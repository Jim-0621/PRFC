File: runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeTests.java
Patch:
@@ -165,9 +165,10 @@ private static String test(RuntimeTestDescriptor descriptor, RuntimeRunner runne
 				descriptor.traceATN,
 				descriptor.showDFA,
 				Stage.Execute,
-				false,
 				targetName,
-				superClass
+				superClass,
+				descriptor.predictionMode,
+				descriptor.buildParseTree
 		);
 
 		State result = runner.run(runOptions);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/GoRunner.java
Patch:
@@ -64,7 +64,7 @@ public String[] getExtraRunArgs() {
 		return new String[]{"run"};
 	}
 
-	private static final String GoRuntimeImportPath = "github.com/antlr/antlr4/runtime/Go/antlr/v4";
+	private static final String GoRuntimeImportPath = "github.com/antlr4-go/antlr/v4";
 
 	private final static Map<String, String> environment;
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/helpers/RuntimeTestLexer.java
Patch:
@@ -1,3 +1,5 @@
+package org.antlr.v4.test.runtime.java.helpers;
+
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Lexer;
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/helpers/RuntimeTestParser.java
Patch:
@@ -1,3 +1,5 @@
+package org.antlr.v4.test.runtime.java.helpers;
+
 import org.antlr.v4.runtime.Parser;
 import org.antlr.v4.runtime.TokenStream;
 

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -67,7 +67,7 @@ public class RuntimeMetaData {
 	 * omitted.</li>
 	 * </ul>
 	 */
-	public static final String VERSION = "4.12.0";
+	public static final String VERSION = "4.13.0";
 
 	/**
 	 * Gets the currently executing version of the ANTLR 4 runtime library.

File: tool-testsuite/test/org/antlr/v4/test/tool/TestCompositeGrammars.java
Patch:
@@ -727,7 +727,7 @@ private static boolean compile(String grammarFileName, String grammarStr, String
 	) {
 		RunOptions runOptions = createOptionsForJavaToolTests(grammarFileName, grammarStr, parserName, null,
 				false, false, startRuleName, null,
-				false, false, Stage.Compile, false);
+				false, false, Stage.Compile);
 		try (JavaRunner runner = new JavaRunner(tempDirPath, false)) {
 			JavaCompiledState compiledState = (JavaCompiledState) runner.run(runOptions);
 			return !compiledState.containsErrors();

File: tool-testsuite/test/org/antlr/v4/test/tool/TestParserProfiler.java
Patch:
@@ -223,7 +223,7 @@ public class TestParserProfiler {
 
 		RunOptions runOptions = createOptionsForJavaToolTests("T.g4", grammar, "TParser", "TLexer",
 				false, false, "s", "xyz;abc;z.q",
-				true, false, Stage.Execute, false);
+				true, false, Stage.Execute);
 		try (JavaRunner runner = new JavaRunner()) {
 			ExecutedState state = (ExecutedState) runner.run(runOptions);
 			String expecting =

File: tool-testsuite/test/org/antlr/v4/test/tool/TestPerformance.java
Patch:
@@ -1103,7 +1103,7 @@ protected JavaCompiledState compileJavaParser(boolean leftRecursive) throws IOEx
 
 		RunOptions runOptions = createOptionsForJavaToolTests(grammarFileName, body, parserName, lexerName,
 				false, true, null, null,
-				false, false, Stage.Compile, false);
+				false, false, Stage.Compile);
 		try (RuntimeRunner runner = new JavaRunner()) {
 			return (JavaCompiledState) runner.run(runOptions);
 		}
@@ -1136,7 +1136,7 @@ protected ParserFactory getParserFactory(JavaCompiledState javaCompiledState, St
             final Constructor<? extends Parser> parserCtor = javaCompiledState.parser.getConstructor(TokenStream.class);
 
             // construct initial instances of the lexer and parser to deserialize their ATNs
-			javaCompiledState.initializeLexerAndParser("");
+			javaCompiledState.initializeDummyLexerAndParser();
 
             return new ParserFactory() {
 

File: tool-testsuite/test/org/antlr/v4/test/tool/TestUnicodeEscapes.java
Patch:
@@ -19,7 +19,6 @@ public void latinJavaEscape() {
 
 	@Test
 	public void latinPythonEscape() {
-		checkUnicodeEscape("\\u0061", 0x0061, "Python2");
 		checkUnicodeEscape("\\u0061", 0x0061, "Python3");
 	}
 
@@ -35,7 +34,6 @@ public void bmpJavaEscape() {
 
 	@Test
 	public void bmpPythonEscape() {
-		checkUnicodeEscape("\\uABCD", 0xABCD, "Python2");
 		checkUnicodeEscape("\\uABCD", 0xABCD, "Python3");
 	}
 
@@ -51,7 +49,6 @@ public void smpJavaEscape() {
 
 	@Test
 	public void smpPythonEscape() {
-		checkUnicodeEscape("\\U0001F4A9", 0x1F4A9, "Python2");
 		checkUnicodeEscape("\\U0001F4A9", 0x1F4A9, "Python3");
 	}
 

File: tool-testsuite/test/org/antlr/v4/test/tool/TestXPath.java
Patch:
@@ -201,7 +201,7 @@ private Pair<String[], Collection<ParseTree>> compileAndExtract(String grammarFi
 	) throws Exception {
 		RunOptions runOptions = createOptionsForJavaToolTests(grammarFileName, grammar, parserName, lexerName,
 				false, false, startRuleName, input,
-				false, false, Stage.Execute, true);
+				false, false, Stage.Execute);
 		try (JavaRunner runner = new JavaRunner()) {
 			JavaExecutedState executedState = (JavaExecutedState)runner.run(runOptions);
 			JavaCompiledState compiledState = (JavaCompiledState)executedState.previousState;

File: tool/src/org/antlr/v4/codegen/UnicodeEscapes.java
Patch:
@@ -20,7 +20,6 @@ public static String escapeCodePoint(int codePoint, String language) {
 	public static void appendEscapedCodePoint(StringBuilder sb, int codePoint, String language) {
 		switch (language) {
 			case "CSharp":
-			case "Python2":
 			case "Python3":
 			case "Cpp":
 			case "Go":

File: tool/src/org/antlr/v4/codegen/model/OutputFile.java
Patch:
@@ -26,7 +26,7 @@ public OutputFile(OutputModelFactory factory, String fileName) {
         super(factory);
         this.fileName = fileName;
         Grammar g = factory.getGrammar();
-		grammarFileName = g.fileName;
+		grammarFileName = g.fileName.replace("\\", "/"); // Prevent a path with windows delim and u breaking Java pre-parser on comments
 		ANTLRVersion = Tool.VERSION;
         TokenLabelType = g.getOptionString("TokenLabelType");
         InputSymbolType = TokenLabelType;

File: tool/src/org/antlr/v4/codegen/model/OutputFile.java
Patch:
@@ -26,7 +26,7 @@ public OutputFile(OutputModelFactory factory, String fileName) {
         super(factory);
         this.fileName = fileName;
         Grammar g = factory.getGrammar();
-		grammarFileName = g.fileName;
+		grammarFileName = g.fileName.replace("\\", "/"); // Prevent a path with windows delim and u breaking Java pre-parser on comments
 		ANTLRVersion = Tool.VERSION;
         TokenLabelType = g.getOptionString("TokenLabelType");
         InputSymbolType = TokenLabelType;

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -112,6 +112,7 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 	public boolean warnings_are_errors = false;
 	public boolean longMessages = false;
 	public boolean exact_output_dir = false;
+	public boolean lock_free_cpp_target = false;
 
     public final static Option[] optionDefs = {
 		new Option("outputDirectory",             "-o", OptionArgType.STRING, "specify output directory where all output is generated"),
@@ -133,6 +134,7 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 		new Option("force_atn",                   "-Xforce-atn", "use the ATN simulator for all predictions"),
 		new Option("log",                         "-Xlog", "dump lots of logging info to antlr-timestamp.log"),
 	    new Option("exact_output_dir",            "-Xexact-output-dir", "all output goes into -o dir regardless of paths/package"),
+	    new Option("lock_free_cpp_target",         "-lock-free-cpp-target", "generate lock-free C++ lexer and/or parser "),
 	};
 
 	// helper vars for option management

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -78,7 +78,7 @@ public Recognizer(OutputModelFactory factory) {
 		else {
 			superClass = null;
 		}
-		lockFreeCppTarget = "ON".equals(g.getOptionString("lockFreeCppTarget"));
+		lockFreeCppTarget = g.tool.lock_free_cpp_target;
 
 		tokenNames = translateTokenStringsToTarget(g.getTokenDisplayNames(), gen);
 		literalNames = translateTokenStringsToTarget(g.getTokenLiteralNames(), gen);

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -45,6 +45,7 @@ public abstract class Recognizer extends OutputModelObject {
 	@ModelElement public SerializedATN atn;
 	@ModelElement public LinkedHashMap<Rule, RuleSempredFunction> sempredFuncs =
 		new LinkedHashMap<Rule, RuleSempredFunction>();
+	@ModelElement public boolean lockFreeCppTarget;
 
 	public Recognizer(OutputModelFactory factory) {
 		super(factory);
@@ -77,6 +78,7 @@ public Recognizer(OutputModelFactory factory) {
 		else {
 			superClass = null;
 		}
+		lockFreeCppTarget = "ON".equals(g.getOptionString("lockFreeCppTarget"));
 
 		tokenNames = translateTokenStringsToTarget(g.getTokenDisplayNames(), gen);
 		literalNames = translateTokenStringsToTarget(g.getTokenLiteralNames(), gen);

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -82,6 +82,7 @@ public class Grammar implements AttributeResolver {
 		parserOptions.add("language");
 		parserOptions.add("accessLevel");
 		parserOptions.add("exportMacro");
+		parserOptions.add("lockFreeCppTarget");
 		parserOptions.add(caseInsensitiveOptionName);
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/GoRunner.java
Patch:
@@ -79,7 +79,7 @@ public String[] getExtraRunArgs() {
 	protected void initRuntime(RunOptions runOptions) throws Exception {
 		String cachePath = getCachePath();
 		mkdir(cachePath);
-		Path runtimeFilesPath = Paths.get(getRuntimePath("Go"), "antlr");
+		Path runtimeFilesPath = Paths.get(getRuntimePath("Go"), "antlr", "v4");
 		String runtimeToolPath = getRuntimeToolPath();
 		File goModFile = new File(cachePath, "go.mod");
 		if (goModFile.exists())

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/GoRunner.java
Patch:
@@ -79,7 +79,7 @@ public String[] getExtraRunArgs() {
 	protected void initRuntime(RunOptions runOptions) throws Exception {
 		String cachePath = getCachePath();
 		mkdir(cachePath);
-		Path runtimeFilesPath = Paths.get(getRuntimePath("Go"), "antlr");
+		Path runtimeFilesPath = Paths.get(getRuntimePath("Go"), "antlr", "v4");
 		String runtimeToolPath = getRuntimeToolPath();
 		File goModFile = new File(cachePath, "go.mod");
 		if (goModFile.exists())

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/NodeRunner.java
Patch:
@@ -36,7 +36,7 @@ public String getLanguage() {
 
 	private final static String normalizedRuntimePath = getRuntimePath("JavaScript").replace('\\', '/');
 	private final static String newImportAntlrString =
-			"import antlr4 from 'file://" + normalizedRuntimePath + "/src/antlr4/index.js'";
+			"import antlr4 from 'file://" + normalizedRuntimePath + "/src/antlr4/index.node.js'";
 
 	@Override
 	protected CompiledState compile(RunOptions runOptions, GeneratedState generatedState) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/CustomDescriptors.java
Patch:
@@ -148,7 +148,7 @@ private static RuntimeTestDescriptor getAtnStatesSizeMoreThan65535Descriptor() {
 				grammarName,
 				grammar.toString(),
 				null, false, false, false,
-				new String[] {"CSharp", "Python2", "Python3", "Go", "PHP", "Swift", "JavaScript", "Dart"}, uri);
+				new String[] {"CSharp", "Python2", "Python3", "Go", "PHP", "Swift", "JavaScript", "TypeScript", "Dart"}, uri);
 	}
 
 	private static RuntimeTestDescriptor getMultiTokenAlternativeDescriptor() {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/JavaScriptRuntimeTests.java
Patch:
@@ -8,7 +8,6 @@
 
 import org.antlr.v4.test.runtime.RuntimeRunner;
 import org.antlr.v4.test.runtime.RuntimeTests;
-import org.antlr.v4.test.runtime.node.NodeRunner;
 
 public class JavaScriptRuntimeTests extends RuntimeTests {
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/NodeRunner.java
Patch:
@@ -3,7 +3,7 @@
  * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
-package org.antlr.v4.test.runtime.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.*;
 import org.antlr.v4.test.runtime.states.CompiledState;
@@ -52,7 +52,7 @@ protected CompiledState compile(RunOptions runOptions, GeneratedState generatedS
 		}
 
 		writeFile(getTempDirPath(), "package.json",
-				RuntimeTestUtils.getTextFromResource("org/antlr/v4/test/runtime/helpers/package.json"));
+				RuntimeTestUtils.getTextFromResource("org/antlr/v4/test/runtime/helpers/package_js.json"));
 		return new CompiledState(generatedState, null);
 	}
 

File: tool/src/org/antlr/v4/codegen/UnicodeEscapes.java
Patch:
@@ -33,6 +33,7 @@ public static void appendEscapedCodePoint(StringBuilder sb, int codePoint, Strin
 				break;
 			case "Java":
 			case "JavaScript":
+			case "TypeScript":
 			case "Dart":
 			default:
 				if (Character.isSupplementaryCodePoint(codePoint)) {

File: tool/src/org/antlr/v4/codegen/model/decl/StructDecl.java
Patch:
@@ -76,9 +76,9 @@ public void addDecl(Decl d) {
 		if ( d instanceof ContextGetterDecl ) {
 			getters.add(d);
 			signatures.add(((ContextGetterDecl) d).getSignatureDecl());
+		} else {
+			attrs.add(d);
 		}
-		else attrs.add(d);
-
 		// add to specific "lists"
 		if ( d instanceof TokenTypeDecl ) {
 			tokenTypeDecls.add(d);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/Processor.java
Patch:
@@ -61,7 +61,7 @@ public ProcessorResult start() throws InterruptedException, IOException {
 		String output = stdoutReader.toString();
 		String errors = stderrReader.toString();
 		if (throwOnNonZeroErrorCode && process.exitValue() != 0) {
-			throw new InterruptedException(joinLines(output, errors));
+			throw new InterruptedException("Exit code "+process.exitValue()+" with output:\n"+joinLines(output, errors));
 		}
 		return new ProcessorResult(process.exitValue(), output, errors);
 	}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/RunOptions.java
Patch:
@@ -18,6 +18,7 @@ public class RunOptions {
 	public final String input;
 	public final boolean profile;
 	public final boolean showDiagnosticErrors;
+	public final boolean traceATN;
 	public final boolean showDFA;
 	public final Stage endStage;
 	public final boolean returnObject;
@@ -26,7 +27,7 @@ public class RunOptions {
 	public RunOptions(String grammarFileName, String grammarStr, String parserName, String lexerName,
 					  boolean useListener, boolean useVisitor, String startRuleName,
 					  String input, boolean profile, boolean showDiagnosticErrors,
-					  boolean showDFA, Stage endStage, boolean returnObject,
+					  boolean traceATN, boolean showDFA, Stage endStage, boolean returnObject,
 					  String language, String superClass) {
 		this.grammarFileName = grammarFileName;
 		this.grammarStr = grammarStr;
@@ -61,6 +62,7 @@ else if (lexerName != null) {
 		this.input = input;
 		this.profile = profile;
 		this.showDiagnosticErrors = showDiagnosticErrors;
+		this.traceATN = traceATN;
 		this.showDFA = showDFA;
 		this.endStage = endStage;
 		this.returnObject = returnObject;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeTestUtils.java
Patch:
@@ -39,17 +39,17 @@ public abstract class RuntimeTestUtils {
 		if (isWindows()) {
 			locationPath = locationPath.replaceFirst("/", "");
 		}
-		Path potentialRuntimeTestsuitePath = Paths.get(locationPath, "..", "..").normalize();
+		Path potentialRuntimeTestsuitePath = Paths.get(locationPath, "..", "..").normalize().toAbsolutePath();
 		Path potentialResourcePath = Paths.get(potentialRuntimeTestsuitePath.toString(), "resources");
 
 		if (Files.exists(potentialResourcePath)) {
 			runtimeTestsuitePath = potentialRuntimeTestsuitePath;
 		}
 		else {
-			runtimeTestsuitePath = Paths.get("..", "runtime-testsuite").normalize();
+			runtimeTestsuitePath = Paths.get("..", "runtime-testsuite").normalize().toAbsolutePath();
 		}
 
-		runtimePath = Paths.get(runtimeTestsuitePath.toString(), "..", "runtime").normalize();
+		runtimePath = Paths.get(runtimeTestsuitePath.toString(), "..", "runtime").normalize().toAbsolutePath();
 		resourcePath = Paths.get(runtimeTestsuitePath.toString(), "resources");
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeTests.java
Patch:
@@ -162,6 +162,7 @@ private static String test(RuntimeTestDescriptor descriptor, RuntimeRunner runne
 				descriptor.input,
 				false,
 				descriptor.showDiagnosticErrors,
+				descriptor.traceATN,
 				descriptor.showDFA,
 				Stage.Execute,
 				false,
@@ -209,7 +210,7 @@ private static String prepareGrammars(RuntimeTestDescriptor descriptor, RuntimeR
 		return grammarST.render();
 	}
 
-	private static String assertCorrectOutput(RuntimeTestDescriptor descriptor, String targetName, State state) {
+	public static String assertCorrectOutput(RuntimeTestDescriptor descriptor, String targetName, State state) {
 		ExecutedState executedState;
 		if (state instanceof ExecutedState) {
 			executedState = (ExecutedState)state;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/CSharpRunner.java
Patch:
@@ -44,7 +44,7 @@ public class CSharpRunner extends RuntimeRunner {
 	}
 
 	@Override
-	protected void initRuntime() throws Exception {
+	protected void initRuntime(RunOptions runOptions) throws Exception {
 		String cachePath = getCachePath();
 		mkdir(cachePath);
 		String projectPath = Paths.get(getRuntimePath(), "src", "Antlr4.csproj").toString();

File: runtime-testsuite/test/org/antlr/v4/test/runtime/dart/DartRunner.java
Patch:
@@ -25,7 +25,7 @@ public String getLanguage() {
 	private static String cacheDartPackageConfig;
 
 	@Override
-	protected void initRuntime() throws Exception {
+	protected void initRuntime(RunOptions runOptions) throws Exception {
 		String cachePath = getCachePath();
 		mkdir(cachePath);
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/GoRunner.java
Patch:
@@ -76,7 +76,7 @@ public String[] getExtraRunArgs() {
 	}
 
 	@Override
-	protected void initRuntime() throws Exception {
+	protected void initRuntime(RunOptions runOptions) throws Exception {
 		String cachePath = getCachePath();
 		mkdir(cachePath);
 		Path runtimeFilesPath = Paths.get(getRuntimePath("Go"), "antlr");
@@ -138,4 +138,4 @@ protected CompiledState compile(RunOptions runOptions, GeneratedState generatedS
 	public Map<String, String> getExecEnvironment() {
 		return environment;
 	}
-}
\ No newline at end of file
+}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/JavaRunner.java
Patch:
@@ -59,7 +59,7 @@ public JavaRunner() {
 	}
 
 	@Override
-	protected void initRuntime() {
+	protected void initRuntime(RunOptions runOptions) {
 		compiler = ToolProvider.getSystemJavaCompiler();
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/JavaScriptRuntimeTests.java
Patch:
@@ -6,8 +6,9 @@
 
 package org.antlr.v4.test.runtime.javascript;
 
-import org.antlr.v4.test.runtime.RuntimeTests;
 import org.antlr.v4.test.runtime.RuntimeRunner;
+import org.antlr.v4.test.runtime.RuntimeTests;
+import org.antlr.v4.test.runtime.node.NodeRunner;
 
 public class JavaScriptRuntimeTests extends RuntimeTests {
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/node/NodeRunner.java
Patch:
@@ -3,7 +3,7 @@
  * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
-package org.antlr.v4.test.runtime.javascript;
+package org.antlr.v4.test.runtime.node;
 
 import org.antlr.v4.test.runtime.*;
 import org.antlr.v4.test.runtime.states.CompiledState;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/SwiftRunner.java
Patch:
@@ -63,7 +63,7 @@ protected String getCompilerName() {
 	}
 
 	@Override
-	protected void initRuntime() throws Exception {
+	protected void initRuntime(RunOptions runOptions) throws Exception {
 		runCommand(new String[] {getCompilerPath(), "build", "-c", "release"}, swiftRuntimePath, "build Swift runtime");
 	}
 

File: tool-testsuite/test/org/antlr/v4/test/tool/ToolTestUtils.java
Patch:
@@ -89,7 +89,7 @@ public static RunOptions createOptionsForJavaToolTests(
 			Stage endStage, boolean returnObject
 	) {
 		return new RunOptions(grammarFileName, grammarStr, parserName, lexerName, useListener, useVisitor, startRuleName,
-				input, profile, showDiagnosticErrors, false, endStage, returnObject, "Java",
+				input, profile, showDiagnosticErrors, false, false, endStage, returnObject, "Java",
 				JavaRunner.runtimeTestParserName);
 	}
 

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -126,7 +126,7 @@ protected void genFile(Grammar g, ST outputFileST, String fileName)
 	 *  to a token type in the generated code.
 	 */
 	public String getTokenTypeAsTargetLabel(Grammar g, int ttype) {
-		String name = g.getTokenName(ttype);
+	    String name = this.escapeIfNeeded(g.getTokenName(ttype));
 		// If name is not valid, return the token type instead
 		if ( Grammar.INVALID_TOKEN_NAME.equals(name) ) {
 			return String.valueOf(ttype);

File: tool/src/org/antlr/v4/codegen/model/ListenerFile.java
Patch:
@@ -46,7 +46,7 @@ public ListenerFile(OutputModelFactory factory, String fileName) {
 		Grammar g = factory.getGrammar();
 		parserName = g.getRecognizerName();
 		grammarName = g.name;
-		namedActions = buildNamedActions(factory.getGrammar());
+		namedActions = buildNamedActions(factory.getGrammar(), ast -> ast.getScope() == null);
 		for (Rule r : g.rules.values()) {
 			Map<String, List<Pair<Integer,AltAST>>> labels = r.getAltLabels();
 			if ( labels!=null ) {

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -59,7 +59,7 @@ public Recognizer(OutputModelFactory factory) {
 		for (Map.Entry<String, Integer> entry : g.tokenNameToTypeMap.entrySet()) {
 			Integer ttype = entry.getValue();
 			if ( ttype>0 ) {
-				tokens.put(entry.getKey(), ttype);
+			    tokens.put(gen.getTarget().escapeIfNeeded(entry.getKey()), ttype);
 			}
 		}
 

File: tool/src/org/antlr/v4/codegen/model/VisitorFile.java
Patch:
@@ -58,7 +58,8 @@ public VisitorFile(OutputModelFactory factory, String fileName) {
 			}
 		}
 		ActionAST ast = g.namedActions.get("header");
-		if ( ast!=null ) header = new Action(factory, ast);
+		if ( ast!=null && ast.getScope()==null)
+			header = new Action(factory, ast);
 		genPackage = g.tool.genPackage;
 		accessLevel = g.getOptionString("accessLevel");
 		exportMacro = g.getOptionString("exportMacro");

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -39,14 +39,14 @@ public class CppTarget extends Target {
 		"double", "dynamic_cast", "else", "enum", "explicit", "export",
 		"extern", "false", "float", "for", "friend", "goto", "if",
 		"inline", "int", "long", "mutable", "namespace", "new",
-		"noexcept", "not", "not_eq", "nullptr", "operator", "or",
+		"noexcept", "not", "not_eq", "nullptr", "NULL", "operator", "or",
 		"or_eq", "private", "protected", "public", "register",
 		"reinterpret_cast", "requires", "return", "short", "signed",
 		"sizeof", "static", "static_assert", "static_cast", "struct",
 		"switch", "template", "this", "thread_local", "throw", "true",
 		"try", "typedef", "typeid", "typename", "union", "unsigned",
 		"using", "virtual", "void", "volatile", "wchar_t", "while",
-		"xor", "xor_eq",
+		"xor", "xor_eq", 
 
 		"rule", "parserRule"
 	));

File: tool/src/org/antlr/v4/semantics/SymbolCollector.java
Patch:
@@ -63,6 +63,7 @@ public SymbolCollector(Grammar g) {
 
 	@Override
 	public void globalNamedAction(GrammarAST scope, GrammarAST ID, ActionAST action) {
+		action.setScope(scope);
 		namedActions.add((GrammarAST)ID.getParent());
 		action.resolver = g;
 	}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/JavaScriptRuntimeTests.java
Patch:
@@ -6,8 +6,9 @@
 
 package org.antlr.v4.test.runtime.javascript;
 
-import org.antlr.v4.test.runtime.RuntimeTests;
 import org.antlr.v4.test.runtime.RuntimeRunner;
+import org.antlr.v4.test.runtime.RuntimeTests;
+import org.antlr.v4.test.runtime.node.NodeRunner;
 
 public class JavaScriptRuntimeTests extends RuntimeTests {
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/node/NodeRunner.java
Patch:
@@ -3,7 +3,7 @@
  * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
-package org.antlr.v4.test.runtime.javascript;
+package org.antlr.v4.test.runtime.node;
 
 import org.antlr.v4.test.runtime.*;
 import org.antlr.v4.test.runtime.states.CompiledState;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -270,7 +270,7 @@ public class ParserATNSimulator extends ATNSimulator {
 	public static boolean debug = false;
 	public static boolean debug_list_atn_decisions = false;
 	public static boolean dfa_debug = false;
-	public static final boolean retry_debug = false;
+	public static boolean retry_debug = false;
 
 	/** Just in case this optimization is bad, add an ENV variable to turn it off */
 	public static final boolean TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT = Boolean.parseBoolean(getSafeEnv("TURN_OFF_LR_LOOP_ENTRY_BRANCH_OPT"));

File: tool-testsuite/test/org/antlr/v4/test/tool/ToolTestUtils.java
Patch:
@@ -89,7 +89,7 @@ public static RunOptions createOptionsForJavaToolTests(
 			Stage endStage, boolean returnObject
 	) {
 		return new RunOptions(grammarFileName, grammarStr, parserName, lexerName, useListener, useVisitor, startRuleName,
-				input, profile, showDiagnosticErrors, false, endStage, returnObject, "Java",
+				input, profile, showDiagnosticErrors, false, false, endStage, returnObject, "Java",
 				JavaRunner.runtimeTestParserName);
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -267,7 +267,7 @@
  * the input.</p>
  */
 public class ParserATNSimulator extends ATNSimulator {
-	public static final boolean debug = false;
+	public static boolean debug = false;
 	public static boolean debug_list_atn_decisions = false;
 	public static boolean dfa_debug = false;
 	public static final boolean retry_debug = false;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeRunner.java
Patch:
@@ -223,7 +223,7 @@ protected void writeRecognizerFile(RunOptions runOptions) {
 		outputFileST.add("lexerName", runOptions.lexerName);
 		outputFileST.add("parserName", runOptions.parserName);
 		outputFileST.add("parserStartRuleName", grammarParseRuleToRecognizerName(runOptions.startRuleName));
-		outputFileST.add("debug", runOptions.showDiagnosticErrors);
+		outputFileST.add("showDiagnosticErrors", runOptions.showDiagnosticErrors);
 		outputFileST.add("profile", runOptions.profile);
 		outputFileST.add("showDFA", runOptions.showDFA);
 		outputFileST.add("useListener", runOptions.useListener);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -268,8 +268,8 @@
  */
 public class ParserATNSimulator extends ATNSimulator {
 	public static final boolean debug = false;
-	public static final boolean debug_list_atn_decisions = false;
-	public static final boolean dfa_debug = false;
+	public static boolean debug_list_atn_decisions = false;
+	public static boolean dfa_debug = false;
 	public static final boolean retry_debug = false;
 
 	/** Just in case this optimization is bad, add an ENV variable to turn it off */

File: tool/src/org/antlr/v4/codegen/model/decl/ContextGetterDecl.java
Patch:
@@ -24,8 +24,7 @@ public ContextGetterDecl(OutputModelFactory factory, String name, boolean signat
 	 */
 	public String getArgType() { return ""; }; // assume no args
 
-	private boolean signature = false;
-	public boolean getSignature() { return signature; }
+	public final boolean signature;
 	abstract ContextGetterDecl getSignatureDecl();
 
 	@Override

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -126,7 +126,7 @@ protected void genFile(Grammar g, ST outputFileST, String fileName)
 	 *  to a token type in the generated code.
 	 */
 	public String getTokenTypeAsTargetLabel(Grammar g, int ttype) {
-		String name = g.getTokenName(ttype);
+	    String name = this.escapeIfNeeded(g.getTokenName(ttype));
 		// If name is not valid, return the token type instead
 		if ( Grammar.INVALID_TOKEN_NAME.equals(name) ) {
 			return String.valueOf(ttype);

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -59,7 +59,7 @@ public Recognizer(OutputModelFactory factory) {
 		for (Map.Entry<String, Integer> entry : g.tokenNameToTypeMap.entrySet()) {
 			Integer ttype = entry.getValue();
 			if ( ttype>0 ) {
-				tokens.put(entry.getKey(), ttype);
+			    tokens.put(gen.getTarget().escapeIfNeeded(entry.getKey()), ttype);
 			}
 		}
 

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -39,14 +39,14 @@ public class CppTarget extends Target {
 		"double", "dynamic_cast", "else", "enum", "explicit", "export",
 		"extern", "false", "float", "for", "friend", "goto", "if",
 		"inline", "int", "long", "mutable", "namespace", "new",
-		"noexcept", "not", "not_eq", "nullptr", "operator", "or",
+		"noexcept", "not", "not_eq", "nullptr", "NULL", "operator", "or",
 		"or_eq", "private", "protected", "public", "register",
 		"reinterpret_cast", "requires", "return", "short", "signed",
 		"sizeof", "static", "static_assert", "static_cast", "struct",
 		"switch", "template", "this", "thread_local", "throw", "true",
 		"try", "typedef", "typeid", "typename", "union", "unsigned",
 		"using", "virtual", "void", "volatile", "wchar_t", "while",
-		"xor", "xor_eq",
+		"xor", "xor_eq", 
 
 		"rule", "parserRule"
 	));

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -243,6 +243,7 @@ public String getTargetStringLiteralFromANTLRStringLiteral(
 	{
 		StringBuilder sb = new StringBuilder();
 
+		literal = escapeIfNeeded(literal);
 		if ( addQuotes ) sb.append('"');
 
 		for (int i = 1; i < literal.length() -1; ) {

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -126,7 +126,7 @@ protected void genFile(Grammar g, ST outputFileST, String fileName)
 	 *  to a token type in the generated code.
 	 */
 	public String getTokenTypeAsTargetLabel(Grammar g, int ttype) {
-		String name = g.getTokenName(ttype);
+	    String name = this.escapeIfNeeded(g.getTokenName(ttype));
 		// If name is not valid, return the token type instead
 		if ( Grammar.INVALID_TOKEN_NAME.equals(name) ) {
 			return String.valueOf(ttype);
@@ -167,6 +167,7 @@ public String getTargetStringLiteralFromString(String s, boolean quoted) {
 			return null;
 		}
 
+		s = escapeIfNeeded(s);
 		StringBuilder buf = new StringBuilder();
 		if ( quoted ) {
 			buf.append('"');
@@ -242,6 +243,7 @@ public String getTargetStringLiteralFromANTLRStringLiteral(
 	{
 		StringBuilder sb = new StringBuilder();
 
+		literal = escapeIfNeeded(literal);
 		if ( addQuotes ) sb.append('"');
 
 		for (int i = 1; i < literal.length() -1; ) {

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -59,7 +59,7 @@ public Recognizer(OutputModelFactory factory) {
 		for (Map.Entry<String, Integer> entry : g.tokenNameToTypeMap.entrySet()) {
 			Integer ttype = entry.getValue();
 			if ( ttype>0 ) {
-				tokens.put(entry.getKey(), ttype);
+			    tokens.put(gen.getTarget().escapeIfNeeded(entry.getKey()), ttype);
 			}
 		}
 

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -39,14 +39,14 @@ public class CppTarget extends Target {
 		"double", "dynamic_cast", "else", "enum", "explicit", "export",
 		"extern", "false", "float", "for", "friend", "goto", "if",
 		"inline", "int", "long", "mutable", "namespace", "new",
-		"noexcept", "not", "not_eq", "nullptr", "operator", "or",
+		"noexcept", "not", "not_eq", "nullptr", "NULL", "operator", "or",
 		"or_eq", "private", "protected", "public", "register",
 		"reinterpret_cast", "requires", "return", "short", "signed",
 		"sizeof", "static", "static_assert", "static_cast", "struct",
 		"switch", "template", "this", "thread_local", "throw", "true",
 		"try", "typedef", "typeid", "typename", "union", "unsigned",
 		"using", "virtual", "void", "volatile", "wchar_t", "while",
-		"xor", "xor_eq",
+		"xor", "xor_eq", 
 
 		"rule", "parserRule"
 	));

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -243,6 +243,7 @@ public String getTargetStringLiteralFromANTLRStringLiteral(
 	{
 		StringBuilder sb = new StringBuilder();
 
+		literal = escapeIfNeeded(literal);
 		if ( addQuotes ) sb.append('"');
 
 		for (int i = 1; i < literal.length() -1; ) {

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -126,7 +126,7 @@ protected void genFile(Grammar g, ST outputFileST, String fileName)
 	 *  to a token type in the generated code.
 	 */
 	public String getTokenTypeAsTargetLabel(Grammar g, int ttype) {
-		String name = g.getTokenName(ttype);
+	    String name = this.escapeIfNeeded(g.getTokenName(ttype));
 		// If name is not valid, return the token type instead
 		if ( Grammar.INVALID_TOKEN_NAME.equals(name) ) {
 			return String.valueOf(ttype);
@@ -167,6 +167,7 @@ public String getTargetStringLiteralFromString(String s, boolean quoted) {
 			return null;
 		}
 
+		s = escapeIfNeeded(s);
 		StringBuilder buf = new StringBuilder();
 		if ( quoted ) {
 			buf.append('"');
@@ -242,6 +243,7 @@ public String getTargetStringLiteralFromANTLRStringLiteral(
 	{
 		StringBuilder sb = new StringBuilder();
 
+		literal = escapeIfNeeded(literal);
 		if ( addQuotes ) sb.append('"');
 
 		for (int i = 1; i < literal.length() -1; ) {

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -59,7 +59,7 @@ public Recognizer(OutputModelFactory factory) {
 		for (Map.Entry<String, Integer> entry : g.tokenNameToTypeMap.entrySet()) {
 			Integer ttype = entry.getValue();
 			if ( ttype>0 ) {
-				tokens.put(entry.getKey(), ttype);
+			    tokens.put(gen.getTarget().escapeIfNeeded(entry.getKey()), ttype);
 			}
 		}
 

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -39,14 +39,14 @@ public class CppTarget extends Target {
 		"double", "dynamic_cast", "else", "enum", "explicit", "export",
 		"extern", "false", "float", "for", "friend", "goto", "if",
 		"inline", "int", "long", "mutable", "namespace", "new",
-		"noexcept", "not", "not_eq", "nullptr", "operator", "or",
+		"noexcept", "not", "not_eq", "nullptr", "NULL", "operator", "or",
 		"or_eq", "private", "protected", "public", "register",
 		"reinterpret_cast", "requires", "return", "short", "signed",
 		"sizeof", "static", "static_assert", "static_cast", "struct",
 		"switch", "template", "this", "thread_local", "throw", "true",
 		"try", "typedef", "typeid", "typename", "union", "unsigned",
 		"using", "virtual", "void", "volatile", "wchar_t", "while",
-		"xor", "xor_eq",
+		"xor", "xor_eq", 
 
 		"rule", "parserRule"
 	));

File: tool/src/org/antlr/v4/gui/Interpreter.java
Patch:
@@ -19,7 +19,7 @@
 
 /** Interpret a lexer/parser, optionally printing tree string and dumping profile info
  *
- *  $ java org.antlr.v4.runtime.misc.Intrepreter [X.g4|XParser.g4 XLexer.g4] startRuleName inputFileName
+ *  $ java org.antlr.v4.gui.Interpreter [X.g4|XParser.g4 XLexer.g4] startRuleName inputFileName
  *        [-tree]
  *        [-gui]
  *        [-trace]
@@ -62,7 +62,7 @@ public void importTokensFromTokensFile() {
 
 	public Interpreter(String[] args) throws Exception {
 		if ( args.length < 2 ) {
-			System.err.println("java org.antlr.v4.guIntrepreter [X.g4|XParser.g4 XLexer.g4] startRuleName\n" +
+			System.err.println("java org.antlr.v4.gui.Intrepreter [X.g4|XParser.g4 XLexer.g4] startRuleName\n" +
 					"  [-tokens] [-tree] [-gui] [-encoding encodingname]\n" +
 					"  [-trace] [-profile filename.csv] [input-filename(s)]");
 			System.err.println("Omitting input-filename makes rig read from stdin.");

File: tool/src/org/antlr/v4/gui/Interpreter.java
Patch:
@@ -19,7 +19,7 @@
 
 /** Interpret a lexer/parser, optionally printing tree string and dumping profile info
  *
- *  $ java org.antlr.v4.runtime.misc.Intrepreter [X.g4|XParser.g4 XLexer.g4] startRuleName inputFileName
+ *  $ java org.antlr.v4.gui.Interpreter [X.g4|XParser.g4 XLexer.g4] startRuleName inputFileName
  *        [-tree]
  *        [-gui]
  *        [-trace]
@@ -62,7 +62,7 @@ public void importTokensFromTokensFile() {
 
 	public Interpreter(String[] args) throws Exception {
 		if ( args.length < 2 ) {
-			System.err.println("java org.antlr.v4.guIntrepreter [X.g4|XParser.g4 XLexer.g4] startRuleName\n" +
+			System.err.println("java org.antlr.v4.gui.Intrepreter [X.g4|XParser.g4 XLexer.g4] startRuleName\n" +
 					"  [-tokens] [-tree] [-gui] [-encoding encodingname]\n" +
 					"  [-trace] [-profile filename.csv] [input-filename(s)]");
 			System.err.println("Omitting input-filename makes rig read from stdin.");

File: tool/src/org/antlr/v4/codegen/model/LL1Choice.java
Patch:
@@ -13,7 +13,7 @@
 
 public abstract class LL1Choice extends Choice {
 	/** Token names for each alt 0..n-1 */
-	public List<String[]> altLook;
+	public List<TokenInfo[]> altLook;
 	@ModelElement public ThrowNoViableAlt error;
 
 	public LL1Choice(OutputModelFactory factory, GrammarAST blkAST,

File: runtime-testsuite/test/org/antlr/v4/test/runtime/Processor.java
Patch:
@@ -19,8 +19,9 @@ public class Processor {
 	public final Map<String, String> environmentVariables;
 	public final boolean throwOnNonZeroErrorCode;
 
-	public static ProcessorResult run(String[] arguments, String workingDirectory, Map<String, String> environmentVariables
-	) throws InterruptedException, IOException {
+	public static ProcessorResult run(String[] arguments, String workingDirectory, Map<String, String> environmentVariables)
+			throws InterruptedException, IOException
+	{
 		return new Processor(arguments, workingDirectory, environmentVariables, true).start();
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/Processor.java
Patch:
@@ -19,8 +19,9 @@ public class Processor {
 	public final Map<String, String> environmentVariables;
 	public final boolean throwOnNonZeroErrorCode;
 
-	public static ProcessorResult run(String[] arguments, String workingDirectory, Map<String, String> environmentVariables
-	) throws InterruptedException, IOException {
+	public static ProcessorResult run(String[] arguments, String workingDirectory, Map<String, String> environmentVariables)
+			throws InterruptedException, IOException
+	{
 		return new Processor(arguments, workingDirectory, environmentVariables, true).start();
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/states/State.java
Patch:
@@ -23,6 +23,8 @@ public String getErrorMessage() {
 		String result = "State: " + getStage() + "; ";
 		if (exception != null) {
 			result += exception.toString();
+			result += "\nCause:\n";
+			result += exception.getCause().toString();
 		}
 		return result;
 	}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/states/State.java
Patch:
@@ -23,6 +23,8 @@ public String getErrorMessage() {
 		String result = "State: " + getStage() + "; ";
 		if (exception != null) {
 			result += exception.toString();
+			result += "\nCause:\n";
+			result += exception.getCause().toString();
 		}
 		return result;
 	}

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -35,6 +35,7 @@ public class GoTarget extends Target {
 		"true", "false", "iota", "nil",
 		"append", "cap", "close", "complex", "copy", "delete", "imag", "len",
 		"make", "new", "panic", "print", "println", "real", "recover",
+		"string",
 
 		// interface definition of RuleContext from runtime/Go/antlr/rule_context.go
 		"Accept", "GetAltNumber", "GetBaseRuleContext", "GetChild", "GetChildCount",

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -35,6 +35,7 @@ public class GoTarget extends Target {
 		"true", "false", "iota", "nil",
 		"append", "cap", "close", "complex", "copy", "delete", "imag", "len",
 		"make", "new", "panic", "print", "println", "real", "recover",
+		"string",
 
 		// interface definition of RuleContext from runtime/Go/antlr/rule_context.go
 		"Accept", "GetAltNumber", "GetBaseRuleContext", "GetChild", "GetChildCount",

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/api/TestExpectedTokens.java
Patch:
@@ -92,7 +92,7 @@ public void testEpsilonAltSubrule() throws Exception {
 
 		// From the start of 'b' with empty stack, can only see B and EOF
 		int blkStartStateNumber = 9;
-		IntervalSet tokens = atn.getExpectedTokens(blkStartStateNumber, RuleContext.EMPTY);
+		IntervalSet tokens = atn.getExpectedTokens(blkStartStateNumber, ParserRuleContext.EMPTY);
 		assertEquals("{<EOF>, B}", tokens.toString(g.getTokenNames()));
 
 		// Now call from 'a'

File: runtime/Java/src/org/antlr/v4/runtime/ParserRuleContext.java
Patch:
@@ -40,6 +40,8 @@
  *  satisfy the superclass interface.
  */
 public class ParserRuleContext extends RuleContext {
+	public static final ParserRuleContext EMPTY = new ParserRuleContext();
+
 	/** If we are debugging or building a parse tree for a visitor,
 	 *  we need to track all of the tokens and rule invocations associated
 	 *  with this rule's context. This is empty for parsing w/o tree constr.

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -66,8 +66,6 @@
  *  @see ParserRuleContext
  */
 public class RuleContext implements RuleNode {
-	public static final ParserRuleContext EMPTY = new ParserRuleContext();
-
 	/** What context invoked this rule? */
 	public RuleContext parent;
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -137,7 +137,7 @@ public boolean add(
 		DoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)
 	{
 		if ( readonly ) throw new IllegalStateException("This set is readonly");
-		if ( config.semanticContext!=SemanticContext.NONE ) {
+		if ( config.semanticContext != SemanticContext.Empty.Instance ) {
 			hasSemanticContext = true;
 		}
 		if (config.getOuterContextDepth() > 0) {
@@ -199,7 +199,7 @@ public BitSet getAlts() {
 	public List<SemanticContext> getPredicates() {
 		List<SemanticContext> preds = new ArrayList<SemanticContext>();
 		for (ATNConfig c : configs) {
-			if ( c.semanticContext!=SemanticContext.NONE ) {
+			if ( c.semanticContext!=SemanticContext.Empty.Instance ) {
 				preds.add(c.semanticContext);
 			}
 		}

File: runtime/Java/src/org/antlr/v4/runtime/atn/LL1Analyzer.java
Patch:
@@ -45,7 +45,7 @@ public IntervalSet[] getDecisionLookahead(ATNState s) {
 			look[alt] = new IntervalSet();
 			Set<ATNConfig> lookBusy = new HashSet<ATNConfig>();
 			boolean seeThruPreds = false; // fail to get lookahead upon pred
-			_LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,
+			_LOOK(s.transition(alt).target, null, EmptyPredictionContext.Instance,
 				  look[alt], lookBusy, new BitSet(), seeThruPreds, false);
 			// Wipe out lookahead for this alternative if we found nothing
 			// or we had a predicate when we !seeThruPreds
@@ -167,7 +167,7 @@ else if (ctx.isEmpty() && addEOF) {
 				return;
 			}
 
-			if ( ctx != PredictionContext.EMPTY ) {
+			if ( ctx != EmptyPredictionContext.Instance ) {
 				// run thru all possible stack tops in ctx
 				boolean removed = calledRuleStack.get(s.ruleIndex);
 				try {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNConfig.java
Patch:
@@ -21,7 +21,7 @@ public LexerATNConfig(ATNState state,
 						  int alt,
 						  PredictionContext context)
 	{
-		super(state, alt, context, SemanticContext.NONE);
+		super(state, alt, context, SemanticContext.Empty.Instance);
 		this.passedThroughNonGreedyDecision = false;
 		this.lexerActionExecutor = null;
 	}
@@ -31,7 +31,7 @@ public LexerATNConfig(ATNState state,
 						  PredictionContext context,
 						  LexerActionExecutor lexerActionExecutor)
 	{
-		super(state, alt, context, SemanticContext.NONE);
+		super(state, alt, context, SemanticContext.Empty.Instance);
 		this.lexerActionExecutor = lexerActionExecutor;
 		this.passedThroughNonGreedyDecision = false;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -380,7 +380,7 @@ protected ATNState getReachableTarget(Transition trans, int t) {
 	protected ATNConfigSet computeStartState(CharStream input,
 											 ATNState p)
 	{
-		PredictionContext initialContext = PredictionContext.EMPTY;
+		PredictionContext initialContext = EmptyPredictionContext.Instance;
 		ATNConfigSet configs = new OrderedATNConfigSet();
 		for (int i=0; i<p.getNumberOfTransitions(); i++) {
 			ATNState target = p.transition(i).target;
@@ -421,7 +421,7 @@ protected boolean closure(CharStream input, LexerATNConfig config, ATNConfigSet
 					return true;
 				}
 				else {
-					configs.add(new LexerATNConfig(config, config.state, PredictionContext.EMPTY));
+					configs.add(new LexerATNConfig(config, config.state, EmptyPredictionContext.Instance));
 					currentAltReachedAcceptState = true;
 				}
 			}

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContextCache.java
Patch:
@@ -22,7 +22,7 @@ public class PredictionContextCache {
 	 *  Protect shared cache from unsafe thread access.
 	 */
 	public PredictionContext add(PredictionContext ctx) {
-		if ( ctx==PredictionContext.EMPTY ) return PredictionContext.EMPTY;
+		if ( ctx==EmptyPredictionContext.Instance ) return EmptyPredictionContext.Instance;
 		PredictionContext existing = cache.get(ctx);
 		if ( existing!=null ) {
 //			System.out.println(name+" reuses "+existing);

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionMode.java
Patch:
@@ -228,7 +228,7 @@ public static boolean hasSLLConflictTerminatingPrediction(PredictionMode mode, A
 				// dup configs, tossing out semantic predicates
 				ATNConfigSet dup = new ATNConfigSet();
 				for (ATNConfig c : configs) {
-					c = new ATNConfig(c,SemanticContext.NONE);
+					c = new ATNConfig(c,SemanticContext.Empty.Instance);
 					dup.add(c);
 				}
 				configs = dup;

File: runtime/Java/src/org/antlr/v4/runtime/atn/SingletonPredictionContext.java
Patch:
@@ -20,7 +20,7 @@ public class SingletonPredictionContext extends PredictionContext {
 	public static SingletonPredictionContext create(PredictionContext parent, int returnState) {
 		if ( returnState == EMPTY_RETURN_STATE && parent == null ) {
 			// someone can pass in the bits of an array ctx that mean $
-			return EMPTY;
+			return EmptyPredictionContext.Instance;
 		}
 		return new SingletonPredictionContext(parent, returnState);
 	}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/CppRunner.java
Patch:
@@ -55,7 +55,7 @@ public String getLanguage() {
 		else {
 			runtimeBinaryPath = Paths.get(runtimePath, "dist").toString();
 			runtimeLibraryFileName = Paths.get(runtimeBinaryPath,
-					"libantlr4-runtime." + (getOS().equals("mac") ? "dylib" : "so")).toString();
+					"libantlr4-runtime." + (getOS() == OSType.Mac ? "dylib" : "so")).toString();
 			environment.put("LD_PRELOAD", runtimeLibraryFileName);
 		}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/UniversalRuntimeTestDescriptor.java
Patch:
@@ -14,8 +14,8 @@ public class UniversalRuntimeTestDescriptor implements RuntimeTestDescriptor {
 	public String name;
 	public String notes;
 	public String input = "";
-	public String output;
-	public String errors;
+	public String output = "";
+	public String errors = "";
 	public String startRule;
 	public String grammarName;
 	public String grammar;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/dart/TestLexerErrors.java
Patch:
@@ -10,6 +10,7 @@
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {

File: tool-testsuite/test/org/antlr/v4/test/tool/TestATNInterpreter.java
Patch:
@@ -24,7 +24,6 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.antlr.v4.test.runtime.RuntimeTestUtils.getTokenTypesViaATN;
 import static org.junit.Assert.assertEquals;
 
 	// NOTICE: TOKENS IN LEXER, PARSER MUST BE SAME OR TOKEN TYPE MISMATCH

File: tool-testsuite/test/org/antlr/v4/test/tool/TestATNParserPrediction.java
Patch:
@@ -28,7 +28,6 @@
 
 import java.util.Arrays;
 
-import static org.antlr.v4.test.runtime.RuntimeTestUtils.getTokenTypesViaATN;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -299,7 +299,7 @@ private boolean buildRuntime() {
 		}
 		else {
 			try {
-				String[] command = {"cmake", ".", "-DCMAKE_BUILD_TYPE=Debug"};
+				String[] command = {"cmake", ".", "-DCMAKE_BUILD_TYPE=Release"};
 				runCommand(command, runtimePath, "antlr runtime cmake", false);
 			} catch (Exception e) {
 				System.err.println("can't configure antlr cpp runtime cmake file");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/BasePHPTest.java
Patch:
@@ -252,7 +252,7 @@ private String locateTool(String tool) {
 			}
 		}
 
-		throw new RuntimeException("Could not locate " + tool);
+		return "php";
 	}
 
 	protected String locatePhp() {
@@ -266,7 +266,7 @@ protected String locatePhp() {
 		File file = new File(prop);
 
 		if (!file.exists()) {
-			throw new RuntimeException("Missing system property:" + propName);
+			return "php";
 		}
 
 		return file.getAbsolutePath();

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python/BasePythonTest.java
Patch:
@@ -205,7 +205,7 @@ private String locateTool(List<String> tools) {
 				}
 			}
 		}
-		throw new RuntimeException("Could not locate " + tools);
+		return "python";
 	}
 
 	protected String locatePython() {
@@ -215,7 +215,7 @@ protected String locatePython() {
 			prop = locateTool(getPythonExecutables());
 		File file = new File(prop);
 		if(!file.exists())
-			throw new RuntimeException("Missing system property:" + propName);
+			return "python";
 		return file.getAbsolutePath();
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -67,7 +67,7 @@ public class RuntimeMetaData {
 	 * omitted.</li>
 	 * </ul>
 	 */
-	public static final String VERSION = "4.10";
+	public static final String VERSION = "4.10.1";
 
 	/**
 	 * Gets the currently executing version of the ANTLR 4 runtime library.

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -214,7 +214,7 @@ private boolean buildRuntime() {
 		System.out.println("Building ANTLR4 C++ runtime (if necessary) at "+ runtimePath);
 
 		try {
-			String[] command = { "cmake", ".", /*"-DCMAKE_CXX_COMPILER=clang++",*/ "-DCMAKE_BUILD_TYPE=release" };
+			String[] command = { "cmake", ".", "-DCMAKE_BUILD_TYPE=Debug" };
 			if (runCommand(command, runtimePath, "antlr runtime cmake", false) == null) {
 				return false;
 			}
@@ -224,7 +224,7 @@ private boolean buildRuntime() {
 		}
 
 		try {
-			String[] command = { "make", "-j", "8" }; // Assuming a reasonable amount of available CPU cores.
+			String[] command = { "make", "-j", Integer.toString(Runtime.getRuntime().availableProcessors()) };
 			if (runCommand(command, runtimePath, "building antlr runtime", true) == null)
 				return false;
 		}

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -276,7 +276,7 @@ public void execute() throws MojoExecutionException, MojoFailureException {
 		for (List<String> args : argumentSets) {
 			try {
 				// Create an instance of the ANTLR 4 build tool
-				tool = new CustomTool(args.toArray(new String[args.size()]));
+				tool = new CustomTool(args.toArray(new String[0]));
 			} catch (Exception e) {
 				log.error("The attempt to create the ANTLR 4 build tool failed, see exception report for details", e);
 				throw new MojoFailureException("Error creating an instanceof the ANTLR tool.", e);

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -67,7 +67,7 @@ public class RuntimeMetaData {
 	 * omitted.</li>
 	 * </ul>
 	 */
-	public static final String VERSION = "4.9.3";
+	public static final String VERSION = "4.10";
 
 	/**
 	 * Gets the currently executing version of the ANTLR 4 runtime library.

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -366,9 +366,10 @@ public static RuntimeTestDescriptor[] getRuntimeTestDescriptors(String group, St
 		}
 
 		if (group.equals("LexerExec")) {
-			descriptors.add(GeneratedLexerDescriptors.getLineSeparatorLfTest(targetName));
-			descriptors.add(GeneratedLexerDescriptors.getLineSeparatorCrLfTest(targetName));
+			descriptors.add(GeneratedLexerDescriptors.getLineSeparatorLfDescriptor(targetName));
+			descriptors.add(GeneratedLexerDescriptors.getLineSeparatorCrLfDescriptor(targetName));
 			descriptors.add(GeneratedLexerDescriptors.getLargeLexerDescriptor(targetName));
+			descriptors.add(GeneratedLexerDescriptors.getAtnStatesSizeMoreThan65535Descriptor(targetName));
 		}
 
 		return descriptors.toArray(new RuntimeTestDescriptor[0]);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/api/perf/TimeLexerSpeed.java
Patch:
@@ -55,7 +55,7 @@
  *
  *  Sample output on OS X with 4 GHz Intel Core i7 (us == microseconds, 1/1000 of a millisecond):
  *
- Java VM args: -Xms2G -Xmx2G
+ Java VM args: -Xms2G -Xmx8g
  Warming up Java compiler....
  load_legacy_java_ascii_file average time    53us size  58384b over 3500 loads of 29038 symbols from Parser.java
  load_legacy_java_ascii_file average time    27us size  15568b over 3500 loads of  7625 symbols from RuleContext.java

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/BasePHPTest.java
Patch:
@@ -244,7 +244,7 @@ private String locateTool(String tool) {
 			return phpPath;
 		}
 
-		String[] roots = {"/usr/local/bin/", "/opt/local/bin", "/usr/bin/"};
+		String[] roots = {"/usr/local/bin/", "/opt/local/bin", "/opt/homebrew/bin/", "/usr/bin/"};
 
 		for (String root: roots) {
 			if (new File(root + tool).exists()) {

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntegerList.java
Patch:
@@ -276,8 +276,9 @@ private void ensureCapacity(int capacity) {
 		_data = Arrays.copyOf(_data, newLength);
 	}
 
-	/** Convert the list to a UTF-16 encoded char array. If all values are less
-	 *  than the 0xFFFF 16-bit code point limit then this is just a char array
+	/** Convert the int list to a char array where values > 0x7FFFF take 2 bytes. TODO?????
+	 *  If all values are less
+	 *  than the 0x7FFF 16-bit code point limit (1 bit taken to indicatethen this is just a char array
 	 *  of 16-bit char as usual. For values in the supplementary range, encode
 	 * them as two UTF-16 code units.
 	 */

File: tool-testsuite/test/org/antlr/v4/test/tool/TestCharSupport.java
Patch:
@@ -11,8 +11,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
-public class CharSupportTest {
-
+public class TestCharSupport {
 	@Test
 	public void testGetANTLRCharLiteralForChar() {
 		Assert.assertEquals("'<INVALID>'",

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -738,10 +738,10 @@ public static String generateInterpreterData(Grammar g) {
 		}
 		content.append("\n");
 
-		IntegerList serializedATN = ATNSerializer.getSerialized(g.atn, g.getLanguage());
+		IntegerList serializedATN = ATNSerializer.getSerialized(g.atn);
 		// Uncomment if you'd like to write out histogram info on the numbers of
 		// each integer value:
-		// Utils.writeSerializedATNIntegerHistogram(g.name+"-histo.csv", serializedATN);
+		//Utils.writeSerializedATNIntegerHistogram(g.name+"-histo.csv", serializedATN);
 
 		content.append("atn:\n");
 		content.append(serializedATN.toString());

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -337,7 +337,7 @@ protected boolean shouldUseUnicodeEscapeForCodePointInDoubleQuotedString(int cod
 	}
 
 	/** Assume 16-bit char */
-	public String encodeIntAsCharEscape(int v) {
+	public String encodeInt16AsCharEscape(int v) {
 		if (v < Character.MIN_VALUE || v > Character.MAX_VALUE) {
 			throw new IllegalArgumentException(String.format("Cannot encode the specified value: %d", v));
 		}
@@ -505,7 +505,7 @@ public String getBaseVisitorFileName(boolean header) {
 	 * in a single segment (a declaration in target language) of the serialized ATN.
 	 * E.g., in C++, a small segment length results in multiple decls like:
 	 *
-	 *   static const uint16_t serializedATNSegment1[] = {
+	 *   static const int32_t serializedATNSegment1[] = {
 	 *     0x7, 0x12, 0x2, 0x13, 0x7, 0x13, 0x2, 0x14, 0x7, 0x14, 0x2, 0x15, 0x7,
 	 *        0x15, 0x2, 0x16, 0x7, 0x16, 0x2, 0x17, 0x7, 0x17, 0x2, 0x18, 0x7,
 	 *        0x18, 0x2, 0x19, 0x7, 0x19, 0x2, 0x1a, 0x7, 0x1a, 0x2, 0x1b, 0x7,

File: tool/src/org/antlr/v4/codegen/target/PHPTarget.java
Patch:
@@ -96,7 +96,7 @@ public String getTargetStringLiteralFromANTLRStringLiteral(CodeGenerator generat
 
 	@Override
 	public boolean isATNSerializedAsInts() {
-		return false;
+		return true;
 	}
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/BaseSwiftTest.java
Patch:
@@ -396,12 +396,10 @@ private void generateParser(String grammarFileName,
 		List<String> files = new ArrayList<>();
 		if (lexerName != null) {
 			files.add(lexerName + ".swift");
-			files.add(lexerName + "ATN.swift");
 		}
 
 		if (parserName != null) {
 			files.add(parserName + ".swift");
-			files.add(parserName + "ATN.swift");
 			Set<String> optionsSet = new HashSet<>(Arrays.asList(extraOptions));
 			String grammarName = grammarFileName.substring(0, grammarFileName.lastIndexOf('.'));
 			if (!optionsSet.contains("-no-listener")) {

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -392,6 +392,7 @@ private String escapeChar(int v) {
 				return String.format("\\x%X", v);
 			case "Dart":
 			case "PHP":
+			case "Swift":
 				return String.format("\\u{%X}", v);
 		}
 	}

File: tool/src/org/antlr/v4/codegen/target/Python2Target.java
Patch:
@@ -8,7 +8,6 @@
 
 import org.antlr.v4.codegen.CodeGenerator;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.StringRenderer;
 

File: tool/src/org/antlr/v4/codegen/target/SwiftTarget.java
Patch:
@@ -169,7 +169,6 @@ protected STGroup loadTemplates() {
     public String serializeTojson(ATN atn) {
         JsonObjectBuilder builder =  Json.createObjectBuilder();
         builder.add("version", ATNDeserializer.SERIALIZED_VERSION);
-        builder.add("uuid", ATNDeserializer.SERIALIZED_UUID.toString());
 
         // convert grammar type to ATN const to avoid dependence on ANTLRParser
         builder.add("grammarType",atn.grammarType.ordinal());

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTestSupport.java
Patch:
@@ -225,6 +225,7 @@ protected ATN createATN(Grammar g, boolean useSerializer) {
 
 		return atn;
 	}
+
 	protected void semanticProcess(Grammar g) {
 		if ( g.ast!=null && !g.ast.hasErrors ) {
 //			System.out.println(g.ast.toStringTree());

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSerializer.java
Patch:
@@ -44,6 +44,8 @@ public ATNSerializer(ATN atn, List<String> tokenNames) {
 	/** Serialize state descriptors, edge descriptors, and decision&rarr;state map
 	 *  into list of ints:
 	 *
+	 *      SERIALIZED_VERSION
+	 *      UUID (2 longs)
 	 * 		grammar-type, (ANTLRParser.LEXER, ...)
 	 *  	max token type,
 	 *  	num states,

File: tool/src/org/antlr/v4/codegen/model/AddToLabelList.java
Patch:
@@ -11,8 +11,8 @@
 
 /** */
 public class AddToLabelList extends SrcOp {
-	public Decl label;
-	public String listName;
+	public final Decl label;
+	public final String listName;
 
 	public AddToLabelList(OutputModelFactory factory, String listName, Decl label) {
 		super(factory);

File: tool/src/org/antlr/v4/codegen/model/chunk/ArgRef.java
Patch:
@@ -10,7 +10,7 @@
 
 /** */
 public class ArgRef extends LocalRef {
-	public ArgRef(StructDecl ctx, String name) {
-		super(ctx, name);
+	public ArgRef(StructDecl ctx, String name, String escapedName) {
+		super(ctx, name, escapedName);
 	}
 }

File: tool/src/org/antlr/v4/codegen/model/chunk/ListLabelRef.java
Patch:
@@ -9,5 +9,5 @@
 import org.antlr.v4.codegen.model.decl.StructDecl;
 
 public class ListLabelRef extends LabelRef {
-	public ListLabelRef(StructDecl ctx, String name) { super(ctx, name); }
+	public ListLabelRef(StructDecl ctx, String name, String escapedName) { super(ctx, name, escapedName); }
 }

File: tool/src/org/antlr/v4/codegen/model/chunk/SetNonLocalAttr.java
Patch:
@@ -15,10 +15,10 @@ public class SetNonLocalAttr extends SetAttr {
 	public int ruleIndex;
 
 	public SetNonLocalAttr(StructDecl ctx,
-						   String ruleName, String name, int ruleIndex,
+						   String ruleName, String name, String escapedName, int ruleIndex,
 						   List<ActionChunk> rhsChunks)
 	{
-		super(ctx, name, rhsChunks);
+		super(ctx, name, escapedName, rhsChunks);
 		this.ruleName = ruleName;
 		this.ruleIndex = ruleIndex;
 	}

File: tool/src/org/antlr/v4/codegen/model/decl/AltLabelStructDecl.java
Patch:
@@ -21,10 +21,9 @@ public class AltLabelStructDecl extends StructDecl {
 	public AltLabelStructDecl(OutputModelFactory factory, Rule r,
 							  int altNum, String label)
 	{
-		super(factory, r);
+		// override name set in super to the label ctx
+		super(factory, r, factory.getGenerator().getTarget().getAltLabelContextStructName(label));
 		this.altNum = altNum;
-		this.name = // override name set in super to the label ctx
-			factory.getGenerator().getTarget().getAltLabelContextStructName(label);
 		this.parentRule = r.name;
 		derivedFromName = label;
 	}

File: tool/src/org/antlr/v4/codegen/model/decl/ContextGetterDecl.java
Patch:
@@ -37,8 +37,7 @@ public boolean equals(Object obj) {
 		if ( this==obj ) return true;
 		// A() and label A are different
 		if ( !(obj instanceof ContextGetterDecl) ) return false;
-		return
-			name.equals(((Decl) obj).name) &&
+		return name.equals(((Decl) obj).name) &&
 				getArgType().equals(((ContextGetterDecl) obj).getArgType());
 	}
 }

File: tool/src/org/antlr/v4/tool/Rule.java
Patch:
@@ -52,7 +52,7 @@ public class Rule implements AttributeResolver {
 		validLexerCommands.add("more");
 	}
 
-	public String name;
+	public final String name;
 	public List<GrammarAST> modifiers;
 
 	public RuleAST ast;
@@ -61,7 +61,7 @@ public class Rule implements AttributeResolver {
 	public AttributeDict locals;
 
 	/** In which grammar does this rule live? */
-	public Grammar g;
+	public final Grammar g;
 
 	/** If we're in a lexer grammar, we might be in a mode */
 	public final String mode;
@@ -93,7 +93,7 @@ public class Rule implements AttributeResolver {
 
 	public ActionAST finallyAction;
 
-	public int numberOfAlts;
+	public final int numberOfAlts;
 
 	public boolean isStartRule = true; // nobody calls us
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeLexers.java
Patch:
@@ -7,8 +7,10 @@
 package org.antlr.v4.test.runtime.cpp;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
-import org.antlr.v4.test.runtime.RuntimeTestDescriptor;import org.junit.runner.RunWith;
+import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+
 @RunWith(Parameterized.class)
 public class TestCompositeLexers extends BaseRuntimeTest {
 	public TestCompositeLexers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeParsers.java
Patch:
@@ -7,7 +7,8 @@
 package org.antlr.v4.test.runtime.cpp;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
-import org.antlr.v4.test.runtime.RuntimeTestDescriptor;import org.junit.runner.RunWith;
+import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLexerExec.java
Patch:
@@ -7,8 +7,10 @@
 package org.antlr.v4.test.runtime.cpp;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
-import org.antlr.v4.test.runtime.RuntimeTestDescriptor;import org.junit.runner.RunWith;
+import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+
 @RunWith(Parameterized.class)
 public class TestLexerExec extends BaseRuntimeTest {
 	public TestLexerExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestFullContextParsing.java
Patch:
@@ -7,7 +7,8 @@
 package org.antlr.v4.test.runtime.swift;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
-import org.antlr.v4.test.runtime.RuntimeTestDescriptor;import org.junit.runner.RunWith;
+import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerErrors.java
Patch:
@@ -7,8 +7,10 @@
 package org.antlr.v4.test.runtime.swift;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
-import org.antlr.v4.test.runtime.RuntimeTestDescriptor;import org.junit.runner.RunWith;
+import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerExec.java
Patch:
@@ -7,7 +7,8 @@
 package org.antlr.v4.test.runtime.swift;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
-import org.antlr.v4.test.runtime.RuntimeTestDescriptor;import org.junit.runner.RunWith;
+import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -55,7 +55,7 @@
 	name = "antlr4",
 	defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 	requiresDependencyResolution = ResolutionScope.COMPILE,
-	requiresProject = true)
+	requiresProject = true, threadSafe = true)
 public class Antlr4Mojo extends AbstractMojo {
 
     // First, let's deal with the options that the ANTLR tool itself

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -177,7 +177,6 @@ void assignLexerTokenTypes(Grammar g, List<GrammarAST> tokensDefs) {
 				}
 			}
 		}
-
 	}
 
 	boolean hasTypeOrMoreCommand(Rule r) {

File: tool/src/org/antlr/v4/semantics/SymbolCollector.java
Patch:
@@ -91,7 +91,7 @@ public void discoverRule(RuleAST rule, GrammarAST ID,
 	}
 
 	@Override
-	public void discoverLexerRule(RuleAST rule, GrammarAST ID, List<GrammarAST> modifiers,
+	public void discoverLexerRule(RuleAST rule, GrammarAST ID, List<GrammarAST> modifiers, GrammarAST options,
 								  GrammarAST block)
 	{
 		currentRule = g.getRule(ID.getText());

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -276,7 +276,7 @@ public void integrateImportedGrammars(Grammar rootGrammar) {
 			}
 
 			// COPY MODES
-			// The strategy is to copy all the mode sections rules across to any 
+			// The strategy is to copy all the mode sections rules across to any
 			// mode section in the new grammar with the same name or a new
 			// mode section if no matching mode is resolved. Rules which are
 			// already in the new grammar are ignored for copy. If the mode
@@ -311,7 +311,7 @@ public void integrateImportedGrammars(Grammar rootGrammar) {
 						    destinationAST.addChild(r);
 							addedRules++;
 						    rootRuleNames.add(ruleName);
-					    }                        
+					    }
 					}
 					if (!rootAlreadyHasMode && addedRules > 0) {
 						rootGrammar.ast.addChild(destinationAST);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/BaseJavaTest.java
Patch:
@@ -461,7 +461,7 @@ public void testActions(String templates, String actionName, String action, Stri
             AnalysisPipeline anal = new AnalysisPipeline(g);
             anal.process();
 
-			CodeGenerator gen = new CodeGenerator(g);
+			CodeGenerator gen = CodeGenerator.create(g);
 			ST outputFileST = gen.generateParser(false);
 			String output = outputFileST.render();
 			//System.out.println(output);

File: tool-testsuite/test/org/antlr/v4/misc/UtilsTest.java
Patch:
@@ -1,6 +1,7 @@
 package org.antlr.v4.misc;
 
 import org.antlr.runtime.Token;
+import org.antlr.v4.codegen.CodeGenerator;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.junit.Assert;
 import org.junit.Test;

File: tool-testsuite/test/org/antlr/v4/test/tool/TestCodeGeneration.java
Patch:
@@ -130,7 +130,7 @@ public List<String> getEvalInfoForString(String grammarString, String pattern) t
 			if (g.isLexer()) factory = new LexerATNFactory((LexerGrammar) g);
 			g.atn = factory.createATN();
 
-			CodeGenerator gen = new CodeGenerator(g);
+			CodeGenerator gen = CodeGenerator.create(g);
 			ST outputFileST = gen.generateParser();
 
 //			STViz viz = outputFileST.inspect();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -84,8 +84,7 @@ public void loadPrecRuleTemplates() {
 		}
 
 		// use codegen to get correct language templates; that's it though
-		CodeGenerator gen = new CodeGenerator(tool, null, language);
-		codegenTemplates = gen.getTemplates();
+		codegenTemplates = CodeGenerator.create(tool, null, language).getTemplates();
 	}
 
 	@Override

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -62,7 +62,7 @@ public LeftRecursiveRuleTransformer(GrammarRootAST ast, Collection<Rule> rules,
 	}
 
 	public void translateLeftRecursiveRules() {
-		String language = g.getOptionString("language");
+		String language = g.getLanguage();
 		// translate all recursive rules
 		List<String> leftRecursiveRuleNames = new ArrayList<String>();
 		for (Rule r : rules) {

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -101,9 +101,8 @@ protected static String translateTokenStringToTarget(String tokenName, CodeGener
 		}
 
 		if (tokenName.charAt(0) == '\'') {
-			boolean addQuotes = false;
 			String targetString =
-				gen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, addQuotes);
+				gen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, false, true);
 			return "\"'" + targetString + "'\"";
 		}
 		else {

File: tool/src/org/antlr/v4/codegen/model/SemPred.java
Patch:
@@ -67,6 +67,7 @@ public SemPred(OutputModelFactory factory, ActionAST ast) {
 		else {
 			msg = gen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen,
 																		  failNode.getText(),
+																		  true,
 																		  true);
 		}
 	}

File: tool/src/org/antlr/v4/misc/CharSupport.java
Patch:
@@ -17,11 +17,11 @@ public class CharSupport {
 	/** When converting ANTLR char and string literals, here is the
 	 *  value set of escape chars.
 	 */
-	public static int ANTLRLiteralEscapedCharValue[] = new int[255];
+	public static int[] ANTLRLiteralEscapedCharValue = new int[255];
 
 	/** Given a char, we need to be able to show as an ANTLR literal.
 	 */
-	public static String ANTLRLiteralCharValueEscape[] = new String[255];
+	public static String[] ANTLRLiteralCharValueEscape = new String[255];
 
 	static {
 		ANTLRLiteralEscapedCharValue['n'] = '\n';

File: tool/src/org/antlr/v4/misc/EscapeSequenceParsing.java
Patch:
@@ -139,7 +139,7 @@ else if (escaped == 'p' || escaped == 'P') {
 			}
 			String propertyName = s.substring(openBraceOffset + 1, closeBraceOffset);
 			IntervalSet propertyIntervalSet = UnicodeData.getPropertyCodePoints(propertyName);
-			if (propertyIntervalSet == null) {
+			if (propertyIntervalSet == null || propertyIntervalSet.isNil()) {
 				return invalid(startOff, closeBraceOffset);
 			}
 			offset = closeBraceOffset + 1;

File: tool/src/org/antlr/v4/tool/BuildDependencyGenerator.java
Patch:
@@ -68,8 +68,7 @@ public class BuildDependencyGenerator {
     public BuildDependencyGenerator(Tool tool, Grammar g) {
         this.tool = tool;
 		this.g = g;
-		String language = g.getOptionString("language");
-		generator = new CodeGenerator(tool, g, language);
+		generator = CodeGenerator.create(g);
     }
 
     /** From T.g return a list of File objects that

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/BaseJavaTest.java
Patch:
@@ -461,7 +461,7 @@ public void testActions(String templates, String actionName, String action, Stri
             AnalysisPipeline anal = new AnalysisPipeline(g);
             anal.process();
 
-			CodeGenerator gen = new CodeGenerator(g);
+			CodeGenerator gen = CodeGenerator.createCodeGenerator(g);
 			ST outputFileST = gen.generateParser(false);
 			String output = outputFileST.render();
 			//System.out.println(output);

File: tool-testsuite/test/org/antlr/v4/test/tool/TestCodeGeneration.java
Patch:
@@ -130,7 +130,7 @@ public List<String> getEvalInfoForString(String grammarString, String pattern) t
 			if (g.isLexer()) factory = new LexerATNFactory((LexerGrammar) g);
 			g.atn = factory.createATN();
 
-			CodeGenerator gen = new CodeGenerator(g);
+			CodeGenerator gen = CodeGenerator.createCodeGenerator(g);
 			ST outputFileST = gen.generateParser();
 
 //			STViz viz = outputFileST.inspect();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -12,7 +12,6 @@
 import org.antlr.runtime.RecognitionException;
 import org.antlr.runtime.Token;
 import org.antlr.v4.Tool;
-import org.antlr.v4.codegen.Language;
 import org.antlr.v4.misc.OrderedHashMap;
 import org.antlr.v4.parse.ANTLRLexer;
 import org.antlr.v4.parse.ANTLRParser;
@@ -63,7 +62,7 @@ public LeftRecursiveRuleTransformer(GrammarRootAST ast, Collection<Rule> rules,
 	}
 
 	public void translateLeftRecursiveRules() {
-		Language language = g.getLanguage();
+		String language = g.getLanguage();
 		// translate all recursive rules
 		List<String> leftRecursiveRuleNames = new ArrayList<String>();
 		for (Rule r : rules) {
@@ -94,7 +93,7 @@ public void translateLeftRecursiveRules() {
 	/** Return true if successful */
 	public boolean translateLeftRecursiveRule(GrammarRootAST ast,
 											  LeftRecursiveRule r,
-											  Language language)
+											  String language)
 	{
 		//tool.log("grammar", ruleAST.toStringTree());
 		GrammarAST prevRuleAST = r.ast;

File: tool/src/org/antlr/v4/codegen/target/DartTarget.java
Patch:
@@ -8,7 +8,6 @@
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
@@ -19,6 +18,7 @@
 import java.util.Set;
 
 public class DartTarget extends Target {
+	public final static String key = "Dart";
 
 	/**
 	 * The Java target can cache the code generation templates.
@@ -53,8 +53,8 @@ public DartTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected Language getLanguage() {
-		return Language.Dart;
+	protected String getLanguage() {
+		return key;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -7,7 +7,6 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.tool.Grammar;
@@ -30,6 +29,7 @@
  *
  * */
 public class GoTarget extends Target {
+	public final static String key = "Go";
 
 	private static final String[] goKeywords = {
 			"break", "default", "func", "interface", "select",
@@ -70,8 +70,8 @@ public GoTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected Language getLanguage() {
-		return Language.Go;
+	protected String getLanguage() {
+		return key;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/JavaScriptTarget.java
Patch:
@@ -7,7 +7,6 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
@@ -23,6 +22,7 @@
  * @author Eric Vergnaud
  */
 public class JavaScriptTarget extends Target {
+	public final static String key = "JavaScript";
 
 	/** Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar */
 	protected static final String[] javaScriptKeywords = {
@@ -50,8 +50,8 @@ public JavaScriptTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected Language getLanguage() {
-		return Language.JavaScript;
+	protected String getLanguage() {
+		return key;
 	}
 
     @Override

File: tool/src/org/antlr/v4/codegen/target/JavaTarget.java
Patch:
@@ -8,7 +8,6 @@
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
@@ -20,6 +19,7 @@
 import java.util.Set;
 
 public class JavaTarget extends Target {
+	public final static String key = "Java";
 
 	/**
 	 * The Java target can cache the code generation templates.
@@ -45,8 +45,8 @@ public JavaTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected Language getLanguage() {
-		return Language.Java;
+	protected String getLanguage() {
+		return key;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/tool/BuildDependencyGenerator.java
Patch:
@@ -68,7 +68,7 @@ public class BuildDependencyGenerator {
     public BuildDependencyGenerator(Tool tool, Grammar g) {
         this.tool = tool;
 		this.g = g;
-		generator = new CodeGenerator(tool, g, g.getLanguage());
+		generator = CodeGenerator.createCodeGenerator(g);
     }
 
     /** From T.g return a list of File objects that

File: tool-testsuite/test/org/antlr/v4/misc/UtilsTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.antlr.runtime.Token;
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.codegen.TargetType;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.junit.Assert;
 import org.junit.Test;
@@ -131,7 +131,7 @@ public void testSetSize() {
 
 	@Test
 	public void testTargetTypeCorrespondsToTargetClass() {
-		for (TargetType value : TargetType.values()) {
+		for (Language value : Language.values()) {
 			CodeGenerator codeGenerator = new CodeGenerator(value);
 			Assert.assertNotNull(codeGenerator.getTarget());
 		}

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -75,7 +75,7 @@ public LexerATNFactory(LexerGrammar g) {
 		// use codegen to get correct language templates for lexer commands
 		String caseInsensitiveOption = g.getOptionString("caseInsensitive");
 		caseInsensitive = caseInsensitiveOption != null && caseInsensitiveOption.equals("true");
-		CodeGenerator gen = new CodeGenerator(g.tool, null, g.getTargetType());
+		CodeGenerator gen = new CodeGenerator(g.tool, null, g.getLanguage());
 		codegenTemplates = gen.getTemplates();
 	}
 

File: tool/src/org/antlr/v4/codegen/CodeGenPipeline.java
Patch:
@@ -23,7 +23,7 @@ public CodeGenPipeline(Grammar g) {
 	}
 
 	public void process() {
-		if (g.getTargetType() == null) return;
+		if (g.getLanguage() == null) return;
 
 		CodeGenerator gen = new CodeGenerator(g);
 		IntervalSet idTypes = new IntervalSet();

File: tool/src/org/antlr/v4/codegen/Language.java
Patch:
@@ -1,6 +1,6 @@
 package org.antlr.v4.codegen;
 
-public enum TargetType {
+public enum Language {
 	Java("Java"),
 	CSharp("C#"),
 	Python2("Python2"),
@@ -12,7 +12,7 @@ public enum TargetType {
 	PHP("PHP"),
 	Dart("Dart");
 
-	TargetType(String name) {
+	Language(String name) {
 		this.languageName = name;
 	}
 

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -7,8 +7,8 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.NumberRenderer;
@@ -51,8 +51,8 @@ public CppTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.Cpp;
+	protected Language getLanguage() {
+		return Language.Cpp;
 	}
 
 	public String getVersion() {

File: tool/src/org/antlr/v4/codegen/target/DartTarget.java
Patch:
@@ -8,8 +8,8 @@
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.StringRenderer;
@@ -53,8 +53,8 @@ public DartTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.Dart;
+	protected Language getLanguage() {
+		return Language.Dart;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -7,8 +7,8 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.ast.GrammarAST;
@@ -70,8 +70,8 @@ public GoTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.Go;
+	protected Language getLanguage() {
+		return Language.Go;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/JavaScriptTarget.java
Patch:
@@ -7,8 +7,8 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.StringRenderer;
@@ -50,8 +50,8 @@ public JavaScriptTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.JavaScript;
+	protected Language getLanguage() {
+		return Language.JavaScript;
 	}
 
     @Override

File: tool/src/org/antlr/v4/codegen/target/JavaTarget.java
Patch:
@@ -8,8 +8,8 @@
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.StringRenderer;
@@ -45,8 +45,8 @@ public JavaTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.Java;
+	protected Language getLanguage() {
+		return Language.Java;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/PHPTarget.java
Patch:
@@ -7,8 +7,8 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.StringRenderer;
@@ -52,8 +52,8 @@ public PHPTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.PHP;
+	protected Language getLanguage() {
+		return Language.PHP;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/Python2Target.java
Patch:
@@ -7,8 +7,8 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.StringRenderer;
@@ -59,8 +59,8 @@ public Python2Target(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.Python2;
+	protected Language getLanguage() {
+		return Language.Python2;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/Python3Target.java
Patch:
@@ -7,8 +7,8 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.StringRenderer;
@@ -55,8 +55,8 @@ public Python3Target(CodeGenerator gen) {
 	}
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.Python3;
+	protected Language getLanguage() {
+		return Language.Python3;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/SwiftTarget.java
Patch:
@@ -7,8 +7,8 @@
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
+import org.antlr.v4.codegen.Language;
 import org.antlr.v4.codegen.Target;
-import org.antlr.v4.codegen.TargetType;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNDeserializer;
@@ -87,8 +87,8 @@ public SwiftTarget(CodeGenerator gen) {
     }
 
 	@Override
-	protected TargetType getTargetType() {
-		return TargetType.Swift;
+	protected Language getLanguage() {
+		return Language.Swift;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/tool/BuildDependencyGenerator.java
Patch:
@@ -68,7 +68,7 @@ public class BuildDependencyGenerator {
     public BuildDependencyGenerator(Tool tool, Grammar g) {
         this.tool = tool;
 		this.g = g;
-		generator = new CodeGenerator(tool, g, g.getTargetType());
+		generator = new CodeGenerator(tool, g, g.getLanguage());
     }
 
     /** From T.g return a list of File objects that

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -381,7 +381,7 @@ public void processNonCombinedGrammar(Grammar g, boolean gencode) {
 		sem.process();
 
 		String language = g.getOptionString("language");
-		if ( !CodeGenerator.targetExists(language) ) {
+		if ( !Grammar.targetExists(language) ) {
 			errMgr.toolError(ErrorType.CANNOT_CREATE_TARGET_GENERATOR, language);
 			return;
 		}

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -73,10 +73,9 @@ public class LexerATNFactory extends ParserATNFactory {
 	public LexerATNFactory(LexerGrammar g) {
 		super(g);
 		// use codegen to get correct language templates for lexer commands
-		String language = g.getOptionString("language");
 		String caseInsensitiveOption = g.getOptionString("caseInsensitive");
 		caseInsensitive = caseInsensitiveOption != null && caseInsensitiveOption.equals("true");
-		CodeGenerator gen = new CodeGenerator(g.tool, null, language);
+		CodeGenerator gen = new CodeGenerator(g.tool, null, g.getTargetType());
 		codegenTemplates = gen.getTemplates();
 	}
 

File: tool/src/org/antlr/v4/codegen/CodeGenPipeline.java
Patch:
@@ -23,7 +23,7 @@ public CodeGenPipeline(Grammar g) {
 	}
 
 	public void process() {
-		if ( !CodeGenerator.targetExists(g.getOptionString("language")) ) return;
+		if (g.getTargetType() == null) return;
 
 		CodeGenerator gen = new CodeGenerator(g);
 		IntervalSet idTypes = new IntervalSet();

File: tool/src/org/antlr/v4/tool/BuildDependencyGenerator.java
Patch:
@@ -68,8 +68,7 @@ public class BuildDependencyGenerator {
     public BuildDependencyGenerator(Tool tool, Grammar g) {
         this.tool = tool;
 		this.g = g;
-		String language = g.getOptionString("language");
-		generator = new CodeGenerator(tool, g, language);
+		generator = new CodeGenerator(tool, g, g.getTargetType());
     }
 
     /** From T.g return a list of File objects that

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -147,6 +147,9 @@ protected void checkEpsilonClosure() {
 				ErrorType errorType = pair.a instanceof LeftRecursiveRule ? ErrorType.EPSILON_LR_FOLLOW : ErrorType.EPSILON_CLOSURE;
 				g.tool.errMgr.grammarError(errorType, g.fileName, ((GrammarAST)pair.a.ast.getChild(0)).getToken(), pair.a.name);
 			}
+			if ( lookahead.contains(org.antlr.v4.runtime.Token.EOF)) {
+				g.tool.errMgr.grammarError(ErrorType.EOF_CLOSURE, g.fileName, ((GrammarAST)pair.a.ast.getChild(0)).getToken(), pair.a.name);
+			}
 		}
 	}
 

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -101,9 +101,8 @@ protected static String translateTokenStringToTarget(String tokenName, CodeGener
 		}
 
 		if (tokenName.charAt(0) == '\'') {
-			boolean addQuotes = false;
 			String targetString =
-				gen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, addQuotes);
+				gen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen, tokenName, false, true);
 			return "\"'" + targetString + "'\"";
 		}
 		else {

File: tool/src/org/antlr/v4/codegen/model/SemPred.java
Patch:
@@ -67,6 +67,7 @@ public SemPred(OutputModelFactory factory, ActionAST ast) {
 		else {
 			msg = gen.getTarget().getTargetStringLiteralFromANTLRStringLiteral(gen,
 																		  failNode.getText(),
+																		  true,
 																		  true);
 		}
 	}

File: tool/src/org/antlr/v4/codegen/target/DartTarget.java
Patch:
@@ -53,8 +53,9 @@ public DartTarget(CodeGenerator gen) {
 	}
 
 	@Override
-	public String getTargetStringLiteralFromANTLRStringLiteral(CodeGenerator generator, String literal, boolean addQuotes) {
-		return super.getTargetStringLiteralFromANTLRStringLiteral(generator, literal, addQuotes).replace("$", "\\$");
+	public String getTargetStringLiteralFromANTLRStringLiteral(CodeGenerator generator, String literal, boolean addQuotes,
+															   boolean escapeSpecial) {
+		return super.getTargetStringLiteralFromANTLRStringLiteral(generator, literal, addQuotes, escapeSpecial).replace("$", "\\$");
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/PHPTarget.java
Patch:
@@ -104,10 +104,10 @@ protected void appendUnicodeEscapedCodePoint(int codePoint, StringBuilder sb) {
 	}
 
    @Override
-   public String getTargetStringLiteralFromANTLRStringLiteral(CodeGenerator generator, String literal, boolean addQuotes) {
-	   String targetStringLiteral = super.getTargetStringLiteralFromANTLRStringLiteral(generator, literal, addQuotes);
+   public String getTargetStringLiteralFromANTLRStringLiteral(CodeGenerator generator, String literal, boolean addQuotes,
+															  boolean escapeSpecial) {
+	   String targetStringLiteral = super.getTargetStringLiteralFromANTLRStringLiteral(generator, literal, addQuotes, escapeSpecial);
 	   targetStringLiteral = targetStringLiteral.replace("$", "\\$");
-
 	   return targetStringLiteral;
    }
 }

File: tool/src/org/antlr/v4/misc/CharSupport.java
Patch:
@@ -17,11 +17,11 @@ public class CharSupport {
 	/** When converting ANTLR char and string literals, here is the
 	 *  value set of escape chars.
 	 */
-	public static int ANTLRLiteralEscapedCharValue[] = new int[255];
+	public static int[] ANTLRLiteralEscapedCharValue = new int[255];
 
 	/** Given a char, we need to be able to show as an ANTLR literal.
 	 */
-	public static String ANTLRLiteralCharValueEscape[] = new String[255];
+	public static String[] ANTLRLiteralCharValueEscape = new String[255];
 
 	static {
 		ANTLRLiteralEscapedCharValue['n'] = '\n';

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -793,8 +793,9 @@ public String[] getTokenLiteralNames() {
 		}
 
 		for (Map.Entry<String, Integer> entry : stringLiteralToTypeMap.entrySet()) {
-			if (entry.getValue() >= 0 && entry.getValue() < literalNames.length && literalNames[entry.getValue()] == null) {
-				literalNames[entry.getValue()] = entry.getKey();
+			int value = entry.getValue();
+			if (value >= 0 && value < literalNames.length && literalNames[value] == null) {
+				literalNames[value] = entry.getKey();
 			}
 		}
 

File: tool/src/org/antlr/v4/misc/EscapeSequenceParsing.java
Patch:
@@ -139,7 +139,7 @@ else if (escaped == 'p' || escaped == 'P') {
 			}
 			String propertyName = s.substring(openBraceOffset + 1, closeBraceOffset);
 			IntervalSet propertyIntervalSet = UnicodeData.getPropertyCodePoints(propertyName);
-			if (propertyIntervalSet == null) {
+			if (propertyIntervalSet == null || propertyIntervalSet.isNil()) {
 				return invalid(startOff, closeBraceOffset);
 			}
 			offset = closeBraceOffset + 1;

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -824,7 +824,7 @@ public enum ErrorType {
 	 *
 	 * @since 4.2.1
 	 */
-	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence <arg>", ErrorSeverity.WARNING),
+	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence <arg>", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Warning 157.
 	 *

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -1123,6 +1123,7 @@ public enum ErrorType {
 	 * instead offers automatically generated parse tree listeners and visitors
 	 * as a more maintainable alternative.</p>
 	 */
+	@Deprecated
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR 4", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Warning 201.

File: runtime/Java/src/org/antlr/v4/runtime/atn/CodePointTransitions.java
Patch:
@@ -35,7 +35,8 @@ public static Transition createWithCodePoint(ATNState target, int codePoint) {
 	public static Transition createWithCodePointRange(ATNState target, int codePointFrom, int codePointTo) {
 		if (Character.isSupplementaryCodePoint(codePointFrom) || Character.isSupplementaryCodePoint(codePointTo)) {
 			return new SetTransition(target, IntervalSet.of(codePointFrom, codePointTo));
-		} else {
+		}
+		else {
 			return codePointFrom == codePointTo
 					? new AtomTransition(target, codePointFrom)
 					: new RangeTransition(target, codePointFrom, codePointTo);

File: tool/src/org/antlr/v4/automata/ATNOptimizer.java
Patch:
@@ -108,7 +108,7 @@ private static void optimizeSets(Grammar g, ATN atn) {
 						if (a != -1 && b != -1) {
 							for (int v = a; v <= b; v++) {
 								if (matchSet.contains(v)) {
-									// TODO: Token is missing (i.e. position in source will not be displayed).
+									// TODO: Token is missing (i.e. position in source is not displayed).
 									g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET, g.fileName,
 											null,
 											CharSupport.getANTLRCharLiteralForChar(v),
@@ -124,11 +124,11 @@ private static void optimizeSets(Grammar g, ATN atn) {
 				Transition newTransition;
 				if (matchSet.getIntervals().size() == 1) {
 					if (matchSet.size() == 1) {
-						newTransition = CodePointTransitions.createWithCodePoint(blockEndState, matchSet.getMinElement(), false);
+						newTransition = CodePointTransitions.createWithCodePoint(blockEndState, matchSet.getMinElement());
 					}
 					else {
 						Interval matchInterval = matchSet.getIntervals().get(0);
-						newTransition = CodePointTransitions.createWithCodePointRange(blockEndState, matchInterval.a, matchInterval.b, false);
+						newTransition = CodePointTransitions.createWithCodePointRange(blockEndState, matchInterval.a, matchInterval.b);
 					}
 				}
 				else {

File: runtime/Java/src/org/antlr/v4/runtime/misc/InterpreterDataReader.java
Patch:
@@ -90,6 +90,7 @@ public static InterpreterData parseFile(String fileName) {
 				result.ruleNames.add(line);
 		    }
 		    
+			line = br.readLine();
 			if ( line.equals("channel names:") ) { // Additional lexer data.
 				result.channels = new ArrayList<String>();
 			    while ((line = br.readLine()) != null) {

File: runtime/Java/src/org/antlr/v4/runtime/misc/InterpreterDataReader.java
Patch:
@@ -90,6 +90,7 @@ public static InterpreterData parseFile(String fileName) {
 				result.ruleNames.add(line);
 		    }
 		    
+			line = br.readLine();
 			if ( line.equals("channel names:") ) { // Additional lexer data.
 				result.channels = new ArrayList<String>();
 			    while ((line = br.readLine()) != null) {

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRFileStream.java
Patch:
@@ -15,6 +15,7 @@
  *
  * @deprecated as of 4.7 Please use {@link CharStreams} interface.
  */
+@Deprecated
 public class ANTLRFileStream extends ANTLRInputStream {
 	protected String fileName;
 

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRInputStream.java
Patch:
@@ -22,6 +22,7 @@
  *
  * @deprecated as of 4.7 Please use {@link CharStreams} interface.
  */
+@Deprecated
 public class ANTLRInputStream implements CharStream {
     public static final int READ_BUFFER_SIZE = 1024;
    	public static final int INITIAL_BUFFER_SIZE = 1024;

File: runtime/Java/src/org/antlr/v4/runtime/CommonToken.java
Patch:
@@ -261,8 +261,7 @@ public String toString() {
 		return toString(null);
 	}
 
-	public String toString(Recognizer r) {
-
+	public String toString(Recognizer<?, ?> r) {
 		String channelStr = "";
 		if ( channel>0 ) {
 			channelStr=",channel="+channel;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializer.java
Patch:
@@ -789,8 +789,7 @@ protected LexerAction lexerActionFactory(LexerActionType type, int data1, int da
 			return new LexerTypeAction(data1);
 
 		default:
-			String message = String.format(Locale.getDefault(), "The specified lexer action type %d is not valid.", type);
-			throw new IllegalArgumentException(message);
+			throw new IllegalArgumentException(String.format(Locale.getDefault(), "The specified lexer action type %s is not valid.", type));
 		}
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/NotNull.java
Patch:
@@ -17,5 +17,6 @@
 @Documented
 @Retention(RetentionPolicy.CLASS)
 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})
+@Deprecated
 public @interface NotNull {
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java
Patch:
@@ -14,6 +14,7 @@
  *  @deprecated
  *  @since 4.5.1
  */
+@Deprecated
 public class TestRig {
 	public static void main(String[] args) {
 		try {

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -185,6 +185,7 @@ public static List<ParseTree> getDescendants(ParseTree t) {
 	}
 
 	/** @deprecated */
+  @Deprecated
 	public static List<ParseTree> descendants(ParseTree t) {
 		return getDescendants(t);
 	}

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -134,7 +134,9 @@ public String encodeIntAsCharEscape(int v) {
 
 	@Override
 	public int getSerializedATNSegmentLimit() {
-		return 2 ^ 31;
+		// 65535 is the class file format byte limit for a UTF-8 encoded string literal
+		// 3 is the maximum number of bytes it takes to encode a value in the range 0-0xFFFF
+		return 65535 / 3;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/misc/MutableInt.java
Patch:
@@ -6,7 +6,7 @@
 
 package org.antlr.v4.misc;
 
-public class MutableInt extends Number implements Comparable<Number> {
+public class MutableInt extends Number implements Comparable<MutableInt> {
 	public int v;
 
 	public MutableInt(int v) { this.v = v; }
@@ -19,7 +19,7 @@ public boolean equals(Object o) {
 
 	@Override public int hashCode() { return v; }
 
-	@Override public int compareTo(Number o) { return v-o.intValue(); }
+	@Override public int compareTo(MutableInt o) { return v-o.intValue(); }
 	@Override public int intValue() { return v; }
 	@Override public long longValue() { return v; }
 	@Override public float floatValue() { return v; }

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -61,7 +61,7 @@ public ST getMessageTemplate(ANTLRMessage msg) {
 		}
 		if (msg.fileName != null) {
 			String displayFileName = msg.fileName;
-			if (format.equals("antlr")) {
+			if (formatName.equals("antlr")) {
 				// Don't show path to file in messages in ANTLR format;
 				// they're too long.
 				File f = new File(msg.fileName);
@@ -206,6 +206,8 @@ public void emit(ErrorType etype, ANTLRMessage msg) {
 				errors++;
 				tool.error(msg);
 				break;
+      default:
+        break;
 		}
 		errorTypes.add(etype);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRFileStream.java
Patch:
@@ -15,6 +15,7 @@
  *
  * @deprecated as of 4.7 Please use {@link CharStreams} interface.
  */
+@Deprecated
 public class ANTLRFileStream extends ANTLRInputStream {
 	protected String fileName;
 

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRInputStream.java
Patch:
@@ -22,6 +22,7 @@
  *
  * @deprecated as of 4.7 Please use {@link CharStreams} interface.
  */
+@Deprecated
 public class ANTLRInputStream implements CharStream {
     public static final int READ_BUFFER_SIZE = 1024;
    	public static final int INITIAL_BUFFER_SIZE = 1024;

File: runtime/Java/src/org/antlr/v4/runtime/CommonToken.java
Patch:
@@ -261,8 +261,7 @@ public String toString() {
 		return toString(null);
 	}
 
-	public String toString(Recognizer r) {
-
+	public String toString(Recognizer<?, ?> r) {
 		String channelStr = "";
 		if ( channel>0 ) {
 			channelStr=",channel="+channel;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializer.java
Patch:
@@ -789,8 +789,7 @@ protected LexerAction lexerActionFactory(LexerActionType type, int data1, int da
 			return new LexerTypeAction(data1);
 
 		default:
-			String message = String.format(Locale.getDefault(), "The specified lexer action type %d is not valid.", type);
-			throw new IllegalArgumentException(message);
+			throw new IllegalArgumentException(String.format(Locale.getDefault(), "The specified lexer action type %s is not valid.", type));
 		}
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/NotNull.java
Patch:
@@ -17,5 +17,6 @@
 @Documented
 @Retention(RetentionPolicy.CLASS)
 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})
+@Deprecated
 public @interface NotNull {
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java
Patch:
@@ -14,6 +14,7 @@
  *  @deprecated
  *  @since 4.5.1
  */
+@Deprecated
 public class TestRig {
 	public static void main(String[] args) {
 		try {

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -185,6 +185,7 @@ public static List<ParseTree> getDescendants(ParseTree t) {
 	}
 
 	/** @deprecated */
+  @Deprecated
 	public static List<ParseTree> descendants(ParseTree t) {
 		return getDescendants(t);
 	}

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -134,7 +134,9 @@ public String encodeIntAsCharEscape(int v) {
 
 	@Override
 	public int getSerializedATNSegmentLimit() {
-		return 2 ^ 31;
+		// 65535 is the class file format byte limit for a UTF-8 encoded string literal
+		// 3 is the maximum number of bytes it takes to encode a value in the range 0-0xFFFF
+		return 65535 / 3;
 	}
 
 	@Override

File: tool/src/org/antlr/v4/misc/MutableInt.java
Patch:
@@ -6,7 +6,7 @@
 
 package org.antlr.v4.misc;
 
-public class MutableInt extends Number implements Comparable<Number> {
+public class MutableInt extends Number implements Comparable<MutableInt> {
 	public int v;
 
 	public MutableInt(int v) { this.v = v; }
@@ -19,7 +19,7 @@ public boolean equals(Object o) {
 
 	@Override public int hashCode() { return v; }
 
-	@Override public int compareTo(Number o) { return v-o.intValue(); }
+	@Override public int compareTo(MutableInt o) { return v-o.intValue(); }
 	@Override public int intValue() { return v; }
 	@Override public long longValue() { return v; }
 	@Override public float floatValue() { return v; }

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -61,7 +61,7 @@ public ST getMessageTemplate(ANTLRMessage msg) {
 		}
 		if (msg.fileName != null) {
 			String displayFileName = msg.fileName;
-			if (format.equals("antlr")) {
+			if (formatName.equals("antlr")) {
 				// Don't show path to file in messages in ANTLR format;
 				// they're too long.
 				File f = new File(msg.fileName);
@@ -206,6 +206,8 @@ public void emit(ErrorType etype, ANTLRMessage msg) {
 				errors++;
 				tool.error(msg);
 				break;
+      default:
+        break;
 		}
 		errorTypes.add(etype);
 	}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -980,7 +980,7 @@ public enum ErrorType {
 	/**
 	 * Compiler Error 174.
 	 *
-	 * <p>empty strings not allowed</p>
+	 * <p>empty strings and sets not allowed</p>
 	 *
 	 * <pre>
 	 * A: '''test''';

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -474,7 +474,7 @@ public IntervalSet getSetFromCharSetLiteral(GrammarAST charSetAST) {
 				}
 				offset = escapeParseResult.parseLength;
 			}
-			else if (c == '-' && !state.inRange && i != 0 && i != n - 1) {
+			else if (c == '-' && !state.inRange && i != 0 && i != n - 1 && state.mode != CharSetParseState.Mode.NONE) {
 				if (state.mode == CharSetParseState.Mode.PREV_PROPERTY) {
 					g.tool.errMgr.grammarError(ErrorType.UNICODE_PROPERTY_NOT_ALLOWED_IN_RANGE,
 							g.fileName, charSetAST.getToken(), charSetAST.getText());

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -980,7 +980,7 @@ public enum ErrorType {
 	/**
 	 * Compiler Error 174.
 	 *
-	 * <p>empty strings not allowed</p>
+	 * <p>empty strings and sets not allowed</p>
 	 *
 	 * <pre>
 	 * A: '''test''';

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -341,7 +341,7 @@ public enum ErrorType {
 	 * <li>implicitly generated grammar <em>grammar</em> has no rules</li>
 	 * </ul>
 	 */
-	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no non-fragment rules", ErrorSeverity.ERROR),
+	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no rules", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 105.
 	 *

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python/BasePythonTest.java
Patch:
@@ -195,7 +195,8 @@ public String execModule(String fileName) {
 	private String locateTool(List<String> tools) {
 		String[] roots = {
 			"/opt/local/bin", "/usr/bin/", "/usr/local/bin/",
-		    "/Users/"+System.getProperty("user.name")+"/anaconda3/bin/"
+			"/Users/"+System.getProperty("user.name")+"/anaconda3/bin/",
+			"/Users/"+System.getProperty("user.name")+"/opt/anaconda3/bin/"
 		};
 		for(String root : roots) {
 			for (String tool : tools) {

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -67,7 +67,7 @@ public class RuntimeMetaData {
 	 * omitted.</li>
 	 * </ul>
 	 */
-	public static final String VERSION = "4.9.1";
+	public static final String VERSION = "4.9.2";
 
 	/**
 	 * Gets the currently executing version of the ANTLR 4 runtime library.

File: tool/src/org/antlr/v4/codegen/target/CSharpTarget.java
Patch:
@@ -28,7 +28,7 @@ public CSharpTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.9.1";
+        return "4.9.2";
     }
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -51,7 +51,7 @@ public CppTarget(CodeGenerator gen) {
 	}
 
 	public String getVersion() {
-		return "4.9.1";
+		return "4.9.2";
 	}
 
     public boolean needsHeader() { return true; }

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -42,7 +42,7 @@ public class GoTarget extends Target {
 	// predeclared identifiers https://golang.org/ref/spec#Predeclared_identifiers
 	private static final String[] goPredeclaredIdentifiers = {
 			"bool", "byte", "complex64", "complex128", "error", "float32", "float64",
-			"int", ",int8", "int16", "int32", "int64", "rune", "string",
+			"int", "int8", "int16", "int32", "int64", "rune", "string",
 			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
 			"true", "false", "iota", "nil",
 			"append", "cap", "close", "complex", "copy", "delete", "imag", "len",
@@ -71,7 +71,7 @@ public GoTarget(CodeGenerator gen) {
 
 	@Override
 	public String getVersion() {
-		return "4.9.1";
+		return "4.9.2";
 	}
 
 	public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/codegen/target/JavaScriptTarget.java
Patch:
@@ -51,7 +51,7 @@ public JavaScriptTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.9.1";
+        return "4.9.2";
     }
 
     public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/codegen/target/PHPTarget.java
Patch:
@@ -54,7 +54,7 @@ public PHPTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.9.1";
+        return "4.9.2";
     }
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/Python2Target.java
Patch:
@@ -95,7 +95,7 @@ public boolean supportsOverloadedMethods() {
 
 	@Override
 	public String getVersion() {
-		return "4.9.1";
+		return "4.9.2";
 	}
 
 	public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/codegen/target/Python3Target.java
Patch:
@@ -97,7 +97,7 @@ public boolean supportsOverloadedMethods() {
 
 	@Override
 	public String getVersion() {
-		return "4.9.1";
+		return "4.9.2";
 	}
 
 	/** Avoid grammar symbols in this set to prevent conflicts in gen'd code. */

File: tool/src/org/antlr/v4/codegen/target/SwiftTarget.java
Patch:
@@ -87,7 +87,7 @@ public SwiftTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.9.1"; // Java and tool versions move in lock step
+        return "4.9.2"; // Java and tool versions move in lock step
     }
 
     public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -341,7 +341,7 @@ public enum ErrorType {
 	 * <li>implicitly generated grammar <em>grammar</em> has no rules</li>
 	 * </ul>
 	 */
-	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no non-fragment rules", ErrorSeverity.ERROR),
+	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no rules", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 105.
 	 *

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -55,7 +55,7 @@
 	name = "antlr4",
 	defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 	requiresDependencyResolution = ResolutionScope.COMPILE,
-	requiresProject = true)
+	requiresProject = true, threadSafe = true)
 public class Antlr4Mojo extends AbstractMojo {
 
     // First, let's deal with the options that the ANTLR tool itself

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -47,7 +47,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 								: "") + "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");
 		outputFileST.add("lexerName", lexerName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 
 	@Override
@@ -105,6 +105,6 @@ protected void writeParserTestFile(String parserName, String lexerName,
 		outputFileST.add("listenerName", listenerName);
 		outputFileST.add("visitorName", visitorName);
 		outputFileST.add("parserStartRuleName", parserStartRuleName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -44,7 +44,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 								: "") + "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");
 		outputFileST.add("lexerName", lexerName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 
 	@Override
@@ -102,6 +102,6 @@ protected void writeParserTestFile(String parserName, String lexerName,
 		outputFileST.add("listenerName", listenerName);
 		outputFileST.add("visitorName", visitorName);
 		outputFileST.add("parserStartRuleName", parserStartRuleName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -341,7 +341,7 @@ public enum ErrorType {
 	 * <li>implicitly generated grammar <em>grammar</em> has no rules</li>
 	 * </ul>
 	 */
-	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no non-fragment rules", ErrorSeverity.ERROR),
+	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no rules", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 105.
 	 *

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -55,7 +55,7 @@
 	name = "antlr4",
 	defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 	requiresDependencyResolution = ResolutionScope.COMPILE,
-	requiresProject = true)
+	requiresProject = true, threadSafe = true)
 public class Antlr4Mojo extends AbstractMojo {
 
     // First, let's deal with the options that the ANTLR tool itself

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node|Swift|CSharp");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift|CSharp|Dart");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserErrorsDescriptors.java
Patch:
@@ -639,7 +639,7 @@ public static class ExtraneousInput extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !"Java".equals(targetName) && !"Swift".equals(targetName);
+			return !"Java".equals(targetName) && !"Swift".equals(targetName) && !"Dart".equals(targetName);
 		}
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -113,7 +113,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp", "Swift").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp", "Swift", "Dart").contains(targetName);
 		}
 	}
 
@@ -199,7 +199,7 @@ public static class DropLoopEntryBranchInLRRule_4 extends DropLoopEntryBranchInL
 		@Override
 		public boolean ignore(String targetName) {
 			// passes, but still too slow in Python and JavaScript
-			return !Arrays.asList("Java", "CSharp", "Cpp", "Swift").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Cpp", "Swift", "Dart").contains(targetName);
 		}
 	}
 

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -42,7 +42,7 @@ public class GoTarget extends Target {
 	// predeclared identifiers https://golang.org/ref/spec#Predeclared_identifiers
 	private static final String[] goPredeclaredIdentifiers = {
 			"bool", "byte", "complex64", "complex128", "error", "float32", "float64",
-			"int", ",int8", "int16", "int32", "int64", "rune", "string",
+			"int", "int8", "int16", "int32", "int64", "rune", "string",
 			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
 			"true", "false", "iota", "nil",
 			"append", "cap", "close", "complex", "copy", "delete", "imag", "len",

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -42,7 +42,7 @@ public class GoTarget extends Target {
 	// predeclared identifiers https://golang.org/ref/spec#Predeclared_identifiers
 	private static final String[] goPredeclaredIdentifiers = {
 			"bool", "byte", "complex64", "complex128", "error", "float32", "float64",
-			"int", ",int8", "int16", "int32", "int64", "rune", "string",
+			"int", "int8", "int16", "int32", "int64", "rune", "string",
 			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
 			"true", "false", "iota", "nil",
 			"append", "cap", "close", "complex", "copy", "delete", "imag", "len",

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -42,7 +42,7 @@ public class GoTarget extends Target {
 	// predeclared identifiers https://golang.org/ref/spec#Predeclared_identifiers
 	private static final String[] goPredeclaredIdentifiers = {
 			"bool", "byte", "complex64", "complex128", "error", "float32", "float64",
-			"int", ",int8", "int16", "int32", "int64", "rune", "string",
+			"int", "int8", "int16", "int32", "int64", "rune", "string",
 			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
 			"true", "false", "iota", "nil",
 			"append", "cap", "close", "complex", "copy", "delete", "imag", "len",

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -62,7 +62,7 @@ public static void startHeartbeatToAvoidTimeout() {
 	}
 
 	private static boolean requiresHeartbeat() {
-		return isTravisCI() || isAppVeyorCI() || (isCircleCI() && isCPP() && isRecursion());
+		return isTravisCI() || isAppVeyorCI() || (isCPP() && isRecursion());
 	}
 
 	@AfterClass

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -42,7 +42,7 @@ public class GoTarget extends Target {
 	// predeclared identifiers https://golang.org/ref/spec#Predeclared_identifiers
 	private static final String[] goPredeclaredIdentifiers = {
 			"bool", "byte", "complex64", "complex128", "error", "float32", "float64",
-			"int", ",int8", "int16", "int32", "int64", "rune", "string",
+			"int", "int8", "int16", "int32", "int64", "rune", "string",
 			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
 			"true", "false", "iota", "nil",
 			"append", "cap", "close", "complex", "copy", "delete", "imag", "len",

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -341,7 +341,7 @@ public enum ErrorType {
 	 * <li>implicitly generated grammar <em>grammar</em> has no rules</li>
 	 * </ul>
 	 */
-	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no non-fragment rules", ErrorSeverity.ERROR),
+	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no rules", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 105.
 	 *

File: runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java
Patch:
@@ -301,7 +301,7 @@ private String locateTool(String tool) {
 
 		final String[] roots = isWindows()
 				? new String[]{"C:\\tools\\dart-sdk\\bin\\"}
-				: new String[]{"/usr/local/bin/", "/opt/local/bin/", "/usr/bin/", "/usr/lib/dart/bin/"};
+				: new String[]{"/usr/local/bin/", "/opt/local/bin/", "/usr/bin/", "/usr/lib/dart/bin/", "/usr/local/opt/dart/libexec"};
 
 		for (String root : roots) {
 			for (String t : tools) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java
Patch:
@@ -437,7 +437,6 @@ protected void writeTestFile(String parserName,
 		outputFileST.add("lexerName", lexerName);
 		outputFileST.add("parserStartRuleName", parserStartRuleName);
 		writeFile(getTempDirPath(), "Test.dart", outputFileST.render());
-		System.out.println(getTempDirPath());
 	}
 
 	protected void writeLexerTestFile(String lexerName, boolean showDFA) {
@@ -456,7 +455,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 				"  for (Object t in tokens.getTokens()!)\n" +
 				"    print(t);\n" +
 				"\n" +
-				(showDFA ? "stdout.write(lex.interpreter.getDFA(Lexer.DEFAULT_MODE).toLexerString());\n" : "") +
+				(showDFA ? "stdout.write(lex.interpreter!.getDFA(Lexer.DEFAULT_MODE).toLexerString());\n" : "") +
 				"}\n"
 		);
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java
Patch:
@@ -437,6 +437,7 @@ protected void writeTestFile(String parserName,
 		outputFileST.add("lexerName", lexerName);
 		outputFileST.add("parserStartRuleName", parserStartRuleName);
 		writeFile(getTempDirPath(), "Test.dart", outputFileST.render());
+		System.out.println(getTempDirPath());
 	}
 
 	protected void writeLexerTestFile(String lexerName, boolean showDFA) {
@@ -452,7 +453,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 				"  <lexerName> lex = <lexerName>(input);\n" +
 				"  CommonTokenStream tokens = CommonTokenStream(lex);\n" +
 				"  tokens.fill();\n" +
-				"  for (Object t in tokens.getTokens())\n" +
+				"  for (Object t in tokens.getTokens()!)\n" +
 				"    print(t);\n" +
 				"\n" +
 				(showDFA ? "stdout.write(lex.interpreter.getDFA(Lexer.DEFAULT_MODE).toLexerString());\n" : "") +

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -395,7 +395,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 				+ "\n"
 				+ "int main(int argc, const char* argv[]) {\n"
 				+ "  ANTLRFileStream input;\n"
-				+ "  input.loadFile(argv[1]);\n"
+				+ "  input.loadFromFile(argv[1]);\n"
 				+ "  <lexerName> lexer(&input);\n"
 				+ "  CommonTokenStream tokens(&lexer);\n"
 				+ "<createParser>"
@@ -438,7 +438,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 				+ "\n"
 				+ "int main(int argc, const char* argv[]) {\n"
 				+ "  ANTLRFileStream input;\n"
-				+ "  input.loadFile(argv[1]);\n"
+				+ "  input.loadFromFile(argv[1]);\n"
 				+ "  <lexerName> lexer(&input);\n"
 				+ "  CommonTokenStream tokens(&lexer);\n"
 				+ "  tokens.fill();\n"

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -55,7 +55,7 @@
 	name = "antlr4",
 	defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 	requiresDependencyResolution = ResolutionScope.COMPILE,
-	requiresProject = true)
+	requiresProject = true, threadSafe = true)
 public class Antlr4Mojo extends AbstractMojo {
 
     // First, let's deal with the options that the ANTLR tool itself

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -55,7 +55,7 @@
 	name = "antlr4",
 	defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 	requiresDependencyResolution = ResolutionScope.COMPILE,
-	requiresProject = true)
+	requiresProject = true, threadSafe = true)
 public class Antlr4Mojo extends AbstractMojo {
 
     // First, let's deal with the options that the ANTLR tool itself

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -87,13 +87,13 @@ private static void startHeartbeat() {
 			public void run() {
 				heartbeat = true;
 				while (heartbeat) {
-					System.out.print('.');
 					try {
 						//noinspection BusyWait
-						Thread.sleep(5000);
+						Thread.sleep(10000);
 					} catch (Exception e) {
 						e.printStackTrace();
 					}
+					System.out.print('.');
 				}
 			}
 		};

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseCSharpTest.java
Patch:
@@ -195,7 +195,7 @@ public boolean buildProject() {
 
 			// find runtime package
 			final ClassLoader loader = Thread.currentThread().getContextClassLoader();
-			final URL runtimeProj = loader.getResource("CSharp/Antlr4.csproj");
+			final URL runtimeProj = loader.getResource("CSharp/src/Antlr4.csproj");
 			if (runtimeProj == null) {
 				throw new RuntimeException("C# runtime project file not found!");
 			}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -47,7 +47,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 								: "") + "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");
 		outputFileST.add("lexerName", lexerName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 
 	@Override
@@ -105,6 +105,6 @@ protected void writeParserTestFile(String parserName, String lexerName,
 		outputFileST.add("listenerName", listenerName);
 		outputFileST.add("visitorName", visitorName);
 		outputFileST.add("parserStartRuleName", parserStartRuleName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -44,7 +44,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 								: "") + "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");
 		outputFileST.add("lexerName", lexerName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 
 	@Override
@@ -102,6 +102,6 @@ protected void writeParserTestFile(String parserName, String lexerName,
 		outputFileST.add("listenerName", listenerName);
 		outputFileST.add("visitorName", visitorName);
 		outputFileST.add("parserStartRuleName", parserStartRuleName);
-		writeFile(tmpdir, "Test.py", outputFileST.render());
+		writeFile(getTempDirPath(), "Test.py", outputFileST.render());
 	}
 }

File: tool-testsuite/test/org/antlr/v4/test/tool/BaseJavaToolTest.java
Patch:
@@ -16,17 +16,18 @@
 import static org.junit.Assert.assertEquals;
 
 public class BaseJavaToolTest extends BaseJavaTest {
+
 	public void testErrors(String[] pairs, boolean printTree) {
         for (int i = 0; i < pairs.length; i+=2) {
             String grammarStr = pairs[i];
             String expect = pairs[i+1];
 
 			String[] lines = grammarStr.split("\n");
 			String fileName = getFilenameFromFirstLineOfGrammar(lines[0]);
-			ErrorQueue equeue = BaseRuntimeTest.antlrOnString(tmpdir, null, fileName, grammarStr, false); // use default language target in case test overrides
+			ErrorQueue equeue = BaseRuntimeTest.antlrOnString(getTempDirPath(), null, fileName, grammarStr, false); // use default language target in case test overrides
 
 			String actual = equeue.toString(true);
-			actual = actual.replace(tmpdir + File.separator, "");
+			actual = actual.replace(getTempDirPath() + File.separator, "");
 //			System.err.println(actual);
 			String msg = grammarStr;
 			msg = msg.replace("\n","\\n");

File: tool-testsuite/test/org/antlr/v4/test/tool/TestATNLexerInterpreter.java
Patch:
@@ -11,6 +11,7 @@
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.misc.Utils;
+import org.antlr.v4.test.runtime.RuntimeTestUtils;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.LexerGrammar;
 import org.junit.Before;
@@ -386,7 +387,7 @@ protected void checkLexerMatches(LexerGrammar lg, String inputString, String exp
 		DOTGenerator dot = new DOTGenerator(lg);
 //		System.out.println(dot.getDOT(startState, true));
 
-		List<String> tokenTypes = getTokenTypes(lg, atn, input);
+		List<String> tokenTypes = RuntimeTestUtils.getTokenTypes(lg, atn, input);
 
 		String result = Utils.join(tokenTypes.iterator(), ", ");
 //		System.out.println(tokenTypes);

File: tool-testsuite/test/org/antlr/v4/test/tool/TestDollarParser.java
Patch:
@@ -28,7 +28,7 @@ public void testSimpleCall() throws Exception {
 		String found = execParser("T.g4", grammar, "TParser", "TLexer",
 		                          null, null, "a", "x", true);
 		assertTrue(found.indexOf(this.getClass().getSimpleName())>=0);
-		assertNull(this.stderrDuringParse);
+		assertNull(getParseErrors());
 	}
 
 }

File: tool-testsuite/test/org/antlr/v4/test/tool/TestParserProfiler.java
Patch:
@@ -223,7 +223,7 @@ public void testSetUp() throws Exception {
 			" {decision=1, contextSensitivities=0, errors=0, ambiguities=0, SLL_lookahead=6, " +
 			"SLL_ATNTransitions=3, SLL_DFATransitions=3, LL_Fallback=0, LL_lookahead=0, LL_ATNTransitions=0}]\n";
 		assertEquals(expecting, found);
-		assertEquals(null, stderrDuringParse);
+		assertEquals(null, getParseErrors());
 	}
 
 	public DecisionInfo[] interpAndGetDecisionInfo(

File: runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeTestSupport.java
Patch:
@@ -39,4 +39,7 @@ String execParser(String grammarFileName,
 	                  String startRuleName,
 	                  String input,
 	                  boolean showDiagnosticErrors);
+
+    void beforeTest(RuntimeTestDescriptor descriptor);
+	void afterTest(RuntimeTestDescriptor descriptor);
 }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -341,7 +341,7 @@ public enum ErrorType {
 	 * <li>implicitly generated grammar <em>grammar</em> has no rules</li>
 	 * </ul>
 	 */
-	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no rules", ErrorSeverity.ERROR),
+	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no non-fragment rules", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 105.
 	 *

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -341,7 +341,7 @@ public enum ErrorType {
 	 * <li>implicitly generated grammar <em>grammar</em> has no rules</li>
 	 * </ul>
 	 */
-	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no rules", ErrorSeverity.ERROR),
+	NO_RULES(99, "<if(arg2.implicitLexerOwner)>implicitly generated <endif>grammar <arg> has no non-fragment rules", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 105.
 	 *

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -119,12 +119,12 @@ protected void succeeded(Description description) {
 	@Test
 	public void testOne() throws Exception {
 		// System.out.println(delegate.getTmpDir());
-		if ( descriptor.ignore(descriptor.getTarget()) ) {
+		if (descriptor.ignore(descriptor.getTarget()) ) {
 			System.out.println("Ignore " + descriptor);
 			return;
 		}
 
-		if ( descriptor.getTestType().contains("Parser") ) {
+		if (descriptor.getTestType().contains("Parser") ) {
 			testParser(descriptor);
 		}
 		else {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python/BasePythonTest.java
Patch:
@@ -5,7 +5,6 @@
  */
 package org.antlr.v4.test.runtime.python;
 
-import com.sun.codemodel.internal.JForEach;
 import org.antlr.v4.Tool;
 import org.antlr.v4.automata.ATNFactory;
 import org.antlr.v4.automata.ATNPrinter;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python/BasePythonTest.java
Patch:
@@ -5,7 +5,6 @@
  */
 package org.antlr.v4.test.runtime.python;
 
-import com.sun.codemodel.internal.JForEach;
 import org.antlr.v4.Tool;
 import org.antlr.v4.automata.ATNFactory;
 import org.antlr.v4.automata.ATNPrinter;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeParsersDescriptors.java
Patch:
@@ -418,7 +418,7 @@ public static class DelegatorRuleOverridesLookaheadInDelegate extends BaseCompos
 		parser grammar S;
 		type_ : 'int' ;
 		decl : type_ ID ';'
-			| type_ ID init_ ';' {<write("\"JavaDecl: \" + $text")>};
+			| type_ ID init_ ';' {<AppendStr("\"JavaDecl: \"","$text"):writeln()>};
 		init_ : '=' INT;
 		 */
 		@CommentHasStringValue
@@ -532,7 +532,7 @@ public static class ImportedRuleWithAction extends BaseCompositeParserTestDescri
 
 		/**
 		parser grammar S;
-		a @after {<InitIntMember("x","0")>} : B;
+		a @after {<InitIntVar("x","0")>} : B;
 		 */
 		@CommentHasStringValue
 		public String slaveGrammarS;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/FullContextParsingDescriptors.java
Patch:
@@ -372,7 +372,7 @@ public static class LoopsSimulateTailRecursion extends BaseDiagnosticParserTestD
 		 	: expr_or_assign*;
 		 expr_or_assign
 		 	: expr '++' {<writeln("\"fail.\"")>}
-		 	|  expr {<writeln("\"pass: \"+$expr.text")>}
+		 	|  expr {<AppendStr("\"pass: \"","$expr.text"):writeln()>}
 		 	;
 		 expr: expr_primary ('\<-' ID)?;
 		 expr_primary

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node|Swift|CSharp");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift|CSharp|Dart");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserErrorsDescriptors.java
Patch:
@@ -639,7 +639,7 @@ public static class ExtraneousInput extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !"Java".equals(targetName) && !"Swift".equals(targetName);
+			return !"Java".equals(targetName) && !"Swift".equals(targetName) && !"Dart".equals(targetName);
 		}
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -113,7 +113,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp", "Swift").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp", "Swift", "Dart").contains(targetName);
 		}
 	}
 
@@ -199,7 +199,7 @@ public static class DropLoopEntryBranchInLRRule_4 extends DropLoopEntryBranchInL
 		@Override
 		public boolean ignore(String targetName) {
 			// passes, but still too slow in Python and JavaScript
-			return !Arrays.asList("Java", "CSharp", "Cpp", "Swift").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Cpp", "Swift", "Dart").contains(targetName);
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SemPredEvalParserDescriptors.java
Patch:
@@ -144,8 +144,8 @@ public static class DependentPredNotInOuterCtxShouldBeIgnored extends BaseParser
 		/**
 		 grammar T;
 		 s : b[2] ';' |  b[2] '.' ; // decision in s drills down to ctx-dependent pred in a;
-		 b[int i] : a[i] ;
-		 a[int i]
+		 b[<IntArg("i")>] : a[<VarRef("i")>] ;
+		 a[<IntArg("i")>]
 		   : {<ValEquals("$i","1")>}? ID {<writeln("\"alt 1\"")>}
 		     | {<ValEquals("$i","2")>}? ID {<writeln("\"alt 2\"")>}
 		     ;
@@ -310,7 +310,7 @@ public static abstract class PredTestedEvenWhenUnAmbig extends BaseParserTestDes
 		 grammar T;
 		 @parser::members {<InitBooleanMember("enumKeyword",True())>}
 		 primary
-		     :   ID {<writeln("\"ID \"+$ID.text")>}
+		     :   ID {<AppendStr("\"ID \"", "$ID.text"):writeln()>}
 		     |   {<GetMember("enumKeyword"):Not()>}? 'enum' {<writeln("\"enum\"")>}
 		     ;
 		 ID : [a-z]+ ;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestCompositeLexers.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestCompositeParsers.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestFullContextParsing.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestLeftRecursion.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestLexerErrors.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestLexerExec.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestListeners.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestParseTrees.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestParserErrors.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestParserExec.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestPerformance.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestSemPredEvalLexer.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestSemPredEvalParser.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/TestSets.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.javascript;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestCompositeLexers.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.safari;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestCompositeLexers extends BaseRuntimeTest {
 	public TestCompositeLexers(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseSafariTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(CompositeLexersDescriptors.class, "Safari");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(CompositeLexersDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestCompositeParsers.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestCompositeParsers extends BaseRuntimeTest {
 	public TestCompositeParsers(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(CompositeParsersDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(CompositeParsersDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestFullContextParsing.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.safari;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestFullContextParsing extends BaseRuntimeTest {
 	public TestFullContextParsing(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseSafariTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(FullContextParsingDescriptors.class, "Safari");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(FullContextParsingDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestLeftRecursion.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.safari;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestLeftRecursion extends BaseRuntimeTest {
 	public TestLeftRecursion(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseSafariTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(LeftRecursionDescriptors.class, "Safari");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(LeftRecursionDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestLexerErrors.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(LexerErrorsDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(LexerErrorsDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestLexerExec.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestLexerExec extends BaseRuntimeTest {
 	public TestLexerExec(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(LexerExecDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(LexerExecDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestListeners.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestListeners extends BaseRuntimeTest {
 	public TestListeners(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(ListenersDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(ListenersDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestParseTrees.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestParseTrees extends BaseRuntimeTest {
 	public TestParseTrees(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(ParseTreesDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(ParseTreesDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestParserErrors.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.safari;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestParserErrors extends BaseRuntimeTest {
 	public TestParserErrors(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseSafariTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(ParserErrorsDescriptors.class, "Safari");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(ParserErrorsDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestParserExec.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestParserExec extends BaseRuntimeTest {
 	public TestParserExec(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(ParserExecDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(ParserExecDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestPerformance.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestPerformance extends BaseRuntimeTest {
 	public TestPerformance(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(PerformanceDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(PerformanceDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestSemPredEvalLexer.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestSemPredEvalLexer extends BaseRuntimeTest {
 	public TestSemPredEvalLexer(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(SemPredEvalLexerDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(SemPredEvalLexerDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestSemPredEvalParser.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestSemPredEvalParser extends BaseRuntimeTest {
 	public TestSemPredEvalParser(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(SemPredEvalParserDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(SemPredEvalParserDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/php/TestSets.java
Patch:
@@ -4,7 +4,7 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.test.runtime.javascript.chrome;
+package org.antlr.v4.test.runtime.php;
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
@@ -15,11 +15,11 @@
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {
-		super(descriptor,new BaseChromeTest());
+		super(descriptor,new BasePHPTest());
 	}
 
 	@Parameterized.Parameters(name="{0}")
 	public static RuntimeTestDescriptor[] getAllTestDescriptors() {
-		return BaseRuntimeTest.getRuntimeTestDescriptors(SetsDescriptors.class, "Chrome");
+		return BaseRuntimeTest.getRuntimeTestDescriptors(SetsDescriptors.class, "PHP");
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -19,8 +19,8 @@ protected String getLanguage() {
 
 	@Override
 	protected String getPythonExecutable() {
-		return "python3.6";
-	} // force 3.6
+		return "python3.7";
+	} // force 3.7
 
 	@Override
 	protected void writeLexerTestFile(String lexerName, boolean showDFA) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/Tree.java
Patch:
@@ -19,7 +19,7 @@ public interface Tree {
 	Tree getParent();
 
 	/**
-	 * This method returns whatever object represents the data at this note. For
+	 * This method returns whatever object represents the data at this node. For
 	 * example, for parse trees, the payload can be a {@link Token} representing
 	 * a leaf node or a {@link RuleContext} object representing a rule
 	 * invocation. For abstract syntax trees (ASTs), this is a {@link Token}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -281,6 +281,8 @@ public static ErrorQueue antlrOnString(String workdir,
 	// ---- support ----
 
 	public static RuntimeTestDescriptor[] getRuntimeTestDescriptors(Class<?> clazz, String targetName) {
+		if(!TestContext.isSupportedTarget(targetName))
+			return new RuntimeTestDescriptor[0];
 		Class<?>[] nestedClasses = clazz.getClasses();
 		List<RuntimeTestDescriptor> descriptors = new ArrayList<RuntimeTestDescriptor>();
 		for (Class<?> nestedClass : nestedClasses) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -101,7 +101,7 @@ public void setUp() throws Exception {
 	}
 
 	public boolean checkIgnored() {
-		boolean ignored = TestContext.isUnsupportedTarget(descriptor.getTarget()) || descriptor.ignore(descriptor.getTarget());
+		boolean ignored = !TestContext.isSupportedTarget(descriptor.getTarget()) || descriptor.ignore(descriptor.getTarget());
 		if(ignored)
 			System.out.println("Ignore " + descriptor);
 		return ignored;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -98,7 +98,7 @@ public void setUp() throws Exception {
 		// "The default JUnit runner treats tests with failing assumptions as ignored"
 		boolean ignored = descriptor.ignore(descriptor.getTarget());
 		if(ignored)
-			System.out.printf("Ignore " + descriptor);
+			System.out.println("Ignore " + descriptor);
 		assumeFalse(ignored);
 		delegate.testSetUp();
 	}
@@ -116,7 +116,7 @@ protected void succeeded(Description description) {
 	public void testOne() throws Exception {
 		// System.out.println(delegate.getTmpDir());
 		if ( descriptor.ignore(descriptor.getTarget()) ) {
-			System.out.printf("Ignore " + descriptor);
+			System.out.println("Ignore " + descriptor);
 			return;
 		}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/BaseNodeTest.java
Patch:
@@ -335,7 +335,7 @@ public String execModule(String fileName) {
 			String nodejsPath = locateNodeJS();
 			String inputPath = new File(new File(tmpdir), "input")
 					.getAbsolutePath();
-			ProcessBuilder builder = new ProcessBuilder(nodejsPath, "--trace-warnings", modulePath,
+			ProcessBuilder builder = new ProcessBuilder(nodejsPath, modulePath,
 					inputPath);
 			builder.environment().put("NODE_PATH", tmpdir);
 			builder.directory(new File(tmpdir));

File: runtime/Java/src/org/antlr/v4/runtime/tree/Tree.java
Patch:
@@ -19,7 +19,7 @@ public interface Tree {
 	Tree getParent();
 
 	/**
-	 * This method returns whatever object represents the data at this note. For
+	 * This method returns whatever object represents the data at this node. For
 	 * example, for parse trees, the payload can be a {@link Token} representing
 	 * a leaf node or a {@link RuleContext} object representing a rule
 	 * invocation. For abstract syntax trees (ASTs), this is a {@link Token}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java
Patch:
@@ -610,8 +610,8 @@ public String execClass(String className, boolean compile) {
 					className + ".dart", new File(tmpdir, "input").getAbsolutePath()
 				};
 			}
-			String cmdLine = Utils.join(args, " ");
-			System.err.println("execParser: " + cmdLine);
+			//String cmdLine = Utils.join(args, " ");
+			//System.err.println("execParser: " + cmdLine);
 			Process process =
 				Runtime.getRuntime().exec(args, null, new File(tmpdir));
 			StreamVacuum stdoutVacuum = new StreamVacuum(process.getInputStream());

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/LexerExecDescriptors.java
Patch:
@@ -1051,7 +1051,7 @@ public Pair<String, String> getGrammar() {
 				grammar = new String(Files.readAllBytes(Paths.get(stuff.toURI())));
 			}
 			catch (Exception e) {
-				System.err.println("Cannot find grammar org/antlr/v4/test/runtime/LarseLexer.g4");
+				System.err.println("Cannot find grammar org/antlr/v4/test/runtime/LargeLexer.g4");
 			}
 
 			return new Pair<>(grammarName, grammar);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/BaseNodeTest.java
Patch:
@@ -627,7 +627,6 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "var <visitorName> = require('./<visitorName>').<visitorName>;\n"
 						+ "\n"
 						+ "function TreeShapeListener() {\n"
-						+ "	antlr4.tree.ParseTreeListener.call(this);\n"
 						+ "	return this;\n"
 						+ "}\n"
 						+ "\n"

File: runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java
Patch:
@@ -126,7 +126,7 @@ public class BaseDartTest implements RuntimeTestSupport {
 	private static String cacheDartPackages;
 
 	private String getPropertyPrefix() {
-		return "antlr-php";
+		return "antlr-dart";
 	}
 
 	@Override
@@ -572,7 +572,7 @@ protected String rawExecRecognizer(String parserName,
 				profile);
 		}
 
-		return execClass("Test", true);
+		return execClass("Test", aotCompile);
 	}
 
 	public String execClass(String className, boolean compile) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -50,6 +50,7 @@ public abstract class BaseRuntimeTest {
 		"Go",
 		"CSharp",
 		"Python2", "Python3",
+		"PHP",
 		"Node", "Safari", "Firefox", "Explorer", "Chrome"
 	};
 	public final static String[] JavaScriptTargets = {
@@ -116,6 +117,7 @@ public void testOne() throws Exception {
 			System.out.printf("Ignore "+descriptor);
 			return;
 		}
+
 		if ( descriptor.getTestType().contains("Parser") ) {
 			testParser(descriptor);
 		}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeParsersDescriptors.java
Patch:
@@ -418,7 +418,7 @@ public static class DelegatorRuleOverridesLookaheadInDelegate extends BaseCompos
 		parser grammar S;
 		type_ : 'int' ;
 		decl : type_ ID ';'
-			| type_ ID init_ ';' {<write("\"JavaDecl: \" + $text")>};
+			| type_ ID init_ ';' {<AppendStr("\"JavaDecl: \"","$text"):writeln()>};
 		init_ : '=' INT;
 		 */
 		@CommentHasStringValue
@@ -532,7 +532,7 @@ public static class ImportedRuleWithAction extends BaseCompositeParserTestDescri
 
 		/**
 		parser grammar S;
-		a @after {<InitIntMember("x","0")>} : B;
+		a @after {<InitIntVar("x","0")>} : B;
 		 */
 		@CommentHasStringValue
 		public String slaveGrammarS;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/FullContextParsingDescriptors.java
Patch:
@@ -372,7 +372,7 @@ public static class LoopsSimulateTailRecursion extends BaseDiagnosticParserTestD
 		 	: expr_or_assign*;
 		 expr_or_assign
 		 	: expr '++' {<writeln("\"fail.\"")>}
-		 	|  expr {<writeln("\"pass: \"+$expr.text")>}
+		 	|  expr {<AppendStr("\"pass: \"","$expr.text"):writeln()>}
 		 	;
 		 expr: expr_primary ('\<-' ID)?;
 		 expr_primary

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SemPredEvalParserDescriptors.java
Patch:
@@ -144,8 +144,8 @@ public static class DependentPredNotInOuterCtxShouldBeIgnored extends BaseParser
 		/**
 		 grammar T;
 		 s : b[2] ';' |  b[2] '.' ; // decision in s drills down to ctx-dependent pred in a;
-		 b[int i] : a[i] ;
-		 a[int i]
+		 b[<IntArg("i")>] : a[<VarRef("i")>] ;
+		 a[<IntArg("i")>]
 		   : {<ValEquals("$i","1")>}? ID {<writeln("\"alt 1\"")>}
 		     | {<ValEquals("$i","2")>}? ID {<writeln("\"alt 2\"")>}
 		     ;
@@ -310,7 +310,7 @@ public static abstract class PredTestedEvenWhenUnAmbig extends BaseParserTestDes
 		 grammar T;
 		 @parser::members {<InitBooleanMember("enumKeyword",True())>}
 		 primary
-		     :   ID {<writeln("\"ID \"+$ID.text")>}
+		     :   ID {<AppendStr("\"ID \"", "$ID.text"):writeln()>}
 		     |   {<GetMember("enumKeyword"):Not()>}? 'enum' {<writeln("\"enum\"")>}
 		     ;
 		 ID : [a-z]+ ;

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -78,8 +78,6 @@ protected void reset() {
 
 	protected final SimState prevAccept = new SimState();
 
-	public static int match_calls = 0;
-
 	public LexerATNSimulator(ATN atn, DFA[] decisionToDFA,
 							 PredictionContextCache sharedContextCache)
 	{
@@ -103,7 +101,6 @@ public void copyState(LexerATNSimulator simulator) {
 	}
 
 	public int match(CharStream input, int mode) {
-		match_calls++;
 		this.mode = mode;
 		int mark = input.mark();
 		try {

File: tool/src/org/antlr/v4/codegen/model/decl/AltLabelStructDecl.java
Patch:
@@ -17,13 +17,15 @@
 /** A StructDecl to handle a -&gt; label on alt */
 public class AltLabelStructDecl extends StructDecl {
 	public int altNum;
+	public String parentRule;
 	public AltLabelStructDecl(OutputModelFactory factory, Rule r,
 							  int altNum, String label)
 	{
 		super(factory, r);
 		this.altNum = altNum;
 		this.name = // override name set in super to the label ctx
 			factory.getGenerator().getTarget().getAltLabelContextStructName(label);
+		this.parentRule = r.name;
 		derivedFromName = label;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -441,17 +441,15 @@ protected List<Token> filterForChannel(int from, int to, int channel) {
 
 	@Override
 	public String getText() {
-		fill();
 		return getText(Interval.of(0,size()-1));
 	}
 
 	@Override
 	public String getText(Interval interval) {
-		lazyInit();
 		int start = interval.a;
 		int stop = interval.b;
 		if ( start<0 || stop<0 ) return "";
-		sync(stop);
+		fill();
         if ( stop>=tokens.size() ) stop = tokens.size()-1;
 
 		StringBuilder buf = new StringBuilder();

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -78,8 +78,6 @@ protected void reset() {
 
 	protected final SimState prevAccept = new SimState();
 
-	public static int match_calls = 0;
-
 	public LexerATNSimulator(ATN atn, DFA[] decisionToDFA,
 							 PredictionContextCache sharedContextCache)
 	{
@@ -103,7 +101,6 @@ public void copyState(LexerATNSimulator simulator) {
 	}
 
 	public int match(CharStream input, int mode) {
-		match_calls++;
 		this.mode = mode;
 		int mark = input.mark();
 		try {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -50,6 +50,7 @@ public abstract class BaseRuntimeTest {
 		"Go",
 		"CSharp",
 		"Python2", "Python3",
+		"PHP",
 		"Node", "Safari", "Firefox", "Explorer", "Chrome"
 	};
 	public final static String[] JavaScriptTargets = {
@@ -116,6 +117,7 @@ public void testOne() throws Exception {
 			System.out.printf("Ignore "+descriptor);
 			return;
 		}
+
 		if ( descriptor.getTestType().contains("Parser") ) {
 			testParser(descriptor);
 		}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeParsersDescriptors.java
Patch:
@@ -418,7 +418,7 @@ public static class DelegatorRuleOverridesLookaheadInDelegate extends BaseCompos
 		parser grammar S;
 		type_ : 'int' ;
 		decl : type_ ID ';'
-			| type_ ID init_ ';' {<write("\"JavaDecl: \" + $text")>};
+			| type_ ID init_ ';' {<AppendStr("\"JavaDecl: \"","$text"):writeln()>};
 		init_ : '=' INT;
 		 */
 		@CommentHasStringValue
@@ -532,7 +532,7 @@ public static class ImportedRuleWithAction extends BaseCompositeParserTestDescri
 
 		/**
 		parser grammar S;
-		a @after {<InitIntMember("x","0")>} : B;
+		a @after {<InitIntVar("x","0")>} : B;
 		 */
 		@CommentHasStringValue
 		public String slaveGrammarS;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/FullContextParsingDescriptors.java
Patch:
@@ -372,7 +372,7 @@ public static class LoopsSimulateTailRecursion extends BaseDiagnosticParserTestD
 		 	: expr_or_assign*;
 		 expr_or_assign
 		 	: expr '++' {<writeln("\"fail.\"")>}
-		 	|  expr {<writeln("\"pass: \"+$expr.text")>}
+		 	|  expr {<AppendStr("\"pass: \"","$expr.text"):writeln()>}
 		 	;
 		 expr: expr_primary ('\<-' ID)?;
 		 expr_primary

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SemPredEvalParserDescriptors.java
Patch:
@@ -144,8 +144,8 @@ public static class DependentPredNotInOuterCtxShouldBeIgnored extends BaseParser
 		/**
 		 grammar T;
 		 s : b[2] ';' |  b[2] '.' ; // decision in s drills down to ctx-dependent pred in a;
-		 b[int i] : a[i] ;
-		 a[int i]
+		 b[<IntArg("i")>] : a[<VarRef("i")>] ;
+		 a[<IntArg("i")>]
 		   : {<ValEquals("$i","1")>}? ID {<writeln("\"alt 1\"")>}
 		     | {<ValEquals("$i","2")>}? ID {<writeln("\"alt 2\"")>}
 		     ;
@@ -310,7 +310,7 @@ public static abstract class PredTestedEvenWhenUnAmbig extends BaseParserTestDes
 		 grammar T;
 		 @parser::members {<InitBooleanMember("enumKeyword",True())>}
 		 primary
-		     :   ID {<writeln("\"ID \"+$ID.text")>}
+		     :   ID {<AppendStr("\"ID \"", "$ID.text"):writeln()>}
 		     |   {<GetMember("enumKeyword"):Not()>}? 'enum' {<writeln("\"enum\"")>}
 		     ;
 		 ID : [a-z]+ ;

File: tool/src/org/antlr/v4/codegen/model/decl/AltLabelStructDecl.java
Patch:
@@ -17,13 +17,15 @@
 /** A StructDecl to handle a -&gt; label on alt */
 public class AltLabelStructDecl extends StructDecl {
 	public int altNum;
+	public String parentRule;
 	public AltLabelStructDecl(OutputModelFactory factory, Rule r,
 							  int altNum, String label)
 	{
 		super(factory, r);
 		this.altNum = altNum;
 		this.name = // override name set in super to the label ctx
 			factory.getGenerator().getTarget().getAltLabelContextStructName(label);
+		this.parentRule = r.name;
 		derivedFromName = label;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -78,7 +78,7 @@ protected void reset() {
 
 	protected final SimState prevAccept = new SimState();
 
-	public static int match_calls = 0;
+	public static volatile int match_calls = 0;
 
 	public LexerATNSimulator(ATN atn, DFA[] decisionToDFA,
 							 PredictionContextCache sharedContextCache)

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseCSharpTest.java
Patch:
@@ -56,7 +56,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-public class BaseCSharpTest implements RuntimeTestSupport /*, SpecialRuntimeTestAssert*/ {
+public class BaseCSharpTest implements RuntimeTestSupport {
 	public static final String newline = System.getProperty("line.separator");
 	public static final String pathSep = System.getProperty("path.separator");
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -113,7 +113,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp", "Swift").contains(targetName);
 		}
 	}
 
@@ -199,7 +199,7 @@ public static class DropLoopEntryBranchInLRRule_4 extends DropLoopEntryBranchInL
 		@Override
 		public boolean ignore(String targetName) {
 			// passes, but still too slow in Python and JavaScript
-			return !Arrays.asList("Java", "CSharp", "Cpp").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Cpp", "Swift").contains(targetName);
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserErrorsDescriptors.java
Patch:
@@ -639,7 +639,7 @@ public static class ExtraneousInput extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !"Java".equals(targetName);
+			return !"Java".equals(targetName) && !"Swift".equals(targetName);
 		}
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SemPredEvalParserDescriptors.java
Patch:
@@ -291,7 +291,7 @@ public static class PredFromAltTestedInLoopBack_1 extends PredFromAltTestedInLoo
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !"Java".equals(targetName);
+			return !"Java".equals(targetName) && !"Swift".equals(targetName);
 		}
 	}
 

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -397,7 +397,7 @@ public void processNonCombinedGrammar(Grammar g, boolean gencode) {
 
 		if ( generate_ATN_dot ) generateATNs(g);
 
-		if ( g.tool.getNumErrors()==0 ) generateInterpreterData(g);
+		if (gencode && g.tool.getNumErrors()==0 ) generateInterpreterData(g);
 
 		// PERFORM GRAMMAR ANALYSIS ON ATN: BUILD DECISION DFAs
 		AnalysisPipeline anal = new AnalysisPipeline(g);
@@ -838,7 +838,7 @@ public File getOutputDirectory(String fileNameWithPath) {
 		// or just or the relative path recorded for the parent grammar. This means
 		// that when we write the tokens files, or the .java files for imported grammars
 		// taht we will write them in the correct place.
-		if (fileNameWithPath.lastIndexOf(File.separatorChar) == -1) {
+		if ((fileNameWithPath == null) || (fileNameWithPath.lastIndexOf(File.separatorChar) == -1)) {
 			// No path is included in the file name, so make the file
 			// directory the same as the parent grammar (which might sitll be just ""
 			// but when it is not, we will write the file in the correct place.

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -26,6 +26,8 @@
 import org.stringtemplate.v4.StringRenderer;
 import org.stringtemplate.v4.misc.STMessage;
 
+import java.net.URL;
+
 /** */
 public abstract class Target {
 	/** For pure strings of Java 16-bit Unicode char, how can we display

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -231,8 +231,7 @@ else if ( url==null ) {
             setFormat("antlr"); // recurse on this rule, trying the default message format
             return;
         }
-
-        format = new STGroupFile(fileName, "UTF-8");
+        format = new STGroupFile(url, "UTF-8", '<', '>');
         format.load();
 
         if ( !initSTListener.errors.isEmpty() ) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContext.java
Patch:
@@ -316,14 +316,14 @@ public static PredictionContext mergeRoot(SingletonPredictionContext a,
 		}
 		else {
 			if ( a == EMPTY && b == EMPTY ) return EMPTY; // $ + $ = $
-			if ( a == EMPTY ) { // $ + x = [$,x]
+			if ( a == EMPTY ) { // $ + x = [x,$]
 				int[] payloads = {b.returnState, EMPTY_RETURN_STATE};
 				PredictionContext[] parents = {b.parent, null};
 				PredictionContext joined =
 					new ArrayPredictionContext(parents, payloads);
 				return joined;
 			}
-			if ( b == EMPTY ) { // x + $ = [$,x] ($ is always first if present)
+			if ( b == EMPTY ) { // x + $ = [x,$] ($ is always last if present)
 				int[] payloads = {a.returnState, EMPTY_RETURN_STATE};
 				PredictionContext[] parents = {a.parent, null};
 				PredictionContext joined =

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -24,6 +24,7 @@ public abstract class Recognizer extends OutputModelObject {
 	public String name;
 	public String grammarName;
 	public String grammarFileName;
+	public String accessLevel;
 	public Map<String,Integer> tokens;
 
 	/**
@@ -51,6 +52,7 @@ public Recognizer(OutputModelFactory factory) {
 		grammarFileName = new File(g.fileName).getName();
 		grammarName = g.name;
 		name = g.getRecognizerName();
+		accessLevel = g.getOptionString("accessLevel");
 		tokens = new LinkedHashMap<String,Integer>();
 		for (Map.Entry<String, Integer> entry : g.tokenNameToTypeMap.entrySet()) {
 			Integer ttype = entry.getValue();

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -81,6 +81,7 @@ public class Grammar implements AttributeResolver {
 		parserOptions.add("TokenLabelType");
 		parserOptions.add("tokenVocab");
 		parserOptions.add("language");
+		parserOptions.add("accessLevel");
 		parserOptions.add("exportMacro");
 	}
 

File: tool/src/org/antlr/v4/codegen/model/Recognizer.java
Patch:
@@ -24,6 +24,7 @@ public abstract class Recognizer extends OutputModelObject {
 	public String name;
 	public String grammarName;
 	public String grammarFileName;
+	public String accessLevel;
 	public Map<String,Integer> tokens;
 
 	/**
@@ -51,6 +52,7 @@ public Recognizer(OutputModelFactory factory) {
 		grammarFileName = new File(g.fileName).getName();
 		grammarName = g.name;
 		name = g.getRecognizerName();
+		accessLevel = g.getOptionString("accessLevel");
 		tokens = new LinkedHashMap<String,Integer>();
 		for (Map.Entry<String, Integer> entry : g.tokenNameToTypeMap.entrySet()) {
 			Integer ttype = entry.getValue();

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -81,6 +81,7 @@ public class Grammar implements AttributeResolver {
 		parserOptions.add("TokenLabelType");
 		parserOptions.add("tokenVocab");
 		parserOptions.add("language");
+		parserOptions.add("accessLevel");
 		parserOptions.add("exportMacro");
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/BaseSwiftTest.java
Patch:
@@ -281,7 +281,7 @@ private void writeParserTestFile(String parserName,
 						"\n" +
 						"do {\n" +
 						"let args = CommandLine.arguments\n" +
-						"let input = ANTLRFileStream(args[1])\n" +
+						"let input = try ANTLRFileStream(args[1])\n" +
 						"let lex = <lexerName>(input)\n" +
 						"let tokens = CommonTokenStream(lex)\n" +
 						"<createParser>\n" +
@@ -327,7 +327,7 @@ private void writeLexerTestFile(String lexerName, boolean showDFA) {
 
 						"setbuf(stdout, nil)\n" +
 						"let args = CommandLine.arguments\n" +
-						"let input = ANTLRFileStream(args[1])\n" +
+						"let input = try ANTLRFileStream(args[1])\n" +
 						"let lex = <lexerName>(input)\n" +
 						"let tokens = CommonTokenStream(lex)\n" +
 

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -442,7 +442,7 @@ private void checkForOverlap(Grammar g, Rule rule1, Rule rule2, List<String> fir
 
 	// CAN ONLY CALL THE TWO NEXT METHODS AFTER GRAMMAR HAS RULE DEFS (see semanticpipeline)
 	public void checkRuleArgs(Grammar g, List<GrammarAST> rulerefs) {
-		if ( rulerefs==null) return;
+		if ( rulerefs==null ) return;
 		for (GrammarAST ref : rulerefs) {
 			String ruleName = ref.getText();
 			Rule r = g.getRule(ruleName);
@@ -452,7 +452,7 @@ public void checkRuleArgs(Grammar g, List<GrammarAST> rulerefs) {
 						g.fileName, ref.token, ruleName);
 
 			}
-			else if ( arg == null && (r!=null && r.args!=null) ) {
+			else if ( arg==null && (r!=null && r.args!=null) ) {
 				errMgr.grammarError(ErrorType.MISSING_RULE_ARGS,
 						g.fileName, ref.token, ruleName);
 			}

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -108,6 +108,7 @@ public void process() {
 		}
 
 		symcheck.checkForModeConflicts(g);
+		symcheck.checkForUnreachableTokens(g);
 
 		assignChannelTypes(g, collector.channelDefs);
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/BaseSwiftTest.java
Patch:
@@ -281,7 +281,7 @@ private void writeParserTestFile(String parserName,
 						"\n" +
 						"do {\n" +
 						"let args = CommandLine.arguments\n" +
-						"let input = ANTLRFileStream(args[1])\n" +
+						"let input = try ANTLRFileStream(args[1])\n" +
 						"let lex = <lexerName>(input)\n" +
 						"let tokens = CommonTokenStream(lex)\n" +
 						"<createParser>\n" +
@@ -327,7 +327,7 @@ private void writeLexerTestFile(String lexerName, boolean showDFA) {
 
 						"setbuf(stdout, nil)\n" +
 						"let args = CommandLine.arguments\n" +
-						"let input = ANTLRFileStream(args[1])\n" +
+						"let input = try ANTLRFileStream(args[1])\n" +
 						"let lex = <lexerName>(input)\n" +
 						"let tokens = CommonTokenStream(lex)\n" +
 

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -246,7 +246,7 @@ protected void handleArgs() {
 			haveOutputDir = true;
 			if (outDir.exists() && !outDir.isDirectory()) {
 				errMgr.toolError(ErrorType.OUTPUT_DIR_IS_FILE, outputDirectory);
-				libDirectory = ".";
+				outputDirectory = ".";
 			}
 		}
 		else {

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -246,7 +246,7 @@ protected void handleArgs() {
 			haveOutputDir = true;
 			if (outDir.exists() && !outDir.isDirectory()) {
 				errMgr.toolError(ErrorType.OUTPUT_DIR_IS_FILE, outputDirectory);
-				libDirectory = ".";
+				outputDirectory = ".";
 			}
 		}
 		else {

File: runtime-testsuite/test/org/antlr/v4/runtime/TestCodePointCharStream.java
Patch:
@@ -23,6 +23,7 @@ public void emptyBytesHasSize0() {
 		CodePointCharStream s = CharStreams.fromString("");
 		assertEquals(0, s.size());
 		assertEquals(0, s.index());
+		assertEquals("", s.toString());
 	}
 
 	@Test

File: runtime/Java/src/org/antlr/v4/runtime/CodePointCharStream.java
Patch:
@@ -151,8 +151,8 @@ private CodePoint8BitCharStream(int position, int remaining, String name, byte[]
 		/** Return the UTF-16 encoded string for the given interval */
 		@Override
 		public String getText(Interval interval) {
-			int startIdx = Math.min(interval.a, size - 1);
-			int len = Math.min(interval.b - interval.a + 1, size);
+			int startIdx = Math.min(interval.a, size);
+			int len = Math.min(interval.b - interval.a + 1, size - startIdx);
 
 			// We know the maximum code point in byteArray is U+00FF,
 			// so we can treat this as if it were ISO-8859-1, aka Latin-1,

File: runtime-testsuite/test/org/antlr/v4/runtime/TestCodePointCharStream.java
Patch:
@@ -23,6 +23,7 @@ public void emptyBytesHasSize0() {
 		CodePointCharStream s = CharStreams.fromString("");
 		assertEquals(0, s.size());
 		assertEquals(0, s.index());
+		assertEquals("", s.toString());
 	}
 
 	@Test

File: runtime/Java/src/org/antlr/v4/runtime/CodePointCharStream.java
Patch:
@@ -151,8 +151,8 @@ private CodePoint8BitCharStream(int position, int remaining, String name, byte[]
 		/** Return the UTF-16 encoded string for the given interval */
 		@Override
 		public String getText(Interval interval) {
-			int startIdx = Math.min(interval.a, size - 1);
-			int len = Math.min(interval.b - interval.a + 1, size);
+			int startIdx = Math.min(interval.a, size);
+			int len = Math.min(interval.b - interval.a + 1, size - startIdx);
 
 			// We know the maximum code point in byteArray is U+00FF,
 			// so we can treat this as if it were ISO-8859-1, aka Latin-1,

File: runtime-testsuite/test/org/antlr/v4/runtime/TestCodePointCharStream.java
Patch:
@@ -23,6 +23,7 @@ public void emptyBytesHasSize0() {
 		CodePointCharStream s = CharStreams.fromString("");
 		assertEquals(0, s.size());
 		assertEquals(0, s.index());
+		assertEquals("", s.toString());
 	}
 
 	@Test

File: runtime/Java/src/org/antlr/v4/runtime/CodePointCharStream.java
Patch:
@@ -151,8 +151,8 @@ private CodePoint8BitCharStream(int position, int remaining, String name, byte[]
 		/** Return the UTF-16 encoded string for the given interval */
 		@Override
 		public String getText(Interval interval) {
-			int startIdx = Math.min(interval.a, size - 1);
-			int len = Math.min(interval.b - interval.a + 1, size);
+			int startIdx = Math.min(interval.a, size);
+			int len = Math.min(interval.b - interval.a + 1, size - startIdx);
 
 			// We know the maximum code point in byteArray is U+00FF,
 			// so we can treat this as if it were ISO-8859-1, aka Latin-1,

File: runtime-testsuite/test/org/antlr/v4/runtime/TestCodePointCharStream.java
Patch:
@@ -23,6 +23,7 @@ public void emptyBytesHasSize0() {
 		CodePointCharStream s = CharStreams.fromString("");
 		assertEquals(0, s.size());
 		assertEquals(0, s.index());
+		assertEquals("", s.toString());
 	}
 
 	@Test

File: runtime/Java/src/org/antlr/v4/runtime/CodePointCharStream.java
Patch:
@@ -151,8 +151,8 @@ private CodePoint8BitCharStream(int position, int remaining, String name, byte[]
 		/** Return the UTF-16 encoded string for the given interval */
 		@Override
 		public String getText(Interval interval) {
-			int startIdx = Math.min(interval.a, size - 1);
-			int len = Math.min(interval.b - interval.a + 1, size);
+			int startIdx = Math.min(interval.a, size);
+			int len = Math.min(interval.b - interval.a + 1, size - startIdx);
 
 			// We know the maximum code point in byteArray is U+00FF,
 			// so we can treat this as if it were ISO-8859-1, aka Latin-1,

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -395,7 +395,7 @@ private List<List<String>> processGrammarFiles(
             String tokensFileName = grammarFile.getName().split("\\.")[0] + ".tokens";
             File outputFile = new File(outputDirectory, tokensFileName);
             if ( (! outputFile.exists()) ||
-                 outputFile.lastModified() < grammarFile.lastModified() ||
+                 outputFile.lastModified() <= grammarFile.lastModified() ||
                  dependencies.isDependencyChanged(grammarFile)) {
                 grammarFilesToProcess.add(grammarFile);
             }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeLexers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeLexersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeLexers extends BaseRuntimeTest {
 	public TestCompositeLexers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestFullContextParsing.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.FullContextParsingDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestFullContextParsing extends BaseRuntimeTest {
 	public TestFullContextParsing(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLeftRecursion.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LeftRecursionTests;
 import org.antlr.v4.test.runtime.descriptors.LeftRecursionDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LeftRecursionTests.class)
 @RunWith(Parameterized.class)
 public class TestLeftRecursion extends BaseRuntimeTest {
 	public TestLeftRecursion(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLexerErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLexerExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerExec extends BaseRuntimeTest {
 	public TestLexerExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestListeners.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ListenersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestListeners extends BaseRuntimeTest {
 	public TestListeners(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParseTrees.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParseTreesDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParseTrees extends BaseRuntimeTest {
 	public TestParseTrees(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParserErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserErrors extends BaseRuntimeTest {
 	public TestParserErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParserExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserExec extends BaseRuntimeTest {
 	public TestParserExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestPerformance.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.PerformanceDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestPerformance extends BaseRuntimeTest {
 	public TestPerformance(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSemPredEvalLexer.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalLexerDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalLexer extends BaseRuntimeTest {
 	public TestSemPredEvalLexer(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSemPredEvalParser.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalParserDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalParser extends BaseRuntimeTest {
 	public TestSemPredEvalParser(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSets.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SetsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestCompositeLexers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeLexersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeLexers extends BaseRuntimeTest {
 	public TestCompositeLexers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestCompositeParsers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeParsersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeParsers extends BaseRuntimeTest {
 	public TestCompositeParsers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestFullContextParsing.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.FullContextParsingDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestFullContextParsing extends BaseRuntimeTest {
 	public TestFullContextParsing(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestLeftRecursion.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LeftRecursionTests;
 import org.antlr.v4.test.runtime.descriptors.LeftRecursionDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LeftRecursionTests.class)
 @RunWith(Parameterized.class)
 public class TestLeftRecursion extends BaseRuntimeTest {
 	public TestLeftRecursion(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestLexerErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestLexerExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerExec extends BaseRuntimeTest {
 	public TestLexerExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestListeners.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ListenersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestListeners extends BaseRuntimeTest {
 	public TestListeners(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParseTrees.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParseTreesDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParseTrees extends BaseRuntimeTest {
 	public TestParseTrees(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserErrors extends BaseRuntimeTest {
 	public TestParserErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserExec extends BaseRuntimeTest {
 	public TestParserExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestPerformance.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.PerformanceDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestPerformance extends BaseRuntimeTest {
 	public TestPerformance(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSemPredEvalLexer.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalLexerDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalLexer extends BaseRuntimeTest {
 	public TestSemPredEvalLexer(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSemPredEvalParser.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalParserDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalParser extends BaseRuntimeTest {
 	public TestSemPredEvalParser(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSets.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SetsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestCompositeLexers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeLexersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeLexers extends BaseRuntimeTest {
 	public TestCompositeLexers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestCompositeParsers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeParsersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeParsers extends BaseRuntimeTest {
 	public TestCompositeParsers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestFullContextParsing.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.FullContextParsingDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestFullContextParsing extends BaseRuntimeTest {
 	public TestFullContextParsing(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLeftRecursion.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LeftRecursionTests;
 import org.antlr.v4.test.runtime.descriptors.LeftRecursionDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LeftRecursionTests.class)
 @RunWith(Parameterized.class)
 public class TestLeftRecursion extends BaseRuntimeTest {
 	public TestLeftRecursion(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerExec extends BaseRuntimeTest {
 	public TestLexerExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestListeners.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ListenersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestListeners extends BaseRuntimeTest {
 	public TestListeners(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParseTrees.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParseTreesDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParseTrees extends BaseRuntimeTest {
 	public TestParseTrees(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParserErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserErrors extends BaseRuntimeTest {
 	public TestParserErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParserExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserExec extends BaseRuntimeTest {
 	public TestParserExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestPerformance.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.PerformanceDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestPerformance extends BaseRuntimeTest {
 	public TestPerformance(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSemPredEvalLexer.java
Patch:
@@ -9,10 +9,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalLexerDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalLexer extends BaseRuntimeTest {
 	public TestSemPredEvalLexer(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSemPredEvalParser.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalParserDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalParser extends BaseRuntimeTest {
 	public TestSemPredEvalParser(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSets.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SetsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSets.java
Patch:
@@ -8,13 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
-import org.antlr.v4.test.runtime.category.ParserTests;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SetsDescriptors;
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-@Category(ParserTests.class)
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSets.java
Patch:
@@ -8,13 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
-import org.antlr.v4.test.runtime.category.ParserTests;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SetsDescriptors;
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-@Category(ParserTests.class)
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeLexers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeLexersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeLexers extends BaseRuntimeTest {
 	public TestCompositeLexers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestFullContextParsing.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.FullContextParsingDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestFullContextParsing extends BaseRuntimeTest {
 	public TestFullContextParsing(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLeftRecursion.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LeftRecursionTests;
 import org.antlr.v4.test.runtime.descriptors.LeftRecursionDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LeftRecursionTests.class)
 @RunWith(Parameterized.class)
 public class TestLeftRecursion extends BaseRuntimeTest {
 	public TestLeftRecursion(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLexerErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLexerExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerExec extends BaseRuntimeTest {
 	public TestLexerExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestListeners.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ListenersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestListeners extends BaseRuntimeTest {
 	public TestListeners(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParseTrees.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParseTreesDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParseTrees extends BaseRuntimeTest {
 	public TestParseTrees(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParserErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserErrors extends BaseRuntimeTest {
 	public TestParserErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParserExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserExec extends BaseRuntimeTest {
 	public TestParserExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestPerformance.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.PerformanceDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestPerformance extends BaseRuntimeTest {
 	public TestPerformance(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSemPredEvalLexer.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalLexerDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalLexer extends BaseRuntimeTest {
 	public TestSemPredEvalLexer(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSemPredEvalParser.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalParserDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalParser extends BaseRuntimeTest {
 	public TestSemPredEvalParser(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSets.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.SetsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestCompositeLexers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeLexersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeLexers extends BaseRuntimeTest {
 	public TestCompositeLexers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestCompositeParsers.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.CompositeParsersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestCompositeParsers extends BaseRuntimeTest {
 	public TestCompositeParsers(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestFullContextParsing.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.FullContextParsingDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestFullContextParsing extends BaseRuntimeTest {
 	public TestFullContextParsing(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLeftRecursion.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LeftRecursionTests;
 import org.antlr.v4.test.runtime.descriptors.LeftRecursionDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LeftRecursionTests.class)
 @RunWith(Parameterized.class)
 public class TestLeftRecursion extends BaseRuntimeTest {
 	public TestLeftRecursion(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerErrors extends BaseRuntimeTest {
 	public TestLexerErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.LexerExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestLexerExec extends BaseRuntimeTest {
 	public TestLexerExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestListeners.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ListenersDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestListeners extends BaseRuntimeTest {
 	public TestListeners(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParseTrees.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParseTreesDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParseTrees extends BaseRuntimeTest {
 	public TestParseTrees(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParserErrors.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserErrorsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserErrors extends BaseRuntimeTest {
 	public TestParserErrors(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParserExec.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.ParserExecDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestParserExec extends BaseRuntimeTest {
 	public TestParserExec(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestPerformance.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.PerformanceDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestPerformance extends BaseRuntimeTest {
 	public TestPerformance(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSemPredEvalLexer.java
Patch:
@@ -9,10 +9,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.LexerTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalLexerDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(LexerTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalLexer extends BaseRuntimeTest {
 	public TestSemPredEvalLexer(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSemPredEvalParser.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.SemPredEvalParserDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestSemPredEvalParser extends BaseRuntimeTest {
 	public TestSemPredEvalParser(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSets.java
Patch:
@@ -8,10 +8,13 @@
 
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
+import org.antlr.v4.test.runtime.category.ParserTests;
 import org.antlr.v4.test.runtime.descriptors.SetsDescriptors;
+import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+@Category(ParserTests.class)
 @RunWith(Parameterized.class)
 public class TestSets extends BaseRuntimeTest {
 	public TestSets(RuntimeTestDescriptor descriptor) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -38,7 +38,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 						+ "        lexer = <lexerName>(input, output)\n"
 						+ "        stream = CommonTokenStream(lexer)\n"
 						+ "        stream.fill()\n"
-						+ "        [ print(t, file=output) for t in stream.tokens ]\n"
+						+ "        [ print(unicode(t), file=output) for t in stream.tokens ]\n"
 						+ (showDFA ? "        print(lexer._interp.decisionToDFA[Lexer.DEFAULT_MODE].toLexerString(), end='', file=output)\n"
 								: "") + "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -38,7 +38,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 						+ "        lexer = <lexerName>(input, output)\n"
 						+ "        stream = CommonTokenStream(lexer)\n"
 						+ "        stream.fill()\n"
-						+ "        [ print(t, file=output) for t in stream.tokens ]\n"
+						+ "        [ print(unicode(t), file=output) for t in stream.tokens ]\n"
 						+ (showDFA ? "        print(lexer._interp.decisionToDFA[Lexer.DEFAULT_MODE].toLexerString(), end='', file=output)\n"
 								: "") + "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -38,7 +38,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 						+ "        lexer = <lexerName>(input, output)\n"
 						+ "        stream = CommonTokenStream(lexer)\n"
 						+ "        stream.fill()\n"
-						+ "        [ print(t, file=output) for t in stream.tokens ]\n"
+						+ "        [ print(unicode(t), file=output) for t in stream.tokens ]\n"
 						+ (showDFA ? "        print(lexer._interp.decisionToDFA[Lexer.DEFAULT_MODE].toLexerString(), end='', file=output)\n"
 								: "") + "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/LexerErrorsDescriptors.java
Patch:
@@ -222,10 +222,11 @@ public static abstract class StringsEmbeddedInActions extends BaseLexerTestDescr
 		public String startRule = "";
 		public String grammarName = "L";
 
+		// ST interprets \\ as \ so we need \\\\ to get \\
 		/**
 		 lexer grammar L;
 		 ACTION2 : '[' (STRING | ~'"')*? ']';
-		 STRING : '"' ('\\"' | .)*? '"';
+		 STRING : '"' ('\\\\' '"' | .)*? '"';
 		 WS : [ \t\r\n]+ -> skip;
 		 */
 		@CommentHasStringValue

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/LexerErrorsDescriptors.java
Patch:
@@ -222,10 +222,11 @@ public static abstract class StringsEmbeddedInActions extends BaseLexerTestDescr
 		public String startRule = "";
 		public String grammarName = "L";
 
+		// ST interprets \\ as \ so we need \\\\ to get \\
 		/**
 		 lexer grammar L;
 		 ACTION2 : '[' (STRING | ~'"')*? ']';
-		 STRING : '"' ('\\"' | .)*? '"';
+		 STRING : '"' ('\\\\' '"' | .)*? '"';
 		 WS : [ \t\r\n]+ -> skip;
 		 */
 		@CommentHasStringValue

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -824,7 +824,7 @@ public enum ErrorType {
 	 *
 	 * @since 4.2.1
 	 */
-	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence", ErrorSeverity.WARNING),
+	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence <arg>", ErrorSeverity.WARNING),
 	/**
 	 * Compiler Warning 157.
 	 *

File: tool/src/org/antlr/v4/tool/ast/GrammarASTWithOptions.java
Patch:
@@ -43,7 +43,7 @@ public String getOptionString(String key) {
 			if ( v.startsWith("'") || v.startsWith("\"") ) {
 				v = CharSupport.getStringFromGrammarStringLiteral(v);
 				if (v == null) {
-					g.tool.errMgr.grammarError(ErrorType.INVALID_ESCAPE_SEQUENCE, g.fileName, value.getToken());
+					g.tool.errMgr.grammarError(ErrorType.INVALID_ESCAPE_SEQUENCE, g.fileName, value.getToken(), value.getText());
 					v = "";
 				}
 			}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -824,7 +824,7 @@ public enum ErrorType {
 	 *
 	 * @since 4.2.1
 	 */
-	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence", ErrorSeverity.WARNING),
+	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence <arg>", ErrorSeverity.WARNING),
 	/**
 	 * Compiler Warning 157.
 	 *

File: tool/src/org/antlr/v4/tool/ast/GrammarASTWithOptions.java
Patch:
@@ -43,7 +43,7 @@ public String getOptionString(String key) {
 			if ( v.startsWith("'") || v.startsWith("\"") ) {
 				v = CharSupport.getStringFromGrammarStringLiteral(v);
 				if (v == null) {
-					g.tool.errMgr.grammarError(ErrorType.INVALID_ESCAPE_SEQUENCE, g.fileName, value.getToken());
+					g.tool.errMgr.grammarError(ErrorType.INVALID_ESCAPE_SEQUENCE, g.fileName, value.getToken(), value.getText());
 					v = "";
 				}
 			}

File: tool/src/org/antlr/v4/codegen/target/Python3Target.java
Patch:
@@ -56,7 +56,7 @@ public Python3Target(CodeGenerator gen) {
 	@Override
 	public int getSerializedATNSegmentLimit() {
 		// set to something stupid to avoid segmentation
-		return 2 ^ 31;
+		return Integer.MAX_VALUE;
 	}
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/BaseJavaTest.java
Patch:
@@ -923,7 +923,7 @@ protected void writeTestFile(String parserName,
 			"\n" +
 			"public class Test {\n" +
 			"    public static void main(String[] args) throws Exception {\n" +
-			"        CharStream input = CharStreams.createWithUTF8(Paths.get(args[0]));\n" +
+			"        CharStream input = CharStreams.fromPath(Paths.get(args[0]));\n" +
 			"        <lexerName> lex = new <lexerName>(input);\n" +
 			"        CommonTokenStream tokens = new CommonTokenStream(lex);\n" +
 			"        <createParser>\n"+
@@ -980,7 +980,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 			"\n" +
 			"public class Test {\n" +
 			"    public static void main(String[] args) throws Exception {\n" +
-			"        CharStream input = CharStreams.createWithUTF8(Paths.get(args[0]));\n" +
+			"        CharStream input = CharStreams.fromPath(Paths.get(args[0]));\n" +
 			"        <lexerName> lex = new <lexerName>(input);\n" +
 			"        CommonTokenStream tokens = new CommonTokenStream(lex);\n" +
 			"        tokens.fill();\n" +

File: tool-testsuite/test/org/antlr/v4/test/tool/TestATNLexerInterpreter.java
Patch:
@@ -381,7 +381,7 @@ public void testSetUp() throws Exception {
 
 	protected void checkLexerMatches(LexerGrammar lg, String inputString, String expecting) {
 		ATN atn = createATN(lg, true);
-		CharStream input = CharStreams.createWithString(inputString);
+		CharStream input = CharStreams.fromString(inputString);
 		ATNState startState = atn.modeNameToStartState.get("DEFAULT_MODE");
 		DOTGenerator dot = new DOTGenerator(lg);
 //		System.out.println(dot.getDOT(startState, true));

File: tool-testsuite/test/org/antlr/v4/test/tool/TestUnicodeGrammar.java
Patch:
@@ -161,7 +161,7 @@ private static String parseTreeForGrammarWithInput(
 			String inputText) throws Exception {
 		Grammar grammar = new Grammar(grammarText);
 		LexerInterpreter lexEngine = grammar.createLexerInterpreter(
-				CharStreams.createWithString(inputText));
+				CharStreams.fromString(inputText));
 		CommonTokenStream tokens = new CommonTokenStream(lexEngine);
 		GrammarParserInterpreter parser = grammar.createGrammarParserInterpreter(tokens);
 		ParseTree parseTree = parser.parse(grammar.rules.get(rootRule).index);

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -16,7 +16,6 @@
 import java.net.URL;
 import java.util.Collection;
 import java.util.EnumSet;
-import java.util.Locale;
 import java.util.Set;
 
 public class ErrorManager {
@@ -32,8 +31,6 @@ public class ErrorManager {
     /** The group of templates that represent the current message format. */
     STGroup format;
 
-    /** Messages should be sensitive to the locale. */
-    Locale locale;
     String formatName;
 
     ErrorBuffer initSTListener = new ErrorBuffer();

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -522,7 +522,7 @@ public void testSetUp() throws Exception {
 				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:4:30: invalid escape sequence\n" +
 				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:4:40: invalid escape sequence\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:5:33: string literals and sets cannot be empty: 'F'..'A'\n" +
-				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:6:30: string literals and sets cannot be empty: [f-a]\n" +
+				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:6:30: string literals and sets cannot be empty: 'f'..'a'\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:6:36: string literals and sets cannot be empty: []\n" +
 				"error(" + ErrorType.INVALID_CHAR_SET.code + "): Test.g4:7:30: invalid charset (range without start or end): [-z]\n" +
 				"error(" + ErrorType.INVALID_CHAR_SET.code + "): Test.g4:7:37: invalid charset (range without start or end): [a-]\n" +

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -1054,7 +1054,7 @@ public enum ErrorType {
 	 *
 	 * TODO: Does not work with fragment rules.
 	 */
-	CHARACTERS_COLLISION_IN_SET(180, "chars \"<arg>\" used multiple times in set <arg2>", ErrorSeverity.WARNING),
+	CHARACTERS_COLLISION_IN_SET(180, "chars <arg> used multiple times in set <arg2>", ErrorSeverity.WARNING),
 
 	/**
 	 * Compiler Warning 181

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -522,7 +522,7 @@ public void testSetUp() throws Exception {
 				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:4:30: invalid escape sequence\n" +
 				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:4:40: invalid escape sequence\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:5:33: string literals and sets cannot be empty: 'F'..'A'\n" +
-				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:6:30: string literals and sets cannot be empty: [f-a]\n" +
+				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:6:30: string literals and sets cannot be empty: 'f'..'a'\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:6:36: string literals and sets cannot be empty: []\n" +
 				"error(" + ErrorType.INVALID_CHAR_SET.code + "): Test.g4:7:30: invalid charset (range without start or end): [-z]\n" +
 				"error(" + ErrorType.INVALID_CHAR_SET.code + "): Test.g4:7:37: invalid charset (range without start or end): [a-]\n" +

File: tool/src/org/antlr/v4/automata/ATNOptimizer.java
Patch:
@@ -111,7 +111,7 @@ private static void optimizeSets(Grammar g, ATN atn) {
 									// TODO: Token is missing (i.e. position in source will not be displayed).
 									g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET, g.fileName,
 											null,
-											String.valueOf(Character.toChars(v)),
+											CharSupport.getANTLRCharLiteralForChar(v),
 											matchSet.toString(true));
 									break;
 								}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -1054,7 +1054,7 @@ public enum ErrorType {
 	 *
 	 * TODO: Does not work with fragment rules.
 	 */
-	CHARACTERS_COLLISION_IN_SET(180, "chars \"<arg>\" used multiple times in set <arg2>", ErrorSeverity.WARNING),
+	CHARACTERS_COLLISION_IN_SET(180, "chars <arg> used multiple times in set <arg2>", ErrorSeverity.WARNING),
 
 	/**
 	 * Compiler Warning 181

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -509,9 +509,9 @@ public void testSetUp() throws Exception {
 				"INVALID_CHAR_SET:             [\\u24\\uA2][\\{];\n" +  //https://github.com/antlr/antlr4/issues/1077
 				"EMPTY_STRING_LITERAL_RANGE:   'F'..'A' | 'Z';\n" +
 				"EMPTY_CHAR_SET:               [f-az][];\n" +
-				"INVALID_RANGE_IN_CHAR_SET:    [-z] | [a-] | [-];" +
+				"INVALID_RANGE_IN_CHAR_SET:    [-z] | [a-] | [-];\n" +
 				"VALID_STRING_LITERALS:        '\\u1234' | '\\t' | '\\'';\n" +
-				"VALID_CHAR_SET:               [`\\-=\\]];\n";
+				"VALID_CHAR_SET:               [`\\-=\\]];";
 
 		String expected =
 				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:2:31: invalid escape sequence\n" +

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -595,7 +595,7 @@ public Token consume() {
 	/** How to create a token leaf node associated with a parent.
 	 *  Typically, the terminal node to create is not a function of the parent.
 	 *
-	 * @since 4.6.1
+	 * @since 4.7
 	 */
 	public TerminalNode createTerminalNode(ParserRuleContext parent, Token t) {
 		return new TerminalNodeImpl(t);
@@ -604,7 +604,7 @@ public TerminalNode createTerminalNode(ParserRuleContext parent, Token t) {
 	/** How to create an error node, given a token, associated with a parent.
 	 *  Typically, the error node to create is not a function of the parent.
 	 *
-	 * @since 4.6.1
+	 * @since 4.7
 	 */
 	public ErrorNode createErrorNode(ParserRuleContext parent, Token t) {
 		return new ErrorNodeImpl(t);

File: runtime/Java/src/org/antlr/v4/runtime/ParserRuleContext.java
Patch:
@@ -127,7 +127,7 @@ public void exitRule(ParseTreeListener listener) { }
 	 *  because the existing interfaces do not have a setParent()
 	 *  method and I don't want to break backward compatibility for this.
 	 *
-	 *  @since 4.6.1
+	 *  @since 4.7
 	 */
 	public <T extends ParseTree> T addAnyChild(T t) {
 		if ( children==null ) children = new ArrayList<>();
@@ -147,7 +147,7 @@ public TerminalNode addChild(TerminalNode t) {
 
 	/** Add an error node child and force its parent to be this node.
 	 *
-	 * @since 4.6.1
+	 * @since 4.7
 	 */
 	public ErrorNode addErrorNode(ErrorNode errorNode) {
 		errorNode.setParent(this);

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -67,7 +67,7 @@ public class RuntimeMetaData {
 	 * omitted.</li>
 	 * </ul>
 	 */
-	public static final String VERSION = "4.6.1";
+	public static final String VERSION = "4.7";
 
 	/**
 	 * Gets the currently executing version of the ANTLR 4 runtime library.

File: runtime/Java/src/org/antlr/v4/runtime/TokenFactory.java
Patch:
@@ -10,7 +10,7 @@
 
 /** The default mechanism for creating tokens. It's used by default in Lexer and
  *  the error handling strategy (to create missing tokens).  Notifying the parser
- *  of a new factory means that it notifies it's token source and error strategy.
+ *  of a new factory means that it notifies its token source and error strategy.
  */
 public interface TokenFactory<Symbol extends Token> {
 	/** This is the method used to create tokens in the lexer and in the

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -161,7 +161,8 @@ public boolean equals(Object o) {
 	public boolean equals(ATNConfig other) {
 		if (this == other) {
 			return true;
-		} else if (other == null) {
+		}
+		else if (other == null) {
 			return false;
 		}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -738,7 +738,8 @@ public void consume(CharStream input) {
 		if ( curChar=='\n' ) {
 			line++;
 			charPositionInLine=0;
-		} else {
+		}
+		else {
 			charPositionInLine++;
 		}
 		input.consume();

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -389,12 +389,13 @@ public void testLabelsForTokensWithMixedTypesLRWithoutLabels() {
 				"TOKEN_RANGE:      [aa-f];\n" +
 				"TOKEN_RANGE_2:    [A-FD-J];\n" +
 				"TOKEN_RANGE_3:    'Z' | 'K'..'R' | 'O'..'V';\n" +
-				"TOKEN_RANGE_4:    'g'..'l' | [g-l];\n",             // Handling in ATNOptimizer.
+				"TOKEN_RANGE_4:    'g'..'l' | [g-l];\n" +
+				"TOKEN_RANGE_WITHOUT_COLLISION: '_' | [a-zA-Z];",
 
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:2:18: chars \"a-f\" used multiple times in set [aa-f]\n" +
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:3:18: chars \"D-J\" used multiple times in set [A-FD-J]\n" +
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:4:13: chars \"O-V\" used multiple times in set 'Z' | 'K'..'R' | 'O'..'V'\n" +
-				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4::: chars \"g-l\" used multiple times in set [g-l]\n"
+				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4::: chars \"g\" used multiple times in set {'g'..'l'}\n"
 		};
 
 		testErrors(test, false);

File: tool/src/org/antlr/v4/automata/TailEpsilonRemover.java
Patch:
@@ -45,7 +45,8 @@ public void visitState(ATNState p) {
 						// skip over q
 						if (p.transition(0) instanceof RuleTransition) {
 							((RuleTransition) p.transition(0)).followState = r;
-						} else {
+						}
+						else {
 							p.transition(0).target = r;
 						}
 						_atn.removeState(q);

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -6,9 +6,9 @@
 
 package org.antlr.v4.codegen.target;
 
-import org.antlr.v4.codegen.UnicodeEscapes;
 import org.antlr.v4.codegen.CodeGenerator;
 import org.antlr.v4.codegen.Target;
+import org.antlr.v4.codegen.UnicodeEscapes;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.stringtemplate.v4.NumberRenderer;
@@ -50,7 +50,7 @@ public CppTarget(CodeGenerator gen) {
 	}
 
 	public String getVersion() {
-		return "4.6.1";
+		return "4.7";
 	}
 
     public boolean needsHeader() { return true; }

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -61,7 +61,7 @@ public GoTarget(CodeGenerator gen) {
 
 	@Override
 	public String getVersion() {
-		return "4.6.1";
+		return "4.7";
 	}
 
 	public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/codegen/target/JavaScriptTarget.java
Patch:
@@ -51,7 +51,7 @@ public JavaScriptTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.6.1";
+        return "4.7";
     }
 
     public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/codegen/target/Python2Target.java
Patch:
@@ -94,7 +94,7 @@ public boolean supportsOverloadedMethods() {
 
 	@Override
 	public String getVersion() {
-		return "4.6.1";
+		return "4.7";
 	}
 
 	public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/codegen/target/Python3Target.java
Patch:
@@ -96,7 +96,7 @@ public boolean supportsOverloadedMethods() {
 
 	@Override
 	public String getVersion() {
-		return "4.6.1";
+		return "4.7";
 	}
 
 	/** Avoid grammar symbols in this set to prevent conflicts in gen'd code. */

File: tool/src/org/antlr/v4/codegen/target/SwiftTarget.java
Patch:
@@ -87,7 +87,7 @@ public SwiftTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.6.1"; // Java and tool versions move in lock step
+        return "4.7"; // Java and tool versions move in lock step
     }
 
     public Set<String> getBadWords() {
@@ -124,7 +124,8 @@ protected void genFile(Grammar g,
 
         if (g.isLexer()  && lexerAtnJSON == null) {
             lexerAtnJSON = getLexerOrParserATNJson(g, fileName);
-        } else if (!g.isLexer()  && parserAtnJSON == null && g.atn != null) {
+        }
+        else if (!g.isLexer()  && parserAtnJSON == null && g.atn != null) {
             parserAtnJSON = getLexerOrParserATNJson(g, fileName);
         }
 

File: tool/src/org/antlr/v4/gui/GraphicsSupport.java
Patch:
@@ -93,7 +93,8 @@ public int print(Graphics g, PageFormat pf, int page) {
 				job.print(doc, attributes);
 				out.close();
 			}
-		} else {
+		}
+		else {
 			// parrt: works with [image/jpeg, image/png, image/x-png, image/vnd.wap.wbmp, image/bmp, image/gif]
 			Rectangle rect = comp.getBounds();
 			BufferedImage image = new BufferedImage(rect.width, rect.height,

File: tool/src/org/antlr/v4/gui/TreeViewer.java
Patch:
@@ -159,7 +159,8 @@ protected void paintEdges(Graphics g, Tree parent) {
 					double ctrly2 = y1;
 					c.setCurve(x1, y1, ctrlx1, ctrly1, ctrlx2, ctrly2, x2, y2);
 					((Graphics2D) g).draw(c);
-				} else {
+				}
+				else {
 					g.drawLine((int) x1, (int) y1,
 							   (int) x2, (int) y2);
 				}

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -122,7 +122,8 @@ public static <T> int lastIndexOf(List<? extends T> elems, Filter<T> filter) {
 	public static void setSize(List<?> list, int size) {
 		if (size < list.size()) {
 			list.subList(size, list.size()).clear();
-		} else {
+		}
+		else {
 			while (size > list.size()) {
 				list.add(null);
 			}

File: tool/src/org/antlr/v4/parse/ScopeParser.java
Patch:
@@ -312,7 +312,8 @@ public static int _splitArgumentList(String actionText,
 						// do we see a matching '>' ahead?  if so, hope it's a generic
 						// and not less followed by expr with greater than
 						p = _splitArgumentList(actionText, p + 1, '>', separatorChar, args);
-					} else {
+					}
+					else {
 						p++; // treat as normal char
 					}
 					break;

File: tool/src/org/antlr/v4/tool/DOTGenerator.java
Patch:
@@ -289,7 +289,8 @@ else if ( edge instanceof RangeTransition ) {
 				edgeST.add("arrowhead", arrowhead);
 				if (s.getNumberOfTransitions() > 1) {
 					edgeST.add("transitionIndex", i);
-				} else {
+				}
+				else {
 					edgeST.add("transitionIndex", false);
 				}
 				dot.add("edges", edgeST);

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -389,12 +389,13 @@ public void testLabelsForTokensWithMixedTypesLRWithoutLabels() {
 				"TOKEN_RANGE:      [aa-f];\n" +
 				"TOKEN_RANGE_2:    [A-FD-J];\n" +
 				"TOKEN_RANGE_3:    'Z' | 'K'..'R' | 'O'..'V';\n" +
-				"TOKEN_RANGE_4:    'g'..'l' | [g-l];\n",             // Handling in ATNOptimizer.
+				"TOKEN_RANGE_4:    'g'..'l' | [g-l];\n" +
+				"TOKEN_RANGE_WITHOUT_COLLISION: '_' | [a-zA-Z];",
 
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:2:18: chars \"a-f\" used multiple times in set [aa-f]\n" +
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:3:18: chars \"D-J\" used multiple times in set [A-FD-J]\n" +
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:4:13: chars \"O-V\" used multiple times in set 'Z' | 'K'..'R' | 'O'..'V'\n" +
-				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4::: chars \"g-l\" used multiple times in set [g-l]\n"
+				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4::: chars \"g\" used multiple times in set {'g'..'l'}\n"
 		};
 
 		testErrors(test, false);

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -221,7 +221,6 @@ public String getTargetStringLiteralFromANTLRStringLiteral(
 				switch (escapedCodePoint) {
 					// Pass through any escapes that Java also needs
 					//
-					case    '"':
 					case    'n':
 					case    'r':
 					case    't':

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -389,12 +389,13 @@ public void testLabelsForTokensWithMixedTypesLRWithoutLabels() {
 				"TOKEN_RANGE:      [aa-f];\n" +
 				"TOKEN_RANGE_2:    [A-FD-J];\n" +
 				"TOKEN_RANGE_3:    'Z' | 'K'..'R' | 'O'..'V';\n" +
-				"TOKEN_RANGE_4:    'g'..'l' | [g-l];\n",             // Handling in ATNOptimizer.
+				"TOKEN_RANGE_4:    'g'..'l' | [g-l];\n" +
+				"TOKEN_RANGE_WITHOUT_COLLISION: '_' | [a-zA-Z];",
 
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:2:18: chars \"a-f\" used multiple times in set [aa-f]\n" +
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:3:18: chars \"D-J\" used multiple times in set [A-FD-J]\n" +
 				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4:4:13: chars \"O-V\" used multiple times in set 'Z' | 'K'..'R' | 'O'..'V'\n" +
-				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4::: chars \"g-l\" used multiple times in set [g-l]\n"
+				"warning(" + ErrorType.CHARACTERS_COLLISION_IN_SET.code + "): L.g4::: chars \"g\" used multiple times in set {'g'..'l'}\n"
 		};
 
 		testErrors(test, false);

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -517,9 +517,9 @@ public void testSetUp() throws Exception {
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:3:26: string literals and sets cannot be empty: 'F'..'A'\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:5:23: string literals and sets cannot be empty: [f-a]\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:5:29: string literals and sets cannot be empty: []\n" +
-				"error(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:23: invalid escape sequence\n" +
-				"error(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:33: invalid escape sequence\n" +
-				"error(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:7:23: invalid escape sequence\n";
+				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:23: invalid escape sequence\n" +
+				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:33: invalid escape sequence\n" +
+				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:7:23: invalid escape sequence\n";
 
 		String[] pair = new String[] {
 				grammar,

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -824,7 +824,7 @@ public enum ErrorType {
 	 *
 	 * @since 4.2.1
 	 */
-	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence", ErrorSeverity.ERROR),
+	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence", ErrorSeverity.WARNING),
 	/**
 	 * Compiler Warning 157.
 	 *

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -517,9 +517,9 @@ public void testSetUp() throws Exception {
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:3:26: string literals and sets cannot be empty: 'F'..'A'\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:5:23: string literals and sets cannot be empty: [f-a]\n" +
 				"error(" + ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED.code + "): Test.g4:5:29: string literals and sets cannot be empty: []\n" +
-				"error(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:23: invalid escape sequence\n" +
-				"error(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:33: invalid escape sequence\n" +
-				"error(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:7:23: invalid escape sequence\n";
+				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:23: invalid escape sequence\n" +
+				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:6:33: invalid escape sequence\n" +
+				"warning(" + ErrorType.INVALID_ESCAPE_SEQUENCE.code + "): Test.g4:7:23: invalid escape sequence\n";
 
 		String[] pair = new String[] {
 				grammar,

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -824,7 +824,7 @@ public enum ErrorType {
 	 *
 	 * @since 4.2.1
 	 */
-	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence", ErrorSeverity.ERROR),
+	INVALID_ESCAPE_SEQUENCE(156, "invalid escape sequence", ErrorSeverity.WARNING),
 	/**
 	 * Compiler Warning 157.
 	 *

File: runtime/Java/src/org/antlr/v4/runtime/TokenFactory.java
Patch:
@@ -10,7 +10,7 @@
 
 /** The default mechanism for creating tokens. It's used by default in Lexer and
  *  the error handling strategy (to create missing tokens).  Notifying the parser
- *  of a new factory means that it notifies it's token source and error strategy.
+ *  of a new factory means that it notifies its token source and error strategy.
  */
 public interface TokenFactory<Symbol extends Token> {
 	/** This is the method used to create tokens in the lexer and in the

File: runtime/Java/src/org/antlr/v4/runtime/TokenFactory.java
Patch:
@@ -10,7 +10,7 @@
 
 /** The default mechanism for creating tokens. It's used by default in Lexer and
  *  the error handling strategy (to create missing tokens).  Notifying the parser
- *  of a new factory means that it notifies it's token source and error strategy.
+ *  of a new factory means that it notifies its token source and error strategy.
  */
 public interface TokenFactory<Symbol extends Token> {
 	/** This is the method used to create tokens in the lexer and in the

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -224,7 +224,7 @@ public static ErrorQueue antlrOnString(String workdir,
 	                                       String... extraOptions)
 	{
 		mkdir(workdir);
-		BaseJavaTest.writeFile(workdir, grammarFileName, grammarStr);
+		writeFile(workdir, grammarFileName, grammarStr);
 		return antlrOnString(workdir, targetName, grammarFileName, defaultListener, extraOptions);
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node|Swift");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift|CSharp");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserErrorsDescriptors.java
Patch:
@@ -135,7 +135,7 @@ public static class InvalidATNStateRemoval extends BaseParserTestDescriptor {
 	public static class InvalidEmptyInput extends BaseParserTestDescriptor {
 		public String input = "";
 		public String output = null;
-		public String errors = "line 1:0 missing ID at '<EOF>'\n";
+		public String errors = "line 1:0 mismatched input '<EOF>' expecting ID\n";
 		public String startRule = "start";
 		public String grammarName = "T";
 
@@ -414,7 +414,7 @@ public static class SingleTokenDeletionBeforeLoop extends BaseParserTestDescript
 
 		/**
 		 grammar T;
-		 a : 'a' 'b'* ;
+		 a : 'a' 'b'* EOF ;
 		 */
 		@CommentHasStringValue
 		public String grammar;
@@ -436,7 +436,7 @@ public static class SingleTokenDeletionBeforeLoop2 extends BaseParserTestDescrip
 
 		/**
 		 grammar T;
-		 a : 'a' ('b'|'z'{<Pass()>})*;
+		 a : 'a' ('b'|'z'{<Pass()>})* EOF ;
 		 */
 		@CommentHasStringValue
 		public String grammar;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -113,7 +113,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp").contains(targetName);
 		}
 	}
 
@@ -199,7 +199,7 @@ public static class DropLoopEntryBranchInLRRule_4 extends DropLoopEntryBranchInL
 		@Override
 		public boolean ignore(String targetName) {
 			// passes, but still too slow in Python and JavaScript
-			return !Arrays.asList("Java", "CSharp").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Cpp").contains(targetName);
 		}
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/ParserInterpreter.java
Patch:
@@ -414,7 +414,7 @@ protected void recover(RecognitionException e) {
 				                             Token.DEFAULT_CHANNEL,
 				                            -1, -1, // invalid start/stop
 				                             tok.getLine(), tok.getCharPositionInLine());
-				_ctx.addErrorNode(errToken);
+				_ctx.addErrorNode(createErrorNode(_ctx,errToken));
 			}
 			else { // NoViableAlt
 				Token tok = e.getOffendingToken();
@@ -424,7 +424,7 @@ protected void recover(RecognitionException e) {
 				                             Token.DEFAULT_CHANNEL,
 				                            -1, -1, // invalid start/stop
 				                             tok.getLine(), tok.getCharPositionInLine());
-				_ctx.addErrorNode(errToken);
+				_ctx.addErrorNode(createErrorNode(_ctx,errToken));
 			}
 		}
 	}
@@ -445,3 +445,4 @@ public InterpreterRuleContext getRootContext() {
 		return rootContext;
 	}
 }
+

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -67,7 +67,7 @@ public class RuntimeMetaData {
 	 * omitted.</li>
 	 * </ul>
 	 */
-	public static final String VERSION = "4.6";
+	public static final String VERSION = "4.6.1";
 
 	/**
 	 * Gets the currently executing version of the ANTLR 4 runtime library.

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSerializer.java
Patch:
@@ -340,6 +340,7 @@ else if ( s instanceof BlockStartState ) {
 			}
 		}
 
+		// Note: This value shifting loop is documented in ATNDeserializer.
 		// don't adjust the first value since that's the version number
 		for (int i = 1; i < data.size(); i++) {
 			if (data.get(i) < Character.MIN_VALUE || data.get(i) > Character.MAX_VALUE) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -372,7 +372,7 @@ protected void accept(CharStream input, LexerActionExecutor lexerActionExecutor,
 
 
 	protected ATNState getReachableTarget(Transition trans, int t) {
-		if (trans.matches(t, Character.MIN_VALUE, Character.MAX_VALUE)) {
+		if (trans.matches(t, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {
 			return trans.target;
 		}
 
@@ -544,7 +544,7 @@ protected LexerATNConfig getEpsilonTarget(CharStream input,
 			case Transition.RANGE:
 			case Transition.SET:
 				if (treatEofAsEpsilon) {
-					if (t.matches(CharStream.EOF, Character.MIN_VALUE, Character.MAX_VALUE)) {
+					if (t.matches(CharStream.EOF, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {
 						c = new LexerATNConfig(config, t.target);
 						break;
 					}

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java
Patch:
@@ -505,11 +505,11 @@ public String toString(boolean elemAreChar) {
 			int b = I.b;
 			if ( a==b ) {
 				if ( a==Token.EOF ) buf.append("<EOF>");
-				else if ( elemAreChar ) buf.append("'").append((char)a).append("'");
+				else if ( elemAreChar ) buf.append("'").appendCodePoint(a).append("'");
 				else buf.append(a);
 			}
 			else {
-				if ( elemAreChar ) buf.append("'").append((char)a).append("'..'").append((char)b).append("'");
+				if ( elemAreChar ) buf.append("'").appendCodePoint(a).append("'..'").appendCodePoint(b).append("'");
 				else buf.append(a).append("..").append(b);
 			}
 			if ( iter.hasNext() ) {

File: runtime/Java/src/org/antlr/v4/runtime/ParserInterpreter.java
Patch:
@@ -414,7 +414,7 @@ protected void recover(RecognitionException e) {
 				                             Token.DEFAULT_CHANNEL,
 				                            -1, -1, // invalid start/stop
 				                             tok.getLine(), tok.getCharPositionInLine());
-				_ctx.addErrorNode(errToken);
+				_ctx.addErrorNode(createErrorNode(_ctx,errToken));
 			}
 			else { // NoViableAlt
 				Token tok = e.getOffendingToken();
@@ -424,7 +424,7 @@ protected void recover(RecognitionException e) {
 				                             Token.DEFAULT_CHANNEL,
 				                            -1, -1, // invalid start/stop
 				                             tok.getLine(), tok.getCharPositionInLine());
-				_ctx.addErrorNode(errToken);
+				_ctx.addErrorNode(createErrorNode(_ctx,errToken));
 			}
 		}
 	}
@@ -445,3 +445,4 @@ public InterpreterRuleContext getRootContext() {
 		return rootContext;
 	}
 }
+

File: runtime/Java/src/org/antlr/v4/runtime/ParserInterpreter.java
Patch:
@@ -414,7 +414,7 @@ protected void recover(RecognitionException e) {
 				                             Token.DEFAULT_CHANNEL,
 				                            -1, -1, // invalid start/stop
 				                             tok.getLine(), tok.getCharPositionInLine());
-				_ctx.addErrorNode(errToken);
+				_ctx.addErrorNode(createErrorNode(_ctx,errToken));
 			}
 			else { // NoViableAlt
 				Token tok = e.getOffendingToken();
@@ -424,7 +424,7 @@ protected void recover(RecognitionException e) {
 				                             Token.DEFAULT_CHANNEL,
 				                            -1, -1, // invalid start/stop
 				                             tok.getLine(), tok.getCharPositionInLine());
-				_ctx.addErrorNode(errToken);
+				_ctx.addErrorNode(createErrorNode(_ctx,errToken));
 			}
 		}
 	}
@@ -445,3 +445,4 @@ public InterpreterRuleContext getRootContext() {
 		return rootContext;
 	}
 }
+

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node|Swift");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift|CSharp");
 		}
 	}
 

File: tool/src/org/antlr/v4/codegen/target/CSharpTarget.java
Patch:
@@ -46,7 +46,7 @@ public String encodeIntAsCharEscape(int v) {
 			formatted = String.format("\\x%X", v & 0xFFFF);
 		}
 
-		return "'" + formatted + "'";
+		return formatted;
 	}
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node|Swift");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift|CSharp");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -32,7 +32,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 						+ "from <lexerName> import <lexerName>\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "    stream.fill()\n"
@@ -76,7 +76,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "                raise IllegalStateException(\"Invalid parse tree shape detected.\")\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "<createParser>"

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -30,7 +30,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 						+ "from <lexerName> import <lexerName>\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "    stream.fill()\n"
@@ -74,7 +74,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "                raise IllegalStateException(\"Invalid parse tree shape detected.\")\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "<createParser>"

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -32,7 +32,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 						+ "from <lexerName> import <lexerName>\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "    stream.fill()\n"
@@ -76,7 +76,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "                raise IllegalStateException(\"Invalid parse tree shape detected.\")\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "<createParser>"

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -30,7 +30,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 						+ "from <lexerName> import <lexerName>\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "    stream.fill()\n"
@@ -74,7 +74,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "                raise IllegalStateException(\"Invalid parse tree shape detected.\")\n"
 						+ "\n"
 						+ "def main(argv):\n"
-						+ "    input = FileStream(argv[1])\n"
+						+ "    input = FileStream(argv[1], encoding='utf-8', errors='replace')\n"
 						+ "    lexer = <lexerName>(input)\n"
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "<createParser>"

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -224,7 +224,7 @@ public static ErrorQueue antlrOnString(String workdir,
 	                                       String... extraOptions)
 	{
 		mkdir(workdir);
-		BaseJavaTest.writeFile(workdir, grammarFileName, grammarStr);
+		writeFile(workdir, grammarFileName, grammarStr);
 		return antlrOnString(workdir, targetName, grammarFileName, defaultListener, extraOptions);
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -9,6 +9,8 @@
 import org.antlr.v4.test.runtime.python.BasePythonTest;
 import org.stringtemplate.v4.ST;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
+
 public class BasePython2Test extends BasePythonTest {
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -8,6 +8,8 @@
 import org.antlr.v4.test.runtime.python.BasePythonTest;
 import org.stringtemplate.v4.ST;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
+
 public class BasePython3Test extends BasePythonTest {
 
 	@Override

File: tool-testsuite/test/org/antlr/v4/test/tool/TestCompositeGrammars.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.io.File;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
@@ -460,7 +461,7 @@ public void testImportLargeGrammar() throws Exception {
 		BaseRuntimeTest.mkdir(tmpdir);
 		writeFile(tmpdir, "Java.g4", slave);
 		String found = execParser("NewJava.g4", master, "NewJavaParser", "NewJavaLexer",
-		                          null, null, "compilationUnit", "package Foo;", debug);
+					  null, null, "compilationUnit", "package Foo;", debug);
 		assertEquals(null, found);
 		assertNull(stderrDuringParse);
 	}
@@ -488,7 +489,7 @@ public void testImportLeftRecursiveGrammar() throws Exception {
 		BaseRuntimeTest.mkdir(tmpdir);
 		writeFile(tmpdir, "Java.g4", slave);
 		String found = execParser("T.g4", master, "TParser", "TLexer",
-		                          null, null, "s", "a=b", debug);
+					  null, null, "s", "a=b", debug);
 		assertEquals(null, found);
 		assertNull(stderrDuringParse);
 	}

File: tool-testsuite/test/org/antlr/v4/test/tool/TestPerformance.java
Patch:
@@ -78,6 +78,7 @@
 import java.util.logging.Logger;
 import org.antlr.v4.runtime.misc.MurmurHash;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;

File: tool-testsuite/test/org/antlr/v4/test/tool/TestCompositeGrammars.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.io.File;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
@@ -460,7 +461,7 @@ public void testImportLargeGrammar() throws Exception {
 		BaseRuntimeTest.mkdir(tmpdir);
 		writeFile(tmpdir, "Java.g4", slave);
 		String found = execParser("NewJava.g4", master, "NewJavaParser", "NewJavaLexer",
-		                          null, null, "compilationUnit", "package Foo;", debug);
+					  null, null, "compilationUnit", "package Foo;", debug);
 		assertEquals(null, found);
 		assertNull(stderrDuringParse);
 	}
@@ -488,7 +489,7 @@ public void testImportLeftRecursiveGrammar() throws Exception {
 		BaseRuntimeTest.mkdir(tmpdir);
 		writeFile(tmpdir, "Java.g4", slave);
 		String found = execParser("T.g4", master, "TParser", "TLexer",
-		                          null, null, "s", "a=b", debug);
+					  null, null, "s", "a=b", debug);
 		assertEquals(null, found);
 		assertNull(stderrDuringParse);
 	}

File: tool-testsuite/test/org/antlr/v4/test/tool/TestPerformance.java
Patch:
@@ -78,6 +78,7 @@
 import java.util.logging.Logger;
 import org.antlr.v4.runtime.misc.MurmurHash;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -224,7 +224,7 @@ public static ErrorQueue antlrOnString(String workdir,
 	                                       String... extraOptions)
 	{
 		mkdir(workdir);
-		BaseJavaTest.writeFile(workdir, grammarFileName, grammarStr);
+		writeFile(workdir, grammarFileName, grammarStr);
 		return antlrOnString(workdir, targetName, grammarFileName, defaultListener, extraOptions);
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -9,6 +9,8 @@
 import org.antlr.v4.test.runtime.python.BasePythonTest;
 import org.stringtemplate.v4.ST;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
+
 public class BasePython2Test extends BasePythonTest {
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -8,6 +8,8 @@
 import org.antlr.v4.test.runtime.python.BasePythonTest;
 import org.stringtemplate.v4.ST;
 
+import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;
+
 public class BasePython3Test extends BasePythonTest {
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseCSharpTest.java
Patch:
@@ -409,7 +409,7 @@ private String locateExec() {
 	}
 
 	private String locateTool(String tool) {
-		String[] roots = { "/opt/local/bin/", "/usr/bin/", "/usr/local/bin/" };
+		String[] roots = { "/opt/local/bin/", "/usr/local/bin/", "/usr/bin/" };
 		for(String root : roots) {
 			if(new File(root + tool).exists())
 				return root + tool;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/BaseSwiftTest.java
Patch:
@@ -57,7 +57,7 @@ public class BaseSwiftTest implements RuntimeTestSupport {
 		//add antlr.swift
 		final ClassLoader loader = Thread.currentThread().getContextClassLoader();
 
-		final URL swiftRuntime = loader.getResource("Swift/Antlr4");
+		final URL swiftRuntime = loader.getResource("Swift/Sources/Antlr4");
 		if (swiftRuntime == null) {
 			throw new RuntimeException("Swift runtime file not found at:" + swiftRuntime.getPath());
 		}

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSerializer.java
Patch:
@@ -340,6 +340,7 @@ else if ( s instanceof BlockStartState ) {
 			}
 		}
 
+		// Note: This value shifting loop is documented in ATNDeserializer.
 		// don't adjust the first value since that's the version number
 		for (int i = 1; i < data.size(); i++) {
 			if (data.get(i) < Character.MIN_VALUE || data.get(i) > Character.MAX_VALUE) {

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -252,6 +252,7 @@ public void setTokenSource(TokenSource tokenSource) {
         this.tokenSource = tokenSource;
         tokens.clear();
         p = -1;
+        fetchedEOF = false;
     }
 
     public List<Token> getTokens() { return tokens; }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserErrorsDescriptors.java
Patch:
@@ -135,7 +135,7 @@ public static class InvalidATNStateRemoval extends BaseParserTestDescriptor {
 	public static class InvalidEmptyInput extends BaseParserTestDescriptor {
 		public String input = "";
 		public String output = null;
-		public String errors = "line 1:0 missing ID at '<EOF>'\n";
+		public String errors = "line 1:0 mismatched input '<EOF>' expecting ID\n";
 		public String startRule = "start";
 		public String grammarName = "T";
 
@@ -414,7 +414,7 @@ public static class SingleTokenDeletionBeforeLoop extends BaseParserTestDescript
 
 		/**
 		 grammar T;
-		 a : 'a' 'b'* ;
+		 a : 'a' 'b'* EOF ;
 		 */
 		@CommentHasStringValue
 		public String grammar;
@@ -436,7 +436,7 @@ public static class SingleTokenDeletionBeforeLoop2 extends BaseParserTestDescrip
 
 		/**
 		 grammar T;
-		 a : 'a' ('b'|'z'{<Pass()>})*;
+		 a : 'a' ('b'|'z'{<Pass()>})* EOF ;
 		 */
 		@CommentHasStringValue
 		public String grammar;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -113,7 +113,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp").contains(targetName);
 		}
 	}
 
@@ -199,7 +199,7 @@ public static class DropLoopEntryBranchInLRRule_4 extends DropLoopEntryBranchInL
 		@Override
 		public boolean ignore(String targetName) {
 			// passes, but still too slow in Python and JavaScript
-			return !Arrays.asList("Java", "CSharp").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Cpp").contains(targetName);
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserErrorsDescriptors.java
Patch:
@@ -135,7 +135,7 @@ public static class InvalidATNStateRemoval extends BaseParserTestDescriptor {
 	public static class InvalidEmptyInput extends BaseParserTestDescriptor {
 		public String input = "";
 		public String output = null;
-		public String errors = "line 1:0 missing ID at '<EOF>'\n";
+		public String errors = "line 1:0 mismatched input '<EOF>' expecting ID\n";
 		public String startRule = "start";
 		public String grammarName = "T";
 
@@ -414,7 +414,7 @@ public static class SingleTokenDeletionBeforeLoop extends BaseParserTestDescript
 
 		/**
 		 grammar T;
-		 a : 'a' 'b'* ;
+		 a : 'a' 'b'* EOF ;
 		 */
 		@CommentHasStringValue
 		public String grammar;
@@ -436,7 +436,7 @@ public static class SingleTokenDeletionBeforeLoop2 extends BaseParserTestDescrip
 
 		/**
 		 grammar T;
-		 a : 'a' ('b'|'z'{<Pass()>})*;
+		 a : 'a' ('b'|'z'{<Pass()>})* EOF ;
 		 */
 		@CommentHasStringValue
 		public String grammar;

File: tool/src/org/antlr/v4/codegen/OutputModelController.java
Patch:
@@ -400,7 +400,7 @@ public CodeBlockForAlt epsilon(Alternative alt, boolean outerMost) {
 	public List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST) {
 		List<SrcOp> ops = delegate.wildcard(ast, labelAST);
 		for (CodeGeneratorExtension ext : extensions) {
-			ops = ext.set(ops);
+			ops = ext.wildcard(ops);
 		}
 		return ops;
 	}

File: tool/src/org/antlr/v4/codegen/ParserFactory.java
Patch:
@@ -33,6 +33,7 @@
 import org.antlr.v4.codegen.model.SrcOp;
 import org.antlr.v4.codegen.model.StarBlock;
 import org.antlr.v4.codegen.model.TestSetInline;
+import org.antlr.v4.codegen.model.Wildcard;
 import org.antlr.v4.codegen.model.decl.Decl;
 import org.antlr.v4.codegen.model.decl.RuleContextDecl;
 import org.antlr.v4.codegen.model.decl.TokenDecl;

File: tool/src/org/antlr/v4/codegen/model/Wildcard.java
Patch:
@@ -4,9 +4,9 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.codegen;
+package org.antlr.v4.codegen.model;
 
-import org.antlr.v4.codegen.model.MatchToken;
+import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.tool.ast.GrammarAST;
 
 public class Wildcard extends MatchToken {

File: tool/src/org/antlr/v4/codegen/OutputModelController.java
Patch:
@@ -400,7 +400,7 @@ public CodeBlockForAlt epsilon(Alternative alt, boolean outerMost) {
 	public List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST) {
 		List<SrcOp> ops = delegate.wildcard(ast, labelAST);
 		for (CodeGeneratorExtension ext : extensions) {
-			ops = ext.set(ops);
+			ops = ext.wildcard(ops);
 		}
 		return ops;
 	}

File: tool/src/org/antlr/v4/codegen/ParserFactory.java
Patch:
@@ -33,6 +33,7 @@
 import org.antlr.v4.codegen.model.SrcOp;
 import org.antlr.v4.codegen.model.StarBlock;
 import org.antlr.v4.codegen.model.TestSetInline;
+import org.antlr.v4.codegen.model.Wildcard;
 import org.antlr.v4.codegen.model.decl.Decl;
 import org.antlr.v4.codegen.model.decl.RuleContextDecl;
 import org.antlr.v4.codegen.model.decl.TokenDecl;

File: tool/src/org/antlr/v4/codegen/model/Wildcard.java
Patch:
@@ -4,9 +4,9 @@
  * can be found in the LICENSE.txt file in the project root.
  */
 
-package org.antlr.v4.codegen;
+package org.antlr.v4.codegen.model;
 
-import org.antlr.v4.codegen.model.MatchToken;
+import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.tool.ast.GrammarAST;
 
 public class Wildcard extends MatchToken {

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -372,7 +372,7 @@ public List<Token> getHiddenTokensToRight(int tokenIndex, int channel) {
 
 	/** Collect all hidden tokens (any off-default channel) to the right of
 	 *  the current token up until we see a token on DEFAULT_TOKEN_CHANNEL
-	 *  of EOF.
+	 *  or EOF.
 	 */
 	public List<Token> getHiddenTokensToRight(int tokenIndex) {
 		return getHiddenTokensToRight(tokenIndex, -1);

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -372,7 +372,7 @@ public List<Token> getHiddenTokensToRight(int tokenIndex, int channel) {
 
 	/** Collect all hidden tokens (any off-default channel) to the right of
 	 *  the current token up until we see a token on DEFAULT_TOKEN_CHANNEL
-	 *  of EOF.
+	 *  or EOF.
 	 */
 	public List<Token> getHiddenTokensToRight(int tokenIndex) {
 		return getHiddenTokensToRight(tokenIndex, -1);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -113,7 +113,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp").contains(targetName);
 		}
 	}
 
@@ -199,7 +199,7 @@ public static class DropLoopEntryBranchInLRRule_4 extends DropLoopEntryBranchInL
 		@Override
 		public boolean ignore(String targetName) {
 			// passes, but still too slow in Python and JavaScript
-			return !Arrays.asList("Java", "CSharp").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Cpp").contains(targetName);
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift");
 		}
 	}
 

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -112,6 +112,7 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 	public boolean gen_visitor = false;
 	public boolean gen_dependencies = false;
 	public String genPackage = null;
+	public String exportMacro = null; // C++ specific, need to allow setting a macro to set declspec for generated classes for VC++.
 	public Map<String, String> grammarOptions = null;
 	public boolean warnings_are_errors = false;
 	public boolean longMessages = false;
@@ -128,6 +129,7 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 		new Option("gen_visitor",		"-visitor", "generate parse tree visitor"),
 		new Option("gen_visitor",		"-no-visitor", "don't generate parse tree visitor (default)"),
 		new Option("genPackage",		"-package", OptionArgType.STRING, "specify a package/namespace for the generated code"),
+		new Option("exportMacro",		"-export-macro", OptionArgType.STRING, "C++ only, specify a macro for import/export of generated classes"),
 		new Option("gen_dependencies",	"-depend", "generate file dependencies"),
 		new Option("",					"-D<option>=value", "set/override a grammar-level option"),
 		new Option("warnings_are_errors", "-Werror", "treat warnings as errors"),

File: tool/src/org/antlr/v4/codegen/model/LexerFile.java
Patch:
@@ -12,6 +12,7 @@
 
 public class LexerFile extends OutputFile {
 	public String genPackage; // from -package cmd-line
+	public String exportMacro; // from -DexportMacro cmd-line
 	public boolean genListener; // from -listener cmd-line
 	public boolean genVisitor; // from -visitor cmd-line
 	@ModelElement public Lexer lexer;
@@ -21,6 +22,7 @@ public LexerFile(OutputModelFactory factory, String fileName) {
 		super(factory, fileName);
 		namedActions = buildNamedActions(factory.getGrammar());
 		genPackage = factory.getGrammar().tool.genPackage;
+		exportMacro = factory.getGrammar().getOptionString("exportMacro");
 		genListener = factory.getGrammar().tool.gen_listener;
 		genVisitor = factory.getGrammar().tool.gen_visitor;
 	}

File: tool/src/org/antlr/v4/codegen/model/ListenerFile.java
Patch:
@@ -23,6 +23,7 @@
  */
 public class ListenerFile extends OutputFile {
 	public String genPackage; // from -package cmd-line
+	public String exportMacro; // from -DexportMacro cmd-line
 	public String grammarName;
 	public String parserName;
 	/**
@@ -61,5 +62,6 @@ public ListenerFile(OutputModelFactory factory, String fileName) {
 		ActionAST ast = g.namedActions.get("header");
 		if ( ast!=null ) header = new Action(factory, ast);
 		genPackage = factory.getGrammar().tool.genPackage;
+		exportMacro = factory.getGrammar().getOptionString("exportMacro");
 	}
 }

File: tool/src/org/antlr/v4/codegen/model/ParserFile.java
Patch:
@@ -16,6 +16,7 @@
 /** */
 public class ParserFile extends OutputFile {
 	public String genPackage; // from -package cmd-line
+	public String exportMacro; // from -DexportMacro cmd-line
 	public boolean genListener; // from -listener cmd-line
 	public boolean genVisitor; // from -visitor cmd-line
 	@ModelElement public Parser parser;
@@ -28,6 +29,7 @@ public ParserFile(OutputModelFactory factory, String fileName) {
 		Grammar g = factory.getGrammar();
 		namedActions = buildNamedActions(factory.getGrammar());
 		genPackage = g.tool.genPackage;
+		exportMacro = factory.getGrammar().getOptionString("exportMacro");
 		// need the below members in the ST for Python, C++
 		genListener = g.tool.gen_listener;
 		genVisitor = g.tool.gen_visitor;

File: tool/src/org/antlr/v4/codegen/model/VisitorFile.java
Patch:
@@ -20,6 +20,7 @@
 
 public class VisitorFile extends OutputFile {
 	public String genPackage; // from -package cmd-line
+	public String exportMacro; // from -DexportMacro cmd-line
 	public String grammarName;
 	public String parserName;
 	/**
@@ -58,5 +59,6 @@ public VisitorFile(OutputModelFactory factory, String fileName) {
 		ActionAST ast = g.namedActions.get("header");
 		if ( ast!=null ) header = new Action(factory, ast);
 		genPackage = factory.getGrammar().tool.genPackage;
+		exportMacro = factory.getGrammar().getOptionString("exportMacro");
 	}
 }

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -471,7 +471,7 @@ protected void enterLabeledLexerElement(GrammarAST tree) {
 	protected void enterTerminal(GrammarAST tree) {
 		String text = tree.getText();
 		if (text.equals("''")) {
-			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_NOT_ALLOWED, g.fileName, tree.token);
+			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED, g.fileName, tree.token, "''");
 		}
 	}
 

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -81,6 +81,7 @@ public class Grammar implements AttributeResolver {
 		parserOptions.add("TokenLabelType");
 		parserOptions.add("tokenVocab");
 		parserOptions.add("language");
+		parserOptions.add("exportMacro");
 	}
 
 	public static final Set<String> lexerOptions = parserOptions;

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -471,7 +471,7 @@ protected void enterLabeledLexerElement(GrammarAST tree) {
 	protected void enterTerminal(GrammarAST tree) {
 		String text = tree.getText();
 		if (text.equals("''")) {
-			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_NOT_ALLOWED, g.fileName, tree.token);
+			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED, g.fileName, tree.token, "''");
 		}
 	}
 

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -1034,7 +1034,7 @@ public enum ErrorType {
 	/**
 	 * Compiler Warning 180.
 	 *
-	 * <p>chars "a-f" declared multiply times in set [a-fc-m]</p>
+	 * <p>chars "a-f" used multiple times in set [a-fc-m]</p>
 	 *
 	 * <pre>
 	 * A:    [aa-z];   // warning
@@ -1043,7 +1043,7 @@ public enum ErrorType {
 	 *
 	 * TODO: Does not work with fragment rules.
 	 */
-	CHARACTERS_COLLISION_IN_SET(180, "chars \"<arg>\" declared multiply times in set <arg2>", ErrorSeverity.WARNING),
+	CHARACTERS_COLLISION_IN_SET(180, "chars \"<arg>\" used multiple times in set <arg2>", ErrorSeverity.WARNING),
 
 	/*
 	 * Backward incompatibility errors

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -471,7 +471,7 @@ protected void enterLabeledLexerElement(GrammarAST tree) {
 	protected void enterTerminal(GrammarAST tree) {
 		String text = tree.getText();
 		if (text.equals("''")) {
-			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED, g.fileName, tree.token);
+			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED, g.fileName, tree.token, "''");
 		}
 	}
 

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -471,7 +471,7 @@ protected void enterLabeledLexerElement(GrammarAST tree) {
 	protected void enterTerminal(GrammarAST tree) {
 		String text = tree.getText();
 		if (text.equals("''")) {
-			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_NOT_ALLOWED, g.fileName, tree.token);
+			g.tool.errMgr.grammarError(ErrorType.EMPTY_STRINGS_AND_SETS_NOT_ALLOWED, g.fileName, tree.token);
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -565,13 +565,15 @@ private boolean buildRuntime() {
 		}
 		catch (Exception e) {
 			System.err.println("can't compile antlr cpp runtime");
+			e.printStackTrace(System.err);
 			try {
 			    String command[] = { "ls", "-la" };
 					String output = runCommand(command, runtimePath + "/dist/", "printing library folder content", true);
 				System.out.println(output);
 			}
 			catch (Exception e2) {
 				System.err.println("can't even list folder content");
+				e2.printStackTrace(System.err);
 			}
 		}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3|Node");
+			return !targetName.matches("Java|Python2|Python3|Node|Swift");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -113,7 +113,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node").contains(targetName);
+			return !Arrays.asList("Java", "CSharp", "Python2", "Python3", "Node", "Cpp").contains(targetName);
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.matches("Java|Python2|Python3");
+			return !targetName.matches("Java|Python2|Python3|Node");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.equals("Java");
+			return !targetName.matches("Java|Python2|Python3");
 		}
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -69,7 +69,7 @@ public Map<String, Integer> getTokenTypeMap() {
 			Map<String, Integer> result = tokenTypeMapCache.get(vocabulary);
 			if (result == null) {
 				result = new HashMap<String, Integer>();
-				for (int i = 0; i < getATN().maxTokenType; i++) {
+				for (int i = 0; i <= getATN().maxTokenType; i++) {
 					String literalName = vocabulary.getLiteralName(i);
 					if (literalName != null) {
 						result.put(literalName, i);

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -69,7 +69,7 @@ public Map<String, Integer> getTokenTypeMap() {
 			Map<String, Integer> result = tokenTypeMapCache.get(vocabulary);
 			if (result == null) {
 				result = new HashMap<String, Integer>();
-				for (int i = 0; i < getATN().maxTokenType; i++) {
+				for (int i = 0; i <= getATN().maxTokenType; i++) {
 					String literalName = vocabulary.getLiteralName(i);
 					if (literalName != null) {
 						result.put(literalName, i);

File: runtime/Java/src/org/antlr/v4/runtime/CommonTokenStream.java
Patch:
@@ -77,7 +77,7 @@ protected Token LB(int k) {
         int i = p;
         int n = 1;
         // find k good tokens looking backwards
-        while ( n<=k ) {
+        while ( n<=k && i>0 ) {
             // skip off-channel tokens
             i = previousTokenOnChannel(i - 1, channel);
             n++;

File: tool/src/org/antlr/v4/analysis/AnalysisPipeline.java
Patch:
@@ -34,7 +34,8 @@ public void process() {
 
 		if (g.isLexer()) {
 			processLexer();
-		} else {
+		}
+		else {
 			// BUILD DFA FOR EACH DECISION
 			processParser();
 		}

File: tool/src/org/antlr/v4/analysis/AnalysisPipeline.java
Patch:
@@ -34,7 +34,8 @@ public void process() {
 
 		if (g.isLexer()) {
 			processLexer();
-		} else {
+		}
+		else {
 			// BUILD DFA FOR EACH DECISION
 			processParser();
 		}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -112,7 +112,7 @@ public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.equals("Java");
+			return !targetName.matches("Java|Python2|Python3");
 		}
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -110,6 +110,7 @@ protected void succeeded(Description description) {
 
 	@Test
 	public void testOne() throws Exception {
+		// System.out.println(delegate.getTmpDir());
 		if ( descriptor.ignore(descriptor.getTarget()) ) {
 			System.out.printf("Ignore "+descriptor);
 			return;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -110,6 +110,7 @@ protected void succeeded(Description description) {
 
 	@Test
 	public void testOne() throws Exception {
+		// System.out.println(delegate.getTmpDir());
 		if ( descriptor.ignore(descriptor.getTarget()) ) {
 			System.out.printf("Ignore "+descriptor);
 			return;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -74,9 +74,9 @@ public static class ExtraToken extends BaseParserTestDescriptor {
 
 	}
 
-	public static class ExtraTokensShouldBeInTree extends BaseParserTestDescriptor {
+	public static class ExtraTokensAndAltLabels extends BaseParserTestDescriptor {
 		public String input = "${ ? a ?}";
-		public String output = "(s ${ ? (v a) ? })\n";
+		public String output = "(s ${ (v ? a) ? })\n";
 		public String errors =
 			"line 1:3 extraneous input '?' expecting {'a', 'b'}\n"+
 			"line 1:7 extraneous input '?' expecting '}'\n";

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4ErrorLog.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.mojo.antlr4;

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/MojoUtils.java
Patch:
@@ -1,16 +1,15 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 
 package org.antlr.mojo.antlr4;
 
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.InputStream;
 import java.io.IOException;
-
+import java.io.InputStream;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 

File: runtime-testsuite-legacy/src/org/antlr/v4/testgen/DescrGenerator.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.testgen;

File: runtime-testsuite-legacy/src/org/antlr/v4/testgen/JavaEscapeStringMap.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.testgen;

File: runtime-testsuite-legacy/src/org/antlr/v4/testgen/LinesStringMap.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.testgen;

File: runtime-testsuite-legacy/src/org/antlr/v4/testgen/STGroupModelAdaptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.testgen;

File: runtime-testsuite-legacy/src/org/antlr/v4/testgen/StrlenStringMap.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.testgen;

File: runtime-testsuite-legacy/src/org/antlr/v4/testgen/TestGenerator.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.testgen;

File: runtime-testsuite/annotations/src/org/antlr/v4/test/runtime/CommentHasStringValue.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/processors/src/org/antlr/v4/test/runtime/CommentHasStringValueProcessor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseCompositeLexerTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseCompositeParserTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseDiagnosticParserTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseLexerTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseParserTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/ErrorQueue.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeTestSupport.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/SpecialRuntimeTestAssert.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.cpp;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseCSharpTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.csharp;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeLexersDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeParsersDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/FullContextParsingDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/LeftRecursionDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/LexerErrorsDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/LexerExecDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ListenersDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParseTreesDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserErrorsDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/ParserExecDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexerDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SemPredEvalParserDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SetsDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/VisitorsDescriptors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseGoTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.go;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/BaseJavaTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.java;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/browser/BaseBrowserTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.javascript.browser;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/BaseChromeTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.javascript.chrome;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/SharedWebDriver.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/chrome/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/BaseExplorerTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.javascript.explorer;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/explorer/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/BaseFirefoxTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.javascript.firefox;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/SharedWebDriver.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/firefox/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/BaseNodeTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.javascript.node;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/BaseSafariTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.javascript.safari;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/SharedWebDriver.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/safari/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python/BasePythonTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.python;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 package org.antlr.v4.test.runtime.python3;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/BaseSwiftTest.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestCompositeLexers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestCompositeParsers.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestFullContextParsing.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLeftRecursion.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 
@@ -9,8 +9,6 @@
 import org.antlr.v4.test.runtime.BaseRuntimeTest;
 import org.antlr.v4.test.runtime.RuntimeTestDescriptor;
 import org.antlr.v4.test.runtime.descriptors.LexerErrorsDescriptors;
-import org.junit.Test;
-import org.junit.Ignore;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestLexerExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestListeners.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParseTrees.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParserErrors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestParserExec.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestPerformance.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSemPredEvalLexer.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSemPredEvalParser.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestSets.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestVisitors.java
Patch:
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012 The ANTLR Project Contributors. All rights reserved.
- * Use is of this file is governed by the BSD 3-clause license that
+ * Use of this file is governed by the BSD 3-clause license that
  * can be found in the LICENSE.txt file in the project root.
  */
 

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -1024,15 +1024,15 @@ public enum ErrorType {
 	 *
 	 * <p><em>name</em>is not a recognized mode name</p>
 	 *
-	 * <pre>TOKEN: 'a' -> channel(MODE1); // error 176</pre>
+	 * <pre>TOKEN: 'a' -> mode(MODE1); // error 176</pre>
 	 */
 	CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_MODE_NAME(176, "<arg> is not a recognized mode name", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 177.
 	 *
 	 * <p><em>name</em> is not a recognized channel name</p>
 	 *
-	 * <pre>TOKEN: 'a' -> mode(TOKEN1); // error 177</pre>
+	 * <pre>TOKEN: 'a' -> channel(TOKEN1); // error 177</pre>
 	 */
 	CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME(177, "<arg> is not a recognized channel name", ErrorSeverity.ERROR),
 	/*

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -657,8 +657,8 @@ public void testSetUp() throws Exception {
 			"WHITESPACE: [ \\t]+      -> channel(WHITESPACE_CHANNEL);\n";
 
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:10:35: rule COMMENT contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n" +
-			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:11:35: rule WHITESPACE contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:10:35: COMMENT_CHANNEL is not a recognized channel name\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:11:35: WHITESPACE_CHANNEL is not a recognized channel name\n" +
 			"error(" + ErrorType.CHANNELS_BLOCK_IN_COMBINED_GRAMMAR.code + "): T.g4:3:0: custom channels are not supported in combined grammars\n";
 
 		String[] pair = { grammar, expected };
@@ -686,7 +686,7 @@ public void testSetUp() throws Exception {
 
 		// WHITESPACE_CHANNEL and COMMENT_CHANNEL are defined, but NEWLINE_CHANNEL is not
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:10:34: rule NEWLINE contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n";
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:10:34: NEWLINE_CHANNEL is not a recognized channel name\n";
 
 		String[] pair = { grammar, expected };
 		super.testErrors(pair, true);

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -293,7 +293,7 @@ void assignChannelTypes(Grammar g, List<GrammarAST> channelDefs) {
 			}
 
 			if (LexerATNFactory.COMMON_CONSTANTS.containsKey(channelName)) {
-				g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, channel.token, channelName);
+				g.tool.errMgr.grammarError(ErrorType.CHANNEL_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, channel.token, channelName);
 			}
 
 			if (outermost instanceof LexerGrammar) {

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -278,7 +278,7 @@ public void checkForModeConflicts(Grammar g) {
 			for (String modeName : lexerGrammar.modes.keySet()) {
 				if (!modeName.equals("DEFAULT_MODE") && reservedNames.contains(modeName)) {
 					Rule rule = lexerGrammar.modes.get(modeName).iterator().next();
-					g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
+					g.tool.errMgr.grammarError(ErrorType.MODE_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
 				}
 
 				if (g.getTokenType(modeName) != Token.INVALID_TYPE) {

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -657,8 +657,8 @@ public void testSetUp() throws Exception {
 			"WHITESPACE: [ \\t]+      -> channel(WHITESPACE_CHANNEL);\n";
 
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:35: rule COMMENT contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:11:35: rule WHITESPACE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:10:35: COMMENT_CHANNEL is not a recognized channel name\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:11:35: WHITESPACE_CHANNEL is not a recognized channel name\n" +
 			"error(" + ErrorType.CHANNELS_BLOCK_IN_COMBINED_GRAMMAR.code + "): T.g4:3:0: custom channels are not supported in combined grammars\n";
 
 		String[] pair = { grammar, expected };
@@ -686,7 +686,7 @@ public void testSetUp() throws Exception {
 
 		// WHITESPACE_CHANNEL and COMMENT_CHANNEL are defined, but NEWLINE_CHANNEL is not
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:34: rule NEWLINE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n";
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:10:34: NEWLINE_CHANNEL is not a recognized channel name\n";
 
 		String[] pair = { grammar, expected };
 		super.testErrors(pair, true);

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -240,9 +240,9 @@ public void testSetUp() throws Exception {
 			"mode MODE1;\n" +
 			"MODE1_TOKEN: 'qwer';",
 
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): L.g4:4:22: rule TOKEN contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): L.g4:4:41: rule TOKEN contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): L.g4:4:54: rule TOKEN contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n"
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_TOKEN_NAME.code + "): L.g4:4:22: CHANNEL1 is not a recognized token name\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): L.g4:4:41: MODE1 is not a recognized channel name\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_MODE_NAME.code + "): L.g4:4:54: TOKEN1 is not a recognized mode name\n"
 		};
 
 		testErrors(test, false);

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -657,8 +657,8 @@ public void testSetUp() throws Exception {
 			"WHITESPACE: [ \\t]+      -> channel(WHITESPACE_CHANNEL);\n";
 
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:35: rule COMMENT contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:11:35: rule WHITESPACE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:10:35: COMMENT_CHANNEL is not a recognized channel name\n" +
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:11:35: WHITESPACE_CHANNEL is not a recognized channel name\n" +
 			"error(" + ErrorType.CHANNELS_BLOCK_IN_COMBINED_GRAMMAR.code + "): T.g4:3:0: custom channels are not supported in combined grammars\n";
 
 		String[] pair = { grammar, expected };
@@ -686,7 +686,7 @@ public void testSetUp() throws Exception {
 
 		// WHITESPACE_CHANNEL and COMMENT_CHANNEL are defined, but NEWLINE_CHANNEL is not
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:34: rule NEWLINE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n";
+			"error(" + ErrorType.CONSTANT_VALUE_IS_NOT_A_RECOGNIZED_CHANNEL_NAME.code + "): T.g4:10:34: NEWLINE_CHANNEL is not a recognized channel name\n";
 
 		String[] pair = { grammar, expected };
 		super.testErrors(pair, true);

File: tool-testsuite/test/org/antlr/v4/test/tool/TestTokenStreamRewriter.java
Patch:
@@ -889,9 +889,8 @@ public void testSetUp() throws Exception {
 		assertEquals(expecting, result);
 	}
 
-	// Test for https://github.com/antlr/antlr4/issues/550
+	// Test Fix for https://github.com/antlr/antlr4/issues/550
 	@Test
-	@Ignore
 	public void testPreservesOrderOfContiguousInserts() throws Exception {
 		LexerGrammar g = new LexerGrammar(
 											 "lexer grammar T;\n"+

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -3,6 +3,8 @@
 import org.antlr.v4.test.runtime.BaseParserTestDescriptor;
 import org.antlr.v4.test.runtime.CommentHasStringValue;
 
+import java.util.Arrays;
+
 public class PerformanceDescriptors {
 	/*
 	 * This is a regression test for antlr/antlr4#192 "Poor performance of
@@ -105,7 +107,7 @@ public static abstract class DropLoopEntryBranchInLRRule extends BaseParserTestD
 
 		@Override
 		public boolean ignore(String targetName) {
-			return !targetName.equals("Java");
+			return !Arrays.asList("Java", "Python2", "Python3", "Node").contains(targetName);
 		}
 	}
 

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -657,8 +657,8 @@ public void testSetUp() throws Exception {
 			"WHITESPACE: [ \\t]+      -> channel(WHITESPACE_CHANNEL);\n";
 
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:10:35: rule COMMENT contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n" +
-			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:11:35: rule WHITESPACE contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n" +
+			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:35: rule COMMENT contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
+			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:11:35: rule WHITESPACE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
 			"error(" + ErrorType.CHANNELS_BLOCK_IN_COMBINED_GRAMMAR.code + "): T.g4:3:0: custom channels are not supported in combined grammars\n";
 
 		String[] pair = { grammar, expected };
@@ -686,7 +686,7 @@ public void testSetUp() throws Exception {
 
 		// WHITESPACE_CHANNEL and COMMENT_CHANNEL are defined, but NEWLINE_CHANNEL is not
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:10:34: rule NEWLINE contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n";
+			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:34: rule NEWLINE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n";
 
 		String[] pair = { grammar, expected };
 		super.testErrors(pair, true);

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -293,7 +293,7 @@ void assignChannelTypes(Grammar g, List<GrammarAST> channelDefs) {
 			}
 
 			if (LexerATNFactory.COMMON_CONSTANTS.containsKey(channelName)) {
-				g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, channel.token, channelName);
+				g.tool.errMgr.grammarError(ErrorType.CHANNEL_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, channel.token, channelName);
 			}
 
 			if (outermost instanceof LexerGrammar) {

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -278,12 +278,12 @@ public void checkForModeConflicts(Grammar g) {
 			for (String modeName : lexerGrammar.modes.keySet()) {
 				if (!modeName.equals("DEFAULT_MODE") && reservedNames.contains(modeName)) {
 					Rule rule = lexerGrammar.modes.get(modeName).iterator().next();
-					g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
+					g.tool.errMgr.grammarError(ErrorType.MODE_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
 				}
 
 				if (g.getTokenType(modeName) != Token.INVALID_TYPE) {
 					Rule rule = lexerGrammar.modes.get(modeName).iterator().next();
-					g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
+					g.tool.errMgr.grammarError(ErrorType.MODE_CONFLICTS_WITH_TOKEN, g.fileName, rule.ast.parent.getToken(), modeName);
 				}
 			}
 		}

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -127,7 +127,7 @@ public class TestSymbolIssues extends BaseJavaToolTest {
 		"M1: 'b';\n",
 
 		// YIELDS
-		"error(" + ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS.code + "): F.g4:3:0: cannot declare mode, token or channel with reserved name M1\n"
+		"error(" + ErrorType.MODE_CONFLICTS_WITH_TOKEN.code + "): F.g4:3:0: mode M1 conflicts with token with same name\n"
 	};
 
 	@Before

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -283,7 +283,7 @@ public void checkForModeConflicts(Grammar g) {
 
 				if (g.getTokenType(modeName) != Token.INVALID_TYPE) {
 					Rule rule = lexerGrammar.modes.get(modeName).iterator().next();
-					g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
+					g.tool.errMgr.grammarError(ErrorType.MODE_CONFLICTS_WITH_TOKEN, g.fileName, rule.ast.parent.getToken(), modeName);
 				}
 			}
 		}

File: tool-testsuite/test/org/antlr/v4/test/tool/TestToolSyntaxErrors.java
Patch:
@@ -657,8 +657,8 @@ public void testSetUp() throws Exception {
 			"WHITESPACE: [ \\t]+      -> channel(WHITESPACE_CHANNEL);\n";
 
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:35: rule COMMENT contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:11:35: rule WHITESPACE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n" +
+			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:10:35: rule COMMENT contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n" +
+			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:11:35: rule WHITESPACE contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n" +
 			"error(" + ErrorType.CHANNELS_BLOCK_IN_COMBINED_GRAMMAR.code + "): T.g4:3:0: custom channels are not supported in combined grammars\n";
 
 		String[] pair = { grammar, expected };
@@ -686,7 +686,7 @@ public void testSetUp() throws Exception {
 
 		// WHITESPACE_CHANNEL and COMMENT_CHANNEL are defined, but NEWLINE_CHANNEL is not
 		String expected =
-			"warning(" + ErrorType.UNKNOWN_LEXER_CONSTANT.code + "): T.g4:10:34: rule NEWLINE contains a lexer command with an unrecognized constant value; lexer interpreters may produce incorrect output\n";
+			"warning(" + ErrorType.UNKNOWN_OR_WRONG_LEXER_CONSTANT.code + "): T.g4:10:34: rule NEWLINE contains a lexer command with an unrecognized or wrong constant value; lexer interpreters may produce incorrect output\n";
 
 		String[] pair = { grammar, expected };
 		super.testErrors(pair, true);

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -293,7 +293,7 @@ void assignChannelTypes(Grammar g, List<GrammarAST> channelDefs) {
 			}
 
 			if (LexerATNFactory.COMMON_CONSTANTS.containsKey(channelName)) {
-				g.tool.errMgr.grammarError(ErrorType.CHANNEL_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, channel.token, channelName);
+				g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, channel.token, channelName);
 			}
 
 			if (outermost instanceof LexerGrammar) {

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -278,12 +278,12 @@ public void checkForModeConflicts(Grammar g) {
 			for (String modeName : lexerGrammar.modes.keySet()) {
 				if (!modeName.equals("DEFAULT_MODE") && reservedNames.contains(modeName)) {
 					Rule rule = lexerGrammar.modes.get(modeName).iterator().next();
-					g.tool.errMgr.grammarError(ErrorType.MODE_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
+					g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
 				}
 
 				if (g.getTokenType(modeName) != Token.INVALID_TYPE) {
 					Rule rule = lexerGrammar.modes.get(modeName).iterator().next();
-					g.tool.errMgr.grammarError(ErrorType.MODE_CONFLICTS_WITH_TOKEN, g.fileName, rule.ast.parent.getToken(), modeName);
+					g.tool.errMgr.grammarError(ErrorType.DECLARATION_CONFLICTS_WITH_COMMON_CONSTANTS, g.fileName, rule.ast.parent.getToken(), modeName);
 				}
 			}
 		}

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeWalker.java
Patch:
@@ -34,7 +34,7 @@
 import org.antlr.v4.runtime.RuleContext;
 
 public class ParseTreeWalker {
-    public static final ParseTreeWalker DEFAULT = new IterativeParseTreeWalker();
+    public static final ParseTreeWalker DEFAULT = new ParseTreeWalker();
 
     public void walk(ParseTreeListener listener, ParseTree t) {
 		if ( t instanceof ErrorNode) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContext.java
Patch:
@@ -117,12 +117,13 @@ public static PredictionContext fromRuleContext(ATN atn, RuleContext outerContex
 
 	public abstract int getReturnState(int index);
 
-	/** This means only the {@link #EMPTY} context is in set. */
+	/** This means only the {@link #EMPTY} (wildcard? not sure) context is in set. */
 	public boolean isEmpty() {
 		return this == EMPTY;
 	}
 
 	public boolean hasEmptyPath() {
+		// since EMPTY_RETURN_STATE can only appear in the last position, we check last one
 		return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContext.java
Patch:
@@ -117,12 +117,13 @@ public static PredictionContext fromRuleContext(ATN atn, RuleContext outerContex
 
 	public abstract int getReturnState(int index);
 
-	/** This means only the {@link #EMPTY} context is in set. */
+	/** This means only the {@link #EMPTY} (wildcard? not sure) context is in set. */
 	public boolean isEmpty() {
 		return this == EMPTY;
 	}
 
 	public boolean hasEmptyPath() {
+		// since EMPTY_RETURN_STATE can only appear in the last position, we check last one
 		return getReturnState(size() - 1) == EMPTY_RETURN_STATE;
 	}
 

File: tool-testsuite/test/org/antlr/v4/test/tool/TestAttributeChecks.java
Patch:
@@ -64,7 +64,7 @@ public void testSetUp() throws Exception {
         "c   :   ;\n";
 
     String[] membersChecks = {
-		"$a",			"error(" + ErrorType.UNKNOWN_SIMPLE_ATTRIBUTE.code + "): A.g4:2:11: unknown attribute reference a in $a\n",
+	    "$a",			"error(" + ErrorType.UNKNOWN_SIMPLE_ATTRIBUTE.code + "): A.g4:2:11: unknown attribute reference a in $a\n",
         "$a.y",			"error(" + ErrorType.UNKNOWN_SIMPLE_ATTRIBUTE.code + "): A.g4:2:11: unknown attribute reference a in $a.y\n",
     };
 

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -83,11 +83,13 @@ public void process() {
 		ruleCollector.process(g.ast);
 
 		// DO BASIC / EASY SEMANTIC CHECKS
+		int prevErrors = g.tool.errMgr.getNumErrors();
 		BasicSemanticChecks basics = new BasicSemanticChecks(g, ruleCollector);
 		basics.process();
+		if ( g.tool.errMgr.getNumErrors()>prevErrors ) return;
 
 		// TRANSFORM LEFT-RECURSIVE RULES
-		int prevErrors = g.tool.errMgr.getNumErrors();
+		prevErrors = g.tool.errMgr.getNumErrors();
 		LeftRecursiveRuleTransformer lrtrans =
 			new LeftRecursiveRuleTransformer(g.ast, ruleCollector.rules.values(), g);
 		lrtrans.translateLeftRecursiveRules();

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeParsersDescriptors.java
Patch:
@@ -412,8 +412,8 @@ public static class DelegatorRuleOverridesLookaheadInDelegate extends BaseCompos
 		parser grammar S;
 		type_ : 'int' ;
 		decl : type_ ID ';'
-			| type_ ID init ';' {<write("\"JavaDecl: \" + $text")>};
-		init : '=' INT;
+			| type_ ID init_ ';' {<write("\"JavaDecl: \" + $text")>};
+		init_ : '=' INT;
 		 */
 		@CommentHasStringValue
 		public String slaveGrammarS;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseCSharpTest.java
Patch:
@@ -494,7 +494,7 @@ private String locateExec() {
 	}
 
 	private String locateTool(String tool) {
-		String[] roots = { "/usr/bin/", "/usr/local/bin/" };
+		String[] roots = { "/opt/local/bin/", "/usr/bin/", "/usr/local/bin/" };
 		for(String root : roots) {
 			if(new File(root + tool).exists())
 				return root + tool;

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -50,7 +50,7 @@
  *  The root node always has a null pointer and invokingState of -1.
  *
  *  Upon entry to parsing, the first invoked rule function creates a
- *  context object (asubclass specialized for that rule such as
+ *  context object (a subclass specialized for that rule such as
  *  SContext) and makes it the root of a parse tree, recorded by field
  *  Parser._ctx.
  *

File: runtime/Java/src/org/antlr/v4/runtime/misc/Array2DHashSet.java
Patch:
@@ -50,7 +50,7 @@ public class Array2DHashSet<T> implements Set<T> {
 	/** How many elements in set */
 	protected int n = 0;
 
-	protected int threshold = (int)(INITAL_CAPACITY * LOAD_FACTOR); // when to expand
+	protected int threshold = (int)Math.floor(INITAL_CAPACITY * LOAD_FACTOR); // when to expand
 
 	protected int currentPrime = 1; // jump by 4 primes each expand or whatever
 	protected int initialBucketCapacity = INITAL_BUCKET_CAPACITY;
@@ -407,6 +407,7 @@ public boolean removeAll(Collection<?> c) {
 	public void clear() {
 		buckets = createBuckets(INITAL_CAPACITY);
 		n = 0;
+		threshold = (int)Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
 	}
 
 	@Override

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -65,7 +65,7 @@ public class TestSymbolIssues extends BaseJavaTest {
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:10:20: implicit definition of token Y in parser\n" +
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:11:4: implicit definition of token FJKD in parser\n" +
 			"error(" + ErrorType.RULE_HAS_NO_ARGS.code + "): A.g4:9:37: rule b has no defined parameters\n" +
-			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing arguments(s) on rule reference: a\n"
+			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing argument(s) on rule reference: a\n"
     };
 
     static String[] B = {

File: tool/src/org/antlr/v4/codegen/model/ElementFrequenciesVisitor.java
Patch:
@@ -65,7 +65,7 @@ protected static FrequencySet<String> combineMax(FrequencySet<String> a, Frequen
 	 * @param b The second set.
 	 * @param clip The maximum value to allow for any output.
 	 * @return The sum of the two sets, with the individual elements clipped
-	 * to the maximum value gived by {@code clip}.
+	 * to the maximum value given by {@code clip}.
 	 */
 	protected static FrequencySet<String> combineAndClip(FrequencySet<String> a, FrequencySet<String> b, int clip) {
 		FrequencySet<String> result = new FrequencySet<String>();

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -120,7 +120,7 @@ public static <From,To> List<To> select(List<From> list, Func1<From, To> selecto
 		return b;
 	}
 
-	/** Find exact object type or sublass of cl in list */
+	/** Find exact object type or subclass of cl in list */
 	public static <T> T find(List<?> ops, Class<T> cl) {
 		for (Object o : ops) {
 			if ( cl.isInstance(o) ) return cl.cast(o);

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -157,7 +157,7 @@ public static void internalError(String error) {
     }
 
     /**
-     * Raise a predefined message with some number of paramters for the StringTemplate but for which there
+     * Raise a predefined message with some number of parameters for the StringTemplate but for which there
      * is no location information possible.
      * @param errorType The Message Descriptor
      * @param args The arguments to pass to the StringTemplate

File: tool/src/org/antlr/v4/tool/ErrorSeverity.java
Patch:
@@ -61,7 +61,7 @@ public enum ErrorSeverity {
     /**
      * Standard constructor to build an instance of the Enum entries
      *
-     * @param text The human readable string representing the serverity level
+     * @param text The human readable string representing the severity level
      */
     private ErrorSeverity(String text) { this.text = text; }
 }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -328,9 +328,9 @@ public enum ErrorType {
 	/**
 	 * Compiler Error 79.
 	 *
-	 * <p>missing arguments(s) on rule reference: <em>rule</em></p>
+	 * <p>missing argument(s) on rule reference: <em>rule</em></p>
 	 */
-	MISSING_RULE_ARGS(79, "missing arguments(s) on rule reference: <arg>", ErrorSeverity.ERROR),
+	MISSING_RULE_ARGS(79, "missing argument(s) on rule reference: <arg>", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 80.
 	 *

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/BaseTest.java
Patch:
@@ -119,7 +119,6 @@ public abstract class BaseTest {
 			throw new RuntimeException("Swift runtime file not found at:" + swiftRuntime.getPath());
 		}
 		String swiftRuntimePath = swiftRuntime.getPath();
-//		String swiftRuntimePath = "/Users/janyou/OSXWorks/AntlrSwift/Antlr4/Antlr4";
 
 		//get Antlr4 framework
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/swift/TestCompositeParsers.java
Patch:
@@ -332,8 +332,8 @@ public void testDelegatorRuleOverridesLookaheadInDelegate() throws Exception {
 			"parser grammar S;\n" +
 			"type_ : 'int' ;\n" +
 			"decl : type_ ID ';'\n" +
-			"	| type_ ID init ';' {print(\"JavaDecl: \" + $text, terminator: \"\")};\n" +
-			"init : '=' INT;";
+			"	| type_ ID init_ ';' {print(\"JavaDecl: \" + $text, terminator: \"\")};\n" +
+			"init_ : '=' INT;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(121);

File: runtime/Java/src/org/antlr/v4/runtime/misc/Array2DHashSet.java
Patch:
@@ -50,7 +50,7 @@ public class Array2DHashSet<T> implements Set<T> {
 	/** How many elements in set */
 	protected int n = 0;
 
-	protected int threshold = (int)(INITAL_CAPACITY * LOAD_FACTOR); // when to expand
+	protected int threshold = (int)Math.floor(INITAL_CAPACITY * LOAD_FACTOR); // when to expand
 
 	protected int currentPrime = 1; // jump by 4 primes each expand or whatever
 	protected int initialBucketCapacity = INITAL_BUCKET_CAPACITY;
@@ -407,6 +407,7 @@ public boolean removeAll(Collection<?> c) {
 	public void clear() {
 		buckets = createBuckets(INITAL_CAPACITY);
 		n = 0;
+		threshold = (int)Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
 	}
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -50,7 +50,7 @@
  *  The root node always has a null pointer and invokingState of -1.
  *
  *  Upon entry to parsing, the first invoked rule function creates a
- *  context object (asubclass specialized for that rule such as
+ *  context object (a subclass specialized for that rule such as
  *  SContext) and makes it the root of a parse tree, recorded by field
  *  Parser._ctx.
  *

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -65,7 +65,7 @@ public class TestSymbolIssues extends BaseJavaTest {
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:10:20: implicit definition of token Y in parser\n" +
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:11:4: implicit definition of token FJKD in parser\n" +
 			"error(" + ErrorType.RULE_HAS_NO_ARGS.code + "): A.g4:9:37: rule b has no defined parameters\n" +
-			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing arguments(s) on rule reference: a\n"
+			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing argument(s) on rule reference: a\n"
     };
 
     static String[] B = {

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -713,7 +713,7 @@ public void generateATNs(Grammar g) {
 	 *
 	 *  The output dir -o spec takes precedence if it's absolute.
 	 *  E.g., if the grammar file dir is absolute the output dir is given
-	 *  precendence. "-o /tmp /usr/lib/t.g4" results in "/tmp/T.java" as
+	 *  precedence. "-o /tmp /usr/lib/t.g4" results in "/tmp/T.java" as
 	 *  output (assuming t.g4 holds T.java).
 	 *
 	 *  If no -o is specified, then just write to the directory where the

File: tool/src/org/antlr/v4/codegen/model/ElementFrequenciesVisitor.java
Patch:
@@ -65,7 +65,7 @@ protected static FrequencySet<String> combineMax(FrequencySet<String> a, Frequen
 	 * @param b The second set.
 	 * @param clip The maximum value to allow for any output.
 	 * @return The sum of the two sets, with the individual elements clipped
-	 * to the maximum value gived by {@code clip}.
+	 * to the maximum value given by {@code clip}.
 	 */
 	protected static FrequencySet<String> combineAndClip(FrequencySet<String> a, FrequencySet<String> b, int clip) {
 		FrequencySet<String> result = new FrequencySet<String>();

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -120,7 +120,7 @@ public static <From,To> List<To> select(List<From> list, Func1<From, To> selecto
 		return b;
 	}
 
-	/** Find exact object type or sublass of cl in list */
+	/** Find exact object type or subclass of cl in list */
 	public static <T> T find(List<?> ops, Class<T> cl) {
 		for (Object o : ops) {
 			if ( cl.isInstance(o) ) return cl.cast(o);

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -157,7 +157,7 @@ public static void internalError(String error) {
     }
 
     /**
-     * Raise a predefined message with some number of paramters for the StringTemplate but for which there
+     * Raise a predefined message with some number of parameters for the StringTemplate but for which there
      * is no location information possible.
      * @param errorType The Message Descriptor
      * @param args The arguments to pass to the StringTemplate

File: tool/src/org/antlr/v4/tool/ErrorSeverity.java
Patch:
@@ -61,7 +61,7 @@ public enum ErrorSeverity {
     /**
      * Standard constructor to build an instance of the Enum entries
      *
-     * @param text The human readable string representing the serverity level
+     * @param text The human readable string representing the severity level
      */
     private ErrorSeverity(String text) { this.text = text; }
 }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -328,9 +328,9 @@ public enum ErrorType {
 	/**
 	 * Compiler Error 79.
 	 *
-	 * <p>missing arguments(s) on rule reference: <em>rule</em></p>
+	 * <p>missing argument(s) on rule reference: <em>rule</em></p>
 	 */
-	MISSING_RULE_ARGS(79, "missing arguments(s) on rule reference: <arg>", ErrorSeverity.ERROR),
+	MISSING_RULE_ARGS(79, "missing argument(s) on rule reference: <arg>", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 80.
 	 *

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -50,7 +50,7 @@
  *  The root node always has a null pointer and invokingState of -1.
  *
  *  Upon entry to parsing, the first invoked rule function creates a
- *  context object (asubclass specialized for that rule such as
+ *  context object (a subclass specialized for that rule such as
  *  SContext) and makes it the root of a parse tree, recorded by field
  *  Parser._ctx.
  *

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -65,7 +65,7 @@ public class TestSymbolIssues extends BaseJavaTest {
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:10:20: implicit definition of token Y in parser\n" +
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:11:4: implicit definition of token FJKD in parser\n" +
 			"error(" + ErrorType.RULE_HAS_NO_ARGS.code + "): A.g4:9:37: rule b has no defined parameters\n" +
-			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing arguments(s) on rule reference: a\n"
+			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing argument(s) on rule reference: a\n"
     };
 
     static String[] B = {

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -713,7 +713,7 @@ public void generateATNs(Grammar g) {
 	 *
 	 *  The output dir -o spec takes precedence if it's absolute.
 	 *  E.g., if the grammar file dir is absolute the output dir is given
-	 *  precendence. "-o /tmp /usr/lib/t.g4" results in "/tmp/T.java" as
+	 *  precedence. "-o /tmp /usr/lib/t.g4" results in "/tmp/T.java" as
 	 *  output (assuming t.g4 holds T.java).
 	 *
 	 *  If no -o is specified, then just write to the directory where the

File: tool/src/org/antlr/v4/codegen/model/ElementFrequenciesVisitor.java
Patch:
@@ -65,7 +65,7 @@ protected static FrequencySet<String> combineMax(FrequencySet<String> a, Frequen
 	 * @param b The second set.
 	 * @param clip The maximum value to allow for any output.
 	 * @return The sum of the two sets, with the individual elements clipped
-	 * to the maximum value gived by {@code clip}.
+	 * to the maximum value given by {@code clip}.
 	 */
 	protected static FrequencySet<String> combineAndClip(FrequencySet<String> a, FrequencySet<String> b, int clip) {
 		FrequencySet<String> result = new FrequencySet<String>();

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -120,7 +120,7 @@ public static <From,To> List<To> select(List<From> list, Func1<From, To> selecto
 		return b;
 	}
 
-	/** Find exact object type or sublass of cl in list */
+	/** Find exact object type or subclass of cl in list */
 	public static <T> T find(List<?> ops, Class<T> cl) {
 		for (Object o : ops) {
 			if ( cl.isInstance(o) ) return cl.cast(o);

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -157,7 +157,7 @@ public static void internalError(String error) {
     }
 
     /**
-     * Raise a predefined message with some number of paramters for the StringTemplate but for which there
+     * Raise a predefined message with some number of parameters for the StringTemplate but for which there
      * is no location information possible.
      * @param errorType The Message Descriptor
      * @param args The arguments to pass to the StringTemplate

File: tool/src/org/antlr/v4/tool/ErrorSeverity.java
Patch:
@@ -61,7 +61,7 @@ public enum ErrorSeverity {
     /**
      * Standard constructor to build an instance of the Enum entries
      *
-     * @param text The human readable string representing the serverity level
+     * @param text The human readable string representing the severity level
      */
     private ErrorSeverity(String text) { this.text = text; }
 }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -328,9 +328,9 @@ public enum ErrorType {
 	/**
 	 * Compiler Error 79.
 	 *
-	 * <p>missing arguments(s) on rule reference: <em>rule</em></p>
+	 * <p>missing argument(s) on rule reference: <em>rule</em></p>
 	 */
-	MISSING_RULE_ARGS(79, "missing arguments(s) on rule reference: <arg>", ErrorSeverity.ERROR),
+	MISSING_RULE_ARGS(79, "missing argument(s) on rule reference: <arg>", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 80.
 	 *

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/GrammarDependencies.java
Patch:
@@ -50,11 +50,12 @@ public GrammarDependencies(File sourceDirectory, File libDirectory,
     }
 
     /**
-     * Sets the package to use.
+     * Determines the package to use.
      *
      * @param   arguments  the tool arguments.
      *
-     * @return  self-reference.
+     * @return  the package. Returns {@code null} to indicate that no package should be
+     *          used.
      */
     private String getPackage(List<String> arguments) {
         int index = (arguments != null) ? arguments.indexOf("-package") : -1;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseRuntimeTest.java
Patch:
@@ -126,12 +126,12 @@ public void testParser(RuntimeTestDescriptor descriptor) throws Exception {
 		                                   descriptor.showDiagnosticErrors()
 		                                  );
 		if ( delegate instanceof RuntimeTestAssert ) {
-			((RuntimeTestAssert)delegate).assertEqualStrings(descriptor.getOutput(), found);
 			((RuntimeTestAssert)delegate).assertEqualStrings(descriptor.getErrors(), delegate.getParseErrors());
+			((RuntimeTestAssert)delegate).assertEqualStrings(descriptor.getOutput(), found);
 		}
 		else {
-			assertEquals(descriptor.getOutput(), found);
 			assertEquals(descriptor.getErrors(), delegate.getParseErrors());
+			assertEquals(descriptor.getOutput(), found);
 		}
 	}
 

File: tool/src/org/antlr/v4/tool/AttributeDict.java
Patch:
@@ -65,7 +65,7 @@ public class AttributeDict {
         predefinedTokenDict.add(new Attribute("int"));
     }
 
-    public static enum DictType {
+    public enum DictType {
         ARG, RET, LOCAL, TOKEN,
 		PREDEFINED_RULE, PREDEFINED_LEXER_RULE,
     }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/BaseDiagnosticParserTestDescriptor.java
Patch:
@@ -1,6 +1,6 @@
 package org.antlr.v4.test.runtime;
 
-public abstract class BaseDebugParserTestDescriptor extends BaseParserTestDescriptor {
+public abstract class BaseDiagnosticParserTestDescriptor extends BaseParserTestDescriptor {
 	@Override
 	public boolean showDiagnosticErrors() {
 		return true;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeParsersDescriptors.java
Patch:
@@ -458,7 +458,7 @@ public List<Pair<String, String>> getSlaveGrammars() {
 	 */
 	public static class ImportLexerWithOnlyFragmentRules extends BaseCompositeParserTestDescriptor {
 		public String input = "test test";
-		public String output = "";
+		public String output = null;
 		public String errors = null;
 		public String startRule = "program";
 		public String grammarName = "Test";
@@ -499,7 +499,7 @@ public List<Pair<String, String>> getSlaveGrammars() {
 
 	public static class ImportedGrammarWithEmptyOptions extends BaseCompositeParserTestDescriptor {
 		public String input = "b";
-		public String output = "";
+		public String output = null;
 		public String errors = null;
 		public String startRule = "s";
 		public String grammarName = "M";
@@ -533,7 +533,7 @@ public List<Pair<String, String>> getSlaveGrammars() {
 
 	public static class ImportedRuleWithAction extends BaseCompositeParserTestDescriptor {
 		public String input = "b";
-		public String output = "";
+		public String output = null;
 		public String errors = null;
 		public String startRule = "s";
 		public String grammarName = "M";

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -10,7 +10,7 @@ public class PerformanceDescriptors {
 	 * https://github.com/antlr/antlr4/issues/192
 	 */
 	public static abstract class ExpressionGrammar extends BaseParserTestDescriptor {
-		public String output = "";
+		public String output = null;
 		public String errors = null;
 		public String startRule = "program";
 		public String grammarName = "Expr";

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/SetsDescriptors.java
Patch:
@@ -32,7 +32,7 @@ public static class CharSetLiteral extends BaseParserTestDescriptor {
 
 	public static class ComplementSet extends BaseParserTestDescriptor {
 		public String input = "a";
-		public String output = "";
+		public String output = null;
 		/**
 		line 1:0 token recognition error at: 'a'
 		line 1:1 missing {} at '<EOF>'

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -60,7 +60,7 @@
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.test.runtime.ErrorQueue;
-import org.antlr.v4.test.runtime.SingleTest;
+import org.antlr.v4.test.runtime.RuntimeTestSupport;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.DefaultToolListener;
@@ -99,7 +99,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-public class BaseCppTest implements SingleTest {
+public class BaseCppTest implements RuntimeTestSupport {
 	// -J-Dorg.antlr.v4.test.BaseTest.level=FINE
 	// private static final Logger LOGGER = Logger.getLogger(BaseTest.class.getName());
 	public static final String newline = System.getProperty("line.separator");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseCSharpTest.java
Patch:
@@ -36,7 +36,7 @@
 import org.antlr.v4.runtime.WritableToken;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.test.runtime.ErrorQueue;
-import org.antlr.v4.test.runtime.SingleTest;
+import org.antlr.v4.test.runtime.RuntimeTestSupport;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DefaultToolListener;
 import org.antlr.v4.tool.GrammarSemanticsMessage;
@@ -77,7 +77,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-public class BaseCSharpTest implements SingleTest {
+public class BaseCSharpTest implements RuntimeTestSupport {
 	public static final String newline = System.getProperty("line.separator");
 	public static final String pathSep = System.getProperty("path.separator");
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/CompositeLexersDescriptors.java
Patch:
@@ -20,7 +20,7 @@ public static class LexerDelegatorInvokesDelegateRule extends BaseCompositeLexer
 		@CommentHasStringValue
 		public String output;
 
-		public String errors = "";
+		public String errors = null;
 		public String startRule = "";
 		public String grammarName = "M";
 
@@ -60,7 +60,7 @@ public static class LexerDelegatorRuleOverridesDelegate extends BaseCompositeLex
 		@CommentHasStringValue
 		public String output;
 
-		public String errors = "";
+		public String errors = null;
 		public String startRule = "";
 		public String grammarName = "M";
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/FullContextParsingDescriptors.java
Patch:
@@ -205,7 +205,7 @@ public static class ExprAmbiguity_2 extends ExprAmbiguity {
 	}
 
 	public static abstract class FullContextIF_THEN_ELSEParse extends BaseDebugParserTestDescriptor {
-		public String errors = "";
+		public String errors = null;
 		public String startRule = "s";
 		public String grammarName = "T";
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/LexerErrorsDescriptors.java
Patch:
@@ -54,7 +54,7 @@ public static class DFAToATNThatMatchesThenFailsInATN extends BaseLexerTestDescr
 	}
 
 	public static abstract class EnforcedGreedyNestedBraces extends BaseLexerTestDescriptor {
-		public String errors = "";
+		public String errors = null;
 		public String startRule = "";
 		public String grammarName = "L";
 
@@ -212,7 +212,7 @@ public static class LexerExecDFA extends BaseLexerTestDescriptor {
 	}
 
 	public static abstract class StringsEmbeddedInActions extends BaseLexerTestDescriptor {
-		public String errors = "";
+		public String errors = null;
 		public String startRule = "";
 		public String grammarName = "L";
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/descriptors/PerformanceDescriptors.java
Patch:
@@ -11,7 +11,7 @@ public class PerformanceDescriptors {
 	 */
 	public static abstract class ExpressionGrammar extends BaseParserTestDescriptor {
 		public String output = "";
-		public String errors = "";
+		public String errors = null;
 		public String startRule = "program";
 		public String grammarName = "Expr";
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseGoTest.java
Patch:
@@ -57,7 +57,7 @@
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.test.runtime.ErrorQueue;
-import org.antlr.v4.test.runtime.SingleTest;
+import org.antlr.v4.test.runtime.RuntimeTestSupport;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.DefaultToolListener;
@@ -97,7 +97,7 @@
 import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertArrayEquals;
 
-public class BaseGoTest implements SingleTest {
+public class BaseGoTest implements RuntimeTestSupport {
 	// -J-Dorg.antlr.v4.test.BaseTest.level=FINE
 	// private static final Logger LOGGER =
 	// Logger.getLogger(BaseTest.class.getName());

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/BaseJavaTest.java
Patch:
@@ -61,7 +61,7 @@
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.test.runtime.ErrorQueue;
-import org.antlr.v4.test.runtime.SingleTest;
+import org.antlr.v4.test.runtime.RuntimeTestSupport;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DefaultToolListener;
 import org.antlr.v4.tool.Grammar;
@@ -109,7 +109,7 @@
 import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertArrayEquals;
 
-public class BaseJavaTest implements SingleTest {
+public class BaseJavaTest implements RuntimeTestSupport {
 	// -J-Dorg.antlr.v4.test.BaseTest.level=FINE
 	private static final Logger LOGGER = Logger.getLogger(BaseJavaTest.class.getName());
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/browser/BaseBrowserTest.java
Patch:
@@ -57,7 +57,7 @@
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.test.runtime.ErrorQueue;
-import org.antlr.v4.test.runtime.SingleTest;
+import org.antlr.v4.test.runtime.RuntimeTestSupport;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.DefaultToolListener;
@@ -103,7 +103,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-public abstract class BaseBrowserTest implements SingleTest {
+public abstract class BaseBrowserTest implements RuntimeTestSupport {
 	// -J-Dorg.antlr.v4.test.BaseTest.level=FINE
 	// private static final Logger LOGGER = Logger.getLogger(BaseTest.class.getName());
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/BaseNodeTest.java
Patch:
@@ -57,7 +57,7 @@
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.test.runtime.ErrorQueue;
-import org.antlr.v4.test.runtime.SingleTest;
+import org.antlr.v4.test.runtime.RuntimeTestSupport;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.DefaultToolListener;
@@ -95,7 +95,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-public class BaseNodeTest implements SingleTest {
+public class BaseNodeTest implements RuntimeTestSupport {
 	// -J-Dorg.antlr.v4.test.BaseTest.level=FINE
 	// private static final Logger LOGGER =
 	// Logger.getLogger(BaseTest.class.getName());

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python/BasePythonTest.java
Patch:
@@ -60,7 +60,7 @@
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.test.runtime.ErrorQueue;
-import org.antlr.v4.test.runtime.SingleTest;
+import org.antlr.v4.test.runtime.RuntimeTestSupport;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.DefaultToolListener;
@@ -101,7 +101,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
-public abstract class BasePythonTest implements SingleTest {
+public abstract class BasePythonTest implements RuntimeTestSupport {
 	// -J-Dorg.antlr.v4.test.BaseTest.level=FINE
 	// private static final Logger LOGGER = Logger.getLogger(BaseTest.class.getName());
 	public static final String newline = System.getProperty("line.separator");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -606,7 +606,7 @@ private boolean buildRuntime() {
   static boolean runtimeBuiltOnce = false;
   
 	public String execModule(String fileName) {
-		String compilerPath = locateCompiler();
+		String compilerPath = "g++"; //locateCompiler();
 		String runtimePath = locateRuntime();
 		String includePath = runtimePath + "/runtime/src";
 		String binPath = new File(new File(tmpdir), "a.out").getAbsolutePath();

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSemPredEvalParser.java
Patch:
@@ -2,7 +2,6 @@
 package org.antlr.v4.test.runtime.csharp;
 
 import org.junit.Test;
-import org.junit.Ignore;
 
 @SuppressWarnings("unused")
 public class TestSemPredEvalParser extends BaseTest {
@@ -552,11 +551,11 @@ public void testToLeft() throws Exception {
 	@Test
 	public void testToLeftWithVaryingPredicate() throws Exception {
 		mkdir(tmpdir);
-		StringBuilder grammarBuilder = new StringBuilder(269);
+		StringBuilder grammarBuilder = new StringBuilder(276);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@parser::members {int i = 0;}\n");
 		grammarBuilder.append("s : ({this.i += 1;\n");
-		grammarBuilder.append("Console.WriteLine(\"i=\"+i);} a)+ ;\n");
+		grammarBuilder.append("Console.WriteLine(\"i=\" + this.i);} a)+ ;\n");
 		grammarBuilder.append("a : {this.i % 2 == 0}? ID {Console.WriteLine(\"alt 1\");}\n");
 		grammarBuilder.append("  | {this.i % 2 != 0}? ID {Console.WriteLine(\"alt 2\");}\n");
 		grammarBuilder.append("  ;\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserErrors.java
Patch:
@@ -2,7 +2,6 @@
 package org.antlr.v4.test.runtime.csharp;
 
 import org.junit.Test;
-import org.junit.Ignore;
 
 @SuppressWarnings("unused")
 public class TestParserErrors extends BaseTest {
@@ -551,7 +550,7 @@ public void testTokenMismatch2() throws Exception {
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserErrors.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.go;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParserErrors extends BaseTest {
 
@@ -585,7 +585,7 @@ public void testTokenMismatch2() throws Exception {
 			"TListener", "TVisitor", "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserErrors.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.java;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParserErrors extends BaseTest {
 
@@ -679,7 +679,7 @@ public void testTokenMismatch2() throws Exception {
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserErrors.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.javascript.node;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 @SuppressWarnings("unused")
 public class TestParserErrors extends BaseTest {
@@ -617,7 +617,7 @@ public void testTokenMismatch2() throws Exception {
 		                          "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserErrors.java
Patch:
@@ -2,7 +2,6 @@
 package org.antlr.v4.test.runtime.csharp;
 
 import org.junit.Test;
-import org.junit.Ignore;
 
 @SuppressWarnings("unused")
 public class TestParserErrors extends BaseTest {
@@ -551,7 +550,7 @@ public void testTokenMismatch2() throws Exception {
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserErrors.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.go;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParserErrors extends BaseTest {
 
@@ -585,7 +585,7 @@ public void testTokenMismatch2() throws Exception {
 			"TListener", "TVisitor", "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserErrors.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.java;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParserErrors extends BaseTest {
 
@@ -679,7 +679,7 @@ public void testTokenMismatch2() throws Exception {
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserErrors.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.javascript.node;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 @SuppressWarnings("unused")
 public class TestParserErrors extends BaseTest {
@@ -617,7 +617,7 @@ public void testTokenMismatch2() throws Exception {
 		                          "stat", input, false);
 		assertEquals("", found);
 
-		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting ')'\n", this.stderrDuringParse);
+		assertEquals("line 1:2 mismatched input '~FORCE_ERROR~' expecting {')', ID}\n", this.stderrDuringParse);
 
 	}
 

File: tool-testsuite/test/org/antlr/v4/test/tool/TestSymbolIssues.java
Patch:
@@ -64,7 +64,7 @@ public class TestSymbolIssues extends BaseTest {
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:10:20: implicit definition of token Y in parser\n" +
 			"warning(" + ErrorType.IMPLICIT_TOKEN_DEFINITION.code + "): A.g4:11:4: implicit definition of token FJKD in parser\n" +
 			"error(" + ErrorType.RULE_HAS_NO_ARGS.code + "): A.g4:9:37: rule b has no defined parameters\n" +
-			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing arguments(s) on rule reference: a\n"
+			"error(" + ErrorType.MISSING_RULE_ARGS.code + "): A.g4:10:31: missing argument(s) on rule reference: a\n"
     };
 
     static String[] B = {

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -328,9 +328,9 @@ public enum ErrorType {
 	/**
 	 * Compiler Error 79.
 	 *
-	 * <p>missing arguments(s) on rule reference: <em>rule</em></p>
+	 * <p>missing argument(s) on rule reference: <em>rule</em></p>
 	 */
-	MISSING_RULE_ARGS(79, "missing arguments(s) on rule reference: <arg>", ErrorSeverity.ERROR),
+	MISSING_RULE_ARGS(79, "missing argument(s) on rule reference: <arg>", ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 80.
 	 *

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -50,7 +50,7 @@
  *  The root node always has a null pointer and invokingState of -1.
  *
  *  Upon entry to parsing, the first invoked rule function creates a
- *  context object (asubclass specialized for that rule such as
+ *  context object (a subclass specialized for that rule such as
  *  SContext) and makes it the root of a parse tree, recorded by field
  *  Parser._ctx.
  *

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -713,7 +713,7 @@ public void generateATNs(Grammar g) {
 	 *
 	 *  The output dir -o spec takes precedence if it's absolute.
 	 *  E.g., if the grammar file dir is absolute the output dir is given
-	 *  precendence. "-o /tmp /usr/lib/t.g4" results in "/tmp/T.java" as
+	 *  precedence. "-o /tmp /usr/lib/t.g4" results in "/tmp/T.java" as
 	 *  output (assuming t.g4 holds T.java).
 	 *
 	 *  If no -o is specified, then just write to the directory where the

File: tool/src/org/antlr/v4/codegen/model/ElementFrequenciesVisitor.java
Patch:
@@ -65,7 +65,7 @@ protected static FrequencySet<String> combineMax(FrequencySet<String> a, Frequen
 	 * @param b The second set.
 	 * @param clip The maximum value to allow for any output.
 	 * @return The sum of the two sets, with the individual elements clipped
-	 * to the maximum value gived by {@code clip}.
+	 * to the maximum value given by {@code clip}.
 	 */
 	protected static FrequencySet<String> combineAndClip(FrequencySet<String> a, FrequencySet<String> b, int clip) {
 		FrequencySet<String> result = new FrequencySet<String>();

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -120,7 +120,7 @@ public static <From,To> List<To> select(List<From> list, Func1<From, To> selecto
 		return b;
 	}
 
-	/** Find exact object type or sublass of cl in list */
+	/** Find exact object type or subclass of cl in list */
 	public static <T> T find(List<?> ops, Class<T> cl) {
 		for (Object o : ops) {
 			if ( cl.isInstance(o) ) return cl.cast(o);

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -157,7 +157,7 @@ public static void internalError(String error) {
     }
 
     /**
-     * Raise a predefined message with some number of paramters for the StringTemplate but for which there
+     * Raise a predefined message with some number of parameters for the StringTemplate but for which there
      * is no location information possible.
      * @param errorType The Message Descriptor
      * @param args The arguments to pass to the StringTemplate

File: tool/src/org/antlr/v4/tool/ErrorSeverity.java
Patch:
@@ -61,7 +61,7 @@ public enum ErrorSeverity {
     /**
      * Standard constructor to build an instance of the Enum entries
      *
-     * @param text The human readable string representing the serverity level
+     * @param text The human readable string representing the severity level
      */
     private ErrorSeverity(String text) { this.text = text; }
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParseTrees.java
Patch:
@@ -2,6 +2,7 @@
 package org.antlr.v4.test.runtime.csharp;
 
 import org.junit.Test;
+import org.junit.Ignore;
 
 @SuppressWarnings("unused")
 public class TestParseTrees extends BaseTest {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserExec.java
Patch:
@@ -529,14 +529,14 @@ public void testOptional_4() throws Exception {
 	@Test
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
-		StringBuilder grammarBuilder = new StringBuilder(155);
+		StringBuilder grammarBuilder = new StringBuilder(163);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("bool Property() {\n");
 		grammarBuilder.append("	return true;\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {Property()}? ID {Console.WriteLine(\"valid\");}\n");
+		grammarBuilder.append("a : {$parser.Property()}? ID {Console.WriteLine(\"valid\");}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -556,14 +556,14 @@ public void testOptional_4() throws Exception {
 	@Test
 	public void testParserProperty() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(160);
+		StringBuilder grammarBuilder = new StringBuilder(181);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@parser::members {\n");
-		grammarBuilder.append("func Property() bool {\n");
+		grammarBuilder.append("func (p *TParser) Property() bool {\n");
 		grammarBuilder.append("	return true\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {Property()}? ID {fmt.Println(\"valid\")}\n");
+		grammarBuilder.append("a : {$parser.Property()}? ID {fmt.Println(\"valid\")}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParseTrees.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.java;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.junit.Assert.*;
 
 public class TestParseTrees extends BaseTest {
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserExec.java
Patch:
@@ -639,14 +639,14 @@ public void testOptional_4() throws Exception {
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(160);
+		StringBuilder grammarBuilder = new StringBuilder(168);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("boolean Property() {\n");
 		grammarBuilder.append("  return true;\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {Property()}? ID {System.out.println(\"valid\");}\n");
+		grammarBuilder.append("a : {$parser.Property()}? ID {System.out.println(\"valid\");}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParseTrees.java
Patch:
@@ -1,10 +1,10 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.javascript.node;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.junit.Assert.*;
 
 @SuppressWarnings("unused")
 public class TestParseTrees extends BaseTest {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserExec.java
Patch:
@@ -585,14 +585,14 @@ public void testOptional_4() throws Exception {
 	@Test
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
-		StringBuilder grammarBuilder = new StringBuilder(163);
+		StringBuilder grammarBuilder = new StringBuilder(171);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("this.Property = function() {\n");
 		grammarBuilder.append("    return true;\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {Property()}? ID {console.log(\"valid\");}\n");
+		grammarBuilder.append("a : {$parser.Property()}? ID {console.log(\"valid\");}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParseTrees.java
Patch:
@@ -1,10 +1,9 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.python2;
 
+import org.junit.Ignore;
 import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.junit.Assert.*;
 
 @SuppressWarnings("unused")
 public class TestParseTrees extends BasePython2Test {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParserExec.java
Patch:
@@ -666,14 +666,14 @@ public void testOptional_4() throws Exception {
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(145);
+		StringBuilder grammarBuilder = new StringBuilder(153);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("def Property(self):\n");
 		grammarBuilder.append("    return True\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {Property()}? ID {print(\"valid\")}\n");
+		grammarBuilder.append("a : {$parser.Property()}? ID {print(\"valid\")}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParseTrees.java
Patch:
@@ -1,10 +1,9 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
 package org.antlr.v4.test.runtime.python3;
 
+import org.junit.Ignore;
 import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.junit.Assert.*;
 
 @SuppressWarnings("unused")
 public class TestParseTrees extends BasePython3Test {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParserExec.java
Patch:
@@ -666,14 +666,14 @@ public void testOptional_4() throws Exception {
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(145);
+		StringBuilder grammarBuilder = new StringBuilder(153);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("def Property(self):\n");
 		grammarBuilder.append("    return True\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {Property()}? ID {print(\"valid\")}\n");
+		grammarBuilder.append("a : {$parser.Property()}? ID {print(\"valid\")}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseTest.java
Patch:
@@ -482,6 +482,9 @@ public boolean createProject() {
 				throw new RuntimeException("C# runtime project file not found!");
 			}
 			String runtimeProjPath = runtimeProj.getPath();
+			if(isWindows()){
+				runtimeProjPath = runtimeProjPath.replaceFirst("/", "");
+			}
 			XPathExpression exp = XPathFactory.newInstance().newXPath()
 				.compile("/Project/ItemGroup/ProjectReference[@Include='" + runtimeName + "']");
 			Element node = (Element)exp.evaluate(prjXml, XPathConstants.NODE);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -41,8 +41,8 @@ protected String getLanguage() {
 
 	@Override
 	protected String getPythonExecutable() {
-		return "python3.4"; 
-	}
+		return "python3.5";
+	} // force 3.5
 
 	@Override
 	protected void writeLexerTestFile(String lexerName, boolean showDFA) {

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -34,7 +34,6 @@
 import org.antlr.v4.runtime.atn.ATNDeserializer;
 import org.antlr.v4.runtime.atn.ATNSimulator;
 import org.antlr.v4.runtime.atn.ATNState;
-import org.antlr.v4.runtime.atn.AmbiguityInfo;
 import org.antlr.v4.runtime.atn.ParseInfo;
 import org.antlr.v4.runtime.atn.ParserATNSimulator;
 import org.antlr.v4.runtime.atn.PredictionMode;
@@ -51,7 +50,6 @@
 import org.antlr.v4.runtime.tree.pattern.ParseTreePatternMatcher;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -649,6 +647,7 @@ public void exitRule() {
     }
 
 	public void enterOuterAlt(ParserRuleContext localctx, int altNum) {
+		localctx.setAltNumber(altNum);
 		// if we have new localctx, make sure we replace existing ctx
 		// that is previous child of parse tree
 		if ( _buildParseTrees && _ctx != localctx ) {

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -91,7 +91,7 @@ public class RuntimeMetaData {
 	 * omitted.</li>
 	 * </ul>
 	 */
-	public static final String VERSION = "4.5.1";
+	public static final String VERSION = "4.5.3";
 
 	/**
 	 * Gets the currently executing version of the ANTLR 4 runtime library.

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -788,7 +788,8 @@ protected int execATNWithFullContext(DFA dfa,
 	protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,
 										   boolean fullCtx)
 	{
-		if ( debug ) System.out.println("in computeReachSet, starting closure: " + closure);
+		if ( debug ) 
+			System.out.println("in computeReachSet, starting closure: " + closure);
 
 		if (mergeCache == null) {
 			mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();

File: tool/src/org/antlr/v4/analysis/AnalysisPipeline.java
Patch:
@@ -100,7 +100,7 @@ protected void processParser() {
 		}
 	}
 
-	/** Return whether lookahead sets are disjoint; no lookahead => not disjoint */
+	/** Return whether lookahead sets are disjoint; no lookahead  not disjoint */
 	public static boolean disjoint(IntervalSet[] altLook) {
 		boolean collision = false;
 		IntervalSet combined = new IntervalSet();

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -324,7 +324,7 @@ else if ( t.getType()==ANTLRParser.TOKEN_REF ) {
 
 	/** For a lexer, a string is a sequence of char to match.  That is,
 	 *  "fog" is treated as 'f' 'o' 'g' not as a single transition in
-	 *  the DFA.  Machine== o-'f'->o-'o'->o-'g'->o and has n+1 states
+	 *  the DFA.  Machine== o-'f'-&gt;o-'o'-&gt;o-'g'-&gt;o and has n+1 states
 	 *  for n characters.
 	 */
 	@Override

File: tool/src/org/antlr/v4/codegen/ActionTranslator.java
Patch:
@@ -138,7 +138,7 @@ public static List<ActionChunk> translateAction(OutputModelFactory factory,
 													ActionAST node)
 	{
 		String action = tokenWithinAction.getText();
-		if ( action.charAt(0)=='{' ) {
+		if ( action!=null && action.length()>0 && action.charAt(0)=='{' ) {
 			int firstCurly = action.indexOf('{');
 			int lastCurly = action.lastIndexOf('}');
 			if ( firstCurly>=0 && lastCurly>=0 ) {
@@ -158,7 +158,7 @@ public static List<ActionChunk> translateActionChunk(OutputModelFactory factory,
 		translator.rf = rf;
         factory.getGrammar().tool.log("action-translator", "translate " + action);
 		String altLabel = node.getAltLabel();
-		if ( rf!=null ) { 
+		if ( rf!=null ) {
 		    translator.nodeContext = rf.ruleCtx;
 	        if ( altLabel!=null ) translator.nodeContext = rf.altLabelCtxs.get(altLabel);
 		}

File: tool/src/org/antlr/v4/codegen/OutputModelWalker.java
Patch:
@@ -53,7 +53,7 @@
  *  We identify those nested objects by the list of arguments in the template
  *  definition. For example, here is the definition of the parser template:
  *
- *  Parser(parser, scopes, funcs) ::= <<...>>
+ *  Parser(parser, scopes, funcs) ::= &lt;&lt;...&gt;&gt;
  *
  *  The first template argument is always the output model object from which
  *  this walker will create the template. Any other arguments identify

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -56,7 +56,7 @@ public abstract class Target {
 	 *  predicates and such that may refer to chars that need to be escaped
 	 *  when represented as strings.  Also, templates need to be escaped so
 	 *  that the target language can hold them as a string.
-	 *  <p/>
+	 *  <p>
 	 *  I have defined (via the constructor) the set of typical escapes,
 	 *  but your {@link Target} subclass is free to alter the translated chars
 	 *  or add more definitions.  This is non-static so each target can have

File: tool/src/org/antlr/v4/codegen/model/decl/AltLabelStructDecl.java
Patch:
@@ -38,7 +38,7 @@
 
 import java.util.ArrayList;
 
-/** A StructDecl to handle a -> label on alt */
+/** A StructDecl to handle a -&gt; label on alt */
 public class AltLabelStructDecl extends StructDecl {
 	public int altNum;
 	public AltLabelStructDecl(OutputModelFactory factory, Rule r,

File: tool/src/org/antlr/v4/codegen/target/CSharpTarget.java
Patch:
@@ -51,7 +51,7 @@ public CSharpTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.5.1"; // crossing fingers that it's close enough.
+        return "4.5.3";
     }
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/JavaScriptTarget.java
Patch:
@@ -74,7 +74,7 @@ public JavaScriptTarget(CodeGenerator gen) {
 
     @Override
     public String getVersion() {
-        return "4.5.1";
+        return "4.5.3";
     }
 
     public Set<String> getBadWords() {
@@ -93,11 +93,11 @@ protected void addBadWords() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
+	 * <p>
 	 * For Java, this is the translation {@code 'a\n"'} &rarr; {@code "a\n\""}.
 	 * Expect single quotes around the incoming literal. Just flip the quotes
 	 * and replace double quotes with {@code \"}.
-	 * <p/>
+	 * <p>
 	 * Note that we have decided to allow people to use '\"' without penalty, so
 	 * we must build the target string in a loop as {@link String#replace}
 	 * cannot handle both {@code \"} and {@code "} without a lot of messing

File: tool/src/org/antlr/v4/codegen/target/Python2Target.java
Patch:
@@ -50,7 +50,7 @@ public class Python2Target extends Target {
 		"abs", "all", "any", "apply", "as",
 		"bin", "bool", "buffer", "bytearray",
 		"callable", "chr", "classmethod", "coerce", "compile", "complex",
-		"delattr", "dict", "dir", "divmod",
+		"del", "delattr", "dict", "dir", "divmod",
 		"enumerate", "eval", "execfile",
 		"file", "filter", "float", "format", "frozenset",
 		"getattr", "globals",
@@ -61,7 +61,7 @@ public class Python2Target extends Target {
 		"memoryview",
 		"object", "oct", "open", "ord",
 		"pow", "print", "property",
-		"range", "raw_input", "reduce", "reload", "repr", "reversed", "round",
+		"range", "raw_input", "reduce", "reload", "repr", "return", "reversed", "round",
 		"set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super",
 		"tuple", "type",
 		"unichr", "unicode",
@@ -117,7 +117,7 @@ public boolean supportsOverloadedMethods() {
 
 	@Override
 	public String getVersion() {
-		return "4.5.2";
+		return "4.5.3";
 	}
 
 	public Set<String> getBadWords() {

File: tool/src/org/antlr/v4/codegen/target/Python3Target.java
Patch:
@@ -50,7 +50,7 @@ public class Python3Target extends Target {
 		"abs", "all", "any", "apply", "as",
 		"bin", "bool", "buffer", "bytearray",
 		"callable", "chr", "classmethod", "coerce", "compile", "complex",
-		"delattr", "dict", "dir", "divmod",
+		"del", "delattr", "dict", "dir", "divmod",
 		"enumerate", "eval", "execfile",
 		"file", "filter", "float", "format", "frozenset",
 		"getattr", "globals",
@@ -61,7 +61,7 @@ public class Python3Target extends Target {
 		"memoryview",
 		"object", "oct", "open", "ord",
 		"pow", "print", "property",
-		"range", "raw_input", "reduce", "reload", "repr", "reversed", "round",
+		"range", "raw_input", "reduce", "reload", "repr", "return", "reversed", "round",
 		"set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super",
 		"tuple", "type",
 		"unichr", "unicode",
@@ -119,7 +119,7 @@ public boolean supportsOverloadedMethods() {
 
 	@Override
 	public String getVersion() {
-		return "4.5.2";
+		return "4.5.3";
 	}
 
 	/** Avoid grammar symbols in this set to prevent conflicts in gen'd code. */

File: tool/src/org/antlr/v4/misc/Graph.java
Patch:
@@ -81,7 +81,7 @@ protected Node<T> getNode(T a) {
 	 *  For sorting, I'm not following convention here since ANTLR
 	 *  needs the opposite.  Here's what I assume for sorting:
 	 *
-	 *    If there exists an edge u -> v then u depends on v and v
+	 *    If there exists an edge u -&gt; v then u depends on v and v
 	 *    must happen before u.
 	 *
 	 *  So if this gives nonreversed postorder traversal, I get the order
@@ -114,4 +114,4 @@ public void DFS(Node<T> n, Set<Node<T>> visited, ArrayList<T> sorted) {
 		}
 		sorted.add(n.payload);
 	}
-}
\ No newline at end of file
+}

File: tool/src/org/antlr/v4/parse/GrammarToken.java
Patch:
@@ -35,7 +35,7 @@
 import org.antlr.v4.tool.Grammar;
 
 /** A CommonToken that can also track it's original location,
- *  derived from options on the element ref like BEGIN<line=34,...>.
+ *  derived from options on the element ref like BEGIN&lt;line=34,...&gt;.
  */
 public class GrammarToken extends CommonToken {
 	public Grammar g;

File: tool/src/org/antlr/v4/tool/AttributeDict.java
Patch:
@@ -39,7 +39,7 @@
 import java.util.Set;
 
 /** Track the attributes within retval, arg lists etc...
- *  <p/>
+ *  <p>
  *  Each rule has potentially 3 scopes: return values,
  *  parameters, and an implicitly-named scope (i.e., a scope defined in a rule).
  *  Implicitly-defined scopes are named after the rule; rules and scopes then

File: tool/src/org/antlr/v4/tool/GrammarParserInterpreter.java
Patch:
@@ -151,7 +151,7 @@ else if ( startState.transition(0).target == decisionState ) {
 	 *  it's simple. Set decisionStatesThatSetOuterAltNumInContext
 	 *  indicates which decision states should set the outer alternative number.
 	 *
-	 *  Left recursive rules are much more complicated to deal with:
+	 *  <p>Left recursive rules are much more complicated to deal with:
 	 *  there is typically a decision for the primary alternatives and a
 	 *  decision to choose between the recursive operator alternatives.
 	 *  For example, the following left recursive rule has two primary and 2

File: tool/src/org/antlr/v4/tool/LeftRecursiveRule.java
Patch:
@@ -136,7 +136,7 @@ public int[] getRecursiveOpAlts() {
 		return alts;
 	}
 
-	/** Get -> labels from those alts we deleted for left-recursive rules. */
+	/** Get -&gt; labels from those alts we deleted for left-recursive rules. */
 	@Override
 	public Map<String, List<Pair<Integer, AltAST>>> getAltLabels() {
 		Map<String, List<Pair<Integer, AltAST>>> labels = new HashMap<String, List<Pair<Integer, AltAST>>>();

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseTest.java
Patch:
@@ -907,7 +907,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 					+ "	for _, t := range stream.GetAllTokens() {\n"
 					+ "		fmt.Println(t)\n"
 					+ "	}\n"
-					+ (showDFA ? "fmt.Print(lexer.GetInterpreter().DecisionToDFA[antlr.LexerDefaultMode].ToLexerString())\n"
+					+ (showDFA ? "fmt.Print(lexer.GetInterpreter().DecisionToDFA()[antlr.LexerDefaultMode].ToLexerString())\n"
 							: "")
 					+ "}\n"
 					+ "\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -556,9 +556,9 @@ public void testOptional_4() throws Exception {
 	@Test
 	public void testParserProperty() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(152);
+		StringBuilder grammarBuilder = new StringBuilder(160);
 		grammarBuilder.append("grammar T;\n");
-		grammarBuilder.append("@members {\n");
+		grammarBuilder.append("@parser::members {\n");
 		grammarBuilder.append("func Property() bool {\n");
 		grammarBuilder.append("	return true\n");
 		grammarBuilder.append("}\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParseTrees.java
Patch:
@@ -193,7 +193,7 @@ public void testToken2() throws Exception {
 	@Test
 	public void testTokenAndRuleContextString() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(167);
+		StringBuilder grammarBuilder = new StringBuilder(194);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("s\n");
 		grammarBuilder.append("@init {\n");
@@ -204,7 +204,7 @@ public void testTokenAndRuleContextString() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("  : r=a ;\n");
 		grammarBuilder.append("a : 'x' { \n");
-		grammarBuilder.append("fmt.Println(p.GetRuleInvocationStack(nil))\n");
+		grammarBuilder.append("fmt.Println(antlr.PrintArrayJavaStyle(p.GetRuleInvocationStack(nil)))\n");
 		grammarBuilder.append("} ;");
 		String grammar = grammarBuilder.toString();
 		String input ="x";

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/BaseTest.java
Patch:
@@ -482,6 +482,9 @@ public boolean createProject() {
 				throw new RuntimeException("C# runtime project file not found!");
 			}
 			String runtimeProjPath = runtimeProj.getPath();
+			if(isWindows()){
+				runtimeProjPath = runtimeProjPath.replaceFirst("/", "");
+			}
 			XPathExpression exp = XPathFactory.newInstance().newXPath()
 				.compile("/Project/ItemGroup/ProjectReference[@Include='" + runtimeName + "']");
 			Element node = (Element)exp.evaluate(prjXml, XPathConstants.NODE);

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeWalker.java
Patch:
@@ -34,7 +34,7 @@
 import org.antlr.v4.runtime.RuleContext;
 
 public class ParseTreeWalker {
-    public static final ParseTreeWalker DEFAULT = new ParseTreeWalker();
+    public static final ParseTreeWalker DEFAULT = new IterativeParseTreeWalker();
 
     public void walk(ParseTreeListener listener, ParseTree t) {
 		if ( t instanceof ErrorNode) {

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestListeners.java
Patch:
@@ -120,7 +120,7 @@ public void testLR() throws Exception {
 	@Test
 	public void testLRWithLabels() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(709);
+		StringBuilder grammarBuilder = new StringBuilder(726);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@parser::header {\n");
 		grammarBuilder.append("}\n");
@@ -135,7 +135,7 @@ public void testLRWithLabels() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("func (*LeafListener) ExitCall(ctx *CallContext) {\n");
-		grammarBuilder.append("	fmt.Printf(\"%s %s\", ctx.E().GetStart().GetText(), ctx.EList())\n");
+		grammarBuilder.append("	fmt.Printf(\"%s %s\", ctx.E().GetStart().GetText(), ctx.EList().String(nil, nil))\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("func (*LeafListener) ExitInt(ctx *IntContext) {\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserErrors.java
Patch:
@@ -51,8 +51,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {Console.Write('a');};\n");
-		grammarBuilder.append("b : 'b' {Console.Write('b');};");
+		grammarBuilder.append("a : 'a' {Console.Write(\"a\");};\n");
+		grammarBuilder.append("b : 'b' {Console.Write(\"b\");};");
 		String grammar = grammarBuilder.toString();
 		String input ="abab";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "s", input, true);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserErrors.java
Patch:
@@ -55,8 +55,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {fmt.Print('a')};\n");
-		grammarBuilder.append("b : 'b' {fmt.Print('b')};");
+		grammarBuilder.append("a : 'a' {fmt.Print(\"a\")};\n");
+		grammarBuilder.append("b : 'b' {fmt.Print(\"b\")};");
 		String grammar = grammarBuilder.toString();
 		String input ="abab";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer",

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserErrors.java
Patch:
@@ -61,8 +61,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {System.out.print('a');};\n");
-		grammarBuilder.append("b : 'b' {System.out.print('b');};");
+		grammarBuilder.append("a : 'a' {System.out.print(\"a\");};\n");
+		grammarBuilder.append("b : 'b' {System.out.print(\"b\");};");
 		String grammar = grammarBuilder.toString();
 
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserErrors.java
Patch:
@@ -57,8 +57,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("    };\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {process.stdout.write('a');};\n");
-		grammarBuilder.append("b : 'b' {process.stdout.write('b');};");
+		grammarBuilder.append("a : 'a' {process.stdout.write(\"a\");};\n");
+		grammarBuilder.append("b : 'b' {process.stdout.write(\"b\");};");
 		String grammar = grammarBuilder.toString();
 		String input ="abab";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer",

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParserErrors.java
Patch:
@@ -62,8 +62,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("    b = s.b()\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {print('a',end='')};\n");
-		grammarBuilder.append("b : 'b' {print('b',end='')};");
+		grammarBuilder.append("a : 'a' {print(\"a\",end='')};\n");
+		grammarBuilder.append("b : 'b' {print(\"b\",end='')};");
 		String grammar = grammarBuilder.toString();
 
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParserErrors.java
Patch:
@@ -62,8 +62,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("    b = s.b()\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {print('a',end='')};\n");
-		grammarBuilder.append("b : 'b' {print('b',end='')};");
+		grammarBuilder.append("a : 'a' {print(\"a\",end='')};\n");
+		grammarBuilder.append("b : 'b' {print(\"b\",end='')};");
 		String grammar = grammarBuilder.toString();
 
 

File: runtime-testsuite/src/org/antlr/v4/testgen/TestGenerator.java
Patch:
@@ -42,6 +42,7 @@
 import org.stringtemplate.v4.ST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.STGroupFile;
+import org.stringtemplate.v4.StringRenderer;
 import org.stringtemplate.v4.gui.STViz;
 
 public class TestGenerator {
@@ -169,6 +170,7 @@ private String getTargetName() {
 	public void execute() {
 		STGroup targetGroup = new STGroupFile(runtimeTemplate.getPath());
 		targetGroup.registerModelAdaptor(STGroup.class, new STGroupModelAdaptor());
+		targetGroup.registerRenderer(String.class, new StringRenderer(), true);
 		targetGroup.defineDictionary("escape", new JavaEscapeStringMap());
 		targetGroup.defineDictionary("lines", new LinesStringMap());
 		targetGroup.defineDictionary("strlen", new StrlenStringMap());

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -599,10 +599,10 @@ public void testPredicatedIfIfElse() throws Exception {
 	@Test
 	public void testPredictionIssue334() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(251);
+		StringBuilder grammarBuilder = new StringBuilder(255);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("file_ @init{\n");
-		grammarBuilder.append("p.SetErrorHandler(p.NewBailErrorStrategy())\n");
+		grammarBuilder.append("p.SetErrorHandler(antlr.NewBailErrorStrategy())\n");
 		grammarBuilder.append("} \n");
 		grammarBuilder.append("@after {\n");
 		grammarBuilder.append("fmt.Println($ctx.ToStringTree(nil, p))\n");

File: tool/src/org/antlr/v4/codegen/model/RuleFunction.java
Patch:
@@ -81,6 +81,7 @@ public class RuleFunction extends OutputModelObject {
 	public Rule rule;
 	public AltLabelStructDecl[] altToContext;
 	public boolean hasLookaheadBlock;
+	public String recognizerName;
 
 	@ModelElement public List<SrcOp> code;
 	@ModelElement public OrderedHashSet<Decl> locals; // TODO: move into ctx?
@@ -138,6 +139,7 @@ public RuleFunction(OutputModelFactory factory, Rule r) {
 		}
 
 		startState = factory.getGrammar().atn.ruleToStartState[r.index];
+		recognizerName = factory.getGrammar().getRecognizerName();
 	}
 
 	public void addContextGetters(OutputModelFactory factory, Rule r) {

File: tool/src/org/antlr/v4/codegen/model/RuleSempredFunction.java
Patch:
@@ -34,7 +34,10 @@
 import org.antlr.v4.tool.Rule;
 
 public class RuleSempredFunction extends RuleActionFunction {
+	public String recognizerName;
+
 	public RuleSempredFunction(OutputModelFactory factory, Rule r, String ctxType) {
 		super(factory, r, ctxType);
+		recognizerName = factory.getGrammar().getRecognizerName();
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserErrors.java
Patch:
@@ -51,8 +51,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {Console.Write('a');};\n");
-		grammarBuilder.append("b : 'b' {Console.Write('b');};");
+		grammarBuilder.append("a : 'a' {Console.Write(\"a\");};\n");
+		grammarBuilder.append("b : 'b' {Console.Write(\"b\");};");
 		String grammar = grammarBuilder.toString();
 		String input ="abab";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "s", input, true);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserErrors.java
Patch:
@@ -55,8 +55,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {fmt.Print('a')};\n");
-		grammarBuilder.append("b : 'b' {fmt.Print('b')};");
+		grammarBuilder.append("a : 'a' {fmt.Print(\"a\")};\n");
+		grammarBuilder.append("b : 'b' {fmt.Print(\"b\")};");
 		String grammar = grammarBuilder.toString();
 		String input ="abab";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer",

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserErrors.java
Patch:
@@ -61,8 +61,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {System.out.print('a');};\n");
-		grammarBuilder.append("b : 'b' {System.out.print('b');};");
+		grammarBuilder.append("a : 'a' {System.out.print(\"a\");};\n");
+		grammarBuilder.append("b : 'b' {System.out.print(\"b\");};");
 		String grammar = grammarBuilder.toString();
 
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserErrors.java
Patch:
@@ -57,8 +57,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("    };\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {process.stdout.write('a');};\n");
-		grammarBuilder.append("b : 'b' {process.stdout.write('b');};");
+		grammarBuilder.append("a : 'a' {process.stdout.write(\"a\");};\n");
+		grammarBuilder.append("b : 'b' {process.stdout.write(\"b\");};");
 		String grammar = grammarBuilder.toString();
 		String input ="abab";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer",

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParserErrors.java
Patch:
@@ -62,8 +62,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("    b = s.b()\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {print('a',end='')};\n");
-		grammarBuilder.append("b : 'b' {print('b',end='')};");
+		grammarBuilder.append("a : 'a' {print(\"a\",end='')};\n");
+		grammarBuilder.append("b : 'b' {print(\"b\",end='')};");
 		String grammar = grammarBuilder.toString();
 
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParserErrors.java
Patch:
@@ -62,8 +62,8 @@ public void testContextListGetters() throws Exception {
 		grammarBuilder.append("    b = s.b()\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("s : (a | b)+;\n");
-		grammarBuilder.append("a : 'a' {print('a',end='')};\n");
-		grammarBuilder.append("b : 'b' {print('b',end='')};");
+		grammarBuilder.append("a : 'a' {print(\"a\",end='')};\n");
+		grammarBuilder.append("b : 'b' {print(\"b\",end='')};");
 		String grammar = grammarBuilder.toString();
 
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestListeners.java
Patch:
@@ -120,7 +120,7 @@ public void testLR() throws Exception {
 	@Test
 	public void testLRWithLabels() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(709);
+		StringBuilder grammarBuilder = new StringBuilder(726);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@parser::header {\n");
 		grammarBuilder.append("}\n");
@@ -135,7 +135,7 @@ public void testLRWithLabels() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("func (*LeafListener) ExitCall(ctx *CallContext) {\n");
-		grammarBuilder.append("	fmt.Printf(\"%s %s\", ctx.E().GetStart().GetText(), ctx.EList())\n");
+		grammarBuilder.append("	fmt.Printf(\"%s %s\", ctx.E().GetStart().GetText(), ctx.EList().String(nil, nil))\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("func (*LeafListener) ExitInt(ctx *IntContext) {\n");

File: runtime-testsuite/src/org/antlr/v4/testgen/TestGenerator.java
Patch:
@@ -42,6 +42,7 @@
 import org.stringtemplate.v4.ST;
 import org.stringtemplate.v4.STGroup;
 import org.stringtemplate.v4.STGroupFile;
+import org.stringtemplate.v4.StringRenderer;
 import org.stringtemplate.v4.gui.STViz;
 
 public class TestGenerator {
@@ -169,6 +170,7 @@ private String getTargetName() {
 	public void execute() {
 		STGroup targetGroup = new STGroupFile(runtimeTemplate.getPath());
 		targetGroup.registerModelAdaptor(STGroup.class, new STGroupModelAdaptor());
+		targetGroup.registerRenderer(String.class, new StringRenderer(), true);
 		targetGroup.defineDictionary("escape", new JavaEscapeStringMap());
 		targetGroup.defineDictionary("lines", new LinesStringMap());
 		targetGroup.defineDictionary("strlen", new StrlenStringMap());

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -599,10 +599,10 @@ public void testPredicatedIfIfElse() throws Exception {
 	@Test
 	public void testPredictionIssue334() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(251);
+		StringBuilder grammarBuilder = new StringBuilder(255);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("file_ @init{\n");
-		grammarBuilder.append("p.SetErrorHandler(p.NewBailErrorStrategy())\n");
+		grammarBuilder.append("p.SetErrorHandler(antlr.NewBailErrorStrategy())\n");
 		grammarBuilder.append("} \n");
 		grammarBuilder.append("@after {\n");
 		grammarBuilder.append("fmt.Println($ctx.ToStringTree(nil, p))\n");

File: tool/src/org/antlr/v4/codegen/model/RuleFunction.java
Patch:
@@ -81,6 +81,7 @@ public class RuleFunction extends OutputModelObject {
 	public Rule rule;
 	public AltLabelStructDecl[] altToContext;
 	public boolean hasLookaheadBlock;
+	public String recognizerName;
 
 	@ModelElement public List<SrcOp> code;
 	@ModelElement public OrderedHashSet<Decl> locals; // TODO: move into ctx?
@@ -138,6 +139,7 @@ public RuleFunction(OutputModelFactory factory, Rule r) {
 		}
 
 		startState = factory.getGrammar().atn.ruleToStartState[r.index];
+		recognizerName = factory.getGrammar().getRecognizerName();
 	}
 
 	public void addContextGetters(OutputModelFactory factory, Rule r) {

File: tool/src/org/antlr/v4/codegen/model/RuleSempredFunction.java
Patch:
@@ -34,7 +34,10 @@
 import org.antlr.v4.tool.Rule;
 
 public class RuleSempredFunction extends RuleActionFunction {
+	public String recognizerName;
+
 	public RuleSempredFunction(OutputModelFactory factory, Rule r, String ctxType) {
 		super(factory, r, ctxType);
+		recognizerName = factory.getGrammar().getRecognizerName();
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestParserExec.java
Patch:
@@ -529,14 +529,14 @@ public void testOptional_4() throws Exception {
 	@Test
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
-		StringBuilder grammarBuilder = new StringBuilder(163);
+		StringBuilder grammarBuilder = new StringBuilder(155);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("bool Property() {\n");
 		grammarBuilder.append("	return true;\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {$parser.Property()}? ID {Console.WriteLine(\"valid\");}\n");
+		grammarBuilder.append("a : {Property()}? ID {Console.WriteLine(\"valid\");}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSemPredEvalLexer.java
Patch:
@@ -113,10 +113,10 @@ public void testIDvsEnum() throws Exception {
 	public void testIndent() throws Exception {
 		mkdir(parserpkgdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(137);
+		StringBuilder grammarBuilder = new StringBuilder(139);
 		grammarBuilder.append("lexer grammar L;\n");
 		grammarBuilder.append("ID : [a-z]+  ;\n");
-		grammarBuilder.append("INDENT : [ \\t]+ { p.TokenStartColumn==0 }?\n");
+		grammarBuilder.append("INDENT : [ \\t]+ { p.TokenStartColumn == 0 }?\n");
 		grammarBuilder.append("         { fmt.Println(\"INDENT\") }  ;\n");
 		grammarBuilder.append("NL : '\\n';\n");
 		grammarBuilder.append("WS : [ \\t]+ ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestParserExec.java
Patch:
@@ -639,14 +639,14 @@ public void testOptional_4() throws Exception {
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(168);
+		StringBuilder grammarBuilder = new StringBuilder(160);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("boolean Property() {\n");
 		grammarBuilder.append("  return true;\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {$parser.Property()}? ID {System.out.println(\"valid\");}\n");
+		grammarBuilder.append("a : {Property()}? ID {System.out.println(\"valid\");}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestParserExec.java
Patch:
@@ -585,14 +585,14 @@ public void testOptional_4() throws Exception {
 	@Test
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
-		StringBuilder grammarBuilder = new StringBuilder(171);
+		StringBuilder grammarBuilder = new StringBuilder(163);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("this.Property = function() {\n");
 		grammarBuilder.append("    return true;\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {$parser.Property()}? ID {console.log(\"valid\");}\n");
+		grammarBuilder.append("a : {Property()}? ID {console.log(\"valid\");}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestParserExec.java
Patch:
@@ -666,14 +666,14 @@ public void testOptional_4() throws Exception {
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(153);
+		StringBuilder grammarBuilder = new StringBuilder(145);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("def Property(self):\n");
 		grammarBuilder.append("    return True\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {$parser.Property()}? ID {print(\"valid\")}\n");
+		grammarBuilder.append("a : {Property()}? ID {print(\"valid\")}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestParserExec.java
Patch:
@@ -666,14 +666,14 @@ public void testOptional_4() throws Exception {
 	public void testParserProperty() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(153);
+		StringBuilder grammarBuilder = new StringBuilder(145);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
 		grammarBuilder.append("def Property(self):\n");
 		grammarBuilder.append("    return True\n");
 		grammarBuilder.append("\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {$parser.Property()}? ID {print(\"valid\")}\n");
+		grammarBuilder.append("a : {Property()}? ID {print(\"valid\")}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -788,7 +788,8 @@ protected int execATNWithFullContext(DFA dfa,
 	protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,
 										   boolean fullCtx)
 	{
-		if ( debug ) System.out.println("in computeReachSet, starting closure: " + closure);
+		if ( debug ) 
+			System.out.println("in computeReachSet, starting closure: " + closure);
 
 		if (mergeCache == null) {
 			mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext, PredictionContext>();

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -920,8 +920,8 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "<createParser>"
 						+ "\n"
 						+ "  Ref\\<tree::ParseTree> tree = parser.<parserStartRuleName>;\n"
-						+ "  Ref\\<TreeShapeListener> listener(new TreeShapeListener());\n"
-						+ "  tree::ParseTreeWalker::DEFAULT->walk(listener, tree);\n"
+						+ "  TreeShapeListener listener;\n"
+						+ "  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\n"
 						+ "\n"
 						+ "  return 0;\n"
 						+ "}\n"

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -1,4 +1,3 @@
-
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
@@ -66,7 +65,7 @@ protected void addBadWords() {
 
 	@Override
 	public String encodeIntAsCharEscape(int v) {
-		return Integer.toString(v) + ",";
+		return Integer.toString(v);
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -1,4 +1,3 @@
-
 package org.antlr.v4.codegen.target;
 
 import org.antlr.v4.codegen.CodeGenerator;
@@ -66,7 +65,7 @@ protected void addBadWords() {
 
 	@Override
 	public String encodeIntAsCharEscape(int v) {
-		return Integer.toString(v) + ",";
+		return Integer.toString(v);
 	}
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java
Patch:
@@ -888,7 +888,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "\n"
 						+ "#include \"support/StringUtils.h\"\n"
 						+ "\n"
-						+ "using namespace org::antlr::v4::runtime;\n"
+						+ "using namespace antlr4;\n"
 						+ "\n"
 						+ "class TreeShapeListener : public tree::ParseTreeListener {\n"
 						+ "public:\n"
@@ -953,7 +953,7 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 					+ "\n"
 					+ "#include \"support/StringUtils.h\"\n"
 					+ "\n"
-					+ "using namespace org::antlr::v4::runtime;\n"
+					+ "using namespace antlr4;\n"
 					+ "\n"
 					+ "int main(int argc, const char* argv[]) {\n"
 					+ "  std::wifstream stream;\n"

File: runtime-testsuite/test/org/antlr/v4/test/runtime/csharp/TestSemPredEvalParser.java
Patch:
@@ -552,11 +552,11 @@ public void testToLeft() throws Exception {
 	@Test
 	public void testToLeftWithVaryingPredicate() throws Exception {
 		mkdir(tmpdir);
-		StringBuilder grammarBuilder = new StringBuilder(268);
+		StringBuilder grammarBuilder = new StringBuilder(261);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {int i = 0;}\n");
 		grammarBuilder.append("s : ({this.i += 1;\n");
-		grammarBuilder.append("Console.WriteLine(\"i=\" + this.i);} a)+ ;\n");
+		grammarBuilder.append("Console.WriteLine(\"i=\"+i);} a)+ ;\n");
 		grammarBuilder.append("a : {this.i % 2 == 0}? ID {Console.WriteLine(\"alt 1\");}\n");
 		grammarBuilder.append("  | {this.i % 2 != 0}? ID {Console.WriteLine(\"alt 2\");}\n");
 		grammarBuilder.append("  ;\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestSemPredEvalParser.java
Patch:
@@ -646,11 +646,11 @@ public void testToLeft() throws Exception {
 	public void testToLeftWithVaryingPredicate() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(271);
+		StringBuilder grammarBuilder = new StringBuilder(264);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {int i = 0;}\n");
 		grammarBuilder.append("s : ({this.i += 1;\n");
-		grammarBuilder.append("System.out.println(\"i=\" + this.i);} a)+ ;\n");
+		grammarBuilder.append("System.out.println(\"i=\"+i);} a)+ ;\n");
 		grammarBuilder.append("a : {this.i % 2 == 0}? ID {System.out.println(\"alt 1\");}\n");
 		grammarBuilder.append("  | {this.i % 2 != 0}? ID {System.out.println(\"alt 2\");}\n");
 		grammarBuilder.append("  ;\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/javascript/node/TestSemPredEvalParser.java
Patch:
@@ -600,11 +600,11 @@ public void testToLeft() throws Exception {
 	@Test
 	public void testToLeftWithVaryingPredicate() throws Exception {
 		mkdir(tmpdir);
-		StringBuilder grammarBuilder = new StringBuilder(252);
+		StringBuilder grammarBuilder = new StringBuilder(245);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {this.i = 0;}\n");
 		grammarBuilder.append("s : ({this.i += 1;\n");
-		grammarBuilder.append("console.log(\"i=\" + this.i);} a)+ ;\n");
+		grammarBuilder.append("console.log(\"i=\"+i);} a)+ ;\n");
 		grammarBuilder.append("a : {this.i % 2 === 0}? ID {console.log(\"alt 1\");}\n");
 		grammarBuilder.append("  | {this.i % 2 != 0}? ID {console.log(\"alt 2\");}\n");
 		grammarBuilder.append("  ;\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python2/TestSemPredEvalParser.java
Patch:
@@ -669,11 +669,11 @@ public void testToLeft() throws Exception {
 	public void testToLeftWithVaryingPredicate() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(228);
+		StringBuilder grammarBuilder = new StringBuilder(226);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {i = 0}\n");
 		grammarBuilder.append("s : ({self.i += 1\n");
-		grammarBuilder.append("print(\"i=\" + str(self.i))} a)+ ;\n");
+		grammarBuilder.append("print(str(\"i=\")+str(i))} a)+ ;\n");
 		grammarBuilder.append("a : {self.i % 2 == 0}? ID {print(\"alt 1\")}\n");
 		grammarBuilder.append("  | {self.i % 2 != 0}? ID {print(\"alt 2\")}\n");
 		grammarBuilder.append("  ;\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/TestSemPredEvalParser.java
Patch:
@@ -669,11 +669,11 @@ public void testToLeft() throws Exception {
 	public void testToLeftWithVaryingPredicate() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(228);
+		StringBuilder grammarBuilder = new StringBuilder(226);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {i = 0}\n");
 		grammarBuilder.append("s : ({self.i += 1\n");
-		grammarBuilder.append("print(\"i=\" + str(self.i))} a)+ ;\n");
+		grammarBuilder.append("print(str(\"i=\")+str(i))} a)+ ;\n");
 		grammarBuilder.append("a : {self.i % 2 == 0}? ID {print(\"alt 1\")}\n");
 		grammarBuilder.append("  | {self.i % 2 != 0}? ID {print(\"alt 2\")}\n");
 		grammarBuilder.append("  ;\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseTest.java
Patch:
@@ -444,7 +444,7 @@ private String locateTool(String tool) {
 		paths.add("c:\\Go\\bin");
 
 		for (String path : paths) {
-			File candidate = new File(path + File.separatorChar + tool);
+			File candidate = new File(new File(path), tool);
 			if (candidate.exists()) {
 				return candidate.getPath();
 			}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -590,7 +590,7 @@ public void testParserProperty() throws Exception {
 		grammarBuilder.append("  return true\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {$parser.Property()}? ID {fmt.Println(\"valid\")}\n");
+		grammarBuilder.append("a : {Property()}? ID {fmt.Println(\"valid\")}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
@@ -611,7 +611,7 @@ public void testPredicatedIfIfElse() throws Exception {
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("s : stmt EOF ;\n");
 		grammarBuilder.append("stmt : ifStmt | ID;\n");
-		grammarBuilder.append("ifStmt : 'if' ID stmt ('else' stmt | { p.GetTokenStream().LA(1)!=TParser.ELSE }?);\n");
+		grammarBuilder.append("ifStmt : 'if' ID stmt ('else' stmt | { p.GetTokenStream().LA(1)!=TParserELSE }?);\n");
 		grammarBuilder.append("ELSE : 'else';\n");
 		grammarBuilder.append("ID : [a-zA-Z]+;\n");
 		grammarBuilder.append("WS : [ \\n\\t]+ -> skip;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -590,7 +590,7 @@ public void testParserProperty() throws Exception {
 		grammarBuilder.append("  return true\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
-		grammarBuilder.append("a : {$parser.Property()}? ID {fmt.Println(\"valid\")}\n");
+		grammarBuilder.append("a : {Property()}? ID {fmt.Println(\"valid\")}\n");
 		grammarBuilder.append("  ;\n");
 		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
@@ -611,7 +611,7 @@ public void testPredicatedIfIfElse() throws Exception {
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("s : stmt EOF ;\n");
 		grammarBuilder.append("stmt : ifStmt | ID;\n");
-		grammarBuilder.append("ifStmt : 'if' ID stmt ('else' stmt | { p.GetTokenStream().LA(1)!=TParser.ELSE }?);\n");
+		grammarBuilder.append("ifStmt : 'if' ID stmt ('else' stmt | { p.GetTokenStream().LA(1)!=TParserELSE }?);\n");
 		grammarBuilder.append("ELSE : 'else';\n");
 		grammarBuilder.append("ID : [a-zA-Z]+;\n");
 		grammarBuilder.append("WS : [ \\n\\t]+ -> skip;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeLexers.java
Patch:
@@ -13,7 +13,7 @@ public class TestCompositeLexers extends BaseCppTest {
 	public void testLexerDelegatorInvokesDelegateRule() throws Exception {
 		mkdir(tmpdir);
 
-		String slave_S =
+		String slave_S = 
 			"lexer grammar S;\n" +
 			"A : 'a' {std::cout << \"S.A\" << \"\\n\";};\n" +
 			"C : 'c' ;";
@@ -43,7 +43,7 @@ public void testLexerDelegatorInvokesDelegateRule() throws Exception {
 	public void testLexerDelegatorRuleOverridesDelegate() throws Exception {
 		mkdir(tmpdir);
 
-		String slave_S =
+		String slave_S = 
 			"lexer grammar S;\n" +
 			"A : 'a' {std::cout << \"S.A\" << \"\\n\";} ;\n" +
 			"B : 'b' {std::cout << \"S.B\" << \"\\n\";} ;";

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestCompositeParsers.java
Patch:
@@ -143,10 +143,10 @@ public void testDelegatorAccessesDelegateMembers() throws Exception {
 			"a : B;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
-		StringBuilder grammarBuilder = new StringBuilder(126);
+		StringBuilder grammarBuilder = new StringBuilder(121);
 		grammarBuilder.append("grammar M; // uses no rules from the import\n");
 		grammarBuilder.append("import S;\n");
-		grammarBuilder.append("s : 'b' {self.foo()} ; // gS is import pointer\n");
+		grammarBuilder.append("s : 'b' {foo()} ; // gS is import pointer\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
 		String grammar = grammarBuilder.toString();
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/TestParserErrors.java
Patch:
@@ -211,7 +211,7 @@ public void testInvalidEmptyInput() throws Exception {
 	public void testLL1ErrorInfo() throws Exception {
 		mkdir(tmpdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(329);
+		StringBuilder grammarBuilder = new StringBuilder(314);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("start : animal (AND acClass)? service EOF;\n");
 		grammarBuilder.append("animal : (DOG | CAT );\n");
@@ -224,7 +224,7 @@ public void testLL1ErrorInfo() throws Exception {
 		grammarBuilder.append("WS : ' ' -> skip ;\n");
 		grammarBuilder.append("acClass\n");
 		grammarBuilder.append("@init\n");
-		grammarBuilder.append("{std::cout << self.getExpectedTokens().toString(self.literalNames, self.symbolicNames) << \"\\n\";}\n");
+		grammarBuilder.append("{std::cout << getExpectedTokens().toString(literalNames, symbolicNames) << \"\\n\";}\n");
 		grammarBuilder.append("  : ;");
 		String grammar = grammarBuilder.toString();
 

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -236,7 +236,7 @@ public Handle lexerCallCommand(GrammarAST ID, GrammarAST arg) {
 
 		cmdST.add("arg", arg.getText());
 		cmdST.add("grammar", arg.g);
-		return cmdST.render();
+		return action(cmdST.render());
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/model/ParserFile.java
Patch:
@@ -47,8 +47,6 @@ public class ParserFile extends OutputFile {
 	@ModelElement public Parser parser;
 	@ModelElement public Map<String, Action> namedActions;
 	@ModelElement public ActionChunk contextSuperClass;
-	public Boolean genListener = false;
-	public Boolean genVisitor = false;
 	public String grammarName;
 
 	public ParserFile(OutputModelFactory factory, String fileName) {

File: tool/src/org/antlr/v4/codegen/target/CppTarget.java
Patch:
@@ -77,7 +77,7 @@ public CppTarget(CodeGenerator gen) {
 	}
 
 	public String getVersion() {
-		return "4.5.2";
+		return "4.5.4";
 	}
 
     public boolean needsHeader() { return true; }

File: tool/src/org/antlr/v4/codegen/ActionTranslator.java
Patch:
@@ -138,7 +138,7 @@ public static List<ActionChunk> translateAction(OutputModelFactory factory,
 													ActionAST node)
 	{
 		String action = tokenWithinAction.getText();
-		if ( action.charAt(0)=='{' ) {
+		if ( action!=null && action.length()>0 && action.charAt(0)=='{' ) {
 			int firstCurly = action.indexOf('{');
 			int lastCurly = action.lastIndexOf('}');
 			if ( firstCurly>=0 && lastCurly>=0 ) {
@@ -158,7 +158,7 @@ public static List<ActionChunk> translateActionChunk(OutputModelFactory factory,
 		translator.rf = rf;
         factory.getGrammar().tool.log("action-translator", "translate " + action);
 		String altLabel = node.getAltLabel();
-		if ( rf!=null ) { 
+		if ( rf!=null ) {
 		    translator.nodeContext = rf.ruleCtx;
 	        if ( altLabel!=null ) translator.nodeContext = rf.altLabelCtxs.get(altLabel);
 		}

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -154,6 +154,7 @@ public String lexerCallCommand(GrammarAST ID, GrammarAST arg) {
 		}
 
 		cmdST.add("arg", arg.getText());
+		cmdST.add("grammar", arg.g);
 		return cmdST.render();
 	}
 

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -41,7 +41,7 @@ protected String getLanguage() {
 
 	@Override
 	protected String getPythonExecutable() {
-		return "python3.5";
+		return "python3";
 	}
 
 	@Override

File: tool/src/org/antlr/v4/codegen/model/ParserFile.java
Patch:
@@ -63,8 +63,8 @@ public ParserFile(OutputModelFactory factory, String fileName) {
 		genVisitor = g.tool.gen_visitor;
 		grammarName = g.name;
 
-		if (g.getOptionString("superClass") != null) {
-			contextSuperClass = new ActionText(null, g.getOptionString("superClass"));
+		if (g.getOptionString("contextSuperClass") != null) {
+			contextSuperClass = new ActionText(null, g.getOptionString("contextSuperClass"));
 		}
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/Vocabulary.java
Patch:
@@ -37,10 +37,9 @@
  * @author Sam Harwell
  */
 public interface Vocabulary {
-
 	/**
 	 * Returns the highest token type value. It can be used to iterate from
-	 * zero to that number, thus querying all stored entries.
+	 * zero to that number, inclusively, thus querying all stored entries.
 	 * @return the highest token type value
 	 */
 	int getMaxTokenType();

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -41,7 +41,7 @@ protected String getLanguage() {
 
 	@Override
 	protected String getPythonExecutable() {
-		return "python3.4"; 
+		return "python3.5";
 	}
 
 	@Override

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -168,8 +168,7 @@ public boolean translateLeftRecursiveRule(GrammarRootAST ast,
 
 		// track recursive alt info for codegen
 		r.recPrimaryAlts = new ArrayList<LeftRecursiveRuleAltInfo>();
-		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.prefixAlts);
-		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.otherAlts);
+		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.prefixAndOtherAlts);
 		if (r.recPrimaryAlts.isEmpty()) {
 			tool.errMgr.grammarError(ErrorType.NO_NON_LR_ALTS, g.fileName, ((GrammarAST)r.ast.getChild(0)).getToken(), r.name);
 		}

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -168,7 +168,7 @@ public boolean translateLeftRecursiveRule(GrammarRootAST ast,
 
 		// track recursive alt info for codegen
 		r.recPrimaryAlts = new ArrayList<LeftRecursiveRuleAltInfo>();
-		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.prefixAlts);
+		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.prefixAndOtherAlts);
 		if (r.recPrimaryAlts.isEmpty()) {
 			tool.errMgr.grammarError(ErrorType.NO_NON_LR_ALTS, g.fileName, ((GrammarAST)r.ast.getChild(0)).getToken(), r.name);
 		}

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -169,7 +169,6 @@ public boolean translateLeftRecursiveRule(GrammarRootAST ast,
 		// track recursive alt info for codegen
 		r.recPrimaryAlts = new ArrayList<LeftRecursiveRuleAltInfo>();
 		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.prefixAlts);
-		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.otherAlts);
 		if (r.recPrimaryAlts.isEmpty()) {
 			tool.errMgr.grammarError(ErrorType.NO_NON_LR_ALTS, g.fileName, ((GrammarAST)r.ast.getChild(0)).getToken(), r.name);
 		}

File: tool/src/org/antlr/v4/codegen/target/Python2Target.java
Patch:
@@ -61,7 +61,7 @@ public class Python2Target extends Target {
 		"memoryview",
 		"object", "oct", "open", "ord",
 		"pow", "print", "property",
-		"range", "raw_input", "reduce", "reload", "repr", "reversed", "round",
+		"range", "raw_input", "reduce", "reload", "repr", "return", "reversed", "round",
 		"set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super",
 		"tuple", "type",
 		"unichr", "unicode",

File: tool/src/org/antlr/v4/analysis/AnalysisPipeline.java
Patch:
@@ -100,7 +100,7 @@ protected void processParser() {
 		}
 	}
 
-	/** Return whether lookahead sets are disjoint; no lookahead => not disjoint */
+	/** Return whether lookahead sets are disjoint; no lookahead  not disjoint */
 	public static boolean disjoint(IntervalSet[] altLook) {
 		boolean collision = false;
 		IntervalSet combined = new IntervalSet();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -330,7 +330,7 @@ public GrammarAST stripLeftRecursion(GrammarAST altAST) {
 		return lrlabel;
 	}
 
-	/** Strip last 2 tokens if -> label; alter indexes in altAST */
+	/** Strip last 2 tokens if  label; alter indexes in altAST */
 	public void stripAltLabel(GrammarAST altAST) {
 		int start = altAST.getTokenStartIndex();
 		int stop = altAST.getTokenStopIndex();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -244,9 +244,9 @@ public RuleAST parseArtificialRule(final Grammar g, String ruleText) {
 	 * 			(ALT ID))
 	 * 		(* (BLOCK
 	 *			(OPTIONS ...)
-	 * 			(ALT {7 >= $_p}? '*' (= b e) {$v = $a.v * $b.v;})
-	 * 			(ALT {6 >= $_p}? '+' (= b e) {$v = $a.v + $b.v;})
-	 * 			(ALT {3 >= $_p}? '++') (ALT {2 >= $_p}? '--'))))))
+	 * 			(ALT {7 &gt;= $_p}? '*' (= b e) {$v = $a.v * $b.v;})
+	 * 			(ALT {6 &gt;= $_p}? '+' (= b e) {$v = $a.v + $b.v;})
+	 * 			(ALT {3 &gt;= $_p}? '++') (ALT {2 &gt;= $_p}? '--'))))))
 	 * </pre>
 	 */
 	public void setAltASTPointers(LeftRecursiveRule r, RuleAST t) {

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -324,7 +324,7 @@ else if ( t.getType()==ANTLRParser.TOKEN_REF ) {
 
 	/** For a lexer, a string is a sequence of char to match.  That is,
 	 *  "fog" is treated as 'f' 'o' 'g' not as a single transition in
-	 *  the DFA.  Machine== o-'f'->o-'o'->o-'g'->o and has n+1 states
+	 *  the DFA.  Machine== o-'f'-&gt;o-'o'-&gt;o-'g'-&gt;o and has n+1 states
 	 *  for n characters.
 	 */
 	@Override

File: tool/src/org/antlr/v4/codegen/OutputModelWalker.java
Patch:
@@ -53,7 +53,7 @@
  *  We identify those nested objects by the list of arguments in the template
  *  definition. For example, here is the definition of the parser template:
  *
- *  Parser(parser, scopes, funcs) ::= <<...>>
+ *  Parser(parser, scopes, funcs) ::= &lt;&lt;...&gt;&gt;
  *
  *  The first template argument is always the output model object from which
  *  this walker will create the template. Any other arguments identify

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -56,7 +56,7 @@ public abstract class Target {
 	 *  predicates and such that may refer to chars that need to be escaped
 	 *  when represented as strings.  Also, templates need to be escaped so
 	 *  that the target language can hold them as a string.
-	 *  <p/>
+	 *  <p>
 	 *  I have defined (via the constructor) the set of typical escapes,
 	 *  but your {@link Target} subclass is free to alter the translated chars
 	 *  or add more definitions.  This is non-static so each target can have

File: tool/src/org/antlr/v4/codegen/model/decl/AltLabelStructDecl.java
Patch:
@@ -38,7 +38,7 @@
 
 import java.util.ArrayList;
 
-/** A StructDecl to handle a -> label on alt */
+/** A StructDecl to handle a -&gt; label on alt */
 public class AltLabelStructDecl extends StructDecl {
 	public int altNum;
 	public AltLabelStructDecl(OutputModelFactory factory, Rule r,

File: tool/src/org/antlr/v4/codegen/target/JavaScriptTarget.java
Patch:
@@ -93,11 +93,11 @@ protected void addBadWords() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
+	 * <p>
 	 * For Java, this is the translation {@code 'a\n"'} &rarr; {@code "a\n\""}.
 	 * Expect single quotes around the incoming literal. Just flip the quotes
 	 * and replace double quotes with {@code \"}.
-	 * <p/>
+	 * <p>
 	 * Note that we have decided to allow people to use '\"' without penalty, so
 	 * we must build the target string in a loop as {@link String#replace}
 	 * cannot handle both {@code \"} and {@code "} without a lot of messing

File: tool/src/org/antlr/v4/misc/Graph.java
Patch:
@@ -81,7 +81,7 @@ protected Node<T> getNode(T a) {
 	 *  For sorting, I'm not following convention here since ANTLR
 	 *  needs the opposite.  Here's what I assume for sorting:
 	 *
-	 *    If there exists an edge u -> v then u depends on v and v
+	 *    If there exists an edge u -&gt; v then u depends on v and v
 	 *    must happen before u.
 	 *
 	 *  So if this gives nonreversed postorder traversal, I get the order
@@ -114,4 +114,4 @@ public void DFS(Node<T> n, Set<Node<T>> visited, ArrayList<T> sorted) {
 		}
 		sorted.add(n.payload);
 	}
-}
\ No newline at end of file
+}

File: tool/src/org/antlr/v4/parse/GrammarToken.java
Patch:
@@ -35,7 +35,7 @@
 import org.antlr.v4.tool.Grammar;
 
 /** A CommonToken that can also track it's original location,
- *  derived from options on the element ref like BEGIN<line=34,...>.
+ *  derived from options on the element ref like BEGIN&lt;line=34,...&gt;.
  */
 public class GrammarToken extends CommonToken {
 	public Grammar g;

File: tool/src/org/antlr/v4/tool/AttributeDict.java
Patch:
@@ -39,7 +39,7 @@
 import java.util.Set;
 
 /** Track the attributes within retval, arg lists etc...
- *  <p/>
+ *  <p>
  *  Each rule has potentially 3 scopes: return values,
  *  parameters, and an implicitly-named scope (i.e., a scope defined in a rule).
  *  Implicitly-defined scopes are named after the rule; rules and scopes then

File: tool/src/org/antlr/v4/tool/GrammarParserInterpreter.java
Patch:
@@ -151,7 +151,7 @@ else if ( startState.transition(0).target == decisionState ) {
 	 *  it's simple. Set decisionStatesThatSetOuterAltNumInContext
 	 *  indicates which decision states should set the outer alternative number.
 	 *
-	 *  Left recursive rules are much more complicated to deal with:
+	 *  <p>Left recursive rules are much more complicated to deal with:
 	 *  there is typically a decision for the primary alternatives and a
 	 *  decision to choose between the recursive operator alternatives.
 	 *  For example, the following left recursive rule has two primary and 2

File: tool/src/org/antlr/v4/tool/LeftRecursiveRule.java
Patch:
@@ -136,7 +136,7 @@ public int[] getRecursiveOpAlts() {
 		return alts;
 	}
 
-	/** Get -> labels from those alts we deleted for left-recursive rules. */
+	/** Get -&gt; labels from those alts we deleted for left-recursive rules. */
 	@Override
 	public Map<String, List<Pair<Integer, AltAST>>> getAltLabels() {
 		Map<String, List<Pair<Integer, AltAST>>> labels = new HashMap<String, List<Pair<Integer, AltAST>>>();

File: tool/src/org/antlr/v4/analysis/AnalysisPipeline.java
Patch:
@@ -100,7 +100,7 @@ protected void processParser() {
 		}
 	}
 
-	/** Return whether lookahead sets are disjoint; no lookahead => not disjoint */
+	/** Return whether lookahead sets are disjoint; no lookahead  not disjoint */
 	public static boolean disjoint(IntervalSet[] altLook) {
 		boolean collision = false;
 		IntervalSet combined = new IntervalSet();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -330,7 +330,7 @@ public GrammarAST stripLeftRecursion(GrammarAST altAST) {
 		return lrlabel;
 	}
 
-	/** Strip last 2 tokens if -> label; alter indexes in altAST */
+	/** Strip last 2 tokens if  label; alter indexes in altAST */
 	public void stripAltLabel(GrammarAST altAST) {
 		int start = altAST.getTokenStartIndex();
 		int stop = altAST.getTokenStopIndex();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -244,9 +244,9 @@ public RuleAST parseArtificialRule(final Grammar g, String ruleText) {
 	 * 			(ALT ID))
 	 * 		(* (BLOCK
 	 *			(OPTIONS ...)
-	 * 			(ALT {7 >= $_p}? '*' (= b e) {$v = $a.v * $b.v;})
-	 * 			(ALT {6 >= $_p}? '+' (= b e) {$v = $a.v + $b.v;})
-	 * 			(ALT {3 >= $_p}? '++') (ALT {2 >= $_p}? '--'))))))
+	 * 			(ALT {7 &gt;= $_p}? '*' (= b e) {$v = $a.v * $b.v;})
+	 * 			(ALT {6 &gt;= $_p}? '+' (= b e) {$v = $a.v + $b.v;})
+	 * 			(ALT {3 &gt;= $_p}? '++') (ALT {2 &gt;= $_p}? '--'))))))
 	 * </pre>
 	 */
 	public void setAltASTPointers(LeftRecursiveRule r, RuleAST t) {

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -324,7 +324,7 @@ else if ( t.getType()==ANTLRParser.TOKEN_REF ) {
 
 	/** For a lexer, a string is a sequence of char to match.  That is,
 	 *  "fog" is treated as 'f' 'o' 'g' not as a single transition in
-	 *  the DFA.  Machine== o-'f'->o-'o'->o-'g'->o and has n+1 states
+	 *  the DFA.  Machine== o-'f'-&gt;o-'o'-&gt;o-'g'-&gt;o and has n+1 states
 	 *  for n characters.
 	 */
 	@Override

File: tool/src/org/antlr/v4/codegen/OutputModelWalker.java
Patch:
@@ -53,7 +53,7 @@
  *  We identify those nested objects by the list of arguments in the template
  *  definition. For example, here is the definition of the parser template:
  *
- *  Parser(parser, scopes, funcs) ::= <<...>>
+ *  Parser(parser, scopes, funcs) ::= &lt;&lt;...&gt;&gt;
  *
  *  The first template argument is always the output model object from which
  *  this walker will create the template. Any other arguments identify

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -56,7 +56,7 @@ public abstract class Target {
 	 *  predicates and such that may refer to chars that need to be escaped
 	 *  when represented as strings.  Also, templates need to be escaped so
 	 *  that the target language can hold them as a string.
-	 *  <p/>
+	 *  <p>
 	 *  I have defined (via the constructor) the set of typical escapes,
 	 *  but your {@link Target} subclass is free to alter the translated chars
 	 *  or add more definitions.  This is non-static so each target can have

File: tool/src/org/antlr/v4/codegen/model/decl/AltLabelStructDecl.java
Patch:
@@ -38,7 +38,7 @@
 
 import java.util.ArrayList;
 
-/** A StructDecl to handle a -> label on alt */
+/** A StructDecl to handle a -&gt; label on alt */
 public class AltLabelStructDecl extends StructDecl {
 	public int altNum;
 	public AltLabelStructDecl(OutputModelFactory factory, Rule r,

File: tool/src/org/antlr/v4/codegen/target/JavaScriptTarget.java
Patch:
@@ -93,11 +93,11 @@ protected void addBadWords() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
+	 * <p>
 	 * For Java, this is the translation {@code 'a\n"'} &rarr; {@code "a\n\""}.
 	 * Expect single quotes around the incoming literal. Just flip the quotes
 	 * and replace double quotes with {@code \"}.
-	 * <p/>
+	 * <p>
 	 * Note that we have decided to allow people to use '\"' without penalty, so
 	 * we must build the target string in a loop as {@link String#replace}
 	 * cannot handle both {@code \"} and {@code "} without a lot of messing

File: tool/src/org/antlr/v4/misc/Graph.java
Patch:
@@ -81,7 +81,7 @@ protected Node<T> getNode(T a) {
 	 *  For sorting, I'm not following convention here since ANTLR
 	 *  needs the opposite.  Here's what I assume for sorting:
 	 *
-	 *    If there exists an edge u -> v then u depends on v and v
+	 *    If there exists an edge u -&gt; v then u depends on v and v
 	 *    must happen before u.
 	 *
 	 *  So if this gives nonreversed postorder traversal, I get the order
@@ -114,4 +114,4 @@ public void DFS(Node<T> n, Set<Node<T>> visited, ArrayList<T> sorted) {
 		}
 		sorted.add(n.payload);
 	}
-}
\ No newline at end of file
+}

File: tool/src/org/antlr/v4/parse/GrammarToken.java
Patch:
@@ -35,7 +35,7 @@
 import org.antlr.v4.tool.Grammar;
 
 /** A CommonToken that can also track it's original location,
- *  derived from options on the element ref like BEGIN<line=34,...>.
+ *  derived from options on the element ref like BEGIN&lt;line=34,...&gt;.
  */
 public class GrammarToken extends CommonToken {
 	public Grammar g;

File: tool/src/org/antlr/v4/tool/AttributeDict.java
Patch:
@@ -39,7 +39,7 @@
 import java.util.Set;
 
 /** Track the attributes within retval, arg lists etc...
- *  <p/>
+ *  <p>
  *  Each rule has potentially 3 scopes: return values,
  *  parameters, and an implicitly-named scope (i.e., a scope defined in a rule).
  *  Implicitly-defined scopes are named after the rule; rules and scopes then

File: tool/src/org/antlr/v4/tool/GrammarParserInterpreter.java
Patch:
@@ -151,7 +151,7 @@ else if ( startState.transition(0).target == decisionState ) {
 	 *  it's simple. Set decisionStatesThatSetOuterAltNumInContext
 	 *  indicates which decision states should set the outer alternative number.
 	 *
-	 *  Left recursive rules are much more complicated to deal with:
+	 *  <p>Left recursive rules are much more complicated to deal with:
 	 *  there is typically a decision for the primary alternatives and a
 	 *  decision to choose between the recursive operator alternatives.
 	 *  For example, the following left recursive rule has two primary and 2

File: tool/src/org/antlr/v4/tool/LeftRecursiveRule.java
Patch:
@@ -136,7 +136,7 @@ public int[] getRecursiveOpAlts() {
 		return alts;
 	}
 
-	/** Get -> labels from those alts we deleted for left-recursive rules. */
+	/** Get -&gt; labels from those alts we deleted for left-recursive rules. */
 	@Override
 	public Map<String, List<Pair<Integer, AltAST>>> getAltLabels() {
 		Map<String, List<Pair<Integer, AltAST>>> labels = new HashMap<String, List<Pair<Integer, AltAST>>>();

File: tool/src/org/antlr/v4/codegen/target/Python2Target.java
Patch:
@@ -61,7 +61,7 @@ public class Python2Target extends Target {
 		"memoryview",
 		"object", "oct", "open", "ord",
 		"pow", "print", "property",
-		"range", "raw_input", "reduce", "reload", "repr", "reversed", "round",
+		"range", "raw_input", "reduce", "reload", "repr", "return", "reversed", "round",
 		"set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super",
 		"tuple", "type",
 		"unichr", "unicode",

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -847,7 +847,7 @@ public void testActions(String templates, String actionName, String action, Stri
 			g.atn = factory.createATN();
 
 			CodeGenerator gen = new CodeGenerator(g);
-			ST outputFileST = gen.generateParser();
+			ST outputFileST = gen.generateParser(false);
 			String output = outputFileST.render();
 			//System.out.println(output);
 			String b = "#" + actionName + "#";

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -169,7 +169,6 @@ public boolean translateLeftRecursiveRule(GrammarRootAST ast,
 		// track recursive alt info for codegen
 		r.recPrimaryAlts = new ArrayList<LeftRecursiveRuleAltInfo>();
 		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.prefixAlts);
-		r.recPrimaryAlts.addAll(leftRecursiveRuleWalker.otherAlts);
 		if (r.recPrimaryAlts.isEmpty()) {
 			tool.errMgr.grammarError(ErrorType.NO_NON_LR_ALTS, g.fileName, ((GrammarAST)r.ast.getChild(0)).getToken(), r.name);
 		}

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSemPredEvalParser.java
Patch:
@@ -599,11 +599,11 @@ public void testToLeft() throws Exception {
 	@Test
 	public void testToLeftWithVaryingPredicate() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(247);
+		StringBuilder grammarBuilder = new StringBuilder(259);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {var i int = 0; var _ int = i; }\n");
 		grammarBuilder.append("s : ({i += 1;\n");
-		grammarBuilder.append("fmt.Println(\"i=\" + i)} a)+ ;\n");
+		grammarBuilder.append("fmt.Println(\"i=\" + fmt.Sprint(i))} a)+ ;\n");
 		grammarBuilder.append("a : {i % 2 == 0}? ID {fmt.Println(\"alt 1\")}\n");
 		grammarBuilder.append("  | {i % 2 != 0}? ID {fmt.Println(\"alt 2\")}\n");
 		grammarBuilder.append("  ;\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParseTrees.java
Patch:
@@ -200,7 +200,7 @@ public void testToken2() throws Exception {
 	@Test
 	public void testTokenAndRuleContextString() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(163);
+		StringBuilder grammarBuilder = new StringBuilder(166);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("s\n");
 		grammarBuilder.append("@init {\n");
@@ -211,7 +211,7 @@ public void testTokenAndRuleContextString() throws Exception {
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("  : r=a ;\n");
 		grammarBuilder.append("a : 'x' { \n");
-		grammarBuilder.append("fmt.Println(p.GetRuleInvocationStack())\n");
+		grammarBuilder.append("fmt.Println(p.GetRuleInvocationStack(nil))\n");
 		grammarBuilder.append("} ;");
 		String grammar = grammarBuilder.toString();
 		String input ="x";

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -441,11 +441,10 @@ public void testLabels() throws Exception {
 	@Test
 	public void testListLabelForClosureContext() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(462);
+		StringBuilder grammarBuilder = new StringBuilder(420);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("ifStatement\n");
 		grammarBuilder.append("@after {\n");
-		grammarBuilder.append("List<?> __ttt__ = $ctx.elseIfStatement();\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("    : 'if' expression\n");
 		grammarBuilder.append("      ( ( 'then'\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -584,11 +584,11 @@ public void testOptional_4() throws Exception {
 	@Test
 	public void testParserProperty() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(157);
+		StringBuilder grammarBuilder = new StringBuilder(161);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("@members {\n");
-		grammarBuilder.append("bool Property() {\n");
-		grammarBuilder.append("  return true;\n");
+		grammarBuilder.append("func Property() bool {\n");
+		grammarBuilder.append("  return true\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("}\n");
 		grammarBuilder.append("a : {$parser.Property()}? ID {fmt.Println(\"valid\")}\n");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestCompositeParsers.java
Patch:
@@ -379,7 +379,7 @@ public void testImportedRuleWithAction() throws Exception {
 		mkdir(parserpkgdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a @after {var x int = 0; var _ int = x; // to disable unused var } : B;";
+			"a @after {var x int = 0; var _ int = x; } : B;";
 		writeFile(parserpkgdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(62);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSemPredEvalLexer.java
Patch:
@@ -113,10 +113,10 @@ public void testIDvsEnum() throws Exception {
 	public void testIndent() throws Exception {
 		mkdir(parserpkgdir);
 
-		StringBuilder grammarBuilder = new StringBuilder(153);
+		StringBuilder grammarBuilder = new StringBuilder(152);
 		grammarBuilder.append("lexer grammar L;\n");
 		grammarBuilder.append("ID : [a-z]+  ;\n");
-		grammarBuilder.append("INDENT : [ \\t]+ { this._tokenStartCharPositionInLine==0 }?\n");
+		grammarBuilder.append("INDENT : [ \\t]+ { this.TokenStartCharPositionInLine==0 }?\n");
 		grammarBuilder.append("         { fmt.Println(\"INDENT\") }  ;\n");
 		grammarBuilder.append("NL : '\\n';\n");
 		grammarBuilder.append("WS : [ \\t]+ ;");

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestCompositeParsers.java
Patch:
@@ -379,7 +379,7 @@ public void testImportedRuleWithAction() throws Exception {
 		mkdir(parserpkgdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a @after {var x int = 0;} : B;";
+			"a @after {var x int = 0; var _ int = x; // to disable unused var } : B;";
 		writeFile(parserpkgdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(62);
@@ -406,10 +406,10 @@ public void testKeywordVSIDOrder() throws Exception {
 			"ID : 'a'..'z'+;";
 		writeFile(parserpkgdir, "S.g4", slave_S);
 
-		StringBuilder grammarBuilder = new StringBuilder(113);
+		StringBuilder grammarBuilder = new StringBuilder(125);
 		grammarBuilder.append("grammar M;\n");
 		grammarBuilder.append("import S;\n");
-		grammarBuilder.append("a : A {fmt.Println(\"M.a: \" + $A)};\n");
+		grammarBuilder.append("a : A {fmt.Println(\"M.a: \" + fmt.Sprint($A))};\n");
 		grammarBuilder.append("A : 'abc' {fmt.Println(\"M.A\")};\n");
 		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
 		String grammar = grammarBuilder.toString();

File: tool/src/org/antlr/v4/codegen/model/RuleActionFunction.java
Patch:
@@ -38,6 +38,7 @@
 public class RuleActionFunction extends OutputModelObject {
 	public String name;
 	public String ctxType;
+	public boolean isRuleContext;
 	public int ruleIndex;
 
 	/** Map actionIndex to Action */
@@ -48,6 +49,7 @@ public RuleActionFunction(OutputModelFactory factory, Rule r, String ctxType) {
 		super(factory);
 		name = r.name;
 		ruleIndex = r.index;
+		isRuleContext = ctxType.equals("RuleContext");
 		this.ctxType = ctxType;
 	}
 }

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseTest.java
Patch:
@@ -802,7 +802,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 		if (debug) {
 			createParserST = new ST(
 					"	p := parser.New<parserName>(stream)\n"
-							+ "	p.AddErrorListener(antlr4.NewDiagnosticErrorListener())\n");
+							+ "	p.AddErrorListener(antlr4.NewDiagnosticErrorListener(true))\n");
 		}
 		outputFileST.add("createParser", createParserST);
 		outputFileST.add("parserName", parserName);

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserErrors.java
Patch:
@@ -184,7 +184,7 @@ public void testInvalidEmptyInput() throws Exception {
 	@Test
 	public void testLL1ErrorInfo() throws Exception {
 		mkdir(parserpkgdir);
-		StringBuilder grammarBuilder = new StringBuilder(298);
+		StringBuilder grammarBuilder = new StringBuilder(314);
 		grammarBuilder.append("grammar T;\n");
 		grammarBuilder.append("start : animal (AND acClass)? service EOF;\n");
 		grammarBuilder.append("animal : (DOG | CAT );\n");
@@ -197,7 +197,7 @@ public void testLL1ErrorInfo() throws Exception {
 		grammarBuilder.append("WS : ' ' -> skip ;\n");
 		grammarBuilder.append("acClass\n");
 		grammarBuilder.append("@init\n");
-		grammarBuilder.append("{fmt.Println(this.GetExpectedTokens().toString(this.tokenNames))}\n");
+		grammarBuilder.append("{fmt.Println(p.GetExpectedTokens().StringVerbose(p.GetTokenNames(), nil, false))}\n");
 		grammarBuilder.append("  : ;");
 		String grammar = grammarBuilder.toString();
 		String input ="dog and software";

File: tool/src/org/antlr/v4/codegen/target/GoTarget.java
Patch:
@@ -96,11 +96,11 @@ public String toString(Object o, String formatString, Locale locale) {
 	}
 
 	public boolean wantsBaseListener() {
-		return false;
+		return true;
 	}
 
 	public boolean wantsBaseVisitor() {
-		return false;
+		return true;
 	}
 
 	public boolean supportsOverloadedMethods() {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1462,7 +1462,6 @@ protected void closure(ATNConfig config,
 						   boolean fullCtx,
 						   boolean treatEofAsEpsilon)
 	{
-		console.log("closure");
 		final int initialDepth = 0;
 		closureCheckingStopState(config, configs, closureBusy, collectPredicates,
 								 fullCtx,

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1462,6 +1462,7 @@ protected void closure(ATNConfig config,
 						   boolean fullCtx,
 						   boolean treatEofAsEpsilon)
 	{
+		console.log("closure");
 		final int initialDepth = 0;
 		closureCheckingStopState(config, configs, closureBusy, collectPredicates,
 								 fullCtx,

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseTest.java
Patch:
@@ -27,7 +27,7 @@
  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.automata.ATNFactory;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestCompositeLexers.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestCompositeParsers.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestFullContextParsing.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestLeftRecursion.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestLexerErrors.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestLexerExec.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestListeners.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParseTrees.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserErrors.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestParserExec.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestPerformance.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSemPredEvalLexer.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSemPredEvalParser.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/go/TestSets.java
Patch:
@@ -1,5 +1,5 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-package org.antlr.v4.test.runtime.javascript.node;
+package org.antlr.v4.test.runtime.go;
 
 import org.junit.Ignore;
 import org.junit.Test;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -570,7 +570,7 @@ protected int execATN(DFA dfa, DFAState s0,
 	 * {@code t}, or {@code null} if the target state for this edge is not
 	 * already cached
 	 */
-	protected DFAState getExistingTargetState(DFAState previousD, int t) {
+	protected DFAState getExistingTargetState( previousD, int t) {
 		DFAState[] edges = previousD.edges;
 		if (edges == null || t + 1 < 0 || t + 1 >= edges.length) {
 			return null;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializer.java
Patch:
@@ -368,7 +368,7 @@ else if (state instanceof StarLoopbackState) {
 		int ndecisions = toInt(data[p++]);
 		for (int i=1; i<=ndecisions; i++) {
 			int s = toInt(data[p++]);
-			DecisionState decState = (DecisionState)atn.states.get(s);
+			DecisionState decState = atn.states.get(s);
 			atn.decisionToState.add(decState);
 			decState.decision = i-1;
 		}

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -83,7 +83,7 @@ public class LexerATNFactory extends ParserATNFactory {
 	 * actions, but are required during code generation for creating
 	 * {@link LexerAction} instances that are usable by a lexer interpreter.
 	 */
-	protected static final Map<String, Integer> COMMON_CONSTANTS = new HashMap<String, Integer>();
+	public static final Map<String, Integer> COMMON_CONSTANTS = new HashMap<String, Integer>();
 	static {
 		COMMON_CONSTANTS.put("HIDDEN", Lexer.HIDDEN);
 		COMMON_CONSTANTS.put("DEFAULT_TOKEN_CHANNEL", Lexer.DEFAULT_TOKEN_CHANNEL);

File: tool/src/org/antlr/v4/gui/TestRig.java
Patch:
@@ -80,7 +80,7 @@ public class TestRig {
 
 	public TestRig(String[] args) throws Exception {
 		if ( args.length < 2 ) {
-			System.err.println("java org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName\n" +
+			System.err.println("java org.antlr.v4.gui.TestRig GrammarName startRuleName\n" +
 							   "  [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]\n" +
 							   "  [-trace] [-diagnostics] [-SLL]\n"+
 							   "  [input-filename(s)]");

File: tool-testsuite/test/org/antlr/v4/test/tool/TestATNSerialization.java
Patch:
@@ -632,7 +632,7 @@ public class TestATNSerialization extends BaseTest {
 			"lexer grammar L;\n"+
 			"A : 'a'\n ;\n" +
 			"B : 'b';\n" +
-			"mode A;\n" +
+			"mode M;\n" +
 			"C : 'c';\n"+
 			"D : 'd';\n");
 		String expecting =

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -128,6 +128,8 @@ public void process() {
 							 collector.tokenIDRefs, collector.terminals);
 		}
 
+		symcheck.checkForModeConflicts(g);
+
 		assignChannelTypes(g, collector.channelDefs);
 
 		// CHECK RULE REFS NOW (that we've defined rules in grammar)

File: runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -41,7 +41,7 @@ protected String getLanguage() {
 
 	@Override
 	protected String getPythonExecutable() {
-		return "python3.4";
+		return "python3.4"; 
 	}
 
 	@Override

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/ErrorQueue.java
Patch:
@@ -27,7 +27,7 @@
  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package org.antlr.v4.test.tool;
+package org.antlr.v4.test.runtime.java;
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.runtime.misc.Utils;

File: runtime-testsuite/test/org/antlr/v4/test/runtime/java/TestPerformance.java
Patch:
@@ -1,12 +1,11 @@
 /* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
-
 package org.antlr.v4.test.runtime.java;
 
 import org.antlr.v4.test.tool.BaseTest;
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestPerformance extends BaseTest {
 

File: tool/test/org/antlr/v4/test/runtime/csharp/TestCompositeParsers.java
Patch:
@@ -15,7 +15,7 @@ public void testDelegatorInvokesDelegateRuleWithArgs() throws Exception {
 		mkdir(tmpdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a[int x] returns [int y] : B {Console.Write(\"S.a\");$y=1000;} ;";
+			"a[int x] returns [int y] : B {Console.Write(\"S.a\"); $y=1000;} ;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(144);

File: tool/test/org/antlr/v4/test/runtime/javascript/chrome/TestCompositeParsers.java
Patch:
@@ -17,7 +17,7 @@ public void testDelegatorInvokesDelegateRuleWithArgs() throws Exception {
 		mkdir(tmpdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\";$y=1000;} ;";
+			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\"; $y=1000;} ;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(175);

File: tool/test/org/antlr/v4/test/runtime/javascript/explorer/TestCompositeParsers.java
Patch:
@@ -17,7 +17,7 @@ public void testDelegatorInvokesDelegateRuleWithArgs() throws Exception {
 		mkdir(tmpdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\";$y=1000;} ;";
+			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\"; $y=1000;} ;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(175);

File: tool/test/org/antlr/v4/test/runtime/javascript/firefox/TestCompositeParsers.java
Patch:
@@ -17,7 +17,7 @@ public void testDelegatorInvokesDelegateRuleWithArgs() throws Exception {
 		mkdir(tmpdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\";$y=1000;} ;";
+			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\"; $y=1000;} ;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(175);

File: tool/test/org/antlr/v4/test/runtime/javascript/node/TestCompositeParsers.java
Patch:
@@ -17,7 +17,7 @@ public void testDelegatorInvokesDelegateRuleWithArgs() throws Exception {
 		mkdir(tmpdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a[int x] returns [int y] : B {process.stdout.write(\"S.a\");$y=1000;} ;";
+			"a[int x] returns [int y] : B {process.stdout.write(\"S.a\"); $y=1000;} ;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(138);

File: tool/test/org/antlr/v4/test/runtime/javascript/safari/TestCompositeParsers.java
Patch:
@@ -17,7 +17,7 @@ public void testDelegatorInvokesDelegateRuleWithArgs() throws Exception {
 		mkdir(tmpdir);
 		String slave_S =
 			"parser grammar S;\n" +
-			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\";$y=1000;} ;";
+			"a[int x] returns [int y] : B {document.getElementById('output').value += \"S.a\"; $y=1000;} ;";
 		writeFile(tmpdir, "S.g4", slave_S);
 
 		StringBuilder grammarBuilder = new StringBuilder(175);

File: tool/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java
Patch:
@@ -41,7 +41,7 @@ protected String getLanguage() {
 
 	@Override
 	protected String getPythonExecutable() {
-		return "Python3.4";
+		return "python3.4";
 	}
 
 	@Override

File: tool/test/org/antlr/v4/test/runtime/python2/BasePython2Test.java
Patch:
@@ -12,7 +12,7 @@ protected String getLanguage() {
 
 	@Override
 	protected String getPythonExecutable() {
-		return "Python2.7";
+		return "python2.7";
 	}
 
 	@Override

File: tool/test/org/antlr/v4/test/rt/csharp/TestCompositeParsers.java
Patch:
@@ -1,11 +1,12 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
 import org.antlr.v4.test.tool.ErrorQueue;
 import org.antlr.v4.tool.Grammar;
 
-public class TestCompositeParsers extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestCompositeParsers extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -337,4 +338,4 @@ public void testImportLexerWithOnlyFragmentRules() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestFullContextParsing.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestFullContextParsing extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestFullContextParsing extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -222,4 +223,4 @@ public void testExprAmbiguity_2() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestLeftRecursion.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestLeftRecursion extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestLeftRecursion extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	String testSimple(String input) throws Exception {
@@ -1161,4 +1162,4 @@ public void testReturnValueAndActionsList2_4() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestListeners.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestListeners extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestListeners extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -233,4 +234,4 @@ public void testLRWithLabels() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestParseTrees.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestParseTrees extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestParseTrees extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -167,4 +168,4 @@ public void testSync() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestParserErrors.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestParserErrors extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestParserErrors extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -347,4 +348,4 @@ public void testNoViableAltAvoidance() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestParserExec.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestParserExec extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestParserExec extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -471,4 +472,4 @@ public void testParserProperty() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestSemPredEvalParser.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestSemPredEvalParser extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestSemPredEvalParser extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -450,4 +451,4 @@ public void testPredFromAltTestedInLoopBack_2() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/csharp/TestSets.java
Patch:
@@ -1,8 +1,9 @@
 package org.antlr.v4.test.rt.csharp;
 
+import org.antlr.v4.test.runtime.csharp.BaseTest;
 import org.junit.Test;
 
-public class TestSets extends org.antlr.v4.test.runtime.csharp.BaseTest {
+public class TestSets extends BaseTest {
 
 	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
@@ -257,4 +258,4 @@ public void testComplementSet() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -626,6 +626,7 @@ public void enterRule(ParserRuleContext localctx, int state, int ruleIndex) {
 		_ctx = localctx;
 		_ctx.start = _input.LT(1);
 		if (_buildParseTrees) addContextToParseTree();
+        if ( _parseListeners != null) triggerEnterRuleEvent();
 	}
 
     public void exitRule() {

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -626,7 +626,6 @@ public void enterRule(ParserRuleContext localctx, int state, int ruleIndex) {
 		_ctx = localctx;
 		_ctx.start = _input.LT(1);
 		if (_buildParseTrees) addContextToParseTree();
-        if ( _parseListeners != null) triggerEnterRuleEvent();
 	}
 
     public void exitRule() {

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -626,7 +626,6 @@ public void enterRule(ParserRuleContext localctx, int state, int ruleIndex) {
 		_ctx = localctx;
 		_ctx.start = _input.LT(1);
 		if (_buildParseTrees) addContextToParseTree();
-        if ( _parseListeners != null) triggerEnterRuleEvent();
 	}
 
     public void exitRule() {

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -956,7 +956,7 @@ public enum ErrorType {
 	 */
 	CHANNELS_BLOCK_IN_COMBINED_GRAMMAR(164, "custom channels are not supported in combined grammars", ErrorSeverity.ERROR),
 
-	NONCONFORMING_LR_RULE(165, "rule <arg> is left recursive but doesn't conform to a pattern ANTLR can handle", ErrorSeverity.ERROR),
+	NONCONFORMING_LR_RULE(169, "rule <arg> is left recursive but doesn't conform to a pattern ANTLR can handle", ErrorSeverity.ERROR),
 
 	/*
 	 * Backward incompatibility errors

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -480,18 +480,18 @@ public void tokenRef(TerminalAST ref) {
 			@Override
 			public void ruleRef(GrammarAST ref, ActionAST arg) {
 				RuleAST ruleAST = ruleToAST.get(ref.getText());
+				String fileName = ref.getToken().getInputStream().getSourceName();
 				if (Character.isUpperCase(currentRuleName.charAt(0)) &&
 					Character.isLowerCase(ref.getText().charAt(0)))
 				{
 					badref = true;
-					String fileName = ref.getToken().getInputStream().getSourceName();
 					errMgr.grammarError(ErrorType.PARSER_RULE_REF_IN_LEXER_RULE,
 										fileName, ref.getToken(), ref.getText(), currentRuleName);
 				}
 				else if ( ruleAST==null ) {
 					badref = true;
 					errMgr.grammarError(ErrorType.UNDEFINED_RULE_REF,
-										g.fileName, ref.token, ref.getText());
+										fileName, ref.token, ref.getText());
 				}
 			}
 			@Override

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -480,18 +480,18 @@ public void tokenRef(TerminalAST ref) {
 			@Override
 			public void ruleRef(GrammarAST ref, ActionAST arg) {
 				RuleAST ruleAST = ruleToAST.get(ref.getText());
+				String fileName = ref.getToken().getInputStream().getSourceName();
 				if (Character.isUpperCase(currentRuleName.charAt(0)) &&
 					Character.isLowerCase(ref.getText().charAt(0)))
 				{
 					badref = true;
-					String fileName = ref.getToken().getInputStream().getSourceName();
 					errMgr.grammarError(ErrorType.PARSER_RULE_REF_IN_LEXER_RULE,
 										fileName, ref.getToken(), ref.getText(), currentRuleName);
 				}
 				else if ( ruleAST==null ) {
 					badref = true;
 					errMgr.grammarError(ErrorType.UNDEFINED_RULE_REF,
-										g.fileName, ref.token, ref.getText());
+										fileName, ref.token, ref.getText());
 				}
 			}
 			@Override

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -956,6 +956,8 @@ public enum ErrorType {
 	 */
 	CHANNELS_BLOCK_IN_COMBINED_GRAMMAR(164, "custom channels are not supported in combined grammars", ErrorSeverity.ERROR),
 
+	NONCONFORMING_LR_RULE(165, "rule <arg> is left recursive but doesn't conform to a pattern ANTLR can handle", ErrorSeverity.ERROR),
+
 	/*
 	 * Backward incompatibility errors
 	 */

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -956,6 +956,8 @@ public enum ErrorType {
 	 */
 	CHANNELS_BLOCK_IN_COMBINED_GRAMMAR(164, "custom channels are not supported in combined grammars", ErrorSeverity.ERROR),
 
+	NONCONFORMING_LR_RULE(165, "rule <arg> is left recursive but doesn't conform to a pattern ANTLR can handle", ErrorSeverity.ERROR),
+
 	/*
 	 * Backward incompatibility errors
 	 */

File: tool/test/org/antlr/v4/test/rt/py3/BasePython3Test.java
Patch:
@@ -68,6 +68,8 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {
 	protected void writeParserTestFile(String parserName, String lexerName,
 			String listenerName, String visitorName,
 			String parserStartRuleName, boolean debug, boolean trace) {
+		if(!parserStartRuleName.endsWith(")"))
+			parserStartRuleName += "()";
 		ST outputFileST = new ST(
 				"import sys\n"
 						+ "from antlr4 import *\n"
@@ -99,7 +101,7 @@ protected void writeParserTestFile(String parserName, String lexerName,
 						+ "    stream = CommonTokenStream(lexer)\n"
 						+ "<createParser>"
 						+ "    parser.buildParseTrees = True\n"
-						+ "    tree = parser.<parserStartRuleName>()\n"
+						+ "    tree = parser.<parserStartRuleName>\n"
 						+ "    ParseTreeWalker.DEFAULT.walk(TreeShapeListener(), tree)\n"
 						+ "\n" + "if __name__ == '__main__':\n"
 						+ "    main(sys.argv)\n" + "\n");

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorStrategy.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  * The interface for defining strategies to deal with syntax errors encountered
  * during a parse by ANTLR-generated parsers. We distinguish between three

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.ArrayList;
 import java.util.HashSet;

File: runtime/Java/src/org/antlr/v4/runtime/CharStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** A source of characters for an ANTLR lexer. */
 public interface CharStream extends IntStream {

File: runtime/Java/src/org/antlr/v4/runtime/DefaultErrorStrategy.java
Patch:
@@ -34,8 +34,6 @@
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.atn.RuleTransition;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Pair;
 
 /**

File: runtime/Java/src/org/antlr/v4/runtime/FailedPredicateException.java
Patch:
@@ -32,8 +32,6 @@
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.atn.AbstractPredicateTransition;
 import org.antlr.v4.runtime.atn.PredicateTransition;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Locale;
 

File: runtime/Java/src/org/antlr/v4/runtime/LexerInterpreter.java
Patch:
@@ -35,7 +35,6 @@
 import org.antlr.v4.runtime.atn.LexerATNSimulator;
 import org.antlr.v4.runtime.atn.PredictionContextCache;
 import org.antlr.v4.runtime.dfa.DFA;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Collection;
 

File: runtime/Java/src/org/antlr/v4/runtime/LexerNoViableAltException.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.atn.ATNConfigSet;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Utils;
 
 import java.util.Locale;

File: runtime/Java/src/org/antlr/v4/runtime/ListTokenSource.java
Patch:
@@ -1,6 +1,5 @@
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/NoViableAltException.java
Patch:
@@ -30,8 +30,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.atn.ATNConfigSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /** Indicates that the parser could not decide which of two or more paths
  *  to take based upon the remaining input. It tracks the starting token

File: runtime/Java/src/org/antlr/v4/runtime/RecognitionException.java
Patch:
@@ -31,7 +31,6 @@
 
 import org.antlr.v4.runtime.atn.DecisionState;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /** The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
  *  3 kinds of errors: prediction errors, failed predicate errors, and

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNSimulator;
 import org.antlr.v4.runtime.atn.ParseInfo;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Utils;
 
 import java.util.Collections;

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  * This class provides access to the current version of the ANTLR 4 runtime
  * library as compile-time and runtime constants, along with methods for

File: runtime/Java/src/org/antlr/v4/runtime/TokenFactory.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 
 /** The default mechanism for creating tokens. It's used by default in Lexer and

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -29,9 +29,6 @@
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 /**
  * A source of tokens must provide a sequence of tokens via {@link #nextToken()}
  * and also must reveal it's source of characters; {@link CommonToken}'s text is

File: runtime/Java/src/org/antlr/v4/runtime/TokenStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  * An {@link IntStream} whose symbols are {@link Token} instances.

File: runtime/Java/src/org/antlr/v4/runtime/UnbufferedTokenStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Arrays;
 

File: runtime/Java/src/org/antlr/v4/runtime/Vocabulary.java
Patch:
@@ -29,9 +29,6 @@
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 /**
  * This interface provides information about the vocabulary used by a
  * recognizer.

File: runtime/Java/src/org/antlr/v4/runtime/VocabularyImpl.java
Patch:
@@ -29,9 +29,6 @@
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 import java.util.Arrays;
 
 /**

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATN.java
Patch:
@@ -34,7 +34,6 @@
 import org.antlr.v4.runtime.RuleContext;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -32,8 +32,6 @@
 
 import org.antlr.v4.runtime.Recognizer;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /** A tuple: (ATN state, predicted alt, syntactic, semantic context).
  *  The syntactic context is a graph-structured stack node whose

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializationOptions.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  *
  * @author Sam Harwell

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializer.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 
 import java.io.InvalidClassException;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSimulator.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.dfa.DFAState;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.IdentityHashMap;
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/atn/AtomTransition.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** TODO: make all transitions sets? no, should remove set edges */
 public final class AtomTransition extends Transition {

File: runtime/Java/src/org/antlr/v4/runtime/atn/EpsilonTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 public final class EpsilonTransition extends Transition {
 
 	private final int outermostPrecedenceReturn;

File: runtime/Java/src/org/antlr/v4/runtime/atn/LL1Analyzer.java
Patch:
@@ -33,8 +33,6 @@
 import org.antlr.v4.runtime.RuleContext;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.BitSet;
 import java.util.HashSet;

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNConfig.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.ObjectEqualityComparator;
 
 public class LexerATNConfig extends ATNConfig {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -38,8 +38,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.dfa.DFAState;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Locale;
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerAction.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Lexer;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  * Represents a single action which can be executed following the successful

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerActionExecutor.java
Patch:
@@ -35,7 +35,6 @@
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Arrays;
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerIndexedCustomAction.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  * This implementation of {@link LexerAction} is used for tracking input offsets

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParseInfo.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.dfa.DFA;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.ArrayList;
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredicateTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /** TODO: this is old comment:
  *  A tree of semantic predicates from the grammar AST if label==SEMPRED.
  *  In the ATN, labels will always be exactly one predicate, but the DFA

File: runtime/Java/src/org/antlr/v4/runtime/atn/RangeTransition.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 public final class RangeTransition extends Transition {
 	public final int from;

File: runtime/Java/src/org/antlr/v4/runtime/atn/RuleTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /** */
 public final class RuleTransition extends Transition {
 	/** Ptr to the rule definition object for this rule ref */

File: runtime/Java/src/org/antlr/v4/runtime/atn/SemanticContext.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.Recognizer;
 import org.antlr.v4.runtime.RuleContext;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Utils;
 
 import java.util.ArrayList;

File: runtime/Java/src/org/antlr/v4/runtime/atn/SetTransition.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** A transition containing a set of values. */
 public class SetTransition extends Transition {

File: runtime/Java/src/org/antlr/v4/runtime/atn/Transition.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Arrays;
 import java.util.Collections;

File: runtime/Java/src/org/antlr/v4/runtime/atn/WildcardTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 public final class WildcardTransition extends Transition {
 	public WildcardTransition(ATNState target) { super(target); }
 

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFA.java
Patch:
@@ -35,8 +35,6 @@
 import org.antlr.v4.runtime.atn.ATNConfigSet;
 import org.antlr.v4.runtime.atn.DecisionState;
 import org.antlr.v4.runtime.atn.StarLoopEntryState;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.ArrayList;
 import java.util.Arrays;

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFASerializer.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.Vocabulary;
 import org.antlr.v4.runtime.VocabularyImpl;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Arrays;
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFAState.java
Patch:
@@ -38,8 +38,6 @@
 import org.antlr.v4.runtime.atn.ParserATNSimulator;
 import org.antlr.v4.runtime.atn.SemanticContext;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Arrays;
 import java.util.HashSet;

File: runtime/Java/src/org/antlr/v4/runtime/dfa/LexerDFASerializer.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.dfa;
 
 import org.antlr.v4.runtime.VocabularyImpl;
-import org.antlr.v4.runtime.misc.NotNull;
 
 public class LexerDFASerializer extends DFASerializer {
 	public LexerDFASerializer(DFA dfa) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.TokenStream;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** A tree that knows about an interval in a token stream
  *  is some kind of syntax tree. Subinterfaces distinguish

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -36,7 +36,6 @@
 import org.abego.treelayout.util.DefaultConfiguration;
 import org.antlr.v4.runtime.misc.GraphicsSupport;
 import org.antlr.v4.runtime.misc.JFileChooserConfirmOverwrite;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ErrorNode;
 import org.antlr.v4.runtime.tree.Tree;

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreeMatch.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.runtime.tree.pattern;
 
 import org.antlr.v4.runtime.misc.MultiMap;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.tree.ParseTree;
 
 import java.util.Collections;

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePattern.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.runtime.tree.pattern;
 
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.xpath.XPath;
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePatternMatcher.java
Patch:
@@ -42,8 +42,6 @@
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.misc.MultiMap;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.ParseCancellationException;
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.RuleNode;

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/RuleTagToken.java
Patch:
@@ -33,8 +33,6 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenSource;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /**
  * A {@link Token} object representing an entire subtree matched by a parser

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TagChunk.java
Patch:
@@ -30,9 +30,6 @@
 
 package org.antlr.v4.runtime.tree.pattern;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 /**
  * Represents a placeholder tag in a tree pattern. A tag can have any of the
  * following forms.

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TextChunk.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.tree.pattern;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  * Represents a span of raw text (concrete syntax) between tags in a tree
  * pattern string.

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TokenTagToken.java
Patch:
@@ -32,8 +32,6 @@
 
 import org.antlr.v4.runtime.CommonToken;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /**
  * A {@link Token} object representing a token of a particular type; e.g.,

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -51,7 +51,6 @@
 import org.antlr.v4.parse.v3TreeGrammarException;
 import org.antlr.v4.runtime.RuntimeMetaData;
 import org.antlr.v4.runtime.misc.LogManager;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.ANTLRToolListener;

File: tool/src/org/antlr/v4/automata/ATNFactory.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNState;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.tool.ast.ActionAST;
 import org.antlr.v4.tool.ast.BlockAST;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/automata/ATNOptimizer.java
Patch:
@@ -42,7 +42,6 @@
 import org.antlr.v4.runtime.atn.Transition;
 import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.Rule;
 

File: tool/src/org/antlr/v4/automata/ATNVisitor.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.atn.Transition;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.HashSet;
 import java.util.Set;

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -58,8 +58,6 @@
 import org.antlr.v4.runtime.atn.Transition;
 import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.LexerGrammar;
 import org.antlr.v4.tool.Rule;

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -68,8 +68,6 @@
 import org.antlr.v4.runtime.atn.Transition;
 import org.antlr.v4.runtime.atn.WildcardTransition;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Triple;
 import org.antlr.v4.semantics.UseDefAnalyzer;
 import org.antlr.v4.tool.ErrorManager;

File: tool/src/org/antlr/v4/automata/TailEpsilonRemover.java
Patch:
@@ -38,7 +38,6 @@
 import org.antlr.v4.runtime.atn.RuleTransition;
 import org.antlr.v4.runtime.atn.StarLoopbackState;
 import org.antlr.v4.runtime.atn.Transition;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  *

File: tool/src/org/antlr/v4/codegen/CodeGenerator.java
Patch:
@@ -33,8 +33,6 @@
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.model.OutputModelObject;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;
 import org.stringtemplate.v4.AutoIndentWriter;

File: tool/src/org/antlr/v4/codegen/DefaultOutputModelFactory.java
Patch:
@@ -36,8 +36,6 @@
 import org.antlr.v4.codegen.model.SrcOp;
 import org.antlr.v4.codegen.model.decl.CodeBlock;
 import org.antlr.v4.codegen.model.decl.Decl;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.Alternative;
 import org.antlr.v4.tool.Grammar;
 

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -37,7 +37,6 @@
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.runtime.RuntimeMetaData;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.Rule;

File: tool/src/org/antlr/v4/codegen/model/LL1PlusBlockSingleAlt.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.runtime.atn.PlusBlockStartState;
-import org.antlr.v4.runtime.atn.PlusLoopbackState;
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.tool.ast.BlockAST;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/codegen/model/RuleFunction.java
Patch:
@@ -61,15 +61,14 @@
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import static org.antlr.v4.parse.ANTLRParser.RULE_REF;
 import static org.antlr.v4.parse.ANTLRParser.TOKEN_REF;
 
-import java.util.LinkedHashSet;
-
 /** */
 public class RuleFunction extends OutputModelObject {
 	public String name;

File: tool/src/org/antlr/v4/codegen/model/SemPred.java
Patch:
@@ -35,7 +35,6 @@
 import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.codegen.model.chunk.ActionChunk;
 import org.antlr.v4.runtime.atn.AbstractPredicateTransition;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.tool.ast.ActionAST;
 import org.antlr.v4.tool.ast.GrammarAST;
 

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.misc;
 
-import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.tool.ast.GrammarAST;
 
 import java.util.ArrayList;

File: tool/src/org/antlr/v4/parse/ScopeParser.java
Patch:
@@ -32,12 +32,9 @@
 
 import org.antlr.runtime.BaseRecognizer;
 import org.antlr.runtime.CommonToken;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.Attribute;
 import org.antlr.v4.tool.AttributeDict;
-import org.antlr.v4.tool.ErrorManager;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.ast.ActionAST;

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.analysis.LeftRecursiveRuleTransformer;
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.semantics;
 
 import org.antlr.v4.parse.ANTLRParser;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.Alternative;
 import org.antlr.v4.tool.Attribute;
 import org.antlr.v4.tool.AttributeDict;

File: tool/src/org/antlr/v4/tool/ANTLRMessage.java
Patch:
@@ -31,9 +31,8 @@
 package org.antlr.v4.tool;
 
 import org.antlr.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.stringtemplate.v4.ST;
+
 import java.util.Arrays;
 
 public class ANTLRMessage {

File: tool/src/org/antlr/v4/tool/AttributeDict.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.tool;
 
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ast.GrammarAST;
 
 import java.util.Collections;

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.tool;
 
-import org.antlr.runtime.Token;
 import org.antlr.v4.Tool;
 import org.stringtemplate.v4.ST;
 import org.stringtemplate.v4.STGroup;

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -55,8 +55,6 @@
 import org.antlr.v4.runtime.misc.IntSet;
 import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.ast.ActionAST;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/tool/ast/GrammarASTWithOptions.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.runtime.Token;
 import org.antlr.v4.misc.CharSupport;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Collections;
 import java.util.HashMap;

File: tool/src/org/antlr/v4/tool/ast/GrammarRootAST.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.runtime.Token;
 import org.antlr.runtime.TokenStream;
 import org.antlr.runtime.tree.Tree;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.HashMap;
 import java.util.Map;

File: tool/test/org/antlr/v4/test/rt/java/BaseTest.java
Patch:
@@ -56,7 +56,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ParseTree;

File: tool/test/org/antlr/v4/test/rt/java/TestFullContextParsing.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestFullContextParsing extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestLeftRecursion.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestLeftRecursion extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestListeners.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestListeners extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestParseTrees.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParseTrees extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestParserExec.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParserExec extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestSemPredEvalParser.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestSemPredEvalParser extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestSets.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestSets extends BaseTest {
 

File: tool/test/org/antlr/v4/test/tool/BaseTest.java
Patch:
@@ -56,7 +56,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ParseTree;

File: tool/test/org/antlr/v4/test/tool/JavaUnicodeInputStream.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  *

File: tool/test/org/antlr/v4/test/tool/TestPerformance.java
Patch:
@@ -57,7 +57,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.dfa.DFAState;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.ParseCancellationException;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ErrorNode;

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorStrategy.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  * The interface for defining strategies to deal with syntax errors encountered
  * during a parse by ANTLR-generated parsers. We distinguish between three

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.ArrayList;
 import java.util.HashSet;

File: runtime/Java/src/org/antlr/v4/runtime/CharStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** A source of characters for an ANTLR lexer. */
 public interface CharStream extends IntStream {

File: runtime/Java/src/org/antlr/v4/runtime/DefaultErrorStrategy.java
Patch:
@@ -34,8 +34,6 @@
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.atn.RuleTransition;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Pair;
 
 /**

File: runtime/Java/src/org/antlr/v4/runtime/FailedPredicateException.java
Patch:
@@ -32,8 +32,6 @@
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.atn.AbstractPredicateTransition;
 import org.antlr.v4.runtime.atn.PredicateTransition;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Locale;
 

File: runtime/Java/src/org/antlr/v4/runtime/LexerInterpreter.java
Patch:
@@ -35,7 +35,6 @@
 import org.antlr.v4.runtime.atn.LexerATNSimulator;
 import org.antlr.v4.runtime.atn.PredictionContextCache;
 import org.antlr.v4.runtime.dfa.DFA;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Collection;
 

File: runtime/Java/src/org/antlr/v4/runtime/LexerNoViableAltException.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.atn.ATNConfigSet;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Utils;
 
 import java.util.Locale;

File: runtime/Java/src/org/antlr/v4/runtime/ListTokenSource.java
Patch:
@@ -1,6 +1,5 @@
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/NoViableAltException.java
Patch:
@@ -30,8 +30,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.atn.ATNConfigSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /** Indicates that the parser could not decide which of two or more paths
  *  to take based upon the remaining input. It tracks the starting token

File: runtime/Java/src/org/antlr/v4/runtime/RecognitionException.java
Patch:
@@ -31,7 +31,6 @@
 
 import org.antlr.v4.runtime.atn.DecisionState;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /** The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
  *  3 kinds of errors: prediction errors, failed predicate errors, and

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNSimulator;
 import org.antlr.v4.runtime.atn.ParseInfo;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Utils;
 
 import java.util.Collections;

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  * This class provides access to the current version of the ANTLR 4 runtime
  * library as compile-time and runtime constants, along with methods for

File: runtime/Java/src/org/antlr/v4/runtime/TokenFactory.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 
 /** The default mechanism for creating tokens. It's used by default in Lexer and

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -29,9 +29,6 @@
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 /**
  * A source of tokens must provide a sequence of tokens via {@link #nextToken()}
  * and also must reveal it's source of characters; {@link CommonToken}'s text is

File: runtime/Java/src/org/antlr/v4/runtime/TokenStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  * An {@link IntStream} whose symbols are {@link Token} instances.

File: runtime/Java/src/org/antlr/v4/runtime/UnbufferedTokenStream.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Arrays;
 

File: runtime/Java/src/org/antlr/v4/runtime/Vocabulary.java
Patch:
@@ -29,9 +29,6 @@
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 /**
  * This interface provides information about the vocabulary used by a
  * recognizer.

File: runtime/Java/src/org/antlr/v4/runtime/VocabularyImpl.java
Patch:
@@ -29,9 +29,6 @@
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 import java.util.Arrays;
 
 /**

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATN.java
Patch:
@@ -34,7 +34,6 @@
 import org.antlr.v4.runtime.RuleContext;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -32,8 +32,6 @@
 
 import org.antlr.v4.runtime.Recognizer;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /** A tuple: (ATN state, predicted alt, syntactic, semantic context).
  *  The syntactic context is a graph-structured stack node whose

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializationOptions.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  *
  * @author Sam Harwell

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializer.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 
 import java.io.InvalidClassException;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSimulator.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.dfa.DFAState;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.IdentityHashMap;
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/atn/AtomTransition.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** TODO: make all transitions sets? no, should remove set edges */
 public final class AtomTransition extends Transition {

File: runtime/Java/src/org/antlr/v4/runtime/atn/EpsilonTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 public final class EpsilonTransition extends Transition {
 
 	private final int outermostPrecedenceReturn;

File: runtime/Java/src/org/antlr/v4/runtime/atn/LL1Analyzer.java
Patch:
@@ -33,8 +33,6 @@
 import org.antlr.v4.runtime.RuleContext;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.BitSet;
 import java.util.HashSet;

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNConfig.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.ObjectEqualityComparator;
 
 public class LexerATNConfig extends ATNConfig {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -38,8 +38,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.dfa.DFAState;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Locale;
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerAction.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Lexer;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  * Represents a single action which can be executed following the successful

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerActionExecutor.java
Patch:
@@ -35,7 +35,6 @@
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Arrays;
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerIndexedCustomAction.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  * This implementation of {@link LexerAction} is used for tracking input offsets

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParseInfo.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.dfa.DFA;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.ArrayList;
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredicateTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /** TODO: this is old comment:
  *  A tree of semantic predicates from the grammar AST if label==SEMPRED.
  *  In the ATN, labels will always be exactly one predicate, but the DFA

File: runtime/Java/src/org/antlr/v4/runtime/atn/RangeTransition.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 public final class RangeTransition extends Transition {
 	public final int from;

File: runtime/Java/src/org/antlr/v4/runtime/atn/RuleTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /** */
 public final class RuleTransition extends Transition {
 	/** Ptr to the rule definition object for this rule ref */

File: runtime/Java/src/org/antlr/v4/runtime/atn/SemanticContext.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.Recognizer;
 import org.antlr.v4.runtime.RuleContext;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Utils;
 
 import java.util.ArrayList;

File: runtime/Java/src/org/antlr/v4/runtime/atn/SetTransition.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** A transition containing a set of values. */
 public class SetTransition extends Transition {

File: runtime/Java/src/org/antlr/v4/runtime/atn/Transition.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Arrays;
 import java.util.Collections;

File: runtime/Java/src/org/antlr/v4/runtime/atn/WildcardTransition.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 public final class WildcardTransition extends Transition {
 	public WildcardTransition(ATNState target) { super(target); }
 

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFA.java
Patch:
@@ -35,8 +35,6 @@
 import org.antlr.v4.runtime.atn.ATNConfigSet;
 import org.antlr.v4.runtime.atn.DecisionState;
 import org.antlr.v4.runtime.atn.StarLoopEntryState;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.ArrayList;
 import java.util.Arrays;

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFASerializer.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.Vocabulary;
 import org.antlr.v4.runtime.VocabularyImpl;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Arrays;
 import java.util.List;

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFAState.java
Patch:
@@ -38,8 +38,6 @@
 import org.antlr.v4.runtime.atn.ParserATNSimulator;
 import org.antlr.v4.runtime.atn.SemanticContext;
 import org.antlr.v4.runtime.misc.MurmurHash;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 import java.util.Arrays;
 import java.util.HashSet;

File: runtime/Java/src/org/antlr/v4/runtime/dfa/LexerDFASerializer.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.runtime.dfa;
 
 import org.antlr.v4.runtime.VocabularyImpl;
-import org.antlr.v4.runtime.misc.NotNull;
 
 public class LexerDFASerializer extends DFASerializer {
 	public LexerDFASerializer(DFA dfa) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.TokenStream;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /** A tree that knows about an interval in a token stream
  *  is some kind of syntax tree. Subinterfaces distinguish

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -36,7 +36,6 @@
 import org.abego.treelayout.util.DefaultConfiguration;
 import org.antlr.v4.runtime.misc.GraphicsSupport;
 import org.antlr.v4.runtime.misc.JFileChooserConfirmOverwrite;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ErrorNode;
 import org.antlr.v4.runtime.tree.Tree;

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreeMatch.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.runtime.tree.pattern;
 
 import org.antlr.v4.runtime.misc.MultiMap;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.tree.ParseTree;
 
 import java.util.Collections;

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePattern.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.runtime.tree.pattern;
 
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.xpath.XPath;
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePatternMatcher.java
Patch:
@@ -42,8 +42,6 @@
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.misc.MultiMap;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.ParseCancellationException;
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.RuleNode;

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/RuleTagToken.java
Patch:
@@ -33,8 +33,6 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenSource;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /**
  * A {@link Token} object representing an entire subtree matched by a parser

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TagChunk.java
Patch:
@@ -30,9 +30,6 @@
 
 package org.antlr.v4.runtime.tree.pattern;
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
-
 /**
  * Represents a placeholder tag in a tree pattern. A tag can have any of the
  * following forms.

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TextChunk.java
Patch:
@@ -30,8 +30,6 @@
 
 package org.antlr.v4.runtime.tree.pattern;
 
-import org.antlr.v4.runtime.misc.NotNull;
-
 /**
  * Represents a span of raw text (concrete syntax) between tags in a tree
  * pattern string.

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TokenTagToken.java
Patch:
@@ -32,8 +32,6 @@
 
 import org.antlr.v4.runtime.CommonToken;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 
 /**
  * A {@link Token} object representing a token of a particular type; e.g.,

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -51,7 +51,6 @@
 import org.antlr.v4.parse.v3TreeGrammarException;
 import org.antlr.v4.runtime.RuntimeMetaData;
 import org.antlr.v4.runtime.misc.LogManager;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.ANTLRToolListener;

File: tool/src/org/antlr/v4/automata/ATNFactory.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNState;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.tool.ast.ActionAST;
 import org.antlr.v4.tool.ast.BlockAST;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/automata/ATNOptimizer.java
Patch:
@@ -42,7 +42,6 @@
 import org.antlr.v4.runtime.atn.Transition;
 import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.Rule;
 

File: tool/src/org/antlr/v4/automata/ATNVisitor.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.atn.Transition;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.HashSet;
 import java.util.Set;

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -58,8 +58,6 @@
 import org.antlr.v4.runtime.atn.Transition;
 import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.LexerGrammar;
 import org.antlr.v4.tool.Rule;

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -68,8 +68,6 @@
 import org.antlr.v4.runtime.atn.Transition;
 import org.antlr.v4.runtime.atn.WildcardTransition;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Triple;
 import org.antlr.v4.semantics.UseDefAnalyzer;
 import org.antlr.v4.tool.ErrorManager;

File: tool/src/org/antlr/v4/automata/TailEpsilonRemover.java
Patch:
@@ -38,7 +38,6 @@
 import org.antlr.v4.runtime.atn.RuleTransition;
 import org.antlr.v4.runtime.atn.StarLoopbackState;
 import org.antlr.v4.runtime.atn.Transition;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  *

File: tool/src/org/antlr/v4/codegen/CodeGenerator.java
Patch:
@@ -33,8 +33,6 @@
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.model.OutputModelObject;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;
 import org.stringtemplate.v4.AutoIndentWriter;

File: tool/src/org/antlr/v4/codegen/DefaultOutputModelFactory.java
Patch:
@@ -36,8 +36,6 @@
 import org.antlr.v4.codegen.model.SrcOp;
 import org.antlr.v4.codegen.model.decl.CodeBlock;
 import org.antlr.v4.codegen.model.decl.Decl;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.Alternative;
 import org.antlr.v4.tool.Grammar;
 

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -37,7 +37,6 @@
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.runtime.RuntimeMetaData;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.Rule;

File: tool/src/org/antlr/v4/codegen/model/LL1PlusBlockSingleAlt.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.runtime.atn.PlusBlockStartState;
-import org.antlr.v4.runtime.atn.PlusLoopbackState;
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.tool.ast.BlockAST;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/codegen/model/RuleFunction.java
Patch:
@@ -61,15 +61,14 @@
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import static org.antlr.v4.parse.ANTLRParser.RULE_REF;
 import static org.antlr.v4.parse.ANTLRParser.TOKEN_REF;
 
-import java.util.LinkedHashSet;
-
 /** */
 public class RuleFunction extends OutputModelObject {
 	public String name;

File: tool/src/org/antlr/v4/codegen/model/SemPred.java
Patch:
@@ -35,7 +35,6 @@
 import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.codegen.model.chunk.ActionChunk;
 import org.antlr.v4.runtime.atn.AbstractPredicateTransition;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.tool.ast.ActionAST;
 import org.antlr.v4.tool.ast.GrammarAST;
 

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.misc;
 
-import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.tool.ast.GrammarAST;
 
 import java.util.ArrayList;

File: tool/src/org/antlr/v4/parse/ScopeParser.java
Patch:
@@ -32,12 +32,9 @@
 
 import org.antlr.runtime.BaseRecognizer;
 import org.antlr.runtime.CommonToken;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.Attribute;
 import org.antlr.v4.tool.AttributeDict;
-import org.antlr.v4.tool.ErrorManager;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.ast.ActionAST;

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.analysis.LeftRecursiveRuleTransformer;
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.semantics;
 
 import org.antlr.v4.parse.ANTLRParser;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.Alternative;
 import org.antlr.v4.tool.Attribute;
 import org.antlr.v4.tool.AttributeDict;

File: tool/src/org/antlr/v4/tool/ANTLRMessage.java
Patch:
@@ -31,9 +31,8 @@
 package org.antlr.v4.tool;
 
 import org.antlr.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.stringtemplate.v4.ST;
+
 import java.util.Arrays;
 
 public class ANTLRMessage {

File: tool/src/org/antlr/v4/tool/AttributeDict.java
Patch:
@@ -31,8 +31,6 @@
 package org.antlr.v4.tool;
 
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.tool.ast.GrammarAST;
 
 import java.util.Collections;

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.tool;
 
-import org.antlr.runtime.Token;
 import org.antlr.v4.Tool;
 import org.stringtemplate.v4.ST;
 import org.stringtemplate.v4.STGroup;

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -55,8 +55,6 @@
 import org.antlr.v4.runtime.misc.IntSet;
 import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.ast.ActionAST;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/tool/ast/GrammarASTWithOptions.java
Patch:
@@ -32,7 +32,6 @@
 
 import org.antlr.runtime.Token;
 import org.antlr.v4.misc.CharSupport;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.Collections;
 import java.util.HashMap;

File: tool/src/org/antlr/v4/tool/ast/GrammarRootAST.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.runtime.Token;
 import org.antlr.runtime.TokenStream;
 import org.antlr.runtime.tree.Tree;
-import org.antlr.v4.runtime.misc.NotNull;
 
 import java.util.HashMap;
 import java.util.Map;

File: tool/test/org/antlr/v4/test/rt/java/BaseTest.java
Patch:
@@ -56,7 +56,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ParseTree;

File: tool/test/org/antlr/v4/test/rt/java/TestFullContextParsing.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestFullContextParsing extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestLeftRecursion.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestLeftRecursion extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestListeners.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestListeners extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestParseTrees.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParseTrees extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestParserExec.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestParserExec extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestSemPredEvalParser.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestSemPredEvalParser extends BaseTest {
 

File: tool/test/org/antlr/v4/test/rt/java/TestSets.java
Patch:
@@ -1,7 +1,9 @@
 package org.antlr.v4.test.rt.java;
 
 import org.junit.Test;
-import static org.junit.Assert.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public class TestSets extends BaseTest {
 

File: tool/test/org/antlr/v4/test/tool/BaseTest.java
Patch:
@@ -56,7 +56,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ParseTree;

File: tool/test/org/antlr/v4/test/tool/JavaUnicodeInputStream.java
Patch:
@@ -33,7 +33,6 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 
 /**
  *

File: tool/test/org/antlr/v4/test/tool/TestPerformance.java
Patch:
@@ -57,7 +57,6 @@
 import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.dfa.DFAState;
 import org.antlr.v4.runtime.misc.Interval;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.ParseCancellationException;
 import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ErrorNode;

File: tool/src/org/antlr/v4/codegen/JavaScriptTarget.java
Patch:
@@ -45,7 +45,7 @@
  */
 public class JavaScriptTarget extends Target {
 
-	/** Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_gramma */
+	/** Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar */
 	protected static final String[] javaScriptKeywords = {
 		"break", "case", "class", "catch", "const", "continue", "debugger",
 		"default", "delete", "do", "else", "export", "extends", "finally", "for",

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorStrategy.java
Patch:
@@ -63,6 +63,9 @@ public interface ANTLRErrorStrategy {
 	 * returns the {@link Token} instance which should be treated as the
 	 * successful result of the match.
 	 *
+   * <p>This method handles the consumption of any tokens - the caller should
+	 * <b>not</b> call {@link Parser#consume} after a successful recovery.</p>
+	 *
 	 * <p>Note that the calling code will not report an error if this method
 	 * returns successfully. The error strategy implementation is responsible
 	 * for calling {@link Parser#notifyErrorListeners} as appropriate.</p>

File: tool/src/org/antlr/v4/tool/ast/GrammarAST.java
Patch:
@@ -126,7 +126,7 @@ public void getNodesWithTypePreorderDFS_(List<GrammarAST> nodes, IntervalSet typ
 	}
 
 	public GrammarAST getNodeWithTokenIndex(int index) {
-		if ( this.getToken().getTokenIndex()==index ) {
+		if ( this.getToken()!=null && this.getToken().getTokenIndex()==index ) {
 			return this;
 		}
 		// walk all children of root.

File: tool/src/org/antlr/v4/codegen/JavaScriptTarget.java
Patch:
@@ -41,7 +41,7 @@
 
 /**
  *
- * @author Sam Harwell
+ * @author Eric Vergnaud
  */
 public class JavaScriptTarget extends Target {
 

File: tool/src/org/antlr/v4/codegen/JavaScriptTarget.java
Patch:
@@ -41,7 +41,7 @@
 
 /**
  *
- * @author Sam Harwell
+ * @author Eric Vergnaud
  */
 public class JavaScriptTarget extends Target {
 

File: tool/src/org/antlr/v4/codegen/model/chunk/RulePropertyRef_parser.java
Patch:
@@ -33,8 +33,8 @@
 import org.antlr.v4.codegen.model.decl.StructDecl;
 
 /** */
-public class RulePropertyRef_self extends RulePropertyRef {
-	public RulePropertyRef_self(StructDecl ctx, String label) {
+public class RulePropertyRef_parser extends RulePropertyRef {
+	public RulePropertyRef_parser(StructDecl ctx, String label) {
 		super(ctx, label);
 	}
 }

File: tool/src/org/antlr/v4/codegen/model/chunk/ThisRulePropertyRef_parser.java
Patch:
@@ -33,8 +33,8 @@
 import org.antlr.v4.codegen.model.decl.StructDecl;
 
 /** */
-public class ThisRulePropertyRef_self extends RulePropertyRef {
-	public ThisRulePropertyRef_self(StructDecl ctx, String label) {
+public class ThisRulePropertyRef_parser extends RulePropertyRef {
+	public ThisRulePropertyRef_parser(StructDecl ctx, String label) {
 		super(ctx, label);
 	}
 }

File: tool/src/org/antlr/v4/tool/Rule.java
Patch:
@@ -55,7 +55,7 @@ public class Rule implements AttributeResolver {
 	public static final AttributeDict predefinedRulePropertiesDict =
 		new AttributeDict(AttributeDict.DictType.PREDEFINED_RULE);
 	static {
-		predefinedRulePropertiesDict.add(new Attribute("self"));
+		predefinedRulePropertiesDict.add(new Attribute("parser"));
 		predefinedRulePropertiesDict.add(new Attribute("text"));
 		predefinedRulePropertiesDict.add(new Attribute("start"));
 		predefinedRulePropertiesDict.add(new Attribute("stop"));

File: tool/test/org/antlr/v4/test/rt/gen/Generator.java
Patch:
@@ -1417,6 +1417,7 @@ private JUnitTestFile buildParserExec() throws Exception {
 		file.addParserTests(input, "ReferenceToATN", "T", "a",
 			"", "\n",
 			"a 34 c", "a34c\n");
+		file.addParserTest(input, "ParserProperty", "T", "a", "abc", "valid\n", null);
 		/*CompositeParserTestMethod tm = file.addCompositeParserTest(input, "AlternateQuotes", "ModeTagsParser", "file_", "", "", null, "ModeTagsLexer");
 		tm.slaveIsLexer = true;*/
 		return file;

File: tool/test/org/antlr/v4/test/rt/java/TestSemPredEvalParser.java
Patch:
@@ -427,7 +427,7 @@ String testPredFromAltTestedInLoopBack(String input) throws Exception {
 	                  "@after {System.out.println($ctx.toStringTree(this));}\n" +
 	                  "  : para para EOF ;\n" +
 	                  "para: paraContent NL NL ;\n" +
-	                  "paraContent : ('s'|'x'|{this._input.LA(2)!=NL}? NL)+ ;\n" +
+	                  "paraContent : ('s'|'x'|{this._input.LA(2)!=TParser.NL}? NL)+ ;\n" +
 	                  "NL : '\\n' ;\n" +
 	                  "s : 's' ;\n" +
 	                  "X : 'x' ;";

File: tool/test/org/antlr/v4/test/tool/TestDollarParser.java
Patch:
@@ -5,12 +5,12 @@
 import org.antlr.v4.test.rt.java.BaseTest;
 import org.junit.Test;
 
-public class TestDollarSelf extends BaseTest {
+public class TestDollarParser extends BaseTest {
 
 	@Test
 	public void testSimpleCall() throws Exception {
 		String grammar = "grammar T;\n" +
-	                  "a : ID  { System.out.println( $self.getSourceName() ); }\n" +
+	                  "a : ID  { System.out.println( $parser.getSourceName() ); }\n" +
 	                  "  ;\n" +
 	                  "ID : 'a'..'z'+ ;\n";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "a", "x", true);

File: tool/test/org/antlr/v4/test/rt/py2/TestLexerErrors.java
Patch:
@@ -172,5 +172,4 @@ public void testLexerExecDFA() throws Exception {
 		assertEquals("line 1:1 token recognition error at: ' '\nline 1:3 token recognition error at: ' '\n", this.stderrDuringParse);
 	}
 
-
 }
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/py2/TestLexerErrors.java
Patch:
@@ -172,5 +172,4 @@ public void testLexerExecDFA() throws Exception {
 		assertEquals("line 1:1 token recognition error at: ' '\nline 1:3 token recognition error at: ' '\n", this.stderrDuringParse);
 	}
 
-
 }
\ No newline at end of file

File: tool/test/org/antlr/v4/test/rt/java/TestCompositeLexers.java
Patch:
@@ -5,6 +5,7 @@
 
 public class TestCompositeLexers extends BaseTest {
 
+	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
 	public void testLexerDelegatorInvokesDelegateRule() throws Exception {
 		String slave_S = "lexer grammar S;\n" +
@@ -28,6 +29,7 @@ public void testLexerDelegatorInvokesDelegateRule() throws Exception {
 		assertNull(this.stderrDuringParse);
 	}
 
+	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
 	public void testLexerDelegatorRuleOverridesDelegate() throws Exception {
 		String slave_S = "lexer grammar S;\n" +

File: tool/test/org/antlr/v4/test/rt/java/TestCompositeLexers.java
Patch:
@@ -5,6 +5,7 @@
 
 public class TestCompositeLexers extends BaseTest {
 
+	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
 	public void testLexerDelegatorInvokesDelegateRule() throws Exception {
 		String slave_S = "lexer grammar S;\n" +
@@ -28,6 +29,7 @@ public void testLexerDelegatorInvokesDelegateRule() throws Exception {
 		assertNull(this.stderrDuringParse);
 	}
 
+	/* this file and method are generated, any edit will be overwritten by the next generation */
 	@Test
 	public void testLexerDelegatorRuleOverridesDelegate() throws Exception {
 		String slave_S = "lexer grammar S;\n" +

File: tool/test/org/antlr/v4/test/rt/gen/AbstractParserTestMethod.java
Patch:
@@ -1,6 +1,6 @@
 package org.antlr.v4.test.rt.gen;
 
-public class AbstractParserTestMethod extends TestMethod {
+public class AbstractParserTestMethod extends JUnitTestMethod {
 
 	public String startRule;
 

File: tool/test/org/antlr/v4/test/rt/gen/ConcreteParserTestMethod.java
Patch:
@@ -4,7 +4,7 @@
 
 import org.stringtemplate.v4.STGroup;
 
-public class ConcreteParserTestMethod extends TestMethod {
+public class ConcreteParserTestMethod extends JUnitTestMethod {
 
 	public String baseName;
 	

File: tool/test/org/antlr/v4/test/rt/gen/JUnitTestMethod.java
Patch:
@@ -4,7 +4,7 @@
 
 import org.stringtemplate.v4.STGroup;
 
-public abstract class TestMethod {
+public abstract class JUnitTestMethod {
 
 	public String name;
 	public Grammar grammar;
@@ -14,7 +14,7 @@ public abstract class TestMethod {
 	public String expectedErrors;
 	public boolean debug = false;
 	
-	protected TestMethod(String name, String grammarName, String input, 
+	protected JUnitTestMethod(String name, String grammarName, String input, 
 			String expectedOutput, String expectedErrors, Integer index) {
 		this.name = name + (index==null ? "" : "_" + index);
 		this.grammar = new Grammar(name, grammarName);

File: tool/test/org/antlr/v4/test/rt/gen/LexerTestMethod.java
Patch:
@@ -1,6 +1,6 @@
 package org.antlr.v4.test.rt.gen;
 
-public class LexerTestMethod extends TestMethod {
+public class LexerTestMethod extends JUnitTestMethod {
 
 	public String[] outputLines;
 	public boolean lexerOnly = true;

File: tool/test/org/antlr/v4/test/rt/gen/ParserTestMethod.java
Patch:
@@ -1,6 +1,6 @@
 package org.antlr.v4.test.rt.gen;
 
-public class ParserTestMethod extends TestMethod {
+public class ParserTestMethod extends JUnitTestMethod {
 
 	public String startRule;
 

File: tool/test/org/antlr/v4/test/rt/java/TestSemPredEvalParser.java
Patch:
@@ -423,4 +423,4 @@ public void testPredFromAltTestedInLoopBack_2() throws Exception {
 	}
 
 
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/tool/TestPerformance.java
Patch:
@@ -410,7 +410,7 @@ public class TestPerformance extends BaseTest {
     private final AtomicIntegerArray tokenCount = new AtomicIntegerArray(PASSES);
 
     @Test
-    //@org.junit.Ignore
+    @org.junit.Ignore
     public void compileJdk() throws IOException, InterruptedException, ExecutionException {
         String jdkSourceRoot = getSourceRoot("JDK");
 		assertTrue("The JDK_SOURCE_ROOT environment variable must be set for performance testing.", jdkSourceRoot != null && !jdkSourceRoot.isEmpty());

File: tool/test/org/antlr/v4/test/tool/BaseTest.java
Patch:
@@ -27,7 +27,7 @@
  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.automata.ATNFactory;
@@ -1411,4 +1411,4 @@ public <K extends Comparable<? super K>,V> LinkedHashMap<K,V> sort(Map<K,V> data
 		}
 		return dup;
 	}
-}
+}
\ No newline at end of file

File: tool/test/org/antlr/v4/test/tool/ErrorQueue.java
Patch:
@@ -27,7 +27,7 @@
  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.runtime.misc.Utils;

File: tool/test/org/antlr/v4/test/tool/JavaUnicodeInputStream.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.misc.IntegerList;

File: tool/test/org/antlr/v4/test/tool/ParserInterpreterForTesting.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.runtime.Parser;

File: tool/test/org/antlr/v4/test/tool/TestASTStructure.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.runtime.ANTLRStringStream;
 import org.antlr.runtime.CharStream;

File: tool/test/org/antlr/v4/test/tool/TestATNDeserialization.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNDeserializer;

File: tool/test/org/antlr/v4/test/tool/TestATNInterpreter.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.automata.ParserATNFactory;
 import org.antlr.v4.runtime.Lexer;

File: tool/test/org/antlr/v4/test/tool/TestATNLexerInterpreter.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.ANTLRInputStream;
 import org.antlr.v4.runtime.CharStream;

File: tool/test/org/antlr/v4/test/tool/TestATNParserPrediction.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.automata.ParserATNFactory;

File: tool/test/org/antlr/v4/test/tool/TestATNSerialization.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNSerializer;

File: tool/test/org/antlr/v4/test/tool/TestActionSplitter.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.runtime.ANTLRStringStream;
 import org.antlr.runtime.Token;

File: tool/test/org/antlr/v4/test/tool/TestActionTranslation.java
Patch:
@@ -28,11 +28,12 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.junit.Test;
 
 /** */
+@SuppressWarnings("unused")
 public class TestActionTranslation extends BaseTest {
 	String attributeTemplate =
 		"attributeTemplate(members,init,inline,finally,inline2) ::= <<\n" +

File: tool/test/org/antlr/v4/test/tool/TestAttributeChecks.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.runtime.RecognitionException;
 import org.antlr.v4.tool.ErrorType;

File: tool/test/org/antlr/v4/test/tool/TestBasicSemanticErrors.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.tool.ErrorType;
 import org.junit.Test;

File: tool/test/org/antlr/v4/test/tool/TestBufferedTokenStream.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.ANTLRInputStream;
 import org.antlr.v4.runtime.BufferedTokenStream;

File: tool/test/org/antlr/v4/test/tool/TestCodeGeneration.java
Patch:
@@ -27,7 +27,7 @@
  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.runtime.RecognitionException;
 import org.antlr.v4.automata.ATNFactory;
@@ -56,7 +56,7 @@
 
 public class TestCodeGeneration extends BaseTest {
 	@Test public void testArgDecl() throws Exception { // should use template not string
-		ErrorQueue equeue = new ErrorQueue();
+		/*ErrorQueue equeue = */new ErrorQueue();
 		String g =
 				"grammar T;\n" +
 				"a[int xyz] : 'a' ;\n";

File: tool/test/org/antlr/v4/test/tool/TestFastQueue.java
Patch:
@@ -27,7 +27,7 @@
  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.runtime.misc.FastQueue;
 import org.junit.Test;

File: tool/test/org/antlr/v4/test/tool/TestGraphNodes.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.atn.ArrayPredictionContext;
 import org.antlr.v4.runtime.atn.PredictionContext;

File: tool/test/org/antlr/v4/test/tool/TestIntervalSet.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.Token;

File: tool/test/org/antlr/v4/test/tool/TestLexerActions.java
Patch:
@@ -1,4 +1,4 @@
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.junit.Test;
 

File: tool/test/org/antlr/v4/test/tool/TestParseTreeMatcher.java
Patch:
@@ -1,4 +1,4 @@
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CommonTokenStream;

File: tool/test/org/antlr/v4/test/tool/TestParserInterpreter.java
Patch:
@@ -28,7 +28,7 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.ANTLRInputStream;
 import org.antlr.v4.runtime.CommonTokenStream;

File: tool/test/org/antlr/v4/test/tool/TestParserProfiler.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.ANTLRInputStream;
 import org.antlr.v4.runtime.CommonTokenStream;
@@ -46,6 +46,7 @@
 
 import static org.junit.Assert.assertEquals;
 
+@SuppressWarnings("unused")
 public class TestParserProfiler extends BaseTest {
 	LexerGrammar lg;
 

File: tool/test/org/antlr/v4/test/tool/TestPerformance.java
Patch:
@@ -28,7 +28,7 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.ANTLRInputStream;
@@ -107,6 +107,7 @@
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
+@SuppressWarnings("unused")
 public class TestPerformance extends BaseTest {
     /**
      * Parse all java files under this package within the JDK_SOURCE_ROOT
@@ -790,7 +791,6 @@ protected void loadSources(File directory, FilenameFilter filesFilter, FilenameF
 
     int configOutputSize = 0;
 
-    @SuppressWarnings("unused")
 	protected void parseSources(final int currentPass, final ParserFactory factory, Collection<InputDescriptor> sources, boolean shuffleSources) throws InterruptedException {
 		if (shuffleSources) {
 			List<InputDescriptor> sourcesList = new ArrayList<InputDescriptor>(sources);
@@ -1168,6 +1168,7 @@ protected ParserFactory getParserFactory(String lexerName, String parserName, St
             parserCtor.newInstance(new CommonTokenStream(tokenSource));
 
             return new ParserFactory() {
+				
 				@Override
                 public FileParseResult parseFile(CharStream input, int currentPass, int thread) {
 					final Checksum checksum = new CRC32();

File: tool/test/org/antlr/v4/test/tool/TestScopeParsing.java
Patch:
@@ -28,10 +28,9 @@
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.test;
+package org.antlr.v4.test.tool;
 
 import org.antlr.v4.parse.ScopeParser;
-import org.antlr.v4.tool.ErrorManager;
 import org.antlr.v4.tool.Grammar;
 import org.junit.Test;
 

File: tool/test/org/antlr/v4/test/rt/js/node/TestParserErrors.java
Patch:
@@ -44,7 +44,7 @@ public void testSingleTokenInsertion() throws Exception {
 	@Test
 	public void testConjuringUpToken() throws Exception {
 		String grammar = "grammar T;\n" +
-	                  "a : 'a' x='b' {console.log(\"conjured=\"+$x);} 'c' ;";
+	                  "a : 'a' x='b' {console.log(\"conjured=\" + $x);} 'c' ;";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "a", "ac", false);
 		assertEquals("conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n", found);
 		assertEquals("line 1:1 missing 'b' at 'c'\n", this.stderrDuringParse);
@@ -62,7 +62,7 @@ public void testSingleSetInsertion() throws Exception {
 	@Test
 	public void testConjuringUpTokenFromSet() throws Exception {
 		String grammar = "grammar T;\n" +
-	                  "a : 'a' x=('b'|'c') {console.log(\"conjured=\"+$x);} 'd' ;";
+	                  "a : 'a' x=('b'|'c') {console.log(\"conjured=\" + $x);} 'd' ;";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "a", "ad", false);
 		assertEquals("conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n", found);
 		assertEquals("line 1:1 missing {'b', 'c'} at 'd'\n", this.stderrDuringParse);

File: tool/test/org/antlr/v4/test/rt/js/node/TestSemPredEvalParser.java
Patch:
@@ -216,7 +216,7 @@ public void testToLeftWithVaryingPredicate() throws Exception {
 		String grammar = "grammar T;\n" +
 	                  "@members {this.i = 0;}\n" +
 	                  "s : ({this.i += 1;\n" +
-	                  "	  console.log(\"i=\" + this.i);} a)+ ;\n" +
+	                  "console.log(\"i=\" + this.i);} a)+ ;\n" +
 	                  "a : {this.i % 2 === 0}? ID {console.log(\"alt 1\");}\n" +
 	                  "  | {this.i % 2 != 0}? ID {console.log(\"alt 2\");}\n" +
 	                  "  ;\n" +

File: tool/test/org/antlr/v4/test/rt/js/safari/TestParserErrors.java
Patch:
@@ -44,7 +44,7 @@ public void testSingleTokenInsertion() throws Exception {
 	@Test
 	public void testConjuringUpToken() throws Exception {
 		String grammar = "grammar T;\n" +
-	                  "a : 'a' x='b' {document.getElementById('output').value += \"conjured=\"+$x + '\\n';} 'c' ;";
+	                  "a : 'a' x='b' {document.getElementById('output').value += \"conjured=\" + $x + '\\n';} 'c' ;";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "a", "ac", false);
 		assertEquals("conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n", found);
 		assertEquals("line 1:1 missing 'b' at 'c'\n", this.stderrDuringParse);
@@ -62,7 +62,7 @@ public void testSingleSetInsertion() throws Exception {
 	@Test
 	public void testConjuringUpTokenFromSet() throws Exception {
 		String grammar = "grammar T;\n" +
-	                  "a : 'a' x=('b'|'c') {document.getElementById('output').value += \"conjured=\"+$x + '\\n';} 'd' ;";
+	                  "a : 'a' x=('b'|'c') {document.getElementById('output').value += \"conjured=\" + $x + '\\n';} 'd' ;";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "a", "ad", false);
 		assertEquals("conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n", found);
 		assertEquals("line 1:1 missing {'b', 'c'} at 'd'\n", this.stderrDuringParse);

File: tool/test/org/antlr/v4/test/rt/js/safari/TestSemPredEvalParser.java
Patch:
@@ -216,7 +216,7 @@ public void testToLeftWithVaryingPredicate() throws Exception {
 		String grammar = "grammar T;\n" +
 	                  "@members {this.i = 0;}\n" +
 	                  "s : ({this.i += 1;\n" +
-	                  "	  document.getElementById('output').value += \"i=\" + this.i + '\\n';} a)+ ;\n" +
+	                  "document.getElementById('output').value += \"i=\" + this.i + '\\n';} a)+ ;\n" +
 	                  "a : {this.i % 2 === 0}? ID {document.getElementById('output').value += \"alt 1\" + '\\n';}\n" +
 	                  "  | {this.i % 2 != 0}? ID {document.getElementById('output').value += \"alt 2\" + '\\n';}\n" +
 	                  "  ;\n" +

File: tool/test/org/antlr/v4/py/test/BasePythonTest.java
Patch:
@@ -85,7 +85,7 @@
 import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.semantics.SemanticPipeline;
-import org.antlr.v4.test.ErrorQueue;
+import org.antlr.v4.test.tool.ErrorQueue;
 import org.antlr.v4.tool.ANTLRMessage;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.DefaultToolListener;

File: tool/test/org/antlr/v4/test/rt/py3/BasePython3Test.java
Patch:
@@ -27,7 +27,7 @@
  *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-package org.antlr.v4.py3.test;
+package org.antlr.v4.test.rt.py3;
 
 import org.antlr.v4.py.test.BasePythonTest;
 import org.stringtemplate.v4.ST;

File: tool/test/org/antlr/v4/test/rt/py3/TestLexerActions.java
Patch:
@@ -1,4 +1,4 @@
-package org.antlr.v4.py3.test;
+package org.antlr.v4.test.rt.py3;
 
 import org.junit.Test;
 

File: tool/test/org/antlr/v4/test/rt/py2/BasePython2Test.java
Patch:
@@ -1,4 +1,4 @@
-package org.antlr.v4.py2.test;
+package org.antlr.v4.test.rt.py2;
 
 import org.antlr.v4.py.test.BasePythonTest;
 import org.stringtemplate.v4.ST;

File: tool/test/org/antlr/v4/py2/test/TestLexerErrors.java
Patch:
@@ -201,7 +201,7 @@ public void testLexerExecDFA() throws Exception {
 		String result = execLexer("T.g4", grammar, "TLexer", "x : x", false);
 		String expecting =
 			"[@0,0:0='x',<3>,1:0]\n" +
-			"[@1,2:2=':',<2>,1:2]\n" +
+			"[@1,2:2=':',<1>,1:2]\n" +
 			"[@2,4:4='x',<3>,1:4]\n" +
 			"[@3,5:4='<EOF>',<-1>,1:5]\n";
 		assertEquals(expecting, result);

File: tool/test/org/antlr/v4/py2/test/TestParseErrors.java
Patch:
@@ -85,7 +85,7 @@ public class TestParseErrors extends BasePython2Test {
 			"grammar T;\n" +
 			"a : 'a' x='b' {print(\"conjured=\"+str($x))} 'c' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "a", "ac", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 
@@ -104,7 +104,7 @@ public class TestParseErrors extends BasePython2Test {
 			"grammar T;\n" +
 			"a : 'a' x=('b'|'c') {print(\"conjured=\"+str($x))} 'd' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "a", "ad", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 

File: tool/test/org/antlr/v4/test/TestLexerActions.java
Patch:
@@ -79,7 +79,7 @@ public class TestLexerActions extends BaseTest {
 			"Hello: Steve\n" +
 			"\n" +
 			"[@0,0:11='hello Steve\\n',<1>,1:0]\n" +
-			"[@1,12:11='<EOF>',<-1>,2:12]\n";
+			"[@1,12:11='<EOF>',<-1>,2:0]\n";
 		assertEquals(expecting, found);
 	}
 
@@ -276,7 +276,7 @@ public void testFailingPredicateEvalIsNotCached() {
 			"[@3,31:31='\\n',<4>,2:18]\n" +
 			"[@4,32:45='Another line.\\n',<1>,3:0]\n" +
 			"[@5,46:56='More line.\\n',<1>,4:0]\n" +
-			"[@6,57:56='<EOF>',<-1>,5:11]\n";
+			"[@6,57:56='<EOF>',<-1>,5:0]\n";
 		assertEquals(expecting, found);
 	}
 

File: tool/test/org/antlr/v4/test/TestSemPredEvalLexer.java
Patch:
@@ -129,7 +129,7 @@ public class TestSemPredEvalLexer extends BaseTest {
 			"[@3,6:8='def',<1>,2:2]\n" +		// ID
 			"[@4,9:10='  ',<4>,2:5]\n" +		// WS
 			"[@5,11:11='\\n',<3>,2:7]\n" +
-			"[@6,12:11='<EOF>',<-1>,3:8]\n" +
+			"[@6,12:11='<EOF>',<-1>,3:0]\n" +
 			"s0-'\n" +
 			"'->:s2=>3\n" +
 			"s0-'a'->:s1=>1\n" +

File: tool/test/org/antlr/v4/test/TestSemPredEvalParser.java
Patch:
@@ -614,7 +614,7 @@ public void testUnpredicatedPathsInAlt() throws Exception{
 		String found = execParser("T2.g4", grammar, "T2Parser", "T2Lexer", "file",
 								  input, true);
 		assertEquals("(file (para (paraContent s) \\n \\n) (para (paraContent \\n x \\n)) <EOF>)\n", found);
-		assertEquals(stderrDuringParse, "line 5:2 mismatched input '<EOF>' expecting '\n'\n");
+		assertEquals(stderrDuringParse, "line 5:0 mismatched input '<EOF>' expecting '\n'\n");
 
 		input = "s\n\n\nx\n\n";
 		found = execParser("T2.g4", grammar, "T2Parser", "T2Lexer", "file",

File: tool/test/org/antlr/v4/test/rt/gen/LexerTestMethod.java
Patch:
@@ -3,7 +3,8 @@
 public class LexerTestMethod extends TestMethod {
 
 	public String[] outputLines;
-
+	public boolean lexerOnly = true;
+	
 	public LexerTestMethod(String name, String grammarName, String input, 
 			String expectedOutput, String expectedErrors, Integer index) {
 		super(name, grammarName, input, expectedOutput, expectedErrors, index);

File: runtime/Java/src/org/antlr/v4/runtime/misc/Pair.java
Patch:
@@ -30,7 +30,9 @@
 
 package org.antlr.v4.runtime.misc;
 
-public class Pair<A,B> {
+import java.io.Serializable;
+
+public class Pair<A,B> implements Serializable {
 	public final A a;
 	public final B b;
 

File: tool/src/org/antlr/v4/misc/Graph.java
Patch:
@@ -32,7 +32,7 @@
 import org.antlr.v4.runtime.misc.OrderedHashSet;
 
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -59,7 +59,7 @@ public void addEdge(Node<T> n) {
 	}
 
 	/** Map from node payload to node containing it */
-	protected Map<T,Node<T>> nodes = new HashMap<T,Node<T>>();
+	protected Map<T,Node<T>> nodes = new LinkedHashMap<T,Node<T>>();
 
 	public void addEdge(T a, T b) {
 		//System.out.println("add edge "+a+" to "+b);

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -72,6 +72,7 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -1229,7 +1230,7 @@ protected static boolean defAlias(GrammarAST r, String pattern,
 	}
 
 	public Set<String> getStringLiterals() {
-		final Set<String> strings = new HashSet<String>();
+		final Set<String> strings = new LinkedHashSet<String>();
 		GrammarTreeVisitor collector = new GrammarTreeVisitor() {
 			@Override
 			public void stringRef(TerminalAST ref) {

File: tool/src/org/antlr/v4/tool/Rule.java
Patch:
@@ -41,6 +41,7 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -212,7 +213,7 @@ public int getOriginalNumberOfAlts() {
 	 * this label. Unlabeled alternatives are not included in the result.
 	 */
 	public Map<String, List<Pair<Integer, AltAST>>> getAltLabels() {
-		Map<String, List<Pair<Integer, AltAST>>> labels = new HashMap<String, List<Pair<Integer, AltAST>>>();
+		Map<String, List<Pair<Integer, AltAST>>> labels = new LinkedHashMap<String, List<Pair<Integer, AltAST>>>();
 		for (int i=1; i<=numberOfAlts; i++) {
 			GrammarAST altLabel = alt[i].ast.altLabel;
 			if ( altLabel!=null ) {

File: tool/test/org/antlr/v4/test/TestLexerErrors.java
Patch:
@@ -201,7 +201,7 @@ public void testLexerExecDFA() throws Exception {
 		String result = execLexer("T.g4", grammar, "TLexer", "x : x", false);
 		String expecting =
 			"[@0,0:0='x',<3>,1:0]\n" +
-			"[@1,2:2=':',<2>,1:2]\n" +
+			"[@1,2:2=':',<1>,1:2]\n" +
 			"[@2,4:4='x',<3>,1:4]\n" +
 			"[@3,5:4='<EOF>',<-1>,1:5]\n";
 		assertEquals(expecting, result);

File: tool/test/org/antlr/v4/test/TestParseErrors.java
Patch:
@@ -82,7 +82,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x='b' {System.out.println(\"conjured=\"+$x);} 'c' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ac", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 
@@ -101,7 +101,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x=('b'|'c') {System.out.println(\"conjured=\"+$x);} 'd' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ad", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 

File: tool/test/org/antlr/v4/test/TestTopologicalSort.java
Patch:
@@ -53,7 +53,7 @@ public void testFairlyLargeGraph() throws Exception {
         g.addEdge("F", "H");
         g.addEdge("E", "F");
 
-        String expecting = "[H, F, E, D, G, A, B, C]";
+        String expecting = "[H, F, G, E, D, A, B, C]";
         List<String> nodes = g.sort();
         String result = nodes.toString();
         assertEquals(expecting, result);
@@ -95,7 +95,7 @@ public void testSimpleTokenDependence() throws Exception {
         g.addEdge("Def.g4", "Java.tokens");    // walkers feed off generated tokens
         g.addEdge("Ref.g4", "Java.tokens");
 
-        String expecting = "[MyJava.tokens, Java.g4, Java.tokens, Ref.g4, Def.g4]";
+        String expecting = "[MyJava.tokens, Java.g4, Java.tokens, Def.g4, Ref.g4]";
         List<String> nodes = g.sort();
         String result = nodes.toString();
         assertEquals(expecting, result);
@@ -109,7 +109,7 @@ public void testParserLexerCombo() throws Exception {
         g.addEdge("Def.g4", "JavaLexer.tokens");
         g.addEdge("Ref.g4", "JavaLexer.tokens");
 
-        String expecting = "[JavaLexer.g4, JavaLexer.tokens, JavaParser.g4, Ref.g4, Def.g4]";
+        String expecting = "[JavaLexer.g4, JavaLexer.tokens, JavaParser.g4, Def.g4, Ref.g4]";
         List<String> nodes = g.sort();
         String result = nodes.toString();
         assertEquals(expecting, result);

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -91,6 +91,7 @@ public interface TokenSource {
 	 * non-null, non-empty string. If such a name is not known, this method
 	 * returns {@link IntStream#UNKNOWN_SOURCE_NAME}.
 	 */
+	@NotNull
 	public String getSourceName();
 
 	/**

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -1269,7 +1269,7 @@ public int size() {
 
 		@Override
 		public String getSourceName() {
-			return null;
+			return UNKNOWN_SOURCE_NAME;
 		}
 
 		@Override

File: tool/test/org/antlr/v4/test/TestCommonTokenStream.java
Patch:
@@ -33,6 +33,7 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CommonToken;
 import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.IntStream;
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenFactory;
@@ -235,7 +236,7 @@ public CharStream getInputStream() {
 
 			@Override
 			public String getSourceName() {
-				return null;
+				return IntStream.UNKNOWN_SOURCE_NAME;
 			}
 
 			@Override
@@ -283,7 +284,7 @@ public CharStream getInputStream() {
 
 			@Override
 			public String getSourceName() {
-				return null;
+				return IntStream.UNKNOWN_SOURCE_NAME;
 			}
 
 			@Override

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -358,6 +358,7 @@ public String[] getModeNames() {
 	 *  that overrides this to point to their String[] tokenNames.
 	 */
 	@Override
+	@Deprecated
 	public String[] getTokenNames() {
 		return null;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -857,7 +857,7 @@ public List<String> getDFAStrings() {
 			List<String> s = new ArrayList<String>();
 			for (int d = 0; d < _interp.decisionToDFA.length; d++) {
 				DFA dfa = _interp.decisionToDFA[d];
-				s.add( dfa.toString(getTokenNames()) );
+				s.add( dfa.toString(getVocabulary()) );
 			}
 			return s;
 		}
@@ -872,7 +872,7 @@ public void dumpDFA() {
 				if ( !dfa.states.isEmpty() ) {
 					if ( seenOne ) System.out.println();
 					System.out.println("Decision " + dfa.decision + ":");
-					System.out.print(dfa.toString(getTokenNames()));
+					System.out.print(dfa.toString(getVocabulary()));
 					seenOne = true;
 				}
 			}

File: runtime/Java/src/org/antlr/v4/runtime/dfa/LexerDFASerializer.java
Patch:
@@ -30,11 +30,12 @@
 
 package org.antlr.v4.runtime.dfa;
 
+import org.antlr.v4.runtime.VocabularyImpl;
 import org.antlr.v4.runtime.misc.NotNull;
 
 public class LexerDFASerializer extends DFASerializer {
 	public LexerDFASerializer(@NotNull DFA dfa) {
-		super(dfa, null);
+		super(dfa, VocabularyImpl.EMPTY_VOCABULARY);
 	}
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePatternMatcher.java
Patch:
@@ -220,7 +220,7 @@ public ParseTreePattern compile(String pattern, int patternRuleIndex) {
 		CommonTokenStream tokens = new CommonTokenStream(tokenSrc);
 
 		ParserInterpreter parserInterp = new ParserInterpreter(parser.getGrammarFileName(),
-															   Arrays.asList(parser.getTokenNames()),
+															   parser.getVocabulary(),
 															   Arrays.asList(parser.getRuleNames()),
 															   parser.getATNWithBypassAlts(),
 															   tokens);

File: tool/src/org/antlr/v4/automata/ATNPrinter.java
Patch:
@@ -106,7 +106,7 @@ else if ( t instanceof SetTransition ) {
 						buf.append("-").append(not?"~":"").append(st.toString()).append("->").append(getStateString(t.target)).append('\n');
 					}
 					else {
-						buf.append("-").append(not?"~":"").append(st.label().toString(g.getTokenDisplayNames())).append("->").append(getStateString(t.target)).append('\n');
+						buf.append("-").append(not?"~":"").append(st.label().toString(g.getVocabulary())).append("->").append(getStateString(t.target)).append('\n');
 					}
 				}
 				else if ( t instanceof AtomTransition ) {

File: tool/src/org/antlr/v4/tool/DOTGenerator.java
Patch:
@@ -292,7 +292,7 @@ else if ( edge instanceof SetTransition ) {
 					SetTransition set = (SetTransition)edge;
 					String label = set.label().toString();
 					if ( isLexer ) label = set.label().toString(true);
-					else if ( grammar!=null ) label = set.label().toString(grammar.getTokenDisplayNames());
+					else if ( grammar!=null ) label = set.label().toString(grammar.getVocabulary());
 					if ( edge instanceof NotSetTransition ) label = "~"+label;
 					edgeST.add("label", getEdgeLabel(label));
 				}
@@ -301,7 +301,7 @@ else if ( edge instanceof RangeTransition ) {
 					RangeTransition range = (RangeTransition)edge;
 					String label = range.label().toString();
 					if ( isLexer ) label = range.toString();
-					else if ( grammar!=null ) label = range.label().toString(grammar.getTokenDisplayNames());
+					else if ( grammar!=null ) label = range.label().toString(grammar.getVocabulary());
 					edgeST.add("label", getEdgeLabel(label));
 				}
 				else {

File: tool/test/org/antlr/v4/test/ParserInterpreterForTesting.java
Patch:
@@ -73,6 +73,7 @@ public String[] getRuleNames() {
 		}
 
 		@Override
+		@Deprecated
 		public String[] getTokenNames() {
 			return g.getTokenNames();
 		}

File: tool/test/org/antlr/v4/test/TestATNParserPrediction.java
Patch:
@@ -525,7 +525,7 @@ public void checkDFAConstruction(LexerGrammar lg, Grammar g, int decision,
 				nvae.printStackTrace(System.err);
 			}
 			DFA dfa = interp.parser.decisionToDFA[decision];
-			assertEquals(dfaString[i], dfa.toString(g.getTokenDisplayNames()));
+			assertEquals(dfaString[i], dfa.toString(g.getVocabulary()));
 		}
 	}
 }

File: tool/test/org/antlr/v4/test/TestLexerExec.java
Patch:
@@ -647,7 +647,7 @@ public void testLargeLexer() throws Exception {
 		grammar.append("lexer grammar L;\n");
 		grammar.append("WS : [ \\t\\r\\n]+ -> skip;\n");
 		for (int i = 0; i < 4000; i++) {
-			grammar.append("KW").append(i).append(" : '").append("KW").append(i).append("';\n");
+			grammar.append("KW").append(i).append(" : 'KW' '").append(i).append("';\n");
 		}
 
 		String input = "KW400";

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -70,6 +70,7 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -1180,7 +1181,7 @@ protected static boolean defAlias(GrammarAST r, String pattern,
 	}
 
 	public Set<String> getStringLiterals() {
-		final Set<String> strings = new HashSet<String>();
+		final Set<String> strings = new LinkedHashSet<String>();
 		GrammarTreeVisitor collector = new GrammarTreeVisitor() {
 			@Override
 			public void stringRef(TerminalAST ref) {

File: tool/test/org/antlr/v4/test/TestLexerErrors.java
Patch:
@@ -201,7 +201,7 @@ public void testLexerExecDFA() throws Exception {
 		String result = execLexer("T.g4", grammar, "TLexer", "x : x", false);
 		String expecting =
 			"[@0,0:0='x',<3>,1:0]\n" +
-			"[@1,2:2=':',<2>,1:2]\n" +
+			"[@1,2:2=':',<1>,1:2]\n" +
 			"[@2,4:4='x',<3>,1:4]\n" +
 			"[@3,5:4='<EOF>',<-1>,1:5]\n";
 		assertEquals(expecting, result);

File: tool/test/org/antlr/v4/test/TestParseErrors.java
Patch:
@@ -82,7 +82,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x='b' {System.out.println(\"conjured=\"+$x);} 'c' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ac", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 
@@ -101,7 +101,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x=('b'|'c') {System.out.println(\"conjured=\"+$x);} 'd' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ad", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<2>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -432,6 +432,7 @@ public enum ErrorType {
 	 *
 	 * @deprecated This warning is no longer applicable with the current syntax for specifying associativity.
 	 */
+	@Deprecated
 	ALL_OPS_NEED_SAME_ASSOC(118, "all operators of alt <arg> of left-recursive rule must have same associativity", ErrorSeverity.WARNING),
 	/**
 	 * Compiler Error 119.

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -1269,7 +1269,7 @@ public int size() {
 
 		@Override
 		public String getSourceName() {
-			return null;
+			return UNKNOWN_SOURCE_NAME;
 		}
 
 		@Override

File: tool/test/org/antlr/v4/test/TestCommonTokenStream.java
Patch:
@@ -33,6 +33,7 @@
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.CommonToken;
 import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.IntStream;
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenFactory;
@@ -235,7 +236,7 @@ public CharStream getInputStream() {
 
 			@Override
 			public String getSourceName() {
-				return null;
+				return IntStream.UNKNOWN_SOURCE_NAME;
 			}
 
 			@Override
@@ -283,7 +284,7 @@ public CharStream getInputStream() {
 
 			@Override
 			public String getSourceName() {
-				return null;
+				return IntStream.UNKNOWN_SOURCE_NAME;
 			}
 
 			@Override

File: tool/test/org/antlr/v4/js/test/TestLeftRecursion.java
Patch:
@@ -235,7 +235,7 @@ public class TestLeftRecursion extends BaseTest {
 			"(T)x",							"(s (e ( (type T) ) (e x)) <EOF>)",
 			"new A().b",					"(s (e (e new (type A) ( )) . b) <EOF>)",
 			"(T)t.f()",						"(s (e (e ( (type T) ) (e (e t) . f)) ( )) <EOF>)",
-			// "a.f(x)==T.c",					"(s (e (e (e (e a) . f) ( (expressionList (e x)) )) == (e (e T) . c)) <EOF>)",
+			"a.f(x)==T.c",					"(s (e (e (e (e a) . f) ( (expressionList (e x)) )) == (e (e T) . c)) <EOF>)",
 			"a.f().g(x,1)",					"(s (e (e (e (e (e a) . f) ( )) . g) ( (expressionList (e x) , (e 1)) )) <EOF>)",
 			"new T[((n-1) * x) + 1]",		"(s (e new (type T) [ (e (e ( (e (e ( (e (e n) - (e 1)) )) * (e x)) )) + (e 1)) ]) <EOF>)", 
 		};

File: tool/test/org/antlr/v4/test/TestLexerExec.java
Patch:
@@ -647,7 +647,7 @@ public void testLargeLexer() throws Exception {
 		grammar.append("lexer grammar L;\n");
 		grammar.append("WS : [ \\t\\r\\n]+ -> skip;\n");
 		for (int i = 0; i < 4000; i++) {
-			grammar.append("KW").append(i).append(" : '").append("KW").append(i).append("';\n");
+			grammar.append("KW").append(i).append(" : 'KW' '").append(i).append("';\n");
 		}
 
 		String input = "KW400";

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -358,6 +358,7 @@ public String[] getModeNames() {
 	 *  that overrides this to point to their String[] tokenNames.
 	 */
 	@Override
+	@Deprecated
 	public String[] getTokenNames() {
 		return null;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -857,7 +857,7 @@ public List<String> getDFAStrings() {
 			List<String> s = new ArrayList<String>();
 			for (int d = 0; d < _interp.decisionToDFA.length; d++) {
 				DFA dfa = _interp.decisionToDFA[d];
-				s.add( dfa.toString(getTokenNames()) );
+				s.add( dfa.toString(getVocabulary()) );
 			}
 			return s;
 		}
@@ -872,7 +872,7 @@ public void dumpDFA() {
 				if ( !dfa.states.isEmpty() ) {
 					if ( seenOne ) System.out.println();
 					System.out.println("Decision " + dfa.decision + ":");
-					System.out.print(dfa.toString(getTokenNames()));
+					System.out.print(dfa.toString(getVocabulary()));
 					seenOne = true;
 				}
 			}

File: runtime/Java/src/org/antlr/v4/runtime/dfa/LexerDFASerializer.java
Patch:
@@ -30,11 +30,12 @@
 
 package org.antlr.v4.runtime.dfa;
 
+import org.antlr.v4.runtime.VocabularyImpl;
 import org.antlr.v4.runtime.misc.NotNull;
 
 public class LexerDFASerializer extends DFASerializer {
 	public LexerDFASerializer(@NotNull DFA dfa) {
-		super(dfa, null);
+		super(dfa, VocabularyImpl.EMPTY_VOCABULARY);
 	}
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePatternMatcher.java
Patch:
@@ -220,7 +220,7 @@ public ParseTreePattern compile(String pattern, int patternRuleIndex) {
 		CommonTokenStream tokens = new CommonTokenStream(tokenSrc);
 
 		ParserInterpreter parserInterp = new ParserInterpreter(parser.getGrammarFileName(),
-															   Arrays.asList(parser.getTokenNames()),
+															   parser.getVocabulary(),
 															   Arrays.asList(parser.getRuleNames()),
 															   parser.getATNWithBypassAlts(),
 															   tokens);

File: tool/src/org/antlr/v4/automata/ATNPrinter.java
Patch:
@@ -106,7 +106,7 @@ else if ( t instanceof SetTransition ) {
 						buf.append("-").append(not?"~":"").append(st.toString()).append("->").append(getStateString(t.target)).append('\n');
 					}
 					else {
-						buf.append("-").append(not?"~":"").append(st.label().toString(g.getTokenDisplayNames())).append("->").append(getStateString(t.target)).append('\n');
+						buf.append("-").append(not?"~":"").append(st.label().toString(g.getVocabulary())).append("->").append(getStateString(t.target)).append('\n');
 					}
 				}
 				else if ( t instanceof AtomTransition ) {

File: tool/src/org/antlr/v4/tool/DOTGenerator.java
Patch:
@@ -292,7 +292,7 @@ else if ( edge instanceof SetTransition ) {
 					SetTransition set = (SetTransition)edge;
 					String label = set.label().toString();
 					if ( isLexer ) label = set.label().toString(true);
-					else if ( grammar!=null ) label = set.label().toString(grammar.getTokenDisplayNames());
+					else if ( grammar!=null ) label = set.label().toString(grammar.getVocabulary());
 					if ( edge instanceof NotSetTransition ) label = "~"+label;
 					edgeST.add("label", getEdgeLabel(label));
 				}
@@ -301,7 +301,7 @@ else if ( edge instanceof RangeTransition ) {
 					RangeTransition range = (RangeTransition)edge;
 					String label = range.label().toString();
 					if ( isLexer ) label = range.toString();
-					else if ( grammar!=null ) label = range.label().toString(grammar.getTokenDisplayNames());
+					else if ( grammar!=null ) label = range.label().toString(grammar.getVocabulary());
 					edgeST.add("label", getEdgeLabel(label));
 				}
 				else {

File: tool/test/org/antlr/v4/test/ParserInterpreterForTesting.java
Patch:
@@ -73,6 +73,7 @@ public String[] getRuleNames() {
 		}
 
 		@Override
+		@Deprecated
 		public String[] getTokenNames() {
 			return g.getTokenNames();
 		}

File: tool/test/org/antlr/v4/test/TestATNParserPrediction.java
Patch:
@@ -525,7 +525,7 @@ public void checkDFAConstruction(LexerGrammar lg, Grammar g, int decision,
 				nvae.printStackTrace(System.err);
 			}
 			DFA dfa = interp.parser.decisionToDFA[decision];
-			assertEquals(dfaString[i], dfa.toString(g.getTokenDisplayNames()));
+			assertEquals(dfaString[i], dfa.toString(g.getVocabulary()));
 		}
 	}
 }

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -137,7 +137,7 @@ else if ( a.equals(ASSOC.left.toString()) ) {
 		}
 
 		if ( altAssociativity.get(alt)!=null && altAssociativity.get(alt)!=assoc ) {
-			tool.errMgr.toolError(ErrorType.ALL_OPS_NEED_SAME_ASSOC, alt);
+			tool.errMgr.toolError(ErrorType.INTERNAL_ERROR, "all operators of alt " + alt + " of left-recursive rule must have same associativity");
 		}
 		altAssociativity.put(alt, assoc);
 

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -429,6 +429,8 @@ public enum ErrorType {
 	 * <p>
 	 * all operators of alt <em>alt</em> of left-recursive rule must have same
 	 * associativity</p>
+	 *
+	 * @deprecated This warning is no longer applicable with the current syntax for specifying associativity.
 	 */
 	ALL_OPS_NEED_SAME_ASSOC(118, "all operators of alt <arg> of left-recursive rule must have same associativity", ErrorSeverity.WARNING),
 	/**

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4ErrorLog.java
Patch:
@@ -63,7 +63,7 @@ public Antlr4ErrorLog(@NotNull Tool tool, @NotNull BuildContext buildContext, @N
 
     /**
      * {@inheritDoc}
-     * <p/>
+     * <p>
      * This implementation passes the message to the Maven log.
      *
      * @param message The message to send to Maven
@@ -78,7 +78,7 @@ public void info(String message) {
 
     /**
      * {@inheritDoc}
-     * <p/>
+     * <p>
      * This implementation passes the message to the Maven log.
      *
      * @param message The message to send to Maven.
@@ -101,7 +101,7 @@ public void error(ANTLRMessage message) {
 
     /**
      * {@inheritDoc}
-     * <p/>
+     * <p>
      * This implementation passes the message to the Maven log.
      *
      * @param message

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -146,7 +146,7 @@ public class Antlr4Mojo extends AbstractMojo {
 	 * the generate phase of the plugin. Note that the plugin is smart enough to
 	 * realize that imported grammars should be included but not acted upon
 	 * directly by the ANTLR Tool.
-	 * <p/>
+	 * <p>
 	 * A set of Ant-like inclusion patterns used to select files from the source
 	 * directory for processing. By default, the pattern
 	 * <code>**&#47;*.g4</code> is used to select grammar files.

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -137,7 +137,7 @@ else if ( a.equals(ASSOC.left.toString()) ) {
 		}
 
 		if ( altAssociativity.get(alt)!=null && altAssociativity.get(alt)!=assoc ) {
-			tool.errMgr.toolError(ErrorType.ALL_OPS_NEED_SAME_ASSOC, alt);
+			tool.errMgr.toolError(ErrorType.INTERNAL_ERROR, "all operators of alt " + alt + " of left-recursive rule must have same associativity");
 		}
 		altAssociativity.put(alt, assoc);
 

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -429,6 +429,8 @@ public enum ErrorType {
 	 * <p>
 	 * all operators of alt <em>alt</em> of left-recursive rule must have same
 	 * associativity</p>
+	 *
+	 * @deprecated This warning is no longer applicable with the current syntax for specifying associativity.
 	 */
 	ALL_OPS_NEED_SAME_ASSOC(118, "all operators of alt <arg> of left-recursive rule must have same associativity", ErrorSeverity.WARNING),
 	/**

File: tool/test/org/antlr/v4/js/test/BaseTest.java
Patch:
@@ -131,6 +131,9 @@ public void setUp() throws Exception {
     		tmpdir = prop;
     	else
     		tmpdir = new File(System.getProperty("java.io.tmpdir"), getClass().getSimpleName()+"-"+System.currentTimeMillis()).getAbsolutePath(); 
+    	File dir = new File(tmpdir);
+    	if(dir.exists())
+    		this.eraseFiles(dir);
     }
 
     protected org.antlr.v4.Tool newTool(String[] args) {

File: tool/test/org/antlr/v4/js/test/TestLexerActions.java
Patch:
@@ -48,16 +48,16 @@ public class TestLexerActions extends BaseTest {
 			"\n" +
 			"@lexer::members\n" +
 			"{\n" +
-			"this.getRecordedText = function() {\n" +
+			"L.prototype.getRecordedText = function() {\n" +
 			"    return this._input.getText (this.start_index, this.stop_index);\n" +
 			"}\n" +
 			"\n" +
-			"this.start = function() {\n" +
+			"L.prototype.start = function() {\n" +
 			"    this.start_index = this._input.index;\n" +
 			"    console.log(\"Start:\" + this.start_index);\n" +
 			"}\n" +
 			"\n" +
-			"this.stop = function() {\n" +
+			"L.prototype.stop = function() {\n" +
 			"    this.stop_index = this._input.index;\n" +
 			"    console.log(\"Stop:\" + this.stop_index);\n" +
 			"}\n" +

File: tool/src/org/antlr/v4/codegen/model/decl/AttributeDecl.java
Patch:
@@ -36,8 +36,10 @@
 /** */
 public class AttributeDecl extends Decl {
 	public String type;
+	public String initValue;
 	public AttributeDecl(OutputModelFactory factory, Attribute a) {
 		super(factory, a.name, a.decl);
 		this.type = a.type;
+		this.initValue = a.initValue;
 	}
 }

File: tool/src/org/antlr/v4/codegen/model/decl/AttributeDecl.java
Patch:
@@ -36,8 +36,10 @@
 /** */
 public class AttributeDecl extends Decl {
 	public String type;
+	public String initValue;
 	public AttributeDecl(OutputModelFactory factory, Attribute a) {
 		super(factory, a.name, a.decl);
 		this.type = a.type;
+		this.initValue = a.initValue;
 	}
 }

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -557,7 +557,7 @@ public Handle plus(@NotNull GrammarAST plusAST, @NotNull Handle blk) {
 		blkStart.loopBackState = loop;
 		end.loopBackState = loop;
 
-		plusAST.atnState = blkStart;
+		plusAST.atnState = loop;
 		epsilon(blkEnd, loop);		// blk can see loop back
 
 		BlockAST blkAST = (BlockAST)plusAST.getChild(0);

File: tool/src/org/antlr/v4/codegen/ParserFactory.java
Patch:
@@ -63,7 +63,7 @@
 import org.antlr.v4.codegen.model.decl.TokenListDecl;
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.runtime.atn.DecisionState;
-import org.antlr.v4.runtime.atn.PlusBlockStartState;
+import org.antlr.v4.runtime.atn.PlusLoopbackState;
 import org.antlr.v4.runtime.atn.StarLoopEntryState;
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.tool.Alternative;
@@ -246,7 +246,7 @@ public Choice getEBNFBlock(GrammarAST ebnfRoot, List<CodeBlockForAlt> alts) {
 		if (!g.tool.force_atn) {
 			int decision;
 			if ( ebnfRoot.getType()==ANTLRParser.POSITIVE_CLOSURE ) {
-				decision = ((PlusBlockStartState)ebnfRoot.atnState).loopBackState.decision;
+				decision = ((PlusLoopbackState)ebnfRoot.atnState).decision;
 			}
 			else if ( ebnfRoot.getType()==ANTLRParser.CLOSURE ) {
 				decision = ((StarLoopEntryState)ebnfRoot.atnState).decision;

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.tool;
 
-import org.antlr.runtime.tree.Tree;
 import org.antlr.v4.Tool;
 import org.antlr.v4.analysis.LeftRecursiveRuleTransformer;
 import org.antlr.v4.misc.CharSupport;
@@ -1063,6 +1062,8 @@ public Set<String> getStringLiterals() {
 			public void stringRef(TerminalAST ref) {
 				strings.add(ref.getText());
 			}
+			@Override
+			public ErrorManager getErrorManager() { return tool.errMgr; }
 		};
 		collector.visitGrammar(ast);
 		return strings;

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.tool;
 
-import org.antlr.runtime.tree.Tree;
 import org.antlr.v4.Tool;
 import org.antlr.v4.analysis.LeftRecursiveRuleTransformer;
 import org.antlr.v4.misc.CharSupport;
@@ -1063,6 +1062,8 @@ public Set<String> getStringLiterals() {
 			public void stringRef(TerminalAST ref) {
 				strings.add(ref.getText());
 			}
+			@Override
+			public ErrorManager getErrorManager() { return tool.errMgr; }
 		};
 		collector.visitGrammar(ast);
 		return strings;

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -461,7 +461,7 @@ protected STGroup loadTemplates() {
 			result = new STGroupFile(groupFileName);
 		}
 		catch (IllegalArgumentException iae) {
-			gen.tool.errMgr.toolError(ErrorType.CANNOT_CREATE_TARGET_GENERATOR,
+			gen.tool.errMgr.toolError(ErrorType.MISSING_CODE_GEN_TEMPLATES,
 						 iae,
 						 language);
 		}

File: tool/src/org/antlr/v4/codegen/Python2Target.java
Patch:
@@ -38,7 +38,7 @@
  *
  * @author Eric Vergnaud
  */
-public class Python2Target extends AbstractPython3Target {
+public class Python2Target extends AbstractPythonTarget {
 
 	protected static final String[] python2Keywords = {
 		"abs", "all", "any", "apply", "as",

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -131,7 +131,7 @@ else if ( a.equals(ASSOC.left.toString()) ) {
 					assoc = ASSOC.left;
 				}
 				else {
-					tool.errMgr.toolError(ErrorType.ILLEGAL_OPTION_VALUE, t.getOptionAST("assoc").getToken(), "assoc", assoc);
+					tool.errMgr.grammarError(ErrorType.ILLEGAL_OPTION_VALUE, t.g.fileName, t.getOptionAST("assoc").getToken(), "assoc", assoc);
 				}
 			}
 		}

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -218,9 +218,9 @@ public RuleAST parseArtificialRule(final Grammar g, String ruleText) {
 		}
 		catch (Exception e) {
 			tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,
+								  e,
 								  ruleStart,
-								  "error parsing rule created during left-recursion detection: "+ruleText,
-								  e);
+								  "error parsing rule created during left-recursion detection: "+ruleText);
 		}
 		return null;
 	}

File: tool/test/org/antlr/v4/test/TestToolSyntaxErrors.java
Patch:
@@ -538,7 +538,7 @@ public class TestToolSyntaxErrors extends BaseTest {
 			"start : 'T' EOF;\n" +
 			"Something : 'something' -> channel(CUSTOM);";
 		String expected =
-			"error(" + ErrorType.CANNOT_CREATE_TARGET_GENERATOR.code + "):  ANTLR cannot generate 'Foo' code as of version " + Tool.VERSION + "\n";
+			"error(" + ErrorType.CANNOT_CREATE_TARGET_GENERATOR.code + "):  ANTLR cannot generate Foo code as of version " + Tool.VERSION + "\n";
 		String[] pair = new String[] {
 			grammar,
 			expected
@@ -558,7 +558,7 @@ public class TestToolSyntaxErrors extends BaseTest {
 			"options { language=Foo; }\n" +
 			"start : 'T' EOF;\n";
 		String expected =
-			"error(" + ErrorType.CANNOT_CREATE_TARGET_GENERATOR.code + "):  ANTLR cannot generate 'Foo' code as of version " + Tool.VERSION + "\n";
+			"error(" + ErrorType.CANNOT_CREATE_TARGET_GENERATOR.code + "):  ANTLR cannot generate Foo code as of version " + Tool.VERSION + "\n";
 
 		String[] pair = new String[] {
 			grammar,

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -131,7 +131,7 @@ else if ( a.equals(ASSOC.left.toString()) ) {
 					assoc = ASSOC.left;
 				}
 				else {
-					tool.errMgr.toolError(ErrorType.ILLEGAL_OPTION_VALUE, "assoc", assoc);
+					tool.errMgr.toolError(ErrorType.ILLEGAL_OPTION_VALUE, t.getOptionAST("assoc").getToken(), "assoc", assoc);
 				}
 			}
 		}

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -306,7 +306,7 @@ public Handle ruleRef(@NotNull GrammarAST node) {
 	public Handle _ruleRef(@NotNull GrammarAST node) {
 		Rule r = g.getRule(node.getText());
 		if ( r==null ) {
-			g.tool.errMgr.toolError(ErrorType.INTERNAL_ERROR, "Rule "+node.getText()+" undefined");
+			g.tool.errMgr.grammarError(ErrorType.INTERNAL_ERROR, g.fileName, node.getToken(), "Rule "+node.getText()+" undefined");
 			return null;
 		}
 		RuleStartState start = atn.ruleToStartState[r.index];

File: tool/src/org/antlr/v4/codegen/model/RuleFunction.java
Patch:
@@ -235,7 +235,8 @@ protected FrequencySet<String> getElementFrequenciesForAlt(AltAST ast) {
 			}
 
 			return visitor.frequencies.peek();
-		} catch (RecognitionException ex) {
+		}
+		catch (RecognitionException ex) {
 			factory.getGrammar().tool.errMgr.toolError(ErrorType.INTERNAL_ERROR, ex);
 			return new FrequencySet<String>();
 		}

File: tool/src/org/antlr/v4/semantics/RuleCollector.java
Patch:
@@ -81,20 +81,20 @@ public void discoverRule(RuleAST rule, GrammarAST ID,
 		rules.put(r.name, r);
 
 		if ( arg!=null ) {
-			r.args = ScopeParser.parseTypedArgList(arg, arg.getText(), g.tool.errMgr);
+			r.args = ScopeParser.parseTypedArgList(arg, arg.getText(), g);
 			r.args.type = AttributeDict.DictType.ARG;
 			r.args.ast = arg;
 			arg.resolver = r.alt[currentOuterAltNumber];
 		}
 
 		if ( returns!=null ) {
-			r.retvals = ScopeParser.parseTypedArgList(returns, returns.getText(), g.tool.errMgr);
+			r.retvals = ScopeParser.parseTypedArgList(returns, returns.getText(), g);
 			r.retvals.type = AttributeDict.DictType.RET;
 			r.retvals.ast = returns;
 		}
 
 		if ( locals!=null ) {
-			r.locals = ScopeParser.parseTypedArgList(locals, locals.getText(), g.tool.errMgr);
+			r.locals = ScopeParser.parseTypedArgList(locals, locals.getText(), g);
 			r.locals.type = AttributeDict.DictType.LOCAL;
 			r.locals.ast = locals;
 		}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -147,7 +147,7 @@ public enum ErrorType {
 	 * ANTLR cannot generate '<em>language</em>' code as of version
 	 * <em>version</em></p>
 	 */
-	CANNOT_CREATE_TARGET_GENERATOR(31, "ANTLR cannot generate '<arg>' code as of version "+ Tool.VERSION, ErrorSeverity.ERROR_ONE_OFF),
+	CANNOT_CREATE_TARGET_GENERATOR(31, "ANTLR cannot generate <arg> code as of version "+ Tool.VERSION, ErrorSeverity.ERROR),
 	/**
 	 * Compiler Error 32.
 	 *

File: tool/test/org/antlr/v4/test/TestLeftRecursion.java
Patch:
@@ -491,7 +491,7 @@ public void testAmbigLR() throws Exception {
 			"ID : 'a'..'z'+ ;\n" +
 			"WS : (' '|'\\n') -> skip ;\n";
 		String expected =
-			"error(" + ErrorType.NO_NON_LR_ALTS.code + "): T.g4:3:0: left recursive rule 'a' must contain an alternative which is not left recursive\n";
+			"error(" + ErrorType.NO_NON_LR_ALTS.code + "): T.g4:3:0: left recursive rule a must contain an alternative which is not left recursive\n";
 		testErrors(new String[] { grammar, expected }, false);
 	}
 
@@ -505,7 +505,7 @@ public void testAmbigLR() throws Exception {
 			"ID : 'a'..'z'+ ;\n" +
 			"WS : (' '|'\\n') -> skip ;\n";
 		String expected =
-			"error(" + ErrorType.EPSILON_LR_FOLLOW.code + "): T.g4:3:0: left recursive rule 'a' contains a left recursive alternative which can be followed by the empty string\n";
+			"error(" + ErrorType.EPSILON_LR_FOLLOW.code + "): T.g4:3:0: left recursive rule a contains a left recursive alternative which can be followed by the empty string\n";
 		testErrors(new String[] { grammar, expected }, false);
 	}
 

File: tool/test/org/antlr/v4/test/TestSets.java
Patch:
@@ -238,7 +238,7 @@ public TestSets() {
 			"a : A {System.out.println($A.text);} ;\n" +
 			"A : ~('a'|B) ;\n" +
 			"B : 'b' ;\n",
-			"error(" + ErrorType.UNSUPPORTED_REFERENCE_IN_LEXER_SET.code + "): T.g4:3:10: rule reference 'B' is not currently supported in a set\n"
+			"error(" + ErrorType.UNSUPPORTED_REFERENCE_IN_LEXER_SET.code + "): T.g4:3:10: rule reference B is not currently supported in a set\n"
 		};
 		super.testErrors(pair, true);
 	}

File: tool/src/org/antlr/v4/analysis/LeftRecursionDetector.java
Patch:
@@ -74,7 +74,9 @@ public void check() {
 		}
 		//System.out.println("cycles="+listOfRecursiveCycles);
 		if ( !listOfRecursiveCycles.isEmpty() ) {
-			g.tool.errMgr.leftRecursionCycles(g.fileName, listOfRecursiveCycles);
+			RuleStartState firstRuleStartState = atn.ruleToStartState[0];
+			Rule r = g.getRule(firstRuleStartState.ruleIndex);
+			g.tool.errMgr.leftRecursionCycles(g.fileName, r.ast.getToken(), listOfRecursiveCycles);
 		}
 	}
 

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -131,7 +131,7 @@ else if ( a.equals(ASSOC.left.toString()) ) {
 					assoc = ASSOC.left;
 				}
 				else {
-					tool.errMgr.toolError(ErrorType.ILLEGAL_OPTION_VALUE, "assoc", assoc);
+					tool.errMgr.toolError(ErrorType.ILLEGAL_OPTION_VALUE, t.getToken(), "assoc", assoc);
 				}
 			}
 		}

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -306,7 +306,7 @@ public Handle ruleRef(@NotNull GrammarAST node) {
 	public Handle _ruleRef(@NotNull GrammarAST node) {
 		Rule r = g.getRule(node.getText());
 		if ( r==null ) {
-			g.tool.errMgr.toolError(ErrorType.INTERNAL_ERROR, "Rule "+node.getText()+" undefined");
+			g.tool.errMgr.grammarError(ErrorType.INTERNAL_ERROR, g.fileName, node.getToken(), "Rule "+node.getText()+" undefined");
 			return null;
 		}
 		RuleStartState start = atn.ruleToStartState[r.index];

File: tool/src/org/antlr/v4/codegen/model/RuleFunction.java
Patch:
@@ -235,7 +235,8 @@ protected FrequencySet<String> getElementFrequenciesForAlt(AltAST ast) {
 			}
 
 			return visitor.frequencies.peek();
-		} catch (RecognitionException ex) {
+		}
+		catch (RecognitionException ex) {
 			factory.getGrammar().tool.errMgr.toolError(ErrorType.INTERNAL_ERROR, ex);
 			return new FrequencySet<String>();
 		}

File: tool/src/org/antlr/v4/semantics/RuleCollector.java
Patch:
@@ -81,20 +81,20 @@ public void discoverRule(RuleAST rule, GrammarAST ID,
 		rules.put(r.name, r);
 
 		if ( arg!=null ) {
-			r.args = ScopeParser.parseTypedArgList(arg, arg.getText(), g.tool.errMgr);
+			r.args = ScopeParser.parseTypedArgList(arg, arg.getText(), g);
 			r.args.type = AttributeDict.DictType.ARG;
 			r.args.ast = arg;
 			arg.resolver = r.alt[currentOuterAltNumber];
 		}
 
 		if ( returns!=null ) {
-			r.retvals = ScopeParser.parseTypedArgList(returns, returns.getText(), g.tool.errMgr);
+			r.retvals = ScopeParser.parseTypedArgList(returns, returns.getText(), g);
 			r.retvals.type = AttributeDict.DictType.RET;
 			r.retvals.ast = returns;
 		}
 
 		if ( locals!=null ) {
-			r.locals = ScopeParser.parseTypedArgList(locals, locals.getText(), g.tool.errMgr);
+			r.locals = ScopeParser.parseTypedArgList(locals, locals.getText(), g);
 			r.locals.type = AttributeDict.DictType.LOCAL;
 			r.locals.ast = locals;
 		}

File: tool/test/org/antlr/v4/test/TestLeftRecursion.java
Patch:
@@ -491,7 +491,7 @@ public void testAmbigLR() throws Exception {
 			"ID : 'a'..'z'+ ;\n" +
 			"WS : (' '|'\\n') -> skip ;\n";
 		String expected =
-			"error(" + ErrorType.NO_NON_LR_ALTS.code + "): T.g4:3:0: left recursive rule 'a' must contain an alternative which is not left recursive\n";
+			"error(" + ErrorType.NO_NON_LR_ALTS.code + "): T.g4:3:0: left recursive rule a must contain an alternative which is not left recursive\n";
 		testErrors(new String[] { grammar, expected }, false);
 	}
 
@@ -505,7 +505,7 @@ public void testAmbigLR() throws Exception {
 			"ID : 'a'..'z'+ ;\n" +
 			"WS : (' '|'\\n') -> skip ;\n";
 		String expected =
-			"error(" + ErrorType.EPSILON_LR_FOLLOW.code + "): T.g4:3:0: left recursive rule 'a' contains a left recursive alternative which can be followed by the empty string\n";
+			"error(" + ErrorType.EPSILON_LR_FOLLOW.code + "): T.g4:3:0: left recursive rule a contains a left recursive alternative which can be followed by the empty string\n";
 		testErrors(new String[] { grammar, expected }, false);
 	}
 

File: tool/test/org/antlr/v4/test/TestSets.java
Patch:
@@ -238,7 +238,7 @@ public TestSets() {
 			"a : A {System.out.println($A.text);} ;\n" +
 			"A : ~('a'|B) ;\n" +
 			"B : 'b' ;\n",
-			"error(" + ErrorType.UNSUPPORTED_REFERENCE_IN_LEXER_SET.code + "): T.g4:3:10: rule reference 'B' is not currently supported in a set\n"
+			"error(" + ErrorType.UNSUPPORTED_REFERENCE_IN_LEXER_SET.code + "): T.g4:3:10: rule reference B is not currently supported in a set\n"
 		};
 		super.testErrors(pair, true);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -892,6 +892,9 @@ public ParseInfo getParseInfo() {
 		return null;
 	}
 
+	/**
+	 * @since 4.3
+	 */
 	public void setProfile(boolean profile) {
 		ParserATNSimulator interp = getInterpreter();
 		if ( profile ) {

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -160,6 +160,8 @@ public ATNInterpreter getInterpreter() {
 
 	/** If profiling during the parse/lex, this will return DecisionInfo records
 	 *  for each decision in recognizer in a ParseInfo object.
+	 *
+	 * @since 4.3
 	 */
 	public ParseInfo getParseInfo() {
 		return null;

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -61,6 +61,8 @@
  * be removed by calling {@link #removeListener} for
  * {@link DefaultListener#INSTANCE} or {@link #clearListeners}. If required, it
  * may be re-registered by calling {@link #addListener}.</p>
+ *
+ * @since 4.3
  */
 public class RuntimeMetaData {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -199,6 +199,8 @@ public Set<ATNState> getStates() {
 	 * set.
 	 *
 	 * @return the set of represented alternatives in this configuration set
+	 *
+	 * @since 4.3
 	 */
 	@NotNull
 	public BitSet getAlts() {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSimulator.java
Patch:
@@ -108,6 +108,8 @@ public ATNSimulator(@NotNull ATN atn,
 	 *
 	 * @throws UnsupportedOperationException if the current instance does not
 	 * support clearing the DFA.
+	 *
+	 * @since 4.3
 	 */
 	public void clearDFA() {
 		throw new UnsupportedOperationException("This ATN simulator does not support clearing the DFA.");

File: runtime/Java/src/org/antlr/v4/runtime/atn/AmbiguityInfo.java
Patch:
@@ -60,6 +60,8 @@
  *
  * @see ParserATNSimulator#reportAmbiguity
  * @see ANTLRErrorListener#reportAmbiguity
+ *
+ * @since 4.3
  */
 public class AmbiguityInfo extends DecisionEventInfo {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/ContextSensitivityInfo.java
Patch:
@@ -49,6 +49,8 @@
  *
  * @see ParserATNSimulator#reportContextSensitivity
  * @see ANTLRErrorListener#reportContextSensitivity
+ *
+ * @since 4.3
  */
 public class ContextSensitivityInfo extends DecisionEventInfo {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionEventInfo.java
Patch:
@@ -37,6 +37,8 @@
 /**
  * This is the base class for gathering detailed information about prediction
  * events which occur during parsing.
+ *
+ * @since 4.3
  */
 public class DecisionEventInfo {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionInfo.java
Patch:
@@ -43,6 +43,8 @@
  * operations are started). For best results, gather and use aggregate
  * statistics from a large sample of inputs representing the inputs expected in
  * production before using the results to make changes in the grammar.</p>
+ *
+ * @since 4.3
  */
 public class DecisionInfo {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/ErrorInfo.java
Patch:
@@ -45,6 +45,8 @@
  *
  * @see Parser#notifyErrorListeners(Token, String, RecognitionException)
  * @see ANTLRErrorListener#syntaxError
+ *
+ * @since 4.3
  */
 public class ErrorInfo extends DecisionEventInfo {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/LookaheadEventInfo.java
Patch:
@@ -37,6 +37,8 @@
 /**
  * This class represents profiling event information for tracking the lookahead
  * depth required in order to make a prediction.
+ *
+ * @since 4.3
  */
 public class LookaheadEventInfo extends DecisionEventInfo {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParseInfo.java
Patch:
@@ -39,6 +39,8 @@
 /**
  * This class provides access to specific and aggregate statistics gathered
  * during profiling of a parser.
+ *
+ * @since 4.3
  */
 public class ParseInfo {
 	protected final ProfilingATNSimulator atnSimulator;

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredicateEvalInfo.java
Patch:
@@ -41,6 +41,8 @@
  * evaluations which occur during prediction.
  *
  * @see ParserATNSimulator#evalSemanticContext
+ *
+ * @since 4.3
  */
 public class PredicateEvalInfo extends DecisionEventInfo {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/atn/ProfilingATNSimulator.java
Patch:
@@ -40,6 +40,9 @@
 
 import java.util.BitSet;
 
+/**
+ * @since 4.3
+ */
 public class ProfilingATNSimulator extends ParserATNSimulator {
 	protected final DecisionInfo[] decisions;
 	protected int numDecisions;

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorListener.java
Patch:
@@ -88,7 +88,7 @@ public void syntaxError(@NotNull Recognizer<?, ?> recognizer,
 	 *
 	 * <p>Each full-context prediction which does not result in a syntax error
 	 * will call either {@link #reportContextSensitivity} or
-	 * {@link reportAmbiguity}.</p>
+	 * {@link #reportAmbiguity}.</p>
 	 *
 	 * <p>When {@code ambigAlts} is not null, it contains the set of potentially
 	 * viable alternatives identified by the prediction algorithm. When
@@ -166,7 +166,7 @@ void reportAttemptingFullContext(@NotNull Parser recognizer,
 	 *
 	 * <p>Each full-context prediction which does not result in a syntax error
 	 * will call either {@link #reportContextSensitivity} or
-	 * {@link reportAmbiguity}.</p>
+	 * {@link #reportAmbiguity}.</p>
 	 *
 	 * <p>For prediction implementations that only evaluate full-context
 	 * predictions when an SLL conflict is found (including the default

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -114,7 +114,7 @@ public static class VersionMismatchException extends RuntimeException {
 	public interface Listener {
 		/**
 		 * Report a version mismatch which was detected by
-		 * {@link #checkDetails}.
+		 * {@link #checkVersion}.
 		 *
 		 * <p>
 		 * Implementations of this method may, but are not required to, throw
@@ -147,7 +147,7 @@ void reportVersionMismatch(@NotNull VersionMismatchException ex)
 	 */
 	public static class DefaultListener implements Listener {
 		/**
-		 * A default instance of {@link ConsoleListener} which is automatically
+		 * A default instance of {@link DefaultListener} which is automatically
 		 * registered to receive version mismatch events.
 		 */
 		public static final DefaultListener INSTANCE = new DefaultListener();

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionInfo.java
Patch:
@@ -91,7 +91,7 @@ public class DecisionInfo {
 	public long SLL_MaxLook;
 	/**
 	 * Gets the {@link LookaheadEventInfo} associated with the event where the
-	 * {@link #sllMaxLook} value was set.
+	 * {@link #SLL_MaxLook} value was set.
 	 */
 	public LookaheadEventInfo SLL_MaxLookEvent;
 

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntSet.java
Patch:
@@ -30,6 +30,8 @@
 package org.antlr.v4.runtime.misc;
 
 
+import org.antlr.v4.runtime.Token;
+
 import java.util.List;
 
 /**
@@ -121,7 +123,7 @@ public interface IntSet {
 	 * <li>{@code x.complement(y)}</li>
 	 * </ul>
 	 *
-	 * @param elements The set to compare with the current set. A {@code null}
+	 * @param a The set to compare with the current set. A {@code null}
 	 * argument is treated as though it were an empty set.
 	 * @return A new {@link IntSet} instance containing the elements present in
 	 * {@code elements} but not present in the current set. The value

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java
Patch:
@@ -208,7 +208,7 @@ public IntervalSet complement(int minElement, int maxElement) {
         return this.complement(IntervalSet.of(minElement,maxElement));
     }
 
-    /** {@inheritDoc */
+    /** {@inheritDoc} */
     @Override
     public IntervalSet complement(IntSet vocabulary) {
 		if ( vocabulary==null || vocabulary.isNil() ) {

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorListener.java
Patch:
@@ -88,7 +88,7 @@ public void syntaxError(@NotNull Recognizer<?, ?> recognizer,
 	 *
 	 * <p>Each full-context prediction which does not result in a syntax error
 	 * will call either {@link #reportContextSensitivity} or
-	 * {@link reportAmbiguity}.</p>
+	 * {@link #reportAmbiguity}.</p>
 	 *
 	 * <p>When {@code ambigAlts} is not null, it contains the set of potentially
 	 * viable alternatives identified by the prediction algorithm. When
@@ -166,7 +166,7 @@ void reportAttemptingFullContext(@NotNull Parser recognizer,
 	 *
 	 * <p>Each full-context prediction which does not result in a syntax error
 	 * will call either {@link #reportContextSensitivity} or
-	 * {@link reportAmbiguity}.</p>
+	 * {@link #reportAmbiguity}.</p>
 	 *
 	 * <p>For prediction implementations that only evaluate full-context
 	 * predictions when an SLL conflict is found (including the default

File: runtime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java
Patch:
@@ -114,7 +114,7 @@ public static class VersionMismatchException extends RuntimeException {
 	public interface Listener {
 		/**
 		 * Report a version mismatch which was detected by
-		 * {@link #checkDetails}.
+		 * {@link #checkVersion}.
 		 *
 		 * <p>
 		 * Implementations of this method may, but are not required to, throw
@@ -147,7 +147,7 @@ void reportVersionMismatch(@NotNull VersionMismatchException ex)
 	 */
 	public static class DefaultListener implements Listener {
 		/**
-		 * A default instance of {@link ConsoleListener} which is automatically
+		 * A default instance of {@link DefaultListener} which is automatically
 		 * registered to receive version mismatch events.
 		 */
 		public static final DefaultListener INSTANCE = new DefaultListener();

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionInfo.java
Patch:
@@ -91,7 +91,7 @@ public class DecisionInfo {
 	public long SLL_MaxLook;
 	/**
 	 * Gets the {@link LookaheadEventInfo} associated with the event where the
-	 * {@link #sllMaxLook} value was set.
+	 * {@link #SLL_MaxLook} value was set.
 	 */
 	public LookaheadEventInfo SLL_MaxLookEvent;
 

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntSet.java
Patch:
@@ -30,6 +30,8 @@
 package org.antlr.v4.runtime.misc;
 
 
+import org.antlr.v4.runtime.Token;
+
 import java.util.List;
 
 /**
@@ -121,7 +123,7 @@ public interface IntSet {
 	 * <li>{@code x.complement(y)}</li>
 	 * </ul>
 	 *
-	 * @param elements The set to compare with the current set. A {@code null}
+	 * @param a The set to compare with the current set. A {@code null}
 	 * argument is treated as though it were an empty set.
 	 * @return A new {@link IntSet} instance containing the elements present in
 	 * {@code elements} but not present in the current set. The value

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java
Patch:
@@ -208,7 +208,7 @@ public IntervalSet complement(int minElement, int maxElement) {
         return this.complement(IntervalSet.of(minElement,maxElement));
     }
 
-    /** {@inheritDoc */
+    /** {@inheritDoc} */
     @Override
     public IntervalSet complement(IntSet vocabulary) {
 		if ( vocabulary==null || vocabulary.isNil() ) {

File: tool/test/org/antlr/v4/test/TestAttributeChecks.java
Patch:
@@ -78,7 +78,7 @@ public class TestAttributeChecks extends BaseTest {
 		"$x = $y",		"",
 		"$y = $x",		"",
 		"$y.b = 3;",	"",
-		"$a.x = $a.y",	"",
+		"$ctx.x = $ctx.y",	"",
 		"$lab.e",		"",
 		"$lab.text",	"",
 		"$b.e",			"",

File: tool/test/org/antlr/v4/test/TestAttributeChecks.java
Patch:
@@ -78,7 +78,7 @@ public class TestAttributeChecks extends BaseTest {
 		"$x = $y",		"",
 		"$y = $x",		"",
 		"$y.b = 3;",	"",
-		"$a.x = $a.y",	"",
+		"$ctx.x = $ctx.y",	"",
 		"$lab.e",		"",
 		"$lab.text",	"",
 		"$b.e",			"",

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -769,8 +769,8 @@ public static boolean blockHasWildcardAlt(@NotNull GrammarAST block) {
 		for (Object alt : block.getChildren()) {
 			if ( !(alt instanceof AltAST) ) continue;
 			AltAST altAST = (AltAST)alt;
-			if ( altAST.getChildCount()==1 ) {
-				Tree e = altAST.getChild(0);
+			if ( altAST.getChildCount()==1 || (altAST.getChildCount() == 2 && altAST.getChild(0).getType() == ANTLRParser.ELEMENT_OPTIONS) ) {
+				Tree e = altAST.getChild(altAST.getChildCount() - 1);
 				if ( e.getType()==ANTLRParser.WILDCARD ) {
 					return true;
 				}

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -769,8 +769,8 @@ public static boolean blockHasWildcardAlt(@NotNull GrammarAST block) {
 		for (Object alt : block.getChildren()) {
 			if ( !(alt instanceof AltAST) ) continue;
 			AltAST altAST = (AltAST)alt;
-			if ( altAST.getChildCount()==1 ) {
-				Tree e = altAST.getChild(0);
+			if ( altAST.getChildCount()==1 || (altAST.getChildCount() == 2 && altAST.getChild(0).getType() == ANTLRParser.ELEMENT_OPTIONS) ) {
+				Tree e = altAST.getChild(altAST.getChildCount() - 1);
 				if ( e.getType()==ANTLRParser.WILDCARD ) {
 					return true;
 				}

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -604,7 +604,7 @@ public Grammar loadImportedGrammar(Grammar g, String name) throws IOException {
 			return null;
 		}
 
-		ANTLRFileStream in = new ANTLRFileStream(importedFile.getAbsolutePath());
+		ANTLRFileStream in = new ANTLRFileStream(importedFile.getAbsolutePath(), grammarEncoding);
 		GrammarRootAST root = parse(g.fileName, in);
 		Grammar imported = createGrammar(root);
 		imported.fileName = importedFile.getAbsolutePath();

File: tool/src/org/antlr/v4/tool/BuildDependencyGenerator.java
Patch:
@@ -31,7 +31,6 @@
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.misc.Utils;
 import org.antlr.v4.parse.ANTLRParser;
 import org.stringtemplate.v4.ST;
 import org.stringtemplate.v4.STGroup;
@@ -252,7 +251,7 @@ public ST getDependencies() {
     public void loadDependencyTemplates() {
         if (templates != null) return;
         String fileName = "org/antlr/v4/tool/templates/depend.stg";
-        templates = new STGroupFile(fileName);
+        templates = new STGroupFile(fileName, "UTF-8");
     }
 
     public CodeGenerator getGenerator() {

File: tool/src/org/antlr/v4/tool/DOTGenerator.java
Patch:
@@ -284,7 +284,7 @@ else if ( edge instanceof SetTransition ) {
 					SetTransition set = (SetTransition)edge;
 					String label = set.label().toString();
 					if ( isLexer ) label = set.label().toString(true);
-					else if ( grammar!=null ) label = set.label().toString(grammar.getTokenNames());
+					else if ( grammar!=null ) label = set.label().toString(grammar.getTokenDisplayNames());
 					if ( edge instanceof NotSetTransition ) label = "~"+label;
 					edgeST.add("label", getEdgeLabel(label));
 				}
@@ -293,7 +293,7 @@ else if ( edge instanceof RangeTransition ) {
 					RangeTransition range = (RangeTransition)edge;
 					String label = range.label().toString();
 					if ( isLexer ) label = range.toString();
-					else if ( grammar!=null ) label = range.label().toString(grammar.getTokenNames());
+					else if ( grammar!=null ) label = range.label().toString(grammar.getTokenDisplayNames());
 					edgeST.add("label", getEdgeLabel(label));
 				}
 				else {

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -1121,7 +1121,7 @@ public LexerInterpreter createLexerInterpreter(CharStream input) {
 
 		char[] serializedAtn = ATNSerializer.getSerializedAsChars(atn);
 		ATN deserialized = new ATNDeserializer().deserialize(serializedAtn);
-		return new LexerInterpreter(fileName, Arrays.asList(getTokenNames()), Arrays.asList(getRuleNames()), ((LexerGrammar)this).modes.keySet(), deserialized, input);
+		return new LexerInterpreter(fileName, Arrays.asList(getTokenDisplayNames()), Arrays.asList(getRuleNames()), ((LexerGrammar)this).modes.keySet(), deserialized, input);
 	}
 
 	public ParserInterpreter createParserInterpreter(TokenStream tokenStream) {
@@ -1131,6 +1131,6 @@ public ParserInterpreter createParserInterpreter(TokenStream tokenStream) {
 
 		char[] serializedAtn = ATNSerializer.getSerializedAsChars(atn);
 		ATN deserialized = new ATNDeserializer().deserialize(serializedAtn);
-		return new ParserInterpreter(fileName, Arrays.asList(getTokenNames()), Arrays.asList(getRuleNames()), deserialized, tokenStream);
+		return new ParserInterpreter(fileName, Arrays.asList(getTokenDisplayNames()), Arrays.asList(getRuleNames()), deserialized, tokenStream);
 	}
 }

File: tool/src/org/antlr/v4/tool/DOTGenerator.java
Patch:
@@ -284,7 +284,7 @@ else if ( edge instanceof SetTransition ) {
 					SetTransition set = (SetTransition)edge;
 					String label = set.label().toString();
 					if ( isLexer ) label = set.label().toString(true);
-					else if ( grammar!=null ) label = set.label().toString(grammar.getTokenNames());
+					else if ( grammar!=null ) label = set.label().toString(grammar.getTokenDisplayNames());
 					if ( edge instanceof NotSetTransition ) label = "~"+label;
 					edgeST.add("label", getEdgeLabel(label));
 				}
@@ -293,7 +293,7 @@ else if ( edge instanceof RangeTransition ) {
 					RangeTransition range = (RangeTransition)edge;
 					String label = range.label().toString();
 					if ( isLexer ) label = range.toString();
-					else if ( grammar!=null ) label = range.label().toString(grammar.getTokenNames());
+					else if ( grammar!=null ) label = range.label().toString(grammar.getTokenDisplayNames());
 					edgeST.add("label", getEdgeLabel(label));
 				}
 				else {

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -1121,7 +1121,7 @@ public LexerInterpreter createLexerInterpreter(CharStream input) {
 
 		char[] serializedAtn = ATNSerializer.getSerializedAsChars(atn);
 		ATN deserialized = new ATNDeserializer().deserialize(serializedAtn);
-		return new LexerInterpreter(fileName, Arrays.asList(getTokenNames()), Arrays.asList(getRuleNames()), ((LexerGrammar)this).modes.keySet(), deserialized, input);
+		return new LexerInterpreter(fileName, Arrays.asList(getTokenDisplayNames()), Arrays.asList(getRuleNames()), ((LexerGrammar)this).modes.keySet(), deserialized, input);
 	}
 
 	public ParserInterpreter createParserInterpreter(TokenStream tokenStream) {
@@ -1131,6 +1131,6 @@ public ParserInterpreter createParserInterpreter(TokenStream tokenStream) {
 
 		char[] serializedAtn = ATNSerializer.getSerializedAsChars(atn);
 		ATN deserialized = new ATNDeserializer().deserialize(serializedAtn);
-		return new ParserInterpreter(fileName, Arrays.asList(getTokenNames()), Arrays.asList(getRuleNames()), deserialized, tokenStream);
+		return new ParserInterpreter(fileName, Arrays.asList(getTokenDisplayNames()), Arrays.asList(getRuleNames()), deserialized, tokenStream);
 	}
 }

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -604,7 +604,7 @@ public Grammar loadImportedGrammar(Grammar g, String name) throws IOException {
 			return null;
 		}
 
-		ANTLRFileStream in = new ANTLRFileStream(importedFile.getAbsolutePath());
+		ANTLRFileStream in = new ANTLRFileStream(importedFile.getAbsolutePath(), grammarEncoding);
 		GrammarRootAST root = parse(g.fileName, in);
 		Grammar imported = createGrammar(root);
 		imported.fileName = importedFile.getAbsolutePath();

File: tool/src/org/antlr/v4/tool/BuildDependencyGenerator.java
Patch:
@@ -31,7 +31,6 @@
 
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.misc.Utils;
 import org.antlr.v4.parse.ANTLRParser;
 import org.stringtemplate.v4.ST;
 import org.stringtemplate.v4.STGroup;
@@ -252,7 +251,7 @@ public ST getDependencies() {
     public void loadDependencyTemplates() {
         if (templates != null) return;
         String fileName = "org/antlr/v4/tool/templates/depend.stg";
-        templates = new STGroupFile(fileName);
+        templates = new STGroupFile(fileName, "UTF-8");
     }
 
     public CodeGenerator getGenerator() {

File: tool/src/org/antlr/v4/automata/TailEpsilonRemover.java
Patch:
@@ -32,8 +32,8 @@
 
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNState;
-import org.antlr.v4.runtime.atn.ActionTransition;
 import org.antlr.v4.runtime.atn.BlockEndState;
+import org.antlr.v4.runtime.atn.EpsilonTransition;
 import org.antlr.v4.runtime.atn.PlusLoopbackState;
 import org.antlr.v4.runtime.atn.RuleTransition;
 import org.antlr.v4.runtime.atn.StarLoopbackState;
@@ -64,7 +64,7 @@ public void visitState(@NotNull ATNState p) {
 				// if edge out of q is single epsilon to block end
 				// we can strip epsilon p-x->q-eps->r
 				Transition trans = q.transition(0);
-				if (q.getNumberOfTransitions() == 1 && trans.isEpsilon() && !(trans instanceof ActionTransition)) {
+				if (q.getNumberOfTransitions() == 1 && trans instanceof EpsilonTransition) {
 					ATNState r = trans.target;
 					if (r instanceof BlockEndState || r instanceof PlusLoopbackState || r instanceof StarLoopbackState) {
 						// skip over q

File: tool/src/org/antlr/v4/automata/TailEpsilonRemover.java
Patch:
@@ -32,8 +32,8 @@
 
 import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNState;
-import org.antlr.v4.runtime.atn.ActionTransition;
 import org.antlr.v4.runtime.atn.BlockEndState;
+import org.antlr.v4.runtime.atn.EpsilonTransition;
 import org.antlr.v4.runtime.atn.PlusLoopbackState;
 import org.antlr.v4.runtime.atn.RuleTransition;
 import org.antlr.v4.runtime.atn.StarLoopbackState;
@@ -64,7 +64,7 @@ public void visitState(@NotNull ATNState p) {
 				// if edge out of q is single epsilon to block end
 				// we can strip epsilon p-x->q-eps->r
 				Transition trans = q.transition(0);
-				if (q.getNumberOfTransitions() == 1 && trans.isEpsilon() && !(trans instanceof ActionTransition)) {
+				if (q.getNumberOfTransitions() == 1 && trans instanceof EpsilonTransition) {
 					ATNState r = trans.target;
 					if (r instanceof BlockEndState || r instanceof PlusLoopbackState || r instanceof StarLoopbackState) {
 						// skip over q

File: tool/src/org/antlr/v4/codegen/ActionTranslator.java
Patch:
@@ -175,7 +175,6 @@ public void attr(String expr, Token x) {
 				case RET: chunks.add(new RetValueRef(rf.ruleCtx, x.getText())); break;
 				case LOCAL: chunks.add(new LocalRef(nodeContext,x.getText())); break;
 				case PREDEFINED_RULE: chunks.add(getRulePropertyRef(x));	break;
-				default: // avoid warning
 			}
 		}
 		if ( node.resolver.resolvesToToken(x.getText(), node) ) {
@@ -230,8 +229,6 @@ public void qualifiedAttr(String expr, Token x, Token y) {
 			case TOKEN:
 				chunks.add(getTokenPropertyRef(x, y));
 				break;
-			default:
-				// avoid warning
 		}
 	}
 

File: tool/src/org/antlr/v4/codegen/model/InvokeRule.java
Patch:
@@ -47,7 +47,6 @@
 import java.util.List;
 
 /** */
-@SuppressWarnings("unused")
 public class InvokeRule extends RuleElement implements LabeledOp {
 	public String name;
 	public OrderedHashSet<Decl> labels = new OrderedHashSet<Decl>(); // TODO: should need just 1

File: tool/src/org/antlr/v4/codegen/model/LL1StarBlockSingleAlt.java
Patch:
@@ -38,7 +38,6 @@
 import java.util.List;
 
 /** */
-@SuppressWarnings("unused")
 public class LL1StarBlockSingleAlt extends LL1Loop {
 	public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST starRoot, List<CodeBlockForAlt> alts) {
 		super(factory, starRoot, alts);

File: tool/test/org/antlr/v4/test/TestCompositeGrammars.java
Patch:
@@ -116,7 +116,7 @@ public class TestCompositeGrammars extends BaseTest {
 	@Test public void testDelegatorAccessesDelegateMembers() throws Exception {
 		String slave =
 			"parser grammar S;\n" +
-			"@members {\n" +
+			"@parser::members {\n" +
 			"  public void foo() {System.out.println(\"foo\");}\n" +
 			"}\n" +
 			"a : B ;\n";

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorListener.java
Patch:
@@ -134,7 +134,9 @@ void reportAmbiguity(@NotNull Parser recognizer,
 	 * @param stopIndex the input index where the SLL conflict occurred
 	 * @param conflictingAlts The specific conflicting alternatives. If this is
 	 * {@code null}, the conflicting alternatives are all alternatives
-	 * represented in {@code configs}.
+	 * represented in {@code configs}. At the moment, conflictingAlts is non-null
+	 * (for the reference implementation, but Sam's optimized version can see this
+	 * as null).
 	 * @param configs the ATN configuration set where the SLL conflict was
 	 * detected
 	 */

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -504,7 +504,7 @@ protected int execATN(@NotNull DFA dfa, @NotNull DFAState s0,
 
 			if ( D.requiresFullContext && mode != PredictionMode.SLL ) {
 				// IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
-				BitSet conflictingAlts = null;
+				BitSet conflictingAlts = D.configs.conflictingAlts;
 				if ( D.predicates!=null ) {
 					if ( debug ) System.out.println("DFA state has preds in DFA sim LL failover");
 					int conflictIndex = input.index();

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -91,8 +91,10 @@ public String getLanguage() {
     /** ANTLR tool should check output templates / target are compatible with tool code generation.
      *  For now, a simple string match used on x.y of x.y.z scheme. We use a method to avoid mismatches
      *  between a template called VERSION. This value is checked against Tool.VERSION during load of templates.
+     *
+     *  This additional method forces all targets 4.3 and beyond to add this method.
      */
-    public String getVersion() { return "4.3"; }
+    public abstract String getVersion();
 
     public STGroup getTemplates() {
         if (templates == null) {

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -90,7 +90,7 @@ public class Tool {
 	public static final String VERSION;
 	static {
 		String version = Tool.class.getPackage().getImplementationVersion();
-		VERSION = version != null ? version : "4.2";
+		VERSION = version != null ? version : "4.3";
 	}
 
 	public static final String GRAMMAR_EXTENSION = ".g4";

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -92,15 +92,15 @@ public String getLanguage() {
      *  For now, a simple string match used on x.y of x.y.z scheme. We use a method to avoid mismatches
      *  between a template called VERSION. This value is checked against Tool.VERSION during load of templates.
      */
-    public abstract String getVersion();
+    public String getVersion() { return "4.3"; }
 
     public STGroup getTemplates() {
         if (templates == null) {
-            templates = loadTemplates();
             String version = getVersion();
             if (version == null || !version.equals(Tool.VERSION)) {
                 gen.tool.errMgr.toolError(ErrorType.INCOMPATIBLE_TOOL_AND_TEMPLATES, version, Tool.VERSION, language);
             }
+            templates = loadTemplates();
         }
 
 		return templates;

File: tool/src/org/antlr/v4/codegen/model/decl/StructDecl.java
Patch:
@@ -52,7 +52,7 @@ public class StructDecl extends Decl {
 	public boolean provideCopyFrom;
 	@ModelElement public OrderedHashSet<Decl> attrs = new OrderedHashSet<Decl>();
 	@ModelElement public OrderedHashSet<Decl> getters = new OrderedHashSet<Decl>();
-	@ModelElement public Collection<Attribute> ctorAttrs;
+	@ModelElement public Collection<AttributeDecl> ctorAttrs;
 	@ModelElement public List<? super DispatchMethod> dispatchMethods;
 	@ModelElement public List<OutputModelObject> interfaces;
 	@ModelElement public List<OutputModelObject> extensionMembers;
@@ -85,7 +85,7 @@ public void addDecl(Decl d) {
 	}
 
 	public void addDecl(Attribute a) {
-		addDecl(new AttributeDecl(factory, a.name, a.decl));
+		addDecl(new AttributeDecl(factory, a));
 	}
 
 	public void addDecls(Collection<Attribute> attrList) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionMode.java
Patch:
@@ -556,7 +556,7 @@ public static BitSet getAlts(@NotNull Collection<BitSet> altsets) {
 	 * </pre>
 	 */
 	@NotNull
-	public static Collection<BitSet> getConflictingAltSubsets(ATNConfigSet configs) {
+	public static Collection<BitSet> getConflictingAltSubsets(@NotNull ATNConfigSet configs) {
 		AltAndContextMap configToAlts = new AltAndContextMap();
 		for (ATNConfig c : configs) {
 			BitSet alts = configToAlts.get(c);

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionMode.java
Patch:
@@ -556,7 +556,7 @@ public static BitSet getAlts(@NotNull Collection<BitSet> altsets) {
 	 * </pre>
 	 */
 	@NotNull
-	public static Collection<BitSet> getConflictingAltSubsets(ATNConfigSet configs) {
+	public static Collection<BitSet> getConflictingAltSubsets(@NotNull ATNConfigSet configs) {
 		AltAndContextMap configToAlts = new AltAndContextMap();
 		for (ATNConfig c : configs) {
 			BitSet alts = configToAlts.get(c);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1417,7 +1417,7 @@ protected void closure_(@NotNull ATNConfig config,
 			if ( c!=null ) {
 				if (!t.isEpsilon() && !closureBusy.add(c)) {
 					// avoid infinite recursion for EOF* and EOF+
-					//continue;
+					continue;
 				}
 
 				int newDepth = depth;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1269,7 +1269,7 @@ protected Pair<ATNConfigSet,ATNConfigSet> splitAccordingToSemanticValidity(
 				succeeded.add(c);
 			}
 		}
-		return new Pair(succeeded,failed);
+		return new Pair<ATNConfigSet, ATNConfigSet>(succeeded,failed);
 	}
 
 	/** Look through a list of predicate/alt pairs, returning alts for the

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -152,6 +152,9 @@ public boolean translateLeftRecursiveRule(GrammarRootAST ast,
 		RuleCollector ruleCollector = new RuleCollector(g);
 		ruleCollector.visit(t, "rule");
 		BasicSemanticChecks basics = new BasicSemanticChecks(g, ruleCollector);
+		// disable the assoc element option checks because they are already
+		// handled for the pre-transformed rule.
+		basics.checkAssocElementOption = false;
 		basics.visit(t, "rule");
 
 		// track recursive alt info for codegen

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -152,6 +152,9 @@ public boolean translateLeftRecursiveRule(GrammarRootAST ast,
 		RuleCollector ruleCollector = new RuleCollector(g);
 		ruleCollector.visit(t, "rule");
 		BasicSemanticChecks basics = new BasicSemanticChecks(g, ruleCollector);
+		// disable the assoc element option checks because they are already
+		// handled for the pre-transformed rule.
+		basics.checkAssocElementOption = false;
 		basics.visit(t, "rule");
 
 		// track recursive alt info for codegen

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -339,7 +339,7 @@ public void processGrammarsOnCommandLine() {
 				System.out.println(dep.getDependencies().render());
 
 			}
-			else {
+			else if (errMgr.getNumErrors() == 0) {
 				process(g, true);
 			}
 		}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -726,7 +726,7 @@ public enum ErrorType {
 	 *
 	 * <p>unterminated string literal</p>
 	 *
-	 * <p>The parser contains an unterminated string literal.</p>
+	 * <p>The grammar contains an unterminated string literal.</p>
 	 *
 	 * <p>The following rule produces this error.</p>
 	 *

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -339,7 +339,7 @@ public void processGrammarsOnCommandLine() {
 				System.out.println(dep.getDependencies().render());
 
 			}
-			else {
+			else if (errMgr.getNumErrors() == 0) {
 				process(g, true);
 			}
 		}

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -446,7 +446,7 @@ protected boolean closure(@NotNull CharStream input, @NotNull LexerATNConfig con
 					if (config.context.getReturnState(i) != PredictionContext.EMPTY_RETURN_STATE) {
 						PredictionContext newContext = config.context.getParent(i); // "pop" return state
 						ATNState returnState = atn.states.get(config.context.getReturnState(i));
-						LexerATNConfig c = new LexerATNConfig(returnState, config.alt, newContext);
+						LexerATNConfig c = new LexerATNConfig(config, returnState, newContext);
 						currentAltReachedAcceptState = closure(input, c, configs, currentAltReachedAcceptState, speculative);
 					}
 				}

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntegerList.java
Patch:
@@ -103,6 +103,7 @@ public final void addAll(Collection<Integer> list) {
 		int current = 0;
 		for (int x : list) {
 			_data[_size + current] = x;
+			current++;
 		}
 
 		_size += list.size();

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntegerList.java
Patch:
@@ -103,6 +103,7 @@ public final void addAll(Collection<Integer> list) {
 		int current = 0;
 		for (int x : list) {
 			_data[_size + current] = x;
+			current++;
 		}
 
 		_size += list.size();

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -30,6 +30,7 @@
 
 package org.antlr.v4.runtime.atn;
 
+import org.antlr.v4.runtime.BailErrorStrategy;
 import org.antlr.v4.runtime.CommonTokenStream;
 import org.antlr.v4.runtime.IntStream;
 import org.antlr.v4.runtime.NoViableAltException;
@@ -243,7 +244,7 @@
  * mode with the {@link BailErrorStrategy}:</p>
  *
  * <pre>
- * parser.{@link Parser#getInterpreter() getInterpreter()}.{@link #setSLL setSLL(true)};
+ * parser.{@link Parser#getInterpreter() getInterpreter()}.{@link #setPredictionMode setPredictionMode}{@code (}{@link PredictionMode#SLL}{@code )};
  * parser.{@link Parser#setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
  * </pre>
  *

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPathRuleAnywhereElement.java
Patch:
@@ -5,7 +5,9 @@
 
 import java.util.Collection;
 
-/** Either ID at start of path or ...//ID in middle of path */
+/**
+ * Either {@code ID} at start of path or {@code ...//ID} in middle of path.
+ */
 public class XPathRuleAnywhereElement extends XPathElement {
 	protected int ruleIndex;
 	public XPathRuleAnywhereElement(String ruleName, int ruleIndex) {

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -89,7 +89,7 @@ public class BufferedTokenStream implements TokenStream {
 	 */
 	protected boolean fetchedEOF;
 
-    public BufferedTokenStream(TokenSource tokenSource) {
+    public BufferedTokenStream(@NotNull TokenSource tokenSource) {
 		if (tokenSource == null) {
 			throw new NullPointerException("tokenSource cannot be null");
 		}
@@ -208,6 +208,7 @@ protected Token LB(int k) {
         return tokens.get(p-k);
     }
 
+	@NotNull
     @Override
     public Token LT(int k) {
         lazyInit();

File: runtime/Java/src/org/antlr/v4/runtime/CommonToken.java
Patch:
@@ -71,6 +71,7 @@ public class CommonToken implements WritableToken, Serializable {
 	 * the same source and input stream share a reference to the same
 	 * {@link Pair} containing these values.</p>
 	 */
+	@NotNull
 	protected Pair<TokenSource, CharStream> source;
 
 	/**
@@ -106,6 +107,7 @@ public class CommonToken implements WritableToken, Serializable {
 	 */
 	public CommonToken(int type) {
 		this.type = type;
+		this.source = EMPTY_SOURCE;
 	}
 
 	public CommonToken(@NotNull Pair<TokenSource, CharStream> source, int type, int channel, int start, int stop) {
@@ -139,7 +141,7 @@ public CommonToken(int type, String text) {
 	 *
 	 * @param oldToken The token to copy.
 	 */
-	public CommonToken(Token oldToken) {
+	public CommonToken(@NotNull Token oldToken) {
 		text = oldToken.getText();
 		type = oldToken.getType();
 		line = oldToken.getLine();

File: runtime/Java/src/org/antlr/v4/runtime/DiagnosticErrorListener.java
Patch:
@@ -87,7 +87,7 @@ public DiagnosticErrorListener(boolean exactOnly) {
 
 	@Override
 	public void reportAmbiguity(@NotNull Parser recognizer,
-								DFA dfa,
+								@NotNull DFA dfa,
 								int startIndex,
 								int stopIndex,
 								boolean exact,

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1671,7 +1671,7 @@ protected DFAState addDFAState(@NotNull DFA dfa, @NotNull DFAState D) {
 		}
 	}
 
-	protected void reportAttemptingFullContext(DFA dfa, @Nullable BitSet conflictingAlts, @NotNull ATNConfigSet configs, int startIndex, int stopIndex) {
+	protected void reportAttemptingFullContext(@NotNull DFA dfa, @Nullable BitSet conflictingAlts, @NotNull ATNConfigSet configs, int startIndex, int stopIndex) {
         if ( debug || retry_debug ) {
 			Interval interval = Interval.of(startIndex, stopIndex);
 			System.out.println("reportAttemptingFullContext decision="+dfa.decision+":"+configs+
@@ -1680,7 +1680,7 @@ protected void reportAttemptingFullContext(DFA dfa, @Nullable BitSet conflicting
         if ( parser!=null ) parser.getErrorListenerDispatch().reportAttemptingFullContext(parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
     }
 
-	protected void reportContextSensitivity(DFA dfa, int prediction, @NotNull ATNConfigSet configs, int startIndex, int stopIndex) {
+	protected void reportContextSensitivity(@NotNull DFA dfa, int prediction, @NotNull ATNConfigSet configs, int startIndex, int stopIndex) {
         if ( debug || retry_debug ) {
 			Interval interval = Interval.of(startIndex, stopIndex);
             System.out.println("reportContextSensitivity decision="+dfa.decision+":"+configs+

File: tool/test/org/antlr/v4/test/TestBasicSemanticErrors.java
Patch:
@@ -58,8 +58,8 @@ public class TestBasicSemanticErrors extends BaseTest {
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:2:19: unsupported option 'k'\n" +
 		"error(" + ErrorType.TOKEN_NAMES_MUST_START_UPPER.code + "): U.g4:5:8: token names must start with an uppercase letter: f\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:9:10: unsupported option 'x'\n" +
-		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:9:0: repeated grammar prequel spec (option, token, or import); please merge\n" +
-		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:8:0: repeated grammar prequel spec (option, token, or import); please merge\n" +
+		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:9:0: repeated grammar prequel spec (options, tokens, or import); please merge\n" +
+		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:8:0: repeated grammar prequel spec (options, tokens, or import); please merge\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:12:10: unsupported option 'blech'\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:12:21: unsupported option 'greedy'\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:15:16: unsupported option 'ick'\n" +

File: tool/test/org/antlr/v4/test/TestBasicSemanticErrors.java
Patch:
@@ -58,8 +58,8 @@ public class TestBasicSemanticErrors extends BaseTest {
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:2:19: unsupported option 'k'\n" +
 		"error(" + ErrorType.TOKEN_NAMES_MUST_START_UPPER.code + "): U.g4:5:8: token names must start with an uppercase letter: f\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:9:10: unsupported option 'x'\n" +
-		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:9:0: repeated grammar prequel spec (option, token, or import); please merge\n" +
-		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:8:0: repeated grammar prequel spec (option, token, or import); please merge\n" +
+		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:9:0: repeated grammar prequel spec (options, tokens, or import); please merge\n" +
+		"error(" + ErrorType.REPEATED_PREQUEL.code + "): U.g4:8:0: repeated grammar prequel spec (options, tokens, or import); please merge\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:12:10: unsupported option 'blech'\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:12:21: unsupported option 'greedy'\n" +
 		"warning(" + ErrorType.ILLEGAL_OPTION.code + "): U.g4:15:16: unsupported option 'ick'\n" +

File: runtime/JavaAnnotations/src/org/antlr/v4/runtime/misc/NullUsageProcessor.java
Patch:
@@ -283,7 +283,7 @@ else if (isNullable(overrider) && !(isNullable(overridden) || isNotNull(overridd
 				String error = String.format("parameter %s annotated with %s cannot override or implement a parameter annotated with %s", overriderParameters.get(i).getSimpleName(), notNullType.getSimpleName(), nullableType.getSimpleName());
 				processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error, overriderParameters.get(i), getNotNullAnnotationMirror(overriderParameters.get(i)));
 			}
-			else if (isNotNull(overriderParameters.get(i)) && !(isNullable(overriddenParameters.get(i)) || isNotNull(overriddenParameters.get(i))) /*&& !errorElements.contains(overriderParameters.get(i)) && warnedElements.add(overriderParameters.get(i))*/) {
+			else if (isNotNull(overriderParameters.get(i)) && !(isNullable(overriddenParameters.get(i)) || isNotNull(overriddenParameters.get(i))) && !errorElements.contains(overriderParameters.get(i)) && warnedElements.add(overriderParameters.get(i))) {
 				String error = String.format("parameter %s annotated with %s overrides a parameter that is not annotated", overriderParameters.get(i).getSimpleName(), notNullType.getSimpleName());
 				processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, error, overriderParameters.get(i), getNotNullAnnotationMirror(overriderParameters.get(i)));
 			}

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -212,9 +212,9 @@ void addSourceRoot(File outputDir) {
      * The main entry point for this Mojo, it is responsible for converting
      * ANTLR 4.x grammars into the target language specified by the grammar.
      *
-     * @throws MojoExecutionException if a configuration or grammar error causes
+     * @exception MojoExecutionException if a configuration or grammar error causes
      * the code generation process to fail
-     * @throws MojoFailureException if an instance of the ANTLR 4 {@link Tool}
+     * @exception MojoFailureException if an instance of the ANTLR 4 {@link Tool}
      * cannot be created
      */
     @Override
@@ -353,7 +353,7 @@ private List<String> getCommandArguments() {
     /**
      *
      * @param sourceDirectory
-     * @throws InclusionScanException
+     * @exception InclusionScanException
      */
     @NotNull
     private List<List<String>> processGrammarFiles(List<String> args, File sourceDirectory) throws InclusionScanException {

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRInputStream.java
Patch:
@@ -41,8 +41,8 @@
  * Vacuum all input from a {@link Reader}/{@link InputStream} and then treat it
  * like a {@code char[]} buffer. Can also pass in a {@link String} or
  * {@code char[]} to use.
- * <p/>
- * If you need encoding, pass in stream/reader with correct encoding.
+ *
+ * <p>If you need encoding, pass in stream/reader with correct encoding.</p>
  */
 public class ANTLRInputStream implements CharStream {
     public static final int READ_BUFFER_SIZE = 1024;

File: runtime/Java/src/org/antlr/v4/runtime/BailErrorStrategy.java
Patch:
@@ -33,8 +33,8 @@
 import org.antlr.v4.runtime.misc.ParseCancellationException;
 
 /** Bail out of parser at first syntax error. Do this to use it:
- *  <p/>
- *  {@code myparser.setErrorHandler(new BailErrorStrategy());}
+ *
+ *  <p>{@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
  */
 public class BailErrorStrategy extends DefaultErrorStrategy {
     /** Instead of recovering from exception {@code e}, re-throw it wrapped

File: runtime/Java/src/org/antlr/v4/runtime/CommonToken.java
Patch:
@@ -52,7 +52,7 @@ public class CommonToken implements WritableToken, Serializable {
 	// TODO: can store these in map in token stream rather than as field here
 	protected String text;
 
-	/** What token number is this from 0..n-1 tokens; < 0 implies invalid index */
+	/** What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index */
 	protected int index = -1;
 
 	/** The char position into the input buffer where this token starts */

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -37,15 +37,15 @@
  * and also must reveal it's source of characters; {@link CommonToken}'s text is
  * computed from a {@link CharStream}; it only store indices into the char
  * stream.
- * <p/>
- * Errors from the lexer are never passed to the parser. Either you want to keep
+ *
+ * <p>Errors from the lexer are never passed to the parser. Either you want to keep
  * going or you do not upon token recognition error. If you do not want to
  * continue lexing then you do not want to continue parsing. Just throw an
  * exception not under {@link RecognitionException} and Java will naturally toss
  * you all the way out of the recognizers. If you want to continue lexing then
  * you should not throw an exception to the parser--it has already requested a
  * token. Keep lexing until you get a valid one. Just report errors and keep
- * going, looking for a valid token.
+ * going, looking for a valid token.</p>
  */
 public interface TokenSource {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/TokenStreamRewriter.java
Patch:
@@ -184,11 +184,11 @@ public String toString() {
 
 	/** You may have multiple, named streams of rewrite operations.
 	 *  I'm calling these things "programs."
-	 *  Maps String (name) -> rewrite (List)
+	 *  Maps String (name) &rarr; rewrite (List)
 	 */
 	protected final Map<String, List<RewriteOperation>> programs;
 
-	/** Map String (program name) -> Integer index */
+	/** Map String (program name) &rarr; Integer index */
 	protected final Map<String, Integer> lastRewriteTokenIndexes;
 
 	public TokenStreamRewriter(TokenStream tokens) {
@@ -456,7 +456,7 @@ public String getText(String programName, Interval interval) {
 	 * 		3. throw exception if index in same range as previous replace
 	 *
 	 *  Don't actually delete; make op null in list. Easier to walk list.
-	 *  Later we can throw as we add to index -> op map.
+	 *  Later we can throw as we add to index &rarr; op map.
 	 *
 	 *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
 	 *  inserted stuff would be before the replace range.  But, if you

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATN.java
Patch:
@@ -167,9 +167,9 @@ public int getNumberOfDecisions() {
 	 * assumed true). If a path in the ATN exists from the starting state to the
 	 * {@link RuleStopState} of the outermost context without matching any
 	 * symbols, {@link Token#EOF} is added to the returned set.
-	 * <p/>
-	 * If {@code context} is {@code null}, it is treated as
-	 * {@link ParserRuleContext#EMPTY}.
+	 *
+	 * <p>If {@code context} is {@code null}, it is treated as
+	 * {@link ParserRuleContext#EMPTY}.</p>
 	 *
 	 * @param stateNumber the ATN state number
 	 * @param context the full parse context

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -65,7 +65,7 @@ public class ATNConfig {
 	 * invokes the ATN simulator.
 	 *
 	 * closure() tracks the depth of how far we dip into the
-	 * outer context: depth > 0.  Note that it may not be totally
+	 * outer context: depth &gt; 0.  Note that it may not be totally
 	 * accurate depth since I don't ever decrement. TODO: make it a boolean then
 	 */
 	public int reachesIntoOuterContext;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -149,9 +149,9 @@ public boolean add(@NotNull ATNConfig config) {
 	 * {@link ATNConfig#state}, {@code i} is the {@link ATNConfig#alt}, and
 	 * {@code pi} is the {@link ATNConfig#semanticContext}. We use
 	 * {@code (s,i,pi)} as key.
-	 * <p/>
-	 * This method updates {@link #dipsIntoOuterContext} and
-	 * {@link #hasSemanticContext} when necessary.
+	 *
+	 * <p>This method updates {@link #dipsIntoOuterContext} and
+	 * {@link #hasSemanticContext} when necessary.</p>
 	 */
 	public boolean add(
 		@NotNull ATNConfig config,

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSerializer.java
Patch:
@@ -59,7 +59,7 @@ public ATNSerializer(ATN atn, List<String> tokenNames) {
 		this.tokenNames = tokenNames;
 	}
 
-	/** Serialize state descriptors, edge descriptors, and decision->state map
+	/** Serialize state descriptors, edge descriptors, and decision&rarr;state map
 	 *  into list of ints:
 	 *
 	 * 		grammar-type, (ANTLRParser.LEXER, ...)

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerChannelAction.java
Patch:
@@ -82,9 +82,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#setChannel} with the
-	 * value provided by {@link #getChannel}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#setChannel} with the
+	 * value provided by {@link #getChannel}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerModeAction.java
Patch:
@@ -81,9 +81,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#mode} with the
-	 * value provided by {@link #getMode}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#mode} with the
+	 * value provided by {@link #getMode}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerPushModeAction.java
Patch:
@@ -81,9 +81,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#pushMode} with the
-	 * value provided by {@link #getMode}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#pushMode} with the
+	 * value provided by {@link #getMode}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerTypeAction.java
Patch:
@@ -80,9 +80,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#setType} with the
-	 * value provided by {@link #getType}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#setType} with the
+	 * value provided by {@link #getType}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/StarLoopEntryState.java
Patch:
@@ -39,10 +39,10 @@ public final class StarLoopEntryState extends DecisionState {
 	/**
 	 * Indicates whether this state can benefit from a precedence DFA during SLL
 	 * decision making.
-	 * <p/>
-	 * This is a computed property that is calculated during ATN deserialization
+	 *
+	 * <p>This is a computed property that is calculated during ATN deserialization
 	 * and stored for use in {@link ParserATNSimulator} and
-	 * {@link ParserInterpreter}.
+	 * {@link ParserInterpreter}.</p>
 	 *
 	 * @see DFA#isPrecedenceDfa()
 	 */

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFA.java
Patch:
@@ -62,7 +62,7 @@ public class DFA {
 	/**
 	 * {@code true} if this DFA is for a precedence decision; otherwise,
 	 * {@code false}. This is the backing field for {@link #isPrecedenceDfa},
-	 * {@link #setPrecedenceDfa}, {@link #hasPrecedenceEdge}.
+	 * {@link #setPrecedenceDfa}.
 	 */
 	private volatile boolean precedenceDfa;
 

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntegerList.java
Patch:
@@ -234,10 +234,10 @@ public boolean equals(Object o) {
 
 	/**
 	 * Returns the hash code value for this list.
-	 * <p/>
-	 * This implementation uses exactly the code that is used to define the
+	 *
+	 * <p>This implementation uses exactly the code that is used to define the
 	 * list hash function in the documentation for the {@link List#hashCode}
-	 * method.
+	 * method.</p>
 	 *
 	 * @return the hash code value for this list
 	 */

File: runtime/Java/src/org/antlr/v4/runtime/misc/Interval.java
Patch:
@@ -65,7 +65,7 @@ public static Interval of(int a, int b) {
 	}
 
 	/** return number of elements between a and b inclusively. x..x is length 1.
-	 *  if b < a, then length is 0.  9..10 has length 2.
+	 *  if b &lt; a, then length is 0.  9..10 has length 2.
 	 */
 	public int length() {
 		if ( b<a ) return 0;

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java
Patch:
@@ -111,7 +111,7 @@ public void add(int el) {
     }
 
     /** Add interval; i.e., add all integers from a to b to set.
-     *  If b<a, do nothing.
+     *  If b&lt;a, do nothing.
      *  Keep list in sorted order (by left range value).
      *  If overlap, combine ranges.  For example,
      *  If this is {1..5, 10..20}, adding 6..7 yields
@@ -246,7 +246,7 @@ public IntervalSet complement(IntSet vocabulary) {
 		return compl;
     }
 
-	/** Compute this-other via this&~other.
+	/** Compute this-other via this&amp;~other.
 	 *  Return a new set containing all elements in this but not in other.
 	 *  other is assumed to be a subset of this;
      *  anything that is in other but not in this will be ignored.
@@ -400,7 +400,7 @@ public int getMaxElement() {
 		return last.b;
 	}
 
-	/** Return minimum element >= 0 */
+	/** Return minimum element &gt;= 0 */
 	public int getMinElement() {
 		if ( isNil() ) {
 			return Token.INVALID_TYPE;

File: runtime/Java/src/org/antlr/v4/runtime/misc/Utils.java
Patch:
@@ -136,8 +136,8 @@ public void windowClosing(WindowEvent arg0) {
 		t.join();
 	}
 
-	/** Convert array of strings to string->index map. Useful for
-	 *  converting rulenames to name->ruleindex map.
+	/** Convert array of strings to string&rarr;index map. Useful for
+	 *  converting rulenames to name&rarr;ruleindex map.
 	 */
 	public static Map<String, Integer> toMap(String[] keys) {
 		Map<String, Integer> m = new HashMap<String, Integer>();

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTree.java
Patch:
@@ -38,8 +38,8 @@
  *  during a parse that makes the data structure look like a simple parse tree.
  *  This node represents both internal nodes, rule invocations,
  *  and leaf nodes, token matches.
- * <p/>
- *  The payload is either a {@link Token} or a {@link RuleContext} object.
+ *
+ *  <p>The payload is either a {@link Token} or a {@link RuleContext} object.</p>
  */
 public interface ParseTree extends SyntaxTree {
 	// the following methods narrow the return type; they are not additional methods

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -44,8 +44,8 @@ public interface SyntaxTree extends Tree {
 	 * {@link TokenStream} of the first and last token associated with this
 	 * subtree. If this node is a leaf, then the interval represents a single
 	 * token.
-	 * <p/>
-	 * If source interval is unknown, this returns {@link Interval#INVALID}.
+	 *
+	 * <p>If source interval is unknown, this returns {@link Interval#INVALID}.</p>
 	 */
 	@NotNull
 	Interval getSourceInterval();

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/Chunk.java
Patch:
@@ -33,13 +33,13 @@
 /**
  * A chunk is either a token tag, a rule tag, or a span of literal text within a
  * tree pattern.
- * <p/>
- * The method {@link ParseTreePatternMatcher#split(String)} returns a list of
+ *
+ * <p>The method {@link ParseTreePatternMatcher#split(String)} returns a list of
  * chunks in preparation for creating a token stream by
  * {@link ParseTreePatternMatcher#tokenize(String)}. From there, we get a parse
  * tree from with {@link ParseTreePatternMatcher#compile(String, int)}. These
  * chunks are converted to {@link RuleTagToken}, {@link TokenTagToken}, or the
- * regular tokens of the text surrounding the tags.
+ * regular tokens of the text surrounding the tags.</p>
  */
 abstract class Chunk {
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TextChunk.java
Patch:
@@ -69,9 +69,9 @@ public final String getText() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * The implementation for {@link TextChunk} returns the result of
-	 * {@link #getText()} in single quotes.
+	 *
+	 * <p>The implementation for {@link TextChunk} returns the result of
+	 * {@link #getText()} in single quotes.</p>
 	 */
 	@Override
 	public String toString() {

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -212,9 +212,9 @@ void addSourceRoot(File outputDir) {
      * The main entry point for this Mojo, it is responsible for converting
      * ANTLR 4.x grammars into the target language specified by the grammar.
      *
-     * @throws MojoExecutionException if a configuration or grammar error causes
+     * @exception MojoExecutionException if a configuration or grammar error causes
      * the code generation process to fail
-     * @throws MojoFailureException if an instance of the ANTLR 4 {@link Tool}
+     * @exception MojoFailureException if an instance of the ANTLR 4 {@link Tool}
      * cannot be created
      */
     @Override
@@ -353,7 +353,7 @@ private List<String> getCommandArguments() {
     /**
      *
      * @param sourceDirectory
-     * @throws InclusionScanException
+     * @exception InclusionScanException
      */
     @NotNull
     private List<List<String>> processGrammarFiles(List<String> args, File sourceDirectory) throws InclusionScanException {

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRInputStream.java
Patch:
@@ -41,8 +41,8 @@
  * Vacuum all input from a {@link Reader}/{@link InputStream} and then treat it
  * like a {@code char[]} buffer. Can also pass in a {@link String} or
  * {@code char[]} to use.
- * <p/>
- * If you need encoding, pass in stream/reader with correct encoding.
+ *
+ * <p>If you need encoding, pass in stream/reader with correct encoding.</p>
  */
 public class ANTLRInputStream implements CharStream {
     public static final int READ_BUFFER_SIZE = 1024;

File: runtime/Java/src/org/antlr/v4/runtime/BailErrorStrategy.java
Patch:
@@ -33,8 +33,8 @@
 import org.antlr.v4.runtime.misc.ParseCancellationException;
 
 /** Bail out of parser at first syntax error. Do this to use it:
- *  <p/>
- *  {@code myparser.setErrorHandler(new BailErrorStrategy());}
+ *
+ *  <p>{@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
  */
 public class BailErrorStrategy extends DefaultErrorStrategy {
     /** Instead of recovering from exception {@code e}, re-throw it wrapped

File: runtime/Java/src/org/antlr/v4/runtime/CommonToken.java
Patch:
@@ -52,7 +52,7 @@ public class CommonToken implements WritableToken, Serializable {
 	// TODO: can store these in map in token stream rather than as field here
 	protected String text;
 
-	/** What token number is this from 0..n-1 tokens; < 0 implies invalid index */
+	/** What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index */
 	protected int index = -1;
 
 	/** The char position into the input buffer where this token starts */

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -37,15 +37,15 @@
  * and also must reveal it's source of characters; {@link CommonToken}'s text is
  * computed from a {@link CharStream}; it only store indices into the char
  * stream.
- * <p/>
- * Errors from the lexer are never passed to the parser. Either you want to keep
+ *
+ * <p>Errors from the lexer are never passed to the parser. Either you want to keep
  * going or you do not upon token recognition error. If you do not want to
  * continue lexing then you do not want to continue parsing. Just throw an
  * exception not under {@link RecognitionException} and Java will naturally toss
  * you all the way out of the recognizers. If you want to continue lexing then
  * you should not throw an exception to the parser--it has already requested a
  * token. Keep lexing until you get a valid one. Just report errors and keep
- * going, looking for a valid token.
+ * going, looking for a valid token.</p>
  */
 public interface TokenSource {
 	/**

File: runtime/Java/src/org/antlr/v4/runtime/TokenStreamRewriter.java
Patch:
@@ -184,11 +184,11 @@ public String toString() {
 
 	/** You may have multiple, named streams of rewrite operations.
 	 *  I'm calling these things "programs."
-	 *  Maps String (name) -> rewrite (List)
+	 *  Maps String (name) &rarr; rewrite (List)
 	 */
 	protected final Map<String, List<RewriteOperation>> programs;
 
-	/** Map String (program name) -> Integer index */
+	/** Map String (program name) &rarr; Integer index */
 	protected final Map<String, Integer> lastRewriteTokenIndexes;
 
 	public TokenStreamRewriter(TokenStream tokens) {
@@ -456,7 +456,7 @@ public String getText(String programName, Interval interval) {
 	 * 		3. throw exception if index in same range as previous replace
 	 *
 	 *  Don't actually delete; make op null in list. Easier to walk list.
-	 *  Later we can throw as we add to index -> op map.
+	 *  Later we can throw as we add to index &rarr; op map.
 	 *
 	 *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
 	 *  inserted stuff would be before the replace range.  But, if you

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATN.java
Patch:
@@ -167,9 +167,9 @@ public int getNumberOfDecisions() {
 	 * assumed true). If a path in the ATN exists from the starting state to the
 	 * {@link RuleStopState} of the outermost context without matching any
 	 * symbols, {@link Token#EOF} is added to the returned set.
-	 * <p/>
-	 * If {@code context} is {@code null}, it is treated as
-	 * {@link ParserRuleContext#EMPTY}.
+	 *
+	 * <p>If {@code context} is {@code null}, it is treated as
+	 * {@link ParserRuleContext#EMPTY}.</p>
 	 *
 	 * @param stateNumber the ATN state number
 	 * @param context the full parse context

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -65,7 +65,7 @@ public class ATNConfig {
 	 * invokes the ATN simulator.
 	 *
 	 * closure() tracks the depth of how far we dip into the
-	 * outer context: depth > 0.  Note that it may not be totally
+	 * outer context: depth &gt; 0.  Note that it may not be totally
 	 * accurate depth since I don't ever decrement. TODO: make it a boolean then
 	 */
 	public int reachesIntoOuterContext;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -149,9 +149,9 @@ public boolean add(@NotNull ATNConfig config) {
 	 * {@link ATNConfig#state}, {@code i} is the {@link ATNConfig#alt}, and
 	 * {@code pi} is the {@link ATNConfig#semanticContext}. We use
 	 * {@code (s,i,pi)} as key.
-	 * <p/>
-	 * This method updates {@link #dipsIntoOuterContext} and
-	 * {@link #hasSemanticContext} when necessary.
+	 *
+	 * <p>This method updates {@link #dipsIntoOuterContext} and
+	 * {@link #hasSemanticContext} when necessary.</p>
 	 */
 	public boolean add(
 		@NotNull ATNConfig config,

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSerializer.java
Patch:
@@ -59,7 +59,7 @@ public ATNSerializer(ATN atn, List<String> tokenNames) {
 		this.tokenNames = tokenNames;
 	}
 
-	/** Serialize state descriptors, edge descriptors, and decision->state map
+	/** Serialize state descriptors, edge descriptors, and decision&rarr;state map
 	 *  into list of ints:
 	 *
 	 * 		grammar-type, (ANTLRParser.LEXER, ...)

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerChannelAction.java
Patch:
@@ -82,9 +82,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#setChannel} with the
-	 * value provided by {@link #getChannel}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#setChannel} with the
+	 * value provided by {@link #getChannel}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerModeAction.java
Patch:
@@ -81,9 +81,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#mode} with the
-	 * value provided by {@link #getMode}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#mode} with the
+	 * value provided by {@link #getMode}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerPushModeAction.java
Patch:
@@ -81,9 +81,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#pushMode} with the
-	 * value provided by {@link #getMode}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#pushMode} with the
+	 * value provided by {@link #getMode}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerTypeAction.java
Patch:
@@ -80,9 +80,9 @@ public boolean isPositionDependent() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * This action is implemented by calling {@link Lexer#setType} with the
-	 * value provided by {@link #getType}.
+	 *
+	 * <p>This action is implemented by calling {@link Lexer#setType} with the
+	 * value provided by {@link #getType}.</p>
 	 */
 	@Override
 	public void execute(@NotNull Lexer lexer) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/StarLoopEntryState.java
Patch:
@@ -39,10 +39,10 @@ public final class StarLoopEntryState extends DecisionState {
 	/**
 	 * Indicates whether this state can benefit from a precedence DFA during SLL
 	 * decision making.
-	 * <p/>
-	 * This is a computed property that is calculated during ATN deserialization
+	 *
+	 * <p>This is a computed property that is calculated during ATN deserialization
 	 * and stored for use in {@link ParserATNSimulator} and
-	 * {@link ParserInterpreter}.
+	 * {@link ParserInterpreter}.</p>
 	 *
 	 * @see DFA#isPrecedenceDfa()
 	 */

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFA.java
Patch:
@@ -62,7 +62,7 @@ public class DFA {
 	/**
 	 * {@code true} if this DFA is for a precedence decision; otherwise,
 	 * {@code false}. This is the backing field for {@link #isPrecedenceDfa},
-	 * {@link #setPrecedenceDfa}, {@link #hasPrecedenceEdge}.
+	 * {@link #setPrecedenceDfa}.
 	 */
 	private volatile boolean precedenceDfa;
 

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntegerList.java
Patch:
@@ -234,10 +234,10 @@ public boolean equals(Object o) {
 
 	/**
 	 * Returns the hash code value for this list.
-	 * <p/>
-	 * This implementation uses exactly the code that is used to define the
+	 *
+	 * <p>This implementation uses exactly the code that is used to define the
 	 * list hash function in the documentation for the {@link List#hashCode}
-	 * method.
+	 * method.</p>
 	 *
 	 * @return the hash code value for this list
 	 */

File: runtime/Java/src/org/antlr/v4/runtime/misc/Interval.java
Patch:
@@ -65,7 +65,7 @@ public static Interval of(int a, int b) {
 	}
 
 	/** return number of elements between a and b inclusively. x..x is length 1.
-	 *  if b < a, then length is 0.  9..10 has length 2.
+	 *  if b &lt; a, then length is 0.  9..10 has length 2.
 	 */
 	public int length() {
 		if ( b<a ) return 0;

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java
Patch:
@@ -111,7 +111,7 @@ public void add(int el) {
     }
 
     /** Add interval; i.e., add all integers from a to b to set.
-     *  If b<a, do nothing.
+     *  If b&lt;a, do nothing.
      *  Keep list in sorted order (by left range value).
      *  If overlap, combine ranges.  For example,
      *  If this is {1..5, 10..20}, adding 6..7 yields
@@ -246,7 +246,7 @@ public IntervalSet complement(IntSet vocabulary) {
 		return compl;
     }
 
-	/** Compute this-other via this&~other.
+	/** Compute this-other via this&amp;~other.
 	 *  Return a new set containing all elements in this but not in other.
 	 *  other is assumed to be a subset of this;
      *  anything that is in other but not in this will be ignored.
@@ -400,7 +400,7 @@ public int getMaxElement() {
 		return last.b;
 	}
 
-	/** Return minimum element >= 0 */
+	/** Return minimum element &gt;= 0 */
 	public int getMinElement() {
 		if ( isNil() ) {
 			return Token.INVALID_TYPE;

File: runtime/Java/src/org/antlr/v4/runtime/misc/Utils.java
Patch:
@@ -136,8 +136,8 @@ public void windowClosing(WindowEvent arg0) {
 		t.join();
 	}
 
-	/** Convert array of strings to string->index map. Useful for
-	 *  converting rulenames to name->ruleindex map.
+	/** Convert array of strings to string&rarr;index map. Useful for
+	 *  converting rulenames to name&rarr;ruleindex map.
 	 */
 	public static Map<String, Integer> toMap(String[] keys) {
 		Map<String, Integer> m = new HashMap<String, Integer>();

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTree.java
Patch:
@@ -38,8 +38,8 @@
  *  during a parse that makes the data structure look like a simple parse tree.
  *  This node represents both internal nodes, rule invocations,
  *  and leaf nodes, token matches.
- * <p/>
- *  The payload is either a {@link Token} or a {@link RuleContext} object.
+ *
+ *  <p>The payload is either a {@link Token} or a {@link RuleContext} object.</p>
  */
 public interface ParseTree extends SyntaxTree {
 	// the following methods narrow the return type; they are not additional methods

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -44,8 +44,8 @@ public interface SyntaxTree extends Tree {
 	 * {@link TokenStream} of the first and last token associated with this
 	 * subtree. If this node is a leaf, then the interval represents a single
 	 * token.
-	 * <p/>
-	 * If source interval is unknown, this returns {@link Interval#INVALID}.
+	 *
+	 * <p>If source interval is unknown, this returns {@link Interval#INVALID}.</p>
 	 */
 	@NotNull
 	Interval getSourceInterval();

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/Chunk.java
Patch:
@@ -33,13 +33,13 @@
 /**
  * A chunk is either a token tag, a rule tag, or a span of literal text within a
  * tree pattern.
- * <p/>
- * The method {@link ParseTreePatternMatcher#split(String)} returns a list of
+ *
+ * <p>The method {@link ParseTreePatternMatcher#split(String)} returns a list of
  * chunks in preparation for creating a token stream by
  * {@link ParseTreePatternMatcher#tokenize(String)}. From there, we get a parse
  * tree from with {@link ParseTreePatternMatcher#compile(String, int)}. These
  * chunks are converted to {@link RuleTagToken}, {@link TokenTagToken}, or the
- * regular tokens of the text surrounding the tags.
+ * regular tokens of the text surrounding the tags.</p>
  */
 abstract class Chunk {
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/TextChunk.java
Patch:
@@ -69,9 +69,9 @@ public final String getText() {
 
 	/**
 	 * {@inheritDoc}
-	 * <p/>
-	 * The implementation for {@link TextChunk} returns the result of
-	 * {@link #getText()} in single quotes.
+	 *
+	 * <p>The implementation for {@link TextChunk} returns the result of
+	 * {@link #getText()} in single quotes.</p>
 	 */
 	@Override
 	public String toString() {

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPath.java
Patch:
@@ -181,7 +181,6 @@ public Collection<ParseTree> evaluate(final ParseTree t) {
 		dummyRoot.children = Collections.singletonList(t); // don't set t's parent.
 
 		Collection<ParseTree> work = Collections.<ParseTree>singleton(dummyRoot);
-		work.add(dummyRoot);
 
 		int i = 0;
 		while ( i < elements.length ) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPath.java
Patch:
@@ -181,7 +181,6 @@ public Collection<ParseTree> evaluate(final ParseTree t) {
 		dummyRoot.children = Collections.singletonList(t); // don't set t's parent.
 
 		Collection<ParseTree> work = Collections.<ParseTree>singleton(dummyRoot);
-		work.add(dummyRoot);
 
 		int i = 0;
 		while ( i < elements.length ) {

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -452,7 +452,7 @@ private final class CustomTool extends Tool {
 
 		public CustomTool(String[] args) {
 			super(args);
-			addListener(new Antlr4ErrorLog(getLog()));
+			addListener(new Antlr4ErrorLog(this, getLog()));
 		}
 
 		@Override

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -302,7 +302,9 @@ public GrammarRootAST extractImplicitLexer(Grammar combinedGrammar) {
 				if ( Grammar.lexerOptions.contains(optionName) &&
 					 !Grammar.doNotCopyOptionsToLexer.contains(optionName) )
 				{
-					lexerOptionsRoot.addChild((Tree)adaptor.dupTree(o));
+					GrammarAST optionTree = (GrammarAST)adaptor.dupTree(o);
+					lexerOptionsRoot.addChild(optionTree);
+					lexerAST.setOption(optionName, (GrammarAST)optionTree.getChild(1));
 				}
 			}
 		}

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -302,7 +302,9 @@ public GrammarRootAST extractImplicitLexer(Grammar combinedGrammar) {
 				if ( Grammar.lexerOptions.contains(optionName) &&
 					 !Grammar.doNotCopyOptionsToLexer.contains(optionName) )
 				{
-					lexerOptionsRoot.addChild((Tree)adaptor.dupTree(o));
+					GrammarAST optionTree = (GrammarAST)adaptor.dupTree(o);
+					lexerOptionsRoot.addChild(optionTree);
+					lexerAST.setOption(optionName, (GrammarAST)optionTree.getChild(1));
 				}
 			}
 		}

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -631,7 +631,7 @@ public GrammarRootAST parse(String fileName, CharStream in) {
 				ParserRuleReturnScope r = p.grammarSpec();
 				GrammarAST root = (GrammarAST)r.getTree();
 				if ( root instanceof GrammarRootAST) {
-					((GrammarRootAST)root).hasErrors = p.getNumberOfSyntaxErrors()>0;
+					((GrammarRootAST)root).hasErrors = lexer.getNumberOfSyntaxErrors()>0 || p.getNumberOfSyntaxErrors()>0;
 					assert ((GrammarRootAST)root).tokenStream == tokens;
 					if ( grammarOptions!=null ) {
 						((GrammarRootAST)root).cmdLineOptions = grammarOptions;

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -631,7 +631,7 @@ public GrammarRootAST parse(String fileName, CharStream in) {
 				ParserRuleReturnScope r = p.grammarSpec();
 				GrammarAST root = (GrammarAST)r.getTree();
 				if ( root instanceof GrammarRootAST) {
-					((GrammarRootAST)root).hasErrors = p.getNumberOfSyntaxErrors()>0;
+					((GrammarRootAST)root).hasErrors = lexer.getNumberOfSyntaxErrors()>0 || p.getNumberOfSyntaxErrors()>0;
 					assert ((GrammarRootAST)root).tokenStream == tokens;
 					if ( grammarOptions!=null ) {
 						((GrammarRootAST)root).cmdLineOptions = grammarOptions;

File: tool/test/org/antlr/v4/test/TestXPath.java
Patch:
@@ -76,6 +76,7 @@ public class TestXPath extends BaseTest {
 			"//expr/!primary",	// anything but primary under any expr node
 			"//!*",				// nothing anywhere
 			"/!*",				// nothing at root
+			"//expr//ID",		// any ID under any expression (tests antlr/antlr4#370)
 		};
 		String expected[] = {
 			"[func, func]",
@@ -97,6 +98,7 @@ public class TestXPath extends BaseTest {
 			"[expr, expr, expr, expr, expr, expr]",
 			"[]",
 			"[]",
+			"[y, x]",
 		};
 
 		for (int i=0; i<xpath.length; i++) {

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRInputStream.java
Patch:
@@ -216,8 +216,9 @@ public void seek(int index) {
 			p = index; // just jump; don't update stream state (line, ...)
 			return;
 		}
-		// seek forward, consume until p hits index
-		while ( p<index && index<n ) {
+		// seek forward, consume until p hits index or n (whichever comes first)
+		index = Math.min(index, n);
+		while ( p<index ) {
 			consume();
 		}
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -953,7 +953,7 @@ protected ATNConfigSet computeStartState(@NotNull ATNState p,
 	 *
 	 * <ol>
 	 * <li>Evaluate the precedence predicates for each configuration using
-	 * {@link SemanticContext.evalPrecedence}.</li>
+	 * {@link SemanticContext#evalPrecedence}.</li>
 	 * <li>Remove all configurations which predict an alternative greater than
 	 * 1, for which another configuration that predicts alternative 1 is in the
 	 * same ATN state. This transformation is valid for the following reasons:

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -953,7 +953,7 @@ protected ATNConfigSet computeStartState(@NotNull ATNState p,
 	 *
 	 * <ol>
 	 * <li>Evaluate the precedence predicates for each configuration using
-	 * {@link SemanticContext.evalPrecedence}.</li>
+	 * {@link SemanticContext#evalPrecedence}.</li>
 	 * <li>Remove all configurations which predict an alternative greater than
 	 * 1, for which another configuration that predicts alternative 1 is in the
 	 * same ATN state. This transformation is valid for the following reasons:

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPath.java
Patch:
@@ -6,15 +6,13 @@
 import org.antlr.v4.runtime.Parser;
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.misc.Utils;
 import org.antlr.v4.runtime.tree.ParseTree;
 
 import java.io.IOException;
 import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 
 /** Represent a subset of XPath XML path syntax for use in identifying nodes in
  *  parse trees.
@@ -29,7 +27,7 @@
  *  XPath p = new XPath(parser, xpath);
  *  return p.evaluate(this);
  *
- *  See {@link org.antlr.v4.test.TestXPath} for descriptions. In short, this allows
+ *  See {@code org.antlr.v4.test.TestXPath} for descriptions. In short, this allows
  *  operators:
  *
  *      /         root

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/Chunk.java
Patch:
@@ -3,7 +3,9 @@
 /** A chunk is either a token reference, a rule reference, or some plaintext
  *  within a tree pattern.  Function split() in the pattern matcher returns
  *  a list of chunks in preparation for creating a token stream by tokenize().
- *  From there, we get a parse tree from with compile().
+ *  From there, we get a parse tree from with compile(). These chunks are
+ *  converted to RuleTagToken, TokenTagToken, or the regular tokens
+ *  of the text surrounding the tags.
  */
 abstract class Chunk {
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/Chunk.java
Patch:
@@ -3,7 +3,7 @@
 /** A chunk is either a token reference, a rule reference, or some plaintext
  *  within a tree pattern.  Function split() in the pattern matcher returns
  *  a list of chunks in preparation for creating a token stream by tokenize().
- *  From there, we get a parse tree from the pattern with compile().
+ *  From there, we get a parse tree from with compile().
  */
 abstract class Chunk {
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePatternMatcher.java
Patch:
@@ -267,7 +267,6 @@ else if ( Character.isLowerCase(tagChunk.tag.charAt(0)) ) {
 				}
 				else {
 					System.err.println("invalid tag: "+tagChunk.tag);
-					throw new IllegalArgumentException("invalid tag: "+tagChunk.tag+" in "+pattern);
 				}
 			}
 			else {

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/Chunk.java
Patch:
@@ -3,7 +3,7 @@
 /** A chunk is either a token reference, a rule reference, or some plaintext
  *  within a tree pattern.  Function split() in the pattern matcher returns
  *  a list of chunks in preparation for creating a token stream by tokenize().
- *  From there, we get a parse tree from with compile().
+ *  From there, we get a parse tree from the pattern with compile().
  */
 abstract class Chunk {
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePatternMatcher.java
Patch:
@@ -267,6 +267,7 @@ else if ( Character.isLowerCase(tagChunk.tag.charAt(0)) ) {
 				}
 				else {
 					System.err.println("invalid tag: "+tagChunk.tag);
+					throw new IllegalArgumentException("invalid tag: "+tagChunk.tag+" in "+pattern);
 				}
 			}
 			else {

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -188,9 +188,9 @@ public static Collection<ParseTree> findAllRuleNodes(ParseTree t, int ruleIndex)
 	}
 
 	public static List<ParseTree> findAllNodes(ParseTree t, int index, boolean findTokens) {
-		List<? super ParseTree> nodes = new ArrayList<ParseTree>();
+		List<ParseTree> nodes = new ArrayList<ParseTree>();
 		_findAllNodes(t, index, findTokens, nodes);
-		return (List<ParseTree>)nodes;
+		return nodes;
 	}
 
 	public static void _findAllNodes(ParseTree t, int index, boolean findTokens,

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -543,11 +543,11 @@ public Class<?> loadClassFromTempDir(String name) throws Exception {
 	}
 
 	public Class<? extends Lexer> loadLexerClassFromTempDir(String name) throws Exception {
-		return (Class<? extends Lexer>)loadClassFromTempDir(name);
+		return loadClassFromTempDir(name).asSubclass(Lexer.class);
 	}
 
 	public Class<? extends Parser> loadParserClassFromTempDir(String name) throws Exception {
-		return (Class<? extends Parser>)loadClassFromTempDir(name);
+		return loadClassFromTempDir(name).asSubclass(Parser.class);
 	}
 
 	protected String execParser(String grammarFileName,

File: tool/src/org/antlr/v4/tool/interp/ParserInterpreter.java
Patch:
@@ -214,6 +214,7 @@ protected void visitState(ATNState p) {
 			if (!transition.matches(_input.LA(1), Token.MIN_TOKEN_TYPE, 65535)) {
 				_errHandler.recoverInline(this);
 			}
+			matchWildcard();
 			break;
 
 		case Transition.WILDCARD:

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPathTokenElement.java
Patch:
@@ -21,7 +21,9 @@ public Collection<ParseTree> evaluate(ParseTree t) {
 		for (ParseTree c : t.getChildren()) {
 			if ( c instanceof TerminalNode ) {
 				TerminalNode tnode = (TerminalNode)c;
-				if ( tnode.getSymbol().getType() == tokenType ) {
+				if ( (tnode.getSymbol().getType() == tokenType && !invert) ||
+					 (tnode.getSymbol().getType() != tokenType && invert) )
+				{
 					nodes.add(c);
 				}
 			}

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPathWildcardAnywhereElement.java
Patch:
@@ -3,6 +3,7 @@
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.Trees;
 
+import java.util.ArrayList;
 import java.util.Collection;
 
 public class XPathWildcardAnywhereElement extends XPathElement {
@@ -12,6 +13,7 @@ public XPathWildcardAnywhereElement() {
 
 	@Override
 	public Collection<ParseTree> evaluate(ParseTree t) {
+		if ( invert ) return new ArrayList<ParseTree>(); // !* is weird but valid (empty)
 		return Trees.descendants(t);
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPathWildcardElement.java
Patch:
@@ -12,6 +12,7 @@ public XPathWildcardElement() {
 
 	@Override
 	public Collection<ParseTree> evaluate(final ParseTree t) {
+		if ( invert ) return new ArrayList<ParseTree>(); // !* is weird but valid (empty)
 		return new ArrayList<ParseTree>() {{addAll(t.getChildren());}};
 	}
 }

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -511,7 +511,7 @@ public ParseTree execStartRule(String startRuleName, Parser parser)
 			args = new Integer[] {0};
 		}
 		ParseTree result = (ParseTree)startRule.invoke(parser, args);
-		System.out.println("parse tree = "+result.toStringTree(parser));
+//		System.out.println("parse tree = "+result.toStringTree(parser));
 		return result;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPathRuleElement.java
Patch:
@@ -18,6 +18,9 @@ public XPathRuleElement(String ruleName, int ruleIndex) {
 	public Collection<ParseTree> evaluate(ParseTree t) {
 				// return all children of t that match nodeName
 		List<ParseTree> nodes = new ArrayList<ParseTree>();
+		if ( t.getChildren()==null) {
+			System.out.println();
+		}
 		for (ParseTree c : t.getChildren()) {
 			if ( c instanceof ParserRuleContext ) {
 				ParserRuleContext ctx = (ParserRuleContext)c;

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -34,12 +34,11 @@
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.ParseTreeVisitor;
 import org.antlr.v4.runtime.tree.RuleNode;
-import org.antlr.v4.runtime.tree.Tree;
 import org.antlr.v4.runtime.tree.Trees;
 import org.antlr.v4.runtime.tree.gui.TreeViewer;
 
 import javax.print.PrintException;
-import javax.swing.JDialog;
+import javax.swing.*;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
@@ -152,7 +151,7 @@ public int getChildCount() {
 	}
 
 	@Override
-	public List<? extends Tree> getChildren() {
+	public List<? extends ParseTree> getChildren() {
 		return null;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/TerminalNodeImpl.java
Patch:
@@ -66,7 +66,7 @@ public Interval getSourceInterval() {
 	public int getChildCount() { return 0; }
 
 	@Override
-	public List<? extends Tree> getChildren() {
+	public List<? extends ParseTree> getChildren() {
 		return null;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/DefaultErrorStrategy.java
Patch:
@@ -297,7 +297,7 @@ protected void reportNoViableAlternative(@NotNull Parser recognizer,
 	{
 		TokenStream tokens = recognizer.getInputStream();
 		String input;
-		if (tokens instanceof TokenStream) {
+		if ( tokens!=null ) {
 			if ( e.getStartToken().getType()==Token.EOF ) input = "<EOF>";
 			else input = tokens.getText(e.getStartToken(), e.getOffendingToken());
 		}

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -259,7 +259,7 @@ protected DFAState getExistingTargetState(@NotNull DFAState s, int t) {
 		if (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {
 			return null;
 		}
-		
+
 		DFAState target = s.edges[t - MIN_DFA_EDGE];
 		if (debug && target != null) {
 			System.out.println("reuse state "+s.stateNumber+
@@ -619,7 +619,6 @@ protected void addDFAEdge(@NotNull DFAState p, int t, @NotNull DFAState q) {
 			System.out.println("EDGE "+p+" -> "+q+" upon "+((char)t));
 		}
 
-		DFA dfa = decisionToDFA[mode];
 		synchronized (p) {
 			if ( p.edges==null ) {
 				//  make room for tokens 1..n and -1 masquerading as index 0

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFASerializer.java
Patch:
@@ -67,6 +67,7 @@ public String toString() {
 		}
 
 		String output = buf.toString();
+		if ( output.length()==0 ) return null;
 		//return Utils.sortLinesInString(output);
 		return output;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/misc/GraphicsSupport.java
Patch:
@@ -81,14 +81,14 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 	public static void saveImage(final JComponent comp, String fileName)
 		throws IOException, PrintException
 	{
-		if (fileName.endsWith(".ps") || fileName.endsWith(".eps") ) {
+		if ( fileName.endsWith(".ps") || fileName.endsWith(".eps") ) {
 			DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;
 			String mimeType = "application/postscript";
 			StreamPrintServiceFactory[] factories =
 				StreamPrintServiceFactory.lookupStreamPrintServiceFactories(flavor, mimeType);
 			System.out.println(Arrays.toString(factories));
-			FileOutputStream out = new FileOutputStream(fileName);
 			if (factories.length > 0) {
+				FileOutputStream out = new FileOutputStream(fileName);
 				PrintService service = factories[0].getPrintService(out);
 				SimpleDoc doc = new SimpleDoc(new Printable() {
 					@Override
@@ -115,6 +115,7 @@ public int print(Graphics g, PageFormat pf, int page) {
 				DocPrintJob job = service.createPrintJob();
 				PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet();
 				job.print(doc, attributes);
+				out.close();
 			}
 		} else {
 			// parrt: works with [image/jpeg, image/png, image/x-png, image/vnd.wap.wbmp, image/bmp, image/gif]

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -137,7 +137,7 @@ else if ( a.equals(ASSOC.left.toString()) ) {
 		}
 		altAssociativity.put(alt, assoc);
 
-		System.out.println("setAltAssoc: op " + alt + ": " + t.getText()+", assoc="+assoc);
+//		System.out.println("setAltAssoc: op " + alt + ": " + t.getText()+", assoc="+assoc);
 	}
 
 	@Override

File: tool/src/org/antlr/v4/automata/ATNPrinter.java
Patch:
@@ -111,8 +111,7 @@ else if ( t instanceof SetTransition ) {
 				}
 				else if ( t instanceof AtomTransition ) {
 					AtomTransition a = (AtomTransition)t;
-					String label = a.toString();
-					if ( g!=null ) label = g.getTokenDisplayName(a.label);
+					String label = g.getTokenDisplayName(a.label);
 					buf.append("-").append(label).append("->").append(getStateString(t.target)).append('\n');
 				}
 				else {

File: tool/src/org/antlr/v4/automata/ATNSerializer.java
Patch:
@@ -353,7 +353,7 @@ public String decode(char[] data) {
 			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
 		}
 
-		int grammarType = ATNSimulator.toInt(data[p++]);
+		p++; // skip grammarType
 		int maxType = ATNSimulator.toInt(data[p++]);
 		buf.append("max type ").append(maxType).append("\n");
 		int nstates = ATNSimulator.toInt(data[p++]);

File: tool/src/org/antlr/v4/misc/Graph.java
Patch:
@@ -97,7 +97,9 @@ public List<T> sort() {
 				n = tNode;
 				if ( !visited.contains(n) ) break;
 			}
-			DFS(n, visited, sorted);
+			if (n!=null) { // if at least one unvisited
+				DFS(n, visited, sorted);
+			}
 		}
 		return sorted;
 	}

File: tool/src/org/antlr/v4/semantics/RuleCollector.java
Patch:
@@ -96,7 +96,7 @@ public void discoverRule(RuleAST rule, GrammarAST ID,
 		if ( locals!=null ) {
 			r.locals = ScopeParser.parseTypedArgList(locals, locals.getText(), g.tool.errMgr);
 			r.locals.type = AttributeDict.DictType.LOCAL;
-			r.locals.ast = returns;
+			r.locals.ast = locals;
 		}
 
 		for (GrammarAST a : actions) {

File: tool/src/org/antlr/v4/semantics/RuleCollector.java
Patch:
@@ -96,7 +96,7 @@ public void discoverRule(RuleAST rule, GrammarAST ID,
 		if ( locals!=null ) {
 			r.locals = ScopeParser.parseTypedArgList(locals, locals.getText(), g.tool.errMgr);
 			r.locals.type = AttributeDict.DictType.LOCAL;
-			r.locals.ast = returns;
+			r.locals.ast = locals;
 		}
 
 		for (GrammarAST a : actions) {

File: runtime/Java/src/org/antlr/v4/runtime/misc/GraphicsSupport.java
Patch:
@@ -81,14 +81,14 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 	public static void saveImage(final JComponent comp, String fileName)
 		throws IOException, PrintException
 	{
-		if (fileName.endsWith(".ps") || fileName.endsWith(".eps") ) {
+		if ( fileName.endsWith(".ps") || fileName.endsWith(".eps") ) {
 			DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;
 			String mimeType = "application/postscript";
 			StreamPrintServiceFactory[] factories =
 				StreamPrintServiceFactory.lookupStreamPrintServiceFactories(flavor, mimeType);
 			System.out.println(Arrays.toString(factories));
-			FileOutputStream out = new FileOutputStream(fileName);
 			if (factories.length > 0) {
+				FileOutputStream out = new FileOutputStream(fileName);
 				PrintService service = factories[0].getPrintService(out);
 				SimpleDoc doc = new SimpleDoc(new Printable() {
 					@Override
@@ -115,6 +115,7 @@ public int print(Graphics g, PageFormat pf, int page) {
 				DocPrintJob job = service.createPrintJob();
 				PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet();
 				job.print(doc, attributes);
+				out.close();
 			}
 		} else {
 			// parrt: works with [image/jpeg, image/png, image/x-png, image/vnd.wap.wbmp, image/bmp, image/gif]

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -978,7 +978,7 @@ protected DFAState.PredPrediction[] getPredicatePredictions(BitSet ambigAlts,
 		}
 
 		if ( !containsPredicate ) {
-			pairs = null;
+			return null;
 		}
 
 //		System.out.println(Arrays.toString(altToPred)+"->"+pairs);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -978,7 +978,7 @@ protected DFAState.PredPrediction[] getPredicatePredictions(BitSet ambigAlts,
 		}
 
 		if ( !containsPredicate ) {
-			pairs = null;
+			return null;
 		}
 
 //		System.out.println(Arrays.toString(altToPred)+"->"+pairs);

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -115,7 +115,7 @@ public void setReturnValues(GrammarAST t) {
 	}
 
 	@Override
-	public void setTokenPrec(GrammarAST t, int alt) {
+	public void setTokenAssoc(GrammarAST t, int alt) {
 		ASSOC assoc = ASSOC.left;
 		if ( t instanceof GrammarASTWithOptions ) {
 			if ( ((GrammarASTWithOptions)t).getOptions()!=null ) {

File: tool/src/org/antlr/v4/parse/ActionSplitterListener.java
Patch:
@@ -34,7 +34,6 @@
 
 /** */
 public interface ActionSplitterListener {
-    void setQualifiedAttr(String expr, Token x, Token y, Token rhs);
     void qualifiedAttr(String expr, Token x, Token y);
 	void setAttr(String expr, Token x, Token rhs);
 	void attr(String expr, Token x);

File: tool/src/org/antlr/v4/semantics/UseDefAnalyzer.java
Patch:
@@ -81,8 +81,6 @@ public static boolean actionIsContextDependent(ActionAST actionAST) {
 			@Override
 			public void setNonLocalAttr(String expr, Token x, Token y, Token rhs) { dependent[0] = true; }
 			@Override
-			public void setQualifiedAttr(String expr, Token x, Token y, Token rhs) { dependent[0] = true; }
-			@Override
 			public void attr(String expr, Token x) {  dependent[0] = true; }
 		};
 		ActionSplitter splitter = new ActionSplitter(in, listener);

File: tool/test/org/antlr/v4/test/TestActionSplitter.java
Patch:
@@ -50,7 +50,7 @@ public class TestActionSplitter extends BaseTest {
         "$ID.text",		"['$ID.text'<" + ActionSplitter.QUALIFIED_ATTR + ">]",
         "$ID",		"['$ID'<" + ActionSplitter.ATTR + ">]",
         "$ID.getText()",		"['$ID'<" + ActionSplitter.ATTR + ">, '.getText()'<" + ActionSplitter.TEXT + ">]",
-        "$ID.text = \"test\";",		"['$ID.text = \"test\";'<" + ActionSplitter.SET_QUALIFIED_ATTR + ">]",
+        "$ID.text = \"test\";",		"['$ID.text'<" + ActionSplitter.QUALIFIED_ATTR + ">, ' = \"test\";'<" + ActionSplitter.TEXT + ">]",
         "$a.line == $b.line",		"['$a.line'<" + ActionSplitter.QUALIFIED_ATTR + ">, ' == '<" + ActionSplitter.TEXT + ">, '$b.line'<" + ActionSplitter.QUALIFIED_ATTR + ">]",
         "$r.tree",		"['$r.tree'<" + ActionSplitter.QUALIFIED_ATTR + ">]",
         "foo $a::n bar",		"['foo '<" + ActionSplitter.TEXT + ">, '$a::n'<" + ActionSplitter.NONLOCAL_ATTR + ">, ' bar'<" + ActionSplitter.TEXT + ">]",

File: tool/test/org/antlr/v4/test/TestActionTranslation.java
Patch:
@@ -143,8 +143,8 @@ public class TestActionTranslation extends BaseTest {
 	}
 
 	@Test public void testReturnValues() throws Exception {
-		String action = "$lab.e; $b.e;";
-		String expected = "((AContext)_localctx).lab.e; ((AContext)_localctx).b.e;";
+		String action = "$lab.e; $b.e; $y.e = \"\";";
+		String expected = "((AContext)_localctx).lab.e; ((AContext)_localctx).b.e; _localctx.y.e = \"\";";
 		testActions(attributeTemplate, "inline", action, expected);
 	}
 

File: tool/src/org/antlr/v4/parse/ActionSplitterListener.java
Patch:
@@ -34,7 +34,6 @@
 
 /** */
 public interface ActionSplitterListener {
-    void setQualifiedAttr(String expr, Token x, Token y, Token rhs);
     void qualifiedAttr(String expr, Token x, Token y);
 	void setAttr(String expr, Token x, Token rhs);
 	void attr(String expr, Token x);

File: tool/src/org/antlr/v4/semantics/UseDefAnalyzer.java
Patch:
@@ -81,8 +81,6 @@ public static boolean actionIsContextDependent(ActionAST actionAST) {
 			@Override
 			public void setNonLocalAttr(String expr, Token x, Token y, Token rhs) { dependent[0] = true; }
 			@Override
-			public void setQualifiedAttr(String expr, Token x, Token y, Token rhs) { dependent[0] = true; }
-			@Override
 			public void attr(String expr, Token x) {  dependent[0] = true; }
 		};
 		ActionSplitter splitter = new ActionSplitter(in, listener);

File: tool/test/org/antlr/v4/test/TestActionSplitter.java
Patch:
@@ -50,7 +50,7 @@ public class TestActionSplitter extends BaseTest {
         "$ID.text",		"['$ID.text'<" + ActionSplitter.QUALIFIED_ATTR + ">]",
         "$ID",		"['$ID'<" + ActionSplitter.ATTR + ">]",
         "$ID.getText()",		"['$ID'<" + ActionSplitter.ATTR + ">, '.getText()'<" + ActionSplitter.TEXT + ">]",
-        "$ID.text = \"test\";",		"['$ID.text = \"test\";'<" + ActionSplitter.SET_QUALIFIED_ATTR + ">]",
+        "$ID.text = \"test\";",		"['$ID.text'<" + ActionSplitter.QUALIFIED_ATTR + ">, ' = \"test\";'<" + ActionSplitter.TEXT + ">]",
         "$a.line == $b.line",		"['$a.line'<" + ActionSplitter.QUALIFIED_ATTR + ">, ' == '<" + ActionSplitter.TEXT + ">, '$b.line'<" + ActionSplitter.QUALIFIED_ATTR + ">]",
         "$r.tree",		"['$r.tree'<" + ActionSplitter.QUALIFIED_ATTR + ">]",
         "foo $a::n bar",		"['foo '<" + ActionSplitter.TEXT + ">, '$a::n'<" + ActionSplitter.NONLOCAL_ATTR + ">, ' bar'<" + ActionSplitter.TEXT + ">]",

File: tool/test/org/antlr/v4/test/TestActionTranslation.java
Patch:
@@ -143,8 +143,8 @@ public class TestActionTranslation extends BaseTest {
 	}
 
 	@Test public void testReturnValues() throws Exception {
-		String action = "$lab.e; $b.e;";
-		String expected = "((AContext)_localctx).lab.e; ((AContext)_localctx).b.e;";
+		String action = "$lab.e; $b.e; $y.e = \"\";";
+		String expected = "((AContext)_localctx).lab.e; ((AContext)_localctx).b.e; _localctx.y.e = \"\";";
 		testActions(attributeTemplate, "inline", action, expected);
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -59,8 +59,7 @@ public void enterEveryRule(ParserRuleContext ctx) {
 		@Override
 		public void visitTerminal(TerminalNode node) {
 			System.out.println("consume "+node.getSymbol()+" rule "+
-							   getRuleNames()[_ctx.getRuleIndex()]+
-							   " alt="+_ctx.altNum);
+							   getRuleNames()[_ctx.getRuleIndex()]);
 		}
 
 		@Override
@@ -561,7 +560,6 @@ public void enterOuterAlt(ParserRuleContext localctx, int altNum) {
 			}
 		}
 		_ctx = localctx;
-		_ctx.altNum = altNum;
 	}
 
 	public void enterRecursionRule(ParserRuleContext localctx, int ruleIndex) {

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -239,7 +239,7 @@ public void setAltASTPointers(LeftRecursiveRule r, RuleAST t) {
 		}
 		for (int i = 0; i < r.recOpAlts.size(); i++) {
 			LeftRecursiveRuleAltInfo altInfo = r.recOpAlts.getElement(i);
-			altInfo.altAST = (AltAST)opsBlk.getChild(i + 1);
+			altInfo.altAST = (AltAST)opsBlk.getChild(i);
 			altInfo.altAST.leftRecursiveAltInfo = altInfo;
 			altInfo.originalAltAST.leftRecursiveAltInfo = altInfo;
 //			altInfo.originalAltAST.parent = altInfo.altAST.parent;

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -59,8 +59,7 @@ public void enterEveryRule(ParserRuleContext ctx) {
 		@Override
 		public void visitTerminal(TerminalNode node) {
 			System.out.println("consume "+node.getSymbol()+" rule "+
-							   getRuleNames()[_ctx.getRuleIndex()]+
-							   " alt="+_ctx.altNum);
+							   getRuleNames()[_ctx.getRuleIndex()]);
 		}
 
 		@Override
@@ -561,7 +560,6 @@ public void enterOuterAlt(ParserRuleContext localctx, int altNum) {
 			}
 		}
 		_ctx = localctx;
-		_ctx.altNum = altNum;
 	}
 
 	public void enterRecursionRule(ParserRuleContext localctx, int ruleIndex) {

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -239,7 +239,7 @@ public void setAltASTPointers(LeftRecursiveRule r, RuleAST t) {
 		}
 		for (int i = 0; i < r.recOpAlts.size(); i++) {
 			LeftRecursiveRuleAltInfo altInfo = r.recOpAlts.getElement(i);
-			altInfo.altAST = (AltAST)opsBlk.getChild(i + 1);
+			altInfo.altAST = (AltAST)opsBlk.getChild(i);
 			altInfo.altAST.leftRecursiveAltInfo = altInfo;
 			altInfo.originalAltAST.leftRecursiveAltInfo = altInfo;
 //			altInfo.originalAltAST.parent = altInfo.altAST.parent;

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -285,6 +285,9 @@ public Grammar(String fileName, String grammarText, @Nullable ANTLRToolListener
 
 	protected void initTokenSymbolTables() {
 		tokenNameToTypeMap.put("EOF", Token.EOF);
+
+		// reserve a spot for the INVALID token
+		typeToTokenList.add(null);
 	}
 
     public void loadImportedGrammars() {

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -285,6 +285,9 @@ public Grammar(String fileName, String grammarText, @Nullable ANTLRToolListener
 
 	protected void initTokenSymbolTables() {
 		tokenNameToTypeMap.put("EOF", Token.EOF);
+
+		// reserve a spot for the INVALID token
+		typeToTokenList.add(null);
 	}
 
     public void loadImportedGrammars() {

File: tool/test/org/antlr/v4/test/TestBasicSemanticErrors.java
Patch:
@@ -38,7 +38,7 @@ public class TestBasicSemanticErrors extends BaseTest {
     static String[] U = {
         // INPUT
         "parser grammar U;\n" +
-        "options { foo=bar; k=\"3\";}\n" +
+        "options { foo=bar; k=3;}\n" +
         "tokens {\n" +
 		"        ID,\n" +
         "        f,\n" +

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorListener.java
Patch:
@@ -91,12 +91,14 @@ public void syntaxError(Recognizer<?, ?> recognizer,
      */
     void reportAmbiguity(@NotNull Parser recognizer,
 						 DFA dfa, int startIndex, int stopIndex,
+						 boolean exact,
 						 @NotNull BitSet ambigAlts,
 						 @NotNull ATNConfigSet configs);
 
 	void reportAttemptingFullContext(@NotNull Parser recognizer,
 									 @NotNull DFA dfa,
 									 int startIndex, int stopIndex,
+									 @Nullable BitSet conflictingAlts,
 									 @NotNull ATNConfigSet configs);
 
 	/** Called by the parser when it find a conflict that is resolved
@@ -108,5 +110,6 @@ void reportAttemptingFullContext(@NotNull Parser recognizer,
     void reportContextSensitivity(@NotNull Parser recognizer,
                                   @NotNull DFA dfa,
                                   int startIndex, int stopIndex,
+								  int prediction,
                                   @NotNull ATNConfigSet configs);
 }

File: runtime/Java/src/org/antlr/v4/runtime/BaseErrorListener.java
Patch:
@@ -53,6 +53,7 @@ public void reportAmbiguity(Parser recognizer,
 								DFA dfa,
 								int startIndex,
 								int stopIndex,
+								boolean exact,
 								BitSet ambigAlts,
 								ATNConfigSet configs)
 	{
@@ -63,6 +64,7 @@ public void reportAttemptingFullContext(Parser recognizer,
 											DFA dfa,
 											int startIndex,
 											int stopIndex,
+											BitSet conflictingAlts,
 											ATNConfigSet configs)
 	{
 	}
@@ -72,6 +74,7 @@ public void reportContextSensitivity(Parser recognizer,
 										 DFA dfa,
 										 int startIndex,
 										 int stopIndex,
+										 int prediction,
 										 ATNConfigSet configs)
 	{
 	}

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -1438,7 +1438,7 @@ private static BitSet getRepresentedAlts(ATNConfigSet configs) {
 	private static class SummarizingDiagnosticErrorListener extends DiagnosticErrorListener {
 
 		@Override
-		public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet ambigAlts, ATNConfigSet configs) {
+		public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {
 			if (!REPORT_AMBIGUITIES) {
 				return;
 			}
@@ -1452,7 +1452,7 @@ public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stop
 		}
 
 		@Override
-		public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {
+		public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {
 			if (!REPORT_FULL_CONTEXT) {
 				return;
 			}
@@ -1467,7 +1467,7 @@ public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startInd
 		}
 
 		@Override
-		public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, ATNConfigSet configs) {
+		public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {
 			if (!REPORT_CONTEXT_SENSITIVITY) {
 				return;
 			}

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -1094,6 +1094,9 @@ public FileParseResult parseFile(CharStream input, int currentPass, int thread)
 							sharedLexers[thread] = lexer;
                         }
 
+						lexer.removeErrorListeners();
+						lexer.addErrorListener(DescriptiveErrorListener.INSTANCE);
+
 						if (lexer.getInterpreter().decisionToDFA[0] == null) {
 							ATN atn = lexer.getATN();
 							for (int i = 0; i < lexer.getInterpreter().decisionToDFA.length; i++) {

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -331,7 +331,7 @@ public class TestPerformance extends BaseTest {
 	 * If {@code true}, the parsing operation will be parallelized across files;
 	 * otherwise the parsing will be parallelized across multiple iterations.
 	 */
-	private static final boolean FILE_GRANULARITY = false;
+	private static final boolean FILE_GRANULARITY = true;
 
 	/**
 	 * Number of parser threads to use.

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -849,7 +849,7 @@ public FileParseResult call() {
 					System.out.format("\tMode\tStates\tConfigs\tMode%n");
 					for (int i = 0; i < modeToDFA.length; i++) {
 						DFA dfa = modeToDFA[i];
-						if (dfa == null) {
+						if (dfa == null || dfa.states.isEmpty()) {
 							continue;
 						}
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -299,6 +299,7 @@ protected Graphics getComponentGraphics(Graphics g) {
 	@NotNull
 	protected static JDialog showInDialog(final TreeViewer viewer) {
 		final JDialog dialog = new JDialog();
+		dialog.setTitle("Parse Tree Inspector");
 
 		// Make new content panes
 		final Container mainPane = new JPanel(new BorderLayout(5,5));

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -178,7 +178,7 @@ public class TestPerformance extends BaseTest {
      * {@code true} to use {@link BailErrorStrategy}, {@code false} to use
      * {@link DefaultErrorStrategy}.
      */
-    private static final boolean BAIL_ON_ERROR = true;
+    private static final boolean BAIL_ON_ERROR = false;
 	/**
 	 * {@code true} to compute a checksum for verifying consistency across
 	 * optimizations and multiple passes.

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -431,7 +431,7 @@ public Handle elemList(@NotNull List<Handle> els) {
             boolean isRuleTrans = tr instanceof RuleTransition;
             if ( el.left.getStateType() == ATNState.BASIC &&
 				el.right.getStateType()== ATNState.BASIC &&
-				tr!=null && (isRuleTrans || tr.target == el.right) )
+				tr!=null && (isRuleTrans && ((RuleTransition)tr).followState == el.right || tr.target == el.right) )
 			{
 				// we can avoid epsilon edge to next el
 				if ( isRuleTrans ) ((RuleTransition)tr).followState = els.get(i+1).left;

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -46,6 +46,7 @@
 import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenSource;
 import org.antlr.v4.runtime.TokenStream;
+import org.antlr.v4.runtime.atn.ATN;
 import org.antlr.v4.runtime.atn.ATNConfig;
 import org.antlr.v4.runtime.atn.ATNConfigSet;
 import org.antlr.v4.runtime.atn.LexerATNSimulator;

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -69,7 +69,7 @@ public enum ErrorType {
 
 	// Grammar errors
 	SYNTAX_ERROR(50, "syntax error: <arg>", ErrorSeverity.ERROR),
-	RULE_REDEFINITION(51, "rule '<arg>' redefinition (ignoring); previous at line <arg2>", ErrorSeverity.ERROR),
+	RULE_REDEFINITION(51, "rule '<arg>' redefinition; previous at line <arg2>", ErrorSeverity.ERROR),
 	LEXER_RULES_NOT_ALLOWED(52, "lexer rule '<arg>' not allowed in parser", ErrorSeverity.ERROR),
 	PARSER_RULES_NOT_ALLOWED(53, "parser rule '<arg>' not allowed in lexer", ErrorSeverity.ERROR),
     REPEATED_PREQUEL(54, "repeated grammar prequel spec (option, token, or import); please merge", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ast/RuleAST.java
Patch:
@@ -36,9 +36,6 @@
 import org.antlr.v4.tool.Grammar;
 
 public class RuleAST extends GrammarASTWithOptions {
-	/** Kill redef of rules */
-	public boolean dead;
-
 	public RuleAST(RuleAST node) {
 		super(node);
 	}

File: tool/test/org/antlr/v4/test/TestCompositeGrammars.java
Patch:
@@ -641,9 +641,9 @@ public class TestCompositeGrammars extends BaseTest {
 			"s : a ;\n" +
 			"B : 'b' ;" + // defines B from inherited token space
 			"WS : (' '|'\\n') -> skip ;\n" ;
-		boolean ok = antlr("M.g4", "M.g4", master, false);
-		boolean expecting = true; // should be ok
-		assertEquals(expecting, ok);
+		ErrorQueue equeue = antlr("M.g4", "M.g4", master, false);
+		int expecting = 0; // should be ok
+		assertEquals(expecting, equeue.errors.size());
 	}
 
 	@Test public void testImportedRuleWithAction() throws Exception {

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -69,7 +69,7 @@ public enum ErrorType {
 
 	// Grammar errors
 	SYNTAX_ERROR(50, "syntax error: <arg>", ErrorSeverity.ERROR),
-	RULE_REDEFINITION(51, "rule '<arg>' redefinition (ignoring); previous at line <arg2>", ErrorSeverity.ERROR),
+	RULE_REDEFINITION(51, "rule '<arg>' redefinition; previous at line <arg2>", ErrorSeverity.ERROR),
 	LEXER_RULES_NOT_ALLOWED(52, "lexer rule '<arg>' not allowed in parser", ErrorSeverity.ERROR),
 	PARSER_RULES_NOT_ALLOWED(53, "parser rule '<arg>' not allowed in lexer", ErrorSeverity.ERROR),
     REPEATED_PREQUEL(54, "repeated grammar prequel spec (option, token, or import); please merge", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ast/RuleAST.java
Patch:
@@ -36,9 +36,6 @@
 import org.antlr.v4.tool.Grammar;
 
 public class RuleAST extends GrammarASTWithOptions {
-	/** Kill redef of rules */
-	public boolean dead;
-
 	public RuleAST(RuleAST node) {
 		super(node);
 	}

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -527,7 +527,7 @@ public List<GrammarRootAST> sortGrammarByTokenVocab(List<String> fileNames) {
 	/** Manually get option node from tree; return null if no defined. */
 	public static GrammarAST findOptionValueAST(GrammarRootAST root, String option) {
 		GrammarAST options = (GrammarAST)root.getFirstChildWithType(ANTLRParser.OPTIONS);
-		if ( options!=null ) {
+		if ( options!=null && options.getChildCount() > 0 ) {
 			for (Object o : options.getChildren()) {
 				GrammarAST c = (GrammarAST)o;
 				if ( c.getType() == ANTLRParser.ASSIGN &&

File: tool/test/org/antlr/v4/test/TestCompositeGrammars.java
Patch:
@@ -641,9 +641,9 @@ public class TestCompositeGrammars extends BaseTest {
 			"s : a ;\n" +
 			"B : 'b' ;" + // defines B from inherited token space
 			"WS : (' '|'\\n') -> skip ;\n" ;
-		boolean ok = antlr("M.g4", "M.g4", master, false);
-		boolean expecting = true; // should be ok
-		assertEquals(expecting, ok);
+		ErrorQueue equeue = antlr("M.g4", "M.g4", master, false);
+		int expecting = 0; // should be ok
+		assertEquals(expecting, equeue.errors.size());
 	}
 
 	@Test public void testImportedRuleWithAction() throws Exception {

File: tool/test/org/antlr/v4/test/TestToolSyntaxErrors.java
Patch:
@@ -42,14 +42,14 @@ public class TestToolSyntaxErrors extends BaseTest {
         "error(" + ErrorType.NO_RULES.code + "): A.g4::: grammar 'A' has no rules\n",
 
 		"A;",
-		"error(" + ErrorType.SYNTAX_ERROR.code + "): <string>:1:0: syntax error: 'A' came as a complete surprise to me\n",
+		"error(" + ErrorType.SYNTAX_ERROR.code + "): A.g4:1:0: syntax error: 'A' came as a complete surprise to me\n",
 
 		"grammar ;",
-		"error(" + ErrorType.SYNTAX_ERROR.code + "): <string>:1:8: syntax error: ';' came as a complete surprise to me while looking for an identifier\n",
+		"error(" + ErrorType.SYNTAX_ERROR.code + "): A.g4:1:8: syntax error: ';' came as a complete surprise to me while looking for an identifier\n",
 
 		"grammar A\n" +
 		"a : ID ;\n",
-		"error(" + ErrorType.SYNTAX_ERROR.code + "): <string>:2:0: syntax error: missing SEMI at 'a'\n",
+		"error(" + ErrorType.SYNTAX_ERROR.code + "): A.g4:2:0: syntax error: missing SEMI at 'a'\n",
 
 		"grammar A;\n" +
 		"a : ID ;;\n"+

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -756,7 +756,7 @@ public static String getGrammarTypeToFileNameSuffix(int type) {
 	 */
 	public static void setNodeOptions(GrammarAST node, GrammarAST options) {
 		GrammarASTWithOptions t = (GrammarASTWithOptions)node;
-		if ( t.getChildCount()==0 ) return;
+		if ( t.getChildCount()==0 || options.getChildCount()==0 ) return;
 		for (Object o : options.getChildren()) {
 			GrammarAST c = (GrammarAST)o;
 			if ( c.getType()==ANTLRParser.ASSIGN ) {

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -293,7 +293,7 @@ public GrammarRootAST extractImplicitLexer(Grammar combinedGrammar) {
 		// COPY OPTIONS
 		GrammarAST optionsRoot =
 			(GrammarAST)combinedAST.getFirstChildWithType(ANTLRParser.OPTIONS);
-		if ( optionsRoot!=null ) {
+		if ( optionsRoot!=null && optionsRoot.getChildCount()!=0 ) {
 			GrammarAST lexerOptionsRoot = (GrammarAST)adaptor.dupNode(optionsRoot);
 			lexerAST.addChild(lexerOptionsRoot);
 			GrammarAST[] options = optionsRoot.getChildren().toArray(new GrammarAST[0]);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1229,7 +1229,7 @@ protected void closureCheckingStopState(@NotNull ATNConfig config,
 	{
 		if ( debug ) System.out.println("closure("+config.toString(parser,true)+")");
 
-		if ( !closureBusy.add(config) ) return; // avoid infinite recursion
+		if ( depth != 0 && !closureBusy.add(config) ) return; // avoid infinite recursion
 
 		if ( config.state instanceof RuleStopState ) {
 			// We hit rule end. If we have context info, use it

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -756,7 +756,7 @@ public static String getGrammarTypeToFileNameSuffix(int type) {
 	 */
 	public static void setNodeOptions(GrammarAST node, GrammarAST options) {
 		GrammarASTWithOptions t = (GrammarASTWithOptions)node;
-		if ( t.getChildCount()==0 ) return;
+		if ( t.getChildCount()==0 || options.getChildCount()==0 ) return;
 		for (Object o : options.getChildren()) {
 			GrammarAST c = (GrammarAST)o;
 			if ( c.getType()==ANTLRParser.ASSIGN ) {

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -293,7 +293,7 @@ public GrammarRootAST extractImplicitLexer(Grammar combinedGrammar) {
 		// COPY OPTIONS
 		GrammarAST optionsRoot =
 			(GrammarAST)combinedAST.getFirstChildWithType(ANTLRParser.OPTIONS);
-		if ( optionsRoot!=null ) {
+		if ( optionsRoot!=null && optionsRoot.getChildCount()!=0 ) {
 			GrammarAST lexerOptionsRoot = (GrammarAST)adaptor.dupNode(optionsRoot);
 			lexerAST.addChild(lexerOptionsRoot);
 			GrammarAST[] options = optionsRoot.getChildren().toArray(new GrammarAST[0]);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1229,7 +1229,7 @@ protected void closureCheckingStopState(@NotNull ATNConfig config,
 	{
 		if ( debug ) System.out.println("closure("+config.toString(parser,true)+")");
 
-		if ( !closureBusy.add(config) ) return; // avoid infinite recursion
+		if ( depth != 0 && !closureBusy.add(config) ) return; // avoid infinite recursion
 
 		if ( config.state instanceof RuleStopState ) {
 			// We hit rule end. If we have context info, use it

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -132,7 +132,7 @@ public Parser(TokenStream input) {
 	/** reset the parser's state */
 	public void reset() {
 		if ( getInputStream()!=null ) getInputStream().seek(0);
-		_errHandler.endErrorCondition(this);
+		_errHandler.reset(this);
 		_ctx = null;
 		_syntaxErrors = 0;
 		_tracer = null;
@@ -149,7 +149,7 @@ public void reset() {
 	public Token match(int ttype) throws RecognitionException {
 		Token t = getCurrentToken();
 		if ( t.getType()==ttype ) {
-			_errHandler.endErrorCondition(this);
+			_errHandler.reportMatch(this);
 			consume();
 		}
 		else {
@@ -167,7 +167,7 @@ public Token match(int ttype) throws RecognitionException {
 	public Token matchWildcard() throws RecognitionException {
 		Token t = getCurrentToken();
 		if (t.getType() > 0) {
-			_errHandler.endErrorCondition(this);
+			_errHandler.reportMatch(this);
 			consume();
 		}
 		else {

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorStrategy.java
Patch:
@@ -55,9 +55,6 @@
  *  TODO: what to do about lexers
  */
 public interface ANTLRErrorStrategy {
-	/** To create missing tokens, we need a factory */
-	public void setTokenFactory(TokenFactory<?> factory);
-
 	/** When matching elements within alternative, use this method
 	 *  to recover. The default implementation uses single token
 	 *  insertion and deletion. If you want to change the way ANTLR

File: runtime/Java/src/org/antlr/v4/runtime/DefaultErrorStrategy.java
Patch:
@@ -98,7 +98,6 @@ public void reportError(Parser recognizer,
 //			System.err.print("[SPURIOUS] ");
 			return; // don't count spurious errors
 		}
-		recognizer._syntaxErrors++;
 		beginErrorCondition(recognizer);
 		if ( e instanceof NoViableAltException ) {
 			reportNoViableAlternative(recognizer, (NoViableAltException) e);
@@ -244,7 +243,6 @@ public void reportFailedPredicate(Parser recognizer,
 
 	public void reportUnwantedToken(Parser recognizer) {
 		if (errorRecoveryMode) return;
-		recognizer._syntaxErrors++;
 		beginErrorCondition(recognizer);
 
 		Token t = recognizer.getCurrentToken();
@@ -257,7 +255,6 @@ public void reportUnwantedToken(Parser recognizer) {
 
 	public void reportMissingToken(Parser recognizer) {
 		if (errorRecoveryMode) return;
-		recognizer._syntaxErrors++;
 		beginErrorCondition(recognizer);
 
 		Token t = recognizer.getCurrentToken();

File: runtime/Java/src/org/antlr/v4/runtime/RecognitionException.java
Patch:
@@ -92,10 +92,10 @@ protected final void setOffendingState(int offendingState) {
 	}
 
 	public IntervalSet getExpectedTokens() {
-        // TODO: do we really need this type check?
-		if ( recognizer!=null && recognizer instanceof Parser) {
-			return ((Parser) recognizer).getExpectedTokens();
+		if (recognizer != null) {
+			return recognizer.getATN().getExpectedTokens(offendingState, ctx);
 		}
+
 		return null;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSimulator.java
Patch:
@@ -118,7 +118,6 @@ public static ATN deserialize(@NotNull char[] data) {
 			data[i] = (char)(data[i] - 2);
 		}
 
-		ATN atn = new ATN();
 		List<IntervalSet> sets = new ArrayList<IntervalSet>();
 		int p = 0;
 		int version = toInt(data[p++]);
@@ -134,8 +133,9 @@ public static ATN deserialize(@NotNull char[] data) {
 			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
 		}
 
-		atn.grammarType = ATNType.values()[toInt(data[p++])];
-		atn.maxTokenType = toInt(data[p++]);
+		ATNType grammarType = ATNType.values()[toInt(data[p++])];
+		int maxTokenType = toInt(data[p++]);
+		ATN atn = new ATN(grammarType, maxTokenType);
 
 		//
 		// STATES

File: runtime/Java/src/org/antlr/v4/runtime/FailedPredicateException.java
Patch:
@@ -34,6 +34,8 @@
 import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Nullable;
 
+import java.util.Locale;
+
 /** A semantic predicate failed during validation.  Validation of predicates
  *  occurs when normally parsing the alternative just like matching a token.
  *  Disambiguating predicate evaluation occurs when we test a predicate during
@@ -84,6 +86,6 @@ private static String formatMessage(@Nullable String predicate, @Nullable String
 			return message;
 		}
 
-		return String.format("failed predicate: {%s}?", predicate);
+		return String.format(Locale.getDefault(), "failed predicate: {%s}?", predicate);
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/LexerNoViableAltException.java
Patch:
@@ -36,6 +36,8 @@
 import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.misc.Utils;
 
+import java.util.Locale;
+
 public class LexerNoViableAltException extends RecognitionException {
 	/** Matching attempted at what input index? */
 	private final int startIndex;
@@ -75,6 +77,6 @@ public String toString() {
 			symbol = Utils.escapeWhitespace(symbol, false);
 		}
 
-		return String.format("%s('%s')", LexerNoViableAltException.class.getSimpleName(), symbol);
+		return String.format(Locale.getDefault(), "%s('%s')", LexerNoViableAltException.class.getSimpleName(), symbol);
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSimulator.java
Patch:
@@ -39,6 +39,7 @@
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
 import java.util.List;
+import java.util.Locale;
 
 public abstract class ATNSimulator {
 	public static final int SERIALIZED_VERSION;
@@ -110,7 +111,7 @@ public static ATN deserialize(@NotNull char[] data) {
 		int p = 0;
 		int version = toInt(data[p++]);
 		if (version != SERIALIZED_VERSION) {
-			String reason = String.format("Could not deserialize ATN with version %d (expected %d).", version, SERIALIZED_VERSION);
+			String reason = String.format(Locale.getDefault(), "Could not deserialize ATN with version %d (expected %d).", version, SERIALIZED_VERSION);
 			throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));
 		}
 
@@ -420,7 +421,7 @@ public static ATNState stateFactory(int type, int ruleIndex) {
 			case ATNState.PLUS_LOOP_BACK : s = new PlusLoopbackState(); break;
 			case ATNState.LOOP_END : s = new LoopEndState(); break;
             default :
-				String message = String.format("The specified state type %d is not valid.", type);
+				String message = String.format(Locale.getDefault(), "The specified state type %d is not valid.", type);
 				throw new IllegalArgumentException(message);
 		}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNState.java
Patch:
@@ -36,6 +36,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * The following images show the relation of states and
@@ -182,7 +183,7 @@ public void addTransition(Transition e) {
 			epsilonOnlyTransitions = e.isEpsilon();
 		}
 		else if (epsilonOnlyTransitions != e.isEpsilon()) {
-			System.err.format("ATN state %d has both epsilon and non-epsilon transitions.\n", stateNumber);
+			System.err.format(Locale.getDefault(), "ATN state %d has both epsilon and non-epsilon transitions.\n", stateNumber);
 			epsilonOnlyTransitions = false;
 		}
 

File: tool/test/org/antlr/v4/test/TestSets.java
Patch:
@@ -29,6 +29,7 @@
  */
 package org.antlr.v4.test;
 
+import org.antlr.v4.tool.ErrorType;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -237,7 +238,7 @@ public TestSets() {
 			"a : A {System.out.println($A.text);} ;\n" +
 			"A : ~('a'|B) ;\n" +
 			"B : 'b' ;\n",
-			"error(134): T.g4:3:10: rule reference 'B' is not currently supported in a set\n"
+			"error(" + ErrorType.UNSUPPORTED_REFERENCE_IN_LEXER_SET.code + "): T.g4:3:10: rule reference 'B' is not currently supported in a set\n"
 		};
 		super.testErrors(pair, true);
 	}
@@ -249,7 +250,7 @@ public TestSets() {
 			"a : A {System.out.println($A.text);} ;\n" +
 			"A : ~('a'|'aa') ;\n" +
 			"B : 'b' ;\n",
-			"error(144): T.g4:3:10: multi-character literals are not allowed in lexer sets: 'aa'\n"
+			"error(" + ErrorType.INVALID_LITERAL_IN_LEXER_SET.code + "): T.g4:3:10: multi-character literals are not allowed in lexer sets: 'aa'\n"
 		};
 		super.testErrors(pair, true);
 	}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -142,7 +142,7 @@ public enum ErrorType {
 	 * Whitespace : [ \t]*;  // error 146
 	 * </pre>
 	 */
-	EPSILON_TOKEN(146, "non-fragment lexer rule '<arg>' can match the empty string", ErrorSeverity.ERROR),
+	EPSILON_TOKEN(146, "non-fragment lexer rule '<arg>' can match the empty string", ErrorSeverity.WARNING),
 	/**
 	 * Left-recursive rules must contain at least one alternative which is not
 	 * left recursive.

File: tool/test/org/antlr/v4/test/TestSymbolIssues.java
Patch:
@@ -162,8 +162,8 @@ public class TestSymbolIssues extends BaseTest {
 			"  B : C;\n" +
 			"  fragment C : A | (A C)?;",
 
-			"error(" + ErrorType.EPSILON_TOKEN.code + "): L.g4:3:0: non-fragment lexer rule 'WS' can match the empty string\n" +
-			"error(" + ErrorType.EPSILON_TOKEN.code + "): L.g4:5:2: non-fragment lexer rule 'B' can match the empty string\n"
+			"warning(" + ErrorType.EPSILON_TOKEN.code + "): L.g4:3:0: non-fragment lexer rule 'WS' can match the empty string\n" +
+			"warning(" + ErrorType.EPSILON_TOKEN.code + "): L.g4:5:2: non-fragment lexer rule 'B' can match the empty string\n"
 		};
 
 		testErrors(test, false);

File: tool/src/org/antlr/v4/codegen/CSharpTarget.java
Patch:
@@ -164,8 +164,6 @@ private void reportError(STMessage msg) {
 			}
 		});
 
-		STGroup parentGroup = new STGroupFile(CodeGenerator.TEMPLATE_ROOT+"/CSharp/CSharp"+STGroup.GROUP_FILE_EXTENSION);
-		result.importTemplates(parentGroup);
 		return result;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/UnbufferedCharStream.java
Patch:
@@ -169,7 +169,7 @@ protected void sync(int want) {
 	 */
 	protected int fill(int n) {
 		for (int i=0; i<n; i++) {
-			if (this.n > 0 && data[this.n - 1] == IntStream.EOF) {
+			if (this.n > 0 && data[this.n - 1] == (char)IntStream.EOF) {
 				return i;
 			}
 
@@ -206,7 +206,7 @@ public int LA(int i) {
         sync(i);
         int index = p + i - 1;
         if ( index < 0 ) throw new IndexOutOfBoundsException();
-		if ( index > n ) return IntStream.EOF;
+		if ( index >= n ) return IntStream.EOF;
         char c = data[index];
         if ( c==(char)IntStream.EOF ) return IntStream.EOF;
         return c;
@@ -315,7 +315,7 @@ public String getText(Interval interval) {
 
 		if (interval.a < bufferStartIndex || interval.b >= bufferStartIndex + n) {
 			throw new UnsupportedOperationException("interval "+interval+" outside buffer: "+
-			                    bufferStartIndex+".."+(bufferStartIndex+n));
+			                    bufferStartIndex+".."+(bufferStartIndex+n-1));
 		}
 		// convert from absolute to local index
 		int i = interval.a - bufferStartIndex;

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -51,7 +51,7 @@
 import java.util.Set;
 
 /** */
-public class Target {
+public abstract class Target {
 	/** For pure strings of Java 16-bit Unicode char, how can we display
 	 *  it in the target language as a literal.  Useful for dumping
 	 *  predicates and such that may refer to chars that need to be escaped
@@ -83,7 +83,7 @@ public class Target {
 		"void", "volatile", "while"
 	};
 
-	public Target(CodeGenerator gen, String language) {
+	protected Target(CodeGenerator gen, String language) {
 		targetCharValueEscape['\n'] = "\\n";
 		targetCharValueEscape['\r'] = "\\r";
 		targetCharValueEscape['\t'] = "\\t";

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -480,13 +480,14 @@ public int execDFA(@NotNull DFA dfa, @NotNull DFAState s0,
 										   " at DFA state "+s.stateNumber);
 				}
 
+				//TODO: recheck synchronization here. don't need if no sync
 				// recheck; another thread might have added edge
 				if ( s.edges == null || t >= s.edges.length || t < -1 || s.edges[t+1] == null ) {
 					alt = execATN(dfa, s, input, startIndex, outerContext);
 					// this adds edge even if next state is accept for
 					// same alt; e.g., s0-A->:s1=>2-B->:s2=>2
 					// TODO: This next stuff kills edge, but extra states remain. :(
-					if ( s.isAcceptState && alt!=-1 ) {
+					if ( s.isAcceptState && alt!=ATN.INVALID_ALT_NUMBER ) {
 						DFAState d = s.edges[input.LA(1)+1];
 						if ( d.isAcceptState && d.prediction==s.prediction ) {
 							// we can carve it out.
@@ -509,6 +510,7 @@ public int execDFA(@NotNull DFA dfa, @NotNull DFAState s0,
 				throw noViableAlt(input, outerContext, s.configs, startIndex);
 			}
 			s = target;
+			//TODO: can't be acceptstate here; rm that part of test?
 			if (!s.requiresFullContext && !s.isAcceptState && t != IntStream.EOF) {
 				input.consume();
 				t = input.LA(1);

File: runtime/Java/src/org/antlr/v4/runtime/UnbufferedCharStream.java
Patch:
@@ -207,7 +207,7 @@ public int LA(int i) {
         int index = p + i - 1;
         if ( index < 0 ) throw new IndexOutOfBoundsException();
 		if ( index > n ) return IntStream.EOF;
-        int c = data[index];
+        char c = data[index];
         if ( c==(char)IntStream.EOF ) return IntStream.EOF;
         return c;
     }

File: runtime/Java/src/org/antlr/v4/runtime/IntStream.java
Patch:
@@ -112,7 +112,7 @@ public interface IntStream {
 	 * If {@code i} represents a position at or beyond the end of the stream,
 	 * this method returns {@link #EOF}.
 	 * <p/>
-	 * The return value is unspecified if {@code i&lt;0} and fewer than {@code -i}
+	 * The return value is unspecified if {@code i<0} and fewer than {@code -i}
 	 * calls to {@link #consume consume()} have occurred from the beginning of
 	 * the stream before calling this method.
 	 *

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -93,7 +93,7 @@ public class Antlr4Mojo extends AbstractMojo {
 	/**
 	 * specify grammar file encoding; e.g., euc-jp
 	 */
-	@Parameter
+	@Parameter(property = "project.build.sourceEncoding")
 	protected String encoding;
 
 	/**

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -73,8 +73,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  * @author Sam Harwell
  */
 @Mojo(
-	name = "antlr",
-	defaultPhase = LifecyclePhase.PROCESS_SOURCES,
+	name = "antlr4",
+	defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 	requiresDependencyResolution = ResolutionScope.COMPILE,
 	requiresProject = true)
 public class Antlr4Mojo extends AbstractMojo {

File: tool/test/org/antlr/v4/test/TestSymbolIssues.java
Patch:
@@ -56,8 +56,8 @@ public class TestSymbolIssues extends BaseTest {
         // YIELDS
 			"error(94): A.g4:5:1: redefinition of 'members' action\n" +
 			"error(94): A.g4:7:1: redefinition of 'header' action\n" +
-			"warning(83): A.g4:2:10: illegal option 'opt'\n" +
-			"warning(83): A.g4:2:21: illegal option 'k'\n" +
+			"warning(83): A.g4:2:10: unsupported option 'opt'\n" +
+			"warning(83): A.g4:2:21: unsupported option 'k'\n" +
 			"error(94): A.g4:5:1: redefinition of 'members' action\n" +
 			"warning(125): A.g4:9:27: implicit definition of token 'X' in parser\n" +
 			"warning(125): A.g4:10:20: implicit definition of token 'Y' in parser\n" +

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -130,6 +130,7 @@ public enum ErrorType {
 	MODE_WITHOUT_RULES(145, "lexer mode '<arg>' must contain at least one non-fragment rule", ErrorSeverity.ERROR),
 	EPSILON_TOKEN(146, "non-fragment lexer rule '<arg>' can match the empty string", ErrorSeverity.ERROR),
 	NO_NON_LR_ALTS(147, "left recursive rule '<arg>' must contain an alternative which is not left recursive", ErrorSeverity.ERROR),
+	EPSILON_LR_FOLLOW(148, "left recursive rule '<arg>' contains a left recursive alternative which can be followed by the empty string", ErrorSeverity.ERROR),
 
 	// Backward incompatibility errors
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR 4", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -129,6 +129,7 @@ public enum ErrorType {
 	INVALID_LITERAL_IN_LEXER_SET(144, "multi-character literals are not allowed in lexer sets: <arg>", ErrorSeverity.ERROR),
 	MODE_WITHOUT_RULES(145, "lexer mode '<arg>' must contain at least one non-fragment rule", ErrorSeverity.ERROR),
 	EPSILON_TOKEN(146, "non-fragment lexer rule '<arg>' can match the empty string", ErrorSeverity.ERROR),
+	NO_NON_LR_ALTS(147, "left recursive rule '<arg>' must contain an alternative which is not left recursive", ErrorSeverity.ERROR),
 
 	// Backward incompatibility errors
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR 4", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -74,7 +74,7 @@ public enum ErrorType {
 	PARSER_RULES_NOT_ALLOWED(53, "parser rule '<arg>' not allowed in lexer", ErrorSeverity.ERROR),
     REPEATED_PREQUEL(54, "repeated grammar prequel spec (option, token, or import); please merge", ErrorSeverity.ERROR),
 	UNDEFINED_RULE_REF(56, "reference to undefined rule: <arg>", ErrorSeverity.ERROR),
-	UNDEFINED_RULE_IN_NONLOCAL_REF(57, "reference to undefined rule in nonlocal ref: <arg>::<arg2>", ErrorSeverity.ERROR),
+	UNDEFINED_RULE_IN_NONLOCAL_REF(57, "reference to undefined rule '<arg>' in non-local ref '<arg3>'", ErrorSeverity.ERROR),
     TOKEN_NAMES_MUST_START_UPPER(60, "token names must start with an uppercase letter: <arg>", ErrorSeverity.ERROR),
 	UNKNOWN_SIMPLE_ATTRIBUTE(63, "unknown attribute reference '<arg>' in '<arg2>'", ErrorSeverity.ERROR),
 	INVALID_RULE_PARAMETER_REF(64, "parameter '<arg>' of rule '<arg2>' is not accessible in this scope: <arg3>", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -128,6 +128,7 @@ public enum ErrorType {
 	LOCAL_CONFLICTS_WITH_RETVAL(143, "local '<arg>' conflicts with return value with same name", ErrorSeverity.ERROR),
 	INVALID_LITERAL_IN_LEXER_SET(144, "multi-character literals are not allowed in lexer sets: <arg>", ErrorSeverity.ERROR),
 	MODE_WITHOUT_RULES(145, "lexer mode '<arg>' must contain at least one non-fragment rule", ErrorSeverity.ERROR),
+	EPSILON_TOKEN(146, "non-fragment lexer rule '<arg>' can match the empty string", ErrorSeverity.ERROR),
 
 	// Backward incompatibility errors
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR 4", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -127,6 +127,7 @@ public enum ErrorType {
 	LOCAL_CONFLICTS_WITH_ARG(142, "local '<arg>' conflicts with parameter with same name", ErrorSeverity.ERROR),
 	LOCAL_CONFLICTS_WITH_RETVAL(143, "local '<arg>' conflicts with return value with same name", ErrorSeverity.ERROR),
 	INVALID_LITERAL_IN_LEXER_SET(144, "multi-character literals are not allowed in lexer sets: <arg>", ErrorSeverity.ERROR),
+	MODE_WITHOUT_RULES(145, "lexer mode '<arg>' must contain at least one non-fragment rule", ErrorSeverity.ERROR),
 
 	// Backward incompatibility errors
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR 4", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/semantics/AttributeChecks.java
Patch:
@@ -135,7 +135,7 @@ public void qualifiedAttr(String expr, Token x, Token y) {
 			if ( rref!=null ) {
 				if ( rref.args!=null && rref.args.get(y.getText())!=null ) {
 					g.tool.errMgr.grammarError(ErrorType.INVALID_RULE_PARAMETER_REF,
-											  g.fileName, y, y.getText(), expr);
+											  g.fileName, y, y.getText(), rref.name, expr);
 				}
 				else {
 					errMgr.grammarError(ErrorType.UNKNOWN_RULE_ATTRIBUTE,

File: tool/test/org/antlr/v4/test/TestSets.java
Patch:
@@ -237,7 +237,7 @@ public TestSets() {
 			"a : A {System.out.println($A.text);} ;\n" +
 			"A : ~('a'|B) ;\n" +
 			"B : 'b' ;\n",
-			"error(134): T.g4:3:10: rule reference B is not currently supported in a set\n"
+			"error(134): T.g4:3:10: rule reference 'B' is not currently supported in a set\n"
 		};
 		super.testErrors(pair, true);
 	}

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -187,13 +187,13 @@ else if ( t.getType()==ANTLRParser.STRING_LITERAL ) {
 					set.add(c);
 				}
 				else {
-					g.tool.errMgr.grammarError(ErrorType.INVALID_LEXER_SET_ELEMENT,
+					g.tool.errMgr.grammarError(ErrorType.INVALID_LITERAL_IN_LEXER_SET,
 											   g.fileName, t.getToken(), t.getText());
 
 				}
 			}
 			else if ( t.getType()==ANTLRParser.TOKEN_REF ) {
-				g.tool.errMgr.grammarError(ErrorType.INVALID_LEXER_SET_ELEMENT,
+				g.tool.errMgr.grammarError(ErrorType.UNSUPPORTED_REFERENCE_IN_LEXER_SET,
 										   g.fileName, t.getToken(), t.getText());
 			}
 		}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -116,7 +116,7 @@ public enum ErrorType {
 	LEXER_ACTION_PLACEMENT_ISSUE(132, "action in lexer rule <arg> must be last element of single outermost alt", ErrorSeverity.ERROR),
 	LEXER_COMMAND_PLACEMENT_ISSUE(133, "->command in lexer rule <arg> must be last element of single outermost alt", ErrorSeverity.ERROR),
 	USE_OF_BAD_WORD(134, "symbol <arg> conflicts with generated code in target language or runtime", ErrorSeverity.ERROR),
-	INVALID_LEXER_SET_ELEMENT(134, "lexer set element <arg> is invalid (either lexer rule ref or literal with > 1 char)", ErrorSeverity.ERROR),
+	UNSUPPORTED_REFERENCE_IN_LEXER_SET(134, "rule reference <arg> is not currently supported in a set", ErrorSeverity.ERROR),
 	ASSIGNMENT_TO_LIST_LABEL(135, "cannot assign a value to list label: $<arg>", ErrorSeverity.ERROR),
 	RETVAL_CONFLICTS_WITH_RULE(136, "return value <arg> conflicts with rule with same name", ErrorSeverity.ERROR),
 	RETVAL_CONFLICTS_WITH_TOKEN(137, "return value <arg> conflicts with token with same name", ErrorSeverity.ERROR),
@@ -126,6 +126,7 @@ public enum ErrorType {
 	LOCAL_CONFLICTS_WITH_TOKEN(141, "local <arg> conflicts with rule token same name", ErrorSeverity.ERROR),
 	LOCAL_CONFLICTS_WITH_ARG(142, "local <arg> conflicts with parameter with same name", ErrorSeverity.ERROR),
 	LOCAL_CONFLICTS_WITH_RETVAL(143, "local <arg> conflicts with return value with same name", ErrorSeverity.ERROR),
+	INVALID_LITERAL_IN_LEXER_SET(144, "multi-character literals are not allowed in lexer sets: <arg>", ErrorSeverity.ERROR),
 
 	// Backward incompatibility errors
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR 4", ErrorSeverity.ERROR),

File: tool/test/org/antlr/v4/test/TestAttributeChecks.java
Patch:
@@ -51,8 +51,7 @@ public class TestAttributeChecks extends BaseTest {
         "b[int d] returns [int e]\n" +
         "    :   {<inline2>}\n" +
         "    ;\n" +
-        "c   :   ;\n" +
-		"d	 :   ;\n";
+        "c   :   ;\n";
 
     String[] membersChecks = {
 		"$a",			"error(63): A.g4:2:11: unknown attribute reference a in $a\n",

File: tool/test/org/antlr/v4/test/TestSymbolIssues.java
Patch:
@@ -96,8 +96,8 @@ public class TestSymbolIssues extends BaseTest {
         "        :       ID ;",
 
         // YIELDS
-        "error(72): D.g4:4:21: label j conflicts with rule a's return value or parameter with same name\n" +
-		"error(76): D.g4:6:6: rule b's argument i conflicts a return value with same name\n"
+        "error(72): D.g4:4:21: label j conflicts with parameter with same name\n" +
+		"error(76): D.g4:6:22: return value i conflicts with parameter with same name\n"
     };
 
 	static String[] E = {

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -201,7 +201,7 @@ public void checkForRuleArgumentAndReturnValueConflicts(Rule r) {
 					errMgr.grammarError(
 						ErrorType.ARG_RETVAL_CONFLICT,
 						g.fileName,
-						((GrammarAST) r.ast.getChild(0)).token,
+						r.args.get(key).token != null ? r.args.get(key).token : ((GrammarAST) r.ast.getChild(0)).token,
 						key,
 						r.name);
 				}

File: tool/test/org/antlr/v4/test/TestSymbolIssues.java
Patch:
@@ -97,7 +97,7 @@ public class TestSymbolIssues extends BaseTest {
 
         // YIELDS
         "error(72): D.g4:4:21: label j conflicts with rule a's return value or parameter with same name\n" +
-		"error(76): D.g4:6:0: rule b's argument i conflicts a return value with same name\n"
+		"error(76): D.g4:6:6: rule b's argument i conflicts a return value with same name\n"
     };
 
 	static String[] E = {

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -115,6 +115,7 @@ public enum ErrorType {
 	LEXER_COMMAND_PLACEMENT_ISSUE(133, "->command in lexer rule <arg> must be last element of single outermost alt", ErrorSeverity.ERROR),
 	USE_OF_BAD_WORD(134, "symbol <arg> conflicts with generated code in target language or runtime", ErrorSeverity.ERROR),
 	INVALID_LEXER_SET_ELEMENT(134, "lexer set element <arg> is invalid (either lexer rule ref or literal with > 1 char)", ErrorSeverity.ERROR),
+	ASSIGNMENT_TO_LIST_LABEL(135, "cannot assign a value to list label: $<arg>", ErrorSeverity.ERROR),
 
 	// Backward incompatibility errors
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR 4", ErrorSeverity.ERROR),

File: tool/test/org/antlr/v4/test/TestAttributeChecks.java
Patch:
@@ -102,6 +102,7 @@ public class TestAttributeChecks extends BaseTest {
 		"$b.d",         "error(64): A.g4:7:6: cannot access rule d's parameter: $b.d\n",  // can't see rule ref's arg
 		"$d.text",      "error(63): A.g4:7:4: unknown attribute reference d in $d.text\n", // valid rule, but no ref
 		"$lab.d",		"error(64): A.g4:7:8: cannot access rule d's parameter: $lab.d\n",
+		"$ids = null;",	"error(135): A.g4:7:4: cannot assign a value to list label: $ids\n",
 	};
 
 	String[] finallyChecks = {

File: tool/test/org/antlr/v4/test/TestParserExec.java
Patch:
@@ -284,8 +284,8 @@ public void testPredicatedIfIfElse() throws Exception {
 	}
 
 	/**
-	 * This is a regression test for antlr/antlr4#110.
-	 * https://github.com/antlr/antlr4/issues/110
+	 * This is a regression test for antlr/antlr4#118.
+	 * https://github.com/antlr/antlr4/issues/118
 	 */
 	@Ignore("Performance impact of passing this test may not be worthwhile")
 	@Test public void testStartRuleWithoutEOF() {

File: tool/test/org/antlr/v4/test/TestFullContextParsing.java
Patch:
@@ -333,15 +333,15 @@ public void testExprAmbiguity() throws Exception {
 
 		String expecting =
 			"line 1:1 reportAttemptingFullContext d=1, input='+'\n" +
-			"line 1:1 reportContextSensitivity d=1, input='+'\n";
+			"line 1:2 reportContextSensitivity d=1, input='+b'\n";
 		assertEquals(expecting, this.stderrDuringParse);
 
 		found = execParser("T.g4", grammar, "TParser", "TLexer", "s", "a+b*c", true);
 		assertEquals("(expr a + (expr b * (expr c)))\n", found);
 
 		expecting =
 			"line 1:1 reportAttemptingFullContext d=1, input='+'\n" +
-			"line 1:1 reportContextSensitivity d=1, input='+'\n" +
+			"line 1:2 reportContextSensitivity d=1, input='+b'\n" +
 			"line 1:3 reportAttemptingFullContext d=1, input='*'\n" +
 			"line 1:5 reportAmbiguity d=1: ambigAlts={1, 2}, input='*c'\n";
 		assertEquals(expecting, this.stderrDuringParse);

File: runtime/Java/src/org/antlr/v4/runtime/misc/Array2DHashSet.java
Patch:
@@ -448,16 +448,16 @@ public String toTableString() {
 	}
 
 	/**
-	 * Return {@code o} as an instance of the element type {@link T}. If
-	 * {@code o} is non-null but known to not be an instance of {@link T}, this
+	 * Return {@code o} as an instance of the element type {@code T}. If
+	 * {@code o} is non-null but known to not be an instance of {@code T}, this
 	 * method returns {@code null}. The base implementation does not perform any
 	 * type checks; override this method to provide strong type checks for the
 	 * {@link #contains} and {@link #remove} methods to ensure the arguments to
 	 * the {@link EqualityComparator} for the set always have the expected
 	 * types.
 	 *
 	 * @param o the object to try and cast to the element type of the set
-	 * @return {@code o} if it could be an instance of {@link T}, otherwise
+	 * @return {@code o} if it could be an instance of {@code T}, otherwise
 	 * {@code null}.
 	 */
 	@SuppressWarnings("unchecked")

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTree.java
Patch:
@@ -31,6 +31,8 @@
 package org.antlr.v4.runtime.tree;
 
 import org.antlr.v4.runtime.Parser;
+import org.antlr.v4.runtime.RuleContext;
+import org.antlr.v4.runtime.Token;
 
 /** An interface to access the tree of {@link RuleContext} objects created
  *  during a parse that makes the data structure look like a simple parse tree.

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -30,6 +30,7 @@
 
 package org.antlr.v4.runtime.tree;
 
+import org.antlr.v4.runtime.TokenStream;
 import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.NotNull;
 

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -132,7 +132,7 @@ public class TestPerformance extends BaseTest {
 	 * {@code true} to specify the {@code -XdbgST} option when generating the
 	 * grammar.
 	 */
-	private static final boolean DEBUG_TEMPLATES = true;
+	private static final boolean DEBUG_TEMPLATES = false;
 	/**
 	 * {@code true} to specify the {@code -XdbgSTWait} option when generating the
 	 * grammar.

File: tool/src/org/antlr/v4/codegen/Target.java
Patch:
@@ -284,7 +284,8 @@ public String getTargetStringLiteralFromANTLRStringLiteral(
                     case    'f':
                     case    '\\':
                     case    'u':    // Assume unnnn
-                        sb.append('\\');    // Pass the escape through
+						sb.append('\\');    // Pass the escape through as double \\
+						sb.append('\\');    // so that Java leaves as \u0000 string not char
                         break;
                     default:
                         // Remove the escape by virtue of not adding it here

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -382,7 +382,9 @@ public void notifyErrorListeners(Token offendingToken, String msg,
 	 */
 	public Token consume() {
 		Token o = getCurrentToken();
-		getInputStream().consume();
+		if (o.getType() != EOF) {
+			getInputStream().consume();
+		}
 		boolean hasListener = _parseListeners != null && !_parseListeners.isEmpty();
 		if (_buildParseTrees || hasListener) {
 			if ( _errHandler.inErrorRecoveryMode(this) ) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSimulator.java
Patch:
@@ -381,9 +381,9 @@ public static ATNState stateFactory(int type, int stateNumber) {
 		ATNState s;
 		switch (type) {
 			case ATNState.INVALID_TYPE: return null;
-			case ATNState.BASIC : s = new ATNState(); break;
+			case ATNState.BASIC : s = new BasicState(); break;
 			case ATNState.RULE_START : s = new RuleStartState(); break;
-			case ATNState.BLOCK_START : s = new BlockStartState(); break;
+			case ATNState.BLOCK_START : s = new BasicBlockStartState(); break;
 			case ATNState.PLUS_BLOCK_START : s = new PlusBlockStartState(); break;
 			case ATNState.STAR_BLOCK_START : s = new StarBlockStartState(); break;
 			case ATNState.TOKEN_START : s = new TokensStartState(); break;

File: runtime/Java/src/org/antlr/v4/runtime/atn/BlockStartState.java
Patch:
@@ -31,6 +31,6 @@
 package org.antlr.v4.runtime.atn;
 
 /**  The start of a regular (...) block */
-public class BlockStartState extends DecisionState {
+public abstract class BlockStartState extends DecisionState {
 	public BlockEndState endState;
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionState.java
Patch:
@@ -30,7 +30,7 @@
 
 package org.antlr.v4.runtime.atn;
 
-public class DecisionState extends ATNState {
+public abstract class DecisionState extends ATNState {
 	public int decision = -1;
 	public boolean nonGreedy;
 }

File: tool/src/org/antlr/v4/automata/TailEpsilonRemover.java
Patch:
@@ -54,12 +54,12 @@ public TailEpsilonRemover(@NotNull ATN atn) {
 
 	@Override
 	public void visitState(@NotNull ATNState p) {
-		if (p.getClass() == ATNState.class && p.getNumberOfTransitions() == 1) {
+		if (p.getStateType() == ATNState.BASIC && p.getNumberOfTransitions() == 1) {
 			ATNState q = p.transition(0).target;
 			if (p.transition(0) instanceof RuleTransition) {
 				q = ((RuleTransition) p.transition(0)).followState;
 			}
-			if (q.getClass() == ATNState.class) {
+			if (q.getStateType() == ATNState.BASIC) {
 				// we have p-x->q for x in {rule, action, pred, token, ...}
 				// if edge out of q is single epsilon to block end
 				// we can strip epsilon p-x->q-eps->r

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -173,7 +173,7 @@ void checkForTypeMismatch(LabelElementPair prevLabelPair,
     }
 
     public void checkForLabelConflict(Rule r, GrammarAST labelID) {
-        ErrorType etype = ErrorType.INVALID;
+        ErrorType etype = null;
         Object arg2 = null;
         String name = labelID.getText();
         if ( nameToRuleMap.containsKey(name) ) {
@@ -188,7 +188,7 @@ else if ( (r.retvals!=null&&r.retvals.get(name)!=null) ||
             etype = ErrorType.LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL;
             arg2 = r.name;
         }
-        if ( etype!=ErrorType.INVALID ) {
+        if ( etype!=null ) {
             errMgr.grammarError(etype,g.fileName,labelID.token,name,arg2);
         }
     }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -44,8 +44,6 @@
  * @since 4.0
  */
 public enum ErrorType {
-    INVALID(0, "<INVALID>", ErrorSeverity.ERROR),
-
 	// Tool errors
 	CANNOT_WRITE_FILE(1, "cannot write file <arg>: <arg2>", ErrorSeverity.ERROR),
 	INVALID_CMDLINE_ARG(2, "unknown command-line option <arg>", ErrorSeverity.ERROR),

File: runtime/Java/src/org/antlr/v4/runtime/misc/Array2DHashSet.java
Patch:
@@ -275,13 +275,13 @@ public boolean containsAll(Collection<?> collection) {
 				if ( bucket==null ) continue;
 				for (Object o : bucket) {
 					if ( o==null ) break;
-					if ( !this.contains(o) ) return false;
+					if ( !this.containsFast(asElementType(o)) ) return false;
 				}
 			}
 		}
 		else {
 			for (Object o : collection) {
-				if ( !this.contains(o) ) return false;
+				if ( !this.containsFast(asElementType(o)) ) return false;
 			}
 		}
 		return true;

File: runtime/Java/src/org/antlr/v4/runtime/atn/OrderedATNConfigSet.java
Patch:
@@ -30,7 +30,6 @@
 
 package org.antlr.v4.runtime.atn;
 
-import org.antlr.v4.runtime.misc.Array2DHashSet;
 import org.antlr.v4.runtime.misc.ObjectEqualityComparator;
 
 /**
@@ -43,9 +42,9 @@ public OrderedATNConfigSet() {
 		this.configLookup = new LexerConfigHashSet();
 	}
 
-	public static class LexerConfigHashSet extends Array2DHashSet<ATNConfig> {
+	public static class LexerConfigHashSet extends AbstractConfigHashSet {
 		public LexerConfigHashSet() {
-			super(ObjectEqualityComparator.INSTANCE, 16, 2);
+			super(ObjectEqualityComparator.INSTANCE);
 		}
 	}
 }

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -219,7 +219,7 @@ public void grammarError(ErrorType etype,
 
 	}
 
-	public void leftRecursionCycles(String fileName, Collection cycles) {
+	public void leftRecursionCycles(String fileName, Collection<? extends Collection<Rule>> cycles) {
 		errors++;
 		ANTLRMessage msg = new LeftRecursionCyclesMessage(fileName, cycles);
 		tool.error(msg);

File: tool/src/org/antlr/v4/tool/LeftRecursionCyclesMessage.java
Patch:
@@ -33,9 +33,9 @@
 import java.util.Collection;
 
 public class LeftRecursionCyclesMessage extends ANTLRMessage {
-	public Collection cycles;
+	public Collection<? extends Collection<Rule>> cycles;
 
-	public LeftRecursionCyclesMessage(String fileName, Collection cycles) {
+	public LeftRecursionCyclesMessage(String fileName, Collection<? extends Collection<Rule>> cycles) {
 		super(ErrorType.LEFT_RECURSION_CYCLES, cycles);
 		this.cycles = cycles;
 		this.fileName = fileName;

File: tool/test/org/antlr/v4/test/TestIntervalSet.java
Patch:
@@ -370,7 +370,6 @@ public void testSingleElement() throws Exception {
 		s.add(50,55);
 		s.add(5,5);
 		String expecting = "[5, 20, 21, 22, 23, 24, 25, 50, 51, 52, 53, 54, 55]";
-		List foo = new ArrayList();
 		String result = String.valueOf(s.toList());
 		assertEquals(result, expecting);
 	}

File: tool/test/org/antlr/v4/test/TestTokenTypeAssignment.java
Patch:
@@ -156,7 +156,7 @@ public void testParserSimpleTokens() throws Exception {
 		Grammar g = new Grammar(
 				"grammar t;\n"+
 				"a : '\\n';\n");
-		Set literals = g.stringLiteralToTypeMap.keySet();
+		Set<?> literals = g.stringLiteralToTypeMap.keySet();
 		// must store literals how they appear in the antlr grammar
 		assertEquals("'\\n'", literals.toArray()[0]);
 	}
@@ -179,8 +179,7 @@ protected void checkSymbols(Grammar g,
 			tokens.remove(tokenName);
 		}
 		// make sure there are not any others (other than <EOF> etc...)
-		for (Iterator iter = tokens.iterator(); iter.hasNext();) {
-			String tokenName = (String) iter.next();
+		for (String tokenName : tokens) {
 			assertTrue("unexpected token name "+tokenName,
 					   g.getTokenType(tokenName) < Token.MIN_USER_TOKEN_TYPE);
 		}

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -179,7 +179,7 @@ public class TestPerformance extends BaseTest {
      * {@link Lexer#setInputStream} will be called to initialize it for each
      * source file. Otherwise, a new instance will be created for each file.
      */
-    private static final boolean REUSE_LEXER = true;
+    private static final boolean REUSE_LEXER = false;
 	/**
 	 * If {@code true}, a single DFA will be used for lexing which is shared
 	 * across all threads and files. Otherwise, each file will be lexed with its
@@ -192,7 +192,7 @@ public class TestPerformance extends BaseTest {
      * {@link Parser#setInputStream} will be called to initialize it for each
      * source file. Otherwise, a new instance will be created for each file.
      */
-    private static final boolean REUSE_PARSER = true;
+    private static final boolean REUSE_PARSER = false;
 	/**
 	 * If {@code true}, a single DFA will be used for parsing which is shared
 	 * across all threads and files. Otherwise, each file will be parsed with

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -61,6 +61,8 @@ public enum ErrorType {
 	INTERNAL_ERROR(20, "internal error: <arg> <arg2><if(exception&&verbose)>: <exception>" +
 				   "<stackTrace; separator=\"\\n\"><endif>", ErrorSeverity.ERROR),
 	TOKENS_FILE_SYNTAX_ERROR(21, ".tokens file syntax error <arg>:<arg2>", ErrorSeverity.ERROR),
+	STRING_TEMPLATE_WARNING(22, "template error: <arg> <arg2><if(exception&&verbose)>: <exception>" +
+				   "<stackTrace; separator=\"\\n\"><endif>", ErrorSeverity.WARNING),
 
 	// Code generation errors
 	MISSING_CODE_GEN_TEMPLATES(30, "can't find code generation templates: <arg>", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -56,7 +56,7 @@ public enum ErrorType {
 	CANNOT_OPEN_FILE(7, "cannot find or open file: <arg><if(exception&&verbose)>; reason: <exception><endif>", ErrorSeverity.ERROR),
 	FILE_AND_GRAMMAR_NAME_DIFFER(8, "grammar name <arg> and file name <arg2> differ", ErrorSeverity.ERROR),
 	BAD_OPTION_SET_SYNTAX(9, "invalid -Dname=value syntax: <arg>", ErrorSeverity.ERROR),
-	WARNING_TREATED_AS_ERROR(10, "warning treated as error", ErrorSeverity.ERROR),
+	WARNING_TREATED_AS_ERROR(10, "warning treated as error", ErrorSeverity.ERROR_ONE_OFF),
 
 	INTERNAL_ERROR(20, "internal error: <arg> <arg2><if(exception&&verbose)>: <exception>" +
 				   "<stackTrace; separator=\"\\n\"><endif>", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -131,13 +131,15 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 	public String genPackage = null;
 	public Map<String, String> grammarOptions = null;
 	public boolean warnings_are_errors = false;
+	public boolean longMessages = false;
 
     public static Option[] optionDefs = {
         new Option("outputDirectory",	"-o", OptionArgType.STRING, "specify output directory where all output is generated"),
         new Option("libDirectory",		"-lib", OptionArgType.STRING, "specify location of grammars, tokens files"),
         new Option("generate_ATN_dot",	"-atn", "generate rule augmented transition network diagrams"),
 		new Option("grammarEncoding",	"-encoding", OptionArgType.STRING, "specify grammar file encoding; e.g., euc-jp"),
 		new Option("msgFormat",			"-message-format", OptionArgType.STRING, "specify output style for messages in antlr, gnu, vs2005"),
+		new Option("longMessages",		"-long-messages", "show exception details when available for errors and warnings"),
 		new Option("gen_listener",		"-listener", "generate parse tree listener (default)"),
 		new Option("gen_listener",		"-no-listener", "don't generate parse tree listener"),
 		new Option("gen_visitor",		"-visitor", "generate parse tree visitor"),

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -101,6 +101,7 @@ public ST getMessageTemplate(ANTLRMessage msg) {
 		ST reportST = getReportFormat(msg.errorType.severity);
 		ST messageFormatST = getMessageFormat();
 
+		messageST.add("verbose", tool.longMessages);
 		if ( msg.args!=null ) { // fill in arg1, arg2, ...
 			for (int i=0; i<msg.args.length; i++) {
 				String attr = "arg";
@@ -109,6 +110,7 @@ public ST getMessageTemplate(ANTLRMessage msg) {
 			}
 			if ( msg.args.length<2 ) messageST.add("arg2", null); // some messages ref arg2
 		}
+
 		if ( msg.getCause()!=null ) {
 			messageST.add("exception", msg.getCause());
 			messageST.add("stackTrace", msg.getCause().getStackTrace());

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -53,13 +53,13 @@ public enum ErrorType {
 	ERROR_READING_TOKENS_FILE(4, "cannot find tokens file <arg>: <arg2>", ErrorSeverity.ERROR),
 	DIR_NOT_FOUND(5, "directory not found: <arg>", ErrorSeverity.ERROR),
 	OUTPUT_DIR_IS_FILE(6, "output directory is a file: <arg>", ErrorSeverity.ERROR),
-	CANNOT_OPEN_FILE(7, "cannot find or open file: <arg><if(exception)>; reason: <exception><endif>", ErrorSeverity.ERROR),
+	CANNOT_OPEN_FILE(7, "cannot find or open file: <arg><if(exception&&verbose)>; reason: <exception><endif>", ErrorSeverity.ERROR),
 	FILE_AND_GRAMMAR_NAME_DIFFER(8, "grammar name <arg> and file name <arg2> differ", ErrorSeverity.ERROR),
 	BAD_OPTION_SET_SYNTAX(9, "invalid -Dname=value syntax: <arg>", ErrorSeverity.ERROR),
 	WARNING_TREATED_AS_ERROR(10, "warning treated as error", ErrorSeverity.ERROR),
 
-	INTERNAL_ERROR(20, "internal error: <arg> <arg2><if(exception)>: <exception><endif>" +
-				   "<stackTrace; separator=\"\\n\">", ErrorSeverity.ERROR),
+	INTERNAL_ERROR(20, "internal error: <arg> <arg2><if(exception&&verbose)>: <exception>" +
+				   "<stackTrace; separator=\"\\n\"><endif>", ErrorSeverity.ERROR),
 	TOKENS_FILE_SYNTAX_ERROR(21, ".tokens file syntax error <arg>:<arg2>", ErrorSeverity.ERROR),
 
 	// Code generation errors

File: tool/src/org/antlr/v4/tool/ast/BlockAST.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.tool.ast;
 
 import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.Tree;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -45,7 +44,7 @@ public class BlockAST extends GrammarASTWithOptions implements RuleElementAST {
     public static final Map<String, String> defaultLexerBlockOptions =
             new HashMap<String, String>();
 
-	public BlockAST(GrammarAST node) {
+	public BlockAST(BlockAST node) {
 		super(node);
 	}
 
@@ -55,7 +54,7 @@ public BlockAST(GrammarAST node) {
 	public BlockAST(int type, Token t, String text) { super(type,t,text); }
 
 	@Override
-	public Tree dupNode() { return new BlockAST(this); }
+	public BlockAST dupNode() { return new BlockAST(this); }
 
 	@Override
 	public Object visit(GrammarASTVisitor v) { return v.visit(this); }

File: tool/src/org/antlr/v4/tool/ast/GrammarAST.java
Patch:
@@ -213,7 +213,7 @@ public void setText(String text) {
 //	}
 
 	@Override
-    public Tree dupNode() {
+    public GrammarAST dupNode() {
         return new GrammarAST(this);
     }
 

File: tool/src/org/antlr/v4/tool/ast/OptionalBlockAST.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.tool.ast;
 
 import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.Tree;
 
 public class OptionalBlockAST extends GrammarAST implements RuleElementAST, QuantifierAST {
 	private final boolean _greedy;
@@ -52,7 +51,7 @@ public boolean isGreedy() {
 	}
 
 	@Override
-	public Tree dupNode() { return new OptionalBlockAST(this); }
+	public OptionalBlockAST dupNode() { return new OptionalBlockAST(this); }
 
 	@Override
 	public Object visit(GrammarASTVisitor v) { return v.visit(this); }

File: tool/src/org/antlr/v4/tool/ast/PlusBlockAST.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.tool.ast;
 
 import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.Tree;
 
 public class PlusBlockAST extends GrammarAST implements RuleElementAST, QuantifierAST {
 	private final boolean _greedy;
@@ -52,7 +51,7 @@ public boolean isGreedy() {
 	}
 
 	@Override
-	public Tree dupNode() { return new PlusBlockAST(this); }
+	public PlusBlockAST dupNode() { return new PlusBlockAST(this); }
 
 	@Override
 	public Object visit(GrammarASTVisitor v) { return v.visit(this); }

File: tool/src/org/antlr/v4/tool/ast/PredAST.java
Patch:
@@ -31,10 +31,9 @@
 package org.antlr.v4.tool.ast;
 
 import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.Tree;
 
 public class PredAST extends ActionAST {
-	public PredAST(GrammarAST node) {
+	public PredAST(PredAST node) {
 		super(node);
 	}
 
@@ -43,7 +42,7 @@ public PredAST(GrammarAST node) {
     public PredAST(int type, Token t) { super(type, t); }
 
 	@Override
-	public Tree dupNode() { return new PredAST(this); }
+	public PredAST dupNode() { return new PredAST(this); }
 
 	@Override
 	public Object visit(GrammarASTVisitor v) { return v.visit(this); }

File: tool/src/org/antlr/v4/tool/ast/RuleAST.java
Patch:
@@ -39,7 +39,7 @@ public class RuleAST extends GrammarASTWithOptions {
 	/** Kill redef of rules */
 	public boolean dead;
 
-	public RuleAST(GrammarAST node) {
+	public RuleAST(RuleAST node) {
 		super(node);
 	}
 
@@ -58,7 +58,7 @@ public String getRuleName() {
 	}
 
 	@Override
-	public Tree dupNode() { return new RuleAST(this); }
+	public RuleAST dupNode() { return new RuleAST(this); }
 
 	public ActionAST getLexerAction() {
 		Tree blk = getFirstChildWithType(ANTLRParser.BLOCK);

File: tool/src/org/antlr/v4/tool/ast/RuleRefAST.java
Patch:
@@ -32,10 +32,9 @@
 
 import org.antlr.runtime.CommonToken;
 import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.Tree;
 
 public class RuleRefAST extends GrammarASTWithOptions implements RuleElementAST {
-	public RuleRefAST(GrammarAST node) {
+	public RuleRefAST(RuleRefAST node) {
 		super(node);
 	}
 
@@ -45,7 +44,7 @@ public RuleRefAST(GrammarAST node) {
 
 	/** Dup token too since we overwrite during LR rule transform */
 	@Override
-	public Tree dupNode() {
+	public RuleRefAST dupNode() {
 		RuleRefAST r = new RuleRefAST(this);
 		// In LR transform, we alter original token stream to make e -> e[n]
 		// Since we will be altering the dup, we need dup to have the

File: tool/src/org/antlr/v4/tool/ast/StarBlockAST.java
Patch:
@@ -31,7 +31,6 @@
 package org.antlr.v4.tool.ast;
 
 import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.Tree;
 
 public class StarBlockAST extends GrammarAST implements RuleElementAST, QuantifierAST {
 	private final boolean _greedy;
@@ -52,7 +51,7 @@ public boolean isGreedy() {
 	}
 
 	@Override
-	public Tree dupNode() { return new StarBlockAST(this); }
+	public StarBlockAST dupNode() { return new StarBlockAST(this); }
 
 	@Override
 	public Object visit(GrammarASTVisitor v) { return v.visit(this); }

File: tool/src/org/antlr/v4/tool/ast/TerminalAST.java
Patch:
@@ -31,11 +31,10 @@
 package org.antlr.v4.tool.ast;
 
 import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.Tree;
 
 public class TerminalAST extends GrammarASTWithOptions implements RuleElementAST {
 
-	public TerminalAST(GrammarAST node) {
+	public TerminalAST(TerminalAST node) {
 		super(node);
 	}
 
@@ -44,7 +43,7 @@ public TerminalAST(GrammarAST node) {
     public TerminalAST(int type, Token t) { super(type, t); }
 
 	@Override
-	public Tree dupNode() { return new TerminalAST(this); }
+	public TerminalAST dupNode() { return new TerminalAST(this); }
 
 	@Override
 	public Object visit(GrammarASTVisitor v) { return v.visit(this); }

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -124,7 +124,6 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 	public boolean launch_ST_inspector = false;
     public boolean force_atn = false;
     public boolean log = false;
-	public boolean verbose_dfa = false;
 	public boolean gen_listener = true;
 	public boolean gen_visitor = false;
 	public boolean gen_dependencies = false;
@@ -149,7 +148,6 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
         new Option("launch_ST_inspector", "-XdbgST", "launch StringTemplate visualizer on generated code"),
         new Option("force_atn",			"-Xforce-atn", "use the ATN simulator for all predictions"),
 		new Option("log",   			"-Xlog", "dump lots of logging info to antlr-timestamp.log"),
-		new Option("verbose_dfa",   	"-Xverbose-dfa", "add config set to DFA states"),
 	};
 
 	// helper vars for option management

File: tool/src/org/antlr/v4/tool/DOTGenerator.java
Patch:
@@ -141,7 +141,7 @@ protected String getStateLabel(DFAState s) {
 		if ( s.requiresFullContext) {
 			buf.append("^");
 		}
-		if ( grammar!=null && grammar.tool.verbose_dfa ) {
+		if ( grammar!=null ) {
 			Set<Integer> alts = s.getAltSet();
 			if ( alts!=null ) {
 				buf.append("\\n");

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -121,7 +121,6 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 	public boolean generate_ATN_dot = false;
 	public String grammarEncoding = null; // use default locale's encoding
 	public String msgFormat = "antlr";
-	public boolean saveLexer = false;
 	public boolean launch_ST_inspector = false;
     public boolean force_atn = false;
     public boolean log = false;
@@ -147,7 +146,6 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 		new Option("gen_dependencies",	"-depend", "generate file dependencies"),
 		new Option("",					"-D<option>=value", "set/override a grammar-level option"),
 		new Option("warnings_are_errors", "-Werror", "treat warnings as errors"),
-		new Option("saveLexer",			"-Xsave-lexer", "save temp lexer file created for combined grammars"),
         new Option("launch_ST_inspector", "-XdbgST", "launch StringTemplate visualizer on generated code"),
         new Option("force_atn",			"-Xforce-atn", "use the ATN simulator for all predictions"),
 		new Option("log",   			"-Xlog", "dump lots of logging info to antlr-timestamp.log"),

File: runtime/Java/src/org/antlr/v4/runtime/DefaultErrorStrategy.java
Patch:
@@ -39,6 +39,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.atn.StarLoopbackState;
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.runtime.misc.NotNull;
+import org.antlr.v4.runtime.misc.Pair;
 
 /** This is the default error handling mechanism for ANTLR parsers
  *  and tree parsers.
@@ -380,7 +381,7 @@ protected Token getMissingSymbol(Parser recognizer) {
 			current = lookback;
 		}
 		return
-			_factory.create(current.getTokenSource(), expectedTokenType, tokenText,
+			_factory.create(new Pair<TokenSource, CharStream>(current.getTokenSource(), current.getTokenSource().getInputStream()), expectedTokenType, tokenText,
 							Token.DEFAULT_CHANNEL,
 							-1, -1,
 							current.getLine(), current.getCharPositionInLine());

File: runtime/Java/src/org/antlr/v4/runtime/TokenFactory.java
Patch:
@@ -29,6 +29,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 package org.antlr.v4.runtime;
 
+import org.antlr.v4.runtime.misc.Pair;
+
 /** The default mechanism for creating tokens. It's used by default in Lexer and
  *  the error handling strategy (to create missing tokens).  Notifying the parser
  *  of a new factory means that it notifies it's token source and error strategy.
@@ -38,7 +40,7 @@ public interface TokenFactory<Symbol extends Token> {
 	 *  error handling strategy. If text!=null, than the start and stop positions
 	 *  are wiped to -1 in the text override is set in the CommonToken.
 	 */
-	Symbol create(TokenSource source, int type, String text,
+	Symbol create(Pair<TokenSource, CharStream> source, int type, String text,
 				  int channel, int start, int stop,
 				  int line, int charPositionInLine);
 

File: tool/test/org/antlr/v4/test/TestParserExec.java
Patch:
@@ -37,14 +37,14 @@ public class TestParserExec extends BaseTest {
 	@Test public void testLabels() throws Exception {
 		String grammar =
 			"grammar T;\n" +
-			"a : b1=b b2+=b*;\n" +
+			"a : b1=b b2+=b* b3+=';' ;\n" +
 			"b : id=ID val+=INT*;\n" +
 			"ID : 'a'..'z'+ ;\n" +
 			"INT : '0'..'9'+;\n" +
 			"WS : (' '|'\\n') -> skip ;\n";
 
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "a",
-								  "abc 34", false);
+								  "abc 34;", false);
 		assertEquals("", found);
 		assertEquals(null, stderrDuringParse);
 	}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -115,6 +115,7 @@ public enum ErrorType {
 	LEXER_ACTION_PLACEMENT_ISSUE(132, "action in lexer rule <arg> must be last element of single outermost alt", ErrorSeverity.ERROR),
 	LEXER_COMMAND_PLACEMENT_ISSUE(133, "->command in lexer rule <arg> must be last element of single outermost alt", ErrorSeverity.ERROR),
 	USE_OF_BAD_WORD(134, "symbol <arg> conflicts with generated code in target language or runtime", ErrorSeverity.ERROR),
+	INVALID_LEXER_SET_ELEMENT(134, "lexer set element <arg> is invalid (either lexer rule ref or literal with > 1 char)", ErrorSeverity.ERROR),
 
 	// Backward incompatibility errors
 	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR v4", ErrorSeverity.ERROR),

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4ErrorLog.java
Patch:
@@ -55,7 +55,7 @@ public Antlr4ErrorLog(Log log) {
 
     /**
      * Sends an informational message to the Maven log sink.
-     * @param s The message to send to Maven
+     * @param message The message to send to Maven
      */
     @Override
     public void info(String message) {

File: antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java
Patch:
@@ -466,7 +466,7 @@ private void processGrammarFiles(List<String> args, File sourceDirectory, File o
             throws TokenStreamException, RecognitionException, IOException, InclusionScanException {
         // Which files under the source set should we be looking for as grammar files
         //
-        SourceMapping mapping = new SuffixMapping("g4", Collections.EMPTY_SET);
+        SourceMapping mapping = new SuffixMapping("g4", Collections.<String>emptySet());
 
         // What are the sets of includes (defaulted or otherwise).
         //

File: runtime/Java/src/org/antlr/v4/runtime/tree/TerminalNodeImpl.java
Patch:
@@ -75,8 +75,6 @@ public String toStringTree(Parser parser) {
 		return toString();
 	}
 
-	public boolean isErrorNode() { return this instanceof ErrorNode; }
-
 	@Override
 	public String toString() {
 			if ( symbol.getType() == Token.EOF ) return "<EOF>";

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -179,7 +179,7 @@ public void integrateImportedGrammars(Grammar rootGrammar) {
 			}
 
 			List<GrammarAST> all_actionRoots = new ArrayList<GrammarAST>();
-			List<GrammarAST> imp_actionRoots = imp.ast.getNodesWithType(ANTLRParser.AT);
+			List<GrammarAST> imp_actionRoots = imp.ast.getAllChildrenWithType(ANTLRParser.AT);
 			if ( actionRoots!=null ) all_actionRoots.addAll(actionRoots);
 			all_actionRoots.addAll(imp_actionRoots);
 

File: tool/src/org/antlr/v4/codegen/CodeGenPipeline.java
Patch:
@@ -54,7 +54,7 @@ public void process() {
 		idTypes.add(ANTLRParser.TOKEN_REF);
 		List<GrammarAST> idNodes = g.ast.getNodesWithType(idTypes);
 		for (GrammarAST idNode : idNodes) {
-			if ( gen.target.grammarSymbolCausesIssueInGeneratedCode(idNode.getText()) ) {
+			if ( gen.target.grammarSymbolCausesIssueInGeneratedCode(idNode) ) {
 				g.tool.errMgr.grammarError(ErrorType.USE_OF_BAD_WORD,
 										   g.fileName, idNode.getToken(),
 										   idNode.getText());

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -347,8 +347,7 @@ protected void checkElementIsOuterMostInSingleAlt(GrammarAST tree) {
 		boolean outerMostAlt = blk.parent.getType() == RULE;
 		Tree rule = tree.getAncestor(RULE);
 		String fileName = tree.getToken().getInputStream().getSourceName();
-		if ( !outerMostAlt || tree.getChildIndex() != alt.getChildCount()-1 ||
-			 blk.getChildCount()>1 )
+		if ( !outerMostAlt || blk.getChildCount()>1 )
 		{
 			ErrorType e = ErrorType.LEXER_COMMAND_PLACEMENT_ISSUE;
 			if ( tree.getType() == ACTION ) e = ErrorType.LEXER_ACTION_PLACEMENT_ISSUE;

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -151,7 +151,7 @@ void identifyStartRules(SymbolCollector collector) {
 	void assignLexerTokenTypes(Grammar g, List<GrammarAST> tokensDefs) {
 		Grammar G = g.getOutermostGrammar(); // put in root, even if imported
 		for (GrammarAST def : tokensDefs) {
-			if ( def.getType()== ANTLRParser.ID ) G.defineTokenName(def.getText());
+			if ( def.getType()== ANTLRParser.TOKEN_REF ) G.defineTokenName(def.getText());
 		}
 
 		/* Define token types for nonfragment rules which do not include a 'type(...)'

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -347,8 +347,7 @@ protected void checkElementIsOuterMostInSingleAlt(GrammarAST tree) {
 		boolean outerMostAlt = blk.parent.getType() == RULE;
 		Tree rule = tree.getAncestor(RULE);
 		String fileName = tree.getToken().getInputStream().getSourceName();
-		if ( !outerMostAlt || tree.getChildIndex() != alt.getChildCount()-1 ||
-			 blk.getChildCount()>1 )
+		if ( !outerMostAlt || blk.getChildCount()>1 )
 		{
 			ErrorType e = ErrorType.LEXER_COMMAND_PLACEMENT_ISSUE;
 			if ( tree.getType() == ACTION ) e = ErrorType.LEXER_ACTION_PLACEMENT_ISSUE;

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -151,7 +151,7 @@ void identifyStartRules(SymbolCollector collector) {
 	void assignLexerTokenTypes(Grammar g, List<GrammarAST> tokensDefs) {
 		Grammar G = g.getOutermostGrammar(); // put in root, even if imported
 		for (GrammarAST def : tokensDefs) {
-			if ( def.getType()== ANTLRParser.ID ) G.defineTokenName(def.getText());
+			if ( def.getType()== ANTLRParser.TOKEN_REF ) G.defineTokenName(def.getText());
 		}
 
 		/* Define token types for nonfragment rules which do not include a 'type(...)'

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -116,6 +116,9 @@ public enum ErrorType {
 	LEXER_COMMAND_PLACEMENT_ISSUE(133, "->command in lexer rule <arg> must be last element of single outermost alt", ErrorSeverity.ERROR),
 	USE_OF_BAD_WORD(134, "symbol <arg> conflicts with generated code in target language or runtime", ErrorSeverity.ERROR),
 
+	// Backward incompatibility errors
+	V3_TREE_GRAMMAR(200, "tree grammars are not supported in ANTLR v4", ErrorSeverity.ERROR_ONE_OFF),
+
     // Dependency sorting errors
 
     /** t1.g4 -> t2.g4 -> t3.g4 ->t1.g4 */

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -238,7 +238,7 @@ public Grammar(String fileName, String grammarText, @Nullable ANTLRToolListener
 		org.antlr.runtime.ANTLRStringStream in = new org.antlr.runtime.ANTLRStringStream(grammarText);
 		in.name = fileName;
 
-		this.ast = tool.load(in);
+		this.ast = tool.load(fileName, in);
 		if ( ast==null ) return;
 
 		// ensure each node has pointer to surrounding grammar

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -779,7 +779,7 @@ public void help() {
 	}
 
     public void log(@Nullable String component, String msg) { logMgr.log(component, msg); }
-    public void log(String msg) { log(msg); }
+    public void log(String msg) { log(null, msg); }
 
 	public int getNumErrors() { return errMgr.getNumErrors(); }
 

File: tool/src/org/antlr/v4/parse/ActionSplitterListener.java
Patch:
@@ -41,6 +41,5 @@ public interface ActionSplitterListener {
 	void setNonLocalAttr(String expr, Token x, Token y, Token rhs);
 	void nonLocalAttr(String expr, Token x, Token y);
 
-    void unknownSyntax(Token t);
     void text(String text);
 }

File: tool/src/org/antlr/v4/tool/ErrorSeverity.java
Patch:
@@ -38,7 +38,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public enum ErrorSeverity {
     INFO    ("info"),
     WARNING ("warning"),
-    ERROR   ("error"),
+	ERROR   ("error"),
+	ERROR_ONE_OFF   ("error"),
     FATAL   ("fatal"),  // TODO: add fatal for which phase? sync with ErrorManager
     ;
 

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -279,7 +279,7 @@ public GrammarRootAST extractImplicitLexer(Grammar combinedGrammar) {
 		GrammarRootAST combinedAST = combinedGrammar.ast;
 		//tool.log("grammar", "before="+combinedAST.toStringTree());
 		GrammarASTAdaptor adaptor = new GrammarASTAdaptor(combinedAST.token.getInputStream());
-		GrammarAST[] elements = ((List<?>)combinedAST.getChildren()).toArray(new GrammarAST[0]);
+		GrammarAST[] elements = combinedAST.getChildren().toArray(new GrammarAST[0]);
 
 		// MAKE A GRAMMAR ROOT and ID
 		String lexerName = combinedAST.getChild(0).getText()+"Lexer";
@@ -295,7 +295,7 @@ public GrammarRootAST extractImplicitLexer(Grammar combinedGrammar) {
 		if ( optionsRoot!=null ) {
 			GrammarAST lexerOptionsRoot = (GrammarAST)adaptor.dupNode(optionsRoot);
 			lexerAST.addChild(lexerOptionsRoot);
-			GrammarAST[] options = ((List<?>)optionsRoot.getChildren()).toArray(new GrammarAST[0]);
+			GrammarAST[] options = optionsRoot.getChildren().toArray(new GrammarAST[0]);
 			for (GrammarAST o : options) {
 				String optionName = o.getChild(0).getText();
 				if ( Grammar.lexerOptions.contains(optionName) &&

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -350,7 +350,9 @@ protected void checkElementIsOuterMostInSingleAlt(GrammarAST tree) {
 		if ( !outerMostAlt || tree.getChildIndex() != alt.getChildCount()-1 ||
 			 blk.getChildCount()>1 )
 		{
-			g.tool.errMgr.grammarError(ErrorType.LEXER_ACTION_PLACEMENT_ISSUE,
+			ErrorType e = ErrorType.LEXER_COMMAND_PLACEMENT_ISSUE;
+			if ( tree.getType() == ACTION ) e = ErrorType.LEXER_ACTION_PLACEMENT_ISSUE;
+			g.tool.errMgr.grammarError(e,
 									   fileName,
 									   tree.getToken(),
 									   rule.getChild(0).getText());

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -71,7 +71,7 @@ public enum ErrorType {
 
 	// Grammar errors
 	SYNTAX_ERROR(50, "<arg>", ErrorSeverity.ERROR),
-	RULE_REDEFINITION(51, "rule <arg> redefinition", ErrorSeverity.ERROR),
+	RULE_REDEFINITION(51, "rule <arg> redefinition (ignoring); previous at line <arg2>", ErrorSeverity.ERROR),
 	LEXER_RULES_NOT_ALLOWED(52, "lexer rule <arg> not allowed in parser", ErrorSeverity.ERROR),
 	PARSER_RULES_NOT_ALLOWED(53, "parser rule <arg> not allowed in lexer", ErrorSeverity.ERROR),
     REPEATED_PREQUEL(54, "repeated grammar prequel spec (option, token, or import); please merge", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ast/RuleAST.java
Patch:
@@ -34,6 +34,9 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.parse.ANTLRParser;
 
 public class RuleAST extends GrammarASTWithOptions {
+	/** Kill redef of rules */
+	public boolean dead;
+
 	public RuleAST(GrammarAST node) {
 		super(node);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -258,7 +258,7 @@ public boolean equals(ATNConfig a, ATNConfig b) {
 			if ( hashCode(a) != hashCode(b) ) return false;
 			return a.state.stateNumber==b.state.stateNumber
 				&& a.alt==b.alt
-				&& b.semanticContext.equals(b.semanticContext);
+				&& a.semanticContext.equals(b.semanticContext);
 		}
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionMode.java
Patch:
@@ -49,7 +49,7 @@ public boolean equals(ATNConfig a, ATNConfig b) {
 			if ( a==null || b==null ) return false;
 			if ( hashCode(a) != hashCode(b) ) return false;
 			return a.state.stateNumber==b.state.stateNumber
-				&& b.context.equals(b.context);
+				&& a.context.equals(b.context);
 		}
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/CommonToken.java
Patch:
@@ -28,6 +28,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime;
 
+import org.antlr.v4.runtime.misc.Interval;
+
 import java.io.Serializable;
 
 public class CommonToken implements WritableToken, Serializable {
@@ -109,7 +111,7 @@ public String getText() {
 		if ( input==null ) return null;
 		int n = input.size();
 		if ( start<n && stop<n) {
-			return input.substring(start,stop);
+			return input.getText(Interval.of(start,stop));
 		}
 		else {
 			return "<EOF>";

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -65,4 +65,7 @@ public interface TokenSource {
 
 	/** Optional method that lets users set factory in lexer or other source */
 	public void setTokenFactory(TokenFactory<?> factory);
+
+	/** Gets the factory used for constructing tokens. */
+	public TokenFactory<?> getTokenFactory();
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATN.java
Patch:
@@ -71,6 +71,7 @@ public class ATN {
 	// runtime for lexer only
 	public int[] ruleToTokenType;
 	public int[] ruleToActionIndex;
+
 	@NotNull
 	public final List<TokensStartState> modeToStartState = new ArrayList<TokensStartState>();
 
@@ -119,7 +120,7 @@ public int defineDecisionState(@NotNull DecisionState s) {
 	}
 
     public DecisionState getDecisionState(int decision) {
-        if ( decisionToState.size()>0 ) {
+        if ( !decisionToState.isEmpty() ) {
             return decisionToState.get(decision);
         }
         return null;

File: runtime/Java/src/org/antlr/v4/runtime/atn/BlockEndState.java
Patch:
@@ -31,4 +31,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 /** Terminal node of a simple (a|b|c) block */
 public class BlockEndState extends ATNState {
+	public BlockStartState startState;
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionState.java
Patch:
@@ -31,6 +31,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 public class DecisionState extends ATNState {
 	public int decision = -1;
-
-	public boolean isGreedy = true;
+	public boolean nonGreedy;
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/LoopEndState.java
Patch:
@@ -31,5 +31,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 /** Mark the end of a * or + loop */
 public class LoopEndState extends ATNState {
-	public int loopBackStateNumber;
+	public ATNState loopBackState;
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/StarLoopbackState.java
Patch:
@@ -30,4 +30,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime.atn;
 
 public class StarLoopbackState extends ATNState {
+	public final StarLoopEntryState getLoopEntryState() {
+		return (StarLoopEntryState)transition(0).target;
+	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/TokensStartState.java
Patch:
@@ -30,5 +30,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime.atn;
 
 /** The Tokens rule start state linking to each lexer rule start state */
-public class TokensStartState extends BlockStartState {
+public class TokensStartState extends DecisionState {
 }

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFASerializer.java
Patch:
@@ -60,7 +60,7 @@ public String toString() {
 					if ( t!=null && t.stateNumber != Integer.MAX_VALUE ) {
 						buf.append(getStateString(s));
 						String label = getEdgeLabel(i);
-						buf.append("-"+label+"->"+ getStateString(t)+'\n');
+						buf.append("-").append(label).append("->").append(getStateString(t)).append('\n');
 					}
 				}
 			}
@@ -89,7 +89,7 @@ String getStateString(DFAState s) {
                 stateStr = ":s"+n+"=>"+s.prediction;
             }
 		}
-		else if ( s.isCtxSensitive ) {
+		else if ( s.requiresFullContext) {
 			stateStr = "s"+n+"^";
 		}
 		return stateStr;

File: runtime/Java/src/org/antlr/v4/runtime/misc/LogManager.java
Patch:
@@ -90,8 +90,8 @@ public void save(String filename) throws IOException {
     }
 
     public String save() throws IOException {
-        String dir = System.getProperty("java.io.tmpdir");
-        dir = ".";
+        //String dir = System.getProperty("java.io.tmpdir");
+        String dir = ".";
         String defaultFilename =
             dir + "/antlr-" +
             new SimpleDateFormat("yyyy-MM-dd-HH.mm.ss").format(new Date()) + ".log";

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/PostScriptDocument.java
Patch:
@@ -74,7 +74,7 @@ public void close() {
 	protected StringBuilder header() {
 		StringBuilder b = new StringBuilder();
 		b.append("%!PS-Adobe-3.0 EPSF-3.0\n");
-		b.append(boundingBox+"\n");
+		b.append(boundingBox).append("\n");
 		b.append("0.3 setlinewidth\n");
 		b.append("%% x y w h highlight\n" +
 				 "/highlight {\n" +
@@ -116,7 +116,7 @@ public void setFont(String fontName, int fontSize) {
 
 	public void lineWidth(double w) {
 		lineWidth = w;
-		ps.append(w+" setlinewidth\n");
+		ps.append(w).append(" setlinewidth\n");
 	}
 
 	public void move(double x, double y) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreePostScriptGenerator.java
Patch:
@@ -36,7 +36,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.abego.treelayout.util.DefaultConfiguration;
 import org.antlr.v4.runtime.Parser;
 import org.antlr.v4.runtime.misc.Utils;
-import org.antlr.v4.runtime.tree.ParseTree;
+import org.antlr.v4.runtime.tree.ErrorNode;
 import org.antlr.v4.runtime.tree.Tree;
 
 import java.awt.*;
@@ -129,7 +129,7 @@ protected void generateNode(Tree t) {
 		// for debugging, turn this on to see boundingbox of nodes
 		//doc.rect(box.x, box.y, box.width, box.height);
 		// make error nodes from parse tree red by default
-		if ( t instanceof ParseTree.ErrorNode ) {
+		if ( t instanceof ErrorNode ) {
 			doc.highlight(box.x, box.y, box.width, box.height);
 		}
 		double x = box.x+nodeWidthPadding;

File: tool/playground/TestR.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.DiagnosticErrorStrategy;
+import org.antlr.v4.runtime.DiagnosticErrorListener;
 
 public class TestR {
 	public static void main(String[] args) throws Exception {
@@ -41,7 +41,7 @@ public static void main(String[] args) throws Exception {
 //		}
 		RParser p = new RParser(tokens);
 		p.setBuildParseTree(true);
-		p.setErrorHandler(new DiagnosticErrorStrategy());
+		p.addErrorListener(new DiagnosticErrorListener());
 		p.prog();
 	}
 }

File: tool/playground/TestU.java
Patch:
@@ -1,14 +1,13 @@
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.ParserRuleContext;
 
 public class TestU {
 	public static void main(String[] args) throws Exception {
 		ULexer t = new ULexer(new ANTLRFileStream(args[0]));
 		CommonTokenStream tokens = new CommonTokenStream(t);
 		UParser p = new UParser(tokens);
 		p.setBuildParseTree(true);
-		ParserRuleContext r = p.s();
-		System.out.println(r.toStringTree(p));
+//		ParserRuleContext r = p.s();
+//		System.out.println(r.toStringTree(p));
 	}
 }

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -30,6 +30,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.tool;
 
 import org.antlr.runtime.CommonToken;
+import org.antlr.runtime.tree.CommonTreeNodeStream;
 import org.antlr.runtime.tree.Tree;
 import org.antlr.runtime.tree.TreeVisitor;
 import org.antlr.runtime.tree.TreeVisitorAction;
@@ -76,8 +77,7 @@ public void process() {
 	}
 
 	public void reduceBlocksToSets(GrammarAST root) {
-		org.antlr.runtime.tree.CommonTreeNodeStream nodes =
-			new org.antlr.runtime.tree.CommonTreeNodeStream(root);
+		CommonTreeNodeStream nodes = new CommonTreeNodeStream(new GrammarASTAdaptor(), root);
 		GrammarASTAdaptor adaptor = new GrammarASTAdaptor();
 		BlockSetTransformer transformer = new BlockSetTransformer(nodes, g);
 		transformer.setTreeAdaptor(adaptor);

File: tool/test/org/antlr/v4/test/TestLexerErrors.java
Patch:
@@ -47,7 +47,7 @@ public class TestLexerErrors extends BaseTest {
 	}
 
 	@Test
-	public void tesStringsEmbeddedInActions() {
+	public void testStringsEmbeddedInActions() {
 		String grammar =
 			"lexer grammar Actions;\n"
 			+ "ACTION2 : '[' (STRING | ~'\"')*? ']';\n"

File: runtime/Java/src/org/antlr/v4/runtime/BailErrorStrategy.java
Patch:
@@ -43,7 +43,7 @@ public class BailErrorStrategy extends DefaultErrorStrategy {
      */
     @Override
     public void recover(Parser recognizer, RecognitionException e) {
-		for (ParserRuleContext<?> context = recognizer.getContext(); context != null; context = context.getParent()) {
+		for (ParserRuleContext context = recognizer.getContext(); context != null; context = context.getParent()) {
 			context.exception = e;
 		}
 
@@ -58,7 +58,7 @@ public Token recoverInline(Parser recognizer)
         throws RecognitionException
     {
 		InputMismatchException e = new InputMismatchException(recognizer);
-		for (ParserRuleContext<?> context = recognizer.getContext(); context != null; context = context.getParent()) {
+		for (ParserRuleContext context = recognizer.getContext(); context != null; context = context.getParent()) {
 			context.exception = e;
 		}
 

File: runtime/Java/src/org/antlr/v4/runtime/CommonTokenStream.java
Patch:
@@ -46,7 +46,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *  @see UnbufferedTokenStream
  *  @see BufferedTokenStream
  */
-public class CommonTokenStream extends BufferedTokenStream<Token> {
+public class CommonTokenStream extends BufferedTokenStream {
     /** Skip tokens on any channel but this one; this is how we skip whitespace... */
     protected int channel = Token.DEFAULT_CHANNEL;
 

File: runtime/Java/src/org/antlr/v4/runtime/NoViableAltException.java
Patch:
@@ -64,7 +64,7 @@ public NoViableAltException(@NotNull Parser recognizer,
 								@NotNull Token startToken,
 								@NotNull Token offendingToken,
 								@Nullable ATNConfigSet deadEndConfigs,
-								@NotNull ParserRuleContext<?> ctx)
+								@NotNull ParserRuleContext ctx)
 	{
 		super(recognizer, input, ctx);
 		this.deadEndConfigs = deadEndConfigs;

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -62,7 +62,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *  @see ParserRuleContext
  */
 public class RuleContext implements RuleNode {
-	public static final ParserRuleContext<Token> EMPTY = new ParserRuleContext<Token>();
+	public static final ParserRuleContext EMPTY = new ParserRuleContext();
 
 	/** What context invoked this rule? */
 	public RuleContext parent;

File: runtime/Java/src/org/antlr/v4/runtime/misc/OrderedHashSet.java
Patch:
@@ -118,7 +118,7 @@ public List<T> elements() {
 
     @Override
     public Object clone() {
-        @SuppressWarnings("unchecked")
+        @SuppressWarnings("unchecked") // safe (result of clone)
         OrderedHashSet<T> dup = (OrderedHashSet<T>)super.clone();
         dup.elements = new ArrayList<T>(this.elements);
         return dup;

File: runtime/Java/src/org/antlr/v4/runtime/misc/Utils.java
Patch:
@@ -38,7 +38,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 public class Utils {
     // Seriously: why isn't this built in to java? ugh!
-    public static String join(Iterator iter, String separator) {
+    public static <T> String join(Iterator<T> iter, String separator) {
         StringBuilder buf = new StringBuilder();
         while ( iter.hasNext() ) {
             buf.append(iter.next());

File: runtime/Java/src/org/antlr/v4/runtime/tree/ErrorNode.java
Patch:
@@ -29,7 +29,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 package org.antlr.v4.runtime.tree;
 
-import org.antlr.v4.runtime.Token;
-
-public interface ErrorNode<Symbol extends Token> extends TerminalNode<Symbol> {
+public interface ErrorNode extends TerminalNode {
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeVisitor.java
Patch:
@@ -42,12 +42,12 @@ public T visitChildren(RuleNode node) {
 	 * @param node The {@link TerminalNode} to visit.
 	 * @return The result of visiting the node.
 	 */
-	public T visitTerminal(TerminalNode<? extends Token> node) { return null; }
+	public T visitTerminal(TerminalNode node) { return null; }
 
 	/** Visit an error node, and return a user-defined result of the operation.
 	 *
 	 * @param node The {@link ErrorNode} to visit.
 	 * @return The result of visiting the node.
 	 */
-	public T visitErrorNode(ErrorNode<? extends Token> node) { return null; }
+	public T visitErrorNode(ErrorNode node) { return null; }
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/TerminalNode.java
Patch:
@@ -31,6 +31,6 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import org.antlr.v4.runtime.Token;
 
-public interface TerminalNode<Symbol extends Token> extends ParseTree {
-	Symbol getSymbol();
+public interface TerminalNode extends ParseTree {
+	Token getSymbol();
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -132,9 +132,9 @@ else if ( t instanceof ErrorNode) {
 				return t.toString();
 			}
 			else if ( t instanceof TerminalNode) {
-				Object symbol = ((TerminalNode<?>)t).getSymbol();
-				if (symbol instanceof Token) {
-					String s = ((Token)symbol).getText();
+				Token symbol = ((TerminalNode)t).getSymbol();
+				if (symbol != null) {
+					String s = symbol.getText();
 					return s;
 				}
 			}

File: tool/test/org/antlr/v4/test/TestATNParserPrediction.java
Patch:
@@ -504,7 +504,7 @@ public void checkPredictedAlt(LexerGrammar lg, Grammar g, int decision,
 	}
 
 	public synchronized DFA getDFA(LexerGrammar lg, Grammar g, String ruleName,
-								   String inputString, ParserRuleContext<?> ctx)
+								   String inputString, ParserRuleContext ctx)
 	{
 		// sync to ensure multiple tests don't race on dfa access
 		Tool.internalOption_ShowATNConfigsInDFA = true;

File: tool/test/org/antlr/v4/test/TestBufferedTokenStream.java
Patch:
@@ -42,7 +42,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public class TestBufferedTokenStream extends BaseTest {
 
 	protected TokenStream createTokenStream(TokenSource src) {
-		return new BufferedTokenStream<Token>(src);
+		return new BufferedTokenStream(src);
 	}
 
 	@Test public void testFirstToken() throws Exception {

File: tool/test/org/antlr/v4/test/TestListeners.java
Patch:
@@ -9,7 +9,7 @@ public class TestListeners extends BaseTest {
 			"@header {import org.antlr.v4.runtime.tree.*;}\n"+
 			"@members {\n" +
 			"public static class LeafListener extends TBaseListener {\n" +
-			"    public void visitTerminal(TerminalNode<Token> node) {\n" +
+			"    public void visitTerminal(TerminalNode node) {\n" +
 			"      System.out.println(node.getSymbol().getText());\n" +
 			"    }\n" +
 			"  }}\n" +

File: tool/test/org/antlr/v4/test/TestListeners.java
Patch:
@@ -188,7 +188,7 @@ public class TestListeners extends BaseTest {
 			"1\n" +
 			"2\n" +
 			"3\n" +
-			"1 [16 6]\n";
+			"1 [13 6]\n";
 		assertEquals(expecting, result);
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -46,8 +46,8 @@
 
 /** "dup" of ParserInterpreter */
 public class LexerATNSimulator extends ATNSimulator {
-	public static boolean debug = false;
-	public static boolean dfa_debug = false;
+	public static final boolean debug = false;
+	public static final boolean dfa_debug = false;
 
 	public static final int MIN_DFA_EDGE = 0;
 	public static final int MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNConfig.java
Patch:
@@ -67,7 +67,7 @@ public LexerATNConfig(@NotNull LexerATNConfig c, @NotNull ATNState state,
 						  @NotNull SemanticContext semanticContext) {
 		super(c, state, c.context, semanticContext);
 		this.lexerActionIndex = c.lexerActionIndex;
-		this._passedThroughNonGreedyDecision = checkNonGreedyDecision(c, state);
+		this.passedThroughNonGreedyDecision = checkNonGreedyDecision(c, state);
 	}
 
 	public LexerATNConfig(@NotNull LexerATNConfig c, @NotNull ATNState state,

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -55,6 +55,7 @@ public enum ErrorType {
 	CANNOT_OPEN_FILE(7, "cannot find or open file: <arg><if(exception)>; reason: <exception><endif>", ErrorSeverity.ERROR),
 	FILE_AND_GRAMMAR_NAME_DIFFER(8, "grammar name <arg> and file name <arg2> differ", ErrorSeverity.ERROR),
 	BAD_OPTION_SET_SYNTAX(9, "invalid -Dname=value syntax: <arg>", ErrorSeverity.ERROR),
+	WARNING_TREATED_AS_ERROR(10, "warning treated as error", ErrorSeverity.ERROR),
 
 	INTERNAL_ERROR(20, "internal error: <arg> <arg2><if(exception)>: <exception><endif>\n" +
 				   "<stackTrace; separator=\"\\n\">", ErrorSeverity.ERROR),

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -426,6 +426,7 @@ protected void compileJavaParser(boolean leftRecursive) throws IOException {
         String body = load(sourceName, null);
         @SuppressWarnings({"ConstantConditions"})
         List<String> extraOptions = new ArrayList<String>();
+		extraOptions.add("-Werror");
         if (FORCE_ATN) {
             extraOptions.add("-Xforce-atn");
         }

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionState.java
Patch:
@@ -31,4 +31,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 public class DecisionState extends ATNState {
 	public int decision = -1;
+	public boolean nonGreedy;
 }

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -426,6 +426,7 @@ public Handle elemList(@NotNull List<Handle> els) {
 	public Handle optional(@NotNull GrammarAST optAST, @NotNull Handle blk) {
 		BlockStartState blkStart = (BlockStartState)blk.left;
 
+		blkStart.nonGreedy = !((QuantifierAST)optAST).isGreedy();
 		if (((QuantifierAST)optAST).isGreedy()) {
 			epsilon(blkStart, blk.right);
 		} else {
@@ -454,6 +455,7 @@ public Handle plus(@NotNull GrammarAST plusAST, @NotNull Handle blk) {
 		BlockEndState blkEnd = (BlockEndState)blk.right;
 
 		PlusLoopbackState loop = newState(PlusLoopbackState.class, plusAST);
+		loop.nonGreedy = !((QuantifierAST)plusAST).isGreedy();
 		atn.defineDecisionState(loop);
 		LoopEndState end = newState(LoopEndState.class, plusAST);
 		blkStart.loopBackState = loop;
@@ -499,6 +501,7 @@ public Handle star(@NotNull GrammarAST starAST, @NotNull Handle elem) {
 		BlockEndState blkEnd = (BlockEndState)elem.right;
 
 		StarLoopEntryState entry = newState(StarLoopEntryState.class, starAST);
+		entry.nonGreedy = !((QuantifierAST)starAST).isGreedy();
 		atn.defineDecisionState(entry);
 		LoopEndState end = newState(LoopEndState.class, starAST);
 		StarLoopbackState loop = newState(StarLoopbackState.class, starAST);

File: tool/src/org/antlr/v4/codegen/model/PlusBlock.java
Patch:
@@ -30,7 +30,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.codegen.model;
 
 import org.antlr.v4.codegen.OutputModelFactory;
-import org.antlr.v4.runtime.atn.*;
+import org.antlr.v4.runtime.atn.PlusBlockStartState;
+import org.antlr.v4.runtime.atn.PlusLoopbackState;
 import org.antlr.v4.tool.ast.GrammarAST;
 
 import java.util.List;
@@ -51,6 +52,5 @@ public PlusBlock(OutputModelFactory factory,
 		loopBackStateNumber = loop.stateNumber;
 		this.error = getThrowNoViableAlt(factory, plusRoot, null);
 		decision = loop.decision;
-		exitAlt = alts.size()+1;
 	}
 }

File: tool/src/org/antlr/v4/codegen/model/StarBlock.java
Patch:
@@ -47,6 +47,5 @@ public StarBlock(OutputModelFactory factory,
 		StarLoopEntryState star = (StarLoopEntryState)blkOrEbnfRootAST.atnState;
 		loopBackStateNumber = star.loopBackState.stateNumber;
 		decision = star.decision;
-		exitAlt = alts.size()+1;
 	}
 }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -150,6 +150,7 @@ public enum ErrorType {
 //	ALIAS_REASSIGNMENT(127, "token literal <arg> aliased to new token name <arg2>", ErrorSeverity.WARNING),
 	ATTRIBUTE_IN_LEXER_ACTION(128, "attribute references not allowed in lexer actions: $<arg>", ErrorSeverity.ERROR),
 	WILDCARD_IN_PARSER(129, "wildcard '.' not allowed in parsers", ErrorSeverity.ERROR),
+	LABEL_BLOCK_NOT_A_SET(130, "label <arg> assigned to a block which is not a set", ErrorSeverity.ERROR),
 
 	/** Documentation comment is unterminated */
     //UNTERMINATED_DOC_COMMENT(, "", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -157,7 +157,7 @@ public enum ErrorType {
     // Dependency sorting errors
     //
     /** t1.g4 -> t2.g4 -> t3.g4 ->t1.g4 */
-    CIRCULAR_DEPENDENCY(130, "your grammars contain a circular dependency and cannot be sorted into a valid build order", ErrorSeverity.ERROR),
+    CIRCULAR_DEPENDENCY(200, "your grammars contain a circular dependency and cannot be sorted into a valid build order", ErrorSeverity.ERROR),
 
     // Simple informational messages
     //

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionState.java
Patch:
@@ -31,5 +31,4 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 public class DecisionState extends ATNState {
 	public int decision = -1;
-	public boolean nonGreedy;
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/StarLoopbackState.java
Patch:
@@ -30,4 +30,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime.atn;
 
 public class StarLoopbackState extends ATNState {
+	public final StarLoopEntryState getLoopEntryState() {
+		return (StarLoopEntryState)transition(0).target;
+	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNConfig.java
Patch:
@@ -76,7 +76,7 @@ public LexerATNConfig enterNonGreedyBlock() {
 	}
 
 	public LexerATNConfig exitNonGreedyBlock() {
-		if (!isGreedy()) {
+		if (isGreedy()) {
 			return this;
 		}
 

File: tool/test/org/antlr/v4/test/TestParseErrors.java
Patch:
@@ -292,7 +292,7 @@ public void testInvalidATNStateRemoval() throws Exception {
 			"WS : [ \\t\\r\\n]+ -> skip;\n";
 		String found = execParser("T.g4", grammar, "TParser", "TLexer", "s", "a.", false);
 		String expecting =
-				"exec stderrVacuum: line 1:1 mismatched input '.' expecting '!'";
+				"line 1:1 mismatched input '.' expecting '!'\n";
 		String result = stderrDuringParse;
 		assertEquals(expecting, result);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContext.java
Patch:
@@ -331,7 +331,7 @@ else if ( a.invokingStates[i]<b.invokingStates[j] ) { // copy a[i] to M
 			int p = lastSlot; // walk backwards from last index until we find non-null parent
 			while ( p>=0 && mergedParents[p]==null ) { p--; }
 			// p is now last non-null index
-			assert p>0; // could only happen to be <0 if two arrays with $
+			assert p>=0; // could only happen to be <0 if two arrays with $
 			if ( p < lastSlot ) {
 				int n = p+1; // how many slots we really used in merge
 				if ( n == 1 ) { // for just one merged element, return singleton top

File: runtime/Java/src/org/antlr/v4/runtime/atn/EmptyPredictionContext.java
Patch:
@@ -1,7 +1,6 @@
 package org.antlr.v4.runtime.atn;
 
 public class EmptyPredictionContext extends SingletonPredictionContext {
-	public static final int EMPTY_INVOKING_STATE = ATNState.INVALID_STATE_NUMBER - 1;
 	public EmptyPredictionContext() {
 		super(null, EMPTY_INVOKING_STATE);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -621,7 +621,7 @@ protected void closure(@NotNull LexerATNConfig config, @NotNull ATNConfigSet con
 				for (SingletonPredictionContext ctx : config.context) {
 					if ( !ctx.isEmpty() ) {
 						PredictionContext newContext = ctx.parent; // "pop" invoking state
-						if ( ctx.invokingState==PredictionContext.EMPTY_FULL_CTX_INVOKING_STATE ) {
+						if ( ctx.invokingState==PredictionContext.EMPTY_INVOKING_STATE ) {
 							// we have no context info. Don't pursue but
 							// record a config that indicates how we hit end
 							LexerATNConfig c = new LexerATNConfig(config, config.state, ctx);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1104,7 +1104,7 @@ protected void closureCheckingStopStateAndLoopRecursion(@NotNull ATNConfig confi
 			// run thru all possible stack tops in ctx
 			if ( config.context!=null && !config.context.isEmpty() ) {
 				for (SingletonPredictionContext ctx : config.context) {
-					if ( ctx.invokingState==PredictionContext.EMPTY_FULL_CTX_INVOKING_STATE ) {
+					if ( ctx.invokingState==PredictionContext.EMPTY_INVOKING_STATE ) {
 						// we have no context info, just chase follow links (if greedy)
 						if ( debug ) System.out.println("FALLING off rule "+
 														getRuleName(config.state.ruleIndex));

File: tool/test/org/antlr/v4/test/TestGraphNodes.java
Patch:
@@ -805,7 +805,7 @@ private static String toDOTString(PredictionContext context, boolean rootIsWildc
 					}
 
 					nodes.append("<p").append(i).append('>');
-					if (current.getInvokingState(i) == PredictionContext.EMPTY_FULL_CTX_INVOKING_STATE) {
+					if (current.getInvokingState(i) == PredictionContext.EMPTY_INVOKING_STATE) {
 						nodes.append(rootIsWildcard ? '*' : '$');
 					}
 				}
@@ -820,7 +820,7 @@ private static String toDOTString(PredictionContext context, boolean rootIsWildc
 			}
 
 			for (int i = 0; i < current.size(); i++) {
-				if (current.getInvokingState(i) == PredictionContext.EMPTY_FULL_CTX_INVOKING_STATE) {
+				if (current.getInvokingState(i) == PredictionContext.EMPTY_INVOKING_STATE) {
 					continue;
 				}
 

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -338,14 +338,14 @@ boolean checkOptions(GrammarAST parent,
 	{
 		boolean ok = true;
 		if ( parent.getType()==ANTLRParser.BLOCK ) {
-			if ( g.isLexer() && Grammar.LexerSubruleOptions.contains(optionID.getText()) ) { // block
+			if ( g.isLexer() && !Grammar.LexerBlockOptions.contains(optionID.getText()) ) { // block
 				g.tool.errMgr.grammarError(ErrorType.ILLEGAL_OPTION,
 										   g.fileName,
 										   optionID,
 										   optionID.getText());
 				ok = false;
 			}
-			if ( !g.isLexer() && Grammar.ParserSubruleOptions.contains(optionID.getText()) ) { // block
+			if ( !g.isLexer() && !Grammar.ParserBlockOptions.contains(optionID.getText()) ) { // block
 				g.tool.errMgr.grammarError(ErrorType.ILLEGAL_OPTION,
 										   g.fileName,
 										   optionID,

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -82,10 +82,10 @@ public class Grammar implements AttributeResolver {
 	public static final Set<String> ruleOptions = new HashSet<String>() {{
 	}};
 
-	public static final Set<String> ParserSubruleOptions = new HashSet<String>() {{
+	public static final Set<String> ParserBlockOptions = new HashSet<String>() {{
 	}};
 
-	public static final Set<String> LexerSubruleOptions = new HashSet<String>() {{
+	public static final Set<String> LexerBlockOptions = new HashSet<String>() {{
 	}};
 
 	/** Legal options for terminal refs like ID<assoc=right> */

File: tool/playground/TestJavaLR.java
Patch:
@@ -198,7 +198,7 @@ private static void report() {
 		System.out.println(ParserATNSimulator.predict_calls +" parser predict calls");
 		System.out.println(ParserATNSimulator.retry_with_context +" retry_with_context after SLL conflict");
 		System.out.println(ParserATNSimulator.retry_with_context_indicates_no_conflict +" retry sees no conflict");
-		System.out.println(ParserATNSimulator.retry_with_context_predicts_same_as_alt +" retry predicts same alt as resolving conflict");
+		System.out.println(ParserATNSimulator.retry_with_context_predicts_same_alt +" retry predicts same alt as resolving conflict");
 		System.out.println(ParserATNSimulator.retry_with_context_from_dfa +" retry from DFA");
 	}
 

File: tool/test/org/antlr/v4/test/TestLeftRecursion.java
Patch:
@@ -330,8 +330,7 @@ public void testAmbigLR() throws Exception {
 		result = execParser("Expr.g4", grammar, "ExprParser", "ExprLexer", "prog", "a+b*2\n", true);
 		assertEquals("line 1:1 reportAttemptingFullContext d=3, input='+'\n" +
 					 "line 1:1 reportContextSensitivity d=3, input='+'\n" +
-					 "line 1:3 reportAttemptingFullContext d=3, input='*'\n" +
-					 "line 1:3 reportAmbiguity d=3: ambigAlts={1, 2}, input='*'\n",
+					 "line 1:3 reportAttemptingFullContext d=3, input='*'\n",
 					 stderrDuringParse);
 
 		result = execParser("Expr.g4", grammar, "ExprParser", "ExprLexer", "prog", "(1+2)*3\n", true);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -255,7 +255,7 @@ They are likely LL(1) + pred eval. Easier to do the whole SLL unless
 
 */
 public class ParserATNSimulator extends ATNSimulator {
-	public static boolean debug = true;
+	public static boolean debug = false;
 	public static boolean debug_list_atn_decisions = false;
 	public static boolean dfa_debug = false;
 	public static boolean retry_debug = false;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ArrayPredictionContext.java
Patch:
@@ -84,7 +84,7 @@ public Iterator<SingletonPredictionContext> iterator() {
 			@Override
 			public SingletonPredictionContext next() {
 				SingletonPredictionContext ctx =
-					new SingletonPredictionContext(parents[i], invokingStates[i]);
+					SingletonPredictionContext.create(parents[i], invokingStates[i]);
 				i++;
 				return ctx;
 			}
@@ -144,8 +144,8 @@ public PredictionContext popAll(
 				next = PredictionContext.EMPTY;
 			}
 			else {
-				next = new SingletonPredictionContext(this.parents[i],
-													  this.invokingStates[i]);
+				next = SingletonPredictionContext.create(this.parents[i],
+														 this.invokingStates[i]);
 			}
 			boolean rootIsWildcard = fullCtx;
 			newCtx = merge(newCtx, next, rootIsWildcard, mergeCache);

File: runtime/Java/src/org/antlr/v4/runtime/atn/LL1Analyzer.java
Patch:
@@ -124,7 +124,7 @@ protected void _LOOK(@NotNull ATNState s, @Nullable PredictionContext ctx,
 			Transition t = s.transition(i);
 			if ( t.getClass() == RuleTransition.class ) {
 				PredictionContext newContext =
-					new SingletonPredictionContext(ctx, s.stateNumber);
+					SingletonPredictionContext.create(ctx, s.stateNumber);
 				_LOOK(t.target, newContext, look, lookBusy, seeThruPreds);
 			}
 			else if ( t instanceof PredicateTransition ) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -667,7 +667,7 @@ public LexerATNConfig getEpsilonTarget(@NotNull LexerATNConfig config,
 		switch (t.getSerializationType()) {
 			case Transition.RULE:
 				PredictionContext newContext =
-					new SingletonPredictionContext(config.context, p.stateNumber);
+					SingletonPredictionContext.create(config.context, p.stateNumber);
 				c = new LexerATNConfig(config, t.target, newContext);
 				break;
 			case Transition.PREDICATE:

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1115,7 +1115,7 @@ else if ( loopsSimulateTailRecursion ) {
 				 config.state.getClass()==PlusLoopbackState.class )
 			{
 				config.context =
-					new SingletonPredictionContext(config.context, config.state.stateNumber);
+					SingletonPredictionContext.create(config.context, config.state.stateNumber);
 				// alter config; it's ok, since all calls to closure pass in a fresh config for us to chase
 				if ( debug ) System.out.println("Loop back; push "+config.state.stateNumber+", stack="+config.context);
 			}
@@ -1286,7 +1286,7 @@ public ATNConfig ruleTransition(@NotNull ATNConfig config, @NotNull Transition t
 							   ", ctx="+config.context);
 		}
 		PredictionContext newContext =
-			new SingletonPredictionContext(config.context, config.state.stateNumber);
+			SingletonPredictionContext.create(config.context, config.state.stateNumber);
 		return new ATNConfig(config, t.target, newContext);
 	}
 

File: tool/test/org/antlr/v4/test/TestGraphNodes.java
Patch:
@@ -2,7 +2,6 @@
 
 import junit.framework.TestCase;
 import org.antlr.v4.runtime.atn.ArrayPredictionContext;
-import org.antlr.v4.runtime.atn.EmptyPredictionContext;
 import org.antlr.v4.runtime.atn.PredictionContext;
 import org.antlr.v4.runtime.atn.PredictionContextCache;
 import org.antlr.v4.runtime.atn.SingletonPredictionContext;
@@ -763,7 +762,7 @@ private SingletonPredictionContext y() {
 	}
 
 	public SingletonPredictionContext createSingleton(PredictionContext parent, int payload) {
-		SingletonPredictionContext a = new SingletonPredictionContext(parent, payload);
+		SingletonPredictionContext a = SingletonPredictionContext.create(parent, payload);
 		return a;
 	}
 
@@ -820,7 +819,7 @@ private static String toDOTString(PredictionContext context, boolean rootIsWildc
 			}
 
 			for (int i = 0; i < current.size(); i++) {
-				if (current.getInvokingState(i) == EmptyPredictionContext.EMPTY_INVOKING_STATE) {
+				if (current.getInvokingState(i) == PredictionContext.EMPTY_FULL_CTX_INVOKING_STATE) {
 					continue;
 				}
 

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -454,9 +454,10 @@ public void enterRecursionRule(ParserRuleContext<Token> localctx, int ruleIndex)
 	}
 
 	/* like enterRule but for recursive rules */
-	public void pushNewRecursionContext(ParserRuleContext<Token> localctx, int ruleIndex) {
+	public void pushNewRecursionContext(ParserRuleContext<Token> localctx, int state, int ruleIndex) {
 		ParserRuleContext<Token> previous = _ctx;
 		previous.parent = localctx;
+		previous.invokingState = state;
 		previous.stop = _input.LT(-1);
 
 		_ctx = localctx;

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -65,4 +65,7 @@ public interface TokenSource {
 
 	/** Optional method that lets users set factory in lexer or other source */
 	public void setTokenFactory(TokenFactory<?> factory);
+
+	/** Gets the factory used for constructing tokens. */
+	public TokenFactory<?> getTokenFactory();
 }

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -45,7 +45,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.List;
 
 /** This is all the parsing support code essentially; most of it is error recovery stuff. */
-public abstract class Parser extends Recognizer<Token, ParserATNSimulator<Token>> {
+public abstract class Parser extends Recognizer<Token, ParserATNSimulator> {
 	public class TraceListener implements ParseTreeListener<Token> {
 		@Override
 		public void enterEveryRule(ParserRuleContext<Token> ctx) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNPathFinder.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 package org.antlr.v4.runtime.atn;
 
-public class ParserATNPathFinder /*extends ParserATNSimulator<Token>*/ {
+public class ParserATNPathFinder /*extends ParserATNSimulator*/ {
 
 //	public ParserATNPathFinder(@Nullable Parser parser, @NotNull ATN atn, @NotNull DFA[] decisionToDFA) {
 //		super(parser, atn, decisionToDFA);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -254,7 +254,7 @@ They are likely LL(1) + pred eval. Easier to do the whole SLL unless
  passes over the input.
 
 */
-public class ParserATNSimulator<Symbol extends Token> extends ATNSimulator {
+public class ParserATNSimulator extends ATNSimulator {
 	public static boolean debug = false;
 	public static boolean debug_list_atn_decisions = false;
 	public static boolean dfa_debug = false;

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -341,7 +341,7 @@ protected void parseSources(ParserFactory factory, Collection<CharStream> source
 
         if (RUN_PARSER) {
             // make sure the individual DFAState objects actually have unique ATNConfig arrays
-            final ParserATNSimulator<?> interpreter = sharedParser.getInterpreter();
+            final ParserATNSimulator interpreter = sharedParser.getInterpreter();
             final DFA[] decisionToDFA = interpreter.decisionToDFA;
 
             if (SHOW_DFA_STATE_STATS) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNSimulator.java
Patch:
@@ -250,11 +250,9 @@ else if (state instanceof StarLoopbackState) {
 		int ndecisions = toInt(data[p++]);
 		for (int i=1; i<=ndecisions; i++) {
 			int s = toInt(data[p++]);
-			int isGreedy = toInt(data[p++]);
 			DecisionState decState = (DecisionState)atn.states.get(s);
 			atn.decisionToState.add(decState);
 			decState.decision = i-1;
-			decState.isGreedy = isGreedy==1;
 		}
 
 		verifyATN(atn);

File: runtime/Java/src/org/antlr/v4/runtime/atn/DecisionState.java
Patch:
@@ -31,6 +31,4 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 public class DecisionState extends ATNState {
 	public int decision = -1;
-
-	public boolean isGreedy = true;
 }

File: tool/src/org/antlr/v4/automata/ATNSerializer.java
Patch:
@@ -226,7 +226,6 @@ else if ( s instanceof BlockStartState ) {
 		data.add(ndecisions);
 		for (DecisionState decStartState : atn.decisionToState) {
 			data.add(decStartState.stateNumber);
-			data.add(decStartState.isGreedy?1:0);
 		}
 		return data;
 	}
@@ -300,8 +299,7 @@ else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_STA
 		int ndecisions = ATNSimulator.toInt(data[p++]);
 		for (int i=1; i<=ndecisions; i++) {
 			int s = ATNSimulator.toInt(data[p++]);
-			int isGreedy = ATNSimulator.toInt(data[p++]);
-			buf.append(i-1).append(":").append(s).append(" ").append(isGreedy).append("\n");
+			buf.append(i-1).append(":").append(s).append("\n");
 		}
 		return buf.toString();
 	}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -136,7 +136,7 @@ public enum ErrorType {
 	IMPORT_NAME_CLASH(113, "<arg.typeString> grammar <arg.name> and imported <arg2.typeString> grammar <arg2.name> both generate <arg2.recognizerName>", ErrorSeverity.ERROR),
 	AST_OP_WITH_NON_AST_OUTPUT_OPTION(114, " <arg>", ErrorSeverity.ERROR),
 	AST_OP_IN_ALT_WITH_REWRITE(115, "", ErrorSeverity.ERROR),
-    WILDCARD_AS_ROOT(116, "", ErrorSeverity.ERROR),
+//    WILDCARD_AS_ROOT(116, "", ErrorSeverity.ERROR),
     CONFLICTING_OPTION_IN_TREE_FILTER(117, "", ErrorSeverity.ERROR),
 	ALL_OPS_NEED_SAME_ASSOC(118, "all operators of alt <arg> of left-recursive rule must have same associativity", ErrorSeverity.WARNING),
 	LEFT_RECURSION_CYCLES(119, "The following sets of rules are mutually left-recursive <arg:{c| [<c:{r|<r.name>}; separator=\", \">]}; separator=\" and \">", ErrorSeverity.ERROR),
@@ -149,6 +149,7 @@ public enum ErrorType {
 	IMPLICIT_STRING_DEFINITION(126, "cannot create implicit token for string literal <arg> in non-combined grammar", ErrorSeverity.ERROR),
 //	ALIAS_REASSIGNMENT(127, "token literal <arg> aliased to new token name <arg2>", ErrorSeverity.WARNING),
 	ATTRIBUTE_IN_LEXER_ACTION(128, "attribute references not allowed in lexer actions: $<arg>", ErrorSeverity.ERROR),
+	WILDCARD_IN_PARSER(129, "wildcard '.' not allowed in parsers", ErrorSeverity.ERROR),
 
 	/** Documentation comment is unterminated */
     //UNTERMINATED_DOC_COMMENT(, "", ErrorSeverity.ERROR),

File: tool/test/org/antlr/v4/test/TestLexerExec.java
Patch:
@@ -92,7 +92,7 @@ public class TestLexerExec extends BaseTest {
 		String grammar =
 			"lexer grammar L;\n"+
 			"I : '0'..'9'+ {System.out.println(\"I\");} ;\n"+
-			"HASH : '#' -> type(HASH), skip, more  ;";
+			"HASH : '#' -> type(100), skip, more  ;";
 		String found = execLexer("L.g4", grammar, "L", "34#11");
 		String expecting =
 			"I\n" +

File: tool/src/org/antlr/v4/codegen/ActionTranslator.java
Patch:
@@ -36,7 +36,6 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.codegen.model.chunk.ActionText;
 import org.antlr.v4.codegen.model.chunk.ArgRef;
 import org.antlr.v4.codegen.model.chunk.LabelRef;
-import org.antlr.v4.codegen.model.chunk.LexerSetAttr;
 import org.antlr.v4.codegen.model.chunk.ListLabelRef;
 import org.antlr.v4.codegen.model.chunk.LocalRef;
 import org.antlr.v4.codegen.model.chunk.NonLocalAttrRef;
@@ -240,7 +239,6 @@ public void setAttr(String expr, Token x, Token rhs) {
 		gen.g.tool.log("action-translator", "setAttr "+x+" "+rhs);
 		List<ActionChunk> rhsChunks = translateActionChunk(factory,rf,rhs.getText(),node);
 		SetAttr s = new SetAttr(nodeContext, x.getText(), rhsChunks);
-		if ( factory.getGrammar().isLexer() ) s = new LexerSetAttr(nodeContext, x.getText(), rhsChunks);
 		chunks.add(s);
 	}
 

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -148,6 +148,7 @@ public enum ErrorType {
 	IMPLICIT_TOKEN_DEFINITION(125, "implicit definition of token <arg> in parser", ErrorSeverity.WARNING),
 	IMPLICIT_STRING_DEFINITION(126, "cannot create implicit token for string literal <arg> in non-combined grammar", ErrorSeverity.ERROR),
 //	ALIAS_REASSIGNMENT(127, "token literal <arg> aliased to new token name <arg2>", ErrorSeverity.WARNING),
+	ATTRIBUTE_IN_LEXER_ACTION(128, "attribute references not allowed in lexer actions: $<arg>", ErrorSeverity.ERROR),
 
 	/** Documentation comment is unterminated */
     //UNTERMINATED_DOC_COMMENT(, "", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -107,9 +107,6 @@ public class Grammar implements AttributeResolver {
 
     public static Map<String, AttributeDict> grammarAndLabelRefTypeToScope =
         new HashMap<String, AttributeDict>() {{
-            put("lexer:RULE_LABEL", Rule.predefinedLexerRulePropertiesDict);
-//            put("lexer:LEXER_STRING_LABEL", Rule.predefinedLexerRulePropertiesDict);
-//			put("lexer:TOKEN_LABEL", AttributeDict.predefinedTokenDict);
             put("parser:RULE_LABEL", Rule.predefinedRulePropertiesDict);
             put("parser:TOKEN_LABEL", AttributeDict.predefinedTokenDict);
             put("combined:RULE_LABEL", Rule.predefinedRulePropertiesDict);

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -107,7 +107,7 @@ public class Grammar implements AttributeResolver {
 
     public static Map<String, AttributeDict> grammarAndLabelRefTypeToScope =
         new HashMap<String, AttributeDict>() {{
-//            put("lexer:RULE_LABEL", Rule.predefinedLexerRulePropertiesDict);
+            put("lexer:RULE_LABEL", Rule.predefinedLexerRulePropertiesDict);
 //            put("lexer:LEXER_STRING_LABEL", Rule.predefinedLexerRulePropertiesDict);
 //			put("lexer:TOKEN_LABEL", AttributeDict.predefinedTokenDict);
             put("parser:RULE_LABEL", Rule.predefinedRulePropertiesDict);

File: tool/test/org/antlr/v4/test/TestATNSerialization.java
Patch:
@@ -105,7 +105,7 @@ public class TestATNSerialization extends BaseTest {
 	@Test public void testNot() throws Exception {
 		Grammar g = new Grammar(
 			"parser grammar T;\n"+
-			"tokens {A; B; C;}\n" +
+			"tokens {A, B, C}\n" +
 			"a : ~A ;");
 		String expecting =
 			"max type 3\n" +
@@ -129,7 +129,7 @@ public class TestATNSerialization extends BaseTest {
 	@Test public void testWildcard() throws Exception {
 		Grammar g = new Grammar(
 			"parser grammar T;\n"+
-			"tokens {A; B; C;}\n" +
+			"tokens {A, B, C}\n" +
 			"a : . ;");
 		String expecting =
 			"max type 3\n" +

File: tool/test/org/antlr/v4/test/TestAttributeChecks.java
Patch:
@@ -9,7 +9,7 @@ public class TestAttributeChecks extends BaseTest {
     String attributeTemplate =
         "parser grammar A;\n"+
         "@members {<members>}\n" +
-		"tokens{ID;}\n" +
+		"tokens{ID}\n" +
         "a[int x] returns [int y]\n" +
         "@init {<init>}\n" +
         "    :   id=ID ids+=ID lab=b[34] {\n" +

File: tool/src/org/antlr/v4/semantics/AttributeChecks.java
Patch:
@@ -41,6 +41,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.tool.LabelType;
 import org.antlr.v4.tool.Rule;
 import org.antlr.v4.tool.ast.ActionAST;
+import org.antlr.v4.tool.ast.GrammarAST;
 
 import java.util.List;
 
@@ -83,7 +84,8 @@ public static void checkAllAttributeExpressions(Grammar g) {
                     checker.examineAction();
                 }
             }
-            for (ActionAST a : r.exceptionActions) {
+            for (GrammarAST e : r.exceptions) {
+				ActionAST a = (ActionAST)e.getChild(1);
                 AttributeChecks checker = new AttributeChecks(g, r, null, a, a.token);
                 checker.examineAction();
 			}

File: tool/src/org/antlr/v4/semantics/SymbolCollector.java
Patch:
@@ -124,7 +124,8 @@ public void sempredInAlt(PredAST pred) {
 
 	@Override
 	public void ruleCatch(GrammarAST arg, ActionAST action) {
-		currentRule.exceptionActions.add(action);
+		GrammarAST catchme = (GrammarAST)action.getParent();
+		currentRule.exceptions.add(catchme);
 		action.resolver = currentRule;
 	}
 

File: tool/src/org/antlr/v4/tool/Rule.java
Patch:
@@ -101,10 +101,10 @@ public class Rule implements AttributeResolver {
     public Map<String, ActionAST> namedActions =
         new HashMap<String, ActionAST>();
 
-    /** Track exception handler actions (exception type is prev child);
+    /** Track exception handlers; points at "catch" node of (catch exception action)
 	 *  don't track finally action
 	 */
-    public List<ActionAST> exceptionActions = new ArrayList<ActionAST>();
+    public List<GrammarAST> exceptions = new ArrayList<GrammarAST>();
 
 	/** Track all executable actions other than named actions like @init
 	 *  and catch/finally (not in an alt). Also tracks predicates, rewrite actions.

File: tool/src/org/antlr/v4/codegen/model/MatchNotSet.java
Patch:
@@ -33,6 +33,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.tool.ast.GrammarAST;
 
 public class MatchNotSet extends MatchSet {
+	public String varName = "_la";
 	public MatchNotSet(OutputModelFactory factory, GrammarAST ast) {
 		super(factory, ast);
 	}

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -364,6 +364,8 @@ public void processNonCombinedGrammar(Grammar g, boolean gencode) {
 		if ( g.ast!=null && internalOption_PrintGrammarTree ) System.out.println(g.ast.toStringTree());
 		//g.ast.inspect();
 
+		if ( g.ast.hasErrors ) return;
+
 		int prevErrors = errMgr.getNumErrors();
 		// MAKE SURE GRAMMAR IS SEMANTICALLY CORRECT (FILL IN GRAMMAR OBJECT)
 		SemanticPipeline sem = new SemanticPipeline(g);

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -325,6 +325,7 @@ public static boolean hasImmediateRecursiveRuleRefs(GrammarAST t, String ruleNam
 		for (int i = 0; i < n; i++) {
 			GrammarAST alt = (GrammarAST)blk.getChildren().get(i);
 			Tree first = alt.getChild(0);
+			if ( first==null ) continue;
 			if ( first.getType()==RULE_REF && first.getText().equals(ruleName) ) return true;
 			Tree rref = first.getChild(1);
 			if ( rref!=null && rref.getType()==RULE_REF && rref.getText().equals(ruleName) ) return true;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -606,7 +606,7 @@ public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,
 												 loopsSimulateTailRecursion,
 												 false);
 			if ( reach==null ) {
-				// TODO: if any configs in previous dipped into outer context, that
+				// if any configs in previous dipped into outer context, that
 				// means that input up to t actually finished entry rule
 				// at least for SLL decision. Full LL doesn't dip into outer
 				// so don't need special case.
@@ -683,7 +683,6 @@ public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,
 												  greedy,
 												  loopsSimulateTailRecursion,
 												  true);
-							// we have write lock already, no need to relock
 							predictedAlt = execATNWithFullContext(dfa, D, s0_closure,
 																  input, startIndex,
 																  outerContext,
@@ -804,7 +803,7 @@ public int execATNWithFullContext(DFA dfa,
 //							   " line "+input.LT(1).getLine()+":"+input.LT(1).getCharPositionInLine());
 			reach = computeReachSet(previous, t, greedy, true, fullCtx);
 			if ( reach==null ) {
-				// TODO: if any configs in previous dipped into outer context, that
+				// if any configs in previous dipped into outer context, that
 				// means that input up to t actually finished entry rule
 				// at least for LL decision. Full LL doesn't dip into outer
 				// so don't need special case.

File: tool/test/org/antlr/v4/test/TestParserExec.java
Patch:
@@ -220,8 +220,7 @@ public void testIfIfElse() throws Exception {
 								  "if x if x a else b", true);
 		String expecting = "";
 		assertEquals(expecting, found);
-		assertEquals("line 1:12 reportAttemptingFullContext d=1, input='else'\n",
-					 this.stderrDuringParse);
+		assertNull(this.stderrDuringParse);
 	}
 
 }

File: tool/test/org/antlr/v4/test/TestParserExec.java
Patch:
@@ -220,8 +220,7 @@ public void testIfIfElse() throws Exception {
 								  "if x if x a else b", true);
 		String expecting = "";
 		assertEquals(expecting, found);
-		assertEquals("line 1:12 reportAttemptingFullContext d=1, input='else'\n" +
-					 "line 1:12 reportContextSensitivity d=1, input='else'\n",
+		assertEquals("line 1:12 reportAttemptingFullContext d=1, input='else'\n",
 					 this.stderrDuringParse);
 	}
 

File: tool/src/org/antlr/v4/codegen/model/Lexer.java
Patch:
@@ -33,7 +33,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.codegen.model.chunk.ActionChunk;
 import org.antlr.v4.codegen.model.chunk.ActionText;
-import org.antlr.v4.codegen.model.chunk.DefaultParserSuperClass;
+import org.antlr.v4.codegen.model.chunk.DefaultLexerSuperClass;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.LexerGrammar;
 import org.antlr.v4.tool.Rule;
@@ -99,7 +99,7 @@ public Lexer(OutputModelFactory factory, LexerFile file) {
 			superClass = new ActionText(null, g.getOptionString("superClass"));
 		}
 		else {
-			superClass = new DefaultParserSuperClass();
+			superClass = new DefaultLexerSuperClass();
 		}
 
 		abstractRecognizer = g.isAbstract();

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -79,7 +79,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.concurrent.CopyOnWriteArrayList;
 
 public class Tool {
-	public String VERSION = "4.0b1";
+	public static final String VERSION = "4.0b1";
 
 	public static final String GRAMMAR_EXTENSION = ".g4";
 	public static final String LEGACY_GRAMMAR_EXTENSION = ".g";

File: tool/src/org/antlr/v4/codegen/CodeGenPipeline.java
Patch:
@@ -42,6 +42,8 @@ public CodeGenPipeline(Grammar g) {
 	public void process() {
 		CodeGenerator gen = new CodeGenerator(g);
 
+		if ( gen.templates==null ) return;
+
 		if ( g.isLexer() ) {
 			ST lexer = gen.generateLexer();
 			if ( g.tool.launch_ST_inspector ) lexer.inspect();

File: tool/src/org/antlr/v4/codegen/CodeGenerator.java
Patch:
@@ -118,7 +118,7 @@ public void loadTemplates(String language) {
 		}
 		catch (IllegalArgumentException iae) {
 			tool.errMgr.toolError(ErrorType.CANNOT_CREATE_TARGET_GENERATOR,
-									iae,
+									null,
 						 			language);
 		}
 	}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -28,6 +28,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.tool;
 
+import org.antlr.v4.Tool;
+
 /**
  * A complex enumeration of all the error messages that the tool can issue.
  *
@@ -61,7 +63,7 @@ public enum ErrorType {
 
 	// Code generation errors
 	MISSING_CODE_GEN_TEMPLATES(30, "can't find code generation templates: <arg>", ErrorSeverity.ERROR),
-	CANNOT_CREATE_TARGET_GENERATOR(31, "cannot create target <arg> code generator: <exception>", ErrorSeverity.ERROR),
+	CANNOT_CREATE_TARGET_GENERATOR(31, "ANTLR cannot generate <arg> code as of version "+ Tool.VERSION, ErrorSeverity.ERROR),
 	CODE_TEMPLATE_ARG_ISSUE(32, "code generation template <arg> has missing, misnamed, or incomplete arg list; missing <arg2>", ErrorSeverity.ERROR),
 	CODE_GEN_TEMPLATES_INCOMPLETE(33, "missing code generation template <arg>", ErrorSeverity.ERROR),
 	NO_MODEL_TO_TEMPLATE_MAPPING(34, "no mapping to template name for output model class <arg>", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -205,9 +205,9 @@ public static void main(String[] args) {
 
 	public Tool(String[] args) {
 		this.args = args;
-		handleArgs();
 		errMgr = new ErrorManager(this);
 		errMgr.setFormat(msgFormat);
+		handleArgs();
 	}
 
 	protected void handleArgs() {

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -143,7 +143,7 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 		new Option("gen_visitor",		"-visitor", "generate parse tree visitor"),
 		new Option("gen_visitor",		"-no-visitor", "don't generate parse tree visitor (default)"),
 		new Option("abstract_recognizer", "-abstract", "generate abstract recognizer classes"),
-		new Option("-D<option>=value",	"-message-format", "set a grammar-level option"),
+		new Option("",					"-D<option>=value", "set a grammar-level option"),
 
 
         new Option("saveLexer",			"-Xsave-lexer", "save temp lexer file created for combined grammars"),

File: tool/src/org/antlr/v4/automata/ATNSerializer.java
Patch:
@@ -247,7 +247,7 @@ public String decode(char[] data) {
 				int loopBackStateNumber = ATNSimulator.toInt(data[p++]);
 				arg = " "+loopBackStateNumber;
 			}
-			else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START ) {
+			else if ( stype == ATNState.PLUS_BLOCK_START || stype == ATNState.STAR_BLOCK_START || stype == ATNState.BLOCK_START ) {
 				int endStateNumber = ATNSimulator.toInt(data[p++]);
 				arg = " "+endStateNumber;
 			}

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeWalker.java
Patch:
@@ -37,7 +37,7 @@ public class ParseTreeWalker {
 
     @SuppressWarnings("unchecked")
     public <Symbol extends Token> void walk(ParseTreeListener<Symbol> listener, ParseTree t) {
-		if ( t instanceof ErrorNodeImpl) {
+		if ( t instanceof ErrorNode) {
 			listener.visitErrorNode((ErrorNode<Symbol>)t);
 			return;
 		}

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -102,7 +102,7 @@ public static String getNodeText(Tree t, Parser recog) {
 				String ruleName = recog.getRuleNames()[ruleIndex];
 				return ruleName;
 			}
-			else if ( t instanceof ErrorNodeImpl) {
+			else if ( t instanceof ErrorNode) {
 				return t.toString();
 			}
 			else if ( t instanceof TerminalNode) {

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -32,6 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.ParseTreeVisitor;
+import org.antlr.v4.runtime.tree.RuleNode;
 import org.antlr.v4.runtime.tree.Trees;
 import org.antlr.v4.runtime.tree.gui.TreeViewer;
 
@@ -58,7 +59,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *
  *  @see ParserRuleContext
  */
-public class RuleContext implements ParseTree.RuleNode {
+public class RuleContext implements RuleNode {
 	/** What context invoked this rule? */
 	public RuleContext parent;
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeListener.java
Patch:
@@ -33,8 +33,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.Token;
 
 public interface ParseTreeListener<Symbol extends Token> {
-	void visitTerminal(ParseTree.TerminalNode<Symbol> node);
-	void visitErrorNode(ParseTree.ErrorNode<Symbol> node);
+	void visitTerminal(TerminalNode<Symbol> node);
+	void visitErrorNode(ErrorNode<Symbol> node);
     void enterEveryRule(ParserRuleContext<Symbol> ctx);
     void exitEveryRule(ParserRuleContext<Symbol> ctx);
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeVisitor.java
Patch:
@@ -17,7 +17,7 @@ public T visit(ParseTree tree) {
 	 *  care about some nodes.  The {@link ParserRuleContext#accept} method
 	 *  walks all children by default; i.e., calls this method.
 	 */
-	public T visitChildren(ParseTree.RuleNode node) {
+	public T visitChildren(RuleNode node) {
 		T result = null;
 		int n = node.getChildCount();
 		for (int i=0; i<n; i++) {
@@ -27,6 +27,6 @@ public T visitChildren(ParseTree.RuleNode node) {
 		return result;
 	}
 
-	public T visitTerminal(ParseTree.TerminalNode<? extends Token> node) { return null; }
-	public T visitErrorNode(ParseTree.ErrorNode<? extends Token> node) { return null; }
+	public T visitTerminal(TerminalNode<? extends Token> node) { return null; }
+	public T visitErrorNode(ErrorNode<? extends Token> node) { return null; }
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreePostScriptGenerator.java
Patch:
@@ -36,7 +36,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.abego.treelayout.util.DefaultConfiguration;
 import org.antlr.v4.runtime.Parser;
 import org.antlr.v4.runtime.misc.Utils;
-import org.antlr.v4.runtime.tree.ParseTree;
+import org.antlr.v4.runtime.tree.ErrorNode;
 import org.antlr.v4.runtime.tree.Tree;
 
 import java.awt.*;
@@ -129,7 +129,7 @@ protected void generateNode(Tree t) {
 		// for debugging, turn this on to see boundingbox of nodes
 		//doc.rect(box.x, box.y, box.width, box.height);
 		// make error nodes from parse tree red by default
-		if ( t instanceof ParseTree.ErrorNode ) {
+		if ( t instanceof ErrorNode ) {
 			doc.highlight(box.x, box.y, box.width, box.height);
 		}
 		double x = box.x+nodeWidthPadding;

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -36,7 +36,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.Parser;
 import org.antlr.v4.runtime.misc.GraphicsSupport;
 import org.antlr.v4.runtime.misc.Utils;
-import org.antlr.v4.runtime.tree.ParseTree;
+import org.antlr.v4.runtime.tree.ErrorNode;
 import org.antlr.v4.runtime.tree.Tree;
 import org.antlr.v4.runtime.tree.Trees;
 
@@ -186,10 +186,10 @@ protected void paintBox(Graphics g, Tree tree) {
 		Rectangle2D.Double box = getBoundsOfNode(tree);
 		// draw the box in the background
 		if ( isHighlighted(tree) || boxColor!=null ||
-			 tree instanceof ParseTree.ErrorNode )
+			 tree instanceof ErrorNode )
 		{
 			if ( isHighlighted(tree) ) g.setColor(highlightedBoxColor);
-			else if ( tree instanceof ParseTree.ErrorNode ) g.setColor(LIGHT_RED);
+			else if ( tree instanceof ErrorNode ) g.setColor(LIGHT_RED);
 			else g.setColor(boxColor);
 			g.fillRoundRect((int) box.x, (int) box.y, (int) box.width - 1,
 							(int) box.height - 1, arcSize, arcSize);

File: tool/src/org/antlr/v4/automata/ATNOptimizer.java
Patch:
@@ -57,7 +57,7 @@ public class ATNOptimizer {
 
 	public static void optimize(@NotNull Grammar g, @NotNull ATN atn) {
 		optimizeSets(g, atn);
-//		optimizeStates(atn); // TODO leads to class cast exception
+		optimizeStates(atn);
 	}
 
 	private static void optimizeSets(Grammar g, ATN atn) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LoopEndState.java
Patch:
@@ -31,5 +31,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 /** Mark the end of a * or + loop */
 public class LoopEndState extends ATNState {
-	public int loopBackStateNumber;
+	public ATNState loopBackState;
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -987,7 +987,8 @@ else if ( config.state.getClass()==LoopEndState.class ) {
 				if ( debug ) System.out.println("Loop end; pop, stack=" + config.context);
 				RuleContext p = config.context;
 				LoopEndState end = (LoopEndState) config.state;
-				while ( !p.isEmpty() && p.invokingState == end.loopBackStateNumber ) {
+				int loopBackStateNumber = end.loopBackState.stateNumber;
+				while ( !p.isEmpty() && p.invokingState == loopBackStateNumber ) {
 					p = config.context = config.context.parent; // "pop"
 				}
 			}

File: tool/src/org/antlr/v4/automata/ATNSerializer.java
Patch:
@@ -89,7 +89,7 @@ public IntegerList serialize() {
 			}
 			data.add(s.getStateType());
 			data.add(s.ruleIndex);
-			if ( s.getStateType() == ATNState.LOOP_END ) data.add(((LoopEndState)s).loopBackStateNumber);
+			if ( s.getStateType() == ATNState.LOOP_END ) data.add(((LoopEndState)s).loopBackState.stateNumber);
 			nedges += s.getNumberOfTransitions();
 			for (int i=0; i<s.getNumberOfTransitions(); i++) {
 				Transition t = s.transition(i);

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -425,7 +425,7 @@ public Handle plus(@NotNull GrammarAST plusAST, @NotNull Handle blk) {
 		atn.defineDecisionState(loop);
 		LoopEndState end = newState(LoopEndState.class, plusAST);
 		blkStart.loopBackState = loop;
-		end.loopBackStateNumber = loop.stateNumber;
+		end.loopBackState = loop;
 
 		plusAST.atnState = blkStart;
 		epsilon(blkEnd, loop);		// blk can see loop back
@@ -468,7 +468,7 @@ public Handle star(@NotNull GrammarAST starAST, @NotNull Handle elem) {
 		LoopEndState end = newState(LoopEndState.class, starAST);
 		StarLoopbackState loop = newState(StarLoopbackState.class, starAST);
 		entry.loopBackState = loop;
-		end.loopBackStateNumber = loop.stateNumber;
+		end.loopBackState = loop;
 
 		BlockAST blkAST = (BlockAST)starAST.getChild(0);
 		entry.isGreedy = isGreedy(blkAST);

File: runtime/Java/src/org/antlr/v4/runtime/atn/Transition.java
Patch:
@@ -99,7 +99,7 @@ protected Transition(@NotNull ATNState target) {
 		this.target = target;
 	}
 
-	public int getSerializationType() { return 0; }
+	public abstract int getSerializationType();
 
 	/** Are we epsilon, action, sempred? */
 	public boolean isEpsilon() { return false; }

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -503,7 +503,7 @@ else if ( trans instanceof WildcardTransition && t!=CharStream.EOF ) {
 
 	/** Delete configs for alt following ci. Closure is unmodified; copy returned. */
 	public ATNConfigSet deleteWildcardConfigsForAlt(@NotNull ATNConfigSet closure, int ci, int alt) {
-		ATNConfigSet dup = new ATNConfigSet(closure, null);
+		ATNConfigSet dup = new ATNConfigSet(closure);
 		int j=ci+1;
 		while ( j < dup.size() ) {
 			ATNConfig c = dup.get(j);

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -34,10 +34,10 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.runtime.tree.TreeVisitor;
 import org.antlr.runtime.tree.TreeVisitorAction;
 import org.antlr.v4.Tool;
-import org.antlr.v4.misc.DoubleKeyMap;
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.parse.BlockSetTransformer;
 import org.antlr.v4.parse.GrammarASTAdaptor;
+import org.antlr.v4.runtime.misc.DoubleKeyMap;
 import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.ast.AltAST;
 import org.antlr.v4.tool.ast.BlockAST;

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFAState.java
Patch:
@@ -97,9 +97,9 @@ public class DFAState {
 	 *  on-the-fly. If this is not null, then this.prediction is
 	 *  ATN.INVALID_ALT_NUMBER.
 	 *
-	 *  We only treat these as disambiguating predicates when we found a
-	 *  conflict during SLL prediction where the use of context indicates
-	 *  that it's a true ambiguity.
+	 *  We only use these for non isCtxSensitive but conflicting states. That
+	 *  means we know from the context (it's $ or we don't dip into outer
+	 *  ctx) that it's an ambiguity not a conflict.
 	 *
 	 *  This list is computed by predicateDFAState() in ATN simulator.
 	 */

File: tool/playground/TestJava.java
Patch:
@@ -127,7 +127,7 @@ public static void parseFile(String f)
 				parser.setTokenStream(tokens);
 
 				if ( diag ) parser.addErrorListener(new DiagnosticErrorListener());
-				if ( SLL ) parser.getInterpreter().SLL = true;
+				if ( SLL ) parser.getInterpreter().setSLL(true);
 				// start parsing at the compilationUnit rule
 				ParserRuleContext<Token> tree = parser.compilationUnit();
 				if ( showTree ) tree.inspect(parser);

File: tool/playground/TestJavaLR.java
Patch:
@@ -260,7 +260,7 @@ public static void parseFile(String f) {
 			JavaLRParser parser = new JavaLRParser(tokens);
 			if ( diag ) parser.addErrorListener(new DiagnosticErrorListener());
 			if ( bail ) parser.setErrorHandler(new BailErrorStrategy());
-			if ( SLL ) parser.getInterpreter().SLL = true;
+			if ( SLL ) parser.getInterpreter().setSLL(true);
 
 			// start parsing at the compilationUnit rule
 			ParserRuleContext<Token> t = parser.compilationUnit();

File: tool/playground/TestT.java
Patch:
@@ -26,6 +26,8 @@ public static void main(String[] args) throws Exception {
 
 		parser.addErrorListener(new DiagnosticErrorListener());
 
+		parser.getInterpreter().setSLL(true);
+
 		ParserRuleContext tree = parser.s();
 		System.out.println(tree.toStringTree(parser));
 //		tree.save(parser, "/tmp/t.ps");

File: tool/test/org/antlr/v4/test/TestFullContextParsing.java
Patch:
@@ -239,8 +239,6 @@ public void testLoopsSimulateTailRecursion() throws Exception {
 		assertEquals("pass.\n", found);
 
 		String expecting =
-			"line 1:4 reportAttemptingFullContext d=1, input='a(i)<-'\n" +
-			"line 1:7 reportContextSensitivity d=1, input='a(i)<-x'\n" +
 			"line 1:3 reportAttemptingFullContext d=3, input='a(i)'\n" +
 			"line 1:7 reportAmbiguity d=3: ambigAlts={2..3}, input='a(i)<-x'\n";
 		assertEquals(expecting, this.stderrDuringParse);

File: runtime/Java/src/org/antlr/v4/runtime/atn/Transition.java
Patch:
@@ -99,7 +99,7 @@ protected Transition(@NotNull ATNState target) {
 		this.target = target;
 	}
 
-	public int getSerializationType() { return 0; }
+	public abstract int getSerializationType();
 
 	/** Are we epsilon, action, sempred? */
 	public boolean isEpsilon() { return false; }

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -212,7 +212,7 @@ public List<String> getTokenTypes(LexerGrammar lg,
 									  CharStream input,
 									  boolean adaptive)
 	{
-		LexerATNSimulator interp = new LexerATNSimulator(atn,null,null);
+		LexerATNSimulator interp = new LexerATNSimulator(atn,new DFA[1],null);
 		List<String> tokenTypes = new ArrayList<String>();
 		int ttype;
 		boolean hitEOF = false;

File: tool/test/org/antlr/v4/test/TestATNInterpreter.java
Patch:
@@ -6,6 +6,7 @@
 import org.antlr.v4.runtime.atn.ATNState;
 import org.antlr.v4.runtime.atn.BlockStartState;
 import org.antlr.v4.runtime.atn.LexerATNSimulator;
+import org.antlr.v4.runtime.dfa.DFA;
 import org.antlr.v4.runtime.misc.IntegerList;
 import org.antlr.v4.tool.DOTGenerator;
 import org.antlr.v4.tool.Grammar;
@@ -271,13 +272,11 @@ public void checkMatchedAlt(LexerGrammar lg, final Grammar g,
 								int expected)
 	{
 		ATN lexatn = createATN(lg);
-		LexerATNSimulator lexInterp = new LexerATNSimulator(lexatn,null,null);
+		LexerATNSimulator lexInterp = new LexerATNSimulator(lexatn,new DFA[1],null);
 		IntegerList types = getTokenTypesViaATN(inputString, lexInterp);
 		System.out.println(types);
 
-		semanticProcess(lg);
 		g.importVocab(lg);
-		semanticProcess(g);
 
 		ParserATNFactory f = new ParserATNFactory(g);
 		ATN atn = f.createATN();

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -122,6 +122,7 @@ public boolean add(ATNConfig e) {
 	 *  We use (s,i,pi) as key
 	 */
 	public boolean add(ATNConfig config, @Nullable PredictionContextCache contextCache) {
+		//contextCache = null; // TODO: costs time to cache and saves essentially no RAM
 		Key key = new Key(config);
 		ATNConfig existing = configToContext.get(key);
 		if ( existing==null ) { // nothing there yet; easy, just add

File: runtime/Java/src/org/antlr/v4/runtime/atn/ArrayPredictionContext.java
Patch:
@@ -145,6 +145,7 @@ public PredictionContext popAll(int invokingState,
 			else {
 				next = new SingletonPredictionContext(this.parents[i],
 													  this.invokingStates[i]);
+				if ( contextCache!=null ) next = contextCache.add(next);
 			}
 			boolean rootIsWildcard = fullCtx;
 			newCtx = merge(newCtx, next, contextCache, rootIsWildcard);

File: tool/playground/Foo.java
Patch:
@@ -4,7 +4,7 @@ private int bitsOrSingle(int bits, int ch) {
         if (ch < 256 &&
             !(3==4 && 5==6 &&
               (ch == 0xff || ch == 0xb5 ||
-               ch == 0x49 || ch == 0x69 ||  //I and i
+               ch == 0x49 || ch == 0x69 ||  //I and i // cmt out and it continues!
                ch == 0x53 || ch == 0x73 ||  //S and s
                ch == 0x4b || ch == 0x6b ||  //K and k
                ch == 0xc5 || ch == 0xe5)))  //A+ring

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContext.java
Patch:
@@ -335,6 +335,9 @@ else if ( a.invokingStates[i]<b.invokingStates[j] ) { // copy a[i] to M
 
 		PredictionContext M =
 			new ArrayPredictionContext(mergedParents, mergedInvokingStates);
+		if ( contextCache==null ) {
+			System.err.println("foooooo");
+		}
 		M = contextCache.add(M);
 
 		// if we created same array as a or b, return that instead

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -965,7 +965,7 @@ protected void closureCheckingStopStateAndLoopRecursion(@NotNull ATNConfig confi
 						if ( debug ) System.out.println("FALLING off rule "+
 														getRuleName(config.state.ruleIndex));
 						closure_(config, configs, closureBusy, collectPredicates, greedy,
-								 loopsSimulateTailRecursion, depth - 1);
+								 loopsSimulateTailRecursion, depth);
 						continue;
 					}
 					ATNState invokingState = atn.states.get(ctx.invokingState);

File: tool/playground/TestT.java
Patch:
@@ -26,7 +26,7 @@ public static void main(String[] args) throws Exception {
 
 		parser.addErrorListener(new DiagnosticErrorListener());
 
-		ParserRuleContext tree = parser.s();
+		ParserRuleContext tree = parser.stat();
 //		tree.save(parser, "/tmp/t.ps");
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/ArrayPredictionContext.java
Patch:
@@ -17,13 +17,13 @@ public class ArrayPredictionContext extends PredictionContext {
 
 	public ArrayPredictionContext(SingletonPredictionContext a) {
 		this(new PredictionContext[] {a.parent},
-			 new int[] {a.invokingState});
+			 new int[] {a==PredictionContext.EMPTY ? EMPTY_FULL_CTX_INVOKING_STATE : a.invokingState});
 	}
 
 	public ArrayPredictionContext(PredictionContext[] parents, int[] invokingStates) {
 		super(calculateHashCode(parents, invokingStates));
 		assert parents!=null && parents.length>0;
-//		System.out.println("CREATE ARRAY: "+Arrays.toString(parents)+", "+Arrays.toString(invokingStates));
+//		System.err.println("CREATE ARRAY: "+Arrays.toString(parents)+", "+Arrays.toString(invokingStates));
 		this.parents = parents;
 		this.invokingStates = invokingStates;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/SingletonPredictionContext.java
Patch:
@@ -82,7 +82,7 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		String up = parent.toString();
+		String up = parent!=null ? parent.toString() : "";
 		if ( up.length()==0 ) return String.valueOf(invokingState);
 		return String.valueOf(invokingState)+" "+up;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/EmptyPredictionContext.java
Patch:
@@ -35,6 +35,6 @@ public boolean equals(Object o) {
 
 	@Override
 	public String toString() {
-		return "";
+		return "$";
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -509,7 +509,7 @@ public void deleteWildcardConfigsForAlt(@NotNull ATNConfigSet closure, int ci, i
 	protected ATNConfigSet computeStartState(@NotNull IntStream input,
 											 @NotNull ATNState p)
 	{
-		PredictionContext initialContext = EmptyPredictionContext.EMPTY;
+		PredictionContext initialContext = PredictionContext.EMPTY;
 		ATNConfigSet configs = new ATNConfigSet();
 		for (int i=0; i<p.getNumberOfTransitions(); i++) {
 			ATNState target = p.transition(i).target;

File: runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java
Patch:
@@ -138,6 +138,7 @@ else if ( arg.equals("-ps") ) {
 		}
 		if ( lexerClass==null ) {
 			System.err.println("Can't load "+lexerName);
+			return;
 		}
 
 		InputStream is = System.in;

File: tool/src/org/antlr/v4/semantics/AttributeChecks.java
Patch:
@@ -168,7 +168,7 @@ public void nonLocalAttr(String expr, Token x, Token y) {
 			errMgr.toolError(ErrorType.UNDEFINED_RULE_IN_NONLOCAL_REF,
 							 x.getText(), y.getText());
 		}
-		if ( r.resolveToAttribute(y.getText(), null)==null ) {
+		else if ( r.resolveToAttribute(y.getText(), null)==null ) {
 			errMgr.grammarError(ErrorType.UNKNOWN_RULE_ATTRIBUTE,
 								g.fileName, y, y.getText(), x.getText(), expr);
 
@@ -182,7 +182,7 @@ public void setNonLocalAttr(String expr, Token x, Token y, Token rhs) {
 			errMgr.toolError(ErrorType.UNDEFINED_RULE_IN_NONLOCAL_REF,
 							 x.getText(), y.getText());
 		}
-		if ( r.resolveToAttribute(y.getText(), null)==null ) {
+		else if ( r.resolveToAttribute(y.getText(), null)==null ) {
 			errMgr.grammarError(ErrorType.UNKNOWN_RULE_ATTRIBUTE,
 								g.fileName, y, y.getText(), x.getText(), expr);
 

File: tool/src/org/antlr/v4/codegen/model/decl/Decl.java
Patch:
@@ -57,11 +57,10 @@ public int hashCode() {
 	/** If same name, can't redefine, unless it's a getter */
 	@Override
 	public boolean equals(Object obj) {
-		if ( obj==null ) return false;
+		if ( this==obj ) return true;
+		if ( !(obj instanceof Decl) ) return false;
 		// A() and label A are different
 		if ( obj instanceof ContextGetterDecl ) return false;
-		if ( this==obj ) return true;
-		if ( this.hashCode() != obj.hashCode() ) return false;
 		return name.equals(((Decl) obj).name);
 	}
 }

File: tool/src/org/antlr/v4/parse/TokenVocabParser.java
Patch:
@@ -59,7 +59,7 @@ public Map<String,Integer> load() {
 		int maxTokenType = -1;
 		File fullFile = getImportedVocabFile();
 		try {
-			Pattern tokenDefPattern = Pattern.compile("([^ ]+?)[ \\t]*?=[ \\t]*?([0-9]+)");
+			Pattern tokenDefPattern = Pattern.compile("([^\n]+?)[ \\t]*?=[ \\t]*?([0-9]+)");
 			FileReader fr = new FileReader(fullFile);
 			BufferedReader br = new BufferedReader(fr);
 			String tokenDef = br.readLine();

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -125,6 +125,8 @@ public void reset() {
 		getInterpreter().reset();
 	}
 
+	public LexerATNSimulator getInterpreter() { return _interp; }
+
 	/** Return a token from this source; i.e., match a token on the char
 	 *  stream.
 	 */

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -124,6 +124,8 @@ public void reset() {
 		}
 	}
 
+	public ParserATNSimulator getInterpreter() { return _interp; }
+
 	/** Match current input symbol against ttype.  Attempt
 	 *  single token insertion or deletion error recovery.  If
 	 *  that fails, throw MismatchedTokenException.

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -99,6 +99,8 @@ public abstract class Lexer extends Recognizer<Integer, LexerATNSimulator>
 	 */
 	public String _text;
 
+	public Lexer() { }
+
 	public Lexer(CharStream input) {
 		this._input = input;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -99,6 +99,8 @@ public abstract class Lexer extends Recognizer<Integer, LexerATNSimulator>
 	 */
 	public String _text;
 
+	public Lexer() { }
+
 	public Lexer(CharStream input) {
 		this._input = input;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/DiagnosticErrorListener.java
Patch:
@@ -35,7 +35,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.runtime.misc.NotNull;
 
-public class DiagnosticErrorListener extends BaseErrorListener<Token> {
+public class DiagnosticErrorListener extends BaseErrorListener {
     @Override
     public void reportAmbiguity(@NotNull Parser recognizer,
 								DFA dfa, int startIndex, int stopIndex, @NotNull IntervalSet ambigAlts,

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -360,7 +360,7 @@ public void notifyListeners(LexerNoViableAltException e) {
 		String msg = "token recognition error at: '"+
 			_input.getText(Interval.of(_tokenStartCharIndex, _input.index()))+"'";
 
-		ANTLRErrorListener<? super Integer> listener = getErrorListenerDispatch();
+		ANTLRErrorListener listener = getErrorListenerDispatch();
 		listener.syntaxError(this, null, _tokenStartLine, _tokenStartCharPositionInLine, msg, e);
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -316,7 +316,7 @@ public void notifyErrorListeners(Token offendingToken, String msg,
 			charPositionInLine = ((Token) offendingToken).getCharPositionInLine();
 		}
 
-		ANTLRErrorListener<? super Token> listener = getErrorListenerDispatch();
+		ANTLRErrorListener listener = getErrorListenerDispatch();
 		listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/CommonTokenStream.java
Patch:
@@ -43,7 +43,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *  whitespace and comments etc. to the parser on a hidden channel (i.e.,
  *  you set $channel instead of calling skip() in lexer rules.)
  *
- *  @see UnbufferedTokenStream
+ *  @see OldUnbufferedTokenStream
  *  @see BufferedTokenStream
  */
 public class CommonTokenStream extends BufferedTokenStream<Token> {

File: runtime/Java/src/org/antlr/v4/runtime/Token.java
Patch:
@@ -54,7 +54,7 @@ public interface Token {
 	/** Anything on different channel than DEFAULT_CHANNEL is not parsed
 	 *  by parser.
 	 */
-	public static final int HIDDEN_CHANNEL = 99;
+	public static final int HIDDEN_CHANNEL = 1;
 
 	/** Get the text of the token */
 	String getText();

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -329,7 +329,7 @@ public void notifyListeners(LexerNoViableAltException e) {
 			_input.getText(Interval.of(_tokenStartCharIndex, _input.index()))+"'";
 
 		ANTLRErrorListener<? super Integer> listener = getErrorListenerDispatch();
-		listener.error(this, null, _tokenStartLine, _tokenStartCharPositionInLine, msg, e);
+		listener.syntaxError(this, null, _tokenStartLine, _tokenStartCharPositionInLine, msg, e);
 	}
 
 	public String getCharErrorDisplay(int c) {

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -317,7 +317,7 @@ public void notifyErrorListeners(Token offendingToken, String msg,
 		}
 
 		ANTLRErrorListener<? super Token> listener = getErrorListenerDispatch();
-		listener.error(this, offendingToken, line, charPositionInLine, msg, e);
+		listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
 	}
 
 	/** Consume the current symbol and return it. E.g., given the following

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -543,7 +543,7 @@ private static class DescriptiveErrorListener extends BaseErrorListener<Token> {
 		public static DescriptiveErrorListener INSTANCE = new DescriptiveErrorListener();
 
 		@Override
-		public <T extends Token> void error(Recognizer<T, ?> recognizer, T offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
+		public <T extends Token> void syntaxError(Recognizer<T, ?> recognizer, T offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
 			String sourceName = recognizer.getInputStream().getSourceName();
 			sourceName = sourceName != null && !sourceName.isEmpty() ? sourceName+": " : "";
 			System.err.println(sourceName+"line "+line+":"+charPositionInLine+" "+msg);

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -128,7 +128,7 @@ public Option(String fieldName, String name, OptionArgType argType, String descr
 
     public static Option[] optionDefs = {
         new Option("outputDirectory",	"-o", OptionArgType.STRING, "specify output directory where all output is generated"),
-        new Option("libDirectory",		"-lib", OptionArgType.STRING, "specify location of .token files"),
+        new Option("libDirectory",		"-lib", OptionArgType.STRING, "specify location of grammars, tokens files"),
         new Option("report",			"-report", "print out a report about the grammar(s) processed"),
         new Option("printGrammar",		"-print", "print out the grammar without actions"),
         new Option("debug",				"-debug", "generate a parser that emits debugging events"),

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -91,6 +91,8 @@ public int hashCode() {
 	// TODO: can we track conflicts as they are added to save scanning configs later?
 	public int uniqueAlt;
 	public IntervalSet conflictingAlts;
+	// Used in parser and lexer. In lexer, it indicates we hit a pred
+	// while computing a closure operation.  Don't make a DFA state from this.
 	public boolean hasSemanticContext;
 	public boolean dipsIntoOuterContext;
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -95,7 +95,7 @@ public static String toStringTree(Tree t, Parser recog) {
 		return buf.toString();
 	}
 
-	public static <Symbol> String getNodeText(Tree t, Parser recog) {
+	public static String getNodeText(Tree t, Parser recog) {
 		if ( recog!=null ) {
 			if ( t instanceof ParseTree.RuleNode ) {
 				int ruleIndex = ((ParseTree.RuleNode)t).getRuleContext().getRuleIndex();

File: tool/playground/TestU.java
Patch:
@@ -1,14 +1,13 @@
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.ParserRuleContext;
 
 public class TestU {
 	public static void main(String[] args) throws Exception {
 		ULexer t = new ULexer(new ANTLRFileStream(args[0]));
 		CommonTokenStream tokens = new CommonTokenStream(t);
 		UParser p = new UParser(tokens);
 		p.setBuildParseTree(true);
-		ParserRuleContext r = p.s();
-		System.out.println(r.toStringTree(p));
+//		ParserRuleContext r = p.s();
+//		System.out.println(r.toStringTree(p));
 	}
 }

File: tool/src/org/antlr/v4/tool/AttributeDict.java
Patch:
@@ -59,7 +59,6 @@ public class AttributeDict {
         add(new Attribute("index"));
         add(new Attribute("pos"));
         add(new Attribute("channel"));
-        add(new Attribute("tree"));
         add(new Attribute("int"));
     }};
 

File: tool/test/org/antlr/v4/test/TestActionTranslation.java
Patch:
@@ -125,8 +125,7 @@ public class TestActionTranslation extends BaseTest {
 	@Test public void testRefToTextAttributeForCurrentRule() throws Exception {
         String action = "$a.text; $text";
 		String expected =
-			"(_localctx.a!=null?_input.getText(_localctx.a.start,_localctx.a.stop):" +
-			"null); _input.getText(_localctx.start, _input.LT(-1))";
+			"_input.getText(_localctx.start, _input.LT(-1)); _input.getText(_localctx.start, _input.LT(-1))";
 		testActions(attributeTemplate, "init", action, expected);
 		expected =
 			"_input.getText(_localctx.start, _input.LT(-1)); _input.getText(_localctx.start, _input.LT(-1))";

File: tool/test/org/antlr/v4/test/TestListeners.java
Patch:
@@ -6,6 +6,7 @@ public class TestListeners extends BaseTest {
 	@Test public void testBasic() throws Exception {
 		String grammar =
 			"grammar T;\n" +
+			"@header {import org.antlr.v4.runtime.tree.ParseTree;}\n"+
 			"@members {\n" +
 			"public static class LeafListener extends TBaseListener {\n" +
 			"    public void visitTerminal(ParseTree.TerminalNode<Token> node) {\n" +
@@ -69,7 +70,7 @@ public class TestListeners extends BaseTest {
 
 		result = execParser("T.g4", grammar, "TParser", "TLexer", "s", "abc", false);
 		expecting = "(a abc)\n" +
-					"[@0,0:2='abc',<6>,1:0]\n";
+					"[@0,0:2='abc',<4>,1:0]\n";
 		assertEquals(expecting, result);
 	}
 

File: tool/test/org/antlr/v4/test/TestParseErrors.java
Patch:
@@ -78,7 +78,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x='b' {System.out.println(\"conjured=\"+$x);} 'c' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ac", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<3>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 
@@ -97,7 +97,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x=('b'|'c') {System.out.println(\"conjured=\"+$x);} 'd' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ad", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<3>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 

File: tool/test/org/antlr/v4/test/TestUnbufferedCharStream.java
Patch:
@@ -35,7 +35,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import java.io.StringReader;
 
-public class TestUnbufferedInputStream extends BaseTest {
+public class TestUnbufferedCharStream extends BaseTest {
 	@Test public void testNoChar() throws Exception {
 		CharStream input = new UnbufferedCharStream(
 				new StringReader("")

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -43,6 +43,8 @@ public class ATNConfigSet extends OrderedHashSet<ATNConfig> {
 	// TODO: can we track conflicts as they are added to save scanning configs later?
 	public int uniqueAlt;
 	public IntervalSet conflictingAlts;
+	// Used in parser and lexer. In lexer, it indicates we hit a pred
+	// while computing a closure operation.  Don't make a DFA state from this.
 	public boolean hasSemanticContext;
 	public boolean dipsIntoOuterContext;
 

File: tool/playground/TestU.java
Patch:
@@ -1,14 +1,13 @@
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.ParserRuleContext;
 
 public class TestU {
 	public static void main(String[] args) throws Exception {
 		ULexer t = new ULexer(new ANTLRFileStream(args[0]));
 		CommonTokenStream tokens = new CommonTokenStream(t);
 		UParser p = new UParser(tokens);
 		p.setBuildParseTree(true);
-		ParserRuleContext r = p.s();
-		System.out.println(r.toStringTree(p));
+//		ParserRuleContext r = p.s();
+//		System.out.println(r.toStringTree(p));
 	}
 }

File: tool/test/org/antlr/v4/test/TestSemPredEvalLexer.java
Patch:
@@ -62,7 +62,7 @@ public class TestSemPredEvalLexer extends BaseTest {
 			":s2=>2-'u'->:s3=>2\n" +
 			":s3=>2-'m'->:s4=>2\n" +
 			":s4=>2-'b'->:s4=>2\n" +
-			":s4=>2-'c'->:s4=>2\n\n";
+			":s4=>2-'c'->:s4=>2\n";
 		assertEquals(expecting, found);
 	}
 

File: tool/test/org/antlr/v4/test/TestATNInterpreter.java
Patch:
@@ -198,7 +198,7 @@ public class TestATNInterpreter extends BaseTest {
 			errorTokenType = re.getOffendingToken().getType();
 		}
 		assertEquals(2, errorIndex);
-		assertEquals(6, errorTokenType);
+		assertEquals(4, errorTokenType);
 
 		checkMatchedAlt(lg, g, "abcd", 3); // ignores d on end
 	}

File: tool/test/org/antlr/v4/test/TestActionTranslation.java
Patch:
@@ -125,8 +125,7 @@ public class TestActionTranslation extends BaseTest {
 	@Test public void testRefToTextAttributeForCurrentRule() throws Exception {
         String action = "$a.text; $text";
 		String expected =
-			"(_localctx.a!=null?_input.getText(_localctx.a.start,_localctx.a.stop):" +
-			"null); _input.getText(_localctx.start, _input.LT(-1))";
+			"_input.getText(_localctx.start, _input.LT(-1)); _input.getText(_localctx.start, _input.LT(-1))";
 		testActions(attributeTemplate, "init", action, expected);
 		expected =
 			"_input.getText(_localctx.start, _input.LT(-1)); _input.getText(_localctx.start, _input.LT(-1))";

File: tool/test/org/antlr/v4/test/TestListeners.java
Patch:
@@ -6,6 +6,7 @@ public class TestListeners extends BaseTest {
 	@Test public void testBasic() throws Exception {
 		String grammar =
 			"grammar T;\n" +
+			"@header {import org.antlr.v4.runtime.tree.ParseTree;}\n"+
 			"@members {\n" +
 			"public static class LeafListener extends TBaseListener {\n" +
 			"    public void visitTerminal(ParseTree.TerminalNode<Token> node) {\n" +
@@ -69,7 +70,7 @@ public class TestListeners extends BaseTest {
 
 		result = execParser("T.g4", grammar, "TParser", "TLexer", "s", "abc", false);
 		expecting = "(a abc)\n" +
-					"[@0,0:2='abc',<6>,1:0]\n";
+					"[@0,0:2='abc',<4>,1:0]\n";
 		assertEquals(expecting, result);
 	}
 

File: tool/test/org/antlr/v4/test/TestParseErrors.java
Patch:
@@ -78,7 +78,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x='b' {System.out.println(\"conjured=\"+$x);} 'c' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ac", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<3>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 
@@ -97,7 +97,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x=('b'|'c') {System.out.println(\"conjured=\"+$x);} 'd' ;";
 		String result = execParser("T.g4", grammar, "TParser", "TLexer", "a", "ad", false);
-		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<3>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<1>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 

File: tool/test/org/antlr/v4/test/TestATNInterpreter.java
Patch:
@@ -80,7 +80,7 @@ public class TestATNInterpreter extends BaseTest {
 			errorTokenType = re.getOffendingToken().getType();
 		}
 		assertEquals(1, errorIndex);
-		assertEquals(errorTokenType, 5);
+		assertEquals(3, errorTokenType);
 	}
 
 	@Test public void testMustTrackPreviousGoodAlt2() throws Exception {
@@ -106,7 +106,7 @@ public class TestATNInterpreter extends BaseTest {
 			errorTokenType = re.getOffendingToken().getType();
 		}
 		assertEquals(2, errorIndex);
-		assertEquals(errorTokenType, 6);
+		assertEquals(4, errorTokenType);
 	}
 
 	@Test public void testMustTrackPreviousGoodAlt3() throws Exception {
@@ -129,7 +129,7 @@ public class TestATNInterpreter extends BaseTest {
 			errorTokenType = re.getOffendingToken().getType();
 		}
 		assertEquals(2, errorIndex);
-		assertEquals(errorTokenType, 6);
+		assertEquals(4, errorTokenType);
 	}
 
 	@Test public void testAmbigAltChooseFirst() throws Exception {

File: tool/test/org/antlr/v4/test/TestCommonTokenStream.java
Patch:
@@ -114,7 +114,7 @@ public class TestCommonTokenStream extends BaseTest {
         tokens.LT(i++); // push it past end
         tokens.LT(i++);
 
-        String result = tokens.toString();
+        String result = tokens.getText();
         String expecting = "x = 3 * 0 + 2 * 0;";
         assertEquals(expecting, result);
     }
@@ -146,7 +146,7 @@ public class TestCommonTokenStream extends BaseTest {
         tokens.consume();
         tokens.LT(1);
 
-        String result = tokens.toString();
+        String result = tokens.getText();
         String expecting = "x = 3 * 0 + 2 * 0;";
         assertEquals(expecting, result);
     }

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -95,7 +95,7 @@ public static String toStringTree(Tree t, Parser recog) {
 		return buf.toString();
 	}
 
-	public static <Symbol> String getNodeText(Tree t, Parser recog) {
+	public static String getNodeText(Tree t, Parser recog) {
 		if ( recog!=null ) {
 			if ( t instanceof ParseTree.RuleNode ) {
 				int ruleIndex = ((ParseTree.RuleNode)t).getRuleContext().getRuleIndex();

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -92,7 +92,7 @@ public void exitEveryRule(ParserRuleContext<Token> ctx) {
 	 */
 	protected ParserRuleContext<Token> _ctx;
 
-	protected boolean _buildParseTrees;
+	protected boolean _buildParseTrees = true;
 
 	protected TraceListener _tracer;
 

File: runtime/Java/src/org/antlr/v4/runtime/CommonToken.java
Patch:
@@ -28,6 +28,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime;
 
+import org.antlr.v4.runtime.misc.Interval;
+
 import java.io.Serializable;
 
 public class CommonToken implements WritableToken, Serializable {
@@ -109,7 +111,7 @@ public String getText() {
 		if ( input==null ) return null;
 		int n = input.size();
 		if ( start<n && stop<n) {
-			return input.substring(start,stop);
+			return input.getText(Interval.of(start,stop));
 		}
 		else {
 			return "<EOF>";

File: runtime/Java/src/org/antlr/v4/runtime/ConsoleErrorListener.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *
  * @author Sam Harwell
  */
-public class ConsoleErrorListener implements ANTLRErrorListener<Object> {
+public class ConsoleErrorListener extends BaseErrorListener<Object> {
 	public static final ConsoleErrorListener INSTANCE = new ConsoleErrorListener();
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/LexerNoViableAltException.java
Patch:
@@ -30,6 +30,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime;
 
 import org.antlr.v4.runtime.atn.ATNConfigSet;
+import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.Utils;
 
 public class LexerNoViableAltException extends RecognitionException {
@@ -57,7 +58,7 @@ public CharStream getInputStream() {
 	public String toString() {
 		String symbol = "";
 		if (startIndex >= 0 && startIndex < input.size()) {
-			symbol = getInputStream().substring(startIndex, startIndex);
+			symbol = getInputStream().getText(Interval.of(startIndex,startIndex));
 			symbol = Utils.escapeWhitespace(symbol, false);
 		}
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -41,7 +41,7 @@ public interface SyntaxTree extends Tree {
 	 *  node is a leaf, then the interval represents a single token.
 	 *
 	 *  If source interval is unknown, this does not return null.
-	 *  It returns an interval of length 0.
+	 *  It returns Interval.INVALID.
 	 */
 	Interval getSourceInterval();
 }

File: tool/playground/TestJava.java
Patch:
@@ -7,7 +7,7 @@
 import java.io.File;
 
 /** Parse a java file or directory of java files using the generated parser
- *  ANTLR builds from java.g
+ *  ANTLR builds from java.g4
  */
 class TestJava {
 	public static long lexerTime = 0;

File: tool/playground/TestR.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.DiagnosticErrorStrategy;
+import org.antlr.v4.runtime.DiagnosticErrorListener;
 
 public class TestR {
 	public static void main(String[] args) throws Exception {
@@ -41,7 +41,7 @@ public static void main(String[] args) throws Exception {
 //		}
 		RParser p = new RParser(tokens);
 		p.setBuildParseTree(true);
-		p.setErrorHandler(new DiagnosticErrorStrategy());
+		p.addErrorListener(new DiagnosticErrorListener());
 		p.prog();
 	}
 }

File: tool/playground/TestYang.java
Patch:
@@ -7,7 +7,7 @@
 import java.io.File;
 
 /** Parse a java file or directory of java files using the generated parser
- *  ANTLR builds from java.g
+ *  ANTLR builds from java.g4
  */
 class TestYang {
 	public static long lexerTime = 0;

File: tool/src/org/antlr/v4/codegen/CodeGenerator.java
Patch:
@@ -257,7 +257,7 @@ public void write(ST code, String fileName) {
 		}
 	}
 
-	/** Generate TParser.java and TLexer.java from T.g if combined, else
+	/** Generate TParser.java and TLexer.java from T.g4 if combined, else
 	 *  just use T.java as output regardless of type.
 	 */
 	public String getRecognizerFileName() {

File: tool/src/org/antlr/v4/codegen/model/Lexer.java
Patch:
@@ -49,6 +49,7 @@ public class Lexer extends OutputModelObject {
 	public String[] tokenNames;
 	public Set<String> ruleNames;
 	public Collection<String> modes;
+	public boolean abstractRecognizer;
 
 	@ModelElement public SerializedATN atn;
 	@ModelElement public LinkedHashMap<Rule, RuleActionFunction> actionFuncs =
@@ -89,6 +90,7 @@ public Lexer(OutputModelFactory factory, LexerFile file) {
             }
         }
 		ruleNames = g.rules.keySet();
+		abstractRecognizer = g.isAbstract();
 	}
 
 }

File: tool/src/org/antlr/v4/codegen/model/Parser.java
Patch:
@@ -47,6 +47,7 @@ public class Parser extends OutputModelObject {
 	public Set<String> ruleNames;
 	public Collection<Rule> rules;
 	public ParserFile file;
+	public boolean abstractRecognizer;
 
 	@ModelElement public List<RuleFunction> funcs = new ArrayList<RuleFunction>();
 	@ModelElement public SerializedATN atn;
@@ -89,5 +90,7 @@ public Parser(OutputModelFactory factory, ParserFile file) {
 		} else {
 			superclass = new DefaultParserSuperClass();
 		}
+
+		abstractRecognizer = g.isAbstract();
 	}
 }

File: tool/src/org/antlr/v4/parse/TokenVocabParser.java
Patch:
@@ -137,7 +137,7 @@ else if ( token == '\'' ) {
 	}
 
 	/** Return a File descriptor for vocab file.  Look in library or
-	 *  in -o output path.  antlr -o foo T.g U.g where U needs T.tokens
+	 *  in -o output path.  antlr -o foo T.g4 U.g4 where U needs T.tokens
 	 *  won't work unless we look in foo too. If we do not find the
 	 *  file in the lib directory then must assume that the .tokens file
 	 *  is going to be generated as part of this build and we have defined

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -74,6 +74,7 @@ public class BasicSemanticChecks extends GrammarTreeVisitor {
 				add("TokenLabelType");
 				add("superClass");
 				add("filter");
+				add("abstract");
 			}
 		};
 
@@ -83,6 +84,7 @@ public class BasicSemanticChecks extends GrammarTreeVisitor {
 				add("tokenVocab");
 				add("TokenLabelType");
 				add("superClass");
+				add("abstract");
 			}
 		};
 

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -131,7 +131,7 @@ public ST getMessageTemplate(ANTLRMessage msg) {
 			locationValid = true;
 		}
 
-		messageFormatST.add("id", msg.errorType.ordinal());
+		messageFormatST.add("id", msg.errorType.code);
 		messageFormatST.add("text", messageST);
 
 		if (locationValid) reportST.add("location", locationST);

File: tool/test/org/antlr/v4/test/TestATNConstruction.java
Patch:
@@ -360,14 +360,14 @@ public void testA() throws Exception {
 	@Test public void testNestedAstar() throws Exception {
 		Grammar g = new Grammar(
 			"parser grammar P;\n"+
-			"a : (',' ID*)*;");
+			"a : (COMMA ID*)*;");
 		String expecting =
 			"RuleStart_a_0->StarLoopEntry_13\n" +
 			"StarLoopEntry_13->StarBlockStart_11\n" +
 			"StarLoopEntry_13->s14\n" +
 			"StarBlockStart_11->s2\n" +
 			"s14->RuleStop_a_1\n" +
-			"s2-','->StarLoopEntry_8\n" +
+			"s2-COMMA->StarLoopEntry_8\n" +
 			"RuleStop_a_1-EOF->s16\n" +
 			"StarLoopEntry_8->StarBlockStart_6\n" +
 			"StarLoopEntry_8->s9\n" +

File: tool/test/org/antlr/v4/test/TestSemPredEvalLexer.java
Patch:
@@ -11,7 +11,7 @@ public class TestSemPredEvalLexer extends BaseTest {
 			"E2 : {true}? 'enum' ;\n" +  // winner not E1 or ID
 			"ID : 'a'..'z'+ ;\n"+
 			"WS : (' '|'\\n') {skip();} ;";
-		String found = execLexer("L.g", grammar, "L", "enum abc", true);
+		String found = execLexer("L.g4", grammar, "L", "enum abc", true);
 		String expecting =
 			"[@0,0:3='enum',<4>,1:0]\n" +
 			"[@1,5:7='abc',<5>,1:5]\n" +
@@ -26,7 +26,7 @@ public class TestSemPredEvalLexer extends BaseTest {
 			"E2 : 'enum' {true}? ;\n" +  // winner not E1 or ID
 			"ID : 'a'..'z'+ ;\n"+
 			"WS : (' '|'\\n') {skip();} ;";
-		String found = execLexer("L.g", grammar, "L", "enum abc enum", true);
+		String found = execLexer("L.g4", grammar, "L", "enum abc enum", true);
 		String expecting =
 			"[@0,0:3='enum',<4>,1:0]\n" +
 			"[@1,5:7='abc',<5>,1:5]\n" +
@@ -50,7 +50,7 @@ public void testMatchNChar() throws Exception { // can't do locals yet
 			"B : {int n=0;} ({n<=2}? DIGIT {n++})+ ;\n" +
 			"fragment DIGIT : '0'..'9' ;\n"+
 			"WS : (' '|'\\n') {skip();} ;";
-		String found = execLexer("L.g", grammar, "L", "1234 56", true);
+		String found = execLexer("L.g4", grammar, "L", "1234 56", true);
 		String expecting =
 			"[@0,0:3='enum',<4>,1:0]\n" +
 			"[@1,5:7='abc',<5>,1:5]\n" +

File: tool/test/org/antlr/v4/test/TestTokenTypeAssignment.java
Patch:
@@ -136,7 +136,7 @@ public void testParserSimpleTokens() throws Exception {
 			"A : 'a' ;\n" +
 			"B : '}' ;\n"+
 			"WS : (' '|'\\n') {skip();} ;";
-		String found = execParser("P.g", grammar, "PParser", "PLexer",
+		String found = execParser("P.g4", grammar, "PParser", "PLexer",
 								  "a", "a}", false);
 		assertEquals("a}\n", found);
 	}
@@ -151,7 +151,7 @@ public void testParserSimpleTokens() throws Exception {
 			"A : 'a' ;\n" +
 			"B : '}' ;\n"+
 			"WS : (' '|'\\n') {skip();} ;";
-		String found = execParser("P.g", grammar, "PParser", "PLexer",
+		String found = execParser("P.g4", grammar, "PParser", "PLexer",
 								  "a", "a}", false);
 		assertEquals("a}\n", found);
 	}

File: tool/test/org/antlr/v4/test/TestCompositeGrammars.java
Patch:
@@ -653,7 +653,7 @@ public class TestCompositeGrammars extends BaseTest {
 			"s : a ;\n" +
 			"B : 'b' ;" + // defines B from inherited token space
 			"WS : (' '|'\\n') {skip();} ;\n" ;
-		boolean ok = antlr("M.g4", "M.g4", master);
+		boolean ok = antlr("M.g4", "M.g4", master, false);
 		boolean expecting = true; // should be ok
 		assertEquals(expecting, ok);
 	}

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -433,7 +433,7 @@ protected void compileJavaParser(boolean leftRecursive) throws IOException {
             extraOptions.add("-atn");
         }
         String[] extraOptionsArray = extraOptions.toArray(new String[extraOptions.size()]);
-        boolean success = rawGenerateAndBuildRecognizer(grammarFileName, body, "JavaParser", "JavaLexer", extraOptionsArray);
+        boolean success = rawGenerateAndBuildRecognizer(grammarFileName, body, "JavaParser", "JavaLexer", true, extraOptionsArray);
         assertTrue(success);
     }
 

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -426,6 +426,7 @@ protected void compileJavaParser(boolean leftRecursive) throws IOException {
         String body = load(sourceName, null);
         @SuppressWarnings({"ConstantConditions"})
         List<String> extraOptions = new ArrayList<String>();
+		extraOptions.add("-Werror");
         if (FORCE_ATN) {
             extraOptions.add("-Xforce-atn");
         }

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -52,6 +52,7 @@ public enum ErrorType {
 	OUTPUT_DIR_IS_FILE(6, "output directory is a file: <arg>", ErrorSeverity.ERROR),
 	CANNOT_OPEN_FILE(7, "cannot find or open file: <arg><if(exception)>; reason: <exception><endif>", ErrorSeverity.ERROR),
 	FILE_AND_GRAMMAR_NAME_DIFFER(8, "grammar name <arg> and file name <arg2> differ", ErrorSeverity.ERROR),
+	WARNING_TREATED_AS_ERROR(9, "warning treated as error", ErrorSeverity.ERROR),
 //	FILENAME_EXTENSION_ERROR("", ErrorSeverity.ERROR),
 
 	INTERNAL_ERROR(20, "internal error: <arg> <arg2><if(exception)>: <exception><endif>\n" +

File: tool/test/org/antlr/v4/test/TestATNConstruction.java
Patch:
@@ -360,14 +360,14 @@ public void testA() throws Exception {
 	@Test public void testNestedAstar() throws Exception {
 		Grammar g = new Grammar(
 			"parser grammar P;\n"+
-			"a : (',' ID*)*;");
+			"a : (COMMA ID*)*;");
 		String expecting =
 			"RuleStart_a_0->StarLoopEntry_13\n" +
 			"StarLoopEntry_13->StarBlockStart_11\n" +
 			"StarLoopEntry_13->s14\n" +
 			"StarBlockStart_11->s2\n" +
 			"s14->RuleStop_a_1\n" +
-			"s2-','->StarLoopEntry_8\n" +
+			"s2-COMMA->StarLoopEntry_8\n" +
 			"RuleStop_a_1-EOF->s16\n" +
 			"StarLoopEntry_8->StarBlockStart_6\n" +
 			"StarLoopEntry_8->s9\n" +

File: tool/test/org/antlr/v4/test/TestSymbolIssues.java
Patch:
@@ -46,7 +46,8 @@ public class TestSymbolIssues extends BaseTest {
 		"error(69): B.g4:4:4: label s conflicts with rule with same name\n" +
 		"error(69): B.g4:4:9: label b conflicts with rule with same name\n" +
 		"error(70): B.g4:4:15: label X conflicts with token with same name\n" +
-		"error(75): B.g4:6:9: label x type mismatch with previous definition: TOKEN_LIST_LABEL!=TOKEN_LABEL\n"
+		"error(75): B.g4:6:9: label x type mismatch with previous definition: TOKEN_LIST_LABEL!=TOKEN_LABEL\n" +
+		"error(126): B.g4:4:20: cannot create implicit token for string literal '.' in non-combined grammar\n"
     };
 
     static String[] D = {

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -145,6 +145,7 @@ public enum ErrorType {
 	ALT_LABEL_REDEF(123, "rule alt label <arg> redefined in rule <arg2>, originally in <arg3>", ErrorSeverity.ERROR),
 	ALT_LABEL_CONFLICTS_WITH_RULE(124, "rule alt label <arg> conflicts with rule <arg2>", ErrorSeverity.ERROR),
 	IMPLICIT_TOKEN_DEFINITION(125, "implicit definition of token <arg> in parser", ErrorSeverity.WARNING),
+	IMPLICIT_STRING_DEFINITION(126, "cannot create implicit token for string literal <arg> in non-combined grammar", ErrorSeverity.ERROR),
 
 	/** Documentation comment is unterminated */
     //UNTERMINATED_DOC_COMMENT(, "", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -131,7 +131,7 @@ public ST getMessageTemplate(ANTLRMessage msg) {
 			locationValid = true;
 		}
 
-		messageFormatST.add("id", msg.errorType.ordinal());
+		messageFormatST.add("id", msg.errorType.code);
 		messageFormatST.add("text", messageST);
 
 		if (locationValid) reportST.add("location", locationST);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -397,7 +397,7 @@ public int execDFA(@NotNull DFA dfa, @NotNull DFAState s0,
 				if ( dfa_debug && t>=0 ) System.out.println("no edge for "+parser.getTokenNames()[t]);
 				int alt;
 				if ( dfa_debug ) {
-					Interval interval = Interval.of(startIndex, parser.getTokenStream().size()-1);
+					Interval interval = Interval.of(startIndex, parser.getTokenStream().index());
 					System.out.println("ATN exec upon "+
 									   parser.getTokenStream().getText(interval) +
 									   " at DFA state "+s.stateNumber);

File: tool/test/org/antlr/v4/test/TestListeners.java
Patch:
@@ -192,7 +192,7 @@ public class TestListeners extends BaseTest {
 			"1\n" +
 			"2\n" +
 			"3\n" +
-			"1 [14 6]\n";
+			"1 [16 6]\n";
 		assertEquals(expecting, result);
 	}
 }

File: tool/test/org/antlr/v4/test/TestNonGreedyLoops.java
Patch:
@@ -601,7 +601,7 @@ public void testFindHTMLTags() throws Exception {
 		// Seeing '.' in a lookahead prediction can be misleading!!
 		found = execParser("T.g", grammar, "TParser", "TLexer", "s",
 								  "x <><a>", true);
-		assertEquals("null\n" +
+		assertEquals("<\n" +
 					 "<a>\n" +
 					 "Decision 0:\n" +
 					 "s0-'x'->s1\n" +

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -47,7 +47,7 @@ public abstract class Recognizer<Symbol, ATNInterpreter extends ATNSimulator> {
 
 	protected ATNInterpreter _interp;
 
-	private int _stateNumber;
+	private int _stateNumber = -1;
 
 	/** Used to print out token names like ID during debugging and
 	 *  error reporting.  The generated parsers implement a method

File: runtime/Java/src/org/antlr/v4/runtime/ParserRuleContext.java
Patch:
@@ -294,7 +294,7 @@ public <T extends ParserRuleContext<?>> List<? extends T> getRuleContexts(Class<
 
 	@Override
 	public Interval getSourceInterval() {
-		if ( start==null || stop==null ) return Interval.EMPTY;
+		if ( start==null || stop==null ) return Interval.INVALID;
 		return Interval.of(start.getTokenIndex(), stop.getTokenIndex());
 	}
 
@@ -305,7 +305,7 @@ public Interval getSourceInterval() {
 	 */
 	public String getText(TokenStream tokens) {
 		Interval range = getSourceInterval();
-		return range==Interval.EMPTY ? null : tokens.toString(range.a, range.b);
+		return range==Interval.INVALID ? null : tokens.toString(range.a, range.b);
 	}
 
 	public Symbol getStart() { return start; }

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -212,7 +212,7 @@ public boolean isEmpty() {
 
 	@Override
 	public Interval getSourceInterval() {
-		return Interval.EMPTY;
+		return Interval.INVALID;
 	}
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/misc/Interval.java
Patch:
@@ -33,7 +33,6 @@ public class Interval {
 	public static final int INTERVAL_POOL_MAX_VALUE = 1000;
 
 	public static final Interval INVALID = new Interval(-1,-2);
-	public static final Interval EMPTY = new Interval(0,-1); // len 0
 
 	static Interval[] cache = new Interval[INTERVAL_POOL_MAX_VALUE+1];
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -41,7 +41,7 @@ public interface SyntaxTree extends Tree {
 	 *  node is a leaf, then the interval represents a single token.
 	 *
 	 *  If source interval is unknown, this does not return null.
-	 *  It returns an interval of length 0: Interval.EMPTY.
+	 *  It returns Interval.INVALID.
 	 */
 	Interval getSourceInterval();
 }

File: tool/test/org/antlr/v4/test/TestSemPredEvalParser.java
Patch:
@@ -153,7 +153,7 @@ public class TestSemPredEvalParser extends BaseTest {
 			"alt 1\n" +
 			"alt 1\n";
 		assertEquals(expecting, found);
-        assertEquals("line 1:0 reportAmbiguity d=0: ambigAlts={1..2}:[(6,1,[],up=1), (1,1,[],up=1), (6,2,[],up=1), (1,2,[],up=1), (6,3,[],{1:0}?,up=1), (1,3,[],{1:0}?,up=1)],hasSemanticContext=true,conflictingAlts={1..3},dipsIntoOuterContext, input='x'\n",
+        assertEquals("line 1:0 reportAmbiguity d=0: ambigAlts={1..2}, input='x'\n",
                      this.stderrDuringParse);
 	}
 
@@ -184,7 +184,7 @@ public class TestSemPredEvalParser extends BaseTest {
 			"alt 2\n" +
 			"alt 2\n";
 		assertEquals(expecting, found);
-        assertEquals("line 1:4 reportAmbiguity d=0: ambigAlts={2..3}:[(6,2,[],up=1), (10,2,[],up=1), (1,2,[],up=1), (6,3,[],up=1), (10,3,[],up=1), (1,3,[],up=1), (6,4,[],{1:0}?,up=1), (10,4,[],{1:0}?,up=1), (1,4,[],{1:0}?,up=1)],hasSemanticContext=true,conflictingAlts={2..4},dipsIntoOuterContext, input='x'\n",
+        assertEquals("line 1:4 reportAmbiguity d=0: ambigAlts={2..3}, input='x'\n",
 					 this.stderrDuringParse);
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/SyntaxTree.java
Patch:
@@ -41,7 +41,7 @@ public interface SyntaxTree extends Tree {
 	 *  node is a leaf, then the interval represents a single token.
 	 *
 	 *  If source interval is unknown, this does not return null.
-	 *  It returns an interval of length 0.
+	 *  It returns an interval of length 0: Interval.EMPTY.
 	 */
 	Interval getSourceInterval();
 }

File: runtime/Java/src/org/antlr/v4/runtime/ConsoleErrorListener.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *
  * @author Sam Harwell
  */
-public class ConsoleErrorListener implements ANTLRErrorListener<Object> {
+public class ConsoleErrorListener extends BaseErrorListener<Object> {
 	public static final ConsoleErrorListener INSTANCE = new ConsoleErrorListener();
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/DiagnosticErrorListener.java
Patch:
@@ -34,7 +34,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.runtime.misc.NotNull;
 
-public class DiagnosticErrorStrategy extends DefaultErrorStrategy {
+public class DiagnosticErrorListener extends BaseErrorListener<Token> {
     @Override
     public void reportAmbiguity(@NotNull Parser recognizer,
 								DFA dfa, int startIndex, int stopIndex, @NotNull IntervalSet ambigAlts,

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -1408,15 +1408,15 @@ public void reportAttemptingFullContext(DFA dfa, ATNConfigSet configs, int start
             System.out.println("reportAttemptingFullContext decision="+dfa.decision+":"+configs+
                                ", input="+parser.getInputString(startIndex, stopIndex));
         }
-        if ( parser!=null ) parser.getErrorHandler().reportAttemptingFullContext(parser, dfa, startIndex, stopIndex, configs);
+        if ( parser!=null ) parser.getErrorListenerDispatch().reportAttemptingFullContext(parser, dfa, startIndex, stopIndex, configs);
     }
 
 	public void reportContextSensitivity(DFA dfa, ATNConfigSet configs, int startIndex, int stopIndex) {
         if ( debug || retry_debug ) {
             System.out.println("reportContextSensitivity decision="+dfa.decision+":"+configs+
                                ", input="+parser.getInputString(startIndex, stopIndex));
         }
-        if ( parser!=null ) parser.getErrorHandler().reportContextSensitivity(parser, dfa, startIndex, stopIndex, configs);
+        if ( parser!=null ) parser.getErrorListenerDispatch().reportContextSensitivity(parser, dfa, startIndex, stopIndex, configs);
     }
 
     /** If context sensitive parsing, we know it's ambiguity not conflict */
@@ -1445,7 +1445,7 @@ public void reportAmbiguity(@NotNull DFA dfa, DFAState D, int startIndex, int st
 							   ambigAlts+":"+configs+
                                ", input="+parser.getInputString(startIndex, stopIndex));
         }
-        if ( parser!=null ) parser.getErrorHandler().reportAmbiguity(parser, dfa, startIndex, stopIndex,
+        if ( parser!=null ) parser.getErrorListenerDispatch().reportAmbiguity(parser, dfa, startIndex, stopIndex,
                                                                      ambigAlts, configs);
     }
 }

File: tool/playground/TestR.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.DiagnosticErrorStrategy;
+import org.antlr.v4.runtime.DiagnosticErrorListener;
 
 public class TestR {
 	public static void main(String[] args) throws Exception {
@@ -41,7 +41,7 @@ public static void main(String[] args) throws Exception {
 //		}
 		RParser p = new RParser(tokens);
 		p.setBuildParseTree(true);
-		p.setErrorHandler(new DiagnosticErrorStrategy());
+		p.addErrorListener(new DiagnosticErrorListener());
 		p.prog();
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRInputStream.java
Patch:
@@ -225,5 +225,6 @@ public String getSourceName() {
 		return name;
 	}
 
+    @Override
     public String toString() { return new String(data); }
 }

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -218,7 +218,7 @@ public List<T> getTokens(int start, int stop, Set<Integer> types) {
                 filteredTokens.add(t);
             }
         }
-        if ( filteredTokens.size()==0 ) {
+        if ( filteredTokens.isEmpty() ) {
             filteredTokens = null;
         }
         return filteredTokens;
@@ -234,6 +234,7 @@ public List<T> getTokens(int start, int stop, int ttype) {
     public String getSourceName() {	return tokenSource.getSourceName();	}
 
     /** Grab *all* tokens from stream and return string */
+    @Override
     public String toString() {
         if ( p == -1 ) setup();
         fill();

File: runtime/Java/src/org/antlr/v4/runtime/FailedPredicateException.java
Patch:
@@ -46,13 +46,13 @@ public FailedPredicateException(Parser recognizer) {
 		this(recognizer, null);
 	}
 
-	public FailedPredicateException(Parser recognizer, @Nullable String msg) {
+	public FailedPredicateException(Parser recognizer, @Nullable String predicate) {
 		super(recognizer, recognizer.getInputStream(), recognizer._ctx);
 		ATNState s = recognizer.getInterpreter().atn.states.get(recognizer._ctx.s);
 		PredicateTransition trans = (PredicateTransition)s.transition(0);
 		ruleIndex = trans.ruleIndex;
 		predIndex = trans.predIndex;
-		this.msg = msg;
+		this.msg = String.format("failed predicate: {%s}?", predicate);
 		Token la = recognizer.getCurrentToken();
 		this.offendingToken = la;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/ParseListener.java
Patch:
@@ -9,7 +9,7 @@
  *  use Parser.getRuleContext().
  */
 public interface ParseListener<Symbol extends Token> {
-	void visitTerminal(ParserRuleContext<Symbol> ctx, Symbol symbol);
+	void visitTerminal(ParserRuleContext<Symbol> parent, Symbol token);
 
 	/** Enter all but left-recursive rules */
 	void enterNonLRRule(ParserRuleContext<Symbol> ctx);

File: runtime/Java/src/org/antlr/v4/runtime/TokenStream.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 /** A stream of tokens accessing tokens from a TokenSource */
 public interface TokenStream extends SymbolStream<Token> {
     /** Get Token at current input pointer + i ahead where i=1 is next Token.
-	 *  i<0 indicates tokens in the past.  So -1 is previous token and -2 is
+	 *  i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is
 	 *  two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
 	 *  Return null for LT(0) and any index that results in an absolute address
 	 *  that is negative.

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java
Patch:
@@ -30,10 +30,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.IntervalSet;
-import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.OrderedHashSet;
 
-import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/ActionTransition.java
Patch:
@@ -52,6 +52,7 @@ public boolean isEpsilon() {
 		return true; // we are to be ignored by analysis 'cept for predicates
 	}
 
+	@Override
 	public String toString() {
 		return "action_"+ruleIndex+":"+actionIndex;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/AtomTransition.java
Patch:
@@ -30,7 +30,6 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime.atn;
 
 import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Interval;
 import org.antlr.v4.runtime.misc.IntervalSet;
 
 /** TODO: make all transitions sets? no, should remove set edges */

File: runtime/Java/src/org/antlr/v4/runtime/misc/FastQueue.java
Patch:
@@ -87,6 +87,7 @@ public T elementAt(int i) {
     }
 
     /** Return string of current buffer contents; non-destructive */
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
         int n = size();

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntSet.java
Patch:
@@ -62,6 +62,7 @@ public interface IntSet {
 
     boolean isNil();
 
+    @Override
     boolean equals(Object obj);
 
     int getSingleElement();
@@ -73,5 +74,6 @@ public interface IntSet {
 
     List<Integer> toList();
 
+    @Override
     String toString();
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/Interval.java
Patch:
@@ -64,6 +64,7 @@ public static Interval create(int a, int b) {
 		return cache[a];
 	}
 
+	@Override
 	public boolean equals(Object o) {
 		if ( o==null ) {
 			return false;
@@ -139,6 +140,7 @@ else if ( other.startsAfterNonDisjoint(this) ) {
 		return diff;
 	}
 
+	@Override
 	public String toString() {
 		return a+".."+b;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/misc/OrderedHashSet.java
Patch:
@@ -114,8 +114,9 @@ public List<T> elements() {
 
     @Override
     public Object clone() {
+        @SuppressWarnings("unchecked")
         OrderedHashSet<T> dup = (OrderedHashSet<T>)super.clone();
-        dup.elements = (ArrayList<T>)this.elements.clone();
+        dup.elements = new ArrayList<T>(this.elements);
         return dup;
     }
 
@@ -124,6 +125,7 @@ public Object[] toArray() {
 		return elements.toArray();
 	}
 
+	@Override
 	public String toString() {
         return elements.toString();
     }

File: runtime/Java/src/org/antlr/v4/runtime/misc/Pair.java
Patch:
@@ -1,4 +1,4 @@
-package org.antlr.v4.misc;
+package org.antlr.v4.runtime.misc;
 
 public class Pair<A,B> {
 	public A a;

File: runtime/Java/src/org/antlr/v4/runtime/misc/Triple.java
Patch:
@@ -1,4 +1,4 @@
-package org.antlr.v4.misc;
+package org.antlr.v4.runtime.misc;
 
 public class Triple<A,B,C> extends Pair<A,B> {
 	public C c;

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeListener.java
Patch:
@@ -33,7 +33,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.Token;
 
 public interface ParseTreeListener<Symbol extends Token> {
-    void visitTerminal(ParserRuleContext<Symbol> ctx, Symbol symbol);
+	void visitTerminal(ParseTree.TerminalNode<Symbol> node);
+	void visitErrorNode(ParseTree.ErrorNode<Symbol> node);
     void enterEveryRule(ParserRuleContext<Symbol> ctx);
     void exitEveryRule(ParserRuleContext<Symbol> ctx);
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -102,7 +102,7 @@ public static <Symbol> String getNodeText(Tree t, Parser recog) {
 				String ruleName = recog.getRuleNames()[ruleIndex];
 				return ruleName;
 			}
-			else if ( t instanceof ParseTree.ErrorNodeImpl ) {
+			else if ( t instanceof ParseTree.ErrorNodeImpl) {
 				return t.toString();
 			}
 			else if ( t instanceof ParseTree.TerminalNode) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreePostScriptGenerator.java
Patch:
@@ -129,7 +129,7 @@ protected void generateNode(Tree t) {
 		// for debugging, turn this on to see boundingbox of nodes
 		//doc.rect(box.x, box.y, box.width, box.height);
 		// make error nodes from parse tree red by default
-		if ( t instanceof ParseTree.ErrorNodeImpl ) {
+		if ( t instanceof ParseTree.ErrorNode ) {
 			doc.highlight(box.x, box.y, box.width, box.height);
 		}
 		double x = box.x+nodeWidthPadding;

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -183,10 +183,10 @@ protected void paintBox(Graphics g, Tree tree) {
 		Rectangle2D.Double box = getBoundsOfNode(tree);
 		// draw the box in the background
 		if ( isHighlighted(tree) || boxColor!=null ||
-			 tree instanceof ParseTree.ErrorNodeImpl )
+			 tree instanceof ParseTree.ErrorNode )
 		{
 			if ( isHighlighted(tree) ) g.setColor(highlightedBoxColor);
-			else if ( tree instanceof ParseTree.ErrorNodeImpl ) g.setColor(LIGHT_RED);
+			else if ( tree instanceof ParseTree.ErrorNode ) g.setColor(LIGHT_RED);
 			else g.setColor(boxColor);
 			g.fillRoundRect((int) box.x, (int) box.y, (int) box.width - 1,
 							(int) box.height - 1, arcSize, arcSize);

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java
Patch:
@@ -35,9 +35,9 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.runtime.tree.Tree;
 import org.antlr.v4.Tool;
 import org.antlr.v4.codegen.CodeGenerator;
-import org.antlr.v4.misc.Pair;
 import org.antlr.v4.parse.GrammarASTAdaptor;
 import org.antlr.v4.parse.LeftRecursiveRuleWalker;
+import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.ast.AltAST;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -37,12 +37,12 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.runtime.TokenStream;
 import org.antlr.v4.Tool;
 import org.antlr.v4.misc.OrderedHashMap;
-import org.antlr.v4.misc.Pair;
 import org.antlr.v4.parse.ANTLRLexer;
 import org.antlr.v4.parse.ANTLRParser;
 import org.antlr.v4.parse.GrammarASTAdaptor;
 import org.antlr.v4.parse.ScopeParser;
 import org.antlr.v4.parse.ToolANTLRParser;
+import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.AttributeDict;
 import org.antlr.v4.tool.ErrorType;
 import org.antlr.v4.tool.Grammar;
@@ -225,15 +225,15 @@ public void setAltASTPointers(LeftRecursiveRule r, RuleAST t) {
 			altInfo.altAST = (AltAST)primaryBlk.getChild(i);
 			altInfo.altAST.leftRecursiveAltInfo = altInfo;
 			altInfo.originalAltAST.leftRecursiveAltInfo = altInfo;
-			altInfo.originalAltAST.parent = altInfo.altAST.parent;
+//			altInfo.originalAltAST.parent = altInfo.altAST.parent;
 //			System.out.println(altInfo.altAST.toStringTree());
 		}
 		for (int i = 0; i < r.recOpAlts.size(); i++) {
 			LeftRecursiveRuleAltInfo altInfo = r.recOpAlts.getElement(i);
 			altInfo.altAST = (AltAST)opsBlk.getChild(i);
 			altInfo.altAST.leftRecursiveAltInfo = altInfo;
 			altInfo.originalAltAST.leftRecursiveAltInfo = altInfo;
-			altInfo.originalAltAST.parent = altInfo.altAST.parent;
+//			altInfo.originalAltAST.parent = altInfo.altAST.parent;
 //			System.out.println(altInfo.altAST.toStringTree());
 		}
 	}

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -58,13 +58,14 @@ public LexerATNFactory(LexerGrammar g) {
 		codegenTemplates = gen.templates;
 	}
 
+	@Override
 	public ATN createATN() {
 		// BUILD ALL START STATES (ONE PER MODE)
 		Set<String> modes = ((LexerGrammar) g).modes.keySet();
 		for (String modeName : modes) {
 			// create s0, start state; implied Tokens rule node
 			TokensStartState startState =
-				(TokensStartState)newState(TokensStartState.class, null);
+				newState(TokensStartState.class, null);
 			atn.modeNameToStartState.put(modeName, startState);
 			atn.modeToStartState.add(startState);
 			atn.defineDecisionState(startState);

File: tool/src/org/antlr/v4/codegen/DefaultOutputModelFactory.java
Patch:
@@ -68,6 +68,7 @@ public OutputModelController getController() {
 	// Convenience methods
 
 	@NotNull
+	@Override
 	public Grammar getGrammar() { return g; }
 
 	@Override

File: tool/src/org/antlr/v4/codegen/OutputModelFactory.java
Patch:
@@ -64,7 +64,7 @@ public interface OutputModelFactory {
 
 	CodeBlockForAlt finishAlternative(CodeBlockForAlt blk, List<SrcOp> ops);
 
-	CodeBlockForAlt epsilon();
+	CodeBlockForAlt epsilon(Alternative alt, boolean outerMost);
 
 	List<SrcOp> ruleRef(GrammarAST ID, GrammarAST label, GrammarAST args);
 

File: tool/src/org/antlr/v4/codegen/model/InvokeRule.java
Patch:
@@ -91,6 +91,7 @@ public InvokeRule(ParserFactory factory, GrammarAST ast, GrammarAST labelAST) {
 		}
 	}
 
+	@Override
 	public List<Decl> getLabels() {
 		return labels.elements();
 	}

File: tool/src/org/antlr/v4/codegen/model/LL1AltBlock.java
Patch:
@@ -43,7 +43,6 @@ public LL1AltBlock(OutputModelFactory factory, GrammarAST blkAST, List<CodeBlock
 		this.decision = ((DecisionState)blkAST.atnState).decision;
 
 		/** Lookahead for each alt 1..n */
-//		IntervalSet[] altLookSets = LinearApproximator.getLL1LookaheadSets(dfa);
 		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
 		altLook = getAltLookaheadAsStringLists(altLookSets);
 

File: tool/src/org/antlr/v4/codegen/model/LeftRecursiveRuleFunction.java
Patch:
@@ -33,8 +33,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.codegen.model.decl.RuleContextDecl;
 import org.antlr.v4.codegen.model.decl.StructDecl;
-import org.antlr.v4.misc.Pair;
 import org.antlr.v4.parse.ANTLRParser;
+import org.antlr.v4.runtime.misc.Pair;
 import org.antlr.v4.tool.LeftRecursiveRule;
 import org.antlr.v4.tool.Rule;
 import org.antlr.v4.tool.ast.GrammarAST;

File: tool/src/org/antlr/v4/codegen/model/MatchToken.java
Patch:
@@ -57,5 +57,6 @@ public MatchToken(OutputModelFactory factory, GrammarAST ast) {
 		super(factory, ast);
 	}
 
+	@Override
 	public List<Decl> getLabels() { return labels; }
 }

File: tool/src/org/antlr/v4/misc/Graph.java
Patch:
@@ -48,6 +48,7 @@ public void addEdge(Node n) {
             if ( !edges.contains(n) ) edges.add(n);
         }
 
+        @Override
         public String toString() { return payload.toString(); }
     }
 

File: tool/src/org/antlr/v4/misc/Utils.java
Patch:
@@ -174,9 +174,9 @@ public static <From,To> List<To> select(List<From> list, Func1<From, To> selecto
 	}
 
 	/** Find exact object type or sublass of cl in list */
-	public static Object find(List<?> ops, Class cl) {
+	public static <T> T find(List<?> ops, Class<T> cl) {
 		for (Object o : ops) {
-			if ( cl.isInstance(o) ) return o;
+			if ( cl.isInstance(o) ) return cl.cast(o);
 //			if ( o.getClass() == cl ) return o;
 		}
 		return null;

File: tool/src/org/antlr/v4/parse/GrammarASTAdaptor.java
Patch:
@@ -42,6 +42,7 @@ public class GrammarASTAdaptor extends CommonTreeAdaptor {
     public GrammarASTAdaptor() { ; }
     public GrammarASTAdaptor(org.antlr.runtime.CharStream input) { this.input = input; }
 
+    @Override
     public Object create(Token token) {
         return new GrammarAST(token);
     }
@@ -66,11 +67,13 @@ else if ( tokenType==ANTLRParser.STRING_LITERAL ) {
         return t;
     }
 
+    @Override
     public Object dupNode(Object t) {
         if ( t==null ) return null;
         return ((GrammarAST)t).dupNode(); //create(((GrammarAST)t).token);
     }
 
+    @Override
     public Object errorNode(org.antlr.runtime.TokenStream input, org.antlr.runtime.Token start, org.antlr.runtime.Token stop,
                             org.antlr.runtime.RecognitionException e)
     {

File: tool/src/org/antlr/v4/parse/TokenVocabParser.java
Patch:
@@ -47,7 +47,7 @@ public TokenVocabParser(Tool tool, String vocabName) {
 		this.vocabName = vocabName;
 	}
 
-	/** Load a vocab file <vocabName>.tokens and return mapping. */
+	/** Load a vocab file {@code <vocabName>.tokens} and return mapping. */
 	public Map<String,Integer> load() {
 		Map<String,Integer> tokens = new LinkedHashMap<String,Integer>();
 		int maxTokenType = -1;

File: tool/src/org/antlr/v4/parse/ToolANTLRParser.java
Patch:
@@ -44,6 +44,7 @@ public ToolANTLRParser(TokenStream input, Tool tool) {
 		this.tool = tool;
 	}
 
+	@Override
 	public void displayRecognitionError(String[] tokenNames,
 										RecognitionException e)
 	{

File: tool/src/org/antlr/v4/semantics/SymbolChecks.java
Patch:
@@ -252,10 +252,10 @@ else if ( (r.retvals!=null&&r.retvals.get(name)!=null) ||
 
     public void checkForRuleArgumentAndReturnValueConflicts(Rule r) {
         if ( r.retvals!=null ) {
-            Set conflictingKeys = r.retvals.intersection(r.args);
+            Set<String> conflictingKeys = r.retvals.intersection(r.args);
             if (conflictingKeys!=null) {
-                for (Iterator it = conflictingKeys.iterator(); it.hasNext();) {
-                    String key = (String) it.next();
+                for (Iterator<String> it = conflictingKeys.iterator(); it.hasNext();) {
+                    String key = it.next();
                     errMgr.grammarError(
                         ErrorType.ARG_RETVAL_CONFLICT,
                         g.fileName,

File: tool/src/org/antlr/v4/tool/Attribute.java
Patch:
@@ -57,6 +57,7 @@ public Attribute(String name, String decl) {
         this.decl = decl;
     }
 
+    @Override
     public String toString() {
         if ( initValue!=null ) {
             return type+" "+name+"="+initValue;

File: tool/src/org/antlr/v4/tool/DefaultToolListener.java
Patch:
@@ -38,13 +38,15 @@ public class DefaultToolListener implements ANTLRToolListener {
 
 	public DefaultToolListener(Tool tool) { this.tool = tool; }
 
+	@Override
 	public void info(String msg) {
 		if (tool.errMgr.formatWantsSingleLineMessage()) {
 			msg = msg.replaceAll("\n", " ");
 		}
 		System.out.println(msg);
 	}
 
+	@Override
 	public void error(ANTLRMessage msg) {
 		ST msgST = tool.errMgr.getMessageTemplate(msg);
 		String outputMsg = msgST.render();
@@ -54,6 +56,7 @@ public void error(ANTLRMessage msg) {
 		System.err.println(outputMsg);
 	}
 
+	@Override
 	public void warning(ANTLRMessage msg) {
 		ST msgST = tool.errMgr.getMessageTemplate(msg);
 		String outputMsg = msgST.render();

File: tool/src/org/antlr/v4/tool/LabelElementPair.java
Patch:
@@ -66,6 +66,7 @@ else if ( element.getFirstDescendantWithType(ANTLRParser.RULE_REF)!=null ) {
         }
     }
 
+    @Override
     public String toString() {
         return label.getText()+" "+type+" "+element.toString();
     }

File: tool/src/org/antlr/v4/tool/LeftRecursiveRule.java
Patch:
@@ -31,8 +31,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import org.antlr.v4.analysis.LeftRecursiveRuleAltInfo;
 import org.antlr.v4.misc.OrderedHashMap;
-import org.antlr.v4.misc.Pair;
-import org.antlr.v4.misc.Triple;
+import org.antlr.v4.runtime.misc.Pair;
+import org.antlr.v4.runtime.misc.Triple;
 import org.antlr.v4.tool.ast.AltAST;
 import org.antlr.v4.tool.ast.GrammarAST;
 import org.antlr.v4.tool.ast.RuleAST;

File: tool/src/org/antlr/v4/tool/LexerGrammar.java
Patch:
@@ -31,7 +31,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import org.antlr.runtime.RecognitionException;
 import org.antlr.v4.Tool;
-import org.antlr.v4.misc.MultiMap;
+import org.antlr.v4.runtime.misc.MultiMap;
 import org.antlr.v4.tool.ast.GrammarRootAST;
 
 /** */

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -171,7 +171,7 @@ public String toString(@Nullable Recognizer<?, ?> recog, boolean showAlt) {
         }
         if ( context!=null ) {
             buf.append(",[");
-            buf.append(context.toString(recog));
+            buf.append(context.toString());
 			buf.append("]");
         }
         if ( semanticContext!=null && semanticContext != SemanticContext.NONE ) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/EmptyPredictionContext.java
Patch:
@@ -35,6 +35,6 @@ public boolean equals(Object o) {
 
 	@Override
 	public String toString() {
-		return "$";
+		return "";
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/SingletonPredictionContext.java
Patch:
@@ -82,6 +82,8 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return String.valueOf(invokingState)+" "+parent.toString();
+		String up = parent.toString();
+		if ( up.length()==0 ) return String.valueOf(invokingState);
+		return String.valueOf(invokingState)+" "+up;
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -241,7 +241,8 @@ protected int execDFA(@NotNull CharStream input, @NotNull DFAState s0) {
 			t = input.LA(1);
 		}
 
-		return failOrAccept(prevAccept, input, prevAccept.state.configset, t);
+		ATNConfigSet reach = prevAccept.state != null ? prevAccept.state.configset : null;
+		return failOrAccept(prevAccept, input, reach, t);
 	}
 
 	protected int execATN(@NotNull CharStream input, @NotNull ATNConfigSet s0, @Nullable DFAState ds0) {

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -100,7 +100,7 @@ public void release(int marker) {
 	}
 
     public void reset() {
-        p = 0;
+        seek(0);
     }
 
     @Override

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -335,7 +335,7 @@ else if (target.isAcceptState) {
 			s = target; // flip; current DFA target becomes new src/from state
 		}
 
-		return failOrAccept(prevAccept, input, reach, t);
+		return failOrAccept(prevAccept, input, closure, t);
 	}
 
 	protected int failOrAccept(ExecState prevAccept, CharStream input,

File: runtime/Java/src/org/antlr/v4/runtime/ConsoleErrorListener.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *
  * @author Sam Harwell
  */
-public class ConsoleErrorListener implements ANTLRErrorListener<Object> {
+public class ConsoleErrorListener extends BaseErrorListener<Object> {
 	public static final ConsoleErrorListener INSTANCE = new ConsoleErrorListener();
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/DiagnosticErrorListener.java
Patch:
@@ -38,7 +38,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import java.util.Arrays;
 
-public class DiagnosticErrorStrategy extends DefaultErrorStrategy {
+public class DiagnosticErrorListener extends BaseErrorListener<Token> {
     @Override
     public void reportAmbiguity(@NotNull Parser recognizer,
 								DFA dfa, int startIndex, int stopIndex, @NotNull IntervalSet ambigAlts,

File: runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java
Patch:
@@ -147,7 +147,7 @@ else if ( arg.equals("-ps") ) {
 			Constructor<Parser> parserCtor = parserClass.getConstructor(TokenStream.class);
 			Parser parser = parserCtor.newInstance(tokens);
 
-			parser.setErrorHandler(new DiagnosticErrorStrategy());
+			parser.addErrorListener(new DiagnosticErrorListener());
 
 			if ( printTree || gui || psFile!=null ) {
 				parser.setBuildParseTree(true);

File: tool/playground/TestR.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import org.antlr.v4.runtime.ANTLRFileStream;
 import org.antlr.v4.runtime.CommonTokenStream;
-import org.antlr.v4.runtime.DiagnosticErrorStrategy;
+import org.antlr.v4.runtime.DiagnosticErrorListener;
 
 public class TestR {
 	public static void main(String[] args) throws Exception {
@@ -41,7 +41,7 @@ public static void main(String[] args) throws Exception {
 //		}
 		RParser p = new RParser(tokens);
 		p.setBuildParseTree(true);
-		p.setErrorHandler(new DiagnosticErrorStrategy());
+		p.addErrorListener(new DiagnosticErrorListener());
 		p.prog();
 	}
 }

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -895,7 +895,7 @@ protected void writeTestFile(String parserName,
 			createParserST =
 				new ST(
 				"        <parserName> parser = new <parserName>(tokens);\n" +
-                "        parser.setErrorHandler(new DiagnosticErrorStrategy());\n");
+                "        parser.addErrorListener(new DiagnosticErrorListener());\n");
 		}
 		outputFileST.add("createParser", createParserST);
 		outputFileST.add("parserName", parserName);

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -513,7 +513,7 @@ protected interface ParserFactory {
         void parseFile(CharStream input);
     }
 
-	private static class DescriptiveErrorListener implements ANTLRErrorListener<Token> {
+	private static class DescriptiveErrorListener extends BaseErrorListener<Token> {
 		public static DescriptiveErrorListener INSTANCE = new DescriptiveErrorListener();
 
 		@Override

File: tool/test/org/antlr/v4/test/TestSemPredEvalParser.java
Patch:
@@ -153,7 +153,7 @@ public class TestSemPredEvalParser extends BaseTest {
 			"alt 1\n" +
 			"alt 1\n";
 		assertEquals(expecting, found);
-        assertEquals("line 1:0 reportInsufficientPredicates d=0, decState=24, ambigAlts={1..3}:[{-1:-1}?, {-1:-1}?, {-1:-1}?, {1:0}?], [(6,1,[],up=1), (1,1,[],up=1), (6,2,[],up=1), (1,2,[],up=1), (6,3,[],{1:0}?,up=1), (1,3,[],{1:0}?,up=1)],hasSemanticContext=true,conflictingAlts={1..3},dipsIntoOuterContext, input='x'\n",
+        assertEquals("line 1:0 reportAmbiguity d=0: ambigAlts={1..2}:[(6,1,[],up=1), (1,1,[],up=1), (6,2,[],up=1), (1,2,[],up=1), (6,3,[],{1:0}?,up=1), (1,3,[],{1:0}?,up=1)],hasSemanticContext=true,conflictingAlts={1..3},dipsIntoOuterContext, input='x'\n",
                      this.stderrDuringParse);
 	}
 
@@ -184,8 +184,8 @@ public class TestSemPredEvalParser extends BaseTest {
 			"alt 2\n" +
 			"alt 2\n";
 		assertEquals(expecting, found);
-        assertEquals("line 1:4 reportInsufficientPredicates d=0, decState=32, ambigAlts={2..4}:[{-1:-1}?, {-1:-1}?, {-1:-1}?, {-1:-1}?, {1:0}?], [(6,2,[],up=1), (10,2,[],up=1), (1,2,[],up=1), (6,3,[],up=1), (10,3,[],up=1), (1,3,[],up=1), (6,4,[],{1:0}?,up=1), (10,4,[],{1:0}?,up=1), (1,4,[],{1:0}?,up=1)],hasSemanticContext=true,conflictingAlts={2..4},dipsIntoOuterContext, input='x'\n",
-                     this.stderrDuringParse);
+        assertEquals("line 1:4 reportAmbiguity d=0: ambigAlts={2..3}:[(6,2,[],up=1), (10,2,[],up=1), (1,2,[],up=1), (6,3,[],up=1), (10,3,[],up=1), (1,3,[],up=1), (6,4,[],{1:0}?,up=1), (10,4,[],{1:0}?,up=1), (1,4,[],{1:0}?,up=1)],hasSemanticContext=true,conflictingAlts={2..4},dipsIntoOuterContext, input='x'\n",
+					 this.stderrDuringParse);
 	}
 
 	@Test public void testRewindBeforePredEval() throws Exception {

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTree.java
Patch:
@@ -89,7 +89,7 @@ public String toStringTree(Parser parser) {
 			return toString();
 		}
 
-		public boolean isErrorNode() { return this instanceof ErrorNodeImpl; }
+		public boolean isErrorNode() { return this instanceof ErrorNode; }
 
 		@Override
 		public String toString() {

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -225,15 +225,15 @@ public void setAltASTPointers(LeftRecursiveRule r, RuleAST t) {
 			altInfo.altAST = (AltAST)primaryBlk.getChild(i);
 			altInfo.altAST.leftRecursiveAltInfo = altInfo;
 			altInfo.originalAltAST.leftRecursiveAltInfo = altInfo;
-			altInfo.originalAltAST.parent = altInfo.altAST.parent;
+//			altInfo.originalAltAST.parent = altInfo.altAST.parent;
 //			System.out.println(altInfo.altAST.toStringTree());
 		}
 		for (int i = 0; i < r.recOpAlts.size(); i++) {
 			LeftRecursiveRuleAltInfo altInfo = r.recOpAlts.getElement(i);
 			altInfo.altAST = (AltAST)opsBlk.getChild(i);
 			altInfo.altAST.leftRecursiveAltInfo = altInfo;
 			altInfo.originalAltAST.leftRecursiveAltInfo = altInfo;
-			altInfo.originalAltAST.parent = altInfo.altAST.parent;
+//			altInfo.originalAltAST.parent = altInfo.altAST.parent;
 //			System.out.println(altInfo.altAST.toStringTree());
 		}
 	}

File: runtime/Java/src/org/antlr/v4/runtime/ParserRuleContext.java
Patch:
@@ -178,10 +178,11 @@ public void addChild(Symbol matchedToken) {
 		t.parent = this;
 	}
 
-	public void addErrorNode(Symbol badToken) {
-		TerminalNodeImpl<Symbol> t = new ErrorNode<Symbol>(badToken);
+	public ErrorNode<Symbol> addErrorNode(Symbol badToken) {
+		ErrorNodeImpl<Symbol> t = new ErrorNodeImpl<Symbol>(badToken);
 		addChild(t);
 		t.parent = this;
+		return t;
 	}
 
 	@Override

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeVisitor.java
Patch:
@@ -26,7 +26,7 @@ public T visitChildren(ParserRuleContext<? extends Token> ctx) {
 				result = visit(rctx);
 			}
 			else {
-				if ( c instanceof ParseTree.ErrorNode ) {
+				if ( c instanceof ParseTree.ErrorNodeImpl) {
 					result = visitErrorNode((ParseTree.ErrorNode<? extends Token>)c);
 				}
 				else {

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeWalker.java
Patch:
@@ -37,7 +37,7 @@ public class ParseTreeWalker {
 
     @SuppressWarnings("unchecked")
     public <Symbol extends Token> void walk(ParseTreeListener<Symbol> listener, ParseTree t) {
-		if ( t instanceof ParseTree.ErrorNode ) {
+		if ( t instanceof ParseTree.ErrorNodeImpl) {
 			listener.visitErrorNode((ParseTree.ErrorNode<Symbol>)t);
 			return;
 		}

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -102,7 +102,7 @@ public static <Symbol> String getNodeText(Tree t, Parser recog) {
 				String ruleName = recog.getRuleNames()[ruleIndex];
 				return ruleName;
 			}
-			else if ( t instanceof ParseTree.ErrorNode) {
+			else if ( t instanceof ParseTree.ErrorNodeImpl) {
 				return t.toString();
 			}
 			else if ( t instanceof ParseTree.TerminalNode) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreePostScriptGenerator.java
Patch:
@@ -129,7 +129,7 @@ protected void generateNode(Tree t) {
 		// for debugging, turn this on to see boundingbox of nodes
 		//doc.rect(box.x, box.y, box.width, box.height);
 		// make error nodes from parse tree red by default
-		if ( t instanceof ParseTree.ErrorNode) {
+		if ( t instanceof ParseTree.ErrorNode ) {
 			doc.highlight(box.x, box.y, box.width, box.height);
 		}
 		double x = box.x+nodeWidthPadding;

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -183,10 +183,10 @@ protected void paintBox(Graphics g, Tree tree) {
 		Rectangle2D.Double box = getBoundsOfNode(tree);
 		// draw the box in the background
 		if ( isHighlighted(tree) || boxColor!=null ||
-			 tree instanceof ParseTree.ErrorNode)
+			 tree instanceof ParseTree.ErrorNode )
 		{
 			if ( isHighlighted(tree) ) g.setColor(highlightedBoxColor);
-			else if ( tree instanceof ParseTree.ErrorNode) g.setColor(LIGHT_RED);
+			else if ( tree instanceof ParseTree.ErrorNode ) g.setColor(LIGHT_RED);
 			else g.setColor(boxColor);
 			g.fillRoundRect((int) box.x, (int) box.y, (int) box.width - 1,
 							(int) box.height - 1, arcSize, arcSize);

File: runtime/Java/src/org/antlr/v4/runtime/ParseListener.java
Patch:
@@ -9,7 +9,7 @@
  *  use Parser.getRuleContext().
  */
 public interface ParseListener<Symbol extends Token> {
-	void visitTerminal(ParserRuleContext<Symbol> ctx, Symbol symbol);
+	void visitTerminal(ParserRuleContext<Symbol> parent, Symbol token);
 
 	/** Enter all but left-recursive rules */
 	void enterNonLRRule(ParserRuleContext<Symbol> ctx);

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTree.java
Patch:
@@ -96,8 +96,8 @@ public String toStringTree() {
 	 *  and deletion as well as during "consume until error recovery set"
 	 *  upon no viable alternative exceptions.
 	 */
-	public static class ErrorNodeImpl<Symbol extends Token> extends TerminalNodeImpl<Symbol> {
-		public ErrorNodeImpl(Symbol token) {
+	public static class ErrorNode<Symbol extends Token> extends TerminalNodeImpl<Symbol> {
+		public ErrorNode(Symbol token) {
 			super(token);
 		}
 	}

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeListener.java
Patch:
@@ -33,7 +33,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.Token;
 
 public interface ParseTreeListener<Symbol extends Token> {
-    void visitTerminal(ParserRuleContext<Symbol> ctx, Symbol symbol);
+	void visitTerminal(ParseTree.TerminalNode<Symbol> node);
+	void visitErrorNode(ParseTree.ErrorNode<Symbol> node);
     void enterEveryRule(ParserRuleContext<Symbol> ctx);
     void exitEveryRule(ParserRuleContext<Symbol> ctx);
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/Trees.java
Patch:
@@ -102,7 +102,7 @@ public static <Symbol> String getNodeText(Tree t, Parser recog) {
 				String ruleName = recog.getRuleNames()[ruleIndex];
 				return ruleName;
 			}
-			else if ( t instanceof ParseTree.ErrorNodeImpl ) {
+			else if ( t instanceof ParseTree.ErrorNode) {
 				return t.toString();
 			}
 			else if ( t instanceof ParseTree.TerminalNode) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreePostScriptGenerator.java
Patch:
@@ -129,7 +129,7 @@ protected void generateNode(Tree t) {
 		// for debugging, turn this on to see boundingbox of nodes
 		//doc.rect(box.x, box.y, box.width, box.height);
 		// make error nodes from parse tree red by default
-		if ( t instanceof ParseTree.ErrorNodeImpl ) {
+		if ( t instanceof ParseTree.ErrorNode) {
 			doc.highlight(box.x, box.y, box.width, box.height);
 		}
 		double x = box.x+nodeWidthPadding;

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -183,10 +183,10 @@ protected void paintBox(Graphics g, Tree tree) {
 		Rectangle2D.Double box = getBoundsOfNode(tree);
 		// draw the box in the background
 		if ( isHighlighted(tree) || boxColor!=null ||
-			 tree instanceof ParseTree.ErrorNodeImpl )
+			 tree instanceof ParseTree.ErrorNode)
 		{
 			if ( isHighlighted(tree) ) g.setColor(highlightedBoxColor);
-			else if ( tree instanceof ParseTree.ErrorNodeImpl ) g.setColor(LIGHT_RED);
+			else if ( tree instanceof ParseTree.ErrorNode) g.setColor(LIGHT_RED);
 			else g.setColor(boxColor);
 			g.fillRoundRect((int) box.x, (int) box.y, (int) box.width - 1,
 							(int) box.height - 1, arcSize, arcSize);

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeProperty.java
Patch:
@@ -20,5 +20,5 @@ public class ParseTreeProperty<V> {
 
 	public V get(ParseTree node) { return annotations.get(node); }
 	public void put(ParseTree node, V value) { annotations.put(node, value); }
-	public V removeFrom(ParseTree node) { return annotations.get(node); }
+	public V removeFrom(ParseTree node) { return annotations.remove(node); }
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/OrderedHashSet.java
Patch:
@@ -114,8 +114,9 @@ public List<T> elements() {
 
     @Override
     public Object clone() {
+        @SuppressWarnings("unchecked")
         OrderedHashSet<T> dup = (OrderedHashSet<T>)super.clone();
-        dup.elements = (ArrayList<T>)this.elements.clone();
+        dup.elements = new ArrayList<T>(this.elements);
         return dup;
     }
 

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorListener.java
Patch:
@@ -66,8 +66,8 @@ public interface ANTLRErrorListener<Symbol> {
 	 *        the parser was able to recover in line without exiting the
 	 *        surrounding rule.
 	 */
-	public void error(Recognizer<Symbol, ?> recognizer,
-					  @Nullable Symbol offendingSymbol,
+	public <T extends Symbol> void error(Recognizer<T, ?> recognizer,
+					  @Nullable T offendingSymbol,
 					  int line,
 					  int charPositionInLine,
 					  String msg,

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -309,14 +309,14 @@ public void recover(LexerNoViableAltException e) {
 	public void notifyListeners(LexerNoViableAltException e) {
 		String msg = "token recognition error at: '"+
 			_input.substring(_tokenStartCharIndex, _input.index())+"'";
-		List<? extends ANTLRErrorListener<Integer>> listeners = getErrorListeners();
+		List<? extends ANTLRErrorListener<? super Integer>> listeners = getErrorListeners();
 		if ( listeners.isEmpty() ) {
 			System.err.println("line "+ _tokenStartLine +":"+
 							   _tokenStartCharPositionInLine +" "+
 							   msg);
 			return;
 		}
-		for (ANTLRErrorListener<Integer> pl : listeners) {
+		for (ANTLRErrorListener<? super Integer> pl : listeners) {
 			pl.error(this, null, _tokenStartLine, _tokenStartCharPositionInLine, msg, e);
 		}
 	}

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -255,12 +255,12 @@ public void notifyErrorListeners(Token offendingToken, String msg,
 			line = ((Token) offendingToken).getLine();
 			charPositionInLine = ((Token) offendingToken).getCharPositionInLine();
 		}
-		List<? extends ANTLRErrorListener<Token>> listeners = getErrorListeners();
+		List<? extends ANTLRErrorListener<? super Token>> listeners = getErrorListeners();
 		if ( listeners.isEmpty() ) {
 			System.err.println("line "+line+":"+charPositionInLine+" "+msg);
 			return;
 		}
-		for (ANTLRErrorListener<Token> pl : listeners) {
+		for (ANTLRErrorListener<? super Token> pl : listeners) {
 			pl.error(this, offendingToken, line, charPositionInLine, msg, e);
 		}
 	}

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -517,7 +517,7 @@ private static class DescriptiveErrorListener implements ANTLRErrorListener<Toke
 		public static DescriptiveErrorListener INSTANCE = new DescriptiveErrorListener();
 
 		@Override
-		public void error(Recognizer<Token, ?> recognizer, Token offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
+		public <T extends Token> void error(Recognizer<T, ?> recognizer, T offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
 			String sourceName = recognizer.getInputStream().getSourceName();
 			sourceName = sourceName != null && !sourceName.isEmpty() ? sourceName+": " : "";
 			System.err.println(sourceName+"line "+line+":"+charPositionInLine+" "+msg);

File: tool/src/org/antlr/v4/codegen/OutputModelController.java
Patch:
@@ -375,8 +375,8 @@ public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST, boolean invert) {
 		return ops;
 	}
 
-	public CodeBlockForAlt epsilon() {
-		CodeBlockForAlt blk = delegate.epsilon();
+	public CodeBlockForAlt epsilon(Alternative alt, boolean outerMost) {
+		CodeBlockForAlt blk = delegate.epsilon(alt, outerMost);
 		for (CodeGeneratorExtension ext : extensions) blk = ext.epsilon(blk);
 		return blk;
 	}

File: tool/src/org/antlr/v4/codegen/OutputModelFactory.java
Patch:
@@ -64,7 +64,7 @@ public interface OutputModelFactory {
 
 	CodeBlockForAlt finishAlternative(CodeBlockForAlt blk, List<SrcOp> ops);
 
-	CodeBlockForAlt epsilon();
+	CodeBlockForAlt epsilon(Alternative alt, boolean outerMost);
 
 	List<SrcOp> ruleRef(GrammarAST ID, GrammarAST label, GrammarAST args);
 

File: tool/src/org/antlr/v4/codegen/model/LL1AltBlock.java
Patch:
@@ -43,7 +43,6 @@ public LL1AltBlock(OutputModelFactory factory, GrammarAST blkAST, List<CodeBlock
 		this.decision = ((DecisionState)blkAST.atnState).decision;
 
 		/** Lookahead for each alt 1..n */
-//		IntervalSet[] altLookSets = LinearApproximator.getLL1LookaheadSets(dfa);
 		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);
 		altLook = getAltLookaheadAsStringLists(altLookSets);
 

File: runtime/Java/src/org/antlr/v4/runtime/ParseListener.java
Patch:
@@ -8,7 +8,7 @@
  *  make the interface clear these semantics up. If you need the ctx,
  *  use Parser.getRuleContext().
  */
-public interface ParseListener<Symbol> {
+public interface ParseListener<Symbol extends Token> {
 	void visitTerminal(ParserRuleContext<Symbol> ctx, Symbol symbol);
 
 	/** Enter all but left-recursive rules */

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeListener.java
Patch:
@@ -30,8 +30,9 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime.tree;
 
 import org.antlr.v4.runtime.ParserRuleContext;
+import org.antlr.v4.runtime.Token;
 
-public interface ParseTreeListener<Symbol> {
+public interface ParseTreeListener<Symbol extends Token> {
     void visitTerminal(ParserRuleContext<Symbol> ctx, Symbol symbol);
     void enterEveryRule(ParserRuleContext<Symbol> ctx);
     void exitEveryRule(ParserRuleContext<Symbol> ctx);

File: tool/playground/TestT.java
Patch:
@@ -40,8 +40,8 @@ public static void main(String[] args) throws Exception {
 		}
 		TParser p = new TParser(tokens);
 		p.setBuildParseTree(true);
-		final TParser.sContext tree = p.s();
-		System.out.println(tree.toStringTree(p));
+//		final TParser.sContext tree = p.s();
+//		System.out.println(tree.toStringTree(p));
 //		TreeViewer v = new TreeViewer(p, tree);
 //		v.setHighlightedBoxColor(TreeViewer.LIGHT_RED);
 //		v.addHighlightedNodes(new ArrayList<Tree>() {{

File: tool/src/org/antlr/v4/tool/ast/AltAST.java
Patch:
@@ -50,6 +50,7 @@ public AltAST(GrammarAST node) {
 		super(node);
 		this.alt = ((AltAST)node).alt;
 		this.altLabel = ((AltAST)node).altLabel;
+		this.leftRecursiveAltInfo = ((AltAST)node).leftRecursiveAltInfo;
 	}
 
 	public AltAST(Token t) { super(t); }

File: tool/playground/AVisitor.java
Patch:
@@ -1,3 +1,6 @@
+import org.antlr.v4.runtime.tree.*;
+import org.antlr.v4.runtime.Token;
+
 public interface AVisitor<T> {
 	T visitMult(AParser.MultContext ctx);
 	T visitParens(AParser.ParensContext ctx);

File: tool/playground/AVisitor.java
Patch:
@@ -1,3 +1,6 @@
+import org.antlr.v4.runtime.tree.*;
+import org.antlr.v4.runtime.Token;
+
 public interface AVisitor<T> {
 	T visitMult(AParser.MultContext ctx);
 	T visitParens(AParser.ParensContext ctx);

File: tool/src/org/antlr/v4/codegen/CodeGenPipeline.java
Patch:
@@ -46,9 +46,11 @@ public void process() {
 		}
 		else {
 			gen.writeRecognizer(gen.generateParser());
-			if ( g.tool.gen_listener) {
+			if ( g.tool.gen_listener ) {
 				gen.writeListener(gen.generateListener());
 				gen.writeBaseListener(gen.generateBaseListener());
+			}
+			if ( g.tool.gen_visitor ) {
 				gen.writeVisitor(gen.generateVisitor());
 				gen.writeBaseVisitor(gen.generateBaseVisitor());
 			}

File: tool/src/org/antlr/v4/semantics/BasicSemanticChecks.java
Patch:
@@ -250,7 +250,6 @@ public void finishRule(RuleAST rule, GrammarAST ID, GrammarAST block) {
 		for (int i=0; i< nalts; i++) {
 			AltAST altAST = (AltAST)blk.getChild(i);
 			if ( altAST.altLabel!=null ) {
-				System.out.println("alt label "+altAST.altLabel);
 				ruleToAltLabels.map(rule.getRuleName(), altAST.altLabel);
 				String altLabel = altAST.altLabel.getText();
 				String prevRuleForLabel = altLabelToRuleName.get(altLabel);
@@ -266,11 +265,9 @@ public void finishRule(RuleAST rule, GrammarAST ID, GrammarAST block) {
 				}
 			}
 		}
-		System.out.println(rule.getRuleName()+" has "+ nalts +" alts");
 		List<GrammarAST> altLabels = ruleToAltLabels.get(rule.getRuleName());
 		int numAltLabels = 0;
 		if ( altLabels!=null ) numAltLabels = altLabels.size();
-		System.out.println("labels="+altLabels);
 		if ( numAltLabels>0 && nalts != numAltLabels ) {
 			g.tool.errMgr.grammarError(ErrorType.RULE_WITH_TOO_FEW_ALT_LABELS,
 									   g.fileName, rule.getToken(), rule.getRuleName());

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -43,8 +43,9 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public enum ErrorType {
     INVALID(0, "<INVALID>", ErrorSeverity.ERROR),
 
+	// Tool errors
 	CANNOT_WRITE_FILE(1, "cannot write file <arg>: <arg2>", ErrorSeverity.ERROR),
-//	CANNOT_CLOSE_FILE(2, "cannot close file <arg>", ErrorSeverity.ERROR),
+	INVALID_CMDLINE_ARG(2, "unknown command-line option <arg>", ErrorSeverity.ERROR),
 	CANNOT_FIND_TOKENS_FILE(3, "cannot find tokens file <arg>", ErrorSeverity.ERROR),
 	ERROR_READING_TOKENS_FILE(4, "cannot find tokens file <arg>: <arg2>", ErrorSeverity.ERROR),
 	DIR_NOT_FOUND(5, "directory not found: <arg>", ErrorSeverity.ERROR),

File: tool/playground/ABaseVisitor.java
Patch:
@@ -1,10 +1,10 @@
-import org.antlr.v4.runtime.tree.*;
-import org.antlr.v4.runtime.Token;
+import org.antlr.v4.runtime.tree.ParseTreeVisitor;
 
 public class ABaseVisitor<T> extends ParseTreeVisitor<T> implements AVisitor<T> {
 	public T visit(AParser.MultContext ctx) { visitChildren(ctx); return null; }
 	public T visit(AParser.ParensContext ctx) { visitChildren(ctx); return null; }
 	public T visit(AParser.sContext ctx) { visitChildren(ctx); return null; }
+	public T visit(AParser.FooContext ctx) { visitChildren(ctx); return null; }
 	public T visit(AParser.AddContext ctx) { visitChildren(ctx); return null; }
 	public T visit(AParser.IntContext ctx) { visitChildren(ctx); return null; }
-}
\ No newline at end of file
+}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -139,7 +139,9 @@ public enum ErrorType {
 	ALL_OPS_NEED_SAME_ASSOC(118, "all operators of alt <arg> of left-recursive rule must have same associativity", ErrorSeverity.WARNING),
 	LEFT_RECURSION_CYCLES(119, "The following sets of rules are mutually left-recursive <arg:{c| [<c:{r|<r.name>}; separator=\", \">]}; separator=\" and \">", ErrorSeverity.ERROR),
 	MODE_NOT_IN_LEXER(120, "lexical modes are only allowed in lexer grammars", ErrorSeverity.ERROR),
-    CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(121, "cannot find an attribute name in attribute declaration", ErrorSeverity.ERROR),
+	CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(121, "cannot find an attribute name in attribute declaration", ErrorSeverity.ERROR),
+	RULE_WITH_TOO_FEW_ALT_LABELS(122, "rule <arg>: must label all alternatives or none", ErrorSeverity.ERROR),
+	ALT_LABEL_REDEF(123, "rule alt label <arg> redefined in rule <arg2>, originally in <arg3>", ErrorSeverity.ERROR),
 	/** Documentation comment is unterminated */
     //UNTERMINATED_DOC_COMMENT(, "", ErrorSeverity.ERROR),
 

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -418,7 +418,7 @@ protected JavaParserFactory getParserFactory() {
             @SuppressWarnings({"unchecked"})
             final Class<? extends Parser> parserClass = (Class<? extends Parser>)loader.loadClass("JavaParser");
             @SuppressWarnings({"unchecked"})
-            final Class<? extends ParseTreeListener<Token>> listenerClass = (Class<? extends ParseTreeListener<Token>>)loader.loadClass("BlankJavaListener");
+            final Class<? extends ParseTreeListener<Token>> listenerClass = (Class<? extends ParseTreeListener<Token>>)loader.loadClass("JavaBaseListener");
             TestPerformance.sharedListener = listenerClass.newInstance();
 
             final Constructor<? extends Lexer> lexerCtor = lexerClass.getConstructor(CharStream.class);

File: tool/test/org/antlr/v4/test/TestFullContextParsing.java
Patch:
@@ -118,7 +118,7 @@ public class TestFullContextParsing extends BaseTest {
 		assertEquals(expecting, result);
 		assertEquals("line 1:5 reportAttemptingFullContext d=2: [(30,1,[20 10]), (22,2,[10])], input='34abc'\n" +
 					 "line 1:2 reportContextSensitivity d=2: [(22,1,[10])],uniqueAlt=1, input='34'\n" +
-					 "line 1:17 reportAttemptingFullContext d=2: [(30,1,[24 14]), (26,2,[14])], input='34abc'\n" +
+					 "line 1:14 reportAttemptingFullContext d=2: [(30,1,[24 14]), (26,2,[14])], input='34abc'\n" +
 					 "line 1:14 reportContextSensitivity d=2: [(8,2,[18]), (12,2,[18]), (1,2,[])],uniqueAlt=2, input='34abc'\n",
 					 this.stderrDuringParse);
 	}

File: tool/test/org/antlr/v4/test/TestFullContextParsing.java
Patch:
@@ -118,7 +118,7 @@ public class TestFullContextParsing extends BaseTest {
 		assertEquals(expecting, result);
 		assertEquals("line 1:5 reportAttemptingFullContext d=2: [(30,1,[20 10]), (22,2,[10])], input='34abc'\n" +
 					 "line 1:2 reportContextSensitivity d=2: [(22,1,[10])],uniqueAlt=1, input='34'\n" +
-					 "line 1:17 reportAttemptingFullContext d=2: [(30,1,[24 14]), (26,2,[14])], input='34abc'\n" +
+					 "line 1:14 reportAttemptingFullContext d=2: [(30,1,[24 14]), (26,2,[14])], input='34abc'\n" +
 					 "line 1:14 reportContextSensitivity d=2: [(8,2,[18]), (12,2,[18]), (1,2,[])],uniqueAlt=2, input='34abc'\n",
 					 this.stderrDuringParse);
 	}

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -71,7 +71,7 @@ public abstract class BaseTest {
 	public static final String newline = System.getProperty("line.separator");
 	public static final String pathSep = System.getProperty("path.separator");
 
-	public static final boolean TEST_IN_SAME_PROCESS = false;
+	public static final boolean TEST_IN_SAME_PROCESS = Boolean.parseBoolean(System.getProperty("antlr.testinprocess"));
 
     /**
      * Build up the full classpath we need, including the surefire path (if present)
@@ -510,7 +510,7 @@ protected boolean rawGenerateAndBuildRecognizer(String grammarFileName,
 		}
 		if ( parserName!=null ) {
 			files.add(parserName+".java");
-			files.add("Blank"+grammarFileName.substring(0, grammarFileName.lastIndexOf('.'))+"Listener.java");
+			files.add(grammarFileName.substring(0, grammarFileName.lastIndexOf('.'))+"BaseListener.java");
 		}
 		ok = compile(files.toArray(new String[files.size()]));
 		if ( !ok ) { allIsWell = false; }

File: tool/test/org/antlr/v4/test/TestToolSyntaxErrors.java
Patch:
@@ -135,7 +135,8 @@ public class TestToolSyntaxErrors extends BaseTest {
 			"mode foo;\n" +
 			"b : B ;",
 
-			"error(87): A.g:3:5: lexical modes are only allowed in lexer grammars\n"
+			": A.g:4:0: 'b' came as a complete surprise to me\n" +
+			": A.g:4:6: mismatched input ';' expecting COLON while matching a lexer rule\n"
 		};
 		super.testErrors(pair, true);
 	}

File: tool/src/org/antlr/v4/codegen/CodeGenerator.java
Patch:
@@ -303,6 +303,7 @@ public String getRecognizerFileName() {
 	 *  TListener.java, if we're using the Java target.
  	 */
 	public String getListenerFileName() {
+		assert g.name != null;
 		ST extST = templates.getInstanceOf("codeFileExtension");
 		String listenerName = g.name + "Listener";
 		return listenerName+extST.render();
@@ -312,6 +313,7 @@ public String getListenerFileName() {
 	 *  such as BlankTListener.java, if we're using the Java target.
  	 */
 	public String getBlankListenerFileName() {
+		assert g.name != null;
 		ST extST = templates.getInstanceOf("codeFileExtension");
 		String listenerName = "Blank" + g.name + "Listener";
 		return listenerName+extST.render();

File: tool/test/org/antlr/v4/test/TestLexerAttributes.java
Patch:
@@ -22,7 +22,7 @@ public void testSetType() throws RecognitionException {
 		int start = output.indexOf('#');
 		int end = output.lastIndexOf('#');
 		String snippet = output.substring(start+1,end);
-		assertEquals("type = 101;", snippet);
+		assertEquals("_type = 101;", snippet);
 	}
 
 }

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -6,6 +6,7 @@
 import org.antlr.v4.runtime.tree.ParseTreeListener;
 import org.antlr.v4.runtime.tree.ParseTreeWalker;
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.*;
@@ -75,7 +76,7 @@ public class TestPerformance extends BaseTest {
     private int tokenCount;
 
     @Test
-//    @Ignore
+    @Ignore
     public void compileJdk() throws IOException {
         compileParser(USE_LR_GRAMMAR);
         JavaParserFactory factory = getParserFactory();

File: tool/test/org/antlr/v4/test/TestActionTranslation.java
Patch:
@@ -116,8 +116,8 @@ public class TestActionTranslation extends BaseTest {
     }
 
     @Test public void testRuleRefs() throws Exception {
-        String action = "$lab.start; $c.tree;";
-		String expected = "(_localctx.lab!=null?((Token)_localctx.lab.start):null); (_localctx._rc!=null?((CommonAST)_localctx._rc.tree):null);";
+        String action = "$lab.start;";
+		String expected = "(_localctx.lab!=null?(_localctx.lab.start):null);";
 		testActions(attributeTemplate, "inline", action, expected);
     }
 

File: tool/test/org/antlr/v4/test/TestSemPredEvalParser.java
Patch:
@@ -274,7 +274,7 @@ public void testUnpredicatedPathsInAlt() throws Exception{
 			"alt 1\n";
 		assertEquals(expecting, found);
 
-		expecting = "";
+		expecting = null;
 		assertEquals(expecting, stderrDuringParse);
 	}
 

File: tool/test/org/antlr/v4/test/TestLexerAttributes.java
Patch:
@@ -22,7 +22,7 @@ public void testSetType() throws RecognitionException {
 		int start = output.indexOf('#');
 		int end = output.lastIndexOf('#');
 		String snippet = output.substring(start+1,end);
-		assertEquals("type = 101;", snippet);
+		assertEquals("_type = 101;", snippet);
 	}
 
 }

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -292,7 +292,7 @@ protected boolean compile(String... fileNames) {
 			fileManager.getJavaFileObjectsFromFiles(files);
 
 		Iterable<String> compileOptions =
-			Arrays.asList("-d", tmpdir, "-cp", tmpdir+pathSep+CLASSPATH);
+			Arrays.asList("-g", "-d", tmpdir, "-cp", tmpdir+pathSep+CLASSPATH);
 
 		JavaCompiler.CompilationTask task =
 			compiler.getTask(null, fileManager, null, compileOptions, null,

File: runtime/Java/src/org/antlr/v4/runtime/NoViableAltException.java
Patch:
@@ -57,7 +57,7 @@ public <Symbol> NoViableAltException(Parser recognizer,
 										 Token startToken,
 										 Token offendingToken,
 										 ATNConfigSet deadEndConfigs,
-										 ParserRuleContext ctx)
+										 ParserRuleContext<?> ctx)
 	{
 		super(recognizer, input, ctx);
 		this.deadEndConfigs = deadEndConfigs;

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNPathFinder.java
Patch:
@@ -32,6 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.Parser;
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.RuleContext;
+import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenStream;
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.runtime.misc.NotNull;
@@ -43,7 +44,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.List;
 import java.util.Set;
 
-public class ParserATNPathFinder extends ParserATNSimulator {
+public class ParserATNPathFinder extends ParserATNSimulator<Token> {
 	public ParserATNPathFinder(@Nullable Parser parser, @NotNull ATN atn) {
 		super(parser, atn);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -38,7 +38,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.List;
 
 /** This is all the parsing support code essentially; most of it is error recovery stuff. */
-public abstract class Parser extends Recognizer<Token, v2ParserATNSimulator<Token>> {
+public abstract class Parser extends Recognizer<Token, ParserATNSimulator<Token>> {
 	public class TraceListener implements ParseTreeListener<Token> {
 		@Override
 		public void enterEveryRule(ParserRuleContext<Token> ctx) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNPathFinder.java
Patch:
@@ -43,7 +43,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.List;
 import java.util.Set;
 
-public class ParserATNPathFinder extends v2ParserATNSimulator {
+public class ParserATNPathFinder extends ParserATNSimulator {
 	public ParserATNPathFinder(@Nullable Parser parser, @NotNull ATN atn) {
 		super(parser, atn);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -225,7 +225,7 @@ So, we now cover what I hope is the vast majority of the cases (in
  	 *  when closure operations fall off the end of the rule that
  	 *  holds the decision were evaluating
 */
-public class v2ParserATNSimulator<Symbol> extends ATNSimulator {
+public class ParserATNSimulator<Symbol> extends ATNSimulator {
 	public static boolean debug = false;
 	public static boolean dfa_debug = false;
 	public static boolean retry_debug = false;
@@ -242,11 +242,11 @@ public class v2ParserATNSimulator<Symbol> extends ATNSimulator {
 	public final DFA[] decisionToDFA;
 
 	/** Testing only! */
-	public v2ParserATNSimulator(@NotNull ATN atn) {
+	public ParserATNSimulator(@NotNull ATN atn) {
 		this(null, atn);
 	}
 
-	public v2ParserATNSimulator(@Nullable Parser parser, @NotNull ATN atn) {
+	public ParserATNSimulator(@Nullable Parser parser, @NotNull ATN atn) {
 		super(atn);
 		this.parser = parser;
 //		ctxToDFAs = new HashMap<RuleContext, DFA[]>();

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFA.java
Patch:
@@ -28,10 +28,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime.dfa;
 
-import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenStream;
 import org.antlr.v4.runtime.atn.*;
-import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Nullable;
 
@@ -83,7 +81,7 @@ public class DFA {
 //		return states;
 //	}
 
-	public List<Set<ATNState>> getATNStatesAlongPath(v2ParserATNSimulator atn,
+	public List<Set<ATNState>> getATNStatesAlongPath(ParserATNSimulator atn,
 													 List<DFAState> dfaStates,
 													 TokenStream input, int start, int stop)
 	{

File: tool/test/org/antlr/v4/test/TestATNDeserialization.java
Patch:
@@ -3,7 +3,7 @@
 import org.antlr.v4.automata.ATNSerializer;
 import org.antlr.v4.misc.Utils;
 import org.antlr.v4.runtime.atn.ATN;
-import org.antlr.v4.runtime.atn.v2ParserATNSimulator;
+import org.antlr.v4.runtime.atn.ParserATNSimulator;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.LexerGrammar;
 import org.junit.Test;
@@ -147,7 +147,7 @@ protected void checkDeserializationIsStable(Grammar g) {
 		ATN atn = createATN(g);
 		char[] data = Utils.toCharArray(ATNSerializer.getSerialized(g, atn));
 		String atnData = ATNSerializer.getDecoded(g, atn);
-		ATN atn2 = v2ParserATNSimulator.deserialize(data);
+		ATN atn2 = ParserATNSimulator.deserialize(data);
 		String atn2Data = ATNSerializer.getDecoded(g, atn2);
 
 		assertEquals(atnData, atn2Data);

File: tool/test/org/antlr/v4/test/TestATNParserPrediction.java
Patch:
@@ -541,7 +541,7 @@ public DFA getDFA(LexerGrammar lg, Grammar g, String ruleName,
 //		System.out.println(dot.getDOT(atn.ruleToStartState.get(g.getRule("b"))));
 //		System.out.println(dot.getDOT(atn.ruleToStartState.get(g.getRule("e"))));
 
-		v2ParserATNSimulator interp = new v2ParserATNSimulator(atn);
+		ParserATNSimulator interp = new ParserATNSimulator(atn);
 		List<Integer> types = getTokenTypesViaATN(inputString, lexInterp);
 		System.out.println(types);
 		TokenStream input = new IntTokenStream(types);

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -38,7 +38,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.List;
 
 /** This is all the parsing support code essentially; most of it is error recovery stuff. */
-public abstract class Parser extends Recognizer<Token, v2ParserATNSimulator<Token>> {
+public abstract class Parser extends Recognizer<Token, ParserATNSimulator<Token>> {
 	public class TraceListener implements ParseTreeListener<Token> {
 		@Override
 		public void enterEveryRule(ParserRuleContext<Token> ctx) {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNPathFinder.java
Patch:
@@ -43,7 +43,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.List;
 import java.util.Set;
 
-public class ParserATNPathFinder extends v2ParserATNSimulator {
+public class ParserATNPathFinder extends ParserATNSimulator {
 	public ParserATNPathFinder(@Nullable Parser parser, @NotNull ATN atn) {
 		super(parser, atn);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -225,7 +225,7 @@ So, we now cover what I hope is the vast majority of the cases (in
  	 *  when closure operations fall off the end of the rule that
  	 *  holds the decision were evaluating
 */
-public class v2ParserATNSimulator<Symbol> extends ATNSimulator {
+public class ParserATNSimulator<Symbol> extends ATNSimulator {
 	public static boolean debug = false;
 	public static boolean dfa_debug = false;
 	public static boolean retry_debug = false;
@@ -242,11 +242,11 @@ public class v2ParserATNSimulator<Symbol> extends ATNSimulator {
 	public final DFA[] decisionToDFA;
 
 	/** Testing only! */
-	public v2ParserATNSimulator(@NotNull ATN atn) {
+	public ParserATNSimulator(@NotNull ATN atn) {
 		this(null, atn);
 	}
 
-	public v2ParserATNSimulator(@Nullable Parser parser, @NotNull ATN atn) {
+	public ParserATNSimulator(@Nullable Parser parser, @NotNull ATN atn) {
 		super(atn);
 		this.parser = parser;
 //		ctxToDFAs = new HashMap<RuleContext, DFA[]>();

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFA.java
Patch:
@@ -28,10 +28,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime.dfa;
 
-import org.antlr.v4.runtime.Token;
 import org.antlr.v4.runtime.TokenStream;
 import org.antlr.v4.runtime.atn.*;
-import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.runtime.misc.NotNull;
 import org.antlr.v4.runtime.misc.Nullable;
 
@@ -83,7 +81,7 @@ public class DFA {
 //		return states;
 //	}
 
-	public List<Set<ATNState>> getATNStatesAlongPath(v2ParserATNSimulator atn,
+	public List<Set<ATNState>> getATNStatesAlongPath(ParserATNSimulator atn,
 													 List<DFAState> dfaStates,
 													 TokenStream input, int start, int stop)
 	{

File: tool/test/org/antlr/v4/test/TestATNDeserialization.java
Patch:
@@ -3,7 +3,7 @@
 import org.antlr.v4.automata.ATNSerializer;
 import org.antlr.v4.misc.Utils;
 import org.antlr.v4.runtime.atn.ATN;
-import org.antlr.v4.runtime.atn.v2ParserATNSimulator;
+import org.antlr.v4.runtime.atn.ParserATNSimulator;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.LexerGrammar;
 import org.junit.Test;
@@ -147,7 +147,7 @@ protected void checkDeserializationIsStable(Grammar g) {
 		ATN atn = createATN(g);
 		char[] data = Utils.toCharArray(ATNSerializer.getSerialized(g, atn));
 		String atnData = ATNSerializer.getDecoded(g, atn);
-		ATN atn2 = v2ParserATNSimulator.deserialize(data);
+		ATN atn2 = ParserATNSimulator.deserialize(data);
 		String atn2Data = ATNSerializer.getDecoded(g, atn2);
 
 		assertEquals(atnData, atn2Data);

File: tool/test/org/antlr/v4/test/TestATNParserPrediction.java
Patch:
@@ -541,7 +541,7 @@ public DFA getDFA(LexerGrammar lg, Grammar g, String ruleName,
 //		System.out.println(dot.getDOT(atn.ruleToStartState.get(g.getRule("b"))));
 //		System.out.println(dot.getDOT(atn.ruleToStartState.get(g.getRule("e"))));
 
-		v2ParserATNSimulator interp = new v2ParserATNSimulator(atn);
+		ParserATNSimulator interp = new ParserATNSimulator(atn);
 		List<Integer> types = getTokenTypesViaATN(inputString, lexInterp);
 		System.out.println(types);
 		TokenStream input = new IntTokenStream(types);

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -368,6 +368,7 @@ public GrammarRootAST load(CharStream in) {
 			GrammarASTAdaptor adaptor = new GrammarASTAdaptor(in);
 			ANTLRLexer lexer = new ANTLRLexer(in);
 			CommonTokenStream tokens = new CommonTokenStream(lexer);
+			lexer.tokens = tokens;
 			ToolANTLRParser p = new ToolANTLRParser(tokens, this);
 			p.setTreeAdaptor(adaptor);
 			ParserRuleReturnScope r = p.grammarSpec();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -157,6 +157,7 @@ public RuleAST parseArtificialRule(final Grammar g, String ruleText) {
 		ANTLRLexer lexer = new ANTLRLexer(new ANTLRStringStream(ruleText));
 		GrammarASTAdaptor adaptor = new GrammarASTAdaptor();
 		CommonTokenStream tokens = new CommonTokenStream(lexer);
+		lexer.tokens = tokens;
 		ToolANTLRParser p = new ToolANTLRParser(tokens, tool);
 		p.setTreeAdaptor(adaptor);
 		try {

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -368,6 +368,7 @@ public GrammarRootAST load(CharStream in) {
 			GrammarASTAdaptor adaptor = new GrammarASTAdaptor(in);
 			ANTLRLexer lexer = new ANTLRLexer(in);
 			CommonTokenStream tokens = new CommonTokenStream(lexer);
+			lexer.tokens = tokens;
 			ToolANTLRParser p = new ToolANTLRParser(tokens, this);
 			p.setTreeAdaptor(adaptor);
 			ParserRuleReturnScope r = p.grammarSpec();

File: tool/src/org/antlr/v4/analysis/LeftRecursiveRuleTransformer.java
Patch:
@@ -157,6 +157,7 @@ public RuleAST parseArtificialRule(final Grammar g, String ruleText) {
 		ANTLRLexer lexer = new ANTLRLexer(new ANTLRStringStream(ruleText));
 		GrammarASTAdaptor adaptor = new GrammarASTAdaptor();
 		CommonTokenStream tokens = new CommonTokenStream(lexer);
+		lexer.tokens = tokens;
 		ToolANTLRParser p = new ToolANTLRParser(tokens, tool);
 		p.setTreeAdaptor(adaptor);
 		try {

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -237,6 +237,7 @@ else if ( (i+2)<n && chars.charAt(i+1)=='-' ) { // range x-y
 				int x = c;
 				int y = chars.charAt(i+2);
 				if ( x<=y ) set.add(x,y);
+				i+=2;
 			}
 			else {
 				set.add(c);

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -237,6 +237,7 @@ else if ( (i+2)<n && chars.charAt(i+1)=='-' ) { // range x-y
 				int x = c;
 				int y = chars.charAt(i+2);
 				if ( x<=y ) set.add(x,y);
+				i+=2;
 			}
 			else {
 				set.add(c);

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -347,7 +347,9 @@ protected Rectangle2D.Double getBoundsOfNode(Tree node) {
 	}
 
 	protected String getText(Tree tree) {
-		return treeTextProvider.getText(tree);
+		String s = treeTextProvider.getText(tree);
+		s = Utils.escapeWhitespace(s, true);
+		return s;
 	}
 
 	public TreeTextProvider getTreeTextProvider() {

File: runtime/Java/src/org/antlr/v4/runtime/misc/Utils.java
Patch:
@@ -59,10 +59,10 @@ public  static <T> void removeAllElements(Collection<T> data, T value) {
 		while ( data.contains(value) ) data.remove(value);
 	}
 
-	public static String escapeWhitespace(String s) {
+	public static String escapeWhitespace(String s, boolean escapeSpaces) {
 		StringBuilder buf = new StringBuilder();
 		for (char c : s.toCharArray()) {
-			if ( c==' ' ) buf.append('\u00B7');
+			if ( c==' ' && escapeSpaces ) buf.append('\u00B7');
 			else if ( c=='\t' ) buf.append("\\t");
 			else if ( c=='\n' ) buf.append("\\n");
 			else if ( c=='\r' ) buf.append("\\r");

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java
Patch:
@@ -62,8 +62,7 @@ public DefaultTreeTextProvider(Parser parser) {
 
 		@Override
 		public String getText(Tree node) {
-			boolean escapeWhitespace = true;
-			return String.valueOf(Trees.getNodeText(node, parser, escapeWhitespace));
+			return String.valueOf(Trees.getNodeText(node, parser));
 		}
 	}
 
@@ -213,7 +212,7 @@ protected void paintBox(Graphics g, Tree tree) {
 
 	public void text(Graphics g, String s, int x, int y) {
 //		System.out.println("drawing '"+s+"' @ "+x+","+y);
-		s = Utils.escapeWhitespace(s);
+		s = Utils.escapeWhitespace(s, true);
 		g.drawString(s, x, y);
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -129,7 +129,6 @@ public boolean sempred(@Nullable RuleContext _localctx, int ruleIndex, int actio
 		return true;
 	}
 
-	/** In lexer, both indexes are same; one action per rule. */
 	public void action(@Nullable RuleContext _localctx, int ruleIndex, int actionIndex) {
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/v2ParserATNSimulator.java
Patch:
@@ -759,7 +759,6 @@ public SemanticContext[] getPredsForAmbigAlts(@NotNull IntervalSet ambigAlts,
 		for (ATNConfig c : configs) {
 			if ( c.semanticContext!=SemanticContext.NONE && ambigAlts.contains(c.alt) ) {
 				altToPred[c.alt] = SemanticContext.or(altToPred[c.alt], c.semanticContext);
-				c.resolveWithPredicate = true;
 				nPredAlts++;
 			}
 		}

File: runtime/Java/src/org/antlr/v4/runtime/dfa/DFAState.java
Patch:
@@ -80,7 +80,8 @@ public class DFAState {
 
 	public int prediction; // if accept state, what ttype do we match? is "else" clause if predicated
 
-	public int ruleIndex; // if accept, exec what action?
+	public int lexerRuleIndex = -1;		// if accept, exec action in what rule?
+	public int lexerActionIndex = -1;	// if accept, exec what action?
 
 	// todo: rename as unique?
 	public boolean complete; // all alts predict "prediction"

File: tool/src/org/antlr/v4/codegen/ActionTranslator.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.runtime.ANTLRStringStream;
 import org.antlr.runtime.Token;
 import org.antlr.v4.codegen.model.RuleFunction;
-import org.antlr.v4.codegen.model.actions.*;
+import org.antlr.v4.codegen.model.chunk.*;
 import org.antlr.v4.parse.ActionSplitter;
 import org.antlr.v4.parse.ActionSplitterListener;
 import org.antlr.v4.tool.Attribute;

File: tool/src/org/antlr/v4/codegen/model/InvokeRule.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.codegen.ActionTranslator;
 import org.antlr.v4.codegen.CodeGenerator;
 import org.antlr.v4.codegen.OutputModelFactory;
-import org.antlr.v4.codegen.model.actions.ActionChunk;
+import org.antlr.v4.codegen.model.chunk.ActionChunk;
 import org.antlr.v4.codegen.model.decl.Decl;
 import org.antlr.v4.codegen.model.decl.RuleContextDecl;
 import org.antlr.v4.codegen.model.decl.RuleContextListDecl;

File: tool/src/org/antlr/v4/codegen/model/RuleActionFunction.java
Patch:
@@ -39,6 +39,7 @@ public class RuleActionFunction extends OutputModelObject {
 	public String ctxType;
 	public int ruleIndex;
 
+	/** Map actionIndex to Action */
 	@ModelElement public LinkedHashMap<Integer, Action> actions =
 		new LinkedHashMap<Integer, Action>();
 

File: tool/src/org/antlr/v4/codegen/model/chunk/ActionChunk.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 import org.antlr.v4.codegen.model.OutputModelObject;
 

File: tool/src/org/antlr/v4/codegen/model/chunk/ActionText.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class ActionText extends ActionChunk {

File: tool/src/org/antlr/v4/codegen/model/chunk/ArgRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class ArgRef extends LocalRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/DefaultParserSuperClass.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 public class DefaultParserSuperClass extends ActionChunk {
 }

File: tool/src/org/antlr/v4/codegen/model/chunk/LabelRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 public class LabelRef extends ActionChunk {
 	public String name;

File: tool/src/org/antlr/v4/codegen/model/chunk/LexerSetAttr.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 import java.util.List;
 

File: tool/src/org/antlr/v4/codegen/model/chunk/ListLabelRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 public class ListLabelRef extends LabelRef {
 	public ListLabelRef(String name) { super(name); }

File: tool/src/org/antlr/v4/codegen/model/chunk/LocalRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 public class LocalRef extends ActionChunk {
 	public String name;

File: tool/src/org/antlr/v4/codegen/model/chunk/NonLocalAttrRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 public class NonLocalAttrRef extends ActionChunk {
 	public String ruleName;

File: tool/src/org/antlr/v4/codegen/model/chunk/QRetValueRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class QRetValueRef extends RetValueRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/RetValueRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class RetValueRef extends ActionChunk {

File: tool/src/org/antlr/v4/codegen/model/chunk/RulePropertyRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class RulePropertyRef extends ActionChunk {

File: tool/src/org/antlr/v4/codegen/model/chunk/RulePropertyRef_ctx.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 public class RulePropertyRef_ctx extends RulePropertyRef {
     public RulePropertyRef_ctx(String label) {

File: tool/src/org/antlr/v4/codegen/model/chunk/RulePropertyRef_start.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class RulePropertyRef_start extends RulePropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/RulePropertyRef_stop.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class RulePropertyRef_stop extends RulePropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/RulePropertyRef_text.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class RulePropertyRef_text extends RulePropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/SetAttr.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 import org.antlr.v4.codegen.model.ModelElement;
 

File: tool/src/org/antlr/v4/codegen/model/chunk/SetNonLocalAttr.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 import java.util.List;
 

File: tool/src/org/antlr/v4/codegen/model/chunk/ThisRulePropertyRef_ctx.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 public class ThisRulePropertyRef_ctx extends RulePropertyRef {
     public ThisRulePropertyRef_ctx(String label) {

File: tool/src/org/antlr/v4/codegen/model/chunk/ThisRulePropertyRef_start.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class ThisRulePropertyRef_start extends RulePropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/ThisRulePropertyRef_stop.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class ThisRulePropertyRef_stop extends RulePropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/ThisRulePropertyRef_text.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class ThisRulePropertyRef_text extends RulePropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef extends ActionChunk {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef_channel.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef_channel extends TokenPropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef_index.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef_index extends TokenPropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef_int.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef_int extends TokenPropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef_line.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef_line extends TokenPropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef_pos.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef_pos extends TokenPropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef_text.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef_text extends TokenPropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenPropertyRef_type.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenPropertyRef_type extends TokenPropertyRef {

File: tool/src/org/antlr/v4/codegen/model/chunk/TokenRef.java
Patch:
@@ -27,7 +27,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package org.antlr.v4.codegen.model.actions;
+package org.antlr.v4.codegen.model.chunk;
 
 /** */
 public class TokenRef extends ActionChunk {

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -147,8 +147,8 @@ public class Grammar implements AttributeResolver {
      */
 	public Map<String,ActionAST> namedActions = new HashMap<String,ActionAST>();
 
-	/** Tracks all lexer actions in all alternatives of all rules.
-	 *  Doesn't track sempreds.  maps tree node to action index.
+	/** Tracks all user lexer actions in all alternatives of all rules.
+	 *  Doesn't track sempreds.  maps tree node to action index (alt number 1..n).
  	 */
 	public LinkedHashMap<ActionAST, Integer> lexerActions = new LinkedHashMap<ActionAST, Integer>();
 

File: tool/src/org/antlr/v4/codegen/ParserFactory.java
Patch:
@@ -41,6 +41,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.atn.StarLoopEntryState;
 import org.antlr.v4.runtime.misc.IntervalSet;
 import org.antlr.v4.tool.Alternative;
+import org.antlr.v4.tool.LeftRecursiveRule;
 import org.antlr.v4.tool.Rule;
 import org.antlr.v4.tool.ast.BlockAST;
 import org.antlr.v4.tool.ast.GrammarAST;
@@ -61,9 +62,8 @@ public Parser parser(ParserFile file) {
 	}
 
 	public RuleFunction rule(Rule r) {
-		GrammarAST optionNode = r.ast.getOption("simrecursion_");
-		if ( optionNode!=null && optionNode.getText().equals("true") ) {
-			return new LRecursiveRuleFunction(this, r);
+		if ( r instanceof LeftRecursiveRule ) {
+			return new LeftRecursiveRuleFunction(this, (LeftRecursiveRule)r);
 		}
 		else {
 			return new RuleFunction(this, r);

File: tool/src/org/antlr/v4/tool/ast/AltAST.java
Patch:
@@ -45,6 +45,7 @@ public class AltAST extends GrammarAST {
 	public AltAST(GrammarAST node) {
 		super(node);
 		this.alt = ((AltAST)node).alt;
+		this.altLabel = ((AltAST)node).altLabel;
 	}
 
 	public AltAST(Token t) { super(t); }

File: tool/test/org/antlr/v4/test/TestATNSerialization.java
Patch:
@@ -229,7 +229,7 @@ public class TestATNSerialization extends BaseTest {
 			"4:PLUS_BLOCK_START 0\n" +
 			"5:BLOCK_END 0\n" +
 			"6:PLUS_LOOP_BACK 0\n" +
-			"7:LOOP_END 0\n" +
+			"7:LOOP_END 0 6\n" +
 			"8:BASIC 0\n" +
 			"9:BASIC 0\n" +
 			"10:BASIC 0\n" +
@@ -406,7 +406,7 @@ public class TestATNSerialization extends BaseTest {
 			"5:PLUS_BLOCK_START 0\n" +
 			"6:BLOCK_END 0\n" +
 			"7:PLUS_LOOP_BACK 0\n" +
-			"8:LOOP_END 0\n" +
+			"8:LOOP_END 0 6\n" +
 			"rule 0:1 3,-1\n" +
 			"mode 0:0\n" +
 			"0->1 EPSILON 0,0,0\n" +

File: tool/test/org/antlr/v4/test/TestParseErrors.java
Patch:
@@ -77,7 +77,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x='b' {System.out.println(\"conjured=\"+$x);} 'c' ;";
 		String result = execParser("T.g", grammar, "TParser", "TLexer", "a", "ac", false);
-		String expecting = "conjured=[@-1,0:0='<missing 'b'>',<3>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<3>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 
@@ -96,7 +96,7 @@ public class TestParseErrors extends BaseTest {
 			"grammar T;\n" +
 			"a : 'a' x=('b'|'c') {System.out.println(\"conjured=\"+$x);} 'd' ;";
 		String result = execParser("T.g", grammar, "TParser", "TLexer", "a", "ad", false);
-		String expecting = "conjured=[@-1,0:0='<missing 'b'>',<3>,1:1]\n";
+		String expecting = "conjured=[@-1,-1:-1='<missing 'b'>',<3>,1:1]\n";
 		assertEquals(expecting, result);
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/Lexer.java
Patch:
@@ -322,7 +322,7 @@ public void recover(LexerNoViableAltException e) {
 	public void notifyListeners(LexerNoViableAltException e) {
 		String msg = "token recognition error at: '"+
 			_input.substring(tokenStartCharIndex, _input.index())+"'";
-		ANTLRErrorListener<Integer>[] listeners = getListeners();
+		ANTLRErrorListener<Integer>[] listeners = getErrorListeners();
 		if ( listeners.length == 0 ) {
 			System.err.println("line "+tokenStartLine+":"+
 							   tokenStartCharPositionInLine+" "+

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeListener.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.ParserRuleContext;
 
 public interface ParseTreeListener<Symbol> {
-    void visitTerminal(Symbol symbol);
+    void visitTerminal(ParserRuleContext<Symbol> ctx, Symbol symbol);
     void enterEveryRule(ParserRuleContext<Symbol> ctx);
     void exitEveryRule(ParserRuleContext<Symbol> ctx);
 }

File: tool/test/org/antlr/v4/test/TestPerformance.java
Patch:
@@ -43,7 +43,7 @@ public class TestPerformance extends BaseTest {
     /**
      *  Use ParseTreeWalker.DEFAULT.walk with the BlankJavaParserListener to show parse tree walking overhead.
      *  If {@link #BUILD_PARSE_TREES} is false, the listener will instead be called during the parsing process via
-     *  {@link org.antlr.v4.runtime.Parser#setListener}.
+     *  {@link org.antlr.v4.runtime.Parser#addParseListener}.
      */
     private static final boolean BLANK_LISTENER = false;
 
@@ -262,7 +262,7 @@ public void parseFile(CharStream input) {
                             sharedParser = parserCtor.newInstance(tokens);
                             sharedParser.setBuildParseTree(BUILD_PARSE_TREES);
                             if (!BUILD_PARSE_TREES && BLANK_LISTENER) {
-                                sharedParser.setListener(sharedListener);
+                                sharedParser.addParseListener(sharedListener);
                             }
                             if (BAIL_ON_ERROR) {
                                 sharedParser.setErrorHandler(new BailErrorStrategy());

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -134,4 +134,6 @@ public void action(@Nullable RuleContext _localctx, int ruleIndex, int actionInd
 	public abstract IntStream getInputStream();
 
 	public abstract void setInputStream(IntStream input);
+
+	public abstract void setTokenFactory(TokenFactory<?> input);
 }

File: runtime/Java/src/org/antlr/v4/runtime/Token.java
Patch:
@@ -35,7 +35,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 public interface Token {
 	public static final int INVALID_TYPE = 0;
-	public static final Token INVALID_TOKEN = new CommonToken(INVALID_TYPE);
+//	public static final Token INVALID_TOKEN = new CommonToken(INVALID_TYPE);
 	public static final int MIN_TOKEN_TYPE = 1;
 
     /** During lookahead operations, this "token" signifies we hit rule end ATN state

File: runtime/Java/src/org/antlr/v4/runtime/TokenSource.java
Patch:
@@ -62,4 +62,7 @@ public interface TokenSource {
 	 *  ask lexers input stream.
 	 */
 	public String getSourceName();
+
+	/** Optional method that lets users set factory in lexer or other source */
+	public void setTokenFactory(TokenFactory<?> factory);
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java
Patch:
@@ -119,7 +119,6 @@ else if ( arg.equals("-ps") ) {
 		Parser parser = parserCtor.newInstance(tokens);
 
 		parser.setErrorHandler(new DiagnosticErrorStrategy<Token>());
-		parser.getInterpreter().setTrace(true);
 
 		if ( printTree || gui || psFile!=null ) {
 			parser.setBuildParseTree(true);

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -55,7 +55,7 @@ public class ATNConfig {
 	 *  execution of the ATN simulator.
 	 */
 	@Nullable
-	public final RuleContext context;
+	public RuleContext context;
 
 	/**
 	 * Indicates that we have reached this ATN configuration after

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -525,7 +525,6 @@ else if ( t.getClass() == PredicateTransition.class ) {
 			PredicateTransition pt = (PredicateTransition)t;
 			if ( recog == null || recog.sempred(null, pt.ruleIndex, pt.predIndex) ) {
 				c = new ATNConfig(config, t.target, pt.getPredicate());
-//				c.traversedPredicate = true;
 			}
 		}
 		// ignore actions; just exec one per rule upon accept
@@ -640,7 +639,7 @@ protected DFAState addDFAState(@NotNull ATNConfigSet configs) {
 			{
 				firstConfigWithRuleStopState = c;
 			}
-			if ( c.semanticContext!=null ) traversedPredicate = true;
+			if ( c.semanticContext!=null && c.semanticContext!=SemanticContext.NONE ) traversedPredicate = true;
 //			if ( c.traversedPredicate ) traversedPredicate = true;
 		}
 

File: runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java
Patch:
@@ -119,6 +119,7 @@ else if ( arg.equals("-ps") ) {
 		Parser parser = parserCtor.newInstance(tokens);
 
 		parser.setErrorHandler(new DiagnosticErrorStrategy<Token>());
+		parser.getInterpreter().setTrace(true);
 
 		if ( printTree || gui || psFile!=null ) {
 			parser.setBuildParseTree(true);

File: tool/test/org/antlr/v4/test/TestATNSerialization.java
Patch:
@@ -229,7 +229,7 @@ public class TestATNSerialization extends BaseTest {
 			"4:PLUS_BLOCK_START 0\n" +
 			"5:BLOCK_END 0\n" +
 			"6:PLUS_LOOP_BACK 0\n" +
-			"7:BASIC 0\n" +
+			"7:LOOP_END 0\n" +
 			"8:BASIC 0\n" +
 			"9:BASIC 0\n" +
 			"10:BASIC 0\n" +
@@ -406,7 +406,7 @@ public class TestATNSerialization extends BaseTest {
 			"5:PLUS_BLOCK_START 0\n" +
 			"6:BLOCK_END 0\n" +
 			"7:PLUS_LOOP_BACK 0\n" +
-			"8:BASIC 0\n" +
+			"8:LOOP_END 0\n" +
 			"rule 0:1 3,-1\n" +
 			"mode 0:0\n" +
 			"0->1 EPSILON 0,0,0\n" +
@@ -560,7 +560,7 @@ public class TestATNSerialization extends BaseTest {
 			"10:PLUS_BLOCK_START 0\n" +
 			"11:BLOCK_END 0\n" +
 			"12:PLUS_LOOP_BACK 0\n" +
-			"13:BASIC 0\n" +
+			"13:LOOP_END 0\n" +
 			"14:BASIC 1\n" +
 			"15:BASIC 1\n" +
 			"16:BASIC 1\n" +

File: runtime/Java/src/org/antlr/v4/runtime/misc/LookaheadStream.java
Patch:
@@ -150,7 +150,8 @@ public void seek(int index) {
         }
 
         if (index > currentElementIndex) {
-            for (int i = 0; i < currentElementIndex - index; i++) {
+            int startElementIndex = currentElementIndex;
+            for (int i = 0; i < index - startElementIndex; i++) {
                 consume();
             }
         }

File: runtime/Java/src/org/antlr/v4/runtime/RuleContext.java
Patch:
@@ -180,7 +180,7 @@ public boolean equals(Object o) {
 	 *  fast enough upon nondeterminism.
 	 */
 	public boolean conflictsWith(RuleContext other) {
-		return this.suffix(other); // || this.equals(other);
+		return this.suffix(other) || this.equals(other);
 	}
 
 	/** [$] suffix any context

File: tool/test/org/antlr/v4/test/TestSemPredEvalParser.java
Patch:
@@ -248,8 +248,6 @@ public class TestSemPredEvalParser extends BaseTest {
 		assertEquals(expecting, result);
 	}
 
-	// TODO: test predicates that are validating predicates; not ambiguous decisions
-
 	@Test public void testToLeft() throws Exception {
 		String grammar =
 			"grammar T;\n" +

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -43,7 +43,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.*;
 
 public class ParserATNSimulator<Symbol> extends ATNSimulator {
-	public static boolean debug = false;
+	public static boolean debug = true;
 	public static boolean dfa_debug = false;
 
 	public static int ATN_failover = 0;

File: tool/playground/TestJavaLR.java
Patch:
@@ -121,7 +121,7 @@ public static void parseFile(String f)
 
 			CommonTokenStream tokens = new CommonTokenStream(lexer);
 			long start = System.currentTimeMillis();
-//			tokens.fill();
+			tokens.fill(); // load all and check time
 //			System.out.println(tokens.getTokens());
 			long stop = System.currentTimeMillis();
 			lexerTime += stop-start;
@@ -130,7 +130,7 @@ public static void parseFile(String f)
 				// Create a parser that reads from the scanner
 				if ( parser==null ) {
 					parser = new JavaLRParser(null);
-//                    parser.setBuildParseTree(true);
+					if ( showTree ) parser.setBuildParseTree(true);
 //                    parser.setErrorHandler(new BailErrorStrategy<Token>());
 //					parser.getInterpreter().setContextSensitive(true);
 				}

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -136,7 +136,7 @@ public enum ErrorType {
 	AST_OP_IN_ALT_WITH_REWRITE(115, "rule <arg> alt <arg2> uses rewrite syntax and also an AST operator", ErrorSeverity.ERROR),
     WILDCARD_AS_ROOT(116, "Wildcard invalid as root; wildcard can itself be a tree", ErrorSeverity.ERROR),
     CONFLICTING_OPTION_IN_TREE_FILTER(117, "option <arg>=<arg2> conflicts with tree grammar filter mode", ErrorSeverity.ERROR),
-	ALL_OPS_NEED_SAME_ASSOC(118, "all operators of alt <alt> of left-recursive rule must have same associativity", ErrorSeverity.WARNING),
+	ALL_OPS_NEED_SAME_ASSOC(118, "all operators of alt <arg> of left-recursive rule must have same associativity", ErrorSeverity.WARNING),
 	LEFT_RECURSION_CYCLES(119, "The following sets of rules are mutually left-recursive <arg:{c| [<c:{r|<r.name>}; separator=\", \">]}; separator=\" and \">", ErrorSeverity.ERROR),
 	MODE_NOT_IN_LEXER(120, "lexical modes are only allowed in lexer grammars", ErrorSeverity.ERROR),
     CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(121, "cannot find an attribute name in attribute declaration", ErrorSeverity.ERROR),

File: tool/test/org/antlr/v4/test/TestSemPredEvalParser.java
Patch:
@@ -112,7 +112,9 @@ public class TestSemPredEvalParser extends BaseTest {
 		// Since the 2nd alternative has a true predicate, we always choose that one
 		String grammar =
 			"grammar T;\n" +
-				"s : a a;\n" + // do 2x: once in ATN, next in DFA
+				"s : a {} a;\n" + // do 2x: once in ATN, next in DFA;
+								  // action blocks lookahead from falling off of 'a'
+								  // and looking into 2nd 'a' ref. !ctx dependent pred
 				"a :          ID {System.out.println(\"alt 1\");}\n" +
 				"  | {true}?  ID {System.out.println(\"alt 2\");}\n" +
 				"  ;\n" +

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -61,8 +61,8 @@ public void enterRule(ParserRuleContext<Token> localctx, int ruleIndex) {
 		_ctx.ruleIndex = ruleIndex;
 		if ( buildParseTrees ) addContextToParseTree();
         if ( _listener != null) {
-            _ctx.enterRule(_listener);
             _listener.enterEveryRule(_ctx);
+            _ctx.enterRule(_listener);
         }
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/BailErrorStrategy.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 /** Bail out of parser at first syntax error. Do this to use it:
  *      myparser.setErrorHandler(new BailErrorStrategy<Token>());
  */
-public class BailErrorStrategy<Symbol> extends DefaultErrorStrategy<Symbol> {
+public class BailErrorStrategy extends DefaultErrorStrategy<Token> {
     /** Instead of recovering from exception e, Re-throw wrote it wrapped
      *  in a generic RuntimeException so it is not caught by the
      *  rule function catches.  Exception e is the "cause" of the
@@ -47,7 +47,7 @@ public void recover(BaseRecognizer recognizer, RecognitionException e) {
      *  successfully recovers, it won't throw an exception.
      */
     @Override
-    public Symbol recoverInline(BaseRecognizer recognizer)
+    public Token recoverInline(BaseRecognizer recognizer)
         throws RecognitionException
     {
         throw new RuntimeException(new InputMismatchException(recognizer));

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java
Patch:
@@ -481,7 +481,8 @@ public String toString(String[] tokenNames) {
 			int a = I.a;
 			int b = I.b;
 			if ( a==b ) {
-				if ( a==-1 ) buf.append("<EOF>");
+                if ( a==Token.EOF ) buf.append("<EOF>");
+                else if ( a==Token.EPSILON ) buf.append("<EPSILON>");
 				else buf.append(tokenNames[a]);
 			}
 			else {

File: tool/src/org/antlr/v4/automata/LexerATNFactory.java
Patch:
@@ -132,7 +132,6 @@ public Handle set(GrammarAST associatedAST, List<GrammarAST> alts, boolean inver
 		else {
 			left.addTransition(new SetTransition(right, set));
 		}
-		right.incidentTransition = left.transition(0);
 		associatedAST.atnState = left;
 		return new Handle(left, right);
 	}

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -37,7 +37,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public abstract class Recognizer<Symbol, ATNInterpreter extends ATNSimulator> {
 	public static final int EOF=-1;
 
-	protected ANTLRErrorStrategy<Symbol> _errHandler = new DefaultErrorStrategy();
+	protected ANTLRErrorStrategy<Symbol> _errHandler = new DefaultErrorStrategy<Symbol>();
 
 	private List<ANTLRErrorListener<Symbol>> _listeners;
 

File: tool/src/org/antlr/v4/codegen/model/OutputFile.java
Patch:
@@ -36,12 +36,15 @@ public abstract class OutputFile extends OutputModelObject {
     public final String fileName;
     public final String TokenLabelType;
     public final String ASTLabelType;
+    public final String InputSymbolType;
 
     public OutputFile(OutputModelFactory factory, String fileName) {
         super(factory);
         this.fileName = fileName;
         Grammar g = factory.getGrammar();
         TokenLabelType = g.getOptionString("TokenLabelType");
         ASTLabelType = g.getOptionString("ASTLabelType", "CommonAST");
+        if ( g.isTreeGrammar() ) InputSymbolType = ASTLabelType;
+        else InputSymbolType = TokenLabelType;
     }
 }

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorListener.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.misc.Nullable;
 
 /** How to emit recognition errors */
-public interface ANTLRErrorListener<TSymbol> {
+public interface ANTLRErrorListener<Symbol> {
 	/** Upon syntax error, notify any interested parties. This is not how to
 	 *  recover from errors or compute error messages. The parser
 	 *  ANTLRErrorStrategy specifies how to recover from syntax errors
@@ -66,8 +66,8 @@ public interface ANTLRErrorListener<TSymbol> {
 	 *        the parser was able to recover in line without exiting the
 	 *        surrounding rule.
 	 */
-	public void error(Recognizer<TSymbol, ?> recognizer,
-					  @Nullable TSymbol offendingSymbol,
+	public void error(Recognizer<Symbol, ?> recognizer,
+					  @Nullable Symbol offendingSymbol,
 					  int line,
 					  int charPositionInLine,
 					  String msg,

File: runtime/Java/src/org/antlr/v4/runtime/DefaultTreeGrammarErrorStrategy.java
Patch:
@@ -34,7 +34,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 import java.util.*;
 
-public class DefaultANTLRTreeGrammarErrorStrategy<T> extends DefaultANTLRErrorStrategy<T> {
+public class DefaultTreeGrammarErrorStrategy<T> extends DefaultErrorStrategy<T> {
 	@Override
 	public void beginErrorCondition(BaseRecognizer<T> recognizer) {
 	}

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -30,14 +30,12 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.automata;
 
 
-import org.antlr.v4.runtime.misc.NotNull;
-import org.antlr.v4.runtime.misc.Nullable;
 import org.antlr.runtime.*;
 import org.antlr.runtime.tree.*;
 import org.antlr.v4.misc.CharSupport;
 import org.antlr.v4.parse.*;
 import org.antlr.v4.runtime.atn.*;
-import org.antlr.v4.runtime.misc.IntervalSet;
+import org.antlr.v4.runtime.misc.*;
 import org.antlr.v4.semantics.UseDefAnalyzer;
 import org.antlr.v4.tool.*;
 import org.antlr.v4.tool.ast.*;

File: tool/test/org/antlr/v4/test/TestTreeParsing.java
Patch:
@@ -130,7 +130,7 @@ public class TestTreeParsing extends BaseTest {
 			"WS : (' '|'\\n') {$channel=HIDDEN;} ;\n";
 
 		String treeGrammar =
-			"tree grammar TP; options {ASTLabelType=CommonAST;}\n" +
+			"tree grammar TP; options {tokenVocab=\"T\"; ASTLabelType=CommonAST;}\n" +
 			"a : ID INT+ PERIOD {System.out.print(\"alt 1\");}"+
 			"  | ID INT+ SEMI   {System.out.print(\"alt 2\");}\n" +
 			"  ;\n";

File: tool/test/org/antlr/v4/test/TestASTNodeStream.java
Patch:
@@ -225,8 +225,8 @@ public String toTokenTypeString(ASTNodeStream stream) {
 		stream.consume(); // consume UP
 		stream.consume(); // consume UP
 		stream.consume(); // consume 104
-		stream.seek(index);
-		stream.release(m); // REWIND
+		stream.seek(index); // REWIND
+		stream.release(m);
         stream.mark();   // keep saving nodes though
 
 		assertEquals(107, ((AST)stream.LT(1)).getType());

File: tool/test/org/antlr/v4/test/TestASTOps.java
Patch:
@@ -747,8 +747,8 @@ public void testSetRootWithLabel() throws Exception {
 			"WS : (' '|'\\n') {$channel=HIDDEN;} ;\n";
 		String found = execParser("foo.g", grammar, "fooParser", "fooLexer",
 								  "a", "abc", debug);
-		assertEquals("line 1:3 mismatched input '<EOF>' expecting INT\n", this.stderrDuringParse);
-		assertEquals("<mismatched token: [@1,3:3='<EOF>',<-1>,1:3], resync=abc>\n", found);
+		assertEquals("line 1:3 missing INT at '<EOF>'\n", this.stderrDuringParse);
+		assertEquals("abc <missing INT>\n", found);
 	}
 
 	@Test public void testExtraTokenGivesErrorNode() throws Exception {
@@ -813,7 +813,7 @@ public void testSetRootWithLabel() throws Exception {
 			"WS : (' '|'\\n') {$channel=HIDDEN;} ;\n";
 		String found = execParser("foo.g", grammar, "fooParser", "fooLexer",
 								  "a", "*", debug);
-		assertEquals("line 1:0 no viable alternative at input '*'\n", this.stderrDuringParse);
+		assertEquals("line 1:0 mismatched input '*' expecting {ID, INT}\n", this.stderrDuringParse);
 		assertEquals("<unexpected: [@0,0:0='*',<6>,1:0], resync=*>\n", found);
 	}
 

File: tool/test/org/antlr/v4/test/TestActionTranslation.java
Patch:
@@ -135,7 +135,7 @@ public class TestActionTranslation extends BaseTest {
 
     @Test public void testRuleRefs() throws Exception {
         String action = "$lab.start; $c.tree;";
-		String expected = "(_localctx.lab!=null?(_localctx.lab.start):null); (_localctx._rc!=null?((CommonAST)_localctx._rc.tree):null);";
+		String expected = "(_localctx.lab!=null?((Token)_localctx.lab.start):null); (_localctx._rc!=null?((CommonAST)_localctx._rc.tree):null);";
 		testActions(attributeTemplate, "inline", action, expected);
     }
 

File: tool/test/org/antlr/v4/test/TestCompositeGrammars.java
Patch:
@@ -402,7 +402,7 @@ public class TestCompositeGrammars extends BaseTest {
 			"[@0,0:0='a',<5>,1:0]\n" +
 			"[@1,1:1='b',<3>,1:1]\n" +
 			"[@2,2:2='c',<6>,1:2]\n" +
-			"[@3,3:3='<EOF>',<-1>,1:3]\n";
+			"[@3,3:2='<EOF>',<-1>,1:3]\n";
 		String found = execLexer("M.g", master, "M", "abc", debug);
 		assertEquals(expecting, found);
 	}
@@ -422,7 +422,7 @@ public class TestCompositeGrammars extends BaseTest {
 		String found = execLexer("M.g", master, "M", "ab", debug);
 		assertEquals("M.A\n" +
 					 "[@0,0:1='ab',<3>,1:0]\n" +
-					 "[@1,2:2='<EOF>',<-1>,1:2]\n", found);
+					 "[@1,2:1='<EOF>',<-1>,1:2]\n", found);
 	}
 
 	@Test public void testKeywordVSIDOrder() throws Exception {

File: tool/test/org/antlr/v4/test/TestRewriteAST.java
Patch:
@@ -1019,7 +1019,7 @@ public class TestRewriteAST extends BaseTest {
 			"options { output = AST; }\n" +
 			"tokens { FLOAT; }\n" +
 			"a\n" +
-			"    : INT -> {new CommonAST(new CommonAST(FLOAT,$INT.text+\".0\"))} \n" +
+			"    : INT -> {new CommonAST(new CommonToken(FLOAT,$INT.text+\".0\"))} \n" +
 			"    ; \n" +
 			"INT : '0'..'9'+; \n" +
 			"WS: (' ' | '\\n' | '\\t')+ {$channel = HIDDEN;}; \n";
@@ -1335,7 +1335,7 @@ public class TestRewriteAST extends BaseTest {
 			"WS : (' '|'\\n') {$channel=HIDDEN;} ;\n";
 		String found = execParser("foo.g", grammar, "fooParser", "fooLexer",
 								  "decl", "x=1;", debug);
-		assertEquals("line 1:0 mismatched input 'x' expecting set {'int', 'float'}\n", this.stderrDuringParse);
+		assertEquals("line 1:0 mismatched input 'x' expecting {'int', 'float'}\n", this.stderrDuringParse);
 		assertEquals("(EXPR <error: x> x 1)\n", found); // tree gets invented ID token
 	}
 

File: tool/test/org/antlr/v4/test/TestSemPredEvalLexer.java
Patch:
@@ -15,7 +15,7 @@ public class TestSemPredEvalLexer extends BaseTest {
 		String expecting =
 			"[@0,0:3='enum',<4>,1:0]\n" +
 			"[@1,5:7='abc',<5>,1:5]\n" +
-			"[@2,8:8='<EOF>',<-1>,1:8]\n"; // no dfa since preds on left edge
+			"[@2,8:7='<EOF>',<-1>,1:8]\n"; // no dfa since preds on left edge
 		assertEquals(expecting, found);
 	}
 
@@ -31,7 +31,7 @@ public class TestSemPredEvalLexer extends BaseTest {
 			"[@0,0:3='enum',<4>,1:0]\n" +
 			"[@1,5:7='abc',<5>,1:5]\n" +
 			"[@2,9:12='enum',<4>,1:9]\n" +
-			"[@3,13:13='<EOF>',<-1>,1:13]\n" +
+			"[@3,13:12='<EOF>',<-1>,1:13]\n" +
 			"s0-' '->:s4=>6\n" +
 			"s0-'a'->:s5=>5\n" +
 			"s0-'e'->:s1=>5\n" +

File: tool/test/org/antlr/v4/test/TestSymbolIssues.java
Patch:
@@ -20,9 +20,9 @@ public class TestSymbolIssues extends BaseTest {
         "\n" +
         "ID : 'a'..'z'+ ID ;",
         // YIELDS
-        "warning(50): A.g:2:10: illegal option opt\n" +
+        "warning(51): A.g:2:10: illegal option opt\n" +
 		"error(60): A.g:7:1: redefinition of header action\n" +
-		"warning(50): A.g:2:10: illegal option opt\n" +
+		"warning(51): A.g:2:10: illegal option opt\n" +
 		"error(19): A.g:11:0: rule a redefinition\n" +
 		"error(60): A.g:5:1: redefinition of members action\n" +
 		"error(47): A.g:9:37: rule b has no defined parameters\n" +
@@ -77,7 +77,7 @@ public class TestSymbolIssues extends BaseTest {
 
         // YIELDS
         "error(39): D.g:3:21: label j conflicts with rule a's return value or parameter with same name\n" +
-		"error(43): D.g:5:0: rule b's argument i conflicts a return value with same nameK\n"
+		"error(43): D.g:5:0: rule b's argument i conflicts a return value with same name\n"
     };
 
 	static String[] E = {

File: runtime/Java/src/org/antlr/v4/runtime/FailedPredicateException.java
Patch:
@@ -42,20 +42,20 @@ public class FailedPredicateException extends RecognitionException {
 	public int predIndex;
 	public String msg;
 
-	public FailedPredicateException(BaseRecognizer recognizer) {
+	public FailedPredicateException(BaseRecognizer<?> recognizer) {
 		this(recognizer, null);
 	}
 
-	public FailedPredicateException(BaseRecognizer recognizer, @Nullable String msg) {
+	public FailedPredicateException(BaseRecognizer<?> recognizer, @Nullable String msg) {
 		super(recognizer, recognizer.getInputStream(), recognizer._ctx);
 		ATNState s = recognizer._interp.atn.states.get(recognizer._ctx.s);
 		PredicateTransition trans = (PredicateTransition)s.transition(0);
 		ruleIndex = trans.ruleIndex;
 		predIndex = trans.predIndex;
 		this.msg = msg;
 		Object la = recognizer.getCurrentInputSymbol();
+		this.offendingNode = la;
 		if ( la instanceof AST) {
-			this.offendingNode = la;
 			this.offendingToken = ((AST)la).getPayload();
 		}
 		else {

File: runtime/Java/src/org/antlr/v4/runtime/InputMismatchException.java
Patch:
@@ -6,11 +6,11 @@
  *  when the current input does not match the expected token or tree node.
  */
 public class InputMismatchException extends RecognitionException {
-	public InputMismatchException(BaseRecognizer recognizer) {
+	public InputMismatchException(BaseRecognizer<?> recognizer) {
 		super(recognizer, recognizer.getInputStream(), recognizer._ctx);
 		Object la = recognizer.getCurrentInputSymbol();
+		this.offendingNode = la;
 		if ( la instanceof AST ) {
-			this.offendingNode = la;
 			this.offendingToken = ((AST)la).getPayload();
 		}
 		else {

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java
Patch:
@@ -142,7 +142,7 @@ public String toString() {
 		return toString(null, true);
 	}
 
-	public String toString(Recognizer<?> recog, boolean showAlt) {
+	public String toString(Recognizer<?, ?> recog, boolean showAlt) {
 		StringBuilder buf = new StringBuilder();
 //		if ( state.ruleIndex>=0 ) {
 //			if ( recog!=null ) buf.append(recog.getRuleNames()[state.ruleIndex]+":");

File: runtime/Java/src/org/antlr/v4/runtime/tree/BaseAST.java
Patch:
@@ -258,18 +258,18 @@ public void freshenParentAndChildIndexesDeeply(int offset) {
      */
     public List<? extends Tree> getAncestors() { return Trees.getAncestors(this); }
 
-	public void inspect(BaseRecognizer parser) {
+	public void inspect(BaseRecognizer<?> parser) {
 		TreeViewer viewer = new TreeViewer(parser, this);
 		viewer.open();
 	}
 
-	public void save(BaseRecognizer parser, String fileName)
+	public void save(BaseRecognizer<?> parser, String fileName)
 		throws IOException
 	{
 		Trees.writePS(this, parser, fileName);
 	}
 
-	public void save(BaseRecognizer parser, String fileName,
+	public void save(BaseRecognizer<?> parser, String fileName,
 					 String fontName, int fontSize)
 		throws IOException
 	{

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeListener.java
Patch:
@@ -32,8 +32,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.Token;
 
-public interface ParseTreeListener {
+public interface ParseTreeListener<TSymbol> {
     void visitToken(Token token);
-    void enterEveryRule(ParserRuleContext ctx);
-    void exitEveryRule(ParserRuleContext ctx);
+    void enterEveryRule(ParserRuleContext<TSymbol> ctx);
+    void exitEveryRule(ParserRuleContext<TSymbol> ctx);
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreePostScriptGenerator.java
Patch:
@@ -68,11 +68,11 @@ public double getHeight(Tree tree) {
 
 	protected PostScriptDocument doc;
 
-	public TreePostScriptGenerator(BaseRecognizer parser, Tree root) {
+	public TreePostScriptGenerator(BaseRecognizer<?> parser, Tree root) {
 		this(parser, root, "CourierNew", 11);
 	}
 
-	public TreePostScriptGenerator(BaseRecognizer parser, Tree root,
+	public TreePostScriptGenerator(BaseRecognizer<?> parser, Tree root,
 								   String fontName, int fontSize)
 	{
 		this.root = root;

File: runtime/Java/src/org/antlr/v4/runtime/atn/LL1Analyzer.java
Patch:
@@ -99,6 +99,9 @@ else if ( t.getClass() == WildcardTransition.class ) {
 			else {
 //				System.out.println("adding "+ t);
 				IntervalSet set = t.label();
+				if (t instanceof NotSetTransition) {
+					set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, atn.maxTokenType));
+				}
 				look.addAll(set);
 			}
 		}

File: tool/src/org/antlr/v4/semantics/AttributeChecks.java
Patch:
@@ -150,8 +150,8 @@ public void attr(String expr, Token x) {
 				return; // $ids for ids+=ID etc...
 			}
 			if ( isolatedRuleRef(x.getText())!=null ) {
-//				errMgr.grammarError(ErrorType.ISOLATED_RULE_REF,
-//									g.fileName, x, x.getText(), expr);
+				errMgr.grammarError(ErrorType.ISOLATED_RULE_REF,
+									g.fileName, x, x.getText(), expr);
 				return;
 			}
 			errMgr.grammarError(ErrorType.UNKNOWN_SIMPLE_ATTRIBUTE,

File: tool/src/org/antlr/v4/codegen/model/RuleElement.java
Patch:
@@ -38,7 +38,7 @@ public class RuleElement extends SrcOp {
 
 	public RuleElement(OutputModelFactory factory, GrammarAST ast) {
 		super(factory, ast);
-		if ( ast.atnState!=null ) stateNumber = ast.atnState.stateNumber;
+		if ( ast != null && ast.atnState!=null ) stateNumber = ast.atnState.stateNumber;
 	}
 
 }

File: runtime/Java/src/org/antlr/v4/runtime/TokenStream.java
Patch:
@@ -30,13 +30,14 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime;
 
 /** A stream of tokens accessing tokens from a TokenSource */
-public interface TokenStream extends ObjectStream {
+public interface TokenStream extends ObjectStream<Token> {
     /** Get Token at current input pointer + i ahead where i=1 is next Token.
 	 *  i<0 indicates tokens in the past.  So -1 is previous token and -2 is
 	 *  two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
 	 *  Return null for LT(0) and any index that results in an absolute address
 	 *  that is negative.
 	 */
+    @Override
     public Token LT(int k);
 
 	/** How far ahead has the stream been asked to look?  The return
@@ -51,6 +52,7 @@ public interface TokenStream extends ObjectStream {
 	 *  I believe DebugTokenStream can easily be altered to not use
 	 *  this method, removing the dependency.
 	 */
+	@Override
 	public Token get(int i);
 
 	/** Where is this stream pulling tokens from?  This is not the name, but

File: runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeWalker.java
Patch:
@@ -32,6 +32,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.ParserRuleContext;
 
 public class ParseTreeWalker {
+    public static final ParseTreeWalker DEFAULT = new ParseTreeWalker();
+
     public void walk(ParseTreeListener listener, ParseTree t) {
 		if ( t instanceof ParseTree.TokenNode) {
 			visitToken(listener, (ParseTree.TokenNode) t);

File: tool/src/org/antlr/v4/tool/ast/GrammarAST.java
Patch:
@@ -95,7 +95,7 @@ public List<GrammarAST> getNodesWithType(IntervalSet types) {
 		while ( work.size()>0 ) {
 			t = work.remove(0);
 			if ( types.contains(t.getType()) ) nodes.add(t);
-			if ( t.children!=null ) work.addAll(t.children);
+			if ( t.children!=null ) work.addAll((Collection)t.children);
 		}
 		return nodes;
 	}

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -771,7 +771,7 @@ protected DFAState addDFAEdge(DFA dfa,
 	}
 
 	protected void addDFAEdge(DFAState p, int t, DFAState q) {
-		if ( p==null ) return;
+		if ( p==null || t < -1 ) return;
 		if ( p.edges==null ) {
 			p.edges = new DFAState[atn.maxTokenType+1+1]; // TODO: make adaptive
 		}

File: runtime/Java/src/org/antlr/v4/runtime/Token.java
Patch:
@@ -84,6 +84,9 @@ public interface Token {
 	/** An index from 0..n-1 of the token object in the input stream.
 	 *  This must be valid in order to print token streams,
 	 *  use TokenRewriteStream, and generally deal with ASTs.
+	 *
+	 *  Return -1 to indicate that this token was conjured up since
+	 *  it doesn't have a valid index.
 	 */
 	int getTokenIndex();
 

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -184,7 +184,7 @@ public int execDFA(ObjectStream input, DFA dfa, DFAState s0, RuleContext outerCo
 				if ( s.complete || t==CharStream.EOF ) break;
 			}
 			// if no edge, pop over to ATN interpreter, update DFA and return
-			if ( s.edges == null || t >= s.edges.length || s.edges[t+1] == null ) {
+			if ( s.edges == null || t >= s.edges.length || t < -1 || s.edges[t+1] == null ) {
 				if ( dfa_debug ) System.out.println("no edge for "+t);
 				int alt = -1;
 				if ( dfa_debug ) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/Arial.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 package org.antlr.v4.runtime.tree.gui;
 
-public class Arial extends FontMetrics {
+public class Arial extends BasicFontMetrics {
 	{
 		maxCharHeight = 781;
         widths[32] = 277; // space

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/ArialBlack.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 package org.antlr.v4.runtime.tree.gui;
 
-public class ArialBlack extends FontMetrics {
+public class ArialBlack extends BasicFontMetrics {
     {
 		maxCharHeight = 770;
         widths[32] = 333; // space

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/BasicFontMetrics.java
Patch:
@@ -67,7 +67,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
  	Units are 1000th of an 'em'.
  */
-public abstract class FontMetrics {
+public abstract class BasicFontMetrics {
 	protected int maxCharHeight;
 	protected int[] widths = new int[128];
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/CourierNew.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 package org.antlr.v4.runtime.tree.gui;
 
-public class CourierNew extends FontMetrics {
+public class CourierNew extends BasicFontMetrics {
 	{
 		maxCharHeight = 678;
 		for (int i=0; i<128; i++) widths[i] = 600;

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/PostScriptDocument.java
Patch:
@@ -33,7 +33,7 @@ public class PostScriptDocument {
 	protected int boundingBoxWidth;
 	protected int boundingBoxHeight;
 
-	protected FontMetrics fontMetrics;
+	protected BasicFontMetrics fontMetrics;
 	protected String fontName;
 	protected int fontSize = 12;
 	protected double lineWidth = 0.3;
@@ -98,7 +98,7 @@ public void setFont(String fontName, int fontSize) {
 		this.fontSize = fontSize;
 		try {
 			Class c = Class.forName("org.antlr.v4.runtime.tree.gui." + fontName);
-			this.fontMetrics = (FontMetrics)c.newInstance();
+			this.fontMetrics = (BasicFontMetrics)c.newInstance();
 		}
 		catch (Exception e) {
 			throw new UnsupportedOperationException("No font metrics for "+fontName);

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TimesNewRoman.java
Patch:
@@ -29,7 +29,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 package org.antlr.v4.runtime.tree.gui;
 
-public class TimesNewRoman extends FontMetrics {
+public class TimesNewRoman extends BasicFontMetrics {
     {
 		maxCharHeight = 717;
         widths[32] = 250; // space

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreePostScriptGenerator.java
Patch:
@@ -163,7 +163,7 @@ public static void main(String[] args) {
 		t.addChild(b);
 		b.addChild(c);
 		b.addChild(d);
-		TreePostScriptGenerator psgen = new TreePostScriptGenerator(null, t, "TimesNewRoman", 11);
+		TreePostScriptGenerator psgen = new TreePostScriptGenerator(null, t, "CourierNew", 11);
 		System.out.println(psgen.getPS());
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/BaseRecognizer.java
Patch:
@@ -277,6 +277,7 @@ public List toStrings(List tokens) {
 	 *  configuration information.
 	 */
 	public void setState(int atnState) {
+//		System.err.println("setState "+atnState);
 		_ctx.s = atnState;
 		if ( traceATNStates ) _ctx.trace(atnState);
 	}

File: tool/src/org/antlr/v4/codegen/model/LL1PlusBlock.java
Patch:
@@ -56,6 +56,7 @@ public LL1PlusBlock(OutputModelFactory factory, GrammarAST plusRoot, List<CodeBl
 		PlusBlockStartState blkStart = (PlusBlockStartState)plusRoot.atnState;
 
 		stateNumber = blkStart.loopBackState.stateNumber;
+		blockStartStateNumber = blkStart.stateNumber;
 
 		this.decision = blkStart.decision;
 		Grammar g = factory.getGrammar();

File: tool/src/org/antlr/v4/codegen/model/LL1PlusBlockSingleAlt.java
Patch:
@@ -43,6 +43,7 @@ public LL1PlusBlockSingleAlt(OutputModelFactory factory, GrammarAST blkAST, List
 
 		PlusBlockStartState blkStart = (PlusBlockStartState)blkAST.atnState;
 		stateNumber = blkStart.loopBackState.stateNumber;
+		blockStartStateNumber = blkStart.stateNumber;
 		PlusBlockStartState plus = (PlusBlockStartState)blkAST.atnState;
 		this.decision = plus.loopBackState.decision;
 		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);

File: tool/src/org/antlr/v4/codegen/model/LL1PlusBlockSingleAlt.java
Patch:
@@ -41,6 +41,8 @@ public class LL1PlusBlockSingleAlt extends LL1Loop {
 	public LL1PlusBlockSingleAlt(OutputModelFactory factory, GrammarAST blkAST, List<CodeBlockForAlt> alts) {
 		super(factory, blkAST, alts);
 
+		PlusBlockStartState blkStart = (PlusBlockStartState)blkAST.atnState;
+		stateNumber = blkStart.loopBackState.stateNumber;
 		PlusBlockStartState plus = (PlusBlockStartState)blkAST.atnState;
 		this.decision = plus.loopBackState.decision;
 		IntervalSet[] altLookSets = factory.getGrammar().decisionLOOK.get(decision);

File: tool/src/org/antlr/v4/codegen/model/PlusBlock.java
Patch:
@@ -30,7 +30,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.codegen.model;
 
 import org.antlr.v4.codegen.OutputModelFactory;
-import org.antlr.v4.runtime.atn.*;
+import org.antlr.v4.runtime.atn.PlusBlockStartState;
+import org.antlr.v4.runtime.atn.PlusLoopbackState;
 import org.antlr.v4.tool.GrammarAST;
 
 import java.util.List;
@@ -44,6 +45,7 @@ public PlusBlock(OutputModelFactory factory,
 	{
 		super(factory, ebnfRootAST, alts);
 		PlusLoopbackState loop = ((PlusBlockStartState)ebnfRootAST.atnState).loopBackState;
+		stateNumber = loop.stateNumber;
 		this.error = new ThrowNoViableAlt(factory, ebnfRootAST, null);
 		decision = loop.decision;
 		exitAlt = alts.size()+1;

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -29,7 +29,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime;
 
 
-import org.antlr.v4.runtime.tree.*;
+import org.antlr.v4.runtime.tree.ASTAdaptor;
+import org.antlr.v4.runtime.tree.CommonASTAdaptor;
 
 /** A parser for TokenStreams.  "parser grammars" result in a subclass
  *  of this.
@@ -57,6 +58,7 @@ public void reset() {
 	 *  This is flexible because users do not have to regenerate parsers
 	 *  to get trace facilities.
 	 */
+	@Override
 	public void enterRule(ParserRuleContext localctx, int ruleIndex) {
 		_ctx = localctx;
 		_ctx.start = _input.LT(1);

File: runtime/Java/src/org/antlr/v4/runtime/TreeParserRuleContext.java
Patch:
@@ -3,6 +3,7 @@
 import org.stringtemplate.v4.ST;
 
 public class TreeParserRuleContext extends ParserRuleContext {
+	// TODO: heh, these are duplicates of the fields above!
 	public Object start, stop;
 	public Object tree;
 	public ST st;

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorStrategy.java
Patch:
@@ -81,9 +81,9 @@ Object recoverInline(BaseRecognizer recognizer)
 	 */
 	void sync(BaseRecognizer recognizer);
 
-	/** Reset the error handler. The parser invokes this
-	 *  when it matches a valid token (indicating no longer in recovery mode)
+	/** Reset the error handler. Call this when the parser
+	 *  matches a valid token (indicating no longer in recovery mode)
 	 *  and from its own reset method.
 	 */
-	void endErrorCondition();
+	void endErrorCondition(BaseRecognizer recognizer);
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/TreeParser.java
Patch:
@@ -97,7 +97,7 @@ protected Object getMissingSymbol(IntStream input,
 	{
 		String tokenText =
 			"<missing "+getTokenNames()[expectedTokenType]+">";
-        ASTAdaptor adaptor = ((ASTNodeStream)e.input).getTreeAdaptor();
+        ASTAdaptor adaptor = ((ASTNodeStream)e.getInputStream()).getTreeAdaptor();
         return adaptor.create(new CommonToken(expectedTokenType, tokenText));
 	}
 

File: tool/test/org/antlr/v4/test/TestParseErrors.java
Patch:
@@ -38,8 +38,7 @@ public class TestParseErrors extends BaseTest {
 			"a : 'a' 'b'" +
 			"  | 'a' 'c'" +
 			";\n" +
-			"q : 'e' ;\n" +
-			"WS : ' ' ;\n";
+			"q : 'e' ;\n";
 		String found = execParser("T.g", grammar, "TParser", "TLexer", "a", "ae", false);
 		String expecting = "line 1:1 no viable alternative at input 'e'\n";
 		String result = stderrDuringParse;

File: runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java
Patch:
@@ -65,7 +65,7 @@ public class BufferedTokenStream implements TokenStream {
      */
     protected int p = -1;
 
-	protected int range = -1; // how deep have we gone?
+//	protected int range = -1; // how deep have we gone?
 
     public BufferedTokenStream() {;}
 
@@ -77,7 +77,7 @@ public BufferedTokenStream(TokenSource tokenSource) {
 
 	public int index() { return p; }
 
-	public int range() { return range; }
+//	public int range() { return range; }
 
     public int mark() {
         if ( p == -1 ) setup();
@@ -176,7 +176,7 @@ public Token LT(int k) {
             // EOF must be last token
             return tokens.get(tokens.size()-1);
         }
-		if ( i>range ) range = i;
+//		if ( i>range ) range = i;
         return tokens.get(i);
     }
 

File: runtime/Java/src/org/antlr/v4/runtime/CommonTokenStream.java
Patch:
@@ -100,7 +100,7 @@ public Token LT(int k) {
             i = skipOffTokenChannels(i+1);
             n++;
         }
-		if ( i>range ) range = i;
+//		if ( i>range ) range = i;
         return tokens.get(i);
     }
 

File: runtime/Java/src/org/antlr/v4/runtime/TokenStream.java
Patch:
@@ -42,7 +42,7 @@ public interface TokenStream extends IntStream {
 	/** How far ahead has the stream been asked to look?  The return
 	 *  value is a valid index from 0..n-1.
 	 */
-	int range();
+//	int range();
 
 	/** Get a token at an absolute index i; 0..n-1.  This is really only
 	 *  needed for profiling and debugging and token stream rewriting.

File: runtime/Java/src/org/antlr/v4/runtime/UnwantedTokenException.java
Patch:
@@ -38,14 +38,14 @@ public UnwantedTokenException(BaseRecognizer recognizer, IntStream input, int ex
 	}
 
 	public Token getUnexpectedToken() {
-		return token;
+		return offendingToken;
 	}
 
 	public String toString() {
 		String exp = ", expected "+expecting;
-		if ( token==null ) {
+		if ( offendingToken ==null ) {
 			return "UnwantedTokenException(found="+null+exp+")";
 		}
-		return "UnwantedTokenException(found="+token.getText()+exp+")";
+		return "UnwantedTokenException(found="+ offendingToken.getText()+exp+")";
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/tree/CommonErrorNode.java
Patch:
@@ -99,10 +99,10 @@ else if ( trappedException instanceof UnwantedTokenException ) {
 				   ", resync="+getText()+">";
 		}
 		else if ( trappedException instanceof MismatchedTokenException ) {
-			return "<mismatched token: "+trappedException.token+", resync="+getText()+">";
+			return "<mismatched token: "+trappedException.offendingToken +", resync="+getText()+">";
 		}
 		else if ( trappedException instanceof NoViableAltException ) {
-			return "<unexpected: "+trappedException.token+
+			return "<unexpected: "+trappedException.offendingToken +
 				   ", resync="+getText()+">";
 		}
 		return "<error: "+getText()+">";

File: runtime/Java/src/org/antlr/v4/runtime/Recognizer.java
Patch:
@@ -91,7 +91,7 @@ public String getErrorMessage(RecognitionException e) {
 		if ( e instanceof UnwantedTokenException ) {
 			UnwantedTokenException ute = (UnwantedTokenException)e;
 			String tokenName="<unknown>";
-			if ( ute.expecting.member(Token.EOF) ) {
+			if ( ute.expecting.contains(Token.EOF) ) {
 				tokenName = "EOF";
 			}
 			else {
@@ -103,7 +103,7 @@ public String getErrorMessage(RecognitionException e) {
 		else if ( e instanceof MissingTokenException ) {
 			MissingTokenException mte = (MissingTokenException)e;
 			String tokenName="<unknown>";
-			if ( mte.expecting.member(Token.EOF) ) {
+			if ( mte.expecting.contains(Token.EOF) ) {
 				tokenName = "EOF";
 			}
 			else {
@@ -126,7 +126,7 @@ else if ( e instanceof MismatchedTokenException ) {
 		else if ( e instanceof MismatchedASTNodeException) {
 			MismatchedASTNodeException mtne = (MismatchedASTNodeException)e;
 			String tokenName="<unknown>";
-			if ( mtne.expecting.member(Token.EOF) ) {
+			if ( mtne.expecting.contains(Token.EOF) ) {
 				tokenName = "EOF";
 			}
 			else {

File: runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java
Patch:
@@ -291,7 +291,7 @@ else if ( trans.getClass() == RangeTransition.class ) {
 		else if ( trans instanceof SetTransition ) {
 			SetTransition st = (SetTransition)trans;
 			boolean not = trans instanceof NotSetTransition;
-			if ( !not && st.set.member(t) || not && !st.set.member(t) ) {
+			if ( !not && st.set.contains(t) || not && !st.set.contains(t) ) {
 //				if ( st.set.toString().equals("0") ) {
 //					System.out.println("eh?");
 //				}

File: runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java
Patch:
@@ -485,7 +485,7 @@ public ATNState getReachableTarget(Transition trans, int ttype) {
 		else if ( trans instanceof SetTransition ) {
 			SetTransition st = (SetTransition)trans;
 			boolean not = trans instanceof NotSetTransition;
-			if ( !not && st.set.member(ttype) || not && !st.set.member(ttype) ) {
+			if ( !not && st.set.contains(ttype) || not && !st.set.contains(ttype) ) {
 				return st.target;
 			}
 		}

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntSet.java
Patch:
@@ -70,7 +70,7 @@ public interface IntSet {
 
     int getSingleElement();
 
-    boolean member(int el);
+    boolean contains(int el);
 
     /** remove this element from this set */
     void remove(int el);

File: runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java
Patch:
@@ -318,7 +318,7 @@ else if ( theirs.startsAfterNonDisjoint(mine) ) {
 	}
 
     /** Is el in any range of this set? */
-    public boolean member(int el) {
+    public boolean contains(int el) {
 		int n = intervals.size();
 		for (int i = 0; i < n; i++) {
 			Interval I = (Interval) intervals.get(i);

File: tool/src/org/antlr/v4/tool/GrammarAST.java
Patch:
@@ -88,7 +88,7 @@ public List<GrammarAST> getNodesWithType(IntervalSet types) {
 		GrammarAST t = null;
 		while ( work.size()>0 ) {
 			t = work.remove(0);
-			if ( types.member(t.getType()) ) nodes.add(t);
+			if ( types.contains(t.getType()) ) nodes.add(t);
 			if ( t.children!=null ) work.addAll(t.children);
 		}
 		return nodes;

File: runtime/Java/src/org/antlr/v4/runtime/ANTLRParserListener.java
Patch:
@@ -31,5 +31,5 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 /** */
 public interface ANTLRParserListener {
-	public void error(RecognitionException msg);
+	public void error(int line, int charPositionInLine, String msg);
 }

File: runtime/Java/src/org/antlr/v4/runtime/NoViableAltException.java
Patch:
@@ -41,8 +41,8 @@ public class NoViableAltException extends RecognitionException {
 	/** Used for remote debugger deserialization */
 	public NoViableAltException() {;}
 
-	public NoViableAltException(BaseRecognizer recognizer, RuleContext ctx) { // LL(1) error
-		super(recognizer, recognizer.getInputStream(), ctx);
+	public NoViableAltException(BaseRecognizer recognizer) { // LL(1) error
+		super(recognizer, recognizer.getInputStream(), recognizer._ctx);
 	}
 
 	public NoViableAltException(BaseRecognizer recognizer, IntStream input,

File: tool/src/org/antlr/v4/codegen/model/AltBlock.java
Patch:
@@ -36,14 +36,15 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import java.util.List;
 
 public class AltBlock extends Choice {
-	@ModelElement public ThrowNoViableAlt error;
+//	@ModelElement public ThrowNoViableAlt error;
 
 	public AltBlock(OutputModelFactory factory,
 					GrammarAST blkOrEbnfRootAST,
 					List<CodeBlockForAlt> alts)
 	{
 		super(factory, blkOrEbnfRootAST, alts);
 		decision = ((BlockStartState)blkOrEbnfRootAST.atnState).decision;
-		this.error = new ThrowNoViableAlt(factory, blkOrEbnfRootAST, null);
+		// interp.predict() throws exception
+//		this.error = new ThrowNoViableAlt(factory, blkOrEbnfRootAST, null);
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/ATNState.java
Patch:
@@ -124,7 +124,7 @@ public void setTransition(int i, Transition e) {
 	}
 
 	public boolean onlyHasEpsilonTransitions() {
-		if ( transitions==null ) return false;
+		if ( transitions.size()==0 ) return false;
 		for (Transition t : transitions) {
 			if ( !t.isEpsilon() ) return false;
 		}

File: tool/test/org/antlr/v4/test/TestASTStructure.java
Patch:
@@ -113,7 +113,7 @@ public class TestASTStructure extends org.antlr.v4.gunit.gUnitBase {
 		// gunit test on line 127
 		RuleReturnScope rstruct = (RuleReturnScope)execParser("block", "( ^(A B) | ^(b C) )", 127);
 		Object actual = ((Tree)rstruct.getTree()).toStringTree();
-		Object expecting = "(BLOCK (ALT (^( A B)) (ALT (^( b C)))";
+		Object expecting = "(BLOCK (ALT (^( A DOWN B UP)) (ALT (^( b DOWN C UP)))";
 		assertEquals("testing rule block", expecting, actual);
 	} @Test public void test_ebnf1() throws Exception {
 		// gunit test on line 130

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -36,7 +36,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 public class Parser extends BaseRecognizer {
 
-	public TreeAdaptor _adaptor = new CommonTreeAdaptor();
+	public ASTAdaptor _adaptor = new CommonASTAdaptor();
 
 	public Parser(TokenStream input) {
 		super(input);

File: runtime/Java/src/org/antlr/v4/runtime/RecognitionException.java
Patch:
@@ -187,7 +187,7 @@ public int getUnexpectedType() {
 		}
 		else if ( recognizer._input instanceof TreeNodeStream) {
 			TreeNodeStream nodes = (TreeNodeStream)recognizer._input;
-			TreeAdaptor adaptor = nodes.getTreeAdaptor();
+			ASTAdaptor adaptor = nodes.getTreeAdaptor();
 			return adaptor.getType(node);
 		}
 		else {

File: runtime/Java/src/org/antlr/v4/runtime/debug/DebugTreeNodeStream.java
Patch:
@@ -36,7 +36,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 public class DebugTreeNodeStream implements TreeNodeStream {
 	protected DebugEventListener dbg;
-	protected TreeAdaptor adaptor;
+	protected ASTAdaptor adaptor;
 	protected TreeNodeStream input;
 	protected boolean initialStreamState = true;
 
@@ -56,7 +56,7 @@ public void setDebugListener(DebugEventListener dbg) {
 		this.dbg = dbg;
 	}
 
-	public TreeAdaptor getTreeAdaptor() {
+	public ASTAdaptor getTreeAdaptor() {
 		return adaptor;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/debug/TraceDebugEventListener.java
Patch:
@@ -28,13 +28,13 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.runtime.debug;
 
 import org.antlr.v4.runtime.Token;
-import org.antlr.v4.runtime.tree.TreeAdaptor;
+import org.antlr.v4.runtime.tree.ASTAdaptor;
 
 /** Print out (most of) the events... Useful for debugging, testing... */
 public class TraceDebugEventListener extends BlankDebugEventListener {
-	TreeAdaptor adaptor;
+	ASTAdaptor adaptor;
 
-	public TraceDebugEventListener(TreeAdaptor adaptor) {
+	public TraceDebugEventListener(ASTAdaptor adaptor) {
 		this.adaptor = adaptor;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/misc/Interval.java
Patch:
@@ -32,6 +32,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public class Interval {
 	public static final int INTERVAL_POOL_MAX_VALUE = 1000;
 
+	public static final Interval ZeroLength = new Interval(0,-1);
+
 	static Interval[] cache = new Interval[INTERVAL_POOL_MAX_VALUE+1];
 
 	public int a;

File: runtime/Java/src/org/antlr/v4/runtime/tree/CommonErrorNode.java
Patch:
@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.runtime.*;
 
 /** A node representing erroneous token range in token stream */
-public class CommonErrorNode extends CommonTree {
+public class CommonErrorNode extends CommonAST {
 	public IntStream input;
 	public Token start;
 	public Token stop;

File: runtime/Java/src/org/antlr/v4/runtime/tree/ElementList.java
Patch:
@@ -33,7 +33,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 /** This list tracks elements to left of -> for use on right of -> */
 public class ElementList<E> extends ArrayList<E> {
-	protected TreeAdaptor adaptor;
+	protected ASTAdaptor adaptor;
 
 	/** Once a node / subtree has been used in a stream, it must be dup'd
 	 *  from then on.
@@ -76,7 +76,7 @@ public E next() {
 		public void remove() { throw new UnsupportedOperationException(); }
 	}
 
-	public ElementList(TreeAdaptor adaptor) {
+	public ElementList(ASTAdaptor adaptor) {
 		this.adaptor = adaptor;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/TreeIterator.java
Patch:
@@ -40,7 +40,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *  Emit navigation nodes (DOWN, UP, and EOF) to let show tree structure.
  */
 public class TreeIterator implements Iterator {
-    protected TreeAdaptor adaptor;
+    protected ASTAdaptor adaptor;
     protected Object root;
     protected Object tree;
     protected boolean firstTime = true;
@@ -56,10 +56,10 @@ public class TreeIterator implements Iterator {
     protected FastQueue nodes;
 
     public TreeIterator(Object tree) {
-        this(new CommonTreeAdaptor(),tree);
+        this(new CommonASTAdaptor(),tree);
     }
 
-    public TreeIterator(TreeAdaptor adaptor, Object tree) {
+    public TreeIterator(ASTAdaptor adaptor, Object tree) {
         this.adaptor = adaptor;
         this.tree = tree;
         this.root = tree;

File: runtime/Java/src/org/antlr/v4/runtime/tree/TreeNodeStream.java
Patch:
@@ -67,7 +67,7 @@ public interface TreeNodeStream extends IntStream {
 	/** What adaptor can tell me how to interpret/navigate nodes and
 	 *  trees.  E.g., get text of a node.
 	 */
-	public TreeAdaptor getTreeAdaptor();
+	public ASTAdaptor getTreeAdaptor();
 
 	/** As we flatten the tree, we use UP, DOWN nodes to represent
 	 *  the tree structure.  When debugging we need unique nodes

File: runtime/Java/src/org/antlr/v4/runtime/tree/TreeVisitor.java
Patch:
@@ -33,12 +33,12 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *  as we discover and finish nodes.
  */
 public class TreeVisitor {
-    protected TreeAdaptor adaptor;
+    protected ASTAdaptor adaptor;
 
-    public TreeVisitor(TreeAdaptor adaptor) {
+    public TreeVisitor(ASTAdaptor adaptor) {
         this.adaptor = adaptor;
     }
-    public TreeVisitor() { this(new CommonTreeAdaptor()); }
+    public TreeVisitor() { this(new CommonASTAdaptor()); }
 
     /** Visit every node in tree t and trigger an action for each node
      *  before/after having visited all of its children.

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/ASTViewer.java
Patch:
@@ -33,16 +33,16 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 
 /** */
 public class ASTViewer {
-    TreeAdaptor adaptor;
+    ASTAdaptor adaptor;
     Object root;
 
-    public ASTViewer(TreeAdaptor adaptor, Object root) {
+    public ASTViewer(ASTAdaptor adaptor, Object root) {
         this.adaptor = adaptor;
         this.root = root;
     }
 
     public ASTViewer(Object root) {
-        this.adaptor = new CommonTreeAdaptor();
+        this.adaptor = new CommonASTAdaptor();
         this.root = root;
     }
 

File: runtime/Java/src/org/antlr/v4/runtime/tree/gui/JTreeASTModel.java
Patch:
@@ -35,16 +35,16 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import javax.swing.tree.*;
 
 public class JTreeASTModel implements TreeModel {
-    TreeAdaptor adaptor;
+    ASTAdaptor adaptor;
     Object root;
 
-    public JTreeASTModel(TreeAdaptor adaptor, Object root) {
+    public JTreeASTModel(ASTAdaptor adaptor, Object root) {
         this.adaptor = adaptor;
         this.root = root;
     }
 
     public JTreeASTModel(Object root) {
-        this.adaptor = new CommonTreeAdaptor();
+        this.adaptor = new CommonASTAdaptor();
         this.root = root;
     }
 

File: tool/src/org/antlr/v4/codegen/model/ParserFile.java
Patch:
@@ -48,7 +48,7 @@ public ParserFile(OutputModelFactory factory, String fileName) {
 		this.fileName = fileName;
 		Grammar g = factory.getGrammar();
 		TokenLabelType = g.getOption("TokenLabelType");
-		ASTLabelType = g.getOption("ASTLabelType", "CommonTree");
+		ASTLabelType = g.getOption("ASTLabelType", "CommonAST");
 		namedActions = new HashMap<String, Action>();
 		for (String name : g.namedActions.keySet()) {
 			GrammarAST ast = g.namedActions.get(name);

File: tool/test/org/antlr/v4/test/TestASTOps.java
Patch:
@@ -607,7 +607,7 @@ public void testSetRootWithLabel() throws Exception {
 			"grammar T;\n" +
 			"options {output=AST;}\n" +
 			"a : ( x+=b^ )+ {" +
-			"System.out.print(\"x=\"+((CommonTree)$x.get(1).tree).toStringTree()+';');} ;\n" +
+			"System.out.print(\"x=\"+((CommonAST)$x.get(1).tree).toStringTree()+';');} ;\n" +
 			"b : ID;\n" +
 			"ID : 'a'..'z'+ ;\n" +
 			"INT : '0'..'9'+;\n" +
@@ -622,7 +622,7 @@ public void testSetRootWithLabel() throws Exception {
 			"grammar T;\n" +
 			"options {output=AST;}\n" +
 			"a : x+=b! x+=b {" +
-			"System.out.print(\"1st x=\"+((CommonTree)$x.get(0).tree).toStringTree()+';');} ;\n" +
+			"System.out.print(\"1st x=\"+((CommonAST)$x.get(0).tree).toStringTree()+';');} ;\n" +
 			"b : ID;\n" +
 			"ID : 'a'..'z'+ ;\n" +
 			"INT : '0'..'9'+;\n" +

File: tool/test/org/antlr/v4/test/TestRewriteAST.java
Patch:
@@ -952,7 +952,7 @@ public class TestRewriteAST extends BaseTest {
 			"grammar T;\n" +
 			"options {output=AST;}\n" +
 			"tokens {BLOCK;}\n" +
-			"a : x+=b x+=b -> {new CommonTree()};\n"+
+			"a : x+=b x+=b -> {new CommonAST()};\n"+
 			"b : ID ;\n"+
 			"ID : 'a'..'z'+ ;\n" +
 			"WS : (' '|'\\n') {$channel=HIDDEN;} ;\n";
@@ -1006,7 +1006,7 @@ public class TestRewriteAST extends BaseTest {
 			"options { output = AST; }\n" +
 			"tokens { FLOAT; }\n" +
 			"a\n" +
-			"    : INT -> {new CommonTree(new CommonToken(FLOAT,$INT.text+\".0\"))} \n" +
+			"    : INT -> {new CommonTree(new CommonAST(FLOAT,$INT.text+\".0\"))} \n" +
 			"    ; \n" +
 			"INT : '0'..'9'+; \n" +
 			"WS: (' ' | '\\n' | '\\t')+ {$channel = HIDDEN;}; \n";

File: tool/playground/TestU.java
Patch:
@@ -34,7 +34,7 @@ public static void main(String[] args) throws Exception {
 		ULexer t = new ULexer(new ANTLRFileStream(args[0]));
 		CommonTokenStream tokens = new CommonTokenStream(t);
 		UParser p = new UParser(tokens);
-		ParserRuleContext ret = p.s();
+		ParserRuleContext ret = p.declarator();
 //		System.out.println(((Tree)ret.tree).toStringTree());
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/atn/ActionTransition.java
Patch:
@@ -32,6 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public class ActionTransition extends Transition {
 	public int ruleIndex;
 	public int actionIndex = -1;
+	public boolean isCtxDependent; // e.g., $i ref in action
 
 	public ActionTransition(ATNState target) {
 		super(target);

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredicateTransition.java
Patch:
@@ -38,7 +38,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public class PredicateTransition extends Transition {
 	public int ruleIndex;
 	public int predIndex;
-	public boolean isCtxDependent;
+	public boolean isCtxDependent;  // e.g., $i ref in pred
 
 	public PredicateTransition(ATNState target) {
 		super(target);

File: tool/src/org/antlr/v4/automata/ATNSerializer.java
Patch:
@@ -156,6 +156,7 @@ public List<Integer> serialize() {
 						ActionTransition at = (ActionTransition)t;
 						arg1 = at.ruleIndex;
 						arg2 = at.actionIndex;
+						if ( at.isCtxDependent ) edgeType = Transition.FORCED_DEPENDENT_ACTION;
 						break;
 					case Transition.SET :
 						arg1 = setIndex++;

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -241,6 +241,7 @@ public Handle action(ActionAST action) {
 		a.ruleIndex = currentRule.index;
 		if ( action.getType()==ANTLRParser.FORCED_ACTION ) {
 			a.actionIndex = g.actions.get(action);
+			a.isCtxDependent = UseDefAnalyzer.actionIsContextDependent(action);
 		}
 		left.transition = a;
 		action.atnState = left;

File: runtime/Java/src/org/antlr/v4/runtime/atn/PredicateTransition.java
Patch:
@@ -38,6 +38,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public class PredicateTransition extends Transition {
 	public int ruleIndex;
 	public int predIndex;
+	public boolean isCtxDependent;
 
 	public PredicateTransition(ATNState target) {
 		super(target);

File: tool/src/org/antlr/v4/automata/ATNSerializer.java
Patch:
@@ -143,6 +143,7 @@ public List<Integer> serialize() {
 						PredicateTransition pt = (PredicateTransition)t;
 						arg1 = pt.ruleIndex;
 						arg2 = pt.predIndex;
+						if ( pt.isCtxDependent ) edgeType = Transition.DEPENDENT_PREDICATE;
 						break;
 					case Transition.RANGE :
 						arg1 = ((RangeTransition)t).from;

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -36,6 +36,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.parse.*;
 import org.antlr.v4.runtime.atn.*;
 import org.antlr.v4.runtime.misc.IntervalSet;
+import org.antlr.v4.semantics.UseDefAnalyzer;
 import org.antlr.v4.tool.*;
 
 import java.lang.reflect.Constructor;
@@ -222,6 +223,7 @@ public Handle sempred(PredAST pred) {
 		PredicateTransition p = new PredicateTransition(right);
 		p.ruleIndex = currentRule.index;
 		p.predIndex = g.sempreds.get(pred);
+		p.isCtxDependent = UseDefAnalyzer.actionIsContextDependent(pred);
 		left.transition = p;
 		pred.atnState = left;
 		return new Handle(left, right);

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -125,8 +125,9 @@ public enum ErrorType {
 	NO_SUCH_RULE_IN_SCOPE("rule <arg2> is not defined in grammar <arg>", ErrorSeverity.ERROR),
 	TOKEN_STRING_REASSIGNMENT("cannot alias <arg>; string already assigned to <arg2>", ErrorSeverity.ERROR),
 	TOKEN_NAME_REASSIGNMENT("cannot redefine <arg>; token name already <if(arg2)>assigned to <arg2><else>defined<endif>", ErrorSeverity.ERROR),
-	TOKEN_VOCAB_IN_DELEGATE("tokenVocab option ignored in imported grammar <arg>", ErrorSeverity.ERROR),
-	TOKEN_ALIAS_IN_DELEGATE("can't assign string to token name <arg> to string in imported grammar <arg2>", ErrorSeverity.ERROR),
+	//TOKEN_VOCAB_IN_DELEGATE("tokenVocab option ignored in imported grammar <arg>", ErrorSeverity.ERROR),
+	OPTIONS_IN_DELEGATE("options ignored in imported grammar <arg>", ErrorSeverity.WARNING),
+//	TOKEN_ALIAS_IN_DELEGATE("can't assign string to token name <arg> to string in imported grammar <arg2>", ErrorSeverity.ERROR),
 	CANNOT_FIND_IMPORTED_FILE("can't find or load grammar <arg>", ErrorSeverity.ERROR),
 	INVALID_IMPORT("<arg.typeString> grammar <arg.name> cannot import <arg2.typeString> grammar <arg2.name>", ErrorSeverity.ERROR),
 	IMPORTED_TOKENS_RULE_EMPTY("", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -711,7 +711,6 @@ public static Map<String,String> getStringLiteralAliasesFromLexerRules(GrammarRo
 
 	public Set<String> getStringLiterals() {
 		// TODO: super inefficient way to get these.
-		GrammarASTAdaptor adaptor = new GrammarASTAdaptor();
 		SymbolCollector collector = new SymbolCollector(this);
 		collector.process(ast); // no side-effects; find strings
 		return collector.strings;

File: tool/src/org/antlr/v4/automata/ParserATNFactory.java
Patch:
@@ -137,7 +137,9 @@ public Handle tree(List<Handle> els) {
 	}
 
 	/** Not valid for non-lexers */
-	public Handle range(GrammarAST a, GrammarAST b) { throw new UnsupportedOperationException(); }
+	public Handle range(GrammarAST a, GrammarAST b) {
+		throw new UnsupportedOperationException();
+	}
 
 	/** ~atom only */
 	/*

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -91,7 +91,7 @@ public void process() {
 			g.defineRule(r);
 		}
 		for (GrammarAST a : collector.namedActions) {
-			g.defineAction((GrammarAST)a.getParent());
+			g.defineAction(a);
 		}
 
 		// LINK (outermost) ALT NODES WITH Alternatives
@@ -122,7 +122,7 @@ public void process() {
 		// CHECK ATTRIBUTE EXPRESSIONS FOR SEMANTIC VALIDITY
 		AttributeChecks.checkAllAttributeExpressions(g);
 
-		symcheck.checkForRewriteIssues();
+		symcheck.checkForUndefinedTokensInRewrite();
 
 		UseDefAnalyzer.checkRewriteElementsPresentOnLeftSide(g);
 		UseDefAnalyzer.trackTokenRuleRefsInActions(g);

File: tool/src/org/antlr/v4/semantics/SymbolCollector.java
Patch:
@@ -82,7 +82,7 @@ public void globalScopeDef(GrammarAST ID, ActionAST elems) {
 
 	@Override
 	public void globalNamedAction(GrammarAST scope, GrammarAST ID, ActionAST action) {
-		namedActions.add(ID);
+		namedActions.add((GrammarAST)ID.getParent());
 		action.resolver = g;
 	}
 

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -99,7 +99,7 @@ public enum ErrorType {
 	RULE_HAS_NO_ARGS("rule <arg> has no defined parameters", ErrorSeverity.ERROR),
 	ARGS_ON_TOKEN_REF("token reference <arg> may not have parameters", ErrorSeverity.ERROR),
 	RULE_REF_AMBIG_WITH_RULE_IN_ALT("", ErrorSeverity.ERROR),
-	ILLEGAL_OPTION("illegal option <arg>", ErrorSeverity.ERROR),
+	ILLEGAL_OPTION("illegal option <arg>", ErrorSeverity.WARNING),
 	LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT("", ErrorSeverity.ERROR),
 	REWRITE_ELEMENT_NOT_PRESENT_ON_LHS("reference to rewrite element <arg> not found to left of ->", ErrorSeverity.ERROR),
     UNDEFINED_TOKEN_REF_IN_REWRITE("token <arg> in rewrite is undefined", ErrorSeverity.ERROR),

File: tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java
Patch:
@@ -47,8 +47,8 @@ public void process(GrammarAST ast) {
 		GrammarASTAdaptor adaptor = new GrammarASTAdaptor();
 		BlockSetTransformer transformer = new BlockSetTransformer(nodes);
 		transformer.setTreeAdaptor(adaptor);
-		System.out.println("before: "+ast.toStringTree());
+//		System.out.println("before: "+ast.toStringTree());
 		transformer.downup(ast);
-		System.out.println("after: "+ast.toStringTree());
+//		System.out.println("after: "+ast.toStringTree());
 	}
 }

File: tool/src/org/antlr/v4/codegen/BlankOutputModelFactory.java
Patch:
@@ -79,7 +79,7 @@ public abstract class BlankOutputModelFactory implements OutputModelFactory {
 
 	public List<SrcOp> rootRule(List<SrcOp> ops) { return ops; }
 
-	public List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST) { return null; }
+	public List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST, GrammarAST astOp) { return null; }
 
 	// AST REWRITES
 

File: tool/src/org/antlr/v4/codegen/OutputModelFactory.java
Patch:
@@ -82,7 +82,7 @@ public interface OutputModelFactory {
 
 	List<SrcOp> rootRule(List<SrcOp> ops);
 
-	List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST);
+	List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST, GrammarAST astOp);
 
 	Choice getChoiceBlock(BlockAST blkAST, List<CodeBlockForAlt> alts, GrammarAST label);
 

File: tool/src/org/antlr/v4/codegen/ParserFactory.java
Patch:
@@ -126,7 +126,7 @@ public List<SrcOp> set(GrammarAST setAST, GrammarAST labelAST,
 	}
 
 	@Override
-	public List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST) {
+	public List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST, GrammarAST astOp) {
 		Wildcard wild = new Wildcard(this, ast);
 		// TODO: dup with tokenRef
 		if ( labelAST!=null ) {
@@ -139,6 +139,7 @@ public List<SrcOp> wildcard(GrammarAST ast, GrammarAST labelAST) {
 				getCurrentRuleFunction().addContextDecl(l);
 			}
 		}
+		if ( controller.needsImplicitLabel(ast, wild) ) defineImplicitLabel(ast, wild);
 		AddToLabelList listLabelOp = getListLabelIfPresent(wild, labelAST);
 		return list(wild, listLabelOp);
 	}
@@ -369,7 +370,7 @@ public SrcOp makeChildOrRoot(SrcOp elemToAdd, boolean isRoot) {
 	public void defineImplicitLabel(GrammarAST ast, LabeledOp op) {
 		Decl d;
 		Rule r = g.getRule(ast.getText());
-		if ( ast.getType()==ANTLRParser.SET ) {
+		if ( ast.getType()==ANTLRParser.SET || ast.getType()==ANTLRParser.WILDCARD ) {
 			String implLabel =
 				gen.target.getImplicitSetLabel(String.valueOf(ast.token.getTokenIndex()));
 			d = new TokenDecl(this, implLabel);

File: tool/src/org/antlr/v4/tool/GrammarAST.java
Patch:
@@ -50,6 +50,7 @@ public GrammarAST(int type, Token t) {
 		token.setInputStream(t.getInputStream());
 		token.setLine(t.getLine());
 		token.setCharPositionInLine(t.getCharPositionInLine());
+		token.setTokenIndex(t.getTokenIndex());
 	}
     public GrammarAST(int type, Token t, String text) {
 		this(new CommonToken(type, text));

File: tool/test/org/antlr/v4/test/TestASTOps.java
Patch:
@@ -182,7 +182,7 @@ public void testTokenList() throws Exception {
         String grammar =
             "grammar T;\n" +
             "options {output=AST;}\n" +
-            "a : v='void' x=.^ ';' ;\n" +
+            "a : v='void' x+=.^ ';' ;\n" +
             "ID : 'a'..'z'+ ;\n" +
             "INT : '0'..'9'+;\n" +
             "WS : (' '|'\\n') {$channel=HIDDEN;} ;\n";

File: tool/src/org/antlr/v4/codegen/CodeGeneratorExtension.java
Patch:
@@ -56,9 +56,9 @@ public CodeGeneratorExtension(OutputModelFactory factory) {
 
 	public List<SrcOp> rulePostamble(List<SrcOp> ops) { return ops; }
 
-	public CodeBlockForAlt alternative(CodeBlockForAlt blk) { return blk; }
+	public CodeBlockForAlt alternative(CodeBlockForAlt blk, boolean outerMost) { return blk; }
 
-	public CodeBlockForAlt finishAlternative(CodeBlockForAlt blk) { return blk; }
+	public CodeBlockForAlt finishAlternative(CodeBlockForAlt blk, boolean outerMost) { return blk; }
 
 	public CodeBlockForAlt epsilon(CodeBlockForAlt blk) { return blk; }
 

File: tool/src/org/antlr/v4/codegen/DefaultOutputModelFactory.java
Patch:
@@ -65,11 +65,11 @@ public void setController(OutputModelController controller) {
 
 	public RuleFunction getCurrentRuleFunction() { return controller.getCurrentRuleFunction(); }
 
-	public Alternative getCurrentAlt() { return controller.getCurrentAlt(); }
+	public Alternative getCurrentOuterMostAlt() { return controller.getCurrentOuterMostAlt(); }
 
 	public CodeBlock getCurrentBlock() { return controller.getCurrentBlock(); }
 
-	public CodeBlock getCurrentAlternativeBlock() { return controller.getCurrentAlternativeBlock(); }
+	public CodeBlock getCurrentOuterMostAlternativeBlock() { return controller.getCurrentOuterMostAlternativeBlock(); }
 
 	public int getCodeBlockLevel() { return controller.codeBlockLevel; }
 

File: tool/src/org/antlr/v4/codegen/OutputModelFactory.java
Patch:
@@ -130,11 +130,11 @@ public interface OutputModelFactory {
 
 	RuleFunction getCurrentRuleFunction();
 
-	Alternative getCurrentAlt();
+	Alternative getCurrentOuterMostAlt();
 
 	CodeBlock getCurrentBlock();
 
-	CodeBlock getCurrentAlternativeBlock();
+	CodeBlock getCurrentOuterMostAlternativeBlock();
 
 	int getCodeBlockLevel();
 

File: tool/src/org/antlr/v4/codegen/model/InvokeRule.java
Patch:
@@ -75,7 +75,7 @@ public InvokeRule(OutputModelFactory factory, GrammarAST ast, GrammarAST labelAS
 		}
 
 		// If action refs rule as rulename not label, we need to define implicit label
-		if ( factory.getCurrentAlt().ruleRefsInActions.containsKey(ast.getText()) ) {
+		if ( factory.getCurrentOuterMostAlt().ruleRefsInActions.containsKey(ast.getText()) ) {
 			String label = gen.target.getImplicitRuleLabel(ast.getText());
 			RuleContextDecl d = new RuleContextDecl(factory,label,ctxName);
 			labels.add(d);

File: tool/src/org/antlr/v4/codegen/ParserASTExtension.java
Patch:
@@ -147,7 +147,6 @@ public List<SrcOp> leafRuleInRewriteAlt(InvokeRule invokeOp, List<SrcOp> ops) {
 		// add code to track rule results in _track_r
 		String trackName = factory.getGenerator().target.getElementListName(invokeOp.ast.getText());
 		TrackRuleElement t = new TrackRuleElement(factory, invokeOp.ast, trackName, label);
-		clearTrackingIfSingularLabel(ops, invokeOp, trackName);
 		ops.add(t);
 
 		// track any explicit label like _track_label but not implicit label
@@ -168,7 +167,6 @@ public List<SrcOp> leafTokenInRewriteAlt(SrcOp matchOp, List<SrcOp> ops) {
 		String trackName = factory.getGenerator().target.getElementListName(matchOp.ast.getText());
 		TrackTokenElement t = new TrackTokenElement(factory, matchOp.ast, trackName,
 													label);
-		clearTrackingIfSingularLabel(ops, matchOp, trackName);
 		ops.add(t);
 		if ( !label.isImplicit ) trackExplicitLabel(ops, label, matchOp);
 		return ops;

File: tool/src/org/antlr/v4/codegen/model/InvokeRule.java
Patch:
@@ -55,7 +55,7 @@ public InvokeRule(OutputModelFactory factory, GrammarAST ast, GrammarAST labelAS
 		this.name = ast.getText();
 		CodeGenerator gen = factory.getGenerator();
 		Rule r = factory.getGrammar().getRule(name);
-		ctxName = gen.target.getRuleFunctionContextStructName(factory.getCurrentRuleFunction());
+		ctxName = gen.target.getRuleFunctionContextStructName(r);
 
 		// TODO: move to factory
 		if ( labelAST!=null ) {

File: runtime/Java/src/org/antlr/v4/runtime/tree/BaseTreeAdaptor.java
Patch:
@@ -53,7 +53,7 @@ public void addChildren(Object root, List kids) {
 	 */
 
 	public List<Object> createElementList() {
-		return new ArrayList(3);
+		return new ElementList<Object>(this);
 	}
 
 	// END v4 stuff

File: tool/playground/TestT.java
Patch:
@@ -2,6 +2,7 @@
 import org.antlr.v4.automata.ParserATNFactory;
 import org.antlr.v4.runtime.*;
 import org.antlr.v4.runtime.atn.ATN;
+import org.antlr.v4.runtime.tree.Tree;
 import org.antlr.v4.semantics.SemanticPipeline;
 import org.antlr.v4.tool.*;
 
@@ -12,8 +13,8 @@ public static void main(String[] args) throws Exception {
 		TLexer t = new TLexer(new ANTLRFileStream(args[0]));
 		CommonTokenStream tokens = new CommonTokenStream(t);
 		TParser p = new TParser(tokens);
-//		ParserRuleContext ret = p.a();
-//		System.out.println(((Tree)ret.tree).toStringTree());
+		ParserRuleContext ret = p.a();
+		System.out.println(((Tree)ret.tree).toStringTree());
 	}
 
 	public static void dump() throws Exception {

File: tool/src/org/antlr/v4/codegen/DefaultOutputModelFactory.java
Patch:
@@ -111,6 +111,7 @@ public static List<SrcOp> list(Object... values) {
 	}
 
 	public Decl getCurrentDeclForName(String name) {
+		if ( getCurrentBlock().locals==null ) return null;
 		for (Decl d : getCurrentBlock().locals.elements()) {
 			if ( d.name.equals(name) ) return d;
 		}

File: tool/src/org/antlr/v4/codegen/ParserASTExtension.java
Patch:
@@ -45,7 +45,7 @@ public ParserASTExtension(OutputModelFactory factory) {
 	@Override
 	public CodeBlockForAlt alternative(CodeBlockForAlt blk) {
 		Alternative alt = factory.getCurrentAlt();
-		if ( !alt.hasRewrite() ) blk.addLocalDecl( new RootDecl(factory) );
+		if ( !alt.hasRewrite() ) blk.addLocalDecl( new RootDecl(factory, 0) );
 		return blk;
 	}
 

File: tool/src/org/antlr/v4/codegen/model/Rewrite.java
Patch:
@@ -32,6 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.codegen.OutputModelFactory;
 import org.antlr.v4.codegen.model.decl.CodeBlock;
 
+/** Either an ST or Tree rewrite */
 public class Rewrite extends CodeBlock {
 	public Rewrite(OutputModelFactory factory, int treeLevel, int codeBlockLevel) {
 		super(factory, treeLevel, codeBlockLevel);

File: tool/src/org/antlr/v4/codegen/model/ast/RewriteTokenRefIsRoot.java
Patch:
@@ -30,13 +30,12 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 package org.antlr.v4.codegen.model.ast;
 
 import org.antlr.v4.codegen.OutputModelFactory;
-import org.antlr.v4.codegen.model.decl.RewriteIteratorDecl;
 import org.antlr.v4.tool.GrammarAST;
 
 public class RewriteTokenRefIsRoot extends RewriteTokenRef {
 	public RewriteTokenRefIsRoot(OutputModelFactory factory, GrammarAST ast,
-								 String rootName, RewriteIteratorDecl decl)
+								 String rootName, String iterName)
 	{
-		super(factory, ast, rootName, decl);
+		super(factory, ast, rootName, iterName);
 	}
 }

File: tool/src/org/antlr/v4/codegen/model/decl/RewriteIteratorDecl.java
Patch:
@@ -35,10 +35,11 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 public class RewriteIteratorDecl extends Decl {
 	public String listName;
 	public RewriteIteratorDecl(OutputModelFactory factory,
-							   GrammarAST elem)
+							   GrammarAST elem,
+							   int codeBlockLevel)
 	{
 		super(factory, factory.getGenerator().target
-			  				.getRewriteIteratorName(elem, factory.getCodeBlockLevel()));
+			  				.getRewriteIteratorName(elem, codeBlockLevel));
 		listName = factory.getGenerator().target.getElementListName(elem);
 	}
 }

File: tool/src/org/antlr/v4/codegen/model/decl/RootDecl.java
Patch:
@@ -32,8 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.v4.codegen.OutputModelFactory;
 
 public class RootDecl extends Decl {
-	public RootDecl(OutputModelFactory factory) {
-		super(factory,
-			  factory.getGenerator().target.getRootName(factory.getCodeBlockLevel()));
+	public RootDecl(OutputModelFactory factory, int treeLevel) {
+		super(factory, factory.getGenerator().target.getRootName(treeLevel));
 	}
 }

File: tool/src/org/antlr/v4/codegen/CodeGenerator.java
Patch:
@@ -90,7 +90,7 @@ public ST generate() {
 			controller.addExtension( new ParserASTExtension(factory) );
 		}
 
-		OutputModelObject outputModel = controller.buildOutputModel(controller);
+		OutputModelObject outputModel = controller.buildOutputModel();
 
 		// CREATE TEMPLATES BY WALKING MODEL
 		OutputModelWalker walker = new OutputModelWalker(g.tool, templates);

File: tool/src/org/antlr/v4/codegen/model/RuleFunction.java
Patch:
@@ -25,10 +25,10 @@ public class RuleFunction extends OutputModelObject {
 
 	@ModelElement public List<SrcOp> code;
 	@ModelElement public OrderedHashSet<Decl> locals; // TODO: move into ctx?
-	@ModelElement public StructDecl ruleCtx;
-	//@ModelElement public DynamicScopeStruct scope;
+	@ModelElement public StructDecl ruleCtx;	//@ModelElement public DynamicScopeStruct scope;
 	@ModelElement public Map<String, Action> namedActions;
 	@ModelElement public Action finallyAction;
+	@ModelElement public List<SrcOp> postamble;
 
 	public RuleFunction(OutputModelFactory factory) {
 		super(factory);

File: runtime/Java/src/org/antlr/v4/runtime/Parser.java
Patch:
@@ -65,6 +65,7 @@ protected Object getMissingSymbol(RecognitionException e,
 		t.line = current.getLine();
 		t.charPositionInLine = current.getCharPositionInLine();
 		t.channel = Token.DEFAULT_CHANNEL;
+		t.input = current.getInputStream();
 		return t;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/BaseRecognizer.java
Patch:
@@ -119,6 +119,7 @@ public Object match(int ttype, LABitSet follow)
 	// like matchSet but w/o consume; error checking routine.
 	public void sync(LABitSet expecting) {
 		if ( expecting.member(state.input.LA(1)) ) return;
+		System.out.println("failed sync to "+expecting);
 		LABitSet followSet = computeErrorRecoverySet();
 		followSet.orInPlace(expecting);
 		NoViableAltException e = new NoViableAltException(this, followSet);

File: runtime/Java/src/org/antlr/v4/runtime/misc/LABitSet.java
Patch:
@@ -147,15 +147,13 @@ public int getSingleElement() {
 	 * @return A commma-separated list of values
 	 */
 	public String toString() {
-		System.out.println("toStr");
 		StringBuffer buf = new StringBuffer();
 		String separator = ",";
 		boolean havePrintedAnElement = false;
 		buf.append('{');
 		if ( EOF ) { buf.append("EOF"); havePrintedAnElement=true; }
 
 		for (int i = 0; i < (bits.length << LOG_BITS); i++) {
-			System.out.println("i="+i);
 			if (member(i)) {
 				if ( havePrintedAnElement ) {
 					buf.append(separator);

File: runtime/Java/src/org/antlr/v4/runtime/pda/PDA.java
Patch:
@@ -185,8 +185,8 @@ else if ( tokenLastCharIndex == prevAccept.inputIndex ) {
 			if ( reach.size()>0 ) { // if we reached other states, consume and process them
 				input.consume();
 			}
-			else if ( !accepted) {
-				System.out.println("!!!!! no match for char "+(char)c+" at "+input.index());
+			else if ( !accepted ) {
+				System.err.println("!!!!! no match for char "+(char)c+" at "+input.index());
 				input.consume();
 			}
 			// else reach.size==0 && matched, don't consume: accepted

File: tool/src/org/antlr/v4/codegen/LexerFactory.java
Patch:
@@ -33,6 +33,7 @@ public ST build() {
 				actionST.add("name", r.name);
 				for (Token t : actionTokens) {
 					actionST.add("actions", Misc.strip(t.getText(),1));
+					actionST.add("ruleIndex", r.index);
 				}
 				pdaST.add("actions", actionST);
 				lexerST.add("actions", actionST);
@@ -41,6 +42,7 @@ public ST build() {
 				Set<Token> sempredTokens = pda.ruleSempreds.keySet(r);
 				ST sempredST = gen.templates.getInstanceOf("sempredMethod");
 				sempredST.add("name", r.name);
+				sempredST.add("ruleIndex", r.index);
 				for (Token t : sempredTokens) {
 					sempredST.add("preds", t.getText());
 				}

File: tool/src/org/antlr/v4/codegen/OutputModelFactory.java
Patch:
@@ -99,9 +99,10 @@ public BitSetDecl createFollowBitSet(GrammarAST ast, IntervalSet set) {
 		return b;
 	}
 
-	public BitSetDecl createExpectingBitSet(GrammarAST ast, int decision, IntervalSet set) {
+	public BitSetDecl createExpectingBitSet(GrammarAST ast, int decision, IntervalSet set, String position) {
 		String inRuleName = ast.nfaState.rule.name;
-		String name = "EXPECTING_in_"+inRuleName+"_"+decision;
+		String name = "EXPECTING_in_"+inRuleName+"_"+position+"_"+decision;
+		//System.out.println("!!!!!!!! create "+name);
 		BitSetDecl b = new BitSetDecl(this, name, set);
 		return b;
 	}

File: tool/src/org/antlr/v4/codegen/SourceGenTriggers.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR ${project.version} ${buildNumber} SourceGenTriggers.g 2010-05-19 15:23:17
+// $ANTLR 3.2.1-SNAPSHOT May 24, 2010 15:02:05 SourceGenTriggers.g 2010-05-25 13:12:36
 
 package org.antlr.v4.codegen;
 

File: tool/src/org/antlr/v4/codegen/src/LL1Choice.java
Patch:
@@ -14,10 +14,9 @@ public class LL1Choice extends Choice {
 	/** Token names for each alt 0..n-1 */
 	public List<String[]> altLook;
 	public ThrowNoViableAlt error;
-	
+
 	public LL1Choice(OutputModelFactory factory, GrammarAST blkAST, List<CodeBlock> alts) {
-		super(factory, blkAST, alts);
-		this.decision = ((DecisionState)blkAST.nfaState).decision;
+		super(factory, blkAST, alts, ((DecisionState)blkAST.nfaState).decision);
 		DFA dfa = factory.g.decisionDFAs.get(decision);
 		/** Lookahead for each alt 1..n */
 		IntervalSet[] altLookSets = LinearApproximator.getLL1LookaheadSets(dfa);

File: tool/src/org/antlr/v4/codegen/src/LL1PlusBlockSingleAlt.java
Patch:
@@ -14,7 +14,7 @@ public class LL1PlusBlockSingleAlt extends LL1Loop {
 	public ThrowEarlyExitException earlyExitError;
 
 	public LL1PlusBlockSingleAlt(OutputModelFactory factory, GrammarAST blkAST, List<CodeBlock> alts) {
-		super(factory, blkAST, alts);
+		super(factory, blkAST, alts, ((PlusBlockStartState)blkAST.nfaState).loopBackState.decision);
 		PlusBlockStartState plus = (PlusBlockStartState)blkAST.nfaState;
 		DFA dfa = factory.g.decisionDFAs.get(plus.loopBackState.decision);
 		IntervalSet[] altLookSets = LinearApproximator.getLL1LookaheadSets(dfa);

File: tool/src/org/antlr/v4/codegen/src/LL1StarBlockSingleAlt.java
Patch:
@@ -12,11 +12,11 @@
 /** */
 public class LL1StarBlockSingleAlt extends LL1Loop {
 	public LL1StarBlockSingleAlt(OutputModelFactory factory, GrammarAST blkAST, List<CodeBlock> alts) {
-		super(factory, blkAST, alts);
+		super(factory, blkAST, alts, ((StarBlockStartState)blkAST.nfaState).loopBackState.decision);
 		StarBlockStartState star = (StarBlockStartState)blkAST.nfaState;
 		DFA dfa = factory.g.decisionDFAs.get(star.loopBackState.decision);
 		IntervalSet[] altLookSets = LinearApproximator.getLL1LookaheadSets(dfa);
-		IntervalSet look = altLookSets[1];
+		IntervalSet look = altLookSets[2];
 		addCodeForLookaheadTempVar(look);
 	}
 }

File: tool/src/org/antlr/v4/codegen/src/OptionalBlock.java
Patch:
@@ -8,6 +8,6 @@
 /** */
 public abstract class OptionalBlock extends Choice {
 	public OptionalBlock(OutputModelFactory factory, GrammarAST blkAST, List<CodeBlock> alts) {
-		super(factory, blkAST, alts);
+		super(factory, blkAST, alts, -999);
 	}
 }

File: tool/src/org/antlr/v4/codegen/src/ThrowRecognitionException.java
Patch:
@@ -18,7 +18,7 @@ public ThrowRecognitionException(OutputModelFactory factory, GrammarAST ast, Int
 		grammarLine = ast.getLine();
 		grammarLine = ast.getCharPositionInLine();
 		grammarFile = factory.g.fileName;
-		this.expecting = factory.createExpectingBitSet(ast, decision, expecting);
+		this.expecting = factory.createExpectingBitSet(ast, decision, expecting, "error");
 		factory.defineBitSet(this.expecting);
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/BaseRecognizer.java
Patch:
@@ -321,7 +321,6 @@ public String getErrorHeader(RecognitionException e) {
 	 *  so that it creates a new Java type.
 	 */
 	public String getTokenErrorDisplay(Token t) {
-		System.err.println("mmmm3");		
 		String s = t.getText();
 		if ( s==null ) {
 			if ( t.getType()==Token.EOF ) {

File: runtime/Java/src/org/antlr/v4/runtime/EarlyExitException.java
Patch:
@@ -34,7 +34,7 @@ public class EarlyExitException extends RecognitionException {
 	/** Used for remote debugger deserialization */
 	public EarlyExitException() {;}
 	
-	public EarlyExitException(BaseRecognizer recognizer, LABitSet expecting) {
-		super(recognizer, expecting);
+	public EarlyExitException(BaseRecognizer recognizer, LABitSet firstSet) {
+		super(recognizer, firstSet);
 	}
 }

File: runtime/Java/src/org/antlr/v4/runtime/MismatchedSetException.java
Patch:
@@ -33,8 +33,8 @@ public class MismatchedSetException extends RecognitionException {
 	/** Used for remote debugger deserialization */
 	public MismatchedSetException() {;}
 
-	public MismatchedSetException(BaseRecognizer recognizer, LABitSet expecting) {
-		super(recognizer, expecting);
+	public MismatchedSetException(BaseRecognizer recognizer, LABitSet firstSet) {
+		super(recognizer, firstSet);
 	}
 
 	public String toString() {

File: runtime/Java/src/org/antlr/v4/runtime/MismatchedTokenException.java
Patch:
@@ -34,8 +34,8 @@ public class MismatchedTokenException extends RecognitionException {
 	/** Used for remote debugger deserialization */
 	public MismatchedTokenException() {;}
 
-	public MismatchedTokenException(BaseRecognizer recognizer, int expecting) {
-		super(recognizer, LABitSet.of(expecting));
+	public MismatchedTokenException(BaseRecognizer recognizer, int firstSet) {
+		super(recognizer, LABitSet.of(firstSet));
 	}
 
 	public String toString() {

File: runtime/Java/src/org/antlr/v4/runtime/MismatchedTreeNodeException.java
Patch:
@@ -36,9 +36,9 @@ public MismatchedTreeNodeException() {
 	}
 
 	public MismatchedTreeNodeException(BaseRecognizer recognizer,
-									   int expecting)
+									   int firstSet)
 	{
-		super(recognizer, LABitSet.of(expecting));
+		super(recognizer, LABitSet.of(firstSet));
 	}
 
 	public String toString() {

File: runtime/Java/src/org/antlr/v4/runtime/NoViableAltException.java
Patch:
@@ -35,9 +35,9 @@ public class NoViableAltException extends RecognitionException {
 	public NoViableAltException() {;}
 	
 	public NoViableAltException(BaseRecognizer recognizer,
-								LABitSet expecting)
+								LABitSet firstSet)
 	{
-		super(recognizer, expecting);
+		super(recognizer, firstSet);
 	}
 
 	public String toString() {

File: runtime/Java/src/org/antlr/v4/runtime/ParserRuleContext.java
Patch:
@@ -30,8 +30,8 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.runtime.Token;
 import org.antlr.v4.runtime.misc.LABitSet;
 
-/** Rules that return more than a single value must return an object
- *  containing all the values.  Besides the properties defined in
+/** Rules return values in an object containing all the values.
+ *  Besides the properties defined in
  *  RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
  *  return values.  This class simply defines the minimum properties that
  *  are always defined and methods to access the others that might be
@@ -52,6 +52,6 @@ public class ParserRuleContext extends RuleContext {
 	public Token start, stop;
 	public Object getStart() { return start; }
 	public Object getStop() { return stop; }
-	public ParserRuleContext() {;}
+	public ParserRuleContext() { super(); }
 	public ParserRuleContext(LABitSet follow) { super(follow); }
 }

File: runtime/Java/src/org/antlr/v4/runtime/misc/LABitSet.java
Patch:
@@ -14,6 +14,8 @@ public class LABitSet {
 	 */
 	public final static int MOD_MASK = BITS - 1;
 
+	public static final LABitSet EOF_SET = LABitSet.of(Token.EOF);
+
 	/** The actual data bits */
 	public long bits[];
 

File: tool/src/org/antlr/v4/automata/NFA.java
Patch:
@@ -39,7 +39,6 @@ public void addState(NFAState state) {
 	public int defineDecisionState(DecisionState s) {
 		decisionToNFAState.add(s);
 		s.decision = decisionToNFAState.size()-1;
-		System.out.println("dec state "+s.stateNumber+" gets dec # "+s.decision);
 		return s.decision;
 	}
 }

File: tool/src/org/antlr/v4/codegen/src/Choice.java
Patch:
@@ -23,7 +23,7 @@ public Choice(OutputModelFactory factory, GrammarAST blkOrEbnfRootAST, List<Code
 		// TODO: use existing lookahead! don't compute
 		LinearApproximator approx = new LinearApproximator(factory.g, decision);
 		NFAState decisionState = ast.nfaState;
-		expecting = approx.LOOK(decisionState);
+		expecting = approx.FIRST(decisionState);
 		System.out.println(blkOrEbnfRootAST.toStringTree()+" choice expecting="+expecting);
 	}
 

File: tool/src/org/antlr/v4/codegen/src/InvokeRule.java
Patch:
@@ -51,7 +51,7 @@ public InvokeRule(OutputModelFactory factory, GrammarAST ast, GrammarAST labelAS
 
 		LinearApproximator approx = new LinearApproximator(factory.g, NFA.INVALID_DECISION_NUMBER);
 		RuleTransition call = (RuleTransition)ast.nfaState.transition(0);
-		IntervalSet fset = approx.LOOK(call.followState);
+		IntervalSet fset = approx.FIRST(call.followState);
 		System.out.println("follow rule ref "+name+"="+fset);
 		follow = factory.createFollowBitSet(ast, fset);
 		factory.defineBitSet(follow);

File: tool/src/org/antlr/v4/codegen/src/MatchToken.java
Patch:
@@ -41,7 +41,7 @@ public MatchToken(OutputModelFactory factory, TerminalAST ast, GrammarAST labelA
 		}
 
 		LinearApproximator approx = new LinearApproximator(factory.g, NFA.INVALID_DECISION_NUMBER);
-		IntervalSet fset = approx.LOOK(ast.nfaState.transition(0).target);
+		IntervalSet fset = approx.FIRST(ast.nfaState.transition(0).target);
 		System.out.println("follow match "+name+"="+fset);
 		follow = factory.createFollowBitSet(ast, fset);
 		factory.defineBitSet(follow);

File: runtime/Java/src/org/antlr/v4/runtime/MismatchedNotSetException.java
Patch:
@@ -27,15 +27,14 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.runtime.IntStream;
 import org.antlr.v4.runtime.misc.LABitSet;
 
 public class MismatchedNotSetException extends MismatchedSetException {
 	/** Used for remote debugger deserialization */
 	public MismatchedNotSetException() {;}
 
-	public MismatchedNotSetException(LABitSet expecting, IntStream input) {
-		super(expecting, input);
+	public MismatchedNotSetException(BaseRecognizer recognizer, LABitSet expecting) {
+		super(recognizer, expecting);
 	}
 
 	public String toString() {

File: runtime/Java/src/org/antlr/v4/runtime/MismatchedSetException.java
Patch:
@@ -27,7 +27,6 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.runtime.IntStream;
 import org.antlr.v4.runtime.misc.LABitSet;
 
 public class MismatchedSetException extends RecognitionException {
@@ -36,8 +35,8 @@ public class MismatchedSetException extends RecognitionException {
 	/** Used for remote debugger deserialization */
 	public MismatchedSetException() {;}
 
-	public MismatchedSetException(LABitSet expecting, IntStream input) {
-		super(input);
+	public MismatchedSetException(BaseRecognizer recognizer, LABitSet expecting) {
+		super(recognizer);
 		this.expecting = expecting;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/MismatchedTokenException.java
Patch:
@@ -27,7 +27,6 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.runtime.IntStream;
 import org.antlr.runtime.Token;
 
 /** A mismatched char or Token or tree node */
@@ -37,8 +36,8 @@ public class MismatchedTokenException extends RecognitionException {
 	/** Used for remote debugger deserialization */
 	public MismatchedTokenException() {;}
 
-	public MismatchedTokenException(int expecting, IntStream input) {
-		super(input);
+	public MismatchedTokenException(BaseRecognizer recognizer, int expecting) {
+		super(recognizer);
 		this.expecting = expecting;
 	}
 

File: runtime/Java/src/org/antlr/v4/runtime/RecognizerSharedState.java
Patch:
@@ -30,6 +30,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.antlr.runtime.IntStream;
 import org.antlr.v4.runtime.misc.QStack;
 
+import java.util.List;
 import java.util.Map;
 
 /** The set of fields needed by an abstract recognizer to recognize input
@@ -77,6 +78,8 @@ public class RecognizerSharedState {
 	 */
 	public Map[] ruleMemo;
 
+	List<ANTLRParserListener> listeners;
+
 	public RecognizerSharedState() {
         this.ctx = new QStack<RuleContext>();		
 	}

File: runtime/Java/src/org/antlr/v4/runtime/UnwantedTokenException.java
Patch:
@@ -27,16 +27,15 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  */
 package org.antlr.v4.runtime;
 
-import org.antlr.runtime.IntStream;
 import org.antlr.runtime.Token;
 
 /** An extra token while parsing a TokenStream */
 public class UnwantedTokenException extends MismatchedTokenException {
 	/** Used for remote debugger deserialization */
 	public UnwantedTokenException() {;}
 
-	public UnwantedTokenException(int expecting, IntStream input) {
-		super(expecting, input);
+	public UnwantedTokenException(BaseRecognizer recognizer, int expecting) {
+		super(recognizer, expecting);
 	}
 
 	public Token getUnexpectedToken() {

File: runtime/Java/src/org/antlr/v4/runtime/nfa/NFA.java
Patch:
@@ -177,7 +177,7 @@ public int execThompson(CharStream input) {
 			boolean accepted = false;
 processOneChar:
 			while ( i<closure.size() ) {
-				//System.out.println("input["+input.index()+"]=="+(char)c+" closure="+closure+", i="+i+", reach="+ reach);
+				System.out.println("input["+input.index()+"]=="+(char)c+" closure="+closure+", i="+i+", reach="+ reach);
 				ThreadState t = closure.get(i);
 				ip = t.addr;
 				NFAStack context = t.context;
@@ -260,7 +260,7 @@ else if ( tokenLastCharIndex == prevAcceptLastCharIndex ) {
 				input.consume();
 			}
 			else if ( !accepted) {
-				System.err.println("no match for char "+(char)c+" at "+input.index());
+				System.out.println("!!!!! no match for char "+(char)c+" at "+input.index());
 				input.consume();
 			}
 			// else reach.size==0 && matched, don't consume: accepted and

File: tool/src/org/antlr/v4/analysis/AnalysisPipeline.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.antlr.v4.automata.DFA;
 import org.antlr.v4.automata.DecisionState;
+import org.antlr.v4.automata.TokensStartState;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.LexerGrammar;
 
@@ -25,12 +26,11 @@ public void process() {
 
 	void processLexer() {
 		LexerGrammar lg = (LexerGrammar)g;
-		int d = 0;
 		for (String modeName : lg.modes.keySet()) {
 			LexerNFAToDFAConverter conv = new LexerNFAToDFAConverter(lg);
 			DFA dfa = conv.createDFA(modeName);
-			g.setLookaheadDFA(d, dfa);
-			d++;
+			TokensStartState startState = g.nfa.modeToStartState.get(modeName);
+			g.setLookaheadDFA(startState.decision, dfa);
 
 			if ( g.tool.minimizeDFA ) {
 				int before = dfa.stateSet.size();

File: tool/src/org/antlr/v4/automata/LexerNFAFactory.java
Patch:
@@ -19,6 +19,7 @@ public NFA createNFA() {
 			TokensStartState startState =
 				(TokensStartState)newState(TokensStartState.class, null);
 			nfa.modeToStartState.put(modeName, startState);
+			nfa.defineDecisionState(startState);			
 		}
 
 		// CREATE NFA FOR EACH RULE

File: tool/src/org/antlr/v4/analysis/LeftRecursionDetector.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.antlr.v4.automata.*;
 import org.antlr.v4.misc.OrderedHashSet;
-import org.antlr.v4.tool.ErrorManager;
 import org.antlr.v4.tool.Rule;
 
 import java.util.ArrayList;
@@ -35,7 +34,7 @@ public void check() {
 		}
 		//System.out.println("cycles="+listOfRecursiveCycles);
 		if ( listOfRecursiveCycles.size()>0 ) {
-			ErrorManager.leftRecursionCycles(nfa.g.fileName, listOfRecursiveCycles);
+			nfa.g.tool.errMgr.leftRecursionCycles(nfa.g.fileName, listOfRecursiveCycles);
 		}
 	}
 

File: tool/src/org/antlr/v4/analysis/PredictionDFAFactory.java
Patch:
@@ -3,7 +3,6 @@
 import org.antlr.v4.automata.*;
 import org.antlr.v4.misc.IntervalSet;
 import org.antlr.v4.misc.OrderedHashSet;
-import org.antlr.v4.tool.ErrorManager;
 import org.antlr.v4.tool.Grammar;
 import org.antlr.v4.tool.Rule;
 
@@ -150,7 +149,7 @@ void reach(DFAState d) {
 //				ErrorManager.multipleRecursiveAlts(g.fileName, d, mras.recursiveAltSet);
 //			}
 			catch (AnalysisTimeoutSignal at) {// TODO: nobody throws yet
-				ErrorManager.analysisTimeout();
+				g.tool.errMgr.analysisTimeout();
 			}
 
 			addTransition(d, label, t); // make d-label->t transition

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -78,7 +78,7 @@ public void process() {
 		symcheck.checkForQualifiedRuleIssues(g, collector.qualifiedRulerefs);
 
 		// don't continue if we got symbol errors
-		if ( ErrorManager.getNumErrors()>0 ) return;
+		if ( g.tool.getNumErrors()>0 ) return;
 
 		// CHECK ATTRIBUTE EXPRESSIONS FOR SEMANTIC VALIDITY
 		AttributeChecks.checkAllAttributeExpressions(g);

File: tool/src/org/antlr/v4/semantics/UseDefAnalyzer.java
Patch:
@@ -17,8 +17,8 @@ public void checkRewriteElementsPresentOnLeftSide(Grammar g, List<Rule> rules) {
 						   alt.labelDefs.containsKey(e.getText()) ||
 						   e.getText().equals(r.name)) ) // $r ok in rule r
 					{
-						ErrorManager.grammarError(ErrorType.REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
-												  g.fileName, e.token, e.getText());
+						g.tool.errMgr.grammarError(ErrorType.REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
+												   g.fileName, e.token, e.getText());
 					}
 				}
 			}

File: tool/src/org/antlr/v4/tool/ANTLRToolListener.java
Patch:
@@ -7,7 +7,7 @@
  *  In this way, users of this interface are less sensitive to changes in
  *  the info I need for error messages.
  */
-public interface ANTLRErrorListener {
+public interface ANTLRToolListener {
 	public void info(String msg);
 	public void error(Message msg);
 	public void warning(Message msg);

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -65,7 +65,8 @@ public void process() {
 		symcheck.examine(); // side-effect: strip away redef'd rules.
 
 		// don't continue if we get symbol errors
-		if ( ErrorManager.getNumErrors()>0 ) return;
+		//if ( ErrorManager.getNumErrors()>0 ) return;
+		// hmm...we don't get missing arg errors and such if we bail out here
 
 		// STORE RULES/ACTIONS/SCOPES IN GRAMMAR
 		for (Rule r : collector.rules) g.defineRule(r);
@@ -76,7 +77,7 @@ public void process() {
 		symcheck.checkRuleArgs(g, collector.rulerefs);
 		symcheck.checkForQualifiedRuleIssues(g, collector.qualifiedRulerefs);
 
-		// don't continue if we get symbol errors
+		// don't continue if we got symbol errors
 		if ( ErrorManager.getNumErrors()>0 ) return;
 
 		// CHECK ATTRIBUTE EXPRESSIONS FOR SEMANTIC VALIDITY

File: tool/src/org/antlr/v4/tool/ErrorManager.java
Patch:
@@ -385,6 +385,7 @@ private static StackTraceElement getLastNonErrorManagerCodeLocation(Throwable e)
      *  thread.
      */
     public static void setErrorListener(ANTLRErrorListener l) {
+		resetErrorState();
         state.get().listener = l;
     }
 

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -203,6 +203,7 @@ public void defineAction(GrammarAST atAST) {
     }
 
     public void defineRule(Rule r) {
+		if ( rules.get(r.name)!=null ) return;
 		rules.put(r.name, r);
 		r.index = ruleNumber++;
 	}

File: tool/test/org/antlr/v4/test/TestSymbolIssues.java
Patch:
@@ -32,7 +32,9 @@ public class TestSymbolIssues extends BaseTest {
 		"error(72): A.g:3:19: cannot alias X; token name already defined\n" +
 		"error(72): A.g:3:26: cannot alias Y; token name already assigned to 'y'\n" +
 		"error(72): A.g:3:36: cannot alias Z; token name already defined\n" +
-		"error(23): A.g:13:43: reference to undefined rule: q"
+		"error(46): A.g:13:37: rule b has no defined parameters\n" +
+		"error(23): A.g:13:43: reference to undefined rule: q\n" +
+		"error(45): A.g:14:31: missing parameter(s) on rule reference: a"
     };
 
     static String[] B = {

File: tool/src/org/antlr/v4/parse/ANTLRLexer.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR ${project.version} ${buildNumber} ANTLRLexer.g 2010-02-19 17:45:05
+// $ANTLR ${project.version} ${buildNumber} ANTLRLexer.g 2010-02-23 11:32:31
 
 /*
  [The "BSD licence"]
@@ -263,7 +263,7 @@ public final void mCOMMENT() throws RecognitionException {
                         if ( (( input.LA(2) != '/')) ) {
                             alt3=1;
                         }
-                        else if ( (((( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') ))||( true ))) ) {
+                        else if ( ((( true )||(( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') )))) ) {
                             alt3=2;
                         }
                         else {

File: tool/src/org/antlr/v4/parse/ASTVerifier.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR ${project.version} ${buildNumber} ASTVerifier.g 2010-02-19 17:45:08
+// $ANTLR ${project.version} ${buildNumber} ASTVerifier.g 2010-02-23 11:32:35
 
 /*
  [The "BSD license"]

File: tool/src/org/antlr/v4/semantics/SemanticPipeline.java
Patch:
@@ -104,8 +104,8 @@ public void assignTokenTypes(Grammar g, CollectSymbols collector, SymbolChecks s
 
 			// DEFINE TOKEN TYPES FOR STRING LITERAL REFS LIKE 'while', ';'
 			for (String s : collector.strings) { G.defineStringLiteral(s); }
-			System.out.println("tokens="+G.tokenNameToTypeMap);
-			System.out.println("strings="+G.stringLiteralToTypeMap);
+//			System.out.println("tokens="+G.tokenNameToTypeMap);
+//			System.out.println("strings="+G.stringLiteralToTypeMap);
 		}
 	}
 

File: tool/src/org/antlr/v4/semantics/BasicSemanticTriggers.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR ${project.version} ${buildNumber} BasicSemanticTriggers.g 2010-02-19 17:45:09
+// $ANTLR ${project.version} ${buildNumber} BasicSemanticTriggers.g 2010-02-22 16:10:22
 
 /*
  [The "BSD license"]

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -72,7 +72,7 @@ public enum ErrorType {
 	NO_TOKEN_DEFINITION(ErrorSeverity.ERROR, true, true),
 	UNDEFINED_RULE_REF(ErrorSeverity.ERROR, true, true),
 	LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE(ErrorSeverity.ERROR, true, true),
-	CANNOT_ALIAS_TOKENS_IN_LEXER(ErrorSeverity.ERROR, true, true),
+	CANNOT_ALIAS_TOKENS(ErrorSeverity.ERROR, true, true),
     TOKEN_NAMES_MUST_START_UPPER(ErrorSeverity.ERROR, true, true),
 	ATTRIBUTE_REF_NOT_IN_RULE(ErrorSeverity.ERROR, true, true),
 	INVALID_RULE_SCOPE_ATTRIBUTE_REF(ErrorSeverity.ERROR, true, true),
@@ -123,6 +123,7 @@ public enum ErrorType {
 	TOKEN_ALIAS_CONFLICT(ErrorSeverity.ERROR, true, true),
 	TOKEN_ALIAS_REASSIGNMENT(ErrorSeverity.ERROR, true, true),
 	TOKEN_VOCAB_IN_DELEGATE(ErrorSeverity.ERROR, true, true),
+	TOKEN_ALIAS_IN_DELEGATE(ErrorSeverity.ERROR, true, true),
 	INVALID_IMPORT(ErrorSeverity.ERROR, true, true),
 	IMPORTED_TOKENS_RULE_EMPTY(ErrorSeverity.ERROR, true, true),
 	IMPORT_NAME_CLASH(ErrorSeverity.ERROR, true, true),

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -167,7 +167,7 @@ protected boolean antlr(String fileName, String grammarFileName, String grammarS
 			ErrorManager.setErrorListener(equeue);
 			*/
 			Tool antlr = newTool(optionsA);
-			antlr.process();
+			antlr.processGrammarsOnCommandLine();
 			ANTLRErrorListener listener = ErrorManager.getErrorListener();
 			if ( listener instanceof ErrorQueue ) {
 				ErrorQueue equeue = (ErrorQueue)listener;

File: tool/src/org/antlr/v4/semantics/BasicSemanticTriggers.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 BasicSemanticTriggers.g 2010-02-08 17:03:10
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 BasicSemanticTriggers.g 2010-02-10 11:36:38
 
 /*
  [The "BSD license"]

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -69,7 +69,6 @@ public enum ErrorType {
 	LEXER_RULES_NOT_ALLOWED(ErrorSeverity.ERROR, true, true),
 	PARSER_RULES_NOT_ALLOWED(ErrorSeverity.ERROR, true, true),
     REPEATED_PREQUEL(ErrorSeverity.ERROR, true, true),
-	CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(ErrorSeverity.ERROR, true, true),
 	NO_TOKEN_DEFINITION(ErrorSeverity.ERROR, true, true),
 	UNDEFINED_RULE_REF(ErrorSeverity.ERROR, true, true),
 	LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE(ErrorSeverity.ERROR, true, true),

File: tool/src/org/antlr/v4/semantics/BasicSemanticTriggers.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 BasicSemanticTriggers.g 2010-02-07 14:03:15
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 BasicSemanticTriggers.g 2010-02-07 15:09:46
 
 /*
  [The "BSD license"]

File: tool/src/org/antlr/v4/tool/Rule.java
Patch:
@@ -12,7 +12,8 @@ public class Rule {
     /** All labels go in here (TODO: plus being split per the above lists) to
      *  catch dup label and label type mismatches.
      */
-    public Map<String, GrammarAST> labelNameSpace = new HashMap<String, GrammarAST>();
+    public Map<String, LabelElementPair> labelNameSpace =
+        new HashMap<String, LabelElementPair>();
 
     public Rule(String name, GrammarASTWithOptions ast) {
         this.name = name;

File: tool/src/org/antlr/v4/parse/ANTLRLexer.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-02-03 15:37:27
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-02-04 17:29:59
 
 /*
  [The "BSD licence"]
@@ -263,7 +263,7 @@ public final void mCOMMENT() throws RecognitionException {
                         if ( (( input.LA(2) != '/')) ) {
                             alt3=1;
                         }
-                        else if ( (((( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') ))||( true ))) ) {
+                        else if ( ((( true )||(( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') )))) ) {
                             alt3=2;
                         }
                         else {

File: tool/src/org/antlr/v4/semantics/SemanticsPipeline.java
Patch:
@@ -36,6 +36,9 @@ public void process(Grammar g) {
         }
 
         // DEFINE SYMBOLS
+        nodes.reset();
+        DefineSymbolTriggers sym = new DefineSymbolTriggers(nodes,g);
+        sym.downup(g.ast);
 
         // ASSIGN TOKEN TYPES
 

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -300,7 +300,7 @@ public Grammar load(String fileName) {
 
             p.setTreeAdaptor(new GrammarASTAdaptor(in));
             ParserRuleReturnScope r = p.grammarSpec();
-            GrammarAST t = (GrammarAST) r.getTree();
+            GrammarRootAST t = (GrammarRootAST) r.getTree();
             if ( internalOption_PrintGrammarTree ) System.out.println(t.toStringTree());
             g = new Grammar(this, t);
             g.fileName = fileName;

File: tool/src/org/antlr/v4/parse/ANTLRLexer.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-02-01 14:18:31
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-02-01 17:39:09
 
 /*
  [The "BSD licence"]
@@ -268,7 +268,7 @@ public final void mCOMMENT() throws RecognitionException {
                         if ( (( input.LA(2) != '/')) ) {
                             alt3=1;
                         }
-                        else if ( (((( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') ))||( true ))) ) {
+                        else if ( ((( true )||(( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') )))) ) {
                             alt3=2;
                         }
                         else {

File: tool/src/org/antlr/v4/tool/ErrorType.java
Patch:
@@ -39,6 +39,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  * @since 4.0
  */
 public enum ErrorType {
+    // TODO: set all of the true, true appropriately
 	CANNOT_WRITE_FILE(ErrorSeverity.ERROR, true, true),
 	CANNOT_CLOSE_FILE(ErrorSeverity.ERROR, true, true),
 	CANNOT_FIND_TOKENS_FILE(ErrorSeverity.ERROR, true, true),
@@ -69,6 +70,7 @@ public enum ErrorType {
 	UNDEFINED_RULE_REF(ErrorSeverity.ERROR, true, true),
 	LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE(ErrorSeverity.ERROR, true, true),
 	CANNOT_ALIAS_TOKENS_IN_LEXER(ErrorSeverity.ERROR, true, true),
+    TOKEN_NAMES_MUST_START_UPPER(ErrorSeverity.ERROR, true, true),
 	ATTRIBUTE_REF_NOT_IN_RULE(ErrorSeverity.ERROR, true, true),
 	INVALID_RULE_SCOPE_ATTRIBUTE_REF(ErrorSeverity.ERROR, true, true),
 	UNKNOWN_SIMPLE_ATTRIBUTE(ErrorSeverity.ERROR, true, true),

File: tool/src/org/antlr/v4/Tool.java
Patch:
@@ -53,6 +53,8 @@ public class Tool {
      */
      private boolean make = false;
     private boolean showBanner = true;
+
+    /** Exit after showing version or whatever */ 
     private static boolean exitNow = false;
 
     // The internal options are for my use on the command line during dev
@@ -301,7 +303,7 @@ public Grammar load(String fileName) {
             p.setTreeAdaptor(astAdaptor);
             ParserRuleReturnScope r = p.grammarSpec();
             GrammarAST t = (GrammarAST) r.getTree();
-            System.out.println(t.toStringTree());
+            if ( internalOption_PrintGrammarTree ) System.out.println(t.toStringTree());
             g = new Grammar(this, t);
             g.fileName = fileName;
             grammars.put(g.name, g);

File: tool/src/org/antlr/v4/parse/ANTLRLexer.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-01-31 12:53:18
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-01-31 13:25:10
 
 /*
  [The "BSD licence"]
@@ -269,7 +269,7 @@ public final void mCOMMENT() throws RecognitionException {
                         if ( (( input.LA(2) != '/')) ) {
                             alt3=1;
                         }
-                        else if ( (((( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') ))||( true ))) ) {
+                        else if ( ((( true )||(( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') )))) ) {
                             alt3=2;
                         }
                         else {

File: tool/src/org/antlr/v4/semantics/SemanticsPipeline.java
Patch:
@@ -23,7 +23,7 @@ public void process(Grammar g) {
 
         // DO BASIC / EASY SEMANTIC CHECKS
         nodes.reset();
-        BasicSemanticsChecker basics = new BasicSemanticsChecker(nodes,g);
+        BasicSemanticsChecker basics = new BasicSemanticsChecker(nodes,g.fileName);
         basics.downup(g.ast);
     }
 }

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -23,7 +23,6 @@ public class Grammar {
 
     public Grammar(Tool tool, GrammarAST ast) {
         this.tool = tool;
-        this.name = ast.getChild(0).getText();
         this.ast = ast;
     }
     

File: tool/src/org/antlr/v4/parse/ANTLRLexer.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-01-30 14:28:45
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-01-31 12:53:18
 
 /*
  [The "BSD licence"]

File: tool/src/org/antlr/v4/parse/ASTVerifier.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ASTVerifier.g 2010-01-30 14:28:48
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ASTVerifier.g 2010-01-31 12:53:21
 
 /*
  [The "BSD license"]

File: tool/test/org/antlr/v4/test/BaseTest.java
Patch:
@@ -40,7 +40,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 import org.junit.Before;
 import org.junit.After;
 import org.junit.Assert;
-import org.stringtemplate.ST;
+import org.stringtemplate.v4.ST;
 
 import java.io.*;
 import java.util.*;

File: tool/src/org/antlr/v4/parse/ANTLRLexer.java
Patch:
@@ -1,4 +1,4 @@
-// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-01-27 17:02:05
+// $ANTLR 3.2.1-SNAPSHOT Jan 26, 2010 15:12:28 ANTLRLexer.g 2010-01-30 14:28:45
 
 /*
  [The "BSD licence"]
@@ -269,7 +269,7 @@ public final void mCOMMENT() throws RecognitionException {
                         if ( (( input.LA(2) != '/')) ) {
                             alt3=1;
                         }
-                        else if ( ((( true )||(( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') )))) ) {
+                        else if ( (((( true )&&(    !(input.LA(1) == '*' && input.LA(2) == '/') ))||( true ))) ) {
                             alt3=2;
                         }
                         else {

File: tool/src/org/antlr/v4/tool/ErrorSeverity.java
Patch:
@@ -34,7 +34,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  *
  * @author Jim Idle - Temporal Wave LLC (jimi@temporal-wave.com)
  */
-public enum MessageSeverity {
+public enum ErrorSeverity {
 
     /**
      * How to describe informational messages
@@ -72,7 +72,7 @@ public String getText() {
      *
      * @param text The human readable string representing the serverity level
      */
-    private MessageSeverity(String text) {
+    private ErrorSeverity(String text) {
         this.text = text;
     }
 }

File: tool/src/org/antlr/v4/tool/Grammar.java
Patch:
@@ -16,13 +16,14 @@ public class Grammar {
     public String name;
     public GrammarAST ast;
     public String text; // testing only
+    public String fileName;
 
     protected List<Grammar> importedGrammars;
     protected Map<String, Rule> rules = new HashMap<String, Rule>();
 
-    public Grammar(Tool tool, String name, GrammarAST ast) {
+    public Grammar(Tool tool, GrammarAST ast) {
         this.tool = tool;
-        this.name = name;
+        this.name = ast.getChild(0).getText();
         this.ast = ast;
     }
     

