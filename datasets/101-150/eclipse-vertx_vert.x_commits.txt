File: vertx-core/src/main/java/io/vertx/core/internal/concurrent/InboundMessageQueue.java
Patch:
@@ -80,19 +80,19 @@ public final boolean test(M msg) {
   }
 
   /**
-   * Handle resume, executed on the event-loop thread.
+   * Handle resume, executed on the producer executor.
    */
   protected void handleResume() {
   }
 
   /**
-   * Handler pause, executed on the event-loop thread
+   * Handler pause, executed on the producer executor.
    */
   protected void handlePause() {
   }
 
   /**
-   * Handle a message, executed on the context thread
+   * Handle a message, executed on the consumer executor.
    *
    * @param msg the message
    */

File: vertx-core/src/test/java/io/vertx/benchmarks/BenchmarkBase.java
Patch:
@@ -29,9 +29,6 @@
 @Threads(1)
 @BenchmarkMode(Mode.Throughput)
 @Fork(value = 1, jvmArgs = {
-    "-XX:+UseBiasedLocking",
-    "-XX:BiasedLockingStartupDelay=0",
-    "-XX:+AggressiveOpts",
     "-Djmh.executor=CUSTOM",
     "-Djmh.executor.class=io.vertx.benchmarks.VertxExecutorService"
 })

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -73,15 +73,15 @@ public Future<Boolean> updateSSLOptions(ServerSSLOptions options, boolean force)
   }
 
   @Override
-  public void updateTrafficShapingOptions(TrafficShapingOptions options) {
+  public Future<Boolean> updateTrafficShapingOptions(TrafficShapingOptions options) {
     NetServer s;
     synchronized (this) {
       s = tcpServer;
     }
     if (s == null) {
       throw new IllegalStateException("Not listening");
     }
-    s.updateTrafficShapingOptions(options);
+    return s.updateTrafficShapingOptions(options);
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -437,7 +437,7 @@ default Future<HttpClientResponse> send(ReadStream<Buffer> body) {
    *
    * @see #reset(long)
    */
-  default boolean reset() {
+  default Future<Void> reset() {
     return reset(0L);
   }
 
@@ -455,7 +455,7 @@ default boolean reset() {
    * @param code the error code
    * @return {@code true} when reset has been performed
    */
-  boolean reset(long code);
+  Future<Void> reset(long code);
 
   /**
    * Reset this request:
@@ -472,7 +472,7 @@ default boolean reset() {
    * @param cause an optional cause that can be attached to the error code
    * @return true when reset has been performed
    */
-  boolean reset(long code, Throwable cause);
+  Future<Void> reset(long code, Throwable cause);
 
   /**
    * @return the {@link HttpConnection} associated with this request

File: vertx-core/src/main/java/io/vertx/core/http/HttpServerResponse.java
Patch:
@@ -468,7 +468,7 @@ default Future<HttpServerResponse> push(HttpMethod method, String path) {
   /**
    * Reset this HTTP/2 stream with the error code {@code 0}.
    */
-  default boolean reset() {
+  default Future<Void> reset() {
     return reset(0L);
   }
 
@@ -485,7 +485,7 @@ default boolean reset() {
    * @param code the error code
    * @return {@code true} when reset has been performed
    */
-  boolean reset(long code);
+  Future<Void> reset(long code);
 
   /**
    * Write an HTTP/2 frame to the response, allowing to extend the HTTP/2 protocol.<p>

File: vertx-core/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java
Patch:
@@ -693,14 +693,14 @@ public int streamId() {
   }
 
   @Override
-  public boolean reset(long code) {
+  public Future<Void> reset(long code) {
     synchronized (conn) {
       if (written) {
-        return false;
+        return context.failedFuture("Response written");
       }
     }
     conn.close();
-    return true;
+    return context.succeededFuture();
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/http/impl/Http2ServerConnection.java
Patch:
@@ -177,7 +177,7 @@ protected synchronized void onHeadersRead(int streamId, Http2Headers headers, St
         stream = createStream(headers, endOfStream);
       }
       if (isMalformedRequest(stream)) {
-        handler.writeReset(streamId, Http2Error.PROTOCOL_ERROR.code());
+        handler.writeReset(streamId, Http2Error.PROTOCOL_ERROR.code(), null);
         return;
       }
       initStream(streamId, stream);

File: vertx-core/src/main/java/io/vertx/core/http/impl/Http2ServerResponse.java
Patch:
@@ -608,9 +608,8 @@ public int streamId() {
   }
 
   @Override
-  public boolean reset(long code) {
-    stream.writeReset(code);
-    return true;
+  public Future<Void> reset(long code) {
+    return stream.writeReset(code);
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -80,7 +80,7 @@ default Future<Void> end() {
   void doPause();
   void doFetch(long amount);
 
-  void reset(Throwable cause);
+  Future<Void> reset(Throwable cause);
 
   StreamPriority priority();
   void updatePriority(StreamPriority streamPriority);

File: vertx-core/src/main/java/io/vertx/core/http/impl/StatisticsGatheringHttpClientStream.java
Patch:
@@ -171,8 +171,8 @@ public void doFetch(long amount) {
   }
 
   @Override
-  public void reset(Throwable cause) {
-    delegate.reset(cause);
+  public Future<Void> reset(Throwable cause) {
+    return delegate.reset(cause);
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java
Patch:
@@ -287,8 +287,9 @@ void writeFrame(Http2Stream stream, byte type, short flags, ByteBuf payload, Fut
     checkFlush();
   }
 
-  void writeReset(int streamId, long code) {
-    encoder().writeRstStream(chctx, streamId, code, chctx.newPromise());
+  void writeReset(int streamId, long code, FutureListener<Void> listener) {
+    ChannelPromise promise = listener == null ? chctx.voidPromise() : chctx.newPromise().addListener(listener);
+    encoder().writeRstStream(chctx, streamId, code, promise);
     checkFlush();
   }
 

File: vertx-core/src/test/java/io/vertx/tests/http/Http2Test.java
Patch:
@@ -227,7 +227,7 @@ public void testResetClientRequestNotYetSent() throws Exception {
     startServer(testAddress);
     client.request(requestOptions).onComplete(onSuccess(req -> {
       req.response().onComplete(onFailure(err -> complete()));
-      assertTrue(req.reset());
+      assertTrue(req.reset().succeeded());
     }));
     await();
   }

File: vertx-core/src/test/java/io/vertx/tests/http/HttpTest.java
Patch:
@@ -4455,8 +4455,8 @@ class MockReq implements HttpClientRequest {
       public Future<Void> end(Buffer chunk) { throw new UnsupportedOperationException(); }
       public HttpClientRequest idleTimeout(long timeoutMs) { throw new UnsupportedOperationException(); }
       public HttpClientRequest pushHandler(Handler<HttpClientRequest> handler) { throw new UnsupportedOperationException(); }
-      public boolean reset(long code) { return false; }
-      public boolean reset(long code, Throwable cause) { return false; }
+      public Future<Void> reset(long code) { return Future.failedFuture(new UnsupportedOperationException()); }
+      public Future<Void> reset(long code, Throwable cause) { return Future.failedFuture(new UnsupportedOperationException()); }
       public HttpClientConnection connection() { throw new UnsupportedOperationException(); }
       public Future<Void> writeCustomFrame(int type, int flags, Buffer payload) { throw new UnsupportedOperationException(); }
       public boolean writeQueueFull() { throw new UnsupportedOperationException(); }
@@ -6276,7 +6276,7 @@ public void testClientRequestFlowControlDifferentEventLoops() throws Exception {
     client = vertx.createHttpClient(createBaseClientOptions(), new PoolOptions().setHttp1MaxSize(1));
     Buffer chunk = Buffer.buffer(TestUtils.randomAlphaString(1024));
     client.request(requestOptions).onComplete(onSuccess(req1 -> {
-      assertTrue(req1.reset());
+      assertTrue(req1.reset().succeeded());
       new Thread(() -> {
         Context ctx = vertx.getOrCreateContext();
         ctx.runOnContext(v1 -> {

File: vertx-core/src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -604,7 +604,7 @@ public int getCompressionContentSizeThreshold() {
   }
 
   /**
-   * Set the compression content size threshold if compression is enabled.
+   * Set the compression content size threshold if compression is enabled. This is only applicable for HTTP/1.x response bodies.
    * If the response content size in bytes is greater than this threshold, then the response is compressed. Otherwise, it is not compressed.
    *
    * @param compressionContentSizeThreshold integer greater than or equal to 0.

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpChunkContentCompressor.java
Patch:
@@ -26,8 +26,8 @@
  */
 final class HttpChunkContentCompressor extends HttpContentCompressor {
 
-  public HttpChunkContentCompressor(CompressionOptions... compressionOptions) {
-    super(0, compressionOptions);
+  public HttpChunkContentCompressor(int contentSizeThreshold, CompressionOptions... compressionOptions) {
+    super(contentSizeThreshold, compressionOptions);
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerConnectionInitializer.java
Patch:
@@ -52,6 +52,7 @@ class HttpServerConnectionInitializer {
   private final Handler<Throwable> exceptionHandler;
   private final Object metric;
   private final CompressionOptions[] compressionOptions;
+  private final int compressionContentSizeThreshold;
   private final Function<String, String> encodingDetector;
 
   HttpServerConnectionInitializer(ContextInternal context,
@@ -87,6 +88,7 @@ class HttpServerConnectionInitializer {
     this.exceptionHandler = exceptionHandler;
     this.metric = metric;
     this.compressionOptions = compressionOptions;
+    this.compressionContentSizeThreshold = options.getCompressionContentSizeThreshold();
     this.encodingDetector = compressionOptions != null ? new EncodingDetector(options.getCompressionContentSizeThreshold(), compressionOptions)::determineEncoding : null;
   }
 
@@ -236,7 +238,7 @@ private void configureHttp1Pipeline(ChannelPipeline pipeline, SslChannelProvider
       pipeline.addBefore(name, "inflater", new HttpContentDecompressor(false));
     }
     if (options.isCompressionSupported()) {
-      pipeline.addBefore(name, "deflater", new HttpChunkContentCompressor(compressionOptions));
+      pipeline.addBefore(name, "deflater", new HttpChunkContentCompressor(compressionContentSizeThreshold, compressionOptions));
     }
   }
 

File: vertx-core/src/test/java/io/vertx/tests/http/compression/HttpCompressionTest.java
Patch:
@@ -35,7 +35,7 @@
 
 public abstract class HttpCompressionTest extends HttpTestBase {
 
-  private static final String COMPRESS_TEST_STRING = "/*\n" +
+  protected static final String COMPRESS_TEST_STRING = "/*\n" +
       " * Copyright (c) 2011-2016 The original author or authors\n" +
       " * ------------------------------------------------------\n" +
       " * All rights reserved. This program and the accompanying materials\n" +
@@ -51,7 +51,7 @@ public abstract class HttpCompressionTest extends HttpTestBase {
       " * You may elect to redistribute this code under either of these licenses.\n" +
       " */";
 
-  private Buffer compressedTestString;
+  protected Buffer compressedTestString;
 
   public HttpCompressionTest() {
   }

File: vertx-core/src/main/java/io/vertx/core/spi/transport/Transport.java
Patch:
@@ -16,7 +16,6 @@
 import io.netty.channel.*;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.InternetProtocolFamily;
-import io.vertx.core.buffer.impl.PartialPooledByteBufAllocator;
 import io.vertx.core.datagram.DatagramSocketOptions;
 import io.vertx.core.impl.transports.NioTransport;
 import io.vertx.core.net.ClientOptionsBase;

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -22,11 +22,11 @@
 import io.netty.util.concurrent.GenericFutureListener;
 import io.vertx.core.Future;
 import io.vertx.core.Promise;
-import io.vertx.core.buffer.impl.PartialPooledByteBufAllocator;
 import io.vertx.core.internal.ContextInternal;
 import io.vertx.core.internal.CloseSequence;
 import io.vertx.core.internal.VertxInternal;
 import io.vertx.core.internal.PromiseInternal;
+import io.vertx.core.impl.buffer.VertxByteBufAllocator;
 import io.vertx.core.internal.logging.Logger;
 import io.vertx.core.internal.logging.LoggerFactory;
 import io.vertx.core.internal.net.NetClientInternal;
@@ -282,7 +282,7 @@ private void connectInternal2(ConnectOptions connectOptions,
       Objects.requireNonNull(connectHandler, "No null connectHandler accepted");
       Bootstrap bootstrap = new Bootstrap();
       bootstrap.group(eventLoop);
-      bootstrap.option(ChannelOption.ALLOCATOR, PartialPooledByteBufAllocator.INSTANCE);
+      bootstrap.option(ChannelOption.ALLOCATOR, VertxByteBufAllocator.POOLED_ALLOCATOR);
 
       SocketAddress remoteAddress = connectOptions.getRemoteAddress();
       if (remoteAddress == null) {

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -11,7 +11,6 @@
 package io.vertx.core.net.impl;
 
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.PooledByteBufAllocator;
 import io.netty.channel.*;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.ChannelGroupFuture;
@@ -32,6 +31,7 @@
 import io.vertx.core.internal.ContextInternal;
 import io.vertx.core.internal.PromiseInternal;
 import io.vertx.core.internal.VertxInternal;
+import io.vertx.core.impl.buffer.VertxByteBufAllocator;
 import io.vertx.core.internal.logging.Logger;
 import io.vertx.core.internal.logging.LoggerFactory;
 import io.vertx.core.internal.tls.SslContextManager;
@@ -510,7 +510,7 @@ private void bind(
     if (options.isSsl()) {
       bootstrap.childOption(ChannelOption.ALLOCATOR, PartialPooledByteBufAllocator.INSTANCE);
     } else {
-      bootstrap.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
+      bootstrap.childOption(ChannelOption.ALLOCATOR, VertxByteBufAllocator.POOLED_ALLOCATOR);
     }
 
     bootstrap.childHandler(channelBalancer);

File: vertx-core/src/test/java/io/vertx/tests/deployment/VirtualThreadDeploymentTest.java
Patch:
@@ -192,9 +192,7 @@ public Future<?> start() throws Exception {
                   .compose(HttpClientRequest::send)
                   .await();
               } catch (Throwable e) {
-                if (e instanceof InterruptedException) {
-                  interruptedThreads.add(Thread.currentThread());
-                }
+                interruptedThreads.add(Thread.currentThread());
               }
             });
           }

File: vertx-core/src/test/java/io/vertx/tests/deployment/VirtualThreadDeploymentTest.java
Patch:
@@ -192,9 +192,7 @@ public Future<?> start() throws Exception {
                   .compose(HttpClientRequest::send)
                   .await();
               } catch (Throwable e) {
-                if (e instanceof InterruptedException) {
-                  interruptedThreads.add(Thread.currentThread());
-                }
+                interruptedThreads.add(Thread.currentThread());
               }
             });
           }

File: vertx-core/src/main/java/io/vertx/core/http/impl/Http2ServerStream.java
Patch:
@@ -50,13 +50,14 @@ class Http2ServerStream extends VertxHttp2Stream<Http2ServerConnection> {
 
   Http2ServerStream(Http2ServerConnection conn,
                     ContextInternal context,
+                    Http2Headers headers,
                     HttpMethod method,
                     String uri,
                     TracingPolicy tracingPolicy,
                     boolean halfClosedRemote) {
     super(conn, context);
 
-    this.headers = null;
+    this.headers = headers;
     this.method = method;
     this.uri = uri;
     this.scheme = null;

File: vertx-core/src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandlerBuilder.java
Patch:
@@ -147,7 +147,7 @@ private void configureStreamByteDistributor() {
   protected VertxHttp2ConnectionHandler<C> build(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder, Http2Settings initialSettings) throws Exception {
     if (server) {
       if (compressionOptions != null) {
-        encoder = new CompressorHttp2ConnectionEncoder(encoder, compressionOptions);
+        encoder = new VertxCompressorHttp2ConnectionEncoder(encoder, compressionOptions);
       }
       VertxHttp2ConnectionHandler<C> handler = new VertxHttp2ConnectionHandler<>(connectionFactory, useDecompression, decoder, encoder, initialSettings);
       decoder.frameListener(handler);

File: vertx-core/src/main/generated/io/vertx/core/http/WebSocketConnectOptionsConverter.java
Patch:
@@ -16,7 +16,7 @@ static void fromJson(Iterable<java.util.Map.Entry<String, Object>> json, WebSock
       switch (member.getKey()) {
         case "version":
           if (member.getValue() instanceof String) {
-            obj.setVersion(io.vertx.core.http.WebsocketVersion.valueOf((String)member.getValue()));
+            obj.setVersion(io.vertx.core.http.WebSocketVersion.valueOf((String)member.getValue()));
           }
           break;
         case "subProtocols":

File: vertx-core/src/main/java/io/vertx/core/http/WebSocketVersion.java
Patch:
@@ -19,6 +19,6 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public enum WebsocketVersion {
+public enum WebSocketVersion {
   V00, V07, V08, V13
 }

File: vertx-core/src/main/java/io/vertx/core/http/impl/WebSocketClientImpl.java
Patch:
@@ -93,7 +93,7 @@ public Future<WebSocket> webSocket(WebSocketConnectOptions options) {
     return webSocket(vertx.getOrCreateContext(), options);
   }
 
-  static WebSocketConnectOptions webSocketConnectOptionsAbs(String url, MultiMap headers, WebsocketVersion version, List<String> subProtocols) {
+  static WebSocketConnectOptions webSocketConnectOptionsAbs(String url, MultiMap headers, WebSocketVersion version, List<String> subProtocols) {
     URI uri;
     try {
       uri = new URI(url);
@@ -126,7 +126,7 @@ static WebSocketConnectOptions webSocketConnectOptionsAbs(String url, MultiMap h
       .setSubProtocols(subProtocols);
   }
 
-  public Future<WebSocket> webSocketAbs(String url, MultiMap headers, WebsocketVersion version, List<String> subProtocols) {
+  public Future<WebSocket> webSocketAbs(String url, MultiMap headers, WebSocketVersion version, List<String> subProtocols) {
     return webSocket(webSocketConnectOptionsAbs(url, headers, version, subProtocols));
   }
 

File: vertx-core/src/test/java/io/vertx/tests/json/JsonCodecTest.java
Patch:
@@ -13,7 +13,7 @@
 import com.fasterxml.jackson.core.type.TypeReference;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpHeaders;
-import io.vertx.core.http.WebsocketVersion;
+import io.vertx.core.http.WebSocketVersion;
 import io.vertx.core.impl.Utils;
 import io.vertx.core.json.DecodeException;
 import io.vertx.core.json.EncodeException;
@@ -440,10 +440,10 @@ public void testDecodeValue() {
   @Test
   public void testEnumValue() {
     // just a random enum
-    Buffer json = mapper.toBuffer(WebsocketVersion.V13);
+    Buffer json = mapper.toBuffer(WebSocketVersion.V13);
     assertNotNull(json);
     assertEquals("\"V13\"", json.toString());
-    mapper.fromBuffer(json, WebsocketVersion.class);
+    mapper.fromBuffer(json, WebSocketVersion.class);
   }
 
   @Test

File: vertx-core/src/main/java/io/vertx/core/http/impl/Http2ServerStream.java
Patch:
@@ -50,13 +50,14 @@ class Http2ServerStream extends VertxHttp2Stream<Http2ServerConnection> {
 
   Http2ServerStream(Http2ServerConnection conn,
                     ContextInternal context,
+                    Http2Headers headers,
                     HttpMethod method,
                     String uri,
                     TracingPolicy tracingPolicy,
                     boolean halfClosedRemote) {
     super(conn, context);
 
-    this.headers = null;
+    this.headers = headers;
     this.method = method;
     this.uri = uri;
     this.scheme = null;

File: vertx-core/src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandlerBuilder.java
Patch:
@@ -147,7 +147,7 @@ private void configureStreamByteDistributor() {
   protected VertxHttp2ConnectionHandler<C> build(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder, Http2Settings initialSettings) throws Exception {
     if (server) {
       if (compressionOptions != null) {
-        encoder = new CompressorHttp2ConnectionEncoder(encoder, compressionOptions);
+        encoder = new VertxCompressorHttp2ConnectionEncoder(encoder, compressionOptions);
       }
       VertxHttp2ConnectionHandler<C> handler = new VertxHttp2ConnectionHandler<>(connectionFactory, useDecompression, decoder, encoder, initialSettings);
       decoder.frameListener(handler);

File: vertx-core/src/test/java/io/vertx/tests/eventbus/EventBusTestBase.java
Patch:
@@ -517,7 +517,7 @@ public void testNoHandlersCallbackContext() {
       }
       assertTrue("Not an EL thread", Context.isOnEventLoopThread());
       complete();
-    })).await();
+    }));
 
     // On a EL context
     vertices[0].runOnContext(v -> {

File: vertx-core/src/test/java/io/vertx/tests/eventbus/EventBusTestBase.java
Patch:
@@ -517,7 +517,7 @@ public void testNoHandlersCallbackContext() {
       }
       assertTrue("Not an EL thread", Context.isOnEventLoopThread());
       complete();
-    }));
+    })).await();
 
     // On a EL context
     vertices[0].runOnContext(v -> {
@@ -550,7 +550,7 @@ public void start() throws Exception {
           complete();
         }));
       }
-    }, new DeploymentOptions().setThreadingModel(ThreadingModel.WORKER));
+    }, new DeploymentOptions().setThreadingModel(ThreadingModel.WORKER)).await();
 
     // Inside executeBlocking
     vertices[0].executeBlocking(() -> {

File: vertx-core/src/main/java/io/vertx/core/datagram/DatagramPacket.java
Patch:
@@ -11,16 +11,16 @@
 
 package io.vertx.core.datagram;
 
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.core.buffer.Buffer;
-import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.net.SocketAddress;
 
 /**
  * A received datagram packet (UDP) which contains the data and information about the sender of the data itself.
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-@VertxGen
+@DataObject
 public interface DatagramPacket {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/dns/MxRecord.java
Patch:
@@ -11,14 +11,14 @@
 
 package io.vertx.core.dns;
 
-import io.vertx.codegen.annotations.VertxGen;
+import io.vertx.codegen.annotations.DataObject;
 
 /**
  * Represent a Mail-Exchange-Record (MX) which was resolved for a domain.
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-@VertxGen
+@DataObject
 public interface MxRecord {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/dns/SrvRecord.java
Patch:
@@ -11,15 +11,15 @@
 
 package io.vertx.core.dns;
 
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.Nullable;
-import io.vertx.codegen.annotations.VertxGen;
 
 /**
  * Represent a Service-Record (SRV) which was resolved for a domain.
  *
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-@VertxGen
+@DataObject
 public interface SrvRecord {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/file/FileProps.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.core.file;
 
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.VertxGen;
 
 /**
@@ -19,7 +20,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@VertxGen
+@DataObject
 public interface FileProps {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/file/FileSystemProps.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.core.file;
 
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.VertxGen;
 
 /**
@@ -19,7 +20,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@VertxGen
+@DataObject
 public interface FileSystemProps {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/http/Cookie.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.core.http;
 
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.codegen.annotations.VertxGen;
@@ -21,7 +22,7 @@
  * <p>
  * All cookies must have a name and a value and can optionally have other fields set such as path, domain, etc.
  */
-@VertxGen
+@DataObject
 public interface Cookie {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/http/HttpFrame.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.http;
 
 import io.vertx.codegen.annotations.CacheReturn;
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.buffer.Buffer;
 
@@ -20,7 +21,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@VertxGen
+@DataObject
 public interface HttpFrame {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/http/WebSocketFrame.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.http;
 
 import io.vertx.codegen.annotations.CacheReturn;
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.impl.ws.WebSocketFrameImpl;
@@ -31,7 +32,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
  */
-@VertxGen
+@DataObject
 public interface WebSocketFrame {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/net/SelfSignedCertificate.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.core.net;
 
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.net.impl.SelfSignedCertificateImpl;
 
@@ -21,7 +22,7 @@
  *
  * @author <a href="https://julien.ponge.org/">Julien Ponge</a>
  */
-@VertxGen
+@DataObject
 public interface SelfSignedCertificate {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/parsetools/JsonEvent.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.parsetools;
 
 import com.fasterxml.jackson.core.type.TypeReference;
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.GenIgnore;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.buffer.Buffer;
@@ -25,7 +26,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@VertxGen
+@DataObject
 public interface JsonEvent {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -172,7 +172,7 @@ public Future<HttpServer> listen() {
 
   @Override
   public synchronized Future<HttpServer> listen(SocketAddress address) {
-    if (requestHandler == null && webSocketHandler == null) {
+    if (requestHandler == null && webSocketHandler == null && webSocketHandhakeHandler == null) {
       throw new IllegalStateException("Set request or WebSocket handler first");
     }
     if (tcpServer != null) {

File: vertx-core/src/test/java/io/vertx/tests/context/ContextTaskTest.java
Patch:
@@ -180,17 +180,14 @@ private void testOpFromAnotherEventLoop(BiConsumer<ContextInternal, Handler<Void
     waitFor(2);
     ContextInternal ctx = contextSupplier.get();
     createEventLoopContext().nettyEventLoop().execute(() -> {
-      AtomicBoolean flag = new AtomicBoolean(true);
       op.accept(ctx, v2 -> {
         if (isSchedule) {
           assertNull(Vertx.currentContext());
         } else {
           assertSame(ctx, Vertx.currentContext());
         }
-        assertFalse(flag.get());
         complete();
       });
-      flag.set(false);
       complete();
     });
     await();

File: vertx-core/src/test/java/io/vertx/tests/tracing/EventBusTracingTestBase.java
Patch:
@@ -170,8 +170,8 @@ private void testRequestReply(TracingPolicy policy, boolean create, boolean fail
     assertSingleTrace(finishedSpans);
     finishedSpans.forEach(span -> {
       assertEquals("send", span.operation);
-      assertEquals("vertx-eventbus", span.getTags().get("message_bus.system"));
-      assertEquals("publish", span.getTags().get("message_bus.operation"));
+      assertEquals("vertx-eventbus", span.getTags().get("messaging.system"));
+      assertEquals("send", span.getTags().get("messaging.operation.name"));
     });
   }
 

File: vertx-core/src/main/java/io/vertx/core/Closeable.java
Patch:
@@ -25,5 +25,6 @@ public interface Closeable {
    *
    * @param completion the promise to signal when close has completed
    */
+  // SHOULD BE COMPLETABLE HERE
   void close(Promise<Void> completion);
 }

File: vertx-core/src/main/java/io/vertx/core/impl/deployment/Deployment.java
Patch:
@@ -183,7 +183,9 @@ public Future<?> undeploy() {
     for (Instance instance : instances) {
       Promise<Object> startPromise = instance.startPromise;
       if (startPromise != null) {
-        startPromise.tryFail(new VertxException("Verticle un-deployed", true));
+        if (startPromise.tryFail(new VertxException("Verticle un-deployed", true))) {
+          undeployFutures.add(instance.closeFuture.future());
+        }
       } else {
         ContextInternal context = instance.context;
         Promise<Object> p = Promise.promise();

File: vertx-core/src/main/java/io/vertx/core/impl/DuplicatedContext.java
Patch:
@@ -15,7 +15,7 @@
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.ThreadingModel;
-import io.vertx.core.impl.deployment.Deployment;
+import io.vertx.core.impl.deployment.DeploymentContext;
 import io.vertx.core.internal.CloseFuture;
 import io.vertx.core.internal.ContextInternal;
 import io.vertx.core.internal.EventExecutor;
@@ -86,8 +86,8 @@ public EventLoop nettyEventLoop() {
   }
 
   @Override
-  public Deployment getDeployment() {
-    return delegate.getDeployment();
+  public DeploymentContext deployment() {
+    return delegate.deployment();
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/impl/ShadowContext.java
Patch:
@@ -13,7 +13,7 @@
 import io.netty.channel.EventLoop;
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.core.*;
-import io.vertx.core.impl.deployment.Deployment;
+import io.vertx.core.impl.deployment.DeploymentContext;
 import io.vertx.core.internal.CloseFuture;
 import io.vertx.core.internal.ContextInternal;
 import io.vertx.core.internal.EventExecutor;
@@ -76,7 +76,7 @@ public EventLoop nettyEventLoop() {
   }
 
   @Override
-  public Deployment getDeployment() {
+  public DeploymentContext deployment() {
     return null;
   }
 

File: vertx-core/src/test/java/io/vertx/tests/context/ContextTest.java
Patch:
@@ -449,7 +449,7 @@ public void testDuplicateTwice() throws Exception {
 
   private void checkDuplicate(ContextInternal ctx, ContextInternal duplicated) throws Exception {
     assertSame(ctx.nettyEventLoop(), duplicated.nettyEventLoop());
-    assertSame(ctx.getDeployment(), duplicated.getDeployment());
+    assertSame(ctx.deployment(), duplicated.deployment());
     assertSame(ctx.classLoader(), duplicated.classLoader());
     assertSame(ctx.owner(), duplicated.owner());
     Object shared = new Object();

File: vertx-core/src/test/java/io/vertx/tests/deployment/ClasspathVerticleFactory.java
Patch:
@@ -11,8 +11,8 @@
 
 package io.vertx.tests.deployment;
 
+import io.vertx.core.Deployable;
 import io.vertx.core.Promise;
-import io.vertx.core.Verticle;
 import io.vertx.core.Vertx;
 import io.vertx.core.spi.VerticleFactory;
 
@@ -33,7 +33,7 @@ public String prefix() {
   }
 
   @Override
-  public void createVerticle(String verticleName, ClassLoader classLoader, Promise<Callable<Verticle>> promise) {
+  public void createVerticle2(String verticleName, ClassLoader classLoader, Promise<Callable<? extends Deployable>> promise) {
     promise.complete();
   }
 

File: vertx-core/src/test/java/io/vertx/tests/vertx/AccessEventBusFromInitVerticleFactory.java
Patch:
@@ -11,8 +11,8 @@
 
 package io.vertx.tests.vertx;
 
+import io.vertx.core.Deployable;
 import io.vertx.core.Promise;
-import io.vertx.core.Verticle;
 import io.vertx.core.Vertx;
 import io.vertx.core.spi.VerticleFactory;
 
@@ -37,7 +37,7 @@ public String prefix() {
   }
 
   @Override
-  public void createVerticle(String verticleName, ClassLoader classLoader, Promise<Callable<Verticle>> promise) {
+  public void createVerticle2(String verticleName, ClassLoader classLoader, Promise<Callable<? extends Deployable>> promise) {
     promise.complete();
   }
 

File: vertx-core/src/main/java/io/vertx/core/AsyncResult.java
Patch:
@@ -66,7 +66,7 @@ public interface AsyncResult<T> {
    * @param mapper the mapper function
    * @return the mapped async result
    */
-  default <U> AsyncResult<U> map(Function<T, U> mapper) {
+  default <U> AsyncResult<U> map(Function<? super T, U> mapper) {
     if (mapper == null) {
       throw new NullPointerException();
     }

File: vertx-core/src/main/java/io/vertx/core/CompositeFuture.java
Patch:
@@ -30,13 +30,13 @@ public interface CompositeFuture extends Future<CompositeFuture> {
   CompositeFuture onComplete(Handler<AsyncResult<CompositeFuture>> handler);
 
   @Override
-  default CompositeFuture onSuccess(Handler<CompositeFuture> handler) {
+  default CompositeFuture onSuccess(Handler<? super CompositeFuture> handler) {
     Future.super.onSuccess(handler);
     return this;
   }
 
   @Override
-  default CompositeFuture onFailure(Handler<Throwable> handler) {
+  default CompositeFuture onFailure(Handler<? super Throwable> handler) {
     Future.super.onFailure(handler);
     return this;
   }

File: vertx-core/src/main/java/io/vertx/core/http/impl/Http2UpgradeClientConnection.java
Patch:
@@ -514,7 +514,7 @@ private void doWriteHead(HttpRequestHead head,
                              boolean end,
                              StreamPriority priority,
                              boolean connect,
-                             Handler<AsyncResult<Void>> handler) {
+                             Promise<Void> promise) {
       EventExecutor exec = upgradingConnection.channelHandlerContext().executor();
       if (exec.inEventLoop()) {
         upgradingStream.writeHead(head, chunked, buf, end, priority, connect);
@@ -523,7 +523,7 @@ private void doWriteHead(HttpRequestHead head,
           pipeline.fireUserEventTriggered(SEND_BUFFERED_MESSAGES);
         }
       } else {
-        exec.execute(() -> doWriteHead(head, chunked, buf, end, priority, connect, handler));
+        exec.execute(() -> doWriteHead(head, chunked, buf, end, priority, connect, promise));
       }
     }
 

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -335,7 +335,7 @@ private void handleDrained(Void v) {
     context.dispatch(handler);
   }
 
-  private void handleNextRequest(HttpClientRequest next, Handler<AsyncResult<HttpClientResponse>> handler, long timeoutMs) {
+  private void handleNextRequest(HttpClientRequest next, Promise<HttpClientResponse> handler, long timeoutMs) {
     next.response().onComplete(handler);
     next.exceptionHandler(exceptionHandler());
     exceptionHandler(null);

File: vertx-core/src/main/java/io/vertx/core/impl/future/Operation.java
Patch:
@@ -22,4 +22,5 @@ abstract class Operation<T> extends FutureImpl<T> {
   protected Operation(ContextInternal context) {
     super(context);
   }
+
 }

File: vertx-core/src/main/java/io/vertx/core/internal/PromiseInternal.java
Patch:
@@ -11,8 +11,11 @@
 package io.vertx.core.internal;
 
 import io.netty.util.concurrent.FutureListener;
+import io.vertx.core.Future;
 import io.vertx.core.Promise;
 
+import java.util.function.BiConsumer;
+
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */

File: vertx-core/src/test/java/io/vertx/tests/streams/PipeTest.java
Patch:
@@ -11,6 +11,7 @@
 package io.vertx.tests.streams;
 
 import io.vertx.core.AsyncResult;
+import io.vertx.core.Handler;
 import io.vertx.core.Promise;
 import io.vertx.core.VertxException;
 import io.vertx.core.streams.Pipe;
@@ -273,7 +274,7 @@ public void testPipeCloseFailsTheResult() {
     FakeStream<Object> src = new FakeStream<>();
     Pipe<Object> pipe = src.pipe();
     List<AsyncResult<Void>> res = new ArrayList<>();
-    pipe.to(dst).onComplete(res::add);
+    pipe.to(dst).onComplete(event -> res.add(event));
     assertEquals(Collections.emptyList(), res);
     pipe.close();
     assertEquals(1, res.size());

File: vertx-core/src/test/java/io/vertx/test/fakedns/FakeDNSServer.java
Patch:
@@ -333,7 +333,7 @@ public void messageReceived(IoSession session, Object message) {
     };
 
     UdpTransport udpTransport = new UdpTransport(ipAddress, port);
-    ((DatagramSessionConfig)udpTransport.getAcceptor().getSessionConfig()).setReuseAddress(true);
+    udpTransport.getAcceptor().getSessionConfig().setReuseAddress(true);
     TcpTransport tcpTransport = new TcpTransport(ipAddress, port);
     tcpTransport.getAcceptor().getSessionConfig().setReuseAddress(true);
 

File: vertx-core/src/test/java/io/vertx/tests/http/Http2Test.java
Patch:
@@ -190,7 +190,6 @@ public void testClientRequestWriteFromOtherThread() throws Exception {
     await();
   }
 
-  @Ignore("does not pass with modules")
   @Test
   public void testServerOpenSSL() throws Exception {
     HttpServerOptions opts = new HttpServerOptions()
@@ -972,7 +971,6 @@ public void testUnsupportedAlpnVersion() throws Exception {
     testUnsupportedAlpnVersion(new JdkSSLEngineOptions(), false);
   }
 
-  @Ignore("does not pass in modules")
   @Test
   public void testUnsupportedAlpnVersionOpenSSL() throws Exception {
     testUnsupportedAlpnVersion(new OpenSSLEngineOptions(), true);

File: vertx-core/src/test/java/io/vertx/tests/net/NetTest.java
Patch:
@@ -932,7 +932,7 @@ public void testConnectInvalidPort() {
   }
 
   @Test
-  public void testConnectInvalidHost() {
+  public void testConnectInvwalidHost() {
     assertNullPointerException(() -> client.connect(80, null));
     client.connect(1234, "127.0.0.2").onComplete(onFailure(err -> testComplete()));
     await();

File: vertx-core/src/test/java/io/vertx/tests/tls/SslContextManagerTest.java
Patch:
@@ -54,7 +54,6 @@ public void testUseJdkCiphersWhenNotSpecified() throws Exception {
     await();
   }
 
-  @Ignore
   @Test
   public void testUseOpenSSLCiphersWhenNotSpecified() throws Exception {
     Set<String> expected = OpenSsl.availableOpenSslCipherSuites();
@@ -67,13 +66,11 @@ public void testUseOpenSSLCiphersWhenNotSpecified() throws Exception {
     await();
   }
 
-  @Ignore("native loading")
   @Test
   public void testDefaultOpenSslServerSessionContext() throws Exception {
     testOpenSslServerSessionContext(true);
   }
 
-  @Ignore("native loading")
   @Test
   public void testUserSetOpenSslServerSessionContext() throws Exception {
     testOpenSslServerSessionContext(false);

File: vertx-core/src/test/java/io/vertx/tests/eventbus/EventBusTestBase.java
Patch:
@@ -459,10 +459,10 @@ public void testReplyFromWorker() throws Exception {
     String expectedBody = TestUtils.randomAlphaString(20);
     Vertx[] vertices = vertices(2);
     CountDownLatch latch = new CountDownLatch(1);
-    vertices[0].deployVerticle(new AbstractVerticle() {
+    vertices[1].deployVerticle(new AbstractVerticle() {
       @Override
-      public void start() throws Exception {
-        vertices[1].eventBus().<String>consumer(ADDRESS1, msg -> {
+      public void start() {
+        vertx.eventBus().<String>consumer(ADDRESS1, msg -> {
           msg.reply(expectedBody);
         }).completion().onComplete(ar -> {
           assertTrue(ar.succeeded());

File: vertx-core/src/main/java/io/vertx/core/internal/pool/SimpleConnectionPool.java
Patch:
@@ -58,12 +58,12 @@
  *
  * <h3>Connection eviction</h3>
  *
- * Connections can be evicted from the pool with {@link ConnectionPool#evict(Predicate, Handler)}. It
+ * Connections can be evicted from the pool with {@link ConnectionPool#evict(Predicate)}. It
  * can be used to implement keep alive timeout.
  *
  * <h3>Waiter lifecycle</h3>
  *
- * Connection requests are done with {@link ConnectionPool#acquire(ContextInternal, int, Handler)}. Such request
+ * Connection requests are done with {@link ConnectionPool#acquire(ContextInternal, int)}. Such request
  * creates a {@link PoolWaiter}. When such request is made
  *
  * <ul>
@@ -74,7 +74,7 @@
  * </ul>
  *
  * A connection acquisition a {@link PoolWaiter.Listener} can be provided, letting the requester
- * to get a reference on the waiter and later use {@link #cancel(PoolWaiter, Handler)} to cancel
+ * to get a reference on the waiter and later use {@link #cancel(PoolWaiter)} to cancel
  * a request.
  */
 public class SimpleConnectionPool<C> implements ConnectionPool<C> {

File: vertx-core/src/main/java/io/vertx/core/streams/impl/OutboundWriteQueue.java
Patch:
@@ -214,7 +214,7 @@ public int add(E element) {
     if (WIP_UPDATER.compareAndSet(this, 0, 1)) {
       if (!consumer.test(element)) {
         overflow = element;
-        return DRAIN_REQUIRED_MASK | (WIP_UPDATER.get(this) == highWaterMark ? QUEUE_UNWRITABLE_MASK : 0);
+        return DRAIN_REQUIRED_MASK;
       }
       if (consume(1) == 0) {
         return 0;

File: vertx-core/src/main/java/io/vertx/core/internal/tls/SslContextProvider.java
Patch:
@@ -324,9 +324,9 @@ public void configureEngine(SSLEngine engine, Set<String> enabledProtocols, Stri
     Set<String> protocols = new LinkedHashSet<>(enabledProtocols);
     protocols.retainAll(Arrays.asList(engine.getSupportedProtocols()));
     engine.setEnabledProtocols(protocols.toArray(new String[protocols.size()]));
-    if (client && endpointIdentificationAlgorithm != null && !endpointIdentificationAlgorithm.isEmpty()) {
+    if (client) {
       SSLParameters sslParameters = engine.getSSLParameters();
-      sslParameters.setEndpointIdentificationAlgorithm(endpointIdentificationAlgorithm);
+      sslParameters.setEndpointIdentificationAlgorithm(endpointIdentificationAlgorithm != null ? endpointIdentificationAlgorithm : "");
       engine.setSSLParameters(sslParameters);
     }
     if (serverName != null) {

File: vertx-core/src/main/java/io/vertx/core/Promise.java
Patch:
@@ -44,7 +44,7 @@ static <T> Promise<T> promise() {
    *
    * @param asyncResult the async result to handle
    */
-  @GenIgnore
+  @GenIgnore(GenIgnore.PERMITTED_TYPE)
   @Override
   default void handle(AsyncResult<T> asyncResult) {
     if (asyncResult.succeeded()) {

File: vertx-core/src/main/java/module-info.java
Patch:
@@ -77,6 +77,7 @@
   // Internal API
 
   exports io.vertx.core.internal;
+  exports io.vertx.core.internal.http;
   exports io.vertx.core.internal.buffer;
   exports io.vertx.core.internal.net;
   exports io.vertx.core.internal.net.endpoint;
@@ -107,6 +108,5 @@
   exports io.vertx.core.impl.transports to io.vertx.tests;
   exports io.vertx.core.net.impl.pkcs1 to io.vertx.tests;
   exports io.vertx.core.spi.cluster.impl.selector to io.vertx.tests;
-  exports io.vertx.core.internal.http to io.vertx.tests;
 
 }

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -98,7 +98,6 @@ protected void writeQueueDrained() {
             conn.consumeCredits(this.stream, len);
           }
         });
-        bytesRead += data.length();
         handleData(data);
       }
     });
@@ -146,6 +145,7 @@ void onHeaders(Http2Headers headers, StreamPriority streamPriority) {
   }
 
   void onData(Buffer data) {
+    bytesRead += data.length();
     conn.reportBytesRead(data.length());
     context.execute(data, pending::write);
   }
@@ -237,10 +237,10 @@ public void cancel(Throwable cause) {
   }
 
   void doWriteHeaders(Http2Headers headers, boolean end, boolean checkFlush, Promise<Void> promise) {
-    conn.handler.writeHeaders(stream, headers, end, priority.getDependency(), priority.getWeight(), priority.isExclusive(), checkFlush, (FutureListener<Void>) promise);
     if (end) {
       endWritten();
     }
+    conn.handler.writeHeaders(stream, headers, end, priority.getDependency(), priority.getWeight(), priority.isExclusive(), checkFlush, (FutureListener<Void>) promise);
   }
 
   protected void endWritten() {
@@ -273,10 +273,10 @@ void doWriteData(ByteBuf buf, boolean end, Promise<Void> promise) {
     int numOfBytes = chunk.readableBytes();
     bytesWritten += numOfBytes;
     conn.reportBytesWritten(numOfBytes);
-    conn.handler.writeData(stream, chunk, end, (FutureListener<Void>) promise);
     if (end) {
       endWritten();
     }
+    conn.handler.writeData(stream, chunk, end, (FutureListener<Void>) promise);
   }
 
   final void writeReset(long code) {

File: src/main/java/io/vertx/core/http/HttpConnection.java
Patch:
@@ -157,7 +157,9 @@ default Future<Void> shutdown() {
    *
    * @return a future notified when the client is closed
    */
-  Future<Void> close();
+  default Future<Void> close() {
+    return shutdown(0, TimeUnit.SECONDS);
+  }
 
   /**
    * @return the latest server settings acknowledged by the remote endpoint - this is not implemented for HTTP/1.x

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -270,7 +270,7 @@ protected void initChannel(ChannelPipeline pipeline, boolean ssl) {
     if (options.getLogActivity()) {
       pipeline.addLast("logging", new LoggingHandler(options.getActivityLogDataFormat()));
     }
-    if (ssl || !vertx.transport().supportFileRegion() || (options.getTrafficShapingOptions() != null && options.getTrafficShapingOptions().getOutboundGlobalBandwidth() > 0)) {
+    if (ssl || !options.isFileRegionEnabled() || !vertx.transport().supportFileRegion() || (options.getTrafficShapingOptions() != null && options.getTrafficShapingOptions().getOutboundGlobalBandwidth() > 0)) {
       // only add ChunkedWriteHandler when SSL is enabled or FileRegion isn't supported or when outbound traffic shaping is enabled
       pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());       // For large file / sendfile support
     }

File: src/main/java/io/vertx/core/http/impl/WebSocketConnection.java
Patch:
@@ -198,7 +198,7 @@ void handleWsFrame(WebSocketFrame msg) {
       }
     }
     if (w != null) {
-      w.context().execute(frame, w::handleFrame);
+      w.handleFrame(frame);
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -363,7 +363,7 @@ void handleFrame(WebSocketFrameInternal frame) {
       case PONG:
         Handler<Buffer> pongHandler = pongHandler();
         if (pongHandler != null) {
-          context.dispatch(frame.binaryData(), pongHandler);
+          context.emit(frame.binaryData(), pongHandler);
         }
         break;
       case CLOSE:
@@ -404,10 +404,10 @@ private void handleClose() {
       textConsumer.unregister();
     }
     if (exceptionHandler != null && !graceful) {
-      context.dispatch(HttpUtils.CONNECTION_CLOSED_EXCEPTION, exceptionHandler);
+      context.emit(HttpUtils.CONNECTION_CLOSED_EXCEPTION, exceptionHandler);
     }
     if (closeHandler != null) {
-      context.dispatch(null, closeHandler);
+      context.emit(null, closeHandler);
     }
   }
 

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -2029,7 +2029,6 @@ public void testRaceConditionWithWebSocketClientEventLoop() {
     testRaceConditionWithWebSocketClient(vertx.getOrCreateContext());
   }
 
-  @Ignore
   @Test
   public void testRaceConditionWithWebSocketClientWorker() throws Exception {
     CompletableFuture<Context> fut = new CompletableFuture<>();
@@ -2141,7 +2140,6 @@ private void testRaceConditionWithWebSocketClient(Context context) {
     await();
   }
 
-  @Ignore
   @Test
   public void testRaceConditionWithWebSocketClientWorker2() throws Exception {
     int size = getOptions().getWorkerPoolSize() - 4;
@@ -2164,7 +2162,6 @@ public void testRaceConditionWithWebSocketClientWorker2() throws Exception {
     await();
   }
 
-  @Ignore
   @Test
   public void testWorker() {
     waitFor(2);

File: src/test/benchmarks/io/vertx/core/http/impl/HttpServerHandlerBenchmark.java
Patch:
@@ -74,7 +74,7 @@ public static void consume(final ByteBuf buf) {
 
   static class Alloc implements ByteBufAllocator {
 
-    private final ByteBuf buf = Unpooled.buffer();
+    private final ByteBuf buf = Unpooled.buffer(512);
     private final int capacity = buf.capacity();
 
     @Override
@@ -88,7 +88,7 @@ public ByteBuf buffer(int initialCapacity) {
       if (initialCapacity <= capacity) {
         return buffer();
       } else {
-        throw new IllegalArgumentException();
+        throw new IllegalArgumentException("Invalid capacity " + initialCapacity + " > " + capacity);
       }
     }
 

File: src/main/java/io/vertx/core/http/impl/HttpServerRequestWrapper.java
Patch:
@@ -142,8 +142,8 @@ public String getParamsCharset() {
   }
 
   @Override
-  public MultiMap params() {
-    return delegate.params();
+  public MultiMap params(boolean semicolonIsNormalChar) {
+    return delegate.params(semicolonIsNormalChar);
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/HttpUtils.java
Patch:
@@ -539,8 +539,8 @@ static String absoluteURI(String serverOrigin, HttpServerRequest req) {
     return absoluteURI;
   }
 
-  static MultiMap params(String uri, Charset charset) {
-    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(uri, charset);
+  static MultiMap params(String uri, Charset charset, boolean semicolonIsNormalChar) {
+    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(uri, charset, true, 1024, semicolonIsNormalChar);
     Map<String, List<String>> prms = queryStringDecoder.parameters();
     MultiMap params = MultiMap.caseInsensitiveMultiMap();
     if (!prms.isEmpty()) {

File: src/test/java/io/vertx/core/http/headers/VertxHttpHeadersTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.function.Function;
 import java.util.Set;
 
-import static io.vertx.core.http.HttpUtilsTest.HEADER_NAME_ALLOWED_CHARS;
+import static io.vertx.core.http.impl.HttpUtilsTest.HEADER_NAME_ALLOWED_CHARS;
 import static org.junit.Assert.*;
 
 /**

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -162,7 +162,7 @@ private Future<Deployment> doDeploy(String identifier,
         workerPool = vertx.createSharedWorkerPool(options.getWorkerPoolName(), options.getWorkerPoolSize(), options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit());
       }
     } else {
-      if (!VertxInternal.isVirtualThreadAvailable()) {
+      if (!vertx.isVirtualThreadAvailable()) {
         return callingContext.failedFuture("This Java runtime does not support virtual threads");
       }
     }

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -239,7 +239,5 @@ default <T> Future<T> executeBlockingInternal(Callable<T> blockingCodeHandler, b
   /**
    * @return whether virtual threads are available
    */
-  static boolean isVirtualThreadAvailable() {
-    return VertxImpl.VIRTUAL_THREAD_FACTORY != null;
-  }
+  boolean isVirtualThreadAvailable();
 }

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -1007,7 +1007,7 @@ public void testAwaitFromWorkerThread() {
 
   @Test
   public void testAwaitFromVirtualThreadThread() {
-    Assume.assumeTrue(VertxInternal.isVirtualThreadAvailable());
+    Assume.assumeTrue(isVirtualThreadAvailable());
     testAwaitFromContextThread(ThreadingModel.VIRTUAL_THREAD, false);
   }
 
@@ -1031,7 +1031,7 @@ public void start() {
 
   @Test
   public void testInterruptThreadOnAwait() {
-    Assume.assumeTrue(VertxInternal.isVirtualThreadAvailable());
+    Assume.assumeTrue(isVirtualThreadAvailable());
     vertx.deployVerticle(() -> new AbstractVerticle() {
       @Override
       public void start() {

File: src/test/java/io/vertx/core/eventbus/VirtualThreadEventBusTest.java
Patch:
@@ -29,7 +29,7 @@ public void setUp() throws Exception {
 
   @Test
   public void testEventBus() {
-    Assume.assumeTrue(VertxInternal.isVirtualThreadAvailable());
+    Assume.assumeTrue(isVirtualThreadAvailable());
     EventBus eb = vertx.eventBus();
     eb.consumer("test-addr", msg -> {
       msg.reply(msg.body());

File: src/test/java/io/vertx/core/http/VirtualThreadHttpTest.java
Patch:
@@ -35,7 +35,7 @@ public void setUp() throws Exception {
 
   @Test
   public void testHttpClient1() throws Exception {
-    Assume.assumeTrue(VertxInternal.isVirtualThreadAvailable());
+    Assume.assumeTrue(isVirtualThreadAvailable());
     HttpServer server = vertx.createHttpServer();
     server.requestHandler(req -> {
       req.response().end("Hello World");
@@ -57,7 +57,7 @@ public void testHttpClient1() throws Exception {
 
   @Test
   public void testHttpClient2() throws Exception {
-    Assume.assumeTrue(VertxInternal.isVirtualThreadAvailable());
+    Assume.assumeTrue(isVirtualThreadAvailable());
     waitFor(100);
     HttpServer server = vertx.createHttpServer();
     server.requestHandler(req -> {
@@ -90,7 +90,7 @@ public void testHttpClient2() throws Exception {
 
   @Test
   public void testHttpClientTimeout() throws Exception {
-    Assume.assumeTrue(VertxInternal.isVirtualThreadAvailable());
+    Assume.assumeTrue(isVirtualThreadAvailable());
     HttpServer server = vertx.createHttpServer();
     server.requestHandler(req -> {
     });

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java
Patch:
@@ -64,6 +64,7 @@ public class Http2ServerRequest extends HttpServerRequestInternal implements Htt
   private HttpEventHandler eventHandler;
   private boolean ended;
   private Handler<HttpServerFileUpload> uploadHandler;
+  private boolean expectMultipart;
   private HttpPostRequestDecoder postRequestDecoder;
   private Handler<HttpFrame> customFrameHandler;
   private Handler<StreamPriority> streamPriorityHandler;
@@ -397,6 +398,7 @@ public Future<NetSocket> toNetSocket() {
   public HttpServerRequest setExpectMultipart(boolean expect) {
     synchronized (stream.conn) {
       checkEnded();
+      expectMultipart = expect;
       if (expect) {
         if (postRequestDecoder == null) {
           String contentType = headersMap.get(HttpHeaderNames.CONTENT_TYPE);
@@ -431,7 +433,7 @@ public HttpServerRequest setExpectMultipart(boolean expect) {
   @Override
   public boolean isExpectMultipart() {
     synchronized (stream.conn) {
-      return postRequestDecoder != null;
+      return expectMultipart;
     }
   }
 

File: src/test/java/io/vertx/core/http/HttpServerFileUploadTest.java
Patch:
@@ -304,6 +304,7 @@ private void testFormUploadFile(String filename,
         req.endHandler(v -> {
           MultiMap attrs = req.formAttributes();
           attributeCount.set(attrs.size());
+          assertTrue(req.isExpectMultipart());
           req.response().end();
         });
       }

File: src/test/java/io/vertx/test/proxy/HttpProxy.java
Patch:
@@ -166,7 +166,7 @@ public HttpProxy start(Vertx vertx) throws Exception {
             }
             resp.body().onComplete(ar2 -> {
               if (ar2.succeeded()) {
-                request.response().end(ar2.result());
+                request.response().setStatusCode(resp.statusCode()).end(ar2.result());
               } else {
                 request.response().setStatusCode(500).end(ar2.cause().toString() + " on client request");
               }

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -76,7 +76,7 @@ public NetClientImpl(VertxInternal vertx, TCPMetrics metrics, NetClientOptions o
     CloseSequence closeSequence1 = new CloseSequence(this::doClose, this::doGrace, this::doShutdown);
 
     this.vertx = vertx;
-    this.channelGroup = new DefaultChannelGroup(vertx.getAcceptorEventLoopGroup().next());
+    this.channelGroup = new DefaultChannelGroup(vertx.getAcceptorEventLoopGroup().next(), true);
     this.options = new NetClientOptions(options);
     this.sslHelper = new SSLHelper(SSLHelper.resolveEngineOptions(options.getSslEngineOptions(), options.isUseAlpn()));
     this.metrics = metrics;

File: src/main/java/io/vertx/core/net/impl/ServerChannelLoadBalancer.java
Patch:
@@ -40,7 +40,7 @@ class ServerChannelLoadBalancer extends ChannelInitializer<Channel> {
 
   ServerChannelLoadBalancer(EventExecutor executor) {
     this.workers = new VertxEventLoopGroup();
-    this.channelGroup = new DefaultChannelGroup(executor);
+    this.channelGroup = new DefaultChannelGroup(executor, true);
   }
 
   public VertxEventLoopGroup workers() {

File: src/main/java/io/vertx/core/impl/ContextLocalImpl.java
Patch:
@@ -24,6 +24,6 @@ public ContextLocalImpl(int index) {
   }
 
   public ContextLocalImpl() {
-    this.index = KeySeq.next();
+    this.index = LocalSeq.next();
   }
 }

File: src/main/java/io/vertx/core/impl/LocalSeq.java
Patch:
@@ -15,7 +15,7 @@
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-class KeySeq {
+class LocalSeq {
 
   // 0 : reserved slot for local context map
   private static final AtomicInteger seq = new AtomicInteger(1);

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -195,7 +195,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
     ExecutorService internalWorkerExec = executorServiceFactory.createExecutor(internalWorkerThreadFactory, internalBlockingPoolSize, internalBlockingPoolSize);
     PoolMetrics internalBlockingPoolMetrics = metrics != null ? metrics.createPoolMetrics("worker", "vert.x-internal-blocking", internalBlockingPoolSize) : null;
 
-    contextLocals = KeySeq.get();
+    contextLocals = LocalSeq.get();
     closeFuture = new CloseFuture(log);
     maxEventLoopExecTime = maxEventLoopExecuteTime;
     maxEventLoopExecTimeUnit = maxEventLoopExecuteTimeUnit;

File: src/main/java/io/vertx/core/spi/context/storage/AccessMode.java
Patch:
@@ -15,12 +15,12 @@
 import java.util.function.Supplier;
 
 /**
- * Defines the access mode of a context locals
+ * Defines the access mode of a context local storage.
  */
 public interface AccessMode {
 
   /**
-   * This access mode provides concurrent access to context locals with thread safety and atomicity.
+   * This access mode provides concurrent access to context local storage with thread safety and atomicity.
    */
   AccessMode CONCURRENT = new AccessMode() {
 

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -56,7 +56,7 @@ public void setUp() throws Exception {
 
   @Override
   protected void tearDown() throws Exception {
-    ContextKeyHelper.reset();
+    ContextLocalHelper.reset();
     workerExecutor.shutdown();
     super.tearDown();
   }
@@ -449,7 +449,7 @@ private void checkDuplicate(ContextInternal ctx, ContextInternal duplicated) thr
     Object shared = new Object();
     Object local = new Object();
     ctx.put("key", shared);
-    ctx.putLocal(contextLocal, local);
+    contextLocal.put(ctx, local);
     assertSame(shared, duplicated.get("key"));
     assertNull(duplicated.getLocal(contextLocal));
     assertTrue(duplicated.remove("key"));

File: src/test/java/io/vertx/core/impl/ContextLocalHelper.java
Patch:
@@ -13,13 +13,13 @@
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-public class ContextKeyHelper {
+public class ContextLocalHelper {
 
   /**
-   * Reset the context keys, only available for testing purpose.
+   * Reset the context locals, only available for testing purpose.
    */
   public static void reset() {
-    KeySeq.reset();
+    LocalSeq.reset();
   }
 
 }

File: src/test/java/io/vertx/core/spi/tracing/HttpTracerTestBase.java
Patch:
@@ -17,7 +17,7 @@
 import io.vertx.core.http.HttpTestBase;
 import io.vertx.core.http.RequestOptions;
 import io.vertx.core.impl.ContextInternal;
-import io.vertx.core.impl.ContextKeyHelper;
+import io.vertx.core.impl.ContextLocalHelper;
 import io.vertx.core.spi.context.storage.ContextLocal;
 import io.vertx.core.spi.observability.HttpRequest;
 import io.vertx.core.spi.observability.HttpResponse;
@@ -42,7 +42,7 @@ public void setUp() throws Exception {
 
   @Override
   protected void tearDown() throws Exception {
-    ContextKeyHelper.reset();
+    ContextLocalHelper.reset();
     super.tearDown();
   }
 

File: src/test/java/io/vertx/it/CustomContextLocalTest.java
Patch:
@@ -11,7 +11,7 @@ public void testResolver() {
     assertTrue(CustomContextLocal.initialized);
     Context context = vertx.getOrCreateContext();
     Object o = new Object();
-    context.putLocal(CustomContextLocal.CUSTOM_LOCAL, o);
-    assertSame(o, context.getLocal(CustomContextLocal.CUSTOM_LOCAL));
+    CustomContextLocal.CUSTOM_LOCAL.put(context, o);
+    assertSame(o, CustomContextLocal.CUSTOM_LOCAL.get(context));
   }
 }

File: src/test/java/io/vertx/it/CustomContextLocal.java
Patch:
@@ -4,9 +4,9 @@
 import io.vertx.core.spi.VertxServiceProvider;
 import io.vertx.core.spi.context.storage.ContextLocal;
 
-public class CustomContextKey implements VertxServiceProvider  {
+public class CustomContextLocal implements VertxServiceProvider  {
 
-  public static ContextLocal<Object> CUSTOM_KEY = ContextLocal.registerLocal(Object.class);
+  public static ContextLocal<Object> CUSTOM_LOCAL = ContextLocal.registerLocal(Object.class);
   public static volatile boolean initialized;
 
   @Override

File: src/test/java/io/vertx/it/CustomContextLocalTest.java
Patch:
@@ -8,10 +8,10 @@ public class CustomContextLocalTest extends VertxTestBase {
 
   @Test
   public void testResolver() {
-    assertTrue(CustomContextKey.initialized);
+    assertTrue(CustomContextLocal.initialized);
     Context context = vertx.getOrCreateContext();
     Object o = new Object();
-    context.putLocal(CustomContextKey.CUSTOM_KEY, o);
-    assertSame(o, context.getLocal(CustomContextKey.CUSTOM_KEY));
+    context.putLocal(CustomContextLocal.CUSTOM_LOCAL, o);
+    assertSame(o, context.getLocal(CustomContextLocal.CUSTOM_LOCAL));
   }
 }

File: src/main/java/examples/NetExamples.java
Patch:
@@ -597,10 +597,10 @@ public void exampleSSLEngine(Vertx vertx, JksOptions keyStoreOptions) {
       setSslEngineOptions(new OpenSSLEngineOptions());
   }
 
-  public void example46(Vertx vertx, JksOptions keyStoreOptions) {
+  public void example46(Vertx vertx, String verificationAlgorithm) {
     NetClientOptions options = new NetClientOptions().
       setSsl(true).
-      setHostnameVerificationAlgorithm("HTTPS");
+      setHostnameVerificationAlgorithm(verificationAlgorithm);
     NetClient client = vertx.createNetClient(options);
   }
 

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -75,7 +75,9 @@ public class ClusteredEventBus extends EventBusImpl {
   public ClusteredEventBus(VertxInternal vertx, VertxOptions options, ClusterManager clusterManager, NodeSelector nodeSelector) {
     super(vertx);
 
-    NetClient client = createNetClient(vertx, new NetClientOptions(options.getEventBusOptions().toJson()));
+    NetClient client = createNetClient(vertx, new NetClientOptions(options.getEventBusOptions().toJson())
+      .setHostnameVerificationAlgorithm("")
+    );
 
     this.options = options.getEventBusOptions();
     this.clusterManager = clusterManager;

File: src/main/java/io/vertx/core/net/ClientSSLOptions.java
Patch:
@@ -26,9 +26,9 @@
 public class ClientSSLOptions extends SSLOptions {
 
   /**
-   * Default value to determine hostname verification algorithm hostname verification (for SSL/TLS) = ""
+   * Default value to determine hostname verification algorithm hostname verification (for SSL/TLS) = null
    */
-  public static final String DEFAULT_HOSTNAME_VERIFICATION_ALGORITHM = "";
+  public static final String DEFAULT_HOSTNAME_VERIFICATION_ALGORITHM = null;
 
   /**
    * The default value of whether all servers (SSL/TLS) should be trusted = false

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -1197,6 +1197,7 @@ public void testHTTP2ConnectionCloseBeforePrefaceIsReceived() throws Exception {
       .setSslEngineOptions(new JdkSSLEngineOptions())
       .setUseAlpn(true)
       .setSsl(true)
+      .setHostnameVerificationAlgorithm("HTTPS")
       .setTrustOptions(Trust.SERVER_JKS.get())
       .setApplicationLayerProtocols(Collections.singletonList("h2")));
     CountDownLatch latch = new CountDownLatch(1);

File: src/main/java/io/vertx/core/dns/AddressResolverOptions.java
Patch:
@@ -78,7 +78,7 @@ public class AddressResolverOptions {
   /**
    * The default value of search domains = null
    */
-  public static final List<String> DEFAULT_SEACH_DOMAINS = null;
+  public static final List<String> DEFAULT_SEARCH_DOMAINS = null;
 
   /**
    * The default ndots value = loads the value from the OS on Linux otherwise use the value 1
@@ -120,7 +120,7 @@ public AddressResolverOptions() {
     queryTimeout = DEFAULT_QUERY_TIMEOUT;
     maxQueries = DEFAULT_MAX_QUERIES;
     rdFlag = DEFAULT_RD_FLAG;
-    searchDomains = DEFAULT_SEACH_DOMAINS;
+    searchDomains = DEFAULT_SEARCH_DOMAINS;
     ndots = DEFAULT_NDOTS;
     rotateServers = DEFAULT_ROTATE_SERVERS;
     roundRobinInetAddress = DEFAULT_ROUND_ROBIN_INET_ADDRESS;

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -187,7 +187,7 @@ public void testOptions() {
     assertEquals(AddressResolverOptions.DEFAULT_MAX_QUERIES, options.getMaxQueries());
     assertEquals(AddressResolverOptions.DEFAULT_RD_FLAG, options.getRdFlag());
     assertEquals(AddressResolverOptions.DEFAULT_NDOTS, options.getNdots());
-    assertEquals(AddressResolverOptions.DEFAULT_SEACH_DOMAINS, options.getSearchDomains());
+    assertEquals(AddressResolverOptions.DEFAULT_SEARCH_DOMAINS, options.getSearchDomains());
 
     boolean optResourceEnabled = TestUtils.randomBoolean();
     List<String> servers = Arrays.asList("1.2.3.4", "5.6.7.8");
@@ -277,7 +277,7 @@ public void testOptions() {
     options.setMaxQueries(AddressResolverOptions.DEFAULT_MAX_QUERIES);
     options.setRdFlag(AddressResolverOptions.DEFAULT_RD_FLAG);
     options.setNdots(AddressResolverOptions.DEFAULT_NDOTS);
-    options.setSearchDomains(AddressResolverOptions.DEFAULT_SEACH_DOMAINS);
+    options.setSearchDomains(AddressResolverOptions.DEFAULT_SEARCH_DOMAINS);
 
     assertEquals(optResourceEnabled, copy.isOptResourceEnabled());
     assertEquals(servers, copy.getServers());
@@ -313,7 +313,7 @@ public void testDefaultJsonOptions() {
     assertEquals(AddressResolverOptions.DEFAULT_QUERY_TIMEOUT, options.getQueryTimeout());
     assertEquals(AddressResolverOptions.DEFAULT_MAX_QUERIES, options.getMaxQueries());
     assertEquals(AddressResolverOptions.DEFAULT_RD_FLAG, options.getRdFlag());
-    assertEquals(AddressResolverOptions.DEFAULT_SEACH_DOMAINS, options.getSearchDomains());
+    assertEquals(AddressResolverOptions.DEFAULT_SEARCH_DOMAINS, options.getSearchDomains());
     assertEquals(AddressResolverOptions.DEFAULT_NDOTS, options.getNdots());
   }
 

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -1592,7 +1592,7 @@ public void testSharedServersRoundRobin() throws Exception {
     int numServers = VertxOptions.DEFAULT_EVENT_LOOP_POOL_SIZE / 2- 1;
     int numRequests = numServers * 100;
 
-    List<HttpServer> servers = new ArrayList<>();
+    List<HttpServer> servers = Collections.synchronizedList(new ArrayList<>());
     Set<HttpServer> connectedServers = Collections.newSetFromMap(new ConcurrentHashMap<>());
     Map<HttpServer, Integer> requestCount = new ConcurrentHashMap<>();
 
@@ -1673,6 +1673,7 @@ public void testSharedServersRoundRobinWithOtherServerRunningOnDifferentPort() t
     testSharedServersRoundRobin();
   }
 
+  @Repeat(times = 1000)
   @Test
   public void testSharedServersRoundRobinButFirstStartAndStopServer() throws Exception {
     // Start and stop a server on the same port/host before hand to make sure it doesn't interact

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -21,6 +21,7 @@
 import io.vertx.core.http.HttpClient;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpServer;
+import io.vertx.core.http.HttpTestBase;
 import io.vertx.core.impl.HostnameResolver;
 import io.vertx.core.impl.Utils;
 import io.vertx.core.impl.VertxImpl;
@@ -153,11 +154,11 @@ public void testHttp() throws Exception {
     });
     try {
       CountDownLatch listenLatch = new CountDownLatch(1);
-      server.listen(8080, "vertx.io").onComplete(onSuccess(s -> {
+      server.listen(HttpTestBase.DEFAULT_HTTP_PORT, "vertx.io").onComplete(onSuccess(s -> {
         listenLatch.countDown();
       }));
       awaitLatch(listenLatch);
-      client.request(HttpMethod.GET, 8080, "vertx.io", "/somepath").onComplete(onSuccess(req -> {
+      client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "vertx.io", "/somepath").onComplete(onSuccess(req -> {
         req.send().onComplete(onSuccess(resp -> {
           Buffer buffer = Buffer.buffer();
           resp.handler(buffer::appendBuffer);

File: src/test/java/io/vertx/core/file/FileResolverTestBase.java
Patch:
@@ -277,13 +277,13 @@ public void testFileSystemReadDirectory() {
   @Test
   public void testSendFileFromClasspath() {
     waitFor(2);
-    vertx.createHttpServer(new HttpServerOptions().setPort(8080)).requestHandler(res -> {
+    vertx.createHttpServer(new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT)).requestHandler(res -> {
       res.response()
         .sendFile("webroot/somefile.html")
         .onComplete(onSuccess(v -> complete()));
     }).listen().onComplete(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions())
-        .request(HttpMethod.GET, 8080, "localhost", "/")
+        .request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "localhost", "/")
         .compose(req -> req
           .send()
           .andThen(onSuccess(resp -> assertEquals(200, resp.statusCode())))

File: src/test/java/io/vertx/core/http/Http1xClientConnectionTest.java
Patch:
@@ -73,7 +73,7 @@ public void testResetStreamRequestSent() throws Exception {
             stream.reset(cause);
           });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false);
       }));
     }));
     await();
@@ -97,7 +97,7 @@ public void testServerConnectionClose() throws Exception {
           complete();
         });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
       }));
     }));
     await();

File: src/test/java/io/vertx/core/http/Http2ClientTest.java
Patch:
@@ -1851,7 +1851,7 @@ public void testIdleTimoutNoConnections() throws Exception {
   public void testDisableIdleTimeoutClearTextUpgrade() throws Exception {
     server.close();
     server = vertx.createHttpServer(new HttpServerOptions()
-      .setPort(8080)
+      .setPort(DEFAULT_HTTP_PORT)
       .setHost("localhost"));
     server.requestHandler(req -> {
       req.response().end();
@@ -1861,7 +1861,7 @@ public void testDisableIdleTimeoutClearTextUpgrade() throws Exception {
     client = vertx.createHttpClient(new HttpClientOptions()
       .setIdleTimeout(2)
       .setProtocolVersion(HttpVersion.HTTP_2)
-      .setDefaultPort(8080)
+      .setDefaultPort(DEFAULT_HTTP_PORT)
       .setDefaultHost("localhost"));
     client.request(HttpMethod.GET, "/somepath")
       .compose(req -> req.send().compose(HttpClientResponse::body))

File: src/test/java/io/vertx/core/http/HttpClientConnectionTest.java
Patch:
@@ -63,7 +63,7 @@ public void testStreamGet() throws Exception {
         .createStream((ContextInternal) vertx.getOrCreateContext())
         .onComplete(onSuccess(stream -> {
           stream.writeHead(new HttpRequestHead(
-            HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+            HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
           stream.headHandler(resp -> {
             assertEquals(200, resp.statusCode);
             complete();
@@ -95,7 +95,7 @@ public void testConnectionClose() throws Exception {
       });
       conn.createStream((ContextInternal) vertx.getOrCreateContext()).onComplete(onSuccess(stream -> {
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
         stream.headHandler(resp -> {
           fail();
         });

File: src/test/java/io/vertx/core/http/HttpConnectionEarlyResetTest.java
Patch:
@@ -51,14 +51,14 @@ public void setUp() throws Exception {
         resetLatch.countDown();
       });
     ctx.runOnContext(v -> {
-      httpServer.listen(8080).onComplete(onSuccess(server -> listenLatch.countDown()));
+      httpServer.listen(HttpTestBase.DEFAULT_HTTP_PORT).onComplete(onSuccess(server -> listenLatch.countDown()));
     });
     awaitLatch(listenLatch);
   }
 
   @Test
   public void testExceptionCaught() throws Exception {
-    vertx.createNetClient(new NetClientOptions().setSoLinger(0)).connect(8080, "localhost").onComplete(onSuccess(socket -> {
+    vertx.createNetClient(new NetClientOptions().setSoLinger(0)).connect(HttpTestBase.DEFAULT_HTTP_PORT, "localhost").onComplete(onSuccess(socket -> {
       vertx.setTimer(2000, id -> {
         socket.close();
       });

File: src/test/java/io/vertx/core/http/HttpMetricsTestBase.java
Patch:
@@ -154,7 +154,7 @@ public void testHttpMetricsLifecycle() throws Exception {
     awaitLatch(latch);
     client.close();
     AsyncTestBase.assertWaitUntil(() -> metrics.endpoints().isEmpty());
-    assertEquals(null, metrics.connectionCount("localhost:8080"));
+    assertEquals(null, metrics.connectionCount(DEFAULT_HTTP_HOST_AND_PORT));
     AsyncTestBase.assertWaitUntil(() -> !serverMetric.get().socket.connected.get());
     AsyncTestBase.assertWaitUntil(() -> contentLength == serverMetric.get().socket.bytesRead.get());
     AsyncTestBase.assertWaitUntil(() -> contentLength  == serverMetric.get().socket.bytesWritten.get());
@@ -211,14 +211,14 @@ public void testHttpClientLifecycle() throws Exception {
       });
     });
     CountDownLatch listenLatch = new CountDownLatch(1);
-    server.listen(8080, "localhost").onComplete(onSuccess(s -> { listenLatch.countDown(); }));
+    server.listen(HttpTestBase.DEFAULT_HTTP_PORT, "localhost").onComplete(onSuccess(s -> { listenLatch.countDown(); }));
     awaitLatch(listenLatch);
     FakeHttpClientMetrics clientMetrics = FakeMetricsBase.getMetrics(client);
     CountDownLatch responseBeginLatch = new CountDownLatch(1);
     CountDownLatch responseEndLatch = new CountDownLatch(1);
     Future<HttpClientRequest> request = client.request(new RequestOptions()
       .setMethod(HttpMethod.POST)
-      .setPort(8080)
+      .setPort(HttpTestBase.DEFAULT_HTTP_PORT)
       .setHost("localhost")
       .setURI("/somepath")).onComplete(onSuccess(req -> {
       req

File: src/test/java/io/vertx/core/impl/GlobalEventExecutorNotificationTest.java
Patch:
@@ -14,6 +14,7 @@
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.ServerChannel;
 import io.vertx.core.Vertx;
+import io.vertx.core.http.HttpTestBase;
 import io.vertx.core.net.NetClientOptions;
 import io.vertx.core.net.ProxyOptions;
 import io.vertx.core.net.ProxyType;
@@ -107,7 +108,7 @@ public ChannelFactory<? extends ServerChannel> serverChannelFactory(boolean doma
 
     vertx.createHttpServer()
       .requestHandler(req -> fail())
-      .listen(8080, "localhost").onComplete(onFailure(err -> {
+      .listen(HttpTestBase.DEFAULT_HTTP_PORT, "localhost").onComplete(onFailure(err -> {
       testComplete();
     }));
     await();

File: src/test/java/io/vertx/test/proxy/HttpProxy.java
Patch:
@@ -109,7 +109,7 @@ public HttpProxy start(Vertx vertx) throws Exception {
           }
           // deny ports not considered safe to connect
           // this will deny access to e.g. smtp port 25 to avoid spammers
-          if (port == 8080 || port < 1024 && port != 443) {
+          if (port == HttpTestBase.DEFAULT_HTTP_PORT || port < 1024 && port != 443) {
             request.response().setStatusCode(403).end("access to port denied");
             return;
           }

File: src/test/java/io/vertx/test/verticles/SimpleServer.java
Patch:
@@ -15,6 +15,7 @@
 import io.vertx.core.Promise;
 import io.vertx.core.http.HttpServer;
 import io.vertx.core.http.HttpServerOptions;
+import io.vertx.core.http.HttpTestBase;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
@@ -23,7 +24,7 @@ public class SimpleServer extends AbstractVerticle {
 
   @Override
   public void start(Promise<Void> startPromise) throws Exception {
-    HttpServer server = vertx.createHttpServer(new HttpServerOptions().setPort(8080));
+    HttpServer server = vertx.createHttpServer(new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT));
     server.requestHandler(req -> req.response().end());
     server.listen().onComplete(res -> {
       if (res.succeeded()) {

File: src/main/java/io/vertx/core/impl/transports/EpollTransport.java
Patch:
@@ -150,7 +150,7 @@ public void configure(NetServerOptions options, boolean domainSocket, ServerBoot
   }
 
   @Override
-  public void configure(ClientOptionsBase options, boolean domainSocket, Bootstrap bootstrap) {
+  public void configure(ClientOptionsBase options, int connectTimeout, boolean domainSocket, Bootstrap bootstrap) {
     if (!domainSocket) {
       if (options.isTcpFastOpen()) {
         bootstrap.option(ChannelOption.TCP_FASTOPEN_CONNECT, options.isTcpFastOpen());
@@ -159,6 +159,6 @@ public void configure(ClientOptionsBase options, boolean domainSocket, Bootstrap
       bootstrap.option(EpollChannelOption.TCP_QUICKACK, options.isTcpQuickAck());
       bootstrap.option(EpollChannelOption.TCP_CORK, options.isTcpCork());
     }
-    Transport.super.configure(options, domainSocket, bootstrap);
+    Transport.super.configure(options, connectTimeout, domainSocket, bootstrap);
   }
 }

File: src/main/java/io/vertx/core/net/ClientOptionsBase.java
Patch:
@@ -32,7 +32,7 @@
 public abstract class ClientOptionsBase extends TCPSSLOptions {
 
   /**
-   * The default value of connect timeout = 60000 ms
+   * The default value of connect timeout = 60000 (ms)
    */
   public static final int DEFAULT_CONNECT_TIMEOUT = 60000;
 

File: src/main/java/io/vertx/core/spi/transport/Transport.java
Patch:
@@ -145,7 +145,7 @@ default void configure(DatagramChannel channel, DatagramSocketOptions options) {
     }
   }
 
-  default void configure(ClientOptionsBase options, boolean domainSocket, Bootstrap bootstrap) {
+  default void configure(ClientOptionsBase options, int connectTimeout, boolean domainSocket, Bootstrap bootstrap) {
     if (!domainSocket) {
       bootstrap.option(ChannelOption.SO_REUSEADDR, options.isReuseAddress());
       bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());
@@ -167,7 +167,7 @@ default void configure(ClientOptionsBase options, boolean domainSocket, Bootstra
     if (options.getTrafficClass() != -1) {
       bootstrap.option(ChannelOption.IP_TOS, options.getTrafficClass());
     }
-    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, options.getConnectTimeout());
+    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout);
   }
 
   default void configure(NetServerOptions options, boolean domainSocket, ServerBootstrap bootstrap) {

File: src/main/java/io/vertx/core/file/impl/FileCache.java
Patch:
@@ -197,7 +197,7 @@ File cacheFile(String fileName, File resource, boolean overwrite) throws IOExcep
   void cacheFile(String fileName, InputStream is, boolean overwrite) throws IOException {
     File cacheFile = new File(getCacheDir(), fileName);
     fileNameCheck(cacheFile);
-    cacheFile.getParentFile().mkdirs();
+    boolean created = cacheFile.getParentFile().mkdirs();
     if (!overwrite) {
       try {
         Files.copy(is, cacheFile.toPath());

File: src/test/java/io/vertx/core/file/NestedJarFileResolverTest.java
Patch:
@@ -47,11 +47,11 @@ public URL getResource(String name) {
           } else if (name.startsWith("webroot")) {
             return new URL("jar:" + webrootURL + "!/lib/nested.jar!/" + name.substring(7));
           } else if (name.equals("afile.html")) {
-            return new URL("jar:" + webrootURL + "!/lib/nested.jar!afile.html/");
+            return new URL("jar:" + webrootURL + "!/lib/nested.jar!/afile.html");
           } else if (name.equals("afile with spaces.html")) {
-            return new URL("jar:" + webrootURL + "!/lib/nested.jar!afile with spaces.html/");
+            return new URL("jar:" + webrootURL + "!/lib/nested.jar!/afile with spaces.html");
           } else if (name.equals("afilewithspaceatend ")) {
-            return new URL("jar:" + webrootURL + "!/lib/nested.jar!afilewithspaceatend /");
+            return new URL("jar:" + webrootURL + "!/lib/nested.jar!/afilewithspaceatend ");
           }
         } catch (MalformedURLException e) {
           throw new AssertionError(e);

File: src/test/java/io/vertx/core/file/NestedZipFileResolverTest.java
Patch:
@@ -47,11 +47,11 @@ public URL getResource(String name) {
           } else if (name.startsWith("webroot")) {
             return new URL("jar:" + webrootURL + "!/lib/nested.zip!/" + name.substring(7));
           } else if (name.equals("afile.html")) {
-            return new URL("jar:" + webrootURL + "!/lib/nested.zip!afile.html/");
+            return new URL("jar:" + webrootURL + "!/lib/nested.zip!/afile.html");
           } else if (name.equals("afile with spaces.html")) {
-            return new URL("jar:" + webrootURL + "!/lib/nested.zip!afile with spaces.html/");
+            return new URL("jar:" + webrootURL + "!/lib/nested.zip!/afile with spaces.html");
           } else if (name.equals("afilewithspaceatend ")) {
-            return new URL("jar:" + webrootURL + "!/lib/nested.zip!afilewithspaceatend /");
+            return new URL("jar:" + webrootURL + "!/lib/nested.zip!/afilewithspaceatend ");
           }
         } catch (MalformedURLException e) {
           throw new AssertionError(e);

File: src/test/java/io/vertx/core/http/Http1xProxyTest.java
Patch:
@@ -547,7 +547,7 @@ private void testWebSocket(HttpServerOptions serverOptions, WebSocketClientOptio
             if (proxied) {
               assertNotNull("request did not go through proxy", proxy.getLastUri());
               if (clientOptions.getProxyOptions().getType() == ProxyType.HTTP) {
-                assertEquals("Host header doesn't contain target host", "localhost:4043", proxy.getLastRequestHeaders().get("Host"));
+                assertEquals("Host header doesn't contain target host", DEFAULT_HTTPS_HOST_AND_PORT, proxy.getLastRequestHeaders().get("Host"));
               }
             } else {
               assertNull("request did go through proxy", proxy.getLastUri());

File: src/test/java/io/vertx/core/http/HttpTestBase.java
Patch:
@@ -38,7 +38,7 @@ public class HttpTestBase extends VertxTestBase {
   public static final String DEFAULT_HTTP_HOST_AND_PORT = DEFAULT_HTTP_HOST + ":" +  DEFAULT_HTTP_PORT;
   public static final String DEFAULT_HTTPS_HOST = "localhost";
   public static final int DEFAULT_HTTPS_PORT = Integer.parseInt(System.getProperty("vertx.httpsPort", "4043"));;
-  public static final String DEFAULT_HTTPS_HOST_AND_PORT = DEFAULT_HTTPS_HOST + ":" +  DEFAULT_HTTPS_PORT;;
+  public static final String DEFAULT_HTTPS_HOST_AND_PORT = DEFAULT_HTTPS_HOST + ":" + DEFAULT_HTTPS_PORT;;
   public static final String DEFAULT_TEST_URI = "some-uri";
 
   protected HttpServer server;

File: src/test/java/io/vertx/core/http/Http1xClientConnectionTest.java
Patch:
@@ -73,7 +73,7 @@ public void testResetStreamRequestSent() throws Exception {
             stream.reset(cause);
           });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false);
       }));
     }));
     await();
@@ -97,7 +97,7 @@ public void testServerConnectionClose() throws Exception {
           complete();
         });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
       }));
     }));
     await();

File: src/test/java/io/vertx/core/http/Http1xProxyTest.java
Patch:
@@ -208,7 +208,7 @@ public void testHttpProxyRequestAuth() throws Exception {
         req.send().onComplete(onSuccess(resp -> {
           assertEquals(200, resp.statusCode());
           assertNotNull("request did not go through proxy", proxy.getLastUri());
-          assertEquals("Host header doesn't contain target host", "localhost:" + DEFAULT_HTTP_PORT, proxy.getLastRequestHeaders().get("Host"));
+          assertEquals("Host header doesn't contain target host", DEFAULT_HTTP_HOST_AND_PORT, proxy.getLastRequestHeaders().get("Host"));
           testComplete();
         }));
       }));
@@ -221,9 +221,9 @@ public void testHttpProxyFtpRequest() throws Exception {
     startProxy(null, ProxyType.HTTP);
     client.close();
     client = vertx.createHttpClient(new HttpClientOptions()
-      .setProxyOptions(new ProxyOptions().setType(ProxyType.HTTP).setHost("localhost").setPort(proxy.port())));
+      .setProxyOptions(new ProxyOptions().setType(ProxyType.HTTP).setHost(DEFAULT_HTTP_HOST).setPort(proxy.port())));
     final String url = "ftp://ftp.gnu.org/gnu/";
-    proxy.setForceUri("http://localhost:" + DEFAULT_HTTP_PORT+ "/");
+    proxy.setForceUri("http://" + DEFAULT_HTTP_HOST_AND_PORT+ "/");
     server.requestHandler(req -> {
       req.response().end();
     });

File: src/test/java/io/vertx/core/http/HttpClientConnectionTest.java
Patch:
@@ -63,7 +63,7 @@ public void testStreamGet() throws Exception {
         .createStream((ContextInternal) vertx.getOrCreateContext())
         .onComplete(onSuccess(stream -> {
           stream.writeHead(new HttpRequestHead(
-            HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+            HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
           stream.headHandler(resp -> {
             assertEquals(200, resp.statusCode);
             complete();
@@ -95,7 +95,7 @@ public void testConnectionClose() throws Exception {
       });
       conn.createStream((ContextInternal) vertx.getOrCreateContext()).onComplete(onSuccess(stream -> {
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), DEFAULT_HTTP_HOST_AND_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
         stream.headHandler(resp -> {
           fail();
         });

File: src/test/java/io/vertx/core/http/HttpMetricsTestBase.java
Patch:
@@ -154,7 +154,7 @@ public void testHttpMetricsLifecycle() throws Exception {
     awaitLatch(latch);
     client.close();
     AsyncTestBase.assertWaitUntil(() -> metrics.endpoints().isEmpty());
-    assertEquals(null, metrics.connectionCount("localhost:" + DEFAULT_HTTP_PORT));
+    assertEquals(null, metrics.connectionCount(DEFAULT_HTTP_HOST_AND_PORT));
     AsyncTestBase.assertWaitUntil(() -> !serverMetric.get().socket.connected.get());
     AsyncTestBase.assertWaitUntil(() -> contentLength == serverMetric.get().socket.bytesRead.get());
     AsyncTestBase.assertWaitUntil(() -> contentLength  == serverMetric.get().socket.bytesWritten.get());

File: src/test/java/io/vertx/core/http/HttpTestBase.java
Patch:
@@ -35,10 +35,10 @@ public class HttpTestBase extends VertxTestBase {
 
   public static final String DEFAULT_HTTP_HOST = "localhost";
   public static final int DEFAULT_HTTP_PORT = Integer.parseInt(System.getProperty("vertx.httpPort", "8080"));
-  public static final String DEFAULT_HTTP_HOST_AND_PORT = System.getProperty("vertx.httpHostPort", "localhost:8080");
+  public static final String DEFAULT_HTTP_HOST_AND_PORT = DEFAULT_HTTP_HOST + ":" +  DEFAULT_HTTP_PORT;
   public static final String DEFAULT_HTTPS_HOST = "localhost";
-  public static final int DEFAULT_HTTPS_PORT = 4043;
-  public static final String DEFAULT_HTTPS_HOST_AND_PORT = "localhost:4043";
+  public static final int DEFAULT_HTTPS_PORT = Integer.parseInt(System.getProperty("vertx.httpsPort", "4043"));;
+  public static final String DEFAULT_HTTPS_HOST_AND_PORT = DEFAULT_HTTPS_HOST + ":" +  DEFAULT_HTTPS_PORT;;
   public static final String DEFAULT_TEST_URI = "some-uri";
 
   protected HttpServer server;

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -21,6 +21,7 @@
 import io.vertx.core.http.HttpClient;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpServer;
+import io.vertx.core.http.HttpTestBase;
 import io.vertx.core.impl.HostnameResolver;
 import io.vertx.core.impl.Utils;
 import io.vertx.core.impl.VertxImpl;
@@ -153,11 +154,11 @@ public void testHttp() throws Exception {
     });
     try {
       CountDownLatch listenLatch = new CountDownLatch(1);
-      server.listen(8080, "vertx.io").onComplete(onSuccess(s -> {
+      server.listen(HttpTestBase.DEFAULT_HTTP_PORT, "vertx.io").onComplete(onSuccess(s -> {
         listenLatch.countDown();
       }));
       awaitLatch(listenLatch);
-      client.request(HttpMethod.GET, 8080, "vertx.io", "/somepath").onComplete(onSuccess(req -> {
+      client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "vertx.io", "/somepath").onComplete(onSuccess(req -> {
         req.send().onComplete(onSuccess(resp -> {
           Buffer buffer = Buffer.buffer();
           resp.handler(buffer::appendBuffer);

File: src/test/java/io/vertx/core/file/FileResolverTestBase.java
Patch:
@@ -277,13 +277,13 @@ public void testFileSystemReadDirectory() {
   @Test
   public void testSendFileFromClasspath() {
     waitFor(2);
-    vertx.createHttpServer(new HttpServerOptions().setPort(8080)).requestHandler(res -> {
+    vertx.createHttpServer(new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT)).requestHandler(res -> {
       res.response()
         .sendFile("webroot/somefile.html")
         .onComplete(onSuccess(v -> complete()));
     }).listen().onComplete(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions())
-        .request(HttpMethod.GET, 8080, "localhost", "/")
+        .request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "localhost", "/")
         .compose(req -> req
           .send()
           .andThen(onSuccess(resp -> assertEquals(200, resp.statusCode())))

File: src/test/java/io/vertx/core/http/Http1xClientConnectionTest.java
Patch:
@@ -73,7 +73,7 @@ public void testResetStreamRequestSent() throws Exception {
             stream.reset(cause);
           });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false);
       }));
     }));
     await();
@@ -97,7 +97,7 @@ public void testServerConnectionClose() throws Exception {
           complete();
         });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
       }));
     }));
     await();

File: src/test/java/io/vertx/core/http/Http2ClientTest.java
Patch:
@@ -1851,7 +1851,7 @@ public void testIdleTimoutNoConnections() throws Exception {
   public void testDisableIdleTimeoutClearTextUpgrade() throws Exception {
     server.close();
     server = vertx.createHttpServer(new HttpServerOptions()
-      .setPort(8080)
+      .setPort(DEFAULT_HTTP_PORT)
       .setHost("localhost"));
     server.requestHandler(req -> {
       req.response().end();
@@ -1861,7 +1861,7 @@ public void testDisableIdleTimeoutClearTextUpgrade() throws Exception {
     client = vertx.createHttpClient(new HttpClientOptions()
       .setIdleTimeout(2)
       .setProtocolVersion(HttpVersion.HTTP_2)
-      .setDefaultPort(8080)
+      .setDefaultPort(DEFAULT_HTTP_PORT)
       .setDefaultHost("localhost"));
     client.request(HttpMethod.GET, "/somepath")
       .compose(req -> req.send().compose(HttpClientResponse::body))

File: src/test/java/io/vertx/core/http/HttpClientConnectionTest.java
Patch:
@@ -63,7 +63,7 @@ public void testStreamGet() throws Exception {
         .createStream((ContextInternal) vertx.getOrCreateContext())
         .onComplete(onSuccess(stream -> {
           stream.writeHead(new HttpRequestHead(
-            HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+            HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
           stream.headHandler(resp -> {
             assertEquals(200, resp.statusCode);
             complete();
@@ -95,7 +95,7 @@ public void testConnectionClose() throws Exception {
       });
       conn.createStream((ContextInternal) vertx.getOrCreateContext()).onComplete(onSuccess(stream -> {
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:" + DEFAULT_HTTP_PORT, "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false);
         stream.headHandler(resp -> {
           fail();
         });

File: src/test/java/io/vertx/core/http/HttpConnectionEarlyResetTest.java
Patch:
@@ -51,14 +51,14 @@ public void setUp() throws Exception {
         resetLatch.countDown();
       });
     ctx.runOnContext(v -> {
-      httpServer.listen(8080).onComplete(onSuccess(server -> listenLatch.countDown()));
+      httpServer.listen(HttpTestBase.DEFAULT_HTTP_PORT).onComplete(onSuccess(server -> listenLatch.countDown()));
     });
     awaitLatch(listenLatch);
   }
 
   @Test
   public void testExceptionCaught() throws Exception {
-    vertx.createNetClient(new NetClientOptions().setSoLinger(0)).connect(8080, "localhost").onComplete(onSuccess(socket -> {
+    vertx.createNetClient(new NetClientOptions().setSoLinger(0)).connect(HttpTestBase.DEFAULT_HTTP_PORT, "localhost").onComplete(onSuccess(socket -> {
       vertx.setTimer(2000, id -> {
         socket.close();
       });

File: src/test/java/io/vertx/core/http/HttpMetricsTestBase.java
Patch:
@@ -154,7 +154,7 @@ public void testHttpMetricsLifecycle() throws Exception {
     awaitLatch(latch);
     client.close();
     AsyncTestBase.assertWaitUntil(() -> metrics.endpoints().isEmpty());
-    assertEquals(null, metrics.connectionCount("localhost:8080"));
+    assertEquals(null, metrics.connectionCount("localhost:" + DEFAULT_HTTP_PORT));
     AsyncTestBase.assertWaitUntil(() -> !serverMetric.get().socket.connected.get());
     AsyncTestBase.assertWaitUntil(() -> contentLength == serverMetric.get().socket.bytesRead.get());
     AsyncTestBase.assertWaitUntil(() -> contentLength  == serverMetric.get().socket.bytesWritten.get());
@@ -211,14 +211,14 @@ public void testHttpClientLifecycle() throws Exception {
       });
     });
     CountDownLatch listenLatch = new CountDownLatch(1);
-    server.listen(8080, "localhost").onComplete(onSuccess(s -> { listenLatch.countDown(); }));
+    server.listen(HttpTestBase.DEFAULT_HTTP_PORT, "localhost").onComplete(onSuccess(s -> { listenLatch.countDown(); }));
     awaitLatch(listenLatch);
     FakeHttpClientMetrics clientMetrics = FakeMetricsBase.getMetrics(client);
     CountDownLatch responseBeginLatch = new CountDownLatch(1);
     CountDownLatch responseEndLatch = new CountDownLatch(1);
     Future<HttpClientRequest> request = client.request(new RequestOptions()
       .setMethod(HttpMethod.POST)
-      .setPort(8080)
+      .setPort(HttpTestBase.DEFAULT_HTTP_PORT)
       .setHost("localhost")
       .setURI("/somepath")).onComplete(onSuccess(req -> {
       req

File: src/test/java/io/vertx/core/http/HttpTestBase.java
Patch:
@@ -34,7 +34,7 @@
 public class HttpTestBase extends VertxTestBase {
 
   public static final String DEFAULT_HTTP_HOST = "localhost";
-  public static final int DEFAULT_HTTP_PORT = 8080;
+  public static final int DEFAULT_HTTP_PORT = Integer.parseInt(System.getProperty("port", "8080"));
   public static final String DEFAULT_HTTPS_HOST = "localhost";
   public static final int DEFAULT_HTTPS_PORT = 4043;
   public static final String DEFAULT_HTTPS_HOST_AND_PORT = "localhost:4043";

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -3597,7 +3597,7 @@ public void testSetOriginHeaderV13() throws InterruptedException {
 
   @Test
   public void testEnableOriginHeaderV13() throws InterruptedException {
-    testOriginHeader(WebsocketVersion.V13, true, null, HttpHeaders.ORIGIN, "http://localhost:8080");
+    testOriginHeader(WebsocketVersion.V13, true, null, HttpHeaders.ORIGIN, "http://localhost:" + DEFAULT_HTTP_PORT);
   }
 
   @Test
@@ -3612,7 +3612,7 @@ public void testSetOriginHeaderV08() throws InterruptedException {
 
   @Test
   public void testEnableOriginHeaderV08() throws InterruptedException {
-    testOriginHeader(WebsocketVersion.V08, true, null, HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, "http://localhost:8080");
+    testOriginHeader(WebsocketVersion.V08, true, null, HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, "http://localhost:" + DEFAULT_HTTP_PORT);
   }
 
   @Test
@@ -3627,7 +3627,7 @@ public void testSetOriginHeaderV07() throws InterruptedException {
 
   @Test
   public void testEnableOriginHeaderV07() throws InterruptedException {
-    testOriginHeader(WebsocketVersion.V07, true, null, HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, "http://localhost:8080");
+    testOriginHeader(WebsocketVersion.V07, true, null, HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, "http://localhost:" + DEFAULT_HTTP_PORT);
   }
 
   @Test

File: src/test/java/io/vertx/core/http/impl/EndPointKeyTest.java
Patch:
@@ -10,6 +10,7 @@
  */
 package io.vertx.core.http.impl;
 
+import io.vertx.core.http.HttpTestBase;
 import io.vertx.core.net.HostAndPort;
 import io.vertx.core.net.ProxyOptions;
 import io.vertx.core.net.SocketAddress;
@@ -25,8 +26,8 @@ public class EndPointKeyTest {
 
   @Test
   public void testEndPointKey() {
-    final SocketAddress addr = SocketAddress.inetSocketAddress(8080, "localhost");
-    final HostAndPort peer = HostAndPort.create("localhost", 8080);
+    final SocketAddress addr = SocketAddress.inetSocketAddress(HttpTestBase.DEFAULT_HTTP_PORT, "localhost");
+    final HostAndPort peer = HostAndPort.create("localhost", HttpTestBase.DEFAULT_HTTP_PORT);
     EndpointKey key1 = new EndpointKey(false, null, new ProxyOptions(), addr, peer);
     EndpointKey key2 = new EndpointKey(false, null, new ProxyOptions(), addr, peer);
     assertEquals(key1, key2);

File: src/test/java/io/vertx/core/impl/GlobalEventExecutorNotificationTest.java
Patch:
@@ -14,6 +14,7 @@
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.ServerChannel;
 import io.vertx.core.Vertx;
+import io.vertx.core.http.HttpTestBase;
 import io.vertx.core.net.NetClientOptions;
 import io.vertx.core.net.ProxyOptions;
 import io.vertx.core.net.ProxyType;
@@ -107,7 +108,7 @@ public ChannelFactory<? extends ServerChannel> serverChannelFactory(boolean doma
 
     vertx.createHttpServer()
       .requestHandler(req -> fail())
-      .listen(8080, "localhost").onComplete(onFailure(err -> {
+      .listen(HttpTestBase.DEFAULT_HTTP_PORT, "localhost").onComplete(onFailure(err -> {
       testComplete();
     }));
     await();

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -3955,9 +3955,9 @@ protected void startServer(Context context, NetServer server) throws Exception {
 
   @Test
   public void testUnresolvedSocketAddress() {
-    InetSocketAddress a = InetSocketAddress.createUnresolved("localhost", 8080);
+    InetSocketAddress a = InetSocketAddress.createUnresolved("localhost", HttpTestBase.DEFAULT_HTTP_PORT);
     SocketAddress converted = ((VertxInternal) vertx).transport().convert(a);
-    assertEquals(8080, converted.port());
+    assertEquals(HttpTestBase.DEFAULT_HTTP_PORT, converted.port());
     assertEquals("localhost", converted.host());
   }
 

File: src/test/java/io/vertx/core/net/impl/HostAndPortTest.java
Patch:
@@ -1,5 +1,6 @@
 package io.vertx.core.net.impl;
 
+import io.vertx.core.http.HttpTestBase;
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.net.HostAndPort;
 import org.junit.Test;
@@ -64,12 +65,12 @@ public void testParseHost() {
   public void testParseHostAndPort() {
     assertHostAndPort("10.0.0.1.nip.io", -1, "10.0.0.1.nip.io");
     assertHostAndPort("10.0.0.1.nip.io", 8443, "10.0.0.1.nip.io:8443");
-    assertHostAndPort("example.com", 8080, "example.com:8080");
+    assertHostAndPort("example.com", HttpTestBase.DEFAULT_HTTP_PORT, "example.com:" + HttpTestBase.DEFAULT_HTTP_PORT);
     assertHostAndPort("example.com", -1, "example.com");
     assertHostAndPort("0.1.2.3", -1, "0.1.2.3");
     assertHostAndPort("[0::]", -1, "[0::]");
     assertHostAndPort("", -1, "");
-    assertHostAndPort("", 8080, ":8080");
+    assertHostAndPort("", HttpTestBase.DEFAULT_HTTP_PORT, ":" + HttpTestBase.DEFAULT_HTTP_PORT);
     assertNull(HostAndPortImpl.parseHostAndPort("/", -1));
     assertNull(HostAndPortImpl.parseHostAndPort("10.0.0.1:x", -1));
   }

File: src/test/java/io/vertx/test/proxy/HttpProxy.java
Patch:
@@ -109,7 +109,7 @@ public HttpProxy start(Vertx vertx) throws Exception {
           }
           // deny ports not considered safe to connect
           // this will deny access to e.g. smtp port 25 to avoid spammers
-          if (port == 8080 || port < 1024 && port != 443) {
+          if (port == HttpTestBase.DEFAULT_HTTP_PORT || port < 1024 && port != 443) {
             request.response().setStatusCode(403).end("access to port denied");
             return;
           }

File: src/test/java/io/vertx/test/verticles/SimpleServer.java
Patch:
@@ -15,6 +15,7 @@
 import io.vertx.core.Promise;
 import io.vertx.core.http.HttpServer;
 import io.vertx.core.http.HttpServerOptions;
+import io.vertx.core.http.HttpTestBase;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
@@ -23,7 +24,7 @@ public class SimpleServer extends AbstractVerticle {
 
   @Override
   public void start(Promise<Void> startPromise) throws Exception {
-    HttpServer server = vertx.createHttpServer(new HttpServerOptions().setPort(8080));
+    HttpServer server = vertx.createHttpServer(new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT));
     server.requestHandler(req -> req.response().end());
     server.listen().onComplete(res -> {
       if (res.succeeded()) {

File: src/test/java/io/vertx/core/spi/tracing/EventBusTracingTestBase.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2021 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2023 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -14,7 +14,6 @@
 import io.vertx.core.Vertx;
 import io.vertx.core.eventbus.DeliveryOptions;
 import io.vertx.core.tracing.TracingPolicy;
-import io.vertx.test.core.Repeat;
 import io.vertx.test.core.VertxTestBase;
 import io.vertx.test.faketracer.FakeTracer;
 import io.vertx.test.faketracer.Span;
@@ -170,6 +169,8 @@ private void testRequestReply(TracingPolicy policy, boolean create, boolean fail
     assertSingleTrace(finishedSpans);
     finishedSpans.forEach(span -> {
       assertEquals("send", span.operation);
+      assertEquals("vertx-eventbus", span.getTags().get("message_bus.system"));
+      assertEquals("publish", span.getTags().get("message_bus.operation"));
     });
   }
 

File: src/test/java/io/vertx/core/http/headers/VertxHttpHeadersTest.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.HashMap;
 import java.util.function.Consumer;
 import java.util.function.Function;
+import java.util.Set;
 
 import static io.vertx.core.http.HttpUtilsTest.HEADER_NAME_ALLOWED_CHARS;
 import static org.junit.Assert.*;
@@ -129,7 +130,8 @@ public void testSetAll() {
     assertNotNull(result);
     assertFalse(result.isEmpty());
     assertEquals(2, result.size());
-    assertEquals("=\naaa=bbb\n", result.toString());
+    String actual = result.toString();
+    assertTrue(Set.of("=\naaa=bbb\n", "aaa=bbb\n=\n").contains(actual));
   }
 
   @Test

File: src/test/java/io/vertx/core/http/headers/HeadersTestBase.java
Patch:
@@ -69,7 +69,7 @@ public void testAddAll2() {
     HashMap<String, String> map = new HashMap<>();
     map.put("a", "b");
     map.put("c", "d");
-    assertEquals("a=b\nc=d\n", mmap.addAll(map).toString());
+    assertEquals("a=b\nc=d\n", sortByLine(mmap.addAll(map).toString()));
   }
 
   @Test

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.buffer;
 
 
+import io.vertx.codegen.annotations.DataObject;
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.GenIgnore;
 import io.vertx.codegen.annotations.VertxGen;
@@ -35,7 +36,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@VertxGen
+@DataObject
 public interface Buffer extends ClusterSerializable, Shareable {
 
   /**
@@ -123,6 +124,7 @@ static Buffer buffer(byte[] bytes) {
    *
    * @return a JSON element which can be a {@link JsonArray}, {@link JsonObject}, {@link String}, ...etc if the buffer contains an array, object, string, ...etc
    */
+  @GenIgnore
   default Object toJson() {
     return Json.CODEC.fromBuffer(this, Object.class);
   }

File: src/main/java/io/vertx/core/net/impl/HostAndPortImpl.java
Patch:
@@ -30,7 +30,7 @@ static int parseIPv4Address(String s, int from, int to) {
         return -1;
       }
     }
-    return from;
+    return from < to && s.charAt(from + 1) != ':' ? -1 : from;
   }
 
   static int parseDecOctet(String s, int from, int to) {

File: src/main/java/io/vertx/core/dns/impl/decoder/RecordDecoder.java
Patch:
@@ -222,7 +222,7 @@ public static <T> T decode(DnsRecord record) {
         DnsRecordType type = record.type();
         Function<DnsRecord, ?> decoder = decoders.get(type);
         if (decoder == null) {
-            throw new IllegalStateException("Unsupported resource record type [id: " + type + "].");
+            throw new DecoderException("DNS record decoding error occurred: Unsupported resource record type [id: " + type + "].");
         }
         T result = null;
         try {

File: src/main/java/io/vertx/core/dns/impl/decoder/RecordDecoder.java
Patch:
@@ -222,7 +222,7 @@ public static <T> T decode(DnsRecord record) {
         DnsRecordType type = record.type();
         Function<DnsRecord, ?> decoder = decoders.get(type);
         if (decoder == null) {
-            throw new IllegalStateException("Unsupported resource record type [id: " + type + "].");
+            throw new DecoderException("DNS record decoding error occurred: Unsupported resource record type [id: " + type + "].");
         }
         T result = null;
         try {

File: src/main/java/io/vertx/core/net/TrafficShapingOptions.java
Patch:
@@ -127,7 +127,7 @@ public TrafficShapingOptions setCheckIntervalForStats(long checkIntervalForStats
    * @return a reference to this, so the API can be used fluently
    */
   public TrafficShapingOptions setCheckIntervalForStatsTimeUnit(TimeUnit checkIntervalForStatsTimeUnit) {
-    this.maxDelayToWaitTimeUnit = maxDelayToWaitTimeUnit;
+    this.maxDelayToWaitTimeUnit = checkIntervalForStatsTimeUnit;
     return this;
   }
 

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestBase.java
Patch:
@@ -66,7 +66,9 @@ public abstract class HttpClientRequestBase implements HttpClientRequest {
   }
 
   protected String authority() {
-    if ((authority.port() == 80 && !ssl) || (authority.port() == 443 && ssl) || authority.port() < 0) {
+    if (authority == null) {
+      return null;
+    } else if ((authority.port() == 80 && !ssl) || (authority.port() == 443 && ssl) || authority.port() < 0) {
       return authority.host();
     } else {
       return authority.host() + ':' + authority.port();

File: src/main/java/io/vertx/core/net/impl/HostAndPortImpl.java
Patch:
@@ -115,9 +115,6 @@ static boolean isHEXDIG(char ch) {
    */
   public static HostAndPortImpl parseHostAndPort(String s, int schemePort) {
     int pos = parseHost(s, 0, s.length());
-    if (pos < 1) {
-      return null;
-    }
     if (pos == s.length()) {
       return new HostAndPortImpl(s, schemePort);
     }

File: src/test/java/io/vertx/core/net/impl/HostAndPortTest.java
Patch:
@@ -57,7 +57,8 @@ public void testParseHostAndPort() {
     assertHostAndPort("example.com", -1, "example.com");
     assertHostAndPort("0.1.2.3", -1, "0.1.2.3");
     assertHostAndPort("[0::]", -1, "[0::]");
-    assertNull(HostAndPortImpl.parseHostAndPort("", -1));
+    assertHostAndPort("", -1, "");
+    assertHostAndPort("", 8080, ":8080");
     assertNull(HostAndPortImpl.parseHostAndPort("/", -1));
   }
 

File: src/main/java/io/vertx/core/http/impl/HttpClientBuilderImpl.java
Patch:
@@ -70,15 +70,15 @@ public HttpClient build() {
     if (co.isShared()) {
       CloseFuture closeFuture = new CloseFuture();
       client = vertx.createSharedResource("__vertx.shared.httpClients", co.getName(), closeFuture, cf_ -> {
-        io.vertx.core.spi.net.AddressResolver<?, ?, ?> resolver = addressResolver != null ? addressResolver.resolver(vertx) : null;
+        io.vertx.core.spi.net.AddressResolver<?, ?, ?, ?> resolver = addressResolver != null ? addressResolver.resolver(vertx) : null;
         HttpClientImpl impl = new HttpClientImpl(vertx, resolver, co, po);
         cf_.add(completion -> impl.close().onComplete(completion));
         return impl;
       });
       client = new CleanableHttpClient((HttpClientInternal) client, vertx.cleaner(), (timeout, timeunit) -> closeFuture.close());
       closeable = closeFuture;
     } else {
-      io.vertx.core.spi.net.AddressResolver<?, ?, ?> resolver = addressResolver != null ? addressResolver.resolver(vertx) : null;
+      io.vertx.core.spi.net.AddressResolver<?, ?, ?, ?> resolver = addressResolver != null ? addressResolver.resolver(vertx) : null;
       HttpClientImpl impl = new HttpClientImpl(vertx, resolver, co, po);
       closeable = impl;
       client = new CleanableHttpClient(impl, vertx.cleaner(), impl::shutdown);

File: src/main/java/io/vertx/core/net/AddressResolver.java
Patch:
@@ -24,6 +24,6 @@ public interface AddressResolver {
    * @param vertx the vertx instance
    * @return the resolver
    */
-  io.vertx.core.spi.net.AddressResolver<?, ?, ?> resolver(Vertx vertx);
+  io.vertx.core.spi.net.AddressResolver<?, ?, ?, ?> resolver(Vertx vertx);
 
 }

File: src/main/java/io/vertx/core/http/impl/HttpClientBuilderImpl.java
Patch:
@@ -8,7 +8,6 @@
 import io.vertx.core.impl.CloseFuture;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
-import io.vertx.core.net.Address;
 import io.vertx.core.spi.resolver.AddressResolver;
 
 import java.util.function.Function;
@@ -51,8 +50,8 @@ public HttpClientBuilder withRedirectHandler(Function<HttpClientResponse, Future
   }
 
   @Override
-  public <S, A extends Address, M> HttpClientBuilder withAddressResolver(AddressResolver<S, A, M> addressResolver) {
-    this.addressResolver = addressResolver;
+  public HttpClientBuilder withAddressResolver(io.vertx.core.net.AddressResolver addressResolver) {
+    this.addressResolver = (AddressResolver<?, ?, ?>) addressResolver;
     return this;
   }
 

File: src/main/java/io/vertx/core/spi/resolver/AddressResolver.java
Patch:
@@ -26,7 +26,7 @@
  * @param <A> the type of {@link Address} resolved
  * @param <M> the type of metrics, implementations can use {@code Void} when metrics are not managed
  */
-public interface AddressResolver<S, A extends Address, M> {
+public interface AddressResolver<S, A extends Address, M> extends io.vertx.core.net.AddressResolver {
 
   /**
    * Try to cast the {@code address} to an address instance that can be resolved by this resolver instance.

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -352,6 +352,8 @@ public HttpServer createHttpServer(HttpServerOptions serverOptions) {
   @Override
   public WebSocketClient createWebSocketClient(WebSocketClientOptions options) {
     HttpClientOptions o = new HttpClientOptions(options);
+    o.setDefaultHost(options.getDefaultHost());
+    o.setDefaultPort(options.getDefaultPort());
     o.setVerifyHost(options.isVerifyHost());
     o.setShared(options.isShared());
     o.setName(options.getName());    CloseFuture cf = resolveCloseFuture();

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -352,6 +352,8 @@ public HttpServer createHttpServer(HttpServerOptions serverOptions) {
   @Override
   public WebSocketClient createWebSocketClient(WebSocketClientOptions options) {
     HttpClientOptions o = new HttpClientOptions(options);
+    o.setDefaultHost(options.getDefaultHost());
+    o.setDefaultPort(options.getDefaultPort());
     o.setVerifyHost(options.isVerifyHost());
     o.setShared(options.isShared());
     o.setName(options.getName());    CloseFuture cf = resolveCloseFuture();

File: src/main/java/io/vertx/core/impl/Utils.java
Patch:
@@ -44,5 +44,4 @@ public static boolean isLinux() {
   public static boolean isWindows() {
     return isWindows;
   }
-
 }

File: src/test/java/io/vertx/core/net/impl/pool/SynchronizationTest.java
Patch:
@@ -10,7 +10,6 @@
  */
 package io.vertx.core.net.impl.pool;
 
-import io.vertx.core.impl.Utils;
 import io.vertx.test.core.AsyncTestBase;
 import org.junit.Assume;
 import org.junit.Test;

File: src/test/java/io/vertx/test/fakemetrics/FakeHttpServerMetrics.java
Patch:
@@ -15,12 +15,12 @@
 import io.vertx.core.http.HttpServerRequest;
 import io.vertx.core.http.ServerWebSocket;
 import io.vertx.core.http.WebSocketBase;
-import io.vertx.core.impl.ConcurrentHashSet;
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.spi.metrics.HttpServerMetrics;
 import io.vertx.core.spi.observability.HttpRequest;
 import io.vertx.core.spi.observability.HttpResponse;
 
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
@@ -30,7 +30,7 @@
 public class FakeHttpServerMetrics extends FakeTCPMetrics implements HttpServerMetrics<HttpServerMetric, WebSocketMetric, SocketMetric> {
 
   private final ConcurrentMap<WebSocketBase, WebSocketMetric> webSockets = new ConcurrentHashMap<>();
-  private final ConcurrentHashSet<HttpServerMetric> requests = new ConcurrentHashSet<>();
+  private final Set<HttpServerMetric> requests = ConcurrentHashMap.newKeySet();
 
   public WebSocketMetric getWebSocketMetric(ServerWebSocket ws) {
     return webSockets.get(ws);

File: src/main/java/io/vertx/core/net/impl/VertxHandler.java
Patch:
@@ -126,7 +126,7 @@ public C getConnection() {
   @Override
   public void channelWritabilityChanged(ChannelHandlerContext ctx) {
     C conn = getConnection();
-    conn.handleInterestedOpsChanged();
+    conn.handleChannelWritabilityChanged();
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -42,11 +42,9 @@ public class HttpServerImpl extends TCPServerBase implements HttpServer, Closeab
 
   private static final Handler<Throwable> DEFAULT_EXCEPTION_HANDLER = t -> log.trace("Connection failure", t);
 
-  private static final String FLASH_POLICY_HANDLER_PROP_NAME = "vertx.flashPolicyHandler";
   private static final String DISABLE_WEBSOCKETS_PROP_NAME = "vertx.disableWebsockets";
   private static final String DISABLE_H2C_PROP_NAME = "vertx.disableH2c";
 
-  static final boolean USE_FLASH_POLICY_HANDLER = Boolean.getBoolean(FLASH_POLICY_HANDLER_PROP_NAME);
   static final boolean DISABLE_WEBSOCKETS = Boolean.getBoolean(DISABLE_WEBSOCKETS_PROP_NAME);
 
   final HttpServerOptions options;

File: src/test/java/io/vertx/core/VertxTest.java
Patch:
@@ -268,6 +268,7 @@ public void testCascadeCloseHttpClient() throws Exception {
     }
   }
 
+  @Repeat(times = 10)
   @Test
   public void testFinalizeNetClient() throws Exception {
     VertxInternal vertx = (VertxInternal) Vertx.vertx();

File: src/main/java/io/vertx/core/buffer/impl/BufferImpl.java
Patch:
@@ -137,7 +137,7 @@ public double getDouble(int pos) {
   }
 
   public double getDoubleLE(int pos) {
-    checkUpperBound(pos, 4);
+    checkUpperBound(pos, 8);
     return buffer.getDoubleLE(pos);
   }
 

File: src/main/java/io/vertx/core/net/SSLOptions.java
Patch:
@@ -331,7 +331,7 @@ public boolean equals(Object obj) {
     }
     if (obj instanceof SSLOptions) {
       SSLOptions that = (SSLOptions) obj;
-      return sslHandshakeTimeoutUnit.toNanos(sslHandshakeTimeout) == that.sslHandshakeTimeoutUnit.toNanos(sslHandshakeTimeout) &&
+      return sslHandshakeTimeoutUnit.toNanos(sslHandshakeTimeout) == that.sslHandshakeTimeoutUnit.toNanos(that.sslHandshakeTimeout) &&
          Objects.equals(keyCertOptions, that.keyCertOptions) &&
          Objects.equals(trustOptions, that.trustOptions) &&
          Objects.equals(enabledCipherSuites, that.enabledCipherSuites) &&

File: src/main/java/io/vertx/core/http/impl/Http2ServerStream.java
Patch:
@@ -125,14 +125,14 @@ void onEnd(MultiMap trailers) {
   }
 
   @Override
-  void doWriteHeaders(Http2Headers headers, boolean end, Promise<Void> promise) {
+  void doWriteHeaders(Http2Headers headers, boolean end, boolean checkFlush, Promise<Void> promise) {
     if (Metrics.METRICS_ENABLED && !end) {
       HttpServerMetrics metrics = conn.metrics();
       if (metrics != null) {
         metrics.responseBegin(metric, request.response());
       }
     }
-    super.doWriteHeaders(headers, end, promise);
+    super.doWriteHeaders(headers, end, checkFlush, promise);
   }
 
   @Override

File: src/test/java/io/vertx/core/spi/tracing/HttpTracerTestBase.java
Patch:
@@ -66,7 +66,7 @@ public void sendResponse(Context context, Object response, Object payload, Throw
       assertEquals(1, seq.get());
       ContextInternal ctx = (ContextInternal) Vertx.currentContext();
       assertSame(val, ctx.localContextData().get(key));
-      req.response().endHandler(v -> {
+      req.response().closeHandler(v -> {
         assertNull(ctx.localContextData().get(key));
         assertEquals(2, seq.get());
       });

File: src/main/java/io/vertx/core/http/impl/Http2ServerConnection.java
Patch:
@@ -205,7 +205,7 @@ private synchronized void doSendPush(int streamId, HostAndPort authority, HttpMe
     headers_.path(path);
     headers_.scheme(ssl ? "https" : "http");
     if (authority != null) {
-      String s = (ssl && authority.port() == 443) || (!ssl && authority.port() == 80) ? authority.host() : authority.host() + ':' + authority.port();
+      String s = (ssl && authority.port() == 443) || (!ssl && authority.port() == 80) || authority.port() <= 0 ? authority.host() : authority.host() + ':' + authority.port();
       headers_.authority(s);
     }
     if (headers != null) {

File: src/main/java/io/vertx/core/http/impl/HttpUtils.java
Patch:
@@ -512,7 +512,7 @@ static String absoluteURI(String serverOrigin, HttpServerRequest req) throws URI
       HostAndPort authority = req.authority();
       if (authority != null) {
         StringBuilder sb = new StringBuilder(req.scheme()).append("://").append(authority.host());
-        if ((ssl && authority.port() != 443) || (!ssl && authority.port() != 80)) {
+        if (authority.port() > 0 && (ssl && authority.port() != 443) || (!ssl && authority.port() != 80)) {
           sb.append(':').append(authority.port());
         }
         sb.append(uri);

File: src/main/java/io/vertx/core/http/HttpServerRequest.java
Patch:
@@ -136,7 +136,8 @@ default boolean isSSL() {
   String query();
 
   /**
-   * @return the request authority. For HTTP2 it returns the {@literal :authority} pseudo header otherwise it returns the {@literal Host} header
+   * @return the request authority. For HTTP2 it returns the {@literal :authority} pseudo header otherwise it returns the {@literal Host} header.
+   *         When the authority string does not carry a port, the {@link HostAndPort#port()} returns {@code -1} to indicate the scheme port is prevalent.
    */
   @Nullable
   HostAndPort authority();

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -257,7 +257,9 @@ public String query() {
   public synchronized HostAndPort authority() {
     if (authority == null) {
       String host = getHeader(HttpHeaderNames.HOST);
-      authority = HostAndPortImpl.parseHostAndPort(host, isSSL() ? 443 : 80);
+      if (host != null) {
+        authority = HostAndPortImpl.parseHostAndPort(host, -1);
+      }
     }
     return authority;
   }

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponse.java
Patch:
@@ -638,7 +638,7 @@ public Future<HttpServerResponse> push(HttpMethod method, String authority, Stri
     }
     HostAndPort hostAndPort = null;
     if (authority != null) {
-      hostAndPort = HostAndPortImpl.parseHostAndPort(authority, conn.isSsl() ? 443 : 80);
+      hostAndPort = HostAndPortImpl.parseHostAndPort(authority, -1);
     }
     if (hostAndPort == null) {
       hostAndPort = stream.authority;

File: src/main/java/io/vertx/core/http/impl/Http2ServerStream.java
Patch:
@@ -73,7 +73,7 @@ class Http2ServerStream extends VertxHttp2Stream<Http2ServerConnection> {
     }
 
     this.headers = headers;
-    this.authority = HostAndPortImpl.parseHostAndPort(host, conn.isSsl() ? 443 : 80);
+    this.authority = HostAndPortImpl.parseHostAndPort(host, -1);
     this.uri = headers.get(":path") != null ? headers.get(":path").toString() : null;
     this.method = headers.get(":method") != null ? HttpMethod.valueOf(headers.get(":method").toString()) : null;
     this.tracingPolicy = tracingPolicy;

File: src/main/java/io/vertx/core/logging/JULLogDelegateFactory.java
Patch:
@@ -47,6 +47,7 @@ public boolean isAvailable() {
     return true;
   }
 
+  @Override
   public LogDelegate createDelegate(final String name) {
     return new JULLogDelegate(name);
   }

File: src/main/java/io/vertx/core/logging/Log4j2LogDelegateFactory.java
Patch:
@@ -27,6 +27,7 @@ public boolean isAvailable() {
     return LogManager.getLogger(Log4j2LogDelegateFactory.class) != null;
   }
 
+  @Override
   public LogDelegate createDelegate(final String name) {
     return new Log4j2LogDelegate(name);
   }

File: src/main/java/io/vertx/core/logging/SLF4JLogDelegateFactory.java
Patch:
@@ -45,6 +45,7 @@ public boolean isAvailable() {
     return !(fact instanceof NOPLoggerFactory);
   }
 
+  @Override
   public LogDelegate createDelegate(final String clazz) {
     return new SLF4JLogDelegate(clazz);
   }

File: src/test/java/io/vertx/core/impl/logging/LoggingBackendSelectionTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
-import static io.vertx.core.logging.LoggerFactory.LOGGER_DELEGATE_FACTORY_CLASS_NAME;
+import static io.vertx.core.impl.logging.LoggerFactory.LOGGER_DELEGATE_FACTORY_CLASS_NAME;
 import static org.junit.Assert.assertEquals;
 
 

File: src/test/java/io/vertx/core/impl/logging/NoExceptionInInitializerErrorTest.java
Patch:
@@ -20,8 +20,7 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static io.vertx.core.logging.LoggerFactory.LOGGER_DELEGATE_FACTORY_CLASS_NAME;
-
+import static io.vertx.core.impl.logging.LoggerFactory.LOGGER_DELEGATE_FACTORY_CLASS_NAME;
 
 /**
  * Must be separated from {@link LoggingBackendSelectionTest}.

File: src/test/java/io/vertx/core/logging/LoggerFactoryTest.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.core.logging;
 
+import io.vertx.core.impl.logging.LoggerFactory;
 import org.junit.Test;
 
 /**

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -179,12 +179,13 @@ public void testListenDomainSocketAddress() throws Exception {
     for (int i = 0;i < len;i++) {
       File sockFile = TestUtils.tmpFile(".sock");
       SocketAddress sockAddress = SocketAddress.domainSocketAddress(sockFile.getAbsolutePath());
-      HttpServer server = vertx
+      HttpServer server = vx
         .createHttpServer(createBaseServerOptions())
         .requestHandler(req -> req.response().end(sockAddress.path()));
       startServer(sockAddress, server);
       addresses.add(sockAddress);
     }
+    HttpClient client = vx.createHttpClient(createBaseClientOptions());
     for (int i = 0;i < len;i++) {
       SocketAddress sockAddress = addresses.get(i);
       for (int j = 0;j < len;j++) {

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -1933,14 +1933,15 @@ public void testListenDomainSocketAddress() throws Exception {
     for (int i = 0;i < len;i++) {
       File sockFile = TestUtils.tmpFile(".sock");
       SocketAddress sockAddress = SocketAddress.domainSocketAddress(sockFile.getAbsolutePath());
-      NetServer server = vertx
+      NetServer server = vx
         .createNetServer()
         .connectHandler(so -> {
           so.end(Buffer.buffer(sockAddress.path()));
         });
       startServer(sockAddress, server);
       addresses.add(sockAddress);
     }
+    NetClient client = vx.createNetClient();
     for (int i = 0;i < len;i++) {
       for (int j = 0;j < len;j++) {
         SocketAddress sockAddress = addresses.get(i);

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -30,7 +30,6 @@
 import io.vertx.core.VertxOptions;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.dns.AddressResolverOptions;
-import io.vertx.core.http.Http2ServerTest.TestClient;
 import io.vertx.core.http.impl.HttpServerRequestInternal;
 import io.vertx.core.http.impl.ServerCookie;
 import io.vertx.core.http.impl.headers.HeadersMultiMap;

File: src/test/java/io/vertx/core/DeploymentTest.java
Patch:
@@ -1326,9 +1326,7 @@ public void start() {
         vertx.fileSystem().props("foo.txt").onComplete(onSuccess(props -> {
           assertEquals(5, props.size());
           assertTrue(used.get());
-          vertx.undeploy(context.deploymentID()).onComplete(onSuccess(v -> {
-              testComplete();
-          }));
+          testComplete();
         }));
       }
     }, new DeploymentOptions().setClassLoader(cl)).onComplete(onSuccess(id -> {

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -422,7 +422,7 @@ public <T> void sendOrPubInternal(MessageImpl message, DeliveryOptions options,
 
   private Future<Void> unregisterAll() {
     // Unregister all handlers explicitly - don't rely on context hooks
-    List<Future> futures = new ArrayList<>();
+    List<Future<?>> futures = new ArrayList<>();
     for (ConcurrentCyclicSequence<HandlerHolder> handlers : handlerMap.values()) {
       for (HandlerHolder holder : handlers) {
         futures.add(holder.getHandler().unregister());

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -101,7 +101,7 @@ public Future<Void> undeployAll() {
         deploymentIDs.add(entry.getKey());
       }
     }
-    List<Future> completionList = new ArrayList<>();
+    List<Future<?>> completionList = new ArrayList<>();
     if (!deploymentIDs.isEmpty()) {
       for (String deploymentID : deploymentIDs) {
         Promise<Void> promise = Promise.promise();
@@ -301,7 +301,7 @@ private synchronized void rollback(ContextInternal callingContext, Promise<Deplo
 
     private synchronized Future<Void> doUndeployChildren(ContextInternal undeployingContext) {
       if (!children.isEmpty()) {
-        List<Future> childFuts = new ArrayList<>();
+        List<Future<?>> childFuts = new ArrayList<>();
         for (Deployment childDeployment: new HashSet<>(children)) {
           Promise<Void> p = Promise.promise();
           childFuts.add(p.future());
@@ -325,7 +325,7 @@ public synchronized Future<Void> doUndeploy(ContextInternal undeployingContext)
         return doUndeployChildren(undeployingContext).compose(v -> doUndeploy(undeployingContext));
       } else {
         status = ST_UNDEPLOYED;
-        List<Future> undeployFutures = new ArrayList<>();
+        List<Future<?>> undeployFutures = new ArrayList<>();
         if (parent != null) {
           parent.removeChild(this);
         }

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -564,7 +564,7 @@ private void testDuplicateExecuteBlocking(Supplier<ContextInternal> supplier, bo
     int n = 2;
     List<ContextInternal> dup1 = Stream.generate(supplier).limit(n).collect(Collectors.toList());
     AtomicInteger cnt = new AtomicInteger();
-    List<Future> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
+    List<Future<?>> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
       assertTrue(Context.isOnWorkerThread());
       int val = cnt.incrementAndGet();
       if (ordered) {

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -5333,7 +5333,7 @@ public void testClientEventLoopSize() throws Exception {
       .setPoolEventLoopSize(size));
     List<EventLoop> eventLoops = Collections.synchronizedList(new ArrayList<>());
     client.connectionHandler(conn -> eventLoops.add(((ContextInternal)Vertx.currentContext()).nettyEventLoop()));
-    List<Future> futures = new ArrayList<>();
+    List<Future<Buffer>> futures = new ArrayList<>();
     for (int i = 0;i < size * 2;i++) {
       futures.add(client
         .request(requestOptions)

File: src/test/java/io/vertx/core/shareddata/AsyncMapTest.java
Patch:
@@ -775,7 +775,7 @@ protected Map<JsonObject, Buffer> genJsonToBuffer(int size) {
 
   protected void loadData(Map<JsonObject, Buffer> map, BiConsumer<Vertx, AsyncMap<JsonObject, Buffer>> test) {
     SharedData sharedData = getVertx().sharedData();
-    List<Future> futures = new ArrayList<>(map.size());
+    List<Future<?>> futures = new ArrayList<>(map.size());
     map.forEach((key, value) -> {
       futures.add(sharedData.getAsyncMap("foo").compose(asyncMap -> asyncMap.put(key, value)));
     });

File: src/test/java/io/vertx/core/shareddata/AsynchronousLockTest.java
Patch:
@@ -266,7 +266,7 @@ public void evictTimedOutWaiters() {
     sharedData
       .getLocalLock("foo")
       .onComplete(onSuccess(lock -> {
-        List<Future> locks = new ArrayList<>();
+        List<Future<?>> locks = new ArrayList<>();
         for (int i = 0; i < numWaiters; i++) {
           locks.add(sharedData.getLocalLockWithTimeout("foo", 200));
         }

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -773,7 +773,7 @@ public void testMulti() {
       servers.add(server);
     }
     try {
-      List<Future> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
+      List<Future<?>> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
       CompositeFuture
         .all(collect)
         .onSuccess(v -> {

File: src/test/java/io/vertx/test/verticles/FaultToleranceVerticle.java
Patch:
@@ -40,7 +40,7 @@ public void start() throws Exception {
     JsonObject config = config();
     id = config.getInteger("id");
     numAddresses = config.getInteger("addressesCount");
-    List<Future> registrationFutures = new ArrayList<>(numAddresses);
+    List<Future<Void>> registrationFutures = new ArrayList<>(numAddresses);
     for (int i = 0; i < numAddresses; i++) {
       Promise<Void> registrationFuture = Promise.promise();
       registrationFutures.add(registrationFuture.future());

File: src/test/java/io/vertx/core/http/Http2ClientTest.java
Patch:
@@ -42,7 +42,6 @@
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.ConnectionBase;
 import io.vertx.test.core.AsyncTestBase;
-import io.vertx.test.core.Repeat;
 import io.vertx.test.core.TestUtils;
 import io.vertx.test.tls.Cert;
 import org.junit.Assert;
@@ -1910,7 +1909,6 @@ public void testMaxConcurrencySingleConnection() throws Exception {
     testMaxConcurrency(1, 5);
   }
 
-  @Repeat(times = 1000)
   @Test
   public void testMaxConcurrencyMultipleConnections() throws Exception {
     testMaxConcurrency(2, 1);

File: src/test/java/io/vertx/core/http/Http2ClientTest.java
Patch:
@@ -42,6 +42,7 @@
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.ConnectionBase;
 import io.vertx.test.core.AsyncTestBase;
+import io.vertx.test.core.Repeat;
 import io.vertx.test.core.TestUtils;
 import io.vertx.test.tls.Cert;
 import org.junit.Assert;
@@ -1909,6 +1910,7 @@ public void testMaxConcurrencySingleConnection() throws Exception {
     testMaxConcurrency(1, 5);
   }
 
+  @Repeat(times = 1000)
   @Test
   public void testMaxConcurrencyMultipleConnections() throws Exception {
     testMaxConcurrency(2, 1);

File: src/test/java/io/vertx/core/eventbus/ClusteredEventBusTest.java
Patch:
@@ -688,7 +688,7 @@ public void testMultiHeaders() {
       assertEquals("entry 'd' should have 1 element", Collections.singletonList("4"), headers.getAll("d"));
       complete();
 
-    }).completionHandler(v1 -> {
+    }).completion().onComplete(v1 -> {
       vertices[0].eventBus().send(ADDRESS1, "foo", new DeliveryOptions().setHeaders(expectedHeaders));
     });
 

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredMessage.java
Patch:
@@ -200,7 +200,7 @@ private void encodeHeaders(Buffer buffer) {
     if (headers != null && !headers.isEmpty()) {
       int headersLengthPos = buffer.length();
       buffer.appendInt(0);
-      buffer.appendInt(headers.size());
+      buffer.appendInt(headers.entries().size());
       List<Map.Entry<String, String>> entries = headers.entries();
       for (Map.Entry<String, String> entry: entries) {
         writeString(buffer, entry.getKey());

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -621,7 +621,7 @@ public Stream<Object> stream() {
 
   @Override
   public String toString() {
-    return inspect(this);
+    return encode();
   }
 
   @Override

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -1155,7 +1155,7 @@ public boolean isEmpty() {
 
   @Override
   public String toString() {
-    return inspect(this);
+    return encode();
   }
 
   @Override

File: src/test/java/io/vertx/core/LauncherTest.java
Patch:
@@ -478,7 +478,7 @@ private void testConfigureFromJson(boolean jsonFile) throws Exception {
       Files.write(file.toPath(), json.toBuffer().getBytes());
       optionsArg = file.getPath();
     } else {
-      optionsArg = json.encode();
+      optionsArg = json.toString();
     }
 
     MyLauncher launcher = new MyLauncher();
@@ -579,7 +579,7 @@ private void testCustomMetricsOptionsFromJson(boolean jsonFile) throws Exception
       Files.write(file.toPath(), json.toBuffer().getBytes());
       optionsArg = file.getPath();
     } else {
-      optionsArg = json.encode();
+      optionsArg = json.toString();
     }
 
     MyLauncher launcher = new MyLauncher();

File: src/test/java/io/vertx/core/json/JsonArrayTest.java
Patch:
@@ -853,7 +853,7 @@ static class SomeClass {
   @Test
   public void testToString() {
     jsonArray.add("foo").add(123);
-    assertEquals("[\"foo\", 123]", jsonArray.toString());
+    assertEquals(jsonArray.encode(), jsonArray.toString());
   }
 
   @Test

File: src/test/java/io/vertx/core/json/JsonCodecTest.java
Patch:
@@ -491,10 +491,10 @@ private void testDecodeUnknowContent(boolean asBuffer) {
     assertNull(asBuffer ? mapper.fromBuffer(Buffer.buffer(nullText)) : mapper.fromString(nullText));
 
     JsonObject obj = new JsonObject().put("foo", "bar");
-    assertEquals(obj, asBuffer ? mapper.fromBuffer(obj.toBuffer()) : mapper.fromString(obj.encode()));
+    assertEquals(obj, asBuffer ? mapper.fromBuffer(obj.toBuffer()) : mapper.fromString(obj.toString()));
 
     JsonArray arr = new JsonArray().add(1).add(false).add("whatever").add(obj);
-    assertEquals(arr, asBuffer ? mapper.fromBuffer(arr.toBuffer()) : mapper.fromString(arr.encode()));
+    assertEquals(arr, asBuffer ? mapper.fromBuffer(arr.toBuffer()) : mapper.fromString(arr.toString()));
 
     String invalidText = "\"invalid";
     try {

File: src/test/java/io/vertx/core/json/JsonObjectTest.java
Patch:
@@ -1263,7 +1263,7 @@ public void testMergeInDepth2() {
   @Test
   public void testToString() {
     jsonObject.put("foo", "bar");
-    assertEquals("{foo: \"bar\"}", jsonObject.toString());
+    assertEquals(jsonObject.encode(), jsonObject.toString());
   }
 
   @Test

File: src/test/java/io/vertx/it/CustomJsonCodecTest.java
Patch:
@@ -25,13 +25,13 @@ public class CustomJsonCodecTest extends VertxTestBase {
   public void testJsonObject() {
     JsonObject obj = new JsonObject();
     obj.put("foo", "bar");
-    assertEquals("{\"foo\":\"bar\"}", obj.encode());
+    assertEquals("{\"foo\":\"bar\"}", obj.toString());
   }
 
   @Test
   public void testJsonArray() {
     JsonArray array = new JsonArray();
     array.add("foo");
-    assertEquals("[\"foo\"]", array.encode());
+    assertEquals("[\"foo\"]", array.toString());
   }
 }

File: src/test/java/io/vertx/it/JsonCodecTest.java
Patch:
@@ -25,7 +25,7 @@ public class JsonCodecTest extends VertxTestBase {
   public void testJsonObject() {
     JsonObject obj = new JsonObject("{\"foo\":\"bar\"}");
     assertEquals("bar", obj.getString("foo"));
-    assertEquals("{\"foo\":\"bar\"}", obj.encode());
+    assertEquals("{\"foo\":\"bar\"}", obj.toString());
     try {
       obj.mapTo(Object.class);
       fail();

File: src/test/java/io/vertx/it/JsonTest.java
Patch:
@@ -35,7 +35,7 @@ public void testJsonObject() {
     JsonObject obj = new JsonObject();
     obj.put("foo", "bar");
     try {
-      obj.encode();
+      obj.toString();
       fail();
     } catch (NoClassDefFoundError ignore) {
     }
@@ -48,7 +48,7 @@ public void testJsonArray() {
     JsonArray array = new JsonArray();
     array.add("foo");
     try {
-      array.encode();
+      array.toString();
       fail();
     } catch (NoClassDefFoundError ignore) {
     }

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -621,7 +621,7 @@ public Stream<Object> stream() {
 
   @Override
   public String toString() {
-    return encode();
+    return inspect(this);
   }
 
   @Override

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -1155,7 +1155,7 @@ public boolean isEmpty() {
 
   @Override
   public String toString() {
-    return encode();
+    return inspect(this);
   }
 
   @Override

File: src/test/java/io/vertx/core/LauncherTest.java
Patch:
@@ -478,7 +478,7 @@ private void testConfigureFromJson(boolean jsonFile) throws Exception {
       Files.write(file.toPath(), json.toBuffer().getBytes());
       optionsArg = file.getPath();
     } else {
-      optionsArg = json.toString();
+      optionsArg = json.encode();
     }
 
     MyLauncher launcher = new MyLauncher();
@@ -579,7 +579,7 @@ private void testCustomMetricsOptionsFromJson(boolean jsonFile) throws Exception
       Files.write(file.toPath(), json.toBuffer().getBytes());
       optionsArg = file.getPath();
     } else {
-      optionsArg = json.toString();
+      optionsArg = json.encode();
     }
 
     MyLauncher launcher = new MyLauncher();

File: src/test/java/io/vertx/core/json/JsonArrayTest.java
Patch:
@@ -853,7 +853,7 @@ static class SomeClass {
   @Test
   public void testToString() {
     jsonArray.add("foo").add(123);
-    assertEquals(jsonArray.encode(), jsonArray.toString());
+    assertEquals("[\"foo\", 123]", jsonArray.toString());
   }
 
   @Test

File: src/test/java/io/vertx/core/json/JsonCodecTest.java
Patch:
@@ -491,10 +491,10 @@ private void testDecodeUnknowContent(boolean asBuffer) {
     assertNull(asBuffer ? mapper.fromBuffer(Buffer.buffer(nullText)) : mapper.fromString(nullText));
 
     JsonObject obj = new JsonObject().put("foo", "bar");
-    assertEquals(obj, asBuffer ? mapper.fromBuffer(obj.toBuffer()) : mapper.fromString(obj.toString()));
+    assertEquals(obj, asBuffer ? mapper.fromBuffer(obj.toBuffer()) : mapper.fromString(obj.encode()));
 
     JsonArray arr = new JsonArray().add(1).add(false).add("whatever").add(obj);
-    assertEquals(arr, asBuffer ? mapper.fromBuffer(arr.toBuffer()) : mapper.fromString(arr.toString()));
+    assertEquals(arr, asBuffer ? mapper.fromBuffer(arr.toBuffer()) : mapper.fromString(arr.encode()));
 
     String invalidText = "\"invalid";
     try {

File: src/test/java/io/vertx/core/json/JsonObjectTest.java
Patch:
@@ -1263,7 +1263,7 @@ public void testMergeInDepth2() {
   @Test
   public void testToString() {
     jsonObject.put("foo", "bar");
-    assertEquals(jsonObject.encode(), jsonObject.toString());
+    assertEquals("{foo: \"bar\"}", jsonObject.toString());
   }
 
   @Test

File: src/test/java/io/vertx/it/CustomJsonCodecTest.java
Patch:
@@ -25,13 +25,13 @@ public class CustomJsonCodecTest extends VertxTestBase {
   public void testJsonObject() {
     JsonObject obj = new JsonObject();
     obj.put("foo", "bar");
-    assertEquals("{\"foo\":\"bar\"}", obj.toString());
+    assertEquals("{\"foo\":\"bar\"}", obj.encode());
   }
 
   @Test
   public void testJsonArray() {
     JsonArray array = new JsonArray();
     array.add("foo");
-    assertEquals("[\"foo\"]", array.toString());
+    assertEquals("[\"foo\"]", array.encode());
   }
 }

File: src/test/java/io/vertx/it/JsonCodecTest.java
Patch:
@@ -25,7 +25,7 @@ public class JsonCodecTest extends VertxTestBase {
   public void testJsonObject() {
     JsonObject obj = new JsonObject("{\"foo\":\"bar\"}");
     assertEquals("bar", obj.getString("foo"));
-    assertEquals("{\"foo\":\"bar\"}", obj.toString());
+    assertEquals("{\"foo\":\"bar\"}", obj.encode());
     try {
       obj.mapTo(Object.class);
       fail();

File: src/test/java/io/vertx/it/JsonTest.java
Patch:
@@ -35,7 +35,7 @@ public void testJsonObject() {
     JsonObject obj = new JsonObject();
     obj.put("foo", "bar");
     try {
-      obj.toString();
+      obj.encode();
       fail();
     } catch (NoClassDefFoundError ignore) {
     }
@@ -48,7 +48,7 @@ public void testJsonArray() {
     JsonArray array = new JsonArray();
     array.add("foo");
     try {
-      array.toString();
+      array.encode();
       fail();
     } catch (NoClassDefFoundError ignore) {
     }

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -621,7 +621,7 @@ public Stream<Object> stream() {
 
   @Override
   public String toString() {
-    return encode();
+    return inspect(this);
   }
 
   @Override

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -1155,7 +1155,7 @@ public boolean isEmpty() {
 
   @Override
   public String toString() {
-    return encode();
+    return inspect(this);
   }
 
   @Override

File: src/test/java/io/vertx/core/json/JsonArrayTest.java
Patch:
@@ -853,7 +853,7 @@ static class SomeClass {
   @Test
   public void testToString() {
     jsonArray.add("foo").add(123);
-    assertEquals(jsonArray.encode(), jsonArray.toString());
+    assertEquals("[\"foo\", 123]", jsonArray.toString());
   }
 
   @Test

File: src/test/java/io/vertx/core/json/JsonCodecTest.java
Patch:
@@ -491,10 +491,10 @@ private void testDecodeUnknowContent(boolean asBuffer) {
     assertNull(asBuffer ? mapper.fromBuffer(Buffer.buffer(nullText)) : mapper.fromString(nullText));
 
     JsonObject obj = new JsonObject().put("foo", "bar");
-    assertEquals(obj, asBuffer ? mapper.fromBuffer(obj.toBuffer()) : mapper.fromString(obj.toString()));
+    assertEquals(obj, asBuffer ? mapper.fromBuffer(obj.toBuffer()) : mapper.fromString(obj.encode()));
 
     JsonArray arr = new JsonArray().add(1).add(false).add("whatever").add(obj);
-    assertEquals(arr, asBuffer ? mapper.fromBuffer(arr.toBuffer()) : mapper.fromString(arr.toString()));
+    assertEquals(arr, asBuffer ? mapper.fromBuffer(arr.toBuffer()) : mapper.fromString(arr.encode()));
 
     String invalidText = "\"invalid";
     try {

File: src/test/java/io/vertx/core/json/JsonObjectTest.java
Patch:
@@ -1263,7 +1263,7 @@ public void testMergeInDepth2() {
   @Test
   public void testToString() {
     jsonObject.put("foo", "bar");
-    assertEquals(jsonObject.encode(), jsonObject.toString());
+    assertEquals("{foo: \"bar\"}", jsonObject.toString());
   }
 
   @Test

File: src/main/java/io/vertx/core/http/impl/Http1xUpgradeToH2CHandler.java
Patch:
@@ -94,7 +94,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
                 }
                 handler = initializer.buildHttp2ConnectionHandler(initializer.context, initializer.connectionHandler);
                 pipeline.addLast("handler", handler);
-                handler.serverUpgrade(ctx, settings, request);
+                handler.serverUpgrade(ctx, settings);
                 DefaultHttp2Headers headers = new DefaultHttp2Headers();
                 headers.method(request.method().name());
                 headers.path(request.uri());

File: src/test/java/io/vertx/core/http/Http2MetricsTest.java
Patch:
@@ -30,7 +30,7 @@ public static Collection<Object[]> params() {
     params.add(new Object[] { Http2TestBase.createHttp2ClientOptions(), Http2TestBase.createHttp2ServerOptions(HttpTestBase.DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST) });
     // h2c with upgrade
     params.add(new Object[] { new HttpClientOptions().setProtocolVersion(HttpVersion.HTTP_2).setHttp2ClearTextUpgrade(true), new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT).setHost(HttpTestBase.DEFAULT_HTTP_HOST) });
-    // h2c direct
+    // h2c directq
     params.add(new Object[] { new HttpClientOptions().setProtocolVersion(HttpVersion.HTTP_2).setHttp2ClearTextUpgrade(false), new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT).setHost(HttpTestBase.DEFAULT_HTTP_HOST) });
     return params;
   }

File: src/test/java/io/vertx/test/faketracer/FakeTracer.java
Patch:
@@ -127,7 +127,7 @@ public <R> Span receiveRequest(Context context, SpanKind kind, TracingPolicy pol
   public <R> void sendResponse(Context context, R response, Span span, Throwable failure, TagExtractor<R> tagExtractor) {
     if (span != null) {
       addTags(span, response, tagExtractor);
-      span.finish();
+      span.finish(failure);
     }
   }
 
@@ -154,7 +154,7 @@ public <R> Span sendRequest(Context context, SpanKind kind, TracingPolicy policy
   public <R> void receiveResponse(Context context, R response, Span span, Throwable failure, TagExtractor<R> tagExtractor) {
     if (span != null) {
       addTags(span, response, tagExtractor);
-      span.finish();
+      span.finish(failure);
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpObject;

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -38,6 +38,8 @@ public interface HttpClientStream extends WriteStream<Buffer> {
 
   Object metric();
 
+  Object trace();
+
   /**
    * @return the stream version or null if it's not yet determined
    */

File: src/main/java/io/vertx/core/http/impl/HttpServerWorker.java
Patch:
@@ -270,7 +270,7 @@ private void configureHttp1OrH2C(ChannelPipeline pipeline, SslChannelProvider ss
     if (options.isCompressionSupported()) {
       pipeline.addLast("deflater", new HttpChunkContentCompressor(compressionOptions));
     }
-    if (options.isSsl() || options.isCompressionSupported()) {
+    if (options.isSsl() || options.isCompressionSupported() || !vertx.transport().supportFileRegion()) {
       // only add ChunkedWriteHandler when SSL is enabled otherwise it is not needed as FileRegion is used.
       pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());       // For large file / sendfile support
     }

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -14,7 +14,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.*;
 import io.netty.handler.ssl.SslHandler;
-import io.netty.handler.stream.ChunkedFile;
+import io.netty.handler.stream.ChunkedNioFile;
 import io.netty.handler.timeout.IdleStateEvent;
 import io.netty.util.AttributeKey;
 import io.netty.util.ReferenceCountUtil;
@@ -409,7 +409,7 @@ protected void handleIdle(IdleStateEvent event) {
   protected abstract void handleInterestedOpsChanged();
 
   protected boolean supportsFileRegion() {
-    return !isSsl();
+    return vertx.transport().supportFileRegion() && !isSsl();
   }
 
   protected void reportBytesRead(Object msg) {
@@ -505,7 +505,7 @@ public final ChannelFuture sendFile(RandomAccessFile raf, long offset, long leng
     ChannelPromise writeFuture = chctx.newPromise();
     if (!supportsFileRegion()) {
       // Cannot use zero-copy
-      writeToChannel(new ChunkedFile(raf, offset, length, 8192), writeFuture);
+      writeToChannel(new ChunkedNioFile(raf.getChannel(), offset, length, 8192), writeFuture);
     } else {
       // No encryption - use zero-copy.
       sendFileRegion(raf, offset, length, writeFuture);

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -95,7 +95,7 @@ protected void initChannel(ChannelPipeline pipeline) {
     if (logEnabled) {
       pipeline.addLast("logging", new LoggingHandler(options.getActivityLogDataFormat()));
     }
-    if (options.isSsl()) {
+    if (options.isSsl() || !vertx.transport().supportFileRegion()) {
       // only add ChunkedWriteHandler when SSL is enabled otherwise it is not needed as FileRegion is used.
       pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());       // For large file / sendfile support
     }

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -255,8 +255,8 @@ protected void initChannel(ChannelPipeline pipeline, boolean ssl) {
     if (options.getLogActivity()) {
       pipeline.addLast("logging", new LoggingHandler(options.getActivityLogDataFormat()));
     }
-    if (ssl) {
-      // only add ChunkedWriteHandler when SSL is enabled otherwise it is not needed as FileRegion is used.
+    if (ssl || !vertx.transport().supportFileRegion()) {
+      // only add ChunkedWriteHandler when SSL is enabled or FileRegion isn't supported
       pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());       // For large file / sendfile support
     }
     int idleTimeout = options.getIdleTimeout();

File: src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java
Patch:
@@ -288,6 +288,7 @@ private void checkPending() {
         }
         if (ended) {
           if (pending.isEmpty()) {
+            checkExceptions();
             Handler<Void> handler = endHandler;
             endHandler = null;
             if (handler != null) {

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -29,7 +29,6 @@
 import io.vertx.core.net.NetClientOptions;
 import io.vertx.core.net.NetSocket;
 import io.vertx.core.net.SocketAddress;
-import io.vertx.core.spi.VertxMetricsFactory;
 import io.vertx.test.core.TestUtils;
 import io.vertx.test.core.VertxTestBase;
 import io.vertx.test.fakemetrics.*;
@@ -1007,7 +1006,7 @@ public void testThreadPoolMetricsWithInternalExecuteBlocking() {
 
     assertWaitUntil(() -> metrics.numberOfSubmittedTask() == 100);
     assertWaitUntil(() -> metrics.numberOfCompletedTasks() == 100);
-    assertTrue(hadIdle.get());
+    assertWaitUntil(() -> hadIdle.get());
     assertTrue(hadWaitingQueue.get());
     assertTrue(hadRunning.get());
 

File: src/main/java/io/vertx/core/net/JdkSSLEngineOptions.java
Patch:
@@ -59,6 +59,7 @@ public JdkSSLEngineOptions() {
   }
 
   public JdkSSLEngineOptions(JsonObject json) {
+    super(json);
   }
 
   public JdkSSLEngineOptions(JdkSSLEngineOptions that) {

File: src/main/java/io/vertx/core/net/OpenSSLEngineOptions.java
Patch:
@@ -52,10 +52,12 @@ public OpenSSLEngineOptions() {
   }
 
   public OpenSSLEngineOptions(JsonObject json) {
+    super(json);
     OpenSSLEngineOptionsConverter.fromJson(json, this);
   }
 
   public OpenSSLEngineOptions(OpenSSLEngineOptions other) {
+    super(other);
     this.sessionCacheEnabled = other.isSessionCacheEnabled();
   }
 

File: src/main/java/io/vertx/core/net/impl/SocketAddressImpl.java
Patch:
@@ -52,6 +52,9 @@ public SocketAddressImpl(InetSocketAddress address) {
   }
 
   public SocketAddressImpl(int port, String host) {
+    if (port > 65535) {
+      throw new IllegalArgumentException("port p must be < 65535");
+    }
     this.path = null;
     this.port = port;
     if (NetUtil.isValidIpV4Address(host)) {

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -1135,7 +1135,7 @@ private static ThreadFactory createThreadFactory(VertxThreadFactory threadFactor
     AtomicInteger threadCount = new AtomicInteger(0);
     return runnable -> {
       VertxThread thread = threadFactory.newVertxThread(runnable, prefix + threadCount.getAndIncrement(), worker, maxExecuteTime, maxExecuteTimeUnit);
-      checker.registerThread(thread, thread);
+      checker.registerThread(thread, thread.info);
       if (useDaemonThread != null && thread.isDaemon() != useDaemonThread) {
         thread.setDaemon(useDaemonThread);
       }

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -633,7 +633,7 @@ public void testReentrantDispatch() {
         assertSame(ctx, Vertx.currentContext());
         assertSame(cl, Thread.currentThread().getContextClassLoader());
         int[] called = new int[1];
-        BlockedThreadChecker.Task thread = (BlockedThreadChecker.Task) Thread.currentThread();
+        VertxThread thread = (VertxThread) Thread.currentThread();
         long start = thread.startTime();
         ctx.dispatch(v2 -> {
           called[0]++;

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -490,7 +490,9 @@ public void testClientOptionsJson() {
     } else {
       sslEngine = "openSslEngineOptions";
       boolean sessionCacheEnabled = rand.nextBoolean();
-      sslEngineOptions = new JsonObject().put("sessionCacheEnabled", sessionCacheEnabled);
+      sslEngineOptions = new JsonObject()
+        .put("sessionCacheEnabled", sessionCacheEnabled)
+        .put("useWorkerThread", SSLEngineOptions.DEFAULT_USE_WORKER_POOL);
     }
     long sslHandshakeTimeout = TestUtils.randomPositiveLong();
 

File: src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -328,7 +328,7 @@ public SslHandler createSslHandler(VertxInternal vertx, SocketAddress remoteAddr
   }
 
   public SniHandler createSniHandler(VertxInternal vertx) {
-    return new SniHandler(serverNameMapper(vertx));
+    return new VertxSniHandler(serverNameMapper(vertx), sslHandshakeTimeoutUnit.toMillis(sslHandshakeTimeout));
   }
 
   public ChannelHandler createHandler(VertxInternal vertx) {

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -85,7 +85,7 @@ public abstract class TCPSSLOptions extends NetworkOptions {
    * <p/>
    * "SSLv2Hello" is NOT enabled since it's disabled by default since JDK7
    */
-  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList("TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"));
+  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList("TLSv1.2", "TLSv1.3"));
 
   /**
    * The default TCP_FASTOPEN value = false

File: src/test/java/io/vertx/core/net/SSLHelperTest.java
Patch:
@@ -150,9 +150,7 @@ public void testPreserveEnabledSecureTransportProtocolOrder() throws Exception {
   public void testDefaultVersions() {
     testTLSVersions(new HttpServerOptions(), engine -> {
       List<String> protocols = Arrays.asList(engine.getEnabledProtocols());
-      assertEquals(4, protocols.size());
-      assertTrue(protocols.contains("TLSv1"));
-      assertTrue(protocols.contains("TLSv1.1"));
+      assertEquals(2, protocols.size());
       assertTrue(protocols.contains("TLSv1.2"));
       assertTrue(protocols.contains("TLSv1.3"));
     });

File: src/main/java/examples/NetExamples.java
Patch:
@@ -536,8 +536,7 @@ public void example45(Vertx vertx, JksOptions keyStoreOptions) {
     NetServerOptions options = new NetServerOptions().
       setSsl(true).
       setKeyStoreOptions(keyStoreOptions).
-      removeEnabledSecureTransportProtocol("TLSv1").
-      addEnabledSecureTransportProtocol("TLSv1.3");
+      removeEnabledSecureTransportProtocol("TLSv1");
     NetServer server = vertx.createNetServer(options);
   }
 

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -79,13 +79,13 @@ public abstract class TCPSSLOptions extends NetworkOptions {
   public static final SSLEngineOptions DEFAULT_SSL_ENGINE = null;
 
   /**
-   * The default ENABLED_SECURE_TRANSPORT_PROTOCOLS value = { "TLSv1", "TLSv1.1", "TLSv1.2" }
+   * The default ENABLED_SECURE_TRANSPORT_PROTOCOLS value = { "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3" }
    * <p/>
    * SSLv3 is NOT enabled due to POODLE vulnerability http://en.wikipedia.org/wiki/POODLE
    * <p/>
    * "SSLv2Hello" is NOT enabled since it's disabled by default since JDK7
    */
-  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList("TLSv1", "TLSv1.1", "TLSv1.2"));
+  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList("TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"));
 
   /**
    * The default TCP_FASTOPEN value = false

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -196,7 +196,7 @@ private void http1xConnected(HttpVersion version,
     });
     clientHandler.addHandler(conn -> {
       if (upgrade) {
-        future.complete(new Http2UpgradedClientConnection(client, conn));
+        future.complete(new Http2UpgradeClientConnection(client, conn));
       } else {
         future.complete(conn);
       }

File: src/main/java/io/vertx/core/http/impl/Http2ServerConnection.java
Patch:
@@ -95,7 +95,7 @@ private static boolean isMalformedRequest(Http2Headers headers) {
         return true;
       }
     } else {
-      if (headers.method() == null || headers.scheme() == null || headers.path() == null) {
+      if (headers.method() == null || headers.scheme() == null || headers.path() == null || headers.path().length() == 0) {
         return true;
       }
     }

File: src/main/java/io/vertx/core/http/HttpServerRequest.java
Patch:
@@ -48,7 +48,7 @@
 public interface HttpServerRequest extends ReadStream<Buffer> {
 
   /**
-   * The default invalid request handler, it uses uses the {@link #decoderResult()} cause and the request information
+   * The default invalid request handler, it uses the {@link #decoderResult()} cause and the request information
    * to determine the status code of the response to be sent.
    *
    * <ul>

File: src/main/java/io/vertx/core/buffer/impl/BufferImpl.java
Patch:
@@ -537,7 +537,7 @@ public ByteBuf byteBuf() {
   }
 
   public ByteBuf getByteBuf() {
-    ByteBuf duplicate = buffer.duplicate();
+    ByteBuf duplicate = buffer.slice();
     if (buffer.getClass() != VertxHeapByteBuf.class && buffer.getClass() != VertxUnsafeHeapByteBuf.class) {
       duplicate = Unpooled.unreleasableBuffer(duplicate);
     }

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -1360,7 +1360,6 @@ public void testRequestWrite() {
           int padding = 5;
           for (int i = 0;i < times;i++) {
             Buffer paddedChunk = TestUtils.leftPad(padding, chunk);
-            assertEquals(paddedChunk.getByteBuf().readerIndex(), padding);
             req.write(paddedChunk);
           }
           req.end();

File: src/main/java/io/vertx/core/http/impl/EndpointKey.java
Patch:
@@ -71,8 +71,7 @@ private static int hashCode(ProxyOptions options) {
     if (options.getUsername() != null && options.getPassword() != null) {
       return Objects.hash(options.getHost(), options.getPort(), options.getType(), options.getUsername(), options.getPassword());
     } else {
-      Objects.hash(options.getHost(), options.getPort(), options.getType());
+      return Objects.hash(options.getHost(), options.getPort(), options.getType());
     }
-    return 0;
   }
 }

File: src/main/java/io/vertx/core/net/impl/pool/EndpointProvider.java
Patch:
@@ -17,15 +17,15 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-public interface EndpointProvider<K, C> {
+public interface EndpointProvider<C> {
 
   /**
    * Create an endpoint tracked by the {@link ConnectionManager}.
    *
+   * @param ctx     the creating context
    * @param dispose the callback to signal this endpoint should be destroyed
-   * @param ctx the creating context
    * @return the created endpoint
    */
-  Endpoint<C> create(K key, ContextInternal ctx, Runnable dispose);
+  Endpoint<C> create(ContextInternal ctx, Runnable dispose);
 
 }

File: src/test/java/io/vertx/core/http/HttpTestBase.java
Patch:
@@ -138,10 +138,11 @@ protected void startServer(SocketAddress bindAddress, Context context, HttpServe
 
   protected void startProxy(String username, ProxyType proxyType) throws Exception {
     if (proxyType == ProxyType.HTTP) {
-      proxy = new HttpProxy(username);
+      proxy = new HttpProxy();
     } else {
-      proxy = new SocksProxy(username);
+      proxy = new SocksProxy();
     }
+    proxy.username(username);
     proxy.start(vertx);
   }
 }

File: src/test/java/io/vertx/core/net/ProxyErrorTest.java
Patch:
@@ -69,7 +69,7 @@ protected VertxOptions getOptions() {
   // we don't start http/https servers, due to the error, they will not be queried
 
   private void startProxy(int error, String username) throws Exception {
-    proxy = new HttpProxy(username);
+    proxy = new HttpProxy().username(username);
     proxy.setError(error);
     proxy.start(vertx);
   }
@@ -128,7 +128,7 @@ private void proxyTest(int error, String username, String url, Handler<AsyncResu
         .setProxyOptions(new ProxyOptions()
             .setType(ProxyType.HTTP)
             .setHost("localhost")
-            .setPort(proxy.getPort()));
+            .setPort(proxy.port()));
     HttpClient client = vertx.createHttpClient(options);
 
     client.request(new RequestOptions().setAbsoluteURI(url), ar -> {

File: src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.handler.ssl.SniHandler;
 import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslHandler;
+import io.netty.handler.ssl.SslProvider;
 import io.netty.util.Mapping;
 import io.vertx.core.Future;
 import io.vertx.core.Promise;
@@ -39,6 +40,7 @@
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.TCPSSLOptions;
 import io.vertx.core.net.TrustOptions;
+import io.vertx.core.spi.tls.DefaultSslContextFactory;
 import io.vertx.core.spi.tls.SslContextFactory;
 
 import javax.net.ssl.*;
@@ -222,7 +224,7 @@ public synchronized Future<Void> init(ContextInternal ctx) {
           p.complete(sslProvider);
         })).onComplete(promise);
       } else {
-        fut = Future.succeededFuture();
+        fut = Future.succeededFuture(() -> new DefaultSslContextFactory(SslProvider.JDK, false));
       }
       sslProvider = fut;
     }

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -287,7 +287,7 @@ default DatagramSocket createDatagramSocket() {
    * @return the unique ID of the timer
    */
   default long setPeriodic(long delay, Handler<Long> handler) {
-    return setPeriodic(0, delay, handler);
+    return setPeriodic(delay, delay, handler);
   }
 
   /**

File: src/main/java/io/vertx/core/logging/LoggerFactory.java
Patch:
@@ -32,6 +32,9 @@ public class LoggerFactory {
 
   static {
     initialise();
+    // Do not log before being fully initialized (a logger extension may use Vert.x classes)
+    LogDelegate log = delegateFactory.createDelegate(LoggerFactory.class.getName());
+    log.debug("Using " + delegateFactory.getClass().getName());
   }
 
   public static synchronized void initialise() {
@@ -56,14 +59,12 @@ public static synchronized void initialise() {
   }
 
   private static boolean configureWith(String name, boolean shortName, ClassLoader loader) {
-    String loggerName = LoggerFactory.class.getName();
     try {
       Class<?> clazz = Class.forName(shortName ? "io.vertx.core.logging." + name + "LogDelegateFactory" : name, true, loader);
       LogDelegateFactory factory = (LogDelegateFactory) clazz.newInstance();
       if (!factory.isAvailable()) {
         return false;
       }
-      factory.createDelegate(loggerName).debug("Using " + factory.getClass().getName());
       delegateFactory = factory;
       return true;
     } catch (Throwable ignore) {

File: src/main/java/io/vertx/core/file/impl/FileSystemImpl.java
Patch:
@@ -1065,8 +1065,7 @@ public Buffer perform() {
         try {
           Path target = vertx.resolveFile(path).toPath();
           byte[] bytes = Files.readAllBytes(target);
-          Buffer buff = Buffer.buffer(bytes);
-          return buff;
+          return Buffer.buffer(bytes);
         } catch (IOException e) {
           throw new FileSystemException(getFileAccessErrorMessage("read", path), e);
         }
@@ -1158,7 +1157,7 @@ protected abstract class BlockingAction<T> implements Handler<Promise<T>> {
 
     protected final ContextInternal context;
 
-    public BlockingAction() {
+    protected BlockingAction() {
       this.context = vertx.getOrCreateContext();
     }
 

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -4973,7 +4973,7 @@ public void start(Promise<Void> startFuture) {
   @Test
   public void testHttpServerWithIdleTimeoutSendChunkedFile() throws Exception {
     // Does not pass reliably in CI (timeout)
-    Assume.assumeFalse(vertx.isNativeTransportEnabled() && !Utils.isWindows());
+    Assume.assumeTrue(!vertx.isNativeTransportEnabled() && !Utils.isWindows());
     int expected = 64 * 1024 * 1024; // We estimate this will take more than 200ms to transfer with a 1ms pause in chunks
     File sent = TestUtils.tmpFile(".dat", expected);
     server.close();

File: src/main/java/io/vertx/core/eventbus/DeliveryOptions.java
Patch:
@@ -67,7 +67,9 @@ public DeliveryOptions() {
   public DeliveryOptions(DeliveryOptions other) {
     this.timeout = other.getSendTimeout();
     this.codecName = other.getCodecName();
-    this.headers = other.getHeaders();
+    if (other.getHeaders() != null) {
+      this.headers = MultiMap.caseInsensitiveMultiMap().addAll(other.getHeaders());
+    }
     this.localOnly = other.localOnly;
     this.tracingPolicy = other.tracingPolicy;
   }

File: src/test/java/io/vertx/test/fakecluster/FakeClusterManager.java
Patch:
@@ -45,7 +45,7 @@ public class FakeClusterManager implements ClusterManager {
   private static LocalAsyncLocks localAsyncLocks = new LocalAsyncLocks();
   private static final ConcurrentMap<String, AtomicLong> counters = new ConcurrentHashMap<>();
 
-  private String nodeID;
+  private volatile String nodeID;
   private NodeListener nodeListener;
   private VertxInternal vertx;
   private NodeSelector nodeSelector;

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -99,9 +99,9 @@ public class AsyncFileImpl implements AsyncFile {
     try {
       if (options.getPerms() != null) {
         FileAttribute<?> attrs = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(options.getPerms()));
-        ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool(), attrs);
+        ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor(), attrs);
       } else {
-        ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool());
+        ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor());
       }
       if (options.isAppend()) writePos = ch.size();
     } catch (IOException e) {

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -123,7 +123,7 @@ void setRequest(HttpRequest request) {
 
   private InboundBuffer<Object> pendingQueue() {
     if (pending == null) {
-      pending = new InboundBuffer<>(conn.getContext(), 8);
+      pending = new InboundBuffer<>(context, 8);
       pending.drainHandler(v -> conn.doResume());
       pending.handler(buffer -> {
         if (buffer == InboundBuffer.END_SENTINEL) {

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -71,7 +71,9 @@ public interface VertxInternal extends Vertx {
 
   EventLoopGroup getAcceptorEventLoopGroup();
 
-  ExecutorService getWorkerPool();
+  WorkerPool getWorkerPool();
+
+  WorkerPool getInternalWorkerPool();
 
   Map<ServerID, HttpServerImpl> sharedHttpServers();
 

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -63,8 +63,8 @@ public WorkerPool getPool() {
       }
     }
     ContextInternal context = (ContextInternal) vertx.getOrCreateContext();
-    ContextImpl impl = context instanceof DuplicatedContext ? ((DuplicatedContext)context).delegate : (ContextImpl) context;
-    return ContextImpl.executeBlocking(context, blockingCodeHandler, pool, ordered ? impl.orderedTasks : null);
+    ContextBase impl = context instanceof DuplicatedContext ? ((DuplicatedContext)context).delegate : (ContextBase) context;
+    return ContextBase.executeBlocking(context, blockingCodeHandler, pool, ordered ? impl.orderedTasks : null);
   }
 
   public <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<T>> asyncResultHandler) {

File: src/main/java/io/vertx/core/streams/impl/InboundBuffer.java
Patch:
@@ -99,8 +99,7 @@ public InboundBuffer(Context context, long highWaterMark) {
   }
 
   private void checkThread() {
-    Thread thread = Thread.currentThread();
-    if (!(thread instanceof FastThreadLocalThread)) {
+    if (!context.inThread()) {
       throw new IllegalStateException("This operation must be called from a Vert.x thread");
     }
   }

File: src/test/java/io/vertx/core/http/Http2ClientTest.java
Patch:
@@ -1038,7 +1038,8 @@ public void testServerShutdownConnection() throws Exception {
     });
     client.request(requestOptions).onComplete(onSuccess(req -> {
       req.send(onFailure(err -> {
-        assertEquals(HttpClosedException.class, err.getClass());
+        assertEquals("Was expecting HttpClosedException instead of " + err.getClass().getName() + " / " + err.getMessage(),
+          HttpClosedException.class, err.getClass());
         assertEquals(0, ((HttpClosedException)err).goAway().getErrorCode());
         complete();
       }));

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -563,7 +563,7 @@ void closeConnection() {
    */
   void initiateConnectionCloseTimeout(long timeoutMillis) {
     synchronized (conn) {
-      closeTimeoutID = context.owner().setTimer(timeoutMillis, id -> {
+      closeTimeoutID = context.setTimer(timeoutMillis, id -> {
         synchronized (conn) {
           closeTimeoutID = -1L;
         }

File: src/main/java/io/vertx/core/impl/AbstractContext.java
Patch:
@@ -85,13 +85,13 @@ public final void endDispatch(ContextInternal previous) {
   @Override
   public long setPeriodic(long delay, Handler<Long> handler) {
     VertxImpl owner = (VertxImpl) owner();
-    return owner.scheduleTimeout(this, true, delay, TimeUnit.MILLISECONDS, handler);
+    return owner.scheduleTimeout(this, true, delay, TimeUnit.MILLISECONDS, false, handler);
   }
 
   @Override
   public long setTimer(long delay, Handler<Long> handler) {
     VertxImpl owner = (VertxImpl) owner();
-    return owner.scheduleTimeout(this, false, delay, TimeUnit.MILLISECONDS,handler);
+    return owner.scheduleTimeout(this, false, delay, TimeUnit.MILLISECONDS, false, handler);
   }
 
   @Override

File: src/test/java/io/vertx/core/json/JsonArrayTest.java
Patch:
@@ -1410,8 +1410,8 @@ public void testStreamRawVSJSON() {
 
   @Test
   void testJsonArrayOf() {
-    // test int
-    int i = 1;
+    // test Integer
+    Integer i = 1;
 
     // test string
     String s = "a string";

File: src/test/java/io/vertx/core/json/JsonObjectTest.java
Patch:
@@ -1934,8 +1934,8 @@ public void testStreamRawVSJSON() {
 
   @Test
   void testJsonObjectOf() {
-    // test int
-    int i = 1;
+    // test Ingeger
+    Integer i = 1;
 
     // test string
     String s = "a string";

File: src/main/java/io/vertx/core/http/impl/HttpUtils.java
Patch:
@@ -42,6 +42,7 @@
 import java.io.RandomAccessFile;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.util.Base64;
 import java.util.List;
@@ -493,8 +494,8 @@ static String absoluteURI(String serverOrigin, HttpServerRequest req) throws URI
     return absoluteURI;
   }
 
-  static MultiMap params(String uri) {
-    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(uri);
+  static MultiMap params(String uri, Charset charset) {
+    QueryStringDecoder queryStringDecoder = new QueryStringDecoder(uri, charset);
     Map<String, List<String>> prms = queryStringDecoder.parameters();
     MultiMap params = MultiMap.caseInsensitiveMultiMap();
     if (!prms.isEmpty()) {

File: src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java
Patch:
@@ -309,16 +309,18 @@ public void run() {
           return null;
         }
         LeaseImpl<C> lease;
+        int c;
         if (waiter.disposed) {
           lease = null;
+          c = 0;
         } else {
           lease = new LeaseImpl<>(slot, waiter.handler);
+          c = 1;
           waiter.disposed = true;
           acquisitions--;
         }
         LeaseImpl<C>[] leases;
         int m = (int)Math.min(acquisitions, pool.waiters.size());
-        int c = 1;
         if (m > 0) {
           c += m;
           leases = new LeaseImpl[m];

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -507,7 +507,7 @@ public void testReplyFailureTimeout1() throws Exception {
       latch.countDown();
     });
     awaitLatch(latch);
-    waitUntil(() -> metrics.getReplyFailureAddresses().size() == 1);
+    waitUntil(() -> metrics.getReplyFailureAddresses().size() == 1, 11_000);
     assertEquals(Collections.singletonList(ReplyFailure.TIMEOUT), metrics.getReplyFailures());
   }
 

File: src/test/java/io/vertx/test/fakedns/FakeDNSServer.java
Patch:
@@ -416,7 +416,6 @@ public void messageReceived(IoSession session, Object message) {
   @Override
   public void stop() {
     for (Transport transport : getTransports()) {
-      System.out.println("closing " +transport);
       transport.getAcceptor().dispose();
     }
   }

File: src/main/java/io/vertx/core/impl/AbstractContext.java
Patch:
@@ -18,6 +18,7 @@
 import io.vertx.core.impl.launcher.VertxCommandLauncher;
 
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 /**
  * A context implementation that does not hold any specific state.
@@ -84,13 +85,13 @@ public final void endDispatch(ContextInternal previous) {
   @Override
   public long setPeriodic(long delay, Handler<Long> handler) {
     VertxImpl owner = (VertxImpl) owner();
-    return owner.scheduleTimeout(this, handler, delay, true);
+    return owner.scheduleTimeout(this, true, delay, TimeUnit.MILLISECONDS, handler);
   }
 
   @Override
   public long setTimer(long delay, Handler<Long> handler) {
     VertxImpl owner = (VertxImpl) owner();
-    return owner.scheduleTimeout(this, handler, delay, false);
+    return owner.scheduleTimeout(this, false, delay, TimeUnit.MILLISECONDS,handler);
   }
 
   @Override

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -124,7 +124,7 @@ public void close(Promise<Void> promise) {
   @Override
   public MessageImpl createMessage(boolean send, String address, MultiMap headers, Object body, String codecName) {
     Objects.requireNonNull(address, "no null address accepted");
-    MessageCodec codec = codecManager.lookupCodec(body, codecName);
+    MessageCodec codec = codecManager.lookupCodec(body, codecName, false);
     @SuppressWarnings("unchecked")
     ClusteredMessage msg = new ClusteredMessage(nodeId, address, headers, body, codec, send, this);
     return msg;

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -610,8 +610,7 @@ public static VertxHttp2ConnectionHandler<Http2ClientConnection> createHttp2Conn
     ClientMetrics metrics,
     EventLoopContext context,
     boolean upgrade,
-    Object socketMetric,
-    Handler<Http2ClientConnection> c) {
+    Object socketMetric) {
     HttpClientOptions options = client.options();
     HttpClientMetrics met = client.metrics();
     VertxHttp2ConnectionHandler<Http2ClientConnection> handler = new VertxHttp2ConnectionHandlerBuilder<Http2ClientConnection>()
@@ -638,7 +637,6 @@ public static VertxHttp2ConnectionHandler<Http2ClientConnection> createHttp2Conn
           met.endpointConnected(metrics);
         }
       }
-      c.handle(conn);
     });
     handler.removeHandler(conn -> {
       if (metrics != null) {

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -20,8 +20,8 @@
 import io.vertx.core.json.Json;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
+import io.vertx.core.shareddata.ClusterSerializable;
 import io.vertx.core.shareddata.Shareable;
-import io.vertx.core.shareddata.impl.ClusterSerializable;
 
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -12,8 +12,8 @@
 package io.vertx.core.json;
 
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.shareddata.ClusterSerializable;
 import io.vertx.core.shareddata.Shareable;
-import io.vertx.core.shareddata.impl.ClusterSerializable;
 
 import java.time.Instant;
 import java.util.*;

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -11,8 +11,8 @@
 package io.vertx.core.json;
 
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.shareddata.ClusterSerializable;
 import io.vertx.core.shareddata.Shareable;
-import io.vertx.core.shareddata.impl.ClusterSerializable;
 
 import java.time.Instant;
 import java.util.*;

File: src/main/java/io/vertx/core/shareddata/AsyncMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -30,9 +30,8 @@
  * <p>
  * {@link AsyncMap} does <em>not</em> allow {@code null} to be used as a key or value.
  *
- * @implSpec Implementations of the interface must handle {@link io.vertx.core.shareddata.impl.ClusterSerializable}
- * implementing objects.
  * @author <a href="http://tfox.org">Tim Fox</a>
+ * @implSpec Implementations of the interface must handle {@link io.vertx.core.shareddata.ClusterSerializable} implementing objects.
  */
 @VertxGen
 public interface AsyncMap<K, V> {

File: src/main/java/io/vertx/core/shareddata/impl/Checker.java
Patch:
@@ -14,6 +14,7 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;
+import io.vertx.core.shareddata.ClusterSerializable;
 import io.vertx.core.shareddata.Shareable;
 
 import java.io.*;

File: src/main/java/io/vertx/core/spi/cluster/NodeInfo.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -14,7 +14,7 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.impl.Arguments;
 import io.vertx.core.json.JsonObject;
-import io.vertx.core.shareddata.impl.ClusterSerializable;
+import io.vertx.core.shareddata.ClusterSerializable;
 
 import java.util.Objects;
 

File: src/main/java/io/vertx/core/spi/cluster/RegistrationInfo.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -12,7 +12,7 @@
 package io.vertx.core.spi.cluster;
 
 import io.vertx.core.buffer.Buffer;
-import io.vertx.core.shareddata.impl.ClusterSerializable;
+import io.vertx.core.shareddata.ClusterSerializable;
 
 import java.util.Objects;
 

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredMessage.java
Patch:
@@ -275,7 +275,7 @@ void internalError() {
     if (replyAddress != null) {
       reply(new ReplyException(ReplyFailure.ERROR, failure));
     } else {
-      log.trace(failure);
+      log.error(failure);
     }
   }
 }

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -115,7 +115,7 @@ public class Http1xClientConnection extends Http1xConnectionBase<WebSocketImpl>
                          ClientMetrics metrics) {
     super(context, channel);
     this.client = client;
-    this.options = client.getOptions();
+    this.options = client.options();
     this.ssl = ssl;
     this.server = server;
     this.metrics = metrics;
@@ -901,7 +901,7 @@ synchronized void toWebSocket(
       }
 
       ChannelPipeline p = chctx.channel().pipeline();
-      ArrayList<WebSocketClientExtensionHandshaker> extensionHandshakers = initializeWebSocketExtensionHandshakers(client.getOptions());
+      ArrayList<WebSocketClientExtensionHandshaker> extensionHandshakers = initializeWebSocketExtensionHandshakers(client.options());
       if (!extensionHandshakers.isEmpty()) {
         p.addBefore("handler", "webSocketsExtensionsHandler", new WebSocketClientExtensionHandler(
           extensionHandshakers.toArray(new WebSocketClientExtensionHandshaker[0])));

File: src/main/java/io/vertx/core/http/impl/Http2UpgradedClientConnection.java
Patch:
@@ -167,7 +167,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         }
       }
 
-      VertxHttp2ClientUpgradeCodec upgradeCodec = new VertxHttp2ClientUpgradeCodec(upgradedConnection.client.getOptions().getInitialSettings()) {
+      VertxHttp2ClientUpgradeCodec upgradeCodec = new VertxHttp2ClientUpgradeCodec(upgradedConnection.client.options().getInitialSettings()) {
         @Override
         public void upgradeTo(ChannelHandlerContext ctx, FullHttpResponse upgradeResponse) throws Exception {
 

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -70,7 +70,7 @@ public HttpChannelConnector(HttpClientImpl client,
     this.client = client;
     this.netClient = netClient;
     this.metrics = metrics;
-    this.options = client.getOptions();
+    this.options = client.options();
     this.proxyOptions = proxyOptions;
     this.ssl = ssl;
     this.useAlpn = useAlpn;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestBase.java
Patch:
@@ -187,7 +187,7 @@ void handleResponse(HttpClientResponse resp) {
   private synchronized long cancelTimeout() {
     long ret;
     if ((ret = currentTimeoutTimerId) != -1) {
-      client.getVertx().cancelTimer(currentTimeoutTimerId);
+      client.vertx().cancelTimer(currentTimeoutTimerId);
       currentTimeoutTimerId = -1;
       ret = currentTimeoutMs;
       currentTimeoutMs = 0;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -93,7 +93,7 @@ void handleException(Throwable t) {
   public synchronized HttpClientRequest setFollowRedirects(boolean followRedirects) {
     checkEnded();
     if (followRedirects) {
-      this.followRedirects = client.getOptions().getMaxRedirects() - 1;
+      this.followRedirects = client.options().getMaxRedirects() - 1;
     } else {
       this.followRedirects = 0;
     }
@@ -115,7 +115,7 @@ public synchronized HttpClientRequestImpl setChunked(boolean chunked) {
       throw new IllegalStateException("Cannot set chunked after data has been written on request");
     }
     // HTTP 1.0 does not support chunking so we ignore this if HTTP 1.0
-    if (client.getOptions().getProtocolVersion() != io.vertx.core.http.HttpVersion.HTTP_1_0) {
+    if (client.options().getProtocolVersion() != io.vertx.core.http.HttpVersion.HTTP_1_0) {
       this.chunked = chunked;
     }
     return this;
@@ -217,7 +217,7 @@ public HttpClientRequest sendHead(Handler<AsyncResult<Void>> headersHandler) {
 
   @Override
   public Future<HttpClientResponse> connect() {
-    if (client.getOptions().isPipelining()) {
+    if (client.options().isPipelining()) {
       return context.failedFuture("Cannot upgrade a pipe-lined request");
     }
     doWrite(null, false, true, ar -> {});

File: src/main/java/io/vertx/core/http/impl/SharedClientHttpStreamEndpoint.java
Patch:
@@ -169,7 +169,7 @@ void acquire() {
 
   @Override
   public void requestConnection2(ContextInternal ctx, long timeout, Handler<AsyncResult<Lease<HttpClientConnection>>> handler) {
-    Request request = new Request(ctx, client.getOptions().getProtocolVersion(), timeout, handler);
+    Request request = new Request(ctx, client.options().getProtocolVersion(), timeout, handler);
     request.acquire();
   }
 }

File: src/test/java/io/vertx/core/net/ProxyErrorTest.java
Patch:
@@ -51,9 +51,7 @@ public void setUp() throws Exception {
 
   @Override
   protected void tearDown() throws Exception {
-    if (dnsServer.isStarted()) {
-      dnsServer.stop();
-    }
+    dnsServer.stop();
     if (proxy!=null) {
       proxy.stop();
     }

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -658,7 +658,7 @@ public void testResponseEndHandlersChunkedResponse() {
 
   @Test
   public void testResponseEndHandlersSendFile() throws Exception {
-    waitFor(2);
+    waitFor(4);
     AtomicInteger cnt = new AtomicInteger();
     String content = "iqdioqwdqwiojqwijdwqd";
     File toSend = setupFile("somefile.txt", content);
@@ -667,12 +667,14 @@ public void testResponseEndHandlersSendFile() throws Exception {
         // Insert another header
         req.response().putHeader("extraheader", "wibble");
         assertEquals(0, cnt.getAndIncrement());
+        complete();
       });
       req.response().bodyEndHandler(v -> {
         assertEquals(content.length(), req.response().bytesWritten());
         assertEquals(1, cnt.getAndIncrement());
         complete();
       });
+      req.response().endHandler(v -> complete());
       req.response().sendFile(toSend.getAbsolutePath());
     }).listen(testAddress, onSuccess(server -> {
       client.request(requestOptions).onComplete(onSuccess(req -> {

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -5292,8 +5292,9 @@ public void testClientEventLoopSize() throws Exception {
     for (int i = 0;i < size * 2;i++) {
       futures.add(client
         .request(requestOptions)
-        .compose(HttpClientRequest::send)
-        .compose(HttpClientResponse::body));
+        .compose(request -> request
+          .send()
+          .compose(HttpClientResponse::body)));
     }
     CompositeFuture.all(futures).onComplete(onSuccess(v -> {
       assertEquals(maxPoolSize, eventLoops.size());

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -3619,7 +3619,6 @@ public void testServerConnectionHandlerClose() throws Exception {
       conn.closeHandler(v -> complete());
     });
     server.requestHandler(req -> {
-      fail();
     });
     startServer(testAddress, serverCtx, server);
     client.connectionHandler(conn -> {

File: src/main/java/examples/HTTPExamples.java
Patch:
@@ -919,7 +919,7 @@ public void exampleAsynchronousHandshake(HttpServer server) {
         if (ar.succeeded()) {
           // Terminate the handshake with the status code 101 (Switching Protocol)
           // Reject the handshake with 401 (Unauthorized)
-          promise.complete(ar.succeeded() ? 101 : 401);
+          promise.complete(ar.result() ? 101 : 401);
         } else {
           // Will send a 500 error
           promise.fail(ar.cause());

File: src/main/java/io/vertx/core/http/impl/Http2ConnectionBase.java
Patch:
@@ -67,7 +67,7 @@ private static ByteBuf safeBuffer(ByteBuf buf) {
   private Handler<io.vertx.core.http.Http2Settings> remoteSettingsHandler;
   private final ArrayDeque<Handler<Void>> updateSettingsHandlers = new ArrayDeque<>();
   private final ArrayDeque<Promise<Buffer>> pongHandlers = new ArrayDeque<>();
-  private Http2Settings localSettings = new Http2Settings();
+  private Http2Settings localSettings;
   private Http2Settings remoteSettings;
   private Handler<GoAway> goAwayHandler;
   private Handler<Void> shutdownHandler;
@@ -83,6 +83,7 @@ public Http2ConnectionBase(EventLoopContext context, VertxHttp2ConnectionHandler
     this.windowSize = handler.connection().local().flowController().windowSize(handler.connection().connectionStream());
     this.maxConcurrentStreams = io.vertx.core.http.Http2Settings.DEFAULT_MAX_CONCURRENT_STREAMS;
     this.streamKey = handler.connection().newKey();
+    this.localSettings = handler.initialSettings();
   }
 
   VertxInternal vertx() {

File: src/main/java/io/vertx/core/http/impl/SharedClientHttpStreamEndpoint.java
Patch:
@@ -42,7 +42,7 @@ class SharedClientHttpStreamEndpoint extends ClientHttpEndpointBase<Lease<HttpCl
     long last = 0L;
     for (int i = 0; i < size; i++) {
       PoolConnection<HttpClientConnection> pooled = connections.get(i);
-      if (pooled.concurrency() > 0) {
+      if (pooled.available() > 0) {
         HttpClientConnection conn = pooled.get();
         if (selected == null) {
           selected = pooled;

File: src/main/java/io/vertx/core/net/impl/pool/ConnectionPool.java
Patch:
@@ -53,7 +53,7 @@ static <C> ConnectionPool<C> pool(PoolConnector<C> connector, int[] maxSizes, in
    * Set a {@code selector} function that decides the best connection to use.
    *
    * <p> The selector is called with the waiter and a list of candidate connections,
-   * the selector must return a connection with a positive {@link PoolConnection#concurrency()}.
+   * the selector must return a connection with a positive {@link PoolConnection#available()}.
    *
    * <p>The selector can return {@code null} if no suitable connection is found. Then the pool will
    * attempt to create a new connection or chose another available connection.

File: src/main/java/io/vertx/core/http/impl/HttpClientPush.java
Patch:
@@ -34,7 +34,7 @@ public HttpClientPush(Http2Headers headers, HttpClientStream stream) {
     String rawMethod = headers.method().toString();
     String authority = headers.authority() != null ? headers.authority().toString() : null;
     MultiMap headersMap = new Http2HeadersAdaptor(headers);
-    int pos = authority.indexOf(':');
+    int pos = authority == null ? -1 : authority.indexOf(':');
     if (pos == -1) {
       this.host = authority;
       this.port = 80;

File: src/main/java/io/vertx/core/json/impl/JsonUtil.java
Patch:
@@ -106,14 +106,12 @@ public static Object deepCopy(Object val, Function<Object, ?> copier) {
       val = val.toString();
     } else if (val instanceof Shareable) {
       // Shareable objects know how to copy themselves, this covers:
-      // JsonObject, JsonArray or any user defined type that can shared across the cluster
+      // JsonObject, JsonArray, Buffer or any user defined type that can shared across the cluster
       val = ((Shareable) val).copy();
     } else if (val instanceof Map) {
       val = (new JsonObject((Map) val)).copy(copier);
     } else if (val instanceof List) {
       val = (new JsonArray((List) val)).copy(copier);
-    } else if (val instanceof Buffer) {
-      val = ((Buffer) val).copy();
     } else if (val instanceof byte[]) {
       // OK
     } else if (val instanceof Instant) {

File: src/main/java/io/vertx/core/json/jackson/JacksonCodec.java
Patch:
@@ -105,6 +105,9 @@ public String toString(Object object, boolean pretty) throws EncodeException {
   @Override
   public Buffer toBuffer(Object object, boolean pretty) throws EncodeException {
     ByteBuf buf = Unpooled.buffer();
+    // There is no need to use a try with resources here as jackson
+    // is a well-behaved and always calls the closes all streams in the
+    // "finally" block bellow.
     ByteBufOutputStream out = new ByteBufOutputStream(buf);
     JsonGenerator generator = createGenerator(out, pretty);
     try {

File: src/main/java/io/vertx/core/http/impl/HttpClientPush.java
Patch:
@@ -34,7 +34,7 @@ public HttpClientPush(Http2Headers headers, HttpClientStream stream) {
     String rawMethod = headers.method().toString();
     String authority = headers.authority() != null ? headers.authority().toString() : null;
     MultiMap headersMap = new Http2HeadersAdaptor(headers);
-    int pos = authority.indexOf(':');
+    int pos = authority == null ? -1 : authority.indexOf(':');
     if (pos == -1) {
       this.host = authority;
       this.port = 80;

File: src/main/java/io/vertx/core/json/impl/JsonUtil.java
Patch:
@@ -106,14 +106,12 @@ public static Object deepCopy(Object val, Function<Object, ?> copier) {
       val = val.toString();
     } else if (val instanceof Shareable) {
       // Shareable objects know how to copy themselves, this covers:
-      // JsonObject, JsonArray or any user defined type that can shared across the cluster
+      // JsonObject, JsonArray, Buffer or any user defined type that can shared across the cluster
       val = ((Shareable) val).copy();
     } else if (val instanceof Map) {
       val = (new JsonObject((Map) val)).copy(copier);
     } else if (val instanceof List) {
       val = (new JsonArray((List) val)).copy(copier);
-    } else if (val instanceof Buffer) {
-      val = ((Buffer) val).copy();
     } else if (val instanceof byte[]) {
       // OK
     } else if (val instanceof Instant) {

File: src/main/java/io/vertx/core/file/impl/FileResolverImpl.java
Patch:
@@ -237,6 +237,7 @@ private File unpackUrlResource(URL url, String fileName, ClassLoader cl, boolean
       case "bundleresource": // Equinox
       case "jrt": // java run-time (JEP 220)
       case "resource":  // substratevm (graal native image)
+      case "vfs":  // jboss-vfs
         return unpackFromBundleURL(url, isDir);
       default:
         throw new IllegalStateException("Invalid url protocol: " + prot);

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -486,9 +486,6 @@ public void close(Promise<Void> completion) {
     }
     webSocketCM.close();
     httpCM.close();
-    if (metrics != null) {
-      metrics.close();
-    }
     completion.complete();
   }
 

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -404,6 +404,7 @@ protected void handleEvent(Object evt) {
    * perform extra work when the idle event happens.
    */
   protected void handleIdle(IdleStateEvent event) {
+    log.debug("The connection will be closed due to timeout");
     chctx.close();
   }
 

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -23,6 +23,7 @@
 import io.vertx.core.Handler;
 import io.vertx.core.Promise;
 import io.vertx.core.http.HttpClientOptions;
+import io.vertx.core.http.HttpHeaders;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.impl.EventLoopContext;
 import io.vertx.core.impl.ContextInternal;
@@ -169,7 +170,7 @@ private void applyHttp1xConnectionOptions(ChannelPipeline pipeline) {
       options.getMaxHeaderSize(),
       options.getMaxChunkSize(),
       false,
-      false,
+      !HttpHeaders.DISABLE_HTTP_HEADERS_VALIDATION,
       options.getDecoderInitialBufferSize()));
     if (options.isTryUseCompression()) {
       pipeline.addLast("inflater", new HttpContentDecompressor(false));

File: src/main/java/io/vertx/core/http/RequestOptions.java
Patch:
@@ -526,7 +526,7 @@ public MultiMap getHeaders() {
 
   private void checkHeaders() {
     if (headers == null) {
-      headers = MultiMap.caseInsensitiveMultiMap();
+      headers = HttpHeaders.headers();
     }
   }
 

File: src/main/java/io/vertx/core/net/impl/pool/PoolWaiter.java
Patch:
@@ -53,6 +53,7 @@ default void onConnect(PoolWaiter<C> waiter) {
   PoolWaiter<C> prev;
   PoolWaiter<C> next;
   boolean disposed;
+  boolean queued;
 
   PoolWaiter(PoolWaiter.Listener<C> listener, ContextInternal context, final int capacity, Handler<AsyncResult<Lease<C>>> handler) {
     this.listener = listener;

File: src/main/java/io/vertx/core/net/impl/transport/Transport.java
Patch:
@@ -180,7 +180,7 @@ public DatagramChannel datagramChannel(InternetProtocolFamily family) {
    */
   public ChannelFactory<? extends Channel> channelFactory(boolean domainSocket) {
     if (domainSocket) {
-      throw new IllegalArgumentException();
+      throw new IllegalArgumentException("The Vertx instance must be created with the preferNativeTransport option set to true to create domain sockets");
     }
     return NioSocketChannel::new;
   }

File: src/main/java/io/vertx/core/http/Http2Settings.java
Patch:
@@ -57,9 +57,9 @@ public class Http2Settings {
   public static final int DEFAULT_MAX_FRAME_SIZE = 16384;
 
   /**
-   * Default HTTP/2 spec value for {@link #getMaxHeaderListSize} : {@code Integer.MAX_VALUE}
+   * Default HTTP/2 spec value for {@link #getMaxHeaderListSize} : {@code 8192}
    */
-  public static final int DEFAULT_MAX_HEADER_LIST_SIZE = Integer.MAX_VALUE;
+  public static final int DEFAULT_MAX_HEADER_LIST_SIZE = 8192;
 
   /**
    * Default HTTP/2 spec value for {@link #getExtraSettings} : {@code null}

File: src/main/java/io/vertx/core/http/impl/Http2UpgradedClientConnection.java
Patch:
@@ -172,7 +172,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         public void upgradeTo(ChannelHandlerContext ctx, FullHttpResponse upgradeResponse) throws Exception {
 
           // Now we need to upgrade this to an HTTP2
-          VertxHttp2ConnectionHandler<Http2ClientConnection> handler = Http2ClientConnection.createHttp2ConnectionHandler(upgradedConnection.client, upgradingConnection.metrics, (EventLoopContext) upgradingConnection.getContext(), upgradedConnection.current.metric(), conn -> {
+          VertxHttp2ConnectionHandler<Http2ClientConnection> handler = Http2ClientConnection.createHttp2ConnectionHandler(upgradedConnection.client, upgradingConnection.metrics, (EventLoopContext) upgradingConnection.getContext(), true, upgradedConnection.current.metric(), conn -> {
             conn.upgradeStream(upgradingStream.metric(), upgradingStream.getContext(), ar -> {
               upgradingConnection.closeHandler(null);
               upgradingConnection.exceptionHandler(null);

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -73,6 +73,7 @@ protected void tearDown() throws Exception {
       awaitLatch(latch);
     }
     super.tearDown();
+    FakeMetricsBase.sanityCheck();
   }
 
   @Override
@@ -1205,6 +1206,6 @@ public void testHTTP2ConnectionCloseBeforePrefaceIsReceived() throws Exception {
       so.closeHandler(v -> latch.countDown());
     }));
     awaitLatch(latch);
-    assertEquals(0, metrics.getConnectionCount());
+    assertEquals(0, metrics.connectionCount());
   }
 }

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -4738,7 +4738,7 @@ public void testHeaderNameStartsOrEndsWithControlChars() throws Exception {
     server.requestHandler(req -> {
       fail();
     });
-    startServer();
+    startServer(testAddress);
     NetClient client = vertx.createNetClient();
     try {
       char[] chars = { 0x1c, 0x1d, 0x1e, 0x1f, 0x0c };

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -191,7 +191,6 @@ public HttpClientImpl(VertxInternal vertx, HttpClientOptions options, CloseFutur
     }
 
     closeFuture.add(netClient);
-    closeFuture.add(this);
   }
 
   /**

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -334,14 +334,15 @@ public HttpClient createHttpClient(HttpClientOptions options, CloseFuture closeF
   }
 
   public HttpClient createHttpClient(HttpClientOptions options) {
-    CloseFuture closeFuture = resolveCloseFuture();
+    CloseFuture closeFuture = new CloseFuture();
     HttpClient client;
     if (options.isShared()) {
       client = createSharedClient(SharedHttpClient.SHARED_MAP_NAME, options.getName(), closeFuture, cf -> createHttpClient(options, cf));
       client = new SharedHttpClient(this, closeFuture, client);
     } else {
       client = createHttpClient(options, closeFuture);
     }
+    resolveCloseFuture().add(closeFuture);
     return client;
   }
 

File: src/main/java/io/vertx/core/net/KeyStoreOptionsBase.java
Patch:
@@ -177,11 +177,12 @@ KeyStoreHelper getHelper(Vertx vertx) throws Exception {
     if (helper == null) {
       Supplier<Buffer> value;
       if (this.path != null) {
-        value = () -> vertx.fileSystem().readFileBlocking(((VertxInternal) vertx).resolveFile(path).getAbsolutePath());
+        value = () -> vertx.fileSystem().readFileBlocking(path);
       } else if (this.value != null) {
         value = this::getValue;
       } else {
-        return null;
+        // Keystore input can be "null", for example PKCS#11
+        value = () -> null;
       }
       helper = new KeyStoreHelper(KeyStoreHelper.loadKeyStore(type, provider, password, value, getAlias()), password, getAliasPassword());
     }

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -578,7 +578,7 @@ private void doRequest(RequestOptions request, PromiseInternal<HttpClientRequest
       peerHost = peerHost.substring(0, peerHost.length() -  1);
     }
     SocketAddress peerAddress = SocketAddress.inetSocketAddress(port, peerHost);
-    doRequest(method, peerAddress, server, host, port, useSSL, requestURI, headers, timeout, followRedirects, proxyOptions, promise);
+    doRequest(method, peerAddress, server, host, port, useSSL, requestURI, headers, request.getTraceOperation(), timeout, followRedirects, proxyOptions, promise);
   }
 
   private void doRequest(
@@ -590,6 +590,7 @@ private void doRequest(
     Boolean useSSL,
     String requestURI,
     MultiMap headers,
+    String traceOperation,
     long timeout,
     Boolean followRedirects,
     ProxyOptions proxyOptions,
@@ -606,7 +607,7 @@ private void doRequest(
             stream.closeHandler(v -> {
               lease.recycle();
             });
-            HttpClientRequestImpl req = new HttpClientRequestImpl(this, stream, ctx.promise(), useSSL, method, server, host, port, requestURI);
+            HttpClientRequestImpl req = new HttpClientRequestImpl(this, stream, ctx.promise(), useSSL, method, server, host, port, requestURI, traceOperation);
             if (headers != null) {
               req.headers().setAll(headers);
             }

File: src/test/java/io/vertx/core/http/Http1xClientConnectionTest.java
Patch:
@@ -69,7 +69,7 @@ public void testResetStreamRequestSent() throws Exception {
             stream.reset(cause);
           });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", ""), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false, null);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, false, new StreamPriority(), false, null);
       }));
     }));
     await();
@@ -93,7 +93,7 @@ public void testServerConnectionClose() throws Exception {
           complete();
         });
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", ""), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false, null);
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false, null);
       }));
     }));
     await();

File: src/test/java/io/vertx/core/http/HttpClientConnectionTest.java
Patch:
@@ -51,7 +51,7 @@ public void testGet() throws Exception {
     client.connect(testAddress, peerAddress).onComplete(onSuccess(conn -> {
       conn.createStream((ContextInternal) vertx.getOrCreateContext(), onSuccess(stream -> {
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", ""), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false, onSuccess(v -> {
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false, onSuccess(v -> {
         }));
         stream.headHandler(resp -> {
           assertEquals(200, resp.statusCode);
@@ -84,7 +84,7 @@ public void testConnectionClose() throws Exception {
       });
       conn.createStream((ContextInternal) vertx.getOrCreateContext(), onSuccess(stream -> {
         stream.writeHead(new HttpRequestHead(
-          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", ""), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false, onSuccess(v -> {
+          HttpMethod.GET, "/", MultiMap.caseInsensitiveMultiMap(), "localhost:8080", "", null), false, Unpooled.EMPTY_BUFFER, true, new StreamPriority(), false, onSuccess(v -> {
         }));
         stream.headHandler(resp -> {
           fail();

File: src/test/java/io/vertx/test/fakemetrics/FakeHttpClientMetrics.java
Patch:
@@ -155,6 +155,7 @@ public static void sanityCheck() {
     if (err != null) {
       AssertionFailedError afe = new AssertionFailedError();
       afe.initCause(err);
+      unexpectedError = null;
       throw afe;
     }
   }

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -758,7 +758,7 @@ private void handleResponseBegin(Stream stream, HttpResponseHead response) {
         if ((request.method == HttpMethod.CONNECT &&
              response.statusCode == 200) || (
              request.method == HttpMethod.GET &&
-             request.headers != null && request.headers.contains("connection", "Upgrade", false) &&
+             request.headers != null && request.headers.contains(CONNECTION, UPGRADE, true) &&
              response.statusCode == 101)) {
           removeChannelHandlers();
         } else {

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java
Patch:
@@ -52,7 +52,6 @@
 import javax.security.cert.X509Certificate;
 import java.net.URISyntaxException;
 import java.nio.channels.ClosedChannelException;
-import java.util.List;
 import java.util.Set;
 
 /**

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -644,7 +644,7 @@ public void testDefaultServerOptionsJson() {
   @Test
   public void testServerOptionsJson() {
     int sendBufferSize = TestUtils.randomPositiveInt();
-    int receiverBufferSize = TestUtils.randomPortInt();
+    int receiverBufferSize = TestUtils.randomPositiveInt();
     Random rand = new Random();
     boolean reuseAddress = rand.nextBoolean();
     int trafficClass = TestUtils.randomByte() + 128;

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -402,7 +402,7 @@ public <T> void sendOrPubInternal(MessageImpl message, DeliveryOptions options,
 
   private Future<Void> unregisterAll() {
     // Unregister all handlers explicitly - don't rely on context hooks
-    List<Future<?>> futures = new ArrayList<>();
+    List<Future> futures = new ArrayList<>();
     for (ConcurrentCyclicSequence<HandlerHolder> handlers : handlerMap.values()) {
       for (HandlerHolder holder : handlers) {
         futures.add(holder.getHandler().unregister());

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -101,7 +101,7 @@ public Future<Void> undeployAll() {
         deploymentIDs.add(entry.getKey());
       }
     }
-    List<Future<?>> completionList = new ArrayList<>();
+    List<Future> completionList = new ArrayList<>();
     if (!deploymentIDs.isEmpty()) {
       for (String deploymentID : deploymentIDs) {
         Promise<Void> promise = Promise.promise();
@@ -302,7 +302,7 @@ private synchronized void rollback(ContextInternal callingContext, Handler<Async
 
     private synchronized Future<Void> doUndeployChildren(ContextInternal undeployingContext) {
       if (!children.isEmpty()) {
-        List<Future<?>> childFuts = new ArrayList<>();
+        List<Future> childFuts = new ArrayList<>();
         for (Deployment childDeployment: new HashSet<>(children)) {
           Promise<Void> p = Promise.promise();
           childFuts.add(p.future());
@@ -326,7 +326,7 @@ public synchronized Future<Void> doUndeploy(ContextInternal undeployingContext)
         return doUndeployChildren(undeployingContext).compose(v -> doUndeploy(undeployingContext));
       } else {
         status = ST_UNDEPLOYED;
-        List<Future<?>> undeployFutures = new ArrayList<>();
+        List<Future> undeployFutures = new ArrayList<>();
         if (parent != null) {
           parent.removeChild(this);
         }

File: src/main/java/io/vertx/core/net/impl/TCPServerBase.java
Patch:
@@ -254,7 +254,7 @@ private void actualClose(Promise<Void> done) {
    * Internal method that closes all servers when Vert.x is closing
    */
   public void closeAll(Handler<AsyncResult<Void>> handler) {
-    List<Future<?>> futures = new ArrayList<>(actualServer.servers)
+    List<Future> futures = new ArrayList<>(actualServer.servers)
       .stream()
       .map(TCPServerBase::close)
       .collect(Collectors.toList());

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -598,7 +598,7 @@ private void testDuplicateExecuteBlocking(Supplier<ContextInternal> supplier, bo
     int n = 2;
     List<ContextInternal> dup1 = Stream.generate(supplier).limit(n).collect(Collectors.toList());
     AtomicInteger cnt = new AtomicInteger();
-    List<Future<?>> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
+    List<Future> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
       assertTrue(Context.isOnWorkerThread());
       int val = cnt.incrementAndGet();
       if (ordered) {

File: src/test/java/io/vertx/core/shareddata/AsyncMapTest.java
Patch:
@@ -765,9 +765,9 @@ protected Map<JsonObject, Buffer> genJsonToBuffer(int size) {
   }
 
   protected void loadData(Map<JsonObject, Buffer> map, BiConsumer<Vertx, AsyncMap<JsonObject, Buffer>> test) {
-    List<Future<?>> futures = new ArrayList<>(map.size());
+    List<Future> futures = new ArrayList<>(map.size());
     map.forEach((key, value) -> {
-      Promise<Void> future = Promise.promise();
+      Promise future = Promise.promise();
       getVertx().sharedData().getAsyncMap("foo", onSuccess(asyncMap -> {
         asyncMap.put(key, value, future);
       }));

File: src/test/java/io/vertx/core/shareddata/AsynchronousLockTest.java
Patch:
@@ -252,7 +252,7 @@ public void evictTimedOutWaiters() {
     int numWaiters = 10;
     SharedData sharedData = vertx.sharedData();
     sharedData.getLocalLock("foo", onSuccess(lock -> {
-      List<Future<?>> locks = new ArrayList<>();
+      List<Future> locks = new ArrayList<>();
       for (int i = 0;i < numWaiters;i++) {
         locks.add(sharedData.getLocalLockWithTimeout("foo", 200));
       }

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -788,7 +788,7 @@ public void testMulti() {
       servers.add(server);
     }
     try {
-      List<Future<?>> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
+      List<Future> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
       CompositeFuture
         .all(collect)
         .onSuccess(v -> {

File: src/test/java/io/vertx/test/verticles/FaultToleranceVerticle.java
Patch:
@@ -40,7 +40,7 @@ public void start() throws Exception {
     JsonObject config = config();
     id = config.getInteger("id");
     numAddresses = config.getInteger("addressesCount");
-    List<Future<?>> registrationFutures = new ArrayList<>(numAddresses);
+    List<Future> registrationFutures = new ArrayList<>(numAddresses);
     for (int i = 0; i < numAddresses; i++) {
       Promise<Void> registrationFuture = Promise.promise();
       registrationFutures.add(registrationFuture.future());

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -402,7 +402,7 @@ public <T> void sendOrPubInternal(MessageImpl message, DeliveryOptions options,
 
   private Future<Void> unregisterAll() {
     // Unregister all handlers explicitly - don't rely on context hooks
-    List<Future> futures = new ArrayList<>();
+    List<Future<?>> futures = new ArrayList<>();
     for (ConcurrentCyclicSequence<HandlerHolder> handlers : handlerMap.values()) {
       for (HandlerHolder holder : handlers) {
         futures.add(holder.getHandler().unregister());

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -101,7 +101,7 @@ public Future<Void> undeployAll() {
         deploymentIDs.add(entry.getKey());
       }
     }
-    List<Future> completionList = new ArrayList<>();
+    List<Future<?>> completionList = new ArrayList<>();
     if (!deploymentIDs.isEmpty()) {
       for (String deploymentID : deploymentIDs) {
         Promise<Void> promise = Promise.promise();
@@ -302,7 +302,7 @@ private synchronized void rollback(ContextInternal callingContext, Handler<Async
 
     private synchronized Future<Void> doUndeployChildren(ContextInternal undeployingContext) {
       if (!children.isEmpty()) {
-        List<Future> childFuts = new ArrayList<>();
+        List<Future<?>> childFuts = new ArrayList<>();
         for (Deployment childDeployment: new HashSet<>(children)) {
           Promise<Void> p = Promise.promise();
           childFuts.add(p.future());
@@ -326,7 +326,7 @@ public synchronized Future<Void> doUndeploy(ContextInternal undeployingContext)
         return doUndeployChildren(undeployingContext).compose(v -> doUndeploy(undeployingContext));
       } else {
         status = ST_UNDEPLOYED;
-        List<Future> undeployFutures = new ArrayList<>();
+        List<Future<?>> undeployFutures = new ArrayList<>();
         if (parent != null) {
           parent.removeChild(this);
         }

File: src/main/java/io/vertx/core/net/impl/TCPServerBase.java
Patch:
@@ -254,7 +254,7 @@ private void actualClose(Promise<Void> done) {
    * Internal method that closes all servers when Vert.x is closing
    */
   public void closeAll(Handler<AsyncResult<Void>> handler) {
-    List<Future> futures = new ArrayList<>(actualServer.servers)
+    List<Future<?>> futures = new ArrayList<>(actualServer.servers)
       .stream()
       .map(TCPServerBase::close)
       .collect(Collectors.toList());

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -598,7 +598,7 @@ private void testDuplicateExecuteBlocking(Supplier<ContextInternal> supplier, bo
     int n = 2;
     List<ContextInternal> dup1 = Stream.generate(supplier).limit(n).collect(Collectors.toList());
     AtomicInteger cnt = new AtomicInteger();
-    List<Future> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
+    List<Future<?>> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
       assertTrue(Context.isOnWorkerThread());
       int val = cnt.incrementAndGet();
       if (ordered) {

File: src/test/java/io/vertx/core/shareddata/AsyncMapTest.java
Patch:
@@ -765,9 +765,9 @@ protected Map<JsonObject, Buffer> genJsonToBuffer(int size) {
   }
 
   protected void loadData(Map<JsonObject, Buffer> map, BiConsumer<Vertx, AsyncMap<JsonObject, Buffer>> test) {
-    List<Future> futures = new ArrayList<>(map.size());
+    List<Future<?>> futures = new ArrayList<>(map.size());
     map.forEach((key, value) -> {
-      Promise future = Promise.promise();
+      Promise<Void> future = Promise.promise();
       getVertx().sharedData().getAsyncMap("foo", onSuccess(asyncMap -> {
         asyncMap.put(key, value, future);
       }));

File: src/test/java/io/vertx/core/shareddata/AsynchronousLockTest.java
Patch:
@@ -252,7 +252,7 @@ public void evictTimedOutWaiters() {
     int numWaiters = 10;
     SharedData sharedData = vertx.sharedData();
     sharedData.getLocalLock("foo", onSuccess(lock -> {
-      List<Future> locks = new ArrayList<>();
+      List<Future<?>> locks = new ArrayList<>();
       for (int i = 0;i < numWaiters;i++) {
         locks.add(sharedData.getLocalLockWithTimeout("foo", 200));
       }

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -788,7 +788,7 @@ public void testMulti() {
       servers.add(server);
     }
     try {
-      List<Future> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
+      List<Future<?>> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
       CompositeFuture
         .all(collect)
         .onSuccess(v -> {

File: src/test/java/io/vertx/test/verticles/FaultToleranceVerticle.java
Patch:
@@ -40,7 +40,7 @@ public void start() throws Exception {
     JsonObject config = config();
     id = config.getInteger("id");
     numAddresses = config.getInteger("addressesCount");
-    List<Future> registrationFutures = new ArrayList<>(numAddresses);
+    List<Future<?>> registrationFutures = new ArrayList<>(numAddresses);
     for (int i = 0; i < numAddresses; i++) {
       Promise<Void> registrationFuture = Promise.promise();
       registrationFutures.add(registrationFuture.future());

File: src/main/java/io/vertx/core/buffer/impl/BufferImpl.java
Patch:
@@ -518,7 +518,7 @@ public int length() {
   }
 
   public Buffer copy() {
-    return new BufferImpl(buffer.copy());
+    return buffer.isReadOnly() ? this : new BufferImpl(buffer.copy());
   }
 
   public Buffer slice() {

File: src/test/java/io/vertx/core/DeploymentTest.java
Patch:
@@ -1598,7 +1598,7 @@ public void testContextClassLoader() throws Exception {
     ClassLoader cl = new ClassLoader(Thread.currentThread().getContextClassLoader()) {
       @Override
       public URL getResource(String name) {
-        if (name.equals("/foo.txt")) {
+        if (name.equals("foo.txt")) {
           used.set(true);
           return url;
         }
@@ -1610,7 +1610,7 @@ public URL getResource(String name) {
       public void start() {
         assertSame(cl, Thread.currentThread().getContextClassLoader());
         assertSame(cl, ((ContextInternal)context).classLoader());
-        vertx.fileSystem().props("/foo.txt", onSuccess(props -> {
+        vertx.fileSystem().props("foo.txt", onSuccess(props -> {
           assertEquals(5, props.size());
           assertTrue(used.get());
           vertx.undeploy(context.deploymentID(), onSuccess(v -> {

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -308,7 +308,7 @@ public int getIdleTimeout() {
    */
   public TCPSSLOptions setReadIdleTimeout(int idleTimeout) {
     if (idleTimeout < 0) {
-      throw new IllegalArgumentException("idleTimeout must be >= 0");
+      throw new IllegalArgumentException("readIdleTimeout must be >= 0");
     }
     this.readIdleTimeout = idleTimeout;
     return this;
@@ -332,7 +332,7 @@ public int getReadIdleTimeout() {
    */
   public TCPSSLOptions setWriteIdleTimeout(int idleTimeout) {
     if (idleTimeout < 0) {
-      throw new IllegalArgumentException("idleTimeout must be >= 0");
+      throw new IllegalArgumentException("writeIdleTimeout must be >= 0");
     }
     this.writeIdleTimeout = idleTimeout;
     return this;

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -25,6 +25,7 @@
 import io.netty.handler.codec.http.websocketx.extensions.compression.DeflateFrameClientExtensionHandshaker;
 import io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateClientExtensionHandshaker;
 import io.netty.handler.codec.http.websocketx.extensions.compression.PerMessageDeflateServerExtensionHandshaker;
+import io.netty.handler.timeout.IdleStateEvent;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.FutureListener;
 import io.vertx.core.*;
@@ -1091,13 +1092,13 @@ protected void handleClosed() {
     }
   }
 
-  protected void handleIdle() {
+  protected void handleIdle(IdleStateEvent event) {
     synchronized (this) {
       if (webSocket == null && responses.isEmpty() && requests.isEmpty()) {
         return;
       }
     }
-    super.handleIdle();
+    super.handleIdle(event);
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.http2.Http2Exception;
 import io.netty.handler.codec.http2.Http2Headers;
 import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.handler.timeout.IdleStateEvent;
 import io.vertx.core.*;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.*;
@@ -584,9 +585,9 @@ public HttpClientConnection connection() {
   }
 
   @Override
-  protected void handleIdle() {
+  protected void handleIdle(IdleStateEvent event) {
     if (handler.connection().local().numActiveStreams() > 0) {
-      super.handleIdle();
+      super.handleIdle(event);
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/Http2ConnectionBase.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.http2.Http2Headers;
 import io.netty.handler.codec.http2.Http2Settings;
 import io.netty.handler.codec.http2.Http2Stream;
+import io.netty.handler.timeout.IdleStateEvent;
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
@@ -33,7 +34,6 @@
 import io.vertx.core.http.GoAway;
 import io.vertx.core.http.HttpConnection;
 import io.vertx.core.http.StreamPriority;
-import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.EventLoopContext;
 import io.vertx.core.impl.future.PromiseInternal;
 import io.vertx.core.impl.VertxInternal;
@@ -106,8 +106,8 @@ protected void handleInterestedOpsChanged() {
   }
 
   @Override
-  protected void handleIdle() {
-    super.handleIdle();
+  protected void handleIdle(IdleStateEvent event) {
+    super.handleIdle(event);
   }
 
   synchronized void onConnectionError(Throwable cause) {

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java
Patch:
@@ -150,8 +150,8 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
     try {
       super.userEventTriggered(ctx, evt);
     } finally {
-      if (evt instanceof IdleStateEvent && ((IdleStateEvent) evt).state() == IdleState.ALL_IDLE) {
-        connection.handleIdle();
+      if (evt instanceof IdleStateEvent) {
+        connection.handleIdle((IdleStateEvent) evt);
       }
     }
   }

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -15,6 +15,7 @@
 import io.netty.channel.*;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedFile;
+import io.netty.handler.timeout.IdleStateEvent;
 import io.netty.util.AttributeKey;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
@@ -396,8 +397,9 @@ private void checkCloseHandler(AsyncResult<Void> ar) {
    * <p/>
    * Subclasses can override it to prevent the idle event to happen (e.g when the connection is pooled) or
    * perform extra work when the idle event happens.
+   * @param event
    */
-  protected void handleIdle() {
+  protected void handleIdle(IdleStateEvent event) {
     chctx.close();
   }
 

File: src/main/java/io/vertx/core/net/impl/VertxHandler.java
Patch:
@@ -161,8 +161,8 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce
 
   @Override
   public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
-    if (evt instanceof IdleStateEvent && ((IdleStateEvent) evt).state() == IdleState.ALL_IDLE) {
-      conn.handleIdle();
+    if (evt instanceof IdleStateEvent) {
+      conn.handleIdle((IdleStateEvent) evt);
     } else {
       ctx.fireUserEventTriggered(evt);
     }

File: src/main/java/io/vertx/core/http/impl/HttpServerFileUploadImpl.java
Patch:
@@ -76,7 +76,9 @@ private void handleData(Buffer data) {
     Handler<Buffer> handler;
     synchronized (HttpServerFileUploadImpl.this) {
       handler = dataHandler;
-      size += data.length();
+      if (lazyCalculateSize) {
+        size += data.length();
+      }
     }
     if (handler != null) {
       context.dispatch(data, handler);

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -312,7 +312,7 @@ private void webSocket(WebSocketConnectOptions connectOptions, PromiseInternal<W
       ar -> {
         if (ar.succeeded()) {
           Http1xClientConnection conn = (Http1xClientConnection) ar.result();
-          conn.toWebSocket(ctx, connectOptions.getURI(), connectOptions.getHeaders(), connectOptions.getVersion(), connectOptions.getSubProtocols(), HttpClientImpl.this.options.getMaxWebSocketFrameSize(), promise);
+          conn.toWebSocket(ctx, connectOptions.getURI(), connectOptions.getHeaders(), connectOptions.getAllowOriginHeader(), connectOptions.getVersion(), connectOptions.getSubProtocols(), HttpClientImpl.this.options.getMaxWebSocketFrameSize(), promise);
         } else {
           promise.fail(ar.cause());
         }

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponse.java
Patch:
@@ -716,7 +716,7 @@ Set<ServerCookie> cookies() {
   public HttpServerResponse addCookie(Cookie cookie) {
     synchronized (conn) {
       checkHeadWritten();
-      cookies().add((ServerCookie) cookie);
+      CookieImpl.addCookie(cookies(), (ServerCookie) cookie);
     }
     return this;
   }

File: src/main/java/io/vertx/core/http/impl/SharedClientHttpStreamEndpoint.java
Patch:
@@ -119,13 +119,13 @@ void checkExpired() {
 
   private class Request implements PoolWaiter.Listener<HttpClientConnection>, Handler<AsyncResult<Lease<HttpClientConnection>>> {
 
-    private final EventLoopContext context;
+    private final ContextInternal context;
     private final HttpVersion protocol;
     private final long timeout;
     private final Handler<AsyncResult<Lease<HttpClientConnection>>> handler;
     private long timerID;
 
-    Request(EventLoopContext context, HttpVersion protocol, long timeout, Handler<AsyncResult<Lease<HttpClientConnection>>> handler) {
+    Request(ContextInternal context, HttpVersion protocol, long timeout, Handler<AsyncResult<Lease<HttpClientConnection>>> handler) {
       this.context = context;
       this.protocol = protocol;
       this.timeout = timeout;
@@ -166,7 +166,7 @@ void acquire() {
 
   @Override
   public void requestConnection2(ContextInternal ctx, long timeout, Handler<AsyncResult<Lease<HttpClientConnection>>> handler) {
-    Request request = new Request((EventLoopContext) ctx, client.getOptions().getProtocolVersion(), timeout, handler);
+    Request request = new Request(ctx, client.getOptions().getProtocolVersion(), timeout, handler);
     request.acquire();
   }
 }

File: src/main/java/io/vertx/core/net/impl/pool/ConnectionManager.java
Patch:
@@ -13,6 +13,7 @@
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
+import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.EventLoopContext;
 
 import java.util.*;
@@ -38,13 +39,13 @@ public void forEach(Consumer<Endpoint<C>> consumer) {
     endpointMap.values().forEach(consumer);
   }
 
-  public void getConnection(EventLoopContext ctx,
+  public void getConnection(ContextInternal ctx,
                             K key,
                             Handler<AsyncResult<C>> handler) {
     getConnection(ctx, key, 0, handler);
   }
 
-  public void getConnection(EventLoopContext ctx,
+  public void getConnection(ContextInternal ctx,
                             K key,
                             long timeout,
                             Handler<AsyncResult<C>> handler) {

File: src/main/java/io/vertx/core/net/impl/pool/PoolConnection.java
Patch:
@@ -10,7 +10,7 @@
  */
 package io.vertx.core.net.impl.pool;
 
-import io.vertx.core.Context;
+import io.vertx.core.impl.ContextInternal;
 
 /**
  * A wrapper for the actual connection.
@@ -22,7 +22,7 @@ public interface PoolConnection<C> {
   /**
    * @return the connection context
    */
-  Context context();
+  ContextInternal context();
 
   /**
    * @return the connection

File: src/main/java/io/vertx/core/dns/AddressResolverOptions.java
Patch:
@@ -39,12 +39,12 @@ public class AddressResolverOptions {
   public static final boolean DEFAULT_OPT_RESOURCE_ENABLED = false;
 
   /**
-   * The default value for the negative cache min TTL = 0
+   * The default value for the cache min TTL = 0
    */
   public static final int DEFAULT_CACHE_MIN_TIME_TO_LIVE = 0;
 
   /**
-   * The default value for the negative cache max TTL = 0x7fffffff
+   * The default value for the cache max TTL = 0x7fffffff
    */
   public static final int DEFAULT_CACHE_MAX_TIME_TO_LIVE = Integer.MAX_VALUE;
 

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -402,7 +402,7 @@ public <T> void sendOrPubInternal(MessageImpl message, DeliveryOptions options,
 
   private Future<Void> unregisterAll() {
     // Unregister all handlers explicitly - don't rely on context hooks
-    List<Future> futures = new ArrayList<>();
+    List<Future<?>> futures = new ArrayList<>();
     for (ConcurrentCyclicSequence<HandlerHolder> handlers : handlerMap.values()) {
       for (HandlerHolder holder : handlers) {
         futures.add(holder.getHandler().unregister());

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -101,7 +101,7 @@ public Future<Void> undeployAll() {
         deploymentIDs.add(entry.getKey());
       }
     }
-    List<Future> completionList = new ArrayList<>();
+    List<Future<?>> completionList = new ArrayList<>();
     if (!deploymentIDs.isEmpty()) {
       for (String deploymentID : deploymentIDs) {
         Promise<Void> promise = Promise.promise();
@@ -302,7 +302,7 @@ private synchronized void rollback(ContextInternal callingContext, Handler<Async
 
     private synchronized Future<Void> doUndeployChildren(ContextInternal undeployingContext) {
       if (!children.isEmpty()) {
-        List<Future> childFuts = new ArrayList<>();
+        List<Future<?>> childFuts = new ArrayList<>();
         for (Deployment childDeployment: new HashSet<>(children)) {
           Promise<Void> p = Promise.promise();
           childFuts.add(p.future());
@@ -326,7 +326,7 @@ public synchronized Future<Void> doUndeploy(ContextInternal undeployingContext)
         return doUndeployChildren(undeployingContext).compose(v -> doUndeploy(undeployingContext));
       } else {
         status = ST_UNDEPLOYED;
-        List<Future> undeployFutures = new ArrayList<>();
+        List<Future<?>> undeployFutures = new ArrayList<>();
         if (parent != null) {
           parent.removeChild(this);
         }

File: src/main/java/io/vertx/core/net/impl/TCPServerBase.java
Patch:
@@ -247,7 +247,7 @@ private void actualClose(Promise<Void> done) {
    * Internal method that closes all servers when Vert.x is closing
    */
   public void closeAll(Handler<AsyncResult<Void>> handler) {
-    List<Future> futures = new ArrayList<>(actualServer.servers)
+    List<Future<?>> futures = new ArrayList<>(actualServer.servers)
       .stream()
       .map(TCPServerBase::close)
       .collect(Collectors.toList());

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -598,7 +598,7 @@ private void testDuplicateExecuteBlocking(Supplier<ContextInternal> supplier, bo
     int n = 2;
     List<ContextInternal> dup1 = Stream.generate(supplier).limit(n).collect(Collectors.toList());
     AtomicInteger cnt = new AtomicInteger();
-    List<Future> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
+    List<Future<?>> futures = dup1.stream().map(c -> c.<Void>executeBlocking(duplicate -> {
       assertTrue(Context.isOnWorkerThread());
       int val = cnt.incrementAndGet();
       if (ordered) {

File: src/test/java/io/vertx/core/shareddata/AsyncMapTest.java
Patch:
@@ -765,9 +765,9 @@ protected Map<JsonObject, Buffer> genJsonToBuffer(int size) {
   }
 
   protected void loadData(Map<JsonObject, Buffer> map, BiConsumer<Vertx, AsyncMap<JsonObject, Buffer>> test) {
-    List<Future> futures = new ArrayList<>(map.size());
+    List<Future<?>> futures = new ArrayList<>(map.size());
     map.forEach((key, value) -> {
-      Promise future = Promise.promise();
+      Promise<Void> future = Promise.promise();
       getVertx().sharedData().getAsyncMap("foo", onSuccess(asyncMap -> {
         asyncMap.put(key, value, future);
       }));

File: src/test/java/io/vertx/core/shareddata/AsynchronousLockTest.java
Patch:
@@ -252,7 +252,7 @@ public void evictTimedOutWaiters() {
     int numWaiters = 10;
     SharedData sharedData = vertx.sharedData();
     sharedData.getLocalLock("foo", onSuccess(lock -> {
-      List<Future> locks = new ArrayList<>();
+      List<Future<?>> locks = new ArrayList<>();
       for (int i = 0;i < numWaiters;i++) {
         locks.add(sharedData.getLocalLockWithTimeout("foo", 200));
       }

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -788,7 +788,7 @@ public void testMulti() {
       servers.add(server);
     }
     try {
-      List<Future> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
+      List<Future<?>> collect = servers.stream().map(server -> server.listen(8080)).collect(Collectors.toList());
       CompositeFuture
         .all(collect)
         .onSuccess(v -> {

File: src/test/java/io/vertx/test/verticles/FaultToleranceVerticle.java
Patch:
@@ -40,7 +40,7 @@ public void start() throws Exception {
     JsonObject config = config();
     id = config.getInteger("id");
     numAddresses = config.getInteger("addressesCount");
-    List<Future> registrationFutures = new ArrayList<>(numAddresses);
+    List<Future<?>> registrationFutures = new ArrayList<>(numAddresses);
     for (int i = 0; i < numAddresses; i++) {
       Promise<Void> registrationFuture = Promise.promise();
       registrationFutures.add(registrationFuture.future());

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -101,7 +101,7 @@ public class AsyncFileImpl implements AsyncFile {
       }
       if (options.isAppend()) writePos = ch.size();
     } catch (IOException e) {
-      throw new FileSystemException(e);
+      throw new FileSystemException(FileSystemImpl.getFileAccessErrorMessage("open", path), e);
     }
     this.context = context;
     this.queue = new InboundBuffer<>(context, 0);

File: src/main/java/io/vertx/core/file/impl/FileCache.java
Patch:
@@ -56,7 +56,7 @@ static File setupCacheDir(String fileCacheDir) {
         Files.createDirectories(cacheDir.toPath(), PosixFilePermissions.asFileAttribute(perms));
       }
     } catch (IOException e) {
-      throw new IllegalStateException("Failed to create cache dir: " + cacheDirName, e);
+      throw new IllegalStateException(FileSystemImpl.getFolderAccessErrorMessage("create", fileCacheDir), e);
     }
     return cacheDir;
   }

File: src/main/java/io/vertx/core/file/impl/FileResolver.java
Patch:
@@ -211,7 +211,7 @@ private File unpackFromFileURL(URL url, String fileName, ClassLoader cl) {
     try {
       cacheFile = cache.cache(fileName, resource, !enableCaching);
     } catch (IOException e) {
-      throw new VertxException(e);
+      throw new VertxException(FileSystemImpl.getFileAccessErrorMessage("unpack", url.toString()), e);
     }
     if (isDirectory) {
       String[] listing = resource.list();
@@ -267,7 +267,7 @@ private File unpackFromJarURL(URL url, String fileName, ClassLoader cl) {
         }
       }
     } catch (IOException e) {
-      throw new VertxException(e);
+      throw new VertxException(FileSystemImpl.getFileAccessErrorMessage("unpack", url.toString()), e);
     } finally {
       closeQuietly(zip);
     }
@@ -317,7 +317,7 @@ private File unpackFromBundleURL(URL url, boolean isDir) {
         }
       }
     } catch (IOException e) {
-      throw new VertxException(e);
+      throw new VertxException(FileSystemImpl.getFileAccessErrorMessage("unpack", url.toString()), e);
     }
     return cache.getFile(file);
   }

File: src/main/java/io/vertx/core/impl/ContextInternal.java
Patch:
@@ -219,8 +219,8 @@ static ContextInternal current() {
 
   /**
    * @return the {@link ConcurrentMap} used to store context data
-   * @see Context#get(String)
-   * @see Context#put(String, Object)
+   * @see Context#get(Object)
+   * @see Context#put(Object, Object)
    */
   ConcurrentMap<Object, Object> contextData();
 

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -280,7 +280,7 @@ protected void finalize() throws Throwable {
     // Make sure this gets cleaned up if there are no more references to it
     // so as not to leave connections and resources dangling until the system is shutdown
     // which could make the JVM run out of file handles.
-    close((Handler<AsyncResult<Void>>) Promise.<Void>promise());
+    closeFuture.close();
     super.finalize();
   }
 }

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -284,8 +284,10 @@ public Future<HttpClientConnection> connect(SocketAddress server) {
    */
   public Future<HttpClientConnection> connect(SocketAddress server, SocketAddress peer) {
     EventLoopContext context = (EventLoopContext) vertx.getOrCreateContext();
+    Promise<HttpClientConnection> promise = context.promise();
     HttpChannelConnector connector = new HttpChannelConnector(this, netClient, null, null, options.getProtocolVersion(), options.isSsl(), options.isUseAlpn(), peer, server);
-    return connector.httpConnect(context);
+    connector.httpConnect(context, promise);
+    return promise.future();
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/WebSocketEndpoint.java
Patch:
@@ -82,8 +82,7 @@ public void handle(AsyncResult<HttpClientConnection> ar) {
     }
 
     connector
-      .httpConnect((EventLoopContext) ctx)
-      .onComplete(new Listener());
+      .httpConnect((EventLoopContext) ctx, new Listener());
   }
 
   @Override

File: src/main/java/io/vertx/core/eventbus/impl/HandlerRegistration.java
Patch:
@@ -83,7 +83,6 @@ public Future<Void> unregister() {
         registered = null;
         if (bus.metrics != null) {
           bus.metrics.handlerUnregistered(metric);
-          metric = null;
         }
       } else {
         promise.complete();

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -72,9 +72,9 @@ public class HttpServerOptions extends NetServerOptions {
   public static final int DEFAULT_MAX_HEADER_SIZE = 8192;
 
   /**
-   * Default max length of all headers = 2048
+   * Default max length of all headers = 8192
    */
-  public static final int DEFAULT_MAX_FORM_ATTRIBUTE_SIZE = 2048;
+  public static final int DEFAULT_MAX_FORM_ATTRIBUTE_SIZE = 8192;
 
   /**
    * Default value of whether 100-Continue should be handled automatically = {@code false}

File: src/main/java/io/vertx/core/impl/DuplicatedContext.java
Patch:
@@ -38,6 +38,7 @@ class DuplicatedContext extends AbstractContext {
   private ConcurrentMap<Object, Object> localData;
 
   DuplicatedContext(ContextImpl delegate) {
+    super(delegate.disableTCCL);
     this.delegate = delegate;
   }
 

File: src/main/java/io/vertx/core/impl/EventLoopContext.java
Patch:
@@ -27,8 +27,9 @@ public class EventLoopContext extends ContextImpl {
                    WorkerPool workerPool,
                    Deployment deployment,
                    CloseFuture closeFuture,
-                   ClassLoader tccl) {
-    super(vertx, eventLoop, internalBlockingPool, workerPool, deployment, closeFuture, tccl);
+                   ClassLoader tccl,
+                   boolean disableTCCL) {
+    super(vertx, eventLoop, internalBlockingPool, workerPool, deployment, closeFuture, tccl, disableTCCL);
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/VertxThread.java
Patch:
@@ -20,9 +20,6 @@
  */
 public class VertxThread extends FastThreadLocalThread implements BlockedThreadChecker.Task {
 
-  static final String DISABLE_TCCL_PROP_NAME = "vertx.disableTCCL";
-  static final boolean DISABLE_TCCL = Boolean.getBoolean(DISABLE_TCCL_PROP_NAME);
-
   private final boolean worker;
   private final long maxExecTime;
   private final TimeUnit maxExecTimeUnit;

File: src/main/java/io/vertx/core/impl/WorkerContext.java
Patch:
@@ -28,8 +28,9 @@ public class WorkerContext extends ContextImpl {
                 WorkerPool workerPool,
                 Deployment deployment,
                 CloseFuture closeFuture,
-                ClassLoader tccl) {
-    super(vertx, vertx.getEventLoopGroup().next(), internalBlockingPool, workerPool, deployment, closeFuture, tccl);
+                ClassLoader tccl,
+                boolean disableTCCL) {
+    super(vertx, vertx.getEventLoopGroup().next(), internalBlockingPool, workerPool, deployment, closeFuture, tccl, disableTCCL);
   }
 
   @Override

File: src/test/benchmarks/io/vertx/core/impl/BenchmarkContext.java
Patch:
@@ -30,7 +30,7 @@ public static BenchmarkContext create(Vertx vertx) {
   }
 
   public BenchmarkContext(VertxInternal vertx, WorkerPool internalBlockingPool, WorkerPool workerPool, ClassLoader tccl) {
-    super(vertx, vertx.getEventLoopGroup().next(), internalBlockingPool, workerPool, null, null, tccl);
+    super(vertx, vertx.getEventLoopGroup().next(), internalBlockingPool, workerPool, null, null, tccl, false);
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/future/Eventually.java
Patch:
@@ -10,7 +10,6 @@
  */
 package io.vertx.core.impl.future;
 
-import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.impl.ContextInternal;
 

File: src/main/java/io/vertx/core/impl/launcher/commands/BareCommand.java
Patch:
@@ -214,14 +214,14 @@ protected Vertx startVertx() {
     options.setEventBusOptions(eventBusOptions);
 
     beforeStartingVertx(options);
-    builder.init();
 
     configureFromSystemProperties.set(log);
     try {
       configureFromSystemProperties(options, VERTX_OPTIONS_PROP_PREFIX);
       if (options.getMetricsOptions() != null) {
         configureFromSystemProperties(options.getMetricsOptions(), METRICS_OPTIONS_PROP_PREFIX);
       }
+      builder.init();
     } finally {
       configureFromSystemProperties.set(null);
     }

File: src/test/java/io/vertx/core/LauncherTest.java
Patch:
@@ -513,6 +513,7 @@ public void testCustomMetricsOptions() throws Exception {
     VertxOptions opts = launcher.getVertxOptions();
     CustomMetricsOptions custom = (CustomMetricsOptions) opts.getMetricsOptions();
     assertEquals("customPropertyValue", custom.getCustomProperty());
+    assertTrue(launcher.getVertx().isMetricsEnabled());
   }
 
   @Test

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -147,7 +147,7 @@ public HttpServer listen(Handler<AsyncResult<HttpServer>> listenHandler) {
 
   @Override
   public Future<HttpServer> listen(int port, String host) {
-    return listen(SocketAddress.inetSocketAddress(port, host));
+    return listen(new SocketAddressImpl(port, host));
   }
 
   @Override

File: src/main/java/io/vertx/core/net/NetServerOptions.java
Patch:
@@ -349,8 +349,8 @@ public int getPort() {
    * @return a reference to this, so the API can be used fluently
    */
   public NetServerOptions setPort(int port) {
-    if (port < 0 || port > 65535) {
-      throw new IllegalArgumentException("port p must be in range 0 <= p <= 65535");
+    if (port > 65535) {
+      throw new IllegalArgumentException("port must be <= 65535");
     }
     this.port = port;
     return this;

File: src/main/java/io/vertx/core/net/SocketAddress.java
Patch:
@@ -14,6 +14,7 @@
 import io.vertx.codegen.annotations.CacheReturn;
 import io.vertx.codegen.annotations.GenIgnore;
 import io.vertx.codegen.annotations.VertxGen;
+import io.vertx.core.impl.Arguments;
 import io.vertx.core.net.impl.SocketAddressImpl;
 
 import java.net.InetSocketAddress;
@@ -42,6 +43,7 @@ public interface SocketAddress {
    * @return the created socket address
    */
   static SocketAddress inetSocketAddress(int port, String host) {
+    Arguments.requireInRange(port, 0, 65535, "port p must be in range 0 <= p <= 65535");
     return new SocketAddressImpl(port, host);
   }
 
@@ -67,7 +69,7 @@ static SocketAddress domainSocketAddress(String path) {
   static SocketAddress inetSocketAddress(InetSocketAddress address) {
     return new SocketAddressImpl(address);
   }
-  
+
   /**
    * Returns the host name when available or the IP address in string representation.
    * <br/>

File: src/main/java/io/vertx/core/net/impl/SocketAddressImpl.java
Patch:
@@ -52,7 +52,6 @@ public SocketAddressImpl(InetSocketAddress address) {
   }
 
   public SocketAddressImpl(int port, String host) {
-    Arguments.requireInRange(port, 0, 65535, "port p must be in range 0 <= p <= 65535");
     this.path = null;
     this.port = port;
     if (NetUtil.isValidIpV4Address(host)) {

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -316,7 +316,6 @@ public void testServerOptions() {
     assertEquals(0, options.getPort());
     assertEquals(options, options.setPort(1234));
     assertEquals(1234, options.getPort());
-    assertIllegalArgumentException(() -> options.setPort(-1));
     assertIllegalArgumentException(() -> options.setPort(65536));
 
     assertEquals("0.0.0.0", options.getHost());

File: src/main/java/io/vertx/core/spi/VertxTracerFactory.java
Patch:
@@ -31,8 +31,9 @@ public interface VertxTracerFactory extends VertxServiceProvider {
 
   @Override
   default void init(VertxBuilder builder) {
-    if (builder.tracer() == null) {
-      builder.tracer(tracer(builder.options().getTracingOptions()));
+    TracingOptions options = builder.options().getTracingOptions();
+    if (options != null && builder.tracer() == null) {
+      builder.tracer(tracer(options));
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -81,7 +81,7 @@ public SocketAddress server() {
   }
 
   private void connect(EventLoopContext context, Promise<NetSocket> promise) {
-    netClient.connectInternal(proxyOptions, server, peerAddress, this.options.isForceSni() ? peerAddress.host() : null, ssl, useAlpn, promise, context, 0);
+    netClient.connectInternal(proxyOptions, server, peerAddress, this.options.isForceSni() ? peerAddress.host() : null, ssl, useAlpn, false, promise, context, 0);
   }
 
   public Future<HttpClientConnection> wrap(EventLoopContext context, NetSocket so_) {

File: src/main/java/io/vertx/core/http/impl/HttpServerConnection.java
Patch:
@@ -31,4 +31,5 @@ public interface HttpServerConnection extends HttpConnection {
 
   HttpServerConnection handler(Handler<HttpServerRequest> handler);
 
+  HttpServerConnection invalidRequestHandler(Handler<HttpServerRequest> handler);
 }

File: src/main/java/io/vertx/core/http/impl/Http1xUpgradeToH2CHandler.java
Patch:
@@ -81,10 +81,11 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
                 res.headers().add(HttpHeaderNames.UPGRADE, Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME);
                 ctx.writeAndFlush(res);
                 pipeline.remove("httpEncoder");
-                if(isCompressionSupported) {
+                if (isCompressionSupported) {
                   pipeline.remove("deflater");
+                  pipeline.remove("chunkedWriter");
                 }
-                if(isDecompressionSupported) {
+                if (isDecompressionSupported) {
                   pipeline.remove("inflater");
                 }
                 handler = initializer.buildHttp2ConnectionHandler(initializer.context, initializer.connectionHandler);

File: src/main/java/io/vertx/core/net/PemKeyCertOptions.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2021 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -402,7 +402,7 @@ KeyStoreHelper getHelper(Vertx vertx) throws Exception {
         certs.add(vertx.fileSystem().readFileBlocking(((VertxInternal)vertx).resolveFile(certPath).getAbsolutePath()));
       }
       certs.addAll(certValues);
-      helper = new KeyStoreHelper(KeyStoreHelper.loadKeyCert(keys, certs), KeyStoreHelper.DUMMY_PASSWORD);
+      helper = new KeyStoreHelper(KeyStoreHelper.loadKeyCert(keys, certs), KeyStoreHelper.DUMMY_PASSWORD, null);
     }
     return helper;
   }

File: src/main/java/io/vertx/core/net/PemTrustOptions.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2021 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -187,7 +187,7 @@ KeyStoreHelper getHelper(Vertx vertx) throws Exception {
         map(path -> ((VertxInternal)vertx).resolveFile(path).getAbsolutePath()).
         map(vertx.fileSystem()::readFileBlocking);
       certValues = Stream.concat(certValues, this.certValues.stream());
-      helper = new KeyStoreHelper(KeyStoreHelper.loadCA(certValues), null);
+      helper = new KeyStoreHelper(KeyStoreHelper.loadCA(certValues), null, null);
     }
     return helper;
   }

File: src/test/java/io/vertx/test/tls/Cert.java
Patch:
@@ -50,5 +50,6 @@ public interface Cert<K extends KeyCertOptions> extends Supplier<K> {
       .addKeyPath("tls/host5-key.pem").addCertPath("tls/host5-cert.pem");
   Cert<JksOptions> MULTIPLE_JKS = () -> new JksOptions().setPath("tls/multiple.jks").setPassword("wibble").setAlias("precious");
   Cert<JksOptions> MULTIPLE_JKS_WRONG_ALIAS = () -> new JksOptions().setPath("tls/multiple.jks").setPassword("wibble").setAlias("preciouss");
+  Cert<JksOptions> MULTIPLE_JKS_ALIAS_PASSWORD = () -> new JksOptions().setPath("tls/multiple-alias-password.jks").setPassword("wibble").setAlias("fonky").setAliasPassword("family");
 
 }

File: src/test/java/io/vertx/test/tls/Cert.java
Patch:
@@ -49,5 +49,6 @@ public interface Cert<K extends KeyCertOptions> extends Supplier<K> {
       .addKeyPath("tls/host4-key.pem").addCertPath("tls/host4-cert.pem")
       .addKeyPath("tls/host5-key.pem").addCertPath("tls/host5-cert.pem");
   Cert<JksOptions> MULTIPLE_JKS = () -> new JksOptions().setPath("tls/multiple.jks").setPassword("wibble").setAlias("precious");
+  Cert<JksOptions> MULTIPLE_JKS_WRONG_ALIAS = () -> new JksOptions().setPath("tls/multiple.jks").setPassword("wibble").setAlias("preciouss");
 
 }

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -34,7 +34,7 @@
 import static io.vertx.core.http.HttpHeaders.*;
 
 /**
- * This class is optimised for performance when used on the same event loop that is was passed to the handler with.
+ * This class is optimised for performance when used on the same event loop that is passed to the handler with.
  * However it can be used safely from other threads.
  *
  * The internal state is protected using the synchronized keyword. If always used on the same event loop, then

File: src/main/java/io/vertx/core/http/HttpServerResponse.java
Patch:
@@ -347,7 +347,7 @@ default Future<Void> send(Buffer body) {
    * <p> If the {@link HttpHeaders#CONTENT_LENGTH} is set then the request assumes this is the
    * length of the {stream}, otherwise the request will set a chunked {@link HttpHeaders#CONTENT_ENCODING}.
    *
-   * @param handler the completion handler 
+   * @param handler the completion handler
    */
   default void send(ReadStream<Buffer> body, Handler<AsyncResult<Void>> handler) {
     MultiMap headers = headers();
@@ -437,7 +437,7 @@ default HttpServerResponse sendFile(String filename, long offset, Handler<AsyncR
    *
    * @param filename path to the file to serve
    * @param offset the offset to serve from
-   * @param length the length to serve to
+   * @param length length the number of bytes to send
    * @param resultHandler  handler that will be called on completion
    * @return a reference to this, so the API can be used fluently
    */

File: src/main/java/io/vertx/core/impl/TaskQueue.java
Patch:
@@ -18,8 +18,8 @@
 import java.util.concurrent.Executor;
 
 /**
- * A task queue that always run all tasks in order. The executor to run the tasks is passed when
- * the tasks when the tasks are executed, this executor is not guaranteed to be used, as if several
+ * A task queue that always run all tasks in order. The executor to run the tasks is passed
+ * when the tasks are executed, this executor is not guaranteed to be used, as if several
  * tasks are queued, the original thread will be used.
  *
  * More specifically, any call B to the {@link #execute(Runnable, Executor)} method that happens-after another call A to the

File: src/main/java/io/vertx/core/impl/DuplicatedContext.java
Patch:
@@ -144,7 +144,7 @@ public final <T> Future<T> executeBlockingInternal(Handler<Promise<T>> action, b
 
   @Override
   public final <T> Future<T> executeBlocking(Handler<Promise<T>> action, boolean ordered) {
-    return ContextImpl.executeBlocking(this, action, delegate.workerPool, delegate.orderedTasks);
+    return ContextImpl.executeBlocking(this, action, delegate.workerPool, ordered ? delegate.orderedTasks : null);
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http1xConnectionBase.java
Patch:
@@ -119,17 +119,17 @@ public HttpConnection goAwayHandler(@Nullable Handler<GoAway> handler) {
 
   @Override
   public HttpConnection shutdownHandler(@Nullable Handler<Void> handler) {
-    throw new UnsupportedOperationException("HTTP/1.x connections don't support GOAWAY");
+    throw new UnsupportedOperationException("HTTP/1.x connections cannot be shutdown");
   }
 
   @Override
   public void shutdown(long timeout, Handler<AsyncResult<Void>> handler) {
-    throw new UnsupportedOperationException("HTTP/1.x connections don't support GOAWAY");
+    throw new UnsupportedOperationException("HTTP/1.x connections cannot be shutdown");
   }
 
   @Override
   public Future<Void> shutdown(long timeoutMs) {
-    throw new UnsupportedOperationException("HTTP/1.x connections don't support GOAWAY");
+    throw new UnsupportedOperationException("HTTP/1.x connections cannot be shutdown");
   }
 
   @Override

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -250,7 +250,7 @@ default Future<T> recover(Function<Throwable, Future<T>> mapper) {
    * and this mapper returns another future object. This returned future completion will complete the future returned
    * by this method call with the original result of the future.
    *
-   * <p>The outcome of the future returned by the {@code mapper} will not influence the the nature
+   * <p>The outcome of the future returned by the {@code mapper} will not influence the nature
    * of the returned future.
    *
    * @param mapper the function returning the future.

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -305,7 +305,7 @@ static Future<Vertx> clusteredVertx(VertxOptions options) {
   void runOnContext(Handler<Void> action);
 
   /**
-   * Stop the the Vertx instance and release any resources held by it.
+   * Stop the Vertx instance and release any resources held by it.
    * <p>
    * The instance cannot be used after it has been closed.
    * <p>

File: src/main/java/io/vertx/core/eventbus/EventBus.java
Patch:
@@ -59,7 +59,7 @@ public interface EventBus extends Measured {
   EventBus send(String address, @Nullable Object message, DeliveryOptions options);
 
   /**
-   * Sends a message and and specify a {@code replyHandler} that will be called if the recipient
+   * Sends a message and specify a {@code replyHandler} that will be called if the recipient
    * subsequently replies to the message.
    * <p>
    * The message will be delivered to at most one of the handlers registered to the address.

File: src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -143,7 +143,7 @@ public interface HttpClientRequest extends WriteStream<Buffer> {
   HttpClientRequest setMethod(HttpMethod method);
 
   /**
-   * @return the absolute URI corresponding to the the HTTP request
+   * @return the absolute URI corresponding to the HTTP request
    */
   String absoluteURI();
 

File: src/main/java/io/vertx/core/http/HttpServerRequest.java
Patch:
@@ -207,7 +207,7 @@ default SSLSession sslSession() {
   X509Certificate[] peerCertificateChain() throws SSLPeerUnverifiedException;
 
   /**
-   * @return the absolute URI corresponding to the the HTTP request
+   * @return the absolute URI corresponding to the HTTP request
    */
   String absoluteURI();
 

File: src/main/java/io/vertx/core/json/pointer/JsonPointerIterator.java
Patch:
@@ -66,7 +66,7 @@ public interface JsonPointerIterator {
   Object getObjectParameter(@Nullable Object currentValue, String key, boolean createOnMissing);
 
   /**
-   * Move the iterator the the array element at specified index
+   * Move the iterator the array element at specified index
    *
    * @param currentValue
    * @param i array index

File: src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -338,7 +338,7 @@ private TrustManagerFactory getTrustMgrFactory(VertxInternal vertx, String serve
 
   /*
   Proxy the specified trust managers with an implementation checking first the provided certificates
-  against the the Certificate Revocation List (crl) before delegating to the original trust managers.
+  against the Certificate Revocation List (crl) before delegating to the original trust managers.
    */
   private static TrustManager[] createUntrustRevokedCertTrustManager(TrustManager[] trustMgrs, ArrayList<CRL> crls) {
     trustMgrs = trustMgrs.clone();

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -621,7 +621,7 @@ public void testMultipleSearchDomain() throws Exception {
     }));
     awaitLatch(latch2);
 
-    // "host3" resolves via the the "foo.com" search path as it is the first one
+    // "host3" resolves via the "foo.com" search path as it is the first one
     CountDownLatch latch3 = new CountDownLatch(1);
     vertx.resolveAddress("host3", onSuccess(resolved -> {
       assertEquals("127.0.0.4", resolved.getHostAddress());

File: src/test/java/io/vertx/core/http/HttpCompressionTest.java
Patch:
@@ -75,6 +75,7 @@ public void testSkipEncoding() throws Exception {
       .onComplete(onSuccess(req -> {
         req.putHeader(HttpHeaders.ACCEPT_ENCODING, HttpHeaders.DEFLATE_GZIP);
         req.send(onSuccess(resp -> {
+          assertNull(resp.getHeader(HttpHeaders.CONTENT_ENCODING));
           resp.body(onSuccess(responseBuffer -> {
             String responseBody = responseBuffer.toString(CharsetUtil.UTF_8);
             assertEquals(COMPRESS_TEST_STRING, responseBody);

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -33,10 +33,10 @@
 import io.vertx.core.streams.WriteStream;
 import io.vertx.test.core.Repeat;
 import io.vertx.test.core.CheckingSender;
+import io.vertx.test.tls.Cert;
 import io.vertx.test.verticles.SimpleServer;
 import io.vertx.test.core.TestUtils;
 import org.junit.Assume;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -4009,10 +4009,9 @@ public void testIdleTimeoutWithPartialH2CRequest() throws Exception {
   @Test
   public void testTLSDisablesH2CHandlers() throws Exception {
     server.close();
-    SelfSignedCertificate cert = SelfSignedCertificate.create("localhost");
     server = vertx.createHttpServer(createBaseServerOptions()
       .setSsl(true)
-      .setKeyCertOptions(cert.keyCertOptions())
+      .setKeyCertOptions(Cert.SERVER_JKS.get())
     ).connectionHandler(conn -> {
       Channel channel = ((Http1xServerConnection) conn).channel();
       for (Map.Entry<String, ChannelHandler> stringChannelHandlerEntry : channel.pipeline()) {

File: src/main/java/io/vertx/core/http/impl/HttpUtils.java
Patch:
@@ -646,9 +646,9 @@ static void sendError(Channel ch, HttpResponseStatus status, CharSequence err) {
   static String getWebSocketLocation(HttpServerRequest req, boolean ssl) throws Exception {
     String prefix;
     if (ssl) {
-      prefix = "ws://";
-    } else {
       prefix = "wss://";
+    } else {
+      prefix = "ws://";
     }
     URI uri = new URI(req.uri());
     String path = uri.getRawPath();

File: src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2021 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -291,7 +291,7 @@ private SslContext createContext(VertxInternal vertx, boolean useAlpn, X509KeyMa
   }
 
   private KeyManagerFactory getKeyMgrFactory(VertxInternal vertx) throws Exception {
-    return keyCertOptions == null ? null : keyCertOptions.getKeyManagerFactory(vertx);
+    return keyCertOptions == null ? null : keyCertOptions.getKeyManagerFactory(vertx, !client);
   }
 
   private TrustManagerFactory getTrustMgrFactory(VertxInternal vertx, String serverName) throws Exception {

File: src/test/java/io/vertx/test/tls/Cert.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2021 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -48,5 +48,6 @@ public interface Cert<K extends KeyCertOptions> extends Supplier<K> {
       .addKeyPath("tls/host3-key.pem").addCertPath("tls/host3-cert.pem")
       .addKeyPath("tls/host4-key.pem").addCertPath("tls/host4-cert.pem")
       .addKeyPath("tls/host5-key.pem").addCertPath("tls/host5-cert.pem");
+  Cert<JksOptions> MULTIPLE_JKS = () -> new JksOptions().setPath("tls/multiple.jks").setPassword("wibble").setAlias("precious");
 
 }

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -14,6 +14,7 @@
 import io.netty.handler.codec.http.*;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.multipart.Attribute;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData;
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.core.Context;
@@ -26,7 +27,6 @@
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.http.impl.headers.HeadersAdaptor;
-import io.vertx.core.http.impl.netty.HttpPostRequestDecoder;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.impl.future.PromiseInternal;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -17,6 +17,7 @@
 import io.vertx.core.http.HttpClientRequest;
 import io.vertx.core.http.HttpClientResponse;
 import io.vertx.core.http.HttpConnection;
+import io.vertx.core.http.HttpHeaders;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.http.RequestOptions;
@@ -296,9 +297,6 @@ private void handleNextRequest(HttpClientRequest next, Handler<AsyncResult<HttpC
     exceptionHandler(null);
     next.pushHandler(pushHandler());
     next.setMaxRedirects(followRedirects - 1);
-    if (headers != null) {
-      next.headers().addAll(headers);
-    }
     endFuture.onComplete(ar -> {
       if (ar.succeeded()) {
         if (timeoutMs > 0) {

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -3866,6 +3866,7 @@ private void testFollowRedirectWithBody(Function<Buffer, Buffer> translator) thr
         });
       } else {
         assertEquals(HttpMethod.GET, req.method());
+        assertNull(req.getHeader(HttpHeaders.CONTENT_LENGTH));
         req.response().end();
       }
     });

File: src/main/java/io/vertx/core/http/HttpClient.java
Patch:
@@ -20,10 +20,12 @@
 import io.vertx.core.MultiMap;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.metrics.Measured;
+import io.vertx.core.net.SocketAddress;
 import io.vertx.core.streams.ReadStream;
 
 import java.util.List;
 import java.util.function.Function;
+import java.util.function.Predicate;
 
 /**
  * An asynchronous HTTP client.

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -14,20 +14,19 @@
 import io.netty.handler.codec.http.*;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.multipart.Attribute;
-import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData;
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.MultiMap;
-import io.vertx.core.Promise;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.*;
 import io.vertx.core.http.Cookie;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.http.impl.headers.HeadersAdaptor;
+import io.vertx.core.http.impl.netty.HttpPostRequestDecoder;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.impl.future.PromiseInternal;

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java
Patch:
@@ -17,7 +17,6 @@
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.codec.http.multipart.Attribute;
-import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData;
 import io.netty.handler.codec.http2.Http2Headers;
 import io.vertx.codegen.annotations.Nullable;
@@ -37,6 +36,7 @@
 import io.vertx.core.http.StreamResetException;
 import io.vertx.core.http.HttpFrame;
 import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
+import io.vertx.core.http.impl.netty.HttpPostRequestDecoder;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;

File: src/test/java/io/vertx/core/http/Http1xServerFileUploadTest.java
Patch:
@@ -17,7 +17,6 @@
  */
 public class Http1xServerFileUploadTest extends HttpServerFileUploadTest {
 
-
   @Ignore
   @Test
   @Override

File: src/main/java/io/vertx/core/file/OpenOptions.java
Patch:
@@ -274,7 +274,7 @@ public boolean isDsync() {
   }
 
   /**
-   * Set whether every write to the file's content  ill be written synchronously to the underlying hardware.
+   * Set whether every write to the file's content will be written synchronously to the underlying hardware.
    * @param dsync  true if sync
    * @return a reference to this, so the API can be used fluently
    */

File: src/main/java/io/vertx/core/http/impl/ClientHttpEndpointBase.java
Patch:
@@ -13,7 +13,7 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 import io.vertx.core.impl.ContextInternal;
-import io.vertx.core.net.impl.clientconnection.Endpoint;
+import io.vertx.core.net.impl.pool.Endpoint;
 import io.vertx.core.spi.metrics.ClientMetrics;
 
 /**

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -25,7 +25,6 @@
 import io.vertx.core.http.*;
 import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
 import io.vertx.core.impl.EventLoopContext;
-import io.vertx.core.net.impl.clientconnection.ConnectionListener;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.net.impl.ConnectionBase;
 import io.vertx.core.spi.metrics.ClientMetrics;

File: src/main/java/io/vertx/core/http/impl/SharedClientHttpStreamEndpoint.java
Patch:
@@ -17,11 +17,11 @@
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.EventLoopContext;
-import io.vertx.core.net.impl.clientconnection.ConnectResult;
+import io.vertx.core.net.impl.pool.ConnectResult;
 import io.vertx.core.net.impl.pool.ConnectionPool;
 import io.vertx.core.net.impl.pool.PoolConnection;
 import io.vertx.core.net.impl.pool.PoolConnector;
-import io.vertx.core.net.impl.clientconnection.Lease;
+import io.vertx.core.net.impl.pool.Lease;
 import io.vertx.core.net.impl.pool.PoolWaiter;
 import io.vertx.core.spi.metrics.ClientMetrics;
 

File: src/main/java/io/vertx/core/net/impl/pool/ConnectResult.java
Patch:
@@ -8,7 +8,7 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
-package io.vertx.core.net.impl.clientconnection;
+package io.vertx.core.net.impl.pool;
 
 /**
  * The result of a connect operation.

File: src/main/java/io/vertx/core/net/impl/pool/ConnectionManager.java
Patch:
@@ -9,11 +9,10 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.net.impl.clientconnection;
+package io.vertx.core.net.impl.pool;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
-import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.EventLoopContext;
 
 import java.util.*;

File: src/main/java/io/vertx/core/net/impl/pool/ConnectionPool.java
Patch:
@@ -14,7 +14,6 @@
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.impl.EventLoopContext;
-import io.vertx.core.net.impl.clientconnection.Lease;
 
 import java.util.List;
 import java.util.function.BiFunction;

File: src/main/java/io/vertx/core/net/impl/pool/Endpoint.java
Patch:
@@ -8,7 +8,7 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
-package io.vertx.core.net.impl.clientconnection;
+package io.vertx.core.net.impl.pool;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;

File: src/main/java/io/vertx/core/net/impl/pool/EndpointProvider.java
Patch:
@@ -8,7 +8,7 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
-package io.vertx.core.net.impl.clientconnection;
+package io.vertx.core.net.impl.pool;
 
 import io.vertx.core.impl.ContextInternal;
 

File: src/main/java/io/vertx/core/net/impl/pool/Lease.java
Patch:
@@ -8,7 +8,7 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
-package io.vertx.core.net.impl.clientconnection;
+package io.vertx.core.net.impl.pool;
 
 /**
  * A recyclable object.

File: src/main/java/io/vertx/core/net/impl/pool/PoolConnector.java
Patch:
@@ -13,7 +13,6 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 import io.vertx.core.impl.EventLoopContext;
-import io.vertx.core.net.impl.clientconnection.ConnectResult;
 
 /**
  * Defines the interactions with the actual back-end managing connections.

File: src/main/java/io/vertx/core/net/impl/pool/PoolWaiter.java
Patch:
@@ -14,7 +14,6 @@
 import io.vertx.core.Context;
 import io.vertx.core.Handler;
 import io.vertx.core.impl.EventLoopContext;
-import io.vertx.core.net.impl.clientconnection.Lease;
 
 /**
  * A waiter for a connection.

File: src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java
Patch:
@@ -17,8 +17,6 @@
 import io.vertx.core.Promise;
 import io.vertx.core.http.ConnectionPoolTooBusyException;
 import io.vertx.core.impl.EventLoopContext;
-import io.vertx.core.net.impl.clientconnection.ConnectResult;
-import io.vertx.core.net.impl.clientconnection.Lease;
 
 import java.util.AbstractList;
 import java.util.ArrayList;
@@ -384,6 +382,7 @@ public Runnable execute(SimpleConnectionPool<C> pool) {
         pool.capacity -= w;
         pool.capacity += waiter.capacity;
         pool.slots[removed.index] = slot;
+        pool.requests++;
         return () -> {
           if (waiter.listener != null) {
             waiter.listener.onConnect(waiter);
@@ -692,6 +691,7 @@ public Runnable execute(SimpleConnectionPool<C> pool) {
           waiters.add(slot.initiator);
           slot.initiator = null;
         }
+        pool.capacity -= slot.capacity;
         list.add(slot.result.future());
       }
       pool.size = 0;

File: src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java
Patch:
@@ -18,8 +18,6 @@
 import io.vertx.core.http.ConnectionPoolTooBusyException;
 import io.vertx.core.impl.EventLoopContext;
 import io.vertx.core.impl.VertxInternal;
-import io.vertx.core.net.impl.clientconnection.ConnectResult;
-import io.vertx.core.net.impl.clientconnection.Lease;
 import io.vertx.test.core.VertxTestBase;
 import org.junit.Test;
 
@@ -307,7 +305,7 @@ public void testConnectFailureWithPendingWaiter() throws Exception {
     EventLoopContext ctx1 = vertx.createEventLoopContext();
     pool.acquire(ctx1, 0, onFailure(cause -> {
       assertSame(failure, cause);
-      assertEquals(0, pool.requests());
+      assertEquals(1, pool.requests());
       latch.countDown();
     }));
     EventLoopContext ctx2 = vertx.createEventLoopContext();

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -292,7 +292,7 @@ private void webSocket(WebSocketConnectOptions connectOptions, PromiseInternal<W
     if (ctx instanceof EventLoopContext) {
       eventLoopContext = (EventLoopContext) ctx;
     } else {
-      eventLoopContext = (EventLoopContext) vertx.createEventLoopContext(ctx.nettyEventLoop(), ctx.workerPool(), ctx.classLoader());
+      eventLoopContext = vertx.createEventLoopContext(ctx.nettyEventLoop(), ctx.workerPool(), ctx.classLoader());
     }
     webSocketCM.getConnection(
       eventLoopContext,

File: src/main/java/io/vertx/core/http/impl/MimeMapping.java
Patch:
@@ -55,7 +55,8 @@ public class MimeMapping {
     m.put("jar", "application/java-archive");
     m.put("ser", "application/java-serialized-object");
     m.put("class", "application/java-vm");
-    m.put("js", "application/javascript");
+    m.put("js", "text/javascript");
+    m.put("mjs", "text/javascript");
     m.put("json", "application/json");
     m.put("jsonml", "application/jsonml+json");
     m.put("lostxml", "application/lost+xml");

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -795,7 +795,7 @@ public Map<String, Object> getMap() {
   }
 
   /**
-   * Get a Stream over the entries in the JSON array. The values in the stream will follow
+   * Get a Stream over the entries in the JSON object. The values in the stream will follow
    * the same rules as defined in {@link #getValue(String)}, respecting the JSON requirements.
    *
    * To stream the raw values, use the storage object stream instead:

File: src/main/java/io/vertx/core/eventbus/impl/ReplyHandler.java
Patch:
@@ -27,6 +27,7 @@ class ReplyHandler<T> extends HandlerRegistration<T> implements Handler<Long> {
   private final ContextInternal context;
   private final Promise<Message<T>> result;
   private final long timeoutID;
+  private final long timeout;
   private final boolean src;
   private final String repliedAddress;
   Object trace;
@@ -39,6 +40,7 @@ class ReplyHandler<T> extends HandlerRegistration<T> implements Handler<Long> {
     this.src = src;
     this.repliedAddress = repliedAddress;
     this.timeoutID = eventBus.vertx.setTimer(timeout, this);
+    this.timeout = timeout;
   }
 
   private void trace(Object reply, Throwable failure) {
@@ -69,7 +71,7 @@ private void doFail(ReplyException failure) {
   }
 
   @Override
-  public void handle(Long timeout) {
+  public void handle(Long id) {
     unregister();
     doFail(new ReplyException(ReplyFailure.TIMEOUT, "Timed out after waiting " + timeout + "(ms) for a reply. address: " + address + ", repliedAddress: " + repliedAddress));
   }

File: src/main/java/io/vertx/core/net/NetClientOptions.java
Patch:
@@ -347,7 +347,7 @@ public List<String> getApplicationLayerProtocols() {
    * @param protocols the protocols
    * @return a reference to this, so the API can be used fluently
    */
-  public ClientOptionsBase setApplicationLayerProtocols(List<String> protocols) {
+  public NetClientOptions setApplicationLayerProtocols(List<String> protocols) {
     this.applicationLayerProtocols = protocols;
     return this;
   }

File: src/main/java/io/vertx/core/http/impl/ws/WebSocketFrameInternal.java
Patch:
@@ -13,7 +13,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.vertx.core.http.WebSocketFrame;
-import io.vertx.core.http.impl.FrameType;
 
 /**
  * A Web Socket frame that represents either text or binary data.
@@ -23,6 +22,7 @@
  * @version $Rev: 2080 $, $Date: 2010-01-26 18:04:19 +0900 (Tue, 26 Jan 2010) $
  */
 public interface WebSocketFrameInternal extends WebSocketFrame {
+
   /**
    * Returns the content of this frame as-is, with no UTF-8 decoding.
    */
@@ -50,5 +50,4 @@ public interface WebSocketFrameInternal extends WebSocketFrame {
    */
   int length();
 
-  FrameType type();
 }

File: src/main/java/io/vertx/core/impl/future/CompositeFutureImpl.java
Patch:
@@ -148,7 +148,7 @@ public <T> T resultAt(int index) {
   }
 
   private <T> Future<T> future(int index) {
-    if (index < 0 || index > results.length) {
+    if (index < 0 || index >= results.length) {
       throw new IndexOutOfBoundsException();
     }
     return (Future<T>) results[index];

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -466,7 +466,8 @@ public HttpServerRequest setExpectMultipart(boolean expect) {
           if (!HttpUtils.isValidMultipartMethod(request.method())) {
             throw new IllegalStateException("Request method must be one of POST, PUT, PATCH or DELETE to decode a multipart request");
           }
-          NettyFileUploadDataFactory factory = new NettyFileUploadDataFactory(context, conn.options.getMaxFormAttributeSize(), this, () -> uploadHandler);
+          NettyFileUploadDataFactory factory = new NettyFileUploadDataFactory(context, this, () -> uploadHandler);
+          factory.setMaxLimit(conn.options.getMaxFormAttributeSize());
           decoder = new HttpPostRequestDecoder(factory, request);
         }
       } else {

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java
Patch:
@@ -441,7 +441,8 @@ public HttpServerRequest setExpectMultipart(boolean expect) {
             method.toNetty(),
             uri);
           req.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);
-          NettyFileUploadDataFactory factory = new NettyFileUploadDataFactory(context, conn.options.getMaxFormAttributeSize(), this, () -> uploadHandler);
+          NettyFileUploadDataFactory factory = new NettyFileUploadDataFactory(context, this, () -> uploadHandler);
+          factory.setMaxLimit(conn.options.getMaxFormAttributeSize());
           postRequestDecoder = new HttpPostRequestDecoder(factory, req);
         }
       } else {

File: src/test/java/io/vertx/core/http/headers/CaseInsensitiveHeadersTest.java
Patch:
@@ -27,7 +27,7 @@ public CaseInsensitiveHeadersTest() {
     sameBucket2 = "R";
   }
 
-  protected MultiMap newMultiMap() {
+  protected HeadersMultiMap newMultiMap() {
     return new HeadersMultiMap();
   }
 

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -161,8 +161,7 @@ private StreamImpl createStream(ContextInternal context) {
 
   private void recycle() {
     int timeout = client.getOptions().getHttp2KeepAliveTimeout();
-    long expired = timeout > 0 ? System.currentTimeMillis() + timeout * 1000 : 0L;
-    expirationTimestamp = timeout > 0 ? System.currentTimeMillis() + timeout * 1000 : 0L;
+    expirationTimestamp = timeout > 0 ? System.currentTimeMillis() + timeout * 1000L : 0L;
   }
 
   @Override

File: src/test/java/io/vertx/core/http/Http1xClientConnectionTest.java
Patch:
@@ -26,7 +26,7 @@ public void testResetStreamBeforeSend() throws Exception {
     waitFor(1);
     server.requestHandler(req -> {
     });
-    startServer();
+    startServer(testAddress);
     client.connect(testAddress).onComplete(onSuccess(conn -> {
       AtomicInteger evictions = new AtomicInteger();
       conn.evictionHandler(v -> {
@@ -51,7 +51,7 @@ public void testResetStreamRequestSent() throws Exception {
     server.requestHandler(req -> {
       continuation.complete();
     });
-    startServer();
+    startServer(testAddress);
     client.connect(testAddress).onComplete(onSuccess(conn -> {
       AtomicInteger evictions = new AtomicInteger();
       conn.evictionHandler(v -> {
@@ -81,7 +81,7 @@ public void testServerConnectionClose() throws Exception {
     server.requestHandler(req -> {
       req.response().putHeader("Connection", "close").end();
     });
-    startServer();
+    startServer(testAddress);
     client.connect(testAddress).onComplete(onSuccess(conn -> {
       AtomicInteger evictions = new AtomicInteger();
       conn.evictionHandler(v -> {

File: src/test/java/io/vertx/core/http/HttpClientConnectionTest.java
Patch:
@@ -46,7 +46,7 @@ public void testGet() throws Exception {
     server.requestHandler(req -> {
       req.response().end();
     });
-    startServer();
+    startServer(testAddress);
     client.connect(testAddress).onComplete(onSuccess(conn -> {
       conn.createStream((ContextInternal) vertx.getOrCreateContext(), onSuccess(stream -> {
         stream.writeHead(new HttpRequestHead(
@@ -74,7 +74,7 @@ public void testConnectionClose() throws Exception {
     server.requestHandler(req -> {
       req.response().close();
     });
-    startServer();
+    startServer(testAddress);
     client.connect(testAddress).onComplete(onSuccess(conn -> {
       AtomicInteger evictions = new AtomicInteger();
       conn.evictionHandler(v -> {

File: src/main/java/io/vertx/core/eventbus/impl/BodyReadStream.java
Patch:
@@ -32,7 +32,7 @@ public BodyReadStream(ReadStream<Message<T>> delegate) {
   @Override
   public ReadStream<T> exceptionHandler(Handler<Throwable> handler) {
     delegate.exceptionHandler(handler);
-    return null;
+    return this;
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -466,7 +466,8 @@ public HttpServerRequest setExpectMultipart(boolean expect) {
           if (!HttpUtils.isValidMultipartMethod(request.method())) {
             throw new IllegalStateException("Request method must be one of POST, PUT, PATCH or DELETE to decode a multipart request");
           }
-          decoder = new HttpPostRequestDecoder(new NettyFileUploadDataFactory(context, this, () -> uploadHandler), request);
+          NettyFileUploadDataFactory factory = new NettyFileUploadDataFactory(context, conn.options.getMaxFormAttributeSize(), this, () -> uploadHandler);
+          decoder = new HttpPostRequestDecoder(factory, request);
         }
       } else {
         decoder = null;

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java
Patch:
@@ -444,7 +444,8 @@ public HttpServerRequest setExpectMultipart(boolean expect) {
             method.toNetty(),
             uri);
           req.headers().add(HttpHeaderNames.CONTENT_TYPE, contentType);
-          postRequestDecoder = new HttpPostRequestDecoder(new NettyFileUploadDataFactory(context, this, () -> uploadHandler), req);
+          NettyFileUploadDataFactory factory = new NettyFileUploadDataFactory(context, conn.options.getMaxFormAttributeSize(), this, () -> uploadHandler);
+          postRequestDecoder = new HttpPostRequestDecoder(factory, req);
         }
       } else {
         postRequestDecoder = null;

File: src/main/java/io/vertx/core/http/RequestOptions.java
Patch:
@@ -106,6 +106,7 @@ public RequestOptions(RequestOptions other) {
     setPort(other.port);
     setSsl(other.ssl);
     setURI(other.uri);
+    setFollowRedirects(other.followRedirects);
     setTimeout(other.timeout);
     if (other.headers != null) {
       setHeaders(MultiMap.caseInsensitiveMultiMap().setAll(other.headers));

File: src/main/java/io/vertx/core/json/jackson/JacksonCodec.java
Patch:
@@ -32,7 +32,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.Reader;
 import java.io.StringWriter;
 import java.io.Writer;
 import java.lang.reflect.ParameterizedType;

File: src/main/java/io/vertx/core/http/impl/MimeMapping.java
Patch:
@@ -56,6 +56,7 @@ public class MimeMapping {
     m.put("ser", "application/java-serialized-object");
     m.put("class", "application/java-vm");
     m.put("js", "application/javascript");
+    m.put("mjs", "application/javascript");
     m.put("json", "application/json");
     m.put("jsonml", "application/jsonml+json");
     m.put("lostxml", "application/lost+xml");

File: src/main/java/io/vertx/core/spi/VertxMetricsFactory.java
Patch:
@@ -40,6 +40,8 @@ default void init(VertxBuilder builder) {
         metricsOptions = options.getMetricsOptions();
         if (metricsOptions == null) {
           metricsOptions = newOptions();
+        } else {
+          metricsOptions = newOptions(metricsOptions.toJson());
         }
       }
       BareCommand.configureFromSystemProperties(metricsOptions, METRICS_OPTIONS_PROP_PREFIX);;

File: src/test/java/io/vertx/core/spi/metrics/MetricsOptionsTest.java
Patch:
@@ -98,7 +98,7 @@ public void testMetricsFromServiceLoader() {
     VertxMetrics metrics = ((VertxInternal) vertx).metricsSPI();
     assertNotNull(metrics);
     assertTrue(metrics instanceof FakeVertxMetrics);
-    assertSame(metricsOptions, ((FakeVertxMetrics)metrics).options());
+    assertEquals(metricsOptions.isEnabled(), ((FakeVertxMetrics)metrics).options().isEnabled());
   }
 
   @Test

File: src/main/java/io/vertx/core/impl/VertxThread.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-public final class VertxThread extends FastThreadLocalThread implements BlockedThreadChecker.Task {
+public class VertxThread extends FastThreadLocalThread implements BlockedThreadChecker.Task {
 
   static final String DISABLE_TCCL_PROP_NAME = "vertx.disableTCCL";
   static final boolean DISABLE_TCCL = Boolean.getBoolean(DISABLE_TCCL_PROP_NAME);

File: src/test/java/io/vertx/core/impl/GlobalEventExecutorNotificationTest.java
Patch:
@@ -60,7 +60,7 @@ public ChannelFactory<? extends Channel> channelFactory(boolean domainSocket) {
           throw cause;
         };
       }
-    }).vertx();
+    }).init().vertx();
 
     vertx.createNetServer().connectHandler(so -> {
       fail();
@@ -83,7 +83,7 @@ public ChannelFactory<? extends ServerChannel> serverChannelFactory(boolean doma
           throw cause;
         };
       }
-    }).vertx();
+    }).init().vertx();
 
     vertx.createNetServer()
       .connectHandler(so -> fail())
@@ -103,7 +103,7 @@ public ChannelFactory<? extends ServerChannel> serverChannelFactory(boolean doma
           throw cause;
         };
       }
-    }).vertx();
+    }).init().vertx();
 
     vertx.createHttpServer()
       .requestHandler(req -> fail())

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -24,7 +24,7 @@
 import io.vertx.core.http.HttpServer;
 import io.vertx.core.http.HttpServerOptions;
 import io.vertx.core.impl.ContextInternal;
-import io.vertx.core.impl.VertxFactory;
+import io.vertx.core.impl.VertxBuilder;
 import io.vertx.core.impl.resolver.DnsResolverProvider;
 import io.vertx.core.metrics.Measured;
 import io.vertx.core.net.NetClient;
@@ -83,7 +83,7 @@ static Vertx vertx() {
    * @return the instance
    */
   static Vertx vertx(VertxOptions options) {
-    return new VertxFactory(options).vertx();
+    return new VertxBuilder(options).init().vertx();
   }
 
   /**
@@ -95,7 +95,7 @@ static Vertx vertx(VertxOptions options) {
    * @param resultHandler  the result handler that will receive the result
    */
   static void clusteredVertx(VertxOptions options, Handler<AsyncResult<Vertx>> resultHandler) {
-    new VertxFactory(options).clusteredVertx(resultHandler);
+    new VertxBuilder(options).init().clusteredVertx(resultHandler);
   }
 
   /**

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -168,7 +168,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
     this.fileResolver = fileResolver;
     this.addressResolverOptions = options.getAddressResolverOptions();
     this.addressResolver = new AddressResolver(this, options.getAddressResolverOptions());
-    this.tracer = tracer;
+    this.tracer = tracer == VertxTracer.NOOP ? null : tracer;
     this.clusterManager = clusterManager;
     this.nodeSelector = nodeSelector;
     this.eventBus = clusterManager != null ? new ClusteredEventBus(this, options, clusterManager, nodeSelector) : new EventBusImpl(this);

File: src/test/java/io/vertx/core/VertxStartFailureTest.java
Patch:
@@ -12,7 +12,7 @@
 package io.vertx.core;
 
 import io.netty.channel.EventLoopGroup;
-import io.vertx.core.impl.VertxFactory;
+import io.vertx.core.impl.VertxBuilder;
 import io.vertx.core.net.impl.transport.Transport;
 import io.vertx.core.spi.cluster.NodeListener;
 import io.vertx.test.core.AsyncTestBase;
@@ -111,7 +111,7 @@ public EventLoopGroup eventLoopGroup(int type, int nThreads, ThreadFactory threa
       }
     };
     AtomicReference<AsyncResult<Vertx>> resultRef = new AtomicReference<>();
-    new VertxFactory(options).transport(transport).clusteredVertx(ar -> {
+    new VertxBuilder(options).init().transport(transport).clusteredVertx(ar -> {
       resultRef.set(ar);
       latch.countDown();
     });

File: src/test/java/io/vertx/core/eventbus/CustomNodeSelectorTest.java
Patch:
@@ -15,7 +15,7 @@
 import io.vertx.core.Promise;
 import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
-import io.vertx.core.impl.VertxFactory;
+import io.vertx.core.impl.VertxBuilder;
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.spi.cluster.ClusterManager;
 import io.vertx.core.spi.cluster.NodeInfo;
@@ -47,7 +47,7 @@ public void test() throws Exception {
         return vertxOptions;
       })
       .map(options -> {
-        VertxFactory factory = new VertxFactory(options).clusterNodeSelector(new CustomNodeSelector());
+        VertxBuilder factory = new VertxBuilder(options).init().clusterNodeSelector(new CustomNodeSelector());
         Promise promise = Promise.promise();
         factory.clusteredVertx(promise);
         return promise.future();

File: src/test/java/io/vertx/core/eventbus/WriteHandlerLookupFailureTest.java
Patch:
@@ -14,7 +14,7 @@
 import io.vertx.core.Promise;
 import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
-import io.vertx.core.impl.VertxFactory;
+import io.vertx.core.impl.VertxBuilder;
 import io.vertx.core.spi.cluster.NodeSelector;
 import io.vertx.core.spi.cluster.impl.DefaultNodeSelector;
 import io.vertx.test.core.VertxTestBase;
@@ -47,7 +47,7 @@ public void selectForPublish(Message<?> message, Promise<Iterable<String>> promi
         promise.fail("Not implemented");
       }
     };
-    new VertxFactory(options).clusterNodeSelector(nodeSelector).clusteredVertx(onSuccess(node -> {
+    new VertxBuilder(options).init().clusterNodeSelector(nodeSelector).clusteredVertx(onSuccess(node -> {
       vertx = node;
       MessageProducer<String> sender = vertx.eventBus().sender("foo");
       sender.write("the_string", onFailure(err -> {

File: src/test/java/io/vertx/core/impl/GlobalEventExecutorNotificationTest.java
Patch:
@@ -53,7 +53,7 @@ public void testProxyConnectError() {
 
   private void testConnectErrorNotifiesOnEventLoop(NetClientOptions options) {
     RuntimeException cause = new RuntimeException();
-    vertx = new VertxFactory().transport(new Transport() {
+    vertx = new VertxBuilder().transport(new Transport() {
       @Override
       public ChannelFactory<? extends Channel> channelFactory(boolean domainSocket) {
         return (ChannelFactory<Channel>) () -> {
@@ -76,7 +76,7 @@ public ChannelFactory<? extends Channel> channelFactory(boolean domainSocket) {
   @Test
   public void testNetBindError() {
     RuntimeException cause = new RuntimeException();
-    vertx = new VertxFactory().transport(new Transport() {
+    vertx = new VertxBuilder().transport(new Transport() {
       @Override
       public ChannelFactory<? extends ServerChannel> serverChannelFactory(boolean domainSocket) {
         return (ChannelFactory<ServerChannel>) () -> {
@@ -96,7 +96,7 @@ public ChannelFactory<? extends ServerChannel> serverChannelFactory(boolean doma
   @Test
   public void testHttpBindError() {
     RuntimeException cause = new RuntimeException();
-    vertx = new VertxFactory().transport(new Transport() {
+    vertx = new VertxBuilder().transport(new Transport() {
       @Override
       public ChannelFactory<? extends ServerChannel> serverChannelFactory(boolean domainSocket) {
         return (ChannelFactory<ServerChannel>) () -> {

File: src/test/java/io/vertx/test/fakemetrics/FakeMetricsFactory.java
Patch:
@@ -22,7 +22,7 @@ public class FakeMetricsFactory implements VertxMetricsFactory {
 
   @Override
   public VertxMetrics metrics(VertxOptions options) {
-    return new FakeVertxMetrics();
+    return new FakeVertxMetrics(options.getMetricsOptions());
   }
 
 }

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -3161,6 +3161,7 @@ public void start() {
         server.requestHandler(req -> {
           req.response().end();
           assertSameEventLoop(ctx, Vertx.currentContext());
+          assertSame(req.context(), Vertx.currentContext());
           if (!worker) {
             assertSame(thr, Thread.currentThread());
           }

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2011-2021 Contributors to the Eclipse Foundation
  *
  * This program and the accompanying materials are made available under the
  * terms of the Eclipse Public License 2.0 which is available at
@@ -90,7 +90,7 @@ public void close(Promise<Void> completion) {
       if (!closed) {
         closed = true;
         closeHooks.remove(this);
-        pool.release();
+        pool.close();
       }
     }
     completion.complete();

File: src/main/java/io/vertx/core/buffer/impl/VertxByteBufAllocator.java
Patch:
@@ -15,7 +15,7 @@
 import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.util.internal.PlatformDependent;
 
-abstract class VertxByteBufAllocator extends AbstractByteBufAllocator {
+public abstract class VertxByteBufAllocator extends AbstractByteBufAllocator {
 
   private static VertxByteBufAllocator UNSAFE_IMPL = new VertxByteBufAllocator() {
     @Override
@@ -31,7 +31,7 @@ protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) {
     }
   };
 
-  static final VertxByteBufAllocator DEFAULT = PlatformDependent.hasUnsafe() ? UNSAFE_IMPL : IMPL;
+  public static final VertxByteBufAllocator DEFAULT = PlatformDependent.hasUnsafe() ? UNSAFE_IMPL : IMPL;
 
   @Override
   protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -486,7 +486,7 @@ public void handleMessage(Object msg) {
         DatagramPacket packet = (DatagramPacket) msg;
         ByteBuf content = packet.content();
         if (content.isDirect())  {
-          content = VertxHandler.safeBuffer(content, chctx.alloc());
+          content = VertxHandler.safeBuffer(content);
         }
         handlePacket(new DatagramPacketImpl(packet.sender(), Buffer.buffer(content)));
       }

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -562,6 +562,8 @@ private void endDecode() {
           } catch (Exception e) {
             // Will never happen, anyway handle it somehow just in case
             handleException(e);
+          } finally {
+            attr.release();
           }
         }
       }

File: src/main/java/io/vertx/core/http/impl/Http1xUpgradeToH2CHandler.java
Patch:
@@ -119,7 +119,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
       if (handler != null) {
         if (msg instanceof HttpContent) {
           HttpContent content = (HttpContent) msg;
-          ByteBuf buf = VertxHandler.safeBuffer(content.content(), ctx.alloc());
+          ByteBuf buf = VertxHandler.safeBuffer(content.content());
           boolean end = msg instanceof LastHttpContent;
           ctx.fireChannelRead(new DefaultHttp2DataFrame(buf, end, 0));
           if (end) {

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequestImpl.java
Patch:
@@ -225,6 +225,8 @@ void handleEnd(MultiMap trailers) {
               } catch (Exception e) {
                 // Will never happen, anyway handle it somehow just in case
                 handleException(e);
+              } finally {
+                attr.release();
               }
             }
           }

File: src/test/java/io/vertx/core/datagram/DatagramTest.java
Patch:
@@ -11,6 +11,7 @@
 package io.vertx.core.datagram;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.UnpooledHeapByteBuf;
 import io.vertx.core.AbstractVerticle;
 import io.vertx.core.Context;
 import io.vertx.core.DeploymentOptions;
@@ -112,7 +113,8 @@ public void testSendReceive() throws Exception {
         while (buff != buff.unwrap() && buff.unwrap() != null) {
           buff = buff.unwrap();
         }
-        assertTrue("Was expecting an unpooled buffer instead of " + buff.getClass().getSimpleName(), buff.getClass().getSimpleName().contains("Unpooled"));
+
+        assertTrue("Was expecting an unpooled buffer instead of " + buff.getClass().getSimpleName(), buff instanceof UnpooledHeapByteBuf);
         assertEquals(expected, data);
         complete();
       });

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -2027,7 +2027,6 @@ public void handle(Buffer data) {
     await();
   }
 
-
   @Test
   public void testInvalidUnmaskedFrameRequest(){
 

File: src/main/java/io/vertx/core/http/impl/Http2ServerStream.java
Patch:
@@ -98,7 +98,7 @@ void onEnd(MultiMap trailers) {
     if (Metrics.METRICS_ENABLED) {
       HttpServerMetrics metrics = conn.metrics();
       if (metrics != null) {
-        metrics.requestEnd(metric, bytesRead());
+        metrics.requestEnd(metric, (HttpRequest) this, bytesRead());
       }
     }
     super.onEnd(trailers);
@@ -139,7 +139,7 @@ void handleClose() {
         if (failed) {
           metrics.requestReset(metric);
         } else {
-          metrics.responseEnd(metric, bytesWritten());
+          metrics.responseEnd(metric, response, bytesWritten());
         }
       }
     }

File: src/test/java/io/vertx/core/spi/metrics/MetricsContextTest.java
Patch:
@@ -105,7 +105,7 @@ public Void requestBegin(Void socketMetric, HttpRequest request) {
             return null;
           }
           @Override
-          public void responseEnd(Void requestMetric, long bytesWritten) {
+          public void responseEnd(Void requestMetric, HttpResponse response, long bytesWritten) {
             responseEndCalled.set(true);
           }
           @Override
@@ -202,15 +202,15 @@ public Void requestBegin(Void socketMetric, HttpRequest request) {
             return null;
           }
           @Override
-          public void requestEnd(Void requestMetric, long bytesRead) {
+          public void requestEnd(Void requestMetric, HttpRequest request, long bytesRead) {
             assertEquals(1, httpLifecycle.getAndIncrement());
           }
           @Override
           public void responseBegin(Void requestMetric, HttpResponse response) {
             assertEquals(2, httpLifecycle.getAndIncrement());
           }
           @Override
-          public void responseEnd(Void requestMetric, long bytesWritten) {
+          public void responseEnd(Void requestMetric, HttpResponse response, long bytesWritten) {
             assertEquals(3, httpLifecycle.getAndIncrement());
           }
           @Override

File: src/test/java/io/vertx/test/fakemetrics/FakeHttpServerMetrics.java
Patch:
@@ -13,7 +13,6 @@
 
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpServerRequest;
-import io.vertx.core.http.HttpServerResponse;
 import io.vertx.core.http.ServerWebSocket;
 import io.vertx.core.http.WebSocketBase;
 import io.vertx.core.impl.ConcurrentHashSet;
@@ -53,7 +52,7 @@ public HttpServerMetric requestBegin(SocketMetric socketMetric, HttpRequest requ
   }
 
   @Override
-  public void requestEnd(HttpServerMetric requestMetric, long bytesRead) {
+  public void requestEnd(HttpServerMetric requestMetric, HttpRequest request, long bytesRead) {
     requestMetric.requestEnded.set(true);
     requestMetric.bytesRead.set(bytesRead);
   }
@@ -78,7 +77,7 @@ public void responseBegin(HttpServerMetric requestMetric, HttpResponse response)
   }
 
   @Override
-  public void responseEnd(HttpServerMetric requestMetric, long bytesWritten) {
+  public void responseEnd(HttpServerMetric requestMetric, HttpResponse response, long bytesWritten) {
     requests.remove(requestMetric);
     requestMetric.responseEnded.set(true);
     requestMetric.bytesWritten.set(bytesWritten);

File: src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -388,6 +388,7 @@ default void send(ReadStream<Buffer> body, Handler<AsyncResult<HttpClientRespons
     if (headers == null || !headers.contains(HttpHeaders.CONTENT_LENGTH)) {
       setChunked(true);
     }
+    response(handler);
     body.pipeTo(this);
   }
 

File: src/test/java/io/vertx/core/eventbus/ClusteredEventBusTestBase.java
Patch:
@@ -185,7 +185,6 @@ public void handle(AsyncResult<Void> ar) {
     reg.completionHandler(new MyRegisterHandler());
     reg = vertices[1].eventBus().<T>consumer(ADDRESS1).handler(new MyHandler());
     reg.completionHandler(new MyRegisterHandler());
-    vertices[0].eventBus().publish(ADDRESS1, val);
     await();
   }
 

File: src/main/java/io/vertx/core/eventbus/impl/MessageTagExtractor.java
Patch:
@@ -33,7 +33,7 @@ public int len(Message<?> obj) {
   @Override
   public String name(Message<?> obj, int index) {
     if (index == 0) {
-      return "peer.service";
+      return "message_bus.destination";
     }
     throw new IndexOutOfBoundsException("Invalid tag index " + index);
   }

File: src/test/java/io/vertx/core/spi/tracing/EventBusTracerTestBase.java
Patch:
@@ -69,7 +69,7 @@ class EventBusTracer implements VertxTracer<Object, Object> {
     private <T> String addressOf(T obj, TagExtractor<T> extractor) {
       int len = extractor.len(obj);
       for (int idx = 0;idx < len;idx++) {
-        if (extractor.name(obj, idx).equals("peer.service")) {
+        if (extractor.name(obj, idx).equals("message_bus.destination")) {
           String value = extractor.value(obj, idx);
           if (value.startsWith("__vertx")) {
             value = "generated";

File: src/main/java/io/vertx/core/eventbus/impl/MessageTagExtractor.java
Patch:
@@ -33,7 +33,7 @@ public int len(Message<?> obj) {
   @Override
   public String name(Message<?> obj, int index) {
     if (index == 0) {
-      return "peer.service";
+      return "message_bus.destination";
     }
     throw new IndexOutOfBoundsException("Invalid tag index " + index);
   }

File: src/test/java/io/vertx/core/spi/tracing/EventBusTracerTestBase.java
Patch:
@@ -69,7 +69,7 @@ class EventBusTracer implements VertxTracer<Object, Object> {
     private <T> String addressOf(T obj, TagExtractor<T> extractor) {
       int len = extractor.len(obj);
       for (int idx = 0;idx < len;idx++) {
-        if (extractor.name(obj, idx).equals("peer.service")) {
+        if (extractor.name(obj, idx).equals("message_bus.destination")) {
           String value = extractor.value(obj, idx);
           if (value.startsWith("__vertx")) {
             value = "generated";

File: src/main/java/io/vertx/core/eventbus/impl/OutboundDeliveryContext.java
Patch:
@@ -119,7 +119,9 @@ public void next() {
           src = true;
           BiConsumer<String, String> biConsumer = (String key, String val) -> message.headers().set(key, val);
           TracingPolicy tracingPolicy = options.getTracingPolicy();
-          if (tracingPolicy == null) tracingPolicy = TracingPolicy.PROPAGATE;
+          if (tracingPolicy == null) {
+            tracingPolicy = TracingPolicy.PROPAGATE;
+          }
           message.trace = tracer.sendRequest(ctx, SpanKind.RPC, tracingPolicy, message, message.send ? "send" : "publish", biConsumer, MessageTagExtractor.INSTANCE);
         } else {
           // Handle failure here

File: src/test/java/io/vertx/core/http/Http2ServerTest.java
Patch:
@@ -649,7 +649,7 @@ public void testPostFileUpload() throws Exception {
         });
       });
       req.endHandler(v -> {
-        assertEquals(5, req.formAttributes().size());
+        assertEquals(0, req.formAttributes().size());
         req.response().putHeader("content-type", "text/plain").end("done");
       });
     });

File: src/test/java/io/vertx/core/http/Http2ServerTest.java
Patch:
@@ -649,7 +649,7 @@ public void testPostFileUpload() throws Exception {
         });
       });
       req.endHandler(v -> {
-        assertEquals(0, req.formAttributes().size());
+        assertEquals(5, req.formAttributes().size());
         req.response().putHeader("content-type", "text/plain").end("done");
       });
     });

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -460,7 +460,7 @@ public HttpServerRequest setExpectMultipart(boolean expect) {
           if (!HttpUtils.isValidMultipartMethod(request.method())) {
             throw new IllegalStateException("Request method must be one of POST, PUT, PATCH or DELETE to decode a multipart request");
           }
-          decoder = new HttpPostRequestDecoder(new NettyFileUploadDataFactory(conn.getContext(), this, () -> uploadHandler), request);
+          decoder = new HttpPostRequestDecoder(new NettyFileUploadDataFactory(context, this, () -> uploadHandler), request);
         }
       } else {
         decoder = null;

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -142,7 +142,7 @@ void handleContent(Buffer buffer) {
         conn.doPause();
       }
     } else {
-      onData(buffer);
+      context.execute(buffer, this::onData);
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/NettyFileUploadDataFactory.java
Patch:
@@ -47,7 +47,7 @@ public FileUpload createFileUpload(HttpRequest httpRequest, String name, String
       size);
     Handler<HttpServerFileUpload> uploadHandler = lazyUploadHandler.get();
     if (uploadHandler != null) {
-      uploadHandler.handle(upload);
+      context.dispatch(upload, uploadHandler);
     }
     return nettyUpload;
   }

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -111,7 +111,7 @@ void onHeaders(Http2Headers headers, StreamPriority streamPriority) {
 
   void onData(Buffer data) {
     conn.reportBytesRead(data.length());
-    context.emit(data, pending::write);
+    context.execute(data, pending::write);
   }
 
   void onWritabilityChanged() {

File: src/test/java/io/vertx/core/http/HttpServerFileUploadTest.java
Patch:
@@ -12,6 +12,7 @@
 
 import io.vertx.core.Future;
 import io.vertx.core.MultiMap;
+import io.vertx.core.Vertx;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.file.AsyncFile;
 import io.vertx.core.net.SocketAddress;
@@ -205,6 +206,8 @@ private void testFormUploadFile(String filename,
 
         req.uploadHandler(upload -> {
 
+          assertNotNull(Vertx.currentContext());
+
           serverConn.set(req.connection());
           checkClose.run();
 

File: src/main/java/io/vertx/core/impl/future/Composition.java
Patch:
@@ -20,12 +20,12 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-class ComposeTransformation<T, U> extends Transformation<U> implements Listener<T> {
+class Composition<T, U> extends Operation<U> implements Listener<T> {
 
   private final Function<T, Future<U>> successMapper;
   private final Function<Throwable, Future<U>> failureMapper;
 
-  ComposeTransformation(ContextInternal context, Function<T, Future<U>> successMapper, Function<Throwable, Future<U>> failureMapper) {
+  Composition(ContextInternal context, Function<T, Future<U>> successMapper, Function<Throwable, Future<U>> failureMapper) {
     super(context);
     this.successMapper = successMapper;
     this.failureMapper = failureMapper;

File: src/main/java/io/vertx/core/impl/future/FixedMapping.java
Patch:
@@ -17,11 +17,11 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-class MapValueTransformation<T, U> extends Transformation<U> implements Listener<T> {
+class FixedMapping<T, U> extends Operation<U> implements Listener<T> {
 
   private final U value;
 
-  MapValueTransformation(ContextInternal context, U value) {
+  FixedMapping(ContextInternal context, U value) {
     super(context);
     this.value = value;
   }

File: src/main/java/io/vertx/core/impl/future/FixedOtherwise.java
Patch:
@@ -17,11 +17,11 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-class OtherwiseValueTransformation<T> extends Transformation<T> implements Listener<T> {
+class FixedOtherwise<T> extends Operation<T> implements Listener<T> {
 
   private final T value;
 
-  OtherwiseValueTransformation(ContextInternal context, T value) {
+  FixedOtherwise(ContextInternal context, T value) {
     super(context);
     this.value = value;
   }

File: src/main/java/io/vertx/core/impl/future/Mapping.java
Patch:
@@ -19,11 +19,11 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-class MapTransformation<T, U> extends Transformation<U> implements Listener<T> {
+class Mapping<T, U> extends Operation<U> implements Listener<T> {
 
   private final Function<T, U> successMapper;
 
-  MapTransformation(ContextInternal context, Function<T, U> successMapper) {
+  Mapping(ContextInternal context, Function<T, U> successMapper) {
     super(context);
     this.successMapper = successMapper;
   }

File: src/main/java/io/vertx/core/impl/future/Otherwise.java
Patch:
@@ -14,11 +14,11 @@
 
 import java.util.function.Function;
 
-class OtherwiseTransformation<T> extends Transformation<T> implements Listener<T> {
+class Otherwise<T> extends Operation<T> implements Listener<T> {
 
   private final Function<Throwable, T> mapper;
 
-  OtherwiseTransformation(ContextInternal context, Function<Throwable, T> mapper) {
+  Otherwise(ContextInternal context, Function<Throwable, T> mapper) {
     super(context);
     this.mapper = mapper;
   }

File: src/main/java/io/vertx/core/tracing/TracingPolicy.java
Patch:
@@ -10,11 +10,14 @@
  */
 package io.vertx.core.tracing;
 
+import io.vertx.codegen.annotations.VertxGen;
+
 /**
  * Policy controlling the behavior across boundaries.
  *
  * This control is applied for clients or servers reporting traces.
  */
+@VertxGen
 public enum TracingPolicy {
 
   /**

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -217,7 +217,7 @@ private ConnectionManager<EndpointKey, HttpClientConnection> httpConnectionManag
   }
 
   private ConnectionManager<EndpointKey, HttpClientConnection> webSocketConnectionManager() {
-    int maxPoolSize = options.getMaxPoolSize();
+    int maxPoolSize = options.getMaxWebSockets();
     return new ConnectionManager<>((key, ctx, dispose) -> {
       String host;
       int port;

File: src/main/java/io/vertx/core/CompositeFuture.java
Patch:
@@ -73,7 +73,7 @@ static <T1, T2, T3, T4, T5, T6> CompositeFuture all(Future<T1> f1, Future<T2> f2
    * When the list is empty, the returned future will be already completed.
    */
   static CompositeFuture all(List<Future> futures) {
-    return CompositeFutureImpl.all(futures.toArray(new Future[futures.size()]));
+    return CompositeFutureImpl.all(futures.toArray(new Future[0]));
   }
 
   /**
@@ -123,7 +123,7 @@ static <T1, T2, T3, T4, T5, T6> CompositeFuture any(Future<T1> f1, Future<T2> f2
    * When the list is empty, the returned future will be already completed.
    */
   static CompositeFuture any(List<Future> futures) {
-    return CompositeFutureImpl.any(futures.toArray(new Future[futures.size()]));
+    return CompositeFutureImpl.any(futures.toArray(new Future[0]));
   }
 
   /**
@@ -173,7 +173,7 @@ static <T1, T2, T3, T4, T5, T6> CompositeFuture join(Future<T1> f1, Future<T2> f
    * When the list is empty, the returned future will be already completed.
    */
   static CompositeFuture join(List<Future> futures) {
-    return CompositeFutureImpl.join(futures.toArray(new Future[futures.size()]));
+    return CompositeFutureImpl.join(futures.toArray(new Future[0]));
   }
 
   @Override

File: src/main/java/io/vertx/core/file/impl/FileSystemImpl.java
Patch:
@@ -607,7 +607,7 @@ private BlockingAction<Void> copyInternal(String from, String to, CopyOptions op
     Objects.requireNonNull(to);
     Objects.requireNonNull(options);
     Set<CopyOption> copyOptionSet = toCopyOptionSet(options);
-    CopyOption[] copyOptions = copyOptionSet.toArray(new CopyOption[copyOptionSet.size()]);
+    CopyOption[] copyOptions = copyOptionSet.toArray(new CopyOption[0]);
     return new BlockingAction<Void>() {
       public Void perform() {
         try {
@@ -669,7 +669,7 @@ private BlockingAction<Void> moveInternal(String from, String to, CopyOptions op
     Objects.requireNonNull(to);
     Objects.requireNonNull(options);
     Set<CopyOption> copyOptionSet = toCopyOptionSet(options);
-    CopyOption[] copyOptions = copyOptionSet.toArray(new CopyOption[copyOptionSet.size()]);
+    CopyOption[] copyOptions = copyOptionSet.toArray(new CopyOption[0]);
     return new BlockingAction<Void>() {
       public Void perform() {
         try {

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -798,7 +798,7 @@ synchronized void toWebSocket(
       ArrayList<WebSocketClientExtensionHandshaker> extensionHandshakers = initializeWebSocketExtensionHandshakers(client.getOptions());
       if (!extensionHandshakers.isEmpty()) {
         p.addBefore("handler", "webSocketsExtensionsHandler", new WebSocketClientExtensionHandler(
-          extensionHandshakers.toArray(new WebSocketClientExtensionHandshaker[extensionHandshakers.size()])));
+          extensionHandshakers.toArray(new WebSocketClientExtensionHandshaker[0])));
       }
 
       String subp = null;

File: src/main/java/io/vertx/core/http/impl/HttpServerConnectionHandler.java
Patch:
@@ -92,7 +92,7 @@ private void initializeWebSocketExtensions(ChannelPipeline pipeline) {
     }
     if (!extensionHandshakers.isEmpty()) {
       WebSocketServerExtensionHandler extensionHandler = new WebSocketServerExtensionHandler(
-        extensionHandshakers.toArray(new WebSocketServerExtensionHandshaker[extensionHandshakers.size()]));
+        extensionHandshakers.toArray(new WebSocketServerExtensionHandshaker[0]));
       pipeline.addBefore("handler", "webSocketExtensionHandler", extensionHandler);
     }
   }

File: src/main/java/io/vertx/core/impl/LoaderManager.java
Patch:
@@ -93,7 +93,7 @@ private static ClassLoader buildLoader(URLClassLoader parent, DeploymentOptions
     }
     // And add the URLs of the Vert.x classloader
     urls.addAll(Arrays.asList(parent.getURLs()));
-    return new IsolatingClassLoader(urls.toArray(new URL[urls.size()]), parent,
+    return new IsolatingClassLoader(urls.toArray(new URL[0]), parent,
       options.getIsolatedClasses());
   }
 }

File: src/main/java/io/vertx/core/impl/launcher/commands/FileSelector.java
Patch:
@@ -360,6 +360,6 @@ private static String[] tokenizePathToString(String path, String separator) {
     while (st.hasMoreTokens()) {
       ret.add(st.nextToken());
     }
-    return ret.toArray(new String[ret.size()]);
+    return ret.toArray(new String[0]);
   }
 }

File: src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
Patch:
@@ -393,7 +393,7 @@ protected void startAsBackgroundApplication(Handler<Void> onCompletion) {
     // Enable stream redirection
     args.add("--redirect-output");
 
-    executionContext.execute("start", args.toArray(new String[args.size()]));
+    executionContext.execute("start", args.toArray(new String[0]));
     if (onCompletion != null) {
       onCompletion.handle(null);
     }

File: src/main/java/io/vertx/core/impl/resolver/DnsResolverProvider.java
Patch:
@@ -212,7 +212,7 @@ public AddressResolverGroup<InetSocketAddress> resolver(AddressResolverOptions o
   @Override
   public void close(Handler<Void> doneHandler) {
     Context context = vertx.getOrCreateContext();
-    ResolverRegistration[] registrations = this.resolvers.toArray(new ResolverRegistration[this.resolvers.size()]);
+    ResolverRegistration[] registrations = this.resolvers.toArray(new ResolverRegistration[0]);
     if (registrations.length == 0) {
       context.runOnContext(doneHandler);
       return;

File: src/main/java/io/vertx/core/net/impl/KeyStoreHelper.java
Patch:
@@ -127,7 +127,7 @@ public String chooseServerAlias(String s, Principal[] principals, Socket socket)
             }
             @Override
             public X509Certificate[] getCertificateChain(String s) {
-              return chain.toArray(new X509Certificate[chain.size()]);
+              return chain.toArray(new X509Certificate[0]);
             }
             @Override
             public PrivateKey getPrivateKey(String s) {
@@ -350,7 +350,7 @@ private static X509Certificate[] loadCerts(Buffer buffer) throws Exception {
     if (certs.isEmpty()) {
       throw new RuntimeException("Missing -----BEGIN CERTIFICATE----- delimiter");
     }
-    return certs.toArray(new X509Certificate[certs.size()]);
+    return certs.toArray(new X509Certificate[0]);
   }
 
   /**

File: src/test/java/io/vertx/core/file/NestedJarFileResolverTest.java
Patch:
@@ -50,6 +50,8 @@ public URL getResource(String name) {
             return new URL("jar:" + webrootURL + "!/lib/nested.jar!afile.html/");
           } else if (name.equals("afile with spaces.html")) {
             return new URL("jar:" + webrootURL + "!/lib/nested.jar!afile with spaces.html/");
+          } else if (name.equals("afilewithspaceatend ")) {
+            return new URL("jar:" + webrootURL + "!/lib/nested.jar!afilewithspaceatend /");
           }
         } catch (MalformedURLException e) {
           throw new AssertionError(e);

File: src/test/java/io/vertx/core/file/NestedZipFileResolverTest.java
Patch:
@@ -50,6 +50,8 @@ public URL getResource(String name) {
             return new URL("jar:" + webrootURL + "!/lib/nested.zip!afile.html/");
           } else if (name.equals("afile with spaces.html")) {
             return new URL("jar:" + webrootURL + "!/lib/nested.zip!afile with spaces.html/");
+          } else if (name.equals("afilewithspaceatend ")) {
+            return new URL("jar:" + webrootURL + "!/lib/nested.zip!afilewithspaceatend /");
           }
         } catch (MalformedURLException e) {
           throw new AssertionError(e);

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -236,7 +236,6 @@ public MessageImpl createMessage(boolean send, String address, MultiMap headers,
   }
 
   protected <T> HandlerHolder<T> addRegistration(String address, HandlerRegistration<T> registration, boolean replyHandler, boolean localOnly, Promise<Void> promise) {
-//    Objects.requireNonNull(registration.getHandler(), "handler");
     HandlerHolder<T> holder = addLocalRegistration(address, registration, replyHandler, localOnly);
     onLocalRegistration(holder, promise);
     return holder;

File: src/main/java/io/vertx/core/logging/LoggerFactory.java
Patch:
@@ -60,6 +60,9 @@ private static boolean configureWith(String name, boolean shortName, ClassLoader
     try {
       Class<?> clazz = Class.forName(shortName ? "io.vertx.core.logging." + name + "LogDelegateFactory" : name, true, loader);
       LogDelegateFactory factory = (LogDelegateFactory) clazz.newInstance();
+      if (!factory.isAvailable()) {
+        return false;
+      }
       factory.createDelegate(loggerName).debug("Using " + factory.getClass().getName());
       delegateFactory = factory;
       return true;

File: src/test/java/io/vertx/core/ServiceHelperTest.java
Patch:
@@ -49,16 +49,15 @@ public void setUp() throws IOException {
         output));
 
     List<File> classesToCompile = new ArrayList<>();
-    classesToCompile.add(new File("src/test/externals/MyVerticle.java"));
-    classesToCompile.add(new File("src/test/externals/SomeFactoryImplA.java"));
+    classesToCompile.add(new File("src/test/classpath/servicehelper/SomeFactoryImplA.java"));
 
     Iterable<? extends JavaFileObject> compilationUnits1 =
         fileManager.getJavaFileObjectsFromFiles(classesToCompile);
 
     compiler.getTask(null, fileManager, null, null, null, compilationUnits1).call();
 
     // Also copy the META-INF dir
-    File source = new File("src/test/externals/META-INF/services/io.vertx.test.spi.SomeFactory");
+    File source = new File("src/test/classpath/servicehelper/META-INF/services/io.vertx.test.spi.SomeFactory");
     File out = new File("target/externals/META-INF/services/io.vertx.test.spi.SomeFactory");
     out.getParentFile().mkdirs();
     Files.copy(source.toPath(), out.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);

File: src/test/java/io/vertx/core/file/FileResolverTestBase.java
Patch:
@@ -56,7 +56,7 @@ public abstract class FileResolverTestBase extends VertxTestBase {
   public void setUp() throws Exception {
     super.setUp();
     testCL = Thread.currentThread().getContextClassLoader();
-    File baseDir = new File(new File(new File("src"), "test"), "fileresolver");
+    File baseDir = new File(new File(new File(new File("src"), "test"), "classpath"), "fileresolver");
     assertTrue(baseDir.exists() && baseDir.isDirectory());
     ClassLoader resourcesLoader = resourcesLoader(baseDir);
     Thread.currentThread().setContextClassLoader(resourcesLoader);

File: src/test/java/io/vertx/core/impl/launcher/commands/ClasspathHandlerTest.java
Patch:
@@ -44,7 +44,7 @@ public void setUp() throws IOException {
 
     Iterable<? extends JavaFileObject> compilationUnits1 =
         fileManager.getJavaFileObjectsFromFiles(Collections.singletonList(
-            new File("src/test/externals/MyVerticle.java")));
+            new File("src/test/classpath/verticle/MyVerticle.java")));
 
     compiler.getTask(null, fileManager, null, null, null, compilationUnits1).call();
   }

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -20,6 +20,7 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.dns.AddressResolverOptions;
 import io.vertx.core.file.AsyncFile;
+import io.vertx.core.impl.Utils;
 import io.vertx.core.net.*;
 import io.vertx.core.net.impl.HAProxyMessageCompletionHandler;
 import io.vertx.core.streams.Pump;
@@ -2330,6 +2331,7 @@ public void testRequestTimesOutWhenIndicatedPeriodExpiresWithoutAResponseFromRem
 
   @Test
   public void testRequestTimeoutCanceledWhenRequestHasAnOtherError() {
+    Assume.assumeFalse(Utils.isWindows());
     AtomicReference<Throwable> exception = new AtomicReference<>();
     // There is no server running, should fail to connect
     client.request(new RequestOptions().setPort(5000).setTimeout(800))

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -399,6 +399,7 @@ private void testHandlerProcessMessage(Vertx from, Vertx to, int expectedLocalCo
 
   @Test
   public void testHandlerMetricReply() throws Exception {
+    AtomicReference<HandlerMetric> replyRegistration = new AtomicReference<>();
     CountDownLatch latch = new CountDownLatch(1);
     FakeEventBusMetrics metrics = FakeMetricsBase.getMetrics(vertx.eventBus());
     vertx.eventBus().consumer(ADDRESS1, msg -> {
@@ -409,6 +410,7 @@ public void testHandlerMetricReply() throws Exception {
       assertEquals(0, registration.scheduleCount.get());
       assertEquals(0, registration.deliveredCount.get());
       assertEquals(0, registration.localDeliveredCount.get());
+      replyRegistration.set(registration);
       msg.reply("pong");
     }).completionHandler(ar -> {
       assertTrue(ar.succeeded());
@@ -417,7 +419,7 @@ public void testHandlerMetricReply() throws Exception {
     awaitLatch(latch);
     vertx.eventBus().request(ADDRESS1, "ping", reply -> {
       assertEquals(ADDRESS1, metrics.getRegistrations().get(0).address);
-      HandlerMetric registration = metrics.getRegistrations().get(1);
+      HandlerMetric registration = replyRegistration.get();
       assertEquals(ADDRESS1, registration.repliedAddress);
       assertEquals(1, registration.scheduleCount.get());
       assertEquals(1, registration.deliveredCount.get());

File: src/test/java/io/vertx/core/http/HttpTLSTest.java
Patch:
@@ -1435,7 +1435,7 @@ private void testStore(HttpServerOptions serverOptions, List<String> expectedPos
         ok |= cause.getMessage().startsWith(expectedPossiblePrefix);
       }
       if (!ok) {
-        fail("Was expecting e.getCause().getMessage() to be prefixed by one of " + expectedPossiblePrefixes);
+        fail("Was expecting <" + cause.getMessage() + "> e.getCause().getMessage() to be prefixed by one of " + expectedPossiblePrefixes);
       }
       assertTrue(cause.getMessage().endsWith(expectedSuffix));
     }

File: src/main/java/io/vertx/core/file/impl/FileResolver.java
Patch:
@@ -55,8 +55,9 @@ public class FileResolver {
 
   static {
     if (PlatformDependent.isWindows()) {
+      // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions
       CACHE_PATH_CHECKER = c -> {
-        if (c < 33) {
+        if (c < 32) {  // control characters 0-31 are invalid, space character 32 is valid
           return false;
         } else {
           switch (c) {

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -5220,16 +5220,15 @@ private void testPoolNotExpiring(HttpClientOptions options) throws Exception {
     client.close();
     client = vertx.createHttpClient(options);
     client.request(requestOptions)
-      .compose(HttpClientRequest::send)
-      .onComplete(onSuccess(resp -> {
+      .onComplete(onSuccess(req -> req.send().onComplete(onSuccess(resp -> {
         resp.endHandler(v1 -> {
           resp.request().connection().closeHandler(v2 -> {
             long time = System.currentTimeMillis() - now.get();
             assertTrue("Was expecting " + time + " to be > 2000", time >= 2000);
             testComplete();
           });
         });
-      }));
+      }))));
     await();
   }
 

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -481,7 +481,7 @@ public void testReplyFailureTimeout1() throws Exception {
       latch.countDown();
     });
     awaitLatch(latch);
-    assertEquals(1, metrics.getReplyFailureAddresses().size());
+    waitUntil(() -> metrics.getReplyFailureAddresses().size() == 1);
     assertEquals(Collections.singletonList(ReplyFailure.TIMEOUT), metrics.getReplyFailures());
   }
 
@@ -500,7 +500,7 @@ public void testReplyFailureTimeout2() throws Exception {
     });
     awaitLatch(latch);
     FakeEventBusMetrics metrics = FakeMetricsBase.getMetrics(eb);
-    assertEquals(1, metrics.getReplyFailureAddresses().size());
+    waitUntil(() -> metrics.getReplyFailureAddresses().size() == 1);
     assertEquals(Collections.singletonList(ReplyFailure.TIMEOUT), metrics.getReplyFailures());
   }
 

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -523,7 +523,7 @@ public void testReplyFailureRecipientFailure() throws Exception {
       latch.countDown();
     });
     awaitLatch(latch);
-    assertEquals(Collections.singletonList("foo"), metrics.getReplyFailureAddresses());
+    assertWaitUntil(() -> metrics.getReplyFailureAddresses().equals(Collections.singletonList("foo")));
     assertEquals(Collections.singletonList(ReplyFailure.RECIPIENT_FAILURE), metrics.getReplyFailures());
   }
 

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -13,7 +13,6 @@
 
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.GenIgnore;
-import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.future.FailedFuture;
 import io.vertx.core.impl.future.SucceededFuture;
@@ -28,7 +27,6 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@VertxGen
 public interface Future<T> extends AsyncResult<T> {
 
   /**

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -132,7 +132,7 @@ public class HttpServerOptions extends NetServerOptions {
   public static final boolean DEFAULT_WEBSOCKET_PREFERRED_CLIENT_NO_CONTEXT = false;
 
   /**
-   * Default tracing control = {@link TracingPolicy#PROPAGATE}
+   * Default tracing control = {@link TracingPolicy#ALWAYS}
    */
   public static final TracingPolicy DEFAULT_TRACING_POLICY = TracingPolicy.ALWAYS;
 

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -134,7 +134,7 @@ public class HttpServerOptions extends NetServerOptions {
   /**
    * Default tracing control = {@link TracingPolicy#PROPAGATE}
    */
-  public static final TracingPolicy DEFAULT_TRACING_POLICY = TracingPolicy.PROPAGATE;
+  public static final TracingPolicy DEFAULT_TRACING_POLICY = TracingPolicy.ALWAYS;
 
   private boolean compressionSupported;
   private int compressionLevel;

File: src/main/java/io/vertx/core/impl/future/SucceededFuture.java
Patch:
@@ -115,7 +115,7 @@ public Future<T> otherwise(Function<Throwable, T> mapper) {
 
   @Override
   public Future<T> otherwise(T value) {
-    return new SucceededFuture<>(context, value);
+    return this;
   }
 
   @Override

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -250,7 +250,9 @@ public void handle(Buffer buff) {
             }
             parser.fixedSizeMode(4);
             size = -1;
-            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {
+            if (received.hasFailure()) {
+              received.internalError();
+            } else if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {
               // Just send back pong directly on connection
               socket.write(PONG);
             } else {

File: src/main/java/io/vertx/core/eventbus/ReplyFailure.java
Patch:
@@ -39,7 +39,7 @@ public enum ReplyFailure {
   /**
    * A fatal error occured while delivering the message. Do not retry to send.
    */
-  INTERNAL_ERROR;
+  ERROR;
 
   public static ReplyFailure fromInt(int i) {
     switch (i) {
@@ -50,7 +50,7 @@ public static ReplyFailure fromInt(int i) {
       case 2:
         return RECIPIENT_FAILURE;
       case 3:
-        return INTERNAL_ERROR;
+        return ERROR;
       default:
         throw new IllegalStateException("Invalid index " + i);
     }
@@ -64,7 +64,7 @@ public int toInt() {
         return 1;
       case RECIPIENT_FAILURE:
         return 2;
-      case INTERNAL_ERROR:
+      case ERROR:
         return 3;
       default:
         throw new IllegalStateException("How did we get here?");

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredMessage.java
Patch:
@@ -273,7 +273,7 @@ boolean hasFailure() {
 
   void internalError() {
     if (replyAddress != null) {
-      reply(new ReplyException(ReplyFailure.INTERNAL_ERROR, failure));
+      reply(new ReplyException(ReplyFailure.ERROR, failure));
     } else {
       log.trace(failure);
     }

File: src/test/java/io/vertx/core/eventbus/ReplyFailureErrorTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import static org.hamcrest.CoreMatchers.instanceOf;
 
-public class InternalErrorTest extends VertxTestBase {
+public class ReplyFailureErrorTest extends VertxTestBase {
 
   @Override
   public void setUp() throws Exception {
@@ -37,7 +37,7 @@ public void testUnknownCodec() {
       vertices[0].eventBus().request("foo", new MyPOJO("bar"), options, onFailure(t -> {
         assertThat(t, instanceOf(ReplyException.class));
         ReplyException e = (ReplyException) t;
-        assertSame(ReplyFailure.INTERNAL_ERROR, e.failureType());
+        assertSame(ReplyFailure.ERROR, e.failureType());
         testComplete();
       }));
     }));

File: src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -188,16 +188,18 @@ private void handleHandshake(int sc) {
 
   private void doHandshake() {
     Channel channel = conn.channel();
+    Object metric;
     try {
       handshaker.handshake(channel, request.nettyRequest());
+      metric = request.metric;
     } catch (Exception e) {
       request.response().setStatusCode(BAD_REQUEST.code()).end();
       throw e;
     } finally {
       request = null;
     }
     if (conn.metrics != null) {
-      conn.metrics.responseBegin(request.metric, new HttpResponseHead(HttpVersion.HTTP_1_1, 101, "Switching Protocol", MultiMap.caseInsensitiveMultiMap()));
+      conn.metrics.responseBegin(metric, new HttpResponseHead(HttpVersion.HTTP_1_1, 101, "Switching Protocol", MultiMap.caseInsensitiveMultiMap()));
     }
     conn.responseComplete();
     status = SWITCHING_PROTOCOLS.code();

File: src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -197,7 +197,7 @@ private void doHandshake() {
       request = null;
     }
     if (conn.metrics != null) {
-      conn.metrics.responseBegin(null, new HttpResponseHead(HttpVersion.HTTP_1_1, 101, "Switching Protocol", MultiMap.caseInsensitiveMultiMap()));
+      conn.metrics.responseBegin(request.metric, new HttpResponseHead(HttpVersion.HTTP_1_1, 101, "Switching Protocol", MultiMap.caseInsensitiveMultiMap()));
     }
     conn.responseComplete();
     status = SWITCHING_PROTOCOLS.code();

File: src/test/java/io/vertx/test/fakemetrics/FakeHttpClientMetrics.java
Patch:
@@ -137,11 +137,13 @@ public SocketMetric getSocket(SocketAddress address) {
   @Override
   public void bytesRead(SocketMetric socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
     socketMetric.bytesRead.addAndGet(numberOfBytes);
+    socketMetric.bytesReadEvents.add(numberOfBytes);
   }
 
   @Override
   public void bytesWritten(SocketMetric socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
     socketMetric.bytesWritten.addAndGet(numberOfBytes);
+    socketMetric.bytesWrittenEvents.add(numberOfBytes);
   }
 
   @Override

File: src/test/java/io/vertx/test/fakemetrics/FakeHttpServerMetrics.java
Patch:
@@ -104,11 +104,13 @@ public void disconnected(SocketMetric socketMetric, SocketAddress remoteAddress)
   @Override
   public void bytesRead(SocketMetric socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
     socketMetric.bytesRead.addAndGet(numberOfBytes);
+    socketMetric.bytesReadEvents.add(numberOfBytes);
   }
 
   @Override
   public void bytesWritten(SocketMetric socketMetric, SocketAddress remoteAddress, long numberOfBytes) {
     socketMetric.bytesWritten.addAndGet(numberOfBytes);
+    socketMetric.bytesWrittenEvents.add(numberOfBytes);
   }
 
   @Override

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -250,7 +250,9 @@ public void handle(Buffer buff) {
             }
             parser.fixedSizeMode(4);
             size = -1;
-            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {
+            if (received.hasFailure()) {
+              received.internalError();
+            } else if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {
               // Just send back pong directly on connection
               socket.write(PONG);
             } else {

File: src/main/java/io/vertx/core/http/impl/CookieImpl.java
Patch:
@@ -53,6 +53,8 @@ static Cookie removeCookie(Map<String, ServerCookie> cookieMap, String name, boo
         // we need to expire it and sent it back to it can be
         // invalidated
         cookie.setMaxAge(0L);
+        // void the value for user-agents that still read the cookie
+        cookie.setValue("");
       } else {
         // this was a temporary cookie so we can safely remove it
         cookieMap.remove(name);

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -6011,13 +6011,13 @@ public void testRemoveCookies() throws Exception {
       Cookie removed = req.response().removeCookie("foo");
       assertNotNull(removed);
       assertEquals("foo", removed.getName());
-      assertEquals("bar", removed.getValue());
+      assertEquals("", removed.getValue());
       req.response().end();
     }, resp -> {
       List<String> cookies = resp.headers().getAll("set-cookie");
       // the expired cookie must be sent back
       assertEquals(1, cookies.size());
-      assertTrue(cookies.get(0).contains("foo=bar"));
+      assertTrue(cookies.get(0).contains("foo="));
       assertTrue(cookies.get(0).contains("Max-Age=0"));
       assertTrue(cookies.get(0).contains("Expires="));
     });

File: src/main/java/io/vertx/core/http/impl/Http2ServerConnection.java
Patch:
@@ -99,6 +99,7 @@ private Http2ServerRequestImpl createRequest(int streamId, Http2Headers headers,
     Http2Stream stream = handler.connection().stream(streamId);
     String contentEncoding = options.isCompressionSupported() ? HttpUtils.determineContentEncoding(headers) : null;
     Http2ServerRequestImpl request = new Http2ServerRequestImpl(this, context.duplicate(), serverOrigin, headers, contentEncoding, streamEnded);
+    request.isConnect = request.method() == HttpMethod.CONNECT;
     request.init(stream);
     return request;
   }

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -49,7 +49,7 @@ void writeHead(HttpRequestHead request,
                  ByteBuf buf,
                  boolean end,
                  StreamPriority priority,
-                 Promise<NetSocket> netSocketPromise,
+                 boolean connect,
                  Handler<AsyncResult<Void>> handler);
   void writeBuffer(ByteBuf buf, boolean end, Handler<AsyncResult<Void>> listener);
   void writeFrame(int type, int flags, ByteBuf payload);

File: src/test/java/io/vertx/core/http/Http2ServerTest.java
Patch:
@@ -2318,7 +2318,7 @@ public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int
           return data.readableBytes() + padding;
         }
       });
-      request.encoder.writeHeaders(request.context, id, GET("/"), 0, false, request.context.newPromise());
+      request.encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method("CONNECT").authority("example.com:80"), 0, false, request.context.newPromise());
       request.context.flush();
     });
     fut.sync();
@@ -2466,7 +2466,7 @@ public void testNetSocketHandleReset() throws Exception {
           assertEquals(0, status.getAndIncrement());
         });
         socket.endHandler(v -> {
-          fail();
+          // fail();
         });
         socket.closeHandler(v  -> {
           assertEquals(1, status.getAndIncrement());

File: src/main/java/io/vertx/core/http/impl/WebSocketImpl.java
Patch:
@@ -58,7 +58,7 @@ void handleClosed() {
   protected void doClose() {
     if (closingTimeoutMS > 0L) {
       synchronized (conn) {
-        timerID = context.owner().setTimer(1000, id -> {
+        timerID = context.owner().setTimer(closingTimeoutMS, id -> {
           synchronized (conn) {
             timerID = -1L;
           }

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -1474,15 +1474,15 @@ public void testClose(boolean closeClient, boolean closeServer, boolean regularC
     };
     server = vertx.createHttpServer(new HttpServerOptions().setPort(DEFAULT_HTTP_PORT)).webSocketHandler(ws -> {
       test.accept(ws);
-      if (closeClient) {
+      if (closeServer) {
         ws.close();
       }
     });
     server.listen(onSuccess(s -> {
       client.webSocket(DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, "/some/path",
         onSuccess(ws -> {
           test.accept(ws);
-          if (closeServer) {
+          if (closeClient) {
             ws.close();
           }
         }));

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequestHandler.java
Patch:
@@ -48,6 +48,8 @@ public void handle(HttpServerRequest req) {
             ServerWebSocketImpl ws = (ServerWebSocketImpl) ar.result();
             wsHandler.handle(ws);
             ws.tryHandshake(101);
+          } else {
+            // ????
           }
         });
       } else {

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -1947,6 +1947,8 @@ public void testInvalidUnmaskedFrameRequest(){
     server.webSocketHandler(ws -> {
 
       ws.exceptionHandler(exception -> {
+        // Will receive decode error and close error
+        ws.exceptionHandler(null);
         testComplete();
       });
 

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -769,7 +769,9 @@ public JsonObject copy() {
   /**
    * Get the underlying {@code Map} as is.
    *
-   * This map may contain values that are not the types returned by the {@code JsonObject}.
+   * This map may contain values that are not the types returned by the {@code JsonObject} and
+   * with an unpredictable representation of the value, e.g you might get a JSON object
+   * as a {@link JsonObject} or as a {@link Map}.
    *
    * @return the underlying Map.
    */

File: src/main/java/io/vertx/core/json/jackson/JacksonCodec.java
Patch:
@@ -32,6 +32,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.Reader;
 import java.io.StringWriter;
 import java.io.Writer;
 import java.lang.reflect.ParameterizedType;
@@ -284,8 +285,8 @@ private static void encodeJson(Object json, JsonGenerator generator) throws Enco
           encodeJson(item, generator);
         }
         generator.writeEndArray();
-      } else if (json instanceof CharSequence) {
-        generator.writeString(((CharSequence) json).toString());
+      } else if (json instanceof String) {
+        generator.writeString((String) json);
       } else if (json instanceof Number) {
         if (json instanceof Short) {
           generator.writeNumber((Short) json);

File: src/test/java/io/vertx/core/dns/DNSTest.java
Patch:
@@ -315,7 +315,7 @@ public void testTimeout() throws Exception {
 
     dns.lookup("vertx.io", onFailure(result -> {
       assertEquals(VertxException.class, result.getClass());
-      assertEquals("DNS query timeout for vertx.io", result.getMessage());
+      assertEquals("DNS query timeout for vertx.io.", result.getMessage());
       ((DnsClientImpl) dns).inProgressQueries(num -> {
         assertEquals(0, (int)num);
         testComplete();

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestBase.java
Patch:
@@ -213,6 +213,8 @@ private synchronized long cancelTimeout() {
 
   private void handleTimeout(long timeoutMs) {
     synchronized (this) {
+      currentTimeoutTimerId = -1;
+      currentTimeoutMs = 0;
       if (lastDataReceived > 0) {
         long now = System.currentTimeMillis();
         long timeSinceLastData = now - lastDataReceived;

File: src/test/java/io/vertx/core/eventbus/LocalEventBusTest.java
Patch:
@@ -133,7 +133,7 @@ public void testMessageConsumerCloseHookIsClosedCorrectly() {
     vertx.deployVerticle(new AbstractVerticle() {
       MessageConsumer consumer;
       @Override
-      public void start() throws Exception {
+      public void start() {
         context.exceptionHandler(err -> {
           fail("Unexpected exception");
         });

File: src/test/java/io/vertx/core/file/FileResolverTestBase.java
Patch:
@@ -15,6 +15,7 @@
 import io.vertx.core.VertxOptions;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpClientOptions;
+import io.vertx.core.http.HttpClientRequest;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpServerOptions;
 import io.vertx.core.file.impl.FileResolver;
@@ -235,7 +236,8 @@ public void testSendFileFromClasspath() {
       res.response().sendFile(webRoot + "/somefile.html");
     }).listen(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions())
-        .send(HttpMethod.GET, 8080, "localhost", "/")
+        .request(HttpMethod.GET, 8080, "localhost", "/")
+        .compose(HttpClientRequest::send)
         .onComplete(onSuccess(resp -> {
           resp.bodyHandler(buff -> {
             assertTrue(buff.toString().startsWith("<html><body>blah</body></html>"));

File: src/test/java/io/vertx/core/http/Http2Test.java
Patch:
@@ -350,7 +350,6 @@ public void testResetClientRequestNotYetSent() throws Exception {
       req.onComplete(onFailure(err -> {
         complete();
       }));
-      req.setChunked(true).write(TestUtils.randomBuffer(1024));
       assertTrue(req.reset());
     }));
     await();

File: src/main/java/io/vertx/core/logging/Logger.java
Patch:
@@ -21,10 +21,10 @@
  * used by JUL will taken from the default logging.properties in the JDK installation if no {@code  java.util.logging.config.file} system
  * property is set.
  * <p>
- * If you would prefer to use Log4J or SLF4J instead of JUL then you can set a system property called
+ * If you would prefer to use Log4J 2 or SLF4J instead of JUL then you can set a system property called
  * {@code vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
- * For Log4J the value is {@code io.vertx.core.logging.Log4jLogDelegateFactory}, for SLF4J the value
- * is {@code io.vertx.core.logging.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
+ * For Log4J 2 the value is {@link io.vertx.core.logging.Log4j2LogDelegateFactory}, for SLF4J the value
+ * is {@link io.vertx.core.logging.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
  * required by your favourite log framework are on your classpath.
  * <p>
  * Keep in mind that logging backends use different formats to represent replaceable tokens in parameterized messages.

File: src/main/java/io/vertx/core/logging/LoggerFactory.java
Patch:
@@ -47,7 +47,6 @@ public static synchronized void initialise() {
     }
     if (loader.getResource("vertx-default-jul-logging.properties") == null) {
       if (configureWith("SLF4J", true, loader)
-        || configureWith("Log4j", true, loader)
         || configureWith("Log4j2", true, loader)) {
         return;
       }

File: src/test/java/io/vertx/core/VertxOptionsTest.java
Patch:
@@ -91,7 +91,7 @@ public void testOptions() {
     } catch (IllegalArgumentException e) {
       // OK
     }
-    assertEquals("localhost", options.getEventBusOptions().getHost());
+    assertNull(options.getEventBusOptions().getHost());
     String randString = TestUtils.randomUnicodeString(100);
     options.getEventBusOptions().setHost(randString);
     assertEquals(randString, options.getEventBusOptions().getHost());
@@ -318,7 +318,7 @@ public void testJsonOptions() {
     assertEquals(20, options.getInternalBlockingPoolSize());
     assertEquals(20, options.getWorkerPoolSize());
     assertEquals(1000, options.getBlockedThreadCheckInterval());
-    assertEquals("localhost", options.getEventBusOptions().getHost());
+    assertNull(options.getEventBusOptions().getHost());
     assertNull(options.getEventBusOptions().getClusterPublicHost());
     assertEquals(null, options.getClusterManager());
     assertEquals(2000l * 1000000, options.getMaxEventLoopExecuteTime());

File: src/test/java/io/vertx/core/impl/launcher/commands/BareCommandTest.java
Patch:
@@ -60,7 +60,6 @@ public void testRegularBareCommand() throws InterruptedException, IOException {
 
     assertThat(error.toString())
         .contains("Starting clustering...")
-        .contains("No cluster-host specified")
         .contains("Any deploymentIDs waiting on a quorum will now be deployed");
   }
 
@@ -75,7 +74,6 @@ public void testOldBare() throws InterruptedException, IOException {
 
     assertThat(error.toString())
         .contains("Starting clustering...")
-        .contains("No cluster-host specified")
         .contains("Any deploymentIDs waiting on a quorum will now be deployed");
   }
 

File: src/main/java/io/vertx/core/json/impl/JsonUtil.java
Patch:
@@ -15,7 +15,6 @@
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.shareddata.Shareable;
 
-import java.math.BigDecimal;
 import java.time.Instant;
 import java.util.Base64;
 import java.util.List;

File: src/main/java/io/vertx/core/http/impl/headers/HeadersMultiMap.java
Patch:
@@ -537,8 +537,9 @@ private void remove0(int h, int i, CharSequence name) {
           prev.next = next;
         }
         e.remove();
+      } else {
+        prev = e;
       }
-      prev = e;
       e = next;
     }
   }

File: src/test/java/io/vertx/core/http/headers/VertxHttpHeadersTest.java
Patch:
@@ -214,7 +214,8 @@ public void testRemovalNext() {
     MultiMap mmap = newMultiMap();
     String name1 = this.sameHash1;
     String name2 = this.sameHash2;
-    mmap.set(name1, "v");
+    mmap.add(name1, "v");
+    mmap.add(name1, "v");
     mmap.add(name2, "q");
     mmap.remove(name1);
     mmap.set(name1, "w");

File: src/test/java/io/vertx/core/impl/launcher/commands/BareCommandTest.java
Patch:
@@ -60,7 +60,6 @@ public void testRegularBareCommand() throws InterruptedException, IOException {
 
     assertThat(error.toString())
         .contains("Starting clustering...")
-        .contains("No cluster-host specified")
         .contains("Any deploymentIDs waiting on a quorum will now be deployed");
   }
 
@@ -75,7 +74,6 @@ public void testOldBare() throws InterruptedException, IOException {
 
     assertThat(error.toString())
         .contains("Starting clustering...")
-        .contains("No cluster-host specified")
         .contains("Any deploymentIDs waiting on a quorum will now be deployed");
   }
 

File: src/test/java/io/vertx/core/VertxOptionsTest.java
Patch:
@@ -91,7 +91,7 @@ public void testOptions() {
     } catch (IllegalArgumentException e) {
       // OK
     }
-    assertEquals("localhost", options.getEventBusOptions().getHost());
+    assertNull(options.getEventBusOptions().getHost());
     String randString = TestUtils.randomUnicodeString(100);
     options.getEventBusOptions().setHost(randString);
     assertEquals(randString, options.getEventBusOptions().getHost());
@@ -318,7 +318,7 @@ public void testJsonOptions() {
     assertEquals(20, options.getInternalBlockingPoolSize());
     assertEquals(20, options.getWorkerPoolSize());
     assertEquals(1000, options.getBlockedThreadCheckInterval());
-    assertEquals("localhost", options.getEventBusOptions().getHost());
+    assertNull(options.getEventBusOptions().getHost());
     assertNull(options.getEventBusOptions().getClusterPublicHost());
     assertEquals(null, options.getClusterManager());
     assertEquals(2000l * 1000000, options.getMaxEventLoopExecuteTime());

File: src/main/java/io/vertx/core/net/impl/clientconnection/Endpoint.java
Patch:
@@ -48,10 +48,12 @@ public boolean getConnection(ContextInternal ctx, Handler<AsyncResult<C>> handle
         pendingRequestCount--;
         dispose = checkDispose();
       }
-      handler.handle(ar);
+      // Dispose before callback otherwise we can have the callback handler retrying the same
+      // endpoint and never get the callback it expects to creating an infinite loop
       if (dispose) {
         disposeInternal();
       }
+      handler.handle(ar);
     });
     return true;
   }

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -1092,7 +1092,7 @@ public WorkerExecutorImpl createSharedWorkerExecutor(String name, int poolSize)
 
   @Override
   public synchronized WorkerExecutorImpl createSharedWorkerExecutor(String name, int poolSize, long maxExecuteTime) {
-    return createSharedWorkerExecutor(name, poolSize, maxExecuteTime, TimeUnit.NANOSECONDS);
+    return createSharedWorkerExecutor(name, poolSize, maxExecuteTime, maxWorkerExecTimeUnit);
   }
 
   @Override

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -110,7 +110,7 @@ static Future<Vertx> clusteredVertx(VertxOptions options) {
   /**
    * Gets the current context
    *
-   * @return The current context or null if no current context
+   * @return The current context or {@code null} if there is no current context
    */
   static @Nullable Context currentContext() {
     return ContextInternal.current();

File: src/test/java/io/vertx/core/ContextTaskTest.java
Patch:
@@ -57,7 +57,7 @@ protected void tearDown() throws Exception {
   }
 
   private ContextInternal createEventLoopContext() {
-    return ((VertxInternal) vertx).getOrCreateContext();
+    return ((VertxInternal) vertx).createEventLoopContext();
   }
 
   private ContextInternal createWorkerContext() {

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -964,7 +964,8 @@ public void testThreadPoolMetricsWithInternalExecuteBlocking() {
           hadWaitingQueue.set(true);
         }
         fut.complete();
-      }, ar -> {
+      }, false
+        ,ar -> {
         if (metrics.numberOfIdleThreads() > 0) {
           hadIdle.set(true);
         }

File: src/test/java/io/vertx/test/fakecluster/FakeClusterManager.java
Patch:
@@ -220,7 +220,7 @@ private synchronized void fireRegistrationUpdateEvents(List<RegistrationUpdateEv
       }
       for (RegistrationUpdateEvent event : events) {
         FakeClusterManager clusterManager = nodes.get(nid);
-        if (clusterManager.isActive()) {
+        if (clusterManager != null && clusterManager.isActive()) {
           clusterManager.deliveryStrategy.registrationsUpdated(event);
         }
       }

File: src/test/java/io/vertx/core/http/HttpTLSTest.java
Patch:
@@ -1126,6 +1126,8 @@ TLSTest run(boolean shouldPass) {
       }
       if (clientOpenSSL) {
         options.setOpenSslEngineOptions(new OpenSSLEngineOptions());
+      } else {
+        options.setJdkSslEngineOptions(new JdkSSLEngineOptions());
       }
       if (clientUsesAlpn) {
         options.setUseAlpn(true);

File: src/test/java/io/vertx/test/faketracer/FakeTracer.java
Patch:
@@ -76,9 +76,6 @@ public Span decode(String operation, Iterable<Map.Entry<String, String>> headers
     String traceId = null;
     String spanId = null;
     String spanParentId = null;
-    if (headers == null) {
-      System.out.println("NULL");
-    }
     for (Map.Entry<String, String> header : headers) {
       switch (header.getKey()) {
         case "span-trace-id":

File: src/test/java/io/vertx/it/JsonCodecTest.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.it;
 
+import io.vertx.core.json.DecodeException;
 import io.vertx.core.json.JsonObject;
 import io.vertx.test.core.VertxTestBase;
 import org.junit.Test;
@@ -28,7 +29,7 @@ public void testJsonObject() {
     try {
       obj.mapTo(Object.class);
       fail();
-    } catch (UnsupportedOperationException ignore) {
+    } catch (DecodeException ignore) {
       // Expected
     }
   }

File: src/main/java/io/vertx/core/spi/cluster/impl/DefaultDeliveryStrategy.java
Patch:
@@ -85,7 +85,7 @@ private Queue<Promise<NodeSelector>> getWaiters(ContextInternal context, String
 
   @SuppressWarnings("unchecked")
   private void removeWaiters(ContextInternal context, String address) {
-    context.contextData().compute(context, (k, v) -> {
+    context.contextData().compute(this, (k, v) -> {
       Map<String, Queue<Promise<NodeSelector>>> map = (Map<String, Queue<Promise<NodeSelector>>>) v;
       if (map == null) {
         throw new IllegalStateException();

File: src/test/java/io/vertx/test/fakecluster/FakeClusterManager.java
Patch:
@@ -187,10 +187,10 @@ public void leave(Handler<AsyncResult<Void>> resultHandler) {
         registrationInfos.removeIf(registrationInfo -> registrationInfo.getNodeId().equals(nodeID));
       }
     });
-    nodeInfos.remove(nodeID);
     vertx.executeBlocking(fut -> {
       synchronized (this) {
         if (nodeID != null) {
+          nodeInfos.remove(nodeID);
           if (nodeListener != null) {
             nodeListener = null;
           }

File: src/test/java/io/vertx/test/fakecluster/FakeClusterManager.java
Patch:
@@ -206,7 +206,8 @@ public void register(RegistrationInfo registrationInfo, Handler<AsyncResult<Void
   @Override
   public void unregister(RegistrationInfo registrationInfo, Handler<AsyncResult<Void>> completionHandler) {
     Future<Void> result;
-    if (registrations.get(registrationInfo.getAddress()).remove(registrationInfo)) {
+    List<RegistrationInfo> infos = registrations.get(registrationInfo.getAddress());
+    if (infos != null && infos.remove(registrationInfo)) {
       result = Future.succeededFuture();
     } else {
       result = Future.failedFuture("Registration not found");

File: src/main/java/io/vertx/core/eventbus/impl/MessageConsumerImpl.java
Patch:
@@ -129,7 +129,7 @@ public synchronized Future<Void> unregister() {
 
     Promise<Void> res = result; // Alias reference because result can become null when the onComplete callback executes
     if (res != null) {
-      fut.onComplete(ar -> res.tryFail("blah"));
+      fut.onComplete(ar -> res.tryFail("Consumer unregistered before registration completed"));
       result = null;
     }
     return fut;

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -102,6 +102,7 @@ static void setTrustOptions(TCPSSLOptions sslOptions, TrustOptions options) {
 
   @Override
   public void start(Handler<AsyncResult<Void>> resultHandler) {
+    deliveryStrategy.setVertx(vertx);
     server = vertx.createNetServer(getServerOptions());
     server.connectHandler(getServerHandler());
     server.listen(ar -> {

File: src/test/java/io/vertx/core/LauncherTest.java
Patch:
@@ -624,8 +624,8 @@ public void testBareAlias() throws Exception {
   @Test
   public void testConfigureClusterHostPortFromProperties() throws Exception {
     int clusterPort = TestUtils.randomHighPortInt();
-    System.setProperty(RunCommand.VERTX_OPTIONS_PROP_PREFIX + "clusterHost", "127.0.0.1");
-    System.setProperty(RunCommand.VERTX_OPTIONS_PROP_PREFIX + "clusterPort", Integer.toString(clusterPort));
+    System.setProperty(RunCommand.VERTX_EVENTBUS_PROP_PREFIX + "host", "127.0.0.1");
+    System.setProperty(RunCommand.VERTX_EVENTBUS_PROP_PREFIX + "port", Integer.toString(clusterPort));
     MyLauncher launcher = new MyLauncher();
     String[] args = {"run", "java:" + TestVerticle.class.getCanonicalName(), "-cluster"};
     launcher.dispatch(args);

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -50,18 +50,19 @@ public class ClusteredEventBus extends EventBusImpl {
 
   private final EventBusOptions options;
   private final ClusterManager clusterManager;
-  private final DeliveryStrategy deliveryStrategy = null;
+  private final DeliveryStrategy deliveryStrategy;
   private final AtomicLong handlerSequence = new AtomicLong(0);
 
   private final ConcurrentMap<NodeInfo, ConnectionHolder> connections = new ConcurrentHashMap<>();
 
   private NodeInfo nodeInfo;
   private NetServer server;
 
-  public ClusteredEventBus(VertxInternal vertx, VertxOptions options, ClusterManager clusterManager) {
+  public ClusteredEventBus(VertxInternal vertx, VertxOptions options, ClusterManager clusterManager, DeliveryStrategy deliveryStrategy) {
     super(vertx);
     this.options = options.getEventBusOptions();
     this.clusterManager = clusterManager;
+    this.deliveryStrategy = deliveryStrategy;
   }
 
   private NetServerOptions getServerOptions() {

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -55,6 +55,7 @@
 import io.vertx.core.shareddata.impl.SharedDataImpl;
 import io.vertx.core.spi.VerticleFactory;
 import io.vertx.core.spi.cluster.ClusterManager;
+import io.vertx.core.spi.cluster.DeliveryStrategy;
 import io.vertx.core.spi.metrics.Metrics;
 import io.vertx.core.spi.metrics.MetricsProvider;
 import io.vertx.core.spi.metrics.PoolMetrics;
@@ -122,7 +123,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
   private final Transport transport;
   final VertxTracer tracer;
 
-  VertxImpl(VertxOptions options, ClusterManager clusterManager, VertxMetrics metrics, VertxTracer<?, ?> tracer, Transport transport, FileResolver fileResolver) {
+  VertxImpl(VertxOptions options, ClusterManager clusterManager, DeliveryStrategy deliveryStrategy, VertxMetrics metrics, VertxTracer<?, ?> tracer, Transport transport, FileResolver fileResolver) {
     // Sanity check
     if (Vertx.currentContext() != null) {
       log.warn("You're already on a Vert.x context, are you sure you want to create a new Vertx instance?");
@@ -160,7 +161,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
     this.addressResolver = new AddressResolver(this, options.getAddressResolverOptions());
     this.tracer = tracer;
     this.clusterManager = clusterManager;
-    this.eventBus = clusterManager != null ? new ClusteredEventBus(this, options, clusterManager) : new EventBusImpl(this);
+    this.eventBus = clusterManager != null ? new ClusteredEventBus(this, options, clusterManager, deliveryStrategy) : new EventBusImpl(this);
     this.sharedData = new SharedDataImpl(this, clusterManager);
     this.deploymentManager = new DeploymentManager(this);
     this.verticleManager = new VerticleManager(this, deploymentManager);

File: src/main/java/io/vertx/core/VertxOptions.java
Patch:
@@ -207,7 +207,7 @@ public VertxOptions(VertxOptions other) {
     this.fileSystemOptions = other.getFileSystemOptions() != null ? new FileSystemOptions(other.getFileSystemOptions()) : null;
     this.warningExceptionTime = other.warningExceptionTime;
     this.eventBusOptions = new EventBusOptions(other.eventBusOptions);
-    this.addressResolverOptions = other.addressResolverOptions != null ? new AddressResolverOptions() : null;
+    this.addressResolverOptions = other.addressResolverOptions != null ? new AddressResolverOptions(other.getAddressResolverOptions()) : null;
     this.maxEventLoopExecuteTimeUnit = other.maxEventLoopExecuteTimeUnit;
     this.maxWorkerExecuteTimeUnit = other.maxWorkerExecuteTimeUnit;
     this.warningExceptionTimeUnit = other.warningExceptionTimeUnit;

File: src/main/java/io/vertx/core/VertxOptions.java
Patch:
@@ -871,7 +871,6 @@ public String toString() {
         ", metrics=" + metricsOptions +
         ", fileSystemOptions=" + fileSystemOptions +
         ", addressResolver=" + addressResolverOptions.toJson() +
-        ", addressResolver=" + addressResolverOptions.toJson() +
         ", eventbus=" + eventBusOptions.toJson() +
         ", warningExceptionTimeUnit=" + warningExceptionTimeUnit +
         ", warningExceptionTime=" + warningExceptionTime +

File: src/main/java/io/vertx/core/json/jackson/DatabindCodec.java
Patch:
@@ -58,6 +58,8 @@ private static void initialize() {
     module.addDeserializer(Instant.class, new InstantDeserializer());
     module.addSerializer(byte[].class, new ByteArraySerializer());
     module.addDeserializer(byte[].class, new ByteArrayDeserializer());
+    module.addSerializer(Buffer.class, new BufferSerializer());
+    module.addDeserializer(Buffer.class, new BufferDeserializer());
 
     mapper.registerModule(module);
     prettyMapper.registerModule(module);

File: src/main/java/io/vertx/core/json/jackson/JacksonCodec.java
Patch:
@@ -313,6 +313,9 @@ private static void encodeJson(Object json, JsonGenerator generator) throws Enco
       } else if (json instanceof byte[]) {
         // RFC-7493
         generator.writeString(BASE64_ENCODER.encodeToString((byte[]) json));
+      } else if (json instanceof Buffer) {
+        // RFC-7493
+        generator.writeString(BASE64_ENCODER.encodeToString(((Buffer) json).getBytes()));
       } else if (json instanceof Enum) {
         // vert.x extra (non standard but allowed conversion)
         generator.writeString(((Enum<?>) json).name());

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -305,8 +305,8 @@ public byte[] getBinary(String key) {
    *
    * @param key the string to return the value for
    * @return the value or null if no value for that key
-   * @throws java.lang.ClassCastException       if the value is not a String
-   * @throws java.lang.IllegalArgumentException if the value is not a legal Base64 encoded String
+   * @throws java.lang.ClassCastException       if the value is not a string
+   * @throws java.lang.IllegalArgumentException if the value is not a legal Base64 encoded string
    */
   public Buffer getBuffer(String key) {
     Objects.requireNonNull(key);

File: src/main/java/io/vertx/core/http/impl/HttpServerWorker.java
Patch:
@@ -115,6 +115,7 @@ private void configurePipeline(Channel ch) {
         pipeline.addLast(sniHandler);
       } else {
         SslHandler handler = new SslHandler(sslHelper.createEngine(vertx));
+        handler.setHandshakeTimeout(sslHelper.getSslHandshakeTimeout(), sslHelper.getSslHandshakeTimeoutUnit());
         pipeline.addLast("ssl", handler);
       }
       pipeline.addLast("handshaker", new SslHandshakeCompletionHandler(ar -> {

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -109,7 +109,7 @@ public class HttpClientImpl implements HttpClient, MetricsProvider {
 
 
   private final VertxInternal vertx;
-  private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
+  private final ChannelGroup channelGroup;
   private final HttpClientOptions options;
   private final ContextInternal context;
   private final ConnectionManager<EndpointKey, HttpClientConnection> webSocketCM;
@@ -129,6 +129,7 @@ public HttpClientImpl(VertxInternal vertx, HttpClientOptions options) {
     this.vertx = vertx;
     this.metrics = vertx.metricsSPI() != null ? vertx.metricsSPI().createHttpClientMetrics(options) : null;
     this.options = new HttpClientOptions(options);
+    this.channelGroup = new DefaultChannelGroup(vertx.getAcceptorEventLoopGroup().next());
     List<HttpVersion> alpnVersions = options.getAlpnVersions();
     if (alpnVersions == null || alpnVersions.isEmpty()) {
       switch (options.getProtocolVersion()) {

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -62,7 +62,7 @@ public class NetClientImpl implements MetricsProvider, NetClient {
   private final VertxInternal vertx;
   private final NetClientOptions options;
   protected final SSLHelper sslHelper;
-  private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
+  private final ChannelGroup channelGroup;
   private final Closeable closeHook;
   private final ContextInternal creatingContext;
   private final TCPMetrics metrics;
@@ -74,6 +74,7 @@ public NetClientImpl(VertxInternal vertx, NetClientOptions options) {
 
   public NetClientImpl(VertxInternal vertx, NetClientOptions options, boolean useCreatingContext) {
     this.vertx = vertx;
+    this.channelGroup = new DefaultChannelGroup(vertx.getAcceptorEventLoopGroup().next());
     this.options = new NetClientOptions(options);
     this.sslHelper = new SSLHelper(options, options.getKeyCertOptions(), options.getTrustOptions());
     this.closeHook = completionHandler -> {

File: src/main/java/io/vertx/core/net/impl/TCPServerBase.java
Patch:
@@ -103,7 +103,7 @@ public synchronized io.netty.util.concurrent.Future<Channel> listen(SocketAddres
       if (shared == null || actualPort == 0) { // Wildcard port will imply a new actual server each time
         servers = new HashSet<>();
         servers.add(this);
-        channelBalancer = new ServerChannelLoadBalancer();
+        channelBalancer = new ServerChannelLoadBalancer(vertx.getAcceptorEventLoopGroup().next());
         channelBalancer.addWorker(eventLoop, worker);
 
         ServerBootstrap bootstrap = new ServerBootstrap();

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -2823,9 +2823,6 @@ private void testConnectionClose(
       Handler<HttpClientRequest> clientRequest,
       Handler<NetSocket> connectHandler
   ) throws Exception {
-    // Cannot reliably pass due to https://github.com/netty/netty/issues/9113
-    Assume.assumeTrue(testAddress.isInetSocket());
-
     client.close();
     server.close();
 

File: src/main/java/io/vertx/core/dns/AddressResolverOptions.java
Patch:
@@ -35,9 +35,9 @@ public class AddressResolverOptions {
   public static final List<String> DEFAULT_SERVERS = null;
 
   /**
-   * The default value for {@link #setOptResourceEnabled} = true
+   * The default value for {@link #setOptResourceEnabled} = false
    */
-  public static final boolean DEFAULT_OPT_RESOURCE_ENABLED = true;
+  public static final boolean DEFAULT_OPT_RESOURCE_ENABLED = false;
 
   /**
    * The default value for the negative cache min TTL = 0

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -74,7 +74,6 @@ protected void tearDown() throws Exception {
   protected VertxOptions getOptions() {
     VertxOptions options = super.getOptions();
     options.getAddressResolverOptions().addServer(dnsServerAddress.getAddress().getHostAddress() + ":" + dnsServerAddress.getPort());
-    options.getAddressResolverOptions().setOptResourceEnabled(false);
     return options;
   }
 

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -25,7 +25,7 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.*;
 import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
-import io.vertx.core.http.impl.pool.ConnectionListener;
+import io.vertx.core.net.impl.clientconnection.ConnectionListener;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.net.NetSocket;
 import io.vertx.core.net.impl.ConnectionBase;

File: src/main/java/io/vertx/core/http/impl/Http2UpgradedClientConnection.java
Patch:
@@ -25,7 +25,7 @@
 import io.vertx.core.http.*;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
-import io.vertx.core.http.impl.pool.ConnectionListener;
+import io.vertx.core.net.impl.clientconnection.ConnectionListener;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -24,7 +24,7 @@
 import io.vertx.core.http.StreamPriority;
 import io.vertx.core.http.impl.headers.VertxHttpHeaders;
 import io.vertx.core.impl.Arguments;
-import io.vertx.core.impl.ContextInternal;
+import io.vertx.core.impl.PromiseInternal;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;
 import io.vertx.core.net.NetSocket;
@@ -72,9 +72,9 @@ public class HttpClientRequestImpl extends HttpClientRequestBase implements Http
   private boolean connecting;
   private Promise<NetSocket> netSocketPromise;
 
-  HttpClientRequestImpl(HttpClientImpl client, ContextInternal context, boolean ssl, HttpMethod method,
+  HttpClientRequestImpl(HttpClientImpl client, PromiseInternal<HttpClientResponse> responsePromise, boolean ssl, HttpMethod method,
                         SocketAddress server, String host, int port, String requestURI) {
-    super(client, context, ssl, method, server, host, port, requestURI);
+    super(client, responsePromise, ssl, method, server, host, port, requestURI);
     this.chunked = false;
     this.endPromise = context.promise();
     this.endFuture = endPromise.future();

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -39,7 +39,7 @@ public HttpClientRequestPushPromise(
     String host,
     int port,
     MultiMap headers) {
-    super(client, conn.getContext(), ssl, method, SocketAddress.inetSocketAddress(port, host), host, port, uri);
+    super(client, conn.getContext().promise(), ssl, method, SocketAddress.inetSocketAddress(port, host), host, port, uri);
     this.conn = conn;
     this.stream = new Http2ClientConnection.StreamImpl(conn, conn.getContext(), this, null);
     this.headers = headers;

File: src/main/java/io/vertx/core/impl/ContextInternal.java
Patch:
@@ -64,7 +64,8 @@ static ContextInternal current() {
   <T> PromiseInternal<T> promise();
 
   /**
-   * @return a {@link Promise} associated with this context
+   * @return a {@link Promise} associated with this context or the {@code handler}
+   *         if that handler is already an instance of {@code PromiseInternal}
    */
   <T> PromiseInternal<T> promise(Handler<AsyncResult<T>> handler);
 

File: src/main/java/io/vertx/core/net/impl/clientconnection/ConnectionListener.java
Patch:
@@ -9,10 +9,10 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http.impl.pool;
+package io.vertx.core.net.impl.clientconnection;
 
 /**
- * The listener definest the contract used by the {@link ConnectionProvider} to interact with the
+ * The listener defines the contract used by the {@link ConnectionProvider} to interact with the
  * connection pool. Its purpose is also to use a connection implementation without a pool.
  */
 public interface ConnectionListener<C> {

File: src/main/java/io/vertx/core/net/impl/clientconnection/ConnectionProvider.java
Patch:
@@ -9,7 +9,7 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http.impl.pool;
+package io.vertx.core.net.impl.clientconnection;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;

File: src/test/java/io/vertx/core/spi/tracing/HttpTracerTestBase.java
Patch:
@@ -178,7 +178,7 @@ public void receiveResponse(Context context, Object response, Object payload, Th
         resp.endHandler(v2 -> {
           // Updates are done on the HTTP client context, so we need to run task on this context
           // to avoid data race
-          ((HttpClientImpl)client).context().runOnContext(v -> {
+          ctx.runOnContext(v -> {
             assertNull(tracerMap.get(key));
             testComplete();
           });

File: src/main/java/io/vertx/core/http/HttpHeaders.java
Patch:
@@ -17,6 +17,7 @@
 import io.vertx.codegen.annotations.GenIgnore;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.MultiMap;
+import io.vertx.core.http.impl.headers.CaseInsensitiveHeaders;
 
 /**
  * Contains a bunch of useful HTTP headers stuff:

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -30,6 +30,7 @@
 import io.vertx.core.http.*;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
+import io.vertx.core.http.impl.headers.HeadersAdaptor;
 import io.vertx.core.http.impl.pool.ConnectionListener;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.logging.Logger;

File: src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java
Patch:
@@ -26,6 +26,7 @@
 import io.vertx.core.http.*;
 import io.vertx.core.http.Cookie;
 import io.vertx.core.http.HttpVersion;
+import io.vertx.core.http.impl.headers.HeadersAdaptor;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.impl.logging.Logger;

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -24,6 +24,7 @@
 import io.vertx.core.*;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.*;
+import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
 import io.vertx.core.http.impl.pool.ConnectionListener;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.net.NetSocket;
@@ -466,7 +467,7 @@ public void writeHead(HttpMethod method, String uri, MultiMap headers, String au
       }
       if (headers != null && headers.size() > 0) {
         for (Map.Entry<String, String> header : headers) {
-          h.add(Http2HeadersAdaptor.toLowerCase(header.getKey()), header.getValue());
+          h.add(HttpUtils.toLowerCase(header.getKey()), header.getValue());
         }
       }
       if (conn.client.getOptions().isTryUseCompression() && h.get(HttpHeaderNames.ACCEPT_ENCODING) == null) {

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequestImpl.java
Patch:
@@ -37,6 +37,7 @@
 import io.vertx.core.http.StreamPriority;
 import io.vertx.core.http.StreamResetException;
 import io.vertx.core.http.HttpFrame;
+import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponseImpl.java
Patch:
@@ -34,6 +34,7 @@
 import io.vertx.core.http.HttpServerResponse;
 import io.vertx.core.http.StreamPriority;
 import io.vertx.core.http.StreamResetException;
+import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
 import io.vertx.core.net.NetSocket;
 import io.vertx.core.net.impl.ConnectionBase;
 

File: src/main/java/io/vertx/core/http/impl/HttpClientResponseImpl.java
Patch:
@@ -18,6 +18,7 @@
 import io.vertx.core.Promise;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.*;
+import io.vertx.core.http.impl.headers.HeadersAdaptor;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;
 

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -27,6 +27,7 @@
 import io.vertx.core.file.OpenOptions;
 import io.vertx.core.http.HttpFrame;
 import io.vertx.core.http.StreamPriority;
+import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.streams.impl.InboundBuffer;

File: src/main/java/io/vertx/core/http/impl/WebSocketHandshakeInboundHandler.java
Patch:
@@ -26,6 +26,7 @@
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.http.UpgradeRejectedException;
+import io.vertx.core.http.impl.headers.HeadersAdaptor;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>

File: src/main/java/io/vertx/core/http/impl/headers/CaseInsensitiveHeaders.java
Patch:
@@ -8,7 +8,7 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
-package io.vertx.core.http;
+package io.vertx.core.http.impl.headers;
 
 import io.vertx.core.MultiMap;
 

File: src/main/java/io/vertx/core/http/impl/headers/HeadersAdaptor.java
Patch:
@@ -9,7 +9,7 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http.impl;
+package io.vertx.core.http.impl.headers;
 
 import io.netty.handler.codec.http.HttpHeaders;
 import io.vertx.core.MultiMap;

File: src/test/java/io/vertx/core/http/headers/CaseInsensitiveHeadersTest.java
Patch:
@@ -9,9 +9,10 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http;
+package io.vertx.core.http.headers;
 
 import io.vertx.core.MultiMap;
+import io.vertx.core.http.impl.headers.CaseInsensitiveHeaders;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;

File: src/test/java/io/vertx/core/http/headers/HeadersTestBase.java
Patch:
@@ -9,7 +9,7 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http;
+package io.vertx.core.http.headers;
 
 import io.vertx.core.MultiMap;
 import io.vertx.core.http.HttpHeaders;

File: src/test/java/io/vertx/core/http/headers/Http2HeadersAdaptorsTest.java
Patch:
@@ -9,11 +9,11 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http;
+package io.vertx.core.http.headers;
 
 import io.netty.handler.codec.http2.DefaultHttp2Headers;
 import io.vertx.core.MultiMap;
-import io.vertx.core.http.impl.Http2HeadersAdaptor;
+import io.vertx.core.http.impl.headers.Http2HeadersAdaptor;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;

File: src/test/java/io/vertx/core/http/headers/HttpHeadersAdaptorTest.java
Patch:
@@ -9,11 +9,12 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http;
+package io.vertx.core.http.headers;
 
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.vertx.core.MultiMap;
-import io.vertx.core.http.impl.HeadersAdaptor;
+import io.vertx.core.http.headers.HeadersTestBase;
+import io.vertx.core.http.impl.headers.HeadersAdaptor;
 
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>

File: src/test/java/io/vertx/core/http/headers/VertxHttpHeadersTest.java
Patch:
@@ -9,10 +9,11 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.http;
+package io.vertx.core.http.headers;
 
 import io.netty.util.AsciiString;
 import io.vertx.core.MultiMap;
+import io.vertx.core.http.headers.HeadersTestBase;
 import io.vertx.core.http.impl.headers.VertxHttpHeaders;
 import org.junit.Test;
 

File: src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java
Patch:
@@ -325,7 +325,7 @@ private TokenParser(IOContext ctxt, int features) {
     @Override
     public JsonToken nextToken() throws IOException {
       if (tokens.isEmpty()) {
-        return JsonToken.NOT_AVAILABLE;
+        return null;
       }
       text = null;
       _numTypesValid = NR_UNKNOWN;

File: src/main/java/io/vertx/core/datagram/impl/DatagramPacketImpl.java
Patch:
@@ -23,6 +23,7 @@
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 final class DatagramPacketImpl implements DatagramPacket {
+
   private final InetSocketAddress sender;
   private final Buffer buffer;
   private SocketAddress senderAddress;
@@ -35,7 +36,7 @@ final class DatagramPacketImpl implements DatagramPacket {
   @Override
   public SocketAddress sender() {
     if (senderAddress == null) {
-      senderAddress = new SocketAddressImpl(sender.getPort(), sender.getAddress().getHostAddress());
+      senderAddress = SocketAddress.inetSocketAddress(sender);
     }
     return senderAddress;
   }

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -243,13 +243,13 @@ public Future<Void> blockMulticastGroup(String multicastAddress, String sourceTo
   @Override
   public DatagramSocket listen(int port, String address, Handler<AsyncResult<DatagramSocket>> handler) {
     Objects.requireNonNull(handler, "no null handler accepted");
-    listen(new SocketAddressImpl(port, address)).setHandler(handler);
+    listen(SocketAddress.inetSocketAddress(port, address)).setHandler(handler);
     return this;
   }
 
   @Override
   public Future<DatagramSocket> listen(int port, String address) {
-    return listen(new SocketAddressImpl(port, address));
+    return listen(SocketAddress.inetSocketAddress(port, address));
   }
 
   @Override
@@ -350,7 +350,7 @@ public Future<Void> send(Buffer packet, int port, String host) {
         if (metrics != null) {
           f2.addListener(fut -> {
             if (fut.isSuccess()) {
-              metrics.bytesWritten(null, new SocketAddressImpl(port, host), packet.length());
+              metrics.bytesWritten(null, SocketAddress.inetSocketAddress(port, host), packet.length());
             }
           });
         }

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -119,7 +119,7 @@ void getConnection(ContextInternal ctx, SocketAddress peerAddress, boolean ssl,
         int maxPoolSize = Math.max(client.getOptions().getMaxPoolSize(), client.getOptions().getHttp2MaxPoolSize());
         String host;
         int port;
-        if (server.path() == null) {
+        if (server.isInetSocket()) {
           host = server.host();
           port = server.port();
         } else {

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -223,7 +223,7 @@ public Future<HttpServer> listen(SocketAddress address) {
     }
     listenContext = vertx.getOrCreateContext();
     listening = true;
-    String host = address.host() != null ? address.host() : "localhost";
+    String host = address.isInetSocket() ? address.host() : "localhost";
     int port = address.port();
     List<HttpVersion> applicationProtocols = options.getAlpnVersions();
     sslHelper.setApplicationProtocols(applicationProtocols);
@@ -236,7 +236,7 @@ public Future<HttpServer> listen(SocketAddress address) {
         serverChannelGroup = new DefaultChannelGroup("vertx-acceptor-channels", GlobalEventExecutor.INSTANCE);
         ServerBootstrap bootstrap = new ServerBootstrap();
         bootstrap.group(vertx.getAcceptorEventLoopGroup(), availableWorkers);
-        applyConnectionOptions(address.path() != null, bootstrap);
+        applyConnectionOptions(address.isDomainSocket(), bootstrap);
         sslHelper.validate(vertx);
         String serverOrigin = (options.isSsl() ? "https" : "http") + "://" + host + ":" + port;
         bootstrap.childHandler(childHandler(address, serverOrigin));

File: src/main/java/io/vertx/core/net/impl/ChannelProvider.java
Patch:
@@ -78,7 +78,7 @@ public Future<Channel> connect(SocketAddress remoteAddress, SocketAddress peerAd
 
   private void connect(SocketAddress remoteAddress, SocketAddress peerAddress, String serverName, boolean ssl, Promise<Channel> p) {
     try {
-      bootstrap.channelFactory(context.owner().transport().channelFactory(remoteAddress.path() != null));
+      bootstrap.channelFactory(context.owner().transport().channelFactory(remoteAddress.isDomainSocket()));
     } catch (Exception e) {
       p.setFailure(e);
       return;
@@ -133,7 +133,7 @@ protected void initChannel(Channel ch) {
         initSSL(peerAddress, serverName, ssl, ch, channelHandler);
       }
     });
-    ChannelFuture fut = bootstrap.connect(vertx.transport().convert(remoteAddress, false));
+    ChannelFuture fut = bootstrap.connect(vertx.transport().convert(remoteAddress));
     fut.addListener(res -> {
       if (res.isSuccess()) {
         connected(fut.channel(), ssl, channelHandler);
@@ -193,7 +193,7 @@ private void handleProxyConnect(SocketAddress remoteAddress, SocketAddress peerA
         }
 
         bootstrap.resolver(NoopAddressResolverGroup.INSTANCE);
-        java.net.SocketAddress targetAddress = vertx.transport().convert(remoteAddress, false);
+        java.net.SocketAddress targetAddress = vertx.transport().convert(remoteAddress);
 
         bootstrap.handler(new ChannelInitializer<Channel>() {
           @Override

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -198,7 +198,7 @@ private void doConnect(SocketAddress remoteAddress, String serverName, Promise<N
     Bootstrap bootstrap = new Bootstrap();
     bootstrap.group(context.nettyEventLoop());
 
-    applyConnectionOptions(remoteAddress.path() != null, bootstrap);
+    applyConnectionOptions(remoteAddress.isDomainSocket(), bootstrap);
 
     ChannelProvider channelProvider = new ChannelProvider(bootstrap, sslHelper, context, options.getProxyOptions());
 

File: src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -513,7 +513,7 @@ public SSLEngine createEngine(SslContext sslContext) {
   public SSLEngine createEngine(VertxInternal vertx, SocketAddress socketAddress, String serverName) {
     SslContext context = getContext(vertx, null);
     SSLEngine engine;
-    if (socketAddress.path() != null) {
+    if (socketAddress.isDomainSocket()) {
       engine = context.newEngine(ByteBufAllocator.DEFAULT);
     } else {
       engine = context.newEngine(ByteBufAllocator.DEFAULT, socketAddress.host(), socketAddress.port());

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -1006,7 +1006,7 @@ public void testCloseHandlerNotCalledWhenConnectionClosedAfterEnd() throws Excep
 
   @Test
   public void testTimedOutWaiterDoesntConnect() throws Exception {
-    Assume.assumeTrue("Domain socket don't pass this test", testAddress.path() == null);
+    Assume.assumeTrue("Domain socket don't pass this test", testAddress.isInetSocket());
     long responseDelay = 300;
     int requests = 6;
     client.close();
@@ -2823,7 +2823,7 @@ private void testConnectionClose(
       Handler<NetSocket> connectHandler
   ) throws Exception {
     // Cannot reliably pass due to https://github.com/netty/netty/issues/9113
-    Assume.assumeTrue(testAddress.path() == null);
+    Assume.assumeTrue(testAddress.isInetSocket());
 
     client.close();
     server.close();

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -2593,7 +2593,7 @@ public void testHeadButCanSetContentLength() {
   @Test
   public void testRemoteAddress() {
     server.requestHandler(req -> {
-      if (testAddress.host() != null) {
+      if (testAddress.isInetSocket()) {
         assertEquals("127.0.0.1", req.remoteAddress().host());
       } else {
         // Returns null for domain sockets

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -391,8 +391,7 @@ public Future<Void> send(String str, String enc, int port, String host) {
 
   @Override
   public SocketAddress localAddress() {
-    InetSocketAddress addr = channel.localAddress();
-    return new SocketAddressImpl(addr);
+    return context.owner().transport().convert(channel.localAddress());
   }
 
   @Override

File: src/main/java/io/vertx/core/MultiMap.java
Patch:
@@ -16,6 +16,7 @@
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.http.CaseInsensitiveHeaders;
+import io.vertx.core.http.HttpHeaders;
 
 import java.util.List;
 import java.util.Map;
@@ -40,7 +41,7 @@ public interface MultiMap extends Iterable<Map.Entry<String, String>> {
    * @return the multi-map
    */
   static MultiMap caseInsensitiveMultiMap() {
-    return new CaseInsensitiveHeaders();
+    return HttpHeaders.headers();
   }
 
   @GenIgnore(GenIgnore.PERMITTED_TYPE)

File: src/main/java/io/vertx/core/http/WebSocketConnectOptions.java
Patch:
@@ -108,7 +108,7 @@ public WebSocketConnectOptions setHost(String host) {
   }
 
   @Override
-  public WebSocketConnectOptions setPort(int port) {
+  public WebSocketConnectOptions setPort(Integer port) {
     return (WebSocketConnectOptions) super.setPort(port);
   }
 

File: src/main/java/io/vertx/core/http/impl/Http2UpgradedClientConnection.java
Patch:
@@ -105,7 +105,7 @@ public HttpClientConnection connection() {
     public void writeHead(HttpMethod method,
                           String uri,
                           MultiMap headers,
-                          String hostHeader,
+                          String authority,
                           boolean chunked,
                           ByteBuf buf,
                           boolean end,
@@ -170,7 +170,7 @@ public void upgradeTo(ChannelHandlerContext ctx, FullHttpResponse upgradeRespons
       HttpClientUpgradeHandler upgradeHandler = new HttpClientUpgradeHandler(httpCodec, upgradeCodec, 65536);
       pipeline.addAfter("codec", null, new UpgradeRequestHandler());
       pipeline.addAfter("codec", null, upgradeHandler);
-      stream.writeHead(method, uri, headers, hostHeader, chunked, buf, end, priority, listener);
+      stream.writeHead(method, uri, headers, authority, chunked, buf, end, priority, listener);
     }
 
     @Override

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -42,7 +42,7 @@ public interface HttpClientStream {
   HttpConnection connection();
   ContextInternal getContext();
 
-  void writeHead(HttpMethod method, String uri, MultiMap headers, String hostHeader, boolean chunked, ByteBuf buf, boolean end, StreamPriority priority, Handler<AsyncResult<Void>> listener);
+  void writeHead(HttpMethod method, String uri, MultiMap headers, String authority, boolean chunked, ByteBuf buf, boolean end, StreamPriority priority, Handler<AsyncResult<Void>> listener);
   void writeBuffer(ByteBuf buf, boolean end, Handler<AsyncResult<Void>> listener);
   void writeFrame(int type, int flags, ByteBuf payload);
 

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -18,7 +18,6 @@
 import io.vertx.core.VertxException;
 import io.vertx.core.VertxOptions;
 import io.vertx.core.buffer.Buffer;
-import io.vertx.core.dns.AddressResolverOptions;
 import io.vertx.core.http.HttpClient;
 import io.vertx.core.http.HttpServer;
 import io.vertx.core.impl.AddressResolver;
@@ -144,7 +143,7 @@ public void testHttp() throws Exception {
         listenLatch.countDown();
       }));
       awaitLatch(listenLatch);
-      client.getNow(8080, "vertx.io", "/somepath", onSuccess(resp -> {
+      client.get(8080, "vertx.io", "/somepath", onSuccess(resp -> {
         Buffer buffer = Buffer.buffer();
         resp.handler(buffer::appendBuffer);
         resp.endHandler(v -> {

File: src/test/java/io/vertx/core/http/HttpRequestStreamTest.java
Patch:
@@ -79,10 +79,10 @@ public void testReadStreamPauseResume() {
           paused.set(false);
           httpStream.resume();
           client = vertx.createHttpClient(new HttpClientOptions());
-          client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "localhost", path, onSuccess(resp -> {
+          client.get(HttpTestBase.DEFAULT_HTTP_PORT, "localhost", path, onSuccess(resp -> {
             assertEquals(200, resp.statusCode());
             testComplete();
-          })).end();
+          }));
         });
       });
     });

File: src/test/java/io/vertx/core/http/HttpServerChannelInitializerTest.java
Patch:
@@ -10,7 +10,6 @@
  */
 package io.vertx.core.http;
 
-import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.ChannelFuture;
@@ -52,7 +51,7 @@ public void testHttpServer() throws Exception {
     HttpClient client = this.vertx.createHttpClient();
     client.get(HttpTest.DEFAULT_HTTP_PORT, HttpTest.DEFAULT_HTTP_HOST, "/", resp -> {
       testComplete();
-    }).exceptionHandler(this::fail).end();
+    });
     await();
   }
 

File: src/test/java/io/vertx/core/impl/transport/TransportTest.java
Patch:
@@ -123,7 +123,7 @@ public void testHttpServer() {
         });
       }).listen(8080, onSuccess(s -> {
         HttpClient client = vertx.createHttpClient();
-        client.getNow(8080, "localhost", "/", onSuccess(resp -> {
+        client.get(8080, "localhost", "/", onSuccess(resp -> {
           testComplete();
         }));
       }));

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -3194,7 +3194,7 @@ private void testNetServerInternal_(HttpClientOptions clientOptions, boolean exp
     });
     startServer(SocketAddress.inetSocketAddress(1234, "localhost"));
     HttpClient client = vertx.createHttpClient(clientOptions);
-    client.getNow(1234, "localhost", "/somepath", onSuccess(resp -> {
+    client.get(1234, "localhost", "/somepath", onSuccess(resp -> {
       assertEquals(200, resp.statusCode());
       resp.bodyHandler(buff -> {
         assertEquals("Hello World", buff.toString());

File: src/test/java/io/vertx/core/net/ProxyErrorTest.java
Patch:
@@ -14,6 +14,7 @@
 import java.net.InetSocketAddress;
 
 import io.vertx.core.AsyncResult;
+import io.vertx.core.http.RequestOptions;
 import io.vertx.test.proxy.HttpProxy;
 import io.vertx.test.core.VertxTestBase;
 import org.junit.Test;
@@ -130,7 +131,7 @@ private void proxyTest(int error, String username, String url, Handler<AsyncResu
             .setPort(proxy.getPort()));
     HttpClient client = vertx.createHttpClient(options);
 
-    client.getAbs(url, assertResponse).end();
+    client.get(new RequestOptions().setAbsoluteURI(url), assertResponse);
 
     await();
   }

File: src/test/java/io/vertx/it/NettyCompatTest.java
Patch:
@@ -47,7 +47,7 @@ public void testHttp2() {
               .setSsl(true)
               .setSslEngineOptions(new OpenSSLEngineOptions())
               .setTrustStoreOptions(Trust.SERVER_JKS.get()));
-          client.getNow(8443, "localhost", "/somepath", onSuccess(resp -> {
+          client.get(8443, "localhost", "/somepath", onSuccess(resp -> {
             resp.bodyHandler(buff -> {
               assertEquals("OK", buff.toString());
               testComplete();

File: src/test/java/io/vertx/it/SSLEngineTest.java
Patch:
@@ -126,7 +126,7 @@ private void doTest(SSLEngineOptions engine,
           .setUseAlpn(useAlpn)
           .setTrustAll(true)
           .setProtocolVersion(version));
-      client.getNow(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/somepath", onSuccess(resp -> {
+      client.get(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/somepath", onSuccess(resp -> {
         assertEquals(200, resp.statusCode());
         testComplete();
       }));

File: src/main/java/io/vertx/core/http/HttpMethod.java
Patch:
@@ -280,6 +280,6 @@ static HttpMethod valueOf(String value) {
    * @return an un-modifiable list of known HTTP methods
    */
   static List<HttpMethod> values() {
-    return HttpMethodImpl.ALL;
+    return HttpMethods.ALL;
   }
 }

File: src/main/java/io/vertx/core/json/jackson/JacksonCodec.java
Patch:
@@ -289,6 +289,8 @@ private static void encodeJson(Object json, JsonGenerator generator) throws Enco
           generator.writeNumber((Float) json);
         } else if (json instanceof Double) {
           generator.writeNumber((Double) json);
+        } else if (json instanceof Byte) {
+          generator.writeNumber((Byte) json);
         } else if (json instanceof BigInteger) {
           generator.writeNumber((BigInteger) json);
         } else if (json instanceof BigDecimal) {

File: src/test/java/io/vertx/core/json/JsonCodecTest.java
Patch:
@@ -12,7 +12,7 @@
 
 import com.fasterxml.jackson.core.type.TypeReference;
 import io.vertx.core.buffer.Buffer;
-import io.vertx.core.http.HttpMethod;
+import io.vertx.core.http.WebsocketVersion;
 import io.vertx.core.impl.Utils;
 import io.vertx.core.json.jackson.DatabindCodec;
 import io.vertx.core.json.jackson.JacksonCodec;
@@ -401,9 +401,9 @@ public void testDecodeValue() {
   @Test
   public void testEnumValue() {
     // just a random enum
-    Buffer json = mapper.toBuffer(HttpMethod.CONNECT);
+    Buffer json = mapper.toBuffer(WebsocketVersion.V13);
     assertNotNull(json);
-    assertEquals("\"CONNECT\"", json.toString());
+    assertEquals("\"V13\"", json.toString());
   }
 
   @Test

File: src/main/java/io/vertx/core/http/HttpConnection.java
Patch:
@@ -246,7 +246,7 @@ default HttpConnection goAway(long errorCode, int lastStreamId) {
   SocketAddress remoteAddress();
 
   /**
-   * @return the remote address for this connection
+   * @return the local address for this connection
    */
   @CacheReturn
   SocketAddress localAddress();

File: src/main/java/io/vertx/core/file/impl/FileResolver.java
Patch:
@@ -325,7 +325,7 @@ private void setupCacheDir() {
     String cacheDirName = fileCacheDir + "/file-cache-" + UUID.randomUUID().toString();
     cacheDir = new File(cacheDirName);
     if (!cacheDir.mkdirs()) {
-      throw new IllegalStateException("Failed to create cache dir");
+      throw new IllegalStateException("Failed to create cache dir: " + cacheDirName);
     }
     // Add shutdown hook to delete on exit
     synchronized (this) {

File: src/main/java/io/vertx/core/http/impl/MimeMapping.java
Patch:
@@ -576,6 +576,7 @@ public class MimeMapping {
     m.put("zirz", "application/vnd.zul");
     m.put("zaz", "application/vnd.zzazz.deck+xml");
     m.put("vxml", "application/voicexml+xml");
+    m.put("wasm", "application/wasm");
     m.put("wgt", "application/widget");
     m.put("hlp", "application/winhlp");
     m.put("wsdl", "application/wsdl+xml");

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -2128,6 +2128,7 @@ public void testContexts() throws Exception {
     Set<Context> contexts = new ConcurrentHashSet<>();
     Set<Thread> threads = new ConcurrentHashSet<>();
     client.close();
+    client = null;
     Context clientCtx = vertx.getOrCreateContext();
     clientCtx.runOnContext(v -> {
       client = vertx.createHttpClient(createBaseClientOptions().setMaxPoolSize(numConns));

File: src/main/java/io/vertx/core/http/impl/Http1xConnectionBase.java
Patch:
@@ -19,7 +19,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.FileRegion;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpMessage;
+import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.ContinuationWebSocketFrame;
@@ -240,7 +240,7 @@ public Future<Buffer> ping(Buffer data) {
 
   @Override
   protected void reportsBytesWritten(Object msg) {
-    if (msg instanceof HttpMessage) {
+    if (msg instanceof HttpObject) {
       bytesWritten += getBytes(msg);
     } else if (msg instanceof WebSocketFrame) {
       // Only report WebSocket messages since HttpMessage are reported by streams

File: src/test/java/io/vertx/core/http/Http2ServerTest.java
Patch:
@@ -250,7 +250,8 @@ public void testConnectionHandler() throws Exception {
     waitFor(2);
     Context ctx = vertx.getOrCreateContext();
     server.connectionHandler(conn -> {
-      assertOnIOContext(ctx);
+      assertTrue(Context.isOnEventLoopThread());
+      assertSameEventLoop(vertx.getOrCreateContext(), ctx);
       complete();
     });
     server.requestHandler(req -> fail());

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -87,7 +87,7 @@ private DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
   }
 
   private void init() {
-    channel.pipeline().addLast("handler", VertxHandler.create(context, this::createConnection));
+    channel.pipeline().addLast("handler", VertxHandler.create(this::createConnection));
   }
 
   @Override
@@ -483,7 +483,7 @@ protected void handleClosed() {
         metrics.close();
       }
       if (handler != null) {
-        context.emit(handler);
+        context.dispatch(null, handler);
       }
     }
 
@@ -514,7 +514,7 @@ void handlePacket(io.vertx.core.datagram.DatagramPacket packet) {
         }
       }
       if (handler != null) {
-        context.emit(packet, handler);
+        context.dispatch(packet, handler);
       }
     }
   }

File: src/main/java/io/vertx/core/http/impl/Http1xUpgradeToH2CHandler.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http.*;
 import io.netty.handler.codec.http2.*;
-import io.vertx.core.http.HttpServerOptions;
 import io.netty.handler.timeout.IdleState;
 import io.netty.handler.timeout.IdleStateEvent;
 import io.vertx.core.Handler;

File: src/main/java/io/vertx/core/http/impl/HttpServerChannelInitializer.java
Patch:
@@ -240,7 +240,7 @@ private void configureHttp1OrH2C(ChannelPipeline pipeline, HandlerHolder<? exten
   }
 
   void configureHttp1(ChannelPipeline pipeline, HandlerHolder<? extends Handler<HttpServerConnection>> holder) {
-    VertxHandler<Http1xServerConnection> handler = VertxHandler.create(holder.context, chctx -> {
+    VertxHandler<Http1xServerConnection> handler = VertxHandler.create(chctx -> {
       Http1xServerConnection conn = new Http1xServerConnection(holder.context.owner(),
         sslHelper,
         options,
@@ -253,7 +253,7 @@ void configureHttp1(ChannelPipeline pipeline, HandlerHolder<? extends Handler<Ht
     pipeline.addLast("handler", handler);
     Http1xServerConnection conn = handler.getConnection();
     if (metrics != null) {
-      holder.context.dispatchFromIO(v -> conn.metric(metrics.connected(conn.remoteAddress(), conn.remoteName())));
+      conn.metric(metrics.connected(conn.remoteAddress(), conn.remoteName()));
     }
     holder.context.dispatchFromIO(conn, holder.handler);
   }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -226,9 +226,6 @@ public Future<HttpServer> listen(SocketAddress address) {
     String host = address.host() != null ? address.host() : "localhost";
     int port = address.port();
     List<HttpVersion> applicationProtocols = options.getAlpnVersions();
-    if (listenContext.isWorkerContext()) {
-      applicationProtocols =  applicationProtocols.stream().filter(v -> v != HttpVersion.HTTP_2).collect(Collectors.toList());
-    }
     sslHelper.setApplicationProtocols(applicationProtocols);
     Map<ServerID, HttpServerImpl> sharedHttpServers = vertx.sharedHttpServers();
     synchronized (sharedHttpServers) {

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -362,7 +362,6 @@ public Future<Void> writeFrame(WebSocketFrame frame) {
   public S writeFrame(WebSocketFrame frame, Handler<AsyncResult<Void>> handler) {
     synchronized (conn) {
       checkClosed();
-      conn.reportBytesWritten(((WebSocketFrameInternal)frame).length());
       conn.writeToChannel(conn.encodeFrame((WebSocketFrameImpl) frame), handler == null ? null : context.promise(handler));
     }
     return (S) this;
@@ -385,7 +384,6 @@ public boolean isClosed() {
   void handleFrame(WebSocketFrameInternal frame) {
     synchronized (conn) {
       if (frame.type() != FrameType.CLOSE) {
-        conn.reportBytesRead(frame.length());
         if (!pending.write(frame.binaryData())) {
           conn.doPause();
         }

File: src/main/java/io/vertx/core/impl/WorkerContext.java
Patch:
@@ -15,6 +15,8 @@
 import io.vertx.core.spi.metrics.PoolMetrics;
 import io.vertx.core.spi.tracing.VertxTracer;
 
+import java.util.Objects;
+
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
@@ -84,6 +86,7 @@ private <T> void execute(ContextInternal ctx, Runnable task) {
   }
 
   private <T> void execute(ContextInternal ctx, T value, Handler<T> task) {
+    Objects.requireNonNull(task, "Task handler must not be null");
     PoolMetrics metrics = workerPool.metrics();
     Object queueMetric = metrics != null ? metrics.submitted() : null;
     orderedTasks.execute(() -> {

File: src/test/java/io/vertx/core/http/Http2ClientTest.java
Patch:
@@ -45,6 +45,7 @@
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.SSLHelper;
 import io.vertx.test.core.AsyncTestBase;
+import io.vertx.test.core.Repeat;
 import io.vertx.test.core.TestUtils;
 import io.vertx.test.tls.Cert;
 import org.junit.Test;

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -37,6 +37,7 @@
 import io.vertx.core.net.SelfSignedCertificate;
 import io.vertx.core.streams.ReadStream;
 import io.vertx.test.core.CheckingSender;
+import io.vertx.test.core.Repeat;
 import io.vertx.test.core.TestUtils;
 import io.vertx.test.core.VertxTestBase;
 import io.vertx.test.tls.Cert;
@@ -2012,7 +2013,7 @@ private void handshake(HttpClient client, Handler<NetSocket> handler) {
 
   private void testRaceConditionWithWebsocketClient(Context context) {
     server = vertx.createHttpServer(new HttpServerOptions().setPort(DEFAULT_HTTP_PORT));
-    // Handcrafted websocket handshake for sending a frame immediatly after the handshake
+    // Handcrafted websocket handshake for sending a frame immediately after the handshake
     server.requestHandler(req -> {
       NetSocket so = handshake(req);
       if (so != null) {

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -613,7 +613,7 @@ public void testHttpClientMetricsQueueLength() throws Exception {
     CountDownLatch listenLatch = new CountDownLatch(1);
     server.listen(8080, "localhost", onSuccess(s -> { listenLatch.countDown(); }));
     awaitLatch(listenLatch);
-    client = vertx.createHttpClient();
+    client = vertx.createHttpClient(new HttpClientOptions().setKeepAliveTimeout(0));
     FakeHttpClientMetrics metrics = FakeHttpClientMetrics.getMetrics(client);
     CountDownLatch responsesLatch = new CountDownLatch(5);
     for (int i = 0;i < 5;i++) {

File: src/main/java/io/vertx/core/http/impl/FileStreamChannel.java
Patch:
@@ -144,7 +144,7 @@ protected void doWrite(ChannelOutboundBuffer in) {
     while (!stream.isNotWritable() && (chunk = (ByteBuf) in.current()) != null) {
       bytesWritten += chunk.readableBytes();
       stream.writeData(chunk.retain(), false);
-      stream.handlerContext.flush();
+      stream.flush();
       in.remove();
     }
   }

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java
Patch:
@@ -406,6 +406,9 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         connection.onHeadersRead(ctx, 1, frame.headers(), frame.padding(), frame.isEndStream());
       } else if (msg instanceof Http2DataFrame) {
         Http2DataFrame frame = (Http2DataFrame) msg;
+        Http2LocalFlowController controller = decoder().flowController();
+        Http2Stream stream = decoder().connection().stream(1);
+        controller.receiveFlowControlledFrame(stream, frame.content(), frame.padding(), frame.isEndStream());
         connection.onDataRead(ctx, 1, frame.content(), frame.padding(), frame.isEndStream());
       }
     } else {

File: src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -239,15 +239,14 @@ public interface HttpClientRequest extends WriteStream<Buffer>, Future<HttpClien
    * @return a reference to this, so the API can be used fluently
    * @throws java.lang.IllegalStateException when no response handler is set
    */
-  @Fluent
-  HttpClientRequest sendHead();
+  Future<HttpVersion> sendHead();
 
   /**
    * Like {@link #sendHead()} but with an handler after headers have been sent. The handler will be called with
    * the {@link HttpVersion} if it can be determined or null otherwise.<p>
    */
   @Fluent
-  HttpClientRequest sendHead(Handler<HttpVersion> completionHandler);
+  HttpClientRequest sendHead(Handler<AsyncResult<HttpVersion>> completionHandler);
 
   /**
    * Same as {@link #end(Buffer)} but writes a String in UTF-8 encoding

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -196,12 +196,12 @@ public HttpClientRequest continueHandler(@Nullable Handler<Void> handler) {
   }
 
   @Override
-  public HttpClientRequest sendHead() {
+  public Future<HttpVersion> sendHead() {
     throw new IllegalStateException();
   }
 
   @Override
-  public HttpClientRequest sendHead(Handler<HttpVersion> completionHandler) {
+  public HttpClientRequest sendHead(Handler<AsyncResult<HttpVersion>> completionHandler) {
     throw new IllegalStateException();
   }
 

File: src/test/java/io/vertx/core/http/Http2Test.java
Patch:
@@ -119,7 +119,9 @@ public void testClientRequestWriteFromOtherThread() throws Exception {
     HttpClientRequest req = client.request(HttpMethod.GET, testAddress, 8080, "localhost", "/somepath", onSuccess(resp -> {
       assertEquals(200, resp.statusCode());
       testComplete();
-    })).setChunked(true).sendHead();
+    }))
+      .setChunked(true);
+    req.sendHead();
     awaitLatch(latch2); // The next write won't be buffered
     req.write("hello ");
     req.end("world");

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -96,7 +96,6 @@ public void testClientChaining() {
     server.listen(testAddress, onSuccess(server -> {
       HttpClientRequest req = client.request(HttpMethod.PUT, testAddress, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI, noOpHandler());
       assertTrue(req.setChunked(true) == req);
-      assertTrue(req.sendHead() == req);
       testComplete();
     }));
 
@@ -4088,8 +4087,8 @@ class MockReq implements HttpClientRequest {
       public void write(String chunk, Handler<AsyncResult<Void>> handler) { throw new UnsupportedOperationException(); }
       public void write(String chunk, String enc, Handler<AsyncResult<Void>> handler) { throw new UnsupportedOperationException(); }
       public HttpClientRequest continueHandler(@Nullable Handler<Void> handler) { throw new UnsupportedOperationException(); }
-      public HttpClientRequest sendHead() { throw new UnsupportedOperationException(); }
-      public HttpClientRequest sendHead(Handler<HttpVersion> completionHandler) { throw new UnsupportedOperationException(); }
+      public Future<HttpVersion> sendHead() { throw new UnsupportedOperationException(); }
+      public HttpClientRequest sendHead(Handler<AsyncResult<HttpVersion>> completionHandler) { throw new UnsupportedOperationException(); }
       public Future<Void> end(String chunk) { throw new UnsupportedOperationException(); }
       public Future<Void> end(String chunk, String enc) { throw new UnsupportedOperationException(); }
       public void end(String chunk, Handler<AsyncResult<Void>> handler) { throw new UnsupportedOperationException(); }

File: src/main/java/io/vertx/core/http/impl/Http1xConnectionBase.java
Patch:
@@ -46,7 +46,7 @@
  */
 abstract class Http1xConnectionBase<S extends WebSocketImplBase<S>> extends ConnectionBase implements io.vertx.core.http.HttpConnection {
 
-  protected S ws;
+  protected S webSocket;
   private boolean closeFrameSent;
 
   Http1xConnectionBase(VertxInternal vertx, ChannelHandlerContext chctx, ContextInternal context) {
@@ -119,7 +119,7 @@ void handleWsFrame(WebSocketFrame msg) {
           }
           break;
       }
-      w = ws;
+      w = webSocket;
     }
     if (w != null) {
       w.context.emit(frame, ((WebSocketImplBase)w)::handleFrame);
@@ -132,7 +132,7 @@ public Future<Void> close() {
   }
 
   Future<Void> closeWithPayload(short code, String reason) {
-    if (ws == null) {
+    if (webSocket == null) {
       return super.close();
     } else {
       PromiseInternal<Void> promise = context.promise();

File: src/main/java/io/vertx/core/http/impl/HttpClientConnection.java
Patch:
@@ -16,8 +16,10 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.Promise;
 import io.vertx.core.http.HttpConnection;
 import io.vertx.core.impl.ContextInternal;
+import io.vertx.core.net.NetSocket;
 
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
@@ -30,7 +32,7 @@ public interface HttpClientConnection extends HttpConnection {
 
   Future<Void> close();
 
-  void createStream(ContextInternal context, Handler<AsyncResult<HttpClientStream>> handler);
+  void createStream(ContextInternal context, HttpClientRequestImpl req, Promise<NetSocket> netSocketPromise, Handler<AsyncResult<HttpClientStream>> handler);
 
   ContextInternal getContext();
 

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -45,7 +45,7 @@ public HttpClientRequestPushPromise(
       MultiMap headers) {
     super(client, conn.getContext(), ssl, method, SocketAddress.inetSocketAddress(port, host), host, port, uri);
     this.conn = conn;
-    this.stream = new Http2ClientConnection.Http2ClientStream(conn, conn.getContext(), this, stream, false);
+    this.stream = new Http2ClientConnection.Http2ClientStream(conn, conn.getContext(), this, null, stream, false);
     this.rawMethod = rawMethod;
     this.headers = headers;
   }

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -45,7 +45,7 @@ public interface HttpClientStream {
   HttpConnection connection();
   ContextInternal getContext();
 
-  void writeHead(HttpMethod method, String rawMethod, String uri, MultiMap headers, String hostHeader, boolean chunked, ByteBuf buf, boolean end, StreamPriority priority, Handler<Void> contHandler, Handler<AsyncResult<Void>> listener);
+  void writeHead(HttpMethod method, String rawMethod, String uri, MultiMap headers, String hostHeader, boolean chunked, ByteBuf buf, boolean end, StreamPriority priority, Handler<AsyncResult<Void>> listener);
   void writeBuffer(ByteBuf buf, boolean end, Handler<AsyncResult<Void>> listener);
   void writeFrame(int type, int flags, ByteBuf payload);
 
@@ -55,8 +55,6 @@ public interface HttpClientStream {
   void doFetch(long amount);
 
   void reset(Throwable cause);
-  void beginRequest(HttpClientRequestImpl req, Promise<NetSocket> netSocketPromise);
-  void endRequest();
 
   StreamPriority priority();
   void updatePriority(StreamPriority streamPriority);

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -73,7 +73,7 @@ abstract class VertxHttp2Stream<C extends Http2ConnectionBase> {
         handleData(data);
       }
     });
-    pending.exceptionHandler(context.exceptionHandler());
+    pending.exceptionHandler(context::reportException);
 
     pending.resume();
   }

File: src/test/java/io/vertx/core/spi/tracing/HttpTracerTestBase.java
Patch:
@@ -173,10 +173,8 @@ public void receiveResponse(Context context, Object response, Object payload, Th
       ConcurrentMap<Object, Object> tracerMap = ((ContextInternal) ctx).localContextData();
       tracerMap.put(key, val);
       client.getNow(8080, "localhost", "/", onSuccess(resp -> {
-        assertEquals(1, seq.get());
         resp.endHandler(v2 -> {
           vertx.runOnContext(v -> {
-            assertEquals(2, seq.get());
             assertNull(tracerMap.get(key));
             testComplete();
           });

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -19,6 +19,7 @@
 import io.vertx.core.MultiMap;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.*;
+import io.vertx.core.net.NetSocket;
 import io.vertx.core.net.SocketAddress;
 
 /**

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -16,6 +16,7 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 import io.vertx.core.MultiMap;
+import io.vertx.core.Promise;
 import io.vertx.core.http.HttpConnection;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
@@ -54,11 +55,9 @@ public interface HttpClientStream {
   void doFetch(long amount);
 
   void reset(Throwable cause);
-  void beginRequest(HttpClientRequestImpl req);
+  void beginRequest(HttpClientRequestImpl req, Promise<NetSocket> netSocketPromise);
   void endRequest();
 
-  NetSocket createNetSocket();
-
   StreamPriority priority();
   void updatePriority(StreamPriority streamPriority);
 }

File: src/test/java/io/vertx/core/spi/metrics/MetricsContextTest.java
Patch:
@@ -157,7 +157,7 @@ public void close() {
     awaitLatch(latch);
     HttpClient client = vertx.createHttpClient();
     client.put(8080, "localhost", "/", onSuccess(resp -> {
-      resp.netSocket().closeHandler(v -> {
+      resp.request().connection().closeHandler(v -> {
         vertx.close(v4 -> {
           assertTrue(requestBeginCalled.get());
           assertTrue(responseEndCalled.get());

File: src/main/java/io/vertx/core/cli/Option.java
Patch:
@@ -376,7 +376,9 @@ public boolean isFlag() {
    */
   public Option setFlag(boolean flag) {
     this.flag = flag;
-    setSingleValued(false);
+    if (flag) {
+      setSingleValued(false);
+    }
     return this;
   }
 

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -35,6 +35,7 @@
 import io.vertx.core.streams.ReadStream;
 
 import java.util.Set;
+import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 

File: src/main/java/io/vertx/core/impl/Deployment.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.impl;
 
 import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
 import io.vertx.core.DeploymentOptions;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -49,6 +50,8 @@ default void doUndeploy(ContextInternal undeployingContext, Handler<AsyncResult<
 
   DeploymentOptions deploymentOptions();
 
+  Set<Context> getContexts();
+
   Set<Verticle> getVerticles();
 
   boolean isChild();

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -463,7 +463,7 @@ private Future<String> doDeploy(String identifier,
                   deployment.child = true;
                 } else {
                   // Orphan
-                  deployment.undeploy(null);
+                  deployment.undeploy(event -> promise.fail("Verticle deployment failed.Could not be added as child of parent verticle"));
                   return;
                 }
               }

File: src/main/java/io/vertx/core/http/impl/MimeMapping.java
Patch:
@@ -721,6 +721,8 @@ public class MimeMapping {
     m.put("xlf", "application/x-xliff+xml");
     m.put("xpi", "application/x-xpinstall");
     m.put("xz", "application/x-xz");
+    m.put("yml", "application/x-yaml");
+    m.put("yaml", "application/x-yaml");
     m.put("z1", "application/x-zmachine");
     m.put("z2", "application/x-zmachine");
     m.put("z3", "application/x-zmachine");

File: src/main/java/io/vertx/core/cli/Option.java
Patch:
@@ -376,7 +376,9 @@ public boolean isFlag() {
    */
   public Option setFlag(boolean flag) {
     this.flag = flag;
-    setSingleValued(false);
+    if (flag) {
+      setSingleValued(false);
+    }
     return this;
   }
 

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -5487,7 +5487,7 @@ public void testClientRequestFutureSetHandlerFromAnotherThread() throws Exceptio
     server.requestHandler(req -> {
       req.response().end();
     });
-    startServer();
+    startServer(testAddress);
     client.close();
     Context ctx = vertx.getOrCreateContext();
     CompletableFuture<HttpClientRequest> reqFut = new CompletableFuture<>();

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -31,7 +31,6 @@
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.ConnectionBase;
-import io.vertx.core.net.impl.FutureListenerAdapter;
 import io.vertx.core.net.impl.SocketAddressImpl;
 import io.vertx.core.net.impl.VertxHandler;
 import io.vertx.core.net.impl.transport.Transport;
@@ -213,7 +212,7 @@ private DatagramSocket listen(SocketAddress local, Handler<AsyncResult<DatagramS
   @SuppressWarnings("unchecked")
   final void addListener(ChannelFuture future, Handler<AsyncResult<Void>> handler) {
     if (handler != null) {
-      future.addListener(FutureListenerAdapter.toVoid(context, handler));
+      future.addListener(context.toFutureListener(handler));
     }
   }
 
@@ -310,7 +309,7 @@ public synchronized void close(final Handler<AsyncResult<Void>> handler) {
     channel.flush();
     ChannelFuture future = channel.close();
     if (handler != null) {
-      future.addListener(FutureListenerAdapter.toVoid(context, handler));
+      future.addListener(context.toFutureListener(handler));
     }
   }
 

File: src/main/java/io/vertx/core/eventbus/impl/MessageProducerImpl.java
Patch:
@@ -17,6 +17,7 @@
 import io.vertx.core.Promise;
 import io.vertx.core.Vertx;
 import io.vertx.core.eventbus.*;
+import io.vertx.core.impl.VertxInternal;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
@@ -82,7 +83,7 @@ public synchronized MessageProducer<T> setWriteQueueMaxSize(int s) {
 
   @Override
   public synchronized Future<Void> write(T data) {
-    Promise<Void> promise = Promise.promise();
+    Promise<Void> promise = ((VertxInternal)vertx).getOrCreateContext().promise();
     write(data, promise);
     return promise.future();
   }
@@ -91,7 +92,7 @@ public synchronized Future<Void> write(T data) {
   public void write(T data, Handler<AsyncResult<Void>> handler) {
     Promise<Void> promise = null;
     if (handler != null) {
-      promise = Promise.promise();
+      promise = ((VertxInternal)vertx).getOrCreateContext().promise();
       promise.future().setHandler(handler);
     }
     write(data, promise);

File: src/main/java/io/vertx/core/eventbus/impl/ReplyHandler.java
Patch:
@@ -35,7 +35,7 @@ class ReplyHandler<T> extends HandlerRegistration<T> implements Handler<Message<
     super(context, eventBus, address, src);
     this.eventBus = eventBus;
     this.context = context;
-    this.result = Promise.promise();
+    this.result = context.promise();
     this.src = src;
     this.repliedAddress = repliedAddress;
     this.timeoutID = eventBus.vertx.setTimer(timeout, id -> {
@@ -74,7 +74,7 @@ protected void doUnregister() {
   }
 
   void register() {
-    register(repliedAddress, true);
+    register(repliedAddress, true, ar -> {});
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -114,19 +114,18 @@ void upgradeStream(Object metric, ContextInternal context, Handler<AsyncResult<H
 
   @Override
   public void createStream(ContextInternal context, Handler<AsyncResult<HttpClientStream>> completionHandler) {
-    ContextInternal sub = getContext().duplicate(context);
     Future<HttpClientStream> fut;
     synchronized (this) {
       Http2Connection conn = handler.connection();
       try {
         int id = conn.local().lastStreamCreated() == 0 ? 1 : conn.local().lastStreamCreated() + 2;
-        Http2ClientStream stream = createStream(sub, conn.local().createStream(id, false));
+        Http2ClientStream stream = createStream(context, conn.local().createStream(id, false));
         fut = Future.succeededFuture(stream);
       } catch (Exception e) {
         fut = Future.failedFuture(e);
       }
     }
-    sub.dispatch(fut, completionHandler);
+    context.dispatch(fut, completionHandler);
   }
 
   private Http2ClientStream createStream(ContextInternal context, Http2Stream stream) {

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestBase.java
Patch:
@@ -40,7 +40,7 @@ public abstract class HttpClientRequestBase implements HttpClientRequest {
   private long lastDataReceived;
   protected final Promise<HttpClientResponse> responsePromise;
 
-  HttpClientRequestBase(HttpClientImpl client, boolean ssl, HttpMethod method, SocketAddress server, String host, int port, String uri) {
+  HttpClientRequestBase(HttpClientImpl client, ContextInternal context, boolean ssl, HttpMethod method, SocketAddress server, String host, int port, String uri) {
     this.client = client;
     this.uri = uri;
     this.method = method;
@@ -50,7 +50,7 @@ public abstract class HttpClientRequestBase implements HttpClientRequest {
     this.path = uri.length() > 0 ? HttpUtils.parsePath(uri) : "";
     this.query = HttpUtils.parseQuery(uri);
     this.ssl = ssl;
-    this.responsePromise = Promise.promise();
+    this.responsePromise = context.promise();
   }
 
   protected String hostHeader() {

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -42,7 +42,7 @@ public HttpClientRequestPushPromise(
       String host,
       int port,
       MultiMap headers) {
-    super(client, ssl, method, SocketAddress.inetSocketAddress(port, host), host, port, uri);
+    super(client, conn.getContext(), ssl, method, SocketAddress.inetSocketAddress(port, host), host, port, uri);
     this.conn = conn;
     this.stream = new Http2ClientConnection.Http2ClientStream(conn, conn.getContext(), this, stream, false);
     this.rawMethod = rawMethod;

File: src/main/java/io/vertx/core/impl/AddressResolver.java
Patch:
@@ -19,7 +19,6 @@
 import io.vertx.core.impl.launcher.commands.ExecUtils;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;
-import io.vertx.core.net.impl.FutureListenerAdapter;
 import io.vertx.core.spi.resolver.ResolverProvider;
 
 import java.io.File;
@@ -81,7 +80,7 @@ public void resolveHostname(String hostname, Handler<AsyncResult<InetAddress>> r
     ContextInternal callback = (ContextInternal) vertx.getOrCreateContext();
     io.netty.resolver.AddressResolver<InetSocketAddress> resolver = resolverGroup.getResolver(callback.nettyEventLoop());
     io.netty.util.concurrent.Future<InetSocketAddress> fut = resolver.resolve(InetSocketAddress.createUnresolved(hostname, 0));
-    fut.addListener(FutureListenerAdapter.toValue(callback, InetSocketAddress::getAddress, resultHandler));
+    fut.addListener(callback.toFutureListener(InetSocketAddress::getAddress, resultHandler));
   }
 
   AddressResolverGroup<InetSocketAddress> nettyAddressResolverGroup() {

File: src/main/java/io/vertx/core/impl/HAManager.java
Patch:
@@ -282,7 +282,7 @@ private void doDeployVerticle(final String verticleName, DeploymentOptions deplo
         }
       });
     };
-    deploymentManager.deployVerticle(verticleName, deploymentOptions, wrappedHandler);
+    deploymentManager.deployVerticle(verticleName, deploymentOptions).setHandler(wrappedHandler);
   }
 
   // A node has joined the cluster
@@ -431,7 +431,7 @@ private void undeployHADeployments() {
       if (dep != null) {
         if (dep.deploymentOptions().isHa()) {
           ContextImpl.executeIsolated(v -> {
-            deploymentManager.undeployVerticle(deploymentID, result -> {
+            deploymentManager.undeployVerticle(deploymentID).setHandler(result -> {
               if (result.succeeded()) {
                 log.info("Successfully undeployed HA deployment " + deploymentID + "-" + dep.verticleIdentifier() + " as there is no quorum");
                 addToHADeployList(dep.verticleIdentifier(), dep.deploymentOptions(), result1 -> {

File: src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -28,7 +28,6 @@
 import io.vertx.core.eventbus.Message;
 import io.vertx.core.eventbus.MessageConsumer;
 import io.vertx.core.impl.ContextInternal;
-import io.vertx.core.impl.NetSocketInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.impl.logging.Logger;
 import io.vertx.core.impl.logging.LoggerFactory;

File: src/main/java/io/vertx/core/net/impl/NetSocketInternal.java
Patch:
@@ -9,12 +9,10 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  */
 
-package io.vertx.core.impl;
+package io.vertx.core.net.impl;
 
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelPromise;
-import io.netty.util.concurrent.EventExecutorGroup;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 import io.vertx.core.net.NetSocket;

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -30,13 +30,12 @@
 import io.vertx.core.http.impl.FrameType;
 import io.vertx.core.http.impl.ws.WebSocketFrameImpl;
 import io.vertx.core.impl.ConcurrentHashSet;
-import io.vertx.core.impl.NetSocketInternal;
+import io.vertx.core.net.impl.NetSocketInternal;
 import io.vertx.core.net.NetServer;
 import io.vertx.core.net.NetSocket;
 import io.vertx.core.net.SelfSignedCertificate;
 import io.vertx.core.streams.ReadStream;
 import io.vertx.test.core.CheckingSender;
-import io.vertx.test.core.Repeat;
 import io.vertx.test.core.TestUtils;
 import io.vertx.test.core.VertxTestBase;
 import io.vertx.test.tls.Cert;

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -19,13 +19,12 @@
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpVersion;
 import io.vertx.core.*;
-import io.vertx.core.Future;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.eventbus.Message;
 import io.vertx.core.eventbus.MessageConsumer;
 import io.vertx.core.http.*;
 import io.vertx.core.impl.ConcurrentHashSet;
-import io.vertx.core.impl.NetSocketInternal;
+import io.vertx.core.net.impl.NetSocketInternal;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.impl.logging.Logger;

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -92,8 +92,8 @@ boolean onDataRead(Buffer data) {
   void onWritabilityChanged() {
     synchronized (conn) {
       writable = !writable;
-      handleInterestedOpsChanged();
     }
+    handleInterestedOpsChanged();
   }
 
   void onEnd() {

File: src/main/java/io/vertx/core/http/impl/HttpHandlers.java
Patch:
@@ -89,7 +89,7 @@ private void initializeWebsocketExtensions(ChannelPipeline pipeline) {
     if (!extensionHandshakers.isEmpty()) {
       WebSocketServerExtensionHandler extensionHandler = new WebSocketServerExtensionHandler(
         extensionHandshakers.toArray(new WebSocketServerExtensionHandshaker[extensionHandshakers.size()]));
-      pipeline.addLast("websocketExtensionHandler", extensionHandler);
+      pipeline.addBefore("handler", "websocketExtensionHandler", extensionHandler);
     }
   }
 

File: src/main/java/io/vertx/core/Context.java
Patch:
@@ -76,7 +76,7 @@ static boolean isOnWorkerThread() {
    * NOTE! This is not always the same as calling {@link Context#isEventLoopContext}. If you are running blocking code
    * from an event loop context, then this will return false but {@link Context#isEventLoopContext} will return true.
    *
-   * @return true if current thread is a worker thread, false otherwise
+   * @return true if current thread is an event thread, false otherwise
    */
   static boolean isOnEventLoopThread() {
     Thread t = Thread.currentThread();

File: src/main/java/io/vertx/core/streams/impl/InboundBuffer.java
Patch:
@@ -107,7 +107,7 @@ private void checkThread() {
    * it is possible, otherwise it will be queued for later delivery.
    *
    * @param element the element to add
-   * @return {@code true} when the buffer is full and the producer should stop writing
+   * @return {@code false} when the producer should stop writing
    */
   public boolean write(E element) {
     checkThread();
@@ -144,7 +144,7 @@ private boolean checkWritable() {
    *
    * @see #write(E)
    * @param elements the elements to add
-   * @return {@code true} if the buffer is full
+   * @return {@code false} when the producer should stop writing
    */
   public boolean write(Iterable<E> elements) {
     checkThread();

File: src/test/java/io/vertx/core/buffer/BufferTest.java
Patch:
@@ -14,11 +14,10 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.util.IllegalReferenceCountException;
+import io.vertx.core.buffer.impl.BufferImpl;
 import io.vertx.core.json.DecodeException;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
-import io.vertx.core.net.impl.PartialPooledByteBufAllocator;
-import io.vertx.core.spi.BufferFactory;
 import io.vertx.test.core.TestUtils;
 import org.junit.Test;
 
@@ -1103,7 +1102,7 @@ public void testAppendDoesNotModifyByteBufIndex() throws Exception {
 
   @Test
   public void testDirect() {
-    Buffer buff = Buffer.factory.directBuffer("hello world".getBytes());
+    Buffer buff = BufferImpl.directBuffer("hello world".getBytes());
     assertEquals("hello world", buff.toString());
     buff.appendString(" foobar");
     assertEquals("hello world foobar", buff.toString());

File: src/test/java/io/vertx/core/streams/PumpTest.java
Patch:
@@ -14,9 +14,6 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
-import io.vertx.core.streams.Pump;
-import io.vertx.core.streams.ReadStream;
-import io.vertx.core.streams.WriteStream;
 import org.junit.Test;
 
 import java.util.ArrayList;

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -17,12 +17,12 @@
 import io.vertx.codegen.annotations.GenIgnore;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.ServiceHelper;
-import io.vertx.core.json.Json;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.shareddata.Shareable;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
 import io.vertx.core.spi.BufferFactory;
+import io.vertx.core.spi.json.JsonCodec;
 
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
@@ -148,7 +148,7 @@ static Buffer buffer(ByteBuf byteBuf) {
    * @return a JSON element which can be a {@link JsonArray}, {@link JsonObject}, {@link String}, ...etc if the buffer contains an array, object, string, ...etc
    */
   default Object toJson() {
-    return Json.decodeValue(this);
+    return JsonCodec.INSTANCE.fromBuffer(this, Object.class);
   }
 
   /**

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -1177,6 +1177,7 @@ public void testPipeliningLimit() throws Exception {
   }
 
   @Test
+  @Repeat(times = 10)
   public void testCloseServerConnectionWithPendingMessages() throws Exception {
     int n = 5;
     server.requestHandler(req -> {
@@ -1247,7 +1248,6 @@ public void testPipeliningFailure() throws Exception {
   /**
    * A test that stress HTTP server pipe-lining.
    */
-  @Repeat(times = 100)
   @Test
   public void testPipelineStress() throws Exception {
 

File: src/test/java/io/vertx/core/streams/PipeTest.java
Patch:
@@ -11,7 +11,6 @@
 package io.vertx.core.streams;
 
 import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
 import io.vertx.core.Promise;
 import io.vertx.test.core.AsyncTestBase;
 import io.vertx.test.fakestream.FakeStream;
@@ -228,7 +227,7 @@ public void testClosePipeAfterEnd() {
   @Test
   public void testEndWriteStreamSuccess() {
     Promise<Void> completion = Promise.promise();
-    dst.completion(completion.future());
+    dst.setEnd(completion.future());
     FakeStream<Object> src = new FakeStream<>();
     Pipe<Object> pipe = src.pipe();
     AtomicReference<AsyncResult<Void>> ended = new AtomicReference<>();
@@ -242,7 +241,7 @@ public void testEndWriteStreamSuccess() {
   @Test
   public void testEndWriteStreamFail() {
     Promise<Void> completion = Promise.promise();
-    dst.completion(completion.future());
+    dst.setEnd(completion.future());
     FakeStream<Object> src = new FakeStream<>();
     Pipe<Object> pipe = src.pipe();
     AtomicReference<AsyncResult<Void>> ended = new AtomicReference<>();

File: src/test/java/io/vertx/test/fakestream/FakeStreamTest.java
Patch:
@@ -142,7 +142,7 @@ public void testAsyncEnd() {
     Promise<Void> end = Promise.promise();
     AtomicInteger ended = new AtomicInteger();
     AtomicReference<AsyncResult> endRes = new AtomicReference<>();
-    stream.completion(end.future());
+    stream.setEnd(end.future());
     stream.endHandler(v -> ended.incrementAndGet());
     stream.end(endRes::set);
     assertEquals(0, ended.get());
@@ -157,7 +157,7 @@ public void testAsyncEndDeferred() {
     Promise<Void> end = Promise.promise();
     AtomicInteger ended = new AtomicInteger();
     AtomicReference<AsyncResult> endRes = new AtomicReference<>();
-    stream.completion(end.future());
+    stream.setEnd(end.future());
     stream.pause();
     stream.emit(3);
     stream.endHandler(v -> ended.incrementAndGet());

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -719,7 +719,8 @@ synchronized void toWebSocket(
         nettyHeaders,
         maxWebSocketFrameSize,
         !options.isSendUnmaskedFrames(),
-        false);
+        false,
+        -1);
 
       WebSocketHandshakeInboundHandler handshakeInboundHandler = new WebSocketHandshakeInboundHandler(handshaker, ar -> {
         AsyncResult<WebSocket> wsRes = ar.map(v -> {

File: src/test/java/io/vertx/core/http/WebSocketTest.java
Patch:
@@ -1818,7 +1818,7 @@ public void handle(Buffer data) {
   public void testInvalidUnmaskedFrameRequest(){
 
     client = vertx.createHttpClient(new HttpClientOptions().setSendUnmaskedFrames(true));
-    server = vertx.createHttpServer(new HttpServerOptions().setPort(DEFAULT_HTTP_PORT));
+    server = vertx.createHttpServer(new HttpServerOptions().setPort(DEFAULT_HTTP_PORT).setAcceptUnmaskedFrames(false));
     server.requestHandler(req -> {
       req.response().setChunked(true).write("connect");
     });

File: src/test/java/io/vertx/test/core/TestUtils.java
Patch:
@@ -319,7 +319,7 @@ public static void assertIllegalStateException(Runnable runnable) {
     }
   }
 
-  public static void assertIllegalStateException2(Supplier<Future<?>> runnable) {
+  public static void assertIllegalStateExceptionAsync(Supplier<Future<?>> runnable) {
     Future<?> fut = runnable.get();
     assertTrue(fut.failed());
     assertTrue(fut.cause() instanceof IllegalStateException);

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -5418,7 +5418,7 @@ public void testNoCookiesAddCookie() throws Exception {
 
   private void testCookies(String cookieHeader, Consumer<HttpServerRequest> serverChecker, Consumer<HttpClientResponse> clientChecker) throws Exception {
     server.requestHandler(serverChecker::accept);
-    startServer();
+    startServer(testAddress);
     client.request(
       HttpMethod.GET,
       testAddress,

File: src/main/java/io/vertx/core/file/FileSystem.java
Patch:
@@ -483,7 +483,7 @@ public interface FileSystem {
   /**
    * Create the directory represented by {@code path} and any non existent parents, asynchronously.
    * <p>
-   * The operation will fail if the directory already exists.
+   * The operation will fail if the {@code path} already exists but is not a directory.
    *
    * @param path  path to the file
    * @param handler  the handler that will be called on completion
@@ -511,7 +511,7 @@ public interface FileSystem {
    * The permission String takes the form rwxr-x--- as specified
    * in <a href="http://download.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html">here</a>.
    * <p>
-   * The operation will fail if the directory already exists.<p>
+   * The operation will fail if the {@code path} already exists but is not a directory.
    *
    * @param path  path to the file
    * @param perms  the permissions string

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -485,13 +485,13 @@ public void reset(Throwable cause) {
         writeReset(code);
       } else {
         if (!(requestEnded && responseEnded)) {
+          handleException(cause);
           requestEnded = true;
           responseEnded = true;
           writeReset(code);
           if (conn.metrics != null) {
             conn.metrics.requestReset(metric);
           }
-          handleException(cause);
         }
       }
     }

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -55,8 +55,9 @@ public synchronized <T> void executeBlocking(Handler<Promise<T>> blockingCodeHan
     if (closed) {
       throw new IllegalStateException("Worker executor closed");
     }
-    ContextImpl context = (ContextImpl) ctx.owner().getOrCreateContext();
-    ContextImpl.executeBlocking(context, blockingCodeHandler, asyncResultHandler, pool, ordered ? context.orderedTasks : null);
+    ContextInternal context = (ContextInternal) ctx.owner().getOrCreateContext();
+    ContextImpl impl = context instanceof ContextImpl.Duplicated ? ((ContextImpl.Duplicated)context).delegate : (ContextImpl) context;
+    ContextImpl.executeBlocking(context, blockingCodeHandler, asyncResultHandler, pool, ordered ? impl.orderedTasks : null);
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -254,16 +254,16 @@ public ContextInternal getContext() {
     public void writeHead(HttpMethod method, String rawMethod, String uri, MultiMap headers, String hostHeader, boolean chunked, ByteBuf buf, boolean end, StreamPriority priority, Handler<AsyncResult<Void>> handler) {
       HttpRequest request = createRequest(method, rawMethod, uri, headers);
       prepareRequestHeaders(request, hostHeader, chunked);
+      if (buf != null) {
+        bytesWritten += buf.readableBytes();
+      }
       sendRequest(request, buf, end, handler);
       if (conn.responseInProgress == null) {
         conn.responseInProgress = this;
       } else {
         conn.responseInProgress.append(this);
       }
       next = null;
-      if (buf != null) {
-        bytesWritten += buf.readableBytes();
-      }
     }
 
     private HttpRequest createRequest(HttpMethod method, String rawMethod, String uri, MultiMap headers) {

File: src/main/java/docoverride/json/Examples.java
Patch:
@@ -14,8 +14,10 @@
 import io.vertx.core.http.HttpServerRequest;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
+import io.vertx.core.json.pointer.JsonPointer;
 import io.vertx.docgen.Source;
 
+import java.net.URI;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -80,7 +82,4 @@ public void example4(JsonArray array) {
     Boolean boolVal = array.getBoolean(2);
   }
 
-
-
-
 }

File: src/main/java/io/vertx/core/Context.java
Patch:
@@ -108,7 +108,7 @@ static boolean isOnVertxThread() {
    * (e.g. on the original event loop of the caller).
    * <p>
    * A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
-   * the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
+   * the handler should call the {@link Promise#complete} or {@link Promise#complete(Object)} method, or the {@link Promise#fail}
    * method if it failed.
    * <p>
    * The blocking code should block for a reasonable amount of time (i.e no more than a few seconds). Long blocking operations
@@ -127,15 +127,15 @@ static boolean isOnVertxThread() {
    *                 guarantees
    * @param <T> the type of the result
    */
-  <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<@Nullable T>> resultHandler);
+  <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<@Nullable T>> resultHandler);
 
   /**
    * Invoke {@link #executeBlocking(Handler, boolean, Handler)} with order = true.
    * @param blockingCodeHandler  handler representing the blocking code to run
    * @param resultHandler  handler that will be called when the blocking code is complete
    * @param <T> the type of the result
    */
-  <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, Handler<AsyncResult<@Nullable T>> resultHandler);
+  <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, Handler<AsyncResult<@Nullable T>> resultHandler);
 
   /**
    * If the context is associated with a Verticle deployment, this returns the deployment ID of that deployment.

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -503,7 +503,7 @@ static void clusteredVertx(VertxOptions options, Handler<AsyncResult<Vertx>> res
    * (e.g. on the original event loop of the caller).
    * <p>
    * A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
-   * the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
+   * the handler should call the {@link Promise#complete} or {@link Promise#complete(Object)} method, or the {@link Promise#fail}
    * method if it failed.
    * <p>
    * In the {@code blockingCodeHandler} the current context remains the original context and therefore any task
@@ -525,12 +525,12 @@ static void clusteredVertx(VertxOptions options, Handler<AsyncResult<Vertx>> res
    *                 guarantees
    * @param <T> the type of the result
    */
-  <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<@Nullable T>> resultHandler);
+  <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<@Nullable T>> resultHandler);
 
   /**
    * Like {@link #executeBlocking(Handler, boolean, Handler)} called with ordered = true.
    */
-  <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, Handler<AsyncResult<@Nullable T>> resultHandler);
+  <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, Handler<AsyncResult<@Nullable T>> resultHandler);
 
   /**
    * Return the Netty EventLoopGroup used by Vert.x

File: src/main/java/io/vertx/core/WorkerExecutor.java
Patch:
@@ -35,7 +35,7 @@ public interface WorkerExecutor extends Measured {
    * (i.e. on the original event loop of the caller).
    * <p>
    * A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
-   * the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
+   * the handler should call the {@link Promise#complete} or {@link Promise#complete(Object)} method, or the {@link Promise#fail}
    * method if it failed.
    * <p>
    * In the {@code blockingCodeHandler} the current context remains the original context and therefore any task
@@ -48,12 +48,12 @@ public interface WorkerExecutor extends Measured {
    *                 guarantees
    * @param <T> the type of the result
    */
-  <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<@Nullable T>> resultHandler);
+  <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<@Nullable T>> resultHandler);
 
   /**
    * Like {@link #executeBlocking(Handler, boolean, Handler)} called with ordered = true.
    */
-  default <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, Handler<AsyncResult<@Nullable T>> resultHandler) {
+  default <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, Handler<AsyncResult<@Nullable T>> resultHandler) {
     executeBlocking(blockingCodeHandler, true, resultHandler);
   }
 

File: src/main/java/io/vertx/core/file/impl/FileSystemImpl.java
Patch:
@@ -12,8 +12,8 @@
 package io.vertx.core.file.impl;
 
 import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.Promise;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.file.AsyncFile;
 import io.vertx.core.file.CopyOptions;
@@ -951,7 +951,7 @@ public FileSystemProps perform() {
     };
   }
 
-  protected abstract class BlockingAction<T> implements Handler<Future<T>> {
+  protected abstract class BlockingAction<T> implements Handler<Promise<T>> {
 
     private final Handler<AsyncResult<T>> handler;
     protected final ContextInternal context;
@@ -968,7 +968,7 @@ public void run() {
     }
 
     @Override
-    public void handle(Future<T> fut) {
+    public void handle(Promise<T> fut) {
       try {
         T result = perform();
         fut.complete(result);

File: src/main/java/io/vertx/core/http/impl/FileStreamChannel.java
Patch:
@@ -34,6 +34,7 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.Promise;
 
 import java.io.RandomAccessFile;
 import java.net.SocketAddress;
@@ -56,7 +57,7 @@ class FileStreamChannel extends AbstractChannel {
   private final VertxHttp2Stream stream;
 
   FileStreamChannel(
-      Future<Long> result,
+      Promise<Long> result,
       VertxHttp2Stream stream,
       long offset,
       long length) {

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponseImpl.java
Patch:
@@ -26,6 +26,7 @@
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.MultiMap;
+import io.vertx.core.Promise;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpHeaders;
 import io.vertx.core.http.HttpMethod;
@@ -614,8 +615,8 @@ public HttpServerResponse sendFile(String filename, long offset, long length, Ha
       }
       checkSendHeaders(false);
 
-      Future<Long> result = Future.future();
-      result.setHandler(ar -> {
+      Promise<Long> result = Promise.promise();
+      result.future().setHandler(ar -> {
         if (ar.succeeded()) {
           bytesWritten += ar.result();
           end();

File: src/main/java/io/vertx/core/http/impl/VertxHttp2NetSocket.java
Patch:
@@ -21,6 +21,7 @@
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.MultiMap;
+import io.vertx.core.Promise;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.StreamPriority;
 import io.vertx.core.http.StreamResetException;
@@ -269,8 +270,8 @@ public NetSocket sendFile(String filename, long offset, long length, Handler<Asy
 
       long contentLength = Math.min(length, file.length() - offset);
 
-      Future<Long> result = Future.future();
-      result.setHandler(ar -> {
+      Promise<Long> result = Promise.promise();
+      result.future().setHandler(ar -> {
         if (resultHandler != null) {
           resultCtx.runOnContext(v -> {
             resultHandler.handle(Future.succeededFuture());

File: src/main/java/io/vertx/core/impl/AbstractContext.java
Patch:
@@ -11,8 +11,8 @@
 package io.vertx.core.impl;
 
 import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.Promise;
 import io.vertx.core.Starter;
 import io.vertx.core.impl.launcher.VertxCommandLauncher;
 
@@ -108,7 +108,7 @@ public final List<String> processArgs() {
   }
 
   @Override
-  public final <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, Handler<AsyncResult<T>> resultHandler) {
+  public final <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, Handler<AsyncResult<T>> resultHandler) {
     executeBlocking(blockingCodeHandler, true, resultHandler);
   }
 

File: src/main/java/io/vertx/core/impl/ContextInternal.java
Patch:
@@ -14,8 +14,8 @@
 import io.netty.channel.EventLoop;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
-import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.Promise;
 import io.vertx.core.Vertx;
 import io.vertx.core.spi.tracing.VertxTracer;
 
@@ -42,12 +42,12 @@ public interface ContextInternal extends Context {
    * Like {@link #executeBlocking(Handler, boolean, Handler)} but uses the {@code queue} to order the tasks instead
    * of the internal queue of this context.
    */
-  <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, TaskQueue queue, Handler<AsyncResult<T>> resultHandler);
+  <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, TaskQueue queue, Handler<AsyncResult<T>> resultHandler);
 
   /**
    * Execute an internal task on the internal blocking ordered executor.
    */
-  <T> void executeBlockingInternal(Handler<Future<T>> action, Handler<AsyncResult<T>> resultHandler);
+  <T> void executeBlockingInternal(Handler<Promise<T>> action, Handler<AsyncResult<T>> resultHandler);
 
   /**
    * @return the deployment associated with this context or {@code null}

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -100,7 +100,7 @@ public interface VertxInternal extends Vertx {
   /**
    * Like {@link #executeBlocking(Handler, Handler)} but using the internal worker thread pool.
    */
-  <T> void executeBlockingInternal(Handler<Future<T>> blockingCodeHandler, Handler<AsyncResult<T>> resultHandler);
+  <T> void executeBlockingInternal(Handler<Promise<T>> blockingCodeHandler, Handler<AsyncResult<T>> resultHandler);
 
   ClusterManager getClusterManager();
 

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -51,7 +51,7 @@ public WorkerPool getPool() {
     return pool;
   }
 
-  public synchronized <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<T>> asyncResultHandler) {
+  public synchronized <T> void executeBlocking(Handler<Promise<T>> blockingCodeHandler, boolean ordered, Handler<AsyncResult<T>> asyncResultHandler) {
     if (closed) {
       throw new IllegalStateException("Worker executor closed");
     }

File: src/main/java/io/vertx/core/spi/VerticleFactory.java
Patch:
@@ -13,6 +13,7 @@
 
 import io.vertx.core.DeploymentOptions;
 import io.vertx.core.Future;
+import io.vertx.core.Promise;
 import io.vertx.core.Verticle;
 import io.vertx.core.Vertx;
 
@@ -80,7 +81,7 @@ default boolean blockingCreate() {
    * @param classLoader  The classloader
    * @param resolution  A future which will receive the result of the resolution.
    */
-  default void resolve(String identifier, DeploymentOptions deploymentOptions, ClassLoader classLoader, Future<String> resolution) {
+  default void resolve(String identifier, DeploymentOptions deploymentOptions, ClassLoader classLoader, Promise<String> resolution) {
     resolution.complete(identifier);
   }
 

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -148,7 +148,7 @@ public void testExecuteBlockingThreadSyncComplete() throws Exception {
     Context context = vertx.getOrCreateContext();
     context.<Void>runOnContext(v -> {
       Thread expected = Thread.currentThread();
-      context.executeBlocking(Future::complete, r -> {
+      context.executeBlocking(Promise::complete, r -> {
         assertSame(expected, Thread.currentThread());
         testComplete();
       });
@@ -307,7 +307,7 @@ public void testExceptionHandlerOnAsyncDeploymentAsyncResultHandlerFailure() {
     ctx.runOnContext(v -> {
       vertx.deployVerticle(new AbstractVerticle() {
         @Override
-        public void start(Future<Void> startFuture) throws Exception {
+        public void start(Promise<Void> startFuture) throws Exception {
           context.runOnContext(startFuture::complete);
         }
       }, ar -> {
@@ -515,7 +515,7 @@ private void checkDuplicate(ContextInternal ctx, ContextInternal duplicated) thr
 
     CountDownLatch latch4 = new CountDownLatch(1);
     duplicated.runOnContext(v -> {
-      vertx.executeBlocking(Future::complete, res -> {
+      vertx.executeBlocking(Promise::complete, res -> {
         assertSame(duplicated, Vertx.currentContext());
         latch4.countDown();
       });

File: src/test/java/io/vertx/core/NamedWorkerPoolTest.java
Patch:
@@ -53,7 +53,7 @@ public void testMaxExecuteWorkerTime() throws Exception {
       .setMaxWorkerExecuteTime(maxWorkerExecuteTime);
     vertx.deployVerticle(new AbstractVerticle() {
       @Override
-      public void start(Future<Void> startFuture) throws Exception {
+      public void start(Promise<Void> startFuture) throws Exception {
         vertx.executeBlocking(fut -> {
           try {
             SECONDS.sleep(5);

File: src/test/java/io/vertx/core/VerticleFactoryTest.java
Patch:
@@ -256,7 +256,7 @@ public boolean requiresResolve() {
         return true;
       }
       @Override
-      public void resolve(String identifier, DeploymentOptions deploymentOptions, ClassLoader classLoader, Future<String> resolution) {
+      public void resolve(String identifier, DeploymentOptions deploymentOptions, ClassLoader classLoader, Promise<String> resolution) {
         vertx.runOnContext(v -> {
           // Async resolution
           resolution.complete("whatever");
@@ -585,7 +585,7 @@ public boolean requiresResolve() {
     }
 
     @Override
-    public void resolve(String identifier, DeploymentOptions deploymentOptions, ClassLoader classLoader, Future<String> resolution) {
+    public void resolve(String identifier, DeploymentOptions deploymentOptions, ClassLoader classLoader, Promise<String> resolution) {
       if (failInResolve) {
         resolution.fail(new IOException("whatever"));
       } else {

File: src/test/java/io/vertx/core/eventbus/ClusteredEventBusTestBase.java
Patch:
@@ -220,7 +220,7 @@ private void sendMsg() {
       boolean unregisterCalled;
 
       @Override
-      public void start(Future<Void> startFuture) throws Exception {
+      public void start(Promise<Void> startFuture) throws Exception {
         EventBus eventBus = getVertx().eventBus();
         MessageConsumer<String> consumer = eventBus.consumer("whatever");
         consumer.handler(m -> {

File: src/test/java/io/vertx/core/http/HttpServerCloseHookTest.java
Patch:
@@ -12,7 +12,7 @@
 package io.vertx.core.http;
 
 import io.vertx.core.AbstractVerticle;
-import io.vertx.core.Future;
+import io.vertx.core.Promise;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.net.PfxOptions;
 import io.vertx.test.core.VertxTestBase;
@@ -34,7 +34,7 @@ public void deployHandlerShouldGetException() {
   private static class TestVerticle extends AbstractVerticle {
 
     @Override
-    public void start(Future<Void> startFuture) {
+    public void start(Promise<Void> startFuture) {
       HttpServerOptions invalidOptions = new HttpServerOptions()
         .setSsl(true)
         .setPfxTrustOptions(new PfxOptions().setValue(Buffer.buffer("boom")));

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -3091,7 +3091,7 @@ public void testWorkerServer() throws Exception {
     String expected = TestUtils.randomAlphaString(2000);
     vertx.deployVerticle(new AbstractVerticle() {
       @Override
-      public void start(Future<Void> startFuture) throws Exception {
+      public void start(Promise<Void> startFuture) throws Exception {
         NetServer server = vertx.createNetServer();
         server.connectHandler(so -> {
           Buffer received = Buffer.buffer();

File: src/test/java/io/vertx/core/shareddata/AsyncMapTest.java
Patch:
@@ -13,6 +13,7 @@
 
 import io.vertx.core.CompositeFuture;
 import io.vertx.core.Future;
+import io.vertx.core.Promise;
 import io.vertx.core.Vertx;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.json.JsonArray;
@@ -684,11 +685,11 @@ protected Map<JsonObject, Buffer> genJsonToBuffer(int size) {
   protected void loadData(Map<JsonObject, Buffer> map, BiConsumer<Vertx, AsyncMap<JsonObject, Buffer>> test) {
     List<Future> futures = new ArrayList<>(map.size());
     map.forEach((key, value) -> {
-      Future future = Future.future();
+      Promise future = Promise.promise();
       getVertx().sharedData().getAsyncMap("foo", onSuccess(asyncMap -> {
         asyncMap.put(key, value, future);
       }));
-      futures.add(future);
+      futures.add(future.future());
     });
     CompositeFuture.all(futures).setHandler(onSuccess(cf -> {
       Vertx v = getVertx();

File: src/test/java/io/vertx/test/verticles/SimpleServer.java
Patch:
@@ -12,7 +12,7 @@
 package io.vertx.test.verticles;
 
 import io.vertx.core.AbstractVerticle;
-import io.vertx.core.Future;
+import io.vertx.core.Promise;
 import io.vertx.core.http.HttpServer;
 import io.vertx.core.http.HttpServerOptions;
 
@@ -22,7 +22,7 @@
 public class SimpleServer extends AbstractVerticle {
 
   @Override
-  public void start(Future<Void> startFuture) throws Exception {
+  public void start(Promise<Void> startFuture) throws Exception {
     HttpServer server = vertx.createHttpServer(new HttpServerOptions().setPort(8080));
     server.requestHandler(req -> req.response().end());
     server.listen(res -> {

File: src/test/java/io/vertx/test/verticles/TestVerticle2.java
Patch:
@@ -13,7 +13,7 @@
 
 import io.vertx.core.AbstractVerticle;
 import io.vertx.core.Context;
-import io.vertx.core.Future;
+import io.vertx.core.Promise;
 
 import java.util.HashSet;
 import java.util.Set;
@@ -38,9 +38,9 @@ public void start() throws Exception {
   }
 
   @Override
-  public void stop(Future<Void> stopFuture) throws Exception {
+  public void stop(Promise<Void> stopPromise) throws Exception {
     vertx.eventBus().send("tvstopped", "stopped", reply -> {
-      stopFuture.complete(null);
+      stopPromise.complete(null);
     });
   }
 }

File: src/test/java/io/vertx/test/verticles/sourceverticle/SourceVerticle.java
Patch:
@@ -13,7 +13,7 @@
 
 import io.vertx.core.AbstractVerticle;
 import io.vertx.core.DeploymentOptions;
-import io.vertx.core.Future;
+import io.vertx.core.Promise;
 import io.vertx.test.verticles.sourceverticle.somepackage.OtherSourceVerticle;
 
 /**
@@ -23,7 +23,7 @@ public class SourceVerticle extends AbstractVerticle {
 
 
   @Override
-  public void start(Future<Void> startFuture) throws Exception {
+  public void start(Promise<Void> startFuture) throws Exception {
     vertx.deployVerticle("java:" + OtherSourceVerticle.class.getName().replace('.', '/') + ".java", new DeploymentOptions(), ar -> {
       if (ar.succeeded()) {
         startFuture.complete((Void) null);

File: src/test/java/io/vertx/core/json/codecs/MyJsonObjectPojo.java
Patch:
@@ -41,7 +41,7 @@ public boolean equals(Object o) {
     if (this == o) return true;
     if (o == null || getClass() != o.getClass()) return false;
     MyJsonObjectPojo that = (MyJsonObjectPojo) o;
-    return value == that.value;
+    return Objects.equals(value, that.value);
   }
 
   @Override

File: src/main/java/io/vertx/core/cli/converters/Converter.java
Patch:
@@ -16,6 +16,7 @@
  *
  * @author Clement Escoffier <clement@apache.org>
  */
+@FunctionalInterface
 public interface Converter<T> {
 
   T fromString(String s);

File: src/main/java/io/vertx/core/http/impl/VertxHttp2NetSocket.java
Patch:
@@ -344,12 +344,12 @@ Handler<Void> closeHandler() {
   }
 
   @Override
-  public NetSocket upgradeToSsl(Handler<Void> handler) {
+  public NetSocket upgradeToSsl(Handler<AsyncResult<Void>> handler) {
     throw new UnsupportedOperationException("Cannot upgrade HTTP/2 stream to SSL");
   }
 
   @Override
-  public NetSocket upgradeToSsl(String serverName, Handler<Void> handler) {
+  public NetSocket upgradeToSsl(String serverName, Handler<AsyncResult<Void>> handler) {
     throw new UnsupportedOperationException("Cannot upgrade HTTP/2 stream to SSL");
   }
 

File: src/main/java/io/vertx/core/net/NetSocket.java
Patch:
@@ -248,7 +248,7 @@ default NetSocket sendFile(String filename, long offset, Handler<AsyncResult<Voi
    * @return a reference to this, so the API can be used fluently
    */
   @Fluent
-  NetSocket upgradeToSsl(Handler<Void> handler);
+  NetSocket upgradeToSsl(Handler<AsyncResult<Void>> handler);
 
   /**
    * Upgrade channel to use SSL/TLS. Be aware that for this to work SSL must be configured.
@@ -258,7 +258,7 @@ default NetSocket sendFile(String filename, long offset, Handler<AsyncResult<Voi
    * @return a reference to this, so the API can be used fluently
    */
   @Fluent
-  NetSocket upgradeToSsl(String serverName, Handler<Void> handler);
+  NetSocket upgradeToSsl(String serverName, Handler<AsyncResult<Void>> handler);
 
   /**
    * @return true if this {@link io.vertx.core.net.NetSocket} is encrypted via SSL/TLS.

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -338,6 +338,9 @@ void handleHeaders(Http2Headers headers, StreamPriority streamPriority, boolean
           writeReset(0x01 /* PROTOCOL_ERROR */);
           return;
         }
+
+        headers.remove(":status");
+
         response = new HttpClientResponseImpl(
             request,
             HttpVersion.HTTP_2,

File: src/test/java/io/vertx/core/http/Http2ClientTest.java
Patch:
@@ -228,6 +228,7 @@ public void testHeaders() throws Exception {
       assertEquals(2, req.headers().getAll("juu_request").size());
       assertEquals("juu_request_value_1", req.headers().getAll("juu_request").get(0));
       assertEquals("juu_request_value_2", req.headers().getAll("juu_request").get(1));
+      assertEquals(new HashSet<>(Arrays.asList("foo_request", "bar_request", "juu_request")), new HashSet<>(req.headers().names()));
       reqCount.incrementAndGet();
       HttpServerResponse resp = req.response();
       resp.putHeader("content-type", "text/plain");
@@ -247,12 +248,12 @@ public void testHeaders() throws Exception {
         assertEquals(200, resp.statusCode());
         assertEquals("OK", resp.statusMessage());
         assertEquals("text/plain", resp.getHeader("content-type"));
-        assertEquals("200", resp.getHeader(":status"));
         assertEquals("foo_value", resp.getHeader("foo_response"));
         assertEquals("bar_value", resp.getHeader("bar_response"));
         assertEquals(2, resp.headers().getAll("juu_response").size());
         assertEquals("juu_value_1", resp.headers().getAll("juu_response").get(0));
         assertEquals("juu_value_2", resp.headers().getAll("juu_response").get(1));
+        assertEquals(new HashSet<>(Arrays.asList("content-type", "content-length", "foo_response", "bar_response", "juu_response")), new HashSet<>(resp.headers().names()));
         resp.endHandler(v -> {
           assertOnIOContext(ctx);
           testComplete();

File: src/test/java/io/vertx/core/http/Http2Test.java
Patch:
@@ -38,7 +38,7 @@ public class Http2Test extends HttpTest {
 
   @Override
   protected HttpServerOptions createBaseServerOptions() {
-    return Http2TestBase.createHttp2ServerOptions(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST).setHandle100ContinueAutomatically(true);
+    return Http2TestBase.createHttp2ServerOptions(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST);
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -521,7 +521,7 @@ void handleException(Throwable cause) {
         requestEnded = this.requestEnded;
       }
       if (request != null) {
-        if (response == null) {
+        if (response == null || response.statusCode() == 100) {
           request.handleException(cause);
         } else {
           if (!requestEnded) {

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -362,7 +362,7 @@ void handleException(Throwable exception) {
       HttpClientRequestBase req;
       HttpClientResponseImpl resp;
       synchronized (conn) {
-        req = (!requestEnded || response == null) ? request : null;
+        req = (!requestEnded || response == null || response.statusCode() == 100) ? request : null;
         resp = response;
       }
       if (req != null) {

File: src/main/java/io/vertx/core/Context.java
Patch:
@@ -266,6 +266,6 @@ static boolean isOnVertxThread() {
   void addCloseHook(Closeable hook);
 
   @GenIgnore(GenIgnore.PERMITTED_TYPE)
-  void removeCloseHook(Closeable hook);
+  boolean removeCloseHook(Closeable hook);
 
 }

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -262,7 +262,8 @@ public void testClusterUnregistration() {
       fail("Should not receive message");
     });
     consumer.completionHandler(ar -> {
-      assertEquals(Collections.emptyList(), metrics.getRegistrations());
+      List<HandlerMetric> registrations = metrics.getRegistrations();
+      assertEquals(Collections.emptyList(), registrations);
       testComplete();
     });
     consumer.unregister();

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -276,7 +276,7 @@ private <T> LocalRegistrationResult<T> addLocalRegistration(String address, Hand
     }
     registration.setHandlerContext(context);
 
-    HandlerHolder<T> holder = new HandlerHolder<>(metrics, registration, replyHandler, localOnly, context);
+    HandlerHolder<T> holder = new HandlerHolder<>(registration, replyHandler, localOnly, context);
 
     ConcurrentCyclicSequence<HandlerHolder> handlers = new ConcurrentCyclicSequence<HandlerHolder>().add(holder);
     ConcurrentCyclicSequence<HandlerHolder> actualHandlers = handlerMap.merge(

File: src/test/java/io/vertx/test/fakemetrics/FakeEventBusMetrics.java
Patch:
@@ -80,6 +80,9 @@ public HandlerMetric handlerRegistered(String address, String repliedAddress) {
   }
 
   public void handlerUnregistered(HandlerMetric handler) {
+    if (handler == null) {
+      throw new NullPointerException("Must not be null");
+    }
     registrations.remove(handler);
   }
 

File: src/test/java/io/vertx/core/DeploymentTest.java
Patch:
@@ -1206,7 +1206,7 @@ public void testUndeployAllNoDeployments() throws Exception {
   }
 
   @Test
-  public void testGetInstanceCount() throws Exception {
+  public void testGetInstanceCount() {
     class MultiInstanceVerticle extends AbstractVerticle {
       @Override
       public void start() {
@@ -1219,8 +1219,6 @@ public void start() {
       testComplete();
     });
     await();
-    Deployment deployment = ((VertxInternal) vertx).getDeployment(vertx.deploymentIDs().iterator().next());
-    vertx.undeploy(deployment.deploymentID());
   }
 
   @Test

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -3138,9 +3138,9 @@ private void testResetClientRequestNotYetSent(boolean keepAlive, boolean pipelin
       awaitLatch(latch);
       client.close();
       client = vertx.createHttpClient(new HttpClientOptions().setMaxPoolSize(1).setKeepAlive(keepAlive).setPipelining(pipelined));
-      HttpClientRequest post = client.post(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI, resp -> {
+      HttpClientRequest post = client.post(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI, onSuccess(resp -> {
         fail();
-      });
+      }));
       post.setChunked(true).write(TestUtils.randomBuffer(1024));
       assertTrue(post.reset());
       client.getNow(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI, resp -> {

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -874,7 +874,7 @@ public synchronized void handleInterestedOpsChanged() {
       if (current != null) {
         current.context.dispatch(v -> current.request.handleDrained());
       } else if (ws != null) {
-        ws.writable();
+        ws.handleDrained();
       }
     }
   }

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -433,7 +433,7 @@ public synchronized void handleInterestedOpsChanged() {
       if (responseInProgress != null) {
         responseInProgress.context.dispatch(v -> responseInProgress.response().handleDrained());
       } else if (ws != null) {
-        ws.writable();
+        ws.handleDrained();
       }
     }
   }

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -427,7 +427,7 @@ public WebSocketBase pongHandler(Handler<Buffer> handler) {
     }
   }
 
-  void writable() {
+  void handleDrained() {
     if (drainHandler != null) {
       Handler<Void> dh = drainHandler;
       drainHandler = null;

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -16,7 +16,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http.*;
-import io.netty.util.concurrent.GenericFutureListener;
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
@@ -82,7 +81,7 @@ public class HttpServerResponseImpl implements HttpServerResponse {
   private long bytesWritten;
   private NetSocket netSocket;
 
-  HttpServerResponseImpl(final VertxInternal vertx, ContextInternal context, Http1xServerConnection conn, DefaultHttpRequest request, Object requestMetric) {
+  HttpServerResponseImpl(final VertxInternal vertx, ContextInternal context, Http1xServerConnection conn, HttpRequest request, Object requestMetric) {
     this.vertx = vertx;
     this.conn = conn;
     this.context = context;

File: src/main/java/io/vertx/core/http/impl/HttpUtils.java
Patch:
@@ -626,7 +626,7 @@ static void sendError(Channel ch, HttpResponseStatus status, CharSequence err) {
     ch.writeAndFlush(resp);
   }
 
-  static String getWebSocketLocation(HttpRequest req, boolean ssl) throws Exception {
+  static String getWebSocketLocation(HttpServerRequest req, boolean ssl) throws Exception {
     String prefix;
     if (ssl) {
       prefix = "ws://";

File: src/main/java/io/vertx/core/http/impl/WebSocketRequestHandler.java
Patch:
@@ -13,12 +13,12 @@
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
 import io.vertx.core.Handler;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpServerRequest;
 import io.vertx.core.spi.metrics.HttpServerMetrics;
 
-import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
 import static io.vertx.core.http.HttpHeaders.UPGRADE;
 import static io.vertx.core.http.HttpHeaders.WEBSOCKET;
 import static io.vertx.core.http.impl.HttpUtils.SC_SWITCHING_PROTOCOLS;
@@ -80,7 +80,7 @@ private void handle(HttpServerRequestImpl req) {
    * Handle the request once we have the full body.
    */
   private void handle(HttpServerRequestImpl req, Buffer body) {
-    DefaultHttpRequest nettyReq = req.getRequest();
+    HttpRequest nettyReq = req.nettyRequest();
     nettyReq = new DefaultFullHttpRequest(
       nettyReq.protocolVersion(),
       nettyReq.method(),

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -363,7 +363,7 @@ private WebSocketServerHandshaker createHandshaker(HttpRequest request) {
     }
     String wsURL;
     try {
-      wsURL = HttpUtils.getWebSocketLocation(request, isSSL());
+      wsURL = HttpUtils.getWebSocketLocation(request, isSsl());
     } catch (Exception e) {
       HttpUtils.sendError(ch, BAD_REQUEST, "Invalid request URI");
       return null;

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -379,7 +379,7 @@ public void writeHead(HttpMethod method, String rawMethod, String uri, MultiMap
         h.authority(hostHeader);
       } else {
         h.path(uri);
-        h.scheme(conn.isSSL() ? "https" : "http");
+        h.scheme(conn.isSsl() ? "https" : "http");
         if (hostHeader != null) {
           h.authority(hostHeader);
         }

File: src/main/java/io/vertx/core/http/impl/HttpServerRequestImpl.java
Patch:
@@ -381,7 +381,7 @@ public String scheme() {
 
   @Override
   public boolean isSSL() {
-    return conn.isSSL();
+    return conn.isSsl();
   }
 
   @Override

File: src/test/java/io/vertx/core/FutureTest.java
Patch:
@@ -930,12 +930,12 @@ public void handle(AsyncResult<T> asyncResult) {
     }
 
     DefaultCompleterTestFuture<Object> successFuture = new DefaultCompleterTestFuture<>();
-    successFuture.completer().handle(succeededAsyncResult);
+    successFuture.handle(succeededAsyncResult);
     assertTrue(successFuture.succeeded);
     assertEquals(succeededAsyncResult.result(), successFuture.result);
 
     DefaultCompleterTestFuture<Object> failureFuture = new DefaultCompleterTestFuture<>();
-    failureFuture.completer().handle(failedAsyncResult);
+    failureFuture.handle(failedAsyncResult);
     assertTrue(failureFuture.failed);
     assertEquals(failedAsyncResult.cause(), failureFuture.cause);
   }

File: src/test/java/io/vertx/test/verticles/FaultToleranceVerticle.java
Patch:
@@ -43,11 +43,11 @@ public void start() throws Exception {
     for (int i = 0; i < numAddresses; i++) {
       Future<Void> registrationFuture = Future.future();
       registrationFutures.add(registrationFuture);
-      vertx.eventBus().consumer(createAddress(id, i), msg -> msg.reply("pong")).completionHandler(registrationFuture.completer());
+      vertx.eventBus().consumer(createAddress(id, i), msg -> msg.reply("pong")).completionHandler(registrationFuture);
     }
     Future<Void> registrationFuture = Future.future();
     registrationFutures.add(registrationFuture);
-    vertx.eventBus().consumer("ping", this::ping).completionHandler(registrationFuture.completer());
+    vertx.eventBus().consumer("ping", this::ping).completionHandler(registrationFuture);
     CompositeFuture.all(registrationFutures).setHandler(ar -> {
       if (ar.succeeded()) {
         vertx.eventBus().send("control", "start");

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -3399,7 +3399,7 @@ public void testPausedDuringLastChunk() throws Exception {
       });
     });
     startServer();
-    client.connect(1234, "localhost", onSuccess(so -> {
+    client.connect(testAddress, "localhost", onSuccess(so -> {
       so.close();
     }));
     await();

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -478,7 +478,7 @@ private void trace(Object reply, Throwable failure) {
     void fail(ReplyException failure) {
       registration.unregister();
       if (metrics != null) {
-        metrics.replyFailure(registration.address, failure.failureType());
+        metrics.replyFailure(registration.repliedAddress, failure.failureType());
       }
       trace(null, failure);
       result.tryFail(failure);

File: src/test/java/io/vertx/core/spi/metrics/MetricsTest.java
Patch:
@@ -423,7 +423,7 @@ public void testReplyFailureNoHandlers() throws Exception {
     });
     awaitLatch(latch);
     FakeEventBusMetrics metrics = FakeMetricsBase.getMetrics(eb);
-    assertEquals(Collections.singletonList("__vertx.reply.1"), metrics.getReplyFailureAddresses());
+    assertEquals(Collections.singletonList("some-address1"), metrics.getReplyFailureAddresses());
     assertEquals(Collections.singletonList(ReplyFailure.NO_HANDLERS), metrics.getReplyFailures());
   }
 
@@ -482,7 +482,7 @@ public void testReplyFailureRecipientFailure() throws Exception {
       latch.countDown();
     });
     awaitLatch(latch);
-    assertEquals(Collections.singletonList(replyAddress.get()), metrics.getReplyFailureAddresses());
+    assertEquals(Collections.singletonList("foo"), metrics.getReplyFailureAddresses());
     assertEquals(Collections.singletonList(ReplyFailure.RECIPIENT_FAILURE), metrics.getReplyFailures());
   }
 

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -385,7 +385,7 @@ protected void handleClosed() {
         metrics.close();
       }
       if (handler != null) {
-        handler.handle(null);
+        context.dispatch(handler);
       }
     }
 
@@ -416,7 +416,7 @@ void handlePacket(io.vertx.core.datagram.DatagramPacket packet) {
         }
       }
       if (handler != null) {
-        handler.handle(packet);
+        context.dispatch(packet, handler);
       }
     }
   }

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ConnectionHolder.java
Patch:
@@ -122,7 +122,7 @@ private void schedulePing() {
         close();
       });
       ClusteredMessage pingMessage =
-        new ClusteredMessage<>(serverID, PING_ADDRESS, null, null, null, new PingMessageCodec(), true, eventBus);
+        new ClusteredMessage<>(serverID, PING_ADDRESS, null, null, null, new PingMessageCodec(), true, true, eventBus);
       Buffer data = pingMessage.encodeToWire();
       socket.write(data);
     });

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -147,12 +147,12 @@ void getConnection(ContextInternal ctx, String peerHost, boolean ssl, int port,
             metrics.dequeueRequest(endpoint.metric, metric);
           }
 
-          handler.handle(Future.succeededFuture(conn));
+          ctx.schedule(Future.succeededFuture(conn), handler);
         } else {
           if (metrics != null) {
             metrics.dequeueRequest(endpoint.metric, metric);
           }
-          handler.handle(Future.failedFuture(ar.cause()));
+          ctx.schedule(Future.failedFuture(ar.cause()), handler);
         }
       })) {
         break;

File: src/main/java/io/vertx/core/http/impl/HttpClientConnection.java
Patch:
@@ -29,7 +29,7 @@ public interface HttpClientConnection extends HttpConnection {
 
   void close();
 
-  void createStream(Handler<AsyncResult<HttpClientStream>> handler);
+  void createStream(ContextInternal context, Handler<AsyncResult<HttpClientStream>> handler);
 
   ContextInternal getContext();
 

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -951,11 +951,11 @@ private void getConnectionForWebsocket(ContextInternal ctx,
     websocketCM.getConnection(ctx, host, ssl, port, host, ar -> {
       if (ar.succeeded()) {
         HttpClientConnection conn = ar.result();
-        conn.getContext().executeFromIO(v -> {
+        conn.getContext().dispatch(v -> {
           handler.handle((Http1xClientConnection) conn);
         });
       } else {
-        ctx.executeFromIO(v -> {
+        ctx.dispatch(v -> {
           connectionExceptionHandler.handle(ar.cause());
         });
       }
@@ -970,7 +970,7 @@ void getConnectionForRequest(ContextInternal ctx,
                                Handler<AsyncResult<HttpClientStream>> handler) {
     httpCM.getConnection(ctx, peerHost, ssl, port, host, ar -> {
       if (ar.succeeded()) {
-        ar.result().createStream(handler);
+        ar.result().createStream(ctx, handler);
       } else {
         handler.handle(Future.failedFuture(ar.cause()));
       }

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -44,7 +44,7 @@ public HttpClientRequestPushPromise(
       MultiMap headers) {
     super(client, ssl, method, host, port, uri);
     this.conn = conn;
-    this.stream = new Http2ClientConnection.Http2ClientStream(conn, this, stream, false);
+    this.stream = new Http2ClientConnection.Http2ClientStream(conn, conn.getContext(), this, stream, false);
     this.rawMethod = rawMethod;
     this.headers = headers;
     this.respHandler = Future.future();

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -12,18 +12,18 @@
 package io.vertx.core.http.impl;
 
 import io.netty.buffer.ByteBuf;
-import io.vertx.core.Context;
 import io.vertx.core.MultiMap;
 import io.vertx.core.http.HttpConnection;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.http.StreamPriority;
+import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.net.NetSocket;
 
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-interface HttpClientStream {
+public interface HttpClientStream {
 
   /**
    * @return the stream id, {@code 1} denotes the first stream, HTTP/1 is a simple sequence, HTTP/2
@@ -37,7 +37,7 @@ interface HttpClientStream {
   HttpVersion version();
 
   HttpConnection connection();
-  Context getContext();
+  ContextInternal getContext();
 
   void writeHead(HttpMethod method, String rawMethod, String uri, MultiMap headers, String hostHeader, boolean chunked, ByteBuf buf, boolean end, StreamPriority priority);
   void writeBuffer(ByteBuf buf, boolean end);

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -376,7 +376,7 @@ VertxHttp2ConnectionHandler<Http2ServerConnection> buildHttp2ConnectionHandler(H
       }
       if (holder.handler.connectionHandler != null) {
         holder.context.executeFromIO(v -> {
-          holder.handler.connectionHandler.handle(conn);
+          holder.context.dispatch(conn, holder.handler.connectionHandler);
         });
       }
     });

File: src/main/java/io/vertx/core/http/impl/NettyFileUploadDataFactory.java
Patch:
@@ -19,6 +19,7 @@
 import io.vertx.core.Vertx;
 import io.vertx.core.http.HttpServerFileUpload;
 import io.vertx.core.http.HttpServerRequest;
+import io.vertx.core.impl.ContextInternal;
 
 import java.nio.charset.Charset;
 import java.util.function.Supplier;
@@ -47,7 +48,7 @@ public FileUpload createFileUpload(HttpRequest httpRequest, String name, String
       size);
     Handler<HttpServerFileUpload> uploadHandler = lazyUploadHandler.get();
     if (uploadHandler != null) {
-      uploadHandler.handle(upload);
+      ((ContextInternal)context).dispatch(upload, uploadHandler);
     }
     return nettyUpload;
   }

File: src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -16,6 +16,7 @@
 import io.vertx.core.MultiMap;
 import io.vertx.core.http.ServerWebSocket;
 import io.vertx.core.http.WebSocketFrame;
+import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 
 import javax.net.ssl.SSLPeerUnverifiedException;
@@ -48,10 +49,10 @@ public class ServerWebSocketImpl extends WebSocketImplBase<ServerWebSocket> impl
   private Integer status;
   private Future<Integer> handshakeFuture;
 
-  public ServerWebSocketImpl(VertxInternal vertx, String uri, String path, String query, MultiMap headers,
+  public ServerWebSocketImpl(VertxInternal vertx, ContextInternal context, String uri, String path, String query, MultiMap headers,
                              Http1xConnectionBase conn, boolean supportsContinuation, Function<ServerWebSocketImpl, String> handshaker,
                              int maxWebSocketFrameSize, int maxWebSocketMessageSize) {
-    super(vertx, conn, supportsContinuation, maxWebSocketFrameSize, maxWebSocketMessageSize);
+    super(vertx, context, conn, supportsContinuation, maxWebSocketFrameSize, maxWebSocketMessageSize);
     this.uri = uri;
     this.path = path;
     this.query = query;

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -42,12 +42,12 @@ abstract class VertxHttp2Stream<C extends Http2ConnectionBase> {
   private boolean writable;
   private StreamPriority priority;
 
-  VertxHttp2Stream(C conn, Http2Stream stream, boolean writable) {
+  VertxHttp2Stream(C conn, ContextInternal context, Http2Stream stream, boolean writable) {
     this.conn = conn;
     this.vertx = conn.vertx();
     this.handlerContext = conn.handlerContext;
     this.stream = stream;
-    this.context = conn.getContext();
+    this.context = context;
     this.writable = writable;
     this.pending = new InboundBuffer<>(context, 5);
     this.priority = HttpUtils.DEFAULT_STREAM_PRIORITY;

File: src/main/java/io/vertx/core/http/impl/WebSocketImpl.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.http.impl;
 
 import io.vertx.core.http.WebSocket;
+import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.spi.metrics.HttpClientMetrics;
 
@@ -26,10 +27,10 @@
  */
 public class WebSocketImpl extends WebSocketImplBase<WebSocket> implements WebSocket {
 
-  public WebSocketImpl(VertxInternal vertx,
+  public WebSocketImpl(VertxInternal vertx, ContextInternal context,
                        Http1xClientConnection conn, boolean supportsContinuation,
                        int maxWebSocketFrameSize, int maxWebSocketMessageSize) {
-    super(vertx, conn, supportsContinuation, maxWebSocketFrameSize, maxWebSocketMessageSize);
+    super(vertx, context, conn, supportsContinuation, maxWebSocketFrameSize, maxWebSocketMessageSize);
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/Deployment.java
Patch:
@@ -15,6 +15,7 @@
 import io.vertx.core.DeploymentOptions;
 import io.vertx.core.Handler;
 import io.vertx.core.Verticle;
+import io.vertx.core.json.JsonObject;
 
 import java.util.Set;
 
@@ -31,6 +32,8 @@ public interface Deployment {
 
   void doUndeploy(ContextInternal undeployingContext, Handler<AsyncResult<Void>> completionHandler);
 
+  JsonObject config();
+
   String deploymentID();
 
   String verticleIdentifier();

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -16,7 +16,6 @@
 import io.netty.resolver.AddressResolverGroup;
 import io.vertx.core.*;
 import io.vertx.core.http.impl.HttpServerImpl;
-import io.vertx.core.json.JsonObject;
 import io.vertx.core.net.impl.NetServerImpl;
 import io.vertx.core.net.impl.ServerID;
 import io.vertx.core.net.impl.transport.Transport;
@@ -65,12 +64,12 @@ public interface VertxInternal extends Vertx {
   /**
    * @return event loop context
    */
-  EventLoopContext createEventLoopContext(String deploymentID, WorkerPool workerPool, JsonObject config, ClassLoader tccl);
+  EventLoopContext createEventLoopContext(Deployment deployment, WorkerPool workerPool, ClassLoader tccl);
 
   /**
    * @return worker loop context
    */
-  ContextImpl createWorkerContext(String deploymentID, WorkerPool pool, JsonObject config, ClassLoader tccl);
+  ContextInternal createWorkerContext(Deployment deployment, WorkerPool pool, ClassLoader tccl);
 
   @Override
   WorkerExecutorInternal createSharedWorkerExecutor(String name);
@@ -128,4 +127,5 @@ public interface VertxInternal extends Vertx {
   void addCloseHook(Closeable hook);
 
   void removeCloseHook(Closeable hook);
+
 }

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -56,7 +56,7 @@ public synchronized <T> void executeBlocking(Handler<Future<T>> blockingCodeHand
       throw new IllegalStateException("Worker executor closed");
     }
     ContextImpl context = (ContextImpl) ctx.owner().getOrCreateContext();
-    context.executeBlocking(blockingCodeHandler, asyncResultHandler, pool.executor(), ordered ? context.orderedTasks : null, pool.metrics());
+    ContextImpl.executeBlocking(context, blockingCodeHandler, asyncResultHandler, pool, ordered ? context.orderedTasks : null);
   }
 
   @Override

File: src/test/benchmarks/io/vertx/benchmarks/HttpServerHandlerBenchmark.java
Patch:
@@ -222,7 +222,7 @@ protected void encodeHeaders(HttpHeaders headers, ByteBuf buf) {
 
 
 
-    ContextInternal context = new EventLoopContext(vertx, vertxChannel.eventLoop(), null, null, null, new JsonObject(), Thread.currentThread().getContextClassLoader());
+    ContextInternal context = new EventLoopContext(vertx, null, vertxChannel.eventLoop(), null, null, null, Thread.currentThread().getContextClassLoader());
     Handler<HttpServerRequest> app = request -> {
       HttpServerResponse response = request.response();
       MultiMap headers = response.headers();

File: src/test/java/io/vertx/core/eventbus/EventBusFlowControlTest.java
Patch:
@@ -173,7 +173,7 @@ public void testResumePausedProducer() {
       if (sequence.isEmpty()) {
         handlerContext.set(Vertx.currentContext());
       } else {
-        assertEquals(Vertx.currentContext(), handlerContext.get());
+        assertOnIOContext(handlerContext.get());
       }
       sequence.add(msg.body());
     });

File: src/test/java/io/vertx/core/http/Http2SettingsTest.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * @author Thomas Segismont
  */
-public class Http2SettingsTest extends HttpTestBase {
+public class Http2SettingsTest {
 
   long[] min = { 0, 0, 0, 0, 0x4000, 0 };
   long[] max = { 0xFFFFFFFFL, 1, 0xFFFFFFFFL, Integer.MAX_VALUE, 0xFFFFFF, Integer.MAX_VALUE };

File: src/main/java/io/vertx/core/http/HttpServerFileUpload.java
Patch:
@@ -86,7 +86,7 @@ public interface HttpServerFileUpload extends ReadStream<Buffer> {
   long size();
 
   /**
-   * @return true if the size of the upload can be retrieved via {@link #size()}.
+   * @return {@code true} if the size of the upload can be retrieved via {@link #size()}.
    */
   boolean isSizeAvailable();
 

File: src/main/java/io/vertx/core/http/impl/NettyFileUpload.java
Patch:
@@ -48,15 +48,15 @@ final class NettyFileUpload implements FileUpload {
   public void setContent(ByteBuf channelBuffer) throws IOException {
     completed = true;
     upload.receiveData(Buffer.buffer(channelBuffer));
-    upload.complete();
+    upload.end();
   }
 
   @Override
   public void addContent(ByteBuf channelBuffer, boolean last) throws IOException {
     upload.receiveData(Buffer.buffer(channelBuffer));
     if (last) {
       completed = true;
-      upload.complete();
+      upload.end();
     }
   }
 

File: src/main/java/io/vertx/core/Starter.java
Patch:
@@ -238,8 +238,7 @@ private Vertx startVertx(boolean clustered, boolean ha, Args args) {
         return null;
       }
       if (result.get().failed()) {
-        log.error("Failed to form cluster");
-        result.get().cause().printStackTrace();
+        log.error("Failed to form cluster", result.get().cause());
         return null;
       }
       vertx = result.get().result();

File: src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
Patch:
@@ -402,7 +402,6 @@ protected void startAsBackgroundApplication(Handler<Void> onCompletion) {
   protected void deploy() {
     deploy(mainVerticle, vertx, deploymentOptions, res -> {
       if (res.failed()) {
-        res.cause().printStackTrace();
         handleDeployFailed(res.cause());
       }
     });

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -292,7 +292,7 @@ private void sendFileRegion(RandomAccessFile file, long offset, long length, Cha
         if (future.isSuccess()) {
           sendFileRegion(file, offset + MAX_REGION_SIZE, length - MAX_REGION_SIZE, writeFuture);
         } else {
-          future.cause().printStackTrace();
+          log.error(future.cause().getMessage(), future.cause());
           writeFuture.setFailure(future.cause());
         }
       });

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -131,7 +131,7 @@ public void close() {
 
   @Override
   public boolean isMetricsEnabled() {
-    return metrics != null && metrics.isEnabled();
+    return metrics != null;
   }
 
   @Override

File: src/test/java/io/vertx/core/file/FileResolverTestBase.java
Patch:
@@ -102,7 +102,7 @@ public void testResolveFileFromClasspath() throws Exception {
 
   @Test
   public void testResolveFileFromClasspathDisableCaching() throws Exception {
-    VertxInternal vertx = (VertxInternal) Vertx.vertx(new VertxOptions().setFileResolverCachingEnabled(false));
+    VertxInternal vertx = (VertxInternal) Vertx.vertx(new VertxOptions().setFileSystemOptions(new FileSystemOptions().setFileCachingEnabled(true)));
     try {
       for (int i = 0; i < 2; i++) {
         File file = vertx.resolveFile("afile.html");
@@ -291,7 +291,7 @@ public void testDisableCaching() throws Exception {
   }
 
   private void testCaching(boolean enabled) throws Exception {
-    VertxInternal vertx = (VertxInternal) Vertx.vertx(new VertxOptions().setFileResolverCachingEnabled(enabled));
+    VertxInternal vertx = (VertxInternal) Vertx.vertx(new VertxOptions().setFileSystemOptions(new FileSystemOptions().setFileCachingEnabled(enabled)));
     File tmp = File.createTempFile("vertx", ".bin");
     tmp.deleteOnExit();
     URL url = tmp.toURI().toURL();

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -826,7 +826,6 @@ public void testDefaultServerOptionsJson() {
     assertEquals(def.getMaxWebsocketFrameSize(), json.getMaxWebsocketFrameSize());
     assertEquals(def.getWebsocketSubProtocols(), json.getWebsocketSubProtocols());
     assertEquals(def.isCompressionSupported(), json.isCompressionSupported());
-    assertEquals(def.isClientAuthRequired(), json.isClientAuthRequired());
     assertEquals(def.getCrlPaths(), json.getCrlPaths());
     assertEquals(def.getCrlValues(), json.getCrlValues());
     assertEquals(def.getAcceptBacklog(), json.getAcceptBacklog());

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -579,13 +579,11 @@ public void testCopyServerOptions() {
   public void testDefaultServerOptionsJson() {
     NetServerOptions def = new NetServerOptions();
     NetServerOptions json = new NetServerOptions(new JsonObject());
-    assertEquals(def.isClientAuthRequired(), json.isClientAuthRequired());
     assertEquals(def.getCrlPaths(), json.getCrlPaths());
     assertEquals(def.getCrlValues(), json.getCrlValues());
     assertEquals(def.getAcceptBacklog(), json.getAcceptBacklog());
     assertEquals(def.getPort(), json.getPort());
     assertEquals(def.getHost(), json.getHost());
-    assertEquals(def.isClientAuthRequired(), json.isClientAuthRequired());
     assertEquals(def.getCrlPaths(), json.getCrlPaths());
     assertEquals(def.getCrlValues(), json.getCrlValues());
     assertEquals(def.getAcceptBacklog(), json.getAcceptBacklog());

File: src/test/java/io/vertx/core/ComplexHATest.java
Patch:
@@ -230,7 +230,7 @@ protected int checkHasDeployments(int pos, int prevPos) {
     for (Deployment prev: prevSet) {
       boolean contains = false;
       for (Deployment curr: currSet) {
-        if (curr.verticleIdentifier().equals(prev.verticleIdentifier()) && curr.deploymentOptions().equals(prev.deploymentOptions())) {
+        if (curr.verticleIdentifier().equals(prev.verticleIdentifier()) && curr.deploymentOptions().toJson().equals(prev.deploymentOptions().toJson())) {
           contains = true;
           break;
         }

File: src/test/java/io/vertx/core/HATest.java
Patch:
@@ -403,7 +403,7 @@ protected void checkDeploymentExists(int pos, String verticleName, DeploymentOpt
     VertxInternal vi = (VertxInternal)vertices[pos];
     for (String deploymentID: vi.deploymentIDs()) {
       Deployment dep = vi.getDeployment(deploymentID);
-      if (verticleName.equals(dep.verticleIdentifier()) && options.equals(dep.deploymentOptions())) {
+      if (verticleName.equals(dep.verticleIdentifier()) && options.toJson().equals(dep.deploymentOptions().toJson())) {
         return;
       }
     }

File: src/test/java/io/vertx/core/LauncherTest.java
Patch:
@@ -534,7 +534,7 @@ public void testConfigureFromSystemPropertiesInvalidPropertyName() throws Except
     if (opts.getMetricsOptions().isEnabled()) {
       def.getMetricsOptions().setEnabled(true);
     }
-    assertEquals(def, opts);
+    assertEquals(def.toJson(), opts.toJson());
 
   }
 
@@ -554,7 +554,7 @@ public void testConfigureFromSystemPropertiesInvalidPropertyType() throws Except
     if (opts.getMetricsOptions().isEnabled()) {
       def.getMetricsOptions().setEnabled(true);
     }
-    assertEquals(def, opts);
+    assertEquals(def.toJson(), opts.toJson());
   }
 
   @Test

File: src/test/java/io/vertx/core/StarterTest.java
Patch:
@@ -275,7 +275,7 @@ public void testConfigureFromSystemPropertiesInvalidPropertyName() throws Except
     if (opts.getMetricsOptions().isEnabled()) {
       def.getMetricsOptions().setEnabled(true);
     }
-    assertEquals(def, opts);
+    assertEquals(def.toJson(), opts.toJson());
     cleanup(starter);
   }
 
@@ -295,7 +295,7 @@ public void testConfigureFromSystemPropertiesInvalidPropertyType() throws Except
     if (opts.getMetricsOptions().isEnabled()) {
       def.getMetricsOptions().setEnabled(true);
     }
-    assertEquals(def, opts);
+    assertEquals(def.toJson(), opts.toJson());
     cleanup(starter);
   }
 

File: src/main/java/io/vertx/core/http/impl/pool/Pool.java
Patch:
@@ -224,6 +224,7 @@ public synchronized int closeIdle(long timestamp) {
         }
       }
     }
+    checkProgress();
     for (C conn : toClose) {
       connector.close(conn);
     }

File: src/test/java/io/vertx/core/net/ConnectionPoolTest.java
Patch:
@@ -459,6 +459,7 @@ public void testDiscardExpiredConnections() {
     assertEquals(1, mgr.size());
     assertEquals(1, mgr.removeExpired(2L));
     assertEquals(0, mgr.size());
+    assertWaitUntil(mgr::closed);
   }
 
   @Test

File: src/main/java/io/vertx/core/eventbus/impl/HandlerRegistration.java
Patch:
@@ -232,6 +232,9 @@ public void handle(Message<T> message) {
           pending.add(message);
           message = pending.poll();
         }
+        if (demand != Long.MAX_VALUE) {
+          demand--;
+        }
         theHandler = handler;
       }
       ctx = handlerContext;

File: src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java
Patch:
@@ -224,6 +224,7 @@ private void checkPending() {
             if (endHandler != null) {
               endHandler.handle(null);
             }
+            return;
           }
           break;
         } else {

File: src/test/java/io/vertx/core/parsetools/JsonParserTest.java
Patch:
@@ -789,6 +789,9 @@ public void testStreamEnd() {
     stream.end();
     assertEquals(0, events.size());
     assertEquals(1, ended.get());
+    //regression check for #2790 - ensure that by accident resume method is not called.
+    assertEquals(0, stream.pauseCount());
+    assertEquals(0, stream.resumeCount());
   }
 
   @Test

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java
Patch:
@@ -152,7 +152,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
       super.userEventTriggered(ctx, evt);
     } finally {
       if (evt instanceof IdleStateEvent && ((IdleStateEvent) evt).state() == IdleState.ALL_IDLE) {
-        ctx.close();
+        connection.handleIdle();
       }
     }
   }

File: src/main/java/io/vertx/core/http/impl/pool/ConnectionListener.java
Patch:
@@ -32,8 +32,8 @@ public interface ConnectionListener<C> {
   void onRecycle(long expirationTimestamp);
 
   /**
-   * Discard the connection from the pool, it will now be fully managed by the borrower.
+   * Evict the connection from the pool, it will now be fully managed by the borrower.
    */
-  void onDiscard();
+  void onEvict();
 
 }

File: src/main/java/io/vertx/core/net/impl/VertxHandler.java
Patch:
@@ -177,8 +177,9 @@ public void channelRead(ChannelHandlerContext chctx, Object msg) throws Exceptio
   @Override
   public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
     if (evt instanceof IdleStateEvent && ((IdleStateEvent) evt).state() == IdleState.ALL_IDLE) {
-      ctx.close();
+      context.executeFromIO(v -> conn.handleIdle());
+    } else {
+      ctx.fireUserEventTriggered(evt);
     }
-    ctx.fireUserEventTriggered(evt);
   }
 }

File: src/test/java/io/vertx/core/http/Http1xTest.java
Patch:
@@ -31,7 +31,6 @@
 import org.junit.Test;
 
 import java.io.File;
-import java.io.RandomAccessFile;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -2069,7 +2068,7 @@ public void testContexts() throws Exception {
     CountDownLatch latch2 = new CountDownLatch(1);
     int numReqs = 16;
     int numConns = 8;
-    // There should be a context per *connection*
+    // There should be a context per *endpoint*
     client.close();
     client = vertx.createHttpClient(new HttpClientOptions().setMaxPoolSize(numConns));
     for (int i = 0; i < numReqs; i++) {
@@ -2079,7 +2078,7 @@ public void testContexts() throws Exception {
         if (cnt.incrementAndGet() == numReqs) {
           int size = contexts.size();
           // Some connections might get closed if response comes back quick enough hence the >=
-          assertTrue("Expected " + size + " >= " + numConns, size >= numConns);
+          assertEquals(1, size);
           latch2.countDown();
         }
       })).exceptionHandler(this::fail).end();

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -308,7 +308,7 @@ ServerWebSocketImpl createWebSocket(HttpServerRequestImpl request) {
     FullHttpRequest nettyReq = (FullHttpRequest) request.getRequest();
     WebSocketServerHandshaker handshaker = createHandshaker(nettyReq);
     if (handshaker == null) {
-      throw new IllegalStateException("Can't upgrade this request");
+      return null;
     }
     Function<ServerWebSocketImpl, String> f = ws -> {
       try {

File: src/main/java/io/vertx/core/http/impl/HttpServerRequestImpl.java
Patch:
@@ -425,6 +425,9 @@ public String getFormAttribute(String attributeName) {
   @Override
   public ServerWebSocket upgrade() {
     ServerWebSocketImpl ws = conn.createWebSocket(this);
+    if (ws == null) {
+      throw new IllegalStateException("Can't upgrade this request");
+    }
     ws.connectNow();
     return ws;
   }

File: src/main/java/examples/CoreExamples.java
Patch:
@@ -315,8 +315,6 @@ public void retrieveContextType(Vertx vertx) {
       System.out.println("Context attached to Event Loop");
     } else if (context.isWorkerContext()) {
       System.out.println("Context attached to Worker Thread");
-    } else if (context.isMultiThreadedWorkerContext()) {
-      System.out.println("Context attached to Worker Thread - multi threaded worker");
     } else if (! Context.isOnVertxThread()) {
       System.out.println("Context not attached to a thread managed by vert.x");
     }

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -68,9 +68,6 @@ private DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
     DatagramChannel channel = transport.datagramChannel(options.isIpV6() ? InternetProtocolFamily.IPv6 : InternetProtocolFamily.IPv4);
     transport.configure(channel, new DatagramSocketOptions(options));
     ContextInternal context = vertx.getOrCreateContext();
-    if (context.isMultiThreadedWorkerContext()) {
-      throw new IllegalStateException("Cannot use DatagramSocket in a multi-threaded worker verticle");
-    }
     channel.config().setOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);
     MaxMessagesRecvByteBufAllocator bufAllocator = channel.config().getRecvByteBufAllocator();
     bufAllocator.maxMessagesPerRead(1);

File: src/main/java/io/vertx/core/dns/impl/DnsClientImpl.java
Patch:
@@ -58,9 +58,6 @@ public DnsClientImpl(VertxInternal vertx, DnsClientOptions options) {
     this.options = new DnsClientOptions(options);
 
     ContextInternal creatingContext = vertx.getContext();
-    if (creatingContext != null && creatingContext.isMultiThreadedWorkerContext()) {
-      throw new IllegalStateException("Cannot use DnsClient in a multi-threaded worker verticle");
-    }
 
     this.dnsServer = new InetSocketAddress(options.getHost(), options.getPort());
     if (this.dnsServer.isUnresolved()) {

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -135,9 +135,6 @@ public HttpClientImpl(VertxInternal vertx, HttpClientOptions options) {
       completionHandler.handle(Future.succeededFuture());
     };
     if (creatingContext != null) {
-      if (creatingContext.isMultiThreadedWorkerContext()) {
-        throw new IllegalStateException("Cannot use HttpClient in a multi-threaded worker verticle");
-      }
       if(options.getProtocolVersion() == HttpVersion.HTTP_2 && Context.isOnWorkerThread()) {
         throw new IllegalStateException("Cannot use HttpClient with HTTP_2 in a worker");
       }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -102,9 +102,6 @@ public HttpServerImpl(VertxInternal vertx, HttpServerOptions options) {
     this.vertx = vertx;
     this.creatingContext = vertx.getContext();
     if (creatingContext != null) {
-      if (creatingContext.isMultiThreadedWorkerContext()) {
-        throw new IllegalStateException("Cannot use HttpServer in a multi-threaded worker verticle");
-      }
       creatingContext.addCloseHook(this);
     }
     this.sslHelper = new SSLHelper(options, options.getKeyCertOptions(), options.getTrustOptions());

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -139,9 +139,6 @@ public void runCloseHooks(Handler<AsyncResult<Void>> completionHandler) {
   @Override
   public abstract boolean isEventLoopContext();
 
-  @Override
-  public abstract boolean isMultiThreadedWorkerContext();
-
   @Override
   @SuppressWarnings("unchecked")
   public <T> T get(String key) {

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -70,7 +70,7 @@ public interface VertxInternal extends Vertx {
   /**
    * @return worker loop context
    */
-  ContextImpl createWorkerContext(boolean multiThreaded, String deploymentID, WorkerPool pool, JsonObject config, ClassLoader tccl);
+  ContextImpl createWorkerContext(String deploymentID, WorkerPool pool, JsonObject config, ClassLoader tccl);
 
   @Override
   WorkerExecutorInternal createSharedWorkerExecutor(String name);

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -78,9 +78,6 @@ public NetClientImpl(VertxInternal vertx, NetClientOptions options, boolean useC
     if (useCreatingContext) {
       creatingContext = vertx.getContext();
       if (creatingContext != null) {
-        if (creatingContext.isMultiThreadedWorkerContext()) {
-          throw new IllegalStateException("Cannot use NetClient in a multi-threaded worker verticle");
-        }
         creatingContext.addCloseHook(closeHook);
       }
     } else {

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -85,9 +85,6 @@ public NetServerImpl(VertxInternal vertx, NetServerOptions options) {
     this.creatingContext = vertx.getContext();
     this.logEnabled = options.getLogActivity();
     if (creatingContext != null) {
-      if (creatingContext.isMultiThreadedWorkerContext()) {
-        throw new IllegalStateException("Cannot use NetServer in a multi-threaded worker verticle");
-      }
       creatingContext.addCloseHook(this);
     }
   }

File: src/test/java/io/vertx/core/ContextTest.java
Patch:
@@ -410,7 +410,7 @@ public void testExecuteFromIOEventLoopFromNonVertxThread() {
   public void testExecuteFromIOWorkerFromNonVertxThread() {
     assertEquals("true", System.getProperty("vertx.threadChecks"));
     ExecutorService a = Executors.newSingleThreadExecutor();
-    ContextInternal ctx = ((VertxInternal) vertx).createWorkerContext(false, null, new WorkerPool(a, null), null, Thread.currentThread().getContextClassLoader());
+    ContextInternal ctx = ((VertxInternal) vertx).createWorkerContext(null, new WorkerPool(a, null), null, Thread.currentThread().getContextClassLoader());
     AtomicBoolean called = new AtomicBoolean();
     try {
       ctx.executeFromIO(v -> {

File: src/test/java/io/vertx/core/VerticleFactoryTest.java
Patch:
@@ -257,7 +257,6 @@ public boolean requiresResolve() {
       }
       @Override
       public void resolve(String identifier, DeploymentOptions deploymentOptions, ClassLoader classLoader, Future<String> resolution) {
-        deploymentOptions.setMultiThreaded(true);
         vertx.runOnContext(v -> {
           // Async resolution
           resolution.complete("whatever");
@@ -274,7 +273,7 @@ public Verticle createVerticle(String verticleName, ClassLoader classLoader) thr
     // With completion handler
     vertx.deployVerticle("resolve:someid", onFailure(err -> {
       // Expected since we deploy a non multi-threaded worker verticle
-      assertEquals(IllegalArgumentException.class, err.getClass());
+      assertEquals(ClassNotFoundException.class, err.getClass());
       testComplete();
     }));
     await();

File: src/main/java/io/vertx/core/impl/resolver/DnsResolverProvider.java
Patch:
@@ -28,6 +28,7 @@
 import io.vertx.core.Vertx;
 import io.vertx.core.VertxException;
 import io.vertx.core.dns.AddressResolverOptions;
+import io.vertx.core.dns.impl.netty.Fix;
 import io.vertx.core.impl.AddressResolver;
 import io.vertx.core.impl.VertxImpl;
 import io.vertx.core.spi.resolver.ResolverProvider;
@@ -179,6 +180,8 @@ InetAddress lookup(String inetHost, ResolvedAddressTypes resolvedAddressTypes) {
                 ndots = AddressResolver.DEFAULT_NDOTS_RESOLV_OPTION;
               }
               builder.ndots(ndots);
+            } else {
+              builder.searchDomains(Fix.DEFAULT_SEARCH_DOMAINS);
             }
             return builder.build();
           }

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -23,6 +23,7 @@
 import io.vertx.core.http.impl.HeadersAdaptor;
 import io.vertx.core.net.*;
 import io.vertx.core.streams.Pump;
+import io.vertx.test.core.Repeat;
 import io.vertx.test.core.TestUtils;
 import io.vertx.test.netty.TestLoggerFactory;
 import org.junit.Assume;
@@ -4032,10 +4033,10 @@ public void testServerResponseCloseHandlerNotHoldingLock() throws Exception {
   @Test
   public void testCloseHandlerWhenConnectionEnds() throws Exception {
     server.requestHandler(req -> {
-      req.response().endHandler(v -> {
+      req.response().closeHandler(v -> {
         testComplete();
       });
-      req.response().end("some-data");
+      req.response().setChunked(true).write("some-data");
     });
     startServer();
     client.getNow(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/somepath", onSuccess(resp -> {

File: src/test/java/io/vertx/core/FutureTest.java
Patch:
@@ -876,6 +876,7 @@ class DefaultCompleterTestFuture<T> implements Future<T> {
       Throwable cause;
       public boolean isComplete() { throw new UnsupportedOperationException(); }
       public Future<T> setHandler(Handler<AsyncResult<T>> handler) { throw new UnsupportedOperationException(); }
+      public Handler<AsyncResult<T>> getHandler() { throw new UnsupportedOperationException(); }
 
       public void complete(T result) {
         if (!tryComplete(result)) {

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -144,14 +144,14 @@ public void testHttp() throws Exception {
         listenLatch.countDown();
       }));
       awaitLatch(listenLatch);
-      client.getNow(8080, "vertx.io", "/somepath", resp -> {
+      client.getNow(8080, "vertx.io", "/somepath", onSuccess(resp -> {
         Buffer buffer = Buffer.buffer();
         resp.handler(buffer::appendBuffer);
         resp.endHandler(v -> {
           assertEquals(Buffer.buffer("foo"), buffer);
           testComplete();
         });
-      });
+      }));
       await();
     } finally {
       client.close();

File: src/test/java/io/vertx/core/file/FileResolverTestBase.java
Patch:
@@ -232,12 +232,12 @@ public void testSendFileFromClasspath() {
     vertx.createHttpServer(new HttpServerOptions().setPort(8080)).requestHandler(res -> {
       res.response().sendFile(webRoot + "/somefile.html");
     }).listen(onSuccess(res -> {
-      vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
+      vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", onSuccess(resp -> {
         resp.bodyHandler(buff -> {
           assertTrue(buff.toString().startsWith("<html><body>blah</body></html>"));
           testComplete();
         });
-      }).end();
+      })).end();
     }));
     await();
   }

File: src/test/java/io/vertx/core/http/Http2MetricsTest.java
Patch:
@@ -99,12 +99,12 @@ public void testPushPromise() throws Exception {
       HttpClientMetric metric = metrics.getMetric(pushedReq);
       assertNotNull(metric);
       assertSame(pushedReq, metric.request);
-      pushedReq.handler(resp -> {
+      pushedReq.handler(onSuccess(resp -> {
         resp.endHandler(v -> {
           assertNull(metrics.getMetric(pushedReq));
           complete();
         });
-      });
+      }));
     });
     req.end();
     await();

File: src/test/java/io/vertx/core/http/HttpRequestStreamTest.java
Patch:
@@ -79,10 +79,10 @@ public void testReadStreamPauseResume() {
           paused.set(false);
           httpStream.resume();
           client = vertx.createHttpClient(new HttpClientOptions());
-          client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "localhost", path, resp -> {
+          client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "localhost", path, onSuccess(resp -> {
             assertEquals(200, resp.statusCode());
             testComplete();
-          }).end();
+          })).end();
         });
       });
     });

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -3218,13 +3218,13 @@ private void testNetServerInternal_(HttpClientOptions clientOptions, boolean exp
     });
     startServer(SocketAddress.inetSocketAddress(1234, "localhost"));
     HttpClient client = vertx.createHttpClient(clientOptions);
-    client.getNow(1234, "localhost", "/somepath", resp -> {
+    client.getNow(1234, "localhost", "/somepath", onSuccess(resp -> {
       assertEquals(200, resp.statusCode());
       resp.bodyHandler(buff -> {
         assertEquals("Hello World", buff.toString());
         complete();
       });
-    });
+    }));
     await();
   }
 

File: src/test/java/io/vertx/core/spi/metrics/MetricsContextTest.java
Patch:
@@ -177,7 +177,7 @@ public void close() {
     });
     awaitLatch(latch);
     HttpClient client = vertx.createHttpClient();
-    client.put(8080, "localhost", "/", resp -> {
+    client.put(8080, "localhost", "/", onSuccess(resp -> {
       resp.netSocket().closeHandler(v -> {
         vertx.close(v4 -> {
           assertTrue(requestBeginCalled.get());
@@ -190,7 +190,7 @@ public void close() {
           testComplete();
         });
       });
-    }).exceptionHandler(err -> {
+    })).exceptionHandler(err -> {
       fail(err.getMessage());
     }).setChunked(true).write(Buffer.buffer("hello")).end();
     await();

File: src/test/java/io/vertx/it/NettyCompatTest.java
Patch:
@@ -47,12 +47,12 @@ public void testHttp2() {
               .setSsl(true)
               .setSslEngineOptions(new OpenSSLEngineOptions())
               .setTrustStoreOptions(Trust.SERVER_JKS.get()));
-          client.getNow(8443, "localhost", "/somepath", resp -> {
+          client.getNow(8443, "localhost", "/somepath", onSuccess(resp -> {
             resp.bodyHandler(buff -> {
               assertEquals("OK", buff.toString());
               testComplete();
             });
-          });
+          }));
         }));
     await();
   }

File: src/test/java/io/vertx/it/SSLEngineTest.java
Patch:
@@ -126,10 +126,10 @@ private void doTest(SSLEngineOptions engine,
           .setUseAlpn(useAlpn)
           .setTrustAll(true)
           .setProtocolVersion(version));
-      client.getNow(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/somepath", resp -> {
+      client.getNow(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/somepath", onSuccess(resp -> {
         assertEquals(200, resp.statusCode());
         testComplete();
-      });
+      }));
     }));
     await();
   }

File: src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -309,6 +309,7 @@ public NetSocket upgradeToSsl(String serverName, Handler<Void> handler) {
           handler.handle(null);
         } else {
           chctx.channel().closeFuture();
+          handleException(ar.cause());
         }
       }));
       if (remoteAddress != null) {

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -681,6 +681,9 @@ protected void checkComplete() {
   }
 
   private void checkResponseHandler() {
+    if (stream == null && !connecting && respFut.getHandler() == null) {
+      throw new IllegalStateException("You must set a response handler before connecting to the server");
+    }
   }
 
   synchronized Handler<HttpClientRequest> pushHandler() {

File: src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.http;
 
 import io.vertx.codegen.annotations.*;
+import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 import io.vertx.core.MultiMap;
 import io.vertx.core.buffer.Buffer;
@@ -64,7 +65,7 @@ public interface HttpClientRequest extends WriteStream<Buffer> {
   @Override
   HttpClientRequest drainHandler(Handler<Void> handler);
 
-  HttpClientRequest handler(Handler<HttpClientResponse> handler);
+  HttpClientRequest handler(Handler<AsyncResult<HttpClientResponse>> handler);
 
   @Fluent
   HttpClientRequest setFollowRedirects(boolean followRedirects);

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -50,7 +50,7 @@ public class HttpClientRequestImpl extends HttpClientRequestBase implements Http
   static final Logger log = LoggerFactory.getLogger(ConnectionManager.class);
 
   private final VertxInternal vertx;
-  private Handler<HttpClientResponse> respHandler;
+  private Handler<AsyncResult<HttpClientResponse>> respHandler;
   private boolean chunked;
   private String hostHeader;
   private String rawMethod;
@@ -92,7 +92,7 @@ public int streamId() {
   }
 
   @Override
-  public synchronized HttpClientRequest handler(Handler<HttpClientResponse> handler) {
+  public synchronized HttpClientRequest handler(Handler<AsyncResult<HttpClientResponse>> handler) {
     if (handler != null) {
       checkComplete();
     }
@@ -414,7 +414,7 @@ protected void doHandleResponse(HttpClientResponseImpl resp, long timeoutMs) {
         }
       } else {
         if (respHandler != null) {
-          respHandler.handle(resp);
+          respHandler.handle(Future.succeededFuture(resp));
         }
       }
     }

File: src/test/java/io/vertx/core/dns/HostnameResolutionTest.java
Patch:
@@ -144,14 +144,14 @@ public void testHttp() throws Exception {
         listenLatch.countDown();
       }));
       awaitLatch(listenLatch);
-      client.getNow(8080, "vertx.io", "/somepath", resp -> {
+      client.getNow(8080, "vertx.io", "/somepath", onSuccess(resp -> {
         Buffer buffer = Buffer.buffer();
         resp.handler(buffer::appendBuffer);
         resp.endHandler(v -> {
           assertEquals(Buffer.buffer("foo"), buffer);
           testComplete();
         });
-      });
+      }));
       await();
     } finally {
       client.close();

File: src/test/java/io/vertx/core/file/FileResolverTestBase.java
Patch:
@@ -232,12 +232,12 @@ public void testSendFileFromClasspath() {
     vertx.createHttpServer(new HttpServerOptions().setPort(8080)).requestHandler(res -> {
       res.response().sendFile(webRoot + "/somefile.html");
     }).listen(onSuccess(res -> {
-      vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
+      vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", onSuccess(resp -> {
         resp.bodyHandler(buff -> {
           assertTrue(buff.toString().startsWith("<html><body>blah</body></html>"));
           testComplete();
         });
-      }).end();
+      })).end();
     }));
     await();
   }

File: src/test/java/io/vertx/core/http/Http2MetricsTest.java
Patch:
@@ -99,12 +99,12 @@ public void testPushPromise() throws Exception {
       HttpClientMetric metric = metrics.getMetric(pushedReq);
       assertNotNull(metric);
       assertSame(pushedReq, metric.request);
-      pushedReq.handler(resp -> {
+      pushedReq.handler(onSuccess(resp -> {
         resp.endHandler(v -> {
           assertNull(metrics.getMetric(pushedReq));
           complete();
         });
-      });
+      }));
     });
     req.end();
     await();

File: src/test/java/io/vertx/core/http/HttpRequestStreamTest.java
Patch:
@@ -79,10 +79,10 @@ public void testReadStreamPauseResume() {
           paused.set(false);
           httpStream.resume();
           client = vertx.createHttpClient(new HttpClientOptions());
-          client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "localhost", path, resp -> {
+          client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, "localhost", path, onSuccess(resp -> {
             assertEquals(200, resp.statusCode());
             testComplete();
-          }).end();
+          })).end();
         });
       });
     });

File: src/test/java/io/vertx/core/http/HttpTLSTest.java
Patch:
@@ -1159,7 +1159,7 @@ TLSTest run(boolean shouldPass) {
         }
         HttpClientRequest req = requestProvider.apply(client);
         req.setFollowRedirects(followRedirects);
-        req.handler(response -> {
+        req.handler(onSuccess(response -> {
           HttpConnection conn = response.request().connection();
           if (conn.isSsl()) {
             try {
@@ -1181,7 +1181,7 @@ TLSTest run(boolean shouldPass) {
           } else {
             HttpTLSTest.this.fail("Should not get a response");
           }
-        });
+        }));
         req.exceptionHandler(t -> {
           if (shouldPass) {
             t.printStackTrace();

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -3198,13 +3198,13 @@ private void testNetServerInternal_(HttpClientOptions clientOptions, boolean exp
     });
     startServer(SocketAddress.inetSocketAddress(1234, "localhost"));
     HttpClient client = vertx.createHttpClient(clientOptions);
-    client.getNow(1234, "localhost", "/somepath", resp -> {
+    client.getNow(1234, "localhost", "/somepath", onSuccess(resp -> {
       assertEquals(200, resp.statusCode());
       resp.bodyHandler(buff -> {
         assertEquals("Hello World", buff.toString());
         complete();
       });
-    });
+    }));
     await();
   }
 

File: src/test/java/io/vertx/core/spi/metrics/MetricsContextTest.java
Patch:
@@ -177,7 +177,7 @@ public void close() {
     });
     awaitLatch(latch);
     HttpClient client = vertx.createHttpClient();
-    client.put(8080, "localhost", "/", resp -> {
+    client.put(8080, "localhost", "/", onSuccess(resp -> {
       resp.netSocket().closeHandler(v -> {
         vertx.close(v4 -> {
           assertTrue(requestBeginCalled.get());
@@ -190,7 +190,7 @@ public void close() {
           testComplete();
         });
       });
-    }).exceptionHandler(err -> {
+    })).exceptionHandler(err -> {
       fail(err.getMessage());
     }).setChunked(true).write(Buffer.buffer("hello")).end();
     await();

File: src/test/java/io/vertx/it/NettyCompatTest.java
Patch:
@@ -47,12 +47,12 @@ public void testHttp2() {
               .setSsl(true)
               .setSslEngineOptions(new OpenSSLEngineOptions())
               .setTrustStoreOptions(Trust.SERVER_JKS.get()));
-          client.getNow(8443, "localhost", "/somepath", resp -> {
+          client.getNow(8443, "localhost", "/somepath", onSuccess(resp -> {
             resp.bodyHandler(buff -> {
               assertEquals("OK", buff.toString());
               testComplete();
             });
-          });
+          }));
         }));
     await();
   }

File: src/test/java/io/vertx/it/SSLEngineTest.java
Patch:
@@ -126,10 +126,10 @@ private void doTest(SSLEngineOptions engine,
           .setUseAlpn(useAlpn)
           .setTrustAll(true)
           .setProtocolVersion(version));
-      client.getNow(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/somepath", resp -> {
+      client.getNow(DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, "/somepath", onSuccess(resp -> {
         assertEquals(200, resp.statusCode());
         testComplete();
-      });
+      }));
     }));
     await();
   }

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestBase.java
Patch:
@@ -214,6 +214,7 @@ public synchronized Throwable fillInStackTrace() {
         return this;
       }
     });
+    reset(0);
   }
 
   synchronized void dataReceived() {

File: src/main/java/io/vertx/core/http/impl/HttpServerFileUploadImpl.java
Patch:
@@ -63,6 +63,7 @@ class HttpServerFileUploadImpl implements HttpServerFileUpload {
     this.charset = charset;
     this.size = size;
     this.pending = new InboundBuffer<Buffer>(context)
+      .drainHandler(v -> req.resume())
       .emptyHandler(v -> {
         if (complete) {
           handleComplete();

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestBase.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.core.http.impl;
 
+import io.netty.handler.codec.http2.Http2CodecUtil;
 import io.vertx.core.Handler;
 import io.vertx.core.http.HttpClientRequest;
 import io.vertx.core.http.HttpClientResponse;
@@ -250,4 +251,5 @@ public synchronized HttpClientRequest fetch(long amount) {
     }
     return this;
   }
+  
 }

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -671,4 +671,5 @@ public HttpServerResponse push(HttpMethod method, String host, String path, Mult
   public HttpServerResponse writeCustomFrame(int type, int flags, Buffer payload) {
     return this;
   }
+
 }

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -4015,6 +4015,8 @@ class MockReq implements HttpClientRequest {
       public HttpClientRequest connectionHandler(@Nullable Handler<HttpConnection> handler) { throw new UnsupportedOperationException(); }
       public HttpClientRequest writeCustomFrame(int type, int flags, Buffer payload) { throw new UnsupportedOperationException(); }
       public boolean writeQueueFull() { throw new UnsupportedOperationException(); }
+      @Override public HttpClientRequest setStreamPriority(StreamPriority streamPriority) { return this; }
+      @Override public StreamPriority getStreamPriority() { return null; }
     }
     HttpClientRequest req = new MockReq();
     class MockResp implements HttpClientResponse {
@@ -4037,6 +4039,7 @@ class MockResp implements HttpClientResponse {
       public HttpClientResponse customFrameHandler(Handler<HttpFrame> handler) { throw new UnsupportedOperationException(); }
       public NetSocket netSocket() { throw new UnsupportedOperationException(); }
       public HttpClientRequest request() { return req; }
+      public HttpClientResponse streamPriorityHandler(Handler<StreamPriority> handler) { return this; }
     }
     MockResp resp = new MockResp();
     Function<HttpClientResponse, Future<HttpClientRequest>> handler = client.redirectHandler();

File: src/main/java/io/vertx/core/eventbus/impl/HandlerRegistration.java
Patch:
@@ -26,6 +26,7 @@
 import io.vertx.core.streams.ReadStream;
 
 import java.util.*;
+import java.util.stream.Collectors;
 
 /*
  * This class is optimised for performance when used on the same event loop it was created on.
@@ -103,6 +104,7 @@ public MessageConsumer<T> setMaxBufferedMessages(int maxBufferedMessages) {
         discarded.add(pending.poll());
       }
     }
+    System.out.println("discarded = " + discarded.stream().map(m -> m.body()).collect(Collectors.toList()));
     for (Message<T> msg : discarded) {
       discardHandler.handle(msg);
     }

File: src/test/java/io/vertx/core/http/HttpTest.java
Patch:
@@ -131,7 +131,7 @@ public void testListenDomainSocketAddress() throws Exception {
     Assume.assumeTrue("Native transport must be enabled", vx.isNativeTransportEnabled());
     NetClient netClient = vx.createNetClient();
     HttpServer httpserver = vx.createHttpServer().requestHandler(req -> req.response().end());
-    File sockFile = TestUtils.tmpFile("vertx", ".sock");
+    File sockFile = TestUtils.tmpFile(".sock");
     SocketAddress sockAddress = SocketAddress.domainSocketAddress(sockFile.getAbsolutePath());
     httpserver.listen(sockAddress, onSuccess(server -> {
       netClient.connect(sockAddress, onSuccess(sock -> {

File: src/test/java/io/vertx/it/TransportTest.java
Patch:
@@ -87,7 +87,7 @@ private void testNetServer(VertxOptions options) {
 
   @Test
   public void testDomainSocketServer() throws Exception {
-    File sock = TestUtils.tmpFile("vertx", ".sock");
+    File sock = TestUtils.tmpFile(".sock");
     vertx = Vertx.vertx();
     NetServer server = vertx.createNetServer();
     server.connectHandler(so -> {});
@@ -100,7 +100,7 @@ public void testDomainSocketServer() throws Exception {
 
   @Test
   public void testDomainSocketClient() throws Exception {
-    File sock = TestUtils.tmpFile("vertx", ".sock");
+    File sock = TestUtils.tmpFile(".sock");
     vertx = Vertx.vertx();
     NetClient client = vertx.createNetClient();
     client.connect(SocketAddress.domainSocketAddress(sock.getAbsolutePath()), onFailure(err -> {

File: src/main/java/io/vertx/core/http/impl/HttpHandlers.java
Patch:
@@ -25,16 +25,19 @@
  */
 public class HttpHandlers {
 
+  final HttpServerImpl server;
   final Handler<HttpServerRequest> requestHandler;
   final Handler<ServerWebSocket> wsHandler;
   final Handler<HttpConnection> connectionHandler;
   final Handler<Throwable> exceptionHandler;
 
   public HttpHandlers(
+    HttpServerImpl server,
     Handler<HttpServerRequest> requestHandler,
     Handler<ServerWebSocket> wsHandler,
     Handler<HttpConnection> connectionHandler,
     Handler<Throwable> exceptionHandler) {
+    this.server = server;
     this.requestHandler = requestHandler;
     this.wsHandler = wsHandler;
     this.connectionHandler = connectionHandler;

File: src/test/benchmarks/io/vertx/benchmarks/HttpServerHandlerBenchmark.java
Patch:
@@ -233,7 +233,7 @@ protected void encodeHeaders(HttpHeaders headers, ByteBuf buf) {
           .add(HEADER_CONTENT_LENGTH, HELLO_WORLD_LENGTH);
       response.end(HELLO_WORLD_BUFFER);
     };
-    HandlerHolder<HttpHandlers> holder = new HandlerHolder<>(context, new HttpHandlers(app, null, null, null));
+    HandlerHolder<HttpHandlers> holder = new HandlerHolder<>(context, new HttpHandlers(null, app, null, null, null));
     VertxHandler<Http1xServerConnection> handler = VertxHandler.create(holder.context, chctx -> new Http1xServerConnection(
       holder.context.owner(),
       null,

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -75,7 +75,7 @@ protected ContextImpl(VertxInternal vertx, WorkerPool internalBlockingPool, Work
 
   protected ContextImpl(VertxInternal vertx, EventLoop eventLoop, WorkerPool internalBlockingPool, WorkerPool workerPool, String deploymentID, JsonObject config,
                         ClassLoader tccl) {
-    if (DISABLE_TCCL && !tccl.getClass().getName().equals("sun.misc.Launcher$AppClassLoader")) {
+    if (DISABLE_TCCL && tccl != ClassLoader.getSystemClassLoader()) {
       log.warn("You have disabled TCCL checks but you have a custom TCCL to set.");
     }
     this.deploymentID = deploymentID;

File: src/main/java/io/vertx/core/http/StreamPriority.java
Patch:
@@ -18,14 +18,13 @@
 /**
  * This class represents HTTP/2 stream priority defined in RFC 7540 clause 5.3
  */
-@DataObject(generateConverter=true, publicConverter=false)
+@DataObject
 public class StreamPriority {
     
     public static final StreamPriority DEFAULT = new StreamPriority();
     /**
      * 
      */
-    @DataObjectProperty()
     private short weight;
     private int streamDependency;
     private boolean exclusive;

File: src/main/java/io/vertx/core/http/impl/Http2ConnectionBase.java
Patch:
@@ -199,7 +199,6 @@ public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDe
       synchronized (this) {
         stream = streams.get(streamId);
       }
-      System.out.println(getClass().getName() + ".onPriorityRead(" + new StreamPriority(streamDependency, weight, exclusive) + ") : " + stream);
 
       if (stream != null) {
         StreamPriority streamPriority = new StreamPriority(streamDependency, weight, exclusive);

File: src/main/java/io/vertx/core/http/HttpServerRequest.java
Patch:
@@ -330,10 +330,11 @@ default HttpServerRequest bodyHandler(@Nullable Handler<Buffer> bodyHandler) {
   HttpConnection connection();
 
   /**
-   * @return The priority of associated stream  
+   * Gets the priority of the associated HTTP/2 stream
+   * @return The priority of the associated HTTP/2 stream for HTTP/2 otherwise {@code null}  
    */
   default StreamPriority getStreamPriority() {
-      return StreamPriority.DEFAULT;
+      return null;
   }
 
   /**

File: src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -398,10 +398,10 @@ default HttpClientRequest setStreamPriority(StreamPriority streamPriority) {
   }
 
   /**
-   * Gets the priority of the associated stream
-   * @return The priority of this requet's stream  
+   * Gets the priority of the associated HTTP/2 stream
+   * @return The priority of the associated HTTP/2 stream for HTTP/2 otherwise {@code null}  
    */
   default StreamPriority getStreamPriority() {
-      return StreamPriority.DEFAULT;
+      return null;
   }
 }

File: src/main/java/io/vertx/core/http/StreamPriority.java
Patch:
@@ -18,13 +18,14 @@
 /**
  * This class represents HTTP/2 stream priority defined in RFC 7540 clause 5.3
  */
-@DataObject
+@DataObject(generateConverter=true, publicConverter=false)
 public class StreamPriority {
     
     public static final StreamPriority DEFAULT = new StreamPriority();
     /**
      * 
      */
+    @DataObjectProperty()
     private short weight;
     private int streamDependency;
     private boolean exclusive;

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -60,7 +60,7 @@ default void writePriorityFrame() {}
   NetSocket createNetSocket();
   
   default StreamPriority getStreamPriority() {
-      return StreamPriority.DEFAULT;
+      return null;
   }
   default void setStreamPriority(StreamPriority streamPriority) { }
 }
\ No newline at end of file

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -146,7 +146,7 @@ public HttpServerResponseImpl setChunked(boolean chunked) {
   @Override
   public boolean isChunked() {
     synchronized (conn) {
-      return HttpHeaders.CHUNKED.equals(headers.get(HttpHeaders.TRANSFER_ENCODING));
+      return headers.contains(HttpHeaders.TRANSFER_ENCODING, HttpHeaders.CHUNKED, true);
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -712,12 +712,12 @@ synchronized void toWebSocket(String requestURI, MultiMap headers, WebsocketVers
   ArrayList<WebSocketClientExtensionHandshaker> initializeWebsocketExtensionHandshakers (HttpClientOptions options) {
     ArrayList<WebSocketClientExtensionHandshaker> extensionHandshakers = new ArrayList<WebSocketClientExtensionHandshaker>();
     if (options.tryWebsocketDeflateFrameCompression()) {
-      extensionHandshakers.add(new DeflateFrameClientExtensionHandshaker(options.websocketCompressionLevel(),
+      extensionHandshakers.add(new DeflateFrameClientExtensionHandshaker(options.getWebsocketCompressionLevel(),
         false));
     }
 
     if (options.tryUsePerMessageWebsocketCompression ()) {
-      extensionHandshakers.add(new PerMessageDeflateClientExtensionHandshaker(options.websocketCompressionLevel(),
+      extensionHandshakers.add(new PerMessageDeflateClientExtensionHandshaker(options.getWebsocketCompressionLevel(),
         ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), PerMessageDeflateServerExtensionHandshaker.MAX_WINDOW_SIZE,
         options.getWebsocketCompressionAllowClientNoContext(), options.getWebsocketCompressionRequestServerNoContext()));
     }

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -833,8 +833,9 @@ private void writeUntilFull(NetSocket so, Handler<Void> handler) {
     if (so.writeQueueFull()) {
       handler.handle(null);
     } else {
-      so.write(TestUtils.randomBuffer(256));
-      vertx.runOnContext(v -> writeUntilFull(so, handler));
+      // Give enough time to report a proper full
+      so.write(TestUtils.randomBuffer(16384));
+      vertx.setTimer(10, id -> writeUntilFull(so, handler));
     }
   }
 

File: src/test/java/io/vertx/core/DeploymentTest.java
Patch:
@@ -1324,7 +1324,9 @@ public void testGetInstanceCountMultipleVerticles() throws Exception {
     });
     await();
     Deployment deployment = ((VertxInternal) vertx).getDeployment(vertx.deploymentIDs().iterator().next());
-    vertx.undeploy(deployment.deploymentID());
+    CountDownLatch latch = new CountDownLatch(1);
+    vertx.undeploy(deployment.deploymentID(), ar -> latch.countDown());
+    awaitLatch(latch);
   }
 
   @Test

File: src/test/java/io/vertx/test/verticles/TestVerticle3.java
Patch:
@@ -23,7 +23,4 @@ public class TestVerticle3 extends AbstractVerticle {
   public void start() throws Exception {
     vertx.eventBus().send("instanceCount", vertx.getOrCreateContext().getInstanceCount());
   }
-
-  @Override
-  public void stop(Future<Void> stopFuture) throws Exception { }
 }

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -307,7 +307,7 @@ public SSLSession sslSession() {
 
   public X509Certificate[] peerCertificateChain() throws SSLPeerUnverifiedException {
     if (isSSL()) {
-      ChannelHandlerContext sslHandlerContext = chctx.pipeline().context("ssl");
+      ChannelHandlerContext sslHandlerContext = chctx.pipeline().context(SslHandler.class);
       assert sslHandlerContext != null;
       SslHandler sslHandler = (SslHandler) sslHandlerContext.handler();
       return sslHandler.engine().getSession().getPeerCertificateChain();
@@ -317,8 +317,8 @@ public X509Certificate[] peerCertificateChain() throws SSLPeerUnverifiedExceptio
   }
 
   public String indicatedServerName() {
-    if (chctx.channel().hasAttr(VertxSniHandler.SERVER_NAME_ATTR)) {
-      return chctx.channel().attr(VertxSniHandler.SERVER_NAME_ATTR).get();
+    if (chctx.channel().hasAttr(SslHandshakeCompletionHandler.SERVER_NAME_ATTR)) {
+      return chctx.channel().attr(SslHandshakeCompletionHandler.SERVER_NAME_ATTR).get();
     } else {
       return null;
     }

File: src/test/java/io/vertx/core/http/HttpTLSTest.java
Patch:
@@ -1129,7 +1129,7 @@ TLSTest run(boolean shouldPass) {
       AtomicInteger count = new AtomicInteger();
       server.exceptionHandler(err -> {
         if (shouldPass) {
-          fail();
+          HttpTLSTest.this.fail(err);
         } else {
           if (count.incrementAndGet() == 1) {
             complete();

File: src/test/java/io/vertx/core/net/NetTest.java
Patch:
@@ -41,6 +41,7 @@
 import io.vertx.test.proxy.SocksProxy;
 import io.vertx.test.proxy.TestProxyBase;
 import org.junit.Assume;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -3011,7 +3012,7 @@ public void testTLSHostnameCertCheckIncorrect() {
       client.connect(4043, "127.0.0.1", arSocket -> {
         if (arSocket.succeeded()) {
           NetSocket ns = arSocket.result();
-          ns.exceptionHandler(th -> {
+          ns.closeHandler(v -> {
             testComplete();
           });
           ns.upgradeToSsl(v -> {

File: src/main/java/io/vertx/core/parsetools/impl/RecordParserImpl.java
Patch:
@@ -169,6 +169,9 @@ public RecordParser maxRecordSize(int size) {
   }
 
   private void handleParsing() {
+    if (buff == null) {
+      return;
+    }
     int len = buff.length();
     do {
       if (next == -1) {

File: src/test/java/io/vertx/core/parsetools/RecordParserTest.java
Patch:
@@ -305,6 +305,8 @@ public void testWrapReadStream() {
     Deque<String> records = new ArrayDeque<>();
     parser.handler(record -> records.add(record.toString()));
     assertFalse(stream.isPaused());
+    parser.pause();
+    parser.resume();
     stream.handle(Buffer.buffer("first\r\nsecond\r\nthird"));
     assertEquals("first", records.poll());
     assertEquals("second", records.poll());

File: src/test/java/io/vertx/core/http/Http2ServerTest.java
Patch:
@@ -528,7 +528,7 @@ public void testURI() throws Exception {
       assertTrue(names.contains("bar"));
       assertEquals("foo_value", params.get("foo"));
       assertEquals(Collections.singletonList("foo_value"), params.getAll("foo"));
-      assertEquals("bar_value_2", params.get("bar"));
+      assertEquals("bar_value_1", params.get("bar"));
       assertEquals(Arrays.asList("bar_value_1", "bar_value_2"), params.getAll("bar"));
       testComplete();
     });

File: src/main/java/io/vertx/core/http/CaseInsensitiveHeaders.java
Patch:
@@ -242,14 +242,14 @@ public String get(final String name) {
     int h = hash(name);
     int i = index(h);
     MapEntry e = entries[i];
+    String value = null;
     while (e != null) {
       if (e.hash == h && eq(name, e.key)) {
-        return e.getValue();
+        value = e.getValue();
       }
-
       e = e.next;
     }
-    return null;
+    return value;
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/headers/VertxHttpHeaders.java
Patch:
@@ -546,14 +546,15 @@ private CharSequence get0(CharSequence name) {
     int h = AsciiString.hashCode(name);
     int i = h & 0x0000000F;
     VertxHttpHeaders.MapEntry e = entries[i];
+    CharSequence value = null;
     while (e != null) {
       CharSequence key = e.key;
       if (e.hash == h && (name == key || AsciiString.contentEqualsIgnoreCase(name, key))) {
-        return e.getValue();
+        value = e.getValue();
       }
       e = e.next;
     }
-    return null;
+    return value;
   }
 
   private MultiMap set0(Iterable<Map.Entry<String, String>> map) {

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -274,7 +274,7 @@ <T> void executeBlocking(Handler<Future<T>> blockingCodeHandler,
           metrics.end(execMetric, res.succeeded());
         }
         if (resultHandler != null) {
-          runOnContext(v -> res.setHandler(resultHandler));
+          res.setHandler(ar -> runOnContext(v -> resultHandler.handle(ar)));
         }
       };
       if (queue != null) {

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java
Patch:
@@ -50,7 +50,7 @@ public VertxHttp2ConnectionHandler(
     this.useDecompressor = useDecompressor;
     encoder().flowController().listener(s -> {
       if (connection != null) {
-        connection.onStreamwritabilityChanged(s);
+        connection.onStreamWritabilityChanged(s);
       }
     });
     connection().addListener(this);

File: src/main/java/io/vertx/core/http/impl/WebSocketImpl.java
Patch:
@@ -39,7 +39,7 @@ void handleClosed() {
       if (metrics != null) {
         metrics.disconnected(getMetric());
       }
-      super.handleClosed();
     }
+    super.handleClosed();
   }
 }

File: src/test/java/io/vertx/core/http/Http2ServerTest.java
Patch:
@@ -313,9 +313,10 @@ public void testServerSettings() throws Exception {
     server = vertx.createHttpServer(serverOptions);
     Context otherContext = vertx.getOrCreateContext();
     server.connectionHandler(conn -> {
+      Context ctx = Vertx.currentContext();
       otherContext.runOnContext(v -> {
         conn.updateSettings(expectedSettings, ar -> {
-          assertSame(otherContext, Vertx.currentContext());
+          assertSame(ctx, Vertx.currentContext());
           io.vertx.core.http.Http2Settings ackedSettings = conn.settings();
           assertEquals(expectedSettings.getMaxHeaderListSize(), ackedSettings.getMaxHeaderListSize());
           assertEquals(expectedSettings.getMaxFrameSize(), ackedSettings.getMaxFrameSize());

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -204,7 +204,7 @@ private void doConnect(
       }
     };
 
-    channelProvider.connect(client.getVertx(), bootstrap, options.getProxyOptions(), SocketAddress.inetSocketAddress(port, host), channelInitializer, channelHandler);
+    channelProvider.connect(context, bootstrap, options.getProxyOptions(), SocketAddress.inetSocketAddress(port, host), channelInitializer, channelHandler);
   }
 
   private void applyConnectionOptions(Bootstrap bootstrap) {

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -229,7 +229,7 @@ protected void doConnect(SocketAddress remoteAddress, String serverName, Handler
       }
     };
 
-    channelProvider.connect(vertx, bootstrap, options.getProxyOptions(), remoteAddress, channelInitializer, channelHandler);
+    channelProvider.connect(context, bootstrap, options.getProxyOptions(), remoteAddress, channelInitializer, channelHandler);
   }
 
   private void connected(ContextInternal context, Channel ch, Handler<AsyncResult<NetSocket>> connectHandler, SocketAddress remoteAddress) {

File: src/main/java/io/vertx/core/net/impl/ProxyChannelProvider.java
Patch:
@@ -27,6 +27,7 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.net.ProxyOptions;
 import io.vertx.core.net.ProxyType;
@@ -48,13 +49,14 @@ private ProxyChannelProvider() {
   }
 
   @Override
-  public void connect(VertxInternal vertx,
+  public void doConnect(ContextInternal context,
                       Bootstrap bootstrap,
                       ProxyOptions options,
                       SocketAddress remoteAddress,
                       Handler<Channel> channelInitializer,
                       Handler<AsyncResult<Channel>> channelHandler) {
 
+    final VertxInternal vertx = context.owner();
     final String proxyHost = options.getHost();
     final int proxyPort = options.getPort();
     final String proxyUsername = options.getUsername();

File: src/main/java/examples/CoreExamples.java
Patch:
@@ -100,7 +100,7 @@ public void workerExecutor3(Vertx vertx) {
 
     // 2 minutes
     long maxExecuteTime = 2;
-    TimeUnit maxExecuteTimeUnit = TimeUnit.SECONDS;
+    TimeUnit maxExecuteTimeUnit = TimeUnit.MINUTES;
 
     WorkerExecutor executor = vertx.createSharedWorkerExecutor("my-worker-pool", poolSize, maxExecuteTime, maxExecuteTimeUnit);
   }

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -277,7 +277,7 @@ private void http2Connected(ConnectionListener<HttpClientConnection> listener,
                               Channel ch,
                               Future<ConnectResult<HttpClientConnection>> future) {
     try {
-      VertxHttp2ConnectionHandler<Http2ClientConnection> clientHandler = Http2ClientConnection.createHttp2ConnectionHandler(client, metric, listener, context, (conn, concurrency) -> {
+      VertxHttp2ConnectionHandler<Http2ClientConnection> clientHandler = Http2ClientConnection.createHttp2ConnectionHandler(client, metric, listener, context, null, (conn, concurrency) -> {
         future.complete(new ConnectResult<>(conn, concurrency, ch, context, http2Weight));
       });
       ch.pipeline().addLast("handler", clientHandler);

File: src/main/java/io/vertx/core/http/impl/HttpClientConnection.java
Patch:
@@ -33,4 +33,6 @@ public interface HttpClientConnection extends HttpConnection {
 
   ContextInternal getContext();
 
+  Object metric();
+
 }

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -323,15 +323,15 @@ ServerWebSocketImpl createWebSocket(HttpServerRequestImpl request) {
       if (handler != null) {
         chctx.pipeline().remove(handler);
       }
-      if (METRICS_ENABLED && metrics != null) {
-        ws.setMetric(metrics.upgrade(request.metric(), ws));
-      }
       ws.registerHandler(vertx.eventBus());
       return handshaker.selectedSubprotocol();
     };
     ws = new ServerWebSocketImpl(vertx, request.uri(), request.path(),
       request.query(), request.headers(), this, handshaker.version() != WebSocketVersion.V00,
       f, options.getMaxWebsocketFrameSize(), options.getMaxWebsocketMessageSize());
+    if (METRICS_ENABLED && metrics != null) {
+      ws.setMetric(metrics.connected(metric(), request.metric(), ws));
+    }
     return ws;
   }
 

File: src/test/java/io/vertx/core/spi/metrics/MetricsContextTest.java
Patch:
@@ -221,7 +221,7 @@ private void testHttpServerWebsocket(Function<Vertx, Context> contextFactory, Bi
       public HttpServerMetrics createHttpServerMetrics(HttpServerOptions options, SocketAddress localAddress) {
         return new DummyHttpServerMetrics() {
           @Override
-          public Void connected(Void socketMetric, ServerWebSocket serverWebSocket) {
+          public Void connected(Void socketMetric, Void requestMetric, ServerWebSocket serverWebSocket) {
             websocketConnected.set(true);
             checker.accept(expectedThread.get(), expectedContext.get());
             return null;

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -323,15 +323,15 @@ ServerWebSocketImpl createWebSocket(HttpServerRequestImpl request) {
       if (handler != null) {
         chctx.pipeline().remove(handler);
       }
+      if (METRICS_ENABLED && metrics != null) {
+        ws.setMetric(metrics.upgrade(request.metric(), ws));
+      }
       ws.registerHandler(vertx.eventBus());
       return handshaker.selectedSubprotocol();
     };
     ws = new ServerWebSocketImpl(vertx, request.uri(), request.path(),
       request.query(), request.headers(), this, handshaker.version() != WebSocketVersion.V00,
       f, options.getMaxWebsocketFrameSize(), options.getMaxWebsocketMessageSize());
-    if (METRICS_ENABLED && metrics != null) {
-      ws.setMetric(metrics.connected(metric(), request.metric(), ws));
-    }
     return ws;
   }
 

File: src/test/java/io/vertx/core/spi/metrics/MetricsContextTest.java
Patch:
@@ -221,7 +221,7 @@ private void testHttpServerWebsocket(Function<Vertx, Context> contextFactory, Bi
       public HttpServerMetrics createHttpServerMetrics(HttpServerOptions options, SocketAddress localAddress) {
         return new DummyHttpServerMetrics() {
           @Override
-          public Void connected(Void socketMetric, Void requestMetric, ServerWebSocket serverWebSocket) {
+          public Void connected(Void socketMetric, ServerWebSocket serverWebSocket) {
             websocketConnected.set(true);
             checker.accept(expectedThread.get(), expectedContext.get());
             return null;

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -323,15 +323,15 @@ ServerWebSocketImpl createWebSocket(HttpServerRequestImpl request) {
       if (handler != null) {
         chctx.pipeline().remove(handler);
       }
-      if (METRICS_ENABLED && metrics != null) {
-        ws.setMetric(metrics.upgrade(request.metric(), ws));
-      }
       ws.registerHandler(vertx.eventBus());
       return handshaker.selectedSubprotocol();
     };
     ws = new ServerWebSocketImpl(vertx, request.uri(), request.path(),
       request.query(), request.headers(), this, handshaker.version() != WebSocketVersion.V00,
       f, options.getMaxWebsocketFrameSize(), options.getMaxWebsocketMessageSize());
+    if (METRICS_ENABLED && metrics != null) {
+      ws.setMetric(metrics.connected(metric(), request.metric(), ws));
+    }
     return ws;
   }
 

File: src/test/java/io/vertx/core/spi/metrics/MetricsContextTest.java
Patch:
@@ -221,7 +221,7 @@ private void testHttpServerWebsocket(Function<Vertx, Context> contextFactory, Bi
       public HttpServerMetrics createHttpServerMetrics(HttpServerOptions options, SocketAddress localAddress) {
         return new DummyHttpServerMetrics() {
           @Override
-          public Void connected(Void socketMetric, ServerWebSocket serverWebSocket) {
+          public Void connected(Void socketMetric, Void requestMetric, ServerWebSocket serverWebSocket) {
             websocketConnected.set(true);
             checker.accept(expectedThread.get(), expectedContext.get());
             return null;

File: src/test/java/io/vertx/core/eventbus/ClusteredEventBusTestBase.java
Patch:
@@ -261,9 +261,9 @@ public void testMessageBodyInterceptor() throws Exception {
     }).completionHandler(ar -> latch.countDown());
     awaitLatch(latch);
     StringLengthCodec codec = new StringLengthCodec();
-    vertices[1].eventBus().registerCodec(codec).addInterceptor(sc -> {
+    vertices[1].eventBus().registerCodec(codec).addOutboundInterceptor(sc -> {
       if ("whatever".equals(sc.message().address())) {
-        assertEquals(content, sc.sentBody());
+        assertEquals(content, sc.body());
         complete();
       }
       sc.next();

File: src/main/java/io/vertx/core/http/impl/VertxHttpResponseEncoder.java
Patch:
@@ -42,6 +42,6 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
   protected boolean isContentAlwaysEmpty(HttpResponse msg) {
     // In HttpServerCodec this is tracked via a FIFO queue of HttpMethod
     // here we track it in the assembled response as we don't use HttpServerCodec
-    return msg instanceof AssembledHttpResponse && ((AssembledHttpResponse) msg).head();
+    return (msg instanceof AssembledHttpResponse && ((AssembledHttpResponse) msg).head()) || super.isContentAlwaysEmpty(msg);
   }
 }

File: src/main/java/io/vertx/core/spi/logging/LogDelegate.java
Patch:
@@ -18,6 +18,8 @@
  */
 public interface LogDelegate {
 
+  boolean isWarnEnabled();
+
   boolean isInfoEnabled();
 
   boolean isDebugEnabled();

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -340,10 +340,11 @@ public void testServerSettings() throws Exception {
     ChannelFuture fut = client.connect(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, request -> {
       request.decoder.frameListener(new Http2FrameAdapter() {
         AtomicInteger count = new AtomicInteger();
+        Context context = vertx.getOrCreateContext();
 
         @Override
         public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings newSettings) throws Http2Exception {
-          vertx.runOnContext(v -> {
+          context.runOnContext(v -> {
             switch (count.getAndIncrement()) {
               case 0:
                 // Initial settings

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -1667,7 +1667,7 @@ void run(boolean shouldPass) {
   // To get this to reliably pass with a lot of connections.
   public void testSharedServersRoundRobin() throws Exception {
 
-    int numServers = 5;
+    int numServers = VertxOptions.DEFAULT_EVENT_LOOP_POOL_SIZE / 2- 1;
     int numConnections = numServers * 20;
 
     List<NetServer> servers = new ArrayList<>();

File: src/test/java/io/vertx/test/core/WebsocketTest.java
Patch:
@@ -517,7 +517,7 @@ public void testHandleWSManually() throws Exception {
   @Test
   public void testSharedServersRoundRobin() throws Exception {
 
-    int numServers = 5;
+    int numServers = VertxOptions.DEFAULT_EVENT_LOOP_POOL_SIZE / 2- 1;
     int numConnections = numServers * 100;
 
     List<HttpServer> servers = new ArrayList<>();

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -259,7 +259,7 @@ public S writeFrame(WebSocketFrame frame) {
     synchronized (conn) {
       checkClosed();
       conn.reportBytesWritten(((WebSocketFrameInternal)frame).length());
-      conn.writeToChannel(frame);
+      conn.writeToChannel(conn.encodeFrame((WebSocketFrameImpl) frame));
     }
     return (S) this;
   }

File: src/main/java/io/vertx/core/spi/metrics/DatagramSocketMetrics.java
Patch:
@@ -41,6 +41,7 @@ public interface DatagramSocketMetrics extends NetworkMetrics<Void> {
    * @param localName
    * @param localAddress the local address the net socket is listening on.
    */
-  void listening(String localName, SocketAddress localAddress);
+  default void listening(String localName, SocketAddress localAddress) {
+  }
 
 }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -278,7 +278,9 @@ protected void initChannel(Channel ch) throws Exception {
                     }
                   } else {
                     HandlerHolder<HttpHandlers> handler = httpHandlerMgr.chooseHandler(ch.eventLoop());
-                    handler.context.executeFromIO(v -> handler.handler.exceptionHandler.handle(future.cause()));
+                    handler.context.executeFromIO(v -> {
+                      handler.handler.exceptionHandler.handle(future.cause());
+                    });
                   }
                 });
               } else {

File: src/test/java/io/vertx/test/core/HttpProxy.java
Patch:
@@ -120,7 +120,6 @@ public void start(Vertx vertx, Handler<Void> finishedHandler) {
           netClient.connect(port, host, result -> {
             if (result.succeeded()) {
               NetSocket clientSocket = result.result();
-              serverSocket.write("HTTP/1.0 200 Connection established\n\n");
               serverSocket.closeHandler(v -> clientSocket.close());
               clientSocket.closeHandler(v -> serverSocket.close());
               Pump.pump(serverSocket, clientSocket).start();

File: src/test/java/io/vertx/test/core/MetricsTest.java
Patch:
@@ -741,9 +741,8 @@ private void testHttpConnect(String host, Consumer<SocketMetric> checker) {
       assertNotNull(serverMetric);
       req.response().setStatusCode(200);
       req.response().setStatusMessage("Connection established");
-      req.response().end();
       NetSocket so = req.netSocket();
-      so.handler(req.netSocket()::write);
+      so.handler(so::write);
       so.closeHandler(v -> {
         assertNull(metrics.getMetric(req));
         assertFalse(serverMetric.socket.connected.get());

File: src/main/java/io/vertx/core/eventbus/Message.java
Patch:
@@ -23,8 +23,7 @@
  * <p>
  * Messages have a {@link #body}, which can be null, and also {@link #headers}, which can be empty.
  * <p>
- * If the message was sent specifying a reply handler it will also have a {@link #replyAddress}. In that case the message
- * can be replied to using that reply address, or, more simply by just using {@link #reply}.
+ * If the message was sent specifying a reply handler, it can be replied to using {@link #reply}.
  * <p>
  * If you want to notify the sender that processing failed, then {@link #fail} can be called.
  *

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -27,6 +27,7 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
 import javax.security.cert.X509Certificate;
+import java.nio.charset.StandardCharsets;
 import java.util.UUID;
 
 /**

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -487,9 +487,7 @@ private boolean endResponse(LastHttpContent trailer) {
         }
         responseEnded = true;
         conn.close |= !conn.options.isKeepAlive();
-        if (paused) {
-          conn.doResume();
-        }
+        conn.doResume();
         return requestEnded;
       }
     }

File: src/main/java/io/vertx/core/http/HttpClientResponse.java
Patch:
@@ -134,7 +134,9 @@ public interface HttpClientResponse extends ReadStream<Buffer> {
   /**
    * Get a net socket for the underlying connection of this request.
    * <p>
-   * USE THIS WITH CAUTION! Writing to the socket directly if you don't know what you're doing can easily break the HTTP protocol
+   * USE THIS WITH CAUTION! Writing to the socket directly if you don't know what you're doing can easily break the HTTP protocol.
+   * <p>
+   * HTTP/1.1 pipe-lined requests cannot support net socket upgrade.
    * <p>
    * One valid use-case for calling this is to receive the {@link io.vertx.core.net.NetSocket} after a HTTP CONNECT was issued to the
    * remote peer and it responded with a status code of 200.

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -13,7 +13,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpResponseStatus;
@@ -210,7 +209,7 @@ void handleEnd(MultiMap trailers) {
       if (trailers == null) {
         trailers = new CaseInsensitiveHeaders();
       }
-      response.handleEnd(null, trailers);
+      response.handleEnd(trailers);
     }
 
     @Override
@@ -259,7 +258,7 @@ void handleInterestedOpsChanged() {
 
     @Override
     void handleCustomFrame(int type, int flags, Buffer buff) {
-      response.handleUnknowFrame(new HttpFrameImpl(type, flags, buff));
+      response.handleUnknownFrame(new HttpFrameImpl(type, flags, buff));
     }
 
     void handleHeaders(Http2Headers headers, boolean end) {

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -322,7 +322,7 @@ public void writeHead(HttpMethod method, String rawMethod, String uri, MultiMap
         h.authority(hostHeader);
       } else {
         h.path(uri);
-        h.scheme("https");
+        h.scheme(conn.isSSL() ? "https" : "http");
         if (hostHeader != null) {
           h.authority(hostHeader);
         }

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -2603,6 +2603,7 @@ private void testUpgradeToClearText(HttpMethod method, Buffer expected) throws E
       .setInitialSettings(new io.vertx.core.http.Http2Settings().setMaxConcurrentStreams(20000)))
       .connectionHandler(conn -> serverConnectionCount.incrementAndGet());
     server.requestHandler(req -> {
+      assertEquals("http", req.scheme());
       assertEquals(method, req.method());
       assertEquals(HttpVersion.HTTP_2, req.version());
       assertEquals(10000, req.connection().remoteSettings().getMaxConcurrentStreams());

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -110,7 +110,7 @@ public void connect(ConnectionListener<HttpClientConnection> listener, ContextIn
   public void activate(HttpClientConnection conn) {
     if (options.getIdleTimeout() > 0) {
       ChannelPipeline pipeline = conn.channelHandlerContext().pipeline();
-      pipeline.addBefore("handler", "idle", new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
+      pipeline.addFirst("idle", new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
     }
   }
 

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -4323,7 +4323,7 @@ public void testHttpServerResponseHeadersDontContainCROrLF() throws Exception {
   }
 
   @Test
-  public void testDisableKeepAliveTimeoutInPool() throws Exception {
+  public void testDisableIdleTimeoutInPool() throws Exception {
     server.requestHandler(req -> {
       req.response().end();
     });

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -972,7 +972,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
                 if (handler.getValue() instanceof Http2ConnectionHandler) {
                   // Continue
                 } else {
-                  iterator.remove();
+                  pipeline.remove(handler.getKey());
                 }
               }
               configureHttp2(pipeline);

File: src/main/java/io/vertx/core/http/impl/HttpClientConnection.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.http.impl;
 
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 import io.vertx.core.http.HttpConnection;
@@ -24,6 +25,8 @@ public interface HttpClientConnection extends HttpConnection {
 
   Channel channel();
 
+  ChannelHandlerContext channelHandlerContext();
+
   void close();
 
   void createStream(Handler<AsyncResult<HttpClientStream>> handler);

File: src/main/java/io/vertx/core/http/impl/HeadersAdaptor.java
Patch:
@@ -122,7 +122,7 @@ public MultiMap clear() {
 
   @Override
   public Iterator<Map.Entry<String, String>> iterator() {
-    return headers.iterator();
+    return headers.iteratorAsString();
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http1xServerHandler.java
Patch:
@@ -58,9 +58,9 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
       ctx,
       holder.context,
       serverOrigin,
+      holder.handler,
       metrics);
     setConnection(conn);
-    conn.requestHandlers(holder.handler);
     if (metrics != null) {
       holder.context.executeFromIO(v -> {
         conn.metric(metrics.connected(conn.remoteAddress(), conn.remoteName()));
@@ -84,7 +84,7 @@ WebSocketServerHandshaker createHandshaker(Http1xServerConnection conn, HttpRequ
       return null;
     }
 
-    if (request.getMethod() != HttpMethod.GET) {
+    if (request.method() != HttpMethod.GET) {
       HttpServerImpl.sendError(null, METHOD_NOT_ALLOWED, ch);
       return null;
     }

File: src/main/java/io/vertx/core/http/impl/VertxHttpHandler.java
Patch:
@@ -41,7 +41,7 @@ protected Object decode(Object msg, ByteBufAllocator allocator) throws Exception
         ByteBuf newBuf = safeBuffer(content, allocator);
         if (msg instanceof LastHttpContent) {
           LastHttpContent last = (LastHttpContent) msg;
-          return new AssembledLastHttpContent(newBuf, last.trailingHeaders(), last.getDecoderResult());
+          return new AssembledLastHttpContent(newBuf, last.trailingHeaders(), last.decoderResult());
         } else {
           return new DefaultHttpContent(newBuf);
         }

File: src/test/java/io/vertx/test/core/StarterTest.java
Patch:
@@ -34,6 +34,7 @@
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
+@SuppressWarnings("deprecation")
 public class StarterTest extends VertxTestBase {
 
   Vertx vertx;

File: src/main/java/io/vertx/core/http/impl/Http1xServerHandler.java
Patch:
@@ -58,9 +58,9 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
       ctx,
       holder.context,
       serverOrigin,
+      holder.handler,
       metrics);
     setConnection(conn);
-    conn.requestHandlers(holder.handler);
     if (metrics != null) {
       holder.context.executeFromIO(v -> {
         conn.metric(metrics.connected(conn.remoteAddress(), conn.remoteName()));

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -375,13 +375,13 @@ private HttpClientResponseImpl beginResponse(HttpResponse resp) {
       if (resp.status().code() != 100 && request.method() != io.vertx.core.http.HttpMethod.CONNECT) {
         // See https://tools.ietf.org/html/rfc7230#section-6.3
         String responseConnectionHeader = resp.headers().get(HttpHeaders.Names.CONNECTION);
-        HttpVersion protocolVersion = conn.options.getProtocolVersion();
+        io.netty.handler.codec.http.HttpVersion protocolVersion = resp.protocolVersion();
         String requestConnectionHeader = request.headers().get(HttpHeaders.Names.CONNECTION);
         // We don't need to protect against concurrent changes on forceClose as it only goes from false -> true
         if (HttpHeaders.Values.CLOSE.equalsIgnoreCase(responseConnectionHeader) || HttpHeaders.Values.CLOSE.equalsIgnoreCase(requestConnectionHeader)) {
           // In all cases, if we have a close connection option then we SHOULD NOT treat the connection as persistent
           close = true;
-        } else if (protocolVersion == HttpVersion.HTTP_1_0 && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(responseConnectionHeader)) {
+        } else if (protocolVersion == io.netty.handler.codec.http.HttpVersion.HTTP_1_0 && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(responseConnectionHeader)) {
           // In the HTTP/1.0 case both request/response need a keep-alive connection header the connection to be persistent
           // currently Vertx forces the Connection header if keepalive is enabled for 1.0
           close = true;

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -197,7 +197,7 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
 
   private void applyHttp2ConnectionOptions(ChannelPipeline pipeline) {
     if (client.getOptions().getIdleTimeout() > 0) {
-      pipeline.addLast("idle", new IdleStateHandler(0, 0, options.getIdleTimeout()));
+      pipeline.addLast("idle", new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
     }
   }
 
@@ -216,7 +216,8 @@ private void applyHttp1xConnectionOptions(ChannelPipeline pipeline) {
       pipeline.addLast("inflater", new HttpContentDecompressor(true));
     }
     if (client.getOptions().getIdleTimeout() > 0) {
-      pipeline.addLast("idle", new IdleStateHandler(0, 0, client.getOptions().getIdleTimeout()));
+      HttpClientOptions options = client.getOptions();
+      pipeline.addLast("idle", new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -290,7 +290,7 @@ protected void initChannel(Channel ch) throws Exception {
                 } else {
                   IdleStateHandler idle;
                   if (options.getIdleTimeout() > 0) {
-                    pipeline.addLast("idle", idle = new IdleStateHandler(0, 0, options.getIdleTimeout()));
+                    pipeline.addLast("idle", idle = new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
                   } else {
                     idle = null;
                   }
@@ -440,7 +440,7 @@ private void configureHttp1(ChannelPipeline pipeline, HandlerHolder<HttpHandlers
       pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());       // For large file / sendfile support
     }
     if (options.getIdleTimeout() > 0) {
-      pipeline.addLast("idle", new IdleStateHandler(0, 0, options.getIdleTimeout()));
+      pipeline.addLast("idle", new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
     }
     if (!DISABLE_H2C) {
       pipeline.addLast("h2c", new Http2UpgradeHandler());
@@ -492,7 +492,7 @@ private void handleHttp2(Channel ch) {
 
   private void configureHttp2(ChannelPipeline pipeline) {
     if (options.getIdleTimeout() > 0) {
-      pipeline.addBefore("handler", "idle", new IdleStateHandler(0, 0, options.getIdleTimeout()));
+      pipeline.addBefore("handler", "idle", new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
     }
   }
 

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -141,7 +141,7 @@ protected void initChannel(ChannelPipeline pipeline) {
       pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());       // For large file / sendfile support
     }
     if (options.getIdleTimeout() > 0) {
-      pipeline.addLast("idle", new IdleStateHandler(0, 0, options.getIdleTimeout()));
+      pipeline.addLast("idle", new IdleStateHandler(0, 0, options.getIdleTimeout(), options.getIdleTimeoutUnit()));
     }
   }
 

File: src/test/java/io/vertx/test/core/Http1xTest.java
Patch:
@@ -131,8 +131,11 @@ public void testClientOptions() {
     assertTrue(options.isUsePooledBuffers());
 
     assertEquals(0, options.getIdleTimeout());
+    assertEquals(TimeUnit.SECONDS, options.getIdleTimeoutUnit());
     assertEquals(options, options.setIdleTimeout(10));
+    assertEquals(options, options.setIdleTimeoutUnit(TimeUnit.MILLISECONDS));
     assertEquals(10, options.getIdleTimeout());
+    assertEquals(TimeUnit.MILLISECONDS, options.getIdleTimeoutUnit());
     assertIllegalArgumentException(() -> options.setIdleTimeout(-1));
 
     assertFalse(options.isSsl());

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -2761,7 +2761,7 @@ public void testUpgradeToClearTextPartialFailure() throws Exception {
   public void testIdleTimeout() throws Exception {
     waitFor(5);
     server.close();
-    server = vertx.createHttpServer(serverOptions.setIdleTimeout(2));
+    server = vertx.createHttpServer(serverOptions.setIdleTimeoutUnit(TimeUnit.MILLISECONDS).setIdleTimeout(2000));
     server.requestHandler(req -> {
       req.exceptionHandler(err -> {
         assertTrue(err instanceof ClosedChannelException);

File: src/test/java/io/vertx/test/core/Http1xTest.java
Patch:
@@ -3049,7 +3049,7 @@ public void testHttpSocksProxyRequestAuth() throws Exception {
   @Test
   public void testRandomPorts() throws Exception {
     int numServers = 10;
-    Set<Integer> ports = new HashSet<>();
+    Set<Integer> ports = Collections.synchronizedSet(new HashSet<>());
     AtomicInteger count = new AtomicInteger();
     for (int i = 0;i < numServers;i++) {
       vertx.createHttpServer().requestHandler(req -> {

File: src/main/java/io/vertx/core/shareddata/impl/SharedDataImpl.java
Patch:
@@ -41,14 +41,15 @@ public class SharedDataImpl implements SharedData {
 
   private final VertxInternal vertx;
   private final ClusterManager clusterManager;
+  private final LocalAsyncLocks localAsyncLocks;
   private final ConcurrentMap<String, LocalAsyncMapImpl<?, ?>> localAsyncMaps = new ConcurrentHashMap<>();
-  private final ConcurrentMap<String, AsynchronousLock> localLocks = new ConcurrentHashMap<>();
   private final ConcurrentMap<String, Counter> localCounters = new ConcurrentHashMap<>();
   private final ConcurrentMap<String, LocalMap<?, ?>> localMaps = new ConcurrentHashMap<>();
 
   public SharedDataImpl(VertxInternal vertx, ClusterManager clusterManager) {
     this.vertx = vertx;
     this.clusterManager = clusterManager;
+    localAsyncLocks = clusterManager == null ? new LocalAsyncLocks() : null;
   }
 
   @Override
@@ -132,8 +133,7 @@ private <K, V> void getLocalAsyncMap(String name, Handler<AsyncResult<AsyncMap<K
   }
 
   private void getLocalLock(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler) {
-    AsynchronousLock lock = localLocks.computeIfAbsent(name, n -> new AsynchronousLock(vertx));
-    lock.acquire(timeout, resultHandler);
+    localAsyncLocks.acquire(vertx.getOrCreateContext(), name, timeout, resultHandler);
   }
 
   private void getLocalCounter(String name, Handler<AsyncResult<Counter>> resultHandler) {

File: src/test/benchmarks/io/vertx/core/impl/VertxExecutorService.java
Patch:
@@ -24,6 +24,6 @@ public VertxExecutorService(int maxThreads, String prefix) {
     super(maxThreads, maxThreads,
         0L, TimeUnit.MILLISECONDS,
         new LinkedBlockingQueue<>(),
-        new VertxThreadFactory(prefix, new BlockedThreadChecker(10000, TimeUnit.NANOSECONDS, 10000, TimeUnit.NANOSECONDS), false, 10000, TimeUnit.NANOSECONDS));
+        new VertxThreadFactory(prefix, new BlockedThreadChecker(10000, TimeUnit.MILLISECONDS, 10000, TimeUnit.MILLISECONDS), false, 10000, TimeUnit.NANOSECONDS));
   }
 }

File: src/main/java/io/vertx/core/shareddata/impl/SharedDataImpl.java
Patch:
@@ -41,14 +41,15 @@ public class SharedDataImpl implements SharedData {
 
   private final VertxInternal vertx;
   private final ClusterManager clusterManager;
+  private final LocalAsyncLocks localAsyncLocks;
   private final ConcurrentMap<String, LocalAsyncMapImpl<?, ?>> localAsyncMaps = new ConcurrentHashMap<>();
-  private final ConcurrentMap<String, AsynchronousLock> localLocks = new ConcurrentHashMap<>();
   private final ConcurrentMap<String, Counter> localCounters = new ConcurrentHashMap<>();
   private final ConcurrentMap<String, LocalMap<?, ?>> localMaps = new ConcurrentHashMap<>();
 
   public SharedDataImpl(VertxInternal vertx, ClusterManager clusterManager) {
     this.vertx = vertx;
     this.clusterManager = clusterManager;
+    localAsyncLocks = clusterManager == null ? new LocalAsyncLocks() : null;
   }
 
   @Override
@@ -132,8 +133,7 @@ private <K, V> void getLocalAsyncMap(String name, Handler<AsyncResult<AsyncMap<K
   }
 
   private void getLocalLock(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler) {
-    AsynchronousLock lock = localLocks.computeIfAbsent(name, n -> new AsynchronousLock(vertx));
-    lock.acquire(timeout, resultHandler);
+    localAsyncLocks.acquire(vertx.getOrCreateContext(), name, timeout, resultHandler);
   }
 
   private void getLocalCounter(String name, Handler<AsyncResult<Counter>> resultHandler) {

File: src/main/java/io/vertx/core/net/impl/transport/Transport.java
Patch:
@@ -199,7 +199,6 @@ public void configure(DatagramChannel channel, DatagramSocketOptions options) {
   }
 
   public void configure(ClientOptionsBase options, Bootstrap bootstrap) {
-    BiConsumer<ChannelOption<Object>, Object> setter = bootstrap::option;
     if (options.getLocalAddress() != null) {
       bootstrap.localAddress(options.getLocalAddress(), 0);
     }
@@ -224,7 +223,6 @@ public void configure(ClientOptionsBase options, Bootstrap bootstrap) {
   }
 
   public void configure(NetServerOptions options, ServerBootstrap bootstrap) {
-    BiConsumer<ChannelOption<Object>, Object> setter = bootstrap::childOption;
     bootstrap.childOption(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());
     if (options.getSendBufferSize() != -1) {
       bootstrap.childOption(ChannelOption.SO_SNDBUF, options.getSendBufferSize());
@@ -234,7 +232,7 @@ public void configure(NetServerOptions options, ServerBootstrap bootstrap) {
       bootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(options.getReceiveBufferSize()));
     }
     if (options.getSoLinger() != -1) {
-      bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+      bootstrap.childOption(ChannelOption.SO_LINGER, options.getSoLinger());
     }
     if (options.getTrafficClass() != -1) {
       bootstrap.childOption(ChannelOption.IP_TOS, options.getTrafficClass());

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -352,8 +352,7 @@ public void channelRead(ChannelHandlerContext chctx, Object msg) throws Exceptio
           }
           @Override
           protected void handleMessage(NetSocketImpl connection, Object msg) {
-            ByteBuf buf = (ByteBuf) msg;
-            connection.handleMessageReceived(buf);
+            connection.handleMessageReceived(msg);
           }
         }.removeHandler(sock -> conn.listener.onDiscard()));
 

File: src/main/java/io/vertx/core/http/impl/Http1xClientHandler.java
Patch:
@@ -14,6 +14,7 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.http.impl.pool.ConnectionListener;
@@ -109,7 +110,8 @@ protected void handleMessage(Http1xClientConnection conn, Object msg) {
           if (!closeFrameSent) {
             // Echo back close frame and close the connection once it was written.
             // This is specified in the WebSockets RFC 6455 Section  5.4.1
-            chctx.writeAndFlush(frame).addListener(ChannelFutureListener.CLOSE);
+            CloseWebSocketFrame closeFrame = new CloseWebSocketFrame(frame.closeStatusCode(), frame.closeReason());
+            chctx.writeAndFlush(closeFrame).addListener(ChannelFutureListener.CLOSE);
             closeFrameSent = true;
           }
           break;

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -291,8 +291,7 @@ public void channelRead(ChannelHandlerContext chctx, Object msg) throws Exceptio
 
       @Override
       protected void handleMessage(NetSocketImpl connection, Object msg) {
-        ByteBuf buf = (ByteBuf) msg;
-        connection.handleMessageReceived(buf);
+        connection.handleMessageReceived(msg);
       }
     }.removeHandler(sock -> connectionMap.remove(chctx.channel())));
 

File: src/test/java/io/vertx/test/core/ClusteredAsynchronousLockTest.java
Patch:
@@ -32,7 +32,7 @@ protected ClusterManager getClusterManager() {
     return new FakeClusterManager();
   }
 
-  protected final int numNodes = 2;
+  protected final int numNodes = 3;
 
   public void setUp() throws Exception {
     super.setUp();

File: src/test/java/io/vertx/core/impl/launcher/commands/WatcherAbsolutePathTest.java
Patch:
@@ -42,7 +42,7 @@ public void prepare() {
             root.getAbsolutePath() + File.separator + "**" + File.separator + "*.txt",
             root.getAbsolutePath() + File.separator + "windows\\*.win",
             root.getAbsolutePath() + File.separator + "unix/*.nix",
-            "FOO.bar")), next -> {
+            root.getAbsolutePath() + File.separator + "FOO.bar")), next -> {
       deploy.incrementAndGet();
       if (next != null) {
         next.handle(null);

File: src/test/java/io/vertx/test/core/Http1xTest.java
Patch:
@@ -1647,6 +1647,7 @@ public void testSharedServersRoundRobin() throws Exception {
       assertTrue(connectedServers.contains(server));
     }
     assertEquals(numServers, requestCount.size());
+    assertEquals(requestCount.values().stream().mapToInt(i -> i).sum(), numRequests);
     for (int cnt : requestCount.values()) {
       assertEquals(numRequests / numServers, cnt);
     }

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -47,7 +47,6 @@
 import java.io.FileOutputStream;
 import java.io.OutputStreamWriter;
 import java.io.UnsupportedEncodingException;
-import java.net.InetAddress;
 import java.net.URLEncoder;
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
@@ -3384,7 +3383,7 @@ public void testClientLogging() throws Exception {
 
   @Test
   public void testClientLocalAddress() throws Exception {
-    String expectedAddress = InetAddress.getLocalHost().getHostAddress();
+    String expectedAddress = TestUtils.loopbackAddress();
     client.close();
     client = vertx.createHttpClient(createBaseClientOptions().setLocalAddress(expectedAddress));
     server.requestHandler(req -> {

File: src/test/java/io/vertx/test/core/ProxyErrorTest.java
Patch:
@@ -44,7 +44,7 @@ public class ProxyErrorTest extends VertxTestBase {
 
   @Override
   public void setUp() throws Exception {
-    dnsServer = FakeDNSServer.testLookupNonExisting();
+    dnsServer = new FakeDNSServer().testLookupNonExisting();
     dnsServer.start();
     dnsServerAddress = dnsServer.localAddress();
     super.setUp();

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -47,7 +47,6 @@
 import java.io.FileOutputStream;
 import java.io.OutputStreamWriter;
 import java.io.UnsupportedEncodingException;
-import java.net.InetAddress;
 import java.net.URLEncoder;
 import java.util.*;
 import java.util.concurrent.CompletableFuture;
@@ -3384,7 +3383,7 @@ public void testClientLogging() throws Exception {
 
   @Test
   public void testClientLocalAddress() throws Exception {
-    String expectedAddress = InetAddress.getLocalHost().getHostAddress();
+    String expectedAddress = TestUtils.loopbackAddress();
     client.close();
     client = vertx.createHttpClient(createBaseClientOptions().setLocalAddress(expectedAddress));
     server.requestHandler(req -> {

File: src/test/java/io/vertx/test/core/FileResolverTestBase.java
Patch:
@@ -61,7 +61,7 @@ public void testReadFileInDirThenReadDir() {
     Buffer buff = vertx.fileSystem().readFileBlocking("webroot/subdir/subfile.html");
     assertEquals(buff.toString(), "<html><body>subfile</body></html>");
     Set<String> names = vertx.fileSystem().readDirBlocking("webroot/subdir").stream().map(path -> {
-      int idx = path.lastIndexOf('/');
+      int idx = path.lastIndexOf(File.separator);
       return idx == -1 ? path : path.substring(idx + 1);
     }).collect(Collectors.toSet());
     assertEquals(names, new HashSet<>(Arrays.asList("subdir2", "subfile.html")));

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponseImpl.java
Patch:
@@ -13,7 +13,6 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.HttpHeaderNames;
@@ -26,7 +25,6 @@
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.MultiMap;
-import io.vertx.core.VertxException;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpServerResponse;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -17,13 +17,13 @@
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.core.*;
 import io.vertx.core.buffer.Buffer;
-import io.vertx.core.http.CaseInsensitiveHeaders;
 import io.vertx.core.http.HttpClientRequest;
 import io.vertx.core.http.HttpClientResponse;
 import io.vertx.core.http.HttpConnection;
 import io.vertx.core.http.HttpFrame;
 import io.vertx.core.http.HttpMethod;
 import io.vertx.core.http.HttpVersion;
+import io.vertx.core.http.impl.headers.VertxHttpHeaders;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.logging.Logger;
@@ -68,7 +68,7 @@ public class HttpClientRequestImpl extends HttpClientRequestBase implements Http
   private int pendingMaxSize = -1;
   private int followRedirects;
   private long written;
-  private CaseInsensitiveHeaders headers;
+  private VertxHttpHeaders headers;
 
   private HttpClientStream stream;
   private boolean connecting;
@@ -183,7 +183,7 @@ public synchronized String getHost() {
   @Override
   public synchronized MultiMap headers() {
     if (headers == null) {
-      headers = new CaseInsensitiveHeaders();
+      headers = new VertxHttpHeaders();
     }
     return headers;
   }

File: src/main/java/io/vertx/core/Starter.java
Patch:
@@ -380,6 +380,8 @@ private void configureFromSystemProperties(Object options, String prefix) {
             arg = Long.valueOf(propVal);
           } else if (argType.equals(boolean.class)) {
             arg = Boolean.valueOf(propVal);
+          } else if (argType.isEnum()){
+            arg = Enum.valueOf((Class<? extends Enum>)argType, propVal);
           } else {
             log.warn("Invalid type for setter: " + argType);
             continue;

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -467,7 +467,7 @@ private void doDeploy(String identifier, String deploymentID, DeploymentOptions
     AtomicInteger deployCount = new AtomicInteger();
     AtomicBoolean failureReported = new AtomicBoolean();
     for (Verticle verticle: verticles) {
-      WorkerExecutorInternal workerExec = poolName != null ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize(), options.getMaxWorkerExecuteTime()) : null;
+      WorkerExecutorInternal workerExec = poolName != null ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize(), options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit()) : null;
       WorkerPool pool = workerExec != null ? workerExec.getPool() : null;
       ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :
         vertx.createEventLoopContext(deploymentID, pool, conf, tccl);

File: src/main/java/io/vertx/core/impl/launcher/commands/BareCommand.java
Patch:
@@ -276,6 +276,8 @@ protected void configureFromSystemProperties(Object options, String prefix) {
             arg = Long.valueOf(propVal);
           } else if (argType.equals(boolean.class)) {
             arg = Boolean.valueOf(propVal);
+          } else if (argType.isEnum()){
+            arg = Enum.valueOf((Class<? extends Enum>)argType, propVal);
           } else {
             log.warn("Invalid type for setter: " + argType);
             continue;

File: src/test/benchmarks/io/vertx/core/impl/VertxExecutorService.java
Patch:
@@ -24,6 +24,6 @@ public VertxExecutorService(int maxThreads, String prefix) {
     super(maxThreads, maxThreads,
         0L, TimeUnit.MILLISECONDS,
         new LinkedBlockingQueue<>(),
-        new VertxThreadFactory(prefix, new BlockedThreadChecker(10000, 10000), false, 10000));
+        new VertxThreadFactory(prefix, new BlockedThreadChecker(10000, TimeUnit.NANOSECONDS, 10000, TimeUnit.NANOSECONDS), false, 10000, TimeUnit.NANOSECONDS));
   }
 }

File: src/test/java/io/vertx/test/core/LauncherTest.java
Patch:
@@ -36,6 +36,7 @@
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Set;
+import java.util.concurrent.TimeUnit;
 
 public class LauncherTest extends VertxTestBase {
 
@@ -423,6 +424,7 @@ private void testConfigureFromSystemProperties(boolean clustered) throws Excepti
     System.setProperty(RunCommand.VERTX_OPTIONS_PROP_PREFIX + "maxEventLoopExecuteTime", "123767667");
     System.setProperty(RunCommand.METRICS_OPTIONS_PROP_PREFIX + "enabled", "true");
     System.setProperty(RunCommand.VERTX_OPTIONS_PROP_PREFIX + "haGroup", "somegroup");
+    System.setProperty(RunCommand.VERTX_OPTIONS_PROP_PREFIX + "maxEventLoopExecuteTimeUnit", "SECONDS");
 
     MyLauncher launcher = new MyLauncher();
     String[] args;
@@ -440,6 +442,7 @@ private void testConfigureFromSystemProperties(boolean clustered) throws Excepti
     assertEquals(123767667L, opts.getMaxEventLoopExecuteTime());
     assertEquals(true, opts.getMetricsOptions().isEnabled());
     assertEquals("somegroup", opts.getHAGroup());
+    assertEquals(TimeUnit.SECONDS, opts.getMaxEventLoopExecuteTimeUnit());
 
   }
 

File: src/test/java/io/vertx/test/core/StarterTest.java
Patch:
@@ -29,6 +29,7 @@
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Set;
+import java.util.concurrent.TimeUnit;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
@@ -198,6 +199,7 @@ private void testConfigureFromSystemProperties(boolean clustered) throws Excepti
     System.setProperty(Starter.VERTX_OPTIONS_PROP_PREFIX + "maxEventLoopExecuteTime", "123767667");
     System.setProperty(Starter.METRICS_OPTIONS_PROP_PREFIX + "enabled", "true");
     System.setProperty(Starter.VERTX_OPTIONS_PROP_PREFIX + "haGroup", "somegroup");
+    System.setProperty(Starter.VERTX_OPTIONS_PROP_PREFIX + "maxEventLoopExecuteTimeUnit", "SECONDS");
 
     MyStarter starter = new MyStarter();
     String[] args;
@@ -215,6 +217,7 @@ private void testConfigureFromSystemProperties(boolean clustered) throws Excepti
     assertEquals(123767667L, opts.getMaxEventLoopExecuteTime());
     assertEquals(true, opts.getMetricsOptions().isEnabled());
     assertEquals("somegroup", opts.getHAGroup());
+    assertEquals(TimeUnit.SECONDS, opts.getMaxEventLoopExecuteTimeUnit());
 
     cleanup(starter);
   }

File: src/main/java/io/vertx/core/dns/impl/DnsClientImpl.java
Patch:
@@ -263,7 +263,7 @@ private class Query<T> {
     long timerID;
 
     public Query(String name, DnsRecordType[] types, Handler<AsyncResult<List<T>>> handler) {
-      this.msg = new DatagramDnsQuery(null, dnsServer, ThreadLocalRandom.current().nextInt()).setRecursionDesired(true);
+      this.msg = new DatagramDnsQuery(null, dnsServer, ThreadLocalRandom.current().nextInt()).setRecursionDesired(options.isRecursionDesired());
       for (DnsRecordType type: types) {
         msg.addRecord(DnsSection.QUESTION, new DefaultDnsQuestion(name, type, DnsRecord.CLASS_IN));
       }

File: src/main/java/io/vertx/core/impl/VertxFactoryImpl.java
Patch:
@@ -27,22 +27,22 @@ public class VertxFactoryImpl implements VertxFactory {
 
   @Override
   public Vertx vertx() {
-    return new VertxImpl();
+    return vertx(new VertxOptions());
   }
 
   @Override
   public Vertx vertx(VertxOptions options) {
     if (options.isClustered()) {
       throw new IllegalArgumentException("Please use Vertx.clusteredVertx() to create a clustered Vert.x instance");
     }
-    return new VertxImpl(options);
+    return VertxImpl.vertx(options);
   }
 
   @Override
   public void clusteredVertx(VertxOptions options, final Handler<AsyncResult<Vertx>> resultHandler) {
     // We don't require the user to set clustered to true if they use this method
     options.setClustered(true);
-    new VertxImpl(options, resultHandler);
+    VertxImpl.clusteredVertx(options, resultHandler);
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -102,6 +102,8 @@ public interface VertxInternal extends Vertx {
 
   ClusterManager getClusterManager();
 
+  HAManager haManager();
+
   /**
    * Resolve an address (e.g. {@code vertx.io} into the first found A (IPv4) or AAAA (IPv6) record.
    *

File: src/main/java/io/vertx/core/impl/VertxFactoryImpl.java
Patch:
@@ -27,22 +27,22 @@ public class VertxFactoryImpl implements VertxFactory {
 
   @Override
   public Vertx vertx() {
-    return new VertxImpl();
+    return vertx(new VertxOptions());
   }
 
   @Override
   public Vertx vertx(VertxOptions options) {
     if (options.isClustered()) {
       throw new IllegalArgumentException("Please use Vertx.clusteredVertx() to create a clustered Vert.x instance");
     }
-    return new VertxImpl(options);
+    return VertxImpl.vertx(options);
   }
 
   @Override
   public void clusteredVertx(VertxOptions options, final Handler<AsyncResult<Vertx>> resultHandler) {
     // We don't require the user to set clustered to true if they use this method
     options.setClustered(true);
-    new VertxImpl(options, resultHandler);
+    VertxImpl.clusteredVertx(options, resultHandler);
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -102,6 +102,8 @@ public interface VertxInternal extends Vertx {
 
   ClusterManager getClusterManager();
 
+  HAManager haManager();
+
   /**
    * Resolve an address (e.g. {@code vertx.io} into the first found A (IPv4) or AAAA (IPv6) record.
    *

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandlerBuilder.java
Patch:
@@ -134,11 +134,11 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) th
         throw new UnsupportedOperationException();
       }
       @Override
-      public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+      public void onPingRead(ChannelHandlerContext channelHandlerContext, long l) throws Http2Exception {
         throw new UnsupportedOperationException();
       }
       @Override
-      public void onPingAckRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
+      public void onPingAckRead(ChannelHandlerContext channelHandlerContext, long l) throws Http2Exception {
         throw new UnsupportedOperationException();
       }
       @Override

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -2830,8 +2830,8 @@ public void testSendPing() throws Exception {
     ChannelFuture fut = client.connect(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, request -> {
       request.decoder.frameListener(new Http2EventAdapter() {
         @Override
-        public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
-          Buffer buffer = Buffer.buffer(data.copy());
+        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {
+          Buffer buffer = Buffer.buffer().appendLong(data);
           vertx.runOnContext(v -> {
             assertEquals(expected, buffer);
             complete();
@@ -2859,7 +2859,7 @@ public void testReceivePing() throws Exception {
     startServer(ctx);
     TestClient client = new TestClient();
     ChannelFuture fut = client.connect(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, request -> {
-      request.encoder.writePing(request.context, false, expected.getByteBuf(), request.context.newPromise());
+      request.encoder.writePing(request.context, false, expected.getLong(0), request.context.newPromise());
     });
     fut.sync();
     await();

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -216,9 +216,9 @@ protected synchronized void handleException(Throwable t) {
       exceptionHandler.handle(t);
     } else {
       if (log.isDebugEnabled()) {
-        log.error(t.getMessage());
-      } else {
         log.error(t.getMessage(), t);
+      } else {
+        log.error(t.getMessage());
       }
     }
   }

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -19,6 +19,7 @@
 import io.vertx.core.ServiceHelper;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
+import io.vertx.core.shareddata.Shareable;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
 import io.vertx.core.spi.BufferFactory;
 
@@ -36,7 +37,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface Buffer extends ClusterSerializable {
+public interface Buffer extends ClusterSerializable, Shareable {
 
   /**
    * Create a new, empty buffer.

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.json;
 
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.shareddata.Shareable;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
 
 import java.time.Instant;
@@ -33,7 +34,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class JsonArray implements Iterable<Object>, ClusterSerializable {
+public class JsonArray implements Iterable<Object>, ClusterSerializable, Shareable {
 
   private List<Object> list;
 
@@ -571,6 +572,7 @@ public String encodePrettily() {
    *
    * @return a copy
    */
+  @Override
   public JsonArray copy() {
     List<Object> copiedList = new ArrayList<>(list.size());
     for (Object val: list) {

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -12,6 +12,7 @@
 
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.shareddata.Shareable;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
 
 import java.nio.charset.StandardCharsets;
@@ -34,7 +35,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class JsonObject implements Iterable<Map.Entry<String, Object>>, ClusterSerializable {
+public class JsonObject implements Iterable<Map.Entry<String, Object>>, ClusterSerializable, Shareable {
 
   private Map<String, Object> map;
 
@@ -784,6 +785,7 @@ public Buffer toBuffer() {
    *
    * @return a copy of the object
    */
+  @Override
   public JsonObject copy() {
     Map<String, Object> copiedMap;
     if (map instanceof LinkedHashMap) {

File: src/main/java/io/vertx/core/shareddata/LocalMap.java
Patch:
@@ -24,13 +24,12 @@
 /**
  * Local maps can be used to share data safely in a single Vert.x instance.
  * <p>
- * The map only allows immutable keys and values in the map, OR certain mutable objects such as {@link io.vertx.core.buffer.Buffer}
- * instances which will be copied when they are added to the map.
+ * By default the map allows immutable keys and values.
+ * Custom keys and values should implement {@link Shareable} interface. The map returns their copies.
  * <p>
  * This ensures there is no shared access to mutable state from different threads (e.g. different event loops) in the
  * Vert.x instance, and means you don't have to protect access to that state using synchronization or locks.
  * <p>
- * Your own objects can be marked as immutable by implementing the {@link Shareable} interface.
  *
  * Since the version 3.4, this class extends the {@link Map} interface. However some methods are only accessible in Java.
  *

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -75,7 +75,7 @@ private DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
       channel.pipeline().addLast("logging", new LoggingHandler());
     }
     VertxMetrics metrics = vertx.metricsSPI();
-    this.metrics = metrics != null ? metrics.createMetrics(this, options) : null;
+    this.metrics = metrics != null ? metrics.createDatagramSocketMetrics(options) : null;
     this.channel = channel;
     this.context = context;
   }

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -63,7 +63,7 @@ public class EventBusImpl implements EventBus, MetricsProvider {
   public EventBusImpl(VertxInternal vertx) {
     VertxMetrics metrics = vertx.metricsSPI();
     this.vertx = vertx;
-    this.metrics = metrics != null ? metrics.createMetrics(this) : null;
+    this.metrics = metrics != null ? metrics.createEventBusMetrics() : null;
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -43,7 +43,6 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
-import java.util.function.Consumer;
 import java.util.function.Function;
 
 /**
@@ -114,7 +113,7 @@ public class HttpClientImpl implements HttpClient, MetricsProvider {
 
   public HttpClientImpl(VertxInternal vertx, HttpClientOptions options) {
     this.vertx = vertx;
-    this.metrics = vertx.metricsSPI() != null ? vertx.metricsSPI().createMetrics(this, options) : null;
+    this.metrics = vertx.metricsSPI() != null ? vertx.metricsSPI().createHttpClientMetrics(options) : null;
     this.options = new HttpClientOptions(options);
     List<HttpVersion> alpnVersions = options.getAlpnVersions();
     if (alpnVersions == null || alpnVersions.isEmpty()) {

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -222,7 +222,7 @@ public HttpServer listen(int port, Handler<AsyncResult<HttpServer>> listenHandle
   public HttpServer listen(int port, String host, Handler<AsyncResult<HttpServer>> listenHandler) {
     return listen(SocketAddress.inetSocketAddress(port, host), listenHandler);
   }
-    
+
   public synchronized HttpServer listen(SocketAddress address, Handler<AsyncResult<HttpServer>> listenHandler) {
     if (requestStream.handler() == null && wsStream.handler() == null) {
       throw new IllegalStateException("Set request or websocket handler first");
@@ -348,7 +348,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
 	      }
               serverChannelGroup.add(serverChannel);
               VertxMetrics metrics = vertx.metricsSPI();
-              this.metrics = metrics != null ? metrics.createMetrics(this, address, options) : null;
+              this.metrics = metrics != null ? metrics.createHttpServerMetrics(options, address) : null;
             }
           });
         } catch (final Throwable t) {
@@ -370,7 +370,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         this.actualPort = shared.actualPort;
         addHandlers(actualServer, listenContext);
         VertxMetrics metrics = vertx.metricsSPI();
-        this.metrics = metrics != null ? metrics.createMetrics(this, address, options) : null;
+        this.metrics = metrics != null ? metrics.createHttpServerMetrics(options, address) : null;
       }
       actualServer.bindFuture.addListener(future -> {
         if (listenHandler != null) {

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -84,7 +84,7 @@ public NetClientImpl(VertxInternal vertx, NetClientOptions options, boolean useC
       creatingContext = null;
     }
     VertxMetrics metrics = vertx.metricsSPI();
-    this.metrics = metrics != null ? metrics.createMetrics(options) : null;
+    this.metrics = metrics != null ? metrics.createNetClientMetrics(options) : null;
     logEnabled = options.getLogActivity();
     idleTimeout = options.getIdleTimeout();
   }

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -229,7 +229,7 @@ protected void initChannel(Channel ch) throws Exception {
               vertx.sharedNetServers().put(id, NetServerImpl.this);
               VertxMetrics metrics = vertx.metricsSPI();
               if (metrics != null) {
-                this.metrics = metrics.createMetrics(new SocketAddressImpl(id.port, id.host), options);
+                this.metrics = metrics.createNetServerMetrics(options, new SocketAddressImpl(id.port, id.host));
               }
             } else {
               vertx.sharedNetServers().remove(id);
@@ -256,7 +256,7 @@ protected void initChannel(Channel ch) throws Exception {
         actualServer = shared;
         this.actualPort = shared.actualPort();
         VertxMetrics metrics = vertx.metricsSPI();
-        this.metrics = metrics != null ? metrics.createMetrics(new SocketAddressImpl(id.port, id.host), options) : null;
+        this.metrics = metrics != null ? metrics.createNetServerMetrics(options, new SocketAddressImpl(id.port, id.host)) : null;
         actualServer.handlerManager.addHandler(new Handlers(handler, exceptionHandler), listenContext);
       }
 

File: src/main/java/io/vertx/core/spi/VertxMetricsFactory.java
Patch:
@@ -11,7 +11,6 @@
 
 package io.vertx.core.spi;
 
-import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
 import io.vertx.core.metrics.MetricsOptions;
 import io.vertx.core.spi.metrics.VertxMetrics;
@@ -28,11 +27,10 @@ public interface VertxMetricsFactory {
    *
    * No specific thread and context can be expected when this method is called.
    *
-   * @param vertx the vertx instance
    * @param options the metrics configuration option
    * @return the metrics implementation
    */
-  VertxMetrics metrics(Vertx vertx, VertxOptions options);
+  VertxMetrics metrics(VertxOptions options);
 
   /**
    * Create an empty metrics options. Providers can override this method to provide a custom metrics options subclass

File: src/test/java/io/vertx/test/core/CustomMetricsFactory.java
Patch:
@@ -11,7 +11,6 @@
 
 package io.vertx.test.core;
 
-import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
 import io.vertx.core.metrics.MetricsOptions;
 import io.vertx.core.metrics.impl.DummyVertxMetrics;
@@ -24,7 +23,7 @@
 public class CustomMetricsFactory implements VertxMetricsFactory {
 
   @Override
-  public VertxMetrics metrics(Vertx vertx, VertxOptions options) {
+  public VertxMetrics metrics(VertxOptions options) {
     return DummyVertxMetrics.INSTANCE;
   }
 

File: src/test/java/io/vertx/test/core/SimpleVertxMetricsFactory.java
Patch:
@@ -11,7 +11,6 @@
 
 package io.vertx.test.core;
 
-import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
 import io.vertx.core.spi.VertxMetricsFactory;
 import io.vertx.core.spi.metrics.VertxMetrics;
@@ -28,7 +27,7 @@ public SimpleVertxMetricsFactory(M instance) {
   }
 
   @Override
-  public VertxMetrics metrics(Vertx vertx, VertxOptions options) {
+  public VertxMetrics metrics(VertxOptions options) {
     return instance;
   }
 }

File: src/test/java/io/vertx/test/fakemetrics/FakeHttpClientMetrics.java
Patch:
@@ -15,7 +15,6 @@
 import io.vertx.core.http.HttpClientResponse;
 import io.vertx.core.http.WebSocket;
 import io.vertx.core.http.WebSocketBase;
-import io.vertx.core.metrics.Measured;
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.spi.metrics.HttpClientMetrics;
 
@@ -34,8 +33,7 @@ public class FakeHttpClientMetrics extends FakeMetricsBase implements HttpClient
   private final ConcurrentMap<HttpClientRequest, HttpClientMetric> requests = new ConcurrentHashMap<>();
   private final ConcurrentHashMap<String, EndpointMetric> endpoints = new ConcurrentHashMap<>();
 
-  public FakeHttpClientMetrics(Measured measured, String name) {
-    super(measured);
+  public FakeHttpClientMetrics(String name) {
     this.name = name;
   }
 

File: src/test/java/io/vertx/test/fakemetrics/FakeMetricsFactory.java
Patch:
@@ -11,7 +11,6 @@
 
 package io.vertx.test.fakemetrics;
 
-import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
 import io.vertx.core.spi.VertxMetricsFactory;
 import io.vertx.core.spi.metrics.VertxMetrics;
@@ -22,8 +21,8 @@
 public class FakeMetricsFactory implements VertxMetricsFactory {
 
   @Override
-  public VertxMetrics metrics(Vertx vertx, VertxOptions options) {
-    return new FakeVertxMetrics(vertx);
+  public VertxMetrics metrics(VertxOptions options) {
+    return new FakeVertxMetrics();
   }
 
 }

File: src/main/java/io/vertx/core/VertxOptions.java
Patch:
@@ -21,7 +21,7 @@
 
 import java.util.Objects;
 
-import static io.vertx.core.impl.FileResolver.DISABLE_FILE_CACHING_PROP_NAME;
+import static io.vertx.core.file.impl.FileResolver.DISABLE_FILE_CACHING_PROP_NAME;
 
 /**
  * Instances of this class are used to configure {@link io.vertx.core.Vertx} instances.

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -215,7 +215,7 @@ protected <T> void addRegistration(boolean newAddress, String address,
   }
 
   @Override
-  protected <T> void removeRegistration(HandlerHolder lastHolder, String address,
+  protected <T> void removeRegistration(HandlerHolder<T> lastHolder, String address,
                                         Handler<AsyncResult<Void>> completionHandler) {
     if (lastHolder != null && subs != null && !lastHolder.isLocalOnly()) {
       ownSubs.remove(address);

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -19,6 +19,7 @@
 import io.vertx.core.ServiceHelper;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
+import io.vertx.core.shareddata.Shareable;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
 import io.vertx.core.spi.BufferFactory;
 
@@ -36,7 +37,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface Buffer extends ClusterSerializable {
+public interface Buffer extends ClusterSerializable, Shareable {
 
   /**
    * Create a new, empty buffer.

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -12,6 +12,7 @@
 package io.vertx.core.json;
 
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.shareddata.Shareable;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
 
 import java.time.Instant;
@@ -33,7 +34,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class JsonArray implements Iterable<Object>, ClusterSerializable {
+public class JsonArray implements Iterable<Object>, ClusterSerializable, Shareable {
 
   private List<Object> list;
 
@@ -571,6 +572,7 @@ public String encodePrettily() {
    *
    * @return a copy
    */
+  @Override
   public JsonArray copy() {
     List<Object> copiedList = new ArrayList<>(list.size());
     for (Object val: list) {

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -12,6 +12,7 @@
 
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.shareddata.Shareable;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
 
 import java.nio.charset.StandardCharsets;
@@ -34,7 +35,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class JsonObject implements Iterable<Map.Entry<String, Object>>, ClusterSerializable {
+public class JsonObject implements Iterable<Map.Entry<String, Object>>, ClusterSerializable, Shareable {
 
   private Map<String, Object> map;
 
@@ -784,6 +785,7 @@ public Buffer toBuffer() {
    *
    * @return a copy of the object
    */
+  @Override
   public JsonObject copy() {
     Map<String, Object> copiedMap;
     if (map instanceof LinkedHashMap) {

File: src/main/java/io/vertx/core/shareddata/LocalMap.java
Patch:
@@ -24,13 +24,12 @@
 /**
  * Local maps can be used to share data safely in a single Vert.x instance.
  * <p>
- * The map only allows immutable keys and values in the map, OR certain mutable objects such as {@link io.vertx.core.buffer.Buffer}
- * instances which will be copied when they are added to the map.
+ * By default the map allows immutable keys and values.
+ * Custom keys and values should implement {@link Shareable} interface. The map returns their copies.
  * <p>
  * This ensures there is no shared access to mutable state from different threads (e.g. different event loops) in the
  * Vert.x instance, and means you don't have to protect access to that state using synchronization or locks.
  * <p>
- * Your own objects can be marked as immutable by implementing the {@link Shareable} interface.
  *
  * Since the version 3.4, this class extends the {@link Map} interface. However some methods are only accessible in Java.
  *

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -735,8 +735,7 @@ protected synchronized void handleClosed() {
         metrics.requestReset(req.request.metric());
       }
     }
-    Exception cause = new VertxException("Connection was closed");
-    failStreams(cause);
+    failStreams(CLOSED_EXCEPTION);
   }
 
   private void failStreams(Throwable cause) {

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -38,7 +38,6 @@
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
-import io.vertx.core.VertxException;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpConnection;
 import io.vertx.core.http.HttpServerOptions;
@@ -361,7 +360,7 @@ synchronized protected void handleClosed() {
       ws.handleClosed();
     }
     if (currentRequest != null) {
-      currentRequest.handleException(new VertxException("Connection was closed"));
+      currentRequest.handleException(CLOSED_EXCEPTION);
     }
     if (pendingResponse != null) {
       if (METRICS_ENABLED && metrics != null) {

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -244,7 +244,7 @@ void handleClose() {
         if (conn.metrics != null) {
           conn.metrics.requestReset(request.metric());
         }
-        handleException(new VertxException("Connection was closed")); // Put that in utility class
+        handleException(CLOSED_EXCEPTION);
       }
     }
 

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponseImpl.java
Patch:
@@ -33,6 +33,7 @@
 import io.vertx.core.http.StreamResetException;
 import io.vertx.core.logging.Logger;
 import io.vertx.core.logging.LoggerFactory;
+import io.vertx.core.net.impl.ConnectionBase;
 import io.vertx.core.spi.metrics.HttpServerMetrics;
 
 import java.io.File;
@@ -457,7 +458,7 @@ private void handleEnded(boolean failed) {
         }
       }
       if (exceptionHandler != null) {
-        conn.getContext().runOnContext(v -> exceptionHandler.handle(new VertxException("Connection was closed")));
+        conn.getContext().runOnContext(v -> exceptionHandler.handle(ConnectionBase.CLOSED_EXCEPTION));
       }
       if (endHandler != null) {
         conn.getContext().runOnContext(endHandler);

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -31,6 +31,7 @@
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.logging.Logger;
 import io.vertx.core.logging.LoggerFactory;
+import io.vertx.core.net.impl.ConnectionBase;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -527,7 +528,7 @@ void handleClosed() {
       if (!closed) {
         closed = true;
         if (!written && exceptionHandler != null) {
-          conn.getContext().runOnContext(v -> exceptionHandler.handle(new VertxException("Connection was closed")));
+          conn.getContext().runOnContext(v -> exceptionHandler.handle(ConnectionBase.CLOSED_EXCEPTION));
         }
         if (endHandler != null) {
           conn.getContext().runOnContext(endHandler);

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -53,13 +53,13 @@ class ConnectionManager {
   }
 
   synchronized void start(boolean checkExpired) {
-    this.timerID = checkExpired ? client.getVertx().setTimer(1, id -> checkExpired()) : -1;
+    this.timerID = checkExpired ? client.getVertx().setTimer(1000, id -> checkExpired()) : -1;
   }
 
   private synchronized void checkExpired() {
     long timestamp = System.currentTimeMillis();
     endpointMap.values().forEach(e -> e.pool.closeIdle(timestamp));
-    timerID = client.getVertx().setTimer(1, id -> checkExpired());
+    timerID = client.getVertx().setTimer(1000, id -> checkExpired());
   }
 
   private static final class EndpointKey {

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -440,7 +440,7 @@ private void doSendFile(String filename, long offset, long length, Handler<Async
         return;
       }
 
-      long contentLength = Math.min(length - offset, file.length() - offset);
+      long contentLength = Math.min(length, file.length() - offset);
       bytesWritten = contentLength;
       if (!headers.contentTypeSet()) {
         String contentType = MimeMapping.getMimeTypeForFilename(filename);

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -1864,7 +1864,6 @@ public void testSendOpenRangeFileFromClasspath() {
       res.response().sendFile("webroot/somefile.html", 6);
     }).listen(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
-        assertEquals(resp.headers().get("Content-Length"), String.valueOf(24));
         resp.bodyHandler(buff -> {
           assertTrue(buff.toString().startsWith("<body>blah</body></html>"));
           testComplete();
@@ -1877,10 +1876,9 @@ public void testSendOpenRangeFileFromClasspath() {
   @Test
   public void testSendRangeFileFromClasspath() {
     vertx.createHttpServer(new HttpServerOptions().setPort(8080)).requestHandler(res -> {
-      res.response().sendFile("webroot/somefile.html", 6, 12);
+      res.response().sendFile("webroot/somefile.html", 6, 6);
     }).listen(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
-        assertEquals(resp.headers().get("Content-Length"), String.valueOf(6));
         resp.bodyHandler(buff -> {
           assertEquals("<body>", buff.toString());
           testComplete();

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -440,7 +440,7 @@ private void doSendFile(String filename, long offset, long length, Handler<Async
         return;
       }
 
-      long contentLength = Math.min(length - offset, file.length() - offset);
+      long contentLength = Math.min(length, file.length() - offset);
       bytesWritten = contentLength;
       if (!headers.contentTypeSet()) {
         String contentType = MimeMapping.getMimeTypeForFilename(filename);

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -1864,7 +1864,6 @@ public void testSendOpenRangeFileFromClasspath() {
       res.response().sendFile("webroot/somefile.html", 6);
     }).listen(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
-        assertEquals(resp.headers().get("Content-Length"), String.valueOf(24));
         resp.bodyHandler(buff -> {
           assertTrue(buff.toString().startsWith("<body>blah</body></html>"));
           testComplete();
@@ -1877,10 +1876,9 @@ public void testSendOpenRangeFileFromClasspath() {
   @Test
   public void testSendRangeFileFromClasspath() {
     vertx.createHttpServer(new HttpServerOptions().setPort(8080)).requestHandler(res -> {
-      res.response().sendFile("webroot/somefile.html", 6, 12);
+      res.response().sendFile("webroot/somefile.html", 6, 6);
     }).listen(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
-        assertEquals(resp.headers().get("Content-Length"), String.valueOf(6));
         resp.bodyHandler(buff -> {
           assertEquals("<body>", buff.toString());
           testComplete();

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -440,7 +440,7 @@ private void doSendFile(String filename, long offset, long length, Handler<Async
         return;
       }
 
-      long contentLength = Math.min(length, file.length() - offset);
+      long contentLength = Math.min(length - offset, file.length() - offset);
       bytesWritten = contentLength;
       if (!headers.contentTypeSet()) {
         String contentType = MimeMapping.getMimeTypeForFilename(filename);

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -1864,6 +1864,7 @@ public void testSendOpenRangeFileFromClasspath() {
       res.response().sendFile("webroot/somefile.html", 6);
     }).listen(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
+        assertEquals(resp.headers().get("Content-Length"), String.valueOf(24));
         resp.bodyHandler(buff -> {
           assertTrue(buff.toString().startsWith("<body>blah</body></html>"));
           testComplete();
@@ -1876,9 +1877,10 @@ public void testSendOpenRangeFileFromClasspath() {
   @Test
   public void testSendRangeFileFromClasspath() {
     vertx.createHttpServer(new HttpServerOptions().setPort(8080)).requestHandler(res -> {
-      res.response().sendFile("webroot/somefile.html", 6, 6);
+      res.response().sendFile("webroot/somefile.html", 6, 12);
     }).listen(onSuccess(res -> {
       vertx.createHttpClient(new HttpClientOptions()).request(HttpMethod.GET, 8080, "localhost", "/", resp -> {
+        assertEquals(resp.headers().get("Content-Length"), String.valueOf(6));
         resp.bodyHandler(buff -> {
           assertEquals("<body>", buff.toString());
           testComplete();

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -17,6 +17,7 @@
 import io.vertx.core.Handler;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.http.impl.pool.Pool;
+import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.spi.metrics.HttpClientMetrics;
 
 import java.util.*;
@@ -110,7 +111,7 @@ public Endpoint(Pool<HttpClientConnection> pool, Object metric) {
     }
   }
 
-  void getConnection(String peerHost, boolean ssl, int port, String host, Handler<AsyncResult<HttpClientConnection>> handler) {
+  void getConnection(ContextInternal ctx, String peerHost, boolean ssl, int port, String host, Handler<AsyncResult<HttpClientConnection>> handler) {
     EndpointKey key = new EndpointKey(ssl, port, peerHost, host);
     while (true) {
       Endpoint endpoint = endpointMap.computeIfAbsent(key, targetAddress -> {
@@ -136,7 +137,7 @@ void getConnection(String peerHost, boolean ssl, int port, String host, Handler<
         metric = null;
       }
 
-      if (endpoint.pool.getConnection(client.getVertx().getOrCreateContext(), ar -> {
+      if (endpoint.pool.getConnection(ctx, ar -> {
         if (ar.succeeded()) {
 
           HttpClientConnection conn = ar.result();

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -611,7 +611,7 @@ private synchronized void connect(Handler<HttpVersion> headersHandler) {
       // This gives the user an opportunity to set an exception handler before connecting so
       // they can capture any exceptions on connection
       connecting = true;
-      client.getConnectionForRequest(peerHost, ssl, port, host, ar1 -> {
+      client.getConnectionForRequest(connectCtx, peerHost, ssl, port, host, ar1 -> {
         if (ar1.succeeded()) {
           HttpClientStream stream = ar1.result();
           ContextInternal ctx = (ContextInternal) stream.getContext();

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -895,7 +895,7 @@ public HttpClientRequest deleteAbs(String absoluteURI, Handler<HttpClientRespons
   }
 
   @Override
-  public synchronized void close() {
+  public void close() {
     synchronized (this) {
       checkClosed();
       closed = true;

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -490,6 +490,7 @@ public HttpClientRequest requestAbs(HttpMethod method, String absoluteURI) {
     URL url = parseUrl(absoluteURI);
     Boolean ssl = false;
     int port = url.getPort();
+    String relativeUri = url.getPath().isEmpty() ? "/" + url.getFile() : url.getFile();
     String protocol = url.getProtocol();
     if ("ftp".equals(protocol)) {
       if (port == -1) {
@@ -509,7 +510,7 @@ public HttpClientRequest requestAbs(HttpMethod method, String absoluteURI) {
       }
     }
     // if we do not know the protocol, the port still may be -1, we will handle that below
-    return createRequest(method, protocol, url.getHost(), port, ssl, url.getFile(), null);
+    return createRequest(method, protocol, url.getHost(), port, ssl, relativeUri, null);
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -495,6 +495,7 @@ public HttpClientRequest requestAbs(HttpMethod method, String absoluteURI) {
     URL url = parseUrl(absoluteURI);
     Boolean ssl = false;
     int port = url.getPort();
+    String relativeUri = url.getPath().isEmpty() ? "/" + url.getFile() : url.getFile();
     String protocol = url.getProtocol();
     if ("ftp".equals(protocol)) {
       if (port == -1) {
@@ -514,7 +515,7 @@ public HttpClientRequest requestAbs(HttpMethod method, String absoluteURI) {
       }
     }
     // if we do not know the protocol, the port still may be -1, we will handle that below
-    return createRequest(method, protocol, url.getHost(), port, ssl, url.getFile(), null);
+    return createRequest(method, protocol, url.getHost(), port, ssl, relativeUri, null);
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -94,7 +94,7 @@ public class Http1xServerConnection extends Http1xConnectionBase implements Http
   private long bytesRead;
   private long bytesWritten;
 
-  // (pending == true) <=> (paused && pending.size() > 0)
+  // (queueing == true) <=> (paused || pending.size() > 0)
   private final Deque<Object> pending = new ArrayDeque<>(8);
   private boolean paused;
   private boolean sentCheck;
@@ -512,7 +512,7 @@ private void checkNextTick() {
             // since we got there because queueing was true
             Object msg = pending.poll();
             if (pending.isEmpty()) {
-              // paused == false && pending.size() == 0 => queueing = false
+              // paused == false && pending.size() == 0 => queueing == false
               unsetQueueing();
             }
             // Process message, it might pause the connection

File: src/main/generated/io/vertx/core/http/HttpClientOptionsConverter.java
Patch:
@@ -102,7 +102,7 @@ static void fromJson(JsonObject json, HttpClientOptions obj) {
       obj.setPipeliningLimit(((Number)json.getValue("pipeliningLimit")).intValue());
     }
     if (json.getValue("poolRecyclePolicy") instanceof String) {
-      obj.setPoolRecyclePolicy(RecyclePolicy.valueOf((String)json.getValue("poolRecyclePolicy")));
+      obj.setPoolRecyclePolicy(io.vertx.core.http.RecyclePolicy.valueOf((String)json.getValue("poolRecyclePolicy")));
     }
     if (json.getValue("protocolVersion") instanceof String) {
       obj.setProtocolVersion(io.vertx.core.http.HttpVersion.valueOf((String)json.getValue("protocolVersion")));
@@ -160,4 +160,4 @@ static void toJson(HttpClientOptions obj, JsonObject json) {
     json.put("tryUseCompression", obj.isTryUseCompression());
     json.put("verifyHost", obj.isVerifyHost());
   }
-}
+}
\ No newline at end of file

File: src/main/java/io/vertx/core/http/impl/Http2ConnectionBase.java
Patch:
@@ -196,9 +196,6 @@ public synchronized void onSettingsAckRead(ChannelHandlerContext ctx) {
     }
   }
 
-  protected void onConnect() {
-  }
-
   protected void concurrencyChanged(long concurrency) {
   }
 

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -170,7 +170,7 @@ public Boolean getBoolean(int pos) {
    * Get the JsonObject at position {@code pos} in the array.
    *
    * @param pos  the position in the array
-   * @return  the Integer, or null if a null value present
+   * @return  the JsonObject, or null if a null value present
    * @throws java.lang.ClassCastException if the value cannot be converted to JsonObject
    */
   public JsonObject getJsonObject(int pos) {

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -170,7 +170,7 @@ public Boolean getBoolean(int pos) {
    * Get the JsonObject at position {@code pos} in the array.
    *
    * @param pos  the position in the array
-   * @return  the Integer, or null if a null value present
+   * @return  the JsonObject, or null if a null value present
    * @throws java.lang.ClassCastException if the value cannot be converted to JsonObject
    */
   public JsonObject getJsonObject(int pos) {

File: src/main/java/io/vertx/core/http/impl/Http1xServerConnection.java
Patch:
@@ -345,7 +345,6 @@ synchronized protected void handleClosed() {
       metrics.disconnected(ws.getMetric());
       ws.setMetric(null);
     }
-    super.handleClosed();
     if (ws != null) {
       ws.handleClosed();
     }
@@ -358,6 +357,7 @@ synchronized protected void handleClosed() {
       }
       pendingResponse.handleClosed();
     }
+    super.handleClosed();
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/HttpServerRequestImpl.java
Patch:
@@ -430,8 +430,9 @@ void handleEnd() {
 
   void handleException(Throwable t) {
     synchronized (conn) {
-      if (exceptionHandler != null) {
-        exceptionHandler.handle(t);
+      Handler<Throwable> handler = this.exceptionHandler;
+      if (handler != null) {
+        conn.getContext().runOnContext(v -> handler.handle(t));
       }
     }
   }

File: src/main/java/io/vertx/core/http/HttpClientOptions.java
Patch:
@@ -70,9 +70,9 @@ public class HttpClientOptions extends ClientOptionsBase {
   public static final int DEFAULT_PIPELINING_LIMIT = 10;
 
   /**
-   * The default keep alive timeout for HTTP/1.1 connection can send = 30 seconds
+   * The default keep alive timeout for HTTP/1.1 connection can send = 60 seconds
    */
-  public static final int DEFAULT_KEEP_ALIVE_TIMEOUT = 30;
+  public static final int DEFAULT_KEEP_ALIVE_TIMEOUT = 60;
 
   /**
    * Default value of whether the client will attempt to use compression = false

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -158,6 +158,8 @@ public HttpClientImpl(VertxInternal vertx, HttpClientOptions options) {
     websocketCM = new ConnectionManager(this, metrics, HttpVersion.HTTP_1_1, maxWeight, options.getMaxWaitQueueSize());
     httpCM = new ConnectionManager(this, metrics, options.getProtocolVersion(), maxWeight, options.getMaxWaitQueueSize());
     proxyType = options.getProxyOptions() != null ? options.getProxyOptions().getType() : null;
+    httpCM.start(options.getKeepAliveTimeout() > 0 || options.getHttp2KeepAliveTimeout() > 0);
+    websocketCM.start(options.getKeepAliveTimeout() > 0 || options.getHttp2KeepAliveTimeout() > 0);
   }
 
   HttpClientMetrics metrics() {

File: src/main/java/io/vertx/core/http/impl/Http1xOrH2CHandler.java
Patch:
@@ -57,8 +57,8 @@ private void end(ChannelHandlerContext ctx, ByteBuf buf, boolean h2c) {
       buf = msg;
     }
     configure(ctx, h2c);
-    ctx.fireChannelRead(buf);
     ctx.pipeline().remove(this);
+    ctx.fireChannelRead(buf);
   }
 
   protected void configure(ChannelHandlerContext ctx, boolean h2c) {

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -44,6 +44,7 @@ public abstract class ConnectionBase {
 
   private static final Logger log = LoggerFactory.getLogger(ConnectionBase.class);
 
+  private final VoidChannelPromise voidPromise;
   protected final VertxInternal vertx;
   protected final ChannelHandlerContext chctx;
   protected final ContextInternal context;
@@ -58,6 +59,7 @@ protected ConnectionBase(VertxInternal vertx, ChannelHandlerContext chctx, Conte
     this.vertx = vertx;
     this.chctx = chctx;
     this.context = context;
+    this.voidPromise = new VoidChannelPromise(chctx.channel(), false);
   }
 
   /**
@@ -119,7 +121,7 @@ private void queueForWrite(Object msg, ChannelPromise promise) {
   }
 
   public void writeToChannel(Object obj) {
-    writeToChannel(obj, chctx.voidPromise());
+    writeToChannel(obj, voidPromise);
   }
 
   // This is a volatile read inside the Netty channel implementation

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -112,7 +112,7 @@ void getConnection(String peerHost, boolean ssl, int port, String host,
         int maxPoolSize = Math.max(client.getOptions().getMaxPoolSize(), client.getOptions().getHttp2MaxPoolSize());
         Object metric = metrics != null ? metrics.createEndpoint(host, port, maxPoolSize) : null;
         HttpChannelConnector connector = new HttpChannelConnector(client, metric, version, ssl, peerHost, host, port);
-        Pool<HttpClientConnection> pool = new Pool<>(connector, maxWaitQueueSize, maxSize,
+        Pool<HttpClientConnection> pool = new Pool<>(connector, maxWaitQueueSize, connector.weight(), maxSize,
           v -> {
             if (metrics != null) {
               metrics.closeEndpoint(host, port, metric);

File: src/main/java/io/vertx/core/http/impl/pool/ConnectionProvider.java
Patch:
@@ -26,9 +26,8 @@ public interface ConnectionProvider<C> {
    *
    * @param listener the listener
    * @param context the context to use for the connection
-   * @return the initial weight of the connection, which will eventually be corrected when calling the listener
    */
-  long connect(ConnectionListener<C> listener, ContextInternal context);
+  void connect(ConnectionListener<C> listener, ContextInternal context);
 
   /**
    * Close a connection.

File: src/test/java/io/vertx/test/core/Http1xTest.java
Patch:
@@ -14,6 +14,7 @@
 import io.netty.handler.codec.TooLongFrameException;
 import io.vertx.core.*;
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.dns.AddressResolverOptions;
 import io.vertx.core.http.*;
 import io.vertx.core.http.impl.HttpClientRequestImpl;
 import io.vertx.core.impl.ConcurrentHashSet;

File: src/main/java/io/vertx/core/json/Json.java
Patch:
@@ -21,6 +21,7 @@
 
 import java.io.DataInput;
 import java.io.IOException;
+import java.io.InputStream;
 import java.math.BigDecimal;
 import java.time.Instant;
 import java.util.Base64;
@@ -162,7 +163,7 @@ public static <T> T decodeValue(Buffer buf, TypeReference<T> type) throws Decode
    */
   public static <T> T decodeValue(Buffer buf, Class<T> clazz) throws DecodeException {
     try {
-      return mapper.readValue((DataInput) new ByteBufInputStream(buf.getByteBuf()), clazz);
+      return mapper.readValue((InputStream) new ByteBufInputStream(buf.getByteBuf()), clazz);
     } catch (Exception e) {
       throw new DecodeException("Failed to decode:" + e.getMessage(), e);
     }

File: src/main/java/io/vertx/core/parsetools/JsonEventType.java
Patch:
@@ -11,11 +11,14 @@
 
 package io.vertx.core.parsetools;
 
+import io.vertx.codegen.annotations.VertxGen;
+
 /**
  * The possibles types of {@link JsonEvent} emitted by the {@link JsonParser}.
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
+@VertxGen
 public enum JsonEventType {
 
   /**

File: src/main/java/docoverride/buffer/package-info.java
Patch:
@@ -17,8 +17,5 @@
  * {@link docoverride.buffer.Examples#example4}
  * ----
  */
-@Document(fileName = "override/buffer_from_bytes.adoc")
 package docoverride.buffer;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/docoverride/dependencies/package-info.java
Patch:
@@ -33,7 +33,4 @@
  * }
  * ----
  */
-@Document(fileName = "override/dependencies.adoc")
 package docoverride.dependencies;
-
-import io.vertx.docgen.Document;

File: src/main/java/docoverride/dns/package-info.java
Patch:
@@ -43,7 +43,4 @@
  * {@link docoverride.dns.Examples#example16}
  * ----
  */
-@Document(fileName = "override/dns.adoc")
 package docoverride.dns;
-
-import io.vertx.docgen.Document;

File: src/main/java/docoverride/eventbus/headers/package-info.java
Patch:
@@ -20,7 +20,4 @@
  * {@link docoverride.eventbus.Examples#headers(io.vertx.core.eventbus.EventBus)}
  * ----
  */
-@Document(fileName = "override/eventbus_headers.adoc")
 package docoverride.eventbus.headers;
-
-import io.vertx.docgen.Document;

File: src/main/java/docoverride/eventbus/package-info.java
Patch:
@@ -35,7 +35,4 @@
  * Message codecs don't always have to encode and decode as the same type. For example you can write a codec that
  * allows a MyPOJO class to be sent, but when that message is sent to a handler it arrives as a MyOtherPOJO class.
  */
-@Document(fileName = "override/eventbus.adoc")
 package docoverride.eventbus;
-
-import io.vertx.docgen.Document;

File: src/main/java/docoverride/json/package-info.java
Patch:
@@ -131,8 +131,5 @@
  *
  *
  */
-@Document(fileName = "override/json.adoc")
 package docoverride.json;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/docoverride/verticles/configuration/package-info.java
Patch:
@@ -38,7 +38,4 @@
  * ----
  *
  */
-@Document(fileName = "override/verticle-configuration.adoc")
 package docoverride.verticles.configuration;
-
-import io.vertx.docgen.Document;

File: src/main/java/docoverride/verticles/package-info.java
Patch:
@@ -108,7 +108,4 @@
  * INFO: You don't need to manually the HTTP server started by a verticle, in the verticle's stop method. Vert.x
  * will automatically stop any running server when the verticle is undeployed.
  */
-@Document(fileName = "override/verticles.adoc")
 package docoverride.verticles;
-
-import io.vertx.docgen.Document;

File: src/main/java/io/vertx/core/buffer/package-info.java
Patch:
@@ -135,8 +135,5 @@
  * After writing a buffer to a socket or other similar place, they cannot be re-used.
  *
  */
-@Document(fileName = "buffers.adoc")
 package io.vertx.core.buffer;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/cli/annotations/package-info.java
Patch:
@@ -93,7 +93,4 @@
  * ----
  *
  */
-@Document(fileName = "cli-for-java.adoc")
 package io.vertx.core.cli.annotations;
-
-import io.vertx.docgen.Document;

File: src/main/java/io/vertx/core/cli/package-info.java
Patch:
@@ -189,7 +189,4 @@
  * ----
  *
  */
-@Document(fileName = "cli.adoc")
 package io.vertx.core.cli;
-
-import io.vertx.docgen.Document;

File: src/main/java/io/vertx/core/datagram/package-info.java
Patch:
@@ -196,8 +196,5 @@
  * You can close a socket by invoking the {@link io.vertx.core.datagram.DatagramSocket#close} method. This will close
  * the socket and release all resources
  */
-@Document(fileName = "datagrams.adoc")
 package io.vertx.core.datagram;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/dns/package-info.java
Patch:
@@ -204,8 +204,5 @@
  *
  * include::override/dns.adoc[]
  */
-@Document(fileName = "dns.adoc")
 package io.vertx.core.dns;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/eventbus/package-info.java
Patch:
@@ -324,8 +324,5 @@
  * {@link examples.EventBusExamples#example14}
  * ----
  */
-@Document(fileName = "eventbus.adoc")
 package io.vertx.core.eventbus;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/file/package-info.java
Patch:
@@ -173,8 +173,5 @@
  * if you want to be notified when the close has been completed you can specify a handler function as an argument.
  *
  */
-@Document(fileName = "filesystem.adoc")
 package io.vertx.core.file;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1756,8 +1756,5 @@
  * when the verticle is undeployed.
  *
  */
-@Document(fileName = "http.adoc")
 package io.vertx.core.http;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/net/package-info.java
Patch:
@@ -779,8 +779,5 @@
  * The DNS resolution is always done on the proxy server, to achieve the functionality of a SOCKS4 client, it is necessary
  * to resolve the DNS address locally.
  */
-@Document(fileName = "net.adoc")
 package io.vertx.core.net;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1772,8 +1772,5 @@
  * very careful when using this settings.
  *
  */
-@Document(fileName = "index.adoc")
 @io.vertx.codegen.annotations.ModuleGen(name = "vertx", groupPackage = "io.vertx")
 package io.vertx.core;
-
-import io.vertx.docgen.Document;

File: src/main/java/io/vertx/core/parsetools/package-info.java
Patch:
@@ -114,8 +114,5 @@
  *
  * For more details, check out the {@link io.vertx.core.parsetools.JsonParser} class.
  */
-@Document(fileName = "parsetools.adoc")
 package io.vertx.core.parsetools;
 
-import io.vertx.docgen.Document;
-

File: src/main/java/io/vertx/core/shareddata/package-info.java
Patch:
@@ -145,8 +145,5 @@
  *
  *
  */
-@Document(fileName = "shareddata.adoc")
 package io.vertx.core.shareddata;
 
-import io.vertx.docgen.Document;
-

File: src/test/java/io/vertx/test/core/net/ConnectionPoolTest.java
Patch:
@@ -186,7 +186,7 @@ public void testConnectionFailure() {
     assertWaitUntil(waiter::isComplete);
     waiter.assertFailure(expected);
     assertTrue(waiter.isFailure());
-    assertTrue(mgr.closed());
+    assertWaitUntil(mgr::closed);
   }
 
   @Test

File: src/main/java/io/vertx/core/impl/Deployment.java
Patch:
@@ -23,7 +23,7 @@
  */
 public interface Deployment {
 
-  void addChild(Deployment deployment);
+  boolean addChild(Deployment deployment);
 
   void removeChild(Deployment deployment);
 

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -53,8 +53,10 @@ public class HttpClientImpl implements HttpClient, MetricsProvider {
       String location = resp.getHeader(HttpHeaders.LOCATION);
       if (location != null && (statusCode == 301 || statusCode == 302 || statusCode == 303 || statusCode == 307)) {
         HttpMethod m = resp.request().method();
-        if (statusCode == 301 || statusCode == 302 || statusCode == 303) {
+        if (statusCode == 303) {
           m = HttpMethod.GET;
+        } else if (m != HttpMethod.GET && m != HttpMethod.HEAD) {
+          return null;
         }
         URI uri = HttpUtils.resolveURIReference(resp.request().absoluteURI(), location);
         boolean ssl;

File: src/test/java/io/vertx/test/core/Http1xTLSTest.java
Patch:
@@ -113,7 +113,7 @@ public void testRedirectToSSL() throws Exception {
         .setHost(DEFAULT_HTTP_HOST)
         .setPort(DEFAULT_HTTP_PORT)
     ).requestHandler(req -> {
-      req.response().setStatusCode(307).putHeader("location", "https://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
+      req.response().setStatusCode(303).putHeader("location", "https://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
     });
     startServer(redirectServer);
     RequestOptions options = new RequestOptions().setHost(DEFAULT_HTTP_HOST).setURI(DEFAULT_TEST_URI).setPort(DEFAULT_HTTP_PORT);
@@ -133,7 +133,7 @@ public void testRedirectFromSSL() throws Exception {
         .setHost(DEFAULT_HTTP_HOST)
         .setPort(DEFAULT_HTTP_PORT)
     ).requestHandler(req -> {
-      req.response().setStatusCode(307).putHeader("location", "http://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
+      req.response().setStatusCode(303).putHeader("location", "http://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
     });
     startServer(redirectServer);
     RequestOptions options = new RequestOptions().setHost(DEFAULT_HTTP_HOST).setURI(DEFAULT_TEST_URI).setPort(4043);

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -53,8 +53,10 @@ public class HttpClientImpl implements HttpClient, MetricsProvider {
       String location = resp.getHeader(HttpHeaders.LOCATION);
       if (location != null && (statusCode == 301 || statusCode == 302 || statusCode == 303 || statusCode == 307)) {
         HttpMethod m = resp.request().method();
-        if (statusCode == 301 || statusCode == 302 || statusCode == 303) {
+        if (statusCode == 303) {
           m = HttpMethod.GET;
+        } else if (m != HttpMethod.GET && m != HttpMethod.HEAD) {
+          return null;
         }
         URI uri = HttpUtils.resolveURIReference(resp.request().absoluteURI(), location);
         boolean ssl;

File: src/test/java/io/vertx/test/core/Http1xTLSTest.java
Patch:
@@ -113,7 +113,7 @@ public void testRedirectToSSL() throws Exception {
         .setHost(DEFAULT_HTTP_HOST)
         .setPort(DEFAULT_HTTP_PORT)
     ).requestHandler(req -> {
-      req.response().setStatusCode(307).putHeader("location", "https://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
+      req.response().setStatusCode(303).putHeader("location", "https://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
     });
     startServer(redirectServer);
     RequestOptions options = new RequestOptions().setHost(DEFAULT_HTTP_HOST).setURI(DEFAULT_TEST_URI).setPort(DEFAULT_HTTP_PORT);
@@ -133,7 +133,7 @@ public void testRedirectFromSSL() throws Exception {
         .setHost(DEFAULT_HTTP_HOST)
         .setPort(DEFAULT_HTTP_PORT)
     ).requestHandler(req -> {
-      req.response().setStatusCode(307).putHeader("location", "http://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
+      req.response().setStatusCode(303).putHeader("location", "http://" + DEFAULT_HTTP_HOST + ":4043/" + DEFAULT_TEST_URI).end();
     });
     startServer(redirectServer);
     RequestOptions options = new RequestOptions().setHost(DEFAULT_HTTP_HOST).setURI(DEFAULT_TEST_URI).setPort(4043);

File: src/test/java/io/vertx/test/core/WebsocketTest.java
Patch:
@@ -49,6 +49,7 @@
 import org.junit.Test;
 
 import javax.security.cert.X509Certificate;
+import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
@@ -1286,7 +1287,7 @@ private void connectUntilWebsocketHandshakeException(HttpClient client, int coun
           doneHandler.handle(Future.failedFuture(new AssertionError()));
         }
       }, err -> {
-        if (err instanceof WebSocketHandshakeException) {
+        if (err instanceof WebSocketHandshakeException || err instanceof IOException) {
           doneHandler.handle(Future.succeededFuture());
         } else if (count < 100) {
           connectUntilWebsocketHandshakeException(client, count + 1, doneHandler);

File: src/main/generated/io/vertx/core/cli/OptionConverter.java
Patch:
@@ -31,7 +31,7 @@ static void fromJson(JsonObject json, Option obj) {
       obj.setArgName((String)json.getValue("argName"));
     }
     if (json.getValue("choices") instanceof JsonArray) {
-      java.util.HashSet<java.lang.String> list = new java.util.HashSet<>();
+      java.util.LinkedHashSet<java.lang.String> list = new java.util.LinkedHashSet<>();
       json.getJsonArray("choices").forEach( item -> {
         if (item instanceof String)
           list.add((String)item);

File: src/main/generated/io/vertx/core/eventbus/EventBusOptionsConverter.java
Patch:
@@ -70,7 +70,7 @@ static void fromJson(JsonObject json, EventBusOptions obj) {
       });
     }
     if (json.getValue("enabledSecureTransportProtocols") instanceof JsonArray) {
-      java.util.HashSet<java.lang.String> list = new java.util.HashSet<>();
+      java.util.LinkedHashSet<java.lang.String> list = new java.util.LinkedHashSet<>();
       json.getJsonArray("enabledSecureTransportProtocols").forEach( item -> {
         if (item instanceof String)
           list.add((String)item);

File: src/main/generated/io/vertx/core/net/TCPSSLOptionsConverter.java
Patch:
@@ -46,7 +46,7 @@ static void fromJson(JsonObject json, TCPSSLOptions obj) {
       });
     }
     if (json.getValue("enabledSecureTransportProtocols") instanceof JsonArray) {
-      java.util.HashSet<java.lang.String> list = new java.util.HashSet<>();
+      java.util.LinkedHashSet<java.lang.String> list = new java.util.LinkedHashSet<>();
       json.getJsonArray("enabledSecureTransportProtocols").forEach( item -> {
         if (item instanceof String)
           list.add((String)item);

File: src/main/java/io/vertx/core/http/impl/Http1xClientHandler.java
Patch:
@@ -130,6 +130,7 @@ protected void handleMessage(Http1xClientConnection conn, ContextImpl context, C
           chctx.writeAndFlush(new PongWebSocketFrame(frame.getBinaryData().copy()));
           break;
         case CLOSE:
+          conn.handleWsFrame(frame);
           if (!closeFrameSent) {
             // Echo back close frame and close the connection once it was written.
             // This is specified in the WebSockets RFC 6455 Section  5.4.1

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -682,6 +682,7 @@ protected void handleMessage(Http1xServerConnection conn, ContextImpl context, C
               ch.writeAndFlush(wsFrame).addListener(ChannelFutureListener.CLOSE);
               closeFrameSent = true;
             }
+            conn.handleMessage(msg);
             break;
           default:
             throw new IllegalStateException("Invalid type: " + wsFrame.type());

File: src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -48,7 +48,7 @@ public class ServerWebSocketImpl extends WebSocketImplBase<ServerWebSocket> impl
   private HttpResponseStatus rejectedStatus;
 
   public ServerWebSocketImpl(VertxInternal vertx, String uri, String path, String query, MultiMap headers,
-                             ConnectionBase conn, boolean supportsContinuation, Supplier<String> connectRunnable,
+                             Http1xConnectionBase conn, boolean supportsContinuation, Supplier<String> connectRunnable,
                              int maxWebSocketFrameSize, int maxWebSocketMessageSize) {
     super(vertx, conn, supportsContinuation, maxWebSocketFrameSize, maxWebSocketMessageSize);
     this.uri = uri;

File: src/main/java/io/vertx/core/spi/WebSocketFrameFactory.java
Patch:
@@ -11,6 +11,7 @@
 
 package io.vertx.core.spi;
 
+import io.netty.buffer.ByteBuf;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.WebSocketFrame;
 

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -71,7 +71,7 @@ public abstract class TCPSSLOptions extends NetworkOptions {
    *
    * SSLv3 is NOT enabled due to POODLE vulnerability http://en.wikipedia.org/wiki/POODLE
    */
-  public static final String[] DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"};
+  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList("SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"));
 
   /**
    * The default TCP_FASTOPEN value = false
@@ -175,7 +175,7 @@ private void init() {
     crlValues = new ArrayList<>();
     useAlpn = DEFAULT_USE_ALPN;
     sslEngineOptions = DEFAULT_SSL_ENGINE;
-    enabledSecureTransportProtocols = new LinkedHashSet<>(Arrays.asList(DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS));
+    enabledSecureTransportProtocols = new LinkedHashSet<>(DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS);
     tcpFastOpen = DEFAULT_TCP_FAST_OPEN;
     tcpCork = DEFAULT_TCP_CORK;
     tcpQuickAck = DEFAULT_TCP_QUICKACK;

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -258,7 +258,9 @@ void handleFrame(WebSocketFrameInternal frame) {
       }
       switch(frame.type()) {
         case PONG:
-          pongHandler.handle(frame.binaryData().copy());
+          if (pongHandler != null) {
+            pongHandler.handle(frame.binaryData().copy());
+          }
           break;
         case TEXT:
         case BINARY:

File: src/main/java/io/vertx/core/eventbus/MessageConsumer.java
Patch:
@@ -64,7 +64,7 @@ public interface MessageConsumer<T> extends ReadStream<Message<T>> {
 
   /**
    * Set the number of messages this registration will buffer when this stream is paused. The default
-   * value is <code>0</code>. When a new value is set, buffered messages may be discarded to reach
+   * value is <code>1000</code>. When a new value is set, buffered messages may be discarded to reach
    * the new value.
    *
    * @param maxBufferedMessages the maximum number of messages that can be buffered

File: src/test/benchmarks/io/vertx/benchmarks/HttpServerHandlerBenchmark.java
Patch:
@@ -84,7 +84,7 @@ public ByteBuf buffer() {
 
     @Override
     public ByteBuf buffer(int initialCapacity) {
-      if (initialCapacity < capacity) {
+      if (initialCapacity <= capacity) {
         return buffer();
       } else {
         throw new IllegalArgumentException();
@@ -93,7 +93,7 @@ public ByteBuf buffer(int initialCapacity) {
 
     @Override
     public ByteBuf buffer(int initialCapacity, int maxCapacity) {
-      if (initialCapacity < capacity) {
+      if (initialCapacity <= capacity) {
         return buffer();
       } else {
         throw new IllegalArgumentException();

File: src/main/java/io/vertx/core/eventbus/MessageConsumer.java
Patch:
@@ -64,7 +64,7 @@ public interface MessageConsumer<T> extends ReadStream<Message<T>> {
 
   /**
    * Set the number of messages this registration will buffer when this stream is paused. The default
-   * value is <code>0</code>. When a new value is set, buffered messages may be discarded to reach
+   * value is <code>1000</code>. When a new value is set, buffered messages may be discarded to reach
    * the new value.
    *
    * @param maxBufferedMessages the maximum number of messages that can be buffered

File: src/main/java/io/vertx/core/impl/resolver/DnsResolverProvider.java
Patch:
@@ -85,7 +85,7 @@ public DnsResolverProvider(VertxImpl vertx, AddressResolverOptions options) {
         }
       }
     } else {
-      DnsServerAddressStream stream = DnsServerAddresses.defaultAddresses().stream();
+      DnsServerAddressStream stream = DefaultDnsServerAddressStreamProvider.defaultAddresses().stream();
       Set<InetSocketAddress> all = new HashSet<>();
       while (true) {
         InetSocketAddress address = stream.next();

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -465,7 +465,7 @@ private void doDeploy(String identifier, String deploymentID, DeploymentOptions
     AtomicInteger deployCount = new AtomicInteger();
     AtomicBoolean failureReported = new AtomicBoolean();
     for (Verticle verticle: verticles) {
-      WorkerExecutorImpl workerExec = poolName != null ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize()) : null;
+      WorkerExecutorImpl workerExec = poolName != null ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize(), options.getMaxWorkerExecuteTime()) : null;
       WorkerPool pool = workerExec != null ? workerExec.getPool() : null;
       ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :
         vertx.createEventLoopContext(deploymentID, pool, conf, tccl);

File: src/test/java/io/vertx/test/core/net/ConnectionPoolTest.java
Patch:
@@ -22,6 +22,7 @@
 import io.vertx.core.impl.ContextImpl;
 import io.vertx.core.impl.ContextInternal;
 import io.vertx.core.net.SocketAddress;
+import io.vertx.test.core.Repeat;
 import io.vertx.test.core.VertxTestBase;
 import org.junit.Test;
 
@@ -332,7 +333,7 @@ public void testRecycleWithoutDispose() {
     conn.recycle(false);
     FakeWaiter waiter2 = new FakeWaiter();
     mgr.getConnection(waiter2);
-    waitUntil(waiter1::isSuccess);
+    waitUntil(waiter2::isSuccess);
     waiter2.assertSuccess(conn);
     conn.recycle(true);
     assertEquals(0, mgr.size());

File: src/main/java/io/vertx/core/dns/impl/DnsClientImpl.java
Patch:
@@ -259,7 +259,7 @@ private class Query<T> {
     long timerID;
 
     public Query(String name, DnsRecordType[] types, Handler<AsyncResult<List<T>>> handler) {
-      this.msg = new DatagramDnsQuery(null, dnsServer, ThreadLocalRandom.current().nextInt());
+      this.msg = new DatagramDnsQuery(null, dnsServer, ThreadLocalRandom.current().nextInt()).setRecursionDesired(true);
       for (DnsRecordType type: types) {
         msg.addRecord(DnsSection.QUESTION, new DefaultDnsQuestion(name, type, DnsRecord.CLASS_IN));
       }

File: src/test/java/io/vertx/test/core/DNSTest.java
Patch:
@@ -27,6 +27,7 @@
 import io.vertx.core.dns.SrvRecord;
 import io.vertx.core.dns.impl.DnsClientImpl;
 import io.vertx.test.fakedns.FakeDNSServer;
+import org.apache.directory.server.dns.messages.DnsMessage;
 import org.junit.Test;
 
 import java.net.InetSocketAddress;
@@ -204,9 +205,10 @@ public void testLookup4() throws Exception {
     final String ip = "10.0.0.1";
     FakeDNSServer server = FakeDNSServer.testLookup4(ip);
     DnsClient dns = prepareDns(server);
-
     dns.lookup4("vertx.io", onSuccess(result -> {
       assertEquals(ip, result);
+      DnsMessage msg = server.pollMessage();
+      assertTrue(msg.isRecursionDesired());
       testComplete();
     }));
     await();

File: src/main/java/io/vertx/core/http/HttpConnection.java
Patch:
@@ -68,11 +68,11 @@ default HttpConnection setWindowSize(int windowSize) {
   }
 
   /**
-   * Like {@link #goAway(long, int)} with a last stream id {@code 2^31-1}.
+   * Like {@link #goAway(long, int)} with a last stream id {@code -1} which means to disallow any new stream creation.
    */
   @Fluent
   default HttpConnection goAway(long errorCode) {
-    return goAway(errorCode, Integer.MAX_VALUE);
+    return goAway(errorCode, -1);
   }
 
   /**

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -682,7 +682,6 @@ private synchronized void connect() {
         ctx.executeFromIO(() -> {
           handleException(failure);
         });
-
       });
       connecting = true;
     }

File: src/main/java/io/vertx/core/http/impl/pool/ConnectionListener.java
Patch:
@@ -66,8 +66,8 @@ void onConnectSuccess(C conn,
   void onRecycle(int capacity, boolean disposable);
 
   /**
-   * Signals the connection is closed.
+   * Signals the connection must not be used anymore by the pool.
    */
-  void onClose();
+  void onDiscard();
 
 }

File: src/main/java/io/vertx/core/http/impl/pool/Waiter.java
Patch:
@@ -31,23 +31,23 @@ protected Waiter(ContextImpl context) {
   }
 
   /**
-   * Handle connection failure.
+   * Handle connection failure, this callback is on a Netty even loop.
    *
    * @param ctx the context used to create the connection
    * @param failure the failure
    */
   public abstract void handleFailure(ContextInternal ctx, Throwable failure);
 
   /**
-   * Init connection.
+   * Init connection, this callback is on a Netty event loop.
    *
    * @param ctx the context used to create the connection
    * @param conn the connection
    */
   public abstract void initConnection(ContextInternal ctx, C conn);
 
   /**
-   * Handle connection success.
+   * Handle connection success, , this callback is on a Netty event loop.
    *
    * @param ctx the context used to create the connection
    * @param conn the connection

File: src/main/java/io/vertx/core/http/impl/pool/Pool.java
Patch:
@@ -171,9 +171,7 @@ public void onConnectSuccess(C conn, long concurrency, Channel channel, ContextI
           boolean consumed = deliverToWaiter(holder, waiter);
           synchronized (Pool.this) {
             if (!consumed) {
-              synchronized (this) {
-                recycleConnection(holder, 1,false);
-              }
+              recycleConnection(holder, 1,false);
             }
             checkPending();
           }

File: src/test/java/io/vertx/test/core/MetricsTest.java
Patch:
@@ -680,7 +680,7 @@ public void testHttpClientMetricsQueueLength() throws Exception {
     assertWaitUntil(() -> requests.size() == 3);
     assertEquals(Collections.singleton("localhost:8080"), metrics.endpoints());
     assertEquals(0, (int)metrics.queueSize("localhost:8080"));
-    assertEquals(5, (int)metrics.connectionCount("localhost:8080"));
+    assertEquals(3, (int)metrics.connectionCount("localhost:8080"));
   }
 
   @Test

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -635,7 +635,7 @@ public void doResume() {
     super.doResume();
     paused = false;
     if (pausedChunk != null) {
-      vertx.runOnContext(v -> {
+      context.runOnContext(v -> {
         if (pausedChunk != null) {
           Buffer chunk = pausedChunk;
           pausedChunk = null;

File: src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java
Patch:
@@ -630,7 +630,7 @@ protected void handleMessage(NetSocketImpl connection, ContextImpl context, Chan
         ByteBuf buf = (ByteBuf) msg;
         connection.handleMessageReceived(buf);
       }
-    }.removeHandler(sock -> listener.onClose(this, chctx.channel())));
+    }.removeHandler(sock -> listener.onClose(this)));
     return socket;
   }
 

File: src/main/java/io/vertx/core/http/impl/HttpChannelConnector.java
Patch:
@@ -262,7 +262,7 @@ private void http1xConnected(ConnectionListener<HttpClientConnection> listener,
       handler.handle(Future.succeededFuture(conn));
     });
     clientHandler.removeHandler(conn -> {
-      listener.onClose(conn, ch);
+      listener.onClose(conn);
     });
     ch.pipeline().addLast("handler", clientHandler);
   }
@@ -297,7 +297,7 @@ private void http2Connected(ConnectionListener<HttpClientConnection> listener,
         if (metrics != null) {
           metrics.endpointDisconnected(endpointMetric, conn.metric());
         }
-        listener.onClose(conn, ch);
+        listener.onClose(conn);
       });
     } catch (Exception e) {
       connectFailed(ch, resultHandler, e);

File: src/main/java/io/vertx/core/http/impl/pool/ConnectionListener.java
Patch:
@@ -15,15 +15,13 @@
  */
 package io.vertx.core.http.impl.pool;
 
-import io.netty.channel.Channel;
-
 /**
  * The listener is used by the {@link ConnectionProvider} to interact with the connection manager.
  */
 public interface ConnectionListener<C> {
 
   void onRecycle(C conn);
 
-  void onClose(C conn, Channel channel);
+  void onClose(C conn);
 
 }

File: src/test/java/io/vertx/test/core/Http2ClientTest.java
Patch:
@@ -1016,7 +1016,9 @@ public void testServerShutdownConnection() throws Exception {
   @Test
   public void testReceivingGoAwayDiscardsTheConnection() throws Exception {
     AtomicInteger reqCount = new AtomicInteger();
+    Set<HttpConnection> connections = Collections.synchronizedSet(new HashSet<>());
     server.requestHandler(req -> {
+      connections.add(req.connection());
       switch (reqCount.getAndIncrement()) {
         case 0:
           req.connection().goAway(0);
@@ -1035,6 +1037,7 @@ public void testReceivingGoAwayDiscardsTheConnection() throws Exception {
       conn.goAwayHandler(ga -> {
         if (gaCount.getAndIncrement() == 0) {
           client.get(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, "/somepath", resp2 -> {
+            assertEquals(2, connections.size());
             testComplete();
           }).setTimeout(5000).exceptionHandler(this::fail).end();
         }

File: src/test/java/io/vertx/test/core/ClusteredEventBusStartFailureTest.java
Patch:
@@ -35,7 +35,7 @@ public class ClusteredEventBusStartFailureTest extends AsyncTestBase {
   public void testCallbackInvokedOnFailure() throws Exception {
 
     // will trigger java.net.UnknownHostException
-    String hostName = getClass().getSimpleName();
+    String hostName = "zoom.zoom.zen.tld";
 
     VertxOptions options = new VertxOptions()
       .setClusterManager(new FakeClusterManager())

File: src/test/java/io/vertx/test/core/ClusteredEventBusStartFailureTest.java
Patch:
@@ -35,7 +35,7 @@ public class ClusteredEventBusStartFailureTest extends AsyncTestBase {
   public void testCallbackInvokedOnFailure() throws Exception {
 
     // will trigger java.net.UnknownHostException
-    String hostName = getClass().getSimpleName();
+    String hostName = "zoom.zoom.zen.tld";
 
     VertxOptions options = new VertxOptions()
       .setClusterManager(new FakeClusterManager())

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1021,7 +1021,7 @@
  * {@link examples.HTTP2Examples#example12}
  * ----
  *
- * === Handling http responses
+ * === Handling HTTP responses
  *
  * You receive an instance of {@link io.vertx.core.http.HttpClientResponse} into the handler that you specify in of
  * the request methods or by setting a handler directly on the {@link io.vertx.core.http.HttpClientRequest} object.

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -791,7 +791,7 @@
  *
  * === Verticle worker pool
  *
- * Verticle uses the Vert.x worker pool for executing blocking actions, i.e {@link io.vertx.core.Context#executeBlocking} or
+ * Verticles use the Vert.x worker pool for executing blocking actions, i.e {@link io.vertx.core.Context#executeBlocking} or
  * worker verticle.
  *
  * A different worker pool can be specified in deployment options:

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1021,7 +1021,7 @@
  * {@link examples.HTTP2Examples#example12}
  * ----
  *
- * === Handling http responses
+ * === Handling HTTP responses
  *
  * You receive an instance of {@link io.vertx.core.http.HttpClientResponse} into the handler that you specify in of
  * the request methods or by setting a handler directly on the {@link io.vertx.core.http.HttpClientRequest} object.

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -493,12 +493,13 @@ private void doDeploy(String identifier, String deploymentID, DeploymentOptions
               if (deployCount.incrementAndGet() == verticles.length) {
                 reportSuccess(deploymentID, callingContext, completionHandler);
               }
-            } else if (!failureReported.get()) {
+            } else if (failureReported.compareAndSet(false, true)) {
               context.runCloseHooks(closeHookAsyncResult -> reportFailure(ar.cause(), callingContext, completionHandler));
             }
           });
         } catch (Throwable t) {
-          context.runCloseHooks(closeHookAsyncResult -> reportFailure(t, callingContext, completionHandler));
+          if (failureReported.compareAndSet(false, true))
+            context.runCloseHooks(closeHookAsyncResult -> reportFailure(t, callingContext, completionHandler));
         }
       });
     }

File: src/main/java/io/vertx/core/net/impl/transport/Transport.java
Patch:
@@ -154,7 +154,7 @@ public DatagramChannel datagramChannel(InternetProtocolFamily family) {
 
   /**
    * @return the type for channel
-   * @param domain wether to create a unix domain channel or a socket channel
+   * @param domain whether to create a unix domain channel or a socket channel
    */
   public Class<? extends Channel> channelType(boolean domain) {
     if (domain) {
@@ -165,7 +165,7 @@ public Class<? extends Channel> channelType(boolean domain) {
 
   /**
    * @return the type for server channel
-   * @param domain wether to create a server unix domain channel or a regular server socket channel
+   * @param domain whether to create a server unix domain channel or a regular server socket channel
    */
   public Class<? extends ServerChannel> serverChannelType(boolean domain) {
     if (domain) {

File: src/main/java/io/vertx/core/net/impl/transport/Transport.java
Patch:
@@ -154,7 +154,7 @@ public DatagramChannel datagramChannel(InternetProtocolFamily family) {
 
   /**
    * @return the type for channel
-   * @param domain wether to create a unix domain channel or a socket channel
+   * @param domain whether to create a unix domain channel or a socket channel
    */
   public Class<? extends Channel> channelType(boolean domain) {
     if (domain) {
@@ -165,7 +165,7 @@ public Class<? extends Channel> channelType(boolean domain) {
 
   /**
    * @return the type for server channel
-   * @param domain wether to create a server unix domain channel or a regular server socket channel
+   * @param domain whether to create a server unix domain channel or a regular server socket channel
    */
   public Class<? extends ServerChannel> serverChannelType(boolean domain) {
     if (domain) {

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -493,12 +493,12 @@ private void doDeploy(String identifier, String deploymentID, DeploymentOptions
               if (deployCount.incrementAndGet() == verticles.length) {
                 reportSuccess(deploymentID, callingContext, completionHandler);
               }
-            } else if (!failureReported.getAndSet(true)) {
+            } else if (failureReported.compareAndSet(false, true)) {
               context.runCloseHooks(closeHookAsyncResult -> reportFailure(ar.cause(), callingContext, completionHandler));
             }
           });
         } catch (Throwable t) {
-          if (!failureReported.getAndSet(true))
+          if (failureReported.compareAndSet(false, true))
             context.runCloseHooks(closeHookAsyncResult -> reportFailure(t, callingContext, completionHandler));
         }
       });

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -493,12 +493,13 @@ private void doDeploy(String identifier, String deploymentID, DeploymentOptions
               if (deployCount.incrementAndGet() == verticles.length) {
                 reportSuccess(deploymentID, callingContext, completionHandler);
               }
-            } else if (!failureReported.get()) {
+            } else if (!failureReported.getAndSet(true)) {
               context.runCloseHooks(closeHookAsyncResult -> reportFailure(ar.cause(), callingContext, completionHandler));
             }
           });
         } catch (Throwable t) {
-          context.runCloseHooks(closeHookAsyncResult -> reportFailure(t, callingContext, completionHandler));
+          if (!failureReported.getAndSet(true))
+            context.runCloseHooks(closeHookAsyncResult -> reportFailure(t, callingContext, completionHandler));
         }
       });
     }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -280,7 +280,7 @@ protected void initChannel(Channel ch) throws Exception {
                     if (options.isUseAlpn()) {
                       SslHandler sslHandler = pipeline.get(SslHandler.class);
                       String protocol = sslHandler.applicationProtocol();
-                      if (protocol.equals("h2")) {
+                      if ("h2".equals(protocol)) {
                         handleHttp2(pipeline.channel());
                       } else {
                         configureHttp1(pipeline);

File: src/test/java/io/vertx/test/core/MetricsTest.java
Patch:
@@ -951,6 +951,9 @@ public void testThreadPoolMetricsWithInternalExecuteBlocking() {
             system.readFile("afile.html", buffer -> {
               fut.complete(null);
             });
+            if (metrics.numberOfRunningTasks() > 0) {
+              hadRunning.set(true);
+            }
           },
           ar -> {
             if (metrics.numberOfWaitingTasks() > 0) {
@@ -959,9 +962,6 @@ public void testThreadPoolMetricsWithInternalExecuteBlocking() {
             if (metrics.numberOfIdleThreads() > 0) {
               hadIdle.set(true);
             }
-            if (metrics.numberOfRunningTasks() > 0) {
-              hadRunning.set(true);
-            }
             if (counter.incrementAndGet() == 100) {
               testComplete();
             }

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -292,7 +292,7 @@ private void createNewConnection(Waiter waiter) {
       sslHelper.validate(vertx);
       Bootstrap bootstrap = new Bootstrap();
       bootstrap.group(context.nettyEventLoop());
-      bootstrap.channelFactory(() -> vertx.transport().socketChannel(false));
+      bootstrap.channel(vertx.transport().channelType(false));
       connector.connect(this, bootstrap, context, peerHost, ssl, pool.version(), host, port, waiter);
     }
 

File: src/main/java/io/vertx/core/net/impl/AsyncResolveConnectHelper.java
Patch:
@@ -71,7 +71,7 @@ private static void checkPort(int port) {
   public static AsyncResolveConnectHelper doBind(VertxInternal vertx, SocketAddress socketAddress,
                                                  ServerBootstrap bootstrap) {
     AsyncResolveConnectHelper asyncResolveConnectHelper = new AsyncResolveConnectHelper();
-    bootstrap.channelFactory(() -> vertx.transport().serverChannel(socketAddress.path() != null));
+    bootstrap.channel(vertx.transport().serverChannelType(socketAddress.path() != null));
     if (socketAddress.path() != null) {
       java.net.SocketAddress converted = vertx.transport().convert(socketAddress, true);
       ChannelFuture future = bootstrap.bind(converted);

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -178,7 +178,7 @@ protected void doConnect(SocketAddress remoteAddress, String serverName, Handler
     sslHelper.validate(vertx);
     Bootstrap bootstrap = new Bootstrap();
     bootstrap.group(context.nettyEventLoop());
-    bootstrap.channelFactory(() -> vertx.transport().socketChannel(remoteAddress.path() != null));
+    bootstrap.channel(vertx.transport().channelType(remoteAddress.path() != null));
 
     applyConnectionOptions(bootstrap);
 

File: src/test/java/io/vertx/test/core/EventLoopGroupTest.java
Patch:
@@ -66,7 +66,7 @@ public void testNettyServerUsesContextEventLoop() throws Exception {
     awaitLatch(latch);
     ServerBootstrap bs = new ServerBootstrap();
     bs.group(context.nettyEventLoop());
-    bs.channelFactory(() -> ((VertxInternal)vertx).transport().serverChannel(false)) ;
+    bs.channel(((VertxInternal)vertx).transport().serverChannelType(false)) ;
     bs.option(ChannelOption.SO_BACKLOG, 100);
     bs.childHandler(new ChannelInitializer<SocketChannel>() {
       @Override

File: src/test/java/io/vertx/test/core/HostnameResolutionTest.java
Patch:
@@ -318,7 +318,7 @@ public void testAsyncResolveConnectIsNotifiedOnChannelEventLoop() throws Excepti
       AtomicReference<Thread> channelThread = new AtomicReference<>();
       CountDownLatch connectLatch = new CountDownLatch(1);
       Bootstrap bootstrap = new Bootstrap();
-      bootstrap.channelFactory(() -> ((VertxInternal)vertx).transport().socketChannel(false));
+      bootstrap.channel(((VertxInternal)vertx).transport().channelType(false));
       bootstrap.group(vertx.nettyEventLoopGroup());
       bootstrap.resolver(((VertxInternal) vertx).nettyAddressResolverGroup());
       bootstrap.handler(new ChannelInitializer<Channel>() {

File: src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java
Patch:
@@ -322,6 +322,9 @@ public void handle(JsonToken event) {
           case VALUE_NUMBER_INT:
             buffer.writeNumber(parser.getLongValue());
             break;
+          case VALUE_NUMBER_FLOAT:
+            buffer.writeNumber(parser.getDoubleValue());
+            break;
           case VALUE_STRING:
             buffer.writeString(parser.getText());
             break;

File: src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java
Patch:
@@ -322,6 +322,9 @@ public void handle(JsonToken event) {
           case VALUE_NUMBER_INT:
             buffer.writeNumber(parser.getLongValue());
             break;
+          case VALUE_NUMBER_FLOAT:
+            buffer.writeNumber(parser.getDoubleValue());
+            break;
           case VALUE_STRING:
             buffer.writeString(parser.getText());
             break;

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -484,7 +484,7 @@ private void doSendFile(String filename, long offset, long length, Handler<Async
       RandomAccessFile raf = null;
       try {
         raf = new RandomAccessFile(file, "r");
-        conn.queueForWrite(new DefaultHttpResponse(version, status, headers));
+        conn.writeToChannel(new DefaultHttpResponse(version, status, headers));
         conn.sendFile(raf, Math.min(offset, file.length()), contentLength);
       } catch (IOException e) {
         try {

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -484,7 +484,7 @@ private void doSendFile(String filename, long offset, long length, Handler<Async
       RandomAccessFile raf = null;
       try {
         raf = new RandomAccessFile(file, "r");
-        conn.queueForWrite(new DefaultHttpResponse(version, status, headers));
+        conn.writeToChannel(new DefaultHttpResponse(version, status, headers));
         conn.sendFile(raf, Math.min(offset, file.length()), contentLength);
       } catch (IOException e) {
         try {

File: src/main/generated/io/vertx/core/DeploymentOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.DeploymentOptions} original class using Vert.x codegen.
  */
-public class DeploymentOptionsConverter {
+ class DeploymentOptionsConverter {
 
-  public static void fromJson(JsonObject json, DeploymentOptions obj) {
+   static void fromJson(JsonObject json, DeploymentOptions obj) {
     if (json.getValue("config") instanceof JsonObject) {
       obj.setConfig(((JsonObject)json.getValue("config")).copy());
     }
@@ -72,7 +72,7 @@ public static void fromJson(JsonObject json, DeploymentOptions obj) {
     }
   }
 
-  public static void toJson(DeploymentOptions obj, JsonObject json) {
+   static void toJson(DeploymentOptions obj, JsonObject json) {
     if (obj.getConfig() != null) {
       json.put("config", obj.getConfig());
     }

File: src/main/generated/io/vertx/core/VertxOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.VertxOptions} original class using Vert.x codegen.
  */
-public class VertxOptionsConverter {
+ class VertxOptionsConverter {
 
-  public static void fromJson(JsonObject json, VertxOptions obj) {
+   static void fromJson(JsonObject json, VertxOptions obj) {
     if (json.getValue("addressResolverOptions") instanceof JsonObject) {
       obj.setAddressResolverOptions(new io.vertx.core.dns.AddressResolverOptions((JsonObject)json.getValue("addressResolverOptions")));
     }
@@ -95,7 +95,7 @@ public static void fromJson(JsonObject json, VertxOptions obj) {
     }
   }
 
-  public static void toJson(VertxOptions obj, JsonObject json) {
+   static void toJson(VertxOptions obj, JsonObject json) {
     if (obj.getAddressResolverOptions() != null) {
       json.put("addressResolverOptions", obj.getAddressResolverOptions().toJson());
     }

File: src/main/generated/io/vertx/core/cli/ArgumentConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.cli.Argument} original class using Vert.x codegen.
  */
-public class ArgumentConverter {
+ class ArgumentConverter {
 
-  public static void fromJson(JsonObject json, Argument obj) {
+   static void fromJson(JsonObject json, Argument obj) {
     if (json.getValue("argName") instanceof String) {
       obj.setArgName((String)json.getValue("argName"));
     }
@@ -50,7 +50,7 @@ public static void fromJson(JsonObject json, Argument obj) {
     }
   }
 
-  public static void toJson(Argument obj, JsonObject json) {
+   static void toJson(Argument obj, JsonObject json) {
     if (obj.getArgName() != null) {
       json.put("argName", obj.getArgName());
     }

File: src/main/generated/io/vertx/core/cli/OptionConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.cli.Option} original class using Vert.x codegen.
  */
-public class OptionConverter {
+ class OptionConverter {
 
-  public static void fromJson(JsonObject json, Option obj) {
+   static void fromJson(JsonObject json, Option obj) {
     if (json.getValue("argName") instanceof String) {
       obj.setArgName((String)json.getValue("argName"));
     }
@@ -68,7 +68,7 @@ public static void fromJson(JsonObject json, Option obj) {
     }
   }
 
-  public static void toJson(Option obj, JsonObject json) {
+   static void toJson(Option obj, JsonObject json) {
     if (obj.getArgName() != null) {
       json.put("argName", obj.getArgName());
     }

File: src/main/generated/io/vertx/core/datagram/DatagramSocketOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.datagram.DatagramSocketOptions} original class using Vert.x codegen.
  */
-public class DatagramSocketOptionsConverter {
+ class DatagramSocketOptionsConverter {
 
-  public static void fromJson(JsonObject json, DatagramSocketOptions obj) {
+   static void fromJson(JsonObject json, DatagramSocketOptions obj) {
     if (json.getValue("broadcast") instanceof Boolean) {
       obj.setBroadcast((Boolean)json.getValue("broadcast"));
     }
@@ -44,7 +44,7 @@ public static void fromJson(JsonObject json, DatagramSocketOptions obj) {
     }
   }
 
-  public static void toJson(DatagramSocketOptions obj, JsonObject json) {
+   static void toJson(DatagramSocketOptions obj, JsonObject json) {
     json.put("broadcast", obj.isBroadcast());
     json.put("ipV6", obj.isIpV6());
     json.put("loopbackModeDisabled", obj.isLoopbackModeDisabled());

File: src/main/generated/io/vertx/core/dns/AddressResolverOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.dns.AddressResolverOptions} original class using Vert.x codegen.
  */
-public class AddressResolverOptionsConverter {
+ class AddressResolverOptionsConverter {
 
-  public static void fromJson(JsonObject json, AddressResolverOptions obj) {
+   static void fromJson(JsonObject json, AddressResolverOptions obj) {
     if (json.getValue("cacheMaxTimeToLive") instanceof Number) {
       obj.setCacheMaxTimeToLive(((Number)json.getValue("cacheMaxTimeToLive")).intValue());
     }
@@ -74,7 +74,7 @@ public static void fromJson(JsonObject json, AddressResolverOptions obj) {
     }
   }
 
-  public static void toJson(AddressResolverOptions obj, JsonObject json) {
+   static void toJson(AddressResolverOptions obj, JsonObject json) {
     json.put("cacheMaxTimeToLive", obj.getCacheMaxTimeToLive());
     json.put("cacheMinTimeToLive", obj.getCacheMinTimeToLive());
     json.put("cacheNegativeTimeToLive", obj.getCacheNegativeTimeToLive());

File: src/main/generated/io/vertx/core/eventbus/EventBusOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.eventbus.EventBusOptions} original class using Vert.x codegen.
  */
-public class EventBusOptionsConverter {
+ class EventBusOptionsConverter {
 
-  public static void fromJson(JsonObject json, EventBusOptions obj) {
+   static void fromJson(JsonObject json, EventBusOptions obj) {
     if (json.getValue("acceptBacklog") instanceof Number) {
       obj.setAcceptBacklog(((Number)json.getValue("acceptBacklog")).intValue());
     }
@@ -164,7 +164,7 @@ public static void fromJson(JsonObject json, EventBusOptions obj) {
     }
   }
 
-  public static void toJson(EventBusOptions obj, JsonObject json) {
+   static void toJson(EventBusOptions obj, JsonObject json) {
     json.put("acceptBacklog", obj.getAcceptBacklog());
     if (obj.getClientAuth() != null) {
       json.put("clientAuth", obj.getClientAuth().name());

File: src/main/generated/io/vertx/core/file/CopyOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.file.CopyOptions} original class using Vert.x codegen.
  */
-public class CopyOptionsConverter {
+ class CopyOptionsConverter {
 
-  public static void fromJson(JsonObject json, CopyOptions obj) {
+   static void fromJson(JsonObject json, CopyOptions obj) {
     if (json.getValue("atomicMove") instanceof Boolean) {
       obj.setAtomicMove((Boolean)json.getValue("atomicMove"));
     }
@@ -41,7 +41,7 @@ public static void fromJson(JsonObject json, CopyOptions obj) {
     }
   }
 
-  public static void toJson(CopyOptions obj, JsonObject json) {
+   static void toJson(CopyOptions obj, JsonObject json) {
     json.put("atomicMove", obj.isAtomicMove());
     json.put("copyAttributes", obj.isCopyAttributes());
     json.put("nofollowLinks", obj.isNofollowLinks());

File: src/main/generated/io/vertx/core/file/OpenOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.file.OpenOptions} original class using Vert.x codegen.
  */
-public class OpenOptionsConverter {
+ class OpenOptionsConverter {
 
-  public static void fromJson(JsonObject json, OpenOptions obj) {
+   static void fromJson(JsonObject json, OpenOptions obj) {
     if (json.getValue("append") instanceof Boolean) {
       obj.setAppend((Boolean)json.getValue("append"));
     }
@@ -62,7 +62,7 @@ public static void fromJson(JsonObject json, OpenOptions obj) {
     }
   }
 
-  public static void toJson(OpenOptions obj, JsonObject json) {
+   static void toJson(OpenOptions obj, JsonObject json) {
     json.put("append", obj.isAppend());
     json.put("create", obj.isCreate());
     json.put("createNew", obj.isCreateNew());

File: src/main/generated/io/vertx/core/http/GoAwayConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.http.GoAway} original class using Vert.x codegen.
  */
-public class GoAwayConverter {
+ class GoAwayConverter {
 
-  public static void fromJson(JsonObject json, GoAway obj) {
+   static void fromJson(JsonObject json, GoAway obj) {
     if (json.getValue("debugData") instanceof String) {
       obj.setDebugData(io.vertx.core.buffer.Buffer.buffer(java.util.Base64.getDecoder().decode((String)json.getValue("debugData"))));
     }
@@ -38,7 +38,7 @@ public static void fromJson(JsonObject json, GoAway obj) {
     }
   }
 
-  public static void toJson(GoAway obj, JsonObject json) {
+   static void toJson(GoAway obj, JsonObject json) {
     if (obj.getDebugData() != null) {
       json.put("debugData", obj.getDebugData().getBytes());
     }

File: src/main/generated/io/vertx/core/http/Http2SettingsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.http.Http2Settings} original class using Vert.x codegen.
  */
-public class Http2SettingsConverter {
+ class Http2SettingsConverter {
 
-  public static void fromJson(JsonObject json, Http2Settings obj) {
+   static void fromJson(JsonObject json, Http2Settings obj) {
     if (json.getValue("headerTableSize") instanceof Number) {
       obj.setHeaderTableSize(((Number)json.getValue("headerTableSize")).longValue());
     }
@@ -47,7 +47,7 @@ public static void fromJson(JsonObject json, Http2Settings obj) {
     }
   }
 
-  public static void toJson(Http2Settings obj, JsonObject json) {
+   static void toJson(Http2Settings obj, JsonObject json) {
     json.put("headerTableSize", obj.getHeaderTableSize());
     json.put("initialWindowSize", obj.getInitialWindowSize());
     json.put("maxConcurrentStreams", obj.getMaxConcurrentStreams());

File: src/main/generated/io/vertx/core/http/HttpClientOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.http.HttpClientOptions} original class using Vert.x codegen.
  */
-public class HttpClientOptionsConverter {
+ class HttpClientOptionsConverter {
 
-  public static void fromJson(JsonObject json, HttpClientOptions obj) {
+   static void fromJson(JsonObject json, HttpClientOptions obj) {
     if (json.getValue("alpnVersions") instanceof JsonArray) {
       java.util.ArrayList<io.vertx.core.http.HttpVersion> list = new java.util.ArrayList<>();
       json.getJsonArray("alpnVersions").forEach( item -> {
@@ -109,7 +109,7 @@ public static void fromJson(JsonObject json, HttpClientOptions obj) {
     }
   }
 
-  public static void toJson(HttpClientOptions obj, JsonObject json) {
+   static void toJson(HttpClientOptions obj, JsonObject json) {
     if (obj.getAlpnVersions() != null) {
       JsonArray array = new JsonArray();
       obj.getAlpnVersions().forEach(item -> array.add(item.name()));

File: src/main/generated/io/vertx/core/http/HttpServerOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.http.HttpServerOptions} original class using Vert.x codegen.
  */
-public class HttpServerOptionsConverter {
+ class HttpServerOptionsConverter {
 
-  public static void fromJson(JsonObject json, HttpServerOptions obj) {
+   static void fromJson(JsonObject json, HttpServerOptions obj) {
     if (json.getValue("acceptUnmaskedFrames") instanceof Boolean) {
       obj.setAcceptUnmaskedFrames((Boolean)json.getValue("acceptUnmaskedFrames"));
     }
@@ -79,7 +79,7 @@ public static void fromJson(JsonObject json, HttpServerOptions obj) {
     }
   }
 
-  public static void toJson(HttpServerOptions obj, JsonObject json) {
+   static void toJson(HttpServerOptions obj, JsonObject json) {
     json.put("acceptUnmaskedFrames", obj.isAcceptUnmaskedFrames());
     if (obj.getAlpnVersions() != null) {
       JsonArray array = new JsonArray();

File: src/main/generated/io/vertx/core/metrics/MetricsOptionsConverter.java
Patch:
@@ -24,15 +24,15 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.metrics.MetricsOptions} original class using Vert.x codegen.
  */
-public class MetricsOptionsConverter {
+ class MetricsOptionsConverter {
 
-  public static void fromJson(JsonObject json, MetricsOptions obj) {
+   static void fromJson(JsonObject json, MetricsOptions obj) {
     if (json.getValue("enabled") instanceof Boolean) {
       obj.setEnabled((Boolean)json.getValue("enabled"));
     }
   }
 
-  public static void toJson(MetricsOptions obj, JsonObject json) {
+   static void toJson(MetricsOptions obj, JsonObject json) {
     json.put("enabled", obj.isEnabled());
   }
 }
\ No newline at end of file

File: src/main/generated/io/vertx/core/net/ClientOptionsBaseConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.ClientOptionsBase} original class using Vert.x codegen.
  */
-public class ClientOptionsBaseConverter {
+ class ClientOptionsBaseConverter {
 
-  public static void fromJson(JsonObject json, ClientOptionsBase obj) {
+   static void fromJson(JsonObject json, ClientOptionsBase obj) {
     if (json.getValue("connectTimeout") instanceof Number) {
       obj.setConnectTimeout(((Number)json.getValue("connectTimeout")).intValue());
     }
@@ -44,7 +44,7 @@ public static void fromJson(JsonObject json, ClientOptionsBase obj) {
     }
   }
 
-  public static void toJson(ClientOptionsBase obj, JsonObject json) {
+   static void toJson(ClientOptionsBase obj, JsonObject json) {
     json.put("connectTimeout", obj.getConnectTimeout());
     if (obj.getLocalAddress() != null) {
       json.put("localAddress", obj.getLocalAddress());

File: src/main/generated/io/vertx/core/net/NetClientOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.NetClientOptions} original class using Vert.x codegen.
  */
-public class NetClientOptionsConverter {
+ class NetClientOptionsConverter {
 
-  public static void fromJson(JsonObject json, NetClientOptions obj) {
+   static void fromJson(JsonObject json, NetClientOptions obj) {
     if (json.getValue("hostnameVerificationAlgorithm") instanceof String) {
       obj.setHostnameVerificationAlgorithm((String)json.getValue("hostnameVerificationAlgorithm"));
     }
@@ -38,7 +38,7 @@ public static void fromJson(JsonObject json, NetClientOptions obj) {
     }
   }
 
-  public static void toJson(NetClientOptions obj, JsonObject json) {
+   static void toJson(NetClientOptions obj, JsonObject json) {
     if (obj.getHostnameVerificationAlgorithm() != null) {
       json.put("hostnameVerificationAlgorithm", obj.getHostnameVerificationAlgorithm());
     }

File: src/main/generated/io/vertx/core/net/NetServerOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.NetServerOptions} original class using Vert.x codegen.
  */
-public class NetServerOptionsConverter {
+ class NetServerOptionsConverter {
 
-  public static void fromJson(JsonObject json, NetServerOptions obj) {
+   static void fromJson(JsonObject json, NetServerOptions obj) {
     if (json.getValue("acceptBacklog") instanceof Number) {
       obj.setAcceptBacklog(((Number)json.getValue("acceptBacklog")).intValue());
     }
@@ -47,7 +47,7 @@ public static void fromJson(JsonObject json, NetServerOptions obj) {
     }
   }
 
-  public static void toJson(NetServerOptions obj, JsonObject json) {
+   static void toJson(NetServerOptions obj, JsonObject json) {
     json.put("acceptBacklog", obj.getAcceptBacklog());
     if (obj.getClientAuth() != null) {
       json.put("clientAuth", obj.getClientAuth().name());

File: src/main/generated/io/vertx/core/net/NetworkOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.NetworkOptions} original class using Vert.x codegen.
  */
-public class NetworkOptionsConverter {
+ class NetworkOptionsConverter {
 
-  public static void fromJson(JsonObject json, NetworkOptions obj) {
+   static void fromJson(JsonObject json, NetworkOptions obj) {
     if (json.getValue("logActivity") instanceof Boolean) {
       obj.setLogActivity((Boolean)json.getValue("logActivity"));
     }
@@ -47,7 +47,7 @@ public static void fromJson(JsonObject json, NetworkOptions obj) {
     }
   }
 
-  public static void toJson(NetworkOptions obj, JsonObject json) {
+   static void toJson(NetworkOptions obj, JsonObject json) {
     json.put("logActivity", obj.getLogActivity());
     json.put("receiveBufferSize", obj.getReceiveBufferSize());
     json.put("reuseAddress", obj.isReuseAddress());

File: src/main/generated/io/vertx/core/net/OpenSSLEngineOptionsConverter.java
Patch:
@@ -24,15 +24,15 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.OpenSSLEngineOptions} original class using Vert.x codegen.
  */
-public class OpenSSLEngineOptionsConverter {
+ class OpenSSLEngineOptionsConverter {
 
-  public static void fromJson(JsonObject json, OpenSSLEngineOptions obj) {
+   static void fromJson(JsonObject json, OpenSSLEngineOptions obj) {
     if (json.getValue("sessionCacheEnabled") instanceof Boolean) {
       obj.setSessionCacheEnabled((Boolean)json.getValue("sessionCacheEnabled"));
     }
   }
 
-  public static void toJson(OpenSSLEngineOptions obj, JsonObject json) {
+   static void toJson(OpenSSLEngineOptions obj, JsonObject json) {
     json.put("alpnAvailable", obj.isAlpnAvailable());
     json.put("available", obj.isAvailable());
     json.put("sessionCacheEnabled", obj.isSessionCacheEnabled());

File: src/main/generated/io/vertx/core/net/PemKeyCertOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.PemKeyCertOptions} original class using Vert.x codegen.
  */
-public class PemKeyCertOptionsConverter {
+ class PemKeyCertOptionsConverter {
 
-  public static void fromJson(JsonObject json, PemKeyCertOptions obj) {
+   static void fromJson(JsonObject json, PemKeyCertOptions obj) {
     if (json.getValue("certPath") instanceof String) {
       obj.setCertPath((String)json.getValue("certPath"));
     }
@@ -73,7 +73,7 @@ public static void fromJson(JsonObject json, PemKeyCertOptions obj) {
     }
   }
 
-  public static void toJson(PemKeyCertOptions obj, JsonObject json) {
+   static void toJson(PemKeyCertOptions obj, JsonObject json) {
     if (obj.getCertPaths() != null) {
       JsonArray array = new JsonArray();
       obj.getCertPaths().forEach(item -> array.add(item));

File: src/main/generated/io/vertx/core/net/PemTrustOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.PemTrustOptions} original class using Vert.x codegen.
  */
-public class PemTrustOptionsConverter {
+ class PemTrustOptionsConverter {
 
-  public static void fromJson(JsonObject json, PemTrustOptions obj) {
+   static void fromJson(JsonObject json, PemTrustOptions obj) {
     if (json.getValue("certPaths") instanceof JsonArray) {
       json.getJsonArray("certPaths").forEach(item -> {
         if (item instanceof String)
@@ -41,7 +41,7 @@ public static void fromJson(JsonObject json, PemTrustOptions obj) {
     }
   }
 
-  public static void toJson(PemTrustOptions obj, JsonObject json) {
+   static void toJson(PemTrustOptions obj, JsonObject json) {
     if (obj.getCertPaths() != null) {
       JsonArray array = new JsonArray();
       obj.getCertPaths().forEach(item -> array.add(item));

File: src/main/generated/io/vertx/core/net/PfxOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.PfxOptions} original class using Vert.x codegen.
  */
-public class PfxOptionsConverter {
+ class PfxOptionsConverter {
 
-  public static void fromJson(JsonObject json, PfxOptions obj) {
+   static void fromJson(JsonObject json, PfxOptions obj) {
     if (json.getValue("password") instanceof String) {
       obj.setPassword((String)json.getValue("password"));
     }
@@ -38,7 +38,7 @@ public static void fromJson(JsonObject json, PfxOptions obj) {
     }
   }
 
-  public static void toJson(PfxOptions obj, JsonObject json) {
+   static void toJson(PfxOptions obj, JsonObject json) {
     if (obj.getPassword() != null) {
       json.put("password", obj.getPassword());
     }

File: src/main/generated/io/vertx/core/net/ProxyOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.ProxyOptions} original class using Vert.x codegen.
  */
-public class ProxyOptionsConverter {
+ class ProxyOptionsConverter {
 
-  public static void fromJson(JsonObject json, ProxyOptions obj) {
+   static void fromJson(JsonObject json, ProxyOptions obj) {
     if (json.getValue("host") instanceof String) {
       obj.setHost((String)json.getValue("host"));
     }
@@ -44,7 +44,7 @@ public static void fromJson(JsonObject json, ProxyOptions obj) {
     }
   }
 
-  public static void toJson(ProxyOptions obj, JsonObject json) {
+   static void toJson(ProxyOptions obj, JsonObject json) {
     if (obj.getHost() != null) {
       json.put("host", obj.getHost());
     }

File: src/main/generated/io/vertx/core/net/TCPSSLOptionsConverter.java
Patch:
@@ -24,9 +24,9 @@
  *
  * NOTE: This class has been automatically generated from the {@link io.vertx.core.net.TCPSSLOptions} original class using Vert.x codegen.
  */
-public class TCPSSLOptionsConverter {
+ class TCPSSLOptionsConverter {
 
-  public static void fromJson(JsonObject json, TCPSSLOptions obj) {
+   static void fromJson(JsonObject json, TCPSSLOptions obj) {
     if (json.getValue("crlPaths") instanceof JsonArray) {
       json.getJsonArray("crlPaths").forEach(item -> {
         if (item instanceof String)
@@ -107,7 +107,7 @@ public static void fromJson(JsonObject json, TCPSSLOptions obj) {
     }
   }
 
-  public static void toJson(TCPSSLOptions obj, JsonObject json) {
+   static void toJson(TCPSSLOptions obj, JsonObject json) {
     if (obj.getCrlPaths() != null) {
       JsonArray array = new JsonArray();
       obj.getCrlPaths().forEach(item -> array.add(item));

File: src/main/java/io/vertx/core/DeploymentOptions.java
Patch:
@@ -30,7 +30,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class DeploymentOptions {
 
   public static final boolean DEFAULT_WORKER = false;

File: src/main/java/io/vertx/core/VertxOptions.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class VertxOptions {
 
   /**

File: src/main/java/io/vertx/core/cli/Argument.java
Patch:
@@ -28,7 +28,7 @@
  * @author Clement Escoffier <clement@apache.org>
  * @see Option
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class Argument {
 
   /**

File: src/main/java/io/vertx/core/cli/Option.java
Patch:
@@ -31,7 +31,7 @@
  *
  * @author Clement Escoffier <clement@apache.org>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class Option {
 
   /**

File: src/main/java/io/vertx/core/datagram/DatagramSocketOptions.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class DatagramSocketOptions extends NetworkOptions {
 
   /**

File: src/main/java/io/vertx/core/dns/AddressResolverOptions.java
Patch:
@@ -31,7 +31,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class AddressResolverOptions {
 
   /**

File: src/main/java/io/vertx/core/eventbus/EventBusOptions.java
Patch:
@@ -29,7 +29,7 @@
  *
  * @author <a href="http://escoffier.me">Clement Escoffier</a>
  */
-@DataObject(generateConverter = true, inheritConverter = true)
+@DataObject(generateConverter = true, inheritConverter = true, publicConverter = false)
 public class EventBusOptions extends TCPSSLOptions {
 
   private boolean clustered = VertxOptions.DEFAULT_CLUSTERED;

File: src/main/java/io/vertx/core/file/CopyOptions.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @author Thomas Segismont
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class CopyOptions {
 
   /**

File: src/main/java/io/vertx/core/file/OpenOptions.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class OpenOptions {
 
   public static final String DEFAULT_PERMS = null;

File: src/main/java/io/vertx/core/http/GoAway.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class GoAway {
 
   private long errorCode;

File: src/main/java/io/vertx/core/http/Http2Settings.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class Http2Settings {
 
   /**

File: src/main/java/io/vertx/core/http/HttpClientOptions.java
Patch:
@@ -31,7 +31,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class HttpClientOptions extends ClientOptionsBase {
 
   /**

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -32,7 +32,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class HttpServerOptions extends NetServerOptions {
 
   /**

File: src/main/java/io/vertx/core/metrics/MetricsOptions.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class MetricsOptions {
 
   /**

File: src/main/java/io/vertx/core/net/ClientOptionsBase.java
Patch:
@@ -27,7 +27,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public abstract class ClientOptionsBase extends TCPSSLOptions {
 
   /**

File: src/main/java/io/vertx/core/net/NetClientOptions.java
Patch:
@@ -27,7 +27,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class NetClientOptions extends ClientOptionsBase {
 
   /**

File: src/main/java/io/vertx/core/net/NetServerOptions.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class NetServerOptions extends TCPSSLOptions {
 
   // Server specific HTTP stuff

File: src/main/java/io/vertx/core/net/NetworkOptions.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public abstract class NetworkOptions {
 
   /**

File: src/main/java/io/vertx/core/net/OpenSSLEngineOptions.java
Patch:
@@ -9,7 +9,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class OpenSSLEngineOptions extends SSLEngineOptions {
 
   /**

File: src/main/java/io/vertx/core/net/PemKeyCertOptions.java
Patch:
@@ -92,7 +92,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class PemKeyCertOptions implements KeyCertOptions, Cloneable {
 
   private List<String> keyPaths;

File: src/main/java/io/vertx/core/net/PemTrustOptions.java
Patch:
@@ -61,7 +61,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class PemTrustOptions implements TrustOptions, Cloneable {
 
   private ArrayList<String> certPaths;

File: src/main/java/io/vertx/core/net/PfxOptions.java
Patch:
@@ -44,7 +44,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class PfxOptions implements KeyCertOptions, TrustOptions, Cloneable {
 
   private String password;

File: src/main/java/io/vertx/core/net/ProxyOptions.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author <a href="http://oss.lehmann.cx/">Alexander Lehmann</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public class ProxyOptions {
 
   /**

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -28,7 +28,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject(generateConverter = true)
+@DataObject(generateConverter = true, publicConverter = false)
 public abstract class TCPSSLOptions extends NetworkOptions {
 
   /**

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -242,6 +242,7 @@ private void handshakeComplete(ChannelHandlerContext ctx, FullHttpResponse respo
                                                   client.getOptions().getMaxWebsocketMessageSize());
       ws = webSocket;
       handshaker.finishHandshake(chctx.channel(), response);
+      ws.subProtocol(handshaker.actualSubprotocol());
       context.executeFromIO(() -> {
         log.debug("WebSocket handshake complete");
         if (metrics != null ) {

File: src/test/java/io/vertx/test/core/tls/Cert.java
Patch:
@@ -18,6 +18,7 @@ public interface Cert<K extends KeyCertOptions> extends Supplier<K> {
   Cert<PfxOptions> SERVER_PKCS12 = () -> new PfxOptions().setPath("tls/server-keystore.p12").setPassword("wibble");
   Cert<PfxOptions> CLIENT_PKCS12 = () -> new PfxOptions().setPath("tls/client-keystore.p12").setPassword("wibble");
   Cert<PemKeyCertOptions> SERVER_PEM = () -> new PemKeyCertOptions().setKeyPath("tls/server-key.pem").setCertPath("tls/server-cert.pem");
+  Cert<PemKeyCertOptions> SERVER_PEM_RSA = () -> new PemKeyCertOptions().setKeyPath("tls/server-key-pkcs1.pem").setCertPath("tls/server-cert.pem");
   Cert<PemKeyCertOptions> CLIENT_PEM = () -> new PemKeyCertOptions().setKeyPath("tls/client-key.pem").setCertPath("tls/client-cert.pem");
   Cert<JksOptions> SERVER_JKS_ROOT_CA = () -> new JksOptions().setPath("tls/server-keystore-root-ca.jks").setPassword("wibble");
   Cert<PfxOptions> SERVER_PKCS12_ROOT_CA = () -> new PfxOptions().setPath("tls/server-keystore-root-ca.p12").setPassword("wibble");

File: src/main/java/io/vertx/core/http/RequestOptions.java
Patch:
@@ -37,12 +37,12 @@ public class RequestOptions {
   public static final int DEFAULT_PORT = 80;
 
   /**
-   * SSL enable by default = false
+   * SSL enabled by default = false
    */
   public static final boolean DEFAULT_SSL = false;
 
   /**
-   * SSL enable by default = false
+   * The default relative request URI = ""
    */
   public static final String DEFAULT_URI = "";
 

File: src/main/java/io/vertx/core/http/HttpClient.java
Patch:
@@ -1309,7 +1309,7 @@ HttpClient websocket(String requestURI, MultiMap headers, WebsocketVersion versi
   ReadStream<WebSocket> websocketStream(String host, String requestURI, MultiMap headers, WebsocketVersion version);
 
   /**
-   * Create a WebSocket stream with the specified options, the specified headers, using the specified version of WebSockets,
+   * Create a WebSocket stream with the specified absolute url, the specified headers, using the specified version of WebSockets,
    * and the specified websocket sub protocols.
    *
    * @param url          the absolute url

File: src/main/java/io/vertx/core/http/RequestOptions.java
Patch:
@@ -37,12 +37,12 @@ public class RequestOptions {
   public static final int DEFAULT_PORT = 80;
 
   /**
-   * SSL enable by default = false
+   * SSL enabled by default = false
    */
   public static final boolean DEFAULT_SSL = false;
 
   /**
-   * SSL enable by default = false
+   * The default relative request URI = ""
    */
   public static final String DEFAULT_URI = "";
 

File: src/test/benchmarks/io/vertx/benchmarks/HttpServerHandlerBenchmark.java
Patch:
@@ -231,7 +231,7 @@ public void setup() {
           .add(HEADER_CONTENT_LENGTH, HELLO_WORLD_LENGTH);
       response.end(HELLO_WORLD_BUFFER);
     };
-    HandlerHolder<HttpHandlers> holder = new HandlerHolder<>(context, new HttpHandlers(app, null, null));
+    HandlerHolder<HttpHandlers> holder = new HandlerHolder<>(context, new HttpHandlers(app, null, null, null));
     ServerHandler handler = new ServerHandler(null, new HttpServerOptions(), "localhost", holder, null);
     vertxChannel.pipeline().addLast("handler", handler);
 

File: src/main/java/io/vertx/core/http/Http2Settings.java
Patch:
@@ -295,8 +295,8 @@ public Long get(int id) {
    * @return a reference to this, so the API can be used fluently
    */
   public Http2Settings set(int id, long value) {
-    Arguments.require(id >= 0 || id <= 0xFFFF, "Setting id must me an unsigned 16-bit value");
-    Arguments.require(value >= 0 || value <= 0xFFFFFFFF, "Setting value must me an unsigned 32-bit value");
+    Arguments.require(id >= 0 && id <= 0xFFFF, "Setting id must me an unsigned 16-bit value");
+    Arguments.require(value >= 0L && value <= 0xFFFFFFFFL, "Setting value must me an unsigned 32-bit value");
     switch (id) {
       case 1:
         setHeaderTableSize(value);

File: src/test/benchmarks/io/vertx/benchmarks/HttpServerHandlerBenchmark.java
Patch:
@@ -231,7 +231,7 @@ public void setup() {
           .add(HEADER_CONTENT_LENGTH, HELLO_WORLD_LENGTH);
       response.end(HELLO_WORLD_BUFFER);
     };
-    HandlerHolder<HttpHandlers> holder = new HandlerHolder<>(context, new HttpHandlers(app, null, null));
+    HandlerHolder<HttpHandlers> holder = new HandlerHolder<>(context, new HttpHandlers(app, null, null, null));
     ServerHandler handler = new ServerHandler(null, new HttpServerOptions(), "localhost", holder, null);
     vertxChannel.pipeline().addLast("handler", handler);
 

File: src/main/java/io/vertx/core/http/Http2Settings.java
Patch:
@@ -295,8 +295,8 @@ public Long get(int id) {
    * @return a reference to this, so the API can be used fluently
    */
   public Http2Settings set(int id, long value) {
-    Arguments.require(id >= 0 || id <= 0xFFFF, "Setting id must me an unsigned 16-bit value");
-    Arguments.require(value >= 0 || value <= 0xFFFFFFFF, "Setting value must me an unsigned 32-bit value");
+    Arguments.require(id >= 0 && id <= 0xFFFF, "Setting id must me an unsigned 16-bit value");
+    Arguments.require(value >= 0L && value <= 0xFFFFFFFFL, "Setting value must me an unsigned 32-bit value");
     switch (id) {
       case 1:
         setHeaderTableSize(value);

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -314,7 +314,7 @@ private String getClusterPublicHost(EventBusOptions options) {
 
   private Handler<NetSocket> getServerHandler() {
     return socket -> {
-      RecordParser parser = RecordParser.newFixed(4, null);
+      RecordParser parser = RecordParser.newFixed(4);
       Handler<Buffer> handler = new Handler<Buffer>() {
         int size = -1;
 

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -3103,7 +3103,7 @@ private void testNetServerInternal_(HttpClientOptions clientOptions, boolean exp
       assertEquals(200, resp.statusCode());
       resp.bodyHandler(buff -> {
         assertEquals("Hello World", buff.toString());
-        testComplete();
+        complete();
       });
     });
     await();

File: src/main/java/examples/ParseToolsExamples.java
Patch:
@@ -71,17 +71,17 @@ public void jsonParserExample2() {
     // start array event
     // start object event
     // "firstName":"Bob" event
-    parser.handle(Buffer.buffer("[{\"firstName\":\"Bob\"},"));
+    parser.handle(Buffer.buffer("[{\"firstName\":\"Bob\","));
 
     // "lastName":"Morane" event
     // end object event
-    parser.handle(Buffer.buffer("\"lastName\":\"Morane\")},"));
+    parser.handle(Buffer.buffer("\"lastName\":\"Morane\"},"));
 
     // start object event
     // "firstName":"Luke" event
     // "lastName":"Lucky" event
     // end object event
-    parser.handle(Buffer.buffer("{\"firstName\":\"Luke\",\"lastName\":\"Lucky\")}"));
+    parser.handle(Buffer.buffer("{\"firstName\":\"Luke\",\"lastName\":\"Lucky\"}"));
 
     // end array event
     parser.handle(Buffer.buffer("]"));

File: src/main/java/io/vertx/core/VertxOptions.java
Patch:
@@ -19,6 +19,7 @@
 import io.vertx.codegen.annotations.DataObject;
 import io.vertx.core.dns.AddressResolverOptions;
 import io.vertx.core.eventbus.EventBusOptions;
+import io.vertx.core.impl.cpu.CpuCoreSensor;
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.metrics.MetricsOptions;
 import io.vertx.core.spi.cluster.ClusterManager;
@@ -38,7 +39,7 @@ public class VertxOptions {
   /**
    * The default number of event loop threads to be used  = 2 * number of cores on the machine
    */
-  public static final int DEFAULT_EVENT_LOOP_POOL_SIZE = 2 * Runtime.getRuntime().availableProcessors();
+  public static final int DEFAULT_EVENT_LOOP_POOL_SIZE = 2 * CpuCoreSensor.availableProcessors();
 
   /**
    * The default number of threads in the worker pool = 20

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -115,7 +115,7 @@ public void deployVerticle(Supplier<? extends Verticle> verticleSupplier, Deploy
         });
       }
       if (verticles.size() != 1) {
-        throw new RuntimeException("Supplied verticles are not of the same class");
+        throw new RuntimeException("Supplied verticles are not from the same class");
       }
       Set<Verticle> instances = verticles.values().iterator().next();
       if (instances.size() != nbInstances) {

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ConnectionHolder.java
Patch:
@@ -95,7 +95,9 @@ void close() {
     // The holder can be null or different if the target server is restarted with same serverid
     // before the cleanup for the previous one has been processed
     if (eventBus.connections().remove(serverID, this)) {
-      log.debug("Cluster connection closed: " + serverID + " holder " + this);
+      if (log.isDebugEnabled()) {
+        log.debug("Cluster connection closed for server " + serverID);
+      }
     }
   }
 

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ConnectionHolder.java
Patch:
@@ -56,6 +56,7 @@ synchronized void connect() {
       if (res.succeeded()) {
         connected(res.result());
       } else {
+        log.error("Connecting to server " + serverID + " failed.", res.cause());
         close();
       }
     });

File: src/main/java/io/vertx/core/buffer/impl/BufferImpl.java
Patch:
@@ -36,7 +36,7 @@ public class BufferImpl implements Buffer {
 
   private ByteBuf buffer;
 
-  BufferImpl() {
+  public BufferImpl() {
     this(0);
   }
 

File: src/main/java/io/vertx/core/shareddata/LocalMap.java
Patch:
@@ -34,10 +34,13 @@
  * <p>
  * This ensures there is no shared access to mutable state from different threads (e.g. different event loops) in the
  * Vert.x instance, and means you don't have to protect access to that state using synchronization or locks.
+ * <p>
+ * Your own objects can be marked as immutable by implementing the {@link Shareable} interface.
  *
  * Since the version 3.4, this class extends the {@link Map} interface. However some methods are only accessible in Java.
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
+ * @see Shareable
  */
 @VertxGen
 public interface LocalMap<K, V> extends Map<K, V> {

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -101,6 +101,7 @@ public class AsyncFileImpl implements AsyncFile {
       } else {
         ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool());
       }
+      if (options.isAppend()) writePos = ch.size();
     } catch (IOException e) {
       throw new FileSystemException(e);
     }

File: src/test/java/io/vertx/test/core/FileSystemTest.java
Patch:
@@ -1162,11 +1162,9 @@ public void testWriteStreamAppend() throws Exception {
     createFile(fileName, existing);
     byte[] content = TestUtils.randomByteArray(chunkSize * chunks);
     Buffer buff = Buffer.buffer(content);
-    vertx.fileSystem().open(testDir + pathSep + fileName, new OpenOptions(), ar -> {
+    vertx.fileSystem().open(testDir + pathSep + fileName, new OpenOptions().setAppend(true), ar -> {
       if (ar.succeeded()) {
         AsyncFile ws = ar.result();
-        long size = vertx.fileSystem().propsBlocking(testDir + pathSep + fileName).size();
-        ws.setWritePos(size);
         ws.exceptionHandler(t -> fail(t.getMessage()));
         for (int i = 0; i < chunks; i++) {
           Buffer chunk = buff.getBuffer(i * chunkSize, (i + 1) * chunkSize);

File: src/main/java/io/vertx/core/shareddata/LocalMap.java
Patch:
@@ -34,10 +34,13 @@
  * <p>
  * This ensures there is no shared access to mutable state from different threads (e.g. different event loops) in the
  * Vert.x instance, and means you don't have to protect access to that state using synchronization or locks.
+ * <p>
+ * Your own objects can be marked as immutable by implementing the {@link Shareable} interface.
  *
  * Since the version 3.4, this class extends the {@link Map} interface. However some methods are only accessible in Java.
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
+ * @see Shareable
  */
 @VertxGen
 public interface LocalMap<K, V> extends Map<K, V> {

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -101,6 +101,7 @@ public class AsyncFileImpl implements AsyncFile {
       } else {
         ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool());
       }
+      if (options.isAppend()) writePos = ch.size();
     } catch (IOException e) {
       throw new FileSystemException(e);
     }

File: src/test/java/io/vertx/test/core/FileSystemTest.java
Patch:
@@ -1162,11 +1162,9 @@ public void testWriteStreamAppend() throws Exception {
     createFile(fileName, existing);
     byte[] content = TestUtils.randomByteArray(chunkSize * chunks);
     Buffer buff = Buffer.buffer(content);
-    vertx.fileSystem().open(testDir + pathSep + fileName, new OpenOptions(), ar -> {
+    vertx.fileSystem().open(testDir + pathSep + fileName, new OpenOptions().setAppend(true), ar -> {
       if (ar.succeeded()) {
         AsyncFile ws = ar.result();
-        long size = vertx.fileSystem().propsBlocking(testDir + pathSep + fileName).size();
-        ws.setWritePos(size);
         ws.exceptionHandler(t -> fail(t.getMessage()));
         for (int i = 0; i < chunks; i++) {
           Buffer chunk = buff.getBuffer(i * chunkSize, (i + 1) * chunkSize);

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -414,7 +414,9 @@ protected synchronized void handleClosed() {
 
     // Connection was closed - call exception handlers for any requests in the pipeline or one being currently written
     for (HttpClientRequestImpl req: requests) {
-      req.handleException(e);
+      if (req != currentRequest) {
+        req.handleException(e);
+      }
     }
     if (currentRequest != null) {
       currentRequest.handleException(e);

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -1787,19 +1787,19 @@ public void testShutdown() throws Exception {
           fail();
         });
         req.response().exceptionHandler(err -> {
-          fail();
+          assertEquals(2, status.getAndIncrement());
         });
       } else {
         assertEquals(0, status.getAndIncrement());
         req.exceptionHandler(err -> {
           fail();
         });
         req.response().exceptionHandler(err -> {
-          fail();
+          assertEquals(3, status.getAndIncrement());
         });
         HttpConnection conn = req.connection();
         conn.closeHandler(v -> {
-          assertEquals(2, status.getAndIncrement());
+          assertEquals(4, status.getAndIncrement());
           complete();
         });
         conn.shutdown();

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -414,7 +414,9 @@ protected synchronized void handleClosed() {
 
     // Connection was closed - call exception handlers for any requests in the pipeline or one being currently written
     for (HttpClientRequestImpl req: requests) {
-      req.handleException(e);
+      if (req != currentRequest) {
+        req.handleException(e);
+      }
     }
     if (currentRequest != null) {
       currentRequest.handleException(e);

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -1787,19 +1787,19 @@ public void testShutdown() throws Exception {
           fail();
         });
         req.response().exceptionHandler(err -> {
-          fail();
+          assertEquals(2, status.getAndIncrement());
         });
       } else {
         assertEquals(0, status.getAndIncrement());
         req.exceptionHandler(err -> {
           fail();
         });
         req.response().exceptionHandler(err -> {
-          fail();
+          assertEquals(3, status.getAndIncrement());
         });
         HttpConnection conn = req.connection();
         conn.closeHandler(v -> {
-          assertEquals(2, status.getAndIncrement());
+          assertEquals(4, status.getAndIncrement());
           complete();
         });
         conn.shutdown();

File: src/test/java/io/vertx/test/core/Http1xTest.java
Patch:
@@ -3397,7 +3397,7 @@ public void testInvalidTrailerInHttpServerRequest() throws Exception {
         so.write("01234567");
       }
     }, errors -> {
-      assertEquals(1, errors.size());
+      assertEquals(2, errors.size());
       assertEquals(TooLongFrameException.class, errors.get(0).getClass());
     });
   }
@@ -3407,7 +3407,7 @@ public void testInvalidChunkInHttpServerRequest() throws Exception {
     testHttpServerRequestDecodeError(so -> {
       so.write("invalid\r\n"); // Empty chunk
     }, errors -> {
-      assertEquals(1, errors.size());
+      assertEquals(2, errors.size());
       assertEquals(NumberFormatException.class, errors.get(0).getClass());
     });
   }

File: src/test/benchmarks/io/vertx/benchmarks/BenchmarkBase.java
Patch:
@@ -32,7 +32,7 @@
 @Measurement(iterations = 10, time = 2, timeUnit = TimeUnit.SECONDS)
 @Threads(1)
 @BenchmarkMode(Mode.Throughput)
-@Fork(value = 1, jvmArgsAppend = {
+@Fork(value = 1, jvmArgs = {
     "-XX:+UseBiasedLocking",
     "-XX:BiasedLockingStartupDelay=0",
     "-XX:+AggressiveOpts",

File: src/main/java/io/vertx/core/http/impl/Http2Pool.java
Patch:
@@ -17,7 +17,6 @@
 package io.vertx.core.http.impl;
 
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http2.Http2Exception;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.impl.ContextImpl;
@@ -86,7 +85,7 @@ void createConn(ContextImpl context, Channel ch, Waiter waiter, boolean upgrade)
       VertxHttp2ConnectionHandler<Http2ClientConnection> handler = new VertxHttp2ConnectionHandlerBuilder<Http2ClientConnection>(ch)
           .connectionMap(connectionMap)
           .server(false)
-          .upgrade(upgrade)
+          .clientUpgrade(upgrade)
           .useCompression(client.getOptions().isTryUseCompression())
           .initialSettings(client.getOptions().getInitialSettings())
           .connectionFactory(connHandler -> {

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -234,7 +234,7 @@ public EventLoop nettyEventLoop() {
     return eventLoop;
   }
 
-  public Vertx owner() {
+  public VertxInternal owner() {
     return owner;
   }
 

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -231,7 +231,7 @@ protected FileSystem getFileSystem() {
 
   @Override
   public DatagramSocket createDatagramSocket(DatagramSocketOptions options) {
-    return new DatagramSocketImpl(this, options);
+    return DatagramSocketImpl.create(this, options);
   }
 
   @Override

File: src/test/java/io/vertx/test/core/DatagramTest.java
Patch:
@@ -207,6 +207,7 @@ public void testSender() {
       WriteStream<Buffer> sender1 = peer1.sender(1234, "127.0.0.1");
       sender1.write(buffer);
     });
+    await();
   }
 
   @Test

File: src/main/java/io/vertx/core/spi/metrics/Metrics.java
Patch:
@@ -24,7 +24,7 @@
  */
 public interface Metrics {
 
-  String DISABLE_METRICS_PROPERTY_NAME = "vertx.disabledMetrics";
+  String DISABLE_METRICS_PROPERTY_NAME = "vertx.disableMetrics";
 
   boolean METRICS_ENABLED = !Boolean.getBoolean(DISABLE_METRICS_PROPERTY_NAME);
 

File: src/test/java/io/vertx/test/core/Http2ClientTest.java
Patch:
@@ -1539,6 +1539,7 @@ public void testRejectClearTextUpgrade() throws Exception {
       server.requestHandler(req -> {
         MultiMap headers = req.headers();
         String upgrade = headers.get("upgrade");
+        assertEquals(DEFAULT_HTTP_HOST + ":" + DEFAULT_HTTP_PORT, req.host());
         if ("h2c".equals(upgrade)) {
           req.response().setStatusCode(400).end();
         } else {

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -173,7 +173,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
     defaultWorkerPoolSize = options.getWorkerPoolSize();
     defaultWorkerMaxExecTime = options.getMaxWorkerExecuteTime();
 
-    this.fileResolver = new FileResolver(this);
+    this.fileResolver = new FileResolver(this, options.isFileResolverCachingEnabled());
     this.addressResolver = new AddressResolver(this, options.getAddressResolverOptions());
     this.deploymentManager = new DeploymentManager(this);
     this.haEnabled = options.isClustered() && options.isHAEnabled();

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -173,7 +173,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
     defaultWorkerPoolSize = options.getWorkerPoolSize();
     defaultWorkerMaxExecTime = options.getMaxWorkerExecuteTime();
 
-    this.fileResolver = new FileResolver(this);
+    this.fileResolver = new FileResolver(this, options.isFileResolverCachingEnabled());
     this.addressResolver = new AddressResolver(this, options.getAddressResolverOptions());
     this.deploymentManager = new DeploymentManager(this);
     this.haEnabled = options.isClustered() && options.isHAEnabled();

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -45,6 +45,7 @@
 import io.vertx.core.http.impl.HeadersAdaptor;
 import io.vertx.core.impl.EventLoopContext;
 import io.vertx.core.impl.WorkerContext;
+import io.vertx.core.net.NetClient;
 import io.vertx.core.net.NetSocket;
 import io.vertx.test.netty.TestLoggerFactory;
 import org.junit.Assume;

File: src/test/java/io/vertx/core/impl/launcher/DefaultCommandTest.java
Patch:
@@ -32,7 +32,7 @@
 
 public class DefaultCommandTest {
 
-  HelloCommand command = new HelloCommand();
+  private HelloCommand command = new HelloCommand();
 
   private CommandLine parse(CLI cli, String... args) throws CLIException {
     return cli.parse(Arrays.asList(args));
@@ -94,4 +94,4 @@ public void run() throws CLIException {
     }
   }
 
-}
\ No newline at end of file
+}

File: src/main/java/io/vertx/core/json/Json.java
Patch:
@@ -81,15 +81,15 @@ public static <T> T decodeValue(String str, Class<T> clazz) throws DecodeExcepti
     try {
       return mapper.readValue(str, clazz);
     } catch (Exception e) {
-      throw new DecodeException("Failed to decode:" + e.getMessage());
+      throw new DecodeException("Failed to decode: " + e.getMessage());
     }
   }
 
   public static <T> T decodeValue(String str, TypeReference<T> type) throws DecodeException {
     try {
       return mapper.readValue(str, type);
     } catch (Exception e) {
-      throw new DecodeException("Failed to decode:" + e.getMessage(), e);
+      throw new DecodeException("Failed to decode: " + e.getMessage(), e);
     }
   }
 

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -45,6 +45,7 @@
 import io.vertx.core.http.impl.HeadersAdaptor;
 import io.vertx.core.impl.EventLoopContext;
 import io.vertx.core.impl.WorkerContext;
+import io.vertx.core.net.NetClient;
 import io.vertx.core.net.NetSocket;
 import io.vertx.test.netty.TestLoggerFactory;
 import org.junit.Assume;

File: src/test/java/io/vertx/core/impl/launcher/DefaultCommandTest.java
Patch:
@@ -32,7 +32,7 @@
 
 public class DefaultCommandTest {
 
-  HelloCommand command = new HelloCommand();
+  private HelloCommand command = new HelloCommand();
 
   private CommandLine parse(CLI cli, String... args) throws CLIException {
     return cli.parse(Arrays.asList(args));
@@ -94,4 +94,4 @@ public void run() throws CLIException {
     }
   }
 
-}
\ No newline at end of file
+}

File: src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
Patch:
@@ -405,7 +405,7 @@ private void handleDeployFailed(Throwable cause) {
   protected JsonObject getConfiguration() {
     JsonObject conf;
     if (config != null) {
-      try (Scanner scanner = new Scanner(new File(config)).useDelimiter("\\A")) {
+      try (Scanner scanner = new Scanner(new File(config), "UTF-8").useDelimiter("\\A")) {
         String sconf = scanner.next();
         try {
           conf = new JsonObject(sconf);

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1090,7 +1090,7 @@
  * `301`, `302`, `303` or `307` status code, it follows the redirection provided by the `Location` response header
  * and the response handler is passed the redirected response instead of the original response.
  *
- * Heres an example:
+ * Here's an example:
  *
  * [source,$lang]
  * ----

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -575,7 +575,8 @@ void applyHttp1xConnectionOptions(ConnQueue queue, ChannelPipeline pipeline, Con
       if (logEnabled) {
         pipeline.addLast("logging", new LoggingHandler());
       }
-      pipeline.addLast("codec", new HttpClientCodec(options.getMaxInitialLineLength(), options.getMaxHeaderSize(), options.getMaxChunkSize(), false, false));
+      pipeline.addLast("codec", new HttpClientCodec(options.getMaxInitialLineLength(), options.getMaxHeaderSize(),
+              options.getMaxChunkSize(), false, false, options.getDecoderInitialBufferSize()));
       if (options.isTryUseCompression()) {
         pipeline.addLast("inflater", new HttpContentDecompressor(true));
       }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -384,7 +384,7 @@ private void configureHttp1(ChannelPipeline pipeline) {
       pipeline.addLast("flashpolicy", new FlashPolicyHandler());
     }
     pipeline.addLast("httpDecoder", new HttpRequestDecoder(options.getMaxInitialLineLength()
-        , options.getMaxHeaderSize(), options.getMaxChunkSize(), false));
+        , options.getMaxHeaderSize(), options.getMaxChunkSize(), false, options.getDecoderInitialBufferSize()));
     pipeline.addLast("httpEncoder", new VertxHttpResponseEncoder());
     if (options.isDecompressionSupported()) {
       pipeline.addLast("inflater", new HttpContentDecompressor(true));

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -566,7 +566,8 @@ void applyHttp1xConnectionOptions(ConnQueue queue, ChannelPipeline pipeline, Con
       if (logEnabled) {
         pipeline.addLast("logging", new LoggingHandler());
       }
-      pipeline.addLast("codec", new HttpClientCodec(options.getMaxInitialLineLength(), options.getMaxHeaderSize(), options.getMaxChunkSize(), false, false));
+      pipeline.addLast("codec", new HttpClientCodec(options.getMaxInitialLineLength(), options.getMaxHeaderSize(),
+              options.getMaxChunkSize(), false, false, options.getInitialBufferSizeHttpDecoder()));
       if (options.isTryUseCompression()) {
         pipeline.addLast("inflater", new HttpContentDecompressor(true));
       }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -374,7 +374,7 @@ private void configureHttp1(ChannelPipeline pipeline) {
       pipeline.addLast("flashpolicy", new FlashPolicyHandler());
     }
     pipeline.addLast("httpDecoder", new HttpRequestDecoder(options.getMaxInitialLineLength()
-        , options.getMaxHeaderSize(), options.getMaxChunkSize(), false));
+        , options.getMaxHeaderSize(), options.getMaxChunkSize(), false, options.getInitialBufferSizeHttpDecoder()));
     pipeline.addLast("httpEncoder", new VertxHttpResponseEncoder());
     if (options.isDecompressionSupported()) {
       pipeline.addLast("inflater", new HttpContentDecompressor(true));

File: src/main/java/examples/HTTPExamples.java
Patch:
@@ -22,6 +22,7 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.file.AsyncFile;
 import io.vertx.core.http.*;
+import io.vertx.core.net.JksOptions;
 import io.vertx.core.net.ProxyOptions;
 import io.vertx.core.net.ProxyType;
 import io.vertx.core.streams.Pump;
@@ -789,5 +790,4 @@ public void setSSLPerRequest(HttpClient client) {
       System.out.println("Received response with status code " + response.statusCode());
     });
   }
-
 }

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequestImpl.java
Patch:
@@ -370,7 +370,7 @@ public SocketAddress localAddress() {
 
   @Override
   public X509Certificate[] peerCertificateChain() throws SSLPeerUnverifiedException {
-    return conn.getPeerCertificateChain();
+    return conn.peerCertificateChain();
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -904,8 +904,8 @@ boolean isCancelled() {
     });
   }
 
-  void getConnectionForRequest(boolean ssl, int port, String host, Waiter waiter) {
-    connectionManager.getConnectionForRequest(ssl, options.getProtocolVersion(), port, host, waiter);
+  void getConnectionForRequest(String peerHost, boolean ssl, int port, String host, Waiter waiter) {
+    connectionManager.getConnectionForRequest(options.getProtocolVersion(), peerHost, ssl, port, host, waiter);
   }
 
   /**

File: src/main/java/io/vertx/core/http/impl/HttpServerRequestImpl.java
Patch:
@@ -271,7 +271,7 @@ public String absoluteURI() {
 
   @Override
   public X509Certificate[] peerCertificateChain() throws SSLPeerUnverifiedException {
-    return conn.getPeerCertificateChain();
+    return conn.peerCertificateChain();
   }
 
   @Override

File: src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -92,7 +92,7 @@ public void reject() {
 
   @Override
   public X509Certificate[] peerCertificateChain() throws SSLPeerUnverifiedException {
-    return conn.getPeerCertificateChain();
+    return conn.peerCertificateChain();
   }
 
   @Override

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -20,7 +20,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
@@ -217,7 +216,7 @@ protected ChannelInitializer channelInitializer(int port, String host, Consumer<
         @Override
         protected void initChannel(Channel ch) throws Exception {
           SSLHelper sslHelper = new SSLHelper(new HttpClientOptions().setUseAlpn(true).setSsl(true), null, Trust.SERVER_JKS.get());
-          SslHandler sslHandler = sslHelper.setApplicationProtocols(Arrays.asList(HttpVersion.HTTP_2, HttpVersion.HTTP_1_1)).createSslHandler((VertxInternal) vertx, host, port);
+          SslHandler sslHandler = new SslHandler(sslHelper.setApplicationProtocols(Arrays.asList(HttpVersion.HTTP_2, HttpVersion.HTTP_1_1)).createEngine((VertxInternal) vertx, host, port));
           ch.pipeline().addLast(sslHandler);
           ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler("whatever") {
             @Override

File: src/test/java/io/vertx/test/core/SSLHelperTest.java
Patch:
@@ -122,7 +122,7 @@ public void testPreserveEnabledCipherSuitesOrder() throws Exception {
     HttpServerOptionsConverter.toJson(options, json);
     assertEquals(new ArrayList<>(new HttpServerOptions(json).getEnabledCipherSuites()), Arrays.asList(engine.getEnabledCipherSuites()));
     SSLHelper helper = new SSLHelper(options, Cert.SERVER_JKS.get(), null);
-    assertEquals(Arrays.asList(helper.createSslHandler((VertxInternal) vertx).engine().getEnabledCipherSuites()), Arrays.asList(engine.getEnabledCipherSuites()));
+    assertEquals(Arrays.asList(helper.createEngine((VertxInternal) vertx).getEnabledCipherSuites()), Arrays.asList(engine.getEnabledCipherSuites()));
   }
 
   @Test
@@ -141,7 +141,7 @@ public void testPreserveEnabledSecureTransportProtocolOrder() throws Exception {
     HttpServerOptionsConverter.toJson(options, json);
     assertEquals(new ArrayList<>(new HttpServerOptions(json).getEnabledSecureTransportProtocols()), Arrays.asList(protocols));
     SSLHelper helper = new SSLHelper(options, Cert.SERVER_JKS.get(), null);
-    List<String> engineProtocols = Arrays.asList(helper.createSslHandler((VertxInternal) vertx).engine().getEnabledProtocols());
+    List<String> engineProtocols = Arrays.asList(helper.createEngine((VertxInternal) vertx).getEnabledProtocols());
     List<String> expectedProtocols = new ArrayList<>(Arrays.asList(protocols));
     expectedProtocols.retainAll(engineProtocols);
     assertEquals(engineProtocols, expectedProtocols);

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -848,10 +848,10 @@ private void write(ByteBuf buff, boolean end) {
             pending = (CompositeByteBuf) pendingChunks;
           } else {
             pending = Unpooled.compositeBuffer();
-            pending.addComponent(pendingChunks).writerIndex(pendingChunks.writerIndex());
+            pending.addComponent(true, pendingChunks);
             pendingChunks = pending;
           }
-          pending.addComponent(buff).writerIndex(pending.writerIndex() + buff.writerIndex());
+          pending.addComponent(true, buff);
         }
       }
       connect(null);

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -218,7 +218,7 @@ public byte[] getBinary(int pos) {
    * Get the Instant at position {@code pos} in the array.
    * <p>
    * JSON itself has no notion of a temporal types, this extension complies to the RFC-7493, so this method assumes
-   * there is a String value and it contains an ISO 8601 encoded data and time format such as "2017-04-03T10:25:41Z",
+   * there is a String value and it contains an ISO 8601 encoded date and time format such as "2017-04-03T10:25:41Z",
    * which it decodes if found and returns.
    * <p>
    * This method should be used in conjunction with {@link #add(Instant)}

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -218,7 +218,7 @@ public byte[] getBinary(int pos) {
    * Get the Instant at position {@code pos} in the array.
    * <p>
    * JSON itself has no notion of a temporal types, this extension complies to the RFC-7493, so this method assumes
-   * there is a String value and it contains an ISO 8601 encoded data and time format such as "2017-04-03T10:25:41Z",
+   * there is a String value and it contains an ISO 8601 encoded date and time format such as "2017-04-03T10:25:41Z",
    * which it decodes if found and returns.
    * <p>
    * This method should be used in conjunction with {@link #add(Instant)}

File: src/main/java/io/vertx/core/file/FileSystem.java
Patch:
@@ -448,7 +448,7 @@ public interface FileSystem {
   /**
    * Reads the entire file as represented by the path {@code path} as a {@link Buffer}, asynchronously.
    * <p>
-   * Do not user this method to read very large files or you risk running out of available RAM.
+   * Do not use this method to read very large files or you risk running out of available RAM.
    *
    * @param path  path to the file
    * @param handler  the handler that will be called on completion

File: src/main/java/io/vertx/core/file/FileSystem.java
Patch:
@@ -448,7 +448,7 @@ public interface FileSystem {
   /**
    * Reads the entire file as represented by the path {@code path} as a {@link Buffer}, asynchronously.
    * <p>
-   * Do not user this method to read very large files or you risk running out of available RAM.
+   * Do not use this method to read very large files or you risk running out of available RAM.
    *
    * @param path  path to the file
    * @param handler  the handler that will be called on completion

File: src/test/java/io/vertx/test/core/Http2ClientTest.java
Patch:
@@ -1290,7 +1290,7 @@ public void test100Continue() throws Exception {
     server.close();
     server = vertx.createHttpServer(serverOptions.setHandle100ContinueAutomatically(true));
     server.requestHandler(req -> {
-      assertEquals(0, status.getAndIncrement());
+      status.getAndIncrement();
       HttpServerResponse resp = req.response();
       req.bodyHandler(body -> {
         assertEquals(2, status.getAndIncrement());
@@ -1311,7 +1311,7 @@ public void test100Continue() throws Exception {
     req.continueHandler(v -> {
       Context ctx = Vertx.currentContext();
       assertOnIOContext(ctx);
-      assertEquals(1, status.getAndIncrement());
+      status.getAndIncrement();
       req.end(Buffer.buffer("request-body"));
     });
     req.sendHead(version -> {

File: src/test/java/io/vertx/test/core/NamedWorkerPoolTest.java
Patch:
@@ -97,8 +97,8 @@ public void testOrdered() {
           }
         });
       }
+      submitted.countDown();
     });
-    submitted.countDown();
     await();
   }
 

File: src/test/java/io/vertx/test/core/NamedWorkerPoolTest.java
Patch:
@@ -97,8 +97,8 @@ public void testOrdered() {
           }
         });
       }
+      submitted.countDown();
     });
-    submitted.countDown();
     await();
   }
 

File: src/test/java/io/vertx/test/core/Http2ClientTest.java
Patch:
@@ -1290,7 +1290,7 @@ public void test100Continue() throws Exception {
     server.close();
     server = vertx.createHttpServer(serverOptions.setHandle100ContinueAutomatically(true));
     server.requestHandler(req -> {
-      assertEquals(0, status.getAndIncrement());
+      status.getAndIncrement();
       HttpServerResponse resp = req.response();
       req.bodyHandler(body -> {
         assertEquals(2, status.getAndIncrement());
@@ -1311,7 +1311,7 @@ public void test100Continue() throws Exception {
     req.continueHandler(v -> {
       Context ctx = Vertx.currentContext();
       assertOnIOContext(ctx);
-      assertEquals(1, status.getAndIncrement());
+      status.getAndIncrement();
       req.end(Buffer.buffer("request-body"));
     });
     req.sendHead(version -> {

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -618,7 +618,7 @@ public void channelRead(ChannelHandlerContext chctx, Object msg) throws Exceptio
       }
 
       @Override
-      protected void handleMsgReceived(Object msg) {
+      protected void handleMsgReceived(NetSocketImpl conn, Object msg) {
         ByteBuf buf = (ByteBuf) msg;
         conn.handleDataReceived(Buffer.buffer(buf));
       }

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -255,7 +255,7 @@ public void channelRead(ChannelHandlerContext chctx, Object msg) throws Exceptio
       }
 
       @Override
-      protected void handleMsgReceived(Object msg) {
+      protected void handleMsgReceived(NetSocketImpl conn, Object msg) {
         ByteBuf buf = (ByteBuf) msg;
         conn.handleDataReceived(Buffer.buffer(buf));
       }

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -192,7 +192,7 @@ private void connect(int port, String host, Handler<AsyncResult<NetSocket>> conn
       }
       pipeline.addLast("handler", new VertxNetHandler<NetSocketImpl>(ch, socketMap) {
         @Override
-        protected void handleMsgReceived(Object msg) {
+        protected void handleMsgReceived(NetSocketImpl conn, Object msg) {
           ByteBuf buf = (ByteBuf) msg;
           conn.handleDataReceived(Buffer.buffer(buf));
         }

File: src/main/java/io/vertx/core/net/impl/NetServerBase.java
Patch:
@@ -304,7 +304,7 @@ public ServerHandler(Channel ch) {
     }
 
     @Override
-    protected void handleMsgReceived(Object msg) {
+    protected void handleMsgReceived(C conn, Object msg) {
       NetServerBase.this.handleMsgReceived(conn, msg);
     }
 

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -618,7 +618,7 @@ public void channelRead(ChannelHandlerContext chctx, Object msg) throws Exceptio
       }
 
       @Override
-      protected void handleMsgReceived(Object msg) {
+      protected void handleMsgReceived(NetSocketImpl conn, Object msg) {
         ByteBuf buf = (ByteBuf) msg;
         conn.handleDataReceived(Buffer.buffer(buf));
       }

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -255,7 +255,7 @@ public void channelRead(ChannelHandlerContext chctx, Object msg) throws Exceptio
       }
 
       @Override
-      protected void handleMsgReceived(Object msg) {
+      protected void handleMsgReceived(NetSocketImpl conn, Object msg) {
         ByteBuf buf = (ByteBuf) msg;
         conn.handleDataReceived(Buffer.buffer(buf));
       }

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -192,7 +192,7 @@ private void connect(int port, String host, Handler<AsyncResult<NetSocket>> conn
       }
       pipeline.addLast("handler", new VertxNetHandler<NetSocketImpl>(ch, socketMap) {
         @Override
-        protected void handleMsgReceived(Object msg) {
+        protected void handleMsgReceived(NetSocketImpl conn, Object msg) {
           ByteBuf buf = (ByteBuf) msg;
           conn.handleDataReceived(Buffer.buffer(buf));
         }

File: src/main/java/io/vertx/core/net/impl/NetServerBase.java
Patch:
@@ -304,7 +304,7 @@ public ServerHandler(Channel ch) {
     }
 
     @Override
-    protected void handleMsgReceived(Object msg) {
+    protected void handleMsgReceived(C conn, Object msg) {
       NetServerBase.this.handleMsgReceived(conn, msg);
     }
 

File: src/main/java/io/vertx/core/eventbus/impl/HandlerRegistration.java
Patch:
@@ -212,7 +212,7 @@ private void deliver(Handler<Message<T>> theHandler, Message<T> message) {
       theHandler.handle(message);
       metrics.endHandleMessage(metric, null);
     } catch (Exception e) {
-      log.error("Failed to handleMessage", e);
+      log.error("Failed to handleMessage. address: " + message.address(), e);
       metrics.endHandleMessage(metric, e);
       throw e;
     }

File: src/main/java/io/vertx/core/eventbus/impl/HandlerRegistration.java
Patch:
@@ -212,7 +212,7 @@ private void deliver(Handler<Message<T>> theHandler, Message<T> message) {
       theHandler.handle(message);
       metrics.endHandleMessage(metric, null);
     } catch (Exception e) {
-      log.error("Failed to handleMessage", e);
+      log.error("Failed to handleMessage. address: " + message.address(), e);
       metrics.endHandleMessage(metric, e);
       throw e;
     }

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -349,6 +349,7 @@ private synchronized void handleData(Buffer buffer) {
   }
 
   private synchronized void handleEnd() {
+    dataHandler = null;
     if (endHandler != null) {
       checkContext();
       endHandler.handle(null);

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -25,8 +25,6 @@
 import io.vertx.core.spi.metrics.MetricsProvider;
 import io.vertx.core.spi.metrics.PoolMetrics;
 
-import java.util.concurrent.Executor;
-
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
@@ -68,7 +66,7 @@ public synchronized <T> void executeBlocking(Handler<Future<T>> blockingCodeHand
       throw new IllegalStateException("Worker executor closed");
     }
     ContextImpl context = (ContextImpl) vertx.getOrCreateContext();
-    context.executeBlocking(null, blockingCodeHandler, asyncResultHandler, pool.executor(), context.orderedTasks, pool.metrics());
+    context.executeBlocking(null, blockingCodeHandler, asyncResultHandler, pool.executor(), ordered ? context.orderedTasks : null, pool.metrics());
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -25,8 +25,6 @@
 import io.vertx.core.spi.metrics.MetricsProvider;
 import io.vertx.core.spi.metrics.PoolMetrics;
 
-import java.util.concurrent.Executor;
-
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
@@ -68,7 +66,7 @@ public synchronized <T> void executeBlocking(Handler<Future<T>> blockingCodeHand
       throw new IllegalStateException("Worker executor closed");
     }
     ContextImpl context = (ContextImpl) vertx.getOrCreateContext();
-    context.executeBlocking(null, blockingCodeHandler, asyncResultHandler, pool.executor(), context.orderedTasks, pool.metrics());
+    context.executeBlocking(null, blockingCodeHandler, asyncResultHandler, pool.executor(), ordered ? context.orderedTasks : null, pool.metrics());
   }
 
   @Override

File: src/test/java/io/vertx/test/core/Http2Test.java
Patch:
@@ -24,9 +24,7 @@
 import io.vertx.core.http.HttpServerOptions;
 import io.vertx.core.http.HttpServerResponse;
 import io.vertx.core.http.StreamResetException;
-import io.vertx.core.net.NetServer;
 import io.vertx.core.net.OpenSSLEngineOptions;
-import io.vertx.core.net.PemKeyCertOptions;
 import io.vertx.test.core.tls.Cert;
 import org.junit.Test;
 
@@ -257,7 +255,7 @@ public void testClientStreamPausedWhenConnectionIsPaused() throws Exception {
       resumeLatch.complete(null);
     });
     resumeLatch.get(20, TimeUnit.SECONDS);
-    waitUntil(() -> !req2.writeQueueFull());
+    assertWaitUntil(() -> !req2.writeQueueFull());
     req1.end();
     req2.end(buffer);
     await();

File: src/test/java/io/vertx/test/core/HttpMetricsTest.java
Patch:
@@ -118,10 +118,10 @@ private void testHttpMetricsLifecycle(HttpVersion protocol) throws Exception {
     });
     awaitLatch(latch);
     client.close();
-    waitUntil(() -> !serverMetric.get().socket.connected.get());
+    assertWaitUntil(() -> !serverMetric.get().socket.connected.get());
     assertEquals(contentLength, serverMetric.get().socket.bytesRead.get());
     assertEquals(contentLength, serverMetric.get().socket.bytesWritten.get());
-    waitUntil(() -> !clientMetric.get().socket.connected.get());
+    assertWaitUntil(() -> !clientMetric.get().socket.connected.get());
     assertEquals(contentLength, clientMetric.get().socket.bytesRead.get());
     assertEquals(contentLength, clientMetric.get().socket.bytesWritten.get());
   }

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -566,7 +566,8 @@ void applyHttp1xConnectionOptions(ConnQueue queue, ChannelPipeline pipeline, Con
       if (logEnabled) {
         pipeline.addLast("logging", new LoggingHandler());
       }
-      pipeline.addLast("codec", new HttpClientCodec(options.getMaxInitialLineLength(), options.getMaxHeaderSize(), options.getMaxChunkSize(), false, false));
+      pipeline.addLast("codec", new HttpClientCodec(options.getMaxInitialLineLength(), options.getMaxHeaderSize(),
+              options.getMaxChunkSize(), false, false, options.getInitialBufferSizeHttpDecoder()));
       if (options.isTryUseCompression()) {
         pipeline.addLast("inflater", new HttpContentDecompressor(true));
       }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -374,7 +374,7 @@ private void configureHttp1(ChannelPipeline pipeline) {
       pipeline.addLast("flashpolicy", new FlashPolicyHandler());
     }
     pipeline.addLast("httpDecoder", new HttpRequestDecoder(options.getMaxInitialLineLength()
-        , options.getMaxHeaderSize(), options.getMaxChunkSize(), false));
+        , options.getMaxHeaderSize(), options.getMaxChunkSize(), false, options.getInitialBufferSizeHttpDecoder()));
     pipeline.addLast("httpEncoder", new VertxHttpResponseEncoder());
     if (options.isDecompressionSupported()) {
       pipeline.addLast("inflater", new HttpContentDecompressor(true));

File: src/test/java/io/vertx/test/core/MetricsTest.java
Patch:
@@ -1005,6 +1005,7 @@ public void start(Future<Void> done) throws Exception {
     });
 
     await();
+    waitUntilNoFail(() -> count + 1 == metrics.numberOfCompletedTasks());
 
     // The verticle deployment is also executed on the worker thread pool
     assertEquals(count + 1, metrics.numberOfSubmittedTask());

File: src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -182,7 +182,7 @@ protected void kill(int pos) {
     v.executeBlocking(fut -> {
       v.simulateKill();
       fut.complete();
-    }, ar -> {
+    }, false, ar -> {
       assertTrue(ar.succeeded());
     });
 

File: src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -182,7 +182,7 @@ protected void kill(int pos) {
     v.executeBlocking(fut -> {
       v.simulateKill();
       fut.complete();
-    }, ar -> {
+    }, false, ar -> {
       assertTrue(ar.succeeded());
     });
 

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -251,10 +251,8 @@ protected <T> void sendOrPub(SendContextImpl<T> sendContext) {
         log.error("Failed to send message", asyncResult.cause());
       }
     };
-    Context context = Vertx.currentContext();
-    if (context == null || !context.isEventLoopContext()) {
+    if (Vertx.currentContext() == null) {
       // Guarantees the order when there is no current context
-      // Or, when there is a worker context, makes sure message can be sent instantly
       sendNoContext.runOnContext(v -> {
         subs.get(address, resultHandler);
       });

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -251,8 +251,7 @@ protected <T> void sendOrPub(SendContextImpl<T> sendContext) {
         log.error("Failed to send message", asyncResult.cause());
       }
     };
-    Context context = Vertx.currentContext();
-    if (context == null || !context.isEventLoopContext()) {
+    if (Vertx.currentContext() == null) {
       // Guarantees the order when there is no current context
       sendNoContext.runOnContext(v -> {
         subs.get(address, resultHandler);

File: src/main/java/io/vertx/core/impl/WorkerContext.java
Patch:
@@ -31,7 +31,7 @@ public WorkerContext(VertxInternal vertx, WorkerPool internalBlockingPool, Worke
 
   @Override
   public void executeAsync(Handler<Void> task) {
-    workerExec.execute(wrapTask(null, task, true, workerPool.metrics()));
+    orderedTasks.execute(wrapTask(null, task, true, workerPool.metrics()), workerPool.executor());
   }
 
   @Override
@@ -53,7 +53,7 @@ protected void checkCorrectThread() {
   // so we need to execute it on the worker thread
   @Override
   public void executeFromIO(ContextTask task) {
-    workerExec.execute(wrapTask(task, null, true, workerPool.metrics()));
+    orderedTasks.execute(wrapTask(task, null, true, workerPool.metrics()), workerPool.executor());
   }
 
 }

File: src/main/java/io/vertx/core/impl/WorkerExecutorImpl.java
Patch:
@@ -35,13 +35,11 @@ class WorkerExecutorImpl implements Closeable, MetricsProvider, WorkerExecutorIn
   private final Vertx vertx;
   private final WorkerPool pool;
   private boolean closed;
-  private final Executor workerExec;
   private final boolean releaseOnClose;
 
   public WorkerExecutorImpl(Vertx vertx, WorkerPool pool, boolean releaseOnClose) {
     this.vertx = vertx;
     this.pool = pool;
-    this.workerExec = pool.createOrderedExecutor();
     this.releaseOnClose = releaseOnClose;
   }
 
@@ -70,7 +68,7 @@ public synchronized <T> void executeBlocking(Handler<Future<T>> blockingCodeHand
       throw new IllegalStateException("Worker executor closed");
     }
     ContextImpl context = (ContextImpl) vertx.getOrCreateContext();
-    context.executeBlocking(null, blockingCodeHandler, asyncResultHandler, ordered ? workerExec : pool.executor(), pool.metrics());
+    context.executeBlocking(null, blockingCodeHandler, asyncResultHandler, pool.executor(), context.orderedTasks, pool.metrics());
   }
 
   @Override

File: src/main/java/io/vertx/core/WorkerExecutor.java
Patch:
@@ -36,7 +36,7 @@ public interface WorkerExecutor extends Measured {
    * Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
    * <p>
    * When the code is complete the handler {@code resultHandler} will be called with the result on the original context
-   * (e.g. on the original event loop of the caller).
+   * (i.e. on the original event loop of the caller).
    * <p>
    * A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
    * the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}

File: src/main/java/io/vertx/core/impl/WorkerExecutorInternal.java
Patch:
@@ -16,11 +16,13 @@
 
 package io.vertx.core.impl;
 
+import io.vertx.core.Vertx;
 import io.vertx.core.WorkerExecutor;
 
 /**
  * @author Thomas Segismont
  */
 public interface WorkerExecutorInternal extends WorkerExecutor {
-  ContextImpl getContext();
+  // TODO Can we get rid of this?
+  Vertx vertx();
 }

File: src/main/java/io/vertx/core/WorkerExecutor.java
Patch:
@@ -36,7 +36,7 @@ public interface WorkerExecutor extends Measured {
    * Executes the blocking code in the handler {@code blockingCodeHandler} using a thread from the worker pool.
    * <p>
    * When the code is complete the handler {@code resultHandler} will be called with the result on the original context
-   * (e.g. on the original event loop of the caller).
+   * (i.e. on the original event loop of the caller).
    * <p>
    * A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
    * the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}

File: src/main/java/io/vertx/core/impl/WorkerExecutorInternal.java
Patch:
@@ -16,11 +16,13 @@
 
 package io.vertx.core.impl;
 
+import io.vertx.core.Vertx;
 import io.vertx.core.WorkerExecutor;
 
 /**
  * @author Thomas Segismont
  */
 public interface WorkerExecutorInternal extends WorkerExecutor {
-  ContextImpl getContext();
+  // TODO Can we get rid of this?
+  Vertx owner();
 }

File: src/main/java/io/vertx/core/dns/AddressResolverOptions.java
Patch:
@@ -47,7 +47,7 @@ public class AddressResolverOptions {
   public static final int DEFAULT_CACHE_MAX_TIME_TO_LIVE = Integer.MAX_VALUE;
   public static final int DEFAULT_CACHE_NEGATIVE_TIME_TO_LIVE = 0;
   public static final int DEFAULT_QUERY_TIMEOUT = 5000;
-  public static final int DEFAULT_MAX_QUERIES = 3;
+  public static final int DEFAULT_MAX_QUERIES = 4;
   public static final boolean DEFAULT_RD_FLAG = true;
   public static final List<String> DEFAULT_SEACH_DOMAINS = null;
   public static final boolean DEFAULT_ROUND_ROBIN = false;

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -130,7 +130,7 @@ public synchronized void onPushPromiseRead(ChannelHandlerContext ctx, int stream
           MultiMap headersMap = new Http2HeadersAdaptor(headers);
           Http2Stream promisedStream = handler.connection().stream(promisedStreamId);
           int port = remoteAddress().port();
-          HttpClientRequestPushPromise pushReq = new HttpClientRequestPushPromise(this, promisedStream, http2Pool.client, method, rawMethod, uri, host, port, headersMap);
+          HttpClientRequestPushPromise pushReq = new HttpClientRequestPushPromise(this, promisedStream, http2Pool.client, isSsl(), method, rawMethod, uri, host, port, headersMap);
           if (metrics.isEnabled()) {
             pushReq.metric(metrics.responsePushed(queueMetric, metric(), localAddress(), remoteAddress(), pushReq));
           }

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -52,7 +52,6 @@ public class HttpClientRequestImpl extends HttpClientRequestBase implements Http
 
   private final VertxInternal vertx;
   private final int port;
-  private final boolean ssl;
   private Handler<HttpClientResponse> respHandler;
   private Handler<Void> endHandler;
   private boolean chunked;
@@ -80,8 +79,7 @@ public class HttpClientRequestImpl extends HttpClientRequestBase implements Http
 
   HttpClientRequestImpl(HttpClientImpl client, boolean ssl, HttpMethod method, String host, int port,
                         String relativeURI, VertxInternal vertx) {
-    super(client, method, host, port, relativeURI);
-    this.ssl = ssl;
+    super(client, ssl, method, host, port, relativeURI);
     this.chunked = false;
     this.vertx = vertx;
     this.port = port;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -43,13 +43,14 @@ public HttpClientRequestPushPromise(
       Http2ClientConnection conn,
       Http2Stream stream,
       HttpClientImpl client,
+      boolean ssl,
       HttpMethod method,
       String rawMethod,
       String uri,
       String host,
       int port,
       MultiMap headers) throws Http2Exception {
-    super(client, method, host, port, uri);
+    super(client, ssl, method, host, port, uri);
     this.conn = conn;
     this.stream = new Http2ClientConnection.Http2ClientStream(conn, this, stream, false);
     this.rawMethod = rawMethod;

File: src/main/java/io/vertx/core/datagram/DatagramSocket.java
Patch:
@@ -58,14 +58,14 @@ public interface DatagramSocket extends ReadStream<DatagramPacket>, Measured {
   DatagramSocket send(Buffer packet, int port, String host, Handler<AsyncResult<DatagramSocket>> handler);
 
   /**
-   * Returns a {@link io.vertx.core.datagram.PacketWritestream} able to send {@link Buffer} to the
+   * Returns a {@code WriteStream<Buffer>} able to send {@link Buffer} to the
    * {@link io.vertx.core.net.SocketAddress}.
    *
    * @param port the port of the remote peer
    * @param host the host address of the remote peer
    * @return the write stream for sending packets
    */
-  PacketWritestream sender(int port, String host);
+  WriteStream<Buffer> sender(int port, String host);
 
   /**
    * Write the given {@link String} to the {@link io.vertx.core.net.SocketAddress} using UTF8 encoding.

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -29,7 +29,6 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.datagram.DatagramSocket;
 import io.vertx.core.datagram.DatagramSocketOptions;
-import io.vertx.core.datagram.PacketWritestream;
 import io.vertx.core.impl.Arguments;
 import io.vertx.core.impl.ContextImpl;
 import io.vertx.core.impl.VertxInternal;
@@ -40,6 +39,7 @@
 import io.vertx.core.spi.metrics.DatagramSocketMetrics;
 import io.vertx.core.spi.metrics.Metrics;
 import io.vertx.core.spi.metrics.MetricsProvider;
+import io.vertx.core.streams.WriteStream;
 
 import java.net.*;
 import java.util.Objects;
@@ -245,7 +245,7 @@ private void doSend(Buffer packet, InetSocketAddress addr, Handler<AsyncResult<D
   }
 
   @Override
-  public PacketWritestream sender(int port, String host) {
+  public WriteStream<Buffer> sender(int port, String host) {
     Arguments.requireInRange(port, 0, 65535, "port p must be in range 0 <= p <= 65535");
     Objects.requireNonNull(host, "no null host accepted");
     return new PacketWriteStreamImpl(this, port, host);

File: src/main/java/io/vertx/core/streams/package-info.java
Patch:
@@ -121,7 +121,7 @@
  *
  * `WriteStream` is implemented by {@link io.vertx.core.http.HttpClientRequest}, {@link io.vertx.core.http.HttpServerResponse}
  * {@link io.vertx.core.http.WebSocket}, {@link io.vertx.core.net.NetSocket}, {@link io.vertx.core.file.AsyncFile},
- * {@link io.vertx.core.datagram.PacketWritestream} and {@link io.vertx.core.eventbus.MessageProducer}
+ * and {@link io.vertx.core.eventbus.MessageProducer}
  *
  * Functions:
  *

File: src/main/java/io/vertx/core/dns/impl/decoder/StartOfAuthorityRecord.java
Patch:
@@ -13,7 +13,7 @@
  *
  * You may elect to redistribute this code under either of these licenses.
  */
-package io.vertx.core.dns.impl.netty.decoder.record;
+package io.vertx.core.dns.impl.decoder;
 
 /**
  * Represents an SOA (start of authority) record, which defines global

File: src/main/java/io/vertx/core/dns/impl/decoder/package-info.java
Patch:
@@ -17,4 +17,4 @@
 /**
  * Handles the decoding of DNS response packets.
  */
-package io.vertx.core.dns.impl.netty.decoder;
+package io.vertx.core.dns.impl.decoder;

File: src/main/java/io/vertx/core/http/impl/Http1xPool.java
Patch:
@@ -17,7 +17,6 @@
 package io.vertx.core.http.impl;
 
 import io.netty.channel.Channel;
-import io.vertx.core.Context;
 import io.vertx.core.http.HttpClientOptions;
 import io.vertx.core.http.HttpVersion;
 import io.vertx.core.impl.ContextImpl;

File: src/main/java/io/vertx/core/http/impl/Http2ConnectionBase.java
Patch:
@@ -45,7 +45,6 @@
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.net.NetSocket;
 import io.vertx.core.net.impl.ConnectionBase;
-import io.vertx.core.spi.metrics.TCPMetrics;
 
 import java.util.ArrayDeque;
 import java.util.Map;

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponseImpl.java
Patch:
@@ -438,7 +438,7 @@ private void handleEnded(boolean failed) {
         }
       }
       if (closeHandler != null) {
-        closeHandler.handle(null);
+        conn.getContext().runOnContext(closeHandler);
       }
     }
   }

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -48,7 +48,6 @@
 import io.vertx.core.net.impl.NetSocketImpl;
 import io.vertx.core.net.impl.VertxNetHandler;
 import io.vertx.core.spi.metrics.HttpServerMetrics;
-import io.vertx.core.spi.metrics.NetworkMetrics;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -362,7 +361,7 @@ synchronized protected void handleClosed() {
     }
   }
 
-  protected ContextImpl getContext() {
+  public ContextImpl getContext() {
     return super.getContext();
   }
 

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -351,10 +351,10 @@ void handleClosed() {
     synchronized (conn) {
       cleanupHandlers();
       if (endHandler != null) {
-        endHandler.handle(null);
+        conn.getContext().runOnContext(endHandler);
       }
       if (closeHandler != null) {
-        closeHandler.handle(null);
+        conn.getContext().runOnContext(closeHandler);
       }
     }
   }

File: src/main/java/io/vertx/core/net/impl/ConnectionBase.java
Patch:
@@ -24,7 +24,6 @@
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.logging.Logger;
 import io.vertx.core.logging.LoggerFactory;
-import io.vertx.core.net.NetworkOptions;
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.spi.metrics.NetworkMetrics;
 import io.vertx.core.spi.metrics.TCPMetrics;
@@ -166,7 +165,7 @@ protected void checkContext() {
   }
 
 
-  protected ContextImpl getContext() {
+  public ContextImpl getContext() {
     return context;
   }
 
@@ -195,7 +194,7 @@ protected synchronized void handleClosed() {
       ((TCPMetrics) metrics).disconnected(metric(), remoteAddress());
     }
     if (closeHandler != null) {
-      closeHandler.handle(null);
+      vertx.runOnContext(closeHandler);
     }
   }
 

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -1048,7 +1048,7 @@ public void testConnectionClose() throws Exception {
     server.requestHandler(req -> {
       HttpConnection conn = req.connection();
       conn.closeHandler(v -> {
-        assertOnIOContext(ctx);
+        assertSame(ctx, Vertx.currentContext());
         testComplete();
       });
       req.response().putHeader("Content-Type", "text/plain").end();

File: src/main/java/io/vertx/core/http/HttpServerResponse.java
Patch:
@@ -184,8 +184,8 @@ public interface HttpServerResponse extends WriteStream<Buffer> {
   HttpServerResponse putTrailer(CharSequence name, Iterable<CharSequence> value);
 
   /**
-   * Set a close handler for the response. This will be called if the underlying connection closes before the response
-   * is complete.
+   * Set a close handler for the response. This will be called when the response is ended or if the underlying connection
+   * closes before the response ends.
    *
    * @param handler  the handler
    * @return a reference to this, so the API can be used fluently

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -323,7 +323,7 @@ public WebSocketBase textMessageHandler(Handler<String> handler) {
   public S binaryMessageHandler(Handler<Buffer> handler) {
     synchronized (conn) {
       checkClosed();
-      if (frameHandler == null || frameHandler.getClass() == FrameAggregator.class) {
+      if (frameHandler == null || frameHandler.getClass() != FrameAggregator.class) {
         frameHandler = new FrameAggregator();
       }
       ((FrameAggregator) frameHandler).binaryMessageHandler = handler;

File: src/main/java/io/vertx/core/AsyncResult.java
Patch:
@@ -129,7 +129,7 @@ default <V> AsyncResult<V> map(V value) {
    * @param mapper the mapper function
    * @return the mapped async result
    */
-  default AsyncResult<T> orElse(Function<Throwable, T> mapper) {
+  default AsyncResult<T> otherwise(Function<Throwable, T> mapper) {
     return new AsyncResult<T>() {
       @Override
       public T result() {
@@ -169,7 +169,7 @@ public boolean failed() {
    * @param value the value that eventually completes the mapped async result
    * @return the mapped async result
    */
-  default AsyncResult<T> orElse(T value) {
-    return orElse(err -> value);
+  default AsyncResult<T> otherwise(T value) {
+    return otherwise(err -> value);
   }
 }

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -389,7 +389,7 @@ default Future<T> recover(Function<Throwable, Future<T>> mapper) {
    * @param mapper the mapper function
    * @return the mapped future
    */
-  default Future<T> orElse(Function<Throwable, T> mapper) {
+  default Future<T> otherwise(Function<Throwable, T> mapper) {
     Future<T> ret = Future.future();
     setHandler(ar -> {
       if (ar.succeeded()) {
@@ -418,7 +418,7 @@ default Future<T> orElse(Function<Throwable, T> mapper) {
    * @param value the value that eventually completes the mapped future
    * @return the mapped future
    */
-  default Future<T> orElse(T value) {
+  default Future<T> otherwise(T value) {
     Future<T> ret = Future.future();
     setHandler(ar -> {
       if (ar.succeeded()) {

File: src/main/java/io/vertx/core/impl/CloseHooks.java
Patch:
@@ -90,7 +90,7 @@ void run(Handler<AsyncResult<Void>> completionHandler) {
             hook.close(a.completer());
           } catch (Throwable t) {
             log.warn("Failed to run close hooks", t);
-            a.fail(t);
+            a.tryFail(t);
           }
         }
       } else {

File: src/main/java/io/vertx/core/http/WebSocket.java
Patch:
@@ -64,6 +64,9 @@ public interface WebSocket extends WebSocketBase {
   @Override
   WebSocket writeBinaryMessage(Buffer data);
 
+  @Override
+  WebSocket writeTextMessage(String text);
+
   @Override
   WebSocket closeHandler(Handler<Void> handler);
 

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -240,7 +240,8 @@ private void handshakeComplete(ChannelHandlerContext ctx, FullHttpResponse respo
       // Need to set context before constructor is called as writehandler registration needs this
       ContextImpl.setContext(context);
       WebSocketImpl webSocket = new WebSocketImpl(vertx, ClientConnection.this, supportsContinuation,
-                                                  client.getOptions().getMaxWebsocketFrameSize());
+                                                  client.getOptions().getMaxWebsocketFrameSize(),
+                                                  client.getOptions().getMaxWebsocketMessageSize());
       ws = webSocket;
       handshaker.finishHandshake(channel, response);
       context.executeFromIO(() -> {

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -805,7 +805,7 @@ private void handshake(FullHttpRequest request, Channel ch, ChannelHandlerContex
 
           ServerWebSocketImpl ws = new ServerWebSocketImpl(vertx, theURI.toString(), theURI.getPath(),
             theURI.getQuery(), new HeadersAdaptor(request.headers()), wsConn, shake.version() != WebSocketVersion.V00,
-            connectRunnable, options.getMaxWebsocketFrameSize());
+            connectRunnable, options.getMaxWebsocketFrameSize(), options().getMaxWebsocketMessageSize());
           ws.setMetric(metrics.connected(wsConn.metric(), ws));
           wsConn.handleWebsocketConnect(ws);
           if (!ws.isRejected()) {

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -191,7 +191,7 @@ ServerWebSocket upgrade(HttpServerRequest request, HttpRequest nettyReq) {
     
     ws = new ServerWebSocketImpl(vertx, request.uri(), request.path(),
       request.query(), request.headers(), this, handshaker.version() != WebSocketVersion.V00,
-      null, server.options().getMaxWebsocketFrameSize());
+      null, server.options().getMaxWebsocketFrameSize(), server.options().getMaxWebsocketMessageSize());
     ws.setMetric(metrics.upgrade(requestMetric, ws));
     try {
       handshaker.handshake(channel, nettyReq);

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1621,8 +1621,9 @@
  *
  * ==== Writing messages to WebSockets
  *
- * If you wish to write a single binary WebSocket message to the WebSocket you can do this with
- * {@link io.vertx.core.http.WebSocket#writeBinaryMessage(io.vertx.core.buffer.Buffer)}:
+ * If you wish to write a single WebSocket message to the WebSocket you can do this with
+ * {@link io.vertx.core.http.WebSocket#writeBinaryMessage(io.vertx.core.buffer.Buffer)} or
+ * {@link io.vertx.core.http.WebSocket#writeTextMessage(java.lang.String)} :
  *
  * [source,$lang]
  * ----

File: src/main/java/io/vertx/core/impl/CompositeFutureImpl.java
Patch:
@@ -272,11 +272,11 @@ public Handler<AsyncResult<CompositeFuture>> completer() {
   }
 
   @Override
-  public void handle(AsyncResult<CompositeFuture> ar) {
-    if (ar.succeeded()) {
+  public void handle(AsyncResult<CompositeFuture> asyncResult) {
+    if (asyncResult.succeeded()) {
       complete(this);
     } else {
-      fail(ar.cause());
+      fail(asyncResult.cause());
     }
   }
 }

File: src/main/java/io/vertx/core/impl/CloseHooks.java
Patch:
@@ -90,9 +90,7 @@ void run(Handler<AsyncResult<Void>> completionHandler) {
             hook.close(a.completer());
           } catch (Throwable t) {
             log.warn("Failed to run close hooks", t);
-            if (!a.isComplete()) {
-              a.fail(t);
-            }
+            a.fail(t);
           }
         }
       } else {

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -312,7 +312,7 @@ default Handler<AsyncResult<T>> completer() {
    * @param mapper A function which takes the exception of a failure and returns a new future.
    * @return A recovered future
    */
-  default Future<T> recover(Function<? super Throwable, Future<T>> mapper) {
+  default Future<T> recover(Function<Throwable, Future<T>> mapper) {
     Future<T> ret = Future.future();
     setHandler(ar -> {
       if (ar.succeeded()) {

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -312,7 +312,7 @@ default Handler<AsyncResult<T>> completer() {
    * @param mapper A function which takes the exception of a failure and returns a new future.
    * @return A recovered future
    */
-  default Future<T> recover(Function<? super Throwable, Future<T>> mapper) {
+  default Future<T> recover(Function<Throwable, Future<T>> mapper) {
     Future<T> ret = Future.future();
     setHandler(ar -> {
       if (ar.succeeded()) {

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -502,7 +502,7 @@ static void clusteredVertx(VertxOptions options, Handler<AsyncResult<Vertx>> res
    *
    * @param name the name of the worker executor
    * @param poolSize the size of the pool
-   * @param maxExecuteTime the value of max worker execute time, in ms
+   * @param maxExecuteTime the value of max worker execute time, in ns
    * @return the named worker executor
    */
   WorkerExecutor createSharedWorkerExecutor(String name, int poolSize, long maxExecuteTime);

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -332,7 +332,7 @@ private <T> void sendToSubs(ChoosableIterable<ServerID> subs, SendContextImpl<T>
     if (sendContext.message.isSend()) {
       // Choose one
       ServerID sid = subs.choose();
-      if (!sid.equals(serverID)) {  //We don't send to this node
+      if (sid != null && !sid.equals(serverID)) {  //We don't send to this node
         metrics.messageSent(address, false, false, true);
         sendRemote(sid, sendContext.message);
       } else {

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -332,7 +332,7 @@ private <T> void sendToSubs(ChoosableIterable<ServerID> subs, SendContextImpl<T>
     if (sendContext.message.isSend()) {
       // Choose one
       ServerID sid = subs.choose();
-      if (sid != null && !sid.equals(serverID)) {  //We don't send to this node
+      if (!sid.equals(serverID)) {  //We don't send to this node
         metrics.messageSent(address, false, false, true);
         sendRemote(sid, sendContext.message);
       } else {

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -332,7 +332,7 @@ private <T> void sendToSubs(ChoosableIterable<ServerID> subs, SendContextImpl<T>
     if (sendContext.message.isSend()) {
       // Choose one
       ServerID sid = subs.choose();
-      if (!sid.equals(serverID)) {  //We don't send to this node
+      if (sid != null && !sid.equals(serverID)) {  //We don't send to this node
         metrics.messageSent(address, false, false, true);
         sendRemote(sid, sendContext.message);
       } else {

File: src/main/java/io/vertx/core/http/HttpServer.java
Patch:
@@ -24,6 +24,7 @@
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.metrics.Measured;
+import io.vertx.core.streams.ReadStream;
 
 /**
  * An HTTP and WebSockets server.
@@ -46,7 +47,7 @@ public interface HttpServer extends Measured {
    * @return the request stream
    */
   @CacheReturn
-  HttpServerRequestStream requestStream();
+  ReadStream<HttpServerRequest> requestStream();
 
   /**
    * Set the request handler for the server to {@code requestHandler}. As HTTP requests are received by the server,
@@ -78,7 +79,7 @@ public interface HttpServer extends Measured {
    * @return the websocket stream
    */
   @CacheReturn
-  ServerWebSocketStream websocketStream();
+  ReadStream<ServerWebSocket> websocketStream();
 
   /**
    * Set the websocket handler for the server to {@code wsHandler}. If a websocket connect handshake is successful a

File: src/main/java/io/vertx/core/net/NetServer.java
Patch:
@@ -40,7 +40,7 @@ public interface NetServer extends Measured {
    *
    * @return the connect stream
    */
-  NetSocketStream connectStream();
+  ReadStream<NetSocket> connectStream();
 
   /**
    * Supply a connect handler for this server. The server can only have at most one connect handler at any one time.

File: src/main/java/io/vertx/core/streams/package-info.java
Patch:
@@ -99,9 +99,8 @@
  *
  * `ReadStream` is implemented by {@link io.vertx.core.http.HttpClientResponse}, {@link io.vertx.core.datagram.DatagramSocket},
  * {@link io.vertx.core.http.HttpClientRequest}, {@link io.vertx.core.http.HttpServerFileUpload},
- * {@link io.vertx.core.http.HttpServerRequest}, {@link io.vertx.core.http.HttpServerRequestStream},
- * {@link io.vertx.core.eventbus.MessageConsumer}, {@link io.vertx.core.net.NetSocket}, {@link io.vertx.core.net.NetSocketStream},
- * {@link io.vertx.core.http.WebSocket}, {@link io.vertx.core.http.WebSocketStream}, {@link io.vertx.core.TimeoutStream},
+ * {@link io.vertx.core.http.HttpServerRequest}, {@link io.vertx.core.eventbus.MessageConsumer},
+ * {@link io.vertx.core.net.NetSocket}, {@link io.vertx.core.http.WebSocket}, {@link io.vertx.core.TimeoutStream},
  * {@link io.vertx.core.file.AsyncFile}.
  *
  * Functions:

File: src/test/java/io/vertx/test/core/HttpRequestStreamTest.java
Patch:
@@ -23,7 +23,6 @@
 import io.vertx.core.http.HttpServer;
 import io.vertx.core.http.HttpServerOptions;
 import io.vertx.core.http.HttpServerRequest;
-import io.vertx.core.http.HttpServerRequestStream;
 import io.vertx.core.http.HttpServerResponse;
 import io.vertx.core.net.NetClient;
 import io.vertx.core.net.NetClientOptions;
@@ -123,7 +122,7 @@ public void testClosingServerClosesRequestStreamEndHandler() {
   public void testCloseServerAsynchronously() {
     this.server = vertx.createHttpServer(new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT));
     AtomicInteger done = new AtomicInteger();
-    HttpServerRequestStream stream = server.requestStream();
+    ReadStream<HttpServerRequest> stream = server.requestStream();
     stream.handler(req -> {});
     ThreadLocal<Object> stack = new ThreadLocal<>();
     stack.set(true);

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -29,6 +29,7 @@
 import io.vertx.core.logging.LoggerFactory;
 import io.vertx.core.net.*;
 import io.vertx.core.net.impl.SocketAddressImpl;
+import io.vertx.core.streams.ReadStream;
 import io.vertx.test.core.tls.Cert;
 import io.vertx.test.core.tls.Trust;
 import io.vertx.test.netty.TestLoggerFactory;
@@ -1991,7 +1992,7 @@ public void testContexts() throws Exception {
   public void testReadStreamPauseResume() {
     server.close();
     server = vertx.createNetServer(new NetServerOptions().setAcceptBacklog(1).setPort(1234).setHost("localhost"));
-    NetSocketStream socketStream = server.connectStream();
+    ReadStream<NetSocket> socketStream = server.connectStream();
     AtomicBoolean paused = new AtomicBoolean();
     socketStream.handler(so -> {
       assertTrue(!paused.get());
@@ -2031,7 +2032,7 @@ public void testReadStreamPauseResume() {
   public void testNetSocketStreamCallbackIsAsync() {
     this.server = vertx.createNetServer(new NetServerOptions());
     AtomicInteger done = new AtomicInteger();
-    NetSocketStream stream = server.connectStream();
+    ReadStream<NetSocket> stream = server.connectStream();
     stream.handler(req -> {});
     ThreadLocal<Object> stack = new ThreadLocal<>();
     stack.set(true);

File: src/test/java/io/vertx/test/core/WebsocketTest.java
Patch:
@@ -361,7 +361,7 @@ private void testTLS(Cert<?> clientCert, Trust<?> clientTrust,
                        boolean clientSsl,
                        boolean serverSsl,
                        String[] enabledCipherSuites,
-                       Function<HttpClient, WebSocketStream> wsProvider) throws Exception {
+                       Function<HttpClient, ReadStream<WebSocket>> wsProvider) throws Exception {
     HttpClientOptions options = new HttpClientOptions();
     options.setSsl(clientSsl);
     if (clientTrustAll) {
@@ -1100,7 +1100,7 @@ public void testClosingServerClosesWebSocketStreamEndHandler() {
   public void testWebsocketStreamCallbackAsynchronously() {
     this.server = vertx.createHttpServer(new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT));
     AtomicInteger done = new AtomicInteger();
-    ServerWebSocketStream stream = server.websocketStream();
+    ReadStream<ServerWebSocket> stream = server.websocketStream();
     stream.handler(req -> { });
     ThreadLocal<Object> stack = new ThreadLocal<>();
     stack.set(true);
@@ -1400,7 +1400,7 @@ public void testRaceConditionWithWebsocketClientWorker2() throws Exception {
     server.listen(ar -> {
       assertTrue(ar.succeeded());
       workers.get(0).runOnContext(v -> {
-        WebSocketStream webSocketStream = client.websocketStream(HttpTestBase.DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, "/");
+        ReadStream<WebSocket> webSocketStream = client.websocketStream(HttpTestBase.DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, "/");
         webSocketStream.handler(ws -> {
           ws.handler(buf -> {
             assertEquals("hello", buf.toString());

File: src/test/java/io/vertx/test/core/FileSystemTest.java
Patch:
@@ -19,7 +19,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.vertx.core.AsyncResult;
-import io.vertx.core.AsyncResultHandler;
 import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
 import io.vertx.core.buffer.Buffer;

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -347,7 +347,7 @@ void handleResponseEnd(LastHttpContent trailer) {
     if (metrics.isEnabled()) {
       HttpClientRequestBase req = currentResponse.request();
       Object reqMetric = req.metric();
-      if (req.exceptionOccurred) {
+      if (req.exceptionOccurred != null) {
         metrics.requestReset(reqMetric);
       } else {
         metrics.responseEnd(reqMetric, currentResponse);

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -129,7 +129,8 @@ public synchronized void onPushPromiseRead(ChannelHandlerContext ctx, int stream
           String host = headers.authority() != null ? headers.authority().toString() : null;
           MultiMap headersMap = new Http2HeadersAdaptor(headers);
           Http2Stream promisedStream = handler.connection().stream(promisedStreamId);
-          HttpClientRequestPushPromise pushReq = new HttpClientRequestPushPromise(this, promisedStream, http2Pool.client, method, rawMethod, uri, host, headersMap);
+          int port = remoteAddress().port();
+          HttpClientRequestPushPromise pushReq = new HttpClientRequestPushPromise(this, promisedStream, http2Pool.client, method, rawMethod, uri, host, port, headersMap);
           if (metrics.isEnabled()) {
             pushReq.metric(metrics.responsePushed(queueMetric, metric(), localAddress(), remoteAddress(), pushReq));
           }
@@ -171,7 +172,7 @@ public int id() {
     @Override
     void handleEnd(MultiMap trailers) {
       if (conn.metrics.isEnabled()) {
-        if (request.exceptionOccurred) {
+        if (request.exceptionOccurred != null) {
           conn.metrics.requestReset(request.metric());
         } else {
           conn.metrics.responseEnd(request.metric(), response);

File: src/test/java/io/vertx/test/core/Http2TestBase.java
Patch:
@@ -43,6 +43,7 @@ static HttpServerOptions createHttp2ServerOptions(int port, String host) {
   static HttpClientOptions createHttp2ClientOptions() {
     return new HttpClientOptions().
         setUseAlpn(true).
+        setSsl(true).
         setTrustStoreOptions(Trust.SERVER_JKS.get()).
         setProtocolVersion(HttpVersion.HTTP_2);
   }

File: src/main/java/io/vertx/core/http/RequestOptions.java
Patch:
@@ -44,7 +44,7 @@ public class RequestOptions {
   /**
    * SSL enable by default = false
    */
-  public static final String DEFAULT_URI = "/";
+  public static final String DEFAULT_URI = "";
 
   private String host;
   private int port;

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -160,7 +160,7 @@ public void close() {
   }
 
   public void getConnectionForWebsocket(int port, String host, Waiter waiter) {
-    ConnectionKey address = new ConnectionKey(false, port, host);
+    ConnectionKey address = new ConnectionKey(options.isSsl(), port, host);
     ConnQueue connQueue = wsQM.getConnQueue(address, HttpVersion.HTTP_1_1);
     connQueue.getConnection(waiter);
   }

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -636,7 +636,7 @@ boolean isCancelled() {
       // We defer actual connection until the first part of body is written or end is called
       // This gives the user an opportunity to set an exception handler before connecting so
       // they can capture any exceptions on connection
-      client.getConnectionForRequest(port, host, waiter);
+      client.getConnectionForRequest(ssl, port, host, waiter);
       connecting = true;
     }
   }

File: src/main/java/io/vertx/core/http/HttpClientOptions.java
Patch:
@@ -141,7 +141,7 @@ public class HttpClientOptions extends ClientOptionsBase {
   /**
    * Default WebSocket Masked bit is true as depicted by RFC. PerformingUnMasking will be false
    */
-  public static final boolean DEFAULT_FRAME_UNMASKING = false;
+  public static final boolean DEFAULT_SEND_UNMASKED_FRAMES = false;
 
   private boolean verifyHost = true;
   private int maxPoolSize;
@@ -236,7 +236,7 @@ private void init() {
     initialSettings = new Http2Settings();
     alpnVersions = new ArrayList<>(DEFAULT_ALPN_VERSIONS);
     http2ClearTextUpgrade = DEFAULT_HTTP2_CLEAR_TEXT_UPGRADE;
-    sendUnmaskedFrames = DEFAULT_FRAME_UNMASKING;
+    sendUnmaskedFrames = DEFAULT_SEND_UNMASKED_FRAMES;
   }
 
   @Override

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -97,7 +97,7 @@ public class HttpServerOptions extends NetServerOptions {
   /**
    * Default WebSocket Masked bit is true as depicted by RFC. PerformingUnMasking will be false
    */
-  public static final boolean DEFAULT_FRAME_UNMASKING = false;
+  public static final boolean DEFAULT_ACCEPT_UNMASKED_FRAMES = false;
 
   private boolean compressionSupported;
   private int compressionLevel;
@@ -168,7 +168,7 @@ private void init() {
     alpnVersions = new ArrayList<>(DEFAULT_ALPN_VERSIONS);
     http2ConnectionWindowSize = DEFAULT_HTTP2_CONNECTION_WINDOW_SIZE;
     decompressionSupported = DEFAULT_DECOMPRESSION_SUPPORTED;
-    acceptUnmaskedFrames = DEFAULT_FRAME_UNMASKING;
+    acceptUnmaskedFrames = DEFAULT_ACCEPT_UNMASKED_FRAMES;
   }
 
   @Override

File: src/main/java/examples/cli/CLIExamples.java
Patch:
@@ -43,7 +43,7 @@ public void example1() {
             .setDescription("The source")
             .setArgName("source"))
         .addArgument(new Argument()
-            .setIndex(0)
+            .setIndex(1)
             .setDescription("The destination")
             .setArgName("target"));
   }

File: src/main/java/io/vertx/core/cli/annotations/package-info.java
Patch:
@@ -55,7 +55,7 @@
  *
  * For booleans, the boolean values are evaluated to {@code true}: `on`, `yes`, `1`, `true`.
  *
- * If one of your option as an `enum` as type, it computes the set of choices automatically.
+ * If one of your option has an `enum` as type, it computes the set of choices automatically.
  *
  * === Using annotations
  *

File: src/main/generated/io/vertx/core/net/ClientOptionsBaseConverter.java
Patch:
@@ -52,6 +52,9 @@ public static void toJson(ClientOptionsBase obj, JsonObject json) {
     if (obj.getMetricsName() != null) {
       json.put("metricsName", obj.getMetricsName());
     }
+    if (obj.getProxyOptions() != null) {
+      json.put("proxyOptions", obj.getProxyOptions().toJson());
+    }
     json.put("trustAll", obj.isTrustAll());
   }
 }
\ No newline at end of file

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -148,9 +148,10 @@ private synchronized AsyncFile doWrite(Buffer buffer, long position, Handler<Asy
     Handler<AsyncResult<Void>> wrapped = ar -> {
       if (ar.succeeded()) {
         checkContext();
-        checkDrained();
         if (writesOutstanding == 0 && closedDeferred != null) {
           closedDeferred.run();
+        } else {
+          checkDrained();
         }
         if (handler != null) {
           handler.handle(ar);

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -189,6 +189,8 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         if (msg instanceof HttpResponse) {
           HttpResponse resp = (HttpResponse) msg;
           if (resp.getStatus().code() != 101) {
+            handshaker = null;
+            close();
             handleException(new WebSocketHandshakeException("Websocket connection attempt returned HTTP status code " + resp.getStatus().code()));
             return;
           }

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredEventBus.java
Patch:
@@ -217,7 +217,7 @@ protected <T> void sendOrPub(SendContextImpl<T> sendContext) {
         if (serverIDs != null && !serverIDs.isEmpty()) {
           sendToSubs(serverIDs, sendContext);
         } else {
-          metrics.messageSent(address, !sendContext.message.send(), true, false);
+          metrics.messageSent(address, !sendContext.message.isSend(), true, false);
           deliverMessageLocally(sendContext);
         }
       } else {
@@ -309,7 +309,7 @@ public void handle(Buffer buff) {
 
   private <T> void sendToSubs(ChoosableIterable<ServerID> subs, SendContextImpl<T> sendContext) {
     String address = sendContext.message.address();
-    if (sendContext.message.send()) {
+    if (sendContext.message.isSend()) {
       // Choose one
       ServerID sid = subs.choose();
       if (!sid.equals(serverID)) {  //We don't send to this node

File: src/test/java/io/vertx/test/core/LocalEventBusTest.java
Patch:
@@ -947,6 +947,7 @@ public void testDefaultCodecReplyExceptionSubclass() throws Exception {
   protected <T, R> void testSend(T val, R received, Consumer<T> consumer, DeliveryOptions options) {
     eb.<T>consumer(ADDRESS1).handler((Message<T> msg) -> {
       if (consumer == null) {
+        assertTrue(msg.isSend());
         assertEquals(received, msg.body());
         if (options != null && options.getHeaders() != null) {
           assertNotNull(msg.headers());
@@ -992,6 +993,7 @@ protected <T, R> void testReply(T val, R received, Consumer<R> consumer, Deliver
     });
     eb.send(ADDRESS1, str, onSuccess((Message<R> reply) -> {
       if (consumer == null) {
+        assertTrue(reply.isSend());
         assertEquals(received, reply.body());
         if (options != null && options.getHeaders() != null) {
           assertNotNull(reply.headers());
@@ -1015,6 +1017,7 @@ class MyHandler implements Handler<Message<T>> {
       @Override
       public void handle(Message<T> msg) {
         if (consumer == null) {
+          assertFalse(msg.isSend());
           assertEquals(val, msg.body());
         } else {
           consumer.accept(msg.body());

File: src/main/generated/io/vertx/core/http/Http2SettingsConverter.java
Patch:
@@ -40,7 +40,7 @@ public static void fromJson(JsonObject json, Http2Settings obj) {
       obj.setMaxFrameSize(((Number)json.getValue("maxFrameSize")).intValue());
     }
     if (json.getValue("maxHeaderListSize") instanceof Number) {
-      obj.setMaxHeaderListSize(((Number)json.getValue("maxHeaderListSize")).intValue());
+      obj.setMaxHeaderListSize(((Number)json.getValue("maxHeaderListSize")).longValue());
     }
     if (json.getValue("pushEnabled") instanceof Boolean) {
       obj.setPushEnabled((Boolean)json.getValue("pushEnabled"));

File: src/test/java/io/vertx/test/core/TestUtils.java
Patch:
@@ -211,12 +211,12 @@ public static String randomAlphaString(int length) {
    * @return the random settings
    */
   public static Http2Settings randomHttp2Settings() {
-    int headerTableSize = 10 + randomPositiveInt() % (Http2CodecUtil.MAX_HEADER_TABLE_SIZE - 10);
+    long headerTableSize = 10 + randomPositiveInt() % (Http2CodecUtil.MAX_HEADER_TABLE_SIZE - 10);
     boolean enablePush = randomBoolean();
-    long maxConcurrentStreams = randomPositiveLong() % (Http2CodecUtil.MAX_CONCURRENT_STREAMS - 10);
+    long maxConcurrentStreams = 10 + randomPositiveLong() % (Http2CodecUtil.MAX_CONCURRENT_STREAMS - 10);
     int initialWindowSize = 10 + randomPositiveInt() % (Http2CodecUtil.MAX_INITIAL_WINDOW_SIZE - 10);
     int maxFrameSize = Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND + randomPositiveInt() % (Http2CodecUtil.MAX_FRAME_SIZE_UPPER_BOUND - Http2CodecUtil.MAX_FRAME_SIZE_LOWER_BOUND);
-    int maxHeaderListSize = 10 + randomPositiveInt() % (int) (Http2CodecUtil.MAX_HEADER_LIST_SIZE - 10);
+    long maxHeaderListSize = 10 + randomPositiveLong() % (Http2CodecUtil.MAX_HEADER_LIST_SIZE - 10);
     Http2Settings settings = new Http2Settings();
     settings.setHeaderTableSize(headerTableSize);
     settings.setPushEnabled(enablePush);

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -532,7 +532,7 @@ void applyHttp1xConnectionOptions(ConnQueue queue, ChannelPipeline pipeline, Con
       if (logEnabled) {
         pipeline.addLast("logging", new LoggingHandler());
       }
-      pipeline.addLast("codec", new HttpClientCodec(4096, 8192, options.getMaxChunkSize(), false, false));
+      pipeline.addLast("codec", new HttpClientCodec(options.getMaxInitialLineLength(), options.getMaxHeaderSize(), options.getMaxChunkSize(), false, false));
       if (options.isTryUseCompression()) {
         pipeline.addLast("inflater", new HttpContentDecompressor(true));
       }

File: src/main/java/io/vertx/core/net/package-info.java
Patch:
@@ -325,7 +325,7 @@
  *
  * [source,java]
  * ----
- * // Force logging to SLF4J
+ * // Force logging to Log4j
  * InternalLoggerFactory.setDefaultFactory(Log4JLoggerFactory.INSTANCE);
  * ----
  *

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -45,9 +45,9 @@ public class HttpServerOptions extends NetServerOptions {
   public static final boolean DEFAULT_COMPRESSION_SUPPORTED = false;
   
   /**
-   * Default gzip/deflate compression level = 1, fastest algorithm
+   * Default gzip/deflate compression level = 6 (Netty legacy)
    */
-  public static final int DEFAULT_COMPRESSION_LEVEL = 1;
+  public static final int DEFAULT_COMPRESSION_LEVEL = 6;
 
   /**
    * Default max websocket framesize = 65536
@@ -374,7 +374,7 @@ public int getCompressionLevel() {
    * when compression support is turned on (@see setCompressionSupported) and the client advertises
    * to support deflate/gizip compression in the Accept-Encoding header
    * 
-   * default value is : 1
+   * default value is : 6 (Netty legacy)
    * 
    * The compression level determines how much the data is compressed on a scale from 1 to 9,
    * where '9' is trying to achieve the maximum compression ratio while '1' instead is giving

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandlerBuilder.java
Patch:
@@ -72,7 +72,7 @@ VertxHttp2ConnectionHandlerBuilder<C> useCompression(boolean useCompression) {
    * (for data sent to client) when compression support is turned on (@see useCompression) and 
    * the client advertises to support deflate/gizip compression in the Accept-Encoding header
    * 
-   * default value is : 1
+   * default value is : 6 (Netty legacy)
    * 
    * While one can think that best value is always the maximum compression ratio, 
    * there's a trade-off to consider: the most compressed level requires the most computatinal work to compress/decompress, 

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -688,7 +688,7 @@
  * at every request body generation ) and in the same way it affects client(s) while decoding (inflating) received responses, operation that becomes more CPU-intensive 
  * the more the level increases.
  * 
- * By default - if compression is enabled via {@link io.vertx.core.http.HttpServerOptions#setCompressionSupported} - Vert.x will use '1' as compression level,
+ * By default - if compression is enabled via {@link io.vertx.core.http.HttpServerOptions#setCompressionSupported} - Vert.x will use '6' as compression level,
  * but the parameter can be configured to address any case with {@link io.vertx.core.http.HttpServerOptions#setCompressionLevel}.
  *
  * === Creating an HTTP client

File: src/main/java/io/vertx/core/net/package-info.java
Patch:
@@ -325,7 +325,7 @@
  *
  * [source,java]
  * ----
- * // Force logging to SLF4J
+ * // Force logging to Log4j
  * InternalLoggerFactory.setDefaultFactory(Log4JLoggerFactory.INSTANCE);
  * ----
  *

File: src/main/java/io/vertx/core/DeploymentOptions.java
Patch:
@@ -337,7 +337,7 @@ public DeploymentOptions setWorkerPoolSize(int workerPoolSize) {
    * This can be used to detect where the user is blocking a worker thread for too long. Although worker threads
    * can be blocked longer than event loop threads, they shouldn't be blocked for long periods of time.
    *
-   * @return The value of max worker execute time, in ms.
+   * @return The value of max worker execute time, in ns.
    */
   public long getMaxWorkerExecuteTime() {
     return maxWorkerExecuteTime;
@@ -346,7 +346,7 @@ public long getMaxWorkerExecuteTime() {
   /**
    * Sets the value of max worker execute time, in ns.
    *
-   * @param maxWorkerExecuteTime the value of max worker execute time, in ms.
+   * @param maxWorkerExecuteTime the value of max worker execute time, in ns.
    * @return a reference to this, so the API can be used fluently
    */
   public DeploymentOptions setMaxWorkerExecuteTime(long maxWorkerExecuteTime) {

File: src/main/java/io/vertx/core/DeploymentOptions.java
Patch:
@@ -337,7 +337,7 @@ public DeploymentOptions setWorkerPoolSize(int workerPoolSize) {
    * This can be used to detect where the user is blocking a worker thread for too long. Although worker threads
    * can be blocked longer than event loop threads, they shouldn't be blocked for long periods of time.
    *
-   * @return The value of max worker execute time, in ms.
+   * @return The value of max worker execute time, in ns.
    */
   public long getMaxWorkerExecuteTime() {
     return maxWorkerExecuteTime;
@@ -346,7 +346,7 @@ public long getMaxWorkerExecuteTime() {
   /**
    * Sets the value of max worker execute time, in ns.
    *
-   * @param maxWorkerExecuteTime the value of max worker execute time, in ms.
+   * @param maxWorkerExecuteTime the value of max worker execute time, in ns.
    * @return a reference to this, so the API can be used fluently
    */
   public DeploymentOptions setMaxWorkerExecuteTime(long maxWorkerExecuteTime) {

File: src/main/java/io/vertx/core/eventbus/EventBusOptions.java
Patch:
@@ -204,7 +204,7 @@ public EventBusOptions setAcceptBacklog(int acceptBacklog) {
   }
 
   /**
-   * @return the host, which can be configured from the {@link VertxOptions#getClusterHost()}, or using
+   * @return the host, which can be configured from the {@link VertxOptions#setClusterHost(String)}, or using
    * the {@code --cluster-host} command line option.
    * @see NetServerOptions#getHost()
    */
@@ -225,7 +225,7 @@ public EventBusOptions setHost(String host) {
   }
 
   /**
-   * @return the post, which can be configured from the {@link VertxOptions#getClusterPort()} ()}, or
+   * @return the port, which can be configured from the {@link VertxOptions#setClusterPort(int)}, or
    * using the {@code --cluster-port} command line option.
    * @see NetServerOptions#getPort()
    */

File: src/test/java/io/vertx/test/core/HATest.java
Patch:
@@ -424,7 +424,7 @@ protected void kill(int pos) {
       } catch (Exception e) {
         fut.fail(e);
       }
-    }, ar -> {
+    }, false, ar -> {
       if (!ar.succeeded()) {
         fail(ar.cause());
       }

File: src/test/java/io/vertx/test/core/HATest.java
Patch:
@@ -424,7 +424,7 @@ protected void kill(int pos) {
       } catch (Exception e) {
         fut.fail(e);
       }
-    }, ar -> {
+    }, false, ar -> {
       if (!ar.succeeded()) {
         fail(ar.cause());
       }

File: src/test/java/io/vertx/test/core/HttpTLSTest.java
Patch:
@@ -245,7 +245,7 @@ public void testTLSClientRevokedServerCert() throws Exception {
   @Test
   // Client specifies cert that the server does not trust via a revoked certificate of the CA
   public void testTLSRevokedClientCertServer() throws Exception {
-    testTLS(Cert.CLIENT_PEM_ROOT_CA, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.CLIENT_PEM_ROOT_CA).requiresClientAuth().clientUsesCrl().fail();
+    testTLS(Cert.CLIENT_PEM_ROOT_CA, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.CLIENT_PEM_ROOT_CA).requiresClientAuth().serverUsesCrl().fail();
   }
 
   @Test
@@ -569,7 +569,7 @@ void run(boolean shouldPass) {
             response.bodyHandler(data -> assertEquals("bar", data.toString()));
             testComplete();
           } else {
-            fail();
+            HttpTLSTest.this.fail("Should not get a response");
           }
         });
         req.exceptionHandler(t -> {
@@ -783,7 +783,7 @@ public void testHttpsProxy() throws Exception {
   // Check that proxy auth fails if it is missing
   public void testHttpsProxyAuthFail() throws Exception {
     startProxy("username", ProxyType.HTTP);
-    testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).useProxy().useProxyAuth().fail();
+    testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).useProxy().fail();
   }
 
   @Test

File: src/test/java/io/vertx/test/core/HttpTLSTest.java
Patch:
@@ -245,7 +245,7 @@ public void testTLSClientRevokedServerCert() throws Exception {
   @Test
   // Client specifies cert that the server does not trust via a revoked certificate of the CA
   public void testTLSRevokedClientCertServer() throws Exception {
-    testTLS(Cert.CLIENT_PEM_ROOT_CA, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.CLIENT_PEM_ROOT_CA).requiresClientAuth().clientUsesCrl().fail();
+    testTLS(Cert.CLIENT_PEM_ROOT_CA, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.CLIENT_PEM_ROOT_CA).requiresClientAuth().serverUsesCrl().fail();
   }
 
   @Test
@@ -569,7 +569,7 @@ void run(boolean shouldPass) {
             response.bodyHandler(data -> assertEquals("bar", data.toString()));
             testComplete();
           } else {
-            fail();
+            HttpTLSTest.this.fail("Should not get a response");
           }
         });
         req.exceptionHandler(t -> {
@@ -783,7 +783,7 @@ public void testHttpsProxy() throws Exception {
   // Check that proxy auth fails if it is missing
   public void testHttpsProxyAuthFail() throws Exception {
     startProxy("username", ProxyType.HTTP);
-    testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).useProxy().useProxyAuth().fail();
+    testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).useProxy().fail();
   }
 
   @Test

File: src/main/java/io/vertx/core/eventbus/EventBusOptions.java
Patch:
@@ -204,7 +204,7 @@ public EventBusOptions setAcceptBacklog(int acceptBacklog) {
   }
 
   /**
-   * @return the host, which can be configured from the {@link VertxOptions#getClusterHost()}, or using
+   * @return the host, which can be configured from the {@link VertxOptions#setClusterHost(String)}, or using
    * the {@code --cluster-host} command line option.
    * @see NetServerOptions#getHost()
    */
@@ -225,7 +225,7 @@ public EventBusOptions setHost(String host) {
   }
 
   /**
-   * @return the post, which can be configured from the {@link VertxOptions#getClusterPort()} ()}, or
+   * @return the port, which can be configured from the {@link VertxOptions#setClusterPort(int)}, or
    * using the {@code --cluster-port} command line option.
    * @see NetServerOptions#getPort()
    */

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1363,7 +1363,7 @@
  *
  * [source]
  * ----
- * vertx run my-verticle.js -ha -ha-group my-group
+ * vertx run my-verticle.js -ha -hagroup my-group
  * ----
  *
  * Let's look at an example:

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1363,7 +1363,7 @@
  *
  * [source]
  * ----
- * vertx run my-verticle.js -ha -ha-group my-group
+ * vertx run my-verticle.js -ha -hagroup my-group
  * ----
  *
  * Let's look at an example:

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -659,7 +659,7 @@ public Deployment getDeployment(String deploymentID) {
   @Override
   public synchronized void failoverCompleteHandler(FailoverCompleteHandler failoverCompleteHandler) {
     if (haManager() != null) {
-      haManager.setFailoverCompleteHandler(failoverCompleteHandler);
+      haManager().setFailoverCompleteHandler(failoverCompleteHandler);
     }
   }
 

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -659,7 +659,7 @@ public Deployment getDeployment(String deploymentID) {
   @Override
   public synchronized void failoverCompleteHandler(FailoverCompleteHandler failoverCompleteHandler) {
     if (haManager() != null) {
-      haManager.setFailoverCompleteHandler(failoverCompleteHandler);
+      haManager().setFailoverCompleteHandler(failoverCompleteHandler);
     }
   }
 

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -400,10 +400,10 @@
  *
  * 1. a file is created (`fut1`)
  * 2. something is written in the file (`fut2`)
- * 3. the file is moved (`fut3`)
+ * 3. the file is moved (`startFuture`)
  *
- * When these 3 steps are successful, the final future (`startFuture`) is completed with a success. However, if one
- * of the steps fails, the final future is completed with a failure.
+ * When these 3 steps are successful, the final future (`startFuture`) is succeeded. However, if one
+ * of the steps fails, the final future is failed.
  *
  * This example uses:
  *

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -103,9 +103,10 @@ public HttpClientRequest connectionHandler(@Nullable Handler<HttpConnection> han
   }
 
   @Override
-  public void reset(long code) {
+  public boolean reset(long code) {
     synchronized (conn) {
       stream.reset(code);
+      return true;
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -499,6 +499,9 @@ public void upgradeTo(ChannelHandlerContext ctx, FullHttpResponse upgradeRespons
     }
 
     void applyConnectionOptions(HttpClientOptions options, Bootstrap bootstrap) {
+      if (options.getLocalAddress() != null) {
+        bootstrap.localAddress(options.getLocalAddress(), 0);
+      }
       bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());
       if (options.getSendBufferSize() != -1) {
         bootstrap.option(ChannelOption.SO_SNDBUF, options.getSendBufferSize());

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -129,6 +129,9 @@ private void checkClosed() {
   }
 
   private void applyConnectionOptions(Bootstrap bootstrap) {
+    if (options.getLocalAddress() != null) {
+      bootstrap.localAddress(options.getLocalAddress(), 0);
+    }
     bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());
     if (options.getSendBufferSize() != -1) {
       bootstrap.option(ChannelOption.SO_SNDBUF, options.getSendBufferSize());

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -103,9 +103,10 @@ public HttpClientRequest connectionHandler(@Nullable Handler<HttpConnection> han
   }
 
   @Override
-  public void reset(long code) {
+  public boolean reset(long code) {
     synchronized (conn) {
       stream.reset(code);
+      return true;
     }
   }
 

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -499,6 +499,9 @@ public void upgradeTo(ChannelHandlerContext ctx, FullHttpResponse upgradeRespons
     }
 
     void applyConnectionOptions(HttpClientOptions options, Bootstrap bootstrap) {
+      if (options.getLocalAddress() != null) {
+        bootstrap.localAddress(options.getLocalAddress(), 0);
+      }
       bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());
       if (options.getSendBufferSize() != -1) {
         bootstrap.option(ChannelOption.SO_SNDBUF, options.getSendBufferSize());

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -129,6 +129,9 @@ private void checkClosed() {
   }
 
   private void applyConnectionOptions(Bootstrap bootstrap) {
+    if (options.getLocalAddress() != null) {
+      bootstrap.localAddress(options.getLocalAddress(), 0);
+    }
     bootstrap.option(ChannelOption.TCP_NODELAY, options.isTcpNoDelay());
     if (options.getSendBufferSize() != -1) {
       bootstrap.option(ChannelOption.SO_SNDBUF, options.getSendBufferSize());

File: src/main/java/io/vertx/core/logging/Log4j2LogDelegate.java
Patch:
@@ -142,7 +142,7 @@ public void trace(final Object message, final Throwable t) {
 
   @Override
   public void trace(Object message, Throwable t, Object... params) {
-    log(Level.INFO, message.toString(), t, params);
+    log(Level.TRACE, message.toString(), t, params);
   }
 
   private void log(Level level, Object message) {

File: src/main/java/io/vertx/core/impl/FileResolver.java
Patch:
@@ -204,8 +204,8 @@ private synchronized File unpackFromJarURL(URL url, String fileName, ClassLoader
       while (entries.hasMoreElements()) {
         ZipEntry entry = entries.nextElement();
         String name = entry.getName();
-        if (name.startsWith(prefix + fileName)) {
-          File file = new File(cacheDir, name.substring(prefix.length()));
+        if (name.startsWith(prefix.isEmpty() ? fileName : prefix + fileName)) {
+          File file = new File(cacheDir, prefix.isEmpty() ? name : name.substring(prefix.length()));
           if (name.endsWith("/")) {
             // Directory
             file.mkdirs();

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -337,7 +337,9 @@ protected <T> Handler<Message<T>> convertHandler(Handler<AsyncResult<Message<T>>
 
   protected void callCompletionHandlerAsync(Handler<AsyncResult<Void>> completionHandler) {
     if (completionHandler != null) {
-      vertx.runOnContext(v -> completionHandler.handle(Future.succeededFuture()));
+      vertx.runOnContext(v -> {
+        completionHandler.handle(Future.succeededFuture());
+      });
     }
   }
 
@@ -540,7 +542,6 @@ public int hashCode() {
     // Called by context on undeploy
     public void close(Handler<AsyncResult<Void>> completionHandler) {
       handler.unregister(completionHandler);
-      completionHandler.handle(Future.succeededFuture());
     }
 
   }

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -765,10 +765,10 @@
  *
  * Keep in mind that the timer will fire on a periodic basis. If your periodic treatment takes a long amount of time to proceed,
  * your timer events could run continuously or even worse : stack up.
- * 
+ *
  * In this case, you should consider using {@link io.vertx.core.Vertx#setTimer} instead. Once your treatment has
  * finished, you can set the next timer.
- * 
+ *
  * [source,$lang]
  * ----
  * {@link examples.CoreExamples#example16}
@@ -1019,7 +1019,7 @@
  *
  * [source]
  * ----
- * vertx -ha
+ * vertx bare
  * ----
  *
  * Depending on your cluster configuration, you may have to append the `cluster-host` and `cluster-port` parameters.

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -765,10 +765,10 @@
  *
  * Keep in mind that the timer will fire on a periodic basis. If your periodic treatment takes a long amount of time to proceed,
  * your timer events could run continuously or even worse : stack up.
- * 
+ *
  * In this case, you should consider using {@link io.vertx.core.Vertx#setTimer} instead. Once your treatment has
  * finished, you can set the next timer.
- * 
+ *
  * [source,$lang]
  * ----
  * {@link examples.CoreExamples#example16}
@@ -1019,7 +1019,7 @@
  *
  * [source]
  * ----
- * vertx -ha
+ * vertx bare
  * ----
  *
  * Depending on your cluster configuration, you may have to append the `cluster-host` and `cluster-port` parameters.

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -2222,8 +2222,8 @@ public void testHostVerificationHttpsNotMatching() {
     await();
   }
 
-  // TODO: this test probably doesn't make sense since it sets HostnameVerification
-  // but also trustAll, which turns off the whole ssl cert checking
+  // this test sets HostnameVerification but also trustAll, it fails if hostname is
+  // incorrect but does not verify the certificate validity
 
   @Test
   public void testHostVerificationHttpsMatching() {

File: src/main/java/io/vertx/core/net/impl/KeyStoreHelper.java
Patch:
@@ -236,7 +236,7 @@ public KeyStore loadStore(VertxInternal vertx) throws Exception {
       Iterable<Buffer> iterable = certValues::iterator;
       for (Buffer certValue : iterable) {
         for (Certificate cert : loadCerts(certValue)) {
-          keyStore.setCertificateEntry("cert-" + count, cert);
+          keyStore.setCertificateEntry("cert-" + count++, cert);
         }
       }
       return keyStore;

File: src/test/java/io/vertx/test/core/tls/Cert.java
Patch:
@@ -25,6 +25,7 @@ public interface Cert<K extends KeyCertOptions> extends Supplier<K> {
   Cert<PemKeyCertOptions> CLIENT_PEM_ROOT_CA = () -> new PemKeyCertOptions().setKeyPath("tls/client-key.pem").setCertPath("tls/client-cert-root-ca.pem");
   Cert<PemKeyCertOptions> SERVER_PEM_INT_CA = () -> new PemKeyCertOptions().setKeyPath("tls/server-key.pem").setCertPath("tls/server-cert-int-ca.pem");
   Cert<PemKeyCertOptions> SERVER_PEM_CA_CHAIN = () -> new PemKeyCertOptions().setKeyPath("tls/server-key.pem").setCertPath("tls/server-cert-ca-chain.pem");
+  Cert<PemKeyCertOptions> SERVER_PEM_OTHER_CA = () -> new PemKeyCertOptions().setKeyPath("tls/server-key.pem").setCertPath("tls/server-cert-other-ca.pem");
   Cert<JksOptions> SERVER_MIM = () -> new JksOptions().setPath("tls/mim-server-keystore.jks").setPassword("wibble");
 
 }

File: src/test/java/io/vertx/test/core/tls/Trust.java
Patch:
@@ -23,5 +23,6 @@ public interface Trust<T extends TrustOptions> extends Supplier<T> {
   Trust<PfxOptions> SERVER_PKCS12_ROOT_CA = () -> new PfxOptions().setPath("tls/client-truststore-root-ca.p12").setPassword("wibble");
   Trust<PemTrustOptions> SERVER_PEM_ROOT_CA = () -> new PemTrustOptions().addCertPath("tls/root-ca/ca-cert.pem");
   Trust<PemTrustOptions> CLIENT_PEM_ROOT_CA = () -> new PemTrustOptions().addCertPath("tls/root-ca/ca-cert.pem");
+  Trust<PemTrustOptions> SERVER_PEM_ROOT_CA_AND_OTHER_CA = () -> new PemTrustOptions().addCertPath("tls/root-ca/ca-cert.pem").addCertPath("tls/other-ca/ca-cert.pem");
 
 }

File: src/main/java/io/vertx/core/impl/HAManager.java
Patch:
@@ -281,7 +281,9 @@ private synchronized void nodeLeft(String leftNodeID) {
 
       for (Map.Entry<String, String> entry: clusterMap.entrySet()) {
         if (!leftNodeID.equals(entry.getKey()) && !nodes.contains(entry.getKey())) {
-          checkFailover(entry.getKey(), new JsonObject(entry.getValue()));
+          JsonObject haInfo = new JsonObject(entry.getValue());
+          checkRemoveSubs(entry.getKey(), haInfo);
+          checkFailover(entry.getKey(), haInfo);
         }
       }
     }

File: src/main/java/io/vertx/core/impl/HAManager.java
Patch:
@@ -281,7 +281,9 @@ private synchronized void nodeLeft(String leftNodeID) {
 
       for (Map.Entry<String, String> entry: clusterMap.entrySet()) {
         if (!leftNodeID.equals(entry.getKey()) && !nodes.contains(entry.getKey())) {
-          checkFailover(entry.getKey(), new JsonObject(entry.getValue()));
+          JsonObject haInfo = new JsonObject(entry.getValue());
+          checkRemoveSubs(entry.getKey(), haInfo);
+          checkFailover(entry.getKey(), haInfo);
         }
       }
     }

File: src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -306,6 +306,7 @@ synchronized void handleDataReceived(Buffer data) {
     }
     if (pendingData != null) {
       data = pendingData.appendBuffer(data);
+      pendingData = null;
     }
     reportBytesRead(data.length());
     if (dataHandler != null) {

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -210,7 +210,7 @@ public synchronized HttpServer listen(int port, String host, Handler<AsyncResult
       this.actualPort = port; // Will be updated on bind for a wildcard port
       id = new ServerID(port, host);
       HttpServerImpl shared = vertx.sharedHttpServers().get(id);
-      if (shared == null) {
+      if (shared == null || port == 0) {
         serverChannelGroup = new DefaultChannelGroup("vertx-acceptor-channels", GlobalEventExecutor.INSTANCE);
         ServerBootstrap bootstrap = new ServerBootstrap();
         bootstrap.group(vertx.getAcceptorEventLoopGroup(), availableWorkers);

File: src/main/java/io/vertx/core/impl/WorkerPool.java
Patch:
@@ -30,7 +30,7 @@ class WorkerPool {
   private final ExecutorService pool;
   private final PoolMetrics metrics;
 
-  public WorkerPool(ExecutorService pool, PoolMetrics metrics) {
+  WorkerPool(ExecutorService pool, PoolMetrics metrics) {
     this.orderedFact = new OrderedExecutorFactory(pool);
     this.pool = pool;
     this.metrics = metrics;

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -271,11 +271,12 @@ <T> void executeBlocking(Action<T> action, Handler<Future<T>> blockingCodeHandle
           runOnContext(v -> res.setHandler(resultHandler));
         }
       });
-    } catch (RejectedExecutionException ignore) {
+    } catch (RejectedExecutionException e) {
       // Pool is already shut down
       if (metrics != null) {
         metrics.rejected(queueMetric);
       }
+      throw e;
     }
   }
 

File: src/main/java/io/vertx/core/file/impl/FileSystemImpl.java
Patch:
@@ -25,9 +25,9 @@
 import io.vertx.core.file.FileSystemException;
 import io.vertx.core.file.FileSystemProps;
 import io.vertx.core.file.OpenOptions;
+import io.vertx.core.impl.Action;
 import io.vertx.core.impl.ContextImpl;
 import io.vertx.core.impl.VertxInternal;
-import io.vertx.core.impl.Action;
 
 import java.io.File;
 import java.io.FilenameFilter;
@@ -733,8 +733,8 @@ private BlockingAction<AsyncFile> openInternal(String p, OpenOptions options, Ha
     Objects.requireNonNull(p);
     Objects.requireNonNull(options);
     return new BlockingAction<AsyncFile>(handler) {
-      String path = vertx.resolveFile(p).getAbsolutePath();
       public AsyncFile perform() {
+        String path = vertx.resolveFile(p).getAbsolutePath();
         return doOpen(path, options, context);
       }
     };

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -36,6 +36,7 @@
 import io.vertx.core.net.NetworkOptions;
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.ConnectionBase;
+import io.vertx.core.net.impl.PartialPooledByteBufAllocator;
 import io.vertx.core.net.impl.SocketAddressImpl;
 import io.vertx.core.spi.metrics.DatagramSocketMetrics;
 import io.vertx.core.spi.metrics.Metrics;
@@ -66,6 +67,7 @@ public DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
     }
     channel.pipeline().addLast("handler", new DatagramServerHandler(this));
     channel().config().setMaxMessagesPerRead(1);
+    channel().config().setAllocator(PartialPooledByteBufAllocator.INSTANCE);
   }
 
   @Override

File: src/main/java/io/vertx/core/file/impl/FileSystemImpl.java
Patch:
@@ -25,9 +25,9 @@
 import io.vertx.core.file.FileSystemException;
 import io.vertx.core.file.FileSystemProps;
 import io.vertx.core.file.OpenOptions;
+import io.vertx.core.impl.Action;
 import io.vertx.core.impl.ContextImpl;
 import io.vertx.core.impl.VertxInternal;
-import io.vertx.core.impl.Action;
 
 import java.io.File;
 import java.io.FilenameFilter;
@@ -733,8 +733,8 @@ private BlockingAction<AsyncFile> openInternal(String p, OpenOptions options, Ha
     Objects.requireNonNull(p);
     Objects.requireNonNull(options);
     return new BlockingAction<AsyncFile>(handler) {
-      String path = vertx.resolveFile(p).getAbsolutePath();
       public AsyncFile perform() {
+        String path = vertx.resolveFile(p).getAbsolutePath();
         return doOpen(path, options, context);
       }
     };

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -45,6 +45,7 @@
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.logging.Logger;
 import io.vertx.core.logging.LoggerFactory;
+import io.vertx.core.net.ProxyType;
 import io.vertx.core.net.impl.ChannelProvider;
 import io.vertx.core.net.impl.PartialPooledByteBufAllocator;
 import io.vertx.core.net.impl.ProxyChannelProvider;
@@ -406,7 +407,8 @@ protected void connect(
       applyConnectionOptions(options, bootstrap);
 
       ChannelProvider channelProvider;
-      if (!options.isSsl() || options.getProxyOptions() == null) {
+      // http proxy requests are handled in HttpClientImpl, everything else can use netty proxy handler
+      if (options.getProxyOptions() == null || !options.isSsl() && options.getProxyOptions().getType()==ProxyType.HTTP ) {
         channelProvider = ChannelProvider.INSTANCE;
       } else {
         channelProvider = ProxyChannelProvider.INSTANCE;

File: src/main/java/io/vertx/core/net/package-info.java
Patch:
@@ -667,9 +667,6 @@
  * and use http://netty.io/wiki/forked-tomcat-native.html[netty-tcnative] jar on the classpath. Using tcnative may require
  * OpenSSL to be installed on your OS depending on the tcnative implementation.
  *
- * OpenSSL restricts the key/certificate configuration to `.pem` files. However it is still possible to use any trust
- * configuration.
- *
  * ===== Jetty-ALPN support
  *
  * Jetty-ALPN is a small jar that overrides a few classes of Java 8 distribution to support ALPN.

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -453,6 +453,7 @@ public void testGet() throws Exception {
       assertEquals(2, req.headers().getAll("juu_request").size());
       assertEquals("juu_request_value_1", req.headers().getAll("juu_request").get(0));
       assertEquals("juu_request_value_2", req.headers().getAll("juu_request").get(1));
+      assertEquals(Collections.singletonList("cookie_1; cookie_2; cookie_3"), req.headers().getAll("cookie"));
       resp.putHeader("content-type", "text/plain");
       resp.putHeader("Foo_response", "foo_response_value");
       resp.putHeader("bar_response", "bar_response_value");
@@ -494,6 +495,7 @@ public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int
       headers.set("foo_request", "foo_request_value");
       headers.set("bar_request", "bar_request_value");
       headers.set("juu_request", "juu_request_value_1", "juu_request_value_2");
+      headers.set("cookie", Arrays.asList("cookie_1", "cookie_2", "cookie_3"));
       request.encoder.writeHeaders(request.context, id, headers, 0, true, request.context.newPromise());
       request.context.flush();
     });

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -36,6 +36,7 @@
 import io.vertx.core.net.NetworkOptions;
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.ConnectionBase;
+import io.vertx.core.net.impl.PartialPooledByteBufAllocator;
 import io.vertx.core.net.impl.SocketAddressImpl;
 import io.vertx.core.spi.metrics.DatagramSocketMetrics;
 import io.vertx.core.spi.metrics.Metrics;
@@ -66,6 +67,7 @@ public DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
     }
     channel.pipeline().addLast("handler", new DatagramServerHandler(this));
     channel().config().setMaxMessagesPerRead(1);
+    channel().config().setAllocator(PartialPooledByteBufAllocator.INSTANCE);
   }
 
   @Override

File: src/test/java/io/vertx/core/impl/launcher/commands/CommandTestBase.java
Patch:
@@ -97,7 +97,7 @@ public void stop() {
   }
 
   protected void waitUntil(BooleanSupplier supplier) {
-    waitUntil(supplier, 10000);
+    waitUntil(supplier, 20000);
   }
 
   protected void waitUntil(BooleanSupplier supplier, long timeout) {

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -406,7 +406,7 @@ protected void connect(
       applyConnectionOptions(options, bootstrap);
 
       ChannelProvider channelProvider;
-      if (options.getProxyOptions() == null) {
+      if (!options.isSsl() || options.getProxyOptions() == null) {
         channelProvider = ChannelProvider.INSTANCE;
       } else {
         channelProvider = ProxyChannelProvider.INSTANCE;

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -2381,7 +2381,7 @@ public void testWithHttpConnectProxy() {
     server.connectHandler(sock -> {
 
     });
-    proxy = new ConnectHttpProxy(null);
+    proxy = new HttpProxy(null);
     proxy.start(vertx, v -> {
       server.listen(ar -> {
         assertTrue(ar.succeeded());

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -406,7 +406,7 @@ protected void connect(
       applyConnectionOptions(options, bootstrap);
 
       ChannelProvider channelProvider;
-      if (options.getProxyOptions() == null) {
+      if (!options.isSsl() || options.getProxyOptions() == null) {
         channelProvider = ChannelProvider.INSTANCE;
       } else {
         channelProvider = ProxyChannelProvider.INSTANCE;

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -406,7 +406,7 @@ protected void connect(
       applyConnectionOptions(options, bootstrap);
 
       ChannelProvider channelProvider;
-      if (options.getProxyOptions() == null) {
+      if (!options.isSsl() || options.getProxyOptions() == null) {
         channelProvider = ChannelProvider.INSTANCE;
       } else {
         channelProvider = ProxyChannelProvider.INSTANCE;

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java
Patch:
@@ -322,7 +322,7 @@ void writePushPromise(int streamId, Http2Headers headers, Handler<AsyncResult<In
     }
   }
 
-  void _writePushPromise(int streamId, int promisedStreamId, Http2Headers headers, ChannelPromise promise) {
+  private void _writePushPromise(int streamId, int promisedStreamId, Http2Headers headers, ChannelPromise promise) {
     encoder().writePushPromise(ctx, streamId, promisedStreamId, headers, 0, promise);
   }
 }

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1275,8 +1275,8 @@
  * {@link examples.CoreExamples#configureSearchDomains()}
  * ----
  *
- * When a search domain list is used, the threshold for the number of dots is {@code 1}, it can be configured with
- * {@link io.vertx.core.dns.AddressResolverOptions#setNdots(int)}.
+ * When a search domain list is used, the threshold for the number of dots is {@code 1} or loaded from `/etc/resolv.conf`
+ * on Linux, it can be configured to a specific value with {@link io.vertx.core.dns.AddressResolverOptions#setNdots(int)}.
  *
  * NOTE: sometimes it can be desirable to use the JVM built-in resolver, the JVM system property
  * _-Dvertx.disableDnsResolver=true_ activates this behavior

File: src/test/java/io/vertx/test/core/HostnameResolutionTest.java
Patch:
@@ -404,7 +404,6 @@ public void testResolveMissingLocalhost() throws Exception {
     // Test using the resolver API
     VertxInternal vertx = (VertxInternal) vertx(new VertxOptions().setAddressResolverOptions(
         new AddressResolverOptions().
-            setHostsValue(Buffer.buffer("")).
             addServer(dnsServerAddress.getAddress().getHostAddress() + ":" + dnsServerAddress.getPort()).
             setOptResourceEnabled(false)
     ));

File: src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -247,7 +247,7 @@ public synchronized NetSocket upgradeToSsl(final Handler<Void> handler) {
     SslHandler sslHandler = channel.pipeline().get(SslHandler.class);
     if (sslHandler == null) {
 
-      sslHandler = helper.createSslHandler(vertx, this.remoteAddress().host(), this.remoteAddress().port());
+      sslHandler = helper.createSslHandler(vertx, this.remoteName(), this.remoteAddress().port());
       channel.pipeline().addFirst("ssl", sslHandler);
     }
     sslHandler.handshakeFuture().addListener(future -> context.executeFromIO(() -> {

File: src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -247,7 +247,7 @@ public synchronized NetSocket upgradeToSsl(final Handler<Void> handler) {
     SslHandler sslHandler = channel.pipeline().get(SslHandler.class);
     if (sslHandler == null) {
 
-      sslHandler = helper.createSslHandler(vertx, this.remoteAddress().host(), this.remoteAddress().port());
+      sslHandler = helper.createSslHandler(vertx, this.remoteName(), this.remoteAddress().port());
       channel.pipeline().addFirst("ssl", sslHandler);
     }
     sslHandler.handshakeFuture().addListener(future -> context.executeFromIO(() -> {

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1613,7 +1613,7 @@
  * The DNS resolution is always done on the proxy server, to achieve the functionality of a SOCKS4 client, it is necessary
  * to resolve the DNS address locally.
  *
- * Please note: When using {@link ProxyType.HTTP} currently http requests are sent as CONNECT requests to the proxy, which will almost
+ * Please note: When using {@link io.vertx.core.net.ProxyType#HTTP} currently http requests are sent as CONNECT requests to the proxy, which will almost
  * certainly not work since a properly configured proxy will deny connections to non-secure ports.
  *
  * This feature will be implemented differently in next version, allowing for a normal proxy request for non-http requests 

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1613,6 +1613,9 @@
  * The DNS resolution is always done on the proxy server, to achieve the functionality of a SOCKS4 client, it is necessary
  * to resolve the DNS address locally.
  *
+ * Please note: When using ProxyType.HTTP currently http requests are sent as CONNECT requests to the proxy, which will almost
+ * certainly not work since a properly configured proxy will deny connections to non-secure ports.
+ *
  * === Automatic clean-up in verticles
  *
  * If you're creating http servers and clients from inside verticles, those servers and clients will be automatically closed

File: src/test/java/io/vertx/test/it/StreamRecording.java
Patch:
@@ -14,7 +14,7 @@
  *  You may elect to redistribute this code under either of these licenses.
  */
 
-package io.vertx.core.logging;
+package io.vertx.test.it;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;

File: src/test/java/io/vertx/core/impl/launcher/commands/CommandTestBase.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.vertx.core.Vertx;
 import io.vertx.core.impl.launcher.VertxCommandLauncher;
+import io.vertx.core.logging.JULLogDelegateFactory;
 import org.junit.After;
 import org.junit.Before;
 
@@ -51,7 +52,7 @@ public void setUp() throws IOException {
     // We need to reset the log configuration to recreate the logger
     // Indeed print stream may have been cached.
     LogManager.getLogManager().reset();
-    LogManager.getLogManager().readConfiguration();
+    JULLogDelegateFactory.loadConfig();
   }
 
   @After

File: src/main/java/io/vertx/core/eventbus/impl/MessageImpl.java
Patch:
@@ -160,7 +160,7 @@ protected <R> void sendReply(MessageImpl msg, DeliveryOptions options, Handler<A
     }
   }
 
-  boolean isLocal() {
+  protected boolean isLocal() {
     return true;
   }
 }

File: src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredMessage.java
Patch:
@@ -246,7 +246,7 @@ public boolean isFromWire() {
     return fromWire;
   }
 
-  boolean isLocal() {
-    return isFromWire();
+  protected boolean isLocal() {
+    return !isFromWire();
   }
 }

File: src/test/java/io/vertx/test/fakemetrics/HandlerMetric.java
Patch:
@@ -26,10 +26,11 @@ public class HandlerMetric {
   public final String address;
   public final String repliedAddress;
   public final AtomicInteger scheduleCount = new AtomicInteger();
+  public final AtomicInteger localScheduleCount = new AtomicInteger();
   public final AtomicInteger beginCount = new AtomicInteger();
   public final AtomicInteger endCount = new AtomicInteger();
   public final AtomicInteger failureCount = new AtomicInteger();
-  public final AtomicInteger localCount = new AtomicInteger();
+  public final AtomicInteger localBeginCount = new AtomicInteger();
 
   public HandlerMetric(String address, String repliedAddress) {
     this.address = address;
@@ -39,6 +40,6 @@ public HandlerMetric(String address, String repliedAddress) {
   @Override
   public String toString() {
     return "HandlerRegistration[address=" + address + ",repliedAddress=" + repliedAddress + ",beginCount=" + beginCount.get() +
-        ",endCount=" + endCount.get() + ",failureCount=" + failureCount + ",localCount=" + localCount.get() + "]";
+        ",endCount=" + endCount.get() + ",failureCount=" + failureCount + ",localCount=" + localBeginCount.get() + "]";
   }
 }

File: src/main/java/io/vertx/core/shareddata/package-info.java
Patch:
@@ -23,7 +23,7 @@
  * Shared data includes local shared maps, distributed, cluster-wide maps, asynchronous cluster-wide locks and
  * asynchronous cluster-wide counters.
  *
- * IMPORTANT: The behavior of the distributed data structure depends of the cluster manager you use. Backup
+ * IMPORTANT: The behavior of the distributed data structure depends on the cluster manager you use. Backup
  * (replication) and behavior when a network partition is faced are defined by the cluster manager and its
  * configuration. Refer to the cluster manager documentation as well as to the underlying framework manual.
  *

File: src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -421,7 +421,7 @@ private SslHandler createHandler(SSLEngine engine, boolean client) {
       engine.setEnabledCipherSuites(toUse);
     }
     engine.setUseClientMode(client);
-    Set<String> protocols = new HashSet<>(Arrays.asList(DEFAULT_ENABLED_PROTOCOLS));
+    Set<String> protocols = new LinkedHashSet<>(Arrays.asList(DEFAULT_ENABLED_PROTOCOLS));
     protocols.retainAll(Arrays.asList(engine.getEnabledProtocols()));
     if (enabledProtocols != null && !enabledProtocols.isEmpty() && !protocols.isEmpty()) {
       protocols.retainAll(enabledProtocols);

File: src/test/java/io/vertx/test/core/Http2ClientTest.java
Patch:
@@ -1739,7 +1739,7 @@ public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int wind
     client.close();
     client = vertx.createHttpClient(new HttpClientOptions(clientOptions).setHttp2ConnectionWindowSize(65535 * 2));
     client.get(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, "/somepath", resp -> {
-    }).end();
+    }).exceptionHandler(this::fail).end();
     await();
   }
 

File: src/main/java/io/vertx/core/dns/impl/fix/DnsNameResolverContext.java
Patch:
@@ -469,7 +469,7 @@ static String decodeDomainName(ByteBuf buf) {
         return null;
       }
 
-      return name.substring(0, name.length() - 1);
+      return name.toString();
     } finally {
       buf.resetReaderIndex();
     }

File: src/main/java/io/vertx/core/net/impl/ProxyChannelProvider.java
Patch:
@@ -24,7 +24,7 @@
 import java.net.InetSocketAddress;
 
 /**
- * A channel provider that connects via a Proxy : HTTP or Socks
+ * A channel provider that connects via a Proxy : HTTP or SOCKS
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
@@ -36,7 +36,7 @@ private ProxyChannelProvider() {
   }
 
   @Override
-  protected void doConnect(VertxInternal vertx, Bootstrap bootstrap, ProxyOptions options, String host, int port,
+  public void connect(VertxInternal vertx, Bootstrap bootstrap, ProxyOptions options, String host, int port,
                            Handler<Channel> channelInitializer, Handler<AsyncResult<Channel>> channelHandler) {
 
     final String proxyHost = options.getHost();
@@ -62,7 +62,7 @@ protected void doConnect(VertxInternal vertx, Bootstrap bootstrap, ProxyOptions
                 ? new Socks5ProxyHandler(proxyAddr, proxyUsername, proxyPassword) : new Socks5ProxyHandler(proxyAddr);
             break;
           case SOCKS4:
-            // apparently SOCKS4 only supports a username?
+            // SOCKS4 only supports a username and could authenticate the user via Ident
             proxy = proxyUsername != null ? new Socks4ProxyHandler(proxyAddr, proxyUsername)
                 : new Socks4ProxyHandler(proxyAddr);
             break;

File: src/main/java/io/vertx/core/net/package-info.java
Patch:
@@ -679,13 +679,11 @@
  *
  * === Using a proxy for client connections
  *
- * The {@link io.vertx.core.net.NetClient} supports configuring an HTTP/1.x _CONNECT_ proxy or _SOCKS4a_ or _SOCKS5_ proxy.
+ * The {@link io.vertx.core.net.NetClient} supports either a HTTP/1.x _CONNECT_, _SOCKS4a_ or _SOCKS5_ proxy.
  *
  * The proxy can be configured in the {@link io.vertx.core.net.NetClientOptions} by setting a
  * {@link io.vertx.core.net.ProxyOptions} object containing proxy type, hostname, port and optionally username and password.
  *
- * For this feature, the jar `io.netty:netty-handler-proxy` has to be present on the classpath.
- *
  * Here's an example:
  *
  * [source,$lang]

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1597,8 +1597,6 @@
  * The proxy can be configured in the {@link io.vertx.core.http.HttpClientOptions} by setting a
  * {@link io.vertx.core.net.ProxyOptions} object containing proxy type, hostname, port and optionally username and password.
  *
- * For this feature, the jar `io.netty:netty-handler-proxy` has to be present on the classpath.
- *
  * Here's an example:
  *
  * [source,$lang]

File: src/main/java/io/vertx/core/net/package-info.java
Patch:
@@ -684,8 +684,6 @@
  * The proxy can be configured in the {@link io.vertx.core.net.NetClientOptions} by setting a
  * {@link io.vertx.core.net.ProxyOptions} object containing proxy type, hostname, port and optionally username and password.
  *
- * For this feature, the jar `io.netty:netty-handler-proxy` has to be present on the classpath.
- *
  * Here's an example:
  *
  * [source,$lang]

File: src/main/java/io/vertx/core/http/impl/Http1xPool.java
Patch:
@@ -120,7 +120,6 @@ void responseEnded(ClientConnection conn, boolean close) {
   void createConn(HttpVersion version, ContextImpl context, int port, String host, Channel ch, Waiter waiter) {
     ClientConnection conn = new ClientConnection(version, client, queue.metric, ch,
         ssl, host, port, context, this, metrics);
-    conn.exceptionHandler(waiter::handleFailure);
     metrics.endpointConnected(queue.metric, conn.metric());
     ClientHandler handler = ch.pipeline().get(ClientHandler.class);
     handler.conn = conn;

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -305,6 +305,6 @@ default Handler<AsyncResult<T>> completer() {
     };
   }
 
-  static FutureFactory factory = ServiceHelper.loadFactory(FutureFactory.class);
+  FutureFactory factory = ServiceHelper.loadFactory(FutureFactory.class);
 
 }

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -521,5 +521,5 @@ static void clusteredVertx(VertxOptions options, Handler<AsyncResult<Vertx>> res
    */
   @Nullable @GenIgnore Handler<Throwable> exceptionHandler();
 
-  static final VertxFactory factory = ServiceHelper.loadFactory(VertxFactory.class);
+  VertxFactory factory = ServiceHelper.loadFactory(VertxFactory.class);
 }

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -697,6 +697,6 @@ static Buffer buffer(ByteBuf byteBuf) {
   @GenIgnore
   ByteBuf getByteBuf();
 
-  static final BufferFactory factory = ServiceHelper.loadFactory(BufferFactory.class);
+  BufferFactory factory = ServiceHelper.loadFactory(BufferFactory.class);
 
 }

File: src/main/java/io/vertx/core/http/WebSocketFrame.java
Patch:
@@ -106,5 +106,5 @@ static WebSocketFrame continuationFrame(Buffer data, boolean isFinal) {
    */
   boolean isFinal();
 
-  static final WebSocketFrameFactory factory = ServiceHelper.loadFactory(WebSocketFrameFactory.class);
+  WebSocketFrameFactory factory = ServiceHelper.loadFactory(WebSocketFrameFactory.class);
 }

File: src/main/java/io/vertx/core/streams/Pump.java
Patch:
@@ -101,7 +101,7 @@ static <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws, int writeQueueMaxSize)
    */
   int numberPumped();
 
-  static final PumpFactory factory = ServiceHelper.loadFactory(PumpFactory.class);
+  PumpFactory factory = ServiceHelper.loadFactory(PumpFactory.class);
 
 
 }

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -305,6 +305,6 @@ default Handler<AsyncResult<T>> completer() {
     };
   }
 
-  static FutureFactory factory = ServiceHelper.loadFactory(FutureFactory.class);
+  FutureFactory factory = ServiceHelper.loadFactory(FutureFactory.class);
 
 }

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -521,5 +521,5 @@ static void clusteredVertx(VertxOptions options, Handler<AsyncResult<Vertx>> res
    */
   @Nullable @GenIgnore Handler<Throwable> exceptionHandler();
 
-  static final VertxFactory factory = ServiceHelper.loadFactory(VertxFactory.class);
+  VertxFactory factory = ServiceHelper.loadFactory(VertxFactory.class);
 }

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -697,6 +697,6 @@ static Buffer buffer(ByteBuf byteBuf) {
   @GenIgnore
   ByteBuf getByteBuf();
 
-  static final BufferFactory factory = ServiceHelper.loadFactory(BufferFactory.class);
+  BufferFactory factory = ServiceHelper.loadFactory(BufferFactory.class);
 
 }

File: src/main/java/io/vertx/core/http/WebSocketFrame.java
Patch:
@@ -106,5 +106,5 @@ static WebSocketFrame continuationFrame(Buffer data, boolean isFinal) {
    */
   boolean isFinal();
 
-  static final WebSocketFrameFactory factory = ServiceHelper.loadFactory(WebSocketFrameFactory.class);
+  WebSocketFrameFactory factory = ServiceHelper.loadFactory(WebSocketFrameFactory.class);
 }

File: src/main/java/io/vertx/core/streams/Pump.java
Patch:
@@ -101,7 +101,7 @@ static <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws, int writeQueueMaxSize)
    */
   int numberPumped();
 
-  static final PumpFactory factory = ServiceHelper.loadFactory(PumpFactory.class);
+  PumpFactory factory = ServiceHelper.loadFactory(PumpFactory.class);
 
 
 }

File: src/test/java/io/vertx/test/core/MetricsTest.java
Patch:
@@ -584,12 +584,12 @@ public void testHttpClientMetricsQueueLength() throws Exception {
     copy.forEach(Runnable::run);
     awaitLatch(responsesLatch);
     waitUntil(() -> requests.size() == 5);
-    copy = new ArrayList<>(requests);
-    requests.clear();
-    copy.forEach(Runnable::run);
     assertEquals(Collections.singleton("localhost:8080"), metrics.endpoints());
     assertEquals(3, (int)metrics.queueSize("localhost:8080"));
     assertEquals(5, (int)metrics.connectionCount("localhost:8080"));
+    copy = new ArrayList<>(requests);
+    requests.clear();
+    copy.forEach(Runnable::run);
     waitUntil(() -> requests.size() == 3);
     assertEquals(Collections.singleton("localhost:8080"), metrics.endpoints());
     assertEquals(0, (int)metrics.queueSize("localhost:8080"));

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -239,6 +239,7 @@ protected <T> boolean addLocalRegistration(String address, HandlerRegistration<T
       // Embedded
       context = vertx.getOrCreateContext();
     }
+    registration.setHandlerContext(context);
 
     boolean newAddress = false;
 

File: src/main/java/io/vertx/core/eventbus/impl/MessageProducerImpl.java
Patch:
@@ -154,7 +154,6 @@ private synchronized void doReceiveCredit(int credit) {
         break;
       } else {
         credits--;
-        System.out.println("sending " + data);
         bus.send(address, data, options);
       }
     }

File: src/main/java/examples/HTTP2Examples.java
Patch:
@@ -284,7 +284,9 @@ public void example28(HttpConnection connection) {
 
   public void useMaxStreams(Vertx vertx) {
 
-    HttpClientOptions clientOptions = new HttpClientOptions().setMaxStreams(10).setMaxPoolSize(3);
+    HttpClientOptions clientOptions = new HttpClientOptions().
+        setHttp2MaxStreams(10).
+        setHttp2MaxPoolSize(3);
 
     // Uses up to 3 connections and up to 10 streams per connection
     HttpClient client = vertx.createHttpClient(clientOptions);

File: src/test/java/io/vertx/test/core/Http1xTest.java
Patch:
@@ -317,7 +317,7 @@ public void testServerOptions() {
     assertEquals(SSLEngine.OPENSSL, options.getSslEngine());
 
     Http2Settings initialSettings = randomHttp2Settings();
-    assertEquals(new Http2Settings(), options.getInitialSettings());
+    assertEquals(new Http2Settings().setMaxConcurrentStreams(HttpServerOptions.DEFAULT_INITIAL_SETTINGS_MAX_CONCURRENT_STREAMS), options.getInitialSettings());
     assertEquals(options, options.setInitialSettings(initialSettings));
     assertEquals(initialSettings, options.getInitialSettings());
 

File: src/test/java/io/vertx/test/core/WebsocketTest.java
Patch:
@@ -961,7 +961,9 @@ public void testWebsocketPauseAndResume() {
       client.websocketStream(HttpTestBase.DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, path).
           exceptionHandler(err -> {
             assertTrue(paused.get());
-            assertTrue(err instanceof WebSocketHandshakeException);
+            if (!(err instanceof WebSocketHandshakeException)) {
+              fail(new AssertionError("Was expecting error to be WebSocketHandshakeException", err));
+            }
             paused.set(false);
             stream.resume();
             client.websocket(HttpTestBase.DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, path, ws -> {

File: src/main/java/io/vertx/core/net/ClientOptionsBase.java
Patch:
@@ -68,7 +68,7 @@ public ClientOptionsBase(ClientOptionsBase other) {
     this.connectTimeout = other.getConnectTimeout();
     this.trustAll = other.isTrustAll();
     this.metricsName = other.metricsName;
-    this.proxyOptions = other.proxyOptions != null ? other.proxyOptions.clone() : null;
+    this.proxyOptions = other.proxyOptions != null ? new ProxyOptions(other.proxyOptions) : null;
   }
 
   /**

File: src/main/generated/io/vertx/core/net/ClientOptionsBaseConverter.java
Patch:
@@ -33,6 +33,9 @@ public static void fromJson(JsonObject json, ClientOptionsBase obj) {
     if (json.getValue("metricsName") instanceof String) {
       obj.setMetricsName((String)json.getValue("metricsName"));
     }
+    if (json.getValue("proxyOptions") instanceof JsonObject) {
+      obj.setProxyOptions(new io.vertx.core.net.ProxyOptions((JsonObject)json.getValue("proxyOptions")));
+    }
     if (json.getValue("trustAll") instanceof Boolean) {
       obj.setTrustAll((Boolean)json.getValue("trustAll"));
     }

File: src/main/java/io/vertx/core/net/impl/VertxHandler.java
Patch:
@@ -127,6 +127,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
     if (evt instanceof IdleStateEvent && ((IdleStateEvent) evt).state() == IdleState.ALL_IDLE) {
       ctx.close();
     }
+    ctx.fireUserEventTriggered(evt);
   }
 
   protected abstract void channelRead(C connection, ContextImpl context, ChannelHandlerContext chctx, Object msg) throws Exception;

File: src/main/java/io/vertx/core/http/impl/Http2ConnectionBase.java
Patch:
@@ -108,7 +108,7 @@ VertxInternal vertx() {
   }
 
   NetSocket toNetSocket(VertxHttp2Stream stream) {
-    VertxHttp2NetSocket<Http2ConnectionBase> rempl = new VertxHttp2NetSocket<>(this, stream.stream);
+    VertxHttp2NetSocket<Http2ConnectionBase> rempl = new VertxHttp2NetSocket<>(this, stream.stream, !stream.isNotWritable());
     streams.put(stream.stream.id(), rempl);
     return rempl;
   }

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequestImpl.java
Patch:
@@ -85,8 +85,8 @@ public class Http2ServerRequestImpl extends VertxHttp2Stream<Http2ServerConnecti
   private NetSocket netSocket;
 
   public Http2ServerRequestImpl(Http2ServerConnection conn, Http2Stream stream, HttpServerMetrics metrics,
-      String serverOrigin, Http2Headers headers, String contentEncoding) {
-    super(conn, stream);
+      String serverOrigin, Http2Headers headers, String contentEncoding, boolean writable) {
+    super(conn, stream, writable);
 
     this.serverOrigin = serverOrigin;
     this.headers = headers;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -54,7 +54,7 @@ public HttpClientRequestPushPromise(
       MultiMap headers) throws Http2Exception {
     super(client, method, host, uri);
     this.conn = conn;
-    this.stream = new Http2ClientConnection.Http2ClientStream(conn, this, stream);
+    this.stream = new Http2ClientConnection.Http2ClientStream(conn, this, stream, false);
     this.method = method;
     this.rawMethod = rawMethod;
     this.uri = uri;

File: src/main/java/io/vertx/core/http/impl/VertxHttp2NetSocket.java
Patch:
@@ -49,8 +49,8 @@ class VertxHttp2NetSocket<C extends Http2ConnectionBase> extends VertxHttp2Strea
   private Handler<Buffer> dataHandler;
   private Handler<Void> drainHandler;
 
-  public VertxHttp2NetSocket(C conn, Http2Stream stream) {
-    super(conn, stream);
+  public VertxHttp2NetSocket(C conn, Http2Stream stream, boolean writable) {
+    super(conn, stream, writable);
   }
 
   // Stream impl

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -44,12 +44,13 @@ abstract class VertxHttp2Stream<C extends Http2ConnectionBase> {
   private boolean paused;
   private boolean writable = true;
 
-  VertxHttp2Stream(C conn, Http2Stream stream) {
+  VertxHttp2Stream(C conn, Http2Stream stream, boolean writable) {
     this.conn = conn;
     this.vertx = conn.vertx();
     this.handlerContext = conn.handlerContext;
     this.stream = stream;
     this.context = conn.getContext();
+    this.writable = writable;
   }
 
   void onResetRead(long code) {

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -778,6 +778,9 @@
  * order to gather metrics. For more information on this, please consult the
  * {@link io.vertx.core.spi.metrics.VertxMetrics API Documentation}.
  *
+ * You can also specify a metrics factory programmatically if embedding Vert.x using
+ * {@link io.vertx.core.metrics.MetricsOptions#setFactory(io.vertx.core.spi.VertxMetricsFactory)}.
+ *
  * == OSGi
  *
  * Vert.x Core is packaged as an OSGi bundle, so can be used in any OSGi R4.2+ environment such as Apache Felix

File: src/main/java/io/vertx/core/http/HttpClientResponse.java
Patch:
@@ -128,13 +128,13 @@ public interface HttpClientResponse extends ReadStream<Buffer> {
   HttpClientResponse bodyHandler(Handler<Buffer> bodyHandler);
 
   /**
-   * Set an unknown frame handler. The handler will get notified when the http stream receives an unknown HTTP/2
+   * Set an custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
    * frame. HTTP/2 permits extension of the protocol.
    *
    * @return a reference to this, so the API can be used fluently
    */
   @Fluent
-  HttpClientResponse unknownFrameHandler(Handler<HttpFrame> handler);
+  HttpClientResponse customFrameHandler(Handler<HttpFrame> handler);
 
   /**
    * Get a net socket for the underlying connection of this request.

File: src/main/java/io/vertx/core/http/HttpServer.java
Patch:
@@ -64,8 +64,7 @@ public interface HttpServer extends Measured {
   Handler<HttpServerRequest> requestHandler();
 
   /**
-   * Set a connection handler for the server. The connection handler is called after an HTTP2 connection has
-   * been negociated.
+   * Set a connection handler for the server.
    *
    * @return a reference to this, so the API can be used fluently
    */

File: src/main/java/io/vertx/core/http/HttpServerRequest.java
Patch:
@@ -277,16 +277,16 @@ default HttpServerRequest bodyHandler(@Nullable Handler<Buffer> bodyHandler) {
   boolean isEnded();
 
   /**
-   * Set an unknown frame handler. The handler will get notified when the http stream receives an unknown HTTP/2
+   * Set a custom frame handler. The handler will get notified when the http stream receives an custom HTTP/2
    * frame. HTTP/2 permits extension of the protocol.
    *
    * @return a reference to this, so the API can be used fluently
    */
   @Fluent
-  HttpServerRequest unknownFrameHandler(Handler<HttpFrame> handler);
+  HttpServerRequest customFrameHandler(Handler<HttpFrame> handler);
 
   /**
-   * @return the {@link HttpConnection} associated with this request when it is an HTTP/2 connection, null otherwise
+   * @return the {@link HttpConnection} associated with this request
    */
   @CacheReturn
   HttpConnection connection();

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -54,7 +54,7 @@ class Http2ClientConnection extends Http2ConnectionBase implements HttpClientCon
   final Http2Pool http2Pool;
   final HttpClientMetrics metrics;
   final Object metric;
-  long streamCount;
+  int streamCount;
 
   public Http2ClientConnection(Http2Pool http2Pool,
                                ContextImpl context,
@@ -227,7 +227,7 @@ void handleInterestedOpsChanged() {
     }
 
     @Override
-    void handleUnknownFrame(int type, int flags, Buffer buff) {
+    void handleCustomFrame(int type, int flags, Buffer buff) {
       response.handleUnknowFrame(new HttpFrameImpl(type, flags, buff));
     }
 

File: src/main/java/io/vertx/core/http/impl/Http2ServerResponseImpl.java
Patch:
@@ -404,7 +404,7 @@ void write(ByteBuf chunk, boolean end) {
   }
 
   @Override
-  public HttpServerResponse writeFrame(int type, int flags, Buffer payload) {
+  public HttpServerResponse writeCustomFrame(int type, int flags, Buffer payload) {
     synchronized (conn) {
       checkEnded();
       checkSendHeaders(false);

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestPushPromise.java
Patch:
@@ -260,7 +260,7 @@ public boolean writeQueueFull() {
   }
 
   @Override
-  public HttpClientRequest writeFrame(int type, int flags, Buffer payload) {
+  public HttpClientRequest writeCustomFrame(int type, int flags, Buffer payload) {
     throw new UnsupportedOperationException("Cannot write frame with HTTP/1.x ");
   }
 }

File: src/main/java/io/vertx/core/http/impl/HttpServerRequestImpl.java
Patch:
@@ -351,13 +351,13 @@ public boolean isEnded() {
   }
 
   @Override
-  public HttpServerRequest unknownFrameHandler(Handler<HttpFrame> handler) {
+  public HttpServerRequest customFrameHandler(Handler<HttpFrame> handler) {
     return this;
   }
 
   @Override
   public HttpConnection connection() {
-    return null;
+    return conn;
   }
 
   void handleData(Buffer data) {

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -628,7 +628,7 @@ public HttpServerResponse push(HttpMethod method, String host, String path, Mult
   }
 
   @Override
-  public HttpServerResponse writeFrame(int type, int flags, Buffer payload) {
+  public HttpServerResponse writeCustomFrame(int type, int flags, Buffer payload) {
     return this;
   }
 }

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -166,7 +166,7 @@ void handleInterestedOpsChanged() {
   void handleData(Buffer buf) {
   }
 
-  void handleUnknownFrame(int type, int flags, Buffer buff) {
+  void handleCustomFrame(int type, int flags, Buffer buff) {
   }
 
   void handleEnd(MultiMap trailers) {

File: src/main/java/io/vertx/core/impl/launcher/commands/Watcher.java
Patch:
@@ -290,7 +290,8 @@ private void executeUserCommand(Handler<Void> onCompletion) {
             .redirectOutput(ProcessBuilder.Redirect.INHERIT)
             .start();
 
-        process.waitFor();
+        int status = process.waitFor();
+        System.out.println("User command terminated with status " + status);
       } catch (Throwable e) {
         System.err.println("Error while executing the on-redeploy command : '" + cmd + "'");
         e.printStackTrace();

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -372,7 +372,8 @@ private void actualClose(ContextImpl closeContext, Handler<AsyncResult<Void>> do
 
   private void executeCloseDone(ContextImpl closeContext, Handler<AsyncResult<Void>> done, Exception e) {
     if (done != null) {
-      closeContext.runOnContext(v -> done.handle(Future.failedFuture(e)));
+      Future<Void> fut = e == null ? Future.succeededFuture() : Future.failedFuture(e);
+      closeContext.runOnContext(v -> done.handle(fut));
     }
   }
 

File: src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -99,7 +99,6 @@ public class SSLHelper {
   private ArrayList<Buffer> crlValues;
   private ClientAuth clientAuth = ClientAuth.NONE;
   private Set<String> enabledCipherSuites;
-  private boolean verifyHost;
   private io.vertx.core.net.SSLEngine sslEngine;
   private boolean client;
   private boolean useAlpn;

File: src/test/java/io/vertx/core/logging/Log4J2LogDelegateTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import java.io.IOException;
 
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertTrue;
 
 /**
  * Theses test checks the Log4J 2 log delegate.

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -2445,12 +2445,12 @@ public void testUnknownFrame() throws Exception {
     Buffer expectedRecv = TestUtils.randomBuffer(500);
     Context ctx = vertx.getOrCreateContext();
     server.requestHandler(req -> {
-      req.unknownFrameHandler(frame -> {
+      req.customFrameHandler(frame -> {
         assertOnIOContext(ctx);
         assertEquals(10, frame.type());
         assertEquals(253, frame.flags());
         assertEquals(expectedSend, frame.payload());
-        req.response().writeFrame(12, 134, expectedRecv).end();
+        req.response().writeCustomFrame(12, 134, expectedRecv).end();
       });
     });
     startServer(ctx);

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -504,7 +504,8 @@ public int actualPort() {
 
   private void executeCloseDone(final ContextImpl closeContext, final Handler<AsyncResult<Void>> done, final Exception e) {
     if (done != null) {
-      closeContext.runOnContext((v) -> done.handle(Future.failedFuture(e)));
+      Future<Void> fut = e != null ? Future.failedFuture(e) : Future.succeededFuture();
+      closeContext.runOnContext((v) -> done.handle(fut));
     }
   }
 

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -372,7 +372,8 @@ private void actualClose(ContextImpl closeContext, Handler<AsyncResult<Void>> do
 
   private void executeCloseDone(ContextImpl closeContext, Handler<AsyncResult<Void>> done, Exception e) {
     if (done != null) {
-      closeContext.runOnContext(v -> done.handle(Future.failedFuture(e)));
+      Future<Void> fut = e == null ? Future.succeededFuture() : Future.failedFuture(e);
+      closeContext.runOnContext(v -> done.handle(fut));
     }
   }
 

File: src/main/java/io/vertx/core/impl/launcher/commands/Watcher.java
Patch:
@@ -283,7 +283,8 @@ private void executeUserCommand(Handler<Void> onCompletion) {
             .redirectOutput(ProcessBuilder.Redirect.INHERIT)
             .start();
 
-        process.waitFor();
+        int status = process.waitFor();
+        System.out.println("User command terminated with status " + status);
       } catch (Throwable e) {
         System.err.println("Error while executing the on-redeploy command : '" + cmd + "'");
         e.printStackTrace();

File: src/test/java/io/vertx/core/logging/Log4J2LogDelegateTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import java.io.IOException;
 
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertTrue;
 
 /**
  * Theses test checks the Log4J 2 log delegate.

File: src/main/java/io/vertx/core/WorkerExecutor.java
Patch:
@@ -17,6 +17,7 @@
 package io.vertx.core;
 
 import io.vertx.codegen.annotations.VertxGen;
+import io.vertx.core.metrics.Measured;
 
 /**
  * An executor for executing blocking code in Vert.x .<p>
@@ -27,7 +28,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
 @VertxGen
-public interface WorkerExecutor {
+public interface WorkerExecutor extends Measured {
 
   /**
    * Safely execute some blocking code.

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -420,7 +420,7 @@ private void doDeploy(String identifier, String deploymentID, DeploymentOptions
     AtomicInteger deployCount = new AtomicInteger();
     AtomicBoolean failureReported = new AtomicBoolean();
     for (Verticle verticle: verticles) {
-      NamedWorkerExecutor workerExec = poolName != null ? vertx.createWorkerExecutor(poolName, options.getWorkerPoolSize()) : null;
+      WorkerExecutorImpl workerExec = poolName != null ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize()) : null;
       WorkerPool pool = workerExec != null ? workerExec.getPool() : null;
       ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :
         vertx.createEventLoopContext(deploymentID, pool, conf, tccl);

File: src/main/java/io/vertx/core/net/ClientOptionsBase.java
Patch:
@@ -39,6 +39,9 @@ public abstract class ClientOptionsBase extends TCPSSLOptions {
    */
   public static final boolean DEFAULT_TRUST_ALL = false;
 
+  /**
+   * The default value of the client metrics = "":
+   */
   public static final String DEFAULT_METRICS_NAME = "";
 
   private int connectTimeout;

File: src/test/java/io/vertx/test/fakemetrics/FakeVertxMetrics.java
Patch:
@@ -32,7 +32,6 @@
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.spi.metrics.*;
 
-import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -136,7 +135,7 @@ public DatagramSocketMetrics createMetrics(DatagramSocket socket, DatagramSocket
   }
 
   @Override
-  public <P> PoolMetrics<?> createMetrics(P pool, String poolName, int maxPoolSize) {
+  public <P> PoolMetrics<?> createMetrics(P pool, String poolType, String poolName, int maxPoolSize) {
     return new FakeThreadPoolMetrics(poolName, maxPoolSize);
   }
 

File: src/test/java/io/vertx/core/impl/launcher/commands/WatcherTest.java
Patch:
@@ -51,7 +51,8 @@ public void prepare() {
     deploy = new AtomicInteger();
     undeploy = new AtomicInteger();
 
-    watcher = new Watcher(root, Collections.singletonList("**" + File.separator + "*.txt"),
+    // Use "/" on purpose, on windows it should replace it by "\".
+    watcher = new Watcher(root, Collections.singletonList("**" + "/" + "*.txt"),
         next -> {
           deploy.incrementAndGet();
           if (next != null) {

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -539,7 +539,9 @@ public void deployVerticle(Verticle verticle, DeploymentOptions options, Handler
       closed = this.closed;
     }
     if (closed) {
-      completionHandler.handle(Future.failedFuture("Vert.x closed"));
+      if (completionHandler != null) {
+        completionHandler.handle(Future.failedFuture("Vert.x closed"));
+      }
     } else {
       deploymentManager.deployVerticle(verticle, options, completionHandler);
     }

File: src/test/java/io/vertx/core/impl/launcher/commands/WatcherTest.java
Patch:
@@ -51,7 +51,8 @@ public void prepare() {
     deploy = new AtomicInteger();
     undeploy = new AtomicInteger();
 
-    watcher = new Watcher(root, Collections.singletonList("**" + File.separator + "*.txt"),
+    // Use "/" on purpose, on windows it should replace it by "\".
+    watcher = new Watcher(root, Collections.singletonList("**" + "/" + "*.txt"),
         next -> {
           deploy.incrementAndGet();
           if (next != null) {

File: src/main/java/io/vertx/core/impl/launcher/commands/Watcher.java
Patch:
@@ -278,7 +278,8 @@ private void executeUserCommand(Handler<Void> onCompletion) {
             .redirectOutput(ProcessBuilder.Redirect.INHERIT)
             .start();
 
-        process.waitFor();
+        int status = process.waitFor();
+        System.out.println("User command terminated with status " + status);
       } catch (Throwable e) {
         System.err.println("Error while executing the on-redeploy command : '" + cmd + "'");
         e.printStackTrace();

File: src/test/java/io/vertx/test/fakemetrics/FakeVertxMetrics.java
Patch:
@@ -72,7 +72,7 @@ public EventBusMetrics createMetrics(EventBus eventBus) {
   }
 
   public HttpClientMetrics<?, ?, ?> createMetrics(HttpClient client, HttpClientOptions options) {
-    return new FakeHttpClientMetrics(client);
+    return new FakeHttpClientMetrics(client, options.getMetricsName());
   }
 
   public TCPMetrics<?> createMetrics(NetServer server, SocketAddress localAddress, NetServerOptions options) {

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1094,7 +1094,7 @@
  * the module explicitly (_Build_ menu -> _Make project_).
  *
  * To debug your application, create your run configuration as a remote application and configure the debugger
- * using `--java-opts`. However, dont forget to re-plug the debugger after every redeployment as a new process is
+ * using `--java-opts`. However, don't forget to re-plug the debugger after every redeployment as a new process is
  * created every time.
  *
  * You can also hook your build process in the redeploy cycle:

File: src/main/java/io/vertx/core/http/impl/proxy/ProxyChannelProvider.java
Patch:
@@ -17,8 +17,6 @@
 import io.vertx.core.http.HttpClientOptions;
 import io.vertx.core.http.impl.ChannelProvider;
 import io.vertx.core.impl.VertxInternal;
-import io.vertx.core.logging.Logger;
-import io.vertx.core.logging.LoggerFactory;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;

File: src/main/java/io/vertx/core/impl/MultiThreadedWorkerContext.java
Patch:
@@ -31,7 +31,7 @@ public MultiThreadedWorkerContext(VertxInternal vertx, WorkerPool workerPool,
 
   @Override
   public void executeAsync(Handler<Void> task) {
-    workerPool.workerExec.execute(wrapTask(null, task, false, workerPool.workerMetrics));
+    workerPool.workerPool.execute(wrapTask(null, task, false, workerPool.workerMetrics));
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/WorkerContext.java
Patch:
@@ -31,7 +31,7 @@ public WorkerContext(VertxInternal vertx, WorkerPool workerPool, String deployme
 
   @Override
   public void executeAsync(Handler<Void> task) {
-    workerPool.workerExec.execute(wrapTask(null, task, true, workerPool.workerMetrics));
+    workerExec.execute(wrapTask(null, task, true, workerPool.workerMetrics));
   }
 
   @Override
@@ -53,7 +53,7 @@ protected void checkCorrectThread() {
   // so we need to execute it on the worker thread
   @Override
   public void executeFromIO(ContextTask task) {
-    workerPool.workerExec.execute(wrapTask(task, null, true, workerPool.workerMetrics));
+    workerExec.execute(wrapTask(task, null, true, workerPool.workerMetrics));
   }
 
 }

File: src/test/java/io/vertx/core/logging/Recording.java
Patch:
@@ -40,7 +40,7 @@ private void start() {
     logger.addHandler(handler);
   }
 
-  private void stop() {
+  public void stop() {
     logger.removeHandler(handler);
   }
 

File: src/test/java/io/vertx/core/impl/launcher/commands/ClasspathHandlerTest.java
Patch:
@@ -56,12 +56,12 @@ public void setUp() throws IOException {
   }
 
   @After
-  public void tearDown() {
+  public void tearDown() throws InterruptedException {
     if (run != null) {
-      run.vertx.close();
+      close(run.vertx);
     }
     if (bare != null) {
-      bare.vertx.close();
+      close(bare.vertx);
     }
   }
 

File: src/test/java/io/vertx/core/impl/launcher/commands/ClasspathHandlerTest.java
Patch:
@@ -56,12 +56,12 @@ public void setUp() throws IOException {
   }
 
   @After
-  public void tearDown() {
+  public void tearDown() throws InterruptedException {
     if (run != null) {
-      run.vertx.close();
+      close(run.vertx);
     }
     if (bare != null) {
-      bare.vertx.close();
+      close(bare.vertx);
     }
   }
 

File: src/main/java/io/vertx/core/impl/OrderedExecutorFactory.java
Patch:
@@ -31,7 +31,7 @@
  * @version <tt>$Revision$</tt>
  */
 public class OrderedExecutorFactory {
-  // It must be package-private rather than `private` in order to avoid the generation of an accessor, which would
+  // It must be package-protected rather than `private` in order to avoid the generation of an accessor, which would
   // cause Quasar 0.7.5-SNAPSHOT+ to print print an harmless error message during vert.x boot when using the agent
   // instrumentation method. See https://github.com/puniverse/quasar/issues/160#issuecomment-205977756 for details.
   static final Logger log = LoggerFactory.getLogger(OrderedExecutorFactory.class);

File: src/main/java/io/vertx/core/http/HttpMethod.java
Patch:
@@ -25,5 +25,5 @@
  */
 @VertxGen
 public enum HttpMethod {
-  OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT, PATCH, UNKNOWN
+  OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT, PATCH, OTHER
 }

File: src/main/java/io/vertx/core/http/impl/HttpClientStream.java
Patch:
@@ -41,8 +41,8 @@ interface HttpClientStream {
   HttpClientConnection connection();
   Context getContext();
 
-  void writeHead(HttpMethod method, String uri, MultiMap headers, String hostHeader, boolean chunked);
-  void writeHeadWithContent(HttpMethod method, String uri, MultiMap headers, String hostHeader, boolean chunked, ByteBuf buf, boolean end);
+  void writeHead(HttpMethod method, String rawMethod, String uri, MultiMap headers, String hostHeader, boolean chunked);
+  void writeHeadWithContent(HttpMethod method, String rawMethod, String uri, MultiMap headers, String hostHeader, boolean chunked, ByteBuf buf, boolean end);
   void writeBuffer(ByteBuf buf, boolean end);
   void writeFrame(int type, int flags, ByteBuf payload);
 

File: src/main/java/io/vertx/core/impl/CompositeFutureImpl.java
Patch:
@@ -66,7 +66,7 @@ public static CompositeFuture any(Future<?>... results) {
         if (ar.succeeded()) {
           synchronized (composite) {
             if (!composite.isComplete()) {
-              composite.setSucceeded();
+              handler = composite.setSucceeded();
             }
           }
         } else {

File: src/main/java/docoverride/verticles/package-info.java
Patch:
@@ -73,7 +73,7 @@
  *       if (res.succeeded()) {
  *         startFuture.complete();
  *       } else {
- *         startFuture.fail();
+ *         startFuture.fail(res.cause());
  *       }
  *     });
  *   }

File: src/main/java/docoverride/verticles/package-info.java
Patch:
@@ -73,7 +73,7 @@
  *       if (res.succeeded()) {
  *         startFuture.complete();
  *       } else {
- *         startFuture.fail();
+ *         startFuture.fail(res.cause());
  *       }
  *     });
  *   }

File: src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
Patch:
@@ -401,7 +401,8 @@ protected JsonObject getConfiguration() {
         try {
           conf = new JsonObject(config);
         } catch (DecodeException e2) {
-          log.error("-conf option does not point to a file and is not valid JSON: " + config);
+          // The configuration is not printed for security purpose, it can contain sensitive data.
+          log.error("The -conf option does not point to an existing file or is not a valid JSON object");
           return null;
         }
       }

File: src/main/java/io/vertx/core/http/impl/Http2Pool.java
Patch:
@@ -76,6 +76,7 @@ void createConn(ContextImpl context, Channel ch, Waiter waiter, boolean upgrade)
           .connectionFactory(connHandler -> new Http2ClientConnection(Http2Pool.this, context, ch, connHandler, client.metrics))
           .build();
       if (upgrade) {
+        System.out.println("upgrade");
         handler.onHttpClientUpgrade();
       }
       Http2ClientConnection conn = handler.connection;

File: src/main/java/io/vertx/core/http/impl/VertxHttp2ClientUpgradeCodec.java
Patch:
@@ -66,5 +66,8 @@ public Collection<CharSequence> setUpgradeHeaders(ChannelHandlerContext ctx, Htt
 
   @Override
   public void upgradeTo(ChannelHandlerContext ctx, FullHttpResponse upgradeResponse) throws Exception {
+
+
+
   }
 }

File: src/main/java/examples/HTTP2Examples.java
Patch:
@@ -186,7 +186,7 @@ public void example13(HttpClient client) {
     request.end();
   }
 
-  public void example13(HttpClientRequest request) {
+  public void example14(HttpClientRequest request) {
     request.pushHandler(pushedRequest -> {
       if (pushedRequest.path().equals("/main.js")) {
         pushedRequest.reset();

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1080,7 +1080,7 @@
  *
  * [source,$lang]
  * ----
- * {@link examples.HTTP2Examples#example13}
+ * {@link examples.HTTP2Examples#example14}
  * ----
  *
  * When no handler is set, any stream pushed will be automatically cancelled by the client with

File: src/main/java/io/vertx/core/http/impl/Http2ClientConnection.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http2.DefaultHttp2Headers;
 import io.netty.handler.codec.http2.Http2Connection;
+import io.netty.handler.codec.http2.Http2Error;
 import io.netty.handler.codec.http2.Http2Exception;
 import io.netty.handler.codec.http2.Http2Headers;
 import io.netty.handler.codec.http2.Http2Stream;
@@ -134,7 +135,7 @@ public synchronized void onPushPromiseRead(ChannelHandlerContext ctx, int stream
         return;
       }
     }
-    handler.writeReset(promisedStreamId, 0);
+    handler.writeReset(promisedStreamId, Http2Error.CANCEL.code());
   }
 
   static class Http2ClientStream extends VertxHttp2Stream<Http2ClientConnection> implements HttpClientStream {

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -1074,7 +1074,8 @@
  * {@link examples.HTTP2Examples#example13}
  * ----
  *
- * When no handler is set, any stream pushed by the server will be automatically reset by the client.
+ * When no handler is set, any stream pushed will be automatically cancelled by the client with
+ * a stream reset (`8` error code).
  *
  * ==== Receiving unknown HTTP/2 frames
  *

File: src/test/java/io/vertx/test/core/Http2ClientTest.java
Patch:
@@ -839,7 +839,7 @@ public void testResetPushPromiseNoHandler() throws Exception {
         resp.setChunked(true).write("content");
         resp.exceptionHandler(err -> {
           assertTrue(err instanceof StreamResetException);
-          assertEquals(0, ((StreamResetException) err).getCode());
+          assertEquals(Http2Error.CANCEL.code(), ((StreamResetException) err).getCode());
           testComplete();
         });
       });

File: src/main/java/io/vertx/core/http/impl/FileStreamChannel.java
Patch:
@@ -149,7 +149,7 @@ protected void doBeginRead() throws Exception {
   @Override
   protected void doWrite(ChannelOutboundBuffer in) throws Exception {
     ByteBuf chunk;
-    while (!stream.isNotWritable() && (chunk = (ByteBuf) in.current()) != null && length > 0) {
+    while (!stream.isNotWritable() && (chunk = (ByteBuf) in.current()) != null) {
       length -= chunk.readableBytes();
       bytesWritten += chunk.readableBytes();
       stream.writeData(chunk.retain(), false);

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -599,7 +599,7 @@ private void connected(HttpClientStream stream, Handler<HttpVersion> headersComp
 
     HttpClientConnection conn = stream.connection();
 
-    synchronized (conn) {
+    synchronized (this) {
       this.conn = conn;
       this.stream = stream;
       stream.beginRequest(this);

File: src/main/java/io/vertx/core/AbstractVerticle.java
Patch:
@@ -24,7 +24,7 @@
  *
  * An abstract base class that you can extend to write your own Verticle classes.
  * <p>
- * Instead of implementing {@link io.vertx.core.Verticle} directly it it often simpler to just extend this class.
+ * Instead of implementing {@link io.vertx.core.Verticle} directly, it is often simpler to just extend this class.
  * <p>
  * In the simplest case, just override the {@link #start} method. If you have verticle clean-up to do you can
  * optionally override the {@link #stop} method too.

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -36,12 +36,12 @@ public abstract class TCPSSLOptions extends NetworkOptions {
   public static final boolean DEFAULT_TCP_NO_DELAY = true;
 
   /**
-   * The default value of TCP keep alive
+   * The default value of TCP keep alive = false
    */
   public static final boolean DEFAULT_TCP_KEEP_ALIVE = false;
 
   /**
-   * The default value of SO_linger
+   * The default value of SO_linger = -1
    */
   public static final int DEFAULT_SO_LINGER = -1;
 

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -206,7 +206,7 @@ default Handler<AsyncResult<T>> completer() {
       if (ar.succeeded()) {
         complete(ar.result());
       } else {
-        ar.failed();
+        fail(ar.cause());
       }
     };
   }

File: src/main/java/io/vertx/core/http/impl/Http2ServerConnection.java
Patch:
@@ -25,10 +25,10 @@
 import io.netty.handler.codec.http2.Http2Headers;
 import io.netty.handler.codec.http2.Http2Settings;
 import io.netty.handler.codec.http2.Http2Stream;
-import io.netty.util.concurrent.EventExecutor;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.MultiMap;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpServerOptions;
 import io.vertx.core.http.HttpServerRequest;
@@ -194,7 +194,7 @@ public Push(Http2Stream stream, String contentEncoding, Handler<AsyncResult<Http
     }
 
     @Override
-    void handleEnd() {
+    void handleEnd(MultiMap trailers) {
     }
 
     @Override

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequestImpl.java
Patch:
@@ -144,7 +144,7 @@ void handleData(Buffer data) {
     }
   }
 
-  void handleEnd() {
+  void handleEnd(MultiMap trailers) {
     ended = true;
     conn.reportBytesRead(bytesRead);
     if (postRequestDecoder != null) {

File: src/main/java/io/vertx/core/http/impl/VertxHttp2NetSocket.java
Patch:
@@ -18,13 +18,13 @@
 
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http2.Http2Stream;
-import io.netty.handler.ssl.SslHandler;
 import io.netty.util.CharsetUtil;
 import io.vertx.codegen.annotations.Nullable;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.MultiMap;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.StreamResetException;
 import io.vertx.core.net.NetSocket;
@@ -56,7 +56,7 @@ public VertxHttp2NetSocket(C conn, Http2Stream stream) {
   // Stream impl
 
   @Override
-  void handleEnd() {
+  void handleEnd(MultiMap trailers) {
     try {
       if (endHandler != null) {
         // Give opportunity to send a last chunk

File: src/test/java/io/vertx/test/core/Http2ClientTest.java
Patch:
@@ -310,6 +310,7 @@ public void testTrailers() throws Exception {
     startServer();
     client.getNow(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, "/somepeth", resp -> {
       assertEquals(null, resp.getTrailer("foo"));
+      resp.exceptionHandler(this::fail);
       resp.endHandler(v -> {
         assertEquals("foo_value", resp.getTrailer("foo"));
         assertEquals("foo_value", resp.getTrailer("Foo"));
@@ -334,6 +335,7 @@ public void testBodyEndHandler() throws Exception {
     startServer();
     client.getNow(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, "/somepath", resp -> {
       Context ctx = vertx.getOrCreateContext();
+      resp.exceptionHandler(this::fail);
       resp.bodyHandler(body -> {
         assertOnIOContext(ctx);
         assertEquals(expected, body);

File: src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
Patch:
@@ -401,7 +401,8 @@ protected JsonObject getConfiguration() {
         try {
           conf = new JsonObject(config);
         } catch (DecodeException e2) {
-          log.error("-conf option does not point to a file and is not valid JSON: " + config);
+          // The configuration is not printed for security purpose, it can contain sensitive data.
+          log.error("The -conf option does not point to an existing file or is not a valid JSON object");
           return null;
         }
       }

File: src/main/java/io/vertx/core/http/impl/Http2ConnectionBase.java
Patch:
@@ -239,7 +239,9 @@ public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int stream
   @Override
   public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) {
     VertxHttp2Stream req = streams.get(streamId);
-    req.handleReset(errorCode);
+    context.executeFromIO(() -> {
+      req.handleReset(errorCode);
+    });
   }
 
   @Override

File: src/main/java/io/vertx/core/http/HttpConnection.java
Patch:
@@ -35,7 +35,6 @@
  * - add rawMethod
  * - byte distribution algorithm configurability (options ? connection ?)
  * - netSocket() interaction are not exactly the same than with http/1.x : see if we can make is the same
- * - run HttpTest with HTTP2
  * - handle data frame padding
  * - documentation
  * - examples

File: src/main/java/io/vertx/core/http/impl/Http2ServerRequestImpl.java
Patch:
@@ -431,12 +431,12 @@ public MultiMap formAttributes() {
 
   @Override
   public ServerWebSocket upgrade() {
-    throw new UnsupportedOperationException();
+    throw new UnsupportedOperationException("HTTP/2 request cannot be upgraded to a websocket");
   }
 
   @Override
   public boolean isEnded() {
-    throw new UnsupportedOperationException();
+    return ended;
   }
 
   @Override

File: src/test/java/io/vertx/test/core/ClusteredEventBusWithSSLTest.java
Patch:
@@ -78,7 +78,7 @@ public static Iterable<Object[]> data() {
         {KeyCert.PEM, Trust.JKS, false, false, false, Collections.emptyList()},
         {KeyCert.PKCS12_CA, Trust.JKS_CA, false, false, false, Collections.emptyList()},
         {KeyCert.PEM_CA, Trust.PKCS12_CA, false, false, false, Collections.emptyList()},
-        {KeyCert.JKS, Trust.PEM_CA, false, true, false, Arrays.asList(HttpTest.ENABLED_CIPHER_SUITES)},
+        {KeyCert.JKS, Trust.PEM_CA, false, true, false, Arrays.asList(Http1xTest.ENABLED_CIPHER_SUITES)},
     });
   }
 

File: src/main/java/io/vertx/core/http/HttpConnection.java
Patch:
@@ -42,7 +42,6 @@
  * - HttpConnection test
  * - compression
  * - handle 100 continue automatically
- * - invalid server response headers (like status = XYZ instead of number)
  *
  * Both:
  * - byte distribution algorithm configurability (options ? connection ?)

File: src/main/java/io/vertx/core/http/HttpConnection.java
Patch:
@@ -36,6 +36,7 @@
  * - HttpServerRequest#peerCertificateChain
  *
  * HttpClient:
+ * - stream error handling
  * - test executeFromIO
  * - metrics
  * - HttpConnection test

File: src/test/java/io/vertx/test/core/Http2ServerTest.java
Patch:
@@ -1296,12 +1296,12 @@ public void testStreamError() throws Exception {
       request.context.flush();
       when.setHandler(ar -> {
         // Send a corrupted frame on purpose to check we get the corresponding error in the request exception handler
-        // the error is : greater padding value 0x -> 1F
+        // the error is : greater padding value 0c -> 1F
         // ChannelFuture a = encoder.frameWriter().writeData(request.context, id, Buffer.buffer("hello").getByteBuf(), 12, false, request.context.newPromise());
         // normal frame    : 00 00 12 00 08 00 00 00 03 0c 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 00
         // corrupted frame : 00 00 12 00 08 00 00 00 03 1F 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 00
         request.channel.write(Buffer.buffer(new byte[]{
-            0x00, 0x00, 0x12, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x1F, 0x68, 0x65, 0x6c, 0x6c,
+            0x00, 0x00, 0x12, 0x00, 0x08, 0x00, 0x00, 0x00, (byte)(id & 0xFF), 0x1F, 0x68, 0x65, 0x6c, 0x6c,
             0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
         }).getByteBuf());
         request.context.flush();
@@ -1329,7 +1329,7 @@ public void testPromiseStreamError() throws Exception {
         resp.setChunked(true).write("whatever"); // Transition to half-closed remote
       });
     });
-    startServer(ctx);;
+    startServer(ctx);
     TestClient client = new TestClient();
     ChannelFuture fut = client.connect(4043, "localhost", request -> {
       request.decoder.frameListener(new Http2EventAdapter() {

File: src/main/java/io/vertx/core/http/impl/Http2Pool.java
Patch:
@@ -172,9 +172,10 @@ public void writeHeadWithContent(HttpMethod method, String uri, MultiMap headers
       h.scheme("https");
       encoder.writeHeaders(handlerCtx, stream.id(), h, 0, end && buf == null, handlerCtx.newPromise());
       if (buf != null) {
-        encoder.writeData(handlerCtx, stream.id(), buf, 0, end, handlerCtx.newPromise());
+        writeBuffer(buf, end);
+      } else {
+        handlerCtx.flush();
       }
-      handlerCtx.flush();
     }
     @Override
     public void writeBuffer(ByteBuf buf, boolean end) {

File: src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java
Patch:
@@ -25,4 +25,6 @@ abstract class VertxHttp2Stream {
 
   abstract void handleReset(long code);
 
+  abstract void handleError(Throwable cause);
+
 }

File: src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -249,7 +249,7 @@ public synchronized NetSocket upgradeToSsl(final Handler<Void> handler) {
     SslHandler sslHandler = channel.pipeline().get(SslHandler.class);
     if (sslHandler == null) {
       sslHandler = helper.createSslHandler(vertx, client);
-      channel.pipeline().addFirst(sslHandler);
+      channel.pipeline().addFirst("ssl", sslHandler);
     }
     sslHandler.handshakeFuture().addListener(future -> context.executeFromIO(() -> {
       if (future.isSuccess()) {

File: src/test/java/io/vertx/core/logging/Recording.java
Patch:
@@ -71,7 +71,8 @@ public void terminate() {
 
   public String execute(Runnable runnable) {
     start();
-    System.err.print("verification message");
+    System.err.print("verification message 1");
+    java.util.logging.Logger.getLogger("the-logger").info("verification message 2");
     runnable.run();
     String result = get();
     stop();

File: src/test/java/io/vertx/core/logging/Recording.java
Patch:
@@ -42,7 +42,7 @@ public void start() {
     System.setErr(new PrintStream(error) {
       @Override
       public void write(byte[] buf, int off, int len) {
-        System.out.println("FOO LOGGED " + new String(buf, off, len));
+        System.out.println("Logged on System.err " + new String(buf, off, len));
         super.write(buf, off, len);
       }
     });
@@ -71,6 +71,7 @@ public void terminate() {
 
   public String execute(Runnable runnable) {
     start();
+    System.err.print("verification message");
     runnable.run();
     String result = get();
     stop();

File: src/test/java/io/vertx/core/logging/Recording.java
Patch:
@@ -74,7 +74,7 @@ public void execute(Runnable runnable, Predicate<String> predicate) {
     long now = System.currentTimeMillis();
     StringBuilder acc = new StringBuilder(get());
     while (!predicate.test(acc.toString())) {
-      Assert.assertTrue("Was not expecting this output " + acc, System.currentTimeMillis() - now < 5000);
+      Assert.assertTrue(System.currentTimeMillis() - now < 5000);
       try {
         Thread.sleep(1);
       } catch (InterruptedException e) {

File: src/test/java/io/vertx/core/logging/Recording.java
Patch:
@@ -74,7 +74,7 @@ public void execute(Runnable runnable, Predicate<String> predicate) {
     long now = System.currentTimeMillis();
     StringBuilder acc = new StringBuilder(get());
     while (!predicate.test(acc.toString())) {
-      Assert.assertTrue(System.currentTimeMillis() - now < 5000);
+      Assert.assertTrue("Was not expecting this output " + acc, System.currentTimeMillis() - now < 5000);
       try {
         Thread.sleep(1);
       } catch (InterruptedException e) {

File: src/test/java/io/vertx/test/core/DatagramTest.java
Patch:
@@ -400,7 +400,7 @@ public void testOptions() {
     rand = 23;
     assertEquals(options, options.setTrafficClass(rand));
     assertEquals(rand, options.getTrafficClass());
-    assertIllegalArgumentException(() -> options.setTrafficClass(-1));
+    assertIllegalArgumentException(() -> options.setTrafficClass(-2));
     assertIllegalArgumentException(() -> options.setTrafficClass(256));
 
     assertFalse(options.isBroadcast());

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -427,7 +427,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
           if (future.isSuccess()) {
             connected(ch, handler);
           } else {
-            log.error("Client from origin " + ch.remoteAddress() + " failed to connect over ssl");
+            log.error("Client from origin " + ch.remoteAddress() + " failed to connect over ssl: " + future.cause());
           }
         });
       } else {

File: src/main/java/io/vertx/core/net/NetworkOptions.java
Patch:
@@ -100,7 +100,7 @@ public int getSendBufferSize() {
    * @return a reference to this, so the API can be used fluently
    */
   public NetworkOptions setSendBufferSize(int sendBufferSize) {
-    Arguments.require(sendBufferSize > 0, "sendBufferSize must be > 0");
+    Arguments.require(sendBufferSize > 0  || sendBufferSize == DEFAULT_SEND_BUFFER_SIZE, "sendBufferSize must be > 0");
     this.sendBufferSize = sendBufferSize;
     return this;
   }
@@ -121,7 +121,7 @@ public int getReceiveBufferSize() {
    * @return a reference to this, so the API can be used fluently
    */
   public NetworkOptions setReceiveBufferSize(int receiveBufferSize) {
-    Arguments.require(receiveBufferSize > 0, "receiveBufferSize must be > 0");
+    Arguments.require(receiveBufferSize > 0 || receiveBufferSize == DEFAULT_RECEIVE_BUFFER_SIZE, "receiveBufferSize must be > 0");
     this.receiveBufferSize = receiveBufferSize;
     return this;
   }
@@ -157,7 +157,7 @@ public int getTrafficClass() {
    * @return a reference to this, so the API can be used fluently
    */
   public NetworkOptions setTrafficClass(int trafficClass) {
-    Arguments.requireInRange(trafficClass, 0, 255, "trafficClass tc must be 0 <= tc <= 255");
+    Arguments.requireInRange(trafficClass, DEFAULT_TRAFFIC_CLASS, 255, "trafficClass tc must be 0 <= tc <= 255");
     this.trafficClass = trafficClass;
     return this;
   }

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -173,7 +173,7 @@ public int getSoLinger() {
    * @return a reference to this, so the API can be used fluently
    */
   public TCPSSLOptions setSoLinger(int soLinger) {
-    if (soLinger < 0) {
+    if (soLinger < 0  && soLinger != DEFAULT_SO_LINGER) {
       throw new IllegalArgumentException("soLinger must be >= 0");
     }
     this.soLinger = soLinger;

File: src/main/java/io/vertx/core/impl/FileResolver.java
Patch:
@@ -23,7 +23,6 @@
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URL;
-import java.net.URLClassLoader;
 import java.net.URLDecoder;
 import java.nio.file.FileAlreadyExistsException;
 import java.nio.file.Files;
@@ -57,7 +56,7 @@ public class FileResolver {
 
   private static final String DEFAULT_CACHE_DIR_BASE = ".vertx";
   private static final String FILE_SEP = System.getProperty("file.separator");
-  private static boolean NON_UNIX_FILE_SEP = !FILE_SEP.equals("/");
+  private static final boolean NON_UNIX_FILE_SEP = !FILE_SEP.equals("/");
   private static final boolean ENABLE_CACHING = !Boolean.getBoolean(DISABLE_FILE_CACHING_PROP_NAME);
   private static final boolean ENABLE_CP_RESOLVING = !Boolean.getBoolean(DISABLE_CP_RESOLVING_PROP_NAME);
   private static final String CACHE_DIR_BASE = System.getProperty(CACHE_DIR_BASE_PROP_NAME, DEFAULT_CACHE_DIR_BASE);

File: src/main/java/io/vertx/core/Future.java
Patch:
@@ -206,7 +206,7 @@ default Handler<AsyncResult<T>> completer() {
       if (ar.succeeded()) {
         complete(ar.result());
       } else {
-        ar.failed();
+        fail(ar.cause());
       }
     };
   }

File: src/test/java/io/vertx/test/core/NestedJarFileResolverTest.java
Patch:
@@ -30,17 +30,17 @@ public class NestedJarFileResolverTest extends FileResolverTestBase {
   public void setUp() throws Exception {
     super.setUp();
     // This is inside the jar webroot3.jar
-    webRoot = "webroot3";
+    webRoot = "webroot4";
 
     prevCL = Thread.currentThread().getContextClassLoader();
-    URL webroot3URL = prevCL.getResource("webroot3.jar");
+    URL webroot3URL = prevCL.getResource("webroot4.jar");
     ClassLoader loader = new ClassLoader(prevCL = Thread.currentThread().getContextClassLoader()) {
       @Override
       public URL getResource(String name) {
         try {
           if (name.startsWith("lib/")) {
             return new URL("jar:" + webroot3URL + "!/" + name);
-          } else if (name.startsWith("webroot3")) {
+          } else if (name.startsWith("webroot4")) {
             return new URL("jar:" + webroot3URL + "!/lib/nested.jar!/" + name.substring(7));
           }
         } catch (MalformedURLException e) {

File: src/main/java/io/vertx/core/CompositeFuture.java
Patch:
@@ -70,7 +70,7 @@ static <T1, T2, T3, T4, T5, T6> CompositeFuture all(Future<T1> f1, Future<T2> f2
   }
 
   /**
-   * Like {@link #all(Future, Future)} but with list of futures.
+   * Like {@link #all(Future, Future)} but with a list of futures.
    */
   static CompositeFuture all(List<Future> futures) {
     return CompositeFutureImpl.all(futures.toArray(new Future[futures.size()]));
@@ -116,7 +116,7 @@ static <T1, T2, T3, T4, T5, T6> CompositeFuture any(Future<T1> f1, Future<T2> f2
   }
 
   /**
-   * Like {@link #any(Future, Future)} but with 6 futures.
+   * Like {@link #any(Future, Future)} but with a list of futures.
    */
   static CompositeFuture any(List<Future> futures) {
     return CompositeFutureImpl.any(futures.toArray(new Future[futures.size()]));

File: src/main/java/docoverride/verticles/package-info.java
Patch:
@@ -90,12 +90,12 @@
  *     // Do something
  *   }
  *
- *   public void stop(Future<Void> startFuture) {
+ *   public void stop(Future<Void> stopFuture) {
  *     obj.doSomethingThatTakesTime(res -> {
  *       if (res.succeeded()) {
- *         startFuture.complete();
+ *         stopFuture.complete();
  *       } else {
- *         startFuture.fail();
+ *         stopFuture.fail();
  *       }
  *     });
  *   }

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -598,7 +598,7 @@ private synchronized void connect() {
             connect();
           }
         }
-      }, exceptionHandler, vertx.getOrCreateContext(), () -> {
+      }, exceptionHandler, vertx.getContext(), () -> {
         // No need to synchronize as the thread is the same that set exceptionOccurred to true
         // exceptionOccurred=true getting the connection => it's a TimeoutException
         return exceptionOccurred;

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -199,7 +199,8 @@ protected void initChannel(Channel ch) throws Exception {
               if (USE_FLASH_POLICY_HANDLER) {
                 pipeline.addLast("flashpolicy", new FlashPolicyHandler());
               }
-              pipeline.addLast("httpDecoder", new HttpRequestDecoder(4096, 8192, options.getMaxChunkSize(), false));
+              pipeline.addLast("httpDecoder", new HttpRequestDecoder(options.getMaxInitialLineLength()
+            		  						, options.getMaxHeaderSize(), options.getMaxChunkSize(), false));
               pipeline.addLast("httpEncoder", new VertxHttpResponseEncoder());
               if (options.isCompressionSupported()) {
                 pipeline.addLast("deflater", new HttpChunkContentCompressor());

File: src/main/java/io/vertx/core/parsetools/package-info.java
Patch:
@@ -18,7 +18,7 @@
  * == Record Parser
  *
  * The record parser allows you to easily parse protocols which are delimited by a sequence of bytes, or fixed
- * size records. It transforms an sequence of input buffer to a sequence of buffer structured as configured (either
+ * size records. It transforms a sequence of input buffer to a sequence of buffer structured as configured (either
  * fixed size or separated records).
  *
  * For example, if you have a simple ASCII text protocol delimited by '\n' and the input is the following:

File: src/main/java/io/vertx/core/streams/package-info.java
Patch:
@@ -155,8 +155,6 @@
  * A pump can be started and stopped multiple times.
  *
  * When a pump is first created it is _not_ started. You need to call the `start()` method to start it.
- *
- * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
 @Document(fileName = "streams.adoc")
 package io.vertx.core.streams;

File: src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -598,7 +598,7 @@ private synchronized void connect() {
             connect();
           }
         }
-      }, exceptionHandler, vertx.getOrCreateContext(), () -> {
+      }, exceptionHandler, vertx.getContext(), () -> {
         // No need to synchronize as the thread is the same that set exceptionOccurred to true
         // exceptionOccurred=true getting the connection => it's a TimeoutException
         return exceptionOccurred;

File: src/main/java/docoverride/verticles/package-info.java
Patch:
@@ -90,12 +90,12 @@
  *     // Do something
  *   }
  *
- *   public void stop(Future<Void> startFuture) {
+ *   public void stop(Future<Void> stopFuture) {
  *     obj.doSomethingThatTakesTime(res -> {
  *       if (res.succeeded()) {
- *         startFuture.complete();
+ *         stopFuture.complete();
  *       } else {
- *         startFuture.fail();
+ *         stopFuture.fail();
  *       }
  *     });
  *   }

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -508,7 +508,7 @@
  *
  * By default compression is not enabled.
  *
- * When HTTP compression is enabled the server will check if the client incldes an `Accept-Encoding` header which
+ * When HTTP compression is enabled the server will check if the client includes an `Accept-Encoding` header which
  * includes the supported compressions. Commonly used are deflate and gzip. Both are supported by Vert.x.
  *
  * If such a header is found the server will automatically compress the body of the response with one of the supported
@@ -1012,8 +1012,8 @@
  * ===== The server WebSocket
  *
  * The {@link io.vertx.core.http.ServerWebSocket} instance enables you to retrieve the {@link io.vertx.core.http.ServerWebSocket#headers() headers},
- * {@link io.vertx.core.http.ServerWebSocket#path()} path}, {@link io.vertx.core.http.ServerWebSocket#query() query} and
- * {@link io.vertx.core.http.ServerWebSocket#uri()} URI} of the HTTP request of the WebSocket handshake.
+ * {@link io.vertx.core.http.ServerWebSocket#path() path}, {@link io.vertx.core.http.ServerWebSocket#query() query} and
+ * {@link io.vertx.core.http.ServerWebSocket#uri() URI} of the HTTP request of the WebSocket handshake.
  *
  * ==== WebSockets on the client
  *

File: src/main/java/io/vertx/core/parsetools/package-info.java
Patch:
@@ -18,7 +18,7 @@
  * == Record Parser
  *
  * The record parser allows you to easily parse protocols which are delimited by a sequence of bytes, or fixed
- * size records. It transforms an sequence of input buffer to a sequence of buffer structured as configured (either
+ * size records. It transforms a sequence of input buffer to a sequence of buffer structured as configured (either
  * fixed size or separated records).
  *
  * For example, if you have a simple ASCII text protocol delimited by '\n' and the input is the following:

File: src/main/java/io/vertx/core/streams/package-info.java
Patch:
@@ -155,8 +155,6 @@
  * A pump can be started and stopped multiple times.
  *
  * When a pump is first created it is _not_ started. You need to call the `start()` method to start it.
- *
- * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
 @Document(fileName = "streams.adoc")
 package io.vertx.core.streams;

File: src/main/java/docoverride/verticles/package-info.java
Patch:
@@ -90,12 +90,12 @@
  *     // Do something
  *   }
  *
- *   public void stop(Future<Void> startFuture) {
+ *   public void stop(Future<Void> stopFuture) {
  *     obj.doSomethingThatTakesTime(res -> {
  *       if (res.succeeded()) {
- *         startFuture.complete();
+ *         stopFuture.complete();
  *       } else {
- *         startFuture.fail();
+ *         stopFuture.fail();
  *       }
  *     });
  *   }

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -508,7 +508,7 @@
  *
  * By default compression is not enabled.
  *
- * When HTTP compression is enabled the server will check if the client incldes an `Accept-Encoding` header which
+ * When HTTP compression is enabled the server will check if the client includes an `Accept-Encoding` header which
  * includes the supported compressions. Commonly used are deflate and gzip. Both are supported by Vert.x.
  *
  * If such a header is found the server will automatically compress the body of the response with one of the supported
@@ -1012,8 +1012,8 @@
  * ===== The server WebSocket
  *
  * The {@link io.vertx.core.http.ServerWebSocket} instance enables you to retrieve the {@link io.vertx.core.http.ServerWebSocket#headers() headers},
- * {@link io.vertx.core.http.ServerWebSocket#path()} path}, {@link io.vertx.core.http.ServerWebSocket#query() query} and
- * {@link io.vertx.core.http.ServerWebSocket#uri()} URI} of the HTTP request of the WebSocket handshake.
+ * {@link io.vertx.core.http.ServerWebSocket#path() path}, {@link io.vertx.core.http.ServerWebSocket#query() query} and
+ * {@link io.vertx.core.http.ServerWebSocket#uri() URI} of the HTTP request of the WebSocket handshake.
  *
  * ==== WebSockets on the client
  *

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -260,7 +260,7 @@
  * In a perfect world, there will be no war or hunger, all APIs will be written asynchronously and bunny rabbits will
  * skip hand-in-hand with baby lambs across sunny green meadows.
  *
- * *But.. the real world is not like that. (Have you watched the news lately?)*
+ * *But... the real world is not like that. (Have you watched the news lately?)*
  *
  * Fact is, many, if not most libraries, especially in the JVM ecosystem have synchronous APIs and many of the methods are
  * likely to block. A good example is the JDBC API - it's inherently synchronous, and no matter how hard it tries, Vert.x

File: src/main/java/io/vertx/core/parsetools/package-info.java
Patch:
@@ -18,7 +18,7 @@
  * == Record Parser
  *
  * The record parser allows you to easily parse protocols which are delimited by a sequence of bytes, or fixed
- * size records. It transforms an sequence of input buffer to a sequence of buffer structured as configured (either
+ * size records. It transforms a sequence of input buffer to a sequence of buffer structured as configured (either
  * fixed size or separated records).
  *
  * For example, if you have a simple ASCII text protocol delimited by '\n' and the input is the following:

File: src/main/java/io/vertx/core/streams/package-info.java
Patch:
@@ -155,8 +155,6 @@
  * A pump can be started and stopped multiple times.
  *
  * When a pump is first created it is _not_ started. You need to call the `start()` method to start it.
- *
- * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
 @Document(fileName = "streams.adoc")
 package io.vertx.core.streams;

File: src/main/java/io/vertx/core/http/impl/ConnectionLifeCycleListener.java
Patch:
@@ -23,7 +23,7 @@ public interface ConnectionLifeCycleListener {
 
   void requestEnded(ClientConnection conn);
 
-  void responseEnded(ClientConnection conn);
+  void responseEnded(ClientConnection conn, boolean close);
 
   void connectionClosed(ClientConnection conn);
 }

File: src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -28,7 +28,6 @@
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BooleanSupplier;
 
 /**
@@ -122,8 +121,8 @@ public synchronized void requestEnded(ClientConnection conn) {
     }
 
     // Called when the response has ended
-    public synchronized void responseEnded(ClientConnection conn) {
-      if (pipelining || keepAlive) {
+    public synchronized void responseEnded(ClientConnection conn, boolean close) {
+      if ((pipelining || keepAlive) && !close) {
         Waiter waiter = getNextWaiter();
         if (waiter != null) {
           waiter.context.runOnContext(v -> waiter.handler.handle(conn));

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -174,7 +174,7 @@ private synchronized AsyncFile doWrite(Buffer buffer, long position, Handler<Asy
   }
 
   @Override
-  public AsyncFile write(Buffer buffer) {
+  public synchronized AsyncFile write(Buffer buffer) {
     int length = buffer.length();
     doWrite(buffer, writePos, null);
     writePos += length;

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1076,7 +1076,7 @@
  * Log4J or SLF4J.
  *
  * To do this you should set a system property called `vertx.logger-delegate-factory-class-name` with the name of a Java
- * class which implements the interface {@link io.vertx.core.logging.LoggerFactory}. We provide pre-built implementations for
+ * class which implements the interface {@link io.vertx.core.spi.logging.LogDelegateFactory}. We provide pre-built implementations for
  * Log4J and SLF4J with the class names `io.vertx.core.logging.Log4jLogDelegateFactory` and `io.vertx.core.logging.SLF4JLogDelegateFactory`
  * respectively. If you want to use these implementations you should also make sure the relevant Log4J or SLF4J jars
  * are on your classpath.

File: src/main/java/io/vertx/core/buffer/Buffer.java
Patch:
@@ -511,6 +511,7 @@ static Buffer buffer(ByteBuf byteBuf) {
 
   /**
    * Returns the Buffer as a Netty {@code ByteBuf}.<p>
+   * The returned buffer is a duplicate.<p>
    * This method is meant for internal use only.
    */
   @GenIgnore

File: src/main/java/io/vertx/core/http/impl/HttpServerRequestImpl.java
Patch:
@@ -364,7 +364,7 @@ void handleData(Buffer data) {
     synchronized (conn) {
       if (decoder != null) {
         try {
-          decoder.offer(new DefaultHttpContent(data.getByteBuf().duplicate()));
+          decoder.offer(new DefaultHttpContent(data.getByteBuf()));
         } catch (HttpPostRequestDecoder.ErrorDataDecoderException e) {
           handleException(e);
         }

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1076,7 +1076,7 @@
  * Log4J or SLF4J.
  *
  * To do this you should set a system property called `vertx.logger-delegate-factory-class-name` with the name of a Java
- * class which implements the interface {@link io.vertx.core.logging.LoggerFactory}. We provide pre-built implementations for
+ * class which implements the interface {@link io.vertx.core.spi.logging.LogDelegateFactory}. We provide pre-built implementations for
  * Log4J and SLF4J with the class names `io.vertx.core.logging.Log4jLogDelegateFactory` and `io.vertx.core.logging.SLF4JLogDelegateFactory`
  * respectively. If you want to use these implementations you should also make sure the relevant Log4J or SLF4J jars
  * are on your classpath.

File: src/main/java/io/vertx/core/http/impl/ConnectionLifeCycleListener.java
Patch:
@@ -21,9 +21,9 @@
  */
 public interface ConnectionLifeCycleListener {
 
-  void requestEnded(ClientConnection conn, boolean available);
+  void requestEnded(ClientConnection conn);
 
-  void responseEnded(ClientConnection conn, boolean available);
+  void responseEnded(ClientConnection conn);
 
   void connectionClosed(ClientConnection conn);
 }

File: src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -170,7 +170,7 @@ private synchronized AsyncFile doWrite(Buffer buffer, long position, Handler<Asy
   }
 
   @Override
-  public AsyncFile write(Buffer buffer) {
+  public synchronized AsyncFile write(Buffer buffer) {
     int length = buffer.length();
     doWrite(buffer, writePos, null);
     writePos += length;

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -188,7 +188,7 @@ private DatagramSocket listen(SocketAddress local, Handler<AsyncResult<DatagramS
     ChannelFuture future = channel().bind(is);
     addListener(future, ar -> {
       if (ar.succeeded()) {
-        ((DatagramSocketMetrics) metrics).listening(localAddress());
+        ((DatagramSocketMetrics) metrics).listening(local);
       }
       handler.handle(ar);
     });

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -188,7 +188,7 @@ private DatagramSocket listen(SocketAddress local, Handler<AsyncResult<DatagramS
     ChannelFuture future = channel().bind(is);
     addListener(future, ar -> {
       if (ar.succeeded()) {
-        ((DatagramSocketMetrics) metrics).listening(localAddress());
+        ((DatagramSocketMetrics) metrics).listening(local);
       }
       handler.handle(ar);
     });

File: src/main/java/io/vertx/core/http/impl/ConnectionLifeCycleListener.java
Patch:
@@ -21,9 +21,9 @@
  */
 public interface ConnectionLifeCycleListener {
 
-  void requestEnded(ClientConnection conn);
+  void requestEnded(ClientConnection conn, boolean available);
 
-  void responseEnded(ClientConnection conn);
+  void responseEnded(ClientConnection conn, boolean available);
 
   void connectionClosed(ClientConnection conn);
 }

File: src/main/java/io/vertx/core/impl/launcher/ServiceCommandFactoryLoader.java
Patch:
@@ -33,10 +33,11 @@ public class ServiceCommandFactoryLoader implements CommandFactoryLookup {
   private ServiceLoader<CommandFactory> loader;
 
   /**
-   * Creates a new instance of {@link ServiceCommandFactoryLoader} using the default classloader.
+   * Creates a new instance of {@link ServiceCommandFactoryLoader} using the classloader having loaded the
+   * {@link ServiceCommandFactoryLoader} class.
    */
   public ServiceCommandFactoryLoader() {
-    this.loader = ServiceLoader.load(CommandFactory.class, null);
+    this.loader = ServiceLoader.load(CommandFactory.class, getClass().getClassLoader());
   }
 
   /**

File: src/main/java/io/vertx/core/impl/launcher/VertxCommandLauncher.java
Patch:
@@ -94,7 +94,8 @@ public List<Command> getCommands() {
   }
 
   /**
-   * Creates a new {@link VertxCommandLauncher} using the default {@link ServiceCommandFactoryLoader}.
+   * Creates a new {@link VertxCommandLauncher} using the default {@link ServiceCommandFactoryLoader}. It uses the
+   * classloader having loaded {@link ServiceCommandFactoryLoader}.
    */
   public VertxCommandLauncher() {
     this(Collections.singletonList(new ServiceCommandFactoryLoader()));

File: src/test/java/io/vertx/test/fakemetrics/FakeVertxMetrics.java
Patch:
@@ -132,7 +132,7 @@ public void close() {
   }
 
   public DatagramSocketMetrics createMetrics(DatagramSocket socket, DatagramSocketOptions options) {
-    throw new UnsupportedOperationException();
+    return new FakeDatagramSocketMetrics(socket);
   }
 
   public boolean isEnabled() {

File: src/main/java/io/vertx/core/metrics/impl/DummyVertxMetrics.java
Patch:
@@ -119,7 +119,7 @@ public void messageRead(String address, int numberOfBytes) {
     }
 
     @Override
-    public Void handlerRegistered(String address, boolean replyHandler) {
+    public Void handlerRegistered(String address, String repliedAddress) {
       return null;
     }
 

File: src/main/java/io/vertx/core/spi/metrics/EventBusMetrics.java
Patch:
@@ -31,9 +31,9 @@ public interface EventBusMetrics<H> extends Metrics {
    * No specific thread and context can be expected when this method is called.
    *
    * @param address the address used to register the handler
-   * @param replyHandler true when the handler is a reply handler
+   * @param repliedAddress null when the handler is not a reply handler, otherwise the address this handler is replying to
    */
-  H handlerRegistered(String address, boolean replyHandler);
+  H handlerRegistered(String address, String repliedAddress);
 
   /**
    * Called when a handler has been unregistered from the event bus.<p/>

File: src/test/java/io/vertx/test/core/MetricsContextTest.java
Patch:
@@ -816,7 +816,7 @@ public boolean isEnabled() {
             return true;
           }
           @Override
-          public Void handlerRegistered(String address, boolean replyHandler) {
+          public Void handlerRegistered(String address, String repliedAddress) {
             registeredCalled.set(true);
             return null;
           }

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -170,6 +170,9 @@ private void createAndStartEventBus(VertxOptions options, Handler<AsyncResult<Ve
     eventBus.start(ar2 -> {
       if (ar2.succeeded()) {
         if (resultHandler != null) {
+          // If the metric provider wants to use the event bus, it cannot use it in its constructor as the event bus
+          // may not be initialized yet. We invokes the eventBusInitialized so it can starts using the event bus.
+          metrics.eventBusInitialized(eventBus);
           resultHandler.handle(Future.succeededFuture(this));
         }
       } else {

File: src/main/java/io/vertx/core/impl/launcher/commands/ExecUtils.java
Patch:
@@ -72,7 +72,7 @@ public static String quoteArgument(final String argument) {
   }
 
   /**
-   * Adds an argument to the given list. It automatially add quotes to the argument if necessary.
+   * Adds an argument to the given list. It automatically adds quotes to the argument if necessary.
    *
    * @param args the list of arguments
    * @param argument the argument to add

File: src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
Patch:
@@ -312,7 +312,7 @@ protected void startAsBackgroundApplication(Handler<Void> onCompletion) {
       args.add("--classpath=" + classpath.stream().collect(Collectors.joining(File.pathSeparator)));
     }
     if (config != null) {
-      args.add("--config=" + config);
+      args.add("--conf=" + config);
     }
     if (instances != 1) {
       args.add("--instances=" + instances);

File: src/test/java/io/vertx/test/core/FileResolverTestBase.java
Patch:
@@ -155,9 +155,9 @@ public void testResolveFileInSubDirectoryFromClasspath() throws Exception {
   public void testRecursivelyUnpack() throws Exception {
     File file = resolver.resolveFile(webRoot + "/subdir");
     assertTrue(file.exists());
-    File sub = new File(new File(file, "subdir2"), "subfile2.html");
+    File sub = new File(file, "subfile.html");
     assertTrue(sub.exists());
-    assertEquals("<html><body>subfile2</body></html>", readFile(sub));
+    assertEquals("<html><body>subfile</body></html>", readFile(sub));
   }
 
   @Test

File: src/main/java/io/vertx/core/impl/HAManager.java
Patch:
@@ -280,7 +280,7 @@ private synchronized void nodeLeft(String leftNodeID) {
       List<String> nodes = clusterManager.getNodes();
 
       for (Map.Entry<String, String> entry: clusterMap.entrySet()) {
-        if (!nodes.contains(entry.getKey())) {
+        if (!leftNodeID.equals(entry.getKey()) && !nodes.contains(entry.getKey())) {
           checkFailover(entry.getKey(), new JsonObject(entry.getValue()));
         }
       }

File: src/main/java/io/vertx/core/logging/Logger.java
Patch:
@@ -28,7 +28,7 @@
  * <p>
  * If you would prefer to use Log4J or SLF4J instead of JUL then you can set a system property called
  * {@code vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
- * For Log4J the value is {@code io.vertx.core.logging.impl.Log4JLogDelegateFactory}, for SLF4J the value
+ * For Log4J the value is {@code io.vertx.core.logging.Log4jLogDelegateFactory}, for SLF4J the value
  * is {@code io.vertx.core.logging.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
  * required by your favourite log framework are on your classpath.
  *

File: src/test/java/io/vertx/test/core/FileResolverTestBase.java
Patch:
@@ -155,9 +155,9 @@ public void testResolveFileInSubDirectoryFromClasspath() throws Exception {
   public void testRecursivelyUnpack() throws Exception {
     File file = resolver.resolveFile(webRoot + "/subdir");
     assertTrue(file.exists());
-    File sub = new File(new File(file, "subdir2"), "subfile2.html");
+    File sub = new File(file, "subfile.html");
     assertTrue(sub.exists());
-    assertEquals("<html><body>subfile2</body></html>", readFile(sub));
+    assertEquals("<html><body>subfile</body></html>", readFile(sub));
   }
 
   @Test

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -1015,10 +1015,10 @@
  *
  * [source]
  * ----
- * java jar target/my-fat-jar.jar redeploy="**&#47;*.java" --on-redeploy="mvn package"
+ * java jar target/my-fat-jar.jar redeploy="**&#47;*.java" --onRedeploy="mvn package"
  * ----
  *
- * The "on-redeploy" option specifies a command invoked after the shutdown of the application and before the
+ * The "onRedeploy" option specifies a command invoked after the shutdown of the application and before the
  * restart. So you can hook your build tool if it updates some runtime artifacts. For instance, you can launch `gulp`
  * or `grunt` to update your resources.
  *

File: src/main/java/io/vertx/core/impl/launcher/commands/Watcher.java
Patch:
@@ -269,7 +269,8 @@ private void executeUserCommand(Handler<Void> onCompletion) {
         } else {
           ExecUtils.addArgument(command, "sh");
           ExecUtils.addArgument(command, "-c");
-          ExecUtils.addArgument(command, cmd);
+          // Do not add quote to the given command:
+          command.add(cmd);
         }
 
         final Process process = new ProcessBuilder(command)

File: src/main/java/io/vertx/core/impl/HAManager.java
Patch:
@@ -280,7 +280,7 @@ private synchronized void nodeLeft(String leftNodeID) {
       List<String> nodes = clusterManager.getNodes();
 
       for (Map.Entry<String, String> entry: clusterMap.entrySet()) {
-        if (!nodes.contains(entry.getKey())) {
+        if (!leftNodeID.equals(entry.getKey()) && !nodes.contains(entry.getKey())) {
           checkFailover(entry.getKey(), new JsonObject(entry.getValue()));
         }
       }

File: src/test/java/io/vertx/core/impl/launcher/VertxCommandLineInterfaceTest.java
Patch:
@@ -159,7 +159,7 @@ public void testComplexCommandUsage() {
 
     assertThat(baos.toString())
         .contains("-o1 <opt>", " [-o2] ")
-        .contains("arg1 [arg2]")
+        .contains("arg1", "[arg2]")
         .contains("A command with options and arguments.") // Summary
         .contains("This is a complex command.") // Description
         .contains("-o1,--option1 <opt>") // Option

File: src/main/java/io/vertx/core/logging/Logger.java
Patch:
@@ -28,7 +28,7 @@
  * <p>
  * If you would prefer to use Log4J or SLF4J instead of JUL then you can set a system property called
  * {@code vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
- * For Log4J the value is {@code io.vertx.core.logging.impl.Log4JLogDelegateFactory}, for SLF4J the value
+ * For Log4J the value is {@code io.vertx.core.logging.Log4jLogDelegateFactory}, for SLF4J the value
  * is {@code io.vertx.core.logging.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
  * required by your favourite log framework are on your classpath.
  *

File: src/main/java/io/vertx/core/Launcher.java
Patch:
@@ -49,21 +49,21 @@ public static void main(String[] args) {
   }
 
   /**
-   * Hook for sub-classes of {@link Starter} before the vertx instance is started.
+   * Hook for sub-classes of {@link Launcher} before the vertx instance is started.
    */
   public void beforeStartingVertx(VertxOptions options) {
 
   }
 
   /**
-   * Hook for sub-classes of {@link Starter} after the vertx instance is started.
+   * Hook for sub-classes of {@link Launcher} after the vertx instance is started.
    */
   public void afterStartingVertx(Vertx vertx) {
 
   }
 
   /**
-   * Hook for sub-classes of {@link Starter} before the verticle is deployed.
+   * Hook for sub-classes of {@link Launcher} before the verticle is deployed.
    */
   public void beforeDeployingVerticle(DeploymentOptions deploymentOptions) {
 

File: src/test/java/io/vertx/test/core/LauncherTest.java
Patch:
@@ -526,6 +526,7 @@ public void assertHooksInvoked() {
       assertTrue(beforeStartingVertxInvoked);
       assertTrue(afterStartingVertxInvoked);
       assertTrue(beforeDeployingVerticle);
+      assertNotNull(vertx);
     }
   }
 

File: src/test/java/io/vertx/core/impl/launcher/DefaultCommandTest.java
Patch:
@@ -60,8 +60,9 @@ public void testSystemProperties() throws CLIException {
     assertThat(System.getProperty("x")).isEqualToIgnoringCase("y");
 
     command.tearDown();
-    assertThat(System.getProperty("foo")).isNull();
-    assertThat(System.getProperty("x")).isNull();
+    // System properties are not removed by the tearDown.
+    assertThat(System.getProperty("foo")).isEqualToIgnoringCase("bar");
+    assertThat(System.getProperty("x")).isEqualToIgnoringCase("y");
   }
 
 }
\ No newline at end of file

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -694,7 +694,9 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
       bootstrap.option(ChannelOption.SO_RCVBUF, options.getReceiveBufferSize());
       bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(options.getReceiveBufferSize()));
     }
-    bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    if (options.getSoLinger() != -1) {
+      bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    }
     if (options.getTrafficClass() != -1) {
       bootstrap.option(ChannelOption.IP_TOS, options.getTrafficClass());
     }

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -46,6 +46,8 @@ public interface VertxInternal extends Vertx {
 
   EventLoopGroup getEventLoopGroup();
 
+  EventLoopGroup getAcceptorEventLoopGroup();
+
   ExecutorService getWorkerPool();
 
   Map<ServerID, HttpServerImpl> sharedHttpServers();

File: src/main/java/io/vertx/core/net/NetServerOptions.java
Patch:
@@ -43,7 +43,7 @@ public class NetServerOptions extends TCPSSLOptions {
   /**
    * The default accept backlog = 1024
    */
-  public static final int DEFAULT_ACCEPT_BACKLOG = 1024;
+  public static final int DEFAULT_ACCEPT_BACKLOG = -1;
 
   /**
    * Default value of whether client auth is required (SSL/TLS) = false

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -137,7 +137,9 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
       bootstrap.option(ChannelOption.SO_RCVBUF, options.getReceiveBufferSize());
       bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(options.getReceiveBufferSize()));
     }
-    bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    if (options.getSoLinger() != -1) {
+      bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    }
     if (options.getTrafficClass() != -1) {
       bootstrap.option(ChannelOption.IP_TOS, options.getTrafficClass());
     }

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -258,7 +258,7 @@ public void testServerOptions() {
     assertEquals(options, options.setTrustStoreOptions(trustStoreOptions));
     assertEquals(trustStoreOptions, options.getTrustOptions());
 
-    assertEquals(1024, options.getAcceptBacklog());
+    assertEquals(-1, options.getAcceptBacklog());
     rand = TestUtils.randomPositiveInt();
     assertEquals(options, options.setAcceptBacklog(rand));
     assertEquals(rand, options.getAcceptBacklog());

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -246,7 +246,7 @@ public void testServerOptions() {
     assertEquals(options, options.setTrustStoreOptions(trustStoreOptions));
     assertEquals(trustStoreOptions, options.getTrustOptions());
 
-    assertEquals(1024, options.getAcceptBacklog());
+    assertEquals(-1, options.getAcceptBacklog());
     rand = TestUtils.randomPositiveInt();
     assertEquals(options, options.setAcceptBacklog(rand));
     assertEquals(rand, options.getAcceptBacklog());

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -694,7 +694,9 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
       bootstrap.option(ChannelOption.SO_RCVBUF, options.getReceiveBufferSize());
       bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(options.getReceiveBufferSize()));
     }
-    bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    if (options.getSoLinger() != -1) {
+      bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    }
     if (options.getTrafficClass() != -1) {
       bootstrap.option(ChannelOption.IP_TOS, options.getTrafficClass());
     }

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -46,6 +46,8 @@ public interface VertxInternal extends Vertx {
 
   EventLoopGroup getEventLoopGroup();
 
+  EventLoopGroup getAcceptorEventLoopGroup();
+
   ExecutorService getWorkerPool();
 
   Map<ServerID, HttpServerImpl> sharedHttpServers();

File: src/main/java/io/vertx/core/net/NetServerOptions.java
Patch:
@@ -43,7 +43,7 @@ public class NetServerOptions extends TCPSSLOptions {
   /**
    * The default accept backlog = 1024
    */
-  public static final int DEFAULT_ACCEPT_BACKLOG = 1024;
+  public static final int DEFAULT_ACCEPT_BACKLOG = -1;
 
   /**
    * Default value of whether client auth is required (SSL/TLS) = false

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -137,7 +137,9 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
       bootstrap.option(ChannelOption.SO_RCVBUF, options.getReceiveBufferSize());
       bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(options.getReceiveBufferSize()));
     }
-    bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    if (options.getSoLinger() != -1) {
+      bootstrap.option(ChannelOption.SO_LINGER, options.getSoLinger());
+    }
     if (options.getTrafficClass() != -1) {
       bootstrap.option(ChannelOption.IP_TOS, options.getTrafficClass());
     }

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -258,7 +258,7 @@ public void testServerOptions() {
     assertEquals(options, options.setTrustStoreOptions(trustStoreOptions));
     assertEquals(trustStoreOptions, options.getTrustOptions());
 
-    assertEquals(1024, options.getAcceptBacklog());
+    assertEquals(-1, options.getAcceptBacklog());
     rand = TestUtils.randomPositiveInt();
     assertEquals(options, options.setAcceptBacklog(rand));
     assertEquals(rand, options.getAcceptBacklog());

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -246,7 +246,7 @@ public void testServerOptions() {
     assertEquals(options, options.setTrustStoreOptions(trustStoreOptions));
     assertEquals(trustStoreOptions, options.getTrustOptions());
 
-    assertEquals(1024, options.getAcceptBacklog());
+    assertEquals(-1, options.getAcceptBacklog());
     rand = TestUtils.randomPositiveInt();
     assertEquals(options, options.setAcceptBacklog(rand));
     assertEquals(rand, options.getAcceptBacklog());

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -568,7 +568,7 @@ public JsonArray copy() {
    * @return a Stream
    */
   public Stream<Object> stream() {
-    return list.stream();
+    return Json.asStream(iterator());
   }
 
   @Override

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -718,7 +718,7 @@ public Map<String, Object> getMap() {
    * @return a stream of the entries.
    */
   public Stream<Map.Entry<String, Object>> stream() {
-    return map.entrySet().stream();
+    return Json.asStream(iterator());
   }
 
   /**

File: src/main/java/io/vertx/core/net/impl/HandlerManager.java
Patch:
@@ -76,7 +76,7 @@ public synchronized void removeHandler(Handler<T> handler, ContextImpl context)
     if (handlers.isEmpty()) {
       handlerMap.remove(worker);
     }
-    if (handlers.isEmpty()) {
+    if (handlerMap.isEmpty()) {
       hasHandlers = false;
     }
     //Available workers does it's own reference counting -since workers can be shared across different Handlers

File: src/main/java/io/vertx/core/cli/CommandLine.java
Patch:
@@ -121,7 +121,7 @@ static CommandLine create(CLI cli) {
    * Gets the raw value of the given option. Raw values are the values as given in the user command line.
    *
    * @param option the option
-   * @return the value, {@link null} if none.
+   * @return the value, {@code null} if none.
    */
   String getRawValueForOption(Option option);
 
@@ -137,7 +137,7 @@ static CommandLine create(CLI cli) {
    * Gets the raw value of the given argument. Raw values are the values as given in the user command line.
    *
    * @param arg the argument
-   * @return the value, {@link null} if none.
+   * @return the value, {@code null} if none.
    */
   String getRawValueForArgument(Argument arg);
 

File: src/main/java/io/vertx/core/cli/InvalidValueException.java
Patch:
@@ -69,7 +69,7 @@ public InvalidValueException(Option option, String value, Exception cause) {
   }
 
   /**
-   * @return the option, may be {@link null} if the exception is about an argument.
+   * @return the option, may be {@code null} if the exception is about an argument.
    */
   public Option getOption() {
     return option;
@@ -83,7 +83,7 @@ public String getValue() {
   }
 
   /**
-   * @return the argument, may be {@link null} if the exception is about an option.
+   * @return the argument, may be {@code null} if the exception is about an option.
    */
   public Argument getArgument() {
     return argument;

File: src/main/java/io/vertx/core/cli/MissingValueException.java
Patch:
@@ -51,14 +51,14 @@ public MissingValueException(Argument argument) {
   }
 
   /**
-   * @return the option, may be {@link null} if the exception is about an argument.
+   * @return the option, may be {@code null} if the exception is about an argument.
    */
   public Option getOption() {
     return option;
   }
 
   /**
-   * @return the argument, may be {@link null} if the exception is about an option.
+   * @return the argument, may be {@code null} if the exception is about an option.
    */
   public Argument getArgument() {
     return argument;

File: src/main/java/io/vertx/core/cli/Option.java
Patch:
@@ -225,7 +225,7 @@ public String getArgName() {
   /**
    * Sets te arg name for this option.
    *
-   * @param argName the arg name, must not be {@link null}
+   * @param argName the arg name, must not be {@code null}
    * @return the current {@link Option} instance
    */
   public Option setArgName(String argName) {

File: src/main/java/io/vertx/core/cli/TypedArgument.java
Patch:
@@ -55,7 +55,7 @@ public TypedArgument() {
   }
 
   /**
-   * @return the argument type, cannot be {@link null} for valid argument.
+   * @return the argument type, cannot be {@code null} for valid argument.
    */
   public Class<T> getType() {
     return type;

File: src/main/java/io/vertx/core/impl/launcher/commands/RunCommand.java
Patch:
@@ -224,7 +224,9 @@ private void stopBackgroundApplication(Handler<Void> onCompletion) {
   protected void startAsBackgroundApplication(Handler<Void> onCompletion) {
     // We need to copy all options and arguments.
     List<String> args = new ArrayList<>();
-    args.add("--vertx.id=" + vertxApplicationBackgroundId);
+    // Pre-prend the command.
+    args.add("run");
+    args.add("--vertx-id=" + vertxApplicationBackgroundId);
     args.addAll(executionContext.commandLine().allArguments());
     // No need to add the main-verticle as it's part of the allArguments list.
     if (cluster) {

File: src/main/java/io/vertx/core/json/JsonArray.java
Patch:
@@ -568,7 +568,7 @@ public JsonArray copy() {
    * @return a Stream
    */
   public Stream<Object> stream() {
-    return list.stream();
+    return Json.asStream(iterator());
   }
 
   @Override

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -718,7 +718,7 @@ public Map<String, Object> getMap() {
    * @return a stream of the entries.
    */
   public Stream<Map.Entry<String, Object>> stream() {
-    return map.entrySet().stream();
+    return Json.asStream(iterator());
   }
 
   /**

File: src/test/java/io/vertx/core/impl/launcher/commands/StartStopListCommandsTest.java
Patch:
@@ -84,7 +84,7 @@ public void testStartListStopWithJVMOptions() throws InterruptedException, IOExc
     record();
 
     cli.dispatch(new String[]{"start", "run", HttpTestVerticle.class.getName(),
-        "--launcher-class", Launcher.class.getName(), "--jvm-opts", "'-Dfoo=bar -Dbaz=bar'", "--redirect-output"});
+        "--launcher-class", Launcher.class.getName(), "--jvm-opts=-Dfoo=bar -Dbaz=bar", "--redirect-output"});
 
     waitForStartup();
     assertThat(output.toString()).contains("Starting vert.x application");
@@ -146,10 +146,8 @@ public void testStartListStopWithId() throws InterruptedException, IOException {
     cli.dispatch(new String[]{"start", "run", HttpTestVerticle.class.getName(),
         "--launcher-class", Launcher.class.getName(), "--vertx.id=hello"});
 
-
     waitForStartup();
 
-
     assertThat(output.toString()).contains("Starting vert.x application").contains("hello");
 
     output.reset();

File: src/test/java/io/vertx/core/impl/launcher/commands/ComplexCommand.java
Patch:
@@ -69,8 +69,8 @@ public void run() throws CLIException {
     out.println("Option 2 : " + option2);
     out.println("Arg 1 : " + arg1);
     out.println("Arg 2 : " + arg2);
-    if (executionContext.commandLine().getAllArguments().size() > 2) {
-      out.println("All args: " + executionContext.commandLine().getAllArguments());
+    if (executionContext.commandLine().allArguments().size() > 2) {
+      out.println("All args: " + executionContext.commandLine().allArguments());
     }
   }
 }

File: src/main/java/io/vertx/core/http/impl/HttpServerResponseImpl.java
Patch:
@@ -121,8 +121,8 @@ public String getStatusMessage() {
   @Override
   public HttpServerResponse setStatusMessage(String statusMessage) {
     synchronized (conn) {
-      this.statusMessage = statusMessage;
-      this.response.setStatus(new HttpResponseStatus(response.getStatus().code(), statusMessage));
+      this.statusMessage = statusMessage != null ? (statusMessage.replace("\r", "\\r").replace("\n", "\\n")) : null;
+      this.response.setStatus(new HttpResponseStatus(response.getStatus().code(), this.statusMessage));
       return this;
     }
   }

File: src/main/java/io/vertx/core/eventbus/EventBus.java
Patch:
@@ -73,7 +73,7 @@ public interface EventBus extends Measured {
    * @return a reference to this, so the API can be used fluently
    */
   @Fluent
-  <T> EventBus send(String address, Object message, DeliveryOptions options);
+  EventBus send(String address, Object message, DeliveryOptions options);
 
   /**
    * Like {@link #send(String, Object, DeliveryOptions)} but specifying a {@code replyHandler} that will be called if the recipient

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -140,7 +140,7 @@ public <T> EventBus send(String address, Object message, Handler<AsyncResult<Mes
   }
 
   @Override
-  public <T> EventBus send(String address, Object message, DeliveryOptions options) {
+  public EventBus send(String address, Object message, DeliveryOptions options) {
     return send(address, message, options, null);
   }
 

File: src/main/java/io/vertx/core/VertxOptions.java
Patch:
@@ -135,7 +135,7 @@ public class VertxOptions {
   private boolean haEnabled = DEFAULT_HA_ENABLED;
   private int quorumSize = DEFAULT_QUORUM_SIZE;
   private String haGroup = DEFAULT_HA_GROUP;
-  private MetricsOptions metrics;
+  private MetricsOptions metrics = new MetricsOptions();
   private long warningExceptionTime = DEFAULT_WARNING_EXECPTION_TIME;
 
   /**

File: src/test/java/io/vertx/test/core/VertxOptionsTest.java
Patch:
@@ -188,7 +188,7 @@ public void testOptions() {
     } catch (NullPointerException e) {
       // OK
     }
-    assertNull(options.getMetricsOptions());
+    assertNotNull(options.getMetricsOptions());
 
     try {
       options.setWarningExceptionTime(-1);
@@ -305,7 +305,7 @@ public void testJsonOptions() {
     assertFalse(options.isHAEnabled());
     assertEquals(1, options.getQuorumSize());
     assertEquals(VertxOptions.DEFAULT_HA_GROUP, options.getHAGroup());
-    assertNull(options.getMetricsOptions());
+    assertNotNull(options.getMetricsOptions());
     assertEquals(5000000000l, options.getWarningExceptionTime());
     int clusterPort = TestUtils.randomPortInt();
     int clusterPublicPort = TestUtils.randomPortInt();

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -880,7 +880,9 @@
  * For pooling to work, keep alive must be true using {@link io.vertx.core.http.HttpClientOptions#setKeepAlive(boolean)}
  * on the options used when configuring the client. The default value is true.
  *
- * When keep alive is enabled. Vert.x will add a `Connection: Keep-Alive` header to each HTTP request sent.
+ * When keep alive is enabled. Vert.x will add a `Connection: Keep-Alive` header to each HTTP/1.0 request sent.
+ * When keep alive is disabled. Vert.x will add a `Connection: Close` header to each HTTP/1.1 request sent to signal
+ * that the connection will be closed after completion of the response.
  *
  * The maximum number of connections to pool *for each server* is configured using {@link io.vertx.core.http.HttpClientOptions#setMaxPoolSize(int)}
  *

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -409,7 +409,7 @@ public void testClientOptionsJson() {
     int receiverBufferSize = TestUtils.randomPortInt();
     Random rand = new Random();
     boolean reuseAddress = rand.nextBoolean();
-    int trafficClass = TestUtils.randomByte() + 127;
+    int trafficClass = TestUtils.randomByte() + 128;
     boolean tcpNoDelay = rand.nextBoolean();
     boolean tcpKeepAlive = rand.nextBoolean();
     int soLinger = TestUtils.randomPositiveInt();
@@ -615,7 +615,7 @@ public void testServerOptionsJson() {
     int receiverBufferSize = TestUtils.randomPortInt();
     Random rand = new Random();
     boolean reuseAddress = rand.nextBoolean();
-    int trafficClass = TestUtils.randomByte() + 127;
+    int trafficClass = TestUtils.randomByte() + 128;
     boolean tcpNoDelay = rand.nextBoolean();
     boolean tcpKeepAlive = rand.nextBoolean();
     int soLinger = TestUtils.randomPositiveInt();

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -280,7 +280,7 @@ public void testCopyClientOptions() {
     int receiverBufferSize = TestUtils.randomPortInt();
     Random rand = new Random();
     boolean reuseAddress = rand.nextBoolean();
-    int trafficClass = TestUtils.randomByte() + 127;
+    int trafficClass = TestUtils.randomByte() + 128;
     boolean tcpNoDelay = rand.nextBoolean();
     boolean tcpKeepAlive = rand.nextBoolean();
     int soLinger = TestUtils.randomPositiveInt();
@@ -369,7 +369,7 @@ public void testClientOptionsJson() {
     int receiverBufferSize = TestUtils.randomPortInt();
     Random rand = new Random();
     boolean reuseAddress = rand.nextBoolean();
-    int trafficClass = TestUtils.randomByte() + 127;
+    int trafficClass = TestUtils.randomByte() + 128;
     boolean tcpNoDelay = rand.nextBoolean();
     boolean tcpKeepAlive = rand.nextBoolean();
     int soLinger = TestUtils.randomPositiveInt();

File: src/main/java/io/vertx/core/DeploymentOptions.java
Patch:
@@ -30,7 +30,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class DeploymentOptions {
 
   public static final boolean DEFAULT_WORKER = false;

File: src/main/java/io/vertx/core/VertxOptions.java
Patch:
@@ -28,7 +28,7 @@
  * 
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class VertxOptions {
 
   /**

File: src/main/java/io/vertx/core/datagram/DatagramSocketOptions.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class DatagramSocketOptions extends NetworkOptions {
 
   /**

File: src/main/java/io/vertx/core/file/OpenOptions.java
Patch:
@@ -24,7 +24,7 @@
  * 
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class OpenOptions {
 
   public static final String DEFAULT_PERMS = null;

File: src/main/java/io/vertx/core/http/HttpClientOptions.java
Patch:
@@ -31,7 +31,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class HttpClientOptions extends ClientOptionsBase {
 
   /**

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class HttpServerOptions extends NetServerOptions {
 
   /**

File: src/main/java/io/vertx/core/metrics/MetricsOptions.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class MetricsOptions {
 
   /**

File: src/main/java/io/vertx/core/net/ClientOptionsBase.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public abstract class ClientOptionsBase extends TCPSSLOptions {
 
   /**

File: src/main/java/io/vertx/core/net/JksOptions.java
Patch:
@@ -44,7 +44,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class JksOptions implements KeyCertOptions, TrustOptions, Cloneable {
 
   private String password;

File: src/main/java/io/vertx/core/net/NetClientOptions.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class NetClientOptions extends ClientOptionsBase {
 
   /**

File: src/main/java/io/vertx/core/net/NetServerOptions.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class NetServerOptions extends TCPSSLOptions {
 
   // Server specific HTTP stuff

File: src/main/java/io/vertx/core/net/NetworkOptions.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public abstract class NetworkOptions {
 
   /**

File: src/main/java/io/vertx/core/net/PemKeyCertOptions.java
Patch:
@@ -66,7 +66,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class PemKeyCertOptions implements KeyCertOptions, Cloneable {
 
   private String keyPath;

File: src/main/java/io/vertx/core/net/PemTrustOptions.java
Patch:
@@ -61,7 +61,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class PemTrustOptions implements TrustOptions, Cloneable {
 
   private ArrayList<String> certPaths;

File: src/main/java/io/vertx/core/net/PfxOptions.java
Patch:
@@ -44,7 +44,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class PfxOptions implements KeyCertOptions, TrustOptions, Cloneable {
 
   private String password;

File: src/main/java/io/vertx/core/net/TCPSSLOptions.java
Patch:
@@ -32,7 +32,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public abstract class TCPSSLOptions extends NetworkOptions {
 
   /**

File: src/test/java/io/vertx/test/codegen/ChildInheritingDataObject.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject(inheritConverter = true)
+@DataObject(inheritConverter = true, generateConverter = true)
 public class ChildInheritingDataObject extends ParentDataObject {
 
   private String childProperty;

File: src/test/java/io/vertx/test/codegen/ChildNotInheritingDataObject.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject(inheritConverter = false)
+@DataObject(inheritConverter = false, generateConverter = true)
 public class ChildNotInheritingDataObject extends ParentDataObject {
 
   private String childProperty;

File: src/test/java/io/vertx/test/codegen/ParentDataObject.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class ParentDataObject {
 
   private String parentProperty;

File: src/test/java/io/vertx/test/codegen/TestDataObject.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@DataObject
+@DataObject(generateConverter = true)
 public class TestDataObject {
 
   private String stringValue;

File: src/main/java/io/vertx/core/impl/Deployment.java
Patch:
@@ -30,6 +30,8 @@ public interface Deployment {
 
   void addChild(Deployment deployment);
 
+  void removeChild(Deployment deployment);
+
   void undeploy(Handler<AsyncResult<Void>> completionHandler);
 
   void doUndeploy(ContextImpl undeployingContext, Handler<AsyncResult<Void>> completionHandler);

File: src/main/java/io/vertx/core/impl/Deployment.java
Patch:
@@ -30,6 +30,8 @@ public interface Deployment {
 
   void addChild(Deployment deployment);
 
+  void removeChild(Deployment deployment);
+
   void undeploy(Handler<AsyncResult<Void>> completionHandler);
 
   void doUndeploy(ContextImpl undeployingContext, Handler<AsyncResult<Void>> completionHandler);

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -186,6 +186,7 @@ ServerWebSocket upgrade(HttpServerRequest request, HttpRequest nettyReq) {
     ws = new ServerWebSocketImpl(vertx, request.uri(), request.path(),
       request.query(), request.headers(), this, handshaker.version() != WebSocketVersion.V00,
       null, server.options().getMaxWebsocketFrameSize());
+    ws.setMetric(metrics.upgrade(requestMetric, ws));
     try {
       handshaker.handshake(channel, nettyReq);
     } catch (WebSocketHandshakeException e) {

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -186,6 +186,7 @@ ServerWebSocket upgrade(HttpServerRequest request, HttpRequest nettyReq) {
     ws = new ServerWebSocketImpl(vertx, request.uri(), request.path(),
       request.query(), request.headers(), this, handshaker.version() != WebSocketVersion.V00,
       null, server.options().getMaxWebsocketFrameSize());
+    ws.setMetric(metrics.upgrade(requestMetric, ws));
     try {
       handshaker.handshake(channel, nettyReq);
     } catch (WebSocketHandshakeException e) {

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -50,6 +50,8 @@
  *
  * From now on we'll just use the word *core* to refer to Vert.x core.
  *
+ * include::override/dependencies.adoc[]
+ *
  * Let's discuss the different concepts and features in core.
  *
  * == In the beginning there was Vert.x

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -401,7 +401,7 @@ private Redeployer getRedeployer(DeploymentOptions options, ClassLoader cl, Cont
           // Probably non file url
         }
       }
-      return new Redeployer(filesToWatch, options.getRedeployGracePeriod());
+      return new Redeployer(filesToWatch, options.getRedeployGraceInterval());
     } else {
       return null;
     }
@@ -631,7 +631,7 @@ private void startRedeployTimer() {
     }
 
     private void doStartRedeployTimer() {
-      redeployTimerID = vertx.setTimer(options.getRedeployScanPeriod(), tid -> vertx.executeBlockingInternal(redeployer, res -> {
+      redeployTimerID = vertx.setTimer(options.getRedeployScanInterval(), tid -> vertx.executeBlockingInternal(redeployer, res -> {
         if (res.succeeded()) {
           if (res.result()) {
             doRedeploy();

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -127,7 +127,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
   }
 
   VertxImpl(VertxOptions options, Handler<AsyncResult<Vertx>> resultHandler) {
-    checker = new BlockedThreadChecker(options.getBlockedThreadCheckPeriod(), options.getMaxEventLoopExecuteTime(),
+    checker = new BlockedThreadChecker(options.getBlockedThreadCheckInterval(), options.getMaxEventLoopExecuteTime(),
                                        options.getMaxWorkerExecuteTime(), options.getWarningExceptionTime());
     eventLoopGroup = new NioEventLoopGroup(options.getEventLoopPoolSize(),
                                            new VertxThreadFactory("vert.x-eventloop-thread-", checker, false));

File: src/test/java/io/vertx/test/core/RedeploymentTest.java
Patch:
@@ -245,14 +245,14 @@ public void testManualUndeployAfterRedeply() throws Exception {
 
   @Test
   public void testDelayedRedeployDueToSequenceOfChanges() throws Exception {
-    testRedeploy(RedeployVerticle.class.getName(), () -> touchJar(), 10, DeploymentOptions.DEFAULT_REDEPLOY_GRACE_PERIOD / 2, 1);
+    testRedeploy(RedeployVerticle.class.getName(), () -> touchJar(), 10, DeploymentOptions.DEFAULT_REDEPLOY_GRACE_INTERVAL / 2, 1);
   }
 
   @Test
   public void testChangeAgainDuringRedeploy() throws Exception {
     testRedeploy(() -> {
       touchJar();
-      vertx.setTimer(DeploymentOptions.DEFAULT_REDEPLOY_GRACE_PERIOD + 1, id -> {
+      vertx.setTimer(DeploymentOptions.DEFAULT_REDEPLOY_GRACE_INTERVAL + 1, id -> {
         touchJar();
       });
     });

File: src/test/java/io/vertx/test/core/StarterTest.java
Patch:
@@ -218,7 +218,7 @@ private void testConfigureFromSystemProperties(boolean clustered) throws Excepti
     System.setProperty(Starter.METRICS_OPTIONS_PROP_PREFIX + "enabled", "true");
     System.setProperty(Starter.VERTX_OPTIONS_PROP_PREFIX + "haGroup", "somegroup");
 
-    System.setProperty(Starter.DEPLOYMENT_OPTIONS_PROP_PREFIX + "redeployScanPeriod", "612536253");
+    System.setProperty(Starter.DEPLOYMENT_OPTIONS_PROP_PREFIX + "redeployScanInterval", "612536253");
 
     MyStarter starter = new MyStarter();
     String[] args;
@@ -242,7 +242,7 @@ private void testConfigureFromSystemProperties(boolean clustered) throws Excepti
 
     DeploymentOptions depOptions = starter.getDeploymentOptions();
 
-    assertEquals(612536253, depOptions.getRedeployScanPeriod());
+    assertEquals(612536253, depOptions.getRedeployScanInterval());
   }
 
   private void clearProperties() {

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -953,7 +953,7 @@
  * the structure of a JUL config file please consult the JUL logging documentation.
  *
  * Vert.x also provides a slightly more convenient way to specify a configuration file without having to set a system
- * property. Just provide a JUL config file with the name `default-jul-logging.properties` on your classpath (e.g.
+ * property. Just provide a JUL config file with the name `vertx-default-jul-logging.properties` on your classpath (e.g.
  * inside your fatjar) and Vert.x will use that to configure JUL.
  *
  * === Using another logging framework

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -294,7 +294,7 @@
  * ----
  *
  * WARNING: Make sure you check the filename in a production system to avoid malicious clients uploading files
- * to arbitrary places on your filesystem. See <<security_notes, security notes>> for more information.
+ * to arbitrary places on your filesystem. See <<Security notes, security notes>> for more information.
  *
  * === Sending back responses
  *
@@ -942,7 +942,7 @@
  *
  * Vert.x http servers and clients can be configured to use HTTPS in exactly the same way as net servers.
  *
- * Please see <<netserver_ssl, configuring net servers to use SSL>> for more information.
+ * Please see <<ssl, configuring net servers to use SSL>> for more information.
  *
  * === WebSockets
  *

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -929,8 +929,9 @@
  * can be easily replaced by a different implementation as Vert.x cluster managers are pluggable.
  *
  * A cluster manager must implement the interface {@link io.vertx.core.spi.cluster.ClusterManager}. Vert.x locates
- * cluster managers at run-time by using the Java {@link java.util.ServiceLoader} functionality to locate instances of
- * {@link io.vertx.core.spi.cluster.ClusterManager} on the classpath.
+ * cluster managers at run-time by using the Java
+ * https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[Service Loader] functionality to locate
+ * instances of {@link io.vertx.core.spi.cluster.ClusterManager} on the classpath.
  *
  * If you are using Vert.x at the command line and you want to use clustering you should make sure the `lib` directory
  * of the Vert.x installation contains your cluster manager jar.

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -669,7 +669,7 @@ private void tryRedeploy() {
           undeployed = false;
           log.trace("Redeployed ok");
         } else {
-          log.trace("Failed to deploy!!");
+          log.trace("Failed to deploy!!", res2.cause());
           broken = true;
           doStartRedeployTimer();
         }

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -42,8 +42,8 @@ public abstract class ContextImpl implements Context {
 
   private static final String THREAD_CHECKS_PROP_NAME = "vertx.threadChecks";
   private static final String DISABLE_TIMINGS_PROP_NAME = "vertx.disableContextTimings";
-  private static final boolean THREAD_CHECKS = "true".equalsIgnoreCase(System.getProperty(THREAD_CHECKS_PROP_NAME));
-  private static final boolean DISABLE_TIMINGS = "true".equalsIgnoreCase(System.getProperty(DISABLE_TIMINGS_PROP_NAME));
+  private static final boolean THREAD_CHECKS = Boolean.getBoolean(THREAD_CHECKS_PROP_NAME);
+  private static final boolean DISABLE_TIMINGS = Boolean.getBoolean(DISABLE_TIMINGS_PROP_NAME);
 
   protected final VertxInternal owner;
   protected final String deploymentID;

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -929,8 +929,9 @@
  * can be easily replaced by a different implementation as Vert.x cluster managers are pluggable.
  *
  * A cluster manager must implement the interface {@link io.vertx.core.spi.cluster.ClusterManager}. Vert.x locates
- * cluster managers at run-time by using the Java {@link java.util.ServiceLoader} functionality to locate instances of
- * {@link io.vertx.core.spi.cluster.ClusterManager} on the classpath.
+ * cluster managers at run-time by using the Java
+ * https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[Service Loader] functionality to locate
+ * instances of {@link io.vertx.core.spi.cluster.ClusterManager} on the classpath.
  *
  * If you are using Vert.x at the command line and you want to use clustering you should make sure the `lib` directory
  * of the Vert.x installation contains your cluster manager jar.

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -294,7 +294,7 @@
  * ----
  *
  * WARNING: Make sure you check the filename in a production system to avoid malicious clients uploading files
- * to arbitrary places on your filesystem. See <<security_notes, security notes>> for more information.
+ * to arbitrary places on your filesystem. See <<Security notes, security notes>> for more information.
  *
  * === Sending back responses
  *
@@ -942,7 +942,7 @@
  *
  * Vert.x http servers and clients can be configured to use HTTPS in exactly the same way as net servers.
  *
- * Please see <<netserver_ssl, configuring net servers to use SSL>> for more information.
+ * Please see <<ssl, configuring net servers to use SSL>> for more information.
  *
  * === WebSockets
  *

File: src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -669,7 +669,7 @@ private void tryRedeploy() {
           undeployed = false;
           log.trace("Redeployed ok");
         } else {
-          log.trace("Failed to deploy!!");
+          log.trace("Failed to deploy!!", res2.cause());
           broken = true;
           doStartRedeployTimer();
         }

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -363,7 +363,7 @@ public synchronized void close() {
 
   NetSocket createNetSocket() {
     // connection was upgraded to raw TCP socket
-    NetSocketImpl socket = new NetSocketImpl(vertx, channel, context, client.getSslHelper(), true, metrics);
+    NetSocketImpl socket = new NetSocketImpl(vertx, channel, context, client.getSslHelper(), true, metrics, metric);
     Map<Channel, NetSocketImpl> connectionMap = new HashMap<>(1);
     connectionMap.put(channel, socket);
 

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -207,7 +207,7 @@ ServerWebSocket upgrade(HttpServerRequest request, HttpRequest nettyReq) {
   }
 
   NetSocket createNetSocket() {
-    NetSocketImpl socket = new NetSocketImpl(vertx, channel, context, server.getSslHelper(), false, metrics);
+    NetSocketImpl socket = new NetSocketImpl(vertx, channel, context, server.getSslHelper(), false, metrics, metric);
     Map<Channel, NetSocketImpl> connectionMap = new HashMap<>(1);
     connectionMap.put(channel, socket);
 

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -215,7 +215,7 @@ protected void initChannel(Channel ch) throws Exception {
   }
 
   private void connected(ContextImpl context, Channel ch, Handler<AsyncResult<NetSocket>> connectHandler) {
-    NetSocketImpl sock = new NetSocketImpl(vertx, ch, context, sslHelper, true, metrics);
+    NetSocketImpl sock = new NetSocketImpl(vertx, ch, context, sslHelper, true, metrics, null);
     socketMap.put(ch, sock);
     context.executeFromIO(() -> {
       sock.setMetric(metrics.connected(sock.remoteAddress()));

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -433,7 +433,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     }
 
     private void connected(Channel ch, HandlerHolder<NetSocket> handler) {
-      NetSocketImpl sock = new NetSocketImpl(vertx, ch, handler.context, sslHelper, false, metrics);
+      NetSocketImpl sock = new NetSocketImpl(vertx, ch, handler.context, sslHelper, false, metrics, null);
       socketMap.put(ch, sock);
       handler.context.executeFromIO(() -> {
         sock.setMetric(metrics.connected(sock.remoteAddress()));

File: src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -74,11 +74,12 @@ public class NetSocketImpl extends ConnectionBase implements NetSocket {
   private boolean paused = false;
   private ChannelFuture writeFuture;
 
-  public NetSocketImpl(VertxInternal vertx, Channel channel, ContextImpl context, SSLHelper helper, boolean client, TCPMetrics metrics) {
+  public NetSocketImpl(VertxInternal vertx, Channel channel, ContextImpl context, SSLHelper helper, boolean client, TCPMetrics metrics, Object metric) {
     super(vertx, channel, context, metrics);
     this.helper = helper;
     this.client = client;
     this.writeHandlerID = UUID.randomUUID().toString();
+    this.metric = metric;
     Handler<Message<Buffer>> writeHandler = msg -> write(msg.body());
     registration = vertx.eventBus().<Buffer>localConsumer(writeHandlerID).handler(writeHandler);
   }

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -283,7 +283,7 @@ public boolean equals(Object o) {
 
     if (compressionSupported != that.compressionSupported) return false;
     if (maxWebsocketFrameSize != that.maxWebsocketFrameSize) return false;
-    if (websocketSubProtocols != that.websocketSubProtocols) return false;
+    if (websocketSubProtocols != null ? !websocketSubProtocols.equals(that.websocketSubProtocols) : that.websocketSubProtocols != null) return false;
 
     return true;
   }

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -281,6 +281,9 @@ public void testServerOptions() {
     assertEquals(options, options.setWebsocketSubProtocol("foo"));
     assertEquals("foo", options.getWebsocketSubProtocols());
 
+    HttpServerOptions optionsCopy = new HttpServerOptions(options);
+    assertEquals(options, optionsCopy.setWebsocketSubProtocol(new String(options.getWebsocketSubProtocols())));
+
     assertTrue(options.getEnabledCipherSuites().isEmpty());
     assertEquals(options, options.addEnabledCipherSuite("foo"));
     assertEquals(options, options.addEnabledCipherSuite("bar"));

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -283,7 +283,7 @@ public boolean equals(Object o) {
 
     if (compressionSupported != that.compressionSupported) return false;
     if (maxWebsocketFrameSize != that.maxWebsocketFrameSize) return false;
-    if (websocketSubProtocols != that.websocketSubProtocols) return false;
+    if (websocketSubProtocols != null ? !websocketSubProtocols.equals(that.websocketSubProtocols) : that.websocketSubProtocols != null) return false;
 
     return true;
   }

File: src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -281,6 +281,9 @@ public void testServerOptions() {
     assertEquals(options, options.setWebsocketSubProtocol("foo"));
     assertEquals("foo", options.getWebsocketSubProtocols());
 
+    HttpServerOptions optionsCopy = new HttpServerOptions(options);
+    assertEquals(options, optionsCopy.setWebsocketSubProtocol(new String(options.getWebsocketSubProtocols())));
+
     assertTrue(options.getEnabledCipherSuites().isEmpty());
     assertEquals(options, options.addEnabledCipherSuite("foo"));
     assertEquals(options, options.addEnabledCipherSuite("bar"));

File: src/main/java/examples/HTTPExamples.java
Patch:
@@ -16,13 +16,11 @@
 
 package examples;
 
-import io.netty.handler.codec.http.HttpResponseStatus;
 import io.vertx.core.MultiMap;
 import io.vertx.core.Vertx;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.file.AsyncFile;
 import io.vertx.core.http.*;
-import io.vertx.core.net.NetSocket;
 import io.vertx.core.streams.Pump;
 
 /**
@@ -257,7 +255,7 @@ public void example28(Vertx vertx) {
 
   public void example29(Vertx vertx) {
     HttpClientOptions options = new HttpClientOptions().setKeepAlive(false);
-    HttpClient client = vertx.createHttpClient();
+    HttpClient client = vertx.createHttpClient(options);
   }
 
   public void example30(Vertx vertx) {

File: src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -244,6 +244,7 @@ private void handshakeComplete(ChannelHandlerContext ctx, FullHttpResponse respo
       handshaker.finishHandshake(channel, response);
       context.executeFromIO(() -> {
         log.debug("WebSocket handshake complete");
+        webSocket.setMetric(metrics().connected(metric(), webSocket));
         wsConnect.handle(webSocket);
       });
     }

File: src/test/java/io/vertx/test/core/MetricsContextTest.java
Patch:
@@ -39,7 +39,6 @@
 /**
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@Ignore
 public class MetricsContextTest extends AsyncTestBase {
 
   @Test

File: src/test/java/io/vertx/test/core/MetricsTest.java
Patch:
@@ -270,7 +270,8 @@ private void testHandlerProcessMessage(Vertx from, Vertx to, int expectedLocalCo
         assertEquals(ADDRESS1, registration.address);
         assertEquals(false, registration.replyHandler);
         assertEquals(1, registration.beginCount.get());
-        assertEquals(1, registration.endCount.get());
+        // This might take a little time
+        waitUntil(() -> 1 == registration.endCount.get());
         assertEquals(0, registration.failureCount.get());
         assertEquals(expectedLocalCoult, registration.localCount.get());
         testComplete();

File: src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -44,7 +44,6 @@ public abstract class WebSocketImplBase implements WebSocketBase {
   private final boolean supportsContinuation;
   private final String textHandlerID;
   private final String binaryHandlerID;
-  private final VertxInternal vertx;
   private final int maxWebSocketFrameSize;
   private final MessageConsumer binaryHandlerRegistration;
   private final MessageConsumer textHandlerRegistration;
@@ -61,7 +60,6 @@ public abstract class WebSocketImplBase implements WebSocketBase {
   protected WebSocketImplBase(VertxInternal vertx, ConnectionBase conn, boolean supportsContinuation,
                               int maxWebSocketFrameSize) {
     this.supportsContinuation = supportsContinuation;
-    this.vertx = vertx;
     this.textHandlerID = UUID.randomUUID().toString();
     this.binaryHandlerID = UUID.randomUUID().toString();
     this.conn = conn;

File: src/main/java/io/vertx/core/impl/BlockedThreadChecker.java
Patch:
@@ -45,8 +45,8 @@ public void run() {
         for (VertxThread thread: threads.keySet()) {
           long execStart = thread.startTime();
           long dur = now - execStart;
-          if (execStart != 0 && dur > (thread.isWorker() ? maxWorkerExecTime : maxEventLoopExecTime)) {
-            long timeLimit = thread.isWorker() ? maxWorkerExecTime : maxEventLoopExecTime;
+          final long timeLimit = thread.isWorker() ? maxWorkerExecTime : maxEventLoopExecTime;
+          if (execStart != 0 && dur > timeLimit) {
             final String message = "Thread " + thread + " has been blocked for " + (dur / 1000000) + " ms, time limit is " + (timeLimit / 1000000);
             if (dur <= warningExceptionTime) {
               log.warn(message);

File: src/main/java/io/vertx/core/json/impl/Json.java
Patch:
@@ -112,10 +112,9 @@ public static String encodePrettily(Object obj) throws EncodeException {
     }
   }
 
-  @SuppressWarnings("unchecked")
-  public static <T> T decodeValue(String str, Class<?> clazz) throws DecodeException {
+  public static <T> T decodeValue(String str, Class<T> clazz) throws DecodeException {
     try {
-      return (T)mapper.readValue(str, clazz);
+      return mapper.readValue(str, clazz);
     }
     catch (Exception e) {
       throw new DecodeException("Failed to decode:" + e.getMessage());

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -559,6 +559,7 @@ private void createConnAndHandle(HandlerHolder<HttpServerRequest> reqHandler, Ch
       conn.requestHandler(reqHandler.handler);
       connectionMap.put(ch, conn);
       reqHandler.context.executeFromIO(() -> {
+        conn.setMetric(metrics.connected(conn.remoteAddress()));
         conn.handleMessage(request);
       });
     }
@@ -594,6 +595,7 @@ private void handshake(FullHttpRequest request, Channel ch, ChannelHandlerContex
 
           ServerConnection wsConn = new ServerConnection(vertx, HttpServerImpl.this, ch, wsHandler.context,
             serverOrigin, shake, metrics);
+          wsConn.setMetric(metrics.connected(wsConn.remoteAddress()));
           wsConn.wsHandler(wsHandler.handler);
 
           Runnable connectRunnable = () -> {

File: src/main/java/io/vertx/core/spi/VertxMetricsFactory.java
Patch:
@@ -28,7 +28,9 @@
 public interface VertxMetricsFactory {
 
   /**
-   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.
+   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.<p/>
+   *
+   * No specific thread and context can be expected when this method is called.
    *
    * @param vertx the vertx instance
    * @param options the metrics configuration option

File: src/main/java/io/vertx/core/spi/metrics/Metrics.java
Patch:
@@ -32,7 +32,9 @@ public interface Metrics {
   boolean isEnabled();
 
   /**
-   * Used to close out the metrics, for example when an http server/client has been closed.
+   * Used to close out the metrics, for example when an http server/client has been closed.<p/>
+   *
+   * No specific thread and context can be expected when this method is called.
    */
   void close();
 }

File: src/main/java/io/vertx/core/spi/metrics/NetworkMetrics.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * An SPI used internally by Vert.x to gather metrics on a net socket which serves
- * as a base class for TCP or UDP.
+ * as a base class for TCP or UDP.<p/>
  *
  * @author <a href="mailto:nscavell@redhat.com">Nick Scavelli</a>
  */

File: src/test/java/io/vertx/test/fakemetrics/FakeEventBusMetrics.java
Patch:
@@ -18,7 +18,6 @@
 
 import io.vertx.core.eventbus.EventBus;
 import io.vertx.core.eventbus.ReplyFailure;
-import io.vertx.core.metrics.Measured;
 import io.vertx.core.spi.metrics.EventBusMetrics;
 
 import java.util.ArrayList;
@@ -138,6 +137,5 @@ public boolean isEnabled() {
   }
 
   public void close() {
-    throw new UnsupportedOperationException();
   }
 }

File: src/main/java/io/vertx/core/logging/Logger.java
Patch:
@@ -27,7 +27,7 @@
  * property is set.
  * <p>
  * If you would prefer to use Log4J or SLF4J instead of JUL then you can set a system property called
- * {@code io.vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
+ * {@code vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
  * For Log4J the value is {@code io.vertx.core.logging.impl.Log4JLogDelegateFactory}, for SLF4J the value
  * is {@code io.vertx.core.logging.impl.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
  * required by your favourite log framework are on your classpath.

File: src/main/java/io/vertx/core/eventbus/impl/MessageImpl.java
Patch:
@@ -250,7 +250,7 @@ private void encodeHeaders(Buffer buffer) {
 
   private void decodeHeaders() {
     int length = wireBuffer.getInt(headersPos);
-    if (length != 0) {
+    if (length != 4) {
       headersPos += 4;
       int numHeaders = wireBuffer.getInt(headersPos);
       headersPos += 4;

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -241,9 +241,7 @@ public DatagramSocket send(String str, String enc, int port, String host, Handle
   public void close(final Handler<AsyncResult<Void>> handler) {
     // make sure everything is flushed out on close
     endReadAndFlush();
-    context.runOnContext(v -> {
-      metrics.close();
-    });
+    metrics.close();
     ChannelFuture future = channel.close();
     if (handler != null) {
       future.addListener(new DatagramChannelFutureListener<>(null, handler, context));

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -407,9 +407,7 @@ private void actualClose(final ContextImpl closeContext, final Handler<AsyncResu
     }
 
     if (metrics != null) {
-      listenContext.runOnContext(v -> {
-        metrics.close();
-      });
+      metrics.close();
     }
 
     ChannelGroupFuture fut = serverChannelGroup.close();

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -386,9 +386,7 @@ private void actualClose(ContextImpl closeContext, Handler<AsyncResult<Void>> do
     ChannelGroupFuture fut = serverChannelGroup.close();
     fut.addListener(cg -> {
       if (metrics != null) {
-        listenContext.runOnContext(v -> {
-          metrics.close();
-        });
+        metrics.close();
       }
       executeCloseDone(closeContext, done, fut.cause());
     });

File: src/main/java/io/vertx/core/spi/VertxMetricsFactory.java
Patch:
@@ -28,9 +28,7 @@
 public interface VertxMetricsFactory {
 
   /**
-   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.<p/>
-   *
-   * No specific thread and context can be expected when this method is called.
+   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.
    *
    * @param vertx the vertx instance
    * @param options the metrics configuration option

File: src/test/java/io/vertx/test/fakemetrics/FakeEventBusMetrics.java
Patch:
@@ -138,5 +138,6 @@ public boolean isEnabled() {
   }
 
   public void close() {
+    throw new UnsupportedOperationException();
   }
 }

File: src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -208,6 +208,7 @@ ServerWebSocket upgrade(HttpServerRequest request, HttpRequest nettyReq) {
 
   NetSocket createNetSocket() {
     NetSocketImpl socket = new NetSocketImpl(vertx, channel, context, server.getSslHelper(), false, metrics);
+    socket.setMetric(metrics.connected(socket.remoteAddress()));
     Map<Channel, NetSocketImpl> connectionMap = new HashMap<Channel, NetSocketImpl>(1);
     connectionMap.put(channel, socket);
 

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -220,6 +220,7 @@ private void connected(ContextImpl context, Channel ch, Handler<AsyncResult<NetS
 
   private void doConnected(ContextImpl context, Channel ch, Handler<AsyncResult<NetSocket>> connectHandler) {
     NetSocketImpl sock = new NetSocketImpl(vertx, ch, context, sslHelper, true, metrics);
+    sock.setMetric(metrics.connected(sock.remoteAddress()));
     socketMap.put(ch, sock);
     connectHandler.handle(Future.succeededFuture(sock));
   }

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -559,6 +559,7 @@ private void createConnAndHandle(HandlerHolder<HttpServerRequest> reqHandler, Ch
       conn.requestHandler(reqHandler.handler);
       connectionMap.put(ch, conn);
       reqHandler.context.executeFromIO(() -> {
+        conn.setMetric(metrics.connected(conn.remoteAddress()));
         conn.handleMessage(request);
       });
     }
@@ -594,6 +595,7 @@ private void handshake(FullHttpRequest request, Channel ch, ChannelHandlerContex
 
           ServerConnection wsConn = new ServerConnection(vertx, HttpServerImpl.this, ch, wsHandler.context,
             serverOrigin, shake, metrics);
+          wsConn.setMetric(metrics.connected(wsConn.remoteAddress()));
           wsConn.wsHandler(wsHandler.handler);
 
           Runnable connectRunnable = () -> {

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -104,10 +104,10 @@ public void close() {
       for (NetSocket sock : socketMap.values()) {
         sock.close();
       }
+      closed = true;
       if (creatingContext != null) {
         creatingContext.removeCloseHook(closeHook);
       }
-      closed = true;
       metrics.close();
     }
   }

File: src/main/java/io/vertx/core/spi/VertxMetricsFactory.java
Patch:
@@ -28,7 +28,9 @@
 public interface VertxMetricsFactory {
 
   /**
-   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.
+   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.<p/>
+   *
+   * No specific thread and context can be expected when this method is called.
    *
    * @param vertx the vertx instance
    * @param options the metrics configuration option

File: src/main/java/io/vertx/core/spi/metrics/Metrics.java
Patch:
@@ -32,7 +32,9 @@ public interface Metrics {
   boolean isEnabled();
 
   /**
-   * Used to close out the metrics, for example when an http server/client has been closed.
+   * Used to close out the metrics, for example when an http server/client has been closed.<p/>
+   *
+   * No specific thread and context can be expected when this method is called.
    */
   void close();
 }

File: src/main/java/io/vertx/core/spi/metrics/NetworkMetrics.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * An SPI used internally by Vert.x to gather metrics on a net socket which serves
- * as a base class for TCP or UDP.
+ * as a base class for TCP or UDP.<p/>
  *
  * @author <a href="mailto:nscavell@redhat.com">Nick Scavelli</a>
  */

File: src/test/java/io/vertx/test/fakemetrics/FakeEventBusMetrics.java
Patch:
@@ -138,6 +138,5 @@ public boolean isEnabled() {
   }
 
   public void close() {
-    throw new UnsupportedOperationException();
   }
 }

File: src/main/java/io/vertx/core/spi/metrics/DatagramSocketMetrics.java
Patch:
@@ -22,7 +22,7 @@
  * The datagram/udp metrics SPI which Vert.x will use to call when each event occurs pertaining to datagram sockets.<p/>
  *
  * All the methods on this object including the methods inherited from the super interfaces are invoked
- * with {@link io.vertx.core.Context} and thread of the http client and therefore are the same than
+ * with {@link io.vertx.core.Context} and thread of the datagram socket and therefore are the same than
  * the {@link io.vertx.core.spi.metrics.VertxMetrics} {@code createMetrics} method that created and returned
  * this metrics object.
  *

File: src/main/java/io/vertx/core/spi/metrics/NetworkMetrics.java
Patch:
@@ -23,7 +23,7 @@
  * as a base class for TCP or UDP.<p/>
  *
  * All the methods on this object including the methods inherited from the super interfaces are invoked
- * with {@link io.vertx.core.Context} and thread of the http client and therefore are the same than
+ * with {@link io.vertx.core.Context} and thread of the network server/client and therefore are the same than
  * the {@link io.vertx.core.spi.metrics.VertxMetrics} {@code createMetrics} method that created and returned
  * this metrics object.
  *

File: src/main/java/io/vertx/core/spi/metrics/TCPMetrics.java
Patch:
@@ -23,7 +23,7 @@
  * as a base class for things like HttpServer and HttpClient, all of which serve TCP connections.<p/>
  *
  * All the methods on this object including the methods inherited from the super interfaces are invoked
- * with {@link io.vertx.core.Context} and thread of the http server and therefore are the same than
+ * with {@link io.vertx.core.Context} and thread of the tcp server/client and therefore are the same than
  * the {@link io.vertx.core.spi.metrics.VertxMetrics} {@code createMetrics} method that created and returned
  * this metrics object.
  *

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -241,7 +241,9 @@ public DatagramSocket send(String str, String enc, int port, String host, Handle
   public void close(final Handler<AsyncResult<Void>> handler) {
     // make sure everything is flushed out on close
     endReadAndFlush();
-    metrics.close();
+    context.runOnContext(v -> {
+      metrics.close();
+    });
     ChannelFuture future = channel.close();
     if (handler != null) {
       future.addListener(new DatagramChannelFutureListener<>(null, handler, context));

File: src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -407,7 +407,9 @@ private void actualClose(final ContextImpl closeContext, final Handler<AsyncResu
     }
 
     if (metrics != null) {
-      metrics.close();
+      listenContext.runOnContext(v -> {
+        metrics.close();
+      });
     }
 
     ChannelGroupFuture fut = serverChannelGroup.close();

File: src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -386,7 +386,9 @@ private void actualClose(ContextImpl closeContext, Handler<AsyncResult<Void>> do
     ChannelGroupFuture fut = serverChannelGroup.close();
     fut.addListener(cg -> {
       if (metrics != null) {
-        metrics.close();
+        listenContext.runOnContext(v -> {
+          metrics.close();
+        });
       }
       executeCloseDone(closeContext, done, fut.cause());
     });

File: src/main/java/io/vertx/core/spi/VertxMetricsFactory.java
Patch:
@@ -28,7 +28,9 @@
 public interface VertxMetricsFactory {
 
   /**
-   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.
+   * Create a new {@link io.vertx.core.spi.metrics.VertxMetrics} object.<p/>
+   *
+   * No specific thread and context can be expected when this method is called.
    *
    * @param vertx the vertx instance
    * @param options the metrics configuration option

File: src/test/java/io/vertx/test/fakemetrics/FakeEventBusMetrics.java
Patch:
@@ -138,6 +138,5 @@ public boolean isEnabled() {
   }
 
   public void close() {
-    throw new UnsupportedOperationException();
   }
 }

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -174,15 +174,15 @@ public class VertxImpl implements VertxInternal, MetricsProvider {
                 if (resultHandler != null) {
                   resultHandler.handle(Future.failedFuture(asyncResult.cause()));
                 } else {
-                  log.error(ar.cause());
+                  log.error(asyncResult.cause());
                 }
              }
             });
           } else {
             if (resultHandler != null) {
               resultHandler.handle(Future.failedFuture(ar2.cause()));
             } else {
-              log.error(ar.cause());
+              log.error(ar2.cause());
             }
           }
         });

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -61,7 +61,7 @@ public DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
       throw new IllegalStateException("Cannot use DatagramSocket in a multi-threaded worker verticle");
     }
     channel().config().setOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);
-    context.getEventLoop().register(channel);
+    context.eventLoop().register(channel);
     channel.pipeline().addLast("handler", new DatagramServerHandler(this.vertx, this));
     channel().config().setMaxMessagesPerRead(1);
   }

File: src/main/java/io/vertx/core/dns/impl/DnsClientImpl.java
Patch:
@@ -80,7 +80,7 @@ public DnsClientImpl(VertxInternal vertx, int port, String host) {
 
     actualCtx = vertx.getOrCreateContext();
     bootstrap = new Bootstrap();
-    bootstrap.group(actualCtx.getEventLoop());
+    bootstrap.group(actualCtx.eventLoop());
     bootstrap.channel(NioDatagramChannel.class);
     bootstrap.option(ChannelOption.ALLOCATOR, PartialPooledByteBufAllocator.INSTANCE);
     bootstrap.handler(new ChannelInitializer<DatagramChannel>() {

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -646,7 +646,7 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
   private void internalConnect(ContextImpl context, int port, String host, Handler<ClientConnection> connectHandler,
                                Handler<Throwable> connectErrorHandler, ConnectionLifeCycleListener listener) {
     Bootstrap bootstrap = new Bootstrap();
-    bootstrap.group(context.getEventLoop());
+    bootstrap.group(context.eventLoop());
     bootstrap.channel(NioSocketChannel.class);
     sslHelper.validate(vertx);
     bootstrap.handler(new ChannelInitializer<Channel>() {

File: src/main/java/io/vertx/core/impl/EventLoopContext.java
Patch:
@@ -38,7 +38,7 @@ public EventLoopContext(VertxInternal vertx, Executor internalBlockingExec, Exec
   }
 
   public void executeAsync(Handler<Void> task) {
-    getEventLoop().execute(wrapTask(null, task, true));
+    eventLoop().execute(wrapTask(null, task, true));
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -76,7 +76,7 @@ public interface VertxInternal extends Vertx {
 
   Deployment getDeployment(String deploymentID);
 
-  void failoverCompleteHandler(Handler<Boolean> failoverCompleteHandler);
+  void failoverCompleteHandler(FailoverCompleteHandler failoverCompleteHandler);
 
   boolean isKilled();
 

File: src/main/java/io/vertx/core/net/impl/HandlerManager.java
Patch:
@@ -56,7 +56,7 @@ public HandlerHolder<T> chooseHandler(EventLoop worker) {
   }
 
   public synchronized void addHandler(Handler<T> handler, ContextImpl context) {
-    EventLoop worker = context.getEventLoop();
+    EventLoop worker = context.eventLoop();
     availableWorkers.addWorker(worker);
     Handlers<T> handlers = new Handlers<T>();
     Handlers<T> prev = handlerMap.putIfAbsent(worker, handlers);
@@ -68,7 +68,7 @@ public synchronized void addHandler(Handler<T> handler, ContextImpl context) {
   }
 
   public synchronized void removeHandler(Handler<T> handler, ContextImpl context) {
-    EventLoop worker = context.getEventLoop();
+    EventLoop worker = context.eventLoop();
     Handlers<T> handlers = handlerMap.get(worker);
     if (!handlers.removeHandler(new HandlerHolder<>(context, handler))) {
       throw new IllegalStateException("Can't find handler");

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -153,7 +153,7 @@ private void connect(int port, String host, Handler<AsyncResult<NetSocket>> conn
     ContextImpl context = vertx.getOrCreateContext();
     sslHelper.validate(vertx);
     Bootstrap bootstrap = new Bootstrap();
-    bootstrap.group(context.getEventLoop());
+    bootstrap.group(context.eventLoop());
     bootstrap.channel(NioSocketChannel.class);
     bootstrap.handler(new ChannelInitializer<Channel>() {
       @Override

File: src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -194,7 +194,7 @@ protected void createNodes(int nodes) {
     for (int i = 0; i < nodes; i++) {
       aliveNodes.add(i);
       int pos = i;
-      ((VertxInternal)vertices[i]).failoverCompleteHandler(succeeded -> {
+      ((VertxInternal)vertices[i]).failoverCompleteHandler((nodeID, haInfo, succeeded) -> {
         failedOverOnto(pos);
       });
     }

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -61,7 +61,7 @@ public DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
       throw new IllegalStateException("Cannot use DatagramSocket in a multi-threaded worker verticle");
     }
     channel().config().setOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);
-    context.getEventLoop().register(channel);
+    context.eventLoop().register(channel);
     channel.pipeline().addLast("handler", new DatagramServerHandler(this.vertx, this));
     channel().config().setMaxMessagesPerRead(1);
   }

File: src/main/java/io/vertx/core/dns/impl/DnsClientImpl.java
Patch:
@@ -80,7 +80,7 @@ public DnsClientImpl(VertxInternal vertx, int port, String host) {
 
     actualCtx = vertx.getOrCreateContext();
     bootstrap = new Bootstrap();
-    bootstrap.group(actualCtx.getEventLoop());
+    bootstrap.group(actualCtx.eventLoop());
     bootstrap.channel(NioDatagramChannel.class);
     bootstrap.option(ChannelOption.ALLOCATOR, PartialPooledByteBufAllocator.INSTANCE);
     bootstrap.handler(new ChannelInitializer<DatagramChannel>() {

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -646,7 +646,7 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
   private void internalConnect(ContextImpl context, int port, String host, Handler<ClientConnection> connectHandler,
                                Handler<Throwable> connectErrorHandler, ConnectionLifeCycleListener listener) {
     Bootstrap bootstrap = new Bootstrap();
-    bootstrap.group(context.getEventLoop());
+    bootstrap.group(context.eventLoop());
     bootstrap.channel(NioSocketChannel.class);
     sslHelper.validate(vertx);
     bootstrap.handler(new ChannelInitializer<Channel>() {

File: src/main/java/io/vertx/core/impl/EventLoopContext.java
Patch:
@@ -38,7 +38,7 @@ public EventLoopContext(VertxInternal vertx, Executor internalBlockingExec, Exec
   }
 
   public void executeAsync(Handler<Void> task) {
-    getEventLoop().execute(wrapTask(null, task, true));
+    eventLoop().execute(wrapTask(null, task, true));
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -76,7 +76,7 @@ public interface VertxInternal extends Vertx {
 
   Deployment getDeployment(String deploymentID);
 
-  void failoverCompleteHandler(Handler<Boolean> failoverCompleteHandler);
+  void failoverCompleteHandler(FailoverCompleteHandler failoverCompleteHandler);
 
   boolean isKilled();
 

File: src/main/java/io/vertx/core/net/impl/HandlerManager.java
Patch:
@@ -56,7 +56,7 @@ public HandlerHolder<T> chooseHandler(EventLoop worker) {
   }
 
   public synchronized void addHandler(Handler<T> handler, ContextImpl context) {
-    EventLoop worker = context.getEventLoop();
+    EventLoop worker = context.eventLoop();
     availableWorkers.addWorker(worker);
     Handlers<T> handlers = new Handlers<T>();
     Handlers<T> prev = handlerMap.putIfAbsent(worker, handlers);
@@ -68,7 +68,7 @@ public synchronized void addHandler(Handler<T> handler, ContextImpl context) {
   }
 
   public synchronized void removeHandler(Handler<T> handler, ContextImpl context) {
-    EventLoop worker = context.getEventLoop();
+    EventLoop worker = context.eventLoop();
     Handlers<T> handlers = handlerMap.get(worker);
     if (!handlers.removeHandler(new HandlerHolder<>(context, handler))) {
       throw new IllegalStateException("Can't find handler");

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -153,7 +153,7 @@ private void connect(int port, String host, Handler<AsyncResult<NetSocket>> conn
     ContextImpl context = vertx.getOrCreateContext();
     sslHelper.validate(vertx);
     Bootstrap bootstrap = new Bootstrap();
-    bootstrap.group(context.getEventLoop());
+    bootstrap.group(context.eventLoop());
     bootstrap.channel(NioSocketChannel.class);
     bootstrap.handler(new ChannelInitializer<Channel>() {
       @Override

File: src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -194,7 +194,7 @@ protected void createNodes(int nodes) {
     for (int i = 0; i < nodes; i++) {
       aliveNodes.add(i);
       int pos = i;
-      ((VertxInternal)vertices[i]).failoverCompleteHandler(succeeded -> {
+      ((VertxInternal)vertices[i]).failoverCompleteHandler((nodeID, haInfo, succeeded) -> {
         failedOverOnto(pos);
       });
     }

File: src/main/java/io/vertx/core/impl/ConcurrentHashSet.java
Patch:
@@ -76,7 +76,7 @@ public boolean add(E e) {
 
   @Override
   public boolean remove(Object o) {
-    return map.remove(o) == null;
+    return map.remove(o) != null;
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -25,6 +25,7 @@
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.net.impl.NetServerImpl;
 import io.vertx.core.net.impl.ServerID;
+import io.vertx.core.spi.cluster.ClusterManager;
 import io.vertx.core.spi.metrics.VertxMetrics;
 
 import java.io.File;
@@ -86,4 +87,6 @@ public interface VertxInternal extends Vertx {
   File resolveFile(String fileName);
 
   <T> void executeBlockingInternal(Action<T> action, Handler<AsyncResult<T>> resultHandler);
+
+  ClusterManager getClusterManager();
 }

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -64,7 +64,7 @@ public class NetClientImpl implements NetClient, MetricsProvider {
   private final Closeable closeHook;
   private final ContextImpl creatingContext;
   private final TCPMetrics metrics;
-  private boolean closed;
+  private volatile boolean closed;
 
   public NetClientImpl(VertxInternal vertx, NetClientOptions options) {
     this(vertx, options, true);
@@ -99,7 +99,7 @@ public synchronized NetClient connect(int port, String host, Handler<AsyncResult
   }
 
   @Override
-  public synchronized void close() {
+  public void close() {
     if (!closed) {
       for (NetSocket sock : socketMap.values()) {
         sock.close();

File: src/test/java/io/vertx/test/fakecluster/ChoosableSet.java
Patch:
@@ -44,8 +44,8 @@ public void add(T elem) {
     ids.add(elem);
   }
 
-  public void remove(T elem) {
-    ids.remove(elem);
+  public boolean remove(T elem) {
+    return ids.remove(elem);
   }
 
   public void merge(ChoosableSet<T> toMerge) {

File: src/main/java/io/vertx/core/impl/ConcurrentHashSet.java
Patch:
@@ -76,7 +76,7 @@ public boolean add(E e) {
 
   @Override
   public boolean remove(Object o) {
-    return map.remove(o) == null;
+    return map.remove(o) != null;
   }
 
   @Override

File: src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -25,6 +25,7 @@
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.net.impl.NetServerImpl;
 import io.vertx.core.net.impl.ServerID;
+import io.vertx.core.spi.cluster.ClusterManager;
 import io.vertx.core.spi.metrics.VertxMetrics;
 
 import java.io.File;
@@ -86,4 +87,6 @@ public interface VertxInternal extends Vertx {
   File resolveFile(String fileName);
 
   <T> void executeBlockingInternal(Action<T> action, Handler<AsyncResult<T>> resultHandler);
+
+  ClusterManager getClusterManager();
 }

File: src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -64,7 +64,7 @@ public class NetClientImpl implements NetClient, MetricsProvider {
   private final Closeable closeHook;
   private final ContextImpl creatingContext;
   private final TCPMetrics metrics;
-  private boolean closed;
+  private volatile boolean closed;
 
   public NetClientImpl(VertxInternal vertx, NetClientOptions options) {
     this(vertx, options, true);
@@ -99,7 +99,7 @@ public synchronized NetClient connect(int port, String host, Handler<AsyncResult
   }
 
   @Override
-  public synchronized void close() {
+  public void close() {
     if (!closed) {
       for (NetSocket sock : socketMap.values()) {
         sock.close();

File: src/test/java/io/vertx/test/fakecluster/ChoosableSet.java
Patch:
@@ -44,8 +44,8 @@ public void add(T elem) {
     ids.add(elem);
   }
 
-  public void remove(T elem) {
-    ids.remove(elem);
+  public boolean remove(T elem) {
+    return ids.remove(elem);
   }
 
   public void merge(ChoosableSet<T> toMerge) {

File: src/main/java/io/vertx/core/http/impl/HttpServerFileUploadImpl.java
Patch:
@@ -187,7 +187,6 @@ synchronized void doReceiveData(Buffer data) {
   }
 
   synchronized void complete() {
-    req.uploadComplete(this);
     if (paused) {
       complete = true;
     } else {
@@ -213,7 +212,6 @@ private void notifyEndHandler() {
     if (endHandler != null) {
       endHandler.handle(null);
     }
-    req.callEndHandler(this);
   }
 
   private void notifyExceptionHandler(Throwable cause) {

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -913,4 +913,5 @@ protected void finalize() throws Throwable {
     close();
     super.finalize();
   }
+
 }

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -913,4 +913,5 @@ protected void finalize() throws Throwable {
     close();
     super.finalize();
   }
+
 }

File: src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -913,4 +913,5 @@ protected void finalize() throws Throwable {
     close();
     super.finalize();
   }
+
 }

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -43,6 +43,7 @@ public abstract class ContextImpl implements Context {
 
   private static final Logger log = LoggerFactory.getLogger(ContextImpl.class);
 
+  protected final VertxInternal owner;
   protected final String deploymentID;
   protected final JsonObject config;
   private Deployment deployment;
@@ -66,6 +67,7 @@ protected ContextImpl(VertxInternal vertx, Executor orderedInternalPoolExec, Exe
       this.eventLoop = null;
     }
     this.tccl = tccl;
+    this.owner = vertx;
   }
 
   public static void setContext(ContextImpl context) {

File: src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -659,7 +659,9 @@ private void removeSub(String subName, ServerID theServerID, Handler<AsyncResult
       if (!ar.succeeded()) {
         log.error("Couldn't find sub to remove");
       } else {
-        completionHandler.handle(Future.succeededFuture());
+        if (completionHandler != null) {
+          completionHandler.handle(Future.succeededFuture());
+        }
       }
     });
   }

File: src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -206,7 +206,7 @@ public class VertxImpl implements VertxInternal {
    * @return The FileSystem implementation for the OS
    */
   protected FileSystem getFileSystem() {
-  	return Windows.isWindows() ? new WindowsFileSystem(this) : new FileSystemImpl(this);
+  	return Utils.isWindows() ? new WindowsFileSystem(this) : new FileSystemImpl(this);
   }
 
   @Override

File: src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java
Patch:
@@ -16,6 +16,8 @@
 
 package io.vertx.core.logging.impl;
 
+import io.vertx.core.impl.Utils;
+
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.time.Instant;
@@ -28,7 +30,6 @@
  * @author <a href="mailto:andy.taylor@jboss.org">Andy Taylor</a>
  */
 public class VertxLoggerFormatter extends java.util.logging.Formatter {
-  private static String LINE_SEPARATOR = System.getProperty("line.separator");
 
   @Override
   public String format(final LogRecord record) {
@@ -41,7 +42,7 @@ public String format(final LogRecord record) {
     sb.append(record.getLoggerName()).append("]").append("  ");
     sb.append(record.getMessage());
 
-    sb.append(VertxLoggerFormatter.LINE_SEPARATOR);
+    sb.append(Utils.LINE_SEPARATOR);
     if (record.getThrown() != null) {
       try {
         StringWriter sw = new StringWriter();

File: src/test/java/io/vertx/test/core/JsonArrayTest.java
Patch:
@@ -17,6 +17,7 @@
 package io.vertx.test.core;
 
 import io.vertx.core.buffer.Buffer;
+import io.vertx.core.impl.Utils;
 import io.vertx.core.json.DecodeException;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
@@ -815,8 +816,8 @@ public void testEncodePrettily() throws Exception {
     jsonArray.add(new JsonObject().put("foo", "bar"));
     jsonArray.add(new JsonArray().add("foo").add(123));
     String strBytes = Base64.getEncoder().encodeToString(bytes);
-    String expected = "[ \"foo\", 123, 1234, 1.23, 2.34, true, \"" + strBytes + "\", null, {\n" +
-      "  \"foo\" : \"bar\"\n" +
+    String expected = "[ \"foo\", 123, 1234, 1.23, 2.34, true, \"" + strBytes + "\", null, {" + Utils.LINE_SEPARATOR +
+      "  \"foo\" : \"bar\"" + Utils.LINE_SEPARATOR +
       "}, [ \"foo\", 123 ] ]";
     String json = jsonArray.encodePrettily();
     assertEquals(expected, json);

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -47,6 +47,7 @@
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.SocketAddressImpl;
 import io.vertx.core.net.impl.SocketDefaults;
+import org.junit.Assume;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -784,6 +785,8 @@ public void testConnectInvalidConnectHandler() throws Exception {
 
   @Test
   public void testListenInvalidPort() {
+    /* Port 80 is free to use by any application on Windows, so this test fails. */
+    Assume.assumeFalse(System.getProperty("os.name").startsWith("Windows"));
     server.close();
     server = vertx.createNetServer(new NetServerOptions().setPort(80));
     server.connectHandler((netSocket) -> {

File: src/test/java/io/vertx/test/core/JsonArrayTest.java
Patch:
@@ -815,8 +815,8 @@ public void testEncodePrettily() throws Exception {
     jsonArray.add(new JsonObject().put("foo", "bar"));
     jsonArray.add(new JsonArray().add("foo").add(123));
     String strBytes = Base64.getEncoder().encodeToString(bytes);
-    String expected = "[ \"foo\", 123, 1234, 1.23, 2.34, true, \"" + strBytes + "\", null, {\n" +
-      "  \"foo\" : \"bar\"\n" +
+    String expected = "[ \"foo\", 123, 1234, 1.23, 2.34, true, \"" + strBytes + "\", null, {" + System.getProperty("line.separator") +
+      "  \"foo\" : \"bar\"" + System.getProperty("line.separator") +
       "}, [ \"foo\", 123 ] ]";
     String json = jsonArray.encodePrettily();
     assertEquals(expected, json);

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -47,6 +47,7 @@
 import io.vertx.core.net.SocketAddress;
 import io.vertx.core.net.impl.SocketAddressImpl;
 import io.vertx.core.net.impl.SocketDefaults;
+import org.junit.Assume;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -784,6 +785,8 @@ public void testConnectInvalidConnectHandler() throws Exception {
 
   @Test
   public void testListenInvalidPort() {
+    /* Port 80 is free to use by any application on Windows, so this test fails. */
+    Assume.assumeFalse(System.getProperty("os.name").startsWith("Windows"));
     server.close();
     server = vertx.createNetServer(new NetServerOptions().setPort(80));
     server.connectHandler((netSocket) -> {

File: src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -77,7 +77,7 @@ public static void setContext(ContextImpl context) {
         Thread.currentThread().setContextClassLoader(null);
       }
     } else {
-      log.warn("Attempt to setContext on non Vert.x thread " + Thread.currentThread());
+      throw new IllegalStateException("Attempt to setContext on non Vert.x thread " + Thread.currentThread());
     }
   }
 

File: src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -75,6 +75,8 @@ public void testComplexFailover() {
     } catch (Throwable t) {
       // Need to explicitly catch throwables in repeats or they will be swallowed
       t.printStackTrace();
+      // Don't forget to fail!
+      fail(t.getMessage());
     }
   }
 
@@ -97,7 +99,6 @@ protected void deployRandomVerticles(Runnable runner) {
         config.put("foo", TestUtils.randomAlphaString(100));
         DeploymentOptions options = new DeploymentOptions().setHa(true).setConfig(config);
         String verticleName = "java:io.vertx.test.core.HAVerticle" + (random.nextInt(3) + 1);
-        toDeploy++;
         v.deployVerticle(verticleName, options, ar -> {
           assertTrue(ar.succeeded());
           deployCount.incrementAndGet();

File: src/main/java/examples/CoreExamples.java
Patch:
@@ -50,7 +50,7 @@ public void example4(HttpServerRequest request) {
   }
 
   public void example5(Vertx vertx) {
-    vertx.setTimer(1000, id -> {
+    vertx.setPeriodic(1000, id -> {
       // This handler will get called every second
       System.out.println("timer fired!");
     });

File: src/main/java/examples/EventBusExamples.java
Patch:
@@ -79,7 +79,7 @@ public void example6(EventBus eventBus) {
   public void example7(EventBus eventBus) {
     DeliveryOptions options = new DeliveryOptions();
     options.addHeader("some-header", "some-value");
-    eventBus.send("news.uk.sport", "Yay! Someone kicked a ball");
+    eventBus.send("news.uk.sport", "Yay! Someone kicked a ball", options);
   }
 
   public void example8(EventBus eventBus) {

File: src/main/java/io/vertx/core/dns/package-info.java
Patch:
@@ -58,7 +58,7 @@
  *
  * === lookup6
  *
- * Try to lookup the AAAA (ipv5) record for a given name. The first which is returned will be used, so it behaves the
+ * Try to lookup the AAAA (ipv6) record for a given name. The first which is returned will be used, so it behaves the
  * same way as you may be used from when using "nslookup" on your operation system.
  *
  * To lookup the A record for "vertx.io" you would typically use it like:

File: src/main/java/io/vertx/core/eventbus/package-info.java
Patch:
@@ -88,7 +88,7 @@
  *
  * However you are not forced to use JSON if you don't want to.
  *
- * The event bus is very flexible and also supports supports sending arbitrary objects over the event bus.
+ * The event bus is very flexible and also supports sending arbitrary objects over the event bus.
  * You do this by defining a {@link io.vertx.core.eventbus.MessageCodec codec} for the objects you want to send.
  *
  * === The Event Bus API

File: src/main/java/io/vertx/core/Context.java
Patch:
@@ -82,8 +82,6 @@ public interface Context {
 
   /**
    * The process args
-   *
-   * @return
    */
   List<String> processArgs();
 

File: src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -443,7 +443,7 @@ static Context currentContext() {
    * (e.g. on the original event loop of the caller).
    * <p>
    * A {@code Future} instance is passed into {@code blockingCodeHandler}. When the blocking code successfully completes,
-   * the handler should call the {@link Future#complete} or {@link Future#complete(T)} method, or the {@link Future#fail}
+   * the handler should call the {@link Future#complete} or {@link Future#complete(Object)} method, or the {@link Future#fail}
    * method if it failed.
    *
    * @param blockingCodeHandler  handler representing the blocking code to run

File: src/main/java/io/vertx/core/http/HttpServerOptions.java
Patch:
@@ -23,7 +23,7 @@
 import io.vertx.core.net.TrustStoreOptions;
 
 /**
- * Represents options used by an {@link com.sun.net.httpserver.HttpServer} instance
+ * Represents options used by an {@link io.vertx.core.http.HttpServer} instance
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */

File: src/main/java/io/vertx/core/http/HttpServerResponse.java
Patch:
@@ -196,7 +196,7 @@ public interface HttpServerResponse extends WriteStream<Buffer> {
    * Write a {@link String} to the response body, encoded using the encoding {@code enc}.
    *
    * @param chunk  the string to write
-   * @enc  the encoding to use
+   * @param enc  the encoding to use
    * @return a reference to this, so the API can be used fluently
    */
   @Fluent

File: src/main/java/io/vertx/core/http/WebSocketFrame.java
Patch:
@@ -79,7 +79,7 @@ static WebSocketFrame continuationFrame(Buffer data, boolean isFinal) {
   boolean isText();
 
   /**
-   * @eturn true if it's a binary frame
+   * @return true if it's a binary frame
    */
   boolean isBinary();
 

File: src/main/java/io/vertx/core/http/package-info.java
Patch:
@@ -546,7 +546,7 @@
  * HEAD requests.
  *
  * The simplest way to do this with the Vert.x http client is using the methods prefixed with `Now`. For example
- * {@link io.vertx.core.http.HttpClient#getNow)}.
+ * {@link io.vertx.core.http.HttpClient#getNow}.
  *
  * These methods create the http request and send it in a single method call and allow you to provide a handler that will be
  * called with the http response when it comes back.

File: src/main/java/io/vertx/core/json/JsonObject.java
Patch:
@@ -16,6 +16,7 @@
 
 package io.vertx.core.json;
 
+import io.vertx.codegen.annotations.Fluent;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.json.impl.Json;
 import io.vertx.core.shareddata.impl.ClusterSerializable;
@@ -693,8 +694,8 @@ public int size() {
 
   /**
    * Remove all the entries in this JSON object
-   * @return
    */
+  @Fluent
   public JsonObject clear() {
     map.clear();
     return this;

File: src/main/java/io/vertx/core/shareddata/AsyncMap.java
Patch:
@@ -49,7 +49,7 @@ public interface AsyncMap<K, V> {
   void put(K k, V v, Handler<AsyncResult<Void>> completionHandler);
 
   /**
-   * Like {@link #put(K, V, Handler)} but specifying a timeout. If the value cannot be put within the timeout a
+   * Like {@link #put} but specifying a timeout. If the value cannot be put within the timeout a
    * failure will be passed to the handler
    *
    * @param k  the key
@@ -70,7 +70,7 @@ public interface AsyncMap<K, V> {
   void putIfAbsent(K k, V v, Handler<AsyncResult<V>> completionHandler);
 
   /**
-   * Link {@link #putIfAbsent(K, V, Handler)} but specifying a timeout. If the value cannot be put within the timeout a
+   * Link {@link #putIfAbsent} but specifying a timeout. If the value cannot be put within the timeout a
    * failure will be passed to the handler
    *
    * @param k  the key
@@ -92,7 +92,7 @@ public interface AsyncMap<K, V> {
    * Remove a value from the map, only if entry already exists with same value.
    *
    * @param k  the key
-   * @paran v  the value
+   * @param v  the value
    * @param resultHandler - this will be called some time later to signify the value has been removed
    */
   void removeIfPresent(K k, V v, Handler<AsyncResult<Boolean>> resultHandler);

File: src/main/java/io/vertx/core/shareddata/Shareable.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * A marker interface which allows you to put arbitrary objects into a {@link io.vertx.core.shareddata.LocalMap}.
  * <p>
- * Normally local maps only allow immutable objects or other copiable objects such as {@link com.sun.javafx.font.FontFileReader.Buffer}
+ * Normally local maps only allow immutable objects or other copiable objects such as {@link io.vertx.core.buffer.Buffer}
  * instances in order to avoid shared access to mutable state.
  * <p>
  * However if you have an object that you know is thread-safe you can mark it with this interface and then you

File: src/main/java/io/vertx/core/streams/Pump.java
Patch:
@@ -64,7 +64,7 @@ static <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws) {
    *
    * @param rs  the read stream
    * @param ws  the write stream
-   * @paran writeQueueMaxSize  the max size of the write queue
+   * @param writeQueueMaxSize  the max size of the write queue
    * @return the pump
    */
   static <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws, int writeQueueMaxSize) {

File: src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.FixedRecvByteBufAllocator;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.channel.socket.InternetProtocolFamily;
@@ -279,6 +280,7 @@ private static NioDatagramChannel createChannel(io.vertx.core.datagram.impl.Inte
     }
     if (options.getReceiveBufferSize() != -1) {
       channel.config().setReceiveBufferSize(options.getReceiveBufferSize());
+      channel.config().setRecvByteBufAllocator(new FixedRecvByteBufAllocator(options.getReceiveBufferSize()));
     }
     channel.config().setReuseAddress(options.isReuseAddress());
     if (options.getTrafficClass() != -1) {

File: src/main/java/io/vertx/core/package-info.java
Patch:
@@ -25,8 +25,8 @@
  *
  * include::{@link io.vertx.core.buffer}[]
  */
-@Document(fileName = "index.ad")
+@Document(fileName = "index.adoc")
 @io.vertx.codegen.annotations.GenModule(name = "vertx")
 package io.vertx.core;
 
-import io.vertx.docgen.Document;
\ No newline at end of file
+import io.vertx.docgen.Document;

File: src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -487,7 +487,8 @@ public void testCopyServerOptions() {
     int receiverBufferSize = TestUtils.randomPortInt();
     Random rand = new Random();
     boolean reuseAddress = rand.nextBoolean();
-    int trafficClass = TestUtils.randomByte() + 127;boolean tcpNoDelay = rand.nextBoolean();
+    int trafficClass = TestUtils.randomByte() + 128;
+    boolean tcpNoDelay = rand.nextBoolean();
     boolean tcpKeepAlive = rand.nextBoolean();
     int soLinger = TestUtils.randomPositiveInt();
     boolean usePooledBuffers = rand.nextBoolean();

File: vertx-core/src/test/java/io/vertx/test/core/AsyncTestBase.java
Patch:
@@ -47,6 +47,7 @@ public class AsyncTestBase {
   private Map<String, Exception> threadNames = new ConcurrentHashMap<>();
 
   protected void setUp() throws Exception {
+    tearingDown = false;
     latch = new CountDownLatch(1);
     throwable = null;
     testCompleteCalled = false;
@@ -71,7 +72,7 @@ public void after() throws Exception {
 
   protected void testComplete() {
     if (tearingDown) {
-      log.warn("testComplete called after test has completed");
+      throw new IllegalStateException("testComplete called after test has completed");
     }
     checkThread();
     if (testCompleteCalled) {

File: vertx-core/src/main/java/io/vertx/core/json/impl/Json.java
Patch:
@@ -56,6 +56,7 @@ public class Json {
     prettyMapper.registerModule(module);
   }
 
+  @SuppressWarnings("unchecked")
   public static Object checkAndCopy(Object val, boolean copy) {
     if (val == null) {
       // OK
@@ -90,7 +91,7 @@ public static Object checkAndCopy(Object val, boolean copy) {
     } else if (val instanceof byte[]) {
       val = Base64.getEncoder().encodeToString((byte[])val);
     } else {
-      throw new IllegalStateException("Illegal value in JsonObject: " + val);
+      throw new IllegalStateException("Illegal type in JsonObject: " + val.getClass());
     }
     return val;
   }

File: vertx-core/src/main/java/io/vertx/core/json/impl/Json.java
Patch:
@@ -56,6 +56,7 @@ public class Json {
     prettyMapper.registerModule(module);
   }
 
+  @SuppressWarnings("unchecked")
   public static Object checkAndCopy(Object val, boolean copy) {
     if (val == null) {
       // OK
@@ -90,7 +91,7 @@ public static Object checkAndCopy(Object val, boolean copy) {
     } else if (val instanceof byte[]) {
       val = Base64.getEncoder().encodeToString((byte[])val);
     } else {
-      throw new IllegalStateException("Illegal value in JsonObject: " + val);
+      throw new IllegalStateException("Illegal type in JsonObject: " + val.getClass());
     }
     return val;
   }

File: vertx-core/src/main/java/io/vertx/core/datagram/DatagramSocket.java
Patch:
@@ -56,14 +56,13 @@ public interface DatagramSocket extends ReadStream<DatagramPacket>, Measured {
   DatagramSocket send(Buffer packet, int port, String host, Handler<AsyncResult<DatagramSocket>> handler);
 
   /**
-   * Returns a {@link WriteStream} able to write {@link Buffer} to the {@link io.vertx.core.net.SocketAddress}. The
-   * stream {@link WriteStream#exceptionHandler} is called when the write fails.
+   * Returns a {@link io.vertx.core.datagram.PacketWritestream} able to send {@link Buffer} to the {@link io.vertx.core.net.SocketAddress}.
    *
    * @param port the host port of the remote peer
    * @param host the host address of the remote peer
    * @return the write stream for sending packets
    */
-  WriteStream<Buffer> sender(int port, String host);
+  PacketWritestream sender(int port, String host);
 
   /**
    * Write the given {@link String} to the {@link io.vertx.core.net.SocketAddress} using UTF8 encoding. The {@link Handler} will be notified once the

File: vertx-core/src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -27,6 +27,7 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.datagram.DatagramSocket;
 import io.vertx.core.datagram.DatagramSocketOptions;
+import io.vertx.core.datagram.PacketWritestream;
 import io.vertx.core.impl.ContextImpl;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.json.JsonObject;
@@ -209,8 +210,8 @@ public DatagramSocket send(Buffer packet, int port, String host, Handler<AsyncRe
   }
 
   @Override
-  public WriteStream<Buffer> sender(int port, String host) {
-    return new PacketWriteStream(this, port, host);
+  public PacketWritestream sender(int port, String host) {
+    return new PacketWriteStreamImpl(this, port, host);
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/net/NetServer.java
Patch:
@@ -45,7 +45,7 @@ public interface NetServer extends Measured {
    *
    * @return the connect stream
    */
-  ReadStream<NetSocket> connectStream();
+  NetSocketStream connectStream();
 
   /**
    * Supply a connect handler for this server. The server can only have at most one connect handler at any one time.

File: vertx-core/src/main/java/io/vertx/core/logging/Logger.java
Patch:
@@ -65,13 +65,10 @@ public void fatal(final Object message, final Throwable t) {
   }
 
   public void error(final Object message) {
-    //System.out.println("error: " + message);
     delegate.error(message);
   }
 
   public void error(final Object message, final Throwable t) {
-//    System.out.println("error: " + message);
-//    t.printStackTrace();
     delegate.error(message, t);
   }
 

File: vertx-hazelcast/src/main/java/io/vertx/spi/cluster/impl/hazelcast/HazelcastClusterManager.java
Patch:
@@ -168,7 +168,6 @@ public <K, V> void getAsyncMap(String name, MapOptions options, Handler<AsyncRes
       IMap<K, V> map = hazelcast.getMap(name);
       return map;
     }, ar -> {
-      System.out.println("Calling result handler on thread: " + Thread.currentThread());
       if (ar.succeeded()) {
         resultHandler.handle(Future.completedFuture(new HazelcastAsyncMap<>(vertx, ar.result())));
       } else {

File: vertx-core/src/main/java/io/vertx/core/datagram/DatagramSocket.java
Patch:
@@ -56,14 +56,13 @@ public interface DatagramSocket extends ReadStream<DatagramPacket>, Measured {
   DatagramSocket send(Buffer packet, int port, String host, Handler<AsyncResult<DatagramSocket>> handler);
 
   /**
-   * Returns a {@link WriteStream} able to write {@link Buffer} to the {@link io.vertx.core.net.SocketAddress}. The
-   * stream {@link WriteStream#exceptionHandler} is called when the write fails.
+   * Returns a {@link io.vertx.core.datagram.PacketWritestream} able to send {@link Buffer} to the {@link io.vertx.core.net.SocketAddress}.
    *
    * @param port the host port of the remote peer
    * @param host the host address of the remote peer
    * @return the write stream for sending packets
    */
-  WriteStream<Buffer> sender(int port, String host);
+  PacketWritestream sender(int port, String host);
 
   /**
    * Write the given {@link String} to the {@link io.vertx.core.net.SocketAddress} using UTF8 encoding. The {@link Handler} will be notified once the

File: vertx-core/src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -27,6 +27,7 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.datagram.DatagramSocket;
 import io.vertx.core.datagram.DatagramSocketOptions;
+import io.vertx.core.datagram.PacketWritestream;
 import io.vertx.core.impl.ContextImpl;
 import io.vertx.core.impl.VertxInternal;
 import io.vertx.core.json.JsonObject;
@@ -209,8 +210,8 @@ public DatagramSocket send(Buffer packet, int port, String host, Handler<AsyncRe
   }
 
   @Override
-  public WriteStream<Buffer> sender(int port, String host) {
-    return new PacketWriteStream(this, port, host);
+  public PacketWritestream sender(int port, String host) {
+    return new PacketWriteStreamImpl(this, port, host);
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/net/NetServer.java
Patch:
@@ -45,7 +45,7 @@ public interface NetServer extends Measured {
    *
    * @return the connect stream
    */
-  ReadStream<NetSocket> connectStream();
+  NetSocketStream connectStream();
 
   /**
    * Supply a connect handler for this server. The server can only have at most one connect handler at any one time.

File: vertx-core/src/main/java/io/vertx/core/impl/Deployment.java
Patch:
@@ -34,7 +34,9 @@ public interface Deployment {
 
   void doUndeploy(ContextImpl undeployingContext, Handler<AsyncResult<Void>> completionHandler);
 
-  String identifier();
+  String deploymentID();
+
+  String verticleIdentifier();
 
   DeploymentOptions deploymentOptions();
 

File: vertx-core/src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -223,7 +223,7 @@ protected int checkHasDeployments(int pos, int prevPos) {
     for (Deployment prev: prevSet) {
       boolean contains = false;
       for (Deployment curr: currSet) {
-        if (curr.identifier().equals(prev.identifier()) && curr.deploymentOptions().equals(prev.deploymentOptions())) {
+        if (curr.verticleIdentifier().equals(prev.verticleIdentifier()) && curr.deploymentOptions().equals(prev.deploymentOptions())) {
           contains = true;
           break;
         }

File: vertx-core/src/test/java/io/vertx/test/core/HATest.java
Patch:
@@ -258,7 +258,7 @@ public void testNonHADeployments() throws Exception {
 
     assertTrue(vertx1.deployments().size() == 1);
     String depID = vertx1.deployments().iterator().next();
-    assertTrue(((VertxInternal) vertx1).getDeployment(depID).identifier().equals("java:" + HAVerticle1.class.getName()));
+    assertTrue(((VertxInternal) vertx1).getDeployment(depID).verticleIdentifier().equals("java:" + HAVerticle1.class.getName()));
     closeVertices(vertx1, vertx2);
   }
 
@@ -288,7 +288,7 @@ public void testCloseRemovesFromCluster() throws Exception {
 
     assertTrue(vertx1.deployments().size() == 1);
     String depID = vertx1.deployments().iterator().next();
-    assertTrue(((VertxInternal) vertx1).getDeployment(depID).identifier().equals("java:" + HAVerticle1.class.getName()));
+    assertTrue(((VertxInternal) vertx1).getDeployment(depID).verticleIdentifier().equals("java:" + HAVerticle1.class.getName()));
     closeVertices(vertx1, vertx3);
   }
 
@@ -374,7 +374,7 @@ protected void checkDeploymentExists(int pos, String verticleName, DeploymentOpt
     VertxInternal vi = (VertxInternal)vertices[pos];
     for (String deploymentID: vi.deployments()) {
       Deployment dep = vi.getDeployment(deploymentID);
-      if (verticleName.equals(dep.identifier()) && options.equals(dep.deploymentOptions())) {
+      if (verticleName.equals(dep.verticleIdentifier()) && options.equals(dep.deploymentOptions())) {
         return;
       }
     }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/BooleanMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 0;
+    return 3;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/ByteArrayMessageCodec.java
Patch:
@@ -51,6 +51,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 10;
+    return 12;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/ByteMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 1;
+    return 2;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/CharMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 7;
+    return 10;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/DoubleMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 6;
+    return 8;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/FloatMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 5;
+    return 7;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/IntMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 3;
+    return 5;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/JsonArrayMessageCodec.java
Patch:
@@ -56,6 +56,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 13;
+    return 14;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/JsonObjectMessageCodec.java
Patch:
@@ -56,6 +56,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 12;
+    return 13;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/LongMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 4;
+    return 6;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/NullMessageCodec.java
Patch:
@@ -45,6 +45,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 9;
+    return 0;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/ReplyExceptionMessageCodec.java
Patch:
@@ -74,6 +74,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 14;
+    return 15;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/ShortMessageCodec.java
Patch:
@@ -47,6 +47,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 2;
+    return 4;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/codecs/StringMessageCodec.java
Patch:
@@ -53,6 +53,6 @@ public String name() {
 
   @Override
   public byte systemCodecID() {
-    return 8;
+    return 9;
   }
 }

File: vertx-core/src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -136,7 +136,8 @@ public class VertxImpl implements VertxInternal {
           haManager = new HAManager(this, deploymentManager, clusterManager, options.getQuorumSize(), options.getHAGroup());
         }
         Vertx inst = this;
-        eventBus = new EventBusImpl(this, options.getClusterPort(), options.getClusterHost(), clusterManager, res -> {
+        eventBus = new EventBusImpl(this, options.getClusterPingInterval(),
+            options.getClusterPingReplyInterval(),  options.getClusterPort(), options.getClusterHost(), clusterManager, res -> {
           if (resultHandler != null) {
             if (res.succeeded()) {
               resultHandler.handle(Future.completedFuture(inst));

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -209,11 +209,11 @@ public EventBus publish(String address, Object message, DeliveryOptions options)
     return this;
   }
 
-  EventBus forward(String address, Object message) {
-    return forward(address, message, null);
+  EventBus forward(Object message) {
+    return forward(message, null);
   }
 
-  EventBus forward(String address, Object message, DeliveryOptions options) {
+  EventBus forward(Object message, DeliveryOptions options) {
     sendOrPub(null, (MessageImpl)message, options, null);
     return this;
   }

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/MessageImpl.java
Patch:
@@ -245,7 +245,7 @@ private void writeHeaders(Buffer buffer) {
       }
       int headersEndPos = buffer.getByteBuf().writerIndex();
       buffer.setInt(headersLengthPos, headersEndPos - headersLengthPos);
-    }else if((headers == null && headersPos != 0) || (headers != null && headersPos == 0)){                        
+    } else if((headers == null && headersPos != 0) || (headers != null && headersPos == 0)){                        
       //headers could exist, just have never been read
       int length = wireBuffer.getInt(headersPos);            
       buffer.appendInt(length);
@@ -285,7 +285,7 @@ private void readHeaders() {
   private void writeBody(Buffer buff) {
     if(sentBody != null){
       messageCodec.encodeToWire(buff, sentBody);          
-    }else if((receivedBody == null && bodyPos != 0)  || (receivedBody != null && bodyPos == 0)){      
+    } else if((receivedBody == null && bodyPos != 0)  || (receivedBody != null && bodyPos == 0)){      
       int length = wireBuffer.getInt(absoluteBodyPos);
       byte[] bytes = wireBuffer.getBytes(absoluteBodyPos + 4, absoluteBodyPos + 4 + length);
       buff.appendInt(bytes.length);

File: vertx-core/src/test/java/io/vertx/test/core/EventBusTestBase.java
Patch:
@@ -336,12 +336,12 @@ public void testForwardWithHeaders(){
     DeliveryOptions options = new DeliveryOptions();
     options.addHeader("first", "first");
     options.addHeader("second", "second");
-    testForward("Test body", options);
+    testForwardWithHeaders("Test body", options);
   }
     
   protected abstract <T> void testForward(T val);
   
-  protected abstract <T> void testForward(T val, DeliveryOptions options);
+  protected abstract <T> void testForwardWithHeaders(T val, DeliveryOptions options);
   
   protected <T> void testSend(T val) {
     testSend(val, null);

File: vertx-core/src/main/java/io/vertx/core/datagram/impl/DatagramSocketImpl.java
Patch:
@@ -51,7 +51,7 @@ public class DatagramSocketImpl extends ConnectionBase implements DatagramSocket
 
   public DatagramSocketImpl(VertxInternal vertx, DatagramSocketOptions options) {
     super(vertx, createChannel(options.isIpV6() ? io.vertx.core.datagram.impl.InternetProtocolFamily.IPv6 : io.vertx.core.datagram.impl.InternetProtocolFamily.IPv4,
-          new DatagramSocketOptions(options)), vertx.getOrCreateContext(), vertx.metricsSPI().register(null, options));
+          new DatagramSocketOptions(options)), vertx.getOrCreateContext(), vertx.metricsSPI().createMetrics(null, options));
     ContextImpl creatingContext = vertx.getContext();
     if (creatingContext != null && creatingContext.isMultiThreaded()) {
       throw new IllegalStateException("Cannot use DatagramSocket in a multi-threaded worker verticle");
@@ -215,7 +215,7 @@ public DatagramSocket send(String str, String enc, int port, String host, Handle
   public void close(final Handler<AsyncResult<Void>> handler) {
     // make sure everything is flushed out on close
     endReadAndFlush();
-    metrics.closed();
+    metrics.close();
     ChannelFuture future = channel.close();
     if (handler != null) {
       future.addListener(new DatagramChannelFutureListener<>(null, handler, vertx, context));

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -131,7 +131,7 @@ public EventBusImpl(VertxInternal vertx, long proxyOperationTimeout) {
     this.subs = null;
     this.clusterMgr = null;
     this.proxyFactory = new ProxyFactory(this, proxyOperationTimeout);
-    this.metrics = vertx.metricsSPI().register(this);
+    this.metrics = vertx.metricsSPI().createMetrics(this);
     setPingHandler();
     putStandardCodecs();
   }
@@ -141,7 +141,7 @@ public EventBusImpl(VertxInternal vertx, long proxyOperationTimeout, int port, S
     this.vertx = vertx;
     this.clusterMgr = clusterManager;
     this.proxyFactory = new ProxyFactory(this, proxyOperationTimeout);
-    this.metrics = vertx.metricsSPI().register(this);
+    this.metrics = vertx.metricsSPI().createMetrics(this);
     clusterMgr.<String, ServerID>getAsyncMultiMap("subs", null, ar -> {
       if (ar.succeeded()) {
         subs = ar.result();

File: vertx-core/src/main/java/io/vertx/core/http/impl/ClientConnection.java
Patch:
@@ -70,13 +70,13 @@ class ClientConnection extends ConnectionBase {
   private final String host;
   private final int port;
   private final ConnectionLifeCycleListener listener;
-  final HttpClientMetrics metrics;
   private WebSocketClientHandshaker handshaker;
   private volatile HttpClientRequestImpl currentRequest;
   // Requests can be pipelined so we need a queue to keep track of requests
   private final Queue<HttpClientRequestImpl> requests = new ArrayDeque<>();
   private volatile HttpClientResponseImpl currentResponse;
   private volatile HttpClientRequestImpl requestForResponse;
+  final HttpClientMetrics metrics;
 
   private WebSocketImpl ws;
 

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -111,7 +111,7 @@ protected void connect(String host, int port, Handler<ClientConnection> connectH
     pool.setKeepAlive(options.isKeepAlive());
     pool.setPipelining(options.isPipelining());
     pool.setMaxSockets(options.getMaxPoolSize());
-    this.metrics = vertx.metricsSPI().register(this, options);
+    this.metrics = vertx.metricsSPI().createMetrics(this, options);
   }
 
   @Override
@@ -176,7 +176,7 @@ public synchronized void close() {
       creatingContext.removeCloseHook(closeHook);
     }
     closed = true;
-    metrics.closed();
+    metrics.close();
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -156,7 +156,7 @@ public ReadStream<HttpServerRequest> handler(Handler<HttpServerRequest> handler)
       }
     };
     this.subProtocols = options.getWebsocketSubProtocols();
-    this.metrics = vertx.metricsSPI().register(this, options);
+    this.metrics = vertx.metricsSPI().createMetrics(this, options);
   }
 
   @Override
@@ -457,7 +457,7 @@ private void actualClose(final ContextImpl closeContext, final Handler<AsyncResu
     } catch (InterruptedException e) {
     }
 
-    metrics.closed();
+    metrics.close();
 
     executeCloseDone(closeContext, done, fut.cause());
   }

File: vertx-core/src/main/java/io/vertx/core/impl/VertxInternal.java
Patch:
@@ -21,7 +21,7 @@
 import io.vertx.core.Handler;
 import io.vertx.core.http.impl.HttpServerImpl;
 import io.vertx.core.json.JsonObject;
-import io.vertx.core.metrics.spi.Metrics;
+import io.vertx.core.metrics.spi.VertxMetrics;
 import io.vertx.core.net.impl.NetServerImpl;
 import io.vertx.core.net.impl.ServerID;
 import io.vertx.core.spi.cluster.VertxSPI;
@@ -48,7 +48,7 @@ public interface VertxInternal extends VertxSPI {
 
   Map<ServerID, NetServerImpl> sharedNetServers();
 
-  Metrics metricsSPI();
+  VertxMetrics metricsSPI();
 
 	/**
 	 * Get the current context

File: vertx-core/src/main/java/io/vertx/core/metrics/spi/BaseMetrics.java
Patch:
@@ -20,7 +20,10 @@
  * @author <a href="mailto:nscavell@redhat.com">Nick Scavelli</a>
  */
 public interface BaseMetrics {
+
   String baseName();
 
   boolean isEnabled();
+
+  void close();
 }

File: vertx-core/src/main/java/io/vertx/core/metrics/spi/NetMetrics.java
Patch:
@@ -34,6 +34,4 @@ public interface NetMetrics extends BaseMetrics {
   void bytesWritten(SocketAddress remoteAddress, long numberOfBytes);
 
   void exceptionOccurred(SocketAddress remoteAddress, Throwable t);
-
-  void closed();
 }

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -80,7 +80,7 @@ public NetClientImpl(VertxInternal vertx, NetClientOptions options) {
       }
       creatingContext.addCloseHook(closeHook);
     }
-    this.metrics = vertx.metricsSPI().register(this, options);
+    this.metrics = vertx.metricsSPI().createMetrics(this, options);
   }
 
   @Override
@@ -100,7 +100,7 @@ public synchronized void close() {
         creatingContext.removeCloseHook(closeHook);
       }
       closed = true;
-      metrics.closed();
+      metrics.close();
     }
   }
 

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -97,7 +97,7 @@ public NetServerImpl(VertxInternal vertx, NetServerOptions options) {
       }
       creatingContext.addCloseHook(this);
     }
-    this.metrics = vertx.metricsSPI().register(this, options);
+    this.metrics = vertx.metricsSPI().createMetrics(this, options);
   }
 
   @Override
@@ -365,7 +365,7 @@ private void actualClose(final ContextImpl closeContext, final Handler<AsyncResu
 
     ChannelGroupFuture fut = serverChannelGroup.close();
     fut.addListener(cg -> {
-      metrics.closed();
+      metrics.close();
       executeCloseDone(closeContext, done, fut.cause());
     });
 

File: vertx-core/src/main/java/io/vertx/core/spi/VertxMetricsFactory.java
Patch:
@@ -18,11 +18,11 @@
 
 import io.vertx.core.Vertx;
 import io.vertx.core.VertxOptions;
-import io.vertx.core.metrics.spi.Metrics;
+import io.vertx.core.metrics.spi.VertxMetrics;
 
 /**
  * @author <a href="mailto:nscavell@redhat.com">Nick Scavelli</a>
  */
-public interface MetricsFactory {
-  Metrics metrics(Vertx vertx, VertxOptions options);
+public interface VertxMetricsFactory {
+  VertxMetrics metrics(Vertx vertx, VertxOptions options);
 }

File: vertx-core/src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -46,9 +46,6 @@ protected ClusterManager getClusterManager() {
     return new FakeClusterManager();
   }
 
-  @Rule
-  public RepeatRule repeatRule = new RepeatRule();
-
   private Random random = new Random();
 
   protected int maxVerticlesPerNode = 20;

File: vertx-core/src/test/java/io/vertx/test/core/VertxOptionsTest.java
Patch:
@@ -215,7 +215,7 @@ public void testCopyOptions() {
     assertEquals(haEnabled, options.isHAEnabled());
     assertEquals(quorumSize, options.getQuorumSize());
     assertEquals(haGroup, options.getHAGroup());
-    assertEquals(metricsEnabled, options.isMetricsEnabled());
+    assertEquals(metricsEnabled || jmxEnabled, options.isMetricsEnabled());
     assertEquals(jmxEnabled, options.isJmxEnabled());
     assertEquals(jmxDomain, options.getJmxDomain());
   }

File: vertx-core/src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java
Patch:
@@ -32,7 +32,7 @@ public class VertxLoggerFormatter extends java.util.logging.Formatter {
   public String format(final LogRecord record) {
     Date date = new Date();
     SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
-    StringBuffer sb = new StringBuffer();
+    StringBuilder sb = new StringBuilder();
     // Minimize memory allocations here.
     date.setTime(record.getMillis());
     sb.append("[").append(Thread.currentThread().getName()).append("] ");

File: vertx-core/src/main/java/io/vertx/core/http/HttpServer.java
Patch:
@@ -21,6 +21,7 @@
 import io.vertx.core.Handler;
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.VertxGen;
+import io.vertx.core.streams.ReadStream;
 
 /**
  * An HTTP and WebSockets server<p>
@@ -42,7 +43,7 @@ public interface HttpServer {
    *
    * @return the request stream
    */
-  HttpStream<HttpServerRequest> requestStream();
+  ReadStream<HttpServerRequest> requestStream();
 
   /**
    * Set the request handler for the server to {@code requestHandler}. As HTTP requests are received by the server,
@@ -61,7 +62,7 @@ public interface HttpServer {
    *
    * @return the websocket stream
    */
-  HttpStream<ServerWebSocket> websocketStream();
+  ReadStream<ServerWebSocket> websocketStream();
 
 
 

File: vertx-core/src/main/java/io/vertx/core/http/impl/WebSocketImplBase.java
Patch:
@@ -35,7 +35,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public abstract class WebSocketImplBase<T> implements WebSocketBase<T> {
+public abstract class WebSocketImplBase<T> implements WebSocketBase {
 
   private final boolean supportsContinuation;
   private final String textHandlerID;

File: vertx-core/src/main/java/io/vertx/core/net/NetServer.java
Patch:
@@ -21,6 +21,7 @@
 import io.vertx.core.Handler;
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.VertxGen;
+import io.vertx.core.streams.ReadStream;
 
 /**
  * Represents a TCP or SSL server<p>
@@ -39,11 +40,11 @@ public interface NetServer {
   /**
    * Return the connect stream for this server. The server can only have at most one handler at any one time.
    * As the server accepts TCP or SSL connections it creates an instance of {@link NetSocket} and passes it to the
-   * connect stream {@link NetStream#handler(io.vertx.core.Handler)}.
+   * connect stream {@link ReadStream#handler(io.vertx.core.Handler)}.
    *
    * @return the connect stream
    */
-  NetStream connectStream();
+  ReadStream<NetSocket> connectStream();
 
   /**
    * Supply a connect handler for this server. The server can only have at most one connect handler at any one time.

File: vertx-core/src/main/java/io/vertx/core/spi/PumpFactory.java
Patch:
@@ -25,7 +25,7 @@
  */
 public interface PumpFactory {
 
-  <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws);
+  <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws);
 
-  <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws, int writeQueueMaxSize);
+  <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws, int writeQueueMaxSize);
 }

File: vertx-core/src/main/java/io/vertx/core/streams/Pump.java
Patch:
@@ -46,15 +46,15 @@ public interface Pump {
   /**
    * Create a new {@code Pump} with the given {@code ReadStream} and {@code WriteStream}
    */
-  static <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws) {
+  static <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws) {
     return factory.pump(rs, ws);
   }
 
   /**
    * Create a new {@code Pump} with the given {@code ReadStream} and {@code WriteStream} and
    * {@code writeQueueMaxSize}
    */
-  static <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws, int writeQueueMaxSize) {
+  static <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws, int writeQueueMaxSize) {
     return factory.pump(rs, ws, writeQueueMaxSize);
   }
 

File: vertx-core/src/main/java/io/vertx/core/streams/StreamBase.java
Patch:
@@ -26,11 +26,11 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen(concrete = false)
-public interface StreamBase<R> {
+public interface StreamBase {
 
   /**
    * Set an exception handler.
    */
   @Fluent
-  R exceptionHandler(Handler<Throwable> handler);
+  StreamBase exceptionHandler(Handler<Throwable> handler);
 }

File: vertx-core/src/main/java/io/vertx/core/streams/impl/PumpFactoryImpl.java
Patch:
@@ -26,12 +26,12 @@
  */
 public class PumpFactoryImpl implements PumpFactory{
   @Override
-  public <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws) {
+  public <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws) {
     return new PumpImpl<>(rs, ws);
   }
 
   @Override
-  public <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws, int writeQueueMaxSize) {
+  public <T> Pump pump(ReadStream<T> rs, WriteStream<T> ws, int writeQueueMaxSize) {
     return new PumpImpl<>(rs, ws, writeQueueMaxSize);
   }
 }

File: vertx-core/src/test/java/io/vertx/test/core/PumpTest.java
Patch:
@@ -92,7 +92,7 @@ public void testPumpPauseResume() throws Exception {
     }
   }
 
-  private class FakeReadStream<T> implements ReadStream<FakeReadStream, T> {
+  private class FakeReadStream<T> implements ReadStream<T> {
 
     private Handler<T> dataHandler;
     private boolean paused;
@@ -143,7 +143,7 @@ public FakeReadStream endHandler(Handler<Void> endHandler) {
     }
   }
 
-  private class FakeWriteStream<T> implements WriteStream<FakeWriteStream, T> {
+  private class FakeWriteStream<T> implements WriteStream<T> {
 
     int maxSize;
     List<T> received = new ArrayList<>();

File: vertx-core/src/test/java/io/vertx/test/core/WebsocketTest.java
Patch:
@@ -25,7 +25,6 @@
 import io.vertx.core.http.HttpServer;
 import io.vertx.core.http.HttpServerOptions;
 import io.vertx.core.http.HttpServerRequest;
-import io.vertx.core.http.HttpStream;
 import io.vertx.core.http.ServerWebSocket;
 import io.vertx.core.http.WebSocketConnectOptions;
 import io.vertx.core.http.WebSocketFrame;
@@ -1005,7 +1004,7 @@ public void testWebsocketPauseAndResume() {
     client = vertx.createHttpClient(new HttpClientOptions().setConnectTimeout(1000));
     String path = "/some/path";
     this.server = vertx.createHttpServer(new HttpServerOptions().setAcceptBacklog(1).setPort(HttpTestBase.DEFAULT_HTTP_PORT));
-    HttpStream<ServerWebSocket> stream = server.websocketStream();
+    ReadStream<ServerWebSocket> stream = server.websocketStream();
     stream.handler(ws -> {
       ws.writeMessage(Buffer.buffer("whatever"));
       ws.close();
@@ -1052,7 +1051,7 @@ public void testWebsocketPauseAndResume() {
   @Test
   public void testClosingServerClosesWebSocketStreamEndHandler() {
     this.server = vertx.createHttpServer(new HttpServerOptions().setPort(HttpTestBase.DEFAULT_HTTP_PORT));
-    HttpStream<ServerWebSocket> stream = server.websocketStream();
+    ReadStream<ServerWebSocket> stream = server.websocketStream();
     AtomicBoolean closed = new AtomicBoolean();
     stream.endHandler(v -> closed.set(true));
     stream.handler(ws -> {});

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -365,7 +365,7 @@ public void handle(Buffer buff) {
         }
       };
       parser.setOutput(handler);
-      socket.dataHandler(parser);
+      socket.handler(parser);
     });
 
     server.listen(asyncResult -> {
@@ -816,7 +816,7 @@ synchronized void connected(ServerID theServerID, NetSocket socket) {
       connected = true;
       socket.exceptionHandler(t -> cleanupConnection(theServerID, ConnectionHolder.this, true));
       socket.closeHandler(v -> cleanupConnection(theServerID, ConnectionHolder.this, false));
-      socket.dataHandler(data -> {
+      socket.handler(data -> {
         // Got a pong back
         vertx.cancelTimer(timeoutID);
         schedulePing(ConnectionHolder.this);

File: vertx-core/src/main/java/io/vertx/core/file/AsyncFile.java
Patch:
@@ -35,7 +35,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface AsyncFile extends ReadStream<AsyncFile>, WriteStream<AsyncFile> {
+public interface AsyncFile extends ReadStream<AsyncFile, Buffer>, WriteStream<AsyncFile, Buffer> {
 
   /**
    * Close the file. The actual close happens asynchronously.

File: vertx-core/src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -246,7 +246,7 @@ private void doRead() {
   }
 
   @Override
-  public AsyncFile dataHandler(Handler<Buffer> handler) {
+  public AsyncFile handler(Handler<Buffer> handler) {
     check();
     this.dataHandler = handler;
     if (dataHandler != null && !paused && !closed) {

File: vertx-core/src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -62,7 +62,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface HttpClientRequest extends WriteStream<HttpClientRequest> {
+public interface HttpClientRequest extends WriteStream<HttpClientRequest, Buffer> {
 
   /**
    * If chunked is true then the request will be set into HTTP chunked mode

File: vertx-core/src/main/java/io/vertx/core/http/HttpClientResponse.java
Patch:
@@ -40,7 +40,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface HttpClientResponse extends ReadStream<HttpClientResponse> {
+public interface HttpClientResponse extends ReadStream<HttpClientResponse, Buffer> {
 
   /**
    * The HTTP status code of the response

File: vertx-core/src/main/java/io/vertx/core/http/HttpServerFileUpload.java
Patch:
@@ -17,6 +17,7 @@
 
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.VertxGen;
+import io.vertx.core.buffer.Buffer;
 import io.vertx.core.streams.ReadStream;
 
 /**
@@ -25,7 +26,7 @@
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
 @VertxGen
-public interface HttpServerFileUpload extends ReadStream<HttpServerFileUpload> {
+public interface HttpServerFileUpload extends ReadStream<HttpServerFileUpload, Buffer> {
   /**
    * Stream the content of this upload to the given filename.
    */

File: vertx-core/src/main/java/io/vertx/core/http/HttpServerRequest.java
Patch:
@@ -44,7 +44,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface HttpServerRequest extends ReadStream<HttpServerRequest> {
+public interface HttpServerRequest extends ReadStream<HttpServerRequest, Buffer> {
 
   /**
    * The HTTP version of the request

File: vertx-core/src/main/java/io/vertx/core/http/HttpServerResponse.java
Patch:
@@ -44,7 +44,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface HttpServerResponse extends WriteStream<HttpServerResponse> {
+public interface HttpServerResponse extends WriteStream<HttpServerResponse, Buffer> {
 
   /**
    * The HTTP status code of the response. The default is {@code 200} representing {@code OK}.

File: vertx-core/src/main/java/io/vertx/core/http/WebSocketBase.java
Patch:
@@ -37,7 +37,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen(concrete = false)
-public interface WebSocketBase<T> extends ReadStream<T>, WriteStream<T> {
+public interface WebSocketBase<T> extends ReadStream<T, Buffer>, WriteStream<T, Buffer> {
 
   /**
    * When a {@code Websocket} is created it automatically registers an event handler with the eventbus, the ID of that

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -424,8 +424,8 @@ public HttpClientResponse endHandler(Handler<Void> endHandler) {
           }
 
           @Override
-          public HttpClientResponse dataHandler(Handler<Buffer> handler) {
-            resp.dataHandler(handler);
+          public HttpClientResponse handler(Handler<Buffer> handler) {
+            resp.handler(handler);
             return this;
           }
 

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientResponseImpl.java
Patch:
@@ -109,7 +109,7 @@ public List<String> cookies() {
   }
 
   @Override
-  public HttpClientResponse dataHandler(Handler<Buffer> dataHandler) {
+  public HttpClientResponse handler(Handler<Buffer> dataHandler) {
     this.dataHandler = dataHandler;
     return this;
   }
@@ -144,7 +144,7 @@ public HttpClientResponse resume() {
   @Override
   public HttpClientResponse bodyHandler(final Handler<Buffer> bodyHandler) {
     final BodyHandler handler = new BodyHandler();
-    dataHandler(handler);
+    handler(handler);
     endHandler(new VoidHandler() {
       public void handle() {
         handler.notifyHandler(bodyHandler);

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerFileUploadImpl.java
Patch:
@@ -101,7 +101,7 @@ public long size() {
   }
 
   @Override
-  public HttpServerFileUpload dataHandler(Handler<Buffer> handler) {
+  public HttpServerFileUpload handler(Handler<Buffer> handler) {
     this.dataHandler = handler;
     return this;
   }

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerRequestImpl.java
Patch:
@@ -169,7 +169,7 @@ public Headers params() {
   }
 
   @Override
-  public HttpServerRequest dataHandler(Handler<Buffer> dataHandler) {
+  public HttpServerRequest handler(Handler<Buffer> dataHandler) {
     this.dataHandler = dataHandler;
     return this;
   }
@@ -229,7 +229,7 @@ public X509Certificate[] peerCertificateChain() throws SSLPeerUnverifiedExceptio
   @Override
   public HttpServerRequest bodyHandler(final Handler<Buffer> bodyHandler) {
     final Buffer body = Buffer.buffer();
-    dataHandler(body::appendBuffer);
+    handler(body::appendBuffer);
     endHandler(v -> bodyHandler.handle(body));
     return this;
   }

File: vertx-core/src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -94,7 +94,7 @@ public void close() {
   }
 
   @Override
-  public ServerWebSocket dataHandler(Handler<Buffer> handler) {
+  public ServerWebSocket handler(Handler<Buffer> handler) {
     checkClosed();
     this.dataHandler = handler;
     return this;

File: vertx-core/src/main/java/io/vertx/core/http/impl/WebSocketImpl.java
Patch:
@@ -30,7 +30,7 @@ public WebSocketImpl(VertxInternal vertx, ConnectionBase conn, boolean supportsC
   }
 
   @Override
-  public WebSocket dataHandler(Handler<Buffer> handler) {
+  public WebSocket handler(Handler<Buffer> handler) {
     checkClosed();
     this.dataHandler = handler;
     return this;

File: vertx-core/src/main/java/io/vertx/core/net/NetSocket.java
Patch:
@@ -21,6 +21,7 @@
 import io.vertx.codegen.annotations.CacheReturn;
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.VertxGen;
+import io.vertx.core.buffer.Buffer;
 import io.vertx.core.streams.ReadStream;
 import io.vertx.core.streams.WriteStream;
 
@@ -37,7 +38,7 @@
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen
-public interface NetSocket extends ReadStream<NetSocket>, WriteStream<NetSocket> {
+public interface NetSocket extends ReadStream<NetSocket, Buffer>, WriteStream<NetSocket, Buffer> {
 
   /**
    * When a {@code NetSocket} is created it automatically registers an event handler with the event bus, the ID of that

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetSocketImpl.java
Patch:
@@ -99,7 +99,7 @@ public NetSocket write(String str, String enc) {
   }
 
   @Override
-  public NetSocket dataHandler(Handler<Buffer> dataHandler) {
+  public NetSocket handler(Handler<Buffer> dataHandler) {
     this.dataHandler = dataHandler;
     return this;
   }

File: vertx-core/src/main/java/io/vertx/core/spi/PumpFactory.java
Patch:
@@ -25,7 +25,7 @@
  */
 public interface PumpFactory {
 
-  Pump pump(ReadStream<?> rs, WriteStream<?> ws);
+  <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws);
 
-  Pump pump(ReadStream<?> rs, WriteStream<?> ws, int writeQueueMaxSize);
+  <T> Pump pump(ReadStream<?, T> rs, WriteStream<?, T> ws, int writeQueueMaxSize);
 }

File: vertx-core/src/main/java/io/vertx/core/streams/StreamBase.java
Patch:
@@ -19,19 +19,18 @@
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.VertxGen;
 import io.vertx.core.Handler;
-import io.vertx.core.buffer.Buffer;
 
 /**
  * Represents a stream of data.<p>
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 @VertxGen(concrete = false)
-public interface StreamBase<T> {
+public interface StreamBase<R> {
 
   /**
    * Set an exception handler.
    */
   @Fluent
-  T exceptionHandler(Handler<Throwable> handler);
+  R exceptionHandler(Handler<Throwable> handler);
 }

File: vertx-core/src/main/java/io/vertx/core/dns/DnsException.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.vertx.core.dns;
 
+import java.util.Objects;
+
 /**
  * Exception which is used to notify the {@link io.vertx.core.AsyncResult}
  * if the DNS query returns a {@link DnsResponseCode} which indicates and error.
@@ -26,9 +28,7 @@ public final class DnsException extends Exception {
   private DnsResponseCode code;
 
   public DnsException(DnsResponseCode code) {
-    if (code == null) {
-      throw new NullPointerException("code");
-    }
+    Objects.requireNonNull(code, "code");
     this.code = code;
   }
 

File: vertx-core/src/main/java/io/vertx/core/dns/impl/netty/DnsHeader.java
Patch:
@@ -15,6 +15,8 @@
  */
 package io.vertx.core.dns.impl.netty;
 
+import java.util.Objects;
+
 /**
  * The header super-class which includes information shared by DNS query and
  * response packet headers such as the ID, opcode, and type. The only flag
@@ -52,9 +54,7 @@ public class DnsHeader {
   private int type;
 
   public DnsHeader(DnsMessage<? extends DnsHeader> parent) {
-    if (parent == null) {
-      throw new NullPointerException("the parent field cannot be null and must point to a valid DnsMessage.");
-    }
+    Objects.requireNonNull(parent, "the parent field cannot be null and must point to a valid DnsMessage.");
     this.parent = parent;
   }
 

File: vertx-core/src/main/java/io/vertx/core/file/impl/FileSystemImpl.java
Patch:
@@ -55,6 +55,7 @@
 import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 import java.util.regex.Pattern;
 
@@ -702,6 +703,7 @@ public Buffer perform() {
   }
 
   private BlockingAction<Void> writeFileInternal(String path, final Buffer data, Handler<AsyncResult<Void>> handler) {
+    Objects.requireNonNull(data, "no null data accepted");
     final Path target = PathAdjuster.adjust(vertx, Paths.get(path));
     return new BlockingAction<Void>(handler) {
       public Void perform() {
@@ -716,6 +718,7 @@ public Void perform() {
   }
 
   private BlockingAction<AsyncFile> openInternal(String p, OpenOptions options, Handler<AsyncResult<AsyncFile>> handler) {
+    Objects.requireNonNull(options, "no null options accepted");
     final String path = PathAdjuster.adjust(vertx, p);
     return new BlockingAction<AsyncFile>(handler) {
       public AsyncFile perform() {

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java
Patch:
@@ -37,6 +37,7 @@
 import io.vertx.core.logging.Logger;
 import io.vertx.core.logging.impl.LoggerFactory;
 
+import java.util.Objects;
 import java.util.concurrent.TimeoutException;
 
 /**
@@ -132,6 +133,7 @@ public HttpClientRequestImpl write(String chunk) {
 
   @Override
   public HttpClientRequestImpl write(String chunk, String enc) {
+    Objects.requireNonNull(enc, "no null encoding accepted");
     check();
     return write(Buffer.buffer(chunk, enc));
   }
@@ -205,6 +207,7 @@ public void end(String chunk) {
 
   @Override
   public void end(String chunk, String enc) {
+    Objects.requireNonNull(enc, "no null encoding accepted");
     end(Buffer.buffer(chunk, enc));
   }
 

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -43,6 +43,7 @@
 
 import java.net.InetSocketAddress;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -123,6 +124,8 @@ private void applyConnectionOptions(Bootstrap bootstrap) {
 
   private void connect(final int port, final String host, final Handler<AsyncResult<NetSocket>> connectHandler,
                        final int remainingAttempts) {
+    Objects.requireNonNull(host, "No null host accepted");
+    Objects.requireNonNull(connectHandler, "No null connectHandler accepted");
     ContextImpl context = vertx.getOrCreateContext();
     sslHelper.checkSSL(vertx);
     Bootstrap bootstrap = new Bootstrap();

File: vertx-core/src/test/java/io/vertx/test/core/ClusteredAsynchronousLockTest.java
Patch:
@@ -19,7 +19,6 @@
 import io.vertx.core.Vertx;
 import io.vertx.core.spi.cluster.ClusterManager;
 import io.vertx.test.fakecluster.FakeClusterManager;
-import org.junit.Before;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
@@ -33,8 +32,8 @@ protected ClusterManager getClusterManager() {
 
   protected final int numNodes = 2;
 
-  @Before
-  public void before() throws Exception {
+  public void setUp() throws Exception {
+    super.setUp();
     startNodes(numNodes);
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/ClusteredSharedCounterTest.java
Patch:
@@ -19,7 +19,6 @@
 import io.vertx.core.Vertx;
 import io.vertx.core.spi.cluster.ClusterManager;
 import io.vertx.test.fakecluster.FakeClusterManager;
-import org.junit.Before;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
@@ -33,8 +32,8 @@ protected ClusterManager getClusterManager() {
 
   protected final int numNodes = 2;
 
-  @Before
-  public void before() throws Exception {
+  public void setUp() throws Exception {
+    super.setUp();
     startNodes(numNodes);
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -24,7 +24,6 @@
 import io.vertx.core.json.JsonObject;
 import io.vertx.core.spi.cluster.ClusterManager;
 import io.vertx.test.fakecluster.FakeClusterManager;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -58,8 +57,8 @@ protected ClusterManager getClusterManager() {
   protected volatile int killedNode;
   protected List<Integer> aliveNodes;
 
-  @Before
-  public void before() {
+  public void setUp() throws Exception {
+    super.setUp();
     deploymentSnapshots = null;
     totDeployed = 0;
     killedNode = 0;

File: vertx-core/src/test/java/io/vertx/test/core/DatagramTest.java
Patch:
@@ -22,7 +22,6 @@
 import io.vertx.core.datagram.DatagramSocket;
 import io.vertx.core.datagram.DatagramSocketOptions;
 import io.vertx.core.json.JsonObject;
-import org.junit.After;
 import org.junit.Test;
 
 import java.net.InetAddress;
@@ -41,8 +40,7 @@ public class DatagramTest extends VertxTestBase {
   private volatile DatagramSocket peer1;
   private volatile DatagramSocket peer2;
 
-  @After
-  public void after() throws Exception {
+  protected void tearDown() throws Exception {
     if (peer1 != null) {
       CountDownLatch latch = new CountDownLatch(2);
       peer1.close(ar -> {
@@ -59,6 +57,7 @@ public void after() throws Exception {
       });
       latch.await(10L, TimeUnit.SECONDS);
     }
+    super.tearDown();
   }
 
   @Test

File: vertx-core/src/test/java/io/vertx/test/core/DeploymentTest.java
Patch:
@@ -56,8 +56,8 @@
  */
 public class DeploymentTest extends VertxTestBase {
 
-  @Before
-  public void before() {
+  public void setUp() throws Exception {
+    super.setUp();
     TestVerticle.instanceCount.set(0);
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/EventBusProxyTest.java
Patch:
@@ -23,7 +23,6 @@
 import io.vertx.core.eventbus.EventBus;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
-import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -35,8 +34,8 @@ public class EventBusProxyTest extends VertxTestBase {
   protected MyService proxy;
   protected MyServiceImpl impl;
 
-  @Before
-  public void before() {
+  public void setUp() throws Exception {
+    super.setUp();
     eb = vertx.eventBus();
     impl = new MyServiceImpl();
     eb.registerService(impl, "service_address");

File: vertx-core/src/test/java/io/vertx/test/core/HATest.java
Patch:
@@ -75,10 +75,10 @@ public void testQuorum() throws Exception {
     // Shouldn't deploy until a quorum is obtained
     Thread.sleep(500);
     assertTrue(vertx1.deployments().isEmpty());
-    startVertx(2);
+    Vertx vertx2 = startVertx(2);
     // Now should be deployed
     await();
-    closeVertices(vertx1);
+    closeVertices(vertx1, vertx2);
   }
 
   @Rule
@@ -294,6 +294,7 @@ public void testCloseRemovesFromCluster() throws Exception {
 
   @Test
   public void testQuorumWithHaGroups() throws Exception {
+
     Vertx vertx1 = startVertx("group1", 2);
     Vertx vertx2 = startVertx("group2", 2);
 

File: vertx-core/src/test/java/io/vertx/test/core/HttpCompressionTest.java
Patch:
@@ -19,7 +19,6 @@
 import io.vertx.core.http.HttpClientOptions;
 import io.vertx.core.http.HttpServerOptions;
 import io.vertx.core.http.RequestOptions;
-import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -28,8 +27,8 @@
  */
 public class HttpCompressionTest extends HttpTestBase {
 
-  @Before
-  public void before() {
+  public void setUp() throws Exception {
+    super.setUp();
     client = vertx.createHttpClient(HttpClientOptions.options().setTryUseCompression(true));
     server = vertx.createHttpServer(HttpServerOptions.options().setPort(DEFAULT_HTTP_PORT).setCompressionSupported(true));
   }

File: vertx-core/src/test/java/io/vertx/test/core/HttpTest.java
Patch:
@@ -98,8 +98,8 @@ public class HttpTest extends HttpTestBase {
 
   private File testDir;
 
-  @Before
-  public void before() throws Exception {
+  public void setUp() throws Exception {
+    super.setUp();
     testDir = Files.createTempDirectory("vertx-test").toFile();
     testDir.deleteOnExit();
     server = vertx.createHttpServer(HttpServerOptions.options().setPort(DEFAULT_HTTP_PORT).setHost(DEFAULT_HTTP_HOST));

File: vertx-core/src/test/java/io/vertx/test/core/JSONEventBusTest.java
Patch:
@@ -20,7 +20,6 @@
 import io.vertx.core.eventbus.Message;
 import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
-import org.junit.Before;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -35,8 +34,8 @@ public class JSONEventBusTest extends VertxTestBase {
 
   private EventBus eb;
 
-  @Before
-  public void before() throws Exception {
+  public void setUp() throws Exception {
+    super.setUp();
     eb = vertx.eventBus();
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/LocalSharedDataTest.java
Patch:
@@ -3,7 +3,6 @@
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.shareddata.LocalMap;
 import io.vertx.core.shareddata.SharedData;
-import org.junit.Before;
 import org.junit.Test;
 
 import java.util.Random;
@@ -15,8 +14,8 @@ public class LocalSharedDataTest extends VertxTestBase {
 
   private SharedData sharedData;
 
-  @Before
-  public void before() {    
+  public void setUp() throws Exception {
+    super.setUp();
     sharedData = vertx.sharedData();
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/StarterTest.java
Patch:
@@ -17,16 +17,15 @@
 package io.vertx.test.core;
 
 import io.vertx.core.Starter;
-import org.junit.Before;
 import org.junit.Test;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 public class StarterTest extends VertxTestBase {
 
-  @Before
-  public void before() {
+  public void setUp() throws Exception {
+    super.setUp();
     TestVerticle.instanceCount.set(0);
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/VerticleFactoryTest.java
Patch:
@@ -21,16 +21,15 @@
 import io.vertx.core.Verticle;
 import io.vertx.core.Vertx;
 import io.vertx.core.spi.VerticleFactory;
-import org.junit.Before;
 import org.junit.Test;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 public class VerticleFactoryTest extends VertxTestBase {
 
-  @Before
-  public void before() {
+  public void setUp() throws Exception {
+    super.setUp();
     // Unregister the factory that's loaded from the classpath
     VerticleFactory factory = vertx.verticleFactories().iterator().next();
     vertx.unregisterVerticleFactory(factory);

File: vertx-hazelcast/src/test/java/io/vertx/test/core/HazelcastClusterWideMapTest.java
Patch:
@@ -25,11 +25,13 @@
 public class HazelcastClusterWideMapTest extends ClusterWideMapTestDifferentNodes {
 
   static {
+    System.setProperty("hazelcast.wait.seconds.before.join", "0");
     System.setProperty("hazelcast.local.localAddress", "127.0.0.1");
   }
 
   @Override
   protected ClusterManager getClusterManager() {
     return new HazelcastClusterManager();
   }
+
 }

File: vertx-hazelcast/src/test/java/io/vertx/test/core/HazelcastClusteredAsynchronousLockTest.java
Patch:
@@ -25,11 +25,13 @@
 public class HazelcastClusteredAsynchronousLockTest extends ClusteredAsynchronousLockTest {
 
   static {
+    System.setProperty("hazelcast.wait.seconds.before.join", "0");
     System.setProperty("hazelcast.local.localAddress", "127.0.0.1");
   }
 
   @Override
   protected ClusterManager getClusterManager() {
     return new HazelcastClusterManager();
   }
+
 }

File: vertx-hazelcast/src/test/java/io/vertx/test/core/HazelcastClusteredSharedCounterTest.java
Patch:
@@ -25,11 +25,13 @@
 public class HazelcastClusteredSharedCounterTest extends ClusteredSharedCounterTest {
 
   static {
+    System.setProperty("hazelcast.wait.seconds.before.join", "0");
     System.setProperty("hazelcast.local.localAddress", "127.0.0.1");
   }
 
   @Override
   protected ClusterManager getClusterManager() {
     return new HazelcastClusterManager();
   }
+
 }

File: vertx-hazelcast/src/test/java/io/vertx/test/core/HazelcastComplexHATest.java
Patch:
@@ -25,11 +25,13 @@
 public class HazelcastComplexHATest extends ComplexHATest {
 
   static {
+    System.setProperty("hazelcast.wait.seconds.before.join", "0");
     System.setProperty("hazelcast.local.localAddress", "127.0.0.1");
   }
 
   @Override
   protected ClusterManager getClusterManager() {
     return new HazelcastClusterManager();
   }
+
 }

File: vertx-hazelcast/src/test/java/io/vertx/test/core/HazelcastHATest.java
Patch:
@@ -25,11 +25,13 @@
 public class HazelcastHATest extends HATest {
 
   static {
+    System.setProperty("hazelcast.wait.seconds.before.join", "0");
     System.setProperty("hazelcast.local.localAddress", "127.0.0.1");
   }
 
   @Override
   protected ClusterManager getClusterManager() {
     return new HazelcastClusterManager();
   }
+
 }

File: vertx-core/src/main/java/io/vertx/core/Starter.java
Patch:
@@ -203,7 +203,7 @@ private void runVerticle(String main, Args args) {
     boolean worker = args.map.get("-worker") != null;
     String message = (worker) ? "deploying worker verticle" : "deploying verticle";
     for (int i = 0; i < instances; i++) {
-      vertx.deployVerticle(main, DeploymentOptions.options().setConfig(conf).setWorker(worker), createLoggingHandler(message, res -> {
+      vertx.deployVerticleWithOptions(main, DeploymentOptions.options().setConfig(conf).setWorker(worker), createLoggingHandler(message, res -> {
         if (res.failed()) {
           // Failed to deploy
           unblock();

File: vertx-core/src/main/java/io/vertx/core/http/HttpClientRequest.java
Patch:
@@ -17,7 +17,7 @@
 package io.vertx.core.http;
 
 import io.vertx.core.Handler;
-import io.vertx.core.MultiMap;
+import io.vertx.core.Headers;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.codegen.annotations.CacheReturn;
 import io.vertx.codegen.annotations.Fluent;
@@ -82,7 +82,7 @@ public interface HttpClientRequest extends WriteStream<HttpClientRequest> {
    * @return The HTTP headers
    */
   @CacheReturn
-  MultiMap headers();
+  Headers headers();
 
   /**
    * Put an HTTP header - fluent API

File: vertx-core/src/main/java/io/vertx/core/http/HttpClientResponse.java
Patch:
@@ -17,7 +17,7 @@
 package io.vertx.core.http;
 
 import io.vertx.core.Handler;
-import io.vertx.core.MultiMap;
+import io.vertx.core.Headers;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.codegen.annotations.CacheReturn;
 import io.vertx.codegen.annotations.Fluent;
@@ -56,13 +56,13 @@ public interface HttpClientResponse extends ReadStream<HttpClientResponse> {
    * @return The HTTP headers
    */
   @CacheReturn
-  MultiMap headers();
+  Headers headers();
 
   /**
    * @return The HTTP trailers
    */
   @CacheReturn
-  MultiMap trailers();
+  Headers trailers();
 
   /**
    * @return The Set-Cookie headers (including trailers)

File: vertx-core/src/main/java/io/vertx/core/http/HttpServerResponse.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
-import io.vertx.core.MultiMap;
+import io.vertx.core.Headers;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.codegen.annotations.CacheReturn;
 import io.vertx.codegen.annotations.Fluent;
@@ -95,7 +95,7 @@ public interface HttpServerResponse extends WriteStream<HttpServerResponse> {
    * @return The HTTP headers
    */
   @CacheReturn
-  MultiMap headers();
+  Headers headers();
 
   /**
    * Put an HTTP header - fluent API
@@ -126,7 +126,7 @@ public interface HttpServerResponse extends WriteStream<HttpServerResponse> {
    * @return The HTTP trailers
    */
   @CacheReturn
-  MultiMap trailers();
+  Headers trailers();
 
   /**
    * Put an HTTP trailer - fluent API

File: vertx-core/src/main/java/io/vertx/core/http/ServerWebSocket.java
Patch:
@@ -16,7 +16,7 @@
 
 package io.vertx.core.http;
 
-import io.vertx.core.MultiMap;
+import io.vertx.core.Headers;
 import io.vertx.codegen.annotations.CacheReturn;
 import io.vertx.codegen.annotations.Fluent;
 import io.vertx.codegen.annotations.VertxGen;
@@ -49,7 +49,7 @@ public interface ServerWebSocket extends WebSocketBase<ServerWebSocket> {
    * A map of all headers in the request to upgrade to websocket
    */
   @CacheReturn
-  MultiMap headers();
+  Headers headers();
 
   /**
    * Reject the WebSocket<p>

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -35,7 +35,7 @@
 import io.netty.handler.timeout.IdleStateHandler;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
-import io.vertx.core.MultiMap;
+import io.vertx.core.Headers;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.http.HttpClient;
 import io.vertx.core.http.HttpClientOptions;
@@ -388,12 +388,12 @@ public String statusMessage() {
           }
 
           @Override
-          public MultiMap headers() {
+          public Headers headers() {
             return resp.headers();
           }
 
           @Override
-          public MultiMap trailers() {
+          public Headers trailers() {
             return resp.trailers();
           }
 

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -602,7 +602,7 @@ private void handshake(final FullHttpRequest request, final Channel ch, ChannelH
         };
 
         final ServerWebSocketImpl ws = new ServerWebSocketImpl(vertx, theURI.toString(), theURI.getPath(),
-            theURI.getQuery(), new HttpHeadersAdapter(request.headers()), wsConn, shake.version() != WebSocketVersion.V00,
+            theURI.getQuery(), new HeadersAdaptor(request.headers()), wsConn, shake.version() != WebSocketVersion.V00,
             connectRunnable);
         wsConn.handleWebsocketConnect(ws);
         if (ws.isRejected()) {

File: vertx-core/src/main/java/io/vertx/core/http/impl/ServerConnection.java
Patch:
@@ -308,7 +308,6 @@ private void processMessage(Object msg) {
       }
     } else if (msg instanceof WebSocketFrameInternal) {
       WebSocketFrameInternal frame = (WebSocketFrameInternal) msg;
-      //System.out.println("got ws frame, final? " + frame.isFinal() + " size: " + frame.binaryData().length());
       handleWsFrame(frame);
     }
 

File: vertx-core/src/test/java/io/vertx/test/core/ComplexHATest.java
Patch:
@@ -95,7 +95,7 @@ protected void deployRandomVerticles(Runnable runner) {
         DeploymentOptions options = DeploymentOptions.options().setHA(true).setConfig(config);
         String verticleName = "java:io.vertx.test.core.HAVerticle" + (random.nextInt(3) + 1);
         toDeploy++;
-        v.deployVerticle(verticleName, options, ar -> {
+        v.deployVerticleWithOptions(verticleName, options, ar -> {
           assertTrue(ar.succeeded());
           deployCount.incrementAndGet();
         });

File: vertx-core/src/test/java/io/vertx/test/core/ContextTest.java
Patch:
@@ -57,7 +57,6 @@ public void run() {
 
   @Test
   public void testNoContext() throws Exception {
-    System.out.println("Thread is: " + Thread.currentThread());
     Set<Context> ctxts = new HashSet<>();
     // We are not on a context when we call this so we should be given a new context each time
     for (int i = 0; i < 10; i++) {

File: vertx-core/src/test/java/io/vertx/test/core/DNSTest.java
Patch:
@@ -275,7 +275,7 @@ public void start() {
       }
     }
     MyVerticle verticle = new MyVerticle();
-    vertx.deployVerticleInstance(verticle, DeploymentOptions.options().setWorker(true).setMultiThreaded(true));
+    vertx.deployVerticleWithOptions(verticle, DeploymentOptions.options().setWorker(true).setMultiThreaded(true));
     await();
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/DatagramTest.java
Patch:
@@ -433,7 +433,7 @@ public void start() {
       }
     }
     MyVerticle verticle = new MyVerticle();
-    vertx.deployVerticleInstance(verticle, DeploymentOptions.options().setWorker(true).setMultiThreaded(true));
+    vertx.deployVerticleWithOptions(verticle, DeploymentOptions.options().setWorker(true).setMultiThreaded(true));
     await();
   }
 }

File: vertx-core/src/test/java/io/vertx/test/core/NetTest.java
Patch:
@@ -1806,7 +1806,7 @@ public void start() {
       }
     }
     MyVerticle verticle = new MyVerticle();
-    vertx.deployVerticleInstance(verticle, DeploymentOptions.options().setWorker(worker));
+    vertx.deployVerticleWithOptions(verticle, DeploymentOptions.options().setWorker(worker));
     await();
   }
 
@@ -1831,7 +1831,7 @@ public void start() {
       }
     }
     MyVerticle verticle = new MyVerticle();
-    vertx.deployVerticleInstance(verticle, DeploymentOptions.options().setWorker(true).setMultiThreaded(true));
+    vertx.deployVerticleWithOptions(verticle, DeploymentOptions.options().setWorker(true).setMultiThreaded(true));
     await();
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/TimerTest.java
Patch:
@@ -78,7 +78,7 @@ public void start() {
       }
     }
     MyVerticle verticle = new MyVerticle();
-    vertx.deployVerticleInstance(verticle);
+    vertx.deployVerticle(verticle);
     await();
   }
 

File: vertx-core/src/test/java/io/vertx/test/core/sourceverticle/SourceVerticle.java
Patch:
@@ -29,9 +29,9 @@ public class SourceVerticle extends AbstractVerticle {
 
   @Override
   public void start(Future<Void> startFuture) throws Exception {
-    vertx.deployVerticle("java:" + OtherSourceVerticle.class.getName().replace('.', '/') + ".java", DeploymentOptions.options(), ar -> {
+    vertx.deployVerticleWithOptions("java:" + OtherSourceVerticle.class.getName().replace('.', '/') + ".java", DeploymentOptions.options(), ar -> {
       if (ar.succeeded()) {
-        startFuture.setResult((Void)null);
+        startFuture.setResult((Void) null);
       } else {
         ar.cause().printStackTrace();
       }

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -44,6 +44,7 @@
 import io.netty.handler.codec.http.websocketx.WebSocketHandshakeException;
 import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
 import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
+import io.netty.handler.codec.http.websocketx.WebSocketVersion;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
 import io.netty.handler.timeout.IdleStateHandler;
@@ -601,7 +602,8 @@ private void handshake(final FullHttpRequest request, final Channel ch, ChannelH
         };
 
         final ServerWebSocketImpl ws = new ServerWebSocketImpl(vertx, theURI.toString(), theURI.getPath(),
-            theURI.getQuery(), new HttpHeadersAdapter(request.headers()), wsConn, connectRunnable);
+            theURI.getQuery(), new HttpHeadersAdapter(request.headers()), wsConn, shake.version() != WebSocketVersion.V00,
+            connectRunnable);
         wsConn.handleWebsocketConnect(ws);
         if (ws.isRejected()) {
           if (firstHandler == null) {

File: vertx-core/src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -35,8 +35,8 @@ public class ServerWebSocketImpl extends WebSocketImplBase<ServerWebSocket> impl
   private final MultiMap headers;
 
   public ServerWebSocketImpl(VertxInternal vertx, String uri, String path, String query, MultiMap headers,
-                             ConnectionBase conn, Runnable connectRunnable) {
-    super(vertx, conn);
+                             ConnectionBase conn, boolean supportsContinuation, Runnable connectRunnable) {
+    super(vertx, conn, supportsContinuation);
     this.uri = uri;
     this.path = path;
     this.query = query;

File: vertx-core/src/main/java/io/vertx/core/http/impl/WebSocketImpl.java
Patch:
@@ -25,8 +25,8 @@
 
 public class WebSocketImpl extends WebSocketImplBase<WebSocket> implements WebSocket {
 
-  public WebSocketImpl(VertxInternal vertx, ConnectionBase conn) {
-    super(vertx, conn);
+  public WebSocketImpl(VertxInternal vertx, ConnectionBase conn, boolean supportsContinuation) {
+    super(vertx, conn, supportsContinuation);
   }
 
   @Override

File: vertx-core/src/test/java/io/vertx/test/core/WebsocketTest.java
Patch:
@@ -937,7 +937,8 @@ private void testReject(int version) throws Exception {
   }
 
 /*
-  // Those 3 tests hang for some reason in the ws close
+  Those 3 tests cannot pass for the moment due to a bug in Netty for websocket version 0:
+  https://github.com/netty/netty/issues/2768
 
   @Test
   public void testWriteMessageHybi00() {

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -44,6 +44,7 @@
 import io.netty.handler.codec.http.websocketx.WebSocketHandshakeException;
 import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
 import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
+import io.netty.handler.codec.http.websocketx.WebSocketVersion;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
 import io.netty.handler.timeout.IdleStateHandler;
@@ -601,7 +602,8 @@ private void handshake(final FullHttpRequest request, final Channel ch, ChannelH
         };
 
         final ServerWebSocketImpl ws = new ServerWebSocketImpl(vertx, theURI.toString(), theURI.getPath(),
-            theURI.getQuery(), new HttpHeadersAdapter(request.headers()), wsConn, connectRunnable);
+            theURI.getQuery(), new HttpHeadersAdapter(request.headers()), wsConn, shake.version() != WebSocketVersion.V00,
+            connectRunnable);
         wsConn.handleWebsocketConnect(ws);
         if (ws.isRejected()) {
           if (firstHandler == null) {

File: vertx-core/src/main/java/io/vertx/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -35,8 +35,8 @@ public class ServerWebSocketImpl extends WebSocketImplBase<ServerWebSocket> impl
   private final MultiMap headers;
 
   public ServerWebSocketImpl(VertxInternal vertx, String uri, String path, String query, MultiMap headers,
-                             ConnectionBase conn, Runnable connectRunnable) {
-    super(vertx, conn);
+                             ConnectionBase conn, boolean supportsContinuation, Runnable connectRunnable) {
+    super(vertx, conn, supportsContinuation);
     this.uri = uri;
     this.path = path;
     this.query = query;

File: vertx-core/src/main/java/io/vertx/core/http/impl/WebSocketImpl.java
Patch:
@@ -25,8 +25,8 @@
 
 public class WebSocketImpl extends WebSocketImplBase<WebSocket> implements WebSocket {
 
-  public WebSocketImpl(VertxInternal vertx, ConnectionBase conn) {
-    super(vertx, conn);
+  public WebSocketImpl(VertxInternal vertx, ConnectionBase conn, boolean supportsContinuation) {
+    super(vertx, conn, supportsContinuation);
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java
Patch:
@@ -810,6 +810,7 @@ private HandlerEntry(String address, Handler<? extends Message> handler) {
 
     @Override
     public boolean equals(Object o) {
+      if (o == null) return false;
       if (this == o) return true;
       if (getClass() != o.getClass()) return false;
       HandlerEntry entry = (HandlerEntry) o;

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -506,6 +506,8 @@ protected void doMessageReceived(ClientConnection conn, ChannelHandlerContext ct
               closeFrameSent = true;
             }
             break;
+          default:
+            throw new IllegalStateException("Invalid type: " + frame.type());
         }
         valid = true;
       }

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -499,6 +499,8 @@ protected void doMessageReceived(ServerConnection conn, ChannelHandlerContext ct
               closeFrameSent = true;
             }
             break;
+          default:
+            throw new IllegalStateException("Invalid type: " + wsFrame.type());
         }
       } else if (msg instanceof HttpContent) {
         if (wsRequest != null) {

File: vertx-core/src/main/java/io/vertx/core/logging/impl/VertxLoggerFormatter.java
Patch:
@@ -50,6 +50,7 @@ public String format(final LogRecord record) {
         pw.close();
         sb.append(sw.toString());
       } catch (Exception ex) {
+        ex.printStackTrace();
       }
     }
     return sb.toString();

File: vertx-core/src/main/java/io/vertx/core/net/impl/HandlerManager.java
Patch:
@@ -54,7 +54,7 @@ public HandlerHolder<T> chooseHandler(EventLoop worker) {
     return handlers == null ? null : handlers.chooseHandler();
   }
 
-  public void addHandler(Handler<T> handler, ContextImpl context) {
+  public synchronized void addHandler(Handler<T> handler, ContextImpl context) {
     EventLoop worker = context.getEventLoop();
     availableWorkers.addWorker(worker);
     Handlers<T> handlers = new Handlers<T>();
@@ -66,7 +66,7 @@ public void addHandler(Handler<T> handler, ContextImpl context) {
     handlerCount++;
   }
 
-  public void removeHandler(Handler<T> handler, ContextImpl context) {
+  public synchronized  void removeHandler(Handler<T> handler, ContextImpl context) {
     EventLoop worker = context.getEventLoop();
     Handlers<T> handlers = handlerMap.get(worker);
     if (!handlers.removeHandler(new HandlerHolder<>(context, handler))) {

File: vertx-core/src/main/java/io/vertx/core/http/impl/VertxHttpHandler.java
Patch:
@@ -75,7 +75,7 @@ protected void channelRead(final C connection, final ContextImpl context, final
       // We execute this directly as we don't have a context yet, the context will have to be set manually
       // inside doMessageReceived();
       try {
-        doMessageReceived(connection, chctx, msg);
+        doMessageReceived(null, chctx, msg);
       } catch (Throwable t) {
         chctx.pipeline().fireExceptionCaught(t);
       }

File: vertx-core/src/main/java/io/vertx/core/impl/HAManager.java
Patch:
@@ -447,8 +447,8 @@ private void checkFailover(String failedNodeID, JsonObject theHAInfo) {
       String group = theHAInfo.getString("group");
       String chosen = chooseHashedNode(group, failedNodeID.hashCode());
       if (chosen != null && chosen.equals(this.nodeID)) {
-        log.info("Node " + failedNodeID + " has failed. This node will deploy " + deployments.size() + " deployments from that node.");
         if (deployments != null) {
+          log.info("Node " + failedNodeID + " has failed. This node will deploy " + deployments.size() + " deployments from that node.");
           for (Object obj: deployments) {
             JsonObject app = (JsonObject)obj;
             processFailover(app);

File: vertx-core/src/main/java/io/vertx/core/net/impl/CaOptionsImpl.java
Patch:
@@ -29,7 +29,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class CaOptionsImpl implements CaOptions {
+public class CaOptionsImpl implements CaOptions, Cloneable {
 
   private ArrayList<String> certPaths;
   private ArrayList<Buffer> certValues;

File: vertx-core/src/main/java/io/vertx/core/net/impl/JKSOptionsImpl.java
Patch:
@@ -24,7 +24,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class JKSOptionsImpl implements JKSOptions {
+public class JKSOptionsImpl implements JKSOptions, Cloneable {
 
   private String password;
   private String path;

File: vertx-core/src/main/java/io/vertx/core/net/impl/KeyCertOptionsImpl.java
Patch:
@@ -24,7 +24,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class KeyCertOptionsImpl implements KeyCertOptions {
+public class KeyCertOptionsImpl implements KeyCertOptions, Cloneable {
 
   private String keyPath;
   private Buffer keyValue;

File: vertx-core/src/main/java/io/vertx/core/net/impl/PCKS12OptionsImpl.java
Patch:
@@ -24,7 +24,7 @@
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class PCKS12OptionsImpl implements PKCS12Options {
+public class PCKS12OptionsImpl implements PKCS12Options, Cloneable {
 
   private String password;
   private String path;

File: vertx-core/src/main/java/io/vertx/core/Starter.java
Patch:
@@ -44,7 +44,7 @@ public class Starter {
 
   private static final Logger log = LoggerFactory.getLogger(Starter.class);
 
-  public static Starter instance = new Starter();
+  public static final Starter instance = new Starter();
 
   public static void main(String[] args) {
     instance.run(args);

File: vertx-core/src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java
Patch:
@@ -349,7 +349,6 @@ public void completed(Integer bytesWritten, Object attachment) {
 
       public void failed(Throwable exc, Object attachment) {
         if (exc instanceof Exception) {
-          Exception e = (Exception) exc;
           context.execute(() -> handler.handle(new FutureResultImpl<Void>().setResult(null)), false);
         } else {
           log.error("Error occurred", exc);

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientResponseImpl.java
Patch:
@@ -221,7 +221,7 @@ public NetSocket netSocket() {
   }
 
 
-  private final class BodyHandler implements Handler<Buffer> {
+  private static final class BodyHandler implements Handler<Buffer> {
     private Buffer body;
 
     @Override

File: vertx-core/src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -212,7 +212,7 @@ public SslHandler createSslHandler(VertxInternal vertx, boolean client) {
       sslContext = createContext(vertx);
     }
     SSLEngine engine = sslContext.createSSLEngine();
-    String[] current = engine.getSupportedCipherSuites();
+//    String[] current = engine.getSupportedCipherSuites();
 //    System.out.println("Enabled cipher suites:");
 //    for (String str: current) {
 //      System.out.println("\"" + str+ "\",");

File: vertx-core/src/main/java/io/vertx/core/net/impl/SocketDefaults.java
Patch:
@@ -25,7 +25,7 @@ public class SocketDefaults {
 
   private static final Logger log = LoggerFactory.getLogger(SocketDefaults.class);
 
-  public static SocketDefaults instance = new SocketDefaults();
+  public static final SocketDefaults instance = new SocketDefaults();
 
   private boolean tcpNoDelay = true;
   private int tcpSendBufferSize;

File: vertx-core/src/main/java/io/vertx/core/net/impl/VertxNetHandler.java
Patch:
@@ -39,7 +39,6 @@ public VertxNetHandler(VertxInternal vertx, Map<Channel, NetSocketImpl> connecti
   protected void channelRead(final NetSocketImpl sock, final ContextImpl context, ChannelHandlerContext chctx, Object msg) throws Exception {
     if (sock != null) {
       final ByteBuf buf = (ByteBuf) msg;
-      Channel ch = chctx.channel();
       // We need to do this since it's possible the server is being used from a worker context
       context.execute(() -> sock.handleDataReceived(Buffer.buffer(buf)), true);
     } else {

File: vertx-core/src/main/java/io/vertx/core/net/KeyStoreOptions.java
Patch:
@@ -15,14 +15,11 @@
  */
 package io.vertx.core.net;
 
-import io.vertx.codegen.annotations.Options;
-
 /**
  * An interface for key store configuration options.
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@Options
 public interface KeyStoreOptions {
 
   /**

File: vertx-core/src/main/java/io/vertx/core/net/TrustStoreOptions.java
Patch:
@@ -15,14 +15,11 @@
  */
 package io.vertx.core.net;
 
-import io.vertx.codegen.annotations.Options;
-
 /**
  * An interface for trust store configuration options.
  *
  * @author <a href="mailto:julien@julienviet.com">Julien Viet</a>
  */
-@Options
 public interface TrustStoreOptions {
 
   /**

File: vertx-core/src/test/java/io/vertx/test/core/HttpCompressionTest.java
Patch:
@@ -44,7 +44,7 @@ public void testDefaultRequestHeaders() {
     });
 
     server.listen(onSuccess(server -> {
-      client.getNow(new RequestOptions().setRequestURI("some-uri").setPort(DEFAULT_HTTP_PORT), resp -> testComplete());
+      client.getNow(RequestOptions.options().setRequestURI("some-uri").setPort(DEFAULT_HTTP_PORT), resp -> testComplete());
     }));
 
     await();

File: vertx-core/src/main/java/io/vertx/core/http/impl/ConnectionManager.java
Patch:
@@ -136,7 +136,6 @@ private void checkReuseConnection(ClientConnection conn) {
 
     private void createNewConnection(Handler<ClientConnection> handler, Handler<Throwable> connectionExceptionHandler, ContextImpl context) {
       connCount++;
-      //System.out.println("Creating new connection!");
       connect(address.host, address.port, conn -> {
         allConnections.add(conn);
         handler.handle(conn);

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java
Patch:
@@ -82,7 +82,7 @@ public class HttpClientImpl implements HttpClient {
   public HttpClientImpl(VertxInternal vertx, HttpClientOptions options) {
     this.vertx = vertx;
     this.options = new HttpClientOptions(options);
-    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStore()), KeyStoreHelper.create(vertx, options.getTrustStore()));
+    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStoreOptions()), KeyStoreHelper.create(vertx, options.getTrustStoreOptions()));
     this.creatingContext = vertx.getContext();
     closeHook = completionHandler -> {
       HttpClientImpl.this.close();

File: vertx-core/src/main/java/io/vertx/core/http/impl/HttpServerImpl.java
Patch:
@@ -126,7 +126,7 @@ public HttpServerImpl(VertxInternal vertx, HttpServerOptions options) {
       }
       creatingContext.addCloseHook(this);
     }
-    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStore()), KeyStoreHelper.create(vertx, options.getTrustStore()));
+    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStoreOptions()), KeyStoreHelper.create(vertx, options.getTrustStoreOptions()));
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/impl/ContextImpl.java
Patch:
@@ -92,7 +92,7 @@ public void removeCloseHook(Closeable hook) {
   }
 
   public void runCloseHooks(Handler<AsyncResult<Void>> completionHandler) {
-    if (closeHooks != null) {
+    if (closeHooks != null && !closeHooks.isEmpty()) {
       final int num = closeHooks.size();
       AtomicInteger count = new AtomicInteger();
       AtomicBoolean failed = new AtomicBoolean();

File: vertx-core/src/main/java/io/vertx/core/impl/DeploymentManager.java
Patch:
@@ -126,6 +126,7 @@ public Set<String> deployments() {
   }
 
   public void undeployAll(Handler<AsyncResult<Void>> completionHandler) {
+    // TODO timeout if it takes too long - e.g. async stop verticle fails to call future
     Set<String> deploymentIDs = new HashSet<>(deployments.keySet());
     if (!deploymentIDs.isEmpty()) {
       AtomicInteger count = new AtomicInteger(0);
@@ -283,7 +284,6 @@ public void undeploy(Handler<AsyncResult<Void>> completionHandler) {
     }
 
     public void doUndeploy(ContextImpl undeployingContext, Handler<AsyncResult<Void>> completionHandler) {
-
       if (!children.isEmpty()) {
         final int size = children.size();
         AtomicInteger childCount = new AtomicInteger();

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetClientImpl.java
Patch:
@@ -63,7 +63,7 @@ public class NetClientImpl implements NetClient {
   public NetClientImpl(VertxInternal vertx, NetClientOptions options) {
     this.vertx = vertx;
     this.options = new NetClientOptions(options);
-    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStore()), KeyStoreHelper.create(vertx, options.getTrustStore()));
+    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStoreOptions()), KeyStoreHelper.create(vertx, options.getTrustStoreOptions()));
     this.closeHook = completionHandler -> {
       NetClientImpl.this.close();
       completionHandler.handle(new FutureResultImpl<>((Void)null));

File: vertx-core/src/main/java/io/vertx/core/net/impl/NetServerImpl.java
Patch:
@@ -83,7 +83,7 @@ public class NetServerImpl implements NetServer, Closeable {
   public NetServerImpl(VertxInternal vertx, NetServerOptions options) {
     this.vertx = vertx;
     this.options = new NetServerOptions(options);
-    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStore()), KeyStoreHelper.create(vertx, options.getTrustStore()));
+    this.sslHelper = new SSLHelper(options, KeyStoreHelper.create(vertx, options.getKeyStoreOptions()), KeyStoreHelper.create(vertx, options.getTrustStoreOptions()));
     this.creatingContext = vertx.getContext();
     if (creatingContext != null) {
       if (creatingContext.isMultithreaded()) {

File: vertx-core/src/main/java/io/vertx/core/shareddata/SharedData.java
Patch:
@@ -40,5 +40,4 @@ public interface SharedData {
    */
   <K, V> LocalMap<K, V> getLocalMap(String name);
 
-
 }

File: vertx-core/src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -17,6 +17,7 @@
 package io.vertx.core.net.impl;
 
 import io.netty.handler.ssl.SslHandler;
+import io.vertx.core.VertxException;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.file.impl.PathAdjuster;
 import io.vertx.core.http.HttpClientOptions;
@@ -144,9 +145,7 @@ private SSLContext createContext(VertxInternal vertx) {
       context.init(keyMgrs, trustMgrs, new SecureRandom());
       return context;
     } catch (Exception e) {
-      //TODO better logging
-      log.error("Failed to create context", e);
-      throw new RuntimeException(e.getMessage());
+      throw new VertxException(e);
     }
   }
 

File: vertx-core/src/main/java/io/vertx/core/net/impl/SSLHelper.java
Patch:
@@ -17,6 +17,7 @@
 package io.vertx.core.net.impl;
 
 import io.netty.handler.ssl.SslHandler;
+import io.vertx.core.VertxException;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.file.impl.PathAdjuster;
 import io.vertx.core.http.HttpClientOptions;
@@ -144,9 +145,7 @@ private SSLContext createContext(VertxInternal vertx) {
       context.init(keyMgrs, trustMgrs, new SecureRandom());
       return context;
     } catch (Exception e) {
-      //TODO better logging
-      log.error("Failed to create context", e);
-      throw new RuntimeException(e.getMessage());
+      throw new VertxException(e);
     }
   }
 

File: vertx-core/src/main/java/io/vertx/core/Vertx.java
Patch:
@@ -35,7 +35,6 @@
 import io.vertx.core.spi.VerticleFactory;
 import io.vertx.core.spi.VertxFactory;
 
-import java.util.List;
 import java.util.ServiceLoader;
 import java.util.Set;
 
@@ -181,7 +180,7 @@ static void newVertx(VertxOptions options, Handler<AsyncResult<Vertx>> resultHan
   void unregisterVerticleFactory(VerticleFactory factory);
 
   @GenIgnore
-  List<VerticleFactory> verticleFactories();
+  Set<VerticleFactory> verticleFactories();
 
   static final VertxFactory factory = loadFactory();
 

File: vertx-core/src/main/java/io/vertx/core/impl/SimpleJavaVerticleFactory.java
Patch:
@@ -30,8 +30,8 @@ public void init(Vertx vertx) {
   }
 
   @Override
-  public boolean matches(String verticleName) {
-    return true;
+  public String prefix() {
+    return "java";
   }
 
   @Override

File: vertx-core/src/main/java/io/vertx/core/impl/VertxImpl.java
Patch:
@@ -59,7 +59,6 @@
 
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.ServiceLoader;
 import java.util.Set;
@@ -421,7 +420,7 @@ public void unregisterVerticleFactory(VerticleFactory factory) {
   }
 
   @Override
-  public List<VerticleFactory> verticleFactories() {
+  public Set<VerticleFactory> verticleFactories() {
     return deploymentManager.verticleFactories();
   }
 

File: vertx-core/src/main/java/io/vertx/core/spi/VerticleFactory.java
Patch:
@@ -26,7 +26,7 @@ public interface VerticleFactory {
 
   void init(Vertx vertx);
 
-  boolean matches(String verticleName);
+  String prefix();
 
   Verticle createVerticle(String verticleName, ClassLoader classLoader) throws Exception;
 

File: vertx-core/src/test/java/io/vertx/test/core/ClasspathVerticleFactory.java
Patch:
@@ -27,12 +27,11 @@ public class ClasspathVerticleFactory implements VerticleFactory{
 
   @Override
   public void init(Vertx vertx) {
-
   }
 
   @Override
-  public boolean matches(String verticleName) {
-    return false;
+  public String prefix() {
+    return "wibble";
   }
 
   @Override

File: vertx-core/src/test/java/io/vertx/test/core/ClasspathVerticleFactoryTest.java
Patch:
@@ -27,7 +27,7 @@ public class ClasspathVerticleFactoryTest extends VertxTestBase{
   @Test
   public void testLoadedFromClasspath() {
     assertEquals(1, vertx.verticleFactories().size());
-    VerticleFactory fact = vertx.verticleFactories().get(0);
+    VerticleFactory fact = vertx.verticleFactories().iterator().next();
     assertTrue(fact instanceof  ClasspathVerticleFactory);
   }
 }

File: vertx-core/src/test/java/io/vertx/test/core/StarterTest.java
Patch:
@@ -41,7 +41,7 @@ public void testVersion() throws Exception {
   @Test
   public void testRunVerticle() throws Exception {
     Thread t = new Thread(() -> {
-      String[] args = new String[] {"run", TestVerticle.class.getCanonicalName()};
+      String[] args = new String[] {"run", "java:" + TestVerticle.class.getCanonicalName()};
       Starter.main(args);
     });
     t.start();

File: vertx-core/src/main/java/io/vertx/core/spi/cluster/AsyncMap.java
Patch:
@@ -52,5 +52,5 @@ public interface AsyncMap<K, V> {
    * @param k The key
    * @param resultHandler - this will be called some time later to signify the value has been removed
    */
-  void remove(K k, Handler<AsyncResult<Boolean>> resultHandler);
+  void remove(K k, Handler<AsyncResult<Void>> resultHandler);
 }

File: vertx-core/src/main/java/io/vertx/core/logging/Logger.java
Patch:
@@ -29,7 +29,7 @@
  * vertx-logs in the users home directory.</p>
  *
  * <p>If you would prefer to use Log4J or SLF4J instead of JUL then you can set a system property called
- * {@code org.vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
+ * {@code io.vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
  * For Log4J the value is {@code io.vertx.core.logging.impl.Log4JLogDelegateFactory}, for SLF4J the value
  * is {@code io.vertx.core.logging.impl.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
  * required by your favourite log framework are on your classpath.</p>

File: vertx-core/src/main/java/io/vertx/core/logging/impl/LoggerFactory.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class LoggerFactory {
 
-  public static final String LOGGER_DELEGATE_FACTORY_CLASS_NAME = "org.vertx.logger-delegate-factory-class-name";
+  public static final String LOGGER_DELEGATE_FACTORY_CLASS_NAME = "io.vertx.logger-delegate-factory-class-name";
 
   private static volatile LogDelegateFactory delegateFactory;
 

File: vertx-hazelcast/src/main/java/io/vertx/spi/cluster/impl/hazelcast/ChoosableSet.java
Patch:
@@ -14,7 +14,7 @@
  * You may elect to redistribute this code under either of these licenses.
  */
 
-package io.vertx.java.spi.cluster.impl.hazelcast;
+package io.vertx.spi.cluster.impl.hazelcast;
 
 import io.vertx.core.impl.ConcurrentHashSet;
 import io.vertx.core.spi.cluster.ChoosableIterable;

File: vertx-hazelcast/src/main/java/io/vertx/spi/cluster/impl/hazelcast/HazelcastAsyncMap.java
Patch:
@@ -14,7 +14,7 @@
  * You may elect to redistribute this code under either of these licenses.
  */
 
-package io.vertx.java.spi.cluster.impl.hazelcast;
+package io.vertx.spi.cluster.impl.hazelcast;
 
 import com.hazelcast.core.IMap;
 import io.vertx.core.AsyncResult;

File: vertx-hazelcast/src/main/java/io/vertx/spi/cluster/impl/hazelcast/HazelcastAsyncMultiMap.java
Patch:
@@ -14,7 +14,7 @@
  * You may elect to redistribute this code under either of these licenses.
  */
 
-package io.vertx.java.spi.cluster.impl.hazelcast;
+package io.vertx.spi.cluster.impl.hazelcast;
 
 import com.hazelcast.core.EntryEvent;
 import com.hazelcast.core.EntryListener;

File: vertx-hazelcast/src/main/java/io/vertx/spi/cluster/impl/hazelcast/HazelcastClusterManager.java
Patch:
@@ -14,7 +14,7 @@
  * You may elect to redistribute this code under either of these licenses.
  */
 
-package io.vertx.java.spi.cluster.impl.hazelcast;
+package io.vertx.spi.cluster.impl.hazelcast;
 
 import com.hazelcast.config.Config;
 import com.hazelcast.config.XmlConfigBuilder;
@@ -46,7 +46,7 @@
  * 
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-class HazelcastClusterManager implements ClusterManager, MembershipListener {
+public class HazelcastClusterManager implements ClusterManager, MembershipListener {
 
   private static final Logger log = LoggerFactory.getLogger(HazelcastClusterManager.class);
 

File: vertx-hazelcast/src/main/java/io/vertx/spi/cluster/impl/hazelcast/HazelcastServerID.java
Patch:
@@ -14,7 +14,7 @@
  * You may elect to redistribute this code under either of these licenses.
  */
 
-package io.vertx.java.spi.cluster.impl.hazelcast;
+package io.vertx.spi.cluster.impl.hazelcast;
 
 import com.hazelcast.nio.ObjectDataInput;
 import com.hazelcast.nio.ObjectDataOutput;

File: vertx-core/src/test/java/org/vertx/java/tests/core/AsyncTestBaseTest.java
Patch:
@@ -35,6 +35,7 @@ public class AsyncTestBaseTest extends AsyncTestBase {
 
   @Before
   public void before() {
+    disableThreadChecks();
     executor = Executors.newFixedThreadPool(10);
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/Starter.java
Patch:
@@ -181,8 +181,9 @@ private void runVerticle(String main, Args args) {
     }
 
     boolean worker = args.map.get("-worker") != null;
+    String message = (worker) ? "deploying worker verticle" : "deploying verticle";
     for (int i = 0; i < instances; i++) {
-      vertx.deployVerticle(main, conf, worker, createLoggingHandler("deploying worker verticle", res -> {
+      vertx.deployVerticle(main, conf, worker, createLoggingHandler(message, res -> {
         if (res.failed()) {
           // Failed to deploy
           unblock();

File: vertx-core/src/main/java/org/vertx/java/core/Starter.java
Patch:
@@ -181,8 +181,9 @@ private void runVerticle(String main, Args args) {
     }
 
     boolean worker = args.map.get("-worker") != null;
+    String message = (worker) ? "deploying worker verticle" : "deploying verticle";
     for (int i = 0; i < instances; i++) {
-      vertx.deployVerticle(main, conf, worker, createLoggingHandler("deploying worker verticle", res -> {
+      vertx.deployVerticle(main, conf, worker, createLoggingHandler(message, res -> {
         if (res.failed()) {
           // Failed to deploy
           unblock();

File: vertx-core/src/main/java/org/vertx/java/core/datagram/impl/DatagramPacketImpl.java
Patch:
@@ -25,12 +25,12 @@
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-final class DefaultDatagramPacket implements DatagramPacket {
+final class DatagramPacketImpl implements DatagramPacket {
   private final InetSocketAddress sender;
   private final Buffer buffer;
   private SocketAddress senderAddress;
 
-  DefaultDatagramPacket(InetSocketAddress sender, Buffer buffer) {
+  DatagramPacketImpl(InetSocketAddress sender, Buffer buffer) {
     this.sender = sender;
     this.buffer = buffer;
   }

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/MxRecordImpl.java
Patch:
@@ -22,10 +22,10 @@
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-final class DefaultMxRecord implements MxRecord, Comparable<MxRecord> {
+final class MxRecordImpl implements MxRecord, Comparable<MxRecord> {
   private final MailExchangerRecord record;
 
-  DefaultMxRecord(MailExchangerRecord record) {
+  MxRecordImpl(MailExchangerRecord record) {
     this.record = record;
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/SrcRecordImpl.java
Patch:
@@ -22,10 +22,10 @@
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */
-final class DefaultSrvRecord implements SrvRecord, Comparable<SrvRecord>{
+final class SrcRecordImpl implements SrvRecord, Comparable<SrvRecord>{
   private final ServiceRecord record;
 
-  DefaultSrvRecord(ServiceRecord record) {
+  SrcRecordImpl(ServiceRecord record) {
     this.record = record;
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/file/impl/FilePropsImpl.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Date;
 
 
-public class DefaultFileProps implements FileProps {
+public class FilePropsImpl implements FileProps {
   
   private final Date creationTime;
   private final Date lastAccessTime;
@@ -33,7 +33,7 @@ public class DefaultFileProps implements FileProps {
   private final boolean isSymbolicLink;
   private final long size;
 
-  public DefaultFileProps(BasicFileAttributes attrs) {
+  public FilePropsImpl(BasicFileAttributes attrs) {
     creationTime = new Date(attrs.creationTime().toMillis());
     lastModifiedTime = new Date(attrs.lastModifiedTime().toMillis());
     lastAccessTime = new Date(attrs.lastAccessTime().toMillis());

File: vertx-core/src/main/java/org/vertx/java/core/file/impl/FileSystemPropsImpl.java
Patch:
@@ -18,13 +18,13 @@
 
 import org.vertx.java.core.file.FileSystemProps;
 
-public class DefaultFileSystemProps implements FileSystemProps {
+public class FileSystemPropsImpl implements FileSystemProps {
 
   private final long totalSpace;
   private final long unallocatedSpace;
   private final long usableSpace;
 
-  public DefaultFileSystemProps(long totalSpace, long unallocatedSpace, long usableSpace) {
+  public FileSystemPropsImpl(long totalSpace, long unallocatedSpace, long usableSpace) {
     this.totalSpace = totalSpace;
     this.unallocatedSpace = unallocatedSpace;
     this.usableSpace = usableSpace;

File: vertx-core/src/main/java/org/vertx/java/core/file/impl/PathAdjuster.java
Patch:
@@ -16,7 +16,7 @@
 
 package org.vertx.java.core.file.impl;
 
-import org.vertx.java.core.impl.DefaultContext;
+import org.vertx.java.core.impl.ContextImpl;
 import org.vertx.java.core.impl.VertxInternal;
 
 import java.nio.file.Path;
@@ -28,7 +28,7 @@
 public class PathAdjuster {
 
   public static Path adjust(final VertxInternal vertx, Path path) {
-    DefaultContext context = vertx.getContext();
+    ContextImpl context = vertx.getContext();
     if (context != null) {
       PathResolver resolver = context.getPathResolver();
       if (resolver != null) {

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/HttpClientResponseImpl.java
Patch:
@@ -36,11 +36,11 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class DefaultHttpClientResponse implements HttpClientResponse  {
+public class HttpClientResponseImpl implements HttpClientResponse  {
 
   private final int statusCode;
   private final String statusMessage;
-  private final DefaultHttpClientRequest request;
+  private final HttpClientRequestImpl request;
   private final Vertx vertx;
   private final ClientConnection conn;
 
@@ -60,7 +60,7 @@ public class DefaultHttpClientResponse implements HttpClientResponse  {
   private MultiMap trailers;
   private List<String> cookies;
 
-  DefaultHttpClientResponse(Vertx vertx, DefaultHttpClientRequest request, ClientConnection conn, HttpResponse response) {
+  HttpClientResponseImpl(Vertx vertx, HttpClientRequestImpl request, ClientConnection conn, HttpResponse response) {
     this.vertx = vertx;
     this.statusCode = response.getStatus().code();
     this.statusMessage = response.getStatus().reasonPhrase();

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/ServerWebSocketImpl.java
Patch:
@@ -24,7 +24,7 @@
 import org.vertx.java.core.impl.VertxInternal;
 import org.vertx.java.core.net.impl.ConnectionBase;
 
-public class DefaultServerWebSocket extends WebSocketImplBase<ServerWebSocket> implements ServerWebSocket {
+public class ServerWebSocketImpl extends WebSocketImplBase<ServerWebSocket> implements ServerWebSocket {
 
   private final String uri;
   private final String path;
@@ -34,8 +34,8 @@ public class DefaultServerWebSocket extends WebSocketImplBase<ServerWebSocket> i
   private boolean rejected;
   private final MultiMap headers;
 
-  public DefaultServerWebSocket(VertxInternal vertx, String uri, String path, String query, MultiMap headers,
-                                ConnectionBase conn, Runnable connectRunnable) {
+  public ServerWebSocketImpl(VertxInternal vertx, String uri, String path, String query, MultiMap headers,
+                             ConnectionBase conn, Runnable connectRunnable) {
     super(vertx, conn);
     this.uri = uri;
     this.path = path;

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/WebSocketImpl.java
Patch:
@@ -23,9 +23,9 @@
 import org.vertx.java.core.impl.VertxInternal;
 import org.vertx.java.core.net.impl.ConnectionBase;
 
-public class DefaultWebSocket extends WebSocketImplBase<WebSocket> implements WebSocket {
+public class WebSocketImpl extends WebSocketImplBase<WebSocket> implements WebSocket {
 
-  public DefaultWebSocket(VertxInternal vertx, ConnectionBase conn) {
+  public WebSocketImpl(VertxInternal vertx, ConnectionBase conn) {
     super(vertx, conn);
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/WebSocketImplBase.java
Patch:
@@ -22,7 +22,7 @@
 import org.vertx.java.core.eventbus.Message;
 import org.vertx.java.core.http.WebSocketBase;
 import org.vertx.java.core.http.WebSocketFrame;
-import org.vertx.java.core.http.impl.ws.DefaultWebSocketFrame;
+import org.vertx.java.core.http.impl.ws.WebSocketFrameImpl;
 import org.vertx.java.core.http.impl.ws.WebSocketFrameInternal;
 import org.vertx.java.core.impl.VertxInternal;
 import org.vertx.java.core.net.SocketAddress;
@@ -101,12 +101,12 @@ public SocketAddress remoteAddress() {
 
   protected void writeBinaryFrameInternal(Buffer data) {
     ByteBuf buf = data.getByteBuf();
-    WebSocketFrame frame = new DefaultWebSocketFrame(WebSocketFrame.FrameType.BINARY, buf);
+    WebSocketFrame frame = new WebSocketFrameImpl(WebSocketFrame.FrameType.BINARY, buf);
     writeFrame(frame);
   }
 
   protected void writeTextFrameInternal(String str) {
-    WebSocketFrame frame = new DefaultWebSocketFrame(str);
+    WebSocketFrame frame = new WebSocketFrameImpl(str);
     writeFrame(frame);
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/impl/BlockingAction.java
Patch:
@@ -28,7 +28,7 @@
  */
 public abstract class BlockingAction<T>  {
 
-  protected DefaultContext context;
+  protected ContextImpl context;
 
   private final VertxInternal vertx;
   private final Handler<AsyncResult<T>> handler;
@@ -44,7 +44,7 @@ public BlockingAction(VertxInternal vertx, Handler<AsyncResult<T>> handler) {
   public void run() {
     context = vertx.getOrCreateContext();
     context.executeOnOrderedWorkerExec(() -> {
-      final DefaultFutureResult<T> res = new DefaultFutureResult<>();
+      final FutureResultImpl<T> res = new FutureResultImpl<>();
       try {
         res.setResult(action());
       } catch (Exception e) {

File: vertx-core/src/main/java/org/vertx/java/core/impl/Deployment.java
Patch:
@@ -28,5 +28,5 @@ public interface Deployment {
 
   void undeploy(Handler<AsyncResult<Void>> doneHandler);
 
-  void doUndeploy(DefaultContext undeployingContext, Handler<AsyncResult<Void>> doneHandler);
+  void doUndeploy(ContextImpl undeployingContext, Handler<AsyncResult<Void>> doneHandler);
 }

File: vertx-core/src/main/java/org/vertx/java/core/impl/EventLoopContext.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class EventLoopContext extends DefaultContext {
+public class EventLoopContext extends ContextImpl {
 
   private static final Logger log = LoggerFactory.getLogger(EventLoopContext.class);
 

File: vertx-core/src/main/java/org/vertx/java/core/impl/VertxThread.java
Patch:
@@ -21,17 +21,17 @@
  */
 final class VertxThread extends Thread {
 
-    private DefaultContext context;
+    private ContextImpl context;
 
     public VertxThread(Runnable target, String name) {
         super(target, name);
     }
 
-    DefaultContext getContext() {
+    ContextImpl getContext() {
         return context;
     }
 
-    void setContext(DefaultContext context) {
+    void setContext(ContextImpl context) {
         this.context = context;
     }
 }

File: vertx-core/src/main/java/org/vertx/java/core/impl/WorkerContext.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public class WorkerContext extends DefaultContext {
+public class WorkerContext extends ContextImpl {
 
   public WorkerContext(VertxInternal vertx, Executor orderedBgExec) {
     super(vertx, orderedBgExec);

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/HandlerHolder.java
Patch:
@@ -17,16 +17,16 @@
 package org.vertx.java.core.net.impl;
 
 import org.vertx.java.core.Handler;
-import org.vertx.java.core.impl.DefaultContext;
+import org.vertx.java.core.impl.ContextImpl;
 
 /**
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
 public class HandlerHolder<T> {
-  public final DefaultContext context;
+  public final ContextImpl context;
   public final Handler<T> handler;
 
-  HandlerHolder(DefaultContext context, Handler<T> handler) {
+  HandlerHolder(ContextImpl context, Handler<T> handler) {
     this.context = context;
     this.handler = handler;
   }

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/HandlerManager.java
Patch:
@@ -18,7 +18,7 @@
 
 import io.netty.channel.EventLoop;
 import org.vertx.java.core.Handler;
-import org.vertx.java.core.impl.DefaultContext;
+import org.vertx.java.core.impl.ContextImpl;
 import org.vertx.java.core.logging.Logger;
 import org.vertx.java.core.logging.impl.LoggerFactory;
 
@@ -54,7 +54,7 @@ public HandlerHolder<T> chooseHandler(EventLoop worker) {
     return handlers == null ? null : handlers.chooseHandler();
   }
 
-  public void addHandler(Handler<T> handler, DefaultContext context) {
+  public void addHandler(Handler<T> handler, ContextImpl context) {
     EventLoop worker = context.getEventLoop();
     availableWorkers.addWorker(worker);
     Handlers<T> handlers = new Handlers<T>();
@@ -66,7 +66,7 @@ public void addHandler(Handler<T> handler, DefaultContext context) {
     handlerCount++;
   }
 
-  public void removeHandler(Handler<T> handler, DefaultContext context) {
+  public void removeHandler(Handler<T> handler, ContextImpl context) {
     EventLoop worker = context.getEventLoop();
     Handlers<T> handlers = handlerMap.get(worker);
     if (!handlers.removeHandler(new HandlerHolder<>(context, handler))) {

File: vertx-core/src/main/java/org/vertx/java/core/sockjs/EventBusBridge.java
Patch:
@@ -22,7 +22,7 @@
 import org.vertx.java.core.buffer.Buffer;
 import org.vertx.java.core.eventbus.EventBus;
 import org.vertx.java.core.eventbus.Message;
-import org.vertx.java.core.impl.DefaultFutureResult;
+import org.vertx.java.core.impl.FutureResultImpl;
 import org.vertx.java.core.json.JsonArray;
 import org.vertx.java.core.json.JsonObject;
 import org.vertx.java.core.logging.Logger;
@@ -415,7 +415,7 @@ private void authorise(final JsonObject message, final String sessionID,
                            final Handler<AsyncResult<Boolean>> handler) {
     if (!handleAuthorise(message, sessionID, handler)) {
       // If session id is in local cache we'll consider them authorised
-      final DefaultFutureResult<Boolean> res = new DefaultFutureResult<>();
+      final FutureResultImpl<Boolean> res = new FutureResultImpl<>();
       if (authCache.containsKey(sessionID)) {
         res.setResult(true).setHandler(handler);
       } else {

File: vertx-core/src/test/java/org/vertx/java/tests/core/FileSystemTest.java
Patch:
@@ -27,7 +27,7 @@
 import org.vertx.java.core.file.AsyncFile;
 import org.vertx.java.core.file.FileProps;
 import org.vertx.java.core.file.FileSystemProps;
-import org.vertx.java.core.file.impl.DefaultAsyncFile;
+import org.vertx.java.core.file.impl.AsyncFileImpl;
 import org.vertx.java.core.impl.Windows;
 import org.vertx.java.core.streams.Pump;
 import org.vertx.java.core.streams.ReadStream;
@@ -1100,7 +1100,7 @@ public void testPumpFileStreams() throws Exception {
     String fileName2 = "some-other-file.dat";
 
     //Non integer multiple of buffer size
-    int fileSize = (int) (DefaultAsyncFile.BUFFER_SIZE * 1000.3);
+    int fileSize = (int) (AsyncFileImpl.BUFFER_SIZE * 1000.3);
     byte[] content = randomByteArray(fileSize);
     createFile(fileName1, content);
 

File: vertx-hazelcast/src/main/java/org/vertx/java/spi/cluster/impl/hazelcast/HazelcastAsyncMultiMap.java
Patch:
@@ -21,7 +21,7 @@
 import org.vertx.java.core.AsyncResult;
 import org.vertx.java.core.AsyncResultHandler;
 import org.vertx.java.core.Handler;
-import org.vertx.java.core.impl.DefaultFutureResult;
+import org.vertx.java.core.impl.FutureResultImpl;
 import org.vertx.java.core.logging.Logger;
 import org.vertx.java.core.logging.impl.LoggerFactory;
 import org.vertx.java.core.spi.Action;
@@ -90,7 +90,7 @@ public Void perform() {
   @Override
   public void get(final K k, final Handler<AsyncResult<ChoosableIterable<V>>> resultHandler) {
     ChoosableSet<V> entries = cache.get(k);
-    DefaultFutureResult<ChoosableIterable<V>> result = new DefaultFutureResult<>();
+    FutureResultImpl<ChoosableIterable<V>> result = new FutureResultImpl<>();
     if (entries != null && entries.isInitialised()) {
       result.setResult(entries).setHandler(resultHandler);
     } else {
@@ -100,7 +100,7 @@ public Collection<V> perform() {
           }
         }, new AsyncResultHandler<Collection<V>>() {
           public void handle(AsyncResult<Collection<V>> result) {
-            DefaultFutureResult<ChoosableIterable<V>> sresult = new DefaultFutureResult<>();
+            FutureResultImpl<ChoosableIterable<V>> sresult = new FutureResultImpl<>();
             if (result.succeeded()) {
               Collection<V> entries = result.result();
               ChoosableSet<V> sids;

File: vertx-testsuite/src/test/java/org/vertx/java/fakecluster/FakeClusterManager.java
Patch:
@@ -28,8 +28,7 @@
 
 public class FakeClusterManager implements ClusterManager {
 
-  private static Map<String, FakeClusterManager> nodes =
-      Collections.synchronizedMap(new LinkedHashMap<String, FakeClusterManager>());
+  private static Map<String, FakeClusterManager> nodes = Collections.synchronizedMap(new LinkedHashMap<>());
 
   private static List<NodeListener> nodeListeners = new ArrayList<>();
   private static ConcurrentMap<String, Map> syncMaps = new ConcurrentHashMap<>();

File: vertx-testsuite/src/test/java/org/vertx/java/tests/newtests/LocalEventBusTest.java
Patch:
@@ -44,7 +44,6 @@ public class LocalEventBusTest extends VertxTestBase {
 
   @Before
   public void before() throws Exception {
-    super.before();
     eb = vertx.eventBus();
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/logging/Logger.java
Patch:
@@ -30,8 +30,8 @@
  *
  * <p>If you would prefer to use Log4J or SLF4J instead of JUL then you can set a system property called
  * {@code org.vertx.logger-delegate-factory-class-name} to the class name of the delegate for your logging system.
- * For Log4J the value is {@code org.vertx.java.core.logging.Log4JLogDelegateFactory}, for SLF4J the value
- * is {@code org.vertx.java.core.logging.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
+ * For Log4J the value is {@code org.vertx.java.core.logging.impl.Log4JLogDelegateFactory}, for SLF4J the value
+ * is {@code org.vertx.java.core.logging.impl.SLF4JLogDelegateFactory}. You will need to ensure whatever jar files
  * required by your favourite log framework are on your classpath.</p>
  *
  * @author <a href="mailto:tim.fox@jboss.com">Tim Fox</a>

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/resolver/MavenResolution.java
Patch:
@@ -133,7 +133,7 @@ static String getResourceName(String data, String contentRoot, ModuleIdentifier
         // Timestamped SNAPSHOT
         actualURI = contentRoot + '/' + uriRoot + identifier.getName() + '-' +
             identifier.getVersion().substring(0, identifier.getVersion().length() - 9) + '-' +
-            timestamp + '-' + buildNumber + (modSuffix ? "" : "-mod") + ".zip";
+            timestamp + '-' + buildNumber + (modSuffix ? "-mod" : "") + ".zip";
       }
     }
     if (actualURI == null) {

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/resolver/MavenResolution.java
Patch:
@@ -133,7 +133,7 @@ static String getResourceName(String data, String contentRoot, ModuleIdentifier
         // Timestamped SNAPSHOT
         actualURI = contentRoot + '/' + uriRoot + identifier.getName() + '-' +
             identifier.getVersion().substring(0, identifier.getVersion().length() - 9) + '-' +
-            timestamp + '-' + buildNumber + (modSuffix ? "" : "-mod") + ".zip";
+            timestamp + '-' + buildNumber + (modSuffix ? "-mod" : "") + ".zip";
       }
     }
     if (actualURI == null) {

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/ClientConnection.java
Patch:
@@ -27,7 +27,7 @@
 import org.vertx.java.core.buffer.Buffer;
 import org.vertx.java.core.http.WebSocket;
 import org.vertx.java.core.http.WebSocketVersion;
-import org.vertx.java.core.http.impl.ws.WebSocketFrame;
+import org.vertx.java.core.http.impl.ws.WebSocketFrameInternal;
 import org.vertx.java.core.impl.DefaultContext;
 import org.vertx.java.core.impl.VertxInternal;
 import org.vertx.java.core.logging.Logger;
@@ -321,7 +321,7 @@ void handleResponseEnd(LastHttpContent trailer) {
     }
   }
 
-  void handleWsFrame(WebSocketFrame frame) {
+  void handleWsFrame(WebSocketFrameInternal frame) {
     if (ws != null) {
       setContext();
       ws.handleFrame(frame);

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpClientResponse.java
Patch:
@@ -27,8 +27,8 @@
 import org.vertx.java.core.http.HttpClientResponse;
 import org.vertx.java.core.net.NetSocket;
 
+import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 
@@ -181,7 +181,7 @@ protected void handle() {
   void handleChunk(Buffer data) {
     if (paused) {
       if (pausedChunks == null) {
-        pausedChunks = new LinkedList<>();
+        pausedChunks = new ArrayDeque<>();
       }
       pausedChunks.add(data);
     } else {

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/PartialPooledByteBufAllocator.java
Patch:
@@ -35,8 +35,7 @@ public final class PartialPooledByteBufAllocator implements ByteBufAllocator {
   // Make sure we use the same number of areas as EventLoop's to reduce condition.
   // We can remove this once the following netty issue is fixed:
   // See https://github.com/netty/netty/issues/2264
-  private static final ByteBufAllocator POOLED = new PooledByteBufAllocator(
-          false, VertxExecutorFactory.eventLoopSize(), VertxExecutorFactory.eventLoopSize(), 8192, 11);
+  private static final ByteBufAllocator POOLED = new PooledByteBufAllocator(false);
   private static final ByteBufAllocator UNPOOLED = new UnpooledByteBufAllocator(false);
 
   public static final PartialPooledByteBufAllocator INSTANCE = new PartialPooledByteBufAllocator();

File: vertx-core/src/main/java/org/vertx/java/core/shareddata/SharedData.java
Patch:
@@ -44,6 +44,7 @@
  *   {@code byte[]} - this will be automatically copied, and the copy will be stored in the structure.
  *   {@link org.vertx.java.core.buffer.Buffer} - this will be automatically copied, and the copy will be stored in the
  *   structure.
+ *   Classes implementing {@link org.vertx.java.core.shareddata.Shareable}
  * </pre>
  * <p>
  *

File: vertx-core/src/main/java/org/vertx/java/core/shareddata/SharedData.java
Patch:
@@ -44,6 +44,7 @@
  *   {@code byte[]} - this will be automatically copied, and the copy will be stored in the structure.
  *   {@link org.vertx.java.core.buffer.Buffer} - this will be automatically copied, and the copy will be stored in the
  *   structure.
+ *   Classes implementing {@link org.vertx.java.core.shareddata.Shareable}
  * </pre>
  * <p>
  *

File: vertx-core/src/main/java/org/vertx/java/core/sockjs/impl/BaseTransport.java
Patch:
@@ -104,6 +104,8 @@ public void handle() {
 
     @Override
     public void sessionClosed() {
+      session.writeClosed(this);
+      close();
     }
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/sockjs/impl/JsonPTransport.java
Patch:
@@ -70,7 +70,7 @@ public void handle(final HttpServerRequest req) {
         if (log.isTraceEnabled()) log.trace("JsonP, post: " + req.uri());
         String sessionID = req.params().get("param0");
         final Session session = sessions.get(sessionID);
-        if (session != null) {
+        if (session != null && !session.isClosed()) {
           handleSend(req, session);
         } else {
           req.response().setStatusCode(404);

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/PriorityHttpConnectionPool.java
Patch:
@@ -105,6 +105,7 @@ public void connectionClosed(ClientConnection conn) {
       connectionCount--;
       if (conn != null) {
         allConnections.remove(conn);
+        available.remove(conn);
       }
       if (connectionCount < maxPoolSize) {
         //Now the connection count has come down, maybe there is another waiter that can

File: vertx-testsuite/src/test/java/org/vertx/java/tests/core/net/JavaNetTest.java
Patch:
@@ -439,7 +439,7 @@ public void testRemoteAddress() throws Exception {
 
   @Test
   public void testListenOnWildcardPort() throws Exception {
-    startTest(getMethodName(), false);
+    startTest(getMethodName());
   }
 
   @Test

File: vertx-core/src/main/java/org/vertx/java/core/shareddata/SharedData.java
Patch:
@@ -44,6 +44,7 @@
  *   {@code byte[]} - this will be automatically copied, and the copy will be stored in the structure.
  *   {@link org.vertx.java.core.buffer.Buffer} - this will be automatically copied, and the copy will be stored in the
  *   structure.
+ *   Classes implementing {@link org.vertx.java.core.shareddata.Shareable}
  * </pre>
  * <p>
  *

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/DefaultPlatformManager.java
Patch:
@@ -682,7 +682,7 @@ private void doMakeFatJar(File modRoot, ModuleIdentifier modID, String directory
   private void doCreateModuleLink(File modRoot, ModuleIdentifier modID) {
     File cpFile = new File(CLASSPATH_FILE);
     if (!cpFile.exists()) {
-      throw new PlatformManagerException("Must create a module.classpath first before creating a module link");
+      throw new PlatformManagerException("Must create a vertx_classpath.txt file first before creating a module link");
     }
     File modDir = new File(modRoot, modID.toString());
     if (modDir.exists()) {
@@ -1153,7 +1153,7 @@ private ModuleInfo loadModuleInfo(File modDir, ModuleIdentifier modID) {
           String path = scanner.next().trim();
           File cpFile = new File(path, CLASSPATH_FILE);
           if (!cpFile.exists()) {
-            throw new PlatformManagerException("Module link file: " + linkFile + " points to path without module.classpath");
+            throw new PlatformManagerException("Module link file: " + linkFile + " points to path without vertx_classpath.txt");
           }
           // Load the cp
           cpList = new ArrayList<>();

File: vertx-core/src/main/java/org/vertx/java/core/sockjs/EventBusBridge.java
Patch:
@@ -271,7 +271,6 @@ public void handle(final SockJSSocket sock) {
 
       sock.endHandler(new VoidHandler() {
         public void handle() {
-          System.out.println("In handlesocketclosed");
           handleSocketClosed(sock, handlers);
         }
       });

File: vertx-core/src/main/java/org/vertx/java/core/sockjs/impl/Session.java
Patch:
@@ -281,7 +281,6 @@ synchronized void register(final TransportListener lst) {
   // Actually close the session - when the user calls close() the session actually continues to exist until timeout
   // Yes, I know it's weird but that's the way SockJS likes it.
   private void doClose() {
-    System.out.println(("**** do close called !!"));
     super.close(); // We must call this or handlers don't get unregistered and we get a leak
     if (heartbeatID != -1) {
       vertx.cancelTimer(heartbeatID);
@@ -291,7 +290,6 @@ private void doClose() {
     }
     if (id != null) {
       // Can be null if websocket session
-      System.out.println(("**** removing session!!"));
       sessions.remove(id);
     }
 

File: vertx-core/src/main/java/org/vertx/java/core/sockjs/EventBusBridge.java
Patch:
@@ -272,7 +272,6 @@ public void handle(final SockJSSocket sock) {
       sock.endHandler(new VoidHandler() {
         public void handle() {
           System.out.println("In handlesocketclosed");
-          new Exception().printStackTrace();
           handleSocketClosed(sock, handlers);
         }
       });

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/DefaultDnsClient.java
Patch:
@@ -30,6 +30,7 @@
 import org.vertx.java.core.impl.DefaultContext;
 import org.vertx.java.core.impl.DefaultFutureResult;
 import org.vertx.java.core.impl.VertxInternal;
+import org.vertx.java.core.net.impl.PartialPooledByteBufAllocator;
 
 import java.net.*;
 import java.util.*;
@@ -58,6 +59,7 @@ public DefaultDnsClient(VertxInternal vertx, InetSocketAddress... dnsServers) {
     bootstrap = new Bootstrap();
     bootstrap.group(actualCtx.getEventLoop());
     bootstrap.channel(NioDatagramChannel.class);
+    bootstrap.option(ChannelOption.ALLOCATOR, PartialPooledByteBufAllocator.INSTANCE);
     bootstrap.handler(new ChannelInitializer<DatagramChannel>() {
       @Override
       protected void initChannel(DatagramChannel ch) throws Exception {

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/ws/DefaultWebSocketFrame.java
Patch:
@@ -48,7 +48,8 @@ public DefaultWebSocketFrame(FrameType frameType) {
    * Creates a new text frame from with the specified string.
    */
   public DefaultWebSocketFrame(String textData) {
-    this(FrameType.TEXT, Unpooled.copiedBuffer(textData, CharsetUtil.UTF_8));
+    this.type = FrameType.TEXT;
+    this.binaryData = Unpooled.copiedBuffer(textData, CharsetUtil.UTF_8);
   }
 
   /**

File: vertx-core/src/main/java/org/vertx/java/core/datagram/impl/DatagramServerHandler.java
Patch:
@@ -16,6 +16,7 @@
 package org.vertx.java.core.datagram.impl;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.socket.DatagramPacket;
@@ -67,12 +68,12 @@ public void run() {
   }
 
   @Override
-  protected Object safeObject(Object msg) throws Exception {
+  protected Object safeObject(Object msg, ByteBufAllocator allocator) throws Exception {
     if (msg instanceof DatagramPacket) {
       DatagramPacket packet = (DatagramPacket) msg;
       ByteBuf content = packet.content();
       if (content.isDirect())  {
-        content = safeBuffer(content);
+        content = safeBuffer(content, allocator);
       }
       return new DefaultDatagramPacket(packet.sender(), new Buffer(content));
     }

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/VertxNetHandler.java
Patch:
@@ -17,6 +17,7 @@
 package org.vertx.java.core.net.impl;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import org.vertx.java.core.buffer.Buffer;
@@ -68,9 +69,9 @@ public void run() {
   }
 
   @Override
-  protected Object safeObject(Object msg) throws Exception {
+  protected Object safeObject(Object msg, ByteBufAllocator allocator) throws Exception {
     if (msg instanceof ByteBuf) {
-      return safeBuffer((ByteBuf) msg);
+      return safeBuffer((ByteBuf) msg, allocator);
     }
     return msg;
   }

File: vertx-core/src/main/java/org/vertx/java/core/impl/VertxInternal.java
Patch:
@@ -22,6 +22,7 @@
 import org.vertx.java.core.net.impl.DefaultNetServer;
 import org.vertx.java.core.net.impl.ServerID;
 import org.vertx.java.core.spi.VertxSPI;
+import org.vertx.java.core.spi.cluster.ClusterManager;
 
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
@@ -66,4 +67,6 @@ public interface VertxInternal extends VertxSPI {
    * @return event loop context
    */
   EventLoopContext createEventLoopContext();
+
+  ClusterManager clusterManager();
 }

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/ClientConnection.java
Patch:
@@ -193,8 +193,7 @@ public void run() {
             } else {
               buffered.add(msg);
             }
-          }
-          catch (WebSocketHandshakeException e) {
+          } catch (WebSocketHandshakeException e) {
             handshaking = false;
             actualClose();
             fire = false;

File: vertx-testsuite/src/test/java/vertx/tests/core/websockets/WebsocketsTestClient.java
Patch:
@@ -291,8 +291,6 @@ public void handle(AsyncResult<HttpServer> ar) {
         tu.azzert(ar.succeeded());
         client.exceptionHandler(new Handler<Throwable>() {
           public void handle(Throwable t) {
-            System.out.println("exce handler called");
-            new Exception().printStackTrace();
             tu.testComplete();
           }
         });

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpServerResponse.java
Patch:
@@ -96,7 +96,7 @@ public int getStatusCode() {
 
   @Override
   public HttpServerResponse setStatusCode(int statusCode) {
-    this.response.setStatus(HttpResponseStatus.valueOf(statusCode));
+    this.response.setStatus(new HttpResponseStatus(statusCode, response.getStatus().reasonPhrase()));
     return this;
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/impl/DefaultVertx.java
Patch:
@@ -18,6 +18,7 @@
 
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
+import io.netty.util.ResourceLeakDetector;
 import org.vertx.java.core.*;
 import org.vertx.java.core.datagram.DatagramSocket;
 import org.vertx.java.core.datagram.InternetProtocolFamily;
@@ -65,7 +66,7 @@ public class DefaultVertx implements VertxInternal {
 
   static {
     // Netty resource leak detection has a performance overhead and we do not need it in Vert.x
-    System.setProperty("io.netty.noResourceLeakDetection", "true");
+    ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.DISABLED);
     // Use the JDK deflater/inflater by default
     System.setProperty("io.netty.noJdkZlibDecoder", "false");
   }

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpServer.java
Patch:
@@ -64,7 +64,6 @@
 public class DefaultHttpServer implements HttpServer, Closeable {
 
   private static final Logger log = LoggerFactory.getLogger(DefaultHttpServer.class);
-  private static final ExceptionDispatchHandler EXCEPTION_DISPATCH_HANDLER = new ExceptionDispatchHandler();
   private static final CharSequence ALLOW = HttpHeaders.newEntity("allow");
   private static final CharSequence GET =  HttpHeaders.newEntity("GET");
   private static final CharSequence WEBSOCKET = HttpHeaders.newEntity(io.netty.handler.codec.http.HttpHeaders.Values.WEBSOCKET);
@@ -166,7 +165,6 @@ public HttpServer listen(int port, String host, final Handler<AsyncResult<HttpSe
             @Override
             protected void initChannel(Channel ch) throws Exception {
               ChannelPipeline pipeline = ch.pipeline();
-              pipeline.addLast("exceptionDispatcher", EXCEPTION_DISPATCH_HANDLER);
               if (tcpHelper.isSSL()) {
                 SSLEngine engine = tcpHelper.getSSLContext().createSSLEngine();
                 engine.setUseClientMode(false);

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/DefaultNetClient.java
Patch:
@@ -41,7 +41,6 @@
 public class DefaultNetClient implements NetClient {
 
   private static final Logger log = LoggerFactory.getLogger(DefaultNetClient.class);
-  private static final ExceptionDispatchHandler EXCEPTION_DISPATCH_HANDLER = new ExceptionDispatchHandler();
 
   private final VertxInternal vertx;
   private final DefaultContext actualCtx;
@@ -313,8 +312,6 @@ private void connect(final int port, final String host, final Handler<AsyncResul
         @Override
         protected void initChannel(Channel ch) throws Exception {
           ChannelPipeline pipeline = ch.pipeline();
-          pipeline.addLast("exceptionDispatcher", EXCEPTION_DISPATCH_HANDLER);
-
           if (tcpHelper.isSSL()) {
             SslHandler sslHandler = tcpHelper.createSslHandler(vertx, true);
             pipeline.addLast("ssl", sslHandler);

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/DefaultNetServer.java
Patch:
@@ -49,7 +49,6 @@
 public class DefaultNetServer implements NetServer, Closeable {
 
   private static final Logger log = LoggerFactory.getLogger(DefaultNetServer.class);
-  private static final ExceptionDispatchHandler EXCEPTION_DISPATCH_HANDLER = new ExceptionDispatchHandler();
 
   private final VertxInternal vertx;
   private final DefaultContext actualCtx;
@@ -120,7 +119,6 @@ public NetServer listen(final int port, final String host, final Handler<AsyncRe
           @Override
           protected void initChannel(Channel ch) throws Exception {
             ChannelPipeline pipeline = ch.pipeline();
-            pipeline.addLast("exceptionDispatcher", EXCEPTION_DISPATCH_HANDLER);
             if (tcpHelper.isSSL()) {
               SslHandler sslHandler = tcpHelper.createSslHandler(vertx, false);
               pipeline.addLast("ssl", sslHandler);

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/PartialPooledByteBufAllocator.java
Patch:
@@ -55,17 +55,17 @@ public ByteBuf buffer(int initialCapacity, int maxCapacity) {
 
   @Override
   public ByteBuf ioBuffer() {
-    return UNPOOLED.heapBuffer();
+    return POOLED.directBuffer();
   }
 
   @Override
   public ByteBuf ioBuffer(int initialCapacity) {
-    return UNPOOLED.heapBuffer(initialCapacity);
+    return POOLED.directBuffer(initialCapacity);
   }
 
   @Override
   public ByteBuf ioBuffer(int initialCapacity, int maxCapacity) {
-    return UNPOOLED.heapBuffer(initialCapacity, maxCapacity);
+    return POOLED.directBuffer(initialCapacity, maxCapacity);
   }
 
   @Override

File: vertx-core/src/main/java/org/vertx/java/core/net/impl/VertxHandler.java
Patch:
@@ -127,7 +127,6 @@ public void run() {
   public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
     C conn = connectionMap.get(ctx.channel());
     if (conn != null) {
-      conn.endReadAndFlush();
       DefaultContext context = getContext(conn);
       // Only mark end read if its not a WorkerVerticle
       if (context.isOnCorrectWorker(ctx.channel().eventLoop())) {

File: vertx-testsuite/src/test/java/vertx/tests/core/http/HttpTestClient.java
Patch:
@@ -2126,7 +2126,9 @@ public void handle(AsyncResult<HttpServer> ar) {
         client.getNow("some-uri", new Handler<HttpClientResponse>() {
           public void handle(final HttpClientResponse response) {
             tu.azzert(response.statusCode() == 200);
-            tu.azzert(file.length() == Long.valueOf(response.headers().get("content-length")));
+            if (!compression()) {
+              tu.azzert(file.length() == Long.valueOf(response.headers().get("content-length")));
+            }
             tu.azzert("text/html".equals(response.headers().get("content-type")));
             response.bodyHandler(new Handler<Buffer>() {
               public void handle(Buffer buff) {

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/java/CompilingClassLoader.java
Patch:
@@ -62,7 +62,7 @@ public CompilingClassLoader(ClassLoader loader, String sourceName) {
       DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
       JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();
       if (javaCompiler == null) {
-        throw new RuntimeException("Unable to detect java compiler, make sure JAVA_HOME is set correctly");
+        throw new RuntimeException("Unable to detect java compiler, make sure you're using a JDK not a JRE!");
       }
       StandardJavaFileManager standardFileManager = javaCompiler.getStandardFileManager(null, null, null);
 

File: vertx-core/src/main/java/org/vertx/java/core/logging/impl/VertxLoggerFormatter.java
Patch:
@@ -29,7 +29,7 @@ public class VertxLoggerFormatter extends java.util.logging.Formatter {
   @Override
   public String format(final LogRecord record) {
     Date date = new Date();
-    SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss,SSS");
+    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
     StringBuffer sb = new StringBuffer();
     // Minimize memory allocations here.
     date.setTime(record.getMillis());

File: vertx-core/src/main/java/org/vertx/java/core/json/JsonObject.java
Patch:
@@ -173,7 +173,7 @@ public Boolean getBoolean(String fieldName) {
 
   public byte[] getBinary(String fieldName) {
     String encoded = (String) map.get(fieldName);
-    return Base64.decode(encoded);
+    return encoded == null ? null : Base64.decode(encoded);
   }
 
   public String getString(String fieldName, String def) {

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/java/CompilingClassLoader.java
Patch:
@@ -61,6 +61,9 @@ public CompilingClassLoader(ClassLoader loader, String sourceName) {
     try {
       DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
       JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();
+      if (javaCompiler == null) {
+        throw new RuntimeException("Unable to detect java compiler, make sure JAVA_HOME is set correctly");
+      }
       StandardJavaFileManager standardFileManager = javaCompiler.getStandardFileManager(null, null, null);
 
       standardFileManager.setLocation(StandardLocation.SOURCE_PATH, Collections.singleton(javaSourceContext.getSourceRoot()));

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/resolver/HttpResolution.java
Patch:
@@ -274,7 +274,6 @@ private static String getBasicAuth() {
   }
 
   private static int getProxyPort() {
-    return Integer.valueOf(System.getProperty(HTTP_PROXY_PORT_PROP_NAME, "80"));
+    return Integer.parseInt(System.getProperty(HTTP_PROXY_PORT_PROP_NAME, "80"));
   }
-
 }

File: vertx-testsuite/src/test/java/org/vertx/java/tests/platform/ProxyRepoDownloadTest.java
Patch:
@@ -25,7 +25,7 @@ public class ProxyRepoDownloadTest extends TestBase {
   @Override
   protected void setUp() throws Exception {
     System.setProperty("http.proxyHost", "127.0.0.1");
-    System.setProperty("http.proxyPort", "9193");
+    System.setProperty("http.proxyPort", "9194");
     super.setUp();
 
     startApp(RepoDownloadTestClient.class.getName());

File: vertx-testsuite/src/test/java/vertx/tests/RepoDownloadTestClient.java
Patch:
@@ -44,7 +44,9 @@ public void testMavenDownloadWithProxy() {
     container.deployModule("io.vertx~mod-proxy-maven-server~1.0", new AsyncResultHandler<String>() {
       public void handle(AsyncResult<String> res) {
         if (res.succeeded()) {
-          container.deployModule("io.vertx~mod-maven-test~1.0.0", new AsyncResultHandler<String>() {
+          // this should not use the same module as the regular test because if the regular test
+          // already downloaded this module, it will not actually use the proxy at all...
+          container.deployModule("io.vertx~mod-maven-proxy-test~1.0.0", new AsyncResultHandler<String>() {
             @Override
             public void handle(AsyncResult<String> res) {
             }

File: vertx-testsuite/src/test/mod-test/io.vertx~mod-proxy-maven-server~1.0/Server.java
Patch:
@@ -34,8 +34,8 @@ public void handle(HttpServerRequest req) {
         // It's being proxied so should be absolute url
         System.out.println("******************************************* uri is " + req.uri());
 
-        tu.azzert(req.uri().equals("http://localhost:9192/maven2/io/vertx/mod-maven-test/1.0.0/mod-maven-test-1.0.0-mod.zip")
-                ||req.uri().equals("http://localhost:9192/maven2/io/vertx/mod-maven-test/1.0.0/mod-maven-test-1.0.0.zip"));
+        tu.azzert(req.uri().equals("http://localhost:9193/maven2/io/vertx/mod-maven-proxy-test/1.0.0/mod-maven-proxy-test-1.0.0-mod.zip")
+                ||req.uri().equals("http://localhost:9193/maven2/io/vertx/mod-maven-proxy-test/1.0.0/mod-maven-proxy-test-1.0.0.zip"));
         if (req.path().indexOf("..") != -1) {
           req.response().setStatusCode(403);
           req.response().end();
@@ -44,7 +44,7 @@ public void handle(HttpServerRequest req) {
           req.response().sendFile("." + req.path());
         }
       }
-    }).listen(9193, "127.0.0.1", new AsyncResultHandler<HttpServer>() {
+    }).listen(9194, "127.0.0.1", new AsyncResultHandler<HttpServer>() {
       @Override
       public void handle(AsyncResult<HttpServer> ar) {
         result.setResult(null);

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/resolver/HttpResolution.java
Patch:
@@ -274,7 +274,6 @@ private static String getBasicAuth() {
   }
 
   private static int getProxyPort() {
-    return Integer.valueOf(System.getProperty(HTTP_PROXY_PORT_PROP_NAME, "80"));
+    return Integer.parseInt(System.getProperty(HTTP_PROXY_PORT_PROP_NAME, "80"));
   }
-
 }

File: vertx-testsuite/src/test/java/org/vertx/java/tests/platform/ProxyRepoDownloadTest.java
Patch:
@@ -25,7 +25,7 @@ public class ProxyRepoDownloadTest extends TestBase {
   @Override
   protected void setUp() throws Exception {
     System.setProperty("http.proxyHost", "127.0.0.1");
-    System.setProperty("http.proxyPort", "9193");
+    System.setProperty("http.proxyPort", "9194");
     super.setUp();
 
     startApp(RepoDownloadTestClient.class.getName());

File: vertx-testsuite/src/test/java/vertx/tests/RepoDownloadTestClient.java
Patch:
@@ -44,7 +44,9 @@ public void testMavenDownloadWithProxy() {
     container.deployModule("io.vertx~mod-proxy-maven-server~1.0", new AsyncResultHandler<String>() {
       public void handle(AsyncResult<String> res) {
         if (res.succeeded()) {
-          container.deployModule("io.vertx~mod-maven-test~1.0.0", new AsyncResultHandler<String>() {
+          // this should not use the same module as the regular test because if the regular test
+          // already downloaded this module, it will not actually use the proxy at all...
+          container.deployModule("io.vertx~mod-maven-proxy-test~1.0.0", new AsyncResultHandler<String>() {
             @Override
             public void handle(AsyncResult<String> res) {
             }

File: vertx-testsuite/src/test/mod-test/io.vertx~mod-proxy-maven-server~1.0/Server.java
Patch:
@@ -34,8 +34,8 @@ public void handle(HttpServerRequest req) {
         // It's being proxied so should be absolute url
         System.out.println("******************************************* uri is " + req.uri());
 
-        tu.azzert(req.uri().equals("http://localhost:9192/maven2/io/vertx/mod-maven-test/1.0.0/mod-maven-test-1.0.0-mod.zip")
-                ||req.uri().equals("http://localhost:9192/maven2/io/vertx/mod-maven-test/1.0.0/mod-maven-test-1.0.0.zip"));
+        tu.azzert(req.uri().equals("http://localhost:9193/maven2/io/vertx/mod-maven-proxy-test/1.0.0/mod-maven-proxy-test-1.0.0-mod.zip")
+                ||req.uri().equals("http://localhost:9193/maven2/io/vertx/mod-maven-proxy-test/1.0.0/mod-maven-proxy-test-1.0.0.zip"));
         if (req.path().indexOf("..") != -1) {
           req.response().setStatusCode(403);
           req.response().end();
@@ -44,7 +44,7 @@ public void handle(HttpServerRequest req) {
           req.response().sendFile("." + req.path());
         }
       }
-    }).listen(9193, "127.0.0.1", new AsyncResultHandler<HttpServer>() {
+    }).listen(9194, "127.0.0.1", new AsyncResultHandler<HttpServer>() {
       @Override
       public void handle(AsyncResult<HttpServer> ar) {
         result.setResult(null);

File: vertx-core/src/main/java/org/vertx/java/core/file/FileSystem.java
Patch:
@@ -115,7 +115,7 @@ public interface FileSystem {
    * Synchronous version of {@link #chown(String, String, String, Handler)}
    *
    */
-  FileSystem chownSync(String user, String group, String perms) ;
+  FileSystem chownSync(String path, String user, String group) ;
 
   /**
    * Obtain properties for the file represented by {@code path}, asynchronously.

File: vertx-core/src/main/java/org/vertx/java/core/file/FileSystem.java
Patch:
@@ -115,7 +115,7 @@ public interface FileSystem {
    * Synchronous version of {@link #chown(String, String, String, Handler)}
    *
    */
-  FileSystem chownSync(String user, String group, String perms) ;
+  FileSystem chownSync(String path, String user, String group) ;
 
   /**
    * Obtain properties for the file represented by {@code path}, asynchronously.

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpClient.java
Patch:
@@ -562,7 +562,7 @@ protected void initChannel(Channel ch) throws Exception {
 
           pipeline.addLast("codec", new HttpClientCodec(4096, 8192, 8192, false, false));
           if (tryUseCompression) {
-            pipeline.addLast("inflater", new HttpContentDecompressor());
+            pipeline.addLast("inflater", new HttpContentDecompressor(true));
           }
           pipeline.addLast("handler", new ClientHandler());
         }

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpServerResponse.java
Patch:
@@ -453,7 +453,7 @@ private void prepareHeaders() {
 
   private DefaultHttpServerResponse write(ByteBuf chunk, final Handler<AsyncResult<Void>> doneHandler) {
     checkWritten();
-    if (version != HttpVersion.HTTP_1_0 && !chunked && !contentLengthSet()) {
+    if (!headWritten && version != HttpVersion.HTTP_1_0 && !chunked && !contentLengthSet()) {
       throw new IllegalStateException("You must set the Content-Length header to be the total size of the message "
                                               + "body BEFORE sending any data if you are not using HTTP chunked encoding.");
     }

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/HttpChunkContentCompressor.java
Patch:
@@ -21,7 +21,6 @@
 import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.HttpContentCompressor;
 
-
 /**
  * @author <a href="mailto:nmaurer@redhat.com">Norman Maurer</a>
  */

File: vertx-core/src/main/java/org/vertx/java/core/impl/DefaultVertx.java
Patch:
@@ -66,6 +66,8 @@ public class DefaultVertx implements VertxInternal {
   static {
     // Netty resource leak detection has a performance overhead and we do not need it in Vert.x
     System.setProperty("io.netty.noResourceLeakDetection", "true");
+    // Use the JDK deflater/inflater by default
+    System.setProperty("io.netty.noJdkZlibDecoder", "false");
   }
 
   private final FileSystem fileSystem = getFileSystem();

File: vertx-core/src/main/java/org/vertx/java/core/eventbus/impl/BaseMessage.java
Patch:
@@ -163,6 +163,7 @@ public <T> void replyWithTimeout(JsonObject message, long timeout, Handler<Async
 
   @Override
   public <T> void reply(JsonArray message, Handler<Message<T>> replyHandler) {
+    System.out.println("Sending a json array");
     sendReply(new JsonArrayMessage(true, replyAddress, message), replyHandler);
   }
 

File: vertx-core/src/main/java/org/vertx/java/core/eventbus/impl/JsonArrayMessage.java
Patch:
@@ -85,7 +85,7 @@ protected Message<JsonArray> copy() {
 
   @Override
   protected byte type() {
-    return MessageFactory.TYPE_JSON;
+    return MessageFactory.TYPE_JSON_ARRAY;
   }
 
 }

File: vertx-core/src/main/java/org/vertx/java/core/eventbus/impl/JsonObjectMessage.java
Patch:
@@ -85,7 +85,7 @@ protected Message<JsonObject> copy() {
 
   @Override
   protected byte type() {
-    return MessageFactory.TYPE_JSON;
+    return MessageFactory.TYPE_JSON_OBJECT;
   }
 
 }

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/java/JavaSourceContext.java
Patch:
@@ -29,7 +29,6 @@
  * @author Janne Hietam&auml;ki
  */
 public class JavaSourceContext {
-  private final static String REMOVE_COMMENTS_REGEXP = "(?://.*)|(/\\*(?:.|[\\n\\r])*?\\*/)";
 
   private final String className;
   private final File sourceRoot;
@@ -74,7 +73,8 @@ public String getClassName() {
   private static String parsePackage(File file) {
     try {
       String source = new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8);
-      source = source.replaceAll(REMOVE_COMMENTS_REGEXP, " ");
+      // http://stackoverflow.com/questions/1657066/java-regular-expression-finding-comments-in-code
+      source = source.replaceAll( "//.*|(\"(?:\\\\[^\"]|\\\\\"|.)*?\")|(?s)/\\*.*?\\*/", "$1 " );
       for (String line : source.split("\\r?\\n")) {
         line = line.trim();
         if (!line.isEmpty()) {

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/resolver/BintrayRepoResolver.java
Patch:
@@ -27,7 +27,7 @@ public BintrayRepoResolver(Vertx vertx, String repoID) {
 
   @Override
   public boolean getModule(String filename, ModuleIdentifier modID) {
-    HttpResolution res = new BintrayResolution(vertx, repoHost, repoPort, modID, filename, contentRoot);
+    HttpResolution res = new BintrayResolution(vertx, repoScheme, repoHost, repoPort, modID, filename, contentRoot);
     res.getModule();
     return res.waitResult();
   }

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/resolver/MavenRepoResolver.java
Patch:
@@ -29,7 +29,7 @@ public MavenRepoResolver(Vertx vertx, String repoID) {
 
   @Override
   public boolean getModule(String filename, ModuleIdentifier moduleIdentifier) {
-    HttpResolution res = new MavenResolution(vertx, repoHost, repoPort, moduleIdentifier, filename, contentRoot);
+    HttpResolution res = new MavenResolution(vertx, repoScheme, repoHost, repoPort, moduleIdentifier, filename, contentRoot);
     res.getModule();
     return res.waitResult();
   }

File: vertx-platform/src/main/java/org/vertx/java/platform/impl/resolver/OldRepoResolver.java
Patch:
@@ -28,7 +28,7 @@ public OldRepoResolver(Vertx vertx, String repoID) {
 
   @Override
   public boolean getModule(String filename, ModuleIdentifier moduleIdentifier) {
-    HttpResolution res = new OldRepoResolution(vertx, repoHost, repoPort, moduleIdentifier, filename, contentRoot);
+    HttpResolution res = new OldRepoResolution(vertx, repoScheme, repoHost, repoPort, moduleIdentifier, filename, contentRoot);
     res.getModule();
     return res.waitResult();
   }

File: vertx-core/src/main/java/org/vertx/java/core/TCPSupport.java
Patch:
@@ -17,7 +17,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public interface TCPSupport<T> extends NetworkSupport {
+public interface TCPSupport<T> extends NetworkSupport<T> {
   /**
    * If {@code tcpNoDelay} is set to {@code true} then <a href="http://en.wikipedia.org/wiki/Nagle's_algorithm">Nagle's algorithm</a>
    * will turned <b>off</b> for the TCP connections created by this instance.

File: vertx-core/src/main/java/org/vertx/java/core/TCPSupport.java
Patch:
@@ -17,7 +17,7 @@
  *
  * @author <a href="http://tfox.org">Tim Fox</a>
  */
-public interface TCPSupport<T> extends NetworkSupport {
+public interface TCPSupport<T> extends NetworkSupport<T> {
   /**
    * If {@code tcpNoDelay} is set to {@code true} then <a href="http://en.wikipedia.org/wiki/Nagle's_algorithm">Nagle's algorithm</a>
    * will turned <b>off</b> for the TCP connections created by this instance.

File: vertx-hazelcast/src/main/java/org/vertx/java/spi/cluster/impl/hazelcast/HazelcastClusterManager.java
Patch:
@@ -169,7 +169,7 @@ public synchronized void memberRemoved(MembershipEvent membershipEvent) {
   private InputStream getConfigStream() {
     InputStream is = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);
     if (is == null) {
-      is = getClass().getClassLoader().getResourceAsStream(CONFIG_FILE);
+      is = getClass().getClassLoader().getResourceAsStream(DEFAULT_CONFIG_FILE);
     }
     return is;
   }

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/netty/DnsHeader.java
Patch:
@@ -109,7 +109,6 @@ public int getOpcode() {
      * Returns the type of {@link DnsMessage}.
      *
      * @see #TYPE_QUERY
-     * @see #TYPE_HEADER
      */
     public int getType() {
         return type;

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/netty/DnsResponseDecoder.java
Patch:
@@ -129,7 +129,7 @@ private static DnsResource decodeResource(ByteBuf buf, ByteBufAllocator allocato
      * Decodes a DNS response header, given a DNS packet in a byte buffer.
      *
      * @param parent
-     *            the parent {@link Message} to this header
+     *            the parent {@link DnsResponse} to this header
      * @param buf
      *            the byte buffer containing the DNS packet
      * @return a {@link DnsResponseHeader} containing the response's header
@@ -194,7 +194,7 @@ protected static DnsResponse decodeResponse(ByteBuf buf, ByteBufAllocator alloca
      * @param ctx
      *            the {@link io.netty.channel.ChannelHandlerContext} this
      *            {@link DnsResponseDecoder} belongs to
-     * @param buf
+     * @param packet
      *            the message being decoded, a {@link io.netty.channel.socket.DatagramPacket} containing
      *            a DNS packet
      * @param out

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/netty/DnsResponseHeader.java
Patch:
@@ -80,8 +80,7 @@ public int getZ() {
     }
 
     /**
-     * Returns the 4 bit return code. Response codes outlined in
-     * {@link ReturnCode}.
+     * Returns the 4 bit return code.
      */
     public int getResponseCode() {
         return responseCode;

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/netty/decoder/package-info.java
Patch:
@@ -15,7 +15,6 @@
  */
 
 /**
- * Handles the decoding of DNS response packets from {@link ByteBuf}s to other
- * data structures.
+ * Handles the decoding of DNS response packets.
  */
 package org.vertx.java.core.dns.impl.netty.decoder;

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/netty/decoder/record/package-info.java
Patch:
@@ -16,6 +16,6 @@
 
 /**
  * Some DNS response packets contain numerous pieces of data that cannot be
- * decoded into a single object such as a {@link String}.
+ * decoded into a single object such as a {@link java.lang.String}.
  */
 package org.vertx.java.core.dns.impl.netty.decoder.record;

File: vertx-core/src/main/java/org/vertx/java/core/impl/DefaultVertx.java
Patch:
@@ -309,14 +309,14 @@ public void stop() {
       for (HttpServer server : sharedHttpServers.values()) {
         server.close();
       }
-      sharedHttpServers = null;
+      sharedHttpServers.clear();
     }
 
     if (sharedNetServers != null) {
       for (NetServer server : sharedNetServers.values()) {
         server.close();
       }
-      sharedNetServers = null;
+      sharedNetServers.clear();
     }
 
     if (backgroundPool != null) {
@@ -334,7 +334,6 @@ public void stop() {
 
     if (eventLoopGroup != null) {
       eventLoopGroup.shutdownGracefully();
-      eventLoopGroup = null;
     }
 
     eventBus.close(null);

File: vertx-testsuite/src/test/java/org/vertx/java/tests/platform/ha/TestPlatformManager.java
Patch:
@@ -33,9 +33,10 @@ void failDuringFailover(boolean fail) {
   }
 
   public void simulateKill() {
-    if (clusterManager != null) {
-      clusterManager.leave();
+    if (haManager != null) {
+      haManager.simulateKill();
     }
+    super.stop();
   }
 
   // For testing only

File: vertx-testsuite/src/test/java/vertx/tests/core/dns/DnsTestClient.java
Patch:
@@ -342,9 +342,9 @@ public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) throws org.
       }
     });
 
-    dns.lookup("vertx.io", new Handler<AsyncResult<InetAddress>>() {
+    dns.lookup4("vertx.io", new Handler<AsyncResult<Inet4Address>>() {
       @Override
-      public void handle(AsyncResult<InetAddress> event) {
+      public void handle(AsyncResult<Inet4Address> event) {
         InetAddress result = event.result();
         tu.azzert(result != null);
         tu.azzert("10.0.0.1".equals(result.getHostAddress()));

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpServer.java
Patch:
@@ -158,7 +158,6 @@ public HttpServer listen(int port, String host, final Handler<AsyncResult<HttpSe
         bootstrap.channel(NioServerSocketChannel.class);
         tcpHelper.applyConnectionOptions(bootstrap);
         tcpHelper.checkSSL(vertx);
-        bootstrap.option(ChannelOption.SO_REUSEADDR, true);
         bootstrap.childHandler(new ChannelInitializer<Channel>() {
             @Override
             protected void initChannel(Channel ch) throws Exception {

File: vertx-core/src/main/java/org/vertx/java/core/dns/DnsClient.java
Patch:
@@ -104,7 +104,7 @@ public interface DnsClient {
    *                  If an error accours it will get failed.
    * @return          itself for method-chaining.
    */
-  DnsClient resolveCNAME(String name, Handler<AsyncResult<String>> handler);
+  DnsClient resolveCNAME(String name, Handler<AsyncResult<List<String>>> handler);
 
   /**
    * Try to resolve the MX records for the given name.
@@ -160,10 +160,10 @@ public interface DnsClient {
    *
    * @param name      The name for which the SRV records should be resolved
    * @param handler   the {@link Handler} to notify with the {@link AsyncResult}. The {@link AsyncResult} will get
-   *                  notified with a List that contains all resolved {@link String}s. If non was found it will
+   *                  notified with a List that contains all resolved {@link SrvRecord}s. If non was found it will
    *                  get notified with an empty {@link List}
    *                  If an error accours it will get failed.
    * @return          itself for method-chaining.
    */
-  DnsClient resolveSRV(String name, Handler<AsyncResult<List<String>>> handler);
+  DnsClient resolveSRV(String name, Handler<AsyncResult<List<SrvRecord>>> handler);
 }

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpServer.java
Patch:
@@ -158,7 +158,7 @@ public HttpServer listen(int port, String host, final Handler<AsyncResult<HttpSe
         bootstrap.channel(NioServerSocketChannel.class);
         tcpHelper.applyConnectionOptions(bootstrap);
         tcpHelper.checkSSL(vertx);
-
+        bootstrap.option(ChannelOption.SO_REUSEADDR, true);
         bootstrap.childHandler(new ChannelInitializer<Channel>() {
             @Override
             protected void initChannel(Channel ch) throws Exception {

File: vertx-core/src/main/java/org/vertx/java/core/dns/impl/netty/DnsResponseDecoder.java
Patch:
@@ -169,9 +169,8 @@ protected static DnsResponse decodeResponse(ByteBuf buf, ByteBufAllocator alloca
             response.addQuestion(decodeQuestion(buf));
         }
         if (header.getResponseCode() != 0) {
-            System.err.println("Encountered error decoding DNS response for domain \""
-                    + response.getQuestions().get(0).name() + "\": "
-                    + DnsResponseCode.valueOf(header.getResponseCode()));
+            // TODO: Provide patch upstream to Netty
+            return response;
         }
         for (int i = 0; i < header.getReadAnswers(); i++) {
             response.addAnswer(decodeResource(buf, allocator));

File: vertx-core/src/main/java/org/vertx/java/core/dns/DnsClient.java
Patch:
@@ -43,8 +43,8 @@ public interface DnsClient {
 
   DnsClient lookupTXTRecords(String record, Handler<AsyncResult<List<String>>> handler);
 
-  DnsClient lookupPTRRecord(String record, Handler<AsyncResult<List>> handler);
+  DnsClient lookupPTRRecord(String record, Handler<AsyncResult<String>> handler);
 
-  DnsClient lookupAAAARecord(String record, Handler<AsyncResult<List<InetAddress>>> handler);
+  DnsClient lookupAAAARecords(String record, Handler<AsyncResult<List<InetAddress>>> handler);
 
 }

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/DefaultHttpServer.java
Patch:
@@ -37,7 +37,6 @@
 import org.vertx.java.core.http.HttpServerRequest;
 import org.vertx.java.core.http.ServerWebSocket;
 import org.vertx.java.core.http.impl.cgbystrom.FlashPolicyHandler;
-import org.vertx.java.core.http.impl.ws.DefaultWebSocketFrame;
 import org.vertx.java.core.http.impl.ws.WebSocketFrame;
 import org.vertx.java.core.impl.*;
 import org.vertx.java.core.logging.Logger;
@@ -623,8 +622,9 @@ protected void doMessageReceived(ServerConnection conn, ChannelHandlerContext ct
             }
             break;
           case CLOSE:
-            //Echo back close frame
-            ch.writeAndFlush(new DefaultWebSocketFrame(WebSocketFrame.FrameType.CLOSE));
+            // Echo back close frame and close the connection once it was written.
+            // This is specified in the WebSockets RFC 6455 Section  5.4.1
+            ch.writeAndFlush(wsFrame).addListener(ChannelFutureListener.CLOSE);
         }
       } else if (msg instanceof HttpContent) {
         if (wsRequest != null) {

File: vertx-core/src/main/java/org/vertx/java/core/http/impl/UriParser.java
Patch:
@@ -39,7 +39,7 @@ static String path(String uri) {
       i  = uri.indexOf('/', i + 3);
     }
 
-   int queryStart = uri.indexOf(i, '?');
+   int queryStart = uri.indexOf('?', i);
    if (queryStart == -1) {
      queryStart = uri.length();
    }

File: vertx-testsuite/src/test/java/vertx/tests/core/http/HttpTestClient.java
Patch:
@@ -511,7 +511,7 @@ private void testSimpleRequest(final String method, final boolean specificMethod
       @Override
       public void handle(AsyncResult<HttpServer> ar) {
         tu.azzert(ar.succeeded());
-        getRequest(specificMethod, method, "some-uri", new Handler<HttpClientResponse>() {
+        getRequest(specificMethod, method, "/some-uri?foo=bar", new Handler<HttpClientResponse>() {
           public void handle(HttpClientResponse resp) {
             tu.checkThread();
             tu.testComplete();
@@ -522,6 +522,7 @@ public void handle(HttpClientResponse resp) {
     startServer(new Handler<HttpServerRequest>() {
       public void handle(HttpServerRequest req) {
         tu.checkThread();
+        tu.azzert(req.path().equals("/some-uri"), "Expected [/some-uri] but got [" + req.path() + "]");
         tu.azzert(req.method().equals(method));
         req.response().end();
       }

