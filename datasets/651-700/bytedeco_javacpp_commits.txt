File: src/main/java/org/bytedeco/javacpp/presets/javacpp.java
Patch:
@@ -50,7 +50,7 @@
                        "api-ms-win-core-sysinfo-l1-1-0", "api-ms-win-core-synch-l1-2-0", "api-ms-win-core-console-l1-1-0", "api-ms-win-core-debug-l1-1-0",
                        "api-ms-win-core-rtlsupport-l1-1-0", "api-ms-win-core-processthreads-l1-1-1", "api-ms-win-core-file-l1-2-0", "api-ms-win-core-profile-l1-1-0",
                        "api-ms-win-core-memory-l1-1-0", "api-ms-win-core-util-l1-1-0", "api-ms-win-core-interlocked-l1-1-0", "ucrtbase",
-                       "vcruntime140", "vcruntime140_1", "msvcp140", "msvcp140_1", "concrt140", "vcomp140"}
+                       "vcruntime140", "vcruntime140_1", "msvcp140", "msvcp140_1", "concrt140", "vcomp140", "libomp140.i386", "libomp140.x86_64"}
         ),
         @Platform(
             value = "windows-x86",

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -313,7 +313,9 @@ public void load(Class cls, boolean inherit) {
         }
         addAll("platform.executablepath", executablepath);
         addAll("platform.executable", executable);
-        setProperty("platform.library", library);
+        if (hasPlatformProperties || getProperty("platform.library", "").length() == 0) {
+            setProperty("platform.library", library);
+        }
 
         if (LoadEnabled.class.isAssignableFrom(c)) {
             try {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -812,7 +812,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("static JavaCPP_noinline jclass JavaCPP_getClass(JNIEnv* env, int i);");
             out.println("static inline void JavaCPP_loadGlobal(JNIEnv* env, jclass cls, const char* filename) {");
             out.println("#ifdef _WIN32");
-            out.println("    HMODULE handle = LoadLibrary(filename);");
+            out.println("    HMODULE handle = LoadLibraryA(filename);");
             out.println("    if (handle == NULL) {");
             out.println("        char temp[256];");
             out.println("        sprintf(temp, \"LoadLibrary() failed with 0x%lx\", GetLastError());");

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -654,6 +654,8 @@ TemplateMap template(Context context) throws ParserException {
                     String key = t.value;
                     map.put(key, map.get(key));
                     token = tokens.next();
+                } else {
+                    map.put("typename arg" + map.size(), null); // Anonymous type
                 }
             } else if (token.match(Token.IDENTIFIER)) {
                 Type type = type(context); // ignore?

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -154,7 +154,7 @@ static enum IntEnum { INT; int value; }
     static enum LongEnum { LONG; long value; }
     static final String JNI_VERSION = "JNI_VERSION_1_6";
     static final List<Class> baseClasses = Arrays.asList(new Class[] {
-            Loader.class,
+            Loader.Helper.class,
             Pointer.class,
             //FunctionPointer.class,
             BytePointer.class,
@@ -2065,6 +2065,7 @@ boolean methods(Class<?> cls) {
         Set<String> memberList = members.get(cls);
         if (!cls.isAnnotationPresent(Opaque.class) && cls != Loader.class
                 && !FunctionPointer.class.isAssignableFrom(cls)
+                && cls.getEnclosingClass() != Loader.class
                 && cls.getEnclosingClass() != Pointer.class) {
             if (memberList == null) {
                 members.put(cls, memberList = new LinkedHashSet<String>());

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1408,7 +1408,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("        return (typename UNIQUE_PTR_NAMESPACE::remove_const<T>::type*)ptr;");
             out.println("    }");
             out.println("    operator U&() const { return uniquePtr; }");
-            out.println("    operator U&&() { return UNIQUE_PTR_NAMESPACE::move(uniquePtr); }");
+            out.println("    operator U&&() { owner = NULL; return UNIQUE_PTR_NAMESPACE::move(uniquePtr); }");
             out.println("    operator U*() { return &uniquePtr; }");
             out.println("    T* ptr;");
             out.println("    size_t size;");
@@ -1437,7 +1437,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("        return ptr;");
             out.println("    }");
             out.println("    operator const T*() { return ptr; }");
-            out.println("    operator T&&() { return MOVE_NAMESPACE::move(movedPtr); }");
+            out.println("    operator T&&() { owner = NULL; return MOVE_NAMESPACE::move(movedPtr); }");
             out.println("    T* ptr;");
             out.println("    size_t size;");
             out.println("    void* owner;");

File: src/main/java/org/bytedeco/javacpp/tools/DeclarationList.java
Patch:
@@ -67,6 +67,8 @@ public boolean add(Declaration decl, String fullName) {
         if (templateMap != null && templateMap.empty() && !decl.custom && (decl.type != null || decl.declarator != null)) {
             // method templates cannot be declared in Java, but make sure to make their
             // info available on request (when Info.javaNames or Info.define is set) to be able to create instances
+            // decl.custom is true when info has a javaText and define is false. This allows to apply a javaText
+            // to a template without instantiating it. define forces instantiation.
             if (infoIterator == null) {
                 Type type = templateMap.type = decl.type;
                 Declarator dcl = templateMap.declarator = decl.declarator;

File: src/main/java/org/bytedeco/javacpp/tools/TemplateMap.java
Patch:
@@ -48,7 +48,7 @@ boolean empty() {
                 return false;
             }
         }
-        return !isEmpty();
+        return true;
     }
 
     boolean full() {

File: src/main/java/org/bytedeco/javacpp/tools/Templates.java
Patch:
@@ -32,7 +32,7 @@ class Templates {
 
     static final Pattern templatePattern = Pattern.compile("<[^<>=]*>");
 
-    /** Remove template arguments from s, taking care of nested templates, default arguments (xxx<>), operator <=>, ->, etc... */
+    /** Remove template arguments from s, taking care of nested templates, default arguments {@code (xxx<>), operator <=>, ->}, etc */
     static String strip(String s) {
         Matcher m;
         do {

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -47,6 +47,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
                                                    "std::function", "std::basic_string"))
         .put(new Info("basic/types").cppTypes("signed", "unsigned", "char", "short", "int", "long", "bool", "float", "double",
                                               "__int8", "__int16", "__int32", "__int64", "_Bool", "_Complex", "_Imaginary", "complex", "imaginary"))
+        .put(new Info("deprecated").annotations("@Deprecated"))
         .put(new Info("noexcept").annotations("@NoException(true)"))
 
         .put(new Info("__COUNTER__").cppText("#define __COUNTER__ 0"))

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -44,7 +44,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("basic/containers").cppTypes("std::array", "std::bitset", "std::deque", "std::list", "std::map", "std::queue", "std::set",
                                                    "std::stack", "std::vector", "std::valarray", "std::pair", "std::tuple", "std::forward_list",
                                                    "std::priority_queue", "std::unordered_map", "std::unordered_set", "std::optional", "std::variant",
-                                                   "std::function"))
+                                                   "std::function", "std::basic_string"))
         .put(new Info("basic/types").cppTypes("signed", "unsigned", "char", "short", "int", "long", "bool", "float", "double",
                                               "__int8", "__int16", "__int32", "__int64", "_Bool", "_Complex", "_Imaginary", "complex", "imaginary"))
         .put(new Info("noexcept").annotations("@NoException(true)"))

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -806,7 +806,7 @@ public static File extractResource(URL resourceURL, File directoryOrFile,
                             // ... extract it from our resources ...
                             file.delete();
                             String s = resourceURL.toString();
-                            URL u = new URL(s.substring(0, s.indexOf("!/") + 2) + entryName);
+                            URL u = new URL(s.substring(0, s.lastIndexOf("!/") + 2) + entryName);
                             file = extractResource(u, file, prefix, suffix);
                         }
                         file.setLastModified(entryTimestamp);

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3359,7 +3359,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
             return false;
         }
         if (!tokens.get().match('{') && tokens.get(1).match(Token.IDENTIFIER)
-                && !tokens.get(1).match(Token.FINAL)
+                && !tokens.get(1).match(Token.FINAL) && !friend
                 && (typedef || !tokens.get(2).match(';'))) {
             tokens.next();
         }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -906,6 +906,9 @@ Type type(Context context, boolean definition) throws ParserException {
             type.indirections++;
             if (type.reference) {
                 type.constValue = false;
+            } else if (type.constValue) {
+                type.constValue = false;
+                type.constPointer = true; // For good measure. constPointer is ignored in this case.
             }
             type.cppName = type.cppName.substring(0, type.cppName.length() - 1);
         }

File: src/main/java/org/bytedeco/javacpp/annotation/NoException.java
Patch:
@@ -22,6 +22,6 @@
 @Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface NoException {
-    /** On override, indicates whether to use the C++ noexcept operator or not. */
+    /** On override, indicates whether to use the C++ noexcept specifier or not. */
     boolean value() default false;
 }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -126,7 +126,7 @@ public static String getPlatform() {
                 osArch = "x86_64";
             } else if (osArch.startsWith("aarch64") || osArch.startsWith("armv8") || osArch.startsWith("arm64")) {
                 osArch = "arm64";
-            } else if ((osArch.startsWith("arm")) && ((abiType.equals("gnueabihf")) || (libPath.contains("openjdk-armhf")))) {
+            } else if ((osArch.startsWith("arm")) && ((abiType.equals("gnueabihf")) || (libPath.contains("jdk-armhf")))) {
                 osArch = "armhf";
             } else if (osArch.startsWith("arm")) {
                 osArch = "arm";

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -449,7 +449,7 @@ int compile(String[] sourceFilenames, String outputFilename, ClassProperties pro
     /**
      * Creates and returns the directory where output files should be placed.
      * Uses {@link #outputDirectory} as is when available, but falls back
-     * on the shortest common path to the classes as well as the platform
+     * on the longest common path to the classes as well as the platform
      * specific library path when available, or the platform name itself
      * and the user provided extension when not.
      *
@@ -476,12 +476,12 @@ File getOutputPath(Class[] classes, String[] sourcePrefixes) throws IOException
                 String resourceURL = Loader.findResource(classes[0], resourceName).toString();
                 String packageURI = resourceURL.substring(0, resourceURL.lastIndexOf('/') + 1);
                 for (int i = 1; i < classes.length; i++) {
-                    // Use shortest common package name among all classes as default output path
+                    // Use the longest common package name among all classes as default output path
                     String resourceName2 = '/' + classes[i].getName().replace('.', '/')  + ".class";
                     String resourceURL2 = Loader.findResource(classes[i], resourceName2).toString();
                     String packageURI2 = resourceURL2.substring(0, resourceURL2.lastIndexOf('/') + 1);
 
-                    String longest = packageURI2.length() > packageURI.length() ? packageURI2 : packageURI;
+                    String longest = packageURI2.length() >= packageURI.length() ? packageURI2 : packageURI;
                     String shortest = packageURI2.length() < packageURI.length() ? packageURI2 : packageURI;
                     while (!longest.startsWith(shortest) && shortest.lastIndexOf('/') > 0) {
                         shortest = shortest.substring(0, shortest.lastIndexOf('/'));

File: src/main/java/org/bytedeco/javacpp/tools/DeclarationList.java
Patch:
@@ -138,8 +138,8 @@ public boolean add(Declaration decl, String fullName) {
             return false;
         }
 
-        // place all definitions prior to the declaractions that need them
-        List<Declaration> stack = new ArrayList<Declaration>();
+        // place all definitions prior to the declarations that need them
+        List<Declaration> stack = new ArrayList<>();
         ListIterator<Declaration> it = stack.listIterator();
         it.add(decl); it.previous();
         while (it.hasNext()) {

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3834,7 +3834,7 @@ boolean enumeration(Context context, DeclarationList declList) throws ParserExce
             String cast = javaType.equals("byte") || javaType.equals("short") ? "(" + javaType + ")(" : "";
             text += spacing + javaName + spacing2 + " = " + cast + countPrefix;
             text2 += spacing + javaName + spacing2 + "(" + cast + countPrefix;
-            if (enumeratorMap.containsKey(countPrefix)) {
+            if (enumeratorMap.containsKey(countPrefix.trim())) {
                 text2 += ".value";
             }
             if (countPrefix.trim().length() > 0) {

File: src/main/java/org/bytedeco/javacpp/tools/TokenIndexer.java
Patch:
@@ -252,7 +252,7 @@ Token[] expand(Token[] array, int index) {
                     // concatenate tokens as required
                     for (int i = startToken; i < tokens.size(); i++) {
                         if (tokens.get(i).match("##")) {
-                            if (i > 0 && i + 1 < tokens.size()) {
+                            if (i > 0 && i + 1 < tokens.size() && !tokens.get(i - 1).match(',')) {
                                 tokens.get(i - 1).value += tokens.get(i + 1).value;
                                 tokens.remove(i);
                                 tokens.remove(i);

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1391,7 +1391,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("        this->ptr = ptr;");
             out.println("        this->size = size;");
             out.println("        this->owner = owner;");
-            out.println("        this->uniquePtr = owner != NULL && owner != ptr ? (U&&)*(U*)owner : U((T*)ptr);");
+            out.println("        this->uniquePtr = owner != NULL && owner != ptr ? (U&&)*(U*)owner : U((T*)NULL);");
             out.println("    }");
             out.println("    static void deallocate(void* owner) { delete (U*)owner; }");
             out.println("    operator typename UNIQUE_PTR_NAMESPACE::remove_const<T>::type*() {");

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -315,6 +315,8 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("#elif defined(__APPLE__) && defined(__OBJC__)");
         out.println("    #include <TargetConditionals.h>");
         out.println("    #include <Foundation/Foundation.h>");
+        out.println("#elif defined(__APPLE__)");
+        out.println("    #include <TargetConditionals.h>");
         out.println("#endif");
         out.println();
         out.println("#ifdef __linux__");

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -4218,13 +4218,13 @@ public File[] parse(File outputDirectory, String[] classPath, Class cls) throws
 
         // Capture class includes
         List<String> clsIncludes = new ArrayList<String>();
-        clsIncludes.addAll(clsProperties.get("platform.include"));
         clsIncludes.addAll(clsProperties.get("platform.cinclude"));
+        clsIncludes.addAll(clsProperties.get("platform.include"));
 
         // Capture all includes
         List<String> allIncludes = new ArrayList<String>();
-        allIncludes.addAll(allProperties.get("platform.include"));
         allIncludes.addAll(allProperties.get("platform.cinclude"));
+        allIncludes.addAll(allProperties.get("platform.include"));
         List<String> allTargets = allProperties.get("target");
         List<String> allGlobals = allProperties.get("global");
         List<String> clsTargets = clsProperties.get("target");

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -92,7 +92,6 @@
 import org.bytedeco.javacpp.annotation.ValueGetter;
 import org.bytedeco.javacpp.annotation.ValueSetter;
 import org.bytedeco.javacpp.annotation.Virtual;
-import sun.misc.Unsafe;
 
 /**
  * The Generator is where all the C++ source code that we need gets generated.
@@ -1995,7 +1994,6 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         reflectClasses.add(Object.class);
         reflectClasses.add(Buffer.class);
         reflectClasses.add(String.class);
-        reflectClasses.add(Unsafe.class);
 
         for (Class cls : new LinkedHashSet<Class>(allClasses)) {
             while ((cls = cls.getEnclosingClass()) != null) {
@@ -2009,7 +2007,6 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             allClasses.add(IntEnum.class);
             allClasses.add(LongEnum.class);
         }
-        allClasses.add(Unsafe.class);
 
         for (PrintWriter o : new PrintWriter[] {jniConfigOut, reflectConfigOut}) {
             if (o == null) {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2415,6 +2415,8 @@ String returnBefore(MethodInformation methodInfo) {
                 returnPrefix = typeName[0] + " rval" + typeName[1] + " = " + cast;
                 if ((returnBy instanceof ByPtr) || (returnBy instanceof ByPtrRef)) {
                     returnPrefix += "*";
+                } else if ((returnBy instanceof ByVal || returnBy instanceof ByRef) && cast.endsWith("*)")) {
+                    returnPrefix += "&";
                 }
             } else if (Enum.class.isAssignableFrom(methodInfo.returnType)) {
                 accessesEnums = true;

File: src/main/java/org/bytedeco/javacpp/annotation/Optional.java
Patch:
@@ -10,8 +10,8 @@
 
 /**
  * A shorthand for {@code @Adapter("OptionalAdapter<type>")}.
- * We also need to define the {@code OPTIONAL_NAMESPACE} macro
- * to something like {@code boost} or {@code std}.
+ * We can also define the {@code OPTIONAL_NAMESPACE} macro
+ * to something like {@code boost} instead of the default {@code std}.
  *
  * @see Adapter
  * @see Generator

File: src/main/java/org/bytedeco/javacpp/annotation/SharedPtr.java
Patch:
@@ -10,8 +10,8 @@
 
 /**
  * A shorthand for {@code @Adapter("SharedPtrAdapter<type>")}.
- * We also need to define the {@code SHARED_PTR_NAMESPACE} macro
- * to something like {@code boost} or {@code std}.
+ * We can also define the {@code SHARED_PTR_NAMESPACE} macro
+ * to something like {@code boost} instead of the default {@code std}.
  *
  * @see Adapter
  * @see Generator

File: src/main/java/org/bytedeco/javacpp/annotation/UniquePtr.java
Patch:
@@ -10,8 +10,8 @@
 
 /**
  * A shorthand for {@code @Adapter("UniquePtrAdapter<type>")}.
- * We also need to define the {@code UNIQUE_PTR_NAMESPACE} macro
- * to something like {@code boost::movelib} or {@code std}.
+ * We can also define the {@code UNIQUE_PTR_NAMESPACE} macro
+ * to something like {@code boost::movelib} instead of the default {@code std}.
  *
  * @see Adapter
  * @see Generator

File: src/test/java/org/bytedeco/javacpp/AdapterTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Samuel Audet
+ * Copyright (C) 2015-2022 Samuel Audet
  *
  * Licensed either under the Apache License, Version 2.0, or (at your option)
  * under the terms of the GNU General Public License as published by
@@ -49,7 +49,7 @@
  *
  * @author Samuel Audet
  */
-@Platform(compiler = "cpp17", define = {"OPTIONAL_NAMESPACE std", "SHARED_PTR_NAMESPACE std", "UNIQUE_PTR_NAMESPACE std"}, include = "AdapterTest.h")
+@Platform(compiler = "cpp17", include = "AdapterTest.h")
 public class AdapterTest {
 
     static native @StdString String testStdString(@StdString String str);

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2695,6 +2695,8 @@ void call(MethodInformation methodInfo, String returnPrefix, boolean secondCall)
             } else if (methodInfo.parameterTypes[j].isPrimitive()) {
                 if (passBy instanceof ByPtr || passBy instanceof ByPtrRef) {
                     out.print("&");
+                } else if ((passBy instanceof ByVal || passBy instanceof ByRef) && cast.endsWith("*)")) {
+                    out.print("*");
                 }
                 out.print(cast + "arg" + j);
             } else if (adapterInfo != null) {

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1917,7 +1917,7 @@ Attribute attribute(boolean explicit) throws ParserException {
         }
         Attribute attr = new Attribute();
         Info info = infoMap.getFirst(attr.cppName = tokens.get().value);
-        boolean keyword = attr.cppName.equals("__attribute__");
+        boolean keyword = attr.cppName.equals("__attribute__") || attr.cppName.equals("alignas");
         if (attr.annotation = info != null && info.annotations != null
                 && info.javaNames == null && info.valueTypes == null && info.pointerTypes == null) {
             for (String s : info.annotations) {

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -46,7 +46,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
                                                    "std::priority_queue", "std::unordered_map", "std::unordered_set", "std::optional", "std::variant",
                                                    "std::function"))
         .put(new Info("basic/types").cppTypes("signed", "unsigned", "char", "short", "int", "long", "bool", "float", "double",
-                                              "_Bool", "_Complex", "_Imaginary", "complex", "imaginary"))
+                                              "__int8", "__int16", "__int32", "__int64", "_Bool", "_Complex", "_Imaginary", "complex", "imaginary"))
         .put(new Info("noexcept").annotations("@NoException(true)"))
 
         .put(new Info("__COUNTER__").cppText("#define __COUNTER__ 0"))

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -885,8 +885,8 @@ public Builder property(String keyValue) {
         if (equalIndex < 0) {
             equalIndex = keyValue.indexOf(':');
         }
-        property(keyValue.substring(2, equalIndex),
-                 keyValue.substring(equalIndex+1));
+        property(keyValue.substring(0, equalIndex),
+                 keyValue.substring(equalIndex + 1));
         return this;
     }
     /** Sets a key/value pair property of the {@link #properties} field. */
@@ -1395,7 +1395,7 @@ public static void main(String[] args) throws Exception {
             } else if ("-propertyfile".equals(args[i])) {
                 builder.propertyFile(args[++i]);
             } else if (args[i].startsWith("-D")) {
-                builder.property(args[i]);
+                builder.property(args[i].length() > 2 ? args[i].substring(2) : args[++i]);
             } else if ("-Xcompiler".equals(args[i])) {
                 builder.compilerOptions(args[++i]);
             } else if ("-clear".equals(args[i])) {

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -572,8 +572,8 @@ public static long maxPhysicalBytes() {
     /** Makes sure to return freed memory to the system, as required by Linux, at least. */
     @Name("JavaCPP_trimMemory") private static native boolean trimMemory();
 
-    /** Returns the amount of physical memory currently used by the whole process, or 0 if unknown.
-     * Also known as "resident set size" (Linux, Mac OS X, etc) or "working set size" (Windows). */
+    /** Returns the amount of non-shared physical memory currently used by the whole process, or 0 if unknown.
+     * Also known as "anonymous resident set size" (Linux, Mac OS X, etc) or "private working set size" (Windows). */
     @Name("JavaCPP_physicalBytes") public static native long physicalBytes();
 
     /** Returns the amount of physical memory installed according to the operating system, or 0 if unknown.

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -4371,6 +4371,7 @@ public File[] parse(File outputDirectory, String[] classPath, Class cls) throws
                                     "@Properties(inherit = " + cls.getCanonicalName() + ".class)\n"
                                   + "public class " + shortName + " ") + "\n";
                     outputFiles.add(javaFile);
+                    javaText = javaText.replace("\n", lineSeparator).replace("\\u", "\\u005Cu");
                     Files.write(javaFile.toPath(), encoding != null ? javaText.getBytes(encoding) : javaText.getBytes());
                     prevd = null;
                 } else {

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -291,7 +291,9 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                             n++;
                         } else for (String javaName : type.javaNames != null ? type.javaNames : new String[] {type.javaName}) {
                             // variant, optional, etc
-                            decl.text += "    public " + containerType.javaName + "(" + javaName + " value) { this(); put(value); }\n";
+                            if (!javaName.substring(javaName.indexOf(' ') + 1).equals("Pointer")) {
+                                decl.text += "    public " + containerType.javaName + "(" + javaName + " value) { this(); put(value); }\n";
+                            }
                         }
                     }
                     if (tuple) {

File: src/main/java/org/bytedeco/javacpp/tools/BuildMojo.java
Patch:
@@ -405,7 +405,7 @@ static String[] merge(String[] ss, String s) {
             }
             properties.setProperty("platform.artifacts", project.getBuild().getOutputDirectory());
             for (Artifact a : plugin.getArtifacts()) {
-                String s = a.getFile().getCanonicalPath();
+                String s = Loader.getCanonicalPath(a.getFile());
                 String v = properties.getProperty("platform.artifacts", "");
                 properties.setProperty("platform.artifacts",
                         v.length() == 0 || v.endsWith(separator) ? v + s : v + separator + s);

File: src/main/java/org/bytedeco/javacpp/tools/CacheMojo.java
Patch:
@@ -127,7 +127,7 @@ String join(String separator, Iterable<String> strings) {
                     logger.info("Caching " + c);
                     File f = (File)cachePackage.invoke(c);
                     if (f != null) {
-                        packages.add(f.getCanonicalPath());
+                        packages.add(Loader.getCanonicalPath(f));
                     }
                 } catch (NoSuchMethodException e) {
                     // assume this class has no associated packages, skip

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -4106,7 +4106,7 @@ void parse(Context context,
         }
         if (file == null && includePath != null) {
             for (String path : includePath) {
-                File f = new File(path, filename).getCanonicalFile();
+                File f = Loader.getCanonicalFile(new File(path, filename));
                 if (f.exists()) {
                     file = f;
                     break;
@@ -4269,7 +4269,7 @@ public File[] parse(File outputDirectory, String[] classPath, Class cls) throws
         List<String> paths = allProperties.get("platform.includepath");
         for (String s : allProperties.get("platform.includeresource")) {
             for (File f : Loader.cacheResources(s)) {
-                paths.add(f.getCanonicalPath());
+                paths.add(Loader.getCanonicalPath(f));
             }
         }
 

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1991,9 +1991,9 @@ Parameters parameters(Context context, int infoNumber, boolean useDefaults) thro
                 for (token = tokens.next(), token.spacing = ""; !token.match(Token.EOF); token = tokens.next()) {
                     if (count2 == 0 && token.match(',', ')', '}')) {
                         break;
-                    } else if (token.match('<', '(', '{')) {
+                    } else if (token.match('(', '{') || (count2 == 0 && token.match('<'))) {
                         count2++;
-                    } else if (token.match('>', ')', '}')) {
+                    } else if (token.match(')', '}') || (count2 == 1 && token.match('>'))) {
                         count2--;
                     }
 

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -166,6 +166,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("close").javaNames("_close"))
         .put(new Info("deallocate").javaNames("_deallocate"))
         .put(new Info("free").javaNames("_free"))
+        .put(new Info("hashCode").javaNames("_hashCode"))
         .put(new Info("address").javaNames("_address"))
         .put(new Info("position").javaNames("_position"))
         .put(new Info("limit").javaNames("_limit"))

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3563,7 +3563,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
         if (/*(context.templateMap == null || context.templateMap.full()) &&*/ constructorInfo == null) {
             infoMap.put(constructorInfo = new Info(type.cppName + "::" + constructorName));
         }
-        if (constructorInfo.javaText == null) {
+        if (constructorInfo.javaText == null && inheritedConstructors.length() > 0) {
             // save constructors to be able inherit them with C++11 "using" statements
             constructorInfo.javaText(inheritedConstructors);
         }
@@ -3808,7 +3808,7 @@ boolean enumeration(Context context, DeclarationList declList) throws ParserExce
                 // XXX: If !typedef, this is a variable declaration with anonymous type
                 String name1 = name;
                 String name2 = token.value;
-                if (typedef || name == null || name.length() == 0) {
+                if ((typedef && indirections == 0) || name == null || name.length() == 0) {
                     name = name2;
                     if (name1 != null && name1.length() > 0) {
                         name2 = name1;

File: src/main/java/org/bytedeco/javacpp/BooleanPointer.java
Patch:
@@ -115,7 +115,7 @@ public BooleanPointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return 1;
+        return getClass() == BooleanPointer.class ? 1 : super.sizeof();
     }
     @Override public BooleanPointer getPointer(long i) {
         return new BooleanPointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/BytePointer.java
Patch:
@@ -155,7 +155,7 @@ public BytePointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return 1;
+        return getClass() == BytePointer.class ? 1 : super.sizeof();
     }
     @Override public BytePointer getPointer(long i) {
         return new BytePointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -121,7 +121,7 @@ public CharPointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return Character.SIZE / Byte.SIZE;
+        return getClass() == CharPointer.class ? Character.SIZE / Byte.SIZE : super.sizeof();
     }
     @Override public CharPointer getPointer(long i) {
         return new CharPointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -111,7 +111,7 @@ public DoublePointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return Double.SIZE / Byte.SIZE;
+        return getClass() == DoublePointer.class ? Double.SIZE / Byte.SIZE : super.sizeof();
     }
     @Override public DoublePointer getPointer(long i) {
         return new DoublePointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -111,7 +111,7 @@ public FloatPointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return Float.SIZE / Byte.SIZE;
+        return getClass() == FloatPointer.class ? Float.SIZE / Byte.SIZE : super.sizeof();
     }
     @Override public FloatPointer getPointer(long i) {
         return new FloatPointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -121,7 +121,7 @@ public IntPointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return Integer.SIZE / Byte.SIZE;
+        return getClass() == IntPointer.class ? Integer.SIZE / Byte.SIZE : super.sizeof();
     }
     @Override public IntPointer getPointer(long i) {
         return new IntPointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -1701,6 +1701,9 @@ public static synchronized String loadLibrary(Class<?> cls, URL[] urls, String l
                 return filename;
             } else if (!libnameversion.trim().endsWith("#")) {
                 // ... or as last resort, try to load it via the system.
+                if (loadError == null) {
+                    loadError = new UnsatisfiedLinkError("Could not find " + libnameversion + " in class, module, and library paths.");
+                }
                 String libname = libnameversion.split("#")[0].split("@")[0];
                 if (libname.endsWith("!")) {
                     libname = libname.substring(0, libname.length() - 1);

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -111,7 +111,7 @@ public LongPointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return Long.SIZE / Byte.SIZE;
+        return getClass() == LongPointer.class ? Long.SIZE / Byte.SIZE : super.sizeof();
     }
     @Override public LongPointer getPointer(long i) {
         return new LongPointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -111,7 +111,7 @@ public ShortPointer() { }
         return super.capacity(capacity);
     }
     @Override public int sizeof() {
-        return Short.SIZE / Byte.SIZE;
+        return getClass() == ShortPointer.class ? Short.SIZE / Byte.SIZE : super.sizeof();
     }
     @Override public ShortPointer getPointer(long i) {
         return new ShortPointer(this).offsetAddress(i);

File: src/main/java/org/bytedeco/javacpp/tools/Info.java
Patch:
@@ -108,7 +108,7 @@ public Info(Info i) {
     /** Skips entirely all the code associated with the C++ identifiers, expressions, or header filenames.
      * Unless more {@link Info} is provided... */
     boolean skip = false;
-    /** Ignores default function arguments to avoid ambiguous C++ function calls. */
+    /** Ignores default type constructors and default function arguments to avoid ambiguous C++ function calls. */
     boolean skipDefaults = false;
     /** Forces a class to be treated as if it were abstract. */
     boolean purify = false;

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3512,7 +3512,9 @@ boolean group(Context context, DeclarationList declList) throws ParserException
                                  "    }\n";
                 }
             }
-            decl.text += constructors;
+            if (info == null || !info.skipDefaults) {
+                decl.text += constructors;
+            }
             declList.spacing = spacing;
             decl.text = declList.rescan(decl.text + casts + "\n");
             declList.spacing = null;

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -1313,6 +1313,7 @@ public static String load(Class cls, Properties properties, boolean pathsFirst,
                             if (f != null) {
                                 f.setExecutable(true);
                                 executablePaths.put(e, f.getAbsolutePath());
+                                break;
                             }
                         }
                     }

File: src/main/java/org/bytedeco/javacpp/annotation/Cast.java
Patch:
@@ -11,7 +11,8 @@
  * Indicates a type cast required on the argument to satisfy the native compiler.
  * When used with {@link Adapter} a second cast can also be specified making it
  * possible to apply a cast to both the argument and the adapter, in this order.
- * A third "precast" can also be specified, which gets applied before the second one.
+ * A third "precast" can also be specified, which gets applied before the second one,
+   but also on return values passed to adapters.
  * <p>
  * At the moment, {@link Generator} makes use of the simple C-style cast. If one
  * requires a different kind of type conversion, such as the {@code dynamic_cast}

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3826,7 +3826,7 @@ boolean enumeration(Context context, DeclarationList declList) throws ParserExce
         Info info = infoMap.getFirst(cppName);
         Info info2 = infoMap.getFirst(null);
         boolean enumerate = info != null ? info.enumerate : info2 != null ? info2.enumerate : false;
-        if ((info != null && info.skip) || (enumerators.length() == 0 && enumerators2.length() == 0)) {
+        if (info != null && info.skip) {
             decl.text = enumSpacing;
         } else {
             if (info != null && info.cppTypes != null && info.cppTypes.length > 0) {
@@ -3838,7 +3838,8 @@ boolean enumeration(Context context, DeclarationList declList) throws ParserExce
             int newline = enumSpacing.lastIndexOf('\n');
             String enumSpacing2 = newline < 0 ? enumSpacing : enumSpacing.substring(newline + 1);
             String javaName = info != null && info.valueTypes != null && info.valueTypes.length > 0 ? info.valueTypes[0] : name;
-            if (enumerate && javaName != null && javaName.length() > 0 && !javaName.equals(javaType)) {
+            if (enumerate && javaName != null && javaName.length() > 0 && !javaName.equals(javaType)
+                    && enumerators.length() > 0 && enumerators2.length() > 0) {
                 String shortName = javaName.substring(javaName.lastIndexOf('.') + 1);
                 String fullName = context.namespace != null ? context.namespace + "::" + shortName : shortName;
                 String annotations = "";

File: src/main/java/org/bytedeco/javacpp/annotation/Cast.java
Patch:
@@ -11,6 +11,7 @@
  * Indicates a type cast required on the argument to satisfy the native compiler.
  * When used with {@link Adapter} a second cast can also be specified making it
  * possible to apply a cast to both the argument and the adapter, in this order.
+ * A third "precast" can also be specified, which gets applied before the second one.
  * <p>
  * At the moment, {@link Generator} makes use of the simple C-style cast. If one
  * requires a different kind of type conversion, such as the {@code dynamic_cast}
@@ -25,4 +26,4 @@
 @Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
 public @interface Cast {
     String[] value();
-}
\ No newline at end of file
+}

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -358,8 +358,10 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                                 decl.text += "\n"
                                           +  "    @Name(\"value\") public native " + type.annotations + type.javaName + " get();\n";
                             } else {
+                                int namespace = containerName.lastIndexOf("::");
+                                String ns = containerName.substring(0, namespace);
                                 decl.text += "    public " + type.annotations + type.javaName + " get" + n + "() { return get" + n + "(this); }\n"
-                                          +  "    @Namespace @Name(\"std::get<" + n + ">\") public static native " + type.annotations + type.javaName + " get" + n + "(@ByRef " + containerType.javaName + " container);\n";
+                                          +  "    @Namespace @Name(\"" + ns + "::get<" + n + ">\") public static native " + type.annotations + type.javaName + " get" + n + "(@ByRef " + containerType.javaName + " container);\n";
                             }
                             if (!constant && !tuple) {
                                 decl.text += "    @ValueSetter public native " + containerType.javaName + " put(" + type.annotations + type.javaName + " value);\n";

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3723,7 +3723,7 @@ static Allocator allocator(Class<?> cls, Method method) {
             }
             org.bytedeco.javacpp.annotation.Properties classProperties =
                     cls.getAnnotation(org.bytedeco.javacpp.annotation.Properties.class);
-            if (classProperties != null) {
+            if (Pointer.class.isAssignableFrom(cls) && classProperties != null) {
                 for (Class c : classProperties.inherit()) {
                     if ((a = allocator(c, method)) != null) {
                         break;
@@ -3748,7 +3748,7 @@ static boolean criticalRegion(Class<?> cls, Method method) {
             }
             org.bytedeco.javacpp.annotation.Properties classProperties =
                     cls.getAnnotation(org.bytedeco.javacpp.annotation.Properties.class);
-            if (classProperties != null) {
+            if (Pointer.class.isAssignableFrom(cls) && classProperties != null) {
                 for (Class c : classProperties.inherit()) {
                     if (criticalRegion = criticalRegion(c, method)) {
                         break;
@@ -3773,7 +3773,7 @@ static boolean noException(Class<?> cls, Method method) {
             }
             org.bytedeco.javacpp.annotation.Properties classProperties =
                     cls.getAnnotation(org.bytedeco.javacpp.annotation.Properties.class);
-            if (classProperties != null) {
+            if (Pointer.class.isAssignableFrom(cls) && classProperties != null) {
                 for (Class c : classProperties.inherit()) {
                     if (noException = noException(c, method)) {
                         break;

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1311,9 +1311,9 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("            uniquePtr2(owner != NULL && owner != ptr ? U() : U((T*)ptr)),");
             out.println("            uniquePtr(owner != NULL && owner != ptr ? *(U*)owner : uniquePtr2) { }");
             out.println("    UniquePtrAdapter(U&& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr2(UNIQUE_PTR_NAMESPACE::move(uniquePtr)), uniquePtr(uniquePtr2) { }");
-            out.println("    UniquePtrAdapter(const U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr((U&)uniquePtr) { }");
-            out.println("    UniquePtrAdapter(      U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr(uniquePtr) { }");
-            out.println("    UniquePtrAdapter(const U* uniquePtr) : ptr(0), size(0), owner(0), uniquePtr(*(U*)uniquePtr) { }");
+            out.println("    UniquePtrAdapter(const U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr2(U(NULL, D())), uniquePtr((U&)uniquePtr) { }");
+            out.println("    UniquePtrAdapter(      U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr2(U(NULL, D())), uniquePtr(uniquePtr) { }");
+            out.println("    UniquePtrAdapter(const U* uniquePtr) : ptr(0), size(0), owner(0), uniquePtr2(U(NULL, D())), uniquePtr(*(U*)uniquePtr) { }");
             out.println("    void assign(T* ptr, size_t size, void* owner) {");
             out.println("        this->ptr = ptr;");
             out.println("        this->size = size;");

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3846,6 +3846,7 @@ void declarations(Context context, DeclarationList declList) throws ParserExcept
                     }
                     int count = 0;
                     for (Map.Entry<String,Type> e : map.entrySet()) {
+                        e.setValue(null);
                         if (count < type.arguments.length) {
                             Type t = type.arguments[count++];
                             String s = t.cppName;

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -283,7 +283,7 @@ static class DeallocatorReference extends PhantomReference<Pointer> implements D
         DeallocatorReference(Pointer p, Deallocator deallocator) {
             super(p, referenceQueue);
             this.deallocator = deallocator;
-            this.bytes = p.capacity * p.sizeof();
+            this.bytes = p.capacity != 0 && referenceQueue != null ? p.capacity * p.sizeof() : 0;
             this.count = new AtomicInteger(0);
         }
 

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -410,8 +410,8 @@ static class DeallocatorThread extends Thread {
     static final long maxBytes;
 
     /** Maximum amount of memory reported by {@link #physicalBytes()} before forcing call to {@link System#gc()}.
-     * Set via "org.bytedeco.javacpp.maxPhysicalBytes" system property, defaults to {@code maxBytes > 0 ? maxBytes + Runtime.maxMemory() : 0}.
-     * If {@link #maxBytes} is also not set, this is equivalent to a default of {@code 2 * Runtime.maxMemory()}.
+     * Set via "org.bytedeco.javacpp.maxPhysicalBytes" system property, defaults to {@code maxBytes > 0 ? maxBytes + 3 * Runtime.maxMemory() : 0}.
+     * If {@link #maxBytes} is also not set, this is equivalent to a default of {@code 4 * Runtime.maxMemory()}.
      * The value is parsed with {@link #parseBytes(String, long)} where {@code relativeMultiple = Runtime.maxMemory()}.
      * We can use a value of 0 or less to prevent any explicit call to the garbage collector. */
     static final long maxPhysicalBytes;
@@ -489,7 +489,7 @@ public static long parseBytes(String string, long relativeMultiple) throws Numbe
         }
         maxBytes = m;
 
-        m = maxBytes > 0 ? maxBytes + maxMemory : 0;
+        m = maxBytes > 0 ? maxBytes + 3 * maxMemory : 0;
         s = System.getProperty("org.bytedeco.javacpp.maxphysicalbytes");
         s = System.getProperty("org.bytedeco.javacpp.maxPhysicalBytes", s);
         if (s != null && s.length() > 0) {

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -360,7 +360,7 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                                 decl.text += "    public native void insert(" + valueType.annotations + valueType.javaName + " value);\n"
                                           +  "    public native void erase(" + valueType.annotations + valueType.javaName + " value);\n";
                             } else if (!dict) {
-                                 // XXX: need to figure out something for insert() on maps
+                                // XXX: need to figure out something for insert() on maps
                                 decl.text += "    public native void erase(@ByVal Iterator pos);\n";
                             }
                         }
@@ -3121,7 +3121,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
                 for (int n = 0; n < Integer.MAX_VALUE; n++) {
                     tokens.index = index;
                     Declarator dcl = declarator(context, null, -1, false, n, false, true);
-                    if (dcl == null) {
+                    if (dcl == null || dcl.cppName == null) {
                         break;
                     } else {
                         // declares variable, treat as anonymous

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -273,7 +273,7 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                 } else if (indexType == null && dim == 0 && !constant) {
                     for (Type type : containerType.arguments) {
                         for (String javaName : type.javaNames != null ? type.javaNames : new String[] {type.javaName}) {
-                            decl.text += "    public " + containerType.javaName + "(" + javaName + " value) { put(value); }\n";
+                            decl.text += "    public " + containerType.javaName + "(" + javaName + " value) { this(); put(value); }\n";
                         }
                     }
                 }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -969,6 +969,8 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
                 count++;
             } else if (token.match(')',']','}')) {
                 count--;
+            } else if (token.match("]]")) {
+                count-=2;
             } else if (count > 0) {
                 continue;
             } else if (token.match(',')) {

File: src/main/java/org/bytedeco/javacpp/tools/TokenIndexer.java
Patch:
@@ -201,6 +201,8 @@ Token[] expand(Token[] array, int index) {
                                 count2++;
                             } else if (token2.match(')',']','}')) {
                                 count2--;
+                            } else if (token2.match("]]")) {
+                                count2-=2;
                             }
                             if (count < args.length) {
                                 if (args[count] == null) {

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1111,7 +1111,7 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
                     try {
                         dims[dcl.indices++] = n.match(Token.INTEGER) ? Integer.decode(n.value) : -1;
                     } catch (NumberFormatException e) {
-                        dims[dcl.indices++] = -1;
+                        dims[dcl.indices] = -1;
                     }
                 } else if (token.match('(', ')')) {
                     break;
@@ -1191,7 +1191,7 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
                 try {
                     dims[dcl.indices++] = n.match(Token.INTEGER) ? Integer.decode(n.value) : -1;
                 } catch (NumberFormatException e) {
-                    dims[dcl.indices++] = -1;
+                    dims[dcl.indices] = -1;
                 }
             } else if (!bracket) {
                 break;

File: src/main/java/org/bytedeco/javacpp/BoolPointer.java
Patch:
@@ -43,7 +43,9 @@ public class BoolPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load BoolPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load BoolPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/BooleanPointer.java
Patch:
@@ -41,7 +41,9 @@ public class BooleanPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load BooleanPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load BooleanPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/BytePointer.java
Patch:
@@ -46,7 +46,9 @@ public class BytePointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load BytePointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load BytePointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/CLongPointer.java
Patch:
@@ -44,7 +44,9 @@ public class CLongPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load CLongPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load CLongPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -39,7 +39,9 @@ public class CharPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load CharPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load CharPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -39,7 +39,9 @@ public class DoublePointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load DoublePointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load DoublePointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -39,7 +39,9 @@ public class FloatPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load FloatPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load FloatPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -39,7 +39,9 @@ public class IntPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load IntPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load IntPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -1874,7 +1874,9 @@ public static String createLibraryLink(String filename, ClassProperties properti
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load Loader: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load Loader: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -39,7 +39,9 @@ public class LongPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load LongPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load LongPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -508,7 +508,9 @@ public static long parseBytes(String string, long relativeMultiple) throws Numbe
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load Pointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load Pointer: " + t);
+            }
         }
 
         String mx = System.getProperty("org.bytedeco.javacpp.mxbean", "false").toLowerCase();

File: src/main/java/org/bytedeco/javacpp/PointerPointer.java
Patch:
@@ -43,7 +43,9 @@ public class PointerPointer<P extends Pointer> extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load PointerPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load PointerPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -39,7 +39,9 @@ public class ShortPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load ShortPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load ShortPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/SizeTPointer.java
Patch:
@@ -43,7 +43,9 @@ public class SizeTPointer extends Pointer {
         try {
             Loader.load();
         } catch (Throwable t) {
-            logger.warn("Could not load SizeTPointer: " + t);
+            if (logger.isDebugEnabled()) {
+                logger.debug("Could not load SizeTPointer: " + t);
+            }
         }
     }
 

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3130,7 +3130,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
             declList.add(decl);
             return true;
         } else if (info != null && info.pointerTypes != null && info.pointerTypes.length > 0) {
-            type.javaName = context.constName != null ? context.constName : info.pointerTypes[0];
+            type.javaName = context.constName != null ? context.constName : info.pointerTypes[0].substring(info.pointerTypes[0].lastIndexOf(" ") + 1);
             name = context.shorten(type.javaName);
         } else if (info == null && !friend) {
             if (type.javaName.length() > 0 && context.javaName != null) {

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -67,7 +67,7 @@ public ClassProperties(Properties properties) {
                 || k.equals("platform.resourcepath") || k.equals("platform.resource")
                 || k.equals("platform.frameworkpath") || k.equals("platform.framework")
                 || k.equals("platform.executablepath") || k.equals("platform.executable")
-                || k.equals("platform.library.suffix") || k.equals("platform.extension")) {
+                || k.equals("platform.compiler.*") || k.equals("platform.library.suffix") || k.equals("platform.extension")) {
                 addAll(k, v.split(pathSeparator));
             } else {
                 setProperty(k, v);

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3554,9 +3554,9 @@ MethodInformation methodInformation(Method method) {
             boolean canBeValueSetter = false;
             boolean canBeMemberGetter = false;
             boolean canBeMemberSetter = false;
-            if (canBeGetter && "get".equals(info.name) && "put".equals(info2.name)) {
+            if (canBeGetter && "get".equals(info.name) && "put".equals(info2.name) && name == null) {
                 canBeValueGetter = true;
-            } else if (canBeSetter && "put".equals(info.name) && "get".equals(info2.name)) {
+            } else if (canBeSetter && "put".equals(info.name) && "get".equals(info2.name) && name == null) {
                 canBeValueSetter = true;
             } else if (info2.name.equals(info.name)) {
                 info.overloaded = true;
@@ -4049,7 +4049,7 @@ String[] cppCastTypeName(Class<?> type, Annotation ... annotations) {
                         templateCount++;
                     } else if (c == '>') {
                         templateCount--;
-                    } else if (templateCount == 0 && c == ')') {
+                    } else if (!prefix.contains("decltype(") && templateCount == 0 && c == ')') {
                         suffix = prefix.substring(i).trim();
                         prefix = prefix.substring(0, i).trim();
                         break;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -43,7 +43,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
     static final InfoMap defaults = new InfoMap(null)
         .put(new Info("basic/containers").cppTypes("std::array", "std::bitset", "std::deque", "std::list", "std::map", "std::queue", "std::set",
                                                    "std::stack", "std::vector", "std::valarray", "std::pair", "std::forward_list",
-                                                   "std::priority_queue", "std::unordered_map", "std::unordered_set"))
+                                                   "std::priority_queue", "std::unordered_map", "std::unordered_set", "std::optional", "std::variant"))
         .put(new Info("basic/types").cppTypes("signed", "unsigned", "char", "short", "int", "long", "bool", "float", "double",
                                               "_Bool", "_Complex", "_Imaginary", "complex", "imaginary"))
         .put(new Info("noexcept").annotations("@NoException"))
@@ -53,7 +53,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("void").valueTypes("void").pointerTypes("Pointer"))
         .put(new Info("std::nullptr_t").valueTypes("Pointer").pointerTypes("PointerPointer"))
         .put(new Info("FILE", "time_t", "va_list", "std::exception", "std::istream", "std::ostream", "std::iostream",
-                "std::ifstream", "std::ofstream", "std::fstream").cast().pointerTypes("Pointer"))
+                "std::ifstream", "std::ofstream", "std::fstream", "std::stringstream").cast().pointerTypes("Pointer"))
 
         .put(new Info("int8_t", "__int8", "jbyte", "signed char")
             .valueTypes("byte").pointerTypes("BytePointer", "ByteBuffer", "byte[]"))

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -671,7 +671,7 @@ protected <P extends Pointer> P deallocator(Deallocator deallocator) {
             synchronized (DeallocatorThread.class) {
                 try {
                     while (count++ < maxRetries && ((maxBytes > 0 && DeallocatorReference.totalBytes + r.bytes > maxBytes)
-                                         || (maxPhysicalBytes > 0 && lastPhysicalBytes > maxPhysicalBytes))) {
+                                         || (maxPhysicalBytes > 0 && lastPhysicalBytes > maxPhysicalBytes)) && referenceQueue != null) {
                         if (logger.isDebugEnabled()) {
                             logger.debug("Calling System.gc() and Pointer.trimMemory() in " + this);
                         }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3258,7 +3258,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
                              "        return (" + shortName + ")super.position(position);\n" +
                              "    }\n" +
                              "    @Override public " + shortName + " getPointer(long i) {\n" +
-                             "        return new " + shortName + "(this).position(position + i);\n" +
+                             "        return new " + shortName + "((Pointer)this).position(position + i);\n" +
                              "    }\n";
             } else {
                 if ((info == null || !info.purify) && (!abstractClass || ctx.virtualize)) {
@@ -3277,7 +3277,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
                                  "        return (" + shortName + ")super.position(position);\n" +
                                  "    }\n" +
                                  "    @Override public " + shortName + " getPointer(long i) {\n" +
-                                 "        return new " + shortName + "(this).position(position + i);\n" +
+                                 "        return new " + shortName + "((Pointer)this).position(position + i);\n" +
                                  "    }\n";
                 }
             }

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -94,7 +94,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("char16_t").cast().valueTypes("char").pointerTypes("CharPointer", "char[]"))
         .put(new Info("char32_t").cast().valueTypes("int").pointerTypes("IntPointer", "int[]"))
         .put(new Info("wchar_t", "WCHAR").cast().valueTypes("char", "int").pointerTypes("CharPointer", "IntPointer"))
-        .put(new Info("const char").valueTypes("byte").pointerTypes("@Cast(\"const char*\") BytePointer", "String"))
+        .put(new Info("const char").valueTypes("@Cast(\"const char\") byte").pointerTypes("@Cast(\"const char*\") BytePointer", "String"))
         .put(new Info("boost::shared_ptr", "std::shared_ptr").annotations("@SharedPtr"))
         .put(new Info("boost::movelib::unique_ptr", "std::unique_ptr").annotations("@UniquePtr"))
         .put(new Info("std::string").annotations("@StdString").valueTypes("BytePointer", "String").pointerTypes("BytePointer"))

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1212,7 +1212,7 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
         int infoLength = 1;
         boolean valueType = false, needCast = arrayAsPointer && dcl.indices > 1, implicitConst = false;
         Info constInfo = infoMap.getFirst("const " + type.cppName, false);
-        Info info = type.constValue && dcl.indirections < 2 && !dcl.reference ? constInfo
+        Info info = type.constValue && (dcl.indirections == 0 || (dcl.indirections < 2 && !dcl.reference)) ? constInfo
                   : infoMap.getFirst(type.cppName, false);
         if ((!typedef || dcl.parameters != null)
                 && (constInfo == null || (constInfo.cppTypes != null && constInfo.cppTypes.length > 0))

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -918,7 +918,7 @@ public Builder addProperty(String key, String... values) {
             String separator = properties.getProperty("platform.path.separator");
             String v = properties.getProperty(key, "");
             for (String s : values) {
-                v += v.length() == 0 || v.endsWith(separator) ? v + s : v + separator + s;
+                v += v.length() == 0 || v.endsWith(separator) ? s : separator + s;
             }
             properties.setProperty(key, v);
         }

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -63,6 +63,7 @@ class Token implements Comparable<Token> {
             ELIF      = new Token(IDENTIFIER, "elif"),
             ELSE      = new Token(IDENTIFIER, "else"),
             ENDIF     = new Token(IDENTIFIER, "endif"),
+            UNDEF     = new Token(IDENTIFIER, "undef"),
             ENUM      = new Token(IDENTIFIER, "enum"),
             EXPLICIT  = new Token(IDENTIFIER, "explicit"),
             EXTERN    = new Token(IDENTIFIER, "extern"),

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -2223,6 +2223,9 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
                 if (token.match(Token.CONST, Token.__CONST, Token.CONSTEXPR)) {
                     decl.constMember = true;
                     token = tokens.next();
+                } else if (token.match(Token.OVERRIDE)) {
+                    type.virtual = true;
+                    token = tokens.next();
                 }
                 if (token.match('&', "&&")) {
                     // ignore?

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -84,6 +84,7 @@ class Token implements Comparable<Token> {
             NEW       = new Token(IDENTIFIER, "new"),
             DELETE    = new Token(IDENTIFIER, "delete"),
             OPERATOR  = new Token(IDENTIFIER, "operator"),
+            OVERRIDE  = new Token(IDENTIFIER, "override"),
             PRIVATE   = new Token(IDENTIFIER, "private"),
             PROTECTED = new Token(IDENTIFIER, "protected"),
             PUBLIC    = new Token(IDENTIFIER, "public"),

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -847,12 +847,12 @@ public Buffer asBuffer() {
     public static native Pointer memset(Pointer dst, int ch, long size);
 
     /** Returns {@code getPointer(0)}. */
-    public Pointer getPointer() {
+    public <P extends Pointer> P getPointer() {
         return getPointer(0);
     }
 
     /** Returns {@code new Pointer(this).position((position + i) * sizeof()).capacity(capacity * sizeof()).limit(limit * sizeof())}. */
-    public Pointer getPointer(long i) {
+    public <P extends Pointer> P getPointer(long i) {
         long s = sizeof();
         return new Pointer(this).position((position + i) * s).capacity(capacity * s).limit(limit *s);
     }

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -198,9 +198,9 @@ void includeJavaPaths(ClassProperties properties, boolean header) {
                 // We only need libjvm for callbacks exported with the header file
                 properties.get("platform.link").add(0, "jvm");
                 properties.addAll("platform.linkpath", jvmpath);
-            }
-            if (platform.startsWith("macosx")) {
-                properties.addAll("platform.framework", "JavaVM");
+                if (platform.startsWith("macosx")) {
+                    properties.addAll("platform.framework", "JavaVM");
+                }
             }
         }
     }

File: src/main/java/org/bytedeco/javacpp/BoolPointer.java
Patch:
@@ -85,6 +85,9 @@ public BoolPointer() { }
     @Override public BoolPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public BoolPointer getPointer(long i) {
+        return new BoolPointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public boolean get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/BooleanPointer.java
Patch:
@@ -115,6 +115,9 @@ public BooleanPointer() { }
     @Override public int sizeof() {
         return 1;
     }
+    @Override public BooleanPointer getPointer(long i) {
+        return new BooleanPointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public boolean get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/CLongPointer.java
Patch:
@@ -96,6 +96,9 @@ public CLongPointer() { }
     @Override public CLongPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public CLongPointer getPointer(long i) {
+        return new CLongPointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public long get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -121,6 +121,9 @@ public CharPointer() { }
     @Override public int sizeof() {
         return Character.SIZE / Byte.SIZE;
     }
+    @Override public CharPointer getPointer(long i) {
+        return new CharPointer(this).position(position + i);
+    }
 
     /** Returns the chars, assuming a null-terminated string if {@code limit <= position}. */
     public char[] getStringChars() {

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -111,6 +111,9 @@ public DoublePointer() { }
     @Override public int sizeof() {
         return Double.SIZE / Byte.SIZE;
     }
+    @Override public DoublePointer getPointer(long i) {
+        return new DoublePointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public double get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -111,6 +111,9 @@ public FloatPointer() { }
     @Override public int sizeof() {
         return Float.SIZE / Byte.SIZE;
     }
+    @Override public FloatPointer getPointer(long i) {
+        return new FloatPointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public float get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -121,6 +121,9 @@ public IntPointer() { }
     @Override public int sizeof() {
         return Integer.SIZE / Byte.SIZE;
     }
+    @Override public IntPointer getPointer(long i) {
+        return new IntPointer(this).position(position + i);
+    }
 
     /** Returns the code points, assuming a null-terminated string if {@code limit <= position}. */
     public int[] getStringCodePoints() {

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -111,6 +111,9 @@ public LongPointer() { }
     @Override public int sizeof() {
         return Long.SIZE / Byte.SIZE;
     }
+    @Override public LongPointer getPointer(long i) {
+        return new LongPointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public long get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/PointerPointer.java
Patch:
@@ -172,6 +172,9 @@ public PointerPointer() { }
     @Override public PointerPointer<P> capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public PointerPointer<P> getPointer(long i) {
+        return new PointerPointer<P>(this).position(position + i);
+    }
 
     /** @return {@code get(BytePointer.class, i).getString()}
      *  @see BytePointer#getString() */

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -111,6 +111,9 @@ public ShortPointer() { }
     @Override public int sizeof() {
         return Short.SIZE / Byte.SIZE;
     }
+    @Override public ShortPointer getPointer(long i) {
+        return new ShortPointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public short get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/SizeTPointer.java
Patch:
@@ -95,6 +95,9 @@ public SizeTPointer() { }
     @Override public SizeTPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public SizeTPointer getPointer(long i) {
+        return new SizeTPointer(this).position(position + i);
+    }
 
     /** @return {@code get(0)} */
     public long get() { return get(0); }

File: src/test/java/org/bytedeco/javacpp/PointerTest.java
Patch:
@@ -190,7 +190,7 @@ static class TestFunction extends FunctionPointer {
         assertEquals(false, pointer.getBool(0));
         assertEquals(true, pointer.getBool(1));
         assertEquals(shortValue, pointer.getChar(1));
-        assertEquals(Loader.sizeof(Pointer.class) == 4 ? intValue : longValue, pointer.getPointer(1).address);
+        assertEquals(Loader.sizeof(Pointer.class) == 4 ? intValue : longValue, pointer.getPointerValue(1).address);
 
         byte[] array2 = new byte[array.length];
         pointer.position(0).get(array2);

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -665,7 +665,7 @@ Type type(Context context, boolean definition) throws ParserException {
                 type.typedef = true;
             } else if (token.match(Token.VIRTUAL)) {
                 type.virtual = true;
-            } else if (token.match(Token.AUTO, Token.ENUM, Token.EXPLICIT, Token.EXTERN, Token.INLINE, Token.CLASS, Token.FINAL,
+            } else if (token.match(Token.ENUM, Token.EXPLICIT, Token.EXTERN, Token.INLINE, Token.CLASS, Token.FINAL,
                                    Token.INTERFACE, Token.__INTERFACE, Token.MUTABLE, Token.NAMESPACE, Token.STRUCT, Token.UNION,
                                    Token.TYPENAME, Token.REGISTER, Token.THREAD_LOCAL, Token.VOLATILE)) {
                 token = tokens.next();

File: src/main/java/org/bytedeco/javacpp/indexer/DoubleRawIndexer.java
Patch:
@@ -108,7 +108,7 @@ public DoubleIndexer putRaw(long i, double d) {
         return this;
     }
     @Override public DoubleIndexer put(long i, double d) {
-        return put(index(i), d);
+        return putRaw(index(i), d);
     }
     @Override public DoubleIndexer put(long i, double[] d, int offset, int length) {
         for (int n = 0; n < length; n++) {

File: src/main/java/org/bytedeco/javacpp/presets/javacpp.java
Patch:
@@ -49,7 +49,7 @@
                        "api-ms-win-core-sysinfo-l1-1-0", "api-ms-win-core-synch-l1-2-0", "api-ms-win-core-console-l1-1-0", "api-ms-win-core-debug-l1-1-0",
                        "api-ms-win-core-rtlsupport-l1-1-0", "api-ms-win-core-processthreads-l1-1-1", "api-ms-win-core-file-l1-2-0", "api-ms-win-core-profile-l1-1-0",
                        "api-ms-win-core-memory-l1-1-0", "api-ms-win-core-util-l1-1-0", "api-ms-win-core-interlocked-l1-1-0", "ucrtbase",
-                       "vcruntime140", "msvcp140", "concrt140", "vcomp140"}
+                       "vcruntime140", "vcruntime140_1", "msvcp140", "concrt140", "vcomp140"}
         ),
         @Platform(
             value = "windows-x86",

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -718,6 +718,7 @@ public void deallocate() {
      * @param deallocate if true, deallocates, else does not, but disables garbage collection
      */
     public void deallocate(boolean deallocate) {
+        DeallocatorReference r = (DeallocatorReference)deallocator;
         if (deallocate && deallocator != null) {
             if (logger.isDebugEnabled()) {
                 logger.debug("Deallocating " + this);
@@ -727,7 +728,6 @@ public void deallocate(boolean deallocate) {
             address = 0;
         }
         if (!deallocate || referenceQueue == null) {
-            DeallocatorReference r = (DeallocatorReference)deallocator;
             if (r != null) {
                 // remove from queue without calling the deallocator
                 Deallocator d = r.deallocator;

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -1234,11 +1234,12 @@ public static String load(Class cls, Properties properties, boolean pathsFirst)
             String prefix = p.getProperty("platform.executable.prefix", "");
             String suffix = p.getProperty("platform.executable.suffix", "");
             String filename = prefix + executable + suffix;
+            String libraryPath  = p.getProperty("platform.library.path", "");
             try {
                 for (int i = extensions.length - 1; i >= -1; i--) {
                     // iterate extensions in reverse to be consistent with the overriding of properties
                     String extension = i >= 0 ? extensions[i] : "";
-                    String subdir = platform + (extension == null ? "" : extension) + "/";
+                    String subdir = (libraryPath.length() > 0 ? "/" + libraryPath : platform + (extension == null ? "" : extension)) + "/";
                     File f = cacheResource(cls, subdir + filename);
                     if (f != null) {
                         f.setExecutable(true);

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -238,7 +238,7 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                         + "    static { Loader.load(); }\n"
                         + "    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */\n"
                         + "    public " + containerType.javaName + "(Pointer p) { super(p); }\n";
-                if (!constant && (dim == 0 || containerType.arguments.length == 1) && firstType != null && secondType != null) {
+                if (!constant && (dim == 0 || (containerType.arguments.length == 1 && indexType != null)) && firstType != null && secondType != null) {
                     String[] firstNames = firstType.javaNames != null ? firstType.javaNames : new String[] {firstType.javaName};
                     String[] secondNames = secondType.javaNames != null ? secondType.javaNames : new String[] {secondType.javaName};
                     String brackets = arrayBrackets + (dim > 0 ? "[]" : "");
@@ -282,7 +282,7 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                     separator = ", ";
                 }
 
-                if (firstType != null && secondType != null) {
+                if ((dim == 0 || indexType != null) && firstType != null && secondType != null) {
                     String indexAnnotation = dim == 0 ? "@MemberGetter " : "@Index(" + (dim > 1 ? "value = " + dim + ", " : "") + "function = \"at\") ";
                     decl.text += "\n"
                               +  "    " + indexAnnotation + "public native " + firstType.annotations + firstType.javaName + " first(" + params + ");"
@@ -371,7 +371,7 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                     }
                 }
 
-                if (!constant && (dim == 0 || containerType.arguments.length == 1) && firstType != null && secondType != null) {
+                if (!constant && (dim == 0 || (containerType.arguments.length == 1 && indexType != null)) && firstType != null && secondType != null) {
                     String[] firstNames = firstType.javaNames != null ? firstType.javaNames : new String[] {firstType.javaName};
                     String[] secondNames = secondType.javaNames != null ? secondType.javaNames : new String[] {secondType.javaName};
                     String brackets = arrayBrackets + (dim > 0 ? "[]" : "");

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3941,6 +3941,9 @@ static String cppScopeName(MethodInformation methodInfo) {
             scopeName = subType;
         }
         Namespace namespace = methodInfo.method.getAnnotation(Namespace.class);
+        if (namespace == null && methodInfo.pairedMethod != null) {
+            namespace = methodInfo.pairedMethod.getAnnotation(Namespace.class);
+        }
         String spaceName = namespace == null ? "" : namespace.value();
         if ((namespace != null && namespace.value().length() == 0) || spaceName.startsWith("::")) {
             scopeName = ""; // user wants to reset namespace here

File: src/it/osgi/src/main/java/org/bytedeco/javacpp/test/osgi/JavaCPPOsgiTest.java
Patch:
@@ -9,5 +9,8 @@ public class JavaCPPOsgiTest {
     @Test
     public void testJavaCPP() {
         assertEquals(3, Calc.add(1, 2));
+
+        Calc.IntValue v = new Calc.IntValue().value(4);
+        assertEquals(4, v.value());
     }
 }

File: src/main/java/org/bytedeco/javacpp/annotation/package-info.java
Patch:
@@ -2,5 +2,4 @@
  * Contains all the annotation classes used by JavaCPP.
  */
 @org.osgi.annotation.bundle.Export
-@org.osgi.annotation.versioning.Version("1.5.0")
 package org.bytedeco.javacpp.annotation;

File: src/main/java/org/bytedeco/javacpp/indexer/package-info.java
Patch:
@@ -2,5 +2,4 @@
  * Contains classes for multidimensional access of arrays and buffers.
  */
 @org.osgi.annotation.bundle.Export
-@org.osgi.annotation.versioning.Version("1.5.0")
 package org.bytedeco.javacpp.indexer;

File: src/main/java/org/bytedeco/javacpp/package-info.java
Patch:
@@ -2,5 +2,4 @@
  * Contains the main set of classes for JavaCPP at runtime.
  */
 @org.osgi.annotation.bundle.Export
-@org.osgi.annotation.versioning.Version("1.5.0")
 package org.bytedeco.javacpp;

File: src/main/java/org/bytedeco/javacpp/tools/package-info.java
Patch:
@@ -3,5 +3,4 @@
  */
 @org.osgi.annotation.bundle.Export(
 		attribute="exclude:=\"BuildMojo,ParseMojo,CacheMojo\"")
-@org.osgi.annotation.versioning.Version("1.5.0")
 package org.bytedeco.javacpp.tools;

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -368,7 +368,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("    #define JavaCPP_noinline");
         out.println("    #define JavaCPP_hidden");
         out.println("#endif");
-        out.println("#if __cplusplus >= 201103L");
+        out.println("#if __cplusplus >= 201103L || _MSC_VER >= 1900");
         out.println("    #define JavaCPP_override override");
         out.println("#else");
         out.println("    #define JavaCPP_override");
@@ -1205,7 +1205,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("};");
             out.println("#endif");
             out.println("");
-            out.println("#if __cplusplus >= 201103L");
+            out.println("#if __cplusplus >= 201103L || _MSC_VER >= 1900");
             out.println("#include <utility>");
             out.println("template<class T> class MoveAdapter {");
             out.println("public:");

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -570,7 +570,6 @@ Type type(Context context, boolean definition) throws ParserException {
                         break;
                     }
                 }
-                type.cppName += token;
                 tokens.next();
                 break;
             } else if (token.match('<')) {

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -88,7 +88,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
             .pointerTypes("FloatPointer", "FloatBuffer", "float[]"))
         .put(new Info("std::complex<double>", "double _Complex", "double _Imaginary", "double complex", "double imaginary").cast()
             .pointerTypes("DoublePointer", "DoubleBuffer", "double[]"))
-        .put(new Info("jboolean").valueTypes("boolean").pointerTypes("BoolPointer", "boolean[]"))
+        .put(new Info("jboolean").valueTypes("boolean").pointerTypes("BooleanPointer", "boolean[]"))
         .put(new Info("_Bool", "bool").cast().valueTypes("boolean").pointerTypes("BoolPointer", "boolean[]"))
         .put(new Info("jchar").valueTypes("char").pointerTypes("CharPointer", "char[]"))
         .put(new Info("char16_t").cast().valueTypes("char").pointerTypes("CharPointer", "char[]"))

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -857,7 +857,7 @@ Type type(Context context, boolean definition) throws ParserException {
                 type.annotations += "@ByRef ";
             }
             if (info != null && info.cast) {
-                type.annotations += "@Cast(\"" + type.cppName + (type.indirections == 0 && !type.value ? "*" : "") + "\") ";
+                type.annotations += "@Cast(\"" + type.cppName + (!type.value ? "*" : "") + "\") ";
             }
             type.annotations += "@Name(\"operator " + (type.constValue && !type.constExpr ? "const " : "")
                     + type.cppName + (type.indirections > 0 ? "*" : type.reference ? "&" : "") + "\") ";

File: src/main/java/org/bytedeco/javacpp/BytePointer.java
Patch:
@@ -126,6 +126,9 @@ public BytePointer() { }
     @Override public BytePointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public int sizeof() {
+        return 1;
+    }
 
     /** Returns the bytes, assuming a null-terminated string if {@code limit <= position}. */
     public byte[] getStringBytes() {

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -106,6 +106,9 @@ public CharPointer() { }
     @Override public CharPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public int sizeof() {
+        return Character.SIZE / Byte.SIZE;
+    }
 
     /** Returns the chars, assuming a null-terminated string if {@code limit <= position}. */
     public char[] getStringChars() {

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -96,6 +96,9 @@ public DoublePointer() { }
     @Override public DoublePointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public int sizeof() {
+        return Double.SIZE / Byte.SIZE;
+    }
 
     /** @return {@code get(0)} */
     public double get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -96,6 +96,9 @@ public FloatPointer() { }
     @Override public FloatPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public int sizeof() {
+        return Float.SIZE / Byte.SIZE;
+    }
 
     /** @return {@code get(0)} */
     public float get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -106,6 +106,9 @@ public IntPointer() { }
     @Override public IntPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public int sizeof() {
+        return Integer.SIZE / Byte.SIZE;
+    }
 
     /** Returns the code points, assuming a null-terminated string if {@code limit <= position}. */
     public int[] getStringCodePoints() {

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -96,6 +96,9 @@ public LongPointer() { }
     @Override public LongPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public int sizeof() {
+        return Long.SIZE / Byte.SIZE;
+    }
 
     /** @return {@code get(0)} */
     public long get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -96,6 +96,9 @@ public ShortPointer() { }
     @Override public ShortPointer capacity(long capacity) {
         return super.capacity(capacity);
     }
+    @Override public int sizeof() {
+        return Short.SIZE / Byte.SIZE;
+    }
 
     /** @return {@code get(0)} */
     public short get() { return get(0); }

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -309,7 +309,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("    #include <dlfcn.h>");
         out.println("    #include <mach-o/dyld.h>");
         out.println("    #include <pthread.h>");
-        out.println("#elif defined(_WIN32)");
+        out.println("#elif defined(_WIN32) && !defined(NO_WINDOWS_H)");
         out.println("    #define NOMINMAX");
         out.println("    #include <windows.h>");
         out.println("    #include <psapi.h>");

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2258,7 +2258,7 @@ void call(MethodInformation methodInfo, String returnPrefix, boolean secondCall)
                         needSecondCall = true;
                     }
                     if (methodInfo.method.isAnnotationPresent(Virtual.class)) {
-                        name = "super_" + name;
+                        name = "super_" + methodInfo.name;
                     }
                     out.print("((" + subType + "*)ptr)->" + name);
                 } else if (index != null) {
@@ -2715,7 +2715,7 @@ void callback(Class<?> cls, Method callbackMethod, String callbackName, int allo
                 }
                 member += "virtual " + returnConvention[0] + (returnConvention.length > 1 ? returnConvention[1] : "")
                        +  methodInfo.memberName[0] + parameterDeclaration + " JavaCPP_override;\n    "
-                       +  returnConvention[0] + "super_" + methodInfo.memberName[0] + nonconstParamDeclaration + " { ";
+                       +  returnConvention[0] + "super_" + methodInfo.name + nonconstParamDeclaration + " { ";
                 if (methodInfo.method.getAnnotation(Virtual.class).value()) {
                     member += "throw JavaCPP_exception(\"Cannot call pure virtual function " + valueTypeName + "::" + methodInfo.memberName[0] + "().\"); }";
                 } else {

File: src/test/java/org/bytedeco/javacpp/BuilderTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 Samuel Audet
+ * Copyright (C) 2017-2019 Samuel Audet
  *
  * Licensed either under the Apache License, Version 2.0, or (at your option)
  * under the terms of the GNU General Public License as published by
@@ -87,6 +87,7 @@ public class BuilderTest implements BuildEnabled, LoadEnabled {
         String filename = Loader.load(c);
         Loader.loadGlobal(filename);
         assertTrue(Loader.getLoadedLibraries().get("jniBuilderTest").contains("-ext1"));
+        Loader.foundLibraries.clear();
         Loader.loadedLibraries.clear();
 
         System.out.println("Builder");
@@ -98,6 +99,7 @@ public class BuilderTest implements BuildEnabled, LoadEnabled {
         filename = Loader.load(c);
         Loader.loadGlobal(filename);
         assertTrue(Loader.getLoadedLibraries().get("jniBuilderTest").contains("-ext2"));
+        Loader.foundLibraries.clear();
         Loader.loadedLibraries.clear();
 
         Loader.loadProperties().put("platform.extension", "-ext1");

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -831,7 +831,7 @@ Type type(Context context, boolean definition) throws ParserException {
         }
 
         if (type.operator) {
-            if (type.constValue) {
+            if (type.constValue && !type.constExpr) {
                 type.annotations += "@Const ";
             }
             if (type.indirections == 0 && !type.reference && !type.value) {
@@ -842,7 +842,7 @@ Type type(Context context, boolean definition) throws ParserException {
             if (info != null && info.cast) {
                 type.annotations += "@Cast(\"" + type.cppName + (type.indirections == 0 && !type.value ? "*" : "") + "\") ";
             }
-            type.annotations += "@Name(\"operator " + (type.constValue ? "const " : "")
+            type.annotations += "@Name(\"operator " + (type.constValue && !type.constExpr ? "const " : "")
                     + type.cppName + (type.indirections > 0 ? "*" : type.reference ? "&" : "") + "\") ";
         }
         if (info != null && info.annotations != null) {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1189,7 +1189,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("        }");
             out.println("        return (typename UNIQUE_PTR_NAMESPACE::remove_const<T>::type*)ptr;");
             out.println("    }");
-            out.println("    operator U&() { return uniquePtr; }");
+            out.println("    operator U&() const { return uniquePtr; }");
             out.println("    operator U&&() { return UNIQUE_PTR_NAMESPACE::move(uniquePtr); }");
             out.println("    operator U*() { return &uniquePtr; }");
             out.println("    T* ptr;");

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3082,7 +3082,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
         }
         if (!anonymous) {
             if (!fullName.equals(cppName)) {
-                decl.text += "@Name(\"" + cppName + "\") ";
+                decl.text += "@Name(\"" + (context.javaName == null || namespace < 0 ? cppName : cppName.substring(namespace + 2)) + "\") ";
             } else if (context.namespace != null && context.javaName == null) {
                 decl.text += "@Namespace(\"" + context.namespace + "\") ";
             }

File: src/main/java/org/bytedeco/javacpp/tools/ClassScanner.java
Patch:
@@ -91,7 +91,7 @@ public void addMatchingDir(String parentName, File dir, String packagePath, bool
 
     public void addPackage(String packageName, boolean recursive) throws IOException, ClassNotFoundException, NoClassDefFoundError {
         String[] paths = loader.getPaths();
-        final String packagePath = packageName == null ? null : (packageName.replace('.', '/') + "/");
+        final String packagePath = packageName != null && packageName.length() > 0 ? (packageName.replace('.', '/') + "/") : packageName;
         int prevSize = classes.size();
         for (String p : paths) {
             File file = new File(p);
@@ -108,9 +108,8 @@ public void addPackage(String packageName, boolean recursive) throws IOException
                 jis.close();
             }
         }
-        if (classes.size() == 0 && packageName == null) {
+        if (classes.size() == 0 && (packageName == null || packageName.length() == 0)) {
             logger.warn("No classes found in the unnamed package");
-            Builder.printHelp();
         } else if (prevSize == classes.size() && packageName != null) {
             logger.warn("No classes found in package " + packageName);
         }

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -532,7 +532,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("#ifdef __linux__");
             out.println("    struct sysinfo info;");
             out.println("    if (sysinfo(&info) == 0) {");
-            out.println("        size = info.totalram;");
+            out.println("        size = (jlong)info.totalram * info.mem_unit;");
             out.println("    }");
             out.println("#elif defined(__APPLE__)");
             out.println("    size_t length = sizeof(size);");
@@ -563,7 +563,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("    if (size == 0) {");
             out.println("        struct sysinfo info;");
             out.println("        if (sysinfo(&info) == 0) {");
-            out.println("            size = info.freeram;");
+            out.println("            size = (jlong)info.freeram * info.mem_unit;");
             out.println("        }");
             out.println("    }");
             out.println("#elif defined(__APPLE__)");

File: src/test/java/org/bytedeco/javacpp/PointerTest.java
Patch:
@@ -190,7 +190,7 @@ static class TestFunction extends FunctionPointer {
         assertEquals(false, pointer.getBool(0));
         assertEquals(true, pointer.getBool(1));
         assertEquals(shortValue, pointer.getChar(1));
-        assertEquals(pointer.sizeof() == 4 ? intValue : longValue, pointer.getPointer(1).address);
+        assertEquals(Loader.sizeof(Pointer.class) == 4 ? intValue : longValue, pointer.getPointer(1).address);
 
         byte[] array2 = new byte[array.length];
         pointer.position(0).get(array2);
@@ -889,7 +889,7 @@ static class TestFunction extends FunctionPointer {
             if (i < 10) {
                 assertNull(pointer2.get(i));
             } else if (i < 20) {
-                assertEquals(0xFFFFFFFF, pointer2.get(i).address() & 0xFFFFFFFF);
+                assertEquals(0xFFFFFFFFL, pointer2.get(i).address() & 0xFFFFFFFFL);
             } else if (i < 30) {
                 assertEquals(pointer.get(i), pointer2.get(i));
             } else {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1660,7 +1660,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
     }
 
     boolean methods(Class<?> cls) {
-        if (Modifier.isAbstract(cls.getModifiers()) || !Loader.checkPlatform(cls, properties)) {
+        if (!Loader.checkPlatform(cls, properties)) {
             return false;
         }
 
@@ -1690,8 +1690,8 @@ boolean methods(Class<?> cls) {
             methodInfos[i] = methodInformation(methods[i]);
         }
         Class<?> c = cls.getSuperclass();
-        while (c != null && c != Object.class) {
-            // consider non-duplicate virtual functions from superclasses as well
+        while (c != null && c != Object.class && !Modifier.isAbstract(cls.getModifiers())) {
+            // consider non-duplicate virtual functions from superclasses as well, unless abstract anyway
             for (Method m : c.getDeclaredMethods()) {
                 if (m.isAnnotationPresent(Virtual.class)) {
                     boolean found = false;

File: src/main/java/org/bytedeco/javacpp/tools/Context.java
Patch:
@@ -64,13 +64,13 @@ String[] qualify(String cppName) {
         if (cppName == null || cppName.length() == 0) {
             return new String[0];
         }
-        for (Map.Entry<String, String> e : namespaceMap.entrySet()) {
-            cppName = cppName.replaceAll(e.getKey() + "::", e.getValue() + "::");
-        }
         if (cppName.startsWith("::")) {
             // already in global namespace, so strip leading operator
             return new String[] { cppName.substring(2) };
         }
+        for (Map.Entry<String, String> e : namespaceMap.entrySet()) {
+            cppName = cppName.replaceAll(e.getKey() + "::", e.getValue() + "::");
+        }
         List<String> names = new ArrayList<String>();
         String ns = namespace != null ? namespace : "";
         while (ns != null) {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3550,8 +3550,9 @@ String cast(Class<?> type, Annotation ... annotations) {
 
     Annotation by(MethodInformation methodInfo, int j) {
         Annotation passBy = by(methodInfo.parameterAnnotations[j]);
-        if (passBy == null && methodInfo.pairedMethod != null &&
-                (methodInfo.valueSetter || methodInfo.memberSetter)) {
+        if (passBy == null && methodInfo.pairedMethod != null
+                && (methodInfo.valueSetter || methodInfo.memberSetter)
+                && j == methodInfo.parameterAnnotations.length - 1) {
             passBy = by(methodInfo.pairedMethod.getAnnotations());
         }
         return passBy;

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -31,7 +31,7 @@ class Type {
     Type(String name) { cppName = javaName = name; }
 
     int indirections = 0;
-    boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
+    boolean anonymous = false, constExpr = false, constPointer = false, constValue = false, constructor = false,
             destructor = false, operator = false, simple = false, staticMember = false, using = false,
             reference = false, value = false, friend = false, typedef = false, virtual = false;
     String annotations = "", cppName = "", javaName = "", javaNames[] = null;

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -325,7 +325,8 @@ static class DeallocatorThread extends Thread {
     static final long maxBytes;
 
     /** Maximum amount of memory reported by {@link #physicalBytes()} before forcing call to {@link System#gc()}.
-     * Set via "org.bytedeco.javacpp.maxphysicalbytes" system property, defaults to {@code 2 * Runtime.maxMemory()}. */
+     * Set via "org.bytedeco.javacpp.maxphysicalbytes" system property, defaults to {@code maxBytes + Runtime.maxMemory()}.
+     * If {@link #maxBytes} is also not set, this is equivalent to a default of {@code 2 * Runtime.maxMemory()}*/
     static final long maxPhysicalBytes;
 
     /** Maximum number of times to call {@link System#gc()} before giving up with {@link OutOfMemoryError}.
@@ -390,7 +391,7 @@ public static long parseBytes(String string) throws NumberFormatException {
         }
         maxBytes = m;
 
-        m = 2 * Runtime.getRuntime().maxMemory();
+        m = maxBytes + Runtime.getRuntime().maxMemory();
         s = System.getProperty("org.bytedeco.javacpp.maxphysicalbytes");
         s = System.getProperty("org.bytedeco.javacpp.maxPhysicalBytes", s);
         if (s != null && s.length() > 0) {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3085,7 +3085,7 @@ void callback(Class<?> cls, Method callbackMethod, String callbackName, int allo
             } else if (returnBy instanceof ByVal || returnBy instanceof ByRef) {
                 out.println("    if (rptr == NULL) {");
                 out.println("        JavaCPP_log(\"Return pointer address is NULL in callback for " + cls.getCanonicalName() + ".\");");
-                out.println("        static " + returnConvention[0] + " empty" + returnTypeName[1] + ";");
+                out.println("        static " + constValueTypeName(returnConvention[0].trim()) + " empty" + returnTypeName[1] + ";");
                 out.println("        return empty;");
                 out.println("    } else {");
                 out.println("        return *" + callbackReturnCast + "rptr;");

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1138,7 +1138,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("    SharedPtrAdapter(const S& sharedPtr) : ptr(0), size(0), owner(0), sharedPtr2(sharedPtr), sharedPtr(sharedPtr2) { }");
             out.println("    SharedPtrAdapter(      S& sharedPtr) : ptr(0), size(0), owner(0), sharedPtr(sharedPtr) { }");
             out.println("    SharedPtrAdapter(const S* sharedPtr) : ptr(0), size(0), owner(0), sharedPtr(*(S*)sharedPtr) { }");
-            out.println("    void assign(T* ptr, size_t size, S* owner) {");
+            out.println("    void assign(T* ptr, size_t size, void* owner) {");
             out.println("        this->ptr = ptr;");
             out.println("        this->size = size;");
             out.println("        this->owner = owner;");
@@ -1173,7 +1173,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("    UniquePtrAdapter(const U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr((U&)uniquePtr) { }");
             out.println("    UniquePtrAdapter(      U& uniquePtr) : ptr(0), size(0), owner(0), uniquePtr(uniquePtr) { }");
             out.println("    UniquePtrAdapter(const U* uniquePtr) : ptr(0), size(0), owner(0), uniquePtr(*(U*)uniquePtr) { }");
-            out.println("    void assign(T* ptr, size_t size, U* owner) {");
+            out.println("    void assign(T* ptr, size_t size, void* owner) {");
             out.println("        this->ptr = ptr;");
             out.println("        this->size = size;");
             out.println("        this->owner = owner;");

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -294,6 +294,7 @@ static class DeallocatorThread extends Thread {
             super("JavaCPP Deallocator");
             setPriority(Thread.MAX_PRIORITY);
             setDaemon(true);
+            setContextClassLoader(null); // as required by containers
             start();
         }
 

File: src/main/java/org/bytedeco/javacpp/tools/MethodInformation.java
Patch:
@@ -36,7 +36,7 @@ public class MethodInformation {
     int modifiers;
     Class<?> returnType;
     String name, memberName[];
-    int dim;
+    int allocatorMax, dim;
     boolean[] parameterRaw;
     Class<?>[] parameterTypes;
     Annotation[][] parameterAnnotations;

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -434,7 +434,7 @@ int compile(String[] sourceFilenames, String outputFilename, ClassProperties pro
                 }
                 List<String> l = new ArrayList<>();
                 l.addAll(linkBeforeOptions);
-                l.add(linkPrefix + s + linkSuffix);
+                l.add(linkPrefix + (s.endsWith("!") ? s.substring(0, s.length() - 1) : s) + linkSuffix);
                 l.addAll(linkAfterOptions);
 
                 command.addAll(i, l);

File: src/main/java/org/bytedeco/javacpp/indexer/UnsafeRaw.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016-2018 Samuel Audet
+ * Copyright (C) 2016-2019 Samuel Audet
  *
  * Licensed either under the Apache License, Version 2.0, or (at your option)
  * under the terms of the GNU General Public License as published by

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -1085,7 +1085,7 @@ public File[] build() throws IOException, InterruptedException, ParserException
                         logger.info("Copying " + in);
                         File outputPath = getOutputPath(classArray, null);
                         Path out = new File(outputPath, filename).toPath();
-                        Files.copy(in, out);
+                        Files.copy(in, out, StandardCopyOption.REPLACE_EXISTING);
                         files = new File[] { out.toFile() };
                         break;
                     }
@@ -1133,7 +1133,7 @@ public File[] build() throws IOException, InterruptedException, ParserException
                         File fo = new File(directory, fi.getName());
                         if (fi.exists() && !outputFiles.contains(fo)) {
                             logger.info("Copying " + fi);
-                            Files.copy(fi.toPath(), fo.toPath());
+                            Files.copy(fi.toPath(), fo.toPath(), StandardCopyOption.REPLACE_EXISTING);
                             outputFiles.add(fo);
                         }
                     }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3068,7 +3068,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
                     }
                 }
                 int end = text.lastIndexOf('}');
-                decl.text += text.substring(start, end).replaceAll("(\\s+)" + base2.javaName + "(\\s+)", "$1" + type.javaName + "$2");
+                decl.text += text.substring(start, end).replace(base2.javaName, type.javaName);
             }
         }
         for (Declaration d : declList2) {

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -303,7 +303,8 @@ public void load(Class cls, boolean inherit) {
             // fail silently as if the interface wasn't implemented
         }
 
-        if (platforms != null && platforms.length > 0) {
+        // need platform information from both classProperties and classPlatform to be considered "loaded"
+        if (platforms != null && platforms.length > (classProperties != null && classPlatform != null ? 1 : 0)) {
             loaded = true;
         }
     }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1959,7 +1959,8 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
                     name = name.substring(namespace2 + 2);
                 }
                 info = fullInfo = infoMap.getFirst(dcl.cppName + "::" + name);
-            } else {
+            }
+            if (info == null) {
                 info = infoMap.getFirst(dcl.cppName);
             }
             if (!type.constructor && !type.destructor && !type.operator) {

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -726,6 +726,7 @@ Type type(Context context, boolean definition) throws ParserException {
         }
 
         Info info = null;
+        String shortName = type.cppName;
         String[] names = context.qualify(type.cppName);
         if (definition && names.length > 0) {
             String constName = type.constValue || type.constPointer ? "const " + names[0] : names[0];
@@ -821,7 +822,7 @@ Type type(Context context, boolean definition) throws ParserException {
             } else if (namespace >= 0 && namespace2 < 0) {
                 cppName = cppName.substring(namespace + 2);
             }
-            if (cppName.equals(groupName)) {
+            if (cppName.equals(groupName) || (groupName.endsWith("::" + shortName) && cppName.equals(groupName + "::" + shortName))) {
                 type.constructor = !type.destructor && !type.operator
                         && type.indirections == 0 && !type.reference && tokens.get().match('(', ':');
             }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -252,8 +252,8 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                 decl.text += "    public " + containerType.javaName + "()       { allocate();  }\n" + (!resizable ? ""
                            : "    public " + containerType.javaName + "(long n) { allocate(n); }\n")
                            + "    private native void allocate();\n"                                + (!resizable ? ""
-                           : "    private native void allocate(@Cast(\"size_t\") long n);\n")
-                           + "    public native @Name(\"operator=\") @ByRef " + containerType.javaName + " put(@ByRef " + containerType.javaName + " x);\n\n";
+                           : "    private native void allocate(@Cast(\"size_t\") long n);\n")       + (constant   ? "\n\n"
+                           : "    public native @Name(\"operator=\") @ByRef " + containerType.javaName + " put(@ByRef " + containerType.javaName + " x);\n\n");
 
                 for (int i = 0; i < dim; i++) {
                     String indexAnnotation = i > 0 ? ("@Index(" + (i > 1 ? "value = " + i + ", " : "" ) + "function = \"at\") ") : "";

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -3693,7 +3693,7 @@ public File parse(File outputDirectory, String[] classPath, Class cls) throws IO
                     String javaText = text + "import static " + global + ".*;\n"
                             + (prevd != null && prevd.comment ? prevd.text : "")
                             + d.text.replace("public static class " + d.type.javaName + " ",
-                                    "@Properties(inherit = " + cls.getSimpleName() + ".class)\n"
+                                    "@Properties(inherit = " + cls.getCanonicalName() + ".class)\n"
                                   + "public class " + d.type.javaName + " ");
                     Files.write(javaFile.toPath(), encoding != null ? javaText.getBytes(encoding) : javaText.getBytes());
                     prevd = null;

File: src/test/java/org/bytedeco/javacpp/BuilderTest.java
Patch:
@@ -59,7 +59,7 @@ public class BuilderTest implements BuildEnabled, LoadEnabled {
         Class c = BuilderTest.class;
         String[] extensions = {"", "-ext1", "-ext2"};
         for (String extension : extensions) {
-            URL u = c.getResource(Loader.getPlatform() + extension);
+            URL u = Loader.findResource(c, Loader.getPlatform() + extension);
             if (u != null) {
                 for (File f : new File(u.toURI()).listFiles()) {
                     f.delete();

File: src/main/java/org/bytedeco/javacpp/annotation/Platform.java
Patch:
@@ -96,6 +96,7 @@
     String[] extension()   default {};
     /** The native JNI library associated with this class that {@link Builder} should
      *  try to build and {@link Loader} should try to load. If left empty, this value
-     *  defaults to "jni" + the name that {@link Class#getSimpleName()} returns. */
+     *  defaults to "jni" + the name that {@link Class#getSimpleName()} returns for
+     *  {@link Properties#target} or {@link Properties#global} class, or this class, if not given. */
     String   library()     default "";
 }

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -93,8 +93,8 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("const char").valueTypes("byte").pointerTypes("@Cast(\"const char*\") BytePointer", "String"))
         .put(new Info("boost::shared_ptr", "std::shared_ptr").annotations("@SharedPtr"))
         .put(new Info("boost::movelib::unique_ptr", "std::unique_ptr").annotations("@UniquePtr"))
-        .put(new Info("std::string").annotations("@StdString").valueTypes("BytePointer", "String"))
-        .put(new Info("std::wstring").annotations("@StdWString").valueTypes("CharPointer", "IntPointer"))
+        .put(new Info("std::string").annotations("@StdString").valueTypes("BytePointer", "String").pointerTypes("BytePointer"))
+        .put(new Info("std::wstring").annotations("@StdWString").valueTypes("CharPointer", "IntPointer").pointerTypes("CharPointer", "IntPointer"))
         .put(new Info("std::vector").annotations("@StdVector"))
 
         .put(new Info("abstract").javaNames("_abstract"))

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -46,6 +46,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
                                                    "std::priority_queue", "std::unordered_map", "std::unordered_set"))
         .put(new Info("basic/types").cppTypes("signed", "unsigned", "char", "short", "int", "long", "bool", "float", "double",
                                               "_Bool", "_Complex", "_Imaginary", "complex", "imaginary"))
+        .put(new Info("noexcept").annotations("@NoException"))
 
         .put(new Info("__COUNTER__").cppText("#define __COUNTER__ 0"))
         .put(new Info(" __attribute__", "__declspec", "static_assert").annotations().skip())

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -88,7 +88,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("std::complex<double>", "double _Complex", "double _Imaginary", "double complex", "double imaginary").cast()
             .pointerTypes("DoublePointer", "DoubleBuffer", "double[]"))
         .put(new Info("_Bool", "bool", "jboolean").cast().valueTypes("boolean").pointerTypes("BoolPointer", "boolean[]"))
-        .put(new Info("wchar_t", "WCHAR").cast().valueTypes("char").pointerTypes("CharPointer"))
+        .put(new Info("wchar_t", "WCHAR").cast().valueTypes("char", "int").pointerTypes("CharPointer", "IntPointer"))
         .put(new Info("const char").valueTypes("byte").pointerTypes("@Cast(\"const char*\") BytePointer", "String"))
         .put(new Info("boost::shared_ptr", "std::shared_ptr").annotations("@SharedPtr"))
         .put(new Info("boost::movelib::unique_ptr", "std::unique_ptr").annotations("@UniquePtr"))

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -2183,7 +2183,8 @@ boolean variable(Context context, DeclarationList declList) throws ParserExcepti
                     if (indices.length() > 0) {
                         indices += ", ";
                     }
-                    decl.text += " " + modifiers + setterType + javaName + "(" + indices + dcl.type.javaName + " " + javaName + ");";
+                    String javaTypeWithoutAnnotations = dcl.type.javaName.substring(dcl.type.javaName.lastIndexOf(" ") + 1);
+                    decl.text += " " + modifiers + setterType + javaName + "(" + indices + javaTypeWithoutAnnotations + " " + javaName + ");";
                 }
                 decl.text += "\n";
                 if ((dcl.type.constValue || dcl.constPointer) && dcl.type.staticMember && indices.length() == 0) {

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -906,7 +906,7 @@ public static String load(Class cls) {
      * @return the full path to the main file loaded, or the library name if unknown
      *         (but {@code if (!isLoadLibraries() || cls == null) { return null; }})
      * @throws NoClassDefFoundError on Class initialization failure
-     * @throws UnsatisfiedLinkError on native library loading failure
+     * @throws UnsatisfiedLinkError on native library loading failure or when interrupted
      * @see #findLibrary(Class, ClassProperties, String, boolean)
      * @see #loadLibrary(URL[], String)
      */
@@ -1117,7 +1117,7 @@ public static URL[] findLibrary(Class cls, ClassProperties properties, String li
      * @param preloaded libraries for which to create symbolic links in same cache directory
      * @return the full path of the file loaded, or the library name if unknown
      *         (but {@code if (!isLoadLibraries) { return null; }})
-     * @throws UnsatisfiedLinkError on failure
+     * @throws UnsatisfiedLinkError on failure or when interrupted
      */
     public synchronized static String loadLibrary(URL[] urls, String libnameversion, String ... preloaded) {
         if (!isLoadLibraries()) {

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -1119,7 +1119,7 @@ public static URL[] findLibrary(Class cls, ClassProperties properties, String li
      *         (but {@code if (!isLoadLibraries) { return null; }})
      * @throws UnsatisfiedLinkError on failure
      */
-    public static String loadLibrary(URL[] urls, String libnameversion, String ... preloaded) {
+    public synchronized static String loadLibrary(URL[] urls, String libnameversion, String ... preloaded) {
         if (!isLoadLibraries()) {
             return null;
         }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -166,7 +166,7 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                     indexFunction = "";
                     valueType.javaName = "boolean";
                     resizable = false;
-                } else if (containerName.endsWith("set")) {
+                } else if (containerName.endsWith("list") || containerName.endsWith("set")) {
                     indexType = null;
                     resizable = false;
                 }

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -208,7 +208,7 @@ public static Properties loadProperties(String name, String defaults) {
     public static Class getEnclosingClass(Class cls) {
         Class<?> c = cls;
         // Find first enclosing declaring class with some properties to use
-        while (c.getDeclaringClass() != null) {
+        while (c.getEnclosingClass() != null) {
             if (c.isAnnotationPresent(org.bytedeco.javacpp.annotation.Properties.class)) {
                 break;
             }
@@ -222,7 +222,7 @@ public static Class getEnclosingClass(Class cls) {
                     break;
                 }
             }
-            c = c.getDeclaringClass();
+            c = c.getEnclosingClass();
         }
         return c;
     }

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3221,8 +3221,8 @@ static boolean noException(Class<?> cls, Method method) {
             if (noException = cls.isAnnotationPresent(NoException.class)) {
                 break;
             }
-            if (cls.getDeclaringClass() != null) {
-                cls = cls.getDeclaringClass();
+            if (cls.getEnclosingClass() != null) {
+                cls = cls.getEnclosingClass();
             } else {
                 cls = cls.getSuperclass();
             }
@@ -3704,7 +3704,7 @@ static String cppScopeName(Class<?> type) {
                 // user wants to reset namespace here
                 break;
             }
-            type = type.getDeclaringClass();
+            type = type.getEnclosingClass();
         }
         return scopeName;
     }

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -930,19 +930,19 @@ public File[] build() throws IOException, InterruptedException, ParserException
                     ClassProperties p2 = Loader.loadProperties(classArray, properties, true);
 
                     for (String s : preloads) {
-                        if (s.trim().endsWith("#")) {
+                        if (s.trim().endsWith("#") || s.trim().length() == 0) {
                             // the user specified an empty destination to skip the copy
                             continue;
                         }
                         URL[] urls = Loader.findLibrary(null, p, s);
                         File fi;
                         try {
-                            fi = new File(urls[0].toURI());
+                            fi = new File(new URI(urls[0].toURI().toString().split("#")[0]));
                         } catch (Exception e) {
                             // try with inherited paths as well
                             urls = Loader.findLibrary(null, p2, s);
                             try {
-                                fi = new File(urls[0].toURI());
+                                fi = new File(new URI(urls[0].toURI().toString().split("#")[0]));
                             } catch (Exception e2) {
                                 logger.warn("Could not find library " + s);
                                 continue;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2017 Samuel Audet
+ * Copyright (C) 2014-2018 Samuel Audet
  *
  * Licensed either under the Apache License, Version 2.0, or (at your option)
  * under the terms of the GNU General Public License as published by
@@ -93,6 +93,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("boost::shared_ptr", "std::shared_ptr").annotations("@SharedPtr"))
         .put(new Info("boost::movelib::unique_ptr", "std::unique_ptr").annotations("@UniquePtr"))
         .put(new Info("std::string").annotations("@StdString").valueTypes("BytePointer", "String"))
+        .put(new Info("std::wstring").annotations("@StdWString").valueTypes("CharPointer", "IntPointer"))
         .put(new Info("std::vector").annotations("@StdVector"))
 
         .put(new Info("abstract").javaNames("_abstract"))

File: src/test/java/org/bytedeco/javacpp/AdapterTest.java
Patch:
@@ -48,8 +48,8 @@ public class AdapterTest {
     static native @StdString String testStdString(@StdString String str);
     static native @StdString BytePointer testStdString(@StdString BytePointer str);
 
-    static native @StdWString @Cast("wchar_t*") CharPointer testStdWString(@StdWString @Cast("wchar_t*") CharPointer str);
-    static native @StdWString @Cast("wchar_t*") IntPointer testStdWString(@StdWString @Cast("wchar_t*") IntPointer str);
+    static native @StdWString CharPointer testStdWString(@StdWString CharPointer str);
+    static native @StdWString IntPointer testStdWString(@StdWString IntPointer str);
 
     static native String testCharString(String str);
     static native @Cast("char*") BytePointer testCharString(@Cast("char*") BytePointer str);

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -1058,8 +1058,9 @@ public static URL[] findLibrary(Class cls, ClassProperties properties, String li
         paths.addAll(properties.get("platform.preloadpath"));
         paths.addAll(properties.get("platform.linkpath"));
         String libpath = System.getProperty("java.library.path", "");
-        if (libpath.length() > 0 && (pathsFirst || !isLoadLibraries())) {
-            // leave loading from "java.library.path" to System.loadLibrary() as fallback, which works better on Android
+        if (libpath.length() > 0 && (pathsFirst || !isLoadLibraries() || reference)) {
+            // leave loading from "java.library.path" to System.loadLibrary() as fallback,
+            // which works better on Android, unless the user wants to rename a library
             paths.addAll(Arrays.asList(libpath.split(File.pathSeparator)));
         }
         ArrayList<URL> urls = new ArrayList<URL>(styles.length * (1 + paths.size()));

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -1163,7 +1163,7 @@ public static String loadLibrary(URL[] urls, String libnameversion, String ... p
                         for (String s : preloaded) {
                             File file2 = new File(s);
                             File dir2 = file2.getParentFile();
-                            if (!dir2.equals(dir)) {
+                            if (dir2 != null && !dir2.equals(dir)) {
                                 File linkFile = new File(dir, file2.getName());
                                 try {
                                     Path linkPath = linkFile.toPath();

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1944,7 +1944,7 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
             tokens.index = startIndex;
             if ((type.constructor || type.destructor || type.operator) && params != null) {
                 type = type(context);
-                params = parameters(context, n / 2, n % 2 != 0);
+                params = parameters(context, n / 2, (info == null || !info.skipDefaults) && n % 2 != 0);
                 dcl = new Declarator();
                 dcl.type = type;
                 dcl.parameters = params;
@@ -1963,7 +1963,7 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
                     }
                 }
             } else {
-                dcl = declarator(context, null, n / 2, n % 2 != 0, 0, false, false);
+                dcl = declarator(context, null, n / 2, (info == null || !info.skipDefaults) && n % 2 != 0, 0, false, false);
                 type = dcl.type;
                 namespace = dcl.cppName.lastIndexOf("::");
                 if (context.namespace != null && namespace < 0) {

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1230,9 +1230,10 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
         }
 
         // initialize shorten Java name and get fully qualified C++ name
+        info = null;
         dcl.javaName = attr != null ? attr.arguments : dcl.cppName;
         if (defaultName == null) {
-            // but only for names that are not function arguments, which can never be qualified
+            // get Info for fully qualified C++ names only, which function arguments cannot have
             for (String name : context.qualify(dcl.cppName)) {
                 if ((info = infoMap.getFirst(name, false)) != null) {
                     dcl.cppName = name;

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1552,7 +1552,7 @@ boolean methods(Class<?> cls) {
         boolean didSomething = false;
         for (Class<?> c : cls.getDeclaredClasses()) {
             if (Pointer.class.isAssignableFrom(c) ||
-                    Pointer.class.isAssignableFrom(c.getEnclosingClass())) {
+                    Pointer.class.equals(c.getEnclosingClass())) {
                 didSomething |= methods(c);
             }
         }

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -435,7 +435,7 @@ public static long maxPhysicalBytes() {
 
     /** Returns the amount of physical memory currently used by the whole process, or 0 if unknown.
      * Also known as "resident set size" (Linux, Mac OS X, etc) or "working set size" (Windows). */
-    @Name("JavaCPP_physicalBytes") public static synchronized native long physicalBytes();
+    @Name("JavaCPP_physicalBytes") public static native long physicalBytes();
 
     /** Returns the amount of physical memory installed according to the operating system, or 0 if unknown.
      * It should not be possible for {@link #physicalBytes()} to go over this value. */

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -481,8 +481,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("        char line[256];");
             out.println("        char* s;");
             out.println("        int n;");
-            out.println("        lseek(fd, 0, SEEK_SET);");
-            out.println("        if ((n = read(fd, line, sizeof(line))) > 0 && (s = (char*)memchr(line, ' ', n)) != NULL) {");
+            out.println("        if ((n = pread(fd, line, sizeof(line), 0)) > 0 && (s = (char*)memchr(line, ' ', n)) != NULL) {");
             out.println("            size = (jlong)(atoll(s + 1) * getpagesize());");
             out.println("        }");
             out.println("        // no close(fd);");

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -2229,7 +2229,7 @@ boolean macro(Context context, DeclarationList declList) throws ParserException
                     for (Token token = tokens.get(); tokens.index < endIndex; token = tokens.next()) {
                         info.cppText += token.match("\n") ? token : token.spacing + token;
                     }
-                    infoMap.putFirst(info);
+                    infoMap.put(info);
                     break;
                 } else if (info != null && info.cppText == null &&
                         info.cppTypes != null && info.cppTypes.length > (hasArgs ? 0 : 1)) {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2967,7 +2967,7 @@ MethodInformation methodInformation(Method method) {
             } else if (info.returnType.isAssignableFrom(ByteBuffer.class) && "asDirectBuffer".equals(info.name) &&
                     !Modifier.isStatic(info.modifiers) && info.parameterTypes.length == 0) {
                 info.bufferGetter = true;
-            } else if (valueGetter) {
+            } else if (valueGetter || (!memberGetter && canBeGetter && "get".equals(info.name) && index != null)) {
                 info.valueGetter = true;
                 info.noReturnGetter = noReturnGetter;
                 info.pairedMethod = pairedMethod;

File: src/main/java/org/bytedeco/javacpp/annotation/Index.java
Patch:
@@ -21,4 +21,6 @@
 public @interface Index {
     /** The number of indices spread over the parameters, for multidimensional access. */
     int value() default 1;
+    /** The name of a function to call instead of {@code operator[]}, for example, "at". */
+    String function() default "";
 }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1977,7 +1977,7 @@ boolean variable(Context context, DeclarationList declList) throws ParserExcepti
             dcl.type.annotations += attr.javaName;
         }
 
-        if (cppName == null || javaName == null || !tokens.get().match('(', '[', '=', ',', ':', ';')) {
+        if (cppName == null || javaName == null || !tokens.get().match('(', '[', '=', ',', ':', ';', '{')) {
             tokens.index = backIndex;
             return false;
         } else if (!dcl.type.staticMember && context.javaName != null) {

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -627,7 +627,7 @@ public int offsetof(String member) {
             if (c != Pointer.class) {
                 offset = Loader.offsetof(c, member);
             }
-        } catch (NullPointerException e) {
+        } catch (ClassCastException | NullPointerException e) {
             return offset;
         }
         return offset;
@@ -663,7 +663,7 @@ public ByteBuffer asByteBuffer() {
         Pointer p = new Pointer();
         p.address = address;
         return p.position(size * position)
-                .limit(size * (limit <= 0 ? position + 1 : limit))
+                .capacity(size * (limit <= 0 ? position + 1 : limit))
                 .asDirectBuffer().order(ByteOrder.nativeOrder());
     }
     /**

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -32,7 +32,7 @@ class Type {
 
     int indirections = 0;
     boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
-            destructor = false, operator = false, simple = false, staticMember = false,
+            destructor = false, operator = false, simple = false, staticMember = false, using = false,
             reference = false, value = false, friend = false, typedef = false, virtual = false;
     String annotations = "", cppName = "", javaName = "", javaNames[] = null;
     Type[] arguments = null;

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -33,7 +33,7 @@ class Type {
     int indirections = 0;
     boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
             destructor = false, operator = false, simple = false, staticMember = false,
-            reference = false, value = false, friend = false, virtual = false;
+            reference = false, value = false, friend = false, typedef = false, virtual = false;
     String annotations = "", cppName = "", javaName = "", javaNames[] = null;
     Type[] arguments = null;
     Attribute[] attributes = null;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2015 Samuel Audet
+ * Copyright (C) 2014-2017 Samuel Audet
  *
  * Licensed either under the Apache License, Version 2.0, or (at your option)
  * under the terms of the GNU General Public License as published by
@@ -166,7 +166,7 @@ String normalize(String name, boolean unconst, boolean untemplate) {
         }
         boolean foundConst = false, simpleType = true;
         String prefix = null;
-        Token[] tokens = new Tokenizer(name).tokenize();
+        Token[] tokens = new Tokenizer(name, null, 0).tokenize();
         int n = tokens.length;
         Info info = getFirst("basic/types");
         String[] basicTypes = info != null ? info.cppTypes : new String[0];

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -177,7 +177,7 @@ public void load(Class cls, boolean inherit) {
             platforms = classProperties.value();
         }
 
-        String[] pragma = {}, define = {}, include = {}, cinclude = {}, includepath = {}, includeresource = {}, compiler = {},
+        String[] pragma = {}, define = {}, exclude = {}, include = {}, cinclude = {}, includepath = {}, includeresource = {}, compiler = {},
                  linkpath = {}, linkresource = {}, link = {}, frameworkpath = {}, framework = {}, preloadpath = {}, preload = {},
                  resourcepath = {}, resource = {}, extensions = {};
         String library = "jni" + c.getSimpleName();
@@ -195,6 +195,7 @@ public void load(Class cls, boolean inherit) {
             if ((names[0].length == 0 || matches[0]) && (names[1].length == 0 || !matches[1])) {
                 if (p.pragma()     .length > 0) { pragma      = p.pragma();      }
                 if (p.define()     .length > 0) { define      = p.define();      }
+                if (p.exclude()    .length > 0) { exclude     = p.exclude();    }
                 if (p.include()    .length > 0) { include     = p.include();     }
                 if (p.cinclude()   .length > 0) { cinclude    = p.cinclude();    }
                 if (p.includepath().length > 0) { includepath = p.includepath(); }
@@ -239,6 +240,7 @@ public void load(Class cls, boolean inherit) {
         }
         addAll("platform.pragma", pragma);
         addAll("platform.define", define);
+        addAll("platform.exclude", exclude);
         addAll("platform.include", include);
         addAll("platform.cinclude", cinclude);
         addAll("platform.includepath", includepath);

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -211,7 +211,7 @@ public static Class getEnclosingClass(Class cls) {
             }
             if (c.isAnnotationPresent(Platform.class)) {
                 Platform p = c.getAnnotation(Platform.class);
-                if (p.pragma().length > 0 || p.define().length > 0 || p.include().length > 0 || p.cinclude().length > 0
+                if (p.pragma().length > 0 || p.define().length > 0 || p.exclude().length > 0 || p.include().length > 0 || p.cinclude().length > 0
                     || p.includepath().length > 0 || p.includeresource().length > 0 || p.compiler().length > 0
                     || p.linkpath().length > 0 || p.linkresource().length > 0 || p.link().length > 0 || p.frameworkpath().length > 0
                     || p.framework().length > 0 || p.preloadpath().length > 0 || p.preload().length > 0

File: src/main/java/org/bytedeco/javacpp/annotation/Platform.java
Patch:
@@ -50,6 +50,9 @@
     /** A list of macros to {@code #define} at the top of the generated code,
      *  before {@link #include()} and {@link #cinclude()} header files. */
     String[] define()      default {};
+    /** A list of C/C++ header files that should not be included in the generated code,
+     *  even when they are inherited from an include list. */
+    String[] exclude()     default {};
     /** A list of C++ header files to include at the top of the generated code. */
     String[] include()     default {};
     /** A list of C header files to include at the top of the generated code. The

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -51,6 +51,7 @@ class Token implements Comparable<Token> {
             EOF       = new Token(-1, "EOF"),
             AUTO      = new Token(IDENTIFIER, "auto"),
             CONST     = new Token(IDENTIFIER, "const"),
+            __CONST   = new Token(IDENTIFIER, "__const"),
             CONSTEXPR = new Token(IDENTIFIER, "constexpr"),
             DECLTYPE  = new Token(IDENTIFIER, "decltype"),
             DEFAULT   = new Token(IDENTIFIER, "default"),

File: src/main/java/org/bytedeco/javacpp/tools/BuildMojo.java
Patch:
@@ -291,7 +291,8 @@ String[] merge(String[] ss, String s) {
                     .compilerOptions(compilerOptions);
             Properties properties = builder.properties;
             log.info("Detected platform \"" + Loader.getPlatform() + "\"");
-            log.info("Building for platform \"" + properties.get("platform") + "\"");
+            log.info("Building for platform \"" + properties.get("platform") + "\""
+                    + (extension != null && extension.length() > 0 ? " with extension \"" + extension + "\"" : ""));
             String separator = properties.getProperty("platform.path.separator");
             for (String s : merge(buildPaths, buildPath)) {
                 String v = properties.getProperty("platform.buildpath", "");

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -64,6 +64,7 @@ class Token implements Comparable<Token> {
             ENUM      = new Token(IDENTIFIER, "enum"),
             EXPLICIT  = new Token(IDENTIFIER, "explicit"),
             EXTERN    = new Token(IDENTIFIER, "extern"),
+            FINAL     = new Token(IDENTIFIER, "final"),
             FRIEND    = new Token(IDENTIFIER, "friend"),
             INLINE    = new Token(IDENTIFIER, "inline"),
             STATIC    = new Token(IDENTIFIER, "static"),

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -248,7 +248,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("    typedef int jint;");
         out.println("    typedef long long jlong;");
         out.println("    typedef signed char jbyte;");
-        out.println("#elif defined(__GNUC__)");
+        out.println("#elif defined(__GNUC__) && !defined(__ANDROID__)");
         out.println("    #define _JAVASOFT_JNI_MD_H_");
         out.println();
         out.println("    #define JNIEXPORT __attribute__((visibility(\"default\")))");
@@ -572,7 +572,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("    }");
         out.println("    if (success) {");
         out.println("        length /= sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);");
-        out.println("        for (int i = 0; i < length; i++) {");
+        out.println("        for (DWORD i = 0; i < length; i++) {");
         out.println("            if (info[i].Relationship == RelationProcessorCore) {");
         out.println("                total++;");
         out.println("            }");
@@ -623,7 +623,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("    }");
         out.println("    if (success) {");
         out.println("        length /= sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);");
-        out.println("        for (int i = 0; i < length; i++) {");
+        out.println("        for (DWORD i = 0; i < length; i++) {");
         out.println("            if (info[i].Relationship == RelationProcessorPackage) {");
         out.println("                total++;");
         out.println("            }");

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3213,10 +3213,10 @@ String[] cppCastTypeName(Class<?> type, Annotation ... annotations) {
                 }
                 typeName = cppTypeName(type);
                 boolean[] b = ((Const)a).value();
-                if (b.length > 1 && b[1]) {
+                if (b.length > 1 && b[1] && !typeName[0].endsWith(" const *")) {
                     typeName[0] = valueTypeName(typeName) + " const *";
                 }
-                if (b.length > 0 && b[0]) {
+                if (b.length > 0 && b[0] && !typeName[0].startsWith("const ")) {
                     typeName[0] = "const " + typeName[0];
                 }
                 Annotation by = by(annotations);

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -266,8 +266,8 @@ public static Class getCallerClass(int i) {
                     return super.getClassContext();
                 }
             }.getClassContext();
-        } catch (NoSuchMethodError e) {
-            logger.error("No definition of this method : " + e.getMessage());
+        } catch (NoSuchMethodError | SecurityException e) {
+            logger.warn("Could not create an instance of SecurityManager: " + e.getMessage());
         }
         if (classContext != null) {
             for (int j = 0; j < classContext.length; j++) {

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -260,7 +260,7 @@ public static ClassProperties loadProperties(Class cls, Properties properties, b
     public static Class getCallerClass(int i) {
         Class[] classContext = null;
         try {
-            new SecurityManager() {
+            classContext = new SecurityManager() {
                 @Override public Class[] getClassContext() {
                     return super.getClassContext();
                 }

File: src/main/java/org/bytedeco/javacpp/BytePointer.java
Patch:
@@ -77,7 +77,7 @@ public BytePointer(byte ... array) {
      */
     public BytePointer(ByteBuffer buffer) {
         super(buffer);
-        if (buffer != null && buffer.hasArray()) {
+        if (buffer != null && !buffer.isDirect() && buffer.hasArray()) {
             byte[] array = buffer.array();
             allocateArray(array.length - buffer.arrayOffset());
             put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -60,7 +60,7 @@ public CharPointer(char ... array) {
      */
     public CharPointer(CharBuffer buffer) {
         super(buffer);
-        if (buffer != null && buffer.hasArray()) {
+        if (buffer != null && !buffer.isDirect() && buffer.hasArray()) {
             char[] array = buffer.array();
             allocateArray(array.length - buffer.arrayOffset());
             put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -50,7 +50,7 @@ public DoublePointer(double ... array) {
      */
     public DoublePointer(DoubleBuffer buffer) {
         super(buffer);
-        if (buffer != null && buffer.hasArray()) {
+        if (buffer != null && !buffer.isDirect() && buffer.hasArray()) {
             double[] array = buffer.array();
             allocateArray(array.length - buffer.arrayOffset());
             put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -50,7 +50,7 @@ public FloatPointer(float ... array) {
      */
     public FloatPointer(FloatBuffer buffer) {
         super(buffer);
-        if (buffer != null && buffer.hasArray()) {
+        if (buffer != null && !buffer.isDirect() && buffer.hasArray()) {
             float[] array = buffer.array();
             allocateArray(array.length - buffer.arrayOffset());
             put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -60,7 +60,7 @@ public IntPointer(int ... array) {
      */
     public IntPointer(IntBuffer buffer) {
         super(buffer);
-        if (buffer != null && buffer.hasArray()) {
+        if (buffer != null && !buffer.isDirect() && buffer.hasArray()) {
             int[] array = buffer.array();
             allocateArray(array.length - buffer.arrayOffset());
             put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -561,8 +561,6 @@ public static File extractResource(URL resourceURL, File directoryOrFile,
             while ((length = is.read(buffer)) != -1) {
                 os.write(buffer, 0, length);
             }
-            is.close();
-            os.close();
         } catch (IOException e) {
             if (file != null && !fileExisted) {
                 file.delete();

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -50,7 +50,7 @@ public LongPointer(long ... array) {
      */
     public LongPointer(LongBuffer buffer) {
         super(buffer);
-        if (buffer != null && buffer.hasArray()) {
+        if (buffer != null && !buffer.isDirect() && buffer.hasArray()) {
             long[] array = buffer.array();
             allocateArray(array.length - buffer.arrayOffset());
             put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -50,7 +50,7 @@ public ShortPointer(short ... array) {
      */
     public ShortPointer(ShortBuffer buffer) {
         super(buffer);
-        if (buffer != null && buffer.hasArray()) {
+        if (buffer != null && !buffer.isDirect() && buffer.hasArray()) {
             short[] array = buffer.array();
             allocateArray(array.length - buffer.arrayOffset());
             put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -932,7 +932,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("        this->sharedPtr = owner != NULL && owner != ptr ? *(S*)owner : S((T*)ptr);");
             out.println("    }");
             out.println("    static void deallocate(void* owner) { delete (S*)owner; }");
-            out.println("    operator T*() {");
+            out.println("    operator typename SHARED_PTR_NAMESPACE::remove_const<T>::type*() {");
             out.println("        ptr = sharedPtr.get();");
             out.println("        if (owner == NULL || owner == ptr) {");
             out.println("            owner = new S(sharedPtr);");
@@ -967,7 +967,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
             out.println("        this->uniquePtr = owner != NULL && owner != ptr ? *(U*)owner : U((T*)ptr);");
             out.println("    }");
             out.println("    static void deallocate(void* owner) { delete (U*)owner; }");
-            out.println("    operator T*() {");
+            out.println("    operator typename UNIQUE_PTR_NAMESPACE::remove_const<T>::type*() {");
             out.println("        ptr = uniquePtr.get();");
             out.println("        if (owner == NULL || owner == ptr) {");
             out.println("            owner = new U(UNIQUE_PTR_NAMESPACE::move(uniquePtr));");

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -546,6 +546,9 @@ protected <P extends Pointer> P deallocator(Deallocator deallocator) {
                 try {
                     while (count++ < maxRetries && ((maxBytes > 0 && DeallocatorReference.totalBytes + r.bytes > maxBytes)
                                          || (maxPhysicalBytes > 0 && (lastPhysicalBytes = physicalBytes()) > maxPhysicalBytes))) {
+                        if (logger.isDebugEnabled()) {
+                            logger.debug("Calling System.gc() in " + this);
+                        }
                         // try to get some more memory back
                         System.gc();
                         Thread.sleep(100);

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -512,7 +512,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("static inline jint JavaCPP_totalProcessors() {");
         out.println("    jint total = 0;");
         out.println("#ifdef __linux__");
-        out.println("    total = get_nprocs_conf();");
+        out.println("    total = sysconf(_SC_NPROCESSORS_CONF);");
         out.println("#elif defined(__APPLE__)");
         out.println("    size_t length = sizeof(total);");
         out.println("    sysctlbyname(\"hw.logicalcpu_max\", &total, &length, NULL, 0);");
@@ -527,7 +527,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("static inline jint JavaCPP_totalCores() {");
         out.println("    jint total = 0;");
         out.println("#ifdef __linux__");
-        out.println("    const int n = get_nprocs_conf();");
+        out.println("    const int n = sysconf(_SC_NPROCESSORS_CONF);");
         out.println("    int pids[n], cids[n];");
         out.println("    for (int i = 0; i < n; i++) {");
         out.println("        int fd = 0, pid = 0, cid = 0;");
@@ -586,7 +586,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("static inline jint JavaCPP_totalChips() {");
         out.println("    jint total = 0;");
         out.println("#ifdef __linux__");
-        out.println("    const int n = get_nprocs_conf();");
+        out.println("    const int n = sysconf(_SC_NPROCESSORS_CONF);");
         out.println("    int pids[n];");
         out.println("    for (int i = 0; i < n; i++) {");
         out.println("        int fd = 0, pid = 0;");

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -344,7 +344,7 @@ int compile(String sourceFilename, String outputFilename, ClassProperties proper
      * @throws InterruptedException
      */
     File generateAndCompile(Class[] classes, String outputName) throws IOException, InterruptedException {
-        File outputFile = null, outputPath = outputDirectory;
+        File outputFile = null, outputPath = outputDirectory != null ? outputDirectory.getCanonicalFile() : null;
         ClassProperties p = Loader.loadProperties(classes, properties, true);
         String platform     = p.getProperty("platform");
         String sourcePrefix = new File(outputPath, outputName).getPath();

File: src/main/java/org/bytedeco/javacpp/BoolPointer.java
Patch:
@@ -49,8 +49,8 @@ public BoolPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new BoolPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new BoolPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/BytePointer.java
Patch:
@@ -99,8 +99,8 @@ public BytePointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new BytePointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new BytePointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/CLongPointer.java
Patch:
@@ -50,8 +50,8 @@ public CLongPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new CLongPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new CLongPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -82,8 +82,8 @@ public CharPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new CharPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new CharPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -72,8 +72,8 @@ public DoublePointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new DoublePointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new DoublePointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -72,8 +72,8 @@ public FloatPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new FloatPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new FloatPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -82,8 +82,8 @@ public IntPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new IntPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new IntPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -72,8 +72,8 @@ public LongPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new LongPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new LongPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/PointerPointer.java
Patch:
@@ -122,8 +122,8 @@ public PointerPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new PointerPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new PointerPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -72,8 +72,8 @@ public ShortPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new ShortPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new ShortPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/SizeTPointer.java
Patch:
@@ -49,8 +49,8 @@ public SizeTPointer(long size) {
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         } catch (OutOfMemoryError e) {
-            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new SizeTPointer(" + size + "), "
-                    + "totalBytes = " + totalBytes() + ", physicalBytes = " + physicalBytes());
+            OutOfMemoryError e2 = new OutOfMemoryError("Cannot allocate new SizeTPointer(" + size + "): "
+                    + "totalBytes = " + formatBytes(totalBytes()) + ", physicalBytes = " + formatBytes(physicalBytes()));
             e2.initCause(e);
             throw e2;
         }

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -800,9 +800,11 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         }
         if (!functions.isEmpty() || !virtualFunctions.isEmpty()) {
             out.println("static JavaCPP_noinline void JavaCPP_detach(bool detach) {");
+            out.println("#ifndef NO_JNI_DETACH_THREAD");
             out.println("    if (detach && JavaCPP_vm->DetachCurrentThread() != JNI_OK) {");
             out.println("        JavaCPP_log(\"Could not detach the JavaVM from the current thread.\");");
             out.println("    }");
+            out.println("#endif");
             out.println("}");
             out.println();
             out.println("static JavaCPP_noinline bool JavaCPP_getEnv(JNIEnv** env) {");

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -48,10 +48,11 @@ class Token implements Comparable<Token> {
             SYMBOL     = 6;
 
     static final Token
-            EOF       = new Token(),
+            EOF       = new Token(-1, "EOF"),
             AUTO      = new Token(IDENTIFIER, "auto"),
             CONST     = new Token(IDENTIFIER, "const"),
             CONSTEXPR = new Token(IDENTIFIER, "constexpr"),
+            DECLTYPE  = new Token(IDENTIFIER, "decltype"),
             DEFAULT   = new Token(IDENTIFIER, "default"),
             DEFINE    = new Token(IDENTIFIER, "define"),
             IF        = new Token(IDENTIFIER, "if"),

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2560,9 +2560,9 @@ static Method[] functionMethods(Class<?> cls, boolean[] callbackAllocators) {
             } else if (methodName.startsWith("call") || methodName.startsWith("apply")) {
                 // found a function caller method and/or callback method
                 functionMethods[0] = methods[i];
-            } else if (methodName.startsWith("get")) {
+            } else if (methodName.startsWith("get") && Modifier.isNative(modifiers)) {
                 functionMethods[1] = methods[i];
-            } else if (methodName.startsWith("put")) {
+            } else if (methodName.startsWith("put") && Modifier.isNative(modifiers)) {
                 functionMethods[2] = methods[i];
             }
         }

File: src/main/java/org/bytedeco/javacpp/tools/AdapterInformation.java
Patch:
@@ -29,6 +29,6 @@
 class AdapterInformation {
     String name;
     int argc;
-    String cast;
+    String cast, cast2;
     boolean constant;
 }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1741,7 +1741,7 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
                 if (type.virtual && context.virtualize) {
                     break;
                 }
-            } else if (found && n / 2 > 0 && n % 2 == 0) {
+            } else if (found && n / 2 > 0 && n % 2 == 0 && n / 2 > Math.max(dcl.infoNumber, dcl.parameters.infoNumber)) {
                 break;
             }
             prevDcl.add(dcl);

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1707,8 +1707,8 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
                 decl.text += "@Namespace(\"" + context.namespace + "\") ";
             }
             if (type.constructor && params != null) {
-                decl.text += "public " + type.annotations + context.shorten(context.javaName) + dcl.parameters.list + " { super((Pointer)null); allocate" + params.names + "; }\n" +
-                             "private native void allocate" + dcl.parameters.list + ";\n";
+                decl.text += "public " + context.shorten(context.javaName) + dcl.parameters.list + " { super((Pointer)null); allocate" + params.names + "; }\n" +
+                             "private native " + type.annotations + "void allocate" + dcl.parameters.list + ";\n";
             } else {
                 decl.text += modifiers + type.annotations + context.shorten(type.javaName) + " " + dcl.javaName + dcl.parameters.list + ";\n";
             }

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -418,7 +418,7 @@ public static long maxPhysicalBytes() {
 
     /** Returns the amount of physical memory currently used by the whole process, or 0 if unknown.
      * Also known as "resident set size" (Linux, Mac OS X, etc) or "working set size" (Windows). */
-    @Name("JavaCPP_physicalBytes") public static native long physicalBytes();
+    @Name("JavaCPP_physicalBytes") public static synchronized native long physicalBytes();
 
     /** The native address of this Pointer, which can be an array. */
     protected long address = 0;

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -3178,7 +3178,8 @@ static String cppScopeName(Class<?> type) {
                 }
                 spaceName += s;
             }
-            if (scopeName.length() > 0 && !spaceName.endsWith("::")) {
+            if (scopeName.length() > 0 && !scopeName.startsWith("class ") && !scopeName.startsWith("struct ")
+                    && !scopeName.startsWith("union ") && !spaceName.endsWith("::")) {
                 spaceName += "::";
             }
             scopeName = spaceName + scopeName;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -42,7 +42,8 @@ public class InfoMap extends HashMap<String,List<Info>> {
     InfoMap parent = null;
     static final InfoMap defaults = new InfoMap(null)
         .put(new Info("basic/containers").cppTypes("std::bitset", "std::deque", "std::list", "std::map", "std::queue", "std::set",
-                                                   "std::stack", "std::vector", "std::valarray", "std::pair"))
+                                                   "std::stack", "std::vector", "std::valarray", "std::pair", "std::forward_list",
+                                                   "std::priority_queue", "std::unordered_map", "std::unordered_set"))
         .put(new Info("basic/types").cppTypes("signed", "unsigned", "char", "short", "int", "long", "bool", "float", "double"))
 
         .put(new Info(" __attribute__", "__declspec").annotations().skip())

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -70,6 +70,7 @@ public class Loader {
         String osName  = System.getProperty("os.name", "").toLowerCase();
         String osArch  = System.getProperty("os.arch", "").toLowerCase();
         String abiType = System.getProperty("sun.arch.abi", "").toLowerCase();
+        String libPath = System.getProperty("sun.boot.library.path", "").toLowerCase();
         if (jvmName.startsWith("dalvik") && osName.startsWith("linux")) {
             osName = "android";
         } else if (jvmName.startsWith("robovm") && osName.startsWith("darwin")) {
@@ -89,9 +90,9 @@ public class Loader {
             osArch = "x86_64";
         } else if (osArch.startsWith("aarch64") || osArch.startsWith("armv8") || osArch.startsWith("arm64")) {
             osArch = "arm64";
-        } else if ((osArch.startsWith("arm")) && abiType.equals("gnueabihf")) {
+        } else if ((osArch.startsWith("arm")) && ((abiType.equals("gnueabihf")) || (libPath.contains("openjdk-armhf")))) {
             osArch = "armhf";
-	} else if (osArch.startsWith("arm")) {
+        } else if (osArch.startsWith("arm")) {
             osArch = "arm";
         }
         PLATFORM = osName + "-" + osArch;

File: src/test/java/org/bytedeco/javacpp/PointerTest.java
Patch:
@@ -46,7 +46,7 @@
 @Platform(define = {"NATIVE_ALLOCATOR malloc", "NATIVE_DEALLOCATOR free"})
 public class PointerTest {
 
-    static long maxBytes = 1000000000;
+    static long maxBytes = 1024 * 1024 * 1024; /* 1g */
 
     @BeforeClass public static void setUpClass() throws Exception {
         Class c = PointerTest.class;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -86,6 +86,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("wchar_t", "WCHAR").cast().valueTypes("char").pointerTypes("CharPointer"))
         .put(new Info("const char").valueTypes("byte").pointerTypes("@Cast(\"const char*\") BytePointer", "String"))
         .put(new Info("boost::shared_ptr", "std::shared_ptr").annotations("@SharedPtr"))
+        .put(new Info("boost::movelib::unique_ptr", "std::unique_ptr").annotations("@UniquePtr"))
         .put(new Info("std::string").annotations("@StdString").valueTypes("BytePointer", "String"))
         .put(new Info("std::vector").annotations("@StdVector"))
 

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1466,8 +1466,7 @@ Parameters parameters(Context context, int infoNumber, boolean useDefaults) thro
                 }
                 if (n >= 0) {
                     s = s.substring(0, n + 6) + "(nullValue = \""
-                            + defaultValue.replaceAll("\n(\\s*)", "\"\n$1 + \"")
-                                          .replaceAll("\"", "\\\\\"") + "\")" + s.substring(n + 6);
+                            + defaultValue.replaceAll("\"", "\\\\\"").replaceAll("\n(\\s*)", "\"\n$1 + \"") + "\")" + s.substring(n + 6);
                 }
                 dcl.type.annotations = s;
             }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -2178,7 +2178,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
             return false;
         }
 
-        tokens.next().expect(Token.IDENTIFIER, '{');
+        tokens.next().expect(Token.IDENTIFIER, '{', "::");
         if (!tokens.get().match('{') && tokens.get(1).match(Token.IDENTIFIER)
                 && (typedef || !tokens.get(2).match(';'))) {
             tokens.next();

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -2178,7 +2178,7 @@ boolean group(Context context, DeclarationList declList) throws ParserException
             return false;
         }
 
-        tokens.next().expect(Token.IDENTIFIER, '{');
+        tokens.next().expect(Token.IDENTIFIER, '{', "::");
         if (!tokens.get().match('{') && tokens.get(1).match(Token.IDENTIFIER)
                 && (typedef || !tokens.get(2).match(';'))) {
             tokens.next();

File: src/main/java/org/bytedeco/javacpp/indexer/Indexable.java
Patch:
@@ -41,6 +41,7 @@ public interface Indexable {
      * @param direct a hint for the implementation, leaving the choice up to the user, since
      *               buffers are slower than arrays on Android, but not with OpenJDK, for example
      * @return a concrete {@link Indexer}
+     * @throws NullPointerException when there is no data
      */
     <I extends Indexer> I createIndexer(boolean direct);
 }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1466,7 +1466,8 @@ Parameters parameters(Context context, int infoNumber, boolean useDefaults) thro
                 }
                 if (n >= 0) {
                     s = s.substring(0, n + 6) + "(nullValue = \""
-                            + defaultValue.replaceAll("\n(\\s*)", "\"\n$1 + \"") + "\")" + s.substring(n + 6);
+                            + defaultValue.replaceAll("\n(\\s*)", "\"\n$1 + \"")
+                                          .replaceAll("\"", "\\\\\"") + "\")" + s.substring(n + 6);
                 }
                 dcl.type.annotations = s;
             }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -914,7 +914,7 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
         if (tokens.get().match(':')) {
             // ignore bitfields
             type.annotations += "@NoOffset ";
-            tokens.next().expect(Token.INTEGER);
+            tokens.next().expect(Token.INTEGER, Token.IDENTIFIER);
             tokens.next().expect(',', ';');
         }
 

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -538,7 +538,7 @@ public static URL[] findLibrary(Class cls, ClassProperties properties, String li
         String version2 = s2.length > 1 ? s2[s2.length-1] : "";
 
         // If we do not already have the native library file ...
-        String filename = loadedLibraries.get(libnameversion);
+        String filename = loadedLibraries.get(libnameversion2);
         if (filename != null) {
             try {
                 return new URL[] { new File(filename).toURI().toURL() };

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -30,6 +30,7 @@
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import org.bytedeco.javacpp.annotation.Platform;
 import org.bytedeco.javacpp.tools.Generator;
 import org.bytedeco.javacpp.tools.Logger;
 
@@ -58,6 +59,7 @@
  *
  * @author Samuel Audet
  */
+@Platform
 public class Pointer implements AutoCloseable {
     /** Default constructor that does nothing. */
     public Pointer() {}

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1044,7 +1044,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, boolean conver
         out.println("}");
         out.println();
 
-        List<Class> allClasses = new ArrayList<Class>();
+        LinkedHashSet<Class> allClasses = new LinkedHashSet<Class>();
         allClasses.addAll(baseClasses);
         allClasses.addAll(Arrays.asList(classes));
 

File: src/test/java/org/bytedeco/javacpp/PointerTest.java
Patch:
@@ -43,11 +43,9 @@
 @Platform(define = {"NATIVE_ALLOCATOR malloc", "NATIVE_DEALLOCATOR free"})
 public class PointerTest {
 
-    static long maxBytes = Runtime.getRuntime().maxMemory() - 1;
+    static long maxBytes = 1000000000;
 
     @BeforeClass public static void setUpClass() throws Exception {
-        System.setProperty("org.bytedeco.javacpp.maxbytes", Long.toString(maxBytes));
-        System.setProperty("org.bytedeco.javacpp.maxretries", "3");
         Class c = PointerTest.class;
         Builder builder = new Builder().classesOrPackages(c.getName());
         File[] outputFiles = builder.build();

File: src/main/java/org/bytedeco/javacpp/indexer/ByteArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class ByteArrayIndexer extends ByteIndexer {
 
     /** Calls {@code ByteArrayIndexer(array, { array.length }, { 1 })}. */
     public ByteArrayIndexer(byte[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/ByteBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class ByteBufferIndexer extends ByteIndexer {
 
     /** Calls {@code ByteBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public ByteBufferIndexer(ByteBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/ByteIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static ByteIndexer create(ByteBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static ByteIndexer create(BytePointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new ByteArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/ByteRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class ByteRawIndexer extends ByteIndexer {
 
     /** Calls {@code ByteRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public ByteRawIndexer(BytePointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/CharArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class CharArrayIndexer extends CharIndexer {
 
     /** Calls {@code CharArrayIndexer(array, { array.length }, { 1 })}. */
     public CharArrayIndexer(char[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/CharBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class CharBufferIndexer extends CharIndexer {
 
     /** Calls {@code CharBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public CharBufferIndexer(CharBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/CharIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static CharIndexer create(CharBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static CharIndexer create(CharPointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new CharArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/CharRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class CharRawIndexer extends CharIndexer {
 
     /** Calls {@code CharRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public CharRawIndexer(CharPointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/DoubleArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class DoubleArrayIndexer extends DoubleIndexer {
 
     /** Calls {@code DoubleArrayIndexer(array, { array.length }, { 1 })}. */
     public DoubleArrayIndexer(double[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/DoubleBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class DoubleBufferIndexer extends DoubleIndexer {
 
     /** Calls {@code DoubleBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public DoubleBufferIndexer(DoubleBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/DoubleIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static DoubleIndexer create(DoubleBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static DoubleIndexer create(DoublePointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new DoubleArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/DoubleRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class DoubleRawIndexer extends DoubleIndexer {
 
     /** Calls {@code DoubleRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public DoubleRawIndexer(DoublePointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/FloatArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class FloatArrayIndexer extends FloatIndexer {
 
     /** Calls {@code FloatArrayIndexer(array, { array.length }, { 1 })}. */
     public FloatArrayIndexer(float[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/FloatBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class FloatBufferIndexer extends FloatIndexer {
 
     /** Calls {@code FloatBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public FloatBufferIndexer(FloatBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/FloatIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static FloatIndexer create(FloatBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static FloatIndexer create(FloatPointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new FloatArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/FloatRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class FloatRawIndexer extends FloatIndexer {
 
     /** Calls {@code FloatRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public FloatRawIndexer(FloatPointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/Indexer.java
Patch:
@@ -49,6 +49,8 @@ public abstract class Indexer implements AutoCloseable {
         release();
     }
 
+    protected static final long[] ONE_STRIDE = { 1 };
+
     /**
      * The number of elements in each dimension.
      * These values are not typically used by the indexer.

File: src/main/java/org/bytedeco/javacpp/indexer/IntArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class IntArrayIndexer extends IntIndexer {
 
     /** Calls {@code IntArrayIndexer(array, { array.length }, { 1 })}. */
     public IntArrayIndexer(int[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/IntBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class IntBufferIndexer extends IntIndexer {
 
     /** Calls {@code IntBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public IntBufferIndexer(IntBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/IntIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static IntIndexer create(IntBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static IntIndexer create(IntPointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new IntArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/IntRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class IntRawIndexer extends IntIndexer {
 
     /** Calls {@code IntRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public IntRawIndexer(IntPointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/LongArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class LongArrayIndexer extends LongIndexer {
 
     /** Calls {@code LongArrayIndexer(array, { array.length }, { 1 })}. */
     public LongArrayIndexer(long[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/LongBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class LongBufferIndexer extends LongIndexer {
 
     /** Calls {@code LongBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public LongBufferIndexer(LongBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/LongIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static LongIndexer create(LongBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static LongIndexer create(LongPointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new LongArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/LongRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class LongRawIndexer extends LongIndexer {
 
     /** Calls {@code LongRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public LongRawIndexer(LongPointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/ShortArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class ShortArrayIndexer extends ShortIndexer {
 
     /** Calls {@code ShortArrayIndexer(array, { array.length }, { 1 })}. */
     public ShortArrayIndexer(short[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/ShortBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class ShortBufferIndexer extends ShortIndexer {
 
     /** Calls {@code ShortBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public ShortBufferIndexer(ShortBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/ShortIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static ShortIndexer create(ShortBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static ShortIndexer create(ShortPointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new ShortArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/ShortRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class ShortRawIndexer extends ShortIndexer {
 
     /** Calls {@code ShortRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public ShortRawIndexer(ShortPointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/UByteArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class UByteArrayIndexer extends UByteIndexer {
 
     /** Calls {@code UByteArrayIndexer(array, { array.length }, { 1 })}. */
     public UByteArrayIndexer(byte[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/UByteBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class UByteBufferIndexer extends UByteIndexer {
 
     /** Calls {@code UByteBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public UByteBufferIndexer(ByteBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/UByteIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static UByteIndexer create(ByteBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static UByteIndexer create(BytePointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new ByteArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/UByteRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class UByteRawIndexer extends UByteIndexer {
 
     /** Calls {@code UByteRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public UByteRawIndexer(BytePointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/UShortArrayIndexer.java
Patch:
@@ -33,7 +33,7 @@ public class UShortArrayIndexer extends UShortIndexer {
 
     /** Calls {@code UShortArrayIndexer(array, { array.length }, { 1 })}. */
     public UShortArrayIndexer(short[] array) {
-        this(array, new long[] { array.length }, new long[] { 1 });
+        this(array, new long[] { array.length }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #array}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/UShortBufferIndexer.java
Patch:
@@ -36,7 +36,7 @@ public class UShortBufferIndexer extends UShortIndexer {
 
     /** Calls {@code UShortBufferIndexer(buffer, { buffer.limit() }, { 1 })}. */
     public UShortBufferIndexer(ShortBuffer buffer) {
-        this(buffer, new long[] { buffer.limit() }, new long[] { 1 });
+        this(buffer, new long[] { buffer.limit() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #buffer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/indexer/UShortIndexer.java
Patch:
@@ -48,7 +48,7 @@ public static UShortIndexer create(ShortBuffer buffer) {
     }
     /** Returns {@code create(pointer, { pointer.limit() - pointer.position() }, { 1 }, true)} */
     public static UShortIndexer create(ShortPointer pointer) {
-        return create(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        return create(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Returns {@code new ShortArrayIndexer(array, sizes, strides)} */

File: src/main/java/org/bytedeco/javacpp/indexer/UShortRawIndexer.java
Patch:
@@ -40,7 +40,7 @@ public class UShortRawIndexer extends UShortIndexer {
 
     /** Calls {@code UShortRawIndexer(pointer, { pointer.limit() - pointer.position() }, { 1 })}. */
     public UShortRawIndexer(ShortPointer pointer) {
-        this(pointer, new long[] { pointer.limit() - pointer.position() }, new long[] { 1 });
+        this(pointer, new long[] { pointer.limit() - pointer.position() }, ONE_STRIDE);
     }
 
     /** Constructor to set the {@link #pointer}, {@link #sizes} and {@link #strides}. */

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -129,6 +129,9 @@ public static Properties loadProperties() {
      * @return the Properties from resources
      */
     public static Properties loadProperties(String name, String defaults) {
+        if (defaults == null) {
+            defaults = "generic";
+        }
         Properties p = new Properties();
         p.put("platform", name);
         p.put("platform.path.separator", File.pathSeparator);

File: src/main/java/org/bytedeco/javacpp/BoolPointer.java
Patch:
@@ -43,6 +43,9 @@ public class BoolPointer extends Pointer {
     public BoolPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new BoolPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/BytePointer.java
Patch:
@@ -93,6 +93,9 @@ public BytePointer(ByteBuffer buffer) {
     public BytePointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new BytePointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/CLongPointer.java
Patch:
@@ -44,6 +44,9 @@ public class CLongPointer extends Pointer {
     public CLongPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new CLongPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -76,6 +76,9 @@ public CharPointer(CharBuffer buffer) {
     public CharPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new CharPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -66,6 +66,9 @@ public DoublePointer(DoubleBuffer buffer) {
     public DoublePointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new DoublePointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -66,6 +66,9 @@ public FloatPointer(FloatBuffer buffer) {
     public FloatPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new FloatPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -76,6 +76,9 @@ public IntPointer(IntBuffer buffer) {
     public IntPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new IntPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -66,6 +66,9 @@ public LongPointer(LongBuffer buffer) {
     public LongPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new LongPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/PointerPointer.java
Patch:
@@ -116,6 +116,9 @@ public PointerPointer(String[] array, String charsetName) throws UnsupportedEnco
     public PointerPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new PointerPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -66,6 +66,9 @@ public ShortPointer(ShortBuffer buffer) {
     public ShortPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new ShortPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/SizeTPointer.java
Patch:
@@ -43,6 +43,9 @@ public class SizeTPointer extends Pointer {
     public SizeTPointer(long size) {
         try {
             allocateArray(size);
+            if (size > 0 && address == 0) {
+                throw new OutOfMemoryError("Cannot allocate new SizeTPointer(" + size + ")");
+            }
         } catch (UnsatisfiedLinkError e) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }

File: src/main/java/org/bytedeco/javacpp/tools/TemplateMap.java
Patch:
@@ -35,6 +35,7 @@ class TemplateMap extends LinkedHashMap<String,Type> {
     Type type = null;
     Declarator declarator = null;
     TemplateMap parent = null;
+    boolean variadic = false;
 
     String getName() {
         return type != null ? type.cppName : declarator != null ? declarator.cppName : null;

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -710,6 +710,9 @@ public File[] build() throws IOException, InterruptedException, ParserException
             }
             createJar(jarFile, outputDirectory == null ? classScanner.getClassLoader().getPaths() : null, files);
         }
+
+        // reset the load flag to let users load compiled libraries
+        System.setProperty("org.bytedeco.javacpp.loadlibraries", "true");
         return files;
     }
 

File: src/test/java/org/bytedeco/javacpp/AdapterTest.java
Patch:
@@ -73,7 +73,6 @@ static class SharedData extends Pointer {
         Class c = AdapterTest.class;
         Builder builder = new Builder().classesOrPackages(c.getName());
         File[] outputFiles = builder.build();
-        Loader.loadLibraries = true;
         Loader.load(c);
     }
 

File: src/test/java/org/bytedeco/javacpp/IndexerTest.java
Patch:
@@ -51,7 +51,6 @@ public class IndexerTest {
         Class c = IndexerTest.class;
         Builder builder = new Builder().classesOrPackages(c.getName());
         File[] outputFiles = builder.build();
-        Loader.loadLibraries = true;
         Loader.load(c);
 
         // work around OutOfMemoryError when testing long indexing

File: src/test/java/org/bytedeco/javacpp/PointerTest.java
Patch:
@@ -47,7 +47,6 @@ public class PointerTest {
         Class c = PointerTest.class;
         Builder builder = new Builder().classesOrPackages(c.getName());
         File[] outputFiles = builder.build();
-        Loader.loadLibraries = true;
         Loader.load(c);
     }
 

File: src/main/java/org/bytedeco/javacpp/tools/Info.java
Patch:
@@ -68,7 +68,7 @@ public Info(Info i) {
     String[] javaNames = null;
     /** Additional Java annotations that should prefix the identifiers on output. */
     String[] annotations = null;
-    /** A list of C++ types that supply information missing from macros, templates, etc.
+    /** A list of C++ types to supply to or substitute from macros, templates, typedefs, etc.
      * By default, identifiers with missing type information are skipped, except for
      * variable-like macros for which the type is guessed based on the expression. */
     String[] cppTypes = null;

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -551,10 +551,10 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, String classPa
             out.println("        this->owner = owner;");
             out.println("        vec.assign(ptr, ptr + size);");
             out.println("    }");
-            out.println("    static void deallocate(void* owner) { delete[] (P*)owner; }");
+            out.println("    static void deallocate(void* owner) { operator delete(owner); }");
             out.println("    operator P*() {");
             out.println("        if (vec.size() > size) {");
-            out.println("            ptr = new (std::nothrow) P[vec.size()];");
+            out.println("            ptr = (P*)(operator new(sizeof(P) * vec.size(), std::nothrow_t()));");
             out.println("        }");
             out.println("        if (ptr) {");
             out.println("            std::copy(vec.begin(), vec.end(), ptr);");

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -134,7 +134,9 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("address").javaNames("_address"))
         .put(new Info("position").javaNames("_position"))
         .put(new Info("limit").javaNames("_limit"))
-        .put(new Info("capacity").javaNames("_capacity"));
+        .put(new Info("capacity").javaNames("_capacity"))
+        .put(new Info("fill").javaNames("_fill"))
+        .put(new Info("zero").javaNames("_zero"));
 
     String normalize(String name, boolean unconst, boolean untemplate) {
         if (name == null || name.length() == 0 || name.startsWith("basic/")) {

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -51,6 +51,7 @@ class Token implements Comparable<Token> {
             EOF       = new Token(),
             CONST     = new Token(IDENTIFIER, "const"),
             CONSTEXPR = new Token(IDENTIFIER, "constexpr"),
+            DEFAULT   = new Token(IDENTIFIER, "default"),
             DEFINE    = new Token(IDENTIFIER, "define"),
             IF        = new Token(IDENTIFIER, "if"),
             IFDEF     = new Token(IDENTIFIER, "ifdef"),

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -381,6 +381,9 @@ Type[] templateArguments(Context context) throws ParserException {
                         count--;
                     }
                     type.cppName += token;
+                    if (token.match(Token.CONST)) {
+                        type.cppName += " ";
+                    }
                 }
                 if (type.cppName.endsWith("*")) {
                     type.javaName = "PointerPointer";

File: src/main/java/org/bytedeco/javacpp/tools/BuildMojo.java
Patch:
@@ -23,6 +23,7 @@
 package org.bytedeco.javacpp.tools;
 
 import java.io.File;
+import java.io.IOException;
 import java.util.Arrays;
 import java.util.Map;
 import java.util.Properties;
@@ -226,7 +227,7 @@ String[] merge(String[] ss, String s) {
             if (log.isDebugEnabled()) {
                 log.debug("outputFiles: " + Arrays.deepToString(outputFiles));
             }
-        } catch (Exception e) {
+        } catch (IOException | ClassNotFoundException | NoClassDefFoundError | InterruptedException | ParserException e) {
             log.error("Failed to execute JavaCPP Builder: " + e.getMessage());
             throw new MojoExecutionException("Failed to execute JavaCPP Builder", e);
         }

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2014 Samuel Audet
+ * Copyright (C) 2011-2016 Samuel Audet
  *
  * Licensed either under the Apache License, Version 2.0, or (at your option)
  * under the terms of the GNU General Public License as published by
@@ -575,7 +575,7 @@ public Builder property(String key, String value) {
     }
     /** Requests the {@link #classScanner} to add a class or all classes from a package.
      *  A {@code null} argument indicates the unnamed package. */
-    public Builder classesOrPackages(String ... classesOrPackages) throws IOException {
+    public Builder classesOrPackages(String ... classesOrPackages) throws IOException, ClassNotFoundException, NoClassDefFoundError {
         if (classesOrPackages == null) {
             classScanner.addPackage(null, true);
         } else for (String s : classesOrPackages) {
@@ -703,7 +703,7 @@ public static void printHelp() {
         }
         System.out.println(
             "JavaCPP version " + version + "\n" +
-            "Copyright (C) 2011-2015 Samuel Audet <samuel.audet@gmail.com>\n" +
+            "Copyright (C) 2011-2016 Samuel Audet <samuel.audet@gmail.com>\n" +
             "Project site: https://github.com/bytedeco/javacpp");
         System.out.println();
         System.out.println("Usage: java -jar javacpp.jar [options] [class or package (suffixed with .* or .**)]");

File: src/main/java/org/bytedeco/javacpp/tools/Context.java
Patch:
@@ -79,8 +79,8 @@ String[] qualify(String cppName) {
             while (map != null) {
                 if (name.equals(map.getName())) {
                     String args = "<", separator = "";
-                    for (String s : map.values()) {
-                        args += separator + s;
+                    for (Type t : map.values()) {
+                        args += separator + (t != null ? t.cppName : t);
                         separator = ",";
                     }
                     names.add(name + args + (args.endsWith(">") ? " >" : ">"));

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -444,7 +444,9 @@ public int offsetof(String member) {
             if (c != Pointer.class) {
                 offset = Loader.offsetof(c, member);
             }
-        } catch (NullPointerException e) { }
+        } catch (NullPointerException e) {
+            return offset;
+        }
         return offset;
     }
 

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -367,7 +367,7 @@ public static File getCacheDir() {
     public static File getTempDir() {
         if (tempDir == null) {
             File tmpdir = new File(System.getProperty("java.io.tmpdir"));
-            File f = null;
+            File f;
             for (int i = 0; i < 1000; i++) {
                 f = new File(tmpdir, "javacpp" + System.nanoTime());
                 if (f.mkdir()) {

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -286,7 +286,7 @@ final void remove() {
 
     /** Clears, deallocates, and removes all garbage collected objects from the {@link #referenceQueue}. */
     public static void deallocateReferences() {
-        DeallocatorReference r = null;
+        DeallocatorReference r;
         while (referenceQueue != null && (r = (DeallocatorReference)referenceQueue.poll()) != null) {
             r.clear();
             r.remove();

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2799,7 +2799,7 @@ String[] cppTypeName(Class<?> type) {
     }
 
     String[] cppFunctionTypeName(Method functionMethod) {
-        String prefix = "", suffix = "";
+        String prefix, suffix;
         Class<?> type = functionMethod.getDeclaringClass();
         Convention convention = type.getAnnotation(Convention.class);
         String callingConvention = convention == null ? "" : convention.value() + " ";

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -111,7 +111,7 @@ void containers(Context context, DeclarationList declList) throws ParserExceptio
                     continue;
                 }
                 int dim = containerName.startsWith("std::pair") ? 0 : 1;
-                boolean resizable = true;
+                boolean resizable;
                 Type containerType = new Parser(this, info.cppNames[0]).type(context),
                         indexType, valueType, firstType = null, secondType = null;
                 if (containerType.arguments == null || containerType.arguments.length == 0 || containerType.arguments[0] == null
@@ -1185,7 +1185,6 @@ String commentBefore() throws ParserException {
             comment += token.spacing + s;
         }
         if (closeComment && !comment.endsWith("*/")) {
-            closeComment = false;
             comment += " */";
         }
         tokens.raw = false;

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -705,7 +705,7 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
             count++;
         }
 
-        int dims[] = new int[256];
+        int[] dims = new int[256];
         int indirections2 = 0;
         dcl.cppName = "";
         Info groupInfo = null;

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -426,8 +426,6 @@ void createJar(File jarFile, String[] classPath, File ... files) throws IOExcept
             }
             fis.close();
             jos.closeEntry();
-//            f.delete();
-//            f.getParentFile().delete();
         }
         jos.close();
     }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -811,7 +811,6 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
                     dimCast += "[" + dims[i] + "]";
                 }
             }
-            //dcl.indices = 0;
             cast += dimCast.length() > 0 ? "(*)" + dimCast : "*";
         }
         if (pointerAsArray && dcl.indirections > (type.anonymous ? 0 : 1)) {
@@ -1581,7 +1580,6 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
             if (info != null && info.javaText != null) {
                 if (first) {
                     decl.text = info.javaText;
-//                    decl.declarator = null;
                 } else {
                     break;
                 }

File: src/main/java/org/bytedeco/javacpp/tools/MethodInformation.java
Patch:
@@ -35,7 +35,7 @@ public class MethodInformation {
     Annotation[] annotations;
     int modifiers;
     Class<?> returnType;
-    String name, memberName[];
+    String[] name, memberName;
     int dim;
     boolean[] parameterRaw;
     Class<?>[] parameterTypes;

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -698,7 +698,7 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
             count++;
         }
 
-        int dims[] = new int[256];
+        int[] dims = new int[256];
         int indirections2 = 0;
         dcl.cppName = "";
         Info groupInfo = null;

File: src/main/java/org/bytedeco/javacpp/annotation/Platform.java
Patch:
@@ -52,7 +52,8 @@
     String[] define()      default {};
     /** A list of C++ header files to include at the top of the generated code. */
     String[] include()     default {};
-    /** A list of C header files to include at the top of the generated code. */
+    /** A list of C header files to include at the top of the generated code. The
+     *  {@code #include} directives will be generated in a {@code extern "C" { } } block.*/
     String[] cinclude()    default {};
     /** A list of include paths passed to the native compiler. */
     String[] includepath() default {};

File: src/main/java/org/bytedeco/javacpp/tools/TokenIndexer.java
Patch:
@@ -210,6 +210,9 @@ Token[] expand(Token[] array, int index) {
                             }
                         }
                         if (!foundArg) {
+                            if (token.type == -1) {
+                                token.type = Token.COMMENT;
+                            }
                             tokens.add(token);
                         }
                         token = tokenizer.nextToken();

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -39,7 +39,8 @@
  * {@code struct}, {@code class}, or {@code union}. All Pointer classes get parsed
  * by {@link Generator} to produce proper wrapping JNI code, but this base class also
  * provides functionality to access native array elements as well as utility methods
- * and classes to let users benefit from garbage collection.
+ * and classes to let users benefit not only from from garbage collection, but also the
+ * try-with-resources statement, since it implements the {@link AutoCloseable} interface.
  * <p>
  * For examples of subclasses, please refer to the following:
  *

File: src/main/java/org/bytedeco/javacpp/indexer/Indexer.java
Patch:
@@ -97,7 +97,7 @@ public int index(int ... indices) {
     public Object array() { return null; }
     /** @return the backing buffer, or {@code null} if none */
     public Buffer buffer() { return null; }
-    /** Makes sure changes are reflected onto the backing memory and releases any references. */
+    /** Makes sure changes are reflected onto the backing memory and clears any references. */
     public abstract void release();
 
     /** Calls {@code get(int...indices)} and returns the value as a double. */

File: src/main/java/org/bytedeco/javacpp/tools/Info.java
Patch:
@@ -50,6 +50,7 @@ public Info(Info i) {
         pointerTypes = i.pointerTypes != null ? i.pointerTypes.clone() : null;
         cast = i.cast;
         define = i.define;
+        flatten = i.flatten;
         translate = i.translate;
         skip = i.skip;
         purify = i.purify;
@@ -81,7 +82,8 @@ public Info(Info i) {
     boolean cast = false;
     /** Indicates expressions of conditional macro groups to parse, or templates to specialize. */
     boolean define = false;
-    /** Outputs declarations for this class into their subclasses as well. */
+    /** Outputs declarations for this class into their subclasses as well.
+     * Also adds methods for explicit casting, as done for multiple inheritance by default. */
     boolean flatten = false;
     /** Attempts to translate naively the statements of variable-like macros to Java. */
     boolean translate = false;

File: src/main/java/org/bytedeco/javacpp/Loader.java
Patch:
@@ -563,8 +563,8 @@ public static String loadLibrary(URL[] urls, String libnameversion) {
                     // ... if the URL is not already a file ...
                     file = new File(url.toURI());
                 } catch (Exception e) {
-                    // ... then check if it's not already cached, and if not ...
-                    if (getCacheDir() == null || !(file = new File(getCacheDir(), new File(url.getPath()).getName())).exists()) {
+                    // ... then check if it has not already been extracted, and if not ...
+                    if (!(file = new File(getCacheDir() != null ? getCacheDir() : getTempDir(), new File(url.getPath()).getName())).exists()) {
                         if (tempFile != null && tempFile.exists()) {
                             tempFile.deleteOnExit();
                         }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1903,7 +1903,7 @@ boolean macro(Context context, DeclarationList declList) throws ParserException
             int n = spacing.lastIndexOf('\n') + 1;
             decl.text += "// " + spacing.substring(n) + "#" + keyword.spacing + keyword;
             for (Token token = tokens.get(); tokens.index < lastIndex; token = tokens.next()) {
-                decl.text += token.match("\n") ? "\n// " : token.spacing + token;
+                decl.text += token.match("\n") ? "\n// " : token.spacing + token.toString().replace("\n", "\n//");
             }
             spacing = spacing.substring(0, n);
         }

File: src/main/java/org/bytedeco/javacpp/tools/DeclarationList.java
Patch:
@@ -112,6 +112,7 @@ String rescan(String lines) {
             }
         }
 
+        add = false;
         while (!stack.isEmpty()) {
             decl = stack.remove(stack.size() - 1);
             if (context != null) {
@@ -148,8 +149,9 @@ String rescan(String lines) {
             if (!found) {
                 decl.text = rescan(decl.text);
                 super.add(decl);
+                add = true;
             }
         }
-        return true;
+        return add;
     }
 }

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1532,7 +1532,8 @@ void call(MethodInformation methodInfo, String returnPrefix, boolean secondCall)
                 }
                 out.print(cast + "adapter" + j);
                 j += adapterInfo.argc - 1;
-            } else if (FunctionPointer.class.isAssignableFrom(methodInfo.parameterTypes[j])) {
+            } else if (FunctionPointer.class.isAssignableFrom(methodInfo.parameterTypes[j])
+                    && !(passBy instanceof ByVal || passBy instanceof ByRef)) {
                 out.print(cast + "(ptr" + j + " == NULL ? NULL : " + (passBy instanceof ByPtrPtr ? "&ptr" : "ptr") + j + "->ptr)");
             } else if (passBy instanceof ByVal || (passBy instanceof ByRef &&
                     methodInfo.parameterTypes[j] != String.class)) {

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -47,6 +47,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
 
         .put(new Info(" __attribute__", "__declspec").annotations().skip())
         .put(new Info("void").valueTypes("void").pointerTypes("Pointer"))
+        .put(new Info("std::nullptr_t").valueTypes("Pointer").pointerTypes("PointerPointer"))
         .put(new Info("FILE", "time_t", "va_list", "std::exception", "std::istream", "std::ostream", "std::iostream",
                 "std::ifstream", "std::ofstream", "std::fstream").cast().pointerTypes("Pointer"))
 
@@ -81,7 +82,7 @@ public class InfoMap extends HashMap<String,List<Info>> {
         .put(new Info("long double").cast().valueTypes("double").pointerTypes("Pointer"))
         .put(new Info("std::complex<float>").cast().pointerTypes("FloatPointer", "FloatBuffer", "float[]"))
         .put(new Info("std::complex<double>").cast().pointerTypes("DoublePointer", "DoubleBuffer", "double[]"))
-        .put(new Info("bool", "jboolean").cast().valueTypes("boolean").pointerTypes("BoolPointer"))
+        .put(new Info("bool", "jboolean").cast().valueTypes("boolean").pointerTypes("BoolPointer", "boolean[]"))
         .put(new Info("wchar_t", "WCHAR").cast().valueTypes("char").pointerTypes("CharPointer"))
         .put(new Info("const char").valueTypes("byte").pointerTypes("@Cast(\"const char*\") BytePointer", "String"))
         .put(new Info("boost::shared_ptr", "std::shared_ptr").annotations("@SharedPtr"))

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2181,7 +2181,7 @@ void callback(Class<?> cls, Method callbackMethod, String callbackName, boolean
             } else if (returnBy instanceof ByVal || returnBy instanceof ByRef) {
                 out.println("    if (rptr == NULL) {");
                 out.println("        JavaCPP_log(\"Return pointer address is NULL in callback for " + cls.getCanonicalName() + ".\");");
-                out.println("        static " + returnValueTypeName + " empty" + returnTypeName[1] + ";");
+                out.println("        static " + returnConvention[0] + " empty" + returnTypeName[1] + ";");
                 out.println("        return empty;");
                 out.println("    } else {");
                 out.println("        return *" + callbackReturnCast + "rptr;");

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -34,7 +34,7 @@ class Type {
     boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
             destructor = false, operator = false, simple = false, staticMember = false,
             reference = false, value = false, friend = false, virtual = false;
-    String annotations = "", cppName = "", javaName = "";
+    String annotations = "", cppName = "", javaName = "", javaNames[] = null;
     Type[] arguments = null;
     Attribute[] attributes = null;
 

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -143,7 +143,7 @@ static String normalize(String name, boolean unconst, boolean untemplate) {
         Token[] tokens = new Tokenizer(name).tokenize();
         int n = tokens.length;
         for (int i = 0; i < n; i++) {
-            if (tokens[i].match(Token.CONST)) {
+            if (tokens[i].match(Token.CONST, Token.CONSTEXPR)) {
                 foundConst = true;
                 for (int j = i + 1; j < n; j++) {
                     tokens[j - 1] = tokens[j];

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -50,6 +50,7 @@ class Token implements Comparable<Token> {
     static final Token
             EOF       = new Token(),
             CONST     = new Token(IDENTIFIER, "const"),
+            CONSTEXPR = new Token(IDENTIFIER, "constexpr"),
             DEFINE    = new Token(IDENTIFIER, "define"),
             IF        = new Token(IDENTIFIER, "if"),
             IFDEF     = new Token(IDENTIFIER, "ifdef"),

File: src/main/java/org/bytedeco/javacpp/tools/Declaration.java
Patch:
@@ -29,6 +29,7 @@
 class Declaration {
     Type type = null;
     Declarator declarator = null;
-    boolean abstractMember = false, constMember = false, inaccessible = false, incomplete = false, variable = false;
+    boolean abstractMember = false, constMember = false, inaccessible = false,
+            incomplete = false, function = false, variable = false;
     String signature = "", text = "";
 }

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -238,8 +238,8 @@ private static class DeallocatorReference extends PhantomReference<Pointer> {
             this.deallocator = deallocator;
         }
 
-        static DeallocatorReference head = null;
-        DeallocatorReference prev = null, next = null;
+        static volatile DeallocatorReference head = null;
+        volatile DeallocatorReference prev = null, next = null;
         Deallocator deallocator;
 
         final void add() {

File: src/main/java/org/bytedeco/javacpp/tools/Info.java
Patch:
@@ -88,8 +88,7 @@ public Info(Info i) {
     boolean skip = false;
     /** Forces a class to be treated as if it were abstract. */
     boolean purify = false;
-    /** Annotates virtual functions with @{@link Virtual} and adds appropriate constructors.
-     * Also maps C++ classes with pure virtual functions to abstract Java classes. */
+    /** Annotates virtual functions with @{@link Virtual} and adds appropriate constructors. */
     boolean virtualize = false;
     /** Allows to override the base class of {@link #pointerTypes}. Defaults to {@link Pointer}. */
     String base = null;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -46,7 +46,7 @@ public class InfoMap extends HashMap<String,LinkedList<Info>> {
     static final InfoMap defaults = new InfoMap(null)
         .put(new Info(" __attribute__", "__declspec").annotations().skip())
         .put(new Info("void").valueTypes("void").pointerTypes("Pointer"))
-        .put(new Info("va_list", "FILE", "std::exception", "std::istream", "std::ostream", "std::iostream",
+        .put(new Info("FILE", "time_t", "va_list", "std::exception", "std::istream", "std::ostream", "std::iostream",
                 "std::ifstream", "std::ofstream", "std::fstream").cast().pointerTypes("Pointer"))
 
         .put(new Info("int8_t", "__int8", "jbyte", "signed char")

File: src/main/java/org/bytedeco/javacpp/tools/Logger.java
Patch:
@@ -31,7 +31,7 @@ public class Logger {
     /** If the "org.bytedeco.javacpp.logger" system property is set to "slf4j",
      *  returns new {@link Slf4jLogger#Slf4jLogger(Class)}, else returns new {@link #Logger()}. */
     public static Logger create(Class cls) {
-        String s = System.getProperty("org.bytedeco.javacpp.logger", "simple").toLowerCase();
+        String s = System.getProperty("org.bytedeco.javacpp.logger", "").toLowerCase();
         if (s.equals("slf4j") || s.equals("slf4jlogger")) {
             return new Slf4jLogger(cls);
         } else {

File: src/main/java/org/bytedeco/javacpp/annotation/Allocator.java
Patch:
@@ -21,7 +21,7 @@
  * the {@link Pointer#deallocator} with {@code NativeDeallocator}, based on the
  * {@code delete} operator, if not additionally annotated with {@link NoDeallocator}.
  *
- * @see Pointer#init(long, int, long)
+ * @see Pointer#init(long, int, long, long)
  * @see Generator
  *
  * @author Samuel Audet

File: src/main/java/org/bytedeco/javacpp/annotation/ArrayAllocator.java
Patch:
@@ -19,7 +19,7 @@
  * with {@code NativeDeallocator}, based on the {@code delete[]} operator, if
  * not additionally annotated with {@link NoDeallocator}.
  *
- * @see Pointer#init(long, int, long)
+ * @see Pointer#init(long, int, long, long)
  * @see Generator
  *
  * @author Samuel Audet

File: src/main/java/org/bytedeco/javacpp/tools/Builder.java
Patch:
@@ -437,7 +437,7 @@ void createJar(File jarFile, String[] classPath, File ... files) throws IOExcept
      * Default constructor that simply initializes everything.
      */
     public Builder() {
-        this(new Logger());
+        this(Logger.create(Builder.class));
     }
     /**
      * Constructor that simply initializes everything.

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -127,6 +127,7 @@ public class InfoMap extends HashMap<String,LinkedList<Info>> {
         .put(new Info("operator delete").javaNames("_delete"))
 
         .put(new Info("allocate").javaNames("_allocate"))
+        .put(new Info("close").javaNames("_close"))
         .put(new Info("deallocate").javaNames("_deallocate"))
         .put(new Info("address").javaNames("_address"))
         .put(new Info("position").javaNames("_position"))

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -377,7 +377,7 @@ Type type(Context context) throws ParserException {
             } else if (token.match(Token.VIRTUAL)) {
                 type.virtual = true;
             } else if (token.match(Token.ENUM, Token.EXPLICIT, Token.EXTERN, Token.INLINE, Token.CLASS, Token.INTERFACE,
-                                   Token.STRUCT, Token.UNION, Token.TYPEDEF, Token.TYPENAME, Token.USING)) {
+                                   Token.__INTERFACE, Token.STRUCT, Token.UNION, Token.TYPEDEF, Token.TYPENAME, Token.USING)) {
                 continue;
             } else if (token.match((Object[])InfoMap.simpleTypes) && (type.cppName.length() == 0 || type.simple)) {
                 type.cppName += token.value + " ";
@@ -1816,9 +1816,9 @@ boolean group(Context context, DeclarationList declList) throws ParserException
         boolean foundGroup = false, friend = false;
         Context ctx = new Context(context);
         for (Token token = tokens.get(); !token.match(Token.EOF); token = tokens.next()) {
-            if (token.match(Token.CLASS, Token.INTERFACE, Token.STRUCT, Token.UNION)) {
+            if (token.match(Token.CLASS, Token.INTERFACE, Token.__INTERFACE, Token.STRUCT, Token.UNION)) {
                 foundGroup = true;
-                ctx.inaccessible = token.match(Token.CLASS, Token.INTERFACE);
+                ctx.inaccessible = token.match(Token.CLASS);
                 break;
             } else if (token.match(Token.FRIEND)) {
                 friend = true;

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -65,6 +65,7 @@ class Token implements Comparable<Token> {
             STATIC    = new Token(IDENTIFIER, "static"),
             CLASS     = new Token(IDENTIFIER, "class"),
             INTERFACE = new Token(IDENTIFIER, "interface"),
+            __INTERFACE = new Token(IDENTIFIER, "__interface"),
             STRUCT    = new Token(IDENTIFIER, "struct"),
             UNION     = new Token(IDENTIFIER, "union"),
             TEMPLATE  = new Token(IDENTIFIER, "template"),

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -379,7 +379,7 @@ Type type(Context context) throws ParserException {
             } else if (token.match(Token.ENUM, Token.EXPLICIT, Token.EXTERN, Token.INLINE, Token.CLASS, Token.INTERFACE,
                                    Token.STRUCT, Token.UNION, Token.TYPEDEF, Token.TYPENAME, Token.USING)) {
                 continue;
-            } else if (token.match((Object[])InfoMap.simpleTypes)) {
+            } else if (token.match((Object[])InfoMap.simpleTypes) && (type.cppName.length() == 0 || type.simple)) {
                 type.cppName += token.value + " ";
                 type.simple = true;
             } else if (token.match(Token.IDENTIFIER)) {

File: src/main/java/org/bytedeco/javacpp/annotation/Properties.java
Patch:
@@ -36,6 +36,8 @@
 public @interface Properties {
     /** A list of classes from which to inherit properties. */
     Class[] inherit() default {};
+    /** A list of platform names to be used as default for {@link #value()}. */
+    String[] names() default {};
     /** A list of properties for different platforms. */
     Platform[] value() default {};
     /** The target Java source code file of the {@link Parser}. */

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -2482,7 +2482,9 @@ public File parse(File outputDirectory, String[] classPath, Class cls) throws IO
         declList = new DeclarationList(declList);
         containers(context, declList);
         for (String include : clsIncludes) {
-            parse(context, declList, includePaths, include);
+            if (allIncludes.contains(include)) {
+                parse(context, declList, includePaths, include);
+            }
         }
 
         final String newline = lineSeparator != null ? lineSeparator : "\n";

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -30,9 +30,10 @@ class Type {
     Type() { }
     Type(String name) { cppName = javaName = name; }
 
+    int indirections = 0;
     boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
             destructor = false, operator = false, simple = false, staticMember = false,
-            pointer = false, reference = false, value = false, friend = false, virtual = false;
+            reference = false, value = false, friend = false, virtual = false;
     String annotations = "", cppName = "", javaName = "";
     Type[] arguments = null;
     Attribute[] attributes = null;

File: src/main/java/org/bytedeco/javacpp/BytePointer.java
Patch:
@@ -78,8 +78,8 @@ public BytePointer(ByteBuffer buffer) {
         super(buffer);
         if (buffer != null && buffer.hasArray()) {
             byte[] array = buffer.array();
-            allocateArray(array.length);
-            put(array);
+            allocateArray(array.length - buffer.arrayOffset());
+            put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());
             position(buffer.position());
             limit(buffer.limit());
         }

File: src/main/java/org/bytedeco/javacpp/CharPointer.java
Patch:
@@ -62,8 +62,8 @@ public CharPointer(CharBuffer buffer) {
         super(buffer);
         if (buffer != null && buffer.hasArray()) {
             char[] array = buffer.array();
-            allocateArray(array.length);
-            put(array);
+            allocateArray(array.length - buffer.arrayOffset());
+            put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());
             position(buffer.position());
             limit(buffer.limit());
         }

File: src/main/java/org/bytedeco/javacpp/DoublePointer.java
Patch:
@@ -52,8 +52,8 @@ public DoublePointer(DoubleBuffer buffer) {
         super(buffer);
         if (buffer != null && buffer.hasArray()) {
             double[] array = buffer.array();
-            allocateArray(array.length);
-            put(array);
+            allocateArray(array.length - buffer.arrayOffset());
+            put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());
             position(buffer.position());
             limit(buffer.limit());
         }

File: src/main/java/org/bytedeco/javacpp/FloatPointer.java
Patch:
@@ -52,8 +52,8 @@ public FloatPointer(FloatBuffer buffer) {
         super(buffer);
         if (buffer != null && buffer.hasArray()) {
             float[] array = buffer.array();
-            allocateArray(array.length);
-            put(array);
+            allocateArray(array.length - buffer.arrayOffset());
+            put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());
             position(buffer.position());
             limit(buffer.limit());
         }

File: src/main/java/org/bytedeco/javacpp/IntPointer.java
Patch:
@@ -62,8 +62,8 @@ public IntPointer(IntBuffer buffer) {
         super(buffer);
         if (buffer != null && buffer.hasArray()) {
             int[] array = buffer.array();
-            allocateArray(array.length);
-            put(array);
+            allocateArray(array.length - buffer.arrayOffset());
+            put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());
             position(buffer.position());
             limit(buffer.limit());
         }

File: src/main/java/org/bytedeco/javacpp/LongPointer.java
Patch:
@@ -52,8 +52,8 @@ public LongPointer(LongBuffer buffer) {
         super(buffer);
         if (buffer != null && buffer.hasArray()) {
             long[] array = buffer.array();
-            allocateArray(array.length);
-            put(array);
+            allocateArray(array.length - buffer.arrayOffset());
+            put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());
             position(buffer.position());
             limit(buffer.limit());
         }

File: src/main/java/org/bytedeco/javacpp/ShortPointer.java
Patch:
@@ -52,8 +52,8 @@ public ShortPointer(ShortBuffer buffer) {
         super(buffer);
         if (buffer != null && buffer.hasArray()) {
             short[] array = buffer.array();
-            allocateArray(array.length);
-            put(array);
+            allocateArray(array.length - buffer.arrayOffset());
+            put(array, buffer.arrayOffset(), array.length - buffer.arrayOffset());
             position(buffer.position());
             limit(buffer.limit());
         }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1258,7 +1258,7 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
         for (int n = -2; n < Integer.MAX_VALUE; n++) {
             decl = new Declaration();
             tokens.index = startIndex;
-            if (type.constructor || type.destructor || type.operator) {
+            if ((type.constructor || type.destructor || type.operator) && params != null) {
                 type = type(context);
                 params = parameters(context, n / 2, n % 2 != 0);
                 dcl = new Declarator();

File: src/main/java/org/bytedeco/javacpp/tools/Token.java
Patch:
@@ -72,6 +72,8 @@ class Token implements Comparable<Token> {
             TYPENAME  = new Token(IDENTIFIER, "typename"),
             USING     = new Token(IDENTIFIER, "using"),
             NAMESPACE = new Token(IDENTIFIER, "namespace"),
+            NEW       = new Token(IDENTIFIER, "new"),
+            DELETE    = new Token(IDENTIFIER, "delete"),
             OPERATOR  = new Token(IDENTIFIER, "operator"),
             PRIVATE   = new Token(IDENTIFIER, "private"),
             PROTECTED = new Token(IDENTIFIER, "protected"),

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -32,7 +32,7 @@ class Type {
 
     boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
             destructor = false, operator = false, simple = false, staticMember = false,
-            pointer = false, reference = false, value = false, virtual = false;
+            pointer = false, reference = false, value = false, friend = false, virtual = false;
     String annotations = "", cppName = "", javaName = "";
     Type[] arguments = null;
     Attribute[] attributes = null;

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -682,13 +682,13 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, String classPa
             out.print("static void " + name + "_deallocate(void *p) { ");
             if (FunctionPointer.class.isAssignableFrom(c)) {
                 String typeName = functionClassName(c) + "*";
-                out.println("JNIEnv *e; bool a = JavaCPP_getEnv(&e); if (e != NULL) e->DeleteWeakGlobalRef((("
+                out.println("JNIEnv *e; bool a = JavaCPP_getEnv(&e); if (e != NULL) e->DeleteWeakGlobalRef((jweak)(("
                         + typeName + ")p)->obj); delete (" + typeName + ")p; JavaCPP_detach(a); }");
             } else if (virtualFunctions.containsKey(c)) {
                 String[] typeName = cppTypeName(c);
                 String valueTypeName = valueTypeName(typeName);
                 String subType = "JavaCPP_" + mangle(valueTypeName);
-                out.println("JNIEnv *e; bool a = JavaCPP_getEnv(&e); if (e != NULL) e->DeleteWeakGlobalRef((("
+                out.println("JNIEnv *e; bool a = JavaCPP_getEnv(&e); if (e != NULL) e->DeleteWeakGlobalRef((jweak)(("
                         + subType + "*)p)->obj); delete (" + subType + "*)p; JavaCPP_detach(a); }");
             } else {
                 String[] typeName = cppTypeName(c);
@@ -887,7 +887,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, String classPa
         out.println("        return;");
         out.println("    }");
         out.println("    for (int i = 0; i < " + jclasses.size() + "; i++) {");
-        out.println("        env->DeleteWeakGlobalRef(JavaCPP_classes[i]);");
+        out.println("        env->DeleteWeakGlobalRef((jweak)JavaCPP_classes[i]);");
         out.println("        JavaCPP_classes[i] = NULL;");
         out.println("    }");
         out.println("    JavaCPP_vm = NULL;");

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -59,7 +59,8 @@ public ClassProperties(Properties properties) {
             if (k.equals("platform.includepath") || k.equals("platform.include") ||
                     k.equals("platform.linkpath") || k.equals("platform.link") ||
                     k.equals("platform.preloadpath") || k.equals("platform.preload") ||
-                    k.equals("platform.framework")) {
+                    k.equals("platform.frameworkpath") || k.equals("platform.framework") ||
+                    k.equals("platform.library.suffix")) {
                 addAll(k, v.split(pathSeparator));
             } else {
                 setProperty(k, v);

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -126,7 +126,8 @@ public void load(Class cls, boolean inherit) {
         LinkedList<Class> classList = new LinkedList<Class>();
         classList.addFirst(c);
         while (!c.isAnnotationPresent(org.bytedeco.javacpp.annotation.Properties.class)
-                && !c.isAnnotationPresent(Platform.class) && c.getSuperclass() != Object.class) {
+                && !c.isAnnotationPresent(Platform.class) && c.getSuperclass() != null
+                && c.getSuperclass() != Object.class) {
             // accumulate superclasses to process native methods from those as well
             classList.addFirst(c = c.getSuperclass());
         }

File: src/main/java/org/bytedeco/javacpp/annotation/ByRef.java
Patch:
@@ -20,6 +20,6 @@
 @Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface ByRef {
-    /** A C++ code snippet to use when null is passed. By default {@link NullPointerException} is thrown. */
+    /** A C++ expression to use when null is passed. By default {@link NullPointerException} is thrown. */
     String nullValue() default "";
 }

File: src/main/java/org/bytedeco/javacpp/annotation/ByVal.java
Patch:
@@ -20,6 +20,6 @@
 @Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface ByVal {
-    /** A C++ code snippet to use when null is passed. By default {@link NullPointerException} is thrown. */
+    /** A C++ expression to use when null is passed. By default {@link NullPointerException} is thrown. */
     String nullValue() default "";
 }

File: src/main/java/org/bytedeco/javacpp/tools/DeclarationList.java
Patch:
@@ -106,7 +106,8 @@ String rescan(String lines) {
         while (!stack.isEmpty()) {
             decl = stack.removeLast();
             if (context != null) {
-                decl.inaccessible = context.inaccessible;
+                decl.inaccessible = context.inaccessible
+                        && !(context.virtualize && decl.declarator != null && decl.declarator.type != null && decl.declarator.type.virtual);
             }
             if (decl.text.length() == 0) {
                 decl.inaccessible = true;

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -30,7 +30,7 @@ class Type {
 
     boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
             destructor = false, operator = false, simple = false, staticMember = false,
-            pointer = false, reference = false, virtual = false;
+            pointer = false, reference = false, value = false, virtual = false;
     String annotations = "", cppName = "", javaName = "";
     Type[] arguments = null;
     Attribute[] attributes = null;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Samuel Audet
+ * Copyright (C) 2014,2015 Samuel Audet
  *
  * This file is part of JavaCPP.
  *
@@ -37,7 +37,7 @@ public class InfoMap extends HashMap<String,LinkedList<Info>> {
     public InfoMap(InfoMap parent) { this.parent = parent; }
 
     InfoMap parent = null;
-    static final String[] containers = { "std::deque", "std::list", "std::map", "std::queue", "std::set", "std::stack", "std::vector", "std::valarray" };
+    static final String[] containers = { "std::deque", "std::list", "std::map", "std::queue", "std::set", "std::stack", "std::vector", "std::valarray", "std::pair" };
     static final String[] simpleTypes = { "signed", "unsigned", "char", "short", "int", "long", "bool", "float", "double" };
     static { Arrays.sort(simpleTypes); }
     static final InfoMap defaults = new InfoMap(null)

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Samuel Audet
+ * Copyright (C) 2014,2015 Samuel Audet
  *
  * This file is part of JavaCPP.
  *
@@ -30,7 +30,7 @@ class Type {
 
     boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
             destructor = false, operator = false, simple = false, staticMember = false,
-            pointer = false, reference = false;
+            pointer = false, reference = false, virtual = false;
     String annotations = "", cppName = "", javaName = "";
     Type[] arguments = null;
     Attribute[] attributes = null;

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -897,7 +897,7 @@ String commentBefore() throws ParserException {
         for (Token token = tokens.get(); token.match(Token.COMMENT); token = tokens.next()) {
             String s = token.value;
             if (s.startsWith("/**") || s.startsWith("/*!") || s.startsWith("///") || s.startsWith("//!")) {
-                if (s.charAt(3) == '<') {
+                if (s.length() > 3 && s.charAt(3) == '<') {
                     continue;
                 } else if (s.startsWith("/// ") || s.startsWith("//!")) {
                     s = (comment.length() == 0 || comment.contains("*/")
@@ -933,7 +933,7 @@ String commentAfter() throws ParserException {
             String spacing = token.spacing;
             int n = spacing.lastIndexOf('\n') + 1;
             if (s.startsWith("/**") || s.startsWith("/*!") || s.startsWith("///") || s.startsWith("//!")) {
-                if (s.charAt(3) != '<') {
+                if (s.length() > 3 && s.charAt(3) != '<') {
                     continue;
                 } else if (s.startsWith("///") || s.startsWith("//!")) {
                     s = (comment.length() == 0 || comment.contains("*/")

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -561,7 +561,7 @@ boolean classes(boolean handleExceptions, boolean defineAdapters, String classPa
             out.println("    operator T*() {");
             out.println("        // take ownership, if unique");
             out.println("        ptr = sharedPtr.get();");
-            out.println("        if (sharedPtr.unique()) {");
+            out.println("        if (sharedPtr.unique() && &sharedPtr == &sharedPtr2) {");
             out.println("            memset(&sharedPtr, 0, sizeof(SHARED_PTR_NAMESPACE::shared_ptr<T>));");
             out.println("        }");
             out.println("        return ptr;");

File: src/main/java/org/bytedeco/javacpp/tools/Context.java
Patch:
@@ -52,6 +52,9 @@ class Context {
     String[] qualify(String cppName) {
         if (cppName == null || cppName.length() == 0) {
             return new String[0];
+        } else if (cppName.startsWith("::")) {
+            // already in global namespace, so strip leading operator
+            return new String[] { cppName.substring(2) };
         }
         ArrayList<String> names = new ArrayList<String>();
         String ns = namespace != null ? namespace : "";

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -80,6 +80,7 @@ public class InfoMap extends HashMap<String,LinkedList<Info>> {
         .put(new Info("bool", "jboolean").cast().valueTypes("boolean").pointerTypes("BoolPointer"))
         .put(new Info("wchar_t", "WCHAR").cast().valueTypes("char").pointerTypes("CharPointer"))
         .put(new Info("const char").valueTypes("byte").pointerTypes("@Cast(\"const char*\") BytePointer", "String"))
+        .put(new Info("boost::shared_ptr", "std::shared_ptr").annotations("@SharedPtr"))
         .put(new Info("std::string").annotations("@StdString").valueTypes("BytePointer", "String"))
         .put(new Info("std::vector").annotations("@StdVector"))
 

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -2582,7 +2582,8 @@ String[] cppFunctionTypeName(Method functionMethod) {
         Class<?> type = functionMethod.getDeclaringClass();
         Convention convention = type.getAnnotation(Convention.class);
         String callingConvention = convention == null ? "" : convention.value() + " ";
-        Namespace namespace = type.getAnnotation(Namespace.class);
+        // for virtual functions, the namespace is managed by the enclosing class
+        Namespace namespace = FunctionPointer.class.isAssignableFrom(type) ? type.getAnnotation(Namespace.class) : null;
         String spaceName = namespace == null ? "" : namespace.value();
         if (spaceName.length() > 0 && !spaceName.endsWith("::")) {
             spaceName += "::";

File: src/main/java/org/bytedeco/javacpp/annotation/Adapter.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -28,7 +29,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
 public @interface Adapter {
     /** The name of the C++ adapter class. */

File: src/main/java/org/bytedeco/javacpp/annotation/Allocator.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -25,6 +26,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface Allocator { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/ArrayAllocator.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -23,6 +24,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface ArrayAllocator { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/ByPtr.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -16,6 +17,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface ByPtr { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/ByPtrPtr.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -16,6 +17,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface ByPtrPtr { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/ByPtrRef.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -14,6 +15,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface ByPtrRef { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/ByRef.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -16,6 +17,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface ByRef { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/ByVal.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -16,6 +17,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface ByVal { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/Cast.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -20,7 +21,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
 public @interface Cast {
     String[] value();

File: src/main/java/org/bytedeco/javacpp/annotation/Const.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -15,7 +16,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
 public @interface Const {
     /** If {@code true}, applies {@code const} to the value and to the pointer, respectively. */

File: src/main/java/org/bytedeco/javacpp/annotation/Convention.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -14,7 +15,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
 public @interface Convention {
     String value();

File: src/main/java/org/bytedeco/javacpp/annotation/Function.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -20,6 +21,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface Function { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/Index.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -15,7 +16,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface Index {
     /** The number of indices spread over the parameters, for multidimensional access. */

File: src/main/java/org/bytedeco/javacpp/annotation/MemberGetter.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -24,6 +25,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface MemberGetter { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/MemberSetter.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -24,6 +25,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface MemberSetter { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/Name.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -19,7 +20,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface Name {
     /** The second element gets used as a suffix to work around arrays of anonymous struct or union. */

File: src/main/java/org/bytedeco/javacpp/annotation/Namespace.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -21,7 +22,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface Namespace {
     String value() default "";

File: src/main/java/org/bytedeco/javacpp/annotation/NoDeallocator.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -21,6 +22,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface NoDeallocator { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/NoException.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -18,6 +19,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface NoException { }

File: src/main/java/org/bytedeco/javacpp/annotation/NoOffset.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -20,6 +21,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface NoOffset { }

File: src/main/java/org/bytedeco/javacpp/annotation/Opaque.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -17,6 +18,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
 public @interface Opaque { }

File: src/main/java/org/bytedeco/javacpp/annotation/Platform.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -34,7 +35,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface Platform {
     /** The properties, class, or method apply only to the named platforms.

File: src/main/java/org/bytedeco/javacpp/annotation/Properties.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -30,7 +31,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE})
 public @interface Properties {
     /** A list of classes from which to inherit properties. */

File: src/main/java/org/bytedeco/javacpp/annotation/Raw.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -19,7 +20,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface Raw {
     /** If {@code true}, passes the {@code JNIEnv*} as first argument to the native function. */

File: src/main/java/org/bytedeco/javacpp/annotation/StdString.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -14,7 +15,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 @Cast("std::string&") @Adapter("StringAdapter")
 public @interface StdString { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/StdVector.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -15,7 +16,7 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 @Adapter("VectorAdapter")
 public @interface StdVector {

File: src/main/java/org/bytedeco/javacpp/annotation/ValueGetter.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -25,6 +26,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface ValueGetter { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/ValueSetter.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -25,6 +26,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface ValueSetter { }
\ No newline at end of file

File: src/main/java/org/bytedeco/javacpp/annotation/Virtual.java
Patch:
@@ -1,5 +1,6 @@
 package org.bytedeco.javacpp.annotation;
 
+import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -14,6 +15,6 @@
  *
  * @author Samuel Audet
  */
-@Retention(RetentionPolicy.RUNTIME)
+@Documented @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface Virtual { }

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1065,6 +1065,7 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
             friend = true;
             tokens.next();
         }
+        int startIndex = tokens.index;
         Type type = type(context);
         Parameters params = parameters(context, 0, false);
         Declarator dcl = new Declarator();
@@ -1102,7 +1103,7 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
             }
             dcl.signature = dcl.javaName + params.signature;
         } else {
-            tokens.index = backIndex;
+            tokens.index = startIndex;
             dcl = declarator(context, null, 0, false, 0, false, false);
             type = dcl.type;
         }
@@ -1172,7 +1173,7 @@ boolean function(Context context, DeclarationList declList) throws ParserExcepti
         boolean first = true;
         for (int n = -2; n < Integer.MAX_VALUE; n++) {
             decl = new Declaration();
-            tokens.index = backIndex;
+            tokens.index = startIndex;
             if (type.constructor || type.destructor || type.operator) {
                 type = type(context);
                 params = parameters(context, n / 2, n % 2 != 0);

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -56,6 +56,7 @@ public ClassProperties(Properties properties) {
             }
             if (k.equals("platform.includepath") || k.equals("platform.include") ||
                     k.equals("platform.linkpath") || k.equals("platform.link") ||
+                    k.equals("platform.preloadpath") || k.equals("platform.preload") ||
                     k.equals("platform.framework")) {
                 addAll(k, v.split(pathSeparator));
             } else {

File: src/main/java/org/bytedeco/javacpp/tools/TokenIndexer.java
Patch:
@@ -73,7 +73,9 @@ void filter(int index) {
                             if (array[index].spacing.indexOf('\n') >= 0) {
                                 break;
                             }
-                            value += array[index].spacing + array[index];
+                            if (!array[index].match(Token.COMMENT)) {
+                                value += array[index].spacing + array[index];
+                            }
                             tokens.add(array[index++]);
                         }
                         define = info == null || !defined;

File: src/main/java/org/bytedeco/javacpp/Pointer.java
Patch:
@@ -385,6 +385,7 @@ public void deallocate() {
     }
     /**
      * Explicitly deallocates native memory without waiting after the garbage collector.
+     * Has no effect if no deallocator was previously set with {@link #deallocator(Deallocator)}.
      * @param deallocate if false, does not deallocate, rather disabling garbage collection
      */
     public void deallocate(boolean deallocate) {

File: src/main/java/org/bytedeco/javacpp/tools/BuildMojo.java
Patch:
@@ -186,7 +186,7 @@ String[] merge(String[] ss, String s) {
         } else if (s != null) {
             ss = new String[] { s };
         }
-        return ss;
+        return ss != null ? ss : new String[0];
     }
 
     @Override public void execute() throws MojoExecutionException {

File: src/main/java/org/bytedeco/javacpp/tools/Generator.java
Patch:
@@ -1313,8 +1313,8 @@ void call(MethodInformation methodInfo, String returnPrefix) {
                 }
                 out.print(cast + "adapter" + j);
                 j += adapterInfo.argc - 1;
-            } else if (FunctionPointer.class.isAssignableFrom(methodInfo.parameterTypes[j]) && passBy == null) {
-                out.print(cast + "(ptr" + j + " == NULL ? NULL : ptr" + j + "->ptr)");
+            } else if (FunctionPointer.class.isAssignableFrom(methodInfo.parameterTypes[j])) {
+                out.print(cast + "(ptr" + j + " == NULL ? NULL : " + (passBy instanceof ByPtrPtr ? "&ptr" : "ptr") + j + "->ptr)");
             } else if (passBy instanceof ByVal || (passBy instanceof ByRef &&
                     methodInfo.parameterTypes[j] != String.class)) {
                 out.print("*" + cast + "ptr" + j);

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -756,7 +756,7 @@ Declarator declarator(Context context, String defaultName, int infoNumber, boole
                 }
             }
 
-            if (!needCast && type.constValue && !implicitConst) {
+            if (!needCast && type.constValue && !implicitConst && !type.javaName.contains("@Cast")) {
                 type.annotations = "@Const " + type.annotations;
             }
         }
@@ -1540,7 +1540,8 @@ boolean typedef(Context context, DeclarationList declList) throws ParserExceptio
             if (dcl.javaName.length() > 0 && context.group != null) {
                 dcl.javaName = context.group.javaName + "." + dcl.javaName;
             }
-            infoMap.put(new Info(defName).valueTypes(dcl.javaName));
+            infoMap.put(new Info(defName).valueTypes(dcl.javaName)
+                    .pointerTypes((dcl.indirections > 0 ? "@ByPtrPtr " : "") + dcl.javaName));
         } else if (typeName.equals("void")) {
             // some opaque data type
             Info info = infoMap.getFirst(defName);

File: src/main/java/org/bytedeco/javacpp/tools/Context.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  *
- * @author saudet
+ * @author Samuel Audet
  */
 class Context {
     Context() {
@@ -47,6 +47,7 @@ class Context {
     TemplateMap templateMap = null;
     LinkedList<String> usingList = null;
 
+    /** Return all likely combinations of namespaces and template arguments for this C++ type */
     String[] qualify(String cppName) {
         if (cppName == null || cppName.length() == 0) {
             return new String[0];
@@ -86,6 +87,7 @@ String[] qualify(String cppName) {
         return names.toArray(new String[names.size()]);
     }
 
+    /** Shorten a qualified Java name, given the Context */
     String shorten(String javaName) {
         if (group != null) {
             int lastDot = 0;

File: src/main/java/org/bytedeco/javacpp/tools/DeclarationList.java
Patch:
@@ -100,6 +100,9 @@ String rescan(String lines) {
             if (context != null) {
                 decl.inaccessible = context.inaccessible;
             }
+            if (decl.text.length() == 0) {
+                decl.inaccessible = true;
+            }
             it = listIterator();
             boolean found = false;
             while (it.hasNext()) {

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -71,7 +71,7 @@ public class InfoMap extends HashMap<String,LinkedList<Info>> {
         .put(new Info("unsigned long", "unsigned long int").cast()
             .valueTypes("long").pointerTypes("CLongPointer"))
 
-        .put(new Info("size_t", "ptrdiff_t").cast().valueTypes("long").pointerTypes("SizeTPointer"))
+        .put(new Info("size_t", "ptrdiff_t", "intptr_t", "uintptr_t", "off_t").cast().valueTypes("long").pointerTypes("SizeTPointer"))
         .put(new Info("float", "jfloat").valueTypes("float").pointerTypes("FloatPointer", "FloatBuffer", "float[]"))
         .put(new Info("double", "jdouble").valueTypes("double").pointerTypes("DoublePointer", "DoubleBuffer", "double[]"))
         .put(new Info("long double").cast().valueTypes("double").pointerTypes("Pointer"))

File: src/main/java/org/bytedeco/javacpp/tools/Type.java
Patch:
@@ -28,8 +28,9 @@ class Type {
     Type() { }
     Type(String name) { cppName = javaName = name; }
 
-    boolean anonymous = false, constValue = false, constructor = false,
-            destructor = false, operator = false, simple = false, staticMember = false;
+    boolean anonymous = false, constPointer = false, constValue = false, constructor = false,
+            destructor = false, operator = false, simple = false, staticMember = false,
+            pointer = false, reference = false;
     String annotations = "", cppName = "", javaName = "";
     Type[] arguments = null;
     Attribute[] attributes = null;

File: src/main/java/org/bytedeco/javacpp/tools/InfoMap.java
Patch:
@@ -74,6 +74,7 @@ public class InfoMap extends HashMap<String,LinkedList<Info>> {
         .put(new Info("size_t", "ptrdiff_t").cast().valueTypes("long").pointerTypes("SizeTPointer"))
         .put(new Info("float", "jfloat").valueTypes("float").pointerTypes("FloatPointer", "FloatBuffer", "float[]"))
         .put(new Info("double", "jdouble").valueTypes("double").pointerTypes("DoublePointer", "DoubleBuffer", "double[]"))
+        .put(new Info("long double").cast().valueTypes("double").pointerTypes("Pointer"))
         .put(new Info("std::complex<float>").cast().pointerTypes("FloatPointer", "FloatBuffer", "float[]"))
         .put(new Info("std::complex<double>").cast().pointerTypes("DoublePointer", "DoubleBuffer", "double[]"))
         .put(new Info("bool", "jboolean").cast().valueTypes("boolean").pointerTypes("BoolPointer"))

File: src/main/java/org/bytedeco/javacpp/tools/Parser.java
Patch:
@@ -1349,6 +1349,7 @@ boolean macro(Context context, DeclarationList declList) throws ParserException
                     if (value.length() > 0) {
                         decl.text += "public static final " + type + " " + macroName + " =" + value + ";\n";
                     }
+                    decl.signature = macroName;
                 }
             }
         }

File: src/main/java/org/bytedeco/javacpp/tools/Tokenizer.java
Patch:
@@ -106,12 +106,13 @@ public Token nextToken() throws IOException {
             token.type = c == '.' ? Token.FLOAT : Token.INTEGER;
             buffer.append((char)c);
             int prevc = 0;
-            boolean large = false, unsigned = false, hex = false;
+            boolean exp = false, large = false, unsigned = false, hex = false;
             while ((c = readChar()) != -1 && (Character.isDigit(c) || c == '.' || c == '-' || c == '+' ||
                    (c >= 'a' && c <= 'f') || c == 'l' || c == 'u' || c == 'x' ||
                    (c >= 'A' && c <= 'F') || c == 'L' || c == 'U' || c == 'X')) {
                 switch (c) {
                     case '.': token.type = Token.FLOAT;  break;
+                    case 'e': case 'E': exp      = true; break;
                     case 'l': case 'L': large    = true; break;
                     case 'u': case 'U': unsigned = true; break;
                     case 'x': case 'X': hex      = true; break;
@@ -121,7 +122,7 @@ public Token nextToken() throws IOException {
                 }
                 prevc = c;
             }
-            if (!hex && (prevc == 'f' || prevc == 'F')) {
+            if (!hex && (exp || prevc == 'f' || prevc == 'F')) {
                 token.type = Token.FLOAT;
             }
             if (token.type == Token.INTEGER && (large || (unsigned && !hex))) {

File: src/main/java/org/bytedeco/javacpp/ClassProperties.java
Patch:
@@ -126,6 +126,7 @@ public void load(Class cls, boolean inherit) {
         classList.addFirst(c);
         while (!c.isAnnotationPresent(org.bytedeco.javacpp.annotation.Properties.class)
                 && !c.isAnnotationPresent(Platform.class) && c.getSuperclass() != Object.class) {
+            // accumulate superclasses to process native methods from those as well
             classList.addFirst(c = c.getSuperclass());
         }
         if (effectiveClasses == null) {

File: src/main/java/com/googlecode/javacpp/Parser.java
Patch:
@@ -182,6 +182,7 @@ public static class InfoMap extends HashMap<String,LinkedList<Info>> {
 
             .put(new Info("allocate").javaNames("_allocate"))
             .put(new Info("deallocate").javaNames("_deallocate"))
+            .put(new Info("address").javaNames("_address"))
             .put(new Info("position").javaNames("_position"))
             .put(new Info("limit").javaNames("_limit"))
             .put(new Info("capacity").javaNames("_capacity"));

File: src/main/java/com/googlecode/javacpp/Generator.java
Patch:
@@ -882,6 +882,7 @@ boolean methods(Class<?> cls) {
                         cls.getCanonicalName() + "\". No code will be generated for callback allocator.");
                 continue;
             } else if (callbackAllocators[i] || (methods[i].equals(functionMethod) && methodInfo == null)) {
+                functions.index(cls);
                 Name name = methods[i].getAnnotation(Name.class);
                 if (name != null && name.value().length > 0 && name.value()[0].length() > 0) {
                     callbackName = name.value()[0];

File: src/main/java/com/googlecode/javacpp/BoolPointer.java
Patch:
@@ -45,6 +45,8 @@ public BoolPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public BoolPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public BoolPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);

File: src/main/java/com/googlecode/javacpp/BytePointer.java
Patch:
@@ -94,6 +94,8 @@ public BytePointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public BytePointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public BytePointer(Pointer p) { super(p); }
     private native void allocateArray(int size);
@@ -196,7 +198,7 @@ public BytePointer putString(String s) {
     /** @return {@code get(array, 0, array.length)} */
     public BytePointer get(byte[] array) { return get(array, 0, array.length); }
     /** @return {@code put(array, 0, array.length)} */
-    public BytePointer put(byte[] array) { return put(array, 0, array.length); }
+    public BytePointer put(byte ... array) { return put(array, 0, array.length); }
     /**
      * Reads a portion of the native array into a Java array.
      *

File: src/main/java/com/googlecode/javacpp/CLongPointer.java
Patch:
@@ -46,6 +46,8 @@ public CLongPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public CLongPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public CLongPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);

File: src/main/java/com/googlecode/javacpp/CharPointer.java
Patch:
@@ -78,6 +78,8 @@ public CharPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public CharPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public CharPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);
@@ -147,7 +149,7 @@ public CharPointer putString(String s) {
     /** @return {@code get(array, 0, array.length)} */
     public CharPointer get(char[] array) { return get(array, 0, array.length); }
     /** @return {@code put(array, 0, array.length)} */
-    public CharPointer put(char[] array) { return put(array, 0, array.length); }
+    public CharPointer put(char ... array) { return put(array, 0, array.length); }
     /**
      * Reads a portion of the native array into a Java array.
      *

File: src/main/java/com/googlecode/javacpp/DoublePointer.java
Patch:
@@ -68,6 +68,8 @@ public DoublePointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public DoublePointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public DoublePointer(Pointer p) { super(p); }
     private native void allocateArray(int size);
@@ -103,7 +105,7 @@ public DoublePointer(int size) {
     /** @return {@code get(array, 0, array.length)} */
     public DoublePointer get(double[] array) { return get(array, 0, array.length); }
     /** @return {@code put(array, 0, array.length)} */
-    public DoublePointer put(double[] array) { return put(array, 0, array.length); }
+    public DoublePointer put(double ... array) { return put(array, 0, array.length); }
     /**
      * Reads a portion of the native array into a Java array.
      *

File: src/main/java/com/googlecode/javacpp/FloatPointer.java
Patch:
@@ -68,6 +68,8 @@ public FloatPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public FloatPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public FloatPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);
@@ -103,7 +105,7 @@ public FloatPointer(int size) {
     /** @return {@code get(array, 0, array.length)} */
     public FloatPointer get(float[] array) { return get(array, 0, array.length); }
     /** @return {@code put(array, 0, array.length)} */
-    public FloatPointer put(float[] array) { return put(array, 0, array.length); }
+    public FloatPointer put(float ... array) { return put(array, 0, array.length); }
     /**
      * Reads a portion of the native array into a Java array.
      *

File: src/main/java/com/googlecode/javacpp/IntPointer.java
Patch:
@@ -78,6 +78,8 @@ public IntPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public IntPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public IntPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);
@@ -151,7 +153,7 @@ public IntPointer putString(String s) {
     /** @return {@code get(array, 0, array.length)} */
     public IntPointer get(int[] array) { return get(array, 0, array.length); }
     /** @return {@code put(array, 0, array.length)} */
-    public IntPointer put(int[] array) { return put(array, 0, array.length); }
+    public IntPointer put(int ... array) { return put(array, 0, array.length); }
     /**
      * Reads a portion of the native array into a Java array.
      *

File: src/main/java/com/googlecode/javacpp/LongPointer.java
Patch:
@@ -68,6 +68,8 @@ public LongPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public LongPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public LongPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);
@@ -103,7 +105,7 @@ public LongPointer(int size) {
     /** @return {@code get(array, 0, array.length)} */
     public LongPointer get(long[] array) { return get(array, 0, array.length); }
     /** @return {@code put(array, 0, array.length)} */
-    public LongPointer put(long[] array) { return put(array, 0, array.length); }
+    public LongPointer put(long ... array) { return put(array, 0, array.length); }
     /**
      * Reads a portion of the native array into a Java array.
      *

File: src/main/java/com/googlecode/javacpp/ShortPointer.java
Patch:
@@ -68,6 +68,8 @@ public ShortPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public ShortPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public ShortPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);
@@ -103,7 +105,7 @@ public ShortPointer(int size) {
     /** @return {@code get(array, 0, array.length)} */
     public ShortPointer get(short[] array) { return get(array, 0, array.length); }
     /** @return {@code put(array, 0, array.length)} */
-    public ShortPointer put(short[] array) { return put(array, 0, array.length); }
+    public ShortPointer put(short ... array) { return put(array, 0, array.length); }
     /**
      * Reads a portion of the native array into a Java array.
      *

File: src/main/java/com/googlecode/javacpp/SizeTPointer.java
Patch:
@@ -45,6 +45,8 @@ public SizeTPointer(int size) {
             throw new RuntimeException("No native JavaCPP library in memory. (Has Loader.load() been called?)", e);
         }
     }
+    /** @see Pointer#Pointer() */
+    public SizeTPointer() { }
     /** @see Pointer#Pointer(Pointer) */
     public SizeTPointer(Pointer p) { super(p); }
     private native void allocateArray(int size);

File: src/main/java/com/googlecode/javacpp/Pointer.java
Patch:
@@ -33,7 +33,7 @@
  * All peer classes to native types must be descended from Pointer, the topmost class.
  * It can be thought as mapping the native C++ {@code void*}, which can point to any
  * {@code struct}, {@code class}, or {@code union}. All Pointer classes get parsed
- * by {@link Generator} to produce proper wrapping JNI code, but this parent class also
+ * by {@link Generator} to produce proper wrapping JNI code, but this base class also
  * provides functionality to access native array elements as well as utility methods
  * and classes to let users benefit from garbage collection.
  * <p>
@@ -71,8 +71,8 @@ public Pointer() {
      * Copies the address, position, limit, and capacity of another Pointer.
      * Also keeps a reference to it to prevent its memory from getting deallocated.
      * <p>
-     * This copy constructor basically acts as a static cast, as least on
-     * plain old data (POD) {@code struct}.
+     * This copy constructor basically acts as a {@code reinterpret_cast}, at least
+     * on plain old data (POD) {@code struct}, so we need to be careful with it.
      *
      * @param p the other Pointer to reference
      */

File: src/main/java/com/googlecode/javacpp/annotation/Index.java
Patch:
@@ -8,7 +8,7 @@
 
 /**
  * Allows using method arguments to call {@code operator[]} in some circumstances.
- * For example, a call like {@code *this[i].foo(str)} could be accomplished with
+ * For example, a call like {@code (*this)[i].foo(str)} could be accomplished with
  * {@code @Index native void foo(int i, String str)}.
  *
  * @see Generator

File: src/main/java/com/googlecode/javacpp/annotation/Name.java
Patch:
@@ -22,6 +22,6 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface Name {
-    /** The second value gets used as a suffix to work around arrays of anonymous struct or union. */
+    /** The second element gets used as a suffix to work around arrays of anonymous struct or union. */
     String[] value();
-}
\ No newline at end of file
+}

File: src/main/java/com/googlecode/javacpp/annotation/MemberGetter.java
Patch:
@@ -8,8 +8,9 @@
 
 /**
  * An annotation indicating that a method should behave like a member getter.
- * However, a pair of methods with the same name, one with a return value, the
- * other without, but with the same number of parameters, plus 1, are recognized
+ * However, a pair of methods with the same name, where the return value type of
+ * the one short by a parameter equals the type of the extra parameter of the other,
+ * whose return value type is {@code void} or of the enclosing class, are recognized
  * as a member getter/setter pair even without annotation. This behavior can be
  * changed by annotating the methods with the {@link Function} annotation.
  * <p>

File: src/main/java/com/googlecode/javacpp/annotation/Platform.java
Patch:
@@ -15,6 +15,9 @@
  * A class or method annotated with only {@link #value()} or {@link #not()}
  * lets {@link Generator} know for which platforms it should generate code
  * (or not). The strings are matched with {@link String#startsWith(String)}.
+ * In particular, {@code @Platform(value="")} matches all platforms, while
+ * {@code @Platform(not="")} matches no platforms, providing a way to specify
+ * methods to skip or classes to ignore, as if they did not exist.
  * <p>
  * Classes annotated with at least one of the other values define a top-enclosing
  * class as returned by {@link Loader#getEnclosingClass(Class)}. By default, one

File: src/main/java/com/googlecode/javacpp/Loader.java
Patch:
@@ -645,7 +645,9 @@ public static URL[] findLibrary(Class cls, ClassProperties properties, String li
                 }
             }
         }
-        return Arrays.copyOf(urls, k);
+        URL[] newurls = new URL[k];
+        System.arraycopy(urls, 0, newurls, 0, k);
+        return newurls;
     }
 
     /**

File: src/main/java/com/googlecode/javacpp/Builder.java
Patch:
@@ -682,7 +682,9 @@ public Builder properties(String platformName) {
     /** Adds all the properties of the argument to the {@link #properties} field. */
     public Builder properties(Properties properties) {
         if (properties != null) {
-            this.properties.putAll(properties);
+            for (Map.Entry e : properties.entrySet()) {
+                property((String)e.getKey(), (String)e.getValue());
+            }
         }
         return this;
     }

File: src/main/java/com/googlecode/javacpp/Loader.java
Patch:
@@ -577,7 +577,7 @@ public static String load(Class cls) {
             URL[] urls = findLibrary(cls, p, library);
             return loadLibrary(urls, library);
         } catch (UnsatisfiedLinkError e) {
-            if (preloadError != null) {
+            if (preloadError != null && e.getCause() == null) {
                 e.initCause(preloadError);
             }
             throw e;
@@ -702,13 +702,13 @@ public static String loadLibrary(URL[] urls, String libnameversion) {
             return libname;
         } catch (UnsatisfiedLinkError e) {
             loadedLibraries.remove(libnameversion);
-            if (loadError != null) {
+            if (loadError != null && e.getCause() == null) {
                 e.initCause(loadError);
             }
             throw e;
         } catch (IOException ex) {
             loadedLibraries.remove(libnameversion);
-            if (loadError != null) {
+            if (loadError != null && ex.getCause() == null) {
                 ex.initCause(loadError);
             }
             Error e = new UnsatisfiedLinkError(ex.toString());

File: src/main/java/com/googlecode/javacpp/Pointer.java
Patch:
@@ -500,7 +500,9 @@ public <P extends Pointer> P fill(int b) {
      * @return true if obj is equal
      */
     @Override public boolean equals(Object obj) {
-        if (obj == null) {
+        if (obj == this) {
+            return true;
+        } else if (obj == null) {
             return isNull();
         } else if (obj.getClass() != getClass()) {
             return false;

File: src/main/java/com/googlecode/javacpp/BuildMojo.java
Patch:
@@ -76,7 +76,7 @@ public class BuildMojo extends AbstractMojo {
     protected boolean header = false;
 
     /**
-     * Also create a JAR file named <tt>jarPrefix-platformName.jar</tt>
+     * Also create a JAR file named {@code <jarPrefix>-<platform.name>.jar}
      * @parameter expression="${jarPrefix}"
      */
     protected String jarPrefix = null;

File: src/main/java/com/googlecode/javacpp/annotation/ArrayAllocator.java
Patch:
@@ -9,13 +9,13 @@
 
 /**
  * An annotation indicating that a method should behave like an array allocator.
- * However, methods with signature <tt>native void allocateArray(int)</tt> are
+ * However, methods with signature {@code native void allocateArray(int)} are
  * recognized as array allocators even without annotation. This behavior can be
  * changed by annotating the method with the {@link Function} annotation.
  * <p>
- * In a nutshell, an array allocator uses the C++ <tt>new[]</tt> operator, and
+ * In a nutshell, an array allocator uses the C++ {@code new[]} operator, and
  * initializes the {@link Pointer#address} as well as the {@link Pointer#deallocator}
- * with <tt>NativeDeallocator</tt>, based on the <tt>delete[]</tt> operator, if
+ * with {@code NativeDeallocator}, based on the {@code delete[]} operator, if
  * not additionally annotated with {@link NoDeallocator}.
  *
  * @see Pointer#init(long, int, long)

File: src/main/java/com/googlecode/javacpp/annotation/ByPtrRef.java
Patch:
@@ -8,7 +8,7 @@
 
 /**
  * Indicates that an argument gets passed or returned by a reference to a pointer.
- * In C++, such a beast looks like <tt>*&</tt>, usually to output pointers via parameters.
+ * In C++, such a beast looks like {@code *&}, usually to output pointers via parameters.
  *
  * @see Generator
  *

File: src/main/java/com/googlecode/javacpp/annotation/Cast.java
Patch:
@@ -12,7 +12,7 @@
  * possible to apply a cast to both the argument and the adapter, in this order.
  * <p>
  * At the moment, {@link Generator} makes use of the simple C-style cast. If one
- * requires a different kind of type conversion, such as the <tt>dynamic_cast</tt>
+ * requires a different kind of type conversion, such as the {@code dynamic_cast}
  * operator, those can be accessed as if they were functions (with the {@link Name}
  * annotation to specify the type) because they have the same syntax.
  *

File: src/main/java/com/googlecode/javacpp/annotation/Const.java
Patch:
@@ -8,8 +8,8 @@
 import java.lang.annotation.Target;
 
 /**
- * A shortcut annotation that adds <tt>const</tt> to the parameter type or a {@link Cast}.
- * Can also be declared on a {@link FunctionPointer} in the case of <tt>const</tt> functions.
+ * A shortcut annotation that adds {@code const} to the parameter type or a {@link Cast}.
+ * Can also be declared on a {@link FunctionPointer} in the case of {@code const} functions.
  *
  * @see Generator
  *
@@ -18,6 +18,6 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
 public @interface Const {
-    /** If true, applies <tt>const</tt> to the pointer instead of the value. */
+    /** If true, applies {@code const} to the pointer instead of the value. */
     boolean value() default false;
 }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/Index.java
Patch:
@@ -7,9 +7,9 @@
 import java.lang.annotation.Target;
 
 /**
- * Allows using method arguments to call <tt>operator[]</tt> in some circumstances.
- * For example, a call like <tt>*this[i].foo(str)</tt> could be accomplished with
- * <tt>@Index native void foo(int i, String str)</tt>.
+ * Allows using method arguments to call {@code operator[]} in some circumstances.
+ * For example, a call like {@code *this[i].foo(str)} could be accomplished with
+ * {@code @Index native void foo(int i, String str)}.
  *
  * @see Generator
  *

File: src/main/java/com/googlecode/javacpp/annotation/NoDeallocator.java
Patch:
@@ -9,8 +9,8 @@
 /**
  * By default, all allocators attach a deallocator to the peer object on creation.
  * This way, the deallocator automatically gets called during garbage collection.
- * Since an allocator uses the <tt>new</tt> (or for arrays the <tt>new[]</tt>)
- * operator, the deallocator produced uses the <tt>delete</tt> (or <tt>delete[]</tt>)
+ * Since an allocator uses the {@code new} (or for arrays the {@code new[]})
+ * operator, the deallocator produced uses the {@code delete} (or {@code delete[]})
  * operator. However, if that operator is not accessible, or the native library
  * does not use that operator for object deallocation, we may apply this annotation
  * to an allocator method to prevent it from using these operators.

File: src/main/java/com/googlecode/javacpp/annotation/NoException.java
Patch:
@@ -12,7 +12,7 @@
  * into a {@link RuntimeException}. However, this adds some overhead and requires
  * additional support from the compiler. Annotating a class or a method with this
  * annotation indicates that none of the enclosed functions can throw exceptions,
- * and need not be included in a <tt>try{ ... }</tt> block.
+ * and need not be included in a {@code try{ ... }} block.
  *
  * @see Generator
  *

File: src/main/java/com/googlecode/javacpp/annotation/NoOffset.java
Patch:
@@ -8,11 +8,11 @@
 import java.lang.annotation.Target;
 
 /**
- * By default, {@link Generator} applies <tt>offsetof()</tt> to all member variables.
+ * By default, {@link Generator} applies {@code offsetof()} to all member variables.
  * For each value returned {@link Loader#putMemberOffset(String, String, int)}
  * gets called, allowing to query efficiently those values from Java at a later
  * point by calling {@link Loader#offsetof(Class, String)}. However, this is
- * only guaranteed to work on plain old data (POD) <tt>struct</tt>. To prevent
+ * only guaranteed to work on plain old data (POD) {@code struct}. To prevent
  * the C++ compiler from complaining in other cases, we can add this annotation
  * to the peer class declaration.
  *

File: src/main/java/com/googlecode/javacpp/annotation/Opaque.java
Patch:
@@ -9,7 +9,7 @@
 
 /**
  * This annotation must be used for native types that get declared but not defined.
- * Such types do not work with the <tt>sizeof()</tt> operator and their pointers
+ * Such types do not work with the {@code sizeof()} operator and their pointers
  * do not support arithmetic, so for peer classes thus annotated, {@link Generator}
  * then also ignores the {@link Pointer#position} value.
  *

File: src/main/java/com/googlecode/javacpp/annotation/Platform.java
Patch:
@@ -37,7 +37,7 @@
     /** The properties, class, or method do NOT apply to the named platforms.
      *  The strings are matched with {@link String#startsWith(String)} */
     String[] not()         default {};
-    /** A list of macros to <tt>#define</tt> at the top of the generated code,
+    /** A list of macros to {@code #define} at the top of the generated code,
      *  before {@link #include()} and {@link #cinclude()} header files. */
     String[] define()      default {};
     /** A list of C++ header files to include at the top of the generated code. */

File: src/main/java/com/googlecode/javacpp/annotation/Raw.java
Patch:
@@ -22,6 +22,6 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface Raw {
-    /** If <tt>true</tt>, passes the <tt>JNIEnv*</tt> as first argument to the native function. */
+    /** If {@code true}, passes the {@code JNIEnv*} as first argument to the native function. */
     boolean withEnv() default false;
 }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/StdString.java
Patch:
@@ -7,7 +7,7 @@
 import java.lang.annotation.Target;
 
 /**
- * A shorthand for <tt>@Cast("std::string&") @Adapter("StringAdapter")</tt>.
+ * A shorthand for {@code @Cast("std::string&") @Adapter("StringAdapter")}.
  *
  * @see Adapter
  * @see Generator

File: src/main/java/com/googlecode/javacpp/annotation/StdVector.java
Patch:
@@ -8,7 +8,7 @@
 import java.lang.annotation.Target;
 
 /**
- * A shorthand for <tt>@Adapter("VectorAdapter<type>")</tt>.
+ * A shorthand for {@code @Adapter("VectorAdapter<type>")}.
  *
  * @see Adapter
  * @see Generator
@@ -19,7 +19,7 @@
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 @Adapter("VectorAdapter")
 public @interface StdVector {
-    /** The template type of <tt>VectorAdapter</tt>. If not specified, it is
+    /** The template type of {@code VectorAdapter}. If not specified, it is
      *  inferred from the value type of the {@link Pointer} or Java array. */
     String value() default "";
 }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/ValueGetter.java
Patch:
@@ -8,7 +8,7 @@
 
 /**
  * An annotation indicating that a method should behave like a value getter.
- * However, a pair of methods named <tt>get()</tt> and <tt>put()</tt>, one with a
+ * However, a pair of methods named {@code get()} and {@code put()}, one with a
  * return value, the other without, but with the same number of parameters, plus 1,
  * are recognized as a value getter/setter pair even without annotation. This behavior
  * can be changed by annotating the methods with the {@link Function} annotation.

File: src/main/java/com/googlecode/javacpp/annotation/ValueSetter.java
Patch:
@@ -8,7 +8,7 @@
 
 /**
  * An annotation indicating that a method should behave like a value setter.
- * However, a pair of methods named <tt>get()</tt> and <tt>put()</tt>, one with a
+ * However, a pair of methods named {@code get()} and {@code put()}, one with a
  * return value, the other without, but with the same number of parameters, plus 1,
  * are recognized as a value getter/setter pair even without annotation. This behavior
  * can be changed by annotating the methods with the {@link Function} annotation.

File: src/main/java/com/googlecode/javacpp/Builder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011,2012 Samuel Audet
+ * Copyright (C) 2011,2012,2013 Samuel Audet
  *
  * This file is part of JavaCPP.
  *
@@ -663,13 +663,13 @@ public static void printHelp() {
         }
         System.out.println(
             "JavaCPP version " + version + "\n" +
-            "Copyright (C) 2011-2012 Samuel Audet <samuel.audet@gmail.com>\n" +
+            "Copyright (C) 2011-2013 Samuel Audet <samuel.audet@gmail.com>\n" +
             "Project site: http://code.google.com/p/javacpp/\n\n" +
 
             "Licensed under the GNU General Public License version 2 (GPLv2) with Classpath exception.\n" +
             "Please refer to LICENSE.txt or http://www.gnu.org/licenses/ for details.");
         System.out.println();
-        System.out.println("Usage: java -jar javacpp.jar [options] [class or package names]");
+        System.out.println("Usage: java -jar javacpp.jar [options] [class or package (suffixed with .* or .**)]");
         System.out.println();
         System.out.println("where options include:");
         System.out.println();

File: src/main/java/com/googlecode/javacpp/Generator.java
Patch:
@@ -513,7 +513,7 @@ private boolean doClasses(boolean handleExceptions, boolean defineAdapters, Stri
             out.println("    for (int i = 1; i < nOptions && argv != NULL; i++) {");
             out.println("        options[i].optionString = (char*)argv[i - 1];");
             out.println("    }");
-            out.println("    JavaVMInitArgs vm_args = { JNI_VERSION_1_6, nOptions, options };");
+            out.println("    JavaVMInitArgs vm_args = { " + JNI_VERSION + ", nOptions, options };");
             out.println("    return JNI_CreateJavaVM(&vm, (void **)&env, &vm_args);");
             out.println("}");
             out.println("#endif");

File: src/main/java/com/googlecode/javacpp/annotation/Platform.java
Patch:
@@ -24,4 +24,5 @@
     String[] framework()   default {};
     String[] preloadpath() default {};
     String[] preload()     default {};
+    String   library()     default "";
 }

File: src/main/java/com/googlecode/javacpp/Generator.java
Patch:
@@ -482,7 +482,8 @@ private boolean doClasses(boolean handleExceptions, boolean defineAdapters, Stri
             String name = "JavaCPP_" + mangle(c.getName());
             out.print("static void " + name + "_deallocate(");
             if (FunctionPointer.class.isAssignableFrom(c)) {
-                out.println(name + "* p) { JNIEnv *e; int a = JavaCPP_getEnv(&e); if (a >= 0) e->DeleteWeakGlobalRef(p->obj); delete p; JavaCPP_detach(a); }");
+                String typeName = getFunctionClassName(c);
+                out.println(typeName + "* p) { JNIEnv *e; int a = JavaCPP_getEnv(&e); if (a >= 0) e->DeleteWeakGlobalRef(p->obj); delete p; JavaCPP_detach(a); }");
             } else {
                 String[] typeName = getCPPTypeName(c);
                 out.println(typeName[0] + " p" + typeName[1] + ") { delete p; }");
@@ -1685,7 +1686,7 @@ private void doCallbackAllocator(Class cls, String callbackName) {
         out.println("        jvalue args[3];");
         out.println("        args[0].j = ptr_to_jlong(rptr);");
         out.println("        args[1].i = 1;");
-        out.println("        args[2].j = ptr_to_jlong(&" + instanceTypeName + "_deallocate);");
+        out.println("        args[2].j = ptr_to_jlong(&JavaCPP_" + mangle(cls.getName()) + "_deallocate);");
         deallocators.register(cls);
         out.println("        env->CallNonvirtualVoidMethodA(obj, JavaCPP_getClass(env, " +
                 jclasses.register(Pointer.class) + "), JavaCPP_initMID, args);");

File: src/main/java/com/googlecode/javacpp/Loader.java
Patch:
@@ -193,7 +193,7 @@ public static void appendProperty(Properties properties, String name,
             String separator, String ... values) {
         if (values == null || values.length == 0) {
             return;
-        } else if (values.length == 1) {
+        } else if (values.length == 1 && values[0] != null) {
             values = values[0].split(separator);
         }
         String oldValue = properties.getProperty(name, "");

File: src/main/java/com/googlecode/javacpp/annotation/Adapter.java
Patch:
@@ -14,5 +14,4 @@
 public @interface Adapter {
     String value();
     int argc() default 1;
-    String cast() default "";
 }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/Cast.java
Patch:
@@ -10,7 +10,7 @@
  * @author Samuel Audet
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.METHOD, ElementType.PARAMETER})
+@Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
 public @interface Cast {
-    String value();
-}
+    String[] value();
+}
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/StdString.java
Patch:
@@ -11,5 +11,5 @@
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD, ElementType.PARAMETER})
-@Adapter(value="StringAdapter", cast="std::string&")
+@Cast("std::string&") @Adapter("StringAdapter")
 public @interface StdString { }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/StdVector.java
Patch:
@@ -13,5 +13,5 @@
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 @Adapter("VectorAdapter")
 public @interface StdVector {
-    String value() default "";
+    String value() default ""; // template type
 }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/Adapter.java
Patch:
@@ -10,7 +10,7 @@
  * @author Samuel Audet
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.METHOD, ElementType.PARAMETER})
+@Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
 public @interface Adapter {
     String value();
     int argc() default 1;

File: src/main/java/com/googlecode/javacpp/FunctionPointer.java
Patch:
@@ -24,9 +24,9 @@
  *
  * @author Samuel Audet
  */
-public class FunctionPointer extends Pointer {
-    public FunctionPointer() { }
-    public FunctionPointer(Pointer p) { super(p); }
+public abstract class FunctionPointer extends Pointer {
+    protected FunctionPointer() { }
+    protected FunctionPointer(Pointer p) { super(p); }
 
     @Override public FunctionPointer position(int position) {
         return (FunctionPointer)super.position(position);

File: src/main/java/com/googlecode/javacpp/annotation/Namespace.java
Patch:
@@ -12,5 +12,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD})
 public @interface Namespace {
-    String value();
+    String value() default "";
 }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/Adapter.java
Patch:
@@ -13,7 +13,6 @@
 @Target({ElementType.METHOD, ElementType.PARAMETER})
 public @interface Adapter {
     String value();
-    boolean out() default false;
     int argc() default 1;
     String cast() default "";
 }
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/annotation/Const.java
Patch:
@@ -11,4 +11,6 @@
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
-public @interface Const { }
\ No newline at end of file
+public @interface Const {
+    boolean value() default false;
+}
\ No newline at end of file

File: src/main/java/com/googlecode/javacpp/Generator.java
Patch:
@@ -824,6 +824,7 @@ private String doReturnBefore(MethodInformation methodInfo) {
                 } else if (methodInfo.returnType == String.class) {
                     out.println("    jstring r = NULL;");
                     out.println("    const char* rpointer;");
+                    returnVariable += "(const char*)";
                 } else if (methodInfo.bufferGetter) {
                     out.println("    jobject r = NULL;");
                     out.println("    char* rpointer;");
@@ -866,7 +867,7 @@ private void doCall(MethodInformation methodInfo, String returnVariable) {
                     !(getParameterBy(methodInfo, k) instanceof ByRef) &&
                     methodInfo.parameterTypes[k] == String.class) {
                 // special considerations for char arrays as strings
-                out.print(indent + "strcpy(");
+                out.print(indent + "strcpy((char*)");
                 wantsPointer = true;
                 prefix = ", ";
             } else if (k >= 1 && methodInfo.parameterTypes[0].isArray() &&
@@ -1696,7 +1697,7 @@ public static MethodInformation getMethodInformation(Method method) {
         return info;
     }
 
-    public static boolean getNoException(Class cls, Method method) {
+    public static boolean getNoException(Class<?> cls, Method method) {
         boolean noException = baseClasses.contains(cls) ||
                 method.isAnnotationPresent(NoException.class);
         while (!noException && cls != null) {

File: src/main/java/com/googlecode/javacpp/annotation/Index.java
Patch:
@@ -12,5 +12,5 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.METHOD})
 public @interface Index {
-    int value() default 0;
+    int value() default 1;
 }

File: src/main/java/com/googlecode/javacpp/Generator.java
Patch:
@@ -310,8 +310,8 @@ private boolean doClasses(Class<?> ... classes) {
         out.println("        vec2(pointer ? std::vector<T>(pointer, pointer + capacity) : std::vector<T>()), vec(vec2) { }");
         out.println("    VectorAdapter(const std::vector<T>& vec) : pointer(0), capacity(0), vec((std::vector<T>&)vec) { }");
         out.println("    void assign(P* pointer, typename std::vector<T>::size_type capacity) {");
-        out.println("        this.pointer = pointer;");
-        out.println("        this.capacity = capacity;");
+        out.println("        this->pointer = pointer;");
+        out.println("        this->capacity = capacity;");
         out.println("        vec.assign(pointer, pointer + capacity);");
         out.println("    }");
         out.println("    static void deallocate(P* pointer) { delete[] pointer; }");

