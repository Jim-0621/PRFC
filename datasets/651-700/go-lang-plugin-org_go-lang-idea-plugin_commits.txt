File: src/com/goide/runconfig/GoRunningState.java
Patch:
@@ -49,7 +49,7 @@ public GoRunningState(@NotNull ExecutionEnvironment env, @NotNull Module module,
   protected ProcessHandler startProcess() throws ExecutionException {
     GoExecutor executor = patchExecutor(createCommonExecutor());
     GeneralCommandLine commandLine = executor.withParameterString(myConfiguration.getParams()).createCommandLine();
-    KillableColoredProcessHandler handler = new KillableColoredProcessHandler(commandLine);
+    KillableColoredProcessHandler handler = new KillableColoredProcessHandler(commandLine, true);
     ProcessTerminatedListener.attach(handler);
     return handler;
   }

File: src/com/goide/util/GoExecutor.java
Patch:
@@ -213,7 +213,7 @@ public boolean execute() {
     try {
       commandLine = createCommandLine();
       GeneralCommandLine finalCommandLine = commandLine;
-      myProcessHandler = new KillableColoredProcessHandler(finalCommandLine) {
+      myProcessHandler = new KillableColoredProcessHandler(finalCommandLine, true) {
         @Override
         public void startNotify() {
           if (myShowGoEnvVariables) {

File: src/com/goide/inspections/GoStructInitializationInspection.java
Patch:
@@ -108,7 +108,7 @@ public GoReplaceWithNamedStructFieldQuickFix(@NotNull String structField) {
     public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
       PsiElement startElement = descriptor.getStartElement();
       if (startElement instanceof GoElement) {
-        startElement.replace(GoElementFactory.createNamedStructField(project, myStructField, startElement.getText()));
+        startElement.replace(GoElementFactory.createLiteralValueElement(project, myStructField, startElement.getText()));
       }
     }
   }

File: src/com/goide/psi/impl/GoElementFactory.java
Patch:
@@ -256,8 +256,8 @@ public static GoType createType(@NotNull Project project, @NotNull String text)
     return PsiTreeUtil.findChildOfType(file, GoType.class);
   }
 
-  public static PsiElement createNamedStructField(@NotNull Project project, @NotNull String field, @NotNull String element) {
-    GoFile file = createFileFromText(project, "package a; var _ = struct { a string } { " + field + ": " + element + " }");
+  public static PsiElement createLiteralValueElement(@NotNull Project project, @NotNull String key, @NotNull String value) {
+    GoFile file = createFileFromText(project, "package a; var _ = struct { a string } { " + key + ": " + value + " }");
     return PsiTreeUtil.findChildOfType(file, GoElement.class);
   }
 

File: src/com/goide/runconfig/testing/frameworks/gobench/GobenchEventsConverter.java
Patch:
@@ -30,8 +30,8 @@
 import java.util.regex.Pattern;
 
 public class GobenchEventsConverter extends GoTestEventsConverterBaseImpl {
-  private static final Pattern RUN = Pattern.compile("^(Benchmark" + GoConstants.IDENTIFIER_REGEX + ")");
-  private static final Pattern FAIL = Pattern.compile("^--- FAIL: (Benchmark" + GoConstants.IDENTIFIER_REGEX + ").*");
+  private static final Pattern RUN = Pattern.compile("^(Benchmark(" + GoConstants.TEST_NAME_REGEX + ")?)");
+  private static final Pattern FAIL = Pattern.compile("^--- FAIL: (Benchmark(" + GoConstants.TEST_NAME_REGEX + ")?).*");
 
   public GobenchEventsConverter(@NotNull TestConsoleProperties properties) {
     super(GobenchFramework.NAME, properties);

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -76,7 +76,7 @@ public void setUp() throws Exception {
       GoInvalidStringOrCharInspection.class,
       GoMixedNamedUnnamedParametersInspection.class,
       GoAnonymousFieldDefinitionTypeInspection.class,
-      GoStringIndexIsByteInspection.class
+      GoStringAndByteTypeMismatchInspection.class
     );
   }
 

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -75,7 +75,8 @@ public void setUp() throws Exception {
       GoAssignmentToReceiverInspection.class,
       GoInvalidStringOrCharInspection.class,
       GoMixedNamedUnnamedParametersInspection.class,
-      GoAnonymousFieldDefinitionTypeInspection.class
+      GoAnonymousFieldDefinitionTypeInspection.class,
+      GoStringIndexIsByteInspection.class
     );
   }
 
@@ -172,6 +173,7 @@ protected boolean isWriteActionRequired() {
   public void testMixedNamedUnnamedParameters() { doTest(); }
   public void testStringInStructSliceWithThirdIndex() { doTest(); }
   public void testAnonymousFieldDefinition()  { doTest(); }
+  public void testStringIndexIsByte()         { doTest(); }
 
   public void testCodedImportString() {
     myFixture.addFileToProject("a/a.go", "package a\n const A = 3");

File: tests/com/goide/psi/GoImportListTest.java
Patch:
@@ -30,6 +30,7 @@ public class GoImportListTest extends GoCodeInsightFixtureTestCase {
   public void testDoNotModifyCImport_1()                                { doAddImportTest(); }
   public void testDoNotModifyCImport_2()                                { doAddImportTest(); }
   public void testInvalidImport()                                       { doAddImportTest(); }
+  public void testInvalidImport2()                                      { doAddImportTest(); }
   
   private void doAddImportTest() {
     myFixture.configureByFile(getTestName(true) + ".go");

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -2435,7 +2435,7 @@ static boolean LiteralTypeExprInner(PsiBuilder b, int l) {
   }
 
   /* ********************************************************** */
-  // (<<isModeOff "BLOCK?">> | <<isModeOn "PAR">> | <<prevIsArrayType>>) '{' ElementList? '}'
+  // (<<isModeOff "BLOCK?">> | <<isModeOn "PAR">> | <<prevIsType>>) '{' ElementList? '}'
   public static boolean LiteralValue(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "LiteralValue")) return false;
     boolean r, p;
@@ -2449,14 +2449,14 @@ public static boolean LiteralValue(PsiBuilder b, int l) {
     return r || p;
   }
 
-  // <<isModeOff "BLOCK?">> | <<isModeOn "PAR">> | <<prevIsArrayType>>
+  // <<isModeOff "BLOCK?">> | <<isModeOn "PAR">> | <<prevIsType>>
   private static boolean LiteralValue_0(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "LiteralValue_0")) return false;
     boolean r;
     Marker m = enter_section_(b);
     r = isModeOff(b, l + 1, "BLOCK?");
     if (!r) r = isModeOn(b, l + 1, "PAR");
-    if (!r) r = prevIsArrayType(b, l + 1);
+    if (!r) r = prevIsType(b, l + 1);
     exit_section_(b, m, null, r);
     return r;
   }

File: src/com/goide/parser/GoParserUtil.java
Patch:
@@ -135,10 +135,10 @@ public static boolean isModeOff(@NotNull PsiBuilder builder_, @SuppressWarnings(
     return getParsingModes(builder_).get(mode) == 0;
   }
 
-  public static boolean prevIsArrayType(@NotNull PsiBuilder builder_, @SuppressWarnings("UnusedParameters") int level) {
+  public static boolean prevIsType(@NotNull PsiBuilder builder_, @SuppressWarnings("UnusedParameters") int level) {
     LighterASTNode marker = builder_.getLatestDoneMarker();
     IElementType type = marker != null ? marker.getTokenType() : null;
-    return type == GoTypes.ARRAY_OR_SLICE_TYPE || type == GoTypes.MAP_TYPE;
+    return type == GoTypes.ARRAY_OR_SLICE_TYPE || type == GoTypes.MAP_TYPE || type == GoTypes.STRUCT_TYPE;
   }
   
   public static boolean keyOrValueExpression(@NotNull PsiBuilder builder_, int level) {

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -34,6 +34,7 @@ public GoParserTest() {
   public void testIncompleteRanges()                { doTest(false); }
   public void testTorture()                         { doTest(true);  }
   public void testLiteralValues()                   { doTest(true);  }
+  public void testLiteralValuesElse()               { doTest(true);  }
   public void testIfComposite()                     { doTest(true);  }
   public void testArrayTypes()                      { doTest(true);  }
   public void testArrayTypesInRanges()              { doTest(true);  }

File: src/com/goide/GoParserDefinition.java
Patch:
@@ -47,7 +47,7 @@ public class GoParserDefinition implements ParserDefinition {
   public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, RAW_STRING, CHAR);
   public static final TokenSet NUMBERS = TokenSet.create(INT, FLOAT, FLOATI, DECIMALI, FLOATI); // todo: HEX, OCT,
   public static final TokenSet KEYWORDS = TokenSet.create(
-    PACKAGE, IMPORT, BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT,
+    BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT,
     INTERFACE, MAP, PACKAGE, RANGE, RETURN, SELECT, STRUCT, SWITCH, TYPE_, VAR);
   public static final TokenSet OPERATORS = TokenSet.create(
     EQ, ASSIGN, NOT_EQ, NOT, PLUS_PLUS, PLUS_ASSIGN, PLUS, MINUS_MINUS, MINUS_ASSIGN, MINUS, COND_OR, BIT_OR_ASSIGN, BIT_OR,

File: src/com/goide/GoParserDefinition.java
Patch:
@@ -47,7 +47,7 @@ public class GoParserDefinition implements ParserDefinition {
   public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, RAW_STRING, CHAR);
   public static final TokenSet NUMBERS = TokenSet.create(INT, FLOAT, FLOATI, DECIMALI, FLOATI); // todo: HEX, OCT,
   public static final TokenSet KEYWORDS = TokenSet.create(
-    PACKAGE, IMPORT, BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT,
+    BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT,
     INTERFACE, MAP, PACKAGE, RANGE, RETURN, SELECT, STRUCT, SWITCH, TYPE_, VAR);
   public static final TokenSet OPERATORS = TokenSet.create(
     EQ, ASSIGN, NOT_EQ, NOT, PLUS_PLUS, PLUS_ASSIGN, PLUS, MINUS_MINUS, MINUS_ASSIGN, MINUS, COND_OR, BIT_OR_ASSIGN, BIT_OR,

File: src/com/goide/inspections/GoImportUsedAsNameInspection.java
Patch:
@@ -60,7 +60,9 @@ public void visitVarDefinition(@NotNull GoVarDefinition o) {
 
   private static void check(@NotNull GoNamedElement element, @NotNull ProblemsHolder holder) {
     String name = element.getName();
-    if (name != null && element.getContainingFile().getImportMap().containsKey(name)) {
+    if (StringUtil.isNotEmpty(name) &&
+        !"_".equals(name) &&
+        element.getContainingFile().getImportMap().containsKey(name)) {
       registerProblem(holder, element);
     }
   }

File: src/com/goide/inspections/GoRedeclareImportAsFunctionInspection.java
Patch:
@@ -32,7 +32,9 @@ protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder, @NotNull Loca
       @Override
       public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
         String functionName = o.getName();
-        if (StringUtil.isNotEmpty(functionName) && o.getContainingFile().getImportMap().containsKey(functionName)) {
+        if (StringUtil.isNotEmpty(functionName) &&
+            !"_".equals(functionName) &&
+            o.getContainingFile().getImportMap().containsKey(functionName)) {
           holder.registerProblem(o.getIdentifier(), "import \"" + functionName + "\" redeclared in this block", new GoRenameQuickFix(o));
         }
       }

File: src/com/goide/inspections/GoImportUsedAsNameInspection.java
Patch:
@@ -60,7 +60,9 @@ public void visitVarDefinition(@NotNull GoVarDefinition o) {
 
   private static void check(@NotNull GoNamedElement element, @NotNull ProblemsHolder holder) {
     String name = element.getName();
-    if (name != null && element.getContainingFile().getImportMap().containsKey(name)) {
+    if (StringUtil.isNotEmpty(name) &&
+        !"_".equals(name) &&
+        element.getContainingFile().getImportMap().containsKey(name)) {
       registerProblem(holder, element);
     }
   }

File: src/com/goide/inspections/GoRedeclareImportAsFunctionInspection.java
Patch:
@@ -32,7 +32,9 @@ protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder, @NotNull Loca
       @Override
       public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
         String functionName = o.getName();
-        if (StringUtil.isNotEmpty(functionName) && o.getContainingFile().getImportMap().containsKey(functionName)) {
+        if (StringUtil.isNotEmpty(functionName) &&
+            !"_".equals(functionName) &&
+            o.getContainingFile().getImportMap().containsKey(functionName)) {
           holder.registerProblem(o.getIdentifier(), "import \"" + functionName + "\" redeclared in this block", new GoRenameQuickFix(o));
         }
       }

File: src/com/goide/runconfig/GoRunConfigurationBase.java
Patch:
@@ -112,9 +112,9 @@ public void checkConfiguration() throws RuntimeConfigurationException {
   public void writeExternal(Element element) throws WriteExternalException {
     super.writeExternal(element);
     writeModule(element);
-    addNonEmptyElement(element, myWorkingDirectory, WORKING_DIRECTORY_NAME);
-    addNonEmptyElement(element, myGoParams, GO_PARAMETERS_NAME);
-    addNonEmptyElement(element, myParams, PARAMETERS_NAME);
+    addNonEmptyElement(element, WORKING_DIRECTORY_NAME, myWorkingDirectory);
+    addNonEmptyElement(element, GO_PARAMETERS_NAME, myGoParams);
+    addNonEmptyElement(element, PARAMETERS_NAME, myParams);
     if (!myCustomEnvironment.isEmpty()) {
       EnvironmentVariablesComponent.writeExternal(element, myCustomEnvironment);
     }

File: src/com/goide/editor/GoFoldingBuilder.java
Patch:
@@ -129,7 +129,7 @@ protected void buildLanguageFoldRegions(@NotNull List<FoldingDescriptor> result,
       foldTypes(type.getSpecType().getType(), result);
     }
 
-    for (GoExprCaseClause caseClause : PsiTreeUtil.findChildrenOfType(file, GoExprCaseClause.class)) {
+    for (GoCaseClause caseClause : PsiTreeUtil.findChildrenOfType(file, GoCaseClause.class)) {
       PsiElement colon = caseClause.getColon();
       if (colon != null && !caseClause.getStatementList().isEmpty()) {
         fold(caseClause, colon.getNextSibling(), caseClause, "...", result);

File: tests/com/goide/editor/GoFoldingBuilderTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -43,4 +43,5 @@ protected String getBasePath() {
   public void testIfStatement()                                   { doTest(); }
   public void testForStatement()                                  { doTest(); }
   public void testSwitchSelectCaseStatement()                     { doTest(); }
+  public void testTypeSwitchStatement()                           { doTest(); }
 }

File: src/com/goide/GoFileElementType.java
Patch:
@@ -31,7 +31,7 @@
 
 public class GoFileElementType extends IStubFileElementType<GoFileStub> {
   public static final IStubFileElementType INSTANCE = new GoFileElementType();
-  public static final int VERSION = 20;
+  public static final int VERSION = 21;
 
   private GoFileElementType() {
     super("GO_FILE", GoLanguage.INSTANCE);

File: src/com/goide/GoFileElementType.java
Patch:
@@ -60,7 +60,7 @@ protected StubElement createStubForFile(@NotNull PsiFile file) {
   @Override
   public void indexStub(@NotNull GoFileStub stub, @NotNull IndexSink sink) {
     super.indexStub(stub, sink);
-    String packageName = stub.getPsi().getPackageName();
+    String packageName = stub.getPackageName();
     if (StringUtil.isNotEmpty(packageName)) {
       sink.occurrence(GoPackagesIndex.KEY, packageName);
     }

File: src/com/goide/stubs/types/GoMethodDeclarationStubElementType.java
Patch:
@@ -75,7 +75,7 @@ public void indexStub(@NotNull GoMethodDeclarationStub stub, @NotNull IndexSink
     if (!StringUtil.isEmpty(typeName)) {
       StubElement parent = stub.getParentStub();
       if (parent instanceof GoFileStub) {
-        String packageName = ((GoFileStub)parent).getPsi().getPackageName();
+        String packageName = ((GoFileStub)parent).getPackageName();
         if (!StringUtil.isEmpty(typeName)) {
           sink.occurrence(GoMethodIndex.KEY, packageName + "." + typeName);
         }

File: src/com/goide/stubs/types/GoNamedStubElementType.java
Patch:
@@ -53,7 +53,7 @@ public void indexStub(@NotNull S stub, @NotNull IndexSink sink) {
       StubElement parent = stub.getParentStub();
       while (parent != null) {
         if (parent instanceof GoFileStub) {
-          packageName = ((GoFileStub)parent).getPsi().getPackageName();
+          packageName = ((GoFileStub)parent).getPackageName();
           break;
         }
         parent = parent.getParentStub();

File: src/com/goide/inspections/GoAnonymousFieldDefinitionTypeInspection.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.goide.psi.GoAnonymousFieldDefinition;
 import com.goide.psi.GoVisitor;
+import com.goide.quickfix.GoCreateWrapperTypeQuickFix;
 import com.intellij.codeInspection.LocalInspectionToolSession;
 import com.intellij.codeInspection.ProblemsHolder;
 import org.jetbrains.annotations.NotNull;
@@ -31,7 +32,8 @@ protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder,
       @Override
       public void visitAnonymousFieldDefinition(@NotNull GoAnonymousFieldDefinition o) {
         if (o.getTypeReferenceExpression() == null) {
-          holder.registerProblem(o, "Invalid type: must be typeName or *typeName");
+          holder.registerProblem(o, "Invalid type " + o.getType().getText() + ": must be typeName or *typeName",
+                                 new GoCreateWrapperTypeQuickFix(o.getType()));
         }
       }
     };

File: tests/com/goide/quickfix/GoCreateWrapperTypeQuickFixTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,7 @@
 import com.goide.inspections.unresolved.GoUnresolvedReferenceInspection;
 import org.jetbrains.annotations.NotNull;
 
-public class GoCreateTypeQuickFixTest extends GoQuickFixTestBase {
+public class GoCreateWrapperTypeQuickFixTest extends GoQuickFixTestBase {
   private static final String CREATE_TYPE_A = "Create type 'A'";
 
   @Override

File: src/com/goide/usages/GoReadWriteAccessDetector.java
Patch:
@@ -48,6 +48,9 @@ public Access getReferenceAccess(@Nullable PsiElement referencedElement, @NotNul
   @NotNull
   @Override
   public Access getExpressionAccess(@Nullable PsiElement e) {
+    if (e instanceof GoFieldName) {
+      return e.getParent() instanceof GoKey ? Access.Write : Access.Read;
+    }
     GoReferenceExpression referenceExpression = PsiTreeUtil.getNonStrictParentOfType(e, GoReferenceExpression.class);
     return referenceExpression != null ? referenceExpression.getReadWriteAccess() : Access.Read;
   }

File: src/com/goide/dlv/protocol/DlvApi.java
Patch:
@@ -78,7 +78,7 @@ public static class Thread {
     // ID is a unique identifier for the thread.
     public int id;
     // PC is the current program counter for the thread.
-    public int pc;
+    public long pc;
     // File is the file for the program counter.
     public String file;
     // Line is the line number for the program counter.
@@ -88,7 +88,7 @@ public static class Thread {
   }
 
   public static class Location {
-    public int pc;
+    public long pc;
     public String file;
     public int line;
     public Function function;
@@ -193,7 +193,7 @@ public static class Goroutine {
     // ID is a unique identifier for the goroutine.
     public int id;
     // PC is the current program counter for the goroutine.
-    public int pc;
+    public long pc;
     // File is the file for the program counter.
     public String file;
     // Line is the line number for the program counter.

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -2219,14 +2219,13 @@ private static boolean ImportSpecs_2(PsiBuilder b, int l) {
   }
 
   /* ********************************************************** */
-  // string | raw_string
+  // StringLiteral
   public static boolean ImportString(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "ImportString")) return false;
     if (!nextTokenIs(b, "<import string>", RAW_STRING, STRING)) return false;
     boolean r;
     Marker m = enter_section_(b, l, _NONE_, IMPORT_STRING, "<import string>");
-    r = consumeToken(b, STRING);
-    if (!r) r = consumeToken(b, RAW_STRING);
+    r = StringLiteral(b, l + 1);
     exit_section_(b, l, m, r, false, null);
     return r;
   }

File: src/com/goide/completion/GoCompletionContributor.java
Patch:
@@ -101,7 +101,8 @@ private static LookupElement packageLookup(@NotNull String packageName, int prio
   }
 
   private static PsiElementPattern.Capture<PsiElement> importString() {
-    return psiElement().withElementType(GoParserDefinition.STRING_LITERALS).withParent(GoImportString.class);
+    return psiElement().withElementType(GoParserDefinition.STRING_LITERALS).withParent(GoStringLiteral.class)
+      .withSuperParent(2, GoImportString.class);
   }
 
   private static PsiElementPattern.Capture<PsiElement> referenceExpression() {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -1152,7 +1152,7 @@ public static boolean shouldGoDeeper(@SuppressWarnings("UnusedParameters") GoTyp
     return false;
   }
 
-  public static boolean shouldGoDeeper(@SuppressWarnings("UnusedParameters") GoType o) {
+  public static boolean shouldGoDeeper(@NotNull GoType o) {
     return o instanceof GoInterfaceType || o instanceof GoStructType;
   }
 
@@ -1162,7 +1162,7 @@ public static boolean isForSideEffects(@NotNull GoImportSpec o) {
 
   @NotNull
   public static String getPath(@NotNull GoImportString o) {
-    return unquote(o.getText());
+    return o.getStringLiteral().getDecodedText();
   }
 
   @NotNull

File: src/com/goide/codeInsight/imports/GoExcludePathLookupActionProvider.java
Patch:
@@ -38,7 +38,7 @@ public class GoExcludePathLookupActionProvider implements LookupActionProvider {
   @Override
   public void fillActions(LookupElement element, Lookup lookup, Consumer<LookupElementAction> consumer) {
     PsiElement psiElement = element.getPsiElement();
-    PsiFile file = psiElement != null ? psiElement.getContainingFile() : null;
+    PsiFile file = psiElement != null && psiElement.isValid() ? psiElement.getContainingFile() : null;
     String importPath = file instanceof GoFile ? ((GoFile)file).getImportPath(false) : null;
     if (importPath != null) {
       Project project = psiElement.getProject();
@@ -72,7 +72,7 @@ public Result performLookupAction() {
       ApplicationManager.getApplication().invokeLater(new Runnable() {
         @Override
         public void run() {
-          final GoAutoImportConfigurable configurable = new GoAutoImportConfigurable(myProject, true);
+          GoAutoImportConfigurable configurable = new GoAutoImportConfigurable(myProject, true);
           ShowSettingsUtil.getInstance().editConfigurable(myProject, configurable, new Runnable() {
               @Override
               public void run() {

File: tests/com/goide/quickfix/GoBoolExpressionsInspectionTest.java
Patch:
@@ -51,7 +51,6 @@ public static Collection<Object[]> data() {
     });
   }
 
-  @SuppressWarnings("JUnitTestCaseWithNonTrivialConstructors")
   public GoBoolExpressionsInspectionTest(String vars, String expr, String after) {
     this.expr = expr;
     this.vars = vars;

File: tests/com/goide/inspections/GoDeferGoInspectionTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.goide.inspections;
 
 import com.goide.quickfix.GoQuickFixTestBase;
-import com.goide.quickfix.GoReplaceWithCorrectDeferRecoverQuickFix;
 import com.intellij.testFramework.LightProjectDescriptor;
 import org.jetbrains.annotations.NotNull;
 
@@ -57,7 +56,7 @@ public void testValid() {
     myFixture.testHighlighting(getTestName(true) + ".go");
   }
 
-  public void testDeferRecover() { doTest(GoReplaceWithCorrectDeferRecoverQuickFix.QUICK_FIX_NAME, true); }
+  public void testDeferRecover() { doTest(GoDeferGoInspection.REPLACE_WITH_CORRECT_DEFER_RECOVER, true); }
 
   @NotNull
   @Override

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -386,6 +386,7 @@ public void testCGOImportInTestFile() {
   }
 
   public void testDeferInLoop() { doWeakTest(); }
+  public void testDeferGo()     { doWeakTest(); }
 
   public void testCommentStart() { doWeakTest(); }
 

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -66,6 +66,7 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testParameter()                         { doTest(); }
   public void testResultParameter()                   { doTest(); }
   public void testReceiver()                          { doTest(); }
+  public void testStructWithAnon()                    { doTest(); }
 
   public void testMultiBlockDoc()                     { doConverterTest(); }
   public void testIndentedBlock()                     { doConverterTest(); }

File: src/com/goide/psi/impl/GoTypeReference.java
Patch:
@@ -143,7 +143,7 @@ public boolean value(GoVarDefinition v) {
     return true;
   }
 
-  private final static Set<String> DOC_ONLY_TYPES = ContainerUtil.set("Type", "Type1", "IntegerType", "FloatType", "ComplexType");
+  public final static Set<String> DOC_ONLY_TYPES = ContainerUtil.set("Type", "Type1", "IntegerType", "FloatType", "ComplexType");
   private static final Condition<GoTypeSpec> BUILTIN_TYPE = new Condition<GoTypeSpec>() {
     @Override
     public boolean value(GoTypeSpec spec) {

File: src/com/goide/psi/impl/GoTypeReference.java
Patch:
@@ -143,7 +143,7 @@ private boolean processUnqualifiedResolve(@NotNull GoFile file,
     if (!processNamedElements(processor, state, result, localResolve)) return false;
     if (!processNamedElements(processor, state, file.getTypes(), localResolve)) return false;
     PsiDirectory dir = file.getOriginalFile().getParent();
-    if (!GoReference.processDirectory(dir, file, file.getPackageName(), processor, state, true)) return false;
+    if (!processDirectory(dir, file, file.getPackageName(), processor, state, true)) return false;
     if (PsiTreeUtil.getParentOfType(getElement(), GoReceiver.class) != null) return true;
     if (!GoReference.processImports(file, processor, state, myElement)) return false;
     if (!processBuiltin(processor, state, myElement)) return false;

File: src/com/goide/completion/GoReferenceCompletionProvider.java
Patch:
@@ -73,11 +73,11 @@ else if (reference instanceof GoReference) {
     else if (reference instanceof GoTypeReference) {
       PsiElement element = reference.getElement();
       final PsiElement spec = PsiTreeUtil.getParentOfType(element, GoFieldDeclaration.class, GoTypeSpec.class);
-      final boolean insideParameter = PsiTreeUtil.getParentOfType(element, GoParameterDeclaration.class) != null;
+      final boolean insideParameterOrReceiver = PsiTreeUtil.getParentOfType(element, GoParameterDeclaration.class, GoReceiver.class) != null;
       ((GoTypeReference)reference).processResolveVariants(new MyGoScopeProcessor(result, file, true) {
         @Override
         protected boolean accept(@NotNull PsiElement e) {
-          return e != spec && !(insideParameter &&
+          return e != spec && !(insideParameterOrReceiver &&
                                 (e instanceof GoNamedSignatureOwner || e instanceof GoVarDefinition || e instanceof GoConstDefinition));
         }
       });

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -263,7 +263,7 @@ private boolean processInTypeRef(@Nullable GoTypeReferenceExpression e, @NotNull
   }
 
   @Nullable
-  private static String getPath(@Nullable PsiFile file) {
+  protected static String getPath(@Nullable PsiFile file) {
     if (file == null) return null;
     VirtualFile virtualFile = file.getOriginalFile().getVirtualFile();
     return virtualFile == null ? null : virtualFile.getPath();

File: src/com/goide/psi/impl/GoTypeReference.java
Patch:
@@ -123,6 +123,7 @@ private boolean processUnqualifiedResolve(@NotNull GoFile file,
     if (!processNamedElements(processor, state, file.getTypes(), localResolve)) return false;
     PsiDirectory dir = file.getOriginalFile().getParent();
     if (!GoReference.processDirectory(dir, file, file.getPackageName(), processor, state, true)) return false;
+    if (PsiTreeUtil.getParentOfType(getElement(), GoReceiver.class) != null) return true;
     if (!GoReference.processImports(file, processor, state, myElement)) return false;
     if (!processBuiltin(processor, state, myElement)) return false;
     if (getIdentifier().textMatches(GoConstants.NIL) && PsiTreeUtil.getParentOfType(myElement, GoTypeCaseClause.class) != null) {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -66,7 +66,6 @@ public void setUp() throws Exception {
       GoCommentStartInspection.class,
       GoPlaceholderCountInspection.class,
       GoEmbeddedInterfacePointerInspection.class,
-      GoMethodOnNonLocalTypeInspection.class,
       GoUnderscoreUsedAsValueInspection.class,
       GoRangeIterationOnIllegalTypeInspection.class,
       GoUnusedParameterInspection.class,

File: src/com/goide/template/GoLiveTemplateContextType.java
Patch:
@@ -161,8 +161,7 @@ private static boolean isInsideFieldTypeDeclaration(@Nullable PsiElement element
       if (element != null) {
         PsiElement parent = element.getParent();
         if (parent instanceof GoTypeReferenceExpression) {
-          PsiElement grandParent = parent.getParent();
-          return grandParent instanceof GoType && grandParent.getParent() instanceof GoFieldDeclaration;
+          return PsiTreeUtil.skipParentsOfType(parent, GoType.class) instanceof GoFieldDeclaration;
         }
       }
       return false;

File: tests/com/goide/editor/GoLiveTemplateTest.java
Patch:
@@ -82,7 +82,7 @@ public void testForInBlock() {
   public void testVarDeclarationInBlock() {
     myFixture.configureByText("a.go", "package main; func main() { <caret> }");
     myFixture.type(":\t");
-    myFixture.checkResult("package main; func main() { name := <caret> }");
+    myFixture.checkResult("package main; func main() {\n\tname :=  }");
   }
 
   public void testVarDeclarationInLabel() {

File: src/com/goide/template/GoLiveTemplatesProvider.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,7 +24,7 @@ public class GoLiveTemplatesProvider implements DefaultLiveTemplatesProvider {
   @NotNull
   @Override
   public String[] getDefaultLiveTemplateFiles() {
-    return new String[]{"/liveTemplates/go"};
+    return new String[]{"/liveTemplates/go", "/liveTemplates/goTags"};
   }
 
   @Nullable

File: src/com/goide/inspections/GoPlaceholderCountInspection.java
Patch:
@@ -310,7 +310,9 @@ private static String getValue(@Nullable GoExpression expression) {
     if (expression instanceof GoAddExpr) {
       StringBuilder result = new StringBuilder();
       for (GoExpression expr : ((GoAddExpr)expression).getExpressionList()) {
-        result.append(getValue(expr));
+        String value = getValue(expr);
+        if (value == null) return null;
+        result.append(value);
       }
       return StringUtil.nullize(result.toString());
     }

File: src/com/goide/inspections/GoPlaceholderCountInspection.java
Patch:
@@ -310,7 +310,9 @@ private static String getValue(@Nullable GoExpression expression) {
     if (expression instanceof GoAddExpr) {
       StringBuilder result = new StringBuilder();
       for (GoExpression expr : ((GoAddExpr)expression).getExpressionList()) {
-        result.append(getValue(expr));
+        String value = getValue(expr);
+        if (value == null) return null;
+        result.append(value);
       }
       return StringUtil.nullize(result.toString());
     }

File: src/com/goide/inspections/GoDirectAssignToStructFieldInMapInspection.java
Patch:
@@ -37,7 +37,7 @@ public void visitLeftHandExprList(@NotNull GoLeftHandExprList o) {
           GoExpression expr = ContainerUtil.getFirstItem(((GoSelectorExpr)expression).getExpressionList());
           if (expr instanceof GoIndexOrSliceExpr) {
             GoType exprType = expr.getGoType(null);
-            if (exprType != null && exprType.getParent() instanceof GoMapType) {
+            if (exprType != null && !(exprType instanceof GoPointerType) && exprType.getParent() instanceof GoMapType) {
               holder.registerProblem(o, "cannot assign to " + expression.getText(), GENERIC_ERROR_OR_WARNING);
             }
           }

File: src/com/goide/inspections/GoDirectAssignToStructFieldInMapInspection.java
Patch:
@@ -37,7 +37,7 @@ public void visitLeftHandExprList(@NotNull GoLeftHandExprList o) {
           GoExpression expr = ContainerUtil.getFirstItem(((GoSelectorExpr)expression).getExpressionList());
           if (expr instanceof GoIndexOrSliceExpr) {
             GoType exprType = expr.getGoType(null);
-            if (exprType != null && exprType.getParent() instanceof GoMapType) {
+            if (exprType != null && !(exprType instanceof GoPointerType) && exprType.getParent() instanceof GoMapType) {
               holder.registerProblem(o, "cannot assign to " + expression.getText(), GENERIC_ERROR_OR_WARNING);
             }
           }

File: tests/com/goide/lexer/GoLexerTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 import com.intellij.lexer.Lexer;
 import com.intellij.openapi.util.io.FileUtil;
 import com.intellij.openapi.util.text.StringUtil;
+import com.intellij.openapi.vfs.CharsetToolkit;
 import com.intellij.testFramework.LexerTestCase;
 import org.jetbrains.annotations.NotNull;
 
@@ -48,7 +49,7 @@ public class GoLexerTest extends LexerTestCase {
 
   private void doTest() {
     try {
-      String text = FileUtil.loadFile(new File("./" + PATH + "/" + getTestName(true) + ".go"));
+      String text = FileUtil.loadFile(new File("./" + PATH + "/" + getTestName(true) + ".go"), CharsetToolkit.UTF8);
       String actual = printTokens(StringUtil.convertLineSeparators(text.trim()), 0);
       assertSameLinesWithFile(new File(PATH + "/" + getTestName(true) + ".txt").getAbsolutePath(), actual);
     } catch (IOException e) {

File: src/com/goide/completion/GoStructLiteralCompletion.java
Patch:
@@ -70,7 +70,7 @@ static Variants allowedVariants(@Nullable GoReferenceExpression structFieldRefer
       return Variants.NONE;
     }
 
-    GoType type = GoPsiImplUtil.getLiteralType(element);
+    GoType type = GoPsiImplUtil.getLiteralType(element, true);
     if (!(type instanceof GoStructType)) {
       return Variants.NONE;
     }

File: src/com/goide/inspections/GoStructInitializationInspection.java
Patch:
@@ -46,7 +46,7 @@ public void visitCompositeLit(@NotNull GoCompositeLit o) {
         if (PsiTreeUtil.getParentOfType(o, GoReturnStatement.class, GoShortVarDeclaration.class, GoAssignmentStatement.class) == null) {
           return;
         }
-        GoType refType = GoPsiImplUtil.getLiteralType(o);
+        GoType refType = GoPsiImplUtil.getLiteralType(o, true);
         if (refType instanceof GoStructType) {
           processStructType((GoStructType)refType, o, holder);
         }

File: src/com/goide/psi/impl/GoFieldNameReference.java
Patch:
@@ -43,7 +43,7 @@ public boolean execute(@NotNull PsiElement e, @NotNull ResolveState state) {
     GoValue value = PsiTreeUtil.getParentOfType(myElement, GoValue.class);
     if (key == null && (value == null || PsiTreeUtil.getPrevSiblingOfType(value, GoKey.class) != null)) return true;
 
-    GoType type = GoPsiImplUtil.getLiteralType(myElement);
+    GoType type = GoPsiImplUtil.getLiteralType(myElement, true);
     if (!processStructType(fieldProcessor, type)) return false;
     return !(type instanceof GoPointerType && !processStructType(fieldProcessor, ((GoPointerType)type).getType()));
   }
@@ -53,7 +53,7 @@ private boolean processStructType(@NotNull GoScopeProcessor fieldProcessor, @Nul
   }
 
   public boolean inStructTypeKey() {
-    return GoPsiImplUtil.getParentGoValue(myElement) == null && GoPsiImplUtil.getLiteralType(myElement) instanceof GoStructType;
+    return GoPsiImplUtil.getParentGoValue(myElement) == null && GoPsiImplUtil.getLiteralType(myElement, false) instanceof GoStructType;
   }
 
   @Nullable

File: src/com/goide/completion/GoKeywordCompletionContributor.java
Patch:
@@ -94,7 +94,7 @@ private static ElementPattern<? extends PsiElement> afterIfBlock(@NotNull IEleme
       psiElement(GoStatement.class).afterSiblingSkipping(psiElement().whitespaceCommentEmptyOrError(), psiElement(GoIfStatement.class));
     PsiElementPattern.Capture<GoLeftHandExprList> lh = psiElement(GoLeftHandExprList.class).withParent(statement);
     return psiElement(tokenType).withParent(psiElement(GoReferenceExpressionBase.class).with(new GoNonQualifiedReference()).withParent(lh))
-      .andNot(afterElseKeyword()).andNot(onStatementBeginning(tokenType));
+      .andNot(afterElseKeyword()).afterLeaf(psiElement(GoTypes.RBRACE));
   }
 
   private static ElementPattern<? extends PsiElement> rangeClause() {

File: src/com/goide/runconfig/testing/frameworks/gotest/GotestGenerateAction.java
Patch:
@@ -49,8 +49,8 @@ public GotestGenerateAction(@NotNull GoTestFunctionType type) {
 
   @Override
   protected boolean isValidForFile(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {
-    GoLiveTemplateContextType.GoFileContextType fileContextType =
-      TemplateContextType.EP_NAME.findExtension(GoLiveTemplateContextType.GoFileContextType.class);
+    GoLiveTemplateContextType.File fileContextType =
+      TemplateContextType.EP_NAME.findExtension(GoLiveTemplateContextType.File.class);
     return fileContextType != null && fileContextType.isInContext(file, editor.getCaretModel().getOffset());
   }
 

File: src/com/goide/completion/GoReferenceCompletionProvider.java
Patch:
@@ -152,6 +152,9 @@ else if (o instanceof GoLabelDefinition) {
         String name = ((GoLabelDefinition)o).getName();
         if (name != null) return GoCompletionUtil.createLabelLookupElement((GoLabelDefinition)o, name);
       }
+      else if (o instanceof GoFieldDefinition) {
+        return GoCompletionUtil.createFieldLookupElement((GoFieldDefinition)o);
+      }
       else {
         return GoCompletionUtil.createVariableLikeLookupElement((GoNamedElement)o);
       }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -145,6 +145,7 @@ protected boolean isWriteActionRequired() {
   public void testCyclicDefinition()          { doTest(); }
   public void testEmbeddedInterfacePointer()  { doTest(); }
   public void testPlaceholderCount()          { doTest(); }
+  public void testPlaceholderCountVet()       { doTest(); }
   public void testTypeConversion()            { doTest(); }
   public void testInit()                      { doTest(); }
   public void testMainWithWrongSignature()    { doTest(); }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -216,8 +216,9 @@ private boolean processExistingType(@NotNull GoType type, @NotNull GoScopeProces
       for (GoFieldDeclaration d : ((GoStructType)type).getFieldDeclarationList()) {
         if (!processNamedElements(processor, state, d.getFieldDefinitionList(), localResolve)) return false;
         GoAnonymousFieldDefinition anon = d.getAnonymousFieldDefinition();
-        if (anon != null) {
-          (anon.getType() instanceof GoPointerType ? structRefs : interfaceRefs).add(anon.getTypeReferenceExpression());
+        GoTypeReferenceExpression ref = anon != null ? anon.getTypeReferenceExpression() : null;
+        if (ref != null) {
+          (anon.getType() instanceof GoPointerType ? structRefs : interfaceRefs).add(ref);
           if (!processNamedElements(processor, state, ContainerUtil.createMaybeSingletonList(anon), localResolve)) return false;
         }
       }

File: tests/com/goide/completion/GoCompletionTest.java
Patch:
@@ -160,7 +160,7 @@ public void testNoKeywordCompletionInsideConstDeclarationList() {
   }
 
   // #2445
-  public void _testNoKeywordCompletionInsideVarDeclarationList() {
+  public void testNoKeywordCompletionInsideVarDeclarationList() {
     doTestEquals("package foo; var (\n\t<caret>\n)");
   }
 

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -54,4 +54,5 @@ public GoParserTest() {
   public void testTypeComma()                       { doTest(false); }
   public void testIncDec()                          { doTest(false); }
   public void testIncompleteTypeDeclaration()       { doTest(false); } 
+  public void testIncompleteVarDeclaration()        { doTest(false); } 
 }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -918,7 +918,8 @@ private static GoType getTypeInner(@NotNull GoType o) {
     if (o instanceof GoParType) return ((GoParType)o).getActualType();
 
     if (o instanceof GoSpecType) {
-      return ((GoSpecType)o).getType().getUnderlyingType();
+      GoType type = ((GoSpecType)o).getType();
+      return type != null ? type.getUnderlyingType() : o;
     }
 
     if (builtin(o)) return o;

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -263,7 +263,7 @@ private boolean processInTypeRef(@Nullable GoTypeReferenceExpression e, @NotNull
       if (type instanceof GoSpecType) {
         GoType inner = ((GoSpecType)type).getType();
         if (inner instanceof GoPointerType && state.get(POINTER) != null) return true;
-        if (!processGoType(inner, processor, state.put(DONT_PROCESS_METHODS, true))) return false;
+        if (inner != null && !processGoType(inner, processor, state.put(DONT_PROCESS_METHODS, true))) return false;
       }
       return true;
     }

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -53,4 +53,5 @@ public GoParserTest() {
   public void testPlusPlusRecover()                 { doTest(false); }
   public void testTypeComma()                       { doTest(false); }
   public void testIncDec()                          { doTest(false); }
+  public void testIncompleteTypeDeclaration()       { doTest(false); } 
 }

File: src/com/goide/inspections/GoEmbeddedInterfacePointerInspection.java
Patch:
@@ -29,9 +29,9 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNul
     return new GoVisitor() {
       @Override
       public void visitAnonymousFieldDefinition(@NotNull GoAnonymousFieldDefinition o) {
-        if (o.getMul() == null) return;
-
-        GoType goType = o.getGoType(null);
+        if (!(o.getType() instanceof GoPointerType)) return;
+        GoTypeReferenceExpression reference = o.getTypeReferenceExpression();
+        GoType goType = reference != null ? reference.resolveType() : null;
         if (!(goType instanceof GoSpecType)) return;
 
         if (!(((GoSpecType)goType).getType() instanceof GoInterfaceType)) return;

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -217,7 +217,7 @@ private boolean processExistingType(@NotNull GoType type, @NotNull GoScopeProces
         if (!processNamedElements(processor, state, d.getFieldDefinitionList(), localResolve)) return false;
         GoAnonymousFieldDefinition anon = d.getAnonymousFieldDefinition();
         if (anon != null) {
-          (anon.getMul() != null ? structRefs : interfaceRefs).add(anon.getTypeReferenceExpression());
+          (anon.getType() instanceof GoPointerType ? structRefs : interfaceRefs).add(anon.getTypeReferenceExpression());
           if (!processNamedElements(processor, state, ContainerUtil.createMaybeSingletonList(anon), localResolve)) return false;
         }
       }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -74,7 +74,8 @@ public void setUp() throws Exception {
       GoInfiniteForInspection.class,
       GoAssignmentToReceiverInspection.class,
       GoInvalidStringOrCharInspection.class,
-      GoMixedNamedUnnamedParametersInspection.class
+      GoMixedNamedUnnamedParametersInspection.class,
+      GoAnonymousFieldDefinitionTypeInspection.class
     );
   }
 
@@ -166,6 +167,7 @@ protected boolean isWriteActionRequired() {
   public void testAssignmentToReceiver()      { doTest(); }
   public void testMixedNamedUnnamedParameters() { doTest(); }
   public void testStringInStructSliceWithThirdIndex() { doTest(); }
+  public void testAnonymousFieldDefinition()  { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {
     myFixture.addFileToProject("pack1/a.go", "package foo;");

File: src/com/goide/completion/GoKeywordCompletionContributor.java
Patch:
@@ -48,7 +48,8 @@ public GoKeywordCompletionContributor() {
     extend(CompletionType.BASIC, importPattern(), new GoKeywordCompletionProvider(KEYWORD_PRIORITY, "import"));
     extend(CompletionType.BASIC, topLevelPattern(), new GoKeywordCompletionProvider(KEYWORD_PRIORITY, "const", "var", "func", "type"));
     extend(CompletionType.BASIC, insideBlockPattern(GoTypes.IDENTIFIER),
-           new GoKeywordCompletionProvider(KEYWORD_PRIORITY, "for", "const", "var", "return", "if", "switch", "go", "defer", "goto"));
+           new GoKeywordCompletionProvider(KEYWORD_PRIORITY, "type", "for", "const", "var", "return", "if", "switch", "go", "defer", 
+                                           "goto"));
     extend(CompletionType.BASIC, insideBlockPattern(GoTypes.IDENTIFIER),
            new GoKeywordCompletionProvider(KEYWORD_PRIORITY, EMPTY_INSERT_HANDLER, "fallthrough"));
     extend(CompletionType.BASIC, insideBlockPattern(GoTypes.IDENTIFIER),

File: tests/com/goide/quickfix/GoReplaceWithNamedStructFieldQuickFixTest.java
Patch:
@@ -32,6 +32,6 @@ protected String getBasePath() {
     return "quickfixes/replace-with-named-struct-field";
   }
 
-  public void testSimple() { doTest(GoReplaceWithNamedStructFieldQuickFix.QUICK_FIX_NAME); }
+  public void testSimple() { doTest(GoStructInitializationInspection.REPLACE_WITH_NAMED_STRUCT_FIELD_FIX_NAME); }
 
 }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -73,7 +73,8 @@ public void setUp() throws Exception {
       GoUnusedParameterInspection.class,
       GoInvalidStringOrCharInspection.class,
       GoDirectAssignToStructFieldInMapInspection.class,
-      GoInfiniteForInspection.class
+      GoInfiniteForInspection.class,
+      GoAssignmentToReceiverInspection.class
     );
   }
 
@@ -157,6 +158,7 @@ protected String getBasePath() {
   public void testSliceWithThirdIndex()       { doTest(); }
   public void testAssignToStructFieldInMap()  { doTest(); }
   public void testInfiniteFor()               { doTest(); }
+  public void testAssignmentToReceiver()      { doTest(); }
   public void testStringInStructSliceWithThirdIndex() { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -72,7 +72,8 @@ public void setUp() throws Exception {
       GoRangeIterationOnIllegalTypeInspection.class,
       GoUnusedParameterInspection.class,
       GoInvalidStringOrCharInspection.class,
-      GoDirectAssignToStructFieldInMapInspection.class
+      GoDirectAssignToStructFieldInMapInspection.class,
+      GoInfiniteForInspection.class
     );
   }
 
@@ -156,6 +157,7 @@ protected String getBasePath() {
   public void testSliceWithThirdIndex()       { doTest(); }
   public void testAssignToStructFieldInMap()  { doTest(); }
   public void testStringInStructSliceWithThirdIndex() { doTest(); }
+  public void testInfiniteFor()               { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {
     myFixture.addFileToProject("pack1/a.go", "package foo;");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -43,6 +43,7 @@ public void setUp() throws Exception {
       GoUnusedConstInspection.class,
       GoUnusedGlobalVariableInspection.class,
       GoUnusedFunctionInspection.class,
+      GoUnusedExportedFunctionInspection.class,
       GoAssignmentToConstantInspection.class,
       GoDuplicateFunctionOrMethodInspection.class,
       GoDuplicateArgumentInspection.class,

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -70,7 +70,8 @@ public void setUp() throws Exception {
       GoUnderscoreUsedAsValueInspection.class,
       GoRangeIterationOnIllegalTypeInspection.class,
       GoUnusedParameterInspection.class,
-      GoInvalidStringOrCharInspection.class
+      GoInvalidStringOrCharInspection.class,
+      GoDirectAssignToStructFieldInMapInspection.class
     );
   }
 
@@ -153,6 +154,7 @@ protected String getBasePath() {
   public void testStringSliceWithThirdIndex() { doTest(); }
   public void testSliceWithThirdIndex()       { doTest(); }
   public void testStringInStructSliceWithThirdIndex() { doTest(); }
+  public void testAssignToStructFieldInMap()  { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {
     myFixture.addFileToProject("pack1/a.go", "package foo;");

File: src/com/goide/inspections/GoInspectionUtil.java
Patch:
@@ -37,6 +37,9 @@ public static int getExpressionResultCount(GoExpression call) {
     if (call instanceof GoTypeAssertionExpr) {
       return getTypeAssertionResultCount((GoTypeAssertionExpr)call);
     }
+    if (GoPsiImplUtil.isConversionExpression(call)) {
+      return 1;
+    }
     if (call instanceof GoCallExpr) {
       return getFunctionResultCount((GoCallExpr)call);
     }

File: tests/com/goide/refactor/GoIntroduceVariableTest.java
Patch:
@@ -67,6 +67,7 @@ private void doFailureTest(String msg) {
 
   public void testCompositeLiteral()                                { doTest(); }
   public void testIndexedExpression()                               { doTest(); }
+  public void testConversion()                                      { doTest(); }
 
   public void testVoidExpression()      { doFailureTest("Expression fmt.Println() returns multiple values."); }
   public void testVoidCallExpression()  { doFailureTest("Expression fmt.Println() returns multiple values."); }

File: tests/com/goide/refactor/GoIntroduceVariableTest.java
Patch:
@@ -62,9 +62,10 @@ private void doFailureTest(String msg) {
   public void testDoNotSuggestNameEqualsToType()                    { doTest(); }
 
   public void testCompositeLiteral()                                { doTest(); }
-  public void testIndexedExpression()   { doTest(); }
+  public void testIndexedExpression()                               { doTest(); }
 
-  public void testMultipleValueResult() { doFailureTest("Expression fmt.Println() returns multiple values."); }
+  public void testVoidExpression()      { doFailureTest("Expression fmt.Println() returns multiple values."); }
+  public void testVoidCallExpression()  { doFailureTest("Expression fmt.Println() returns multiple values."); }
   public void testWrongSelection()      { doFailureTest(RefactoringBundle.message("selected.block.should.represent.an.expression")); }
   public void testTopLevelExpression()  { doFailureTest(RefactoringBundle.message("refactoring.introduce.context.error"));}
 

File: gen/com/goide/psi/GoBlock.java
Patch:
@@ -28,7 +28,7 @@ public interface GoBlock extends GoCompositeElement {
   @NotNull
   List<GoStatement> getStatementList();
 
-  @Nullable
+  @NotNull
   PsiElement getLbrace();
 
   @Nullable

File: gen/com/goide/psi/impl/GoBlockImpl.java
Patch:
@@ -50,9 +50,9 @@ public List<GoStatement> getStatementList() {
   }
 
   @Override
-  @Nullable
+  @NotNull
   public PsiElement getLbrace() {
-    return findChildByType(LBRACE);
+    return notNullChild(findChildByType(LBRACE));
   }
 
   @Override

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -223,7 +223,7 @@ public SearchScope getUseScope() {
     if (!isPublic()) {
       return GoPackageUtil.packageScope(getContainingFile());
     }
-    GoSpecType parentType = PsiTreeUtil.getParentOfType(this, GoSpecType.class);
+    GoSpecType parentType = PsiTreeUtil.getStubOrPsiParentOfType(this, GoSpecType.class);
     if (parentType != null) {
       GoTypeSpec typeSpec = GoPsiImplUtil.getTypeSpecSafe(parentType);
       if (typeSpec != null && !StringUtil.isCapitalized(typeSpec.getName())) {

File: src/com/goide/GoFileElementType.java
Patch:
@@ -31,7 +31,7 @@
 
 public class GoFileElementType extends IStubFileElementType<GoFileStub> {
   public static final IStubFileElementType INSTANCE = new GoFileElementType();
-  public static final int VERSION = 16;
+  public static final int VERSION = 17;
 
   private GoFileElementType() {
     super("GO_FILE", GoLanguage.INSTANCE);

File: src/com/goide/stubs/types/GoNamedStubElementType.java
Patch:
@@ -40,8 +40,9 @@ public GoNamedStubElementType(@NonNls @NotNull String debugName) {
 
   @Override
   public boolean shouldCreateStub(@NotNull ASTNode node) {
+    if (!super.shouldCreateStub(node)) return false;
     PsiElement psi = node.getPsi();
-    return super.shouldCreateStub(node) && psi instanceof GoNamedElement && StringUtil.isNotEmpty(((GoNamedElement)psi).getName());
+    return psi instanceof GoNamedElement && StringUtil.isNotEmpty(((GoNamedElement)psi).getName());
   }
 
   @Override

File: src/com/goide/completion/GoReferenceCompletionProvider.java
Patch:
@@ -81,9 +81,6 @@ protected boolean accept(@NotNull PsiElement e) {
                                 (e instanceof GoNamedSignatureOwner || e instanceof GoVarDefinition || e instanceof GoConstDefinition));
         }
       });
-      if (element instanceof GoReferenceExpressionBase && element.getParent() instanceof GoReceiverType) {
-        fillVariantsByReference(new GoReference((GoReferenceExpressionBase)element), file, result);
-      }
     }
     else if (reference instanceof GoCachedReference) {
       ((GoCachedReference)reference).processResolveVariants(new MyGoScopeProcessor(result, file, false));

File: src/com/goide/inspections/unresolved/GoUnresolvedReferenceInspection.java
Patch:
@@ -184,7 +184,6 @@ private static LocalQuickFix[] createImportPackageFixes(@NotNull PsiElement targ
   }
 
   private static boolean isProhibited(@NotNull GoCompositeElement o, @Nullable GoCompositeElement qualifier) {
-    if (PsiTreeUtil.getPrevSiblingOfType(o, GoReceiverType.class) != null) return true;
     ASTNode next = FormatterUtil.getNextNonWhitespaceSibling(o.getNode());
     boolean isDot = next != null && next.getElementType() == GoTypes.DOT;
     return isDot || qualifier != null;

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -268,7 +268,7 @@ public static GoType getReceiverType(@NotNull GoMethodDeclaration o) {
   @Nullable
   public static GoTypeReferenceExpression getTypeReference(@Nullable GoType o) {
     if (o == null) return null;
-    if (o instanceof GoReceiverType || o instanceof GoPointerType) {
+    if (o instanceof GoPointerType) {
       return PsiTreeUtil.findChildOfAnyType(o, GoTypeReferenceExpression.class);
     }
     return o.getTypeReferenceExpression();

File: src/com/goide/stubs/GoElementTypeFactory.java
Patch:
@@ -36,7 +36,6 @@ public class GoElementTypeFactory {
       put("INTERFACE_TYPE", GoInterfaceTypeImpl.class);
       put("MAP_TYPE", GoMapTypeImpl.class);
       put("POINTER_TYPE", GoPointerTypeImpl.class);
-      put("RECEIVER_TYPE", GoReceiverTypeImpl.class);
       put("STRUCT_TYPE", GoStructTypeImpl.class);
       put("TYPE", GoTypeImpl.class);
       put("PAR_TYPE", GoParTypeImpl.class);

File: src/com/goide/util/GoUtil.java
Patch:
@@ -166,7 +166,6 @@ public static boolean couldBeReferenceTo(@NotNull PsiElement definition, @NotNul
     if (definition instanceof PsiDirectory && reference instanceof GoReferenceExpressionBase) return true;
     if (reference instanceof GoLabelRef && !(definition instanceof GoLabelDefinition)) return false;
     if (reference instanceof GoTypeReferenceExpression &&
-        !(reference.getParent() instanceof GoReceiverType) &&
         !(definition instanceof GoTypeSpec || definition instanceof GoImportSpec)) {
       return false;
     }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -69,7 +69,8 @@ public void setUp() throws Exception {
       GoMethodOnNonLocalTypeInspection.class,
       GoUnderscoreUsedAsValueInspection.class,
       GoRangeIterationOnIllegalTypeInspection.class,
-      GoUnusedParameterInspection.class
+      GoUnusedParameterInspection.class,
+      GoInvalidStringOrCharInspection.class
     );
   }
 

File: src/com/goide/refactor/GoIntroduceVariableBase.java
Patch:
@@ -185,6 +185,7 @@ public void run() {
           if (occurrenceParent instanceof GoParenthesesExpr) occurrence = occurrenceParent;
           newOccurrences.add(occurrence.replace(GoElementFactory.createReferenceExpression(project, name)));
         }
+        operation.getEditor().getCaretModel().moveToOffset(varDefinition.getIdentifier().getTextRange().getStartOffset());
       }
     });
     operation.setOccurrences(newOccurrences);

File: src/com/goide/refactor/GoIntroduceVariableBase.java
Patch:
@@ -185,6 +185,7 @@ public void run() {
           if (occurrenceParent instanceof GoParenthesesExpr) occurrence = occurrenceParent;
           newOccurrences.add(occurrence.replace(GoElementFactory.createReferenceExpression(project, name)));
         }
+        operation.getEditor().getCaretModel().moveToOffset(varDefinition.getIdentifier().getTextRange().getStartOffset());
       }
     });
     operation.setOccurrences(newOccurrences);

File: src/com/goide/inspections/unresolved/GoIntroduceFunctionFix.java
Patch:
@@ -124,10 +124,12 @@ public String fun(PsiElement element) {
           if (file.isEquivalentTo(typeFile) || GoUtil.inSamePackage(typeFile, file)) {
             return spec.getIdentifier().getText();
           }
+          if (!spec.isPublic()) {
+            return GoConstants.INTERFACE_TYPE;
+          }
 
           GoPathScopeHelper scopeHelper = GoPathScopeHelper.fromReferenceFile(file.getProject(), module, file.getVirtualFile());
           boolean isAllowed = scopeHelper.couldBeReferenced(typeFile.getVirtualFile(), file.getVirtualFile());
-
           if (!isAllowed) return GoConstants.INTERFACE_TYPE;
 
           String importPath = typeFile.getImportPath(vendoringEnabled);

File: tests/com/goide/quickfix/GoIntroduceFunctionFixTest.java
Patch:
@@ -150,7 +150,7 @@ public void testInOtherPackageWithTwoAlias() {
   }
 
   public void testInOtherPackageWithPrivateType() {
-    myFixture.addFileToProject("a/a.go", "package a; type MyType int; func CreateMyType() myType { return myType{}};");
+    myFixture.addFileToProject("a/a.go", "package a; type myType int; func CreateMyType() myType { return myType{}};");
     PsiFile file = myFixture.addFileToProject("b/b.go", "package b; import . \"a\"; func _() { asd<caret>(CreateMyType());};");
     myFixture.configureFromExistingVirtualFile(file.getVirtualFile());
     applySingleQuickFix(QUICK_FIX_NAME);

File: src/com/goide/psi/impl/GoTypeUtil.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.goide.psi.impl;
 
+import com.goide.GoConstants;
 import com.goide.psi.*;
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.psi.PsiElement;
@@ -241,14 +242,14 @@ private static GoType createGoTypeListOrGoType(@NotNull List<GoType> types, @Not
     return GoElementFactory.createTypeList(context.getProject(), StringUtil.join(types, new Function<GoType, String>() {
       @Override
       public String fun(GoType type) {
-        return type == null ? "interface{}" : type.getText();
+        return type == null ? GoConstants.INTERFACE_TYPE : type.getText();
       }
     }, ", "));
   }
 
   @NotNull
   private static GoType getInterfaceIfNull(@Nullable GoType type, @NotNull PsiElement context) {
-    return type == null ? GoElementFactory.createType(context.getProject(), "interface{}") : type;
+    return type == null ? GoElementFactory.createType(context.getProject(), GoConstants.INTERFACE_TYPE) : type;
   }
 
   @NotNull

File: utils/src/com/goide/GoConstants.java
Patch:
@@ -51,6 +51,7 @@ public class GoConstants {
   public static final String TESTING_PATH = "testing";
   public static final String VENDOR = "vendor";
   public static final String INTERNAL = "internal";
+  public static final String INTERFACE_TYPE = "interface{}";
 
   public static final NotificationGroup GO_NOTIFICATION_GROUP = NotificationGroup.balloonGroup("Go plugin notifications");
   public static final NotificationGroup GO_EXECUTION_NOTIFICATION_GROUP = NotificationGroup.toolWindowGroup("Go Execution", ToolWindowId.RUN);

File: src/com/goide/inspections/GoTestSignaturesInspection.java
Patch:
@@ -52,7 +52,7 @@ protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsH
       else {
         GoParameterDeclaration param = ContainerUtil.getFirstItem(params);
         GoImportSpec testingImportSpec = file.getImportedPackagesMap().get(GoConstants.TESTING_PATH);
-        String testingAlias = GoPsiImplUtil.getImportQualifierToUseInFile(testingImportSpec);
+        String testingAlias = GoPsiImplUtil.getImportQualifierToUseInFile(testingImportSpec, GoConstants.TESTING_PATH);
         if (GoConstants.TESTING_PATH.equals(file.getImportPath(false))) {
           testingAlias = "";
         }

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -91,7 +91,7 @@ public String getQualifiedName() {
     String name = getName();
     if (name == null) return null;
     String packageName = getContainingFile().getPackageName();
-    return StringUtil.isNotEmpty(packageName) ? packageName + "." + name : name;
+    return GoPsiImplUtil.getFqn(packageName, name);
   }
 
   @Override

File: src/com/goide/runconfig/testing/frameworks/gotest/GotestGenerateAction.java
Patch:
@@ -57,7 +57,7 @@ protected boolean isValidForFile(@NotNull Project project, @NotNull Editor edito
   @NotNull
   public static String importTestingPackageIfNeeded(@NotNull GoFile file) {
     GoImportSpec alreadyImportedPackage = file.getImportedPackagesMap().get(GoConstants.TESTING_PATH);
-    String qualifier = GoPsiImplUtil.getImportQualifierToUseInFile(alreadyImportedPackage);
+    String qualifier = GoPsiImplUtil.getImportQualifierToUseInFile(alreadyImportedPackage, GoConstants.TESTING_PATH);
     if (qualifier != null) {
       return qualifier;
     }

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -54,6 +54,7 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testMultilineVariable_5()               { doTest(); }
   public void testFieldDeclaration()                  { doTest(); }
   public void testSignature()                         { doTest(); }
+  public void testStruct()                            { doTest(); }
   public void testTypeSpec()                          { doTest(); }
   public void testTypeTopDefinition()                 { doTest(); }
   public void testTypeInnerDefinitionWithoutComment() { doTest(); }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -471,7 +471,7 @@ private static GoType unwrapPointerIfNeeded(@Nullable GoType type) {
   }
 
   @Nullable
-  private static GoType getBuiltinType(@NotNull final String name, @NotNull PsiElement context) {
+  public static GoType getBuiltinType(@NotNull final String name, @NotNull PsiElement context) {
     GoFile builtin = GoSdkUtil.findBuiltinFile(context);
     if (builtin != null) {
       GoTypeSpec spec = ContainerUtil.find(builtin.getTypes(), new Condition<GoTypeSpec>() {

File: tests/com/goide/refactor/GoIntroduceVariableTest.java
Patch:
@@ -53,13 +53,13 @@ private void doFailureTest(String msg) {
   public void testCaretOnRightParenthesis()                         { doTest(); }
   public void testCaretOnCallParenthesis()                          { doTest(); }
   public void testNameSuggestOnGetterFunction()                     { doTest(); }
-  public void testNameSuggestOnDefinedImportAlias()                 { doTest(); }
   public void testNameSuggestOnDefaultName()                        { doTest(); }
   public void testNameSuggestOnParamName()                          { doTest(); }
   public void testNameSuggestOnType()                               { doTest(); }
   public void testNameSuggestOnArrayType()                          { doTest(); }
   public void testDoNotSuggestKeywordBasedOnType()                  { doTest(); }
   public void testDoNotSuggestKeywordBasedOnCallName()              { doTest(); }
+  public void testDoNotSuggestNameEqualsToType()                    { doTest(); }
 
   public void testCompositeLiteral()                                { doTest(); }
   public void testIndexedExpression()                               { doTest(); }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -43,6 +43,7 @@ public void setUp() throws Exception {
       GoUnusedConstInspection.class,
       GoUnusedGlobalVariableInspection.class,
       GoUnusedFunctionInspection.class,
+      GoUnusedExportedFunctionInspection.class,
       GoAssignmentToConstantInspection.class,
       GoDuplicateFunctionOrMethodInspection.class,
       GoDuplicateArgumentInspection.class,

File: src/com/goide/psi/impl/GoLightType.java
Patch:
@@ -26,7 +26,7 @@
 
 import java.util.List;
 
-public class GoLightType<E extends GoCompositeElement> extends LightElement implements GoType {
+public abstract class GoLightType<E extends GoCompositeElement> extends LightElement implements GoType {
   @NotNull protected final E myElement;
 
   protected GoLightType(@NotNull E e) {

File: src/com/goide/inspections/GoRedundantTypeDeclInCompositeLit.java
Patch:
@@ -17,6 +17,7 @@
 package com.goide.inspections;
 
 import com.goide.psi.*;
+import com.goide.quickfix.GoDeleteAmpersandAndTypeInCompositeLitQuickFix;
 import com.goide.quickfix.GoDeleteQuickFix;
 import com.intellij.codeInspection.CleanupLocalInspectionTool;
 import com.intellij.codeInspection.LocalInspectionToolSession;
@@ -58,7 +59,8 @@ public void visitCompositeLit(@NotNull GoCompositeLit o) {
                       holder.registerProblem(holder.getManager().createProblemDescriptor(bitAnd, typeExpr,
                                                                                          "Redundant type declaration",
                                                                                          ProblemHighlightType.LIKE_UNUSED_SYMBOL,
-                                                                                         holder.isOnTheFly()));
+                                                                                         holder.isOnTheFly(),
+                                                                                         new GoDeleteAmpersandAndTypeInCompositeLitQuickFix()));
                     }
                   }
                 }

File: tests/com/goide/inspections/GoRedundantTypeDeclInCompositeLitTest.java
Patch:
@@ -74,7 +74,7 @@ public void testCompositeLitWithTwoDimensionalArray() {
 
   //Test Composite literals with pointers *T == &T
   public void testCompositeLitWithPointers() {
-    doTestNoFix(GoRedundantTypeDeclInCompositeLit.DELETE_TYPE_DECLARATION_QUICK_FIX_NAME, true);
+    doTest(GoRedundantTypeDeclInCompositeLit.DELETE_TYPE_DECLARATION_QUICK_FIX_NAME, true);
   }
 
   public void testCompositeLitWithPointersNoFix() {

File: src/com/goide/inspections/GoRedundantTypeDeclInCompositeLit.java
Patch:
@@ -17,6 +17,7 @@
 package com.goide.inspections;
 
 import com.goide.psi.*;
+import com.goide.quickfix.GoDeleteAmpersandAndTypeInCompositeLitQuickFix;
 import com.goide.quickfix.GoDeleteQuickFix;
 import com.intellij.codeInspection.CleanupLocalInspectionTool;
 import com.intellij.codeInspection.LocalInspectionToolSession;
@@ -58,7 +59,8 @@ public void visitCompositeLit(@NotNull GoCompositeLit o) {
                       holder.registerProblem(holder.getManager().createProblemDescriptor(bitAnd, typeExpr,
                                                                                          "Redundant type declaration",
                                                                                          ProblemHighlightType.LIKE_UNUSED_SYMBOL,
-                                                                                         holder.isOnTheFly()));
+                                                                                         holder.isOnTheFly(),
+                                                                                         new GoDeleteAmpersandAndTypeInCompositeLitQuickFix()));
                     }
                   }
                 }

File: tests/com/goide/inspections/GoRedundantTypeDeclInCompositeLitTest.java
Patch:
@@ -74,7 +74,7 @@ public void testCompositeLitWithTwoDimensionalArray() {
 
   //Test Composite literals with pointers *T == &T
   public void testCompositeLitWithPointers() {
-    doTestNoFix(GoRedundantTypeDeclInCompositeLit.DELETE_TYPE_DECLARATION_QUICK_FIX_NAME, true);
+    doTest(GoRedundantTypeDeclInCompositeLit.DELETE_TYPE_DECLARATION_QUICK_FIX_NAME, true);
   }
 
   public void testCompositeLitWithPointersNoFix() {

File: src/com/goide/inspections/GoVarDeclarationInspection.java
Patch:
@@ -69,7 +69,7 @@ private void validatePair(@NotNull GoCompositeElement o, Pair<? extends List<? e
         for (GoCompositeElement idElement : p.first) {
           if (idElement instanceof GoIndexOrSliceExpr) {
             GoType referenceType = GoPsiImplUtil.getIndexedExpressionReferenceType((GoIndexOrSliceExpr)idElement, null);
-            if (referenceType != null && GoTypeUtil.isString(referenceType.getUnderlyingType())) {
+            if (GoTypeUtil.isString(referenceType)) {
               // https://golang.org/ref/spec#Index_expressions
               // For a of string type: a[x] may not be assigned to
               holder.registerProblem(idElement, "Cannot assign to <code>#ref</code> #loc");

File: src/com/goide/psi/impl/GoTypeUtil.java
Patch:
@@ -40,6 +40,7 @@ private static boolean isArray(@Nullable GoType type) {
   }
 
   public static boolean isString(@Nullable GoType type) {
-    return type != null && type.textMatches("string") && GoPsiImplUtil.builtin(type);
+    GoType underlyingType = type != null ? type.getUnderlyingType() : null;
+    return underlyingType != null && underlyingType.textMatches("string") && GoPsiImplUtil.builtin(underlyingType);
   }
 }

File: tests/com/goide/runconfig/testing/GoRunLineMarkerTest.java
Patch:
@@ -20,7 +20,7 @@
 
 public class GoRunLineMarkerTest extends GoRunConfigurationTestCase {
   public void testRunTestLineMarker() {
-    myFixture.configureByText("a_test.go", "package m<caret>ain\n" +
+    myFixture.configureByText("a_test.go", "package <caret>main\n" +
                                            "import .`gopkg.in/check.v1`\n" +
                                            "func TestName(){}\n" +
                                            "func BenchmarkName(){}\n" +
@@ -35,14 +35,14 @@ public void testRunTestLineMarker() {
 
   public void testRunLineMarker() {
     myFixture.configureByText("a.go", "package main\n" +
-                                      "func m<caret>ain(){}");
+                                      "func <caret>main(){}");
     assertEquals(1, myFixture.findGuttersAtCaret().size());
     assertEquals(1, myFixture.findAllGutters().size());
   }
 
   public void testRunLineMarkerInNonMainFile() {
     myFixture.configureByText("a.go", "package not_main\n" +
-                                      "func m<caret>ain(){}");
+                                      "func <caret>main(){}");
     assertEquals(0, myFixture.findGuttersAtCaret().size());
     assertEquals(0, myFixture.findAllGutters().size());
   }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.goide.inspections;
 
 import com.goide.GoCodeInsightFixtureTestCase;
+import com.goide.codeInsight.imports.GoImportOptimizerTest;
 import com.goide.inspections.unresolved.*;
 import com.goide.project.GoModuleLibrariesService;
 import com.intellij.openapi.vfs.VirtualFile;
@@ -303,6 +304,7 @@ public void testPackageWithTestPrefix() {
   public void testMethodOnNonLocalType() {
     VirtualFile file = myFixture.copyFileToProject(getTestName(true) + ".go", "method/nonlocaltype.go");
     myFixture.configureFromExistingVirtualFile(file);
+    GoImportOptimizerTest.resolveAllReferences(myFixture.getFile());
     myFixture.checkHighlighting();
   }
   

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -17,7 +17,7 @@
 package com.goide.formatter;
 
 import com.goide.GoCodeInsightFixtureTestCase;
-import com.intellij.openapi.application.ApplicationManager;
+import com.intellij.openapi.command.WriteCommandAction;
 import com.intellij.psi.codeStyle.CodeStyleManager;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -57,7 +57,7 @@ private void doTest(@Nullable Character c) {
 
   private String doTest(@Nullable Character c, String testName) {
     if (c == null) {
-      ApplicationManager.getApplication().runWriteAction(new Runnable() {
+      WriteCommandAction.runWriteCommandAction(myFixture.getProject(), new Runnable() {
         @Override
         public void run() {
           CodeStyleManager.getInstance(getProject()).reformat(myFixture.getFile());

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -52,7 +52,7 @@ private void doTest(@Nullable Character c) {
     String testName = getTestName(true);
     myFixture.configureByFile(testName + ".go");
     String after = doTest(c, testName);
-    assertSameLinesWithFile(getTestDataPath() + "/" + after, myFixture.getFile().getText());
+    myFixture.checkResultByFile(after);
   }
 
   private String doTest(@Nullable Character c, String testName) {

File: src/com/goide/editor/GoFoldingBuilder.java
Patch:
@@ -164,7 +164,7 @@ protected void buildLanguageFoldRegions(@NotNull final List<FoldingDescriptor> r
 
     for (GoCompositeLit compositeLit : PsiTreeUtil.findChildrenOfType(file, GoCompositeLit.class)) {
       GoLiteralValue literalValue = compositeLit.getLiteralValue();
-      if (literalValue.getElementList().size() > 1) {
+      if (literalValue != null && literalValue.getElementList().size() > 1) {
         fold(literalValue, literalValue.getLbrace(), literalValue.getRbrace(), "{...}", result);
       }
     }

File: src/com/goide/inspections/GoInspectionUtil.java
Patch:
@@ -41,7 +41,9 @@ public static int getExpressionResultCount(GoExpression call) {
       return getFunctionResultCount((GoCallExpr)call);
     }
     if (call instanceof GoReferenceExpression) {
-      if (((GoReferenceExpression)call).resolve() instanceof GoVarDefinition) return 1;
+      // todo: always 1?
+      PsiElement resolve = ((GoReferenceExpression)call).resolve();
+      if (resolve instanceof GoVarDefinition || resolve instanceof GoParamDefinition || resolve instanceof GoReceiver) return 1;
     }
     return UNKNOWN_COUNT;
   }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -152,6 +152,7 @@ protected boolean isWriteActionRequired() {
   public void testUnusedParameter()           { doTest(); }
   public void testUnusedParameter_test()      { doTest(); }
   public void testVoidFunctionUsedAsValue()   { doTest(); }
+  public void testIndexedStringAssign()       { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {
     myFixture.addFileToProject("pack1/a.go", "package foo;");

File: src/com/goide/inspections/GoInspectionUtil.java
Patch:
@@ -31,7 +31,7 @@ private GoInspectionUtil() {}
   public static int getExpressionResultCount(GoExpression call) {
     if (call instanceof GoLiteral || call instanceof GoStringLiteral || call instanceof GoBinaryExpr || call instanceof GoParenthesesExpr ||
         call instanceof GoUnaryExpr && ((GoUnaryExpr)call).getSendChannel() == null || call instanceof GoBuiltinCallExpr ||
-        call instanceof GoCompositeLit) {
+        call instanceof GoCompositeLit || call instanceof GoIndexOrSliceExpr) {
       return 1;
     }
     if (call instanceof GoTypeAssertionExpr) {

File: tests/com/goide/refactor/GoIntroduceVariableTest.java
Patch:
@@ -57,6 +57,7 @@ private void doFailureTest(String msg) {
   public void testNameSuggestOnDefaultName()        { doTest(); }
   public void testNameSuggestOnParamName()          { doTest(); }
   public void testCompositeLiteral()                { doTest(); }
+  public void testIndexedExpression()               { doTest(); }
 
   public void testMultipleValueResult() { doFailureTest("Expression fmt.Println() returns multiple values."); }
   public void testWrongSelection()      { doFailureTest(RefactoringBundle.message("selected.block.should.represent.an.expression")); }

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -61,6 +61,7 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testVarShortDefinition()                { doTest(); }
   public void testSpecType()                          { doTest(); }
   public void testPointer()                           { doTest(); }
+  public void testFunctionType()                      { doTest(); }
 
   public void testMultiBlockDoc()                     { doConverterTest(); }
   public void testIndentedBlock()                     { doConverterTest(); }

File: src/com/goide/psi/impl/GoLightType.java
Patch:
@@ -26,7 +26,7 @@
 
 import java.util.List;
 
-class GoLightType<E extends GoCompositeElement> extends LightElement implements GoType {
+public class GoLightType<E extends GoCompositeElement> extends LightElement implements GoType {
   @NotNull protected final E myElement;
 
   protected GoLightType(@NotNull E e) {

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -60,6 +60,7 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testConstants()                         { doTest(); }
   public void testVarShortDefinition()                { doTest(); }
   public void testSpecType()                          { doTest(); }
+  public void testPointer()                           { doTest(); }
 
   public void testMultiBlockDoc()                     { doConverterTest(); }
   public void testIndentedBlock()                     { doConverterTest(); }

File: src/com/goide/codeInsight/GoExpressionTypeProvider.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.goide.codeInsight;
 
-import com.goide.psi.GoStatement;
+import com.goide.psi.GoTopLevelDeclaration;
 import com.goide.psi.GoType;
 import com.goide.psi.GoTypeOwner;
 import com.intellij.lang.ExpressionTypeProvider;
@@ -50,6 +50,7 @@ public List<GoTypeOwner> getExpressionsAt(@NotNull PsiElement at) {
     if (at instanceof PsiWhiteSpace && at.textMatches("\n")) {
       at = PsiTreeUtil.prevLeaf(at);
     }
-    return SyntaxTraverser.psiApi().parents(at).takeWhile(Conditions.notInstanceOf(GoStatement.class)).filter(GoTypeOwner.class).toList();
+    return SyntaxTraverser.psiApi().parents(at).takeWhile(Conditions.notInstanceOf(GoTopLevelDeclaration.class))
+      .filter(GoTypeOwner.class).toList();
   }
 }
\ No newline at end of file

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -38,6 +38,7 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testFprintln()                          { doTest(); }
   public void testMethod()                            { doTest(); }
   public void testVariable()                          { doTest(); }
+  public void testVariableInSwitch()                  { doTest(); }
   public void testEscape()                            { doTest(); }
   public void testEscapeReturnValues()                { doTest(); }
   public void testPackageWithDoc()                    { doTest(); }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -1336,8 +1336,8 @@ public static GoExpression getValue(@NotNull GoVarDefinition definition) {
       int index = ((GoVarSpec)parent).getVarDefinitionList().indexOf(definition);
       return getByIndex(((GoVarSpec)parent).getRightExpressionsList(), index);
     }
-    if (parent instanceof GoTypeSwitchStatement) {
-      return ((GoTypeSwitchStatement)parent).getTypeSwitchGuard().getExpression();
+    if (parent instanceof GoTypeSwitchGuard) {
+      return ((GoTypeSwitchGuard)parent).getExpression();
     }
     LOG.error("Cannot find value for variable definition: " + definition.getText(),
               AttachmentFactory.createAttachment(definition.getContainingFile().getVirtualFile()));

File: tests/com/goide/psi/impl/GoPsiImplUtilTest.java
Patch:
@@ -183,8 +183,8 @@ public void testGetTypeOfMultipleConstDefinition() {
     assertEquals("int", type.getText());
   }
   
-  public void testGetValueOfVarDefinitionInSelect() {
-    myFixture.configureByText("a.go", "package main\n\n func _() { bar := nil; select fo<caret>o := bar.(type){}}");
+  public void testGetValueOfVarDefinitionInSwitch() {
+    myFixture.configureByText("a.go", "package main\n\n func _() { bar := nil; switch fo<caret>o := bar.(type){}}");
     GoVarDefinition definition = PsiTreeUtil.getNonStrictParentOfType(myFixture.getElementAtCaret(), GoVarDefinition.class);
     assertNotNull(definition);
     GoExpression value = definition.getValue();

File: src/com/goide/inspections/unresolved/GoUnusedFunctionInspection.java
Patch:
@@ -50,8 +50,7 @@ public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
           PsiElement id = o.getIdentifier();
           TextRange range = TextRange.from(id.getStartOffsetInParent(), id.getTextLength());
           holder.registerProblem(o, "Unused function <code>#ref</code> #loc", ProblemHighlightType.LIKE_UNUSED_SYMBOL, range,
-                                 new GoDeleteQuickFix("Delete function '" + name + "'", GoFunctionDeclaration.class), 
-                                 new GoRenameToBlankQuickFix(o));
+                                 new GoDeleteQuickFix("Delete function", GoFunctionDeclaration.class), new GoRenameToBlankQuickFix(o));
         }
       }
     };

File: src/com/goide/inspections/unresolved/GoReplaceAssignmentWithDeclarationQuickFix.java
Patch:
@@ -29,10 +29,10 @@
 import org.jetbrains.annotations.Nls;
 import org.jetbrains.annotations.NotNull;
 
-public class GoReplaceAssignmentWithDeclaration extends LocalQuickFixOnPsiElement {
+public class GoReplaceAssignmentWithDeclarationQuickFix extends LocalQuickFixOnPsiElement {
   public static final String QUICK_FIX_NAME = "Replace with ':='";
 
-  public GoReplaceAssignmentWithDeclaration(@NotNull PsiElement element) {
+  public GoReplaceAssignmentWithDeclarationQuickFix(@NotNull PsiElement element) {
     super(element);
   }
 

File: src/com/goide/inspections/unresolved/GoUnresolvedReferenceInspection.java
Patch:
@@ -93,10 +93,10 @@ else if (holder.isOnTheFly()) {
             else if (canBeLocal) {
               PsiElement grandParent = parent.getParent();
               if (grandParent instanceof GoAssignmentStatement) {
-                fixesList.add(new GoReplaceAssignmentWithDeclaration(grandParent));
+                fixesList.add(new GoReplaceAssignmentWithDeclarationQuickFix(grandParent));
               }
               else if (parent instanceof GoRangeClause || parent instanceof GoRecvStatement) {
-                fixesList.add(new GoReplaceAssignmentWithDeclaration(parent));
+                fixesList.add(new GoReplaceAssignmentWithDeclarationQuickFix(parent));
               }
             }
             fixes = fixesList.toArray(new LocalQuickFix[fixesList.size()]);

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -145,6 +145,7 @@ protected boolean isWriteActionRequired() {
   public void testIota()                      { doTest(); }
   public void testIota2()                     { doTest(); }
   public void testUnaryPointer()              { doTest(); }
+  public void testUnaryMinus()                { doTest(); }
   public void testFileRead()                  { doTest(); }
   public void testLiteralValues()             { doTest(); }
   public void testUnderscoreUsedAsValue()     { doTest(); }

File: src/com/goide/inspections/GoRangeIterationOnIllegalTypeInspection.java
Patch:
@@ -37,7 +37,7 @@ public void visitRangeClause(@NotNull GoRangeClause o) {
         super.visitRangeClause(o);
         GoExpression expression = o.getRangeExpression();
         GoType type = expression != null ? expression.getGoType(null) : null;
-        if (type != null && !GoTypeUtil.isIterable(type.getUnderlyingType())) {
+        if (type != null && !GoTypeUtil.isIterable(type)) {
           holder.registerProblem(expression, "Cannot range over data (type " + GoPsiImplUtil.getText(type) + ")", 
             ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
         }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -431,7 +431,7 @@ else if (type instanceof GoArrayOrSliceType) {
         return typeFromRefOrType(((GoArrayOrSliceType)type).getType());
       }
       else if (GoTypeUtil.isString(type)) {
-        return getBuiltinType("uint8", o);
+        return getBuiltinType("byte", o);
       }
     }
     else if (o instanceof GoTypeAssertionExpr) {

File: tests/com/goide/type/GoTypeResolveTest.java
Patch:
@@ -51,11 +51,11 @@ public void testRangeOverString() {
   }
 
   public void testIndexExpressionOfString() {
-    doStatementTest("foo := \"hello\"\na := <selection>foo[0]</selection>", "uint8");
+    doStatementTest("foo := \"hello\"\na := <selection>foo[0]</selection>", "byte");
   }
 
   public void testIndexExpressionOfStringLiteral() {
-    doExpressionTest("<selection>\"hello\"[0]</selection>", "uint8");
+    doExpressionTest("<selection>\"hello\"[0]</selection>", "byte");
   }
 
   public void testIndexExpressionOfPointer() {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -654,7 +654,7 @@ private static GoType processRangeClause(@NotNull GoVarDefinition o, @NotNull Go
         if (i == 1) return ContainerUtil.getLastItem(list);
       }
       if (GoTypeUtil.isString(type)) {
-        return getBuiltinType("int", o);
+        return getBuiltinType("int32", o);
       }
     }
     return null;

File: tests/com/goide/type/GoTypeResolveTest.java
Patch:
@@ -47,7 +47,7 @@ public void testSlice() {
   }
 
   public void testRangeOverString() {
-    doStatementTest("for fo<caret>o := range \"hello\" {}", "int");
+    doStatementTest("for _, fo<caret>o := range \"hello\" {}", "int32");
   }
 
   public void testIndexExpressionOfString() {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -417,8 +417,8 @@ else if (o instanceof GoSelectorExpr) {
     else if (o instanceof GoIndexOrSliceExpr) {
       GoExpression first = ContainerUtil.getFirstItem(((GoIndexOrSliceExpr)o).getExpressionList());
       GoType firstType = unwrapOnlySpecPointers(first == null ? null : first.getGoType(context));
+      if (o.getNode().findChildByType(GoTypes.COLON) != null) return firstType; // means slice expression, todo: extract if needed
       GoType type = firstType != null ? firstType.getUnderlyingType() : null;
-      if (o.getNode().findChildByType(GoTypes.COLON) != null) return type; // means slice expression, todo: extract if needed
       if (type instanceof GoMapType) {
         List<GoType> list = ((GoMapType)type).getTypeList();
         if (list.size() == 2) {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -567,6 +567,7 @@ public static GoType getGoTypeInner(@NotNull GoVarDefinition o, @Nullable Resolv
         if (typeCase != null) {
           return typeCase.getDefault() != null ? ((GoTypeSwitchGuard)parent).getExpression().getGoType(context) : typeCase.getType();
         }
+        return ((GoTypeSwitchGuard)parent).getExpression().getGoType(null);
       }
     }
     return null;

File: gen/com/goide/psi/GoInterfaceType.java
Patch:
@@ -25,4 +25,6 @@ public interface GoInterfaceType extends GoType {
   @NotNull
   List<GoTypeReferenceExpression> getBaseTypesReferences();
 
+  boolean shouldGoDeeper();
+
 }

File: gen/com/goide/psi/GoStructType.java
Patch:
@@ -19,4 +19,6 @@ public interface GoStructType extends GoType {
   @NotNull
   PsiElement getStruct();
 
+  boolean shouldGoDeeper();
+
 }

File: gen/com/goide/psi/GoType.java
Patch:
@@ -15,4 +15,6 @@ public interface GoType extends GoCompositeElement, StubBasedPsiElement<GoTypeSt
   @NotNull
   GoType getUnderlyingType();
 
+  boolean shouldGoDeeper();
+
 }

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -118,7 +118,8 @@ public GoType getGoType(@Nullable ResolveState context) {
       @Nullable
       @Override
       public Result<GoType> compute() {
-        return Result.create(getGoTypeInner(null), PsiModificationTracker.MODIFICATION_COUNT);
+        return Result.create(getGoTypeInner(GoPsiImplUtil.createContextOnElement(GoNamedElementImpl.this)), 
+                             PsiModificationTracker.MODIFICATION_COUNT);
       }
     });
   }

File: src/com/goide/inspections/unresolved/GoUnusedFunctionInspection.java
Patch:
@@ -51,7 +51,8 @@ public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
           PsiElement id = o.getIdentifier();
           TextRange range = TextRange.from(id.getStartOffsetInParent(), id.getTextLength());
           holder.registerProblem(o, "Unused function " + "'" + name + "'", ProblemHighlightType.LIKE_UNUSED_SYMBOL, range,
-                                 new GoDeleteQuickFix("Delete function '" + name + "'"), new GoRenameToBlankQuickFix(o));
+                                 new GoDeleteQuickFix("Delete function '" + name + "'", GoFunctionDeclaration.class), 
+                                 new GoRenameToBlankQuickFix(o));
         }
       }
     };

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -860,15 +860,15 @@ private static GoType getTypeInner(@NotNull GoType o) {
     if (o instanceof GoParType) return ((GoParType)o).getActualType();
 
     if (o instanceof GoSpecType) {
-      return getUnderlyingType(((GoSpecType)o).getType());
+      return ((GoSpecType)o).getType().getUnderlyingType();
     }
 
     if (builtin(o)) return o;
 
     GoTypeReferenceExpression e = o.getTypeReferenceExpression();
     GoType byRef = e == null ? null : e.resolveType();
     if (byRef != null) {
-      return getUnderlyingType(byRef);
+      return byRef.getUnderlyingType();
     }
 
     return o;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -66,7 +66,8 @@ public void setUp() throws Exception {
       GoEmbeddedInterfacePointerInspection.class,
       GoStructInitializationInspection.class,
       GoMethodOnNonLocalTypeInspection.class,
-      GoUnderscoreUsedAsValueInspection.class
+      GoUnderscoreUsedAsValueInspection.class,
+      GoRangeIterationOnIllegalTypeInspection.class
     );
   }
 

File: src/com/goide/util/GoUtil.java
Patch:
@@ -58,7 +58,6 @@ public VirtualFile fun(VirtualFile file) {
     }
   };
   private static final String PLUGIN_ID = "ro.redeul.google.go";
-  public static final String PLUGIN_VERSION = getPlugin().getVersion();
 
   private GoUtil() {}
 

File: src/com/goide/util/GoUtil.java
Patch:
@@ -58,7 +58,6 @@ public VirtualFile fun(VirtualFile file) {
     }
   };
   private static final String PLUGIN_ID = "ro.redeul.google.go";
-  public static final String PLUGIN_VERSION = getPlugin().getVersion();
 
   private GoUtil() {}
 

File: tests/com/goide/editor/GoQuoteHandlerTest.java
Patch:
@@ -22,7 +22,7 @@ public class GoQuoteHandlerTest extends GoCodeInsightFixtureTestCase {
   public void testNewlineInStringLiteral() {
     myFixture.configureByText("t.go", "package t; const c = \"const<caret>value\"");
     myFixture.type('\n');
-    myFixture.checkResult("package t; const c = \"const\" +\n\"<caret>value\"");
+    myFixture.checkResult("package t; const c = \"const\" +\n\t\"<caret>value\"");
   }
 
   public void testTypeSingleQuote() { doTypeQuoteTest('\''); }

File: src/com/goide/completion/GoAutoImportInsertHandler.java
Patch:
@@ -38,7 +38,7 @@ public class GoAutoImportInsertHandler<T extends GoNamedElement> implements Inse
   public static final InsertHandler<LookupElement> TYPE_CONVERSION_INSERT_HANDLER = new GoAutoImportInsertHandler<GoTypeSpec>(
     GoCompletionUtil.Lazy.TYPE_CONVERSION_INSERT_HANDLER, GoTypeSpec.class);
   public static final InsertHandler<LookupElement> FUNCTION_INSERT_HANDLER = new GoAutoImportInsertHandler<GoFunctionDeclaration>(
-    GoCompletionUtil.Lazy.FUNCTION_INSERT_HANDLER, GoFunctionDeclaration.class);
+    GoCompletionUtil.Lazy.VARIABLE_OR_FUNCTION_INSERT_HANDLER, GoFunctionDeclaration.class);
 
   @Nullable private final InsertHandler<LookupElement> myDelegate;
   @Nullable private final Class<T> myClass;

File: src/com/goide/completion/GoCompletionContributor.java
Patch:
@@ -73,7 +73,7 @@ public void fillCompletionVariants(@NotNull CompletionParameters parameters, @No
       boolean isTestFile = GoTestFinder.isTestFile(file);
       PsiDirectory directory = file.getParent();
       String currentPackageName = ((GoFile)file).getPackageName();
-      Collection<String> packagesInDirectory = GoPackageUtil.getAllPackagesInDirectory(directory, true);
+      Collection<String> packagesInDirectory = GoPackageUtil.getAllPackagesInDirectory(directory, null, true);
       for (String packageName : packagesInDirectory) {
         if (!packageName.equals(currentPackageName)) {
           result.addElement(packageLookup(packageName, GoCompletionUtil.PACKAGE_PRIORITY - 1));

File: src/com/goide/inspections/GoInvalidPackageImportInspection.java
Patch:
@@ -58,7 +58,7 @@ protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsH
         if (GoPackageUtil.isBuiltinPackage(resolve)) {
           problemsHolder.registerProblem(importSpec, "Cannot import 'builtin' package", new GoDeleteImportQuickFix());
         }
-        Collection<String> packagesInDirectory = GoPackageUtil.getAllPackagesInDirectory(resolve, true);
+        Collection<String> packagesInDirectory = GoPackageUtil.getAllPackagesInDirectory(resolve, module, true);
         if (packagesInDirectory.isEmpty()) {
           problemsHolder.registerProblem(importSpec, "'" + resolve.getVirtualFile().getPath() + "' has no buildable Go source files",
                                          new GoDeleteImportQuickFix());

File: src/com/goide/inspections/GoMultiplePackagesInspection.java
Patch:
@@ -39,7 +39,7 @@ protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsH
       String packageName = file.getPackageName();
       if (packageName == null || packageName.equals(GoConstants.DOCUMENTATION)) return;
       PsiDirectory dir = file.getContainingDirectory();
-      Collection<String> packages = GoPackageUtil.getAllPackagesInDirectory(dir, true);
+      Collection<String> packages = GoPackageUtil.getAllPackagesInDirectory(dir, null, true);
       packages.remove(GoConstants.DOCUMENTATION);
       if (packages.size() > 1) {
         Collection<LocalQuickFix> fixes = ContainerUtil.newArrayList();

File: src/com/goide/util/GoUtil.java
Patch:
@@ -191,7 +191,7 @@ public static boolean couldBeReferenceTo(@NotNull PsiElement definition, @NotNul
   @NotNull
   public static String suggestPackageForDirectory(@Nullable PsiDirectory directory) {
     String packageName = GoPsiImplUtil.getLocalPackageName(directory != null ? directory.getName() : "");
-    for (String p : GoPackageUtil.getAllPackagesInDirectory(directory, true)) {
+    for (String p : GoPackageUtil.getAllPackagesInDirectory(directory, null, true)) {
       if (!GoConstants.MAIN.equals(p)) {
         return p;
       }

File: tests/com/goide/GoFindUsageTest.java
Patch:
@@ -85,7 +85,7 @@ public void testCheckImportInWholePackage() {
     assertEquals("b.f.Method()", statement.getText());
   }
 
-  public void _testCheckImportInWholePackageWithRelativeImports() {
+  public void testCheckImportInWholePackageWithRelativeImports() {
     myFixture.addFileToProject("bar/bar1.go", "package bar; func Bar() { b := bar{}; b.f.Method() }");
     myFixture.addFileToProject("bar/bar.go", "package bar; import \"..\"; type bar struct { f *foo.Foo }");
     myFixture.configureByText("foo.go", "package foo; type Foo struct{}; func (*Foo) M<caret>ethod() {}");

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -801,8 +801,7 @@ private static List<GoMethodDeclaration> calcMethods(@NotNull GoTypeSpec o) {
       if (StringUtil.isEmpty(packageName) || StringUtil.isEmpty(typeName)) return Collections.emptyList();
       String key = packageName + "." + typeName;
       Project project = ((GoFile)file).getProject();
-      PsiDirectory parent = file.getParent();
-      GlobalSearchScope scope = parent == null ? GlobalSearchScope.allScope(project) : GoPackageUtil.packageScope(parent);
+      GlobalSearchScope scope = GoPackageUtil.packageScope((GoFile)file);
       Collection<GoMethodDeclaration> declarations = GoMethodIndex.find(key, project, scope, GoIdFilter.getFilesFilter(scope));
       return ContainerUtil.newArrayList(declarations);
     }

File: src/com/goide/highlighting/GoAnnotator.java
Patch:
@@ -41,7 +41,6 @@ public class GoAnnotator implements Annotator {
     "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr",
     "rune", "float32", "float64"
   ); // todo: unify with DlvApi.Variable.Kind
-  private static final boolean ENABLE_CAP_CHECK = false; // todo: disable for a while due to #2268
 
   @Override
   public void annotate(@NotNull PsiElement element, @NotNull AnnotationHolder holder) {
@@ -115,7 +114,7 @@ else if (element instanceof GoBuiltinCallExpr) {
         checkMakeCall(call, holder);
       }
     }
-    else if (ENABLE_CAP_CHECK && element instanceof GoCallExpr) {
+    else if (element instanceof GoCallExpr) {
       GoCallExpr call = (GoCallExpr)element;
       if (call.getExpression() instanceof GoReferenceExpression) {
         GoReferenceExpression reference = (GoReferenceExpression)call.getExpression();

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -488,7 +488,7 @@ public static boolean isUnreachableVendoredPackage(@NotNull VirtualFile targetDi
   }
 
   @Nullable
-  private static VirtualFile findParentDirectory(@Nullable VirtualFile file, @NotNull Set<VirtualFile> sourceRoots, @NotNull String name) {
+  public static VirtualFile findParentDirectory(@Nullable VirtualFile file, @NotNull Set<VirtualFile> sourceRoots, @NotNull String name) {
     if (file == null) {
       return null;
     }

File: src/com/goide/actions/tool/GoTypeFileAction.java
Patch:
@@ -45,6 +45,7 @@ protected GoExecutor createExecutor(@NotNull Project project, @Nullable Module m
     VirtualFile executable = getExecutable(project, module);
     assert executable != null;
 
-    return GoExecutor.in(project, module).withExePath(executable.getPath()).withParameters("-e", "-a", "-v", filePath ).showOutputOnError();
+    return GoExecutor.in(project, module).withExePath(executable.getPath()).withParameters("-e", "-a", "-v", filePath )
+      .showNotifications(false, true).showOutputOnError();
   }
 }

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -2518,9 +2518,9 @@ public static boolean MethodDeclaration(PsiBuilder b, int l) {
     boolean r, p;
     Marker m = enter_section_(b, l, _NONE_, METHOD_DECLARATION, null);
     r = consumeToken(b, FUNC);
-    r = r && Receiver(b, l + 1);
-    p = r; // pin = 2
-    r = r && report_error_(b, consumeToken(b, IDENTIFIER));
+    p = r; // pin = 1
+    r = r && report_error_(b, Receiver(b, l + 1));
+    r = p && report_error_(b, consumeToken(b, IDENTIFIER)) && r;
     r = p && report_error_(b, Signature(b, l + 1)) && r;
     r = p && MethodDeclaration_4(b, l + 1) && r;
     exit_section_(b, l, m, r, p, null);

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -314,7 +314,7 @@ private static String getReferenceText(@Nullable PsiElement element, boolean inc
           }
         }
         else if (element instanceof GoMethodDeclaration) {
-          GoType receiverType = ((GoMethodDeclaration)element).getReceiver().getType();
+          GoType receiverType = ((GoMethodDeclaration)element).getReceiverType();
           String receiver = getReceiverTypeText(receiverType);
           String name = ((GoMethodDeclaration)element).getName();
           if (StringUtil.isNotEmpty(receiver) && StringUtil.isNotEmpty(name)) {

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -193,7 +193,7 @@ private static String calcTailText(GoSignatureOwner m) {
     }
     String text = "";
     if (m instanceof GoMethodDeclaration) {
-      text = GoPsiImplUtil.getText(((GoMethodDeclaration)m).getReceiver().getType());
+      text = GoPsiImplUtil.getText(((GoMethodDeclaration)m).getReceiverType());
     }
     else if (m instanceof GoMethodSpec) {
       PsiElement parent = m.getParent();

File: src/com/goide/inspections/GoMethodOnNonLocalTypeInspection.java
Patch:
@@ -43,7 +43,7 @@ public void visitMethodDeclaration(@NotNull GoMethodDeclaration method) {
 
       @Nullable
       private GoType getMethodType(@NotNull GoMethodDeclaration method) {
-        GoType methodType = method.getReceiver().getType();
+        GoType methodType = method.getReceiverType();
         GoTypeReferenceExpression ref = methodType == null ? null : GoPsiImplUtil.getTypeReference(methodType);
         return ref == null ? null : ref.resolveType();
       }

File: src/com/goide/runconfig/testing/frameworks/gocheck/GocheckFramework.java
Patch:
@@ -47,7 +47,7 @@ private GocheckFramework() {
   public static String getGocheckTestName(@NotNull GoMethodDeclaration method) {
     String methodName = GoTestFunctionType.fromName(method.getName()) == GoTestFunctionType.TEST ? method.getName() : null;
     if (methodName != null) {
-      String suiteName = GoPsiImplUtil.getText(method.getReceiver().getType());
+      String suiteName = GoPsiImplUtil.getText(method.getReceiverType());
       if (!suiteName.isEmpty()) {
         return suiteName + "." + methodName;
       }

File: src/com/goide/stubs/types/GoMethodDeclarationStubElementType.java
Patch:
@@ -91,7 +91,7 @@ public void indexStub(@NotNull GoMethodDeclarationStub stub, @NotNull IndexSink
 
   @Nullable
   public static String calcTypeText(@NotNull GoMethodDeclaration psi) {
-    GoTypeReferenceExpression reference = GoPsiImplUtil.getTypeReference(psi.getReceiver().getType());
+    GoTypeReferenceExpression reference = GoPsiImplUtil.getTypeReference(psi.getReceiverType());
     return reference != null ? reference.getIdentifier().getText() : null;
   }
 }

File: src/com/goide/tree/GoStructureViewFactory.java
Patch:
@@ -157,8 +157,7 @@ public Collection<StructureViewTreeElement> getChildrenBase() {
         for (GoVarDefinition o : ((GoFile)element).getVars()) result.add(new Element(o));
         for (GoFunctionDeclaration o : ((GoFile)element).getFunctions()) result.add(new Element(o));
         for (GoMethodDeclaration o : ((GoFile)element).getMethods()) {
-          GoReceiver receiver = o.getReceiver();
-          GoType type = receiver.getType();
+          GoType type = o.getReceiverType();
           GoTypeReferenceExpression e = GoPsiImplUtil.getTypeReference(type);
           PsiElement resolve = e != null ? e.resolve() : null;
           if (resolve == null) {

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -74,6 +74,7 @@ protected void setUp() throws Exception {
   public void testSimple()                          { doTest(false); }
   public void testRecover()                         { doTest(false); }
   public void testRecover2()                        { doTest(false); }
+  public void testRecover3()                        { doTest(false); }
   public void testMethodExpr()                      { doTest(false); }
   public void testLabels()                          { doTest(false); }
   public void testBlockRecover()                    { doTest(false); }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -66,7 +66,8 @@ public void setUp() throws Exception {
       GoPlaceholderCountInspection.class,
       GoEmbeddedInterfacePointerInspection.class,
       GoStructInitializationInspection.class,
-      GoMethodOnNonLocalTypeInspection.class
+      GoMethodOnNonLocalTypeInspection.class,
+      GoUnderscoreUsedAsValueInspection.class
     );
   }
 
@@ -145,6 +146,7 @@ protected boolean isWriteActionRequired() {
   public void testUnaryPointer()              { doTest(); }
   public void testFileRead()                  { doTest(); }
   public void testLiteralValues()             { doTest(); }
+  public void testUnderscoreUsedAsValue()     { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {
     myFixture.addFileToProject("pack1/a.go", "package foo;");

File: src/com/goide/usages/GoFindUsagesProvider.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,10 +72,11 @@ public String getType(@NotNull PsiElement element) {
     if (element instanceof GoMethodSpec) return "method specification";
     if (element instanceof GoLabelDefinition) return "label";
     if (element instanceof GoPackageClause) return "package statement";
-    
+
     // should be last
     if (element instanceof GoStatement) return "statement";
     if (element instanceof GoTopLevelDeclaration) return "declaration";
+    if (element instanceof GoCommClause || element instanceof GoCaseClause) return "case";
     return "";
   }
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -1394,7 +1394,7 @@ public static ReadWriteAccessDetector.Access getReadWriteAccess(@NotNull GoRefer
     }
     if (parent instanceof GoRecvStatement) {
       return expression.equals(((GoRecvStatement)parent).getRecvExpression()) ? ReadWriteAccessDetector.Access.Read
-                                                                              : ReadWriteAccessDetector.Access.Write;
+                                                                              : ReadWriteAccessDetector.Access.ReadWrite;
     }
     return ReadWriteAccessDetector.Access.Read;
   }

File: src/com/goide/psi/GoFile.java
Patch:
@@ -77,7 +77,7 @@ public GlobalSearchScope getResolveScope() {
   @NotNull
   @Override
   public SearchScope getUseScope() {
-    return GoUtil.goPathUseScope(this);
+    return GoUtil.goPathUseScope(this, true);
   }
 
   @Nullable
@@ -126,7 +126,7 @@ public Result<List<GoFunctionDeclaration>> compute() {
         List<GoFunctionDeclaration> functions = stub != null 
                                                 ? getChildrenByType(stub, GoTypes.FUNCTION_DECLARATION,
                                                                                  GoFunctionDeclarationStubElementType.ARRAY_FACTORY)
-                                                : GoFile.this.calc(
+                                                : calc(
                                                                Conditions.instanceOf(GoFunctionDeclaration.class));
         return Result.create(functions, GoFile.this);
       }
@@ -141,7 +141,7 @@ public Result<List<GoMethodDeclaration>> compute() {
         StubElement<GoFile> stub = getStub();
         List<GoMethodDeclaration> calc = stub != null
                                          ? getChildrenByType(stub, GoTypes.METHOD_DECLARATION, GoMethodDeclarationStubElementType.ARRAY_FACTORY)
-                                         : GoFile.this.calc(Conditions.instanceOf(GoMethodDeclaration.class));
+                                         : calc(Conditions.instanceOf(GoMethodDeclaration.class));
         return Result.create(calc, GoFile.this);
       }
     });

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -219,7 +219,8 @@ public SearchScope getUseScope() {
       GoBlock block = PsiTreeUtil.getParentOfType(this, GoBlock.class);
       if (block != null) return new LocalSearchScope(block);
     }
-    return isPublic() ? GoUtil.goPathUseScope(this) : GoPackageUtil.packageScope(getContainingFile());
+    return isPublic() ? GoUtil.goPathUseScope(this, !(this instanceof GoMethodDeclaration))
+                      : GoPackageUtil.packageScope(getContainingFile());
   }
 
   @Override

File: src/com/goide/util/GoUtil.java
Patch:
@@ -139,8 +139,8 @@ public static boolean directoryToIgnore(@NotNull String name) {
     return StringUtil.startsWithChar(name, '_') || StringUtil.startsWithChar(name, '.');
   }
   
-  public static GlobalSearchScope goPathUseScope(@NotNull PsiElement context) {
-    return GoPathUseScope.create(context);
+  public static GlobalSearchScope goPathUseScope(@NotNull PsiElement context, boolean filterByImportList) {
+    return GoPathUseScope.create(context, filterByImportList);
   }
 
   public static GlobalSearchScope goPathResolveScope(@NotNull PsiElement context) {

File: tests/com/goide/quickfix/GoCreateLocalConstantQuickFixTest.java
Patch:
@@ -44,4 +44,5 @@ private void doTestCreateA() {
   public void testResolved()        { doTestCreateA(); }
   public void testOnAssignment()    { doTestNoFix(CREATE_LOCAL_CONSTANT_A); }
   public void testOnChanRead()      { doTestNoFix(CREATE_LOCAL_CONSTANT_A); }
+  public void testOnTopLevel()      { doTestNoFix(CREATE_LOCAL_CONSTANT_A); }
 }

File: tests/com/goide/quickfix/GoCreateLocalVariableQuickFixTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -42,4 +42,5 @@ private void doTestCreateA() {
   public void testIf()         { doTestCreateA(); }
   public void testUnresolved() { doTestCreateA(); }
   public void testResolved()   { doTestCreateA(); }
+  public void testOnTopLevel() { doTestNoFix(CREATE_LOCAL_VARIABLE_A); }
 }

File: src/com/goide/inspections/unresolved/GoIntroduceGlobalConstantFix.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,6 @@
 
 public class GoIntroduceGlobalConstantFix extends GoUnresolvedFixBase {
   public GoIntroduceGlobalConstantFix(@NotNull PsiElement element, @NotNull String name) {
-    super(element, name, "global constant", "go_lang_global_const_qf");
+    super(element, name, "global constant", "go_lang_const_qf");
   }
 }

File: src/com/goide/inspections/unresolved/GoUnresolvedReferenceInspection.java
Patch:
@@ -82,7 +82,8 @@ else if (holder.isOnTheFly()) {
                                                                        new GoIntroduceGlobalVariableFix(id, name)
             );
             PsiElement parent = o.getParent();
-            if (!(parent instanceof GoLeftHandExprList)) {
+            if (!(parent instanceof GoLeftHandExprList) || parent.getNextSibling() == null) {
+              fixesList.add(new GoIntroduceLocalConstantFix(id, name));
               fixesList.add(new GoIntroduceGlobalConstantFix(id, name));
             }
             fixes = fixesList.toArray(new LocalQuickFix[fixesList.size()]);

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -87,6 +87,7 @@ private static SpacingBuilder createSpacingBuilder(@NotNull CodeStyleSettings se
       .after(FOR).spaces(1)
       .after(IF).spaces(1)
       .after(ELSE).spaces(1)
+      .before(ELSE_STATEMENT).spaces(1)
       .after(CASE).spaces(1)
       .after(RANGE).spaces(1)
       .after(SWITCH).spaces(1)

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -40,6 +40,7 @@ protected String getBasePath() {
   public void testVarDeclaration()                  { doTest(); }
   public void testBreakLines()                      { doTest(); }
   public void testCommentIndentation()              { doTest(); }
+  public void testElseStatement()                   { doTest(); }
 
   private void doTest() { doTest(null); }
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -314,7 +314,7 @@ public static GoType getGoTypeInner(@NotNull GoExpression o, @Nullable ResolveSt
       if (e == null) return null;
       GoType type = e.getGoType(context);
       if (type != null && ((GoUnaryExpr)o).getBitAnd() != null) return new LightPointerType(type);
-      GoType baseType = findBaseType(type);
+      GoType baseType = type == null || type.getTypeReferenceExpression() == null ? type : type.getUnderlyingType();
       if (baseType instanceof GoChannelType && ((GoUnaryExpr)o).getSendChannel() != null) return ((GoChannelType)baseType).getType();
       if (baseType instanceof GoPointerType && ((GoUnaryExpr)o).getMul() != null) return ((GoPointerType)baseType).getType();
       return baseType;
@@ -429,8 +429,7 @@ else if (o instanceof GoConditionalExpr) {
   }
 
   private static GoType findBaseType(@Nullable GoType type) {
-    GoType baseType = type == null ? null : findBaseTypeFromRef(type.getTypeReferenceExpression());
-    return baseType instanceof GoSpecType ? ((GoSpecType)baseType).getType() : type;
+    return type == null || type.getTypeReferenceExpression() == null ? type : type.getUnderlyingType();
   }
 
   @Nullable

File: src/com/goide/psi/impl/GoFieldNameReference.java
Patch:
@@ -102,13 +102,13 @@ else if (inner instanceof GoStructType) {
     }
 
     if (type != null && type.getTypeReferenceExpression() != null) {
-      type = GoPsiImplUtil.findBaseTypeFromRef(type.getTypeReferenceExpression());
+      type = type.getUnderlyingType();
     }
 
     if (type instanceof GoPointerType) {
       GoType inner = ((GoPointerType)type).getType();
       if (inner != null && inner.getTypeReferenceExpression() != null) {
-        type = GoPsiImplUtil.findBaseTypeFromRef(inner.getTypeReferenceExpression());
+        type = inner.getUnderlyingType();
       }
     }
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -367,9 +367,9 @@ else if (resolve == e) { // C.call()
       if (type instanceof GoFunctionType) {
         return funcType(type);
       }
-      GoType byRef = type == null ? null : findBaseTypeFromRef(type.getTypeReferenceExpression());
-      if (byRef instanceof GoSpecType && ((GoSpecType)byRef).getType() instanceof GoFunctionType) {
-        return funcType(((GoSpecType)byRef).getType());
+      GoType byRef = type != null && type.getTypeReferenceExpression() != null ? type.getUnderlyingType() : null;
+      if (byRef instanceof GoFunctionType) {
+        return funcType(byRef);
       }
       return type;
     }

File: src/com/goide/highlighting/GoAnnotator.java
Patch:
@@ -100,8 +100,8 @@ else if (element instanceof GoCompositeLit) {
     else if (element instanceof GoTypeAssertionExpr) {
       GoType type = ((GoTypeAssertionExpr)element).getExpression().getGoType(null);
       if (type != null) {
-        GoType baseType = GoPsiImplUtil.findBaseTypeFromRef(type.getTypeReferenceExpression());
-        if (baseType instanceof GoSpecType && !(((GoSpecType)baseType).getType() instanceof GoInterfaceType)) {
+        GoType underlyingType = type.getUnderlyingType();
+        if (!(underlyingType instanceof GoInterfaceType)) {
           String message =
             String.format("Invalid type assertion: %s, (non-interface type %s on left)", element.getText(), type.getText());
           holder.createErrorAnnotation(((GoTypeAssertionExpr)element).getExpression(), message);

File: gen/com/goide/psi/GoTypeReferenceExpression.java
Patch:
@@ -17,4 +17,7 @@ public interface GoTypeReferenceExpression extends GoReferenceExpressionBase {
   @Nullable
   GoTypeReferenceExpression getQualifier();
 
+  @Nullable
+  GoType resolveType();
+
 }

File: gen/com/goide/psi/GoType.java
Patch:
@@ -12,4 +12,7 @@ public interface GoType extends GoCompositeElement, StubBasedPsiElement<GoTypeSt
   @Nullable
   GoTypeReferenceExpression getTypeReferenceExpression();
 
+  @NotNull
+  GoType getUnderlyingType();
+
 }

File: src/com/goide/highlighting/GoAnnotator.java
Patch:
@@ -265,7 +265,7 @@ private static GoType getBaseType(@NotNull GoType type) {
       type = GoPsiImplUtil.findBaseTypeFromRef(type.getTypeReferenceExpression());
     }
     if (type instanceof GoSpecType) {
-      type = GoPsiImplUtil.findBaseSpecType(type);
+      type = type.getUnderlyingType();
     }
     return type instanceof GoSpecType ? ((GoSpecType)type).getType() : type;
   }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -205,8 +205,7 @@ private boolean processExistingType(@NotNull GoType type, @NotNull GoScopeProces
     if (canProcessMethods && parent != null && !processNamedElements(processor, state, parent.getMethods(), localResolve, true)) return false;
 
     if (type instanceof GoSpecType) {
-      GoType theLatestSpec = findBaseSpecType(type);
-      type = theLatestSpec instanceof GoSpecType ? ((GoSpecType)theLatestSpec).getType() : theLatestSpec;
+      type = type.getUnderlyingType();
     }
     if (type instanceof GoStructType) {
       GoScopeProcessorBase delegate = createDelegate(processor);

File: src/com/goide/inspections/GoDuplicateFunctionOrMethodInspection.java
Patch:
@@ -79,11 +79,12 @@ public void visitFunctionDeclaration(@NotNull final GoFunctionDeclaration func)
 
         final GoFile file = func.getContainingFile();
         final boolean isMainFunction = MAIN.equals(funcName) && MAIN.equals(file.getPackageName()) && zeroArity(func);
+        Module module = ModuleUtilCore.findModuleForPsiElement(file);
         final GlobalSearchScope scope = GoPackageUtil.packageScope(file);
         GoFunctionIndex.process(funcName, file.getProject(), scope, new Processor<GoFunctionDeclaration>() {
           @Override
           public boolean process(GoFunctionDeclaration declaration) {
-            if (!func.isEquivalentTo(declaration)) {
+            if (!func.isEquivalentTo(declaration) && GoUtil.matchedForModuleBuildTarget(declaration.getContainingFile(), module)) {
               if (!isMainFunction || Comparing.equal(declaration.getContainingFile(), file)) {
                 PsiElement identifier = func.getNameIdentifier();
                 holder.registerProblem(identifier == null ? func : identifier, "Duplicate function name");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -218,7 +218,7 @@ public void testDuplicateFunctionsInOnePackage() {
     myFixture.configureByText("a.go", "package foo; func init() {bar()}; func bar() {};");
     myFixture.configureByText("b.go", "//+build appengine\n\npackage foo; func init() {buzz()}; func buzz() {}");
     myFixture.configureByText("c.go",
-                              "package foo; func init() {bar(); buzz();}; func <error descr=\"Duplicate function name\">bar</error>() {}; func <error descr=\"Duplicate function name\">buzz</error>() {}");
+                              "package foo; func init() {bar(); buzz();}; func <error descr=\"Duplicate function name\">bar</error>() {}; func buzz() {}");
     myFixture.checkHighlighting();
   }
 
@@ -230,7 +230,7 @@ public void testDuplicateFunctionsInDifferentPackages() {
 
   public void testDoNotSearchFunctionDuplicatesForNotTargetMatchingFiles() {
     myFixture.configureByText("a.go", "//+build appengine\n\npackage foo; func init() {buzz()}; func buzz() {}");
-    myFixture.configureByText("b.go", "//+build appengine\n\npackage foo; func init() {buzz()}; func buzz() {}");
+    myFixture.configureByText("b.go", "package foo; func init() {buzz()}; func buzz() {}");
     myFixture.checkHighlighting();
   }
 
@@ -242,8 +242,8 @@ public void testDuplicateMethodsInOnePackage() {
   }
 
   public void testDoNotSearchMethodDuplicatesForNotTargetMatchingFiles() {
-    myFixture.configureByText("a.go", "package main; type Foo int; func (f Foo) bar(a, b string) {}");
     myFixture.configureByText("b.go", "//+build appengine\n\npackage main; func (a *Foo) bar() {}");
+    myFixture.configureByText("a.go", "package main; type Foo int; func (f Foo) bar(a, b string) {}");
     myFixture.checkHighlighting();
   }
 

File: src/com/goide/completion/BracesInsertHandler.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,7 +37,7 @@ public class BracesInsertHandler implements InsertHandler<LookupElement> {
   
   private final boolean myOneLine;
 
-  public BracesInsertHandler(boolean oneLine) {
+  private BracesInsertHandler(boolean oneLine) {
     myOneLine = oneLine;
   }
 

File: src/com/goide/runconfig/testing/GoTestFinder.java
Patch:
@@ -43,7 +43,7 @@ public static boolean isTestFile(@Nullable PsiFile file) {
   }
 
   public static boolean isTestFile(@NotNull VirtualFile file) {
-    return file.getNameWithoutExtension().endsWith(GoConstants.TEST_SUFFIX_WITH_EXTENSION);
+    return file.getName().endsWith(GoConstants.TEST_SUFFIX_WITH_EXTENSION);
   }
 
   public static boolean isTestOrExampleFunction(@NotNull GoFunctionOrMethodDeclaration function) {

File: src/com/goide/codeInsight/imports/GoExcludePathLookupActionProvider.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,7 +39,7 @@ public class GoExcludePathLookupActionProvider implements LookupActionProvider {
   public void fillActions(LookupElement element, Lookup lookup, Consumer<LookupElementAction> consumer) {
     PsiElement psiElement = element.getPsiElement();
     PsiFile file = psiElement != null ? psiElement.getContainingFile() : null;
-    String importPath = file instanceof GoFile ? ((GoFile)file).getImportPath() : null;
+    String importPath = file instanceof GoFile ? ((GoFile)file).getImportPath(false) : null;
     if (importPath != null) {
       Project project = psiElement.getProject();
       for (String path : getPaths(importPath)) {

File: src/com/goide/inspections/GoInvalidPackageImportInspection.java
Patch:
@@ -81,7 +81,7 @@ protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsH
         boolean supportsVendoring = GoVendoringUtil.isVendoringEnabled(module);
 
         if (supportsVendoring || supportsInternalPackages) {
-          Set<VirtualFile> sourceRoots = GoSdkUtil.getSourcesPathsToLookup(file.getProject(), module, file);
+          Set<VirtualFile> sourceRoots = GoSdkUtil.getSourcesPathsToLookup(file.getProject(), module);
           for (PsiReference reference : importSpec.getImportString().getReferences()) {
             if (reference instanceof GoImportReference) {
               if (supportsInternalPackages && GoConstants.INTERNAL.equals(reference.getCanonicalText())) {
@@ -97,7 +97,7 @@ else if (supportsVendoring && GoConstants.VENDOR.equals(reference.getCanonicalTe
                   break;
                 }
                 else {
-                  String vendoredImportPath = GoSdkUtil.getVendoringAwareImportPath(resolve, file);
+                  String vendoredImportPath = GoSdkUtil.getImportPath(resolve, true);
                   if (vendoredImportPath != null) {
                     problemsHolder.registerProblem(importSpec, "Must be imported as '" + vendoredImportPath + "'",
                                                    new GoReplaceImportPath(vendoredImportPath),

File: src/com/goide/inspections/GoMethodOnNonLocalTypeInspection.java
Patch:
@@ -35,11 +35,11 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNul
       @Override
       public void visitMethodDeclaration(@NotNull GoMethodDeclaration method) {
         if (method.getIdentifier() == null || method.isBlank()) return;
-        String containingFileImportPath = method.getContainingFile().getImportPath();
+        String containingFileImportPath = method.getContainingFile().getImportPath(false);
         if (containingFileImportPath == null) return;
         GoType methodType = getMethodType(method);
         if (methodType == null) return;
-        String typeImportPath = ((GoFile)methodType.getContainingFile()).getImportPath();
+        String typeImportPath = ((GoFile)methodType.getContainingFile()).getImportPath(false);
         if (typeImportPath == null || typeImportPath.equals(containingFileImportPath)) return;
         holder.registerProblem(method.getIdentifier(), "Method defined on non-local type", ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
       }

File: src/com/goide/inspections/GoPlaceholderCountInspection.java
Patch:
@@ -54,7 +54,7 @@ public class GoPlaceholderCountInspection extends GoInspectionBase {
   private static int getPlaceholderPosition(@NotNull GoFunctionOrMethodDeclaration function) {
     Integer position = FORMATTING_FUNCTIONS.get(StringUtil.toLowerCase(function.getName()));
     if (position != null) {
-      String importPath = function.getContainingFile().getImportPath();
+      String importPath = function.getContainingFile().getImportPath(false);
       if ("fmt".equals(importPath) || "log".equals(importPath)) {
         return position;
       }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -84,7 +84,7 @@ public static boolean isPanic(@NotNull GoCallExpr o) {
   public static boolean isBuiltinFile(@NotNull PsiFile file) {
     return file instanceof GoFile
            && GoConstants.BUILTIN_PACKAGE_NAME.equals(((GoFile)file).getPackageName())
-           && GoConstants.BUILTIN_PACKAGE_NAME.equals(((GoFile)file).getImportPath())
+           && GoConstants.BUILTIN_PACKAGE_NAME.equals(((GoFile)file).getImportPath(false))
            && GoConstants.BUILTIN_FILE_NAME.equals(file.getName());
   }
 

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -42,7 +42,7 @@
 public class GoReference extends PsiPolyVariantReferenceBase<GoReferenceExpressionBase> {
   public static final Key<List<? extends PsiElement>> IMPORT_USERS = Key.create("IMPORT_USERS");
   public static final Key<String> ACTUAL_NAME = Key.create("ACTUAL_NAME");
-  public static final Key<Object> POINTER = Key.create("POINTER");
+  private static final Key<Object> POINTER = Key.create("POINTER");
   private static final Key<Object> DONT_PROCESS_METHODS = Key.create("DONT_PROCESS_METHODS");
 
   private static final ResolveCache.PolyVariantResolver<PsiPolyVariantReferenceBase> MY_RESOLVER =
@@ -239,7 +239,8 @@ public static boolean isLocalResolve(@NotNull PsiFile originFile, @NotNull PsiFi
     if (!(originFile instanceof GoFile) || !(externalFile instanceof GoFile)) return false;
     GoFile o1 = (GoFile)originFile.getOriginalFile();
     GoFile o2 = (GoFile)externalFile.getOriginalFile();
-    return Comparing.equal(o1.getImportPath(), o2.getImportPath()) && Comparing.equal(o1.getPackageName(), o2.getPackageName());
+    return Comparing.equal(o1.getImportPath(false), o2.getImportPath(false)) 
+           && Comparing.equal(o1.getPackageName(), o2.getPackageName());
   }
 
   private boolean processCollectedRefs(@NotNull List<GoTypeReferenceExpression> refs,

File: src/com/goide/runconfig/GoConsoleFilter.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.goide.codeInsight.imports.GoGetPackageFix;
 import com.goide.sdk.GoPackageUtil;
-import com.goide.util.GoPathSearchScope;
+import com.goide.util.GoPathResolveScope;
 import com.goide.util.GoUtil;
 import com.intellij.execution.filters.Filter;
 import com.intellij.execution.filters.HyperlinkInfo;
@@ -166,7 +166,7 @@ private VirtualFile findSingleFile(@NotNull String fileName) {
         return ContainerUtil.getFirstItem(files);
       }
       if (!files.isEmpty()) {
-        final GlobalSearchScope goPathScope = GoPathSearchScope.create(myProject, myModule, null);
+        final GlobalSearchScope goPathScope = GoPathResolveScope.create(myProject, myModule, null);
         files = ContainerUtil.filter(files, new Condition<VirtualFile>() {
           @Override
           public boolean value(VirtualFile file) {

File: src/com/goide/runconfig/application/GoApplicationRunConfigurationProducer.java
Patch:
@@ -62,11 +62,11 @@ private static String getImportPathFromContext(@NotNull ConfigurationContext con
     if (GoRunUtil.isPackageContext(contextElement)) {
       PsiFile file = contextElement.getContainingFile();
       if (file instanceof GoFile) {
-        return ((GoFile)file).getImportPath();
+        return ((GoFile)file).getImportPath(false);
       }
     }
     else if (contextElement instanceof PsiDirectory) {
-      return GoSdkUtil.getImportPath((PsiDirectory)contextElement);
+      return GoSdkUtil.getImportPath((PsiDirectory)contextElement, false);
     }
     return null;
   }

File: src/com/goide/runconfig/testing/GoTestFinder.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -42,8 +42,8 @@ public static boolean isTestFile(@Nullable PsiFile file) {
     return file instanceof GoFile && file.getName().endsWith(GoConstants.TEST_SUFFIX_WITH_EXTENSION);
   }
 
-  public static boolean isTestFile(@Nullable VirtualFile file) {
-    return file != null && file.getFileType() == GoFileType.INSTANCE && file.getNameWithoutExtension().endsWith(GoConstants.TEST_SUFFIX);
+  public static boolean isTestFile(@NotNull VirtualFile file) {
+    return file.getNameWithoutExtension().endsWith(GoConstants.TEST_SUFFIX_WITH_EXTENSION);
   }
 
   public static boolean isTestOrExampleFunction(@NotNull GoFunctionOrMethodDeclaration function) {

File: src/com/goide/runconfig/testing/GoTestRunConfigurationProducerBase.java
Patch:
@@ -87,7 +87,7 @@ public boolean process(VirtualFile file) {
     PsiFile file = contextElement.getContainingFile();
     if (myFramework.isAvailableOnFile(file)) {
       if (GoRunUtil.isPackageContext(contextElement)) {
-        String packageName = StringUtil.notNullize(((GoFile)file).getImportPath());
+        String packageName = StringUtil.notNullize(((GoFile)file).getImportPath(false));
         configuration.setKind(GoTestRunConfiguration.Kind.PACKAGE);
         configuration.setPackage(packageName);
         configuration.setName(getPackageConfigurationName(packageName));
@@ -99,7 +99,7 @@ public boolean process(VirtualFile file) {
           configuration.setPattern("^" + function.getName() + "$");
 
           configuration.setKind(GoTestRunConfiguration.Kind.PACKAGE);
-          configuration.setPackage(StringUtil.notNullize(((GoFile)file).getImportPath()));
+          configuration.setPackage(StringUtil.notNullize(((GoFile)file).getImportPath(false)));
         }
         else {
           configuration.setName(getFileConfigurationName(file.getName()));
@@ -147,7 +147,7 @@ public boolean isConfigurationFromContext(@NotNull GoTestRunConfiguration config
         }
       case PACKAGE:
         if (!GoTestFinder.isTestFile(file)) return false;
-        if (!Comparing.equal(((GoFile)file).getImportPath(), configuration.getPackage())) return false;
+        if (!Comparing.equal(((GoFile)file).getImportPath(false), configuration.getPackage())) return false;
         if (GoRunUtil.isPackageContext(contextElement) && configuration.getPattern().isEmpty()) return true;
 
         GoFunctionOrMethodDeclaration contextFunction = findTestFunctionInContext(contextElement);

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -131,7 +131,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
           throw new ExecutionException("File '" + filePath + "' is not test file");
         }
 
-        String importPath = ((GoFile)file).getImportPath();
+        String importPath = ((GoFile)file).getImportPath(false);
         if (StringUtil.isEmpty(importPath)) {
           throw new ExecutionException("Cannot find import path for " + filePath);
         }

File: src/com/goide/runconfig/testing/frameworks/gocheck/GocheckFramework.java
Patch:
@@ -63,9 +63,8 @@ public String getName() {
   @Override
   public boolean isAvailable(@Nullable Module module) {
     if (module == null) return false;
-    for (GoFile file : StubIndex.getElements(GoPackagesIndex.KEY, "check", module.getProject(), GoUtil.goPathScope(module, null), GoFile.class)) {
-      String importPath = file.getImportPath();
-      if (isGoCheckImportPath(importPath)) {
+    for (GoFile file : StubIndex.getElements(GoPackagesIndex.KEY, "check", module.getProject(), GoUtil.goPathResolveScope(module, null), GoFile.class)) {
+      if (isGoCheckImportPath(file.getImportPath(true))) {
         return true;
       }
     }

File: src/com/goide/sdk/GoPackageUtil.java
Patch:
@@ -54,7 +54,7 @@ private GoPackageUtil() {}
   public static boolean isBuiltinPackage(@Nullable PsiFileSystemItem directory) {
     return directory instanceof PsiDirectory
            && GoConstants.BUILTIN_PACKAGE_NAME.equals(directory.getName())
-           && GoConstants.BUILTIN_PACKAGE_NAME.equals(GoSdkUtil.getImportPath((PsiDirectory)directory));
+           && GoConstants.BUILTIN_PACKAGE_NAME.equals(GoSdkUtil.getImportPath((PsiDirectory)directory, false));
   }
 
   @NotNull
@@ -111,7 +111,7 @@ public static VirtualFile findByImportPath(@NotNull String importPath, @NotNull
       return null;
     }
     importPath = FileUtil.toSystemIndependentName(importPath);
-    for (VirtualFile root : GoSdkUtil.getSourcesPathsToLookup(project, module, null)) {
+    for (VirtualFile root : GoSdkUtil.getSourcesPathsToLookup(project, module)) {
       VirtualFile file = root.findFileByRelativePath(importPath);
       if (file != null) {
         return file;

File: utils/src/com/goide/GoConstants.java
Patch:
@@ -48,6 +48,7 @@ public class GoConstants {
   public static final String C_PATH = "C";
   public static final String TESTING_PATH = "testing";
   public static final String VENDOR = "vendor";
+  public static final String INTERNAL = "internal";
 
   public static final NotificationGroup GO_NOTIFICATION_GROUP = NotificationGroup.balloonGroup("Go plugin notifications");
   public static final NotificationGroup GO_EXECUTION_NOTIFICATION_GROUP = NotificationGroup.toolWindowGroup("Go Execution", ToolWindowId.RUN);

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -699,7 +699,7 @@ public static boolean allowed(@NotNull PsiFile file, @Nullable PsiFile contextFi
     if (!(file instanceof GoFile) || !GoUtil.allowed(file)) return false;
     // it's not a test or context file is also test from the same package
     return !GoTestFinder.isTestFile(file) ||
-           GoTestFinder.isTestFile(contextFile) && Comparing.equal(file.getParent(), contextFile.getParent());
+           GoTestFinder.isTestFile(contextFile) && Comparing.equal(file.getParent(), contextFile.getOriginalFile().getParent());
   }
 
   static boolean processNamedElements(@NotNull PsiScopeProcessor processor,

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,6 +39,7 @@ protected String getBasePath() {
   public void testConstDeclaration()                { doTest(); }
   public void testVarDeclaration()                  { doTest(); }
   public void testBreakLines()                      { doTest(); }
+  public void testCommentIndentation()              { doTest(); }
 
   private void doTest() { doTest(null); }
 

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -250,8 +250,9 @@ else if (element instanceof GoTypeSpec) {
       String name = ((GoTypeSpec)element).getName();
       if (StringUtil.isNotEmpty(name)) {
         String importPath = getImportPathForElement(element);
-        String packageName = ((GoTypeSpec)element).getContainingFile().getPackageName();
-        if (StringUtil.isNotEmpty(packageName) && !GoPsiImplUtil.builtin(element) && !Comparing.equal(importPath, contextImportPath)) {
+        GoFile file = ((GoTypeSpec)element).getContainingFile();
+        String packageName = file.getPackageName();
+        if (StringUtil.isNotEmpty(packageName) && !GoPsiImplUtil.isBuiltinFile(file) && !Comparing.equal(importPath, contextImportPath)) {
           return String.format("<a href=\"%s%s\">%s</a>.<a href=\"%s%s\">%s</a>",
                                DocumentationManagerProtocol.PSI_ELEMENT_PROTOCOL, StringUtil.notNullize(importPath), packageName,
                                DocumentationManagerProtocol.PSI_ELEMENT_PROTOCOL, localUrl, name);

File: src/com/goide/sdk/GoPackageUtil.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.goide.GoConstants;
 import com.goide.psi.GoFile;
-import com.goide.runconfig.testing.GoTestFinder;
 import com.goide.util.GoUtil;
 import com.intellij.openapi.module.Module;
 import com.intellij.openapi.project.Project;
@@ -95,9 +94,9 @@ public Result<Collection<String>> compute() {
         Collection<String> set = ContainerUtil.newLinkedHashSet();
         for (PsiFile file : dir.getFiles()) {
           if (file instanceof GoFile && !GoUtil.directoryToIgnore(file.getName()) && GoUtil.allowed(file)) {
-            String name = ((GoFile)file).getPackageName();
+            String name = trimTestSuffices ? ((GoFile)file).getCanonicalPackageName() : ((GoFile)file).getPackageName();
             if (StringUtil.isNotEmpty(name)) {
-              set.add(trimTestSuffices && GoTestFinder.isTestFile(file) ? StringUtil.trimEnd(name, GoConstants.TEST_SUFFIX) : name);
+              set.add(name);
             }
           }
         }

File: src/com/goide/util/GoUtil.java
Patch:
@@ -201,7 +201,7 @@ public static boolean couldBeReferenceTo(@NotNull PsiElement definition, @NotNul
 
     if (inSamePackage) return true;
     if (reference instanceof GoNamedElement && !((GoNamedElement)reference).isPublic()) return false;
-    if (GoPsiImplUtil.builtin(definitionFile)) return true;
+    if (GoPsiImplUtil.isBuiltinFile(definitionFile)) return true;
     String path = ((GoFile)definitionFile).getVendoringAwareImportPath(reference);
     if (refFile.getImportedPackagesMap().containsKey(path)) return true;
     for (GoFile file : GoPackageUtil.getAllPackageFiles(refFile)) {

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -192,7 +192,7 @@ else if (type != null) {
 
   @NotNull
   private static String getParametersAsString(@NotNull GoParameters parameters) {
-    String contextImportPath = getImportPathForElement(parameters);
+    final String contextImportPath = getImportPathForElement(parameters);
     return StringUtil.join(GoParameterInfoHandler.getParameterPresentations(parameters, new Function<PsiElement, String>() {
       @Override
       public String fun(PsiElement element) {

File: src/com/goide/GoIcons.java
Patch:
@@ -46,7 +46,7 @@ class Helper {
     private Helper() {}
 
     @NotNull
-    public static LayeredIcon createIconWithShift(@NotNull Icon base, Icon mark) {
+    public static LayeredIcon createIconWithShift(@NotNull final Icon base, Icon mark) {
       LayeredIcon icon = new LayeredIcon(2) {
         @Override
         public int getIconHeight() {

File: src/com/goide/GoModuleType.java
Patch:
@@ -71,7 +71,7 @@ public Icon getNodeIcon(boolean isOpened) {
   @NotNull
   @Override
   public ModuleWizardStep[] createWizardSteps(@NotNull WizardContext wizardContext,
-                                              @NotNull GoModuleBuilder moduleBuilder,
+                                              @NotNull final GoModuleBuilder moduleBuilder,
                                               @NotNull ModulesProvider modulesProvider) {
     return new ModuleWizardStep[]{new ProjectJdkForModuleStep(wizardContext, GoSdkType.getInstance()) {
       @Override

File: src/com/goide/UpdateComponent.java
Patch:
@@ -78,7 +78,7 @@ public void run() {
             String pluginId = plugin.getPluginId().getIdString();
             String os = URLEncoder.encode(SystemInfo.OS_NAME + " " + SystemInfo.OS_VERSION, CharsetToolkit.UTF8);
             String uid = UpdateChecker.getInstallationUID(PropertiesComponent.getInstance());
-            String url =
+            final String url =
               "https://plugins.jetbrains.com/plugins/list" +
               "?pluginId=" + pluginId +
               "&build=" + buildNumber +

File: src/com/goide/actions/tool/GoFmtCheckinFactory.java
Patch:
@@ -50,11 +50,11 @@ public class GoFmtCheckinFactory extends CheckinHandlerFactory {
 
   @Override
   @NotNull
-  public CheckinHandler createHandler(@NotNull CheckinProjectPanel panel, @NotNull CommitContext commitContext) {
+  public CheckinHandler createHandler(@NotNull final CheckinProjectPanel panel, @NotNull CommitContext commitContext) {
     return new CheckinHandler() {
       @Override
       public RefreshableOnComponent getBeforeCheckinConfigurationPanel() {
-        JCheckBox checkBox = new JCheckBox("Go fmt");
+        final JCheckBox checkBox = new JCheckBox("Go fmt");
         return new RefreshableOnComponent() {
           @Override
           @NotNull
@@ -83,7 +83,7 @@ public void restoreState() {
       @Override
       public ReturnResult beforeCheckin(@Nullable CommitExecutor executor, PairConsumer<Object, Object> additionalDataConsumer) {
         if (enabled(panel)) {
-          Ref<Boolean> success = new Ref<Boolean>(true);
+          final Ref<Boolean> success = new Ref<Boolean>(true);
           FileDocumentManager.getInstance().saveAllDocuments();
           for (PsiFile file : getPsiFiles()) {
             VirtualFile virtualFile = file.getVirtualFile();

File: src/com/goide/completion/GoAutoImportInsertHandler.java
Patch:
@@ -52,7 +52,7 @@ private GoAutoImportInsertHandler() {
     this((Function<T, InsertHandler<LookupElement>>)null, null);
   }
 
-  private GoAutoImportInsertHandler(@Nullable InsertHandler<LookupElement> delegate, @Nullable Class<T> clazz) {
+  private GoAutoImportInsertHandler(@Nullable final InsertHandler<LookupElement> delegate, @Nullable Class<T> clazz) {
     this(new Function<T, InsertHandler<LookupElement>>() {
       @Nullable
       @Override

File: src/com/goide/completion/GoReferenceCompletionProvider.java
Patch:
@@ -66,8 +66,8 @@ else if (reference instanceof GoReference) {
     }
     else if (reference instanceof GoTypeReference) {
       PsiElement element = reference.getElement();
-      PsiElement spec = PsiTreeUtil.getParentOfType(element, GoFieldDeclaration.class, GoTypeSpec.class);
-      boolean insideParameter = PsiTreeUtil.getParentOfType(element, GoParameterDeclaration.class) != null;
+      final PsiElement spec = PsiTreeUtil.getParentOfType(element, GoFieldDeclaration.class, GoTypeSpec.class);
+      final boolean insideParameter = PsiTreeUtil.getParentOfType(element, GoParameterDeclaration.class) != null;
       ((GoTypeReference)reference).processResolveVariants(new MyGoScopeProcessor(result, true) {
         @Override
         protected boolean accept(@NotNull PsiElement e) {

File: src/com/goide/configuration/GoBuildTagsUI.java
Patch:
@@ -92,7 +92,7 @@ public void actionPerformed(@NotNull ActionEvent event) {
     myArchCombo.addActionListener(updateCgoListener);
   }
 
-  public void initPanel(@NotNull Module module) {
+  public void initPanel(@NotNull final Module module) {
     if (!module.isDisposed()) {
       MessageBusConnection connection = module.getMessageBus().connect(this);
       connection.subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootAdapter() {

File: src/com/goide/configuration/GoLibrariesConfigurable.java
Patch:
@@ -59,7 +59,7 @@ public GoLibrariesConfigurable(@NotNull String displayName, @NotNull GoLibraries
     myLibrariesService = librariesService;
     myReadOnlyPaths = readOnlyPaths;
 
-    JBList filesList = new JBList(myListModel);
+    final JBList filesList = new JBList(myListModel);
     filesList.setCellRenderer(new ColoredListCellRenderer() {
       @Override
       protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {

File: src/com/goide/configuration/GoVendoringUI.java
Patch:
@@ -53,7 +53,7 @@ public class GoVendoringUI implements Disposable {
   @SuppressWarnings("unused") 
   private JTextPane myDescriptionPane;
 
-  public void initPanel(@NotNull Module module) {
+  public void initPanel(@NotNull final Module module) {
     if (!module.isDisposed()) {
       MessageBusConnection connection = module.getMessageBus().connect(this);
       //noinspection unchecked

File: src/com/goide/editor/GoTypedHandler.java
Patch:
@@ -35,14 +35,14 @@ public GoTypedHandler(TypedActionHandler originalHandler) {
   }
 
   @Override
-  public void execute(@NotNull Editor editor, char c, @NotNull DataContext dataContext) {
+  public void execute(@NotNull final Editor editor, char c, @NotNull DataContext dataContext) {
     if (myOriginalHandler != null) myOriginalHandler.execute(editor, c, dataContext);
     if (c != 'e') return;
-    Project project = editor.getProject();
+    final Project project = editor.getProject();
     if (project == null) return;
     int offset = editor.getCaretModel().getOffset();
     if (offset < 4) return;
-    TextRange from = TextRange.from(offset - 4, 4);
+    final TextRange from = TextRange.from(offset - 4, 4);
     String text = editor.getDocument().getText(from);
     if ("case".equals(text)) {
       PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());

File: src/com/goide/highlighting/GoHighlightingAnnotator.java
Patch:
@@ -133,7 +133,7 @@ public void annotate(@NotNull PsiElement o, @NotNull AnnotationHolder holder) {
     if (!o.isValid()) return;
     if (o instanceof GoImportSpec) {
       if (((GoImportSpec)o).isDot()) {
-        o.putUserData(GoReference.IMPORT_USERS, ContainerUtil.newArrayListWithCapacity(0));
+        o.putUserData(GoReference.IMPORT_USERS, ContainerUtil.newArrayList());
       }
     }
     else if (o instanceof GoLiteral) {

File: src/com/goide/highlighting/exitpoint/GoBreakStatementExitPointHandler.java
Patch:
@@ -59,7 +59,7 @@ protected void selectTargets(List<PsiElement> targets, @NotNull Consumer<List<Ps
 
   @Override
   public void computeUsages(List<PsiElement> targets) {
-    PsiElement breakStmtOwner = findBreakStatementOwner();
+    final PsiElement breakStmtOwner = findBreakStatementOwner();
     GoRecursiveVisitor visitor = new GoRecursiveVisitor() {
       @Override
       public void visitLabelDefinition(@NotNull GoLabelDefinition o) {

File: src/com/goide/inspections/GoDeferInLoopInspection.java
Patch:
@@ -29,7 +29,7 @@
 public class GoDeferInLoopInspection extends GoInspectionBase {
   @NotNull
   @Override
-  protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
+  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
     return new GoVisitor() {
       @Override
       public void visitDeferStatement(@NotNull GoDeferStatement o) {

File: src/com/goide/inspections/GoEmbeddedInterfacePointerInspection.java
Patch:
@@ -25,7 +25,7 @@
 public class GoEmbeddedInterfacePointerInspection extends GoInspectionBase {
   @NotNull
   @Override
-  protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
+  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
     return new GoVisitor() {
       @Override
       public void visitAnonymousFieldDefinition(@NotNull GoAnonymousFieldDefinition o) {

File: src/com/goide/inspections/GoMethodOnNonLocalTypeInspection.java
Patch:
@@ -30,7 +30,7 @@
 public class GoMethodOnNonLocalTypeInspection extends GoInspectionBase {
   @NotNull
   @Override
-  protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
+  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
     return new GoVisitor() {
       @Override
       public void visitMethodDeclaration(@NotNull GoMethodDeclaration method) {

File: src/com/goide/inspections/GoMissingReturnInspection.java
Patch:
@@ -128,7 +128,7 @@ else if (s instanceof GoStatement && ((GoStatement)s).getBlock() != null) {
 
   @NotNull
   @Override
-  protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder,
+  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
                                      @SuppressWarnings({"UnusedParameters", "For future"}) @NotNull LocalInspectionToolSession session) {
     return new GoVisitor() {
       @Override

File: src/com/goide/inspections/GoPlaceholderCountInspection.java
Patch:
@@ -151,7 +151,7 @@ else if (expr instanceof GoAddExpr) {
 
   @NotNull
   @Override
-  protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
+  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
     return new GoVisitor() {
       @Override
       public void visitCallExpr(@NotNull GoCallExpr o) {

File: src/com/goide/inspections/GoUsedAsValueInCondition.java
Patch:
@@ -37,7 +37,7 @@ public class GoUsedAsValueInCondition extends GoInspectionBase {
 
   @NotNull
   @Override
-  protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
+  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
     return new GoVisitor() {
       @Override
       public void visitAssignmentStatement(@NotNull GoAssignmentStatement o) {

File: src/com/goide/inspections/MismatchedBuildTargetNotificationProvider.java
Patch:
@@ -47,8 +47,8 @@ public class MismatchedBuildTargetNotificationProvider extends EditorNotificatio
   private final Project myProject;
 
   public MismatchedBuildTargetNotificationProvider(@NotNull Project project, 
-                                                   @NotNull EditorNotifications notifications,
-                                                   @NotNull FileEditorManager fileEditorManager) {
+                                                   @NotNull final EditorNotifications notifications,
+                                                   @NotNull final FileEditorManager fileEditorManager) {
     myProject = project;
     MessageBusConnection connection = myProject.getMessageBus().connect(myProject);
     connection.subscribe(GoModuleSettings.TOPIC, new GoModuleSettings.BuildTargetListener() {
@@ -94,7 +94,7 @@ public EditorNotificationPanel createNotificationPanel(@NotNull VirtualFile file
   }
 
   @NotNull
-  private static EditorNotificationPanel createPanel(@NotNull Module module, @NotNull VirtualFile file) {
+  private static EditorNotificationPanel createPanel(@NotNull final Module module, @NotNull VirtualFile file) {
     EditorNotificationPanel panel = new EditorNotificationPanel();
     panel.setText("'" + file.getName() + "' doesn't match to target system");
     panel.createActionLabel("Open Go project settings", new Runnable() {

File: src/com/goide/inspections/WrongSdkConfigurationNotificationProvider.java
Patch:
@@ -49,7 +49,7 @@ public class WrongSdkConfigurationNotificationProvider extends EditorNotificatio
 
   private final Project myProject;
 
-  public WrongSdkConfigurationNotificationProvider(@NotNull Project project, @NotNull EditorNotifications notifications) {
+  public WrongSdkConfigurationNotificationProvider(@NotNull Project project, @NotNull final EditorNotifications notifications) {
     myProject = project;
     MessageBusConnection connection = myProject.getMessageBus().connect(project);
     connection.subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootAdapter() {
@@ -98,7 +98,7 @@ public EditorNotificationPanel createNotificationPanel(@NotNull VirtualFile file
   }
 
   @NotNull
-  private static EditorNotificationPanel createMissingSdkPanel(@NotNull Project project, @Nullable Module module) {
+  private static EditorNotificationPanel createMissingSdkPanel(@NotNull final Project project, @Nullable final Module module) {
     EditorNotificationPanel panel = new EditorNotificationPanel();
     panel.setText(ProjectBundle.message("project.sdk.not.defined"));
     panel.createActionLabel(ProjectBundle.message("project.sdk.setup"), new Runnable() {
@@ -111,7 +111,7 @@ public void run() {
   }
 
   @NotNull
-  private static EditorNotificationPanel createEmptyGoPathPanel(@NotNull Project project) {
+  private static EditorNotificationPanel createEmptyGoPathPanel(@NotNull final Project project) {
     EditorNotificationPanel panel = new EditorNotificationPanel();
     panel.setText("GOPATH is empty");
     panel.createActionLabel("Configure Go Libraries", new Runnable() {

File: src/com/goide/inspections/unresolved/GoUnresolvedReferenceInspection.java
Patch:
@@ -45,7 +45,7 @@
 public class GoUnresolvedReferenceInspection extends GoInspectionBase {
   @NotNull
   @Override
-  protected GoVisitor buildGoVisitor(@NotNull ProblemsHolder holder,
+  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
                                      @SuppressWarnings({"UnusedParameters", "For future"}) @NotNull LocalInspectionToolSession session) {
     return new GoVisitor() {
       @Override

File: src/com/goide/project/migration/GoBuildTagsSettingsConverterProvider.java
Patch:
@@ -43,7 +43,7 @@ public String getConversionDescription() {
 
   @NotNull
   @Override
-  public ProjectConverter createConverter(@NotNull ConversionContext context) {
+  public ProjectConverter createConverter(@NotNull final ConversionContext context) {
     return new ProjectConverter() {
       private GoBuildTargetSettings newSettings;
 

File: src/com/goide/psi/impl/GoFieldNameReference.java
Patch:
@@ -40,7 +40,7 @@ public GoFieldNameReference(@NotNull GoReferenceExpressionBase element) {
   }
 
   @Override
-  public boolean processResolveVariants(@NotNull GoScopeProcessor processor) {
+  public boolean processResolveVariants(@NotNull final GoScopeProcessor processor) {
     GoScopeProcessor fieldProcessor = processor instanceof GoFieldProcessor ? processor : new GoFieldProcessor(myElement) {
       @Override
       public boolean execute(@NotNull PsiElement e, @NotNull ResolveState state) {

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -89,7 +89,7 @@ private PsiElement getIdentifier() {
   }
 
   @NotNull
-  static GoScopeProcessor createResolveProcessor(@NotNull Collection<ResolveResult> result, @NotNull GoReferenceExpressionBase o) {
+  static GoScopeProcessor createResolveProcessor(@NotNull final Collection<ResolveResult> result, @NotNull final GoReferenceExpressionBase o) {
     return new GoScopeProcessor() {
       @Override
       public boolean execute(@NotNull PsiElement element, @NotNull ResolveState state) {
@@ -162,7 +162,7 @@ private static GoTypeReferenceExpression getTypeRefExpression(@NotNull GoType ty
     return type.getTypeReferenceExpression();
   }
 
-  private boolean processGoType(@NotNull GoType type, @NotNull GoScopeProcessor processor, @NotNull ResolveState state) {
+  private boolean processGoType(@NotNull final GoType type, @NotNull final GoScopeProcessor processor, @NotNull final ResolveState state) {
     Boolean result = RecursionManager.doPreventingRecursion(type, true, new Computable<Boolean>() {
       @Override
       public Boolean compute() {
@@ -412,7 +412,7 @@ protected boolean crossOff(@NotNull PsiElement e) {
 
   private static boolean processFileEntities(@NotNull GoFile file,
                                              @NotNull GoScopeProcessor processor,
-                                             @NotNull ResolveState state,
+                                             @NotNull final ResolveState state,
                                              boolean localProcessing) {
     if (!processNamedElements(processor, state, file.getConstants(), new Condition<GoNamedElement>() {
         @Override

File: src/com/goide/psi/impl/GoVarReference.java
Patch:
@@ -48,7 +48,7 @@ protected boolean crossOff(@NotNull PsiElement e) {
   }
 
   @Override
-  public boolean processResolveVariants(@NotNull GoScopeProcessor processor) {
+  public boolean processResolveVariants(@NotNull final GoScopeProcessor processor) {
     GoVarProcessor p = processor instanceof GoVarProcessor
                        ? (GoVarProcessor)processor
                        : new GoVarProcessor(myElement, processor.isCompletion()) {

File: src/com/goide/psi/impl/imports/GoImportReference.java
Patch:
@@ -132,12 +132,12 @@ public LocalQuickFix[] getQuickFixes() {
       result.add(new GoGetPackageFix(fileReferenceSet.getPathString()));
     }
 
-    String fileNameToCreate = getFileNameToCreate();
+    final String fileNameToCreate = getFileNameToCreate();
     for (PsiFileSystemItem context : getContexts()) {
       if (context instanceof PsiDirectory) {
         try {
           ((PsiDirectory)context).checkCreateSubdirectory(fileNameToCreate);
-          String targetPath = context.getVirtualFile().getPath();
+          final String targetPath = context.getVirtualFile().getPath();
           result.add(new CreateFileFix(true, fileNameToCreate, (PsiDirectory)context) {
             @NotNull
             @Override

File: src/com/goide/psi/impl/imports/GoImportReferenceSet.java
Patch:
@@ -52,7 +52,7 @@ public Collection<PsiFileSystemItem> computeDefaultContexts() {
       return Collections.emptyList();
     }
 
-    PsiManager psiManager = file.getManager();
+    final PsiManager psiManager = file.getManager();
     Module module = ModuleUtilCore.findModuleForPsiElement(file);
     PsiElement contextForSourcePaths = GoVendoringUtil.isVendoringEnabled(module) ? file : null;
     return ContainerUtil.mapNotNull(GoSdkUtil.getSourcesPathsToLookup(file.getProject(), module, contextForSourcePaths),

File: src/com/goide/quickfix/GoDeleteImportQuickFix.java
Patch:
@@ -36,8 +36,8 @@ public GoDeleteImportQuickFix() {
 
   @Override
   public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
-    PsiElement element = PsiTreeUtil.getNonStrictParentOfType(descriptor.getPsiElement(), GoImportSpec.class);
-    PsiFile file = element != null ? element.getContainingFile() : null;
+    final PsiElement element = PsiTreeUtil.getNonStrictParentOfType(descriptor.getPsiElement(), GoImportSpec.class);
+    final PsiFile file = element != null ? element.getContainingFile() : null;
     if (!(file instanceof GoFile)) return;
 
     WriteCommandAction.runWriteCommandAction(project, new Runnable() {

File: src/com/goide/quickfix/GoRenameQuickFix.java
Patch:
@@ -45,9 +45,9 @@ public GoRenameQuickFix(@NotNull GoNamedElement element) {
 
 
   @Override
-  public void invoke(@NotNull Project project,
+  public void invoke(@NotNull final Project project,
                      @NotNull PsiFile file,
-                     @NotNull PsiElement startElement,
+                     @NotNull final PsiElement startElement,
                      @NotNull PsiElement endElement) {
     if (!FileModificationService.getInstance().preparePsiElementsForWrite(startElement)) return;
 

File: src/com/goide/refactor/GoRefactoringUtil.java
Patch:
@@ -40,9 +40,9 @@ public static List<PsiElement> getLocalOccurrences(@NotNull PsiElement element)
   }
 
   @NotNull
-  public static List<PsiElement> getOccurrences(@NotNull PsiElement pattern, @Nullable PsiElement context) {
+  public static List<PsiElement> getOccurrences(@NotNull final PsiElement pattern, @Nullable PsiElement context) {
     if (context == null) return Collections.emptyList();
-    List<PsiElement> occurrences = ContainerUtil.newArrayList();
+    final List<PsiElement> occurrences = ContainerUtil.newArrayList();
     PsiRecursiveElementVisitor visitor = new PsiRecursiveElementVisitor() {
       @Override
       public void visitElement(@NotNull PsiElement element) {

File: src/com/goide/runconfig/GoConsoleFilter.java
Patch:
@@ -166,7 +166,7 @@ private VirtualFile findSingleFile(@NotNull String fileName) {
         return ContainerUtil.getFirstItem(files);
       }
       if (!files.isEmpty()) {
-        GlobalSearchScope goPathScope = GoPathSearchScope.create(myProject, myModule, null);
+        final GlobalSearchScope goPathScope = GoPathSearchScope.create(myProject, myModule, null);
         files = ContainerUtil.filter(files, new Condition<VirtualFile>() {
           @Override
           public boolean value(VirtualFile file) {

File: src/com/goide/runconfig/GoRunUtil.java
Patch:
@@ -85,7 +85,7 @@ public static PsiElement getContextElement(@Nullable ConfigurationContext contex
     return psiElement;
   }
 
-  public static void installGoWithMainFileChooser(Project project, @NotNull TextFieldWithBrowseButton fileField) {
+  public static void installGoWithMainFileChooser(final Project project, @NotNull TextFieldWithBrowseButton fileField) {
     installFileChooser(project, fileField, false, false, new Condition<VirtualFile>() {
       @Override
       public boolean value(VirtualFile file) {

File: src/com/goide/runconfig/application/GoApplicationRunningState.java
Patch:
@@ -66,7 +66,7 @@ public boolean isDebug() {
   @NotNull
   @Override
   protected ProcessHandler startProcess() throws ExecutionException {
-    ProcessHandler processHandler = super.startProcess();
+    final ProcessHandler processHandler = super.startProcess();
     processHandler.addProcessListener(new ProcessAdapter() {
       private final AtomicBoolean firstOutput = new AtomicBoolean(true);
 

File: src/com/goide/runconfig/testing/GoTestRunConfigurationProducerBase.java
Patch:
@@ -50,16 +50,16 @@ protected GoTestRunConfigurationProducerBase(@NotNull GoTestFramework framework)
   }
 
   @Override
-  protected boolean setupConfigurationFromContext(@NotNull GoTestRunConfiguration configuration,
+  protected boolean setupConfigurationFromContext(@NotNull final GoTestRunConfiguration configuration,
                                                   ConfigurationContext context,
                                                   Ref sourceElement) {
-    PsiElement contextElement = GoRunUtil.getContextElement(context);
+    final PsiElement contextElement = GoRunUtil.getContextElement(context);
     if (contextElement == null) {
       return false;
     }
 
     Module module = ModuleUtilCore.findModuleForPsiElement(contextElement);
-    Project project = contextElement.getProject();
+    final Project project = contextElement.getProject();
     if (module == null || !GoSdkService.getInstance(project).isGoModule(module)) return false;
     if (!myFramework.isAvailable(module)) return false;
 

File: src/com/goide/runconfig/testing/coverage/GoCoverageProjectData.java
Patch:
@@ -48,7 +48,7 @@ public void processFile(@NotNull String filePath, @NotNull Processor<RangeData>
     }
   }
 
-  public void addData(String filePath, int startLine, int startColumn, int endLine, int endColumn, int statements, int hits) {
+  public void addData(final String filePath, int startLine, int startColumn, int endLine, int endColumn, int statements, int hits) {
     FileData fileData = ContainerUtil.getOrCreate(myFilesData, filePath, new Factory<FileData>() {
       @Override
       public FileData create() {

File: src/com/goide/runconfig/testing/coverage/GoCoverageRunner.java
Patch:
@@ -90,7 +90,7 @@ public ProjectData loadCoverageData(@NotNull File sessionDataFile, @Nullable Cov
   public static GoCoverageProjectData parseCoverage(@NotNull BufferedReader dataReader,
                                                     @NotNull Project project,
                                                     @Nullable Module module) throws IOException {
-    GoCoverageProjectData result = new GoCoverageProjectData();
+    final GoCoverageProjectData result = new GoCoverageProjectData();
     String line;
 
     while ((line = dataReader.readLine()) != null) {
@@ -144,7 +144,7 @@ public boolean process(GoCoverageProjectData.FileData fileData) {
           max = Math.max(max, rangeData.endLine);
         }
 
-        LineData[] linesArray = new LineData[max + 1];
+        final LineData[] linesArray = new LineData[max + 1];
         linesMap.forEachValue(new TObjectProcedure<LineData>() {
           @Override
           public boolean execute(LineData data) {

File: src/com/goide/sdk/GoPackageUtil.java
Patch:
@@ -85,7 +85,7 @@ public VirtualFile fun(GoFile file) {
   }
 
   @NotNull
-  public static Collection<String> getAllPackagesInDirectory(@Nullable PsiDirectory dir, boolean trimTestSuffices) {
+  public static Collection<String> getAllPackagesInDirectory(@Nullable final PsiDirectory dir, final boolean trimTestSuffices) {
     if (dir == null) return Collections.emptyList();
     Key<CachedValue<Collection<String>>> key = trimTestSuffices ? PACKAGES_TEST_TRIMMED_CACHE : PACKAGES_CACHE;
     return CachedValuesManager.getManager(dir.getProject()).getCachedValue(dir, key, new CachedValueProvider<Collection<String>>() {

File: src/com/goide/stubs/GoStubElementTypeFactory.java
Patch:
@@ -89,7 +89,7 @@ public GoVarSpec createPsi(@NotNull GoVarSpecStub stub) {
     if ("PARAMETER_DECLARATION".equals(name)) return new GoParameterDeclarationStubElementType(name);
     if ("RESULT".equals(name)) return new GoResultStubElementType(name);
 
-    Class c = TYPES.get(name);
+    final Class c = TYPES.get(name);
     if (c != null) {
       return new GoTypeStubElementType(name) {
         @NotNull

File: src/com/goide/tree/GoStructureViewFactory.java
Patch:
@@ -44,7 +44,7 @@
 public class GoStructureViewFactory implements PsiStructureViewFactory {
   @Nullable
   @Override
-  public StructureViewBuilder getStructureViewBuilder(@NotNull PsiFile psiFile) {
+  public StructureViewBuilder getStructureViewBuilder(@NotNull final PsiFile psiFile) {
     return new TreeBasedStructureViewBuilder() {
       @NotNull
       @Override

File: src/com/goide/util/GoUtil.java
Patch:
@@ -69,7 +69,7 @@ public static boolean allowed(@NotNull PsiFile file) {
     return module == null || new GoBuildMatcher(GoBuildTargetUtil.getTargetSystemDescriptor(module)).matchFile(file);
   }
 
-  public static boolean isExcludedFile(@NotNull GoFile file) {
+  public static boolean isExcludedFile(@NotNull final GoFile file) {
     return CachedValuesManager.getCachedValue(file, new CachedValueProvider<Boolean>() {
       @Nullable
       @Override

File: tests/com/goide/inspections/GoInvalidPackageImportInspectionTest.java
Patch:
@@ -133,7 +133,7 @@ public void testImportMainPackage() {
   }
 
   public void testImportPackageWithoutBuildableSource() {
-    PsiFile file = myFixture.addFileToProject("withSources/a.go", "package withSources");
+    final PsiFile file = myFixture.addFileToProject("withSources/a.go", "package withSources");
     WriteCommandAction.runWriteCommandAction(myFixture.getProject(), new Runnable() {
       @Override
       public void run() {

File: src/com/goide/inspections/MismatchedBuildTargetNotificationProvider.java
Patch:
@@ -53,7 +53,7 @@ public MismatchedBuildTargetNotificationProvider(@NotNull Project project,
     MessageBusConnection connection = myProject.getMessageBus().connect(myProject);
     connection.subscribe(GoModuleSettings.TOPIC, new GoModuleSettings.BuildTargetListener() {
       @Override
-      public void changed() {
+      public void changed(@NotNull Module module) {
         notifications.updateAllNotifications();
       }
     });

File: src/com/goide/inspections/GoCgoInTestInspection.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,7 @@
 
 import com.goide.psi.GoFile;
 import com.goide.psi.GoImportSpec;
-import com.goide.quickfix.GoDeleteQuickFix;
+import com.goide.quickfix.GoDeleteImportQuickFix;
 import com.goide.runconfig.testing.GoTestFinder;
 import com.intellij.codeInspection.ProblemsHolder;
 import org.jetbrains.annotations.NotNull;
@@ -29,7 +29,7 @@ protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsH
     if (!GoTestFinder.isTestFile(file)) return;
     for (GoImportSpec importSpec : file.getImports()) {
       if (importSpec.isCImport()) {
-        problemsHolder.registerProblem(importSpec, "Usage of cgo in tests is not supported.", new GoDeleteQuickFix("Remove 'C' import"));
+        problemsHolder.registerProblem(importSpec, "Usage of cgo in tests is not supported.", new GoDeleteImportQuickFix());
       }
     }
   }

File: src/com/goide/psi/impl/imports/GoImportReferenceSet.java
Patch:
@@ -107,7 +107,7 @@ public FileReference createFileReference(TextRange range, int index, String text
     return new GoImportReference(this, range, index, text);
   }
 
-  private boolean isRelativeImport() {
+  public boolean isRelativeImport() {
     return getPathString().startsWith("./") || getPathString().startsWith("../");
   }
 }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -376,7 +376,7 @@ public void testVendoringImportPaths() {
   }
 
   public void testBuiltinImport() {
-    myFixture.configureByText("a.go", "package a; import _ `<error descr=\"Cannot resolve file 'builtin'\">builtin</error>`");
+    myFixture.configureByText("a.go", "package a; import _ `<error descr=\"Cannot import `builtin` package\">builtin</error>`");
     myFixture.checkHighlighting();
   }
   

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -225,7 +225,7 @@ public static String getImportPath(@Nullable PsiDirectory psiDirectory) {
 
   @Nullable
   @Contract("null, _ -> null")
-  private static String getVendoringAwareImportPath(@Nullable PsiDirectory psiDirectory, @Nullable PsiElement context) {
+  public static String getVendoringAwareImportPath(@Nullable PsiDirectory psiDirectory, @Nullable PsiElement context) {
     if (psiDirectory == null) {
       return null;
     }

File: src/com/goide/util/GoUtil.java
Patch:
@@ -209,7 +209,7 @@ public static boolean couldBeReferenceTo(@NotNull PsiElement definition, @NotNul
     if (inSamePackage) return true;
     if (reference instanceof GoNamedElement && !((GoNamedElement)reference).isPublic()) return false;
     if (GoPsiImplUtil.builtin(definitionFile)) return true;
-    String path = ((GoFile)definitionFile).getImportPath();
+    String path = ((GoFile)definitionFile).getVendoringAwareImportPath(reference);
     if (refFile.getImportedPackagesMap().containsKey(path)) return true;
     for (GoFile file : GoPsiImplUtil.getAllPackageFiles(refFile)) {
       if (file != refFile && refFile.getOriginalFile() != file) {

File: src/com/goide/project/GoBuildTargetSettings.java
Patch:
@@ -18,10 +18,12 @@
 
 import com.intellij.util.ArrayUtil;
 import com.intellij.util.ThreeState;
+import com.intellij.util.xmlb.annotations.Tag;
 import org.jetbrains.annotations.NotNull;
 
 import java.util.Arrays;
 
+@Tag("buildTags")
 public class GoBuildTargetSettings {
   public static final String ANY_COMPILER = "Any";
   public static final String DEFAULT = "default";

File: src/com/goide/project/GoVendoringSettings.java
Patch:
@@ -18,9 +18,11 @@
 
 import com.intellij.util.ThreeState;
 import com.intellij.util.text.VersionComparatorUtil;
+import com.intellij.util.xmlb.annotations.Tag;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+@Tag("vendoring")
 public class GoVendoringSettings {
   @NotNull
   public ThreeState vendorSupportEnabled = ThreeState.UNSURE;

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -318,7 +318,8 @@ public GoType compute() {
           @Nullable
           @Override
           public Result<GoType> compute() {
-            return Result.create(getGoTypeInner(o, null), PsiModificationTracker.MODIFICATION_COUNT);
+            GoType inner = getGoTypeInner(o, null);
+            return Result.create(inner instanceof GoParType ? ((GoParType)inner).getActualType() : inner, PsiModificationTracker.MODIFICATION_COUNT);
           }
         });
       }

File: gen/com/goide/psi/GoParType.java
Patch:
@@ -16,4 +16,7 @@ public interface GoParType extends GoType {
   @NotNull
   PsiElement getRparen();
 
+  @NotNull
+  GoType getActualType();
+
 }

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -219,7 +219,7 @@ else if (type instanceof GoChannelType) {
         return replaceInnerTypes(type, contextImportPath, ((GoChannelType)type).getType());
       }
       else if (type instanceof GoParType) {
-        return replaceInnerTypes(type, contextImportPath, ((GoParType)type).getType());
+        return replaceInnerTypes(type, contextImportPath, ((GoParType)type).getActualType());
       }
       else if (type instanceof GoArrayOrSliceType) {
         return replaceInnerTypes(type, contextImportPath, ((GoArrayOrSliceType)type).getType());

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -166,7 +166,7 @@ private boolean processGoType(@NotNull final GoType type, @NotNull final GoScope
     Boolean result = RecursionManager.doPreventingRecursion(type, true, new Computable<Boolean>() {
       @Override
       public Boolean compute() {
-        if (type instanceof GoParType) return processGoType(((GoParType)type).getType(), processor, state);
+        if (type instanceof GoParType) return processGoType(((GoParType)type).getActualType(), processor, state);
         if (!processExistingType(type, processor, state)) return false;
         if (type instanceof GoPointerType) {
           if (!processPointer((GoPointerType)type, processor, state.put(POINTER, true))) return false;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -140,6 +140,7 @@ protected boolean isWriteActionRequired() {
   public void testIota2()                     { doTest(); }
   public void testUnaryPointer()              { doTest(); }
   public void testFileRead()                  { doTest(); }
+  public void testLiteralValues()             { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {
     myFixture.addFileToProject("pack1/a.go", "package foo;");

File: tests/com/goide/psi/legacy/GoLegacyResolveStructTest.java
Patch:
@@ -26,6 +26,7 @@ public class GoLegacyResolveStructTest extends GoLegacyResolveTestBase {
   public void testDirectStructField()                       { doFileTest(); } 
   public void testAnonymousDirectStructField()              { doFileTest(); } 
   public void testPromotedStructField()                     { doFileTest(); } 
+  public void testStructFieldInMap()                        { doFileTest(); } 
   public void testFieldVsParam()                            { doFileTest(); } 
   public void testFieldVsParam2()                           { doFileTest(); }
   public void testFieldVsParam3()                           { doFileTest(); }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -138,6 +138,7 @@ protected boolean isWriteActionRequired() {
   public void testChan()                      { doTest(); }
   public void testIota()                      { doTest(); }
   public void testIota2()                     { doTest(); }
+  public void testUnaryPointer()              { doTest(); }
 
   public void testAvoidDuplicatedUnusedImportReports() {
     myFixture.addFileToProject("pack1/a.go", "package foo;");

File: src/com/goide/GoFileElementType.java
Patch:
@@ -31,7 +31,7 @@
 
 public class GoFileElementType extends IStubFileElementType<GoFileStub> {
   public static final IStubFileElementType INSTANCE = new GoFileElementType();
-  public static final int VERSION = 15;
+  public static final int VERSION = 16;
 
   private GoFileElementType() {
     super("GO_FILE", GoLanguage.INSTANCE);

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -82,4 +82,5 @@ protected void setUp() throws Exception {
   public void testChanRecover()                     { doTest(false); }
   public void testMapLiteralRecover()               { doTest(false); }
   public void testPlusPlusRecover()                 { doTest(false); }
+  public void testTypeComma()                       { doTest(false); }
 }

File: src/com/goide/highlighting/GoColorsAndFontsPage.java
Patch:
@@ -50,6 +50,7 @@ public class GoColorsAndFontsPage implements ColorSettingsPage {
     new AttributesDescriptor("Type specification", TYPE_SPECIFICATION),
     new AttributesDescriptor("Type reference", TYPE_REFERENCE),
     new AttributesDescriptor("Builtin type", BUILTIN_TYPE_REFERENCE),
+    new AttributesDescriptor("Builtin function", BUILTIN_FUNCTION),
     new AttributesDescriptor("Exported function", EXPORTED_FUNCTION),
     new AttributesDescriptor("Local function", LOCAL_FUNCTION),
     new AttributesDescriptor("Package exported interface", PACKAGE_EXPORTED_INTERFACE),
@@ -74,6 +75,7 @@ public class GoColorsAndFontsPage implements ColorSettingsPage {
     ATTRIBUTES_KEY_MAP.put("tr", TYPE_REFERENCE);
     ATTRIBUTES_KEY_MAP.put("ts", TYPE_SPECIFICATION);
     ATTRIBUTES_KEY_MAP.put("bt", BUILTIN_TYPE_REFERENCE);
+    ATTRIBUTES_KEY_MAP.put("bf", BUILTIN_FUNCTION);
     ATTRIBUTES_KEY_MAP.put("kw", KEYWORD);
     ATTRIBUTES_KEY_MAP.put("ef", EXPORTED_FUNCTION);
     ATTRIBUTES_KEY_MAP.put("lf", LOCAL_FUNCTION);
@@ -225,6 +227,7 @@ public String getDemoText() {
            "    _ = <lf>variableFunc</lf>(1)\n" +
            "    _ = <fp>demo1</fp>\n" +
            "    _ = <lv>demo2</lv>\n" +
+           "    <bf>println</bf>(\"builtin function\")" +
            "\n" +
            "}\n" +
            "\n" +

File: src/com/goide/highlighting/GoHighlightingAnnotator.java
Patch:
@@ -93,6 +93,7 @@ private static TextAttributesKey getColor(GoVarDefinition o) {
   }
 
   private static TextAttributesKey getColor(GoNamedSignatureOwner o) {
+    if (GoPsiImplUtil.builtin(o)) return BUILTIN_FUNCTION;
     return o.isPublic() ? EXPORTED_FUNCTION : LOCAL_FUNCTION;
   }
 

File: src/com/goide/highlighting/GoSyntaxHighlightingColors.java
Patch:
@@ -41,6 +41,7 @@ public class GoSyntaxHighlightingColors {
   public static final TextAttributesKey TYPE_SPECIFICATION = createTextAttributesKey("GO_TYPE_SPECIFICATION", DefaultLanguageHighlighterColors.CLASS_NAME);
   public static final TextAttributesKey TYPE_REFERENCE = createTextAttributesKey("GO_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
   public static final TextAttributesKey BUILTIN_TYPE_REFERENCE = createTextAttributesKey("GO_BUILTIN_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
+  public static final TextAttributesKey BUILTIN_FUNCTION = createTextAttributesKey("GO_BUILTIN_FUNCTION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
   public static final TextAttributesKey EXPORTED_FUNCTION = createTextAttributesKey("GO_EXPORTED_FUNCTION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
   public static final TextAttributesKey LOCAL_FUNCTION = createTextAttributesKey("GO_LOCAL_FUNCTION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
   public static final TextAttributesKey PACKAGE_EXPORTED_INTERFACE = createTextAttributesKey("GO_PACKAGE_EXPORTED_INTERFACE", DefaultLanguageHighlighterColors.INTERFACE_NAME);

File: src/com/goide/highlighting/GoColorsAndFontsPage.java
Patch:
@@ -50,6 +50,7 @@ public class GoColorsAndFontsPage implements ColorSettingsPage {
     new AttributesDescriptor("Type specification", TYPE_SPECIFICATION),
     new AttributesDescriptor("Type reference", TYPE_REFERENCE),
     new AttributesDescriptor("Builtin type", BUILTIN_TYPE_REFERENCE),
+    new AttributesDescriptor("Builtin function", BUILTIN_FUNCTION),
     new AttributesDescriptor("Exported function", EXPORTED_FUNCTION),
     new AttributesDescriptor("Local function", LOCAL_FUNCTION),
     new AttributesDescriptor("Package exported interface", PACKAGE_EXPORTED_INTERFACE),
@@ -74,6 +75,7 @@ public class GoColorsAndFontsPage implements ColorSettingsPage {
     ATTRIBUTES_KEY_MAP.put("tr", TYPE_REFERENCE);
     ATTRIBUTES_KEY_MAP.put("ts", TYPE_SPECIFICATION);
     ATTRIBUTES_KEY_MAP.put("bt", BUILTIN_TYPE_REFERENCE);
+    ATTRIBUTES_KEY_MAP.put("bf", BUILTIN_FUNCTION);
     ATTRIBUTES_KEY_MAP.put("kw", KEYWORD);
     ATTRIBUTES_KEY_MAP.put("ef", EXPORTED_FUNCTION);
     ATTRIBUTES_KEY_MAP.put("lf", LOCAL_FUNCTION);
@@ -225,6 +227,7 @@ public String getDemoText() {
            "    _ = <lf>variableFunc</lf>(1)\n" +
            "    _ = <fp>demo1</fp>\n" +
            "    _ = <lv>demo2</lv>\n" +
+           "    <bf>println</bf>(\"builtin function\")" +
            "\n" +
            "}\n" +
            "\n" +

File: src/com/goide/highlighting/GoHighlightingAnnotator.java
Patch:
@@ -92,6 +92,7 @@ private static TextAttributesKey getColor(GoVarDefinition o) {
   }
 
   private static TextAttributesKey getColor(GoNamedSignatureOwner o) {
+    if (GoPsiImplUtil.builtin(o)) return BUILTIN_FUNCTION;
     return o.isPublic() ? EXPORTED_FUNCTION : LOCAL_FUNCTION;
   }
 

File: src/com/goide/highlighting/GoSyntaxHighlightingColors.java
Patch:
@@ -41,6 +41,7 @@ public class GoSyntaxHighlightingColors {
   public static final TextAttributesKey TYPE_SPECIFICATION = createTextAttributesKey("GO_TYPE_SPECIFICATION", DefaultLanguageHighlighterColors.CLASS_NAME);
   public static final TextAttributesKey TYPE_REFERENCE = createTextAttributesKey("GO_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
   public static final TextAttributesKey BUILTIN_TYPE_REFERENCE = createTextAttributesKey("GO_BUILTIN_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
+  public static final TextAttributesKey BUILTIN_FUNCTION = createTextAttributesKey("GO_BUILTIN_FUNCTION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
   public static final TextAttributesKey EXPORTED_FUNCTION = createTextAttributesKey("GO_EXPORTED_FUNCTION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
   public static final TextAttributesKey LOCAL_FUNCTION = createTextAttributesKey("GO_LOCAL_FUNCTION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
   public static final TextAttributesKey PACKAGE_EXPORTED_INTERFACE = createTextAttributesKey("GO_PACKAGE_EXPORTED_INTERFACE", DefaultLanguageHighlighterColors.INTERFACE_NAME);

File: src/com/goide/dlv/DlvDebugProcess.java
Patch:
@@ -231,6 +231,7 @@ public void runToPosition(@NotNull XSourcePosition position) {
 
   @Override
   public void stop() {
+    send(new DlvRequest.Detach(true));
     getSession().stop();
   }
 

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -81,4 +81,5 @@ protected void setUp() throws Exception {
   public void testElementRecover()                  { doTest(false); }
   public void testChanRecover()                     { doTest(false); }
   public void testMapLiteralRecover()               { doTest(false); }
+  public void testPlusPlusRecover()                 { doTest(false); }
 }

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -3367,7 +3367,7 @@ public static boolean Statement(PsiBuilder b, int l) {
   }
 
   /* ********************************************************** */
-  // !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var)
+  // !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var)
   static boolean StatementRecover(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "StatementRecover")) return false;
     boolean r;
@@ -3377,7 +3377,7 @@ static boolean StatementRecover(PsiBuilder b, int l) {
     return r;
   }
 
-  // '!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var
+  // '!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var
   private static boolean StatementRecover_0(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "StatementRecover_0")) return false;
     boolean r;
@@ -3415,7 +3415,6 @@ private static boolean StatementRecover_0(PsiBuilder b, int l) {
     if (!r) r = consumeToken(b, GREATER_OR_EQUAL);
     if (!r) r = consumeToken(b, SHIFT_RIGHT);
     if (!r) r = consumeToken(b, SHIFT_RIGHT_ASSIGN);
-    if (!r) r = consumeToken(b, LBRACK);
     if (!r) r = consumeToken(b, BIT_XOR);
     if (!r) r = consumeToken(b, BIT_XOR_ASSIGN);
     if (!r) r = consumeToken(b, TYPE_);

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -80,4 +80,5 @@ protected void setUp() throws Exception {
   public void testExpressionPerformance()           { doTest(false); }
   public void testElementRecover()                  { doTest(false); }
   public void testChanRecover()                     { doTest(false); }
+  public void testMapLiteralRecover()               { doTest(false); }
 }

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -3367,7 +3367,7 @@ public static boolean Statement(PsiBuilder b, int l) {
   }
 
   /* ********************************************************** */
-  // !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var)
+  // !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var)
   static boolean StatementRecover(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "StatementRecover")) return false;
     boolean r;
@@ -3377,7 +3377,7 @@ static boolean StatementRecover(PsiBuilder b, int l) {
     return r;
   }
 
-  // '!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var
+  // '!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | '*' | '*=' | '+' | '++' | '+=' | '-' | '--' | '-=' | '...' | '/' | '/=' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | char | const | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var
   private static boolean StatementRecover_0(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "StatementRecover_0")) return false;
     boolean r;
@@ -3426,7 +3426,6 @@ private static boolean StatementRecover_0(PsiBuilder b, int l) {
     if (!r) r = consumeToken(b, RBRACE);
     if (!r) r = consumeToken(b, BREAK);
     if (!r) r = consumeToken(b, CASE);
-    if (!r) r = consumeToken(b, CHAN);
     if (!r) r = consumeToken(b, CHAR);
     if (!r) r = consumeToken(b, CONST);
     if (!r) r = consumeToken(b, CONTINUE);

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -79,4 +79,5 @@ protected void setUp() throws Exception {
   public void testMethodWithoutReceiverIdentifier() { doTest(false); }
   public void testExpressionPerformance()           { doTest(false); }
   public void testElementRecover()                  { doTest(false); }
+  public void testChanRecover()                     { doTest(false); }
 }

File: src/com/goide/inspections/GoPlaceholderCountInspection.java
Patch:
@@ -35,7 +35,7 @@
 
 public class GoPlaceholderCountInspection extends GoInspectionBase {
   private static final Pattern PLACEHOLDER_PATTERN =
-    Pattern.compile("(%#?((\\[\\d+\\]|\\*?)?\\.?)*(\\d*\\.?\\d*)*\\s?(v|T|t|b|c|d|o|q|x|X|U|b|e|E|f|F|g|G|s|q|x|X|p))");
+    Pattern.compile("((?<!(?:[^%]%|%%%))%(?:#|\\+|-)?((\\[\\d+\\]|\\*?)?\\.?)*(\\d*\\.?\\d*)*\\s?(v|T|t|b|c|d|o|q|x|X|U|b|e|E|f|F|g|G|s|q|x|X|p))");
 
   private static final Pattern INDEXED_PLACEHOLDER_PATTERN = Pattern.compile("(?:\\[(\\d+)\\])");
 

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -113,7 +113,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
         }
 
         executor.withParameters(importPath);
-        addFilterParameter(executor, buildFilePattern((GoFile)file));
+        addFilterParameter(executor, buildFilterPatternForFile((GoFile)file));
         break;
     }
 
@@ -125,7 +125,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
   }
 
   @NotNull
-  protected String buildFilePattern(GoFile file) {
+  protected String buildFilterPatternForFile(GoFile file) {
     Collection<String> testNames = ContainerUtil.newLinkedHashSet();
     for (GoFunctionDeclaration function : file.getFunctions()) {
       ContainerUtil.addIfNotNull(testNames, GoTestFinder.isTestOrExampleFunction(function) ? function.getName() : null);

File: src/com/goide/runconfig/testing/frameworks/gocheck/GocheckRunningState.java
Patch:
@@ -44,7 +44,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
 
   @NotNull
   @Override
-  protected String buildFilePattern(GoFile file) {
+  protected String buildFilterPatternForFile(GoFile file) {
     Collection<String> testNames = ContainerUtil.newLinkedHashSet();
     for (GoMethodDeclaration method : file.getMethods()) {
       ContainerUtil.addIfNotNull(testNames, GocheckFramework.getGocheckTestName(method));

File: gen/com/goide/psi/GoReceiver.java
Patch:
@@ -19,9 +19,6 @@ public interface GoReceiver extends GoNamedElement, StubBasedPsiElement<GoReceiv
   @NotNull
   PsiElement getLparen();
 
-  @Nullable
-  PsiElement getMul();
-
   @Nullable
   PsiElement getRparen();
 

File: src/com/goide/stubs/index/GoMethodIndex.java
Patch:
@@ -34,7 +34,7 @@ public class GoMethodIndex extends StringStubIndexExtension<GoMethodDeclaration>
 
   @Override
   public int getVersion() {
-    return GoFileElementType.VERSION + 1;
+    return GoFileElementType.VERSION + 2;
   }
 
   @NotNull

File: src/com/goide/tree/GoStructureViewFactory.java
Patch:
@@ -159,7 +159,7 @@ public Collection<StructureViewTreeElement> getChildrenBase() {
         for (GoMethodDeclaration o : ((GoFile)element).getMethods()) {
           GoReceiver receiver = o.getReceiver();
           GoType type = receiver.getType();
-          GoTypeReferenceExpression expression = type != null ? type.getTypeReferenceExpression() : null;
+          GoTypeReferenceExpression expression = GoPsiImplUtil.getTypeReference(type);
           PsiReference reference = expression != null ? expression.getReference() : null;
           PsiElement resolve = reference != null ? reference.resolve() : null;
           if (resolve == null) {

File: src/com/goide/inspections/GoMethodOnNonLocalTypeInspection.java
Patch:
@@ -39,7 +39,7 @@ public void visitMethodDeclaration(@NotNull final GoMethodDeclaration method) {
         if (methodType == null ||
             methodType.getTypeReferenceExpression() == null) return;
 
-        methodType = GoPsiImplUtil.findBaseTypeFromRef(methodType.getTypeReferenceExpression());
+        methodType = GoPsiImplUtil.findTypeFromTypeRef(methodType.getTypeReferenceExpression());
         if (methodType == null) return;
 
         String typeImportPath = ((GoFile)methodType.getContainingFile()).getImportPath();

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -486,7 +486,7 @@ public static GoType typeOrParameterType(@NotNull final GoTypeOwner resolve, @Nu
   }
 
   @Nullable
-  private static GoType findTypeFromTypeRef(@Nullable GoTypeReferenceExpression expression) {
+  public static GoType findTypeFromTypeRef(@Nullable GoTypeReferenceExpression expression) {
     PsiReference reference = expression != null ? expression.getReference() : null;
     PsiElement resolve = reference != null ? reference.resolve() : null;
     if (resolve instanceof GoTypeSpec) return ((GoTypeSpec)resolve).getSpecType();

File: src/com/goide/psi/impl/imports/GoReferenceImporter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -53,7 +53,7 @@ public boolean autoImportReferenceAtCursor(@NotNull Editor editor, @NotNull PsiF
           if (reference instanceof GoReference) {
             GoImportPackageQuickFix fix = new GoImportPackageQuickFix(reference);
             if (fix.isAvailable(file.getProject(), editor, file)) {
-              fix.applyFix();
+              fix.invoke(file.getProject(), editor, file);
               return true;
             }
           }
@@ -75,7 +75,7 @@ public boolean autoImportReferenceAt(@NotNull Editor editor, @NotNull PsiFile fi
       GoImportPackageQuickFix fix = new GoImportPackageQuickFix(reference);
       Project project = file.getProject();
       if (fix.isAvailable(project, editor, file)) {
-        fix.applyFix();
+        fix.invoke(file.getProject(), editor, file);
         return true;
       }
     }

File: src/com/goide/dlv/DlvDebugProcess.java
Patch:
@@ -221,7 +221,7 @@ protected void continueVm(@NotNull StepAction stepAction) {
 
   @NotNull
   @Override
-  public List<Location> getLocationsForBreakpoint(@NotNull XLineBreakpoint<?> breakpoint, boolean b) {
+  public List<Location> getLocationsForBreakpoint(@NotNull XLineBreakpoint<?> breakpoint) {
     return Collections.emptyList();
   }
 

File: src/com/goide/inspections/GoCgoInTestInspection.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.goide.psi.GoFile;
 import com.goide.psi.GoImportSpec;
+import com.goide.quickfix.GoDeleteQuickFix;
 import com.goide.runconfig.testing.GoTestFinder;
 import com.intellij.codeInspection.ProblemsHolder;
 import org.jetbrains.annotations.NotNull;

File: src/com/goide/inspections/GoDeferInLoopInspection.java
Patch:
@@ -26,7 +26,7 @@
 import com.intellij.psi.util.PsiTreeUtil;
 import org.jetbrains.annotations.NotNull;
 
-public class GoDeferInLoop extends GoInspectionBase {
+public class GoDeferInLoopInspection extends GoInspectionBase {
   @NotNull
   @Override
   protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {

File: src/com/goide/inspections/GoFunctionVariadicParameterInspection.java
Patch:
@@ -17,6 +17,7 @@
 package com.goide.inspections;
 
 import com.goide.psi.*;
+import com.goide.quickfix.GoDeleteQuickFix;
 import com.intellij.codeInspection.LocalInspectionToolSession;
 import com.intellij.codeInspection.ProblemHighlightType;
 import com.intellij.codeInspection.ProblemsHolder;

File: src/com/goide/inspections/GoMultiplePackagesInspection.java
Patch:
@@ -19,6 +19,7 @@
 import com.goide.GoConstants;
 import com.goide.psi.GoFile;
 import com.goide.psi.GoPackageClause;
+import com.goide.quickfix.GoMultiplePackagesQuickFix;
 import com.goide.util.GoUtil;
 import com.intellij.codeInspection.LocalQuickFix;
 import com.intellij.codeInspection.ProblemsHolder;

File: src/com/goide/inspections/GoRedeclareImportAsFunctionInspection.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.goide.psi.GoFunctionDeclaration;
 import com.goide.psi.GoVisitor;
+import com.goide.quickfix.GoRenameQuickFix;
 import com.intellij.codeInspection.LocalInspectionToolSession;
 import com.intellij.codeInspection.ProblemsHolder;
 import com.intellij.openapi.util.text.StringUtil;

File: src/com/goide/inspections/GoReservedWordUsedAsNameInspection.java
Patch:
@@ -17,6 +17,7 @@
 package com.goide.inspections;
 
 import com.goide.psi.*;
+import com.goide.quickfix.GoRenameQuickFix;
 import com.goide.sdk.GoSdkUtil;
 import com.intellij.codeInspection.LocalInspectionToolSession;
 import com.intellij.codeInspection.ProblemHighlightType;

File: src/com/goide/inspections/unresolved/GoUnusedFunctionInspection.java
Patch:
@@ -17,9 +17,9 @@
 package com.goide.inspections.unresolved;
 
 import com.goide.GoConstants;
-import com.goide.inspections.GoDeleteQuickFix;
+import com.goide.quickfix.GoDeleteQuickFix;
 import com.goide.inspections.GoInspectionBase;
-import com.goide.inspections.GoRenameToBlankQuickFix;
+import com.goide.quickfix.GoRenameToBlankQuickFix;
 import com.goide.psi.GoFile;
 import com.goide.psi.GoFunctionDeclaration;
 import com.goide.psi.GoVisitor;

File: src/com/goide/inspections/unresolved/GoUnusedVariableInspection.java
Patch:
@@ -17,7 +17,7 @@
 package com.goide.inspections.unresolved;
 
 import com.goide.inspections.GoInspectionBase;
-import com.goide.inspections.GoRenameToBlankQuickFix;
+import com.goide.quickfix.GoRenameToBlankQuickFix;
 import com.goide.psi.*;
 import com.goide.psi.impl.GoVarProcessor;
 import com.goide.quickfix.GoDeleteVarDefinitionQuickFix;

File: src/com/goide/quickfix/GoDeleteQuickFix.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.inspections;
+package com.goide.quickfix;
 
 import com.intellij.codeInspection.LocalQuickFixBase;
 import com.intellij.codeInspection.ProblemDescriptor;

File: src/com/goide/quickfix/GoRenameQuickFix.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.inspections;
+package com.goide.quickfix;
 
 import com.goide.psi.GoNamedElement;
 import com.intellij.codeInsight.FileModificationService;
@@ -38,7 +38,7 @@
 public class GoRenameQuickFix extends LocalQuickFixOnPsiElement {
   private final String myText;
 
-  protected GoRenameQuickFix(@NotNull GoNamedElement element) {
+  public GoRenameQuickFix(@NotNull GoNamedElement element) {
     super(element);
     myText = "Rename " + ElementDescriptionUtil.getElementDescription(element, UsageViewTypeLocation.INSTANCE);
   }

File: src/com/goide/quickfix/GoRenameToBlankQuickFix.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.inspections;
+package com.goide.quickfix;
 
 import com.goide.psi.GoNamedElement;
 import com.intellij.codeInspection.LocalQuickFixOnPsiElement;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -61,7 +61,7 @@ public void setUp() throws Exception {
       GoRedeclareImportAsFunctionInspection.class,
       GoStructTagInspection.class,
       GoUsedAsValueInCondition.class,
-      GoDeferInLoop.class,
+      GoDeferInLoopInspection.class,
       GoCommentStartInspection.class,
       GoPlaceholderCountInspection.class,
       GoEmbeddedInterfacePointerInspection.class,

File: tests/com/goide/quickfix/GoMultiplePackagesQuickFixTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.goide.quickfix;
 
 import com.goide.inspections.GoMultiplePackagesInspection;
-import com.goide.inspections.GoMultiplePackagesQuickFix;
 import org.jetbrains.annotations.NotNull;
 
 public class GoMultiplePackagesQuickFixTest extends GoQuickFixTestBase {

File: tests/com/goide/quickfix/GoRenameFunctionQuickFixTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.goide.quickfix;
 
-import com.goide.inspections.GoRenameToBlankQuickFix;
 import com.goide.inspections.unresolved.GoUnusedFunctionInspection;
 import org.jetbrains.annotations.NotNull;
 

File: tests/com/goide/quickfix/GoRenameVarQuickFixTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.goide.quickfix;
 
-import com.goide.inspections.GoRenameToBlankQuickFix;
 import com.goide.inspections.unresolved.GoUnusedVariableInspection;
 import org.jetbrains.annotations.NotNull;
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -705,7 +705,8 @@ public Result<List<GoMethodDeclaration>> compute() {
   }
 
   public static boolean allowed(@NotNull PsiFile file, @Nullable PsiFile contextFile) {
-    if (contextFile == null || !(contextFile instanceof GoFile) || !(file instanceof GoFile) || !GoUtil.allowed(file)) return true;
+    if (contextFile == null || !(contextFile instanceof GoFile)) return true;
+    if (!(file instanceof GoFile) || !GoUtil.allowed(file)) return false;
     // it's not a test or context file is also test from the same package
     return !GoTestFinder.isTestFile(file) || 
            GoTestFinder.isTestFile(contextFile) && Comparing.equal(file.getParent(), contextFile.getParent());

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -419,8 +419,9 @@ private static boolean processFileEntities(@NotNull GoFile file,
                                              boolean localProcessing) {
     if (!processNamedElements(processor, state, file.getConstants(), new Condition<GoNamedElement>() {
         @Override
-        public boolean value(GoNamedElement o) {
+        public boolean value(@NotNull GoNamedElement o) {
           return !Comparing.equal(GoConstants.IOTA, o.getName()) ||
+                 !builtin(o) ||
                  PsiTreeUtil.getParentOfType(getContext(state), GoConstSpec.class) != null;
         }
       }, localProcessing, false)) return false;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -140,6 +140,7 @@ protected boolean isWriteActionRequired() {
   public void testInit()                      { doTest(); }
   public void testChan()                      { doTest(); }
   public void testIota()                      { doTest(); }
+  public void testIota2()                     { doTest(); }
 
   public void testCheckSamePackage_test()     { 
     myFixture.configureByText("a_test.go", "package check; func TestStringer(t *testing.T) {}"); 

File: src/com/goide/highlighting/GoAnnotator.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Florin Patan
+ * Copyright 2013-2016 Sergey Ignatov, Alexander Zolotov, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -214,8 +214,7 @@ else if (definition instanceof GoConstDefinition) {
       value = ((GoConstDefinition)definition).getValue();
     }
 
-    if (value != null &&
-        value.equals(PsiTreeUtil.getTopmostParentOfType(o, GoExpression.class))) {
+    if (value != null && value.equals(GoPsiImplUtil.getNonStrictTopmostParentOfType(o, GoExpression.class))) {
       holder.createErrorAnnotation(o, "Cyclic definition detected");
     }
   }

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -195,6 +195,9 @@ public static int compareVersions(@NotNull String lhs, @NotNull String rhs) {
 
   @Nullable
   public static VirtualFile findFileByRelativeToLibrariesPath(@NotNull String path, @NotNull Project project, @Nullable Module module) {
+    if (path.isEmpty()) {
+      return null;
+    }
     for (VirtualFile root : getSourcesPathsToLookup(project, module)) {
       VirtualFile file = root.findFileByRelativePath(path);
       if (file != null) {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -439,6 +439,9 @@ else if (o instanceof GoLiteral) {
       if (l.getFloati() != null) return getBuiltinType(o, "complex64");
       if (l.getDecimali() != null) return getBuiltinType(o, "complex128");
     }
+    else if (o instanceof GoConditionalExpr) {
+      return getBuiltinType(o, "bool");
+    }
     return null;
   }
 

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -139,6 +139,7 @@ protected boolean isWriteActionRequired() {
   public void testTypeConversion()            { doTest(); }
   public void testInit()                      { doTest(); }
   public void testChan()                      { doTest(); }
+  public void testIota()                      { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: utils/src/com/goide/GoConstants.java
Patch:
@@ -43,6 +43,7 @@ public class GoConstants {
   public static final String TEST_MAIN = "TestMain";
   public static final String MAIN = "main";
   public static final String INIT = "init";
+  public static final String IOTA = "iota";
   public static final String DOCUMENTATION = "documentation";
   public static final String C_PATH = "C";
   public static final String TESTING_PATH = "testing";

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -138,6 +138,7 @@ protected boolean isWriteActionRequired() {
   public void testPlaceholderCount()          { doTest(); }
   public void testTypeConversion()            { doTest(); }
   public void testInit()                      { doTest(); }
+  public void testChan()                      { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -25,7 +25,6 @@
 import com.intellij.openapi.util.io.FileUtil;
 import com.intellij.openapi.vfs.VfsUtil;
 import com.intellij.openapi.vfs.VirtualFile;
-import com.intellij.openapi.vfs.VirtualFileManager;
 import com.intellij.testFramework.LightProjectDescriptor;
 import org.jetbrains.annotations.NotNull;
 
@@ -138,6 +137,7 @@ protected boolean isWriteActionRequired() {
   public void testEmbeddedInterfacePointer()  { doTest(); }
   public void testPlaceholderCount()          { doTest(); }
   public void testTypeConversion()            { doTest(); }
+  public void testInit()                      { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: src/com/goide/inspections/GoPlaceholderCountInspection.java
Patch:
@@ -35,7 +35,7 @@
 
 public class GoPlaceholderCountInspection extends GoInspectionBase {
   private static final Pattern PLACEHOLDER_PATTERN =
-    Pattern.compile("(%#?((\\[\\d+\\]|\\*?)?\\.?)*(\\d*\\.\\d*)*\\s?(v|T|t|b|c|d|o|q|x|X|U|b|e|E|f|F|g|G|s|q|x|X|p))");
+    Pattern.compile("(%#?((\\[\\d+\\]|\\*?)?\\.?)*(\\d*\\.?\\d*)*\\s?(v|T|t|b|c|d|o|q|x|X|U|b|e|E|f|F|g|G|s|q|x|X|p))");
 
   private static final Pattern INDEXED_PLACEHOLDER_PATTERN = Pattern.compile("(?:\\[(\\d+)\\])");
 

File: src/com/goide/inspections/GoPlaceholderCountInspection.java
Patch:
@@ -35,7 +35,7 @@
 
 public class GoPlaceholderCountInspection extends GoInspectionBase {
   private static final Pattern PLACEHOLDER_PATTERN =
-    Pattern.compile("(%#?((\\[\\d+\\]|\\*?)?\\.?)*(\\d*\\.\\d*)*\\s?(v|T|t|b|c|d|o|q|x|X|U|b|e|E|f|F|g|G|s|q|x|X|p))");
+    Pattern.compile("(%#?((\\[\\d+\\]|\\*?)?\\.?)*(\\d*\\.?\\d*)*\\s?(v|T|t|b|c|d|o|q|x|X|U|b|e|E|f|F|g|G|s|q|x|X|p))");
 
   private static final Pattern INDEXED_PLACEHOLDER_PATTERN = Pattern.compile("(?:\\[(\\d+)\\])");
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -376,7 +376,7 @@ else if (o instanceof GoCallExpr) {
           }
         }
         else if (resolve == e) { // C.call()
-          return new MyCType(e);
+          return new GoCType(e);
         }
       }
       GoType type = ((GoCallExpr)o).getExpression().getGoType(context);
@@ -484,7 +484,7 @@ private static GoType findTypeFromTypeRef(@Nullable GoTypeReferenceExpression ex
     PsiElement resolve = reference != null ? reference.resolve() : null;
     if (resolve instanceof GoTypeSpec) return ((GoTypeSpec)resolve).getSpecType();
     if (resolve == expression && expression != null) {  // hacky C resolve
-      return new MyCType(expression);
+      return new GoCType(expression);
     }
     return null;
   }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -38,7 +38,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.goide.psi.impl.GoLightType.*;
 import static com.goide.psi.impl.GoPsiImplUtil.*;
 
 public class GoReference extends PsiPolyVariantReferenceBase<GoReferenceExpressionBase> {
@@ -133,7 +132,7 @@ private boolean processQualifierExpression(@NotNull GoFile file,
     if (target instanceof PsiDirectory && !processDirectory((PsiDirectory)target, file, null, processor, state, false)) return false;
     if (target instanceof GoTypeOwner) {
       GoType type = typeOrParameterType((GoTypeOwner)target, createContext());
-      if (type instanceof MyCType) return processor.execute(myElement, state);
+      if (type instanceof GoCType) return processor.execute(myElement, state);
       if (type != null) {
         if (!processGoType(type, processor, state)) return false;
         GoTypeReferenceExpression ref = getTypeRefExpression(type);

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -137,6 +137,7 @@ protected boolean isWriteActionRequired() {
   public void testCyclicDefinition()          { doTest(); }
   public void testEmbeddedInterfacePointer()  { doTest(); }
   public void testPlaceholderCount()          { doTest(); }
+  public void testDeclaredButNotUsed()        { doTest(); }
   public void testTypeConversion()            { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
@@ -358,7 +359,7 @@ public void testCGOImportInNonTestFile() {
     myFixture.configureByText("a.go", "package a; import \"C\"");
     myFixture.checkHighlighting();
   }
-  
+
   @SuppressWarnings("ConstantConditions")
   public void testDoNotHighlightCodeFromIgnoredImportPaths() throws Throwable {
     final VirtualFile tmp = WriteCommandAction.runWriteCommandAction(myFixture.getProject(), new ThrowableComputable<VirtualFile, Throwable>() {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -376,7 +376,7 @@ else if (o instanceof GoCallExpr) {
           }
         }
         else if (resolve == e) { // C.call()
-          return new MyCType(e);
+          return new GoCType(e);
         }
       }
       GoType type = ((GoCallExpr)o).getExpression().getGoType(context);
@@ -484,7 +484,7 @@ private static GoType findTypeFromTypeRef(@Nullable GoTypeReferenceExpression ex
     PsiElement resolve = reference != null ? reference.resolve() : null;
     if (resolve instanceof GoTypeSpec) return ((GoTypeSpec)resolve).getSpecType();
     if (resolve == expression && expression != null) {  // hacky C resolve
-      return new MyCType(expression);
+      return new GoCType(expression);
     }
     return null;
   }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -38,7 +38,6 @@
 import java.util.List;
 import java.util.Map;
 
-import static com.goide.psi.impl.GoLightType.*;
 import static com.goide.psi.impl.GoPsiImplUtil.*;
 
 public class GoReference extends PsiPolyVariantReferenceBase<GoReferenceExpressionBase> {
@@ -133,7 +132,7 @@ private boolean processQualifierExpression(@NotNull GoFile file,
     if (target instanceof PsiDirectory && !processDirectory((PsiDirectory)target, file, null, processor, state, false)) return false;
     if (target instanceof GoTypeOwner) {
       GoType type = typeOrParameterType((GoTypeOwner)target, createContext());
-      if (type instanceof MyCType) return processor.execute(myElement, state);
+      if (type instanceof GoCType) return processor.execute(myElement, state);
       if (type != null) {
         if (!processGoType(type, processor, state)) return false;
         GoTypeReferenceExpression ref = getTypeRefExpression(type);

File: src/com/goide/psi/impl/GoCompositeElementImpl.java
Patch:
@@ -58,7 +58,8 @@ public static boolean processDeclarationsDefault(@NotNull GoCompositeElement o,
           o instanceof GoIfStatement ||
           o instanceof GoForStatement ||
           o instanceof GoCommClause ||
-          o instanceof GoBlock
+          o instanceof GoBlock ||
+          o instanceof GoCaseClause
         ) 
         && processor instanceof GoScopeProcessorBase) {
       if (!PsiTreeUtil.isAncestor(o, ((GoScopeProcessorBase)processor).myOrigin, false)) return true;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -137,6 +137,7 @@ protected boolean isWriteActionRequired() {
   public void testCyclicDefinition()          { doTest(); }
   public void testEmbeddedInterfacePointer()  { doTest(); }
   public void testPlaceholderCount()          { doTest(); }
+  public void testTypeConversion()            { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: src/com/goide/psi/impl/GoCompositeElementImpl.java
Patch:
@@ -58,7 +58,8 @@ public static boolean processDeclarationsDefault(@NotNull GoCompositeElement o,
           o instanceof GoIfStatement ||
           o instanceof GoForStatement ||
           o instanceof GoCommClause ||
-          o instanceof GoBlock
+          o instanceof GoBlock ||
+          o instanceof GoCaseClause
         ) 
         && processor instanceof GoScopeProcessorBase) {
       if (!PsiTreeUtil.isAncestor(o, ((GoScopeProcessorBase)processor).myOrigin, false)) return true;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -132,6 +132,7 @@ protected boolean isWriteActionRequired() {
   public void testCyclicDefinition()          { doTest(); }
   public void testEmbeddedInterfacePointer()  { doTest(); }
   public void testPlaceholderCount()          { doTest(); }
+  public void testTypeConversion()            { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: src/com/goide/inspections/GoMultiplePackagesQuickFix.java
Patch:
@@ -45,10 +45,10 @@
 import java.util.Collection;
 
 public class GoMultiplePackagesQuickFix extends LocalQuickFixAndIntentionActionOnPsiElement {
+  private static String myTestingPackageName;
   private Collection<String> myPackages;
   private String myPackageName;
   private boolean myIsOneTheFly;
-  private static String myTestingPackageName;
 
   protected GoMultiplePackagesQuickFix(@NotNull PsiElement element, @NotNull String packageName, Collection<String> packages, boolean isOnTheFly) {
     super(element);
@@ -133,6 +133,6 @@ public String getText() {
   @NotNull
   @Override
   public String getFamilyName() {
-    return GoConstants.GO;
+    return "Rename packages";
   }
 }

File: src/com/goide/inspections/GoRenameQuickFix.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.goide.inspections;
 
-import com.goide.GoConstants;
 import com.goide.psi.GoNamedElement;
 import com.intellij.codeInsight.FileModificationService;
 import com.intellij.codeInspection.LocalQuickFixOnPsiElement;
@@ -80,7 +79,7 @@ public void consume(DataContext dataContext) {
 
   @NotNull
   public String getFamilyName() {
-    return GoConstants.GO;
+    return getName();
   }
 
   @NotNull

File: src/com/goide/inspections/GoRenameToBlankQuickFix.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.goide.inspections;
 
-import com.goide.GoConstants;
 import com.goide.psi.GoNamedElement;
 import com.intellij.codeInspection.LocalQuickFixOnPsiElement;
 import com.intellij.openapi.project.Project;
@@ -47,6 +46,6 @@ public void invoke(@NotNull Project project, @NotNull PsiFile file, @NotNull Psi
   @NotNull
   @Override
   public String getFamilyName() {
-    return GoConstants.GO;
+    return getName();
   }
 }

File: src/com/goide/quickfix/GoDeleteConstDefinitionQuickFix.java
Patch:
@@ -27,7 +27,7 @@
 
 public class GoDeleteConstDefinitionQuickFix extends LocalQuickFixBase {
   public GoDeleteConstDefinitionQuickFix(@Nullable String constName) {
-    super("Delete const " + (constName != null ? "'" + constName + "'" : ""));
+    super("Delete const " + (constName != null ? "'" + constName + "'" : ""), "Delete constant");
   }
 
   @Override

File: src/com/goide/quickfix/GoDeleteVarDefinitionQuickFix.java
Patch:
@@ -27,7 +27,7 @@
 
 public class GoDeleteVarDefinitionQuickFix extends LocalQuickFixBase {
   public GoDeleteVarDefinitionQuickFix(@Nullable String variableName) {
-    super("Delete variable " + (variableName != null ? "'" + variableName + "'" : ""));
+    super("Delete variable " + (variableName != null ? "'" + variableName + "'" : ""), "Delete variable");
   }
 
   @Override

File: src/com/goide/highlighting/GoDefaultHighlightingSettingProvider.java
Patch:
@@ -39,7 +39,7 @@ public FileHighlightingSetting getDefaultSetting(@NotNull Project project, @NotN
     if (FileIndexFacade.getInstance(project).isInContent(file)) return null;
 
     PsiFile psiFile = PsiManager.getInstance(project).findFile(file);
-    if (psiFile instanceof GoFile && !GoUtil.importPathToIgnore(((GoFile)psiFile).getImportPath())) {
+    if (psiFile instanceof GoFile && GoUtil.importPathToIgnore(((GoFile)psiFile).getImportPath())) {
       return FileHighlightingSetting.SKIP_HIGHLIGHTING;
     }
     return null;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -59,7 +59,8 @@ public void setUp() throws Exception {
       GoStructTagInspection.class,
       GoUsedAsValueInCondition.class,
       GoDeferInLoop.class,
-      GoCommentStartInspection.class
+      GoCommentStartInspection.class,
+      GoEmbeddedInterfacePointerInspection.class
     );
   }
 
@@ -127,6 +128,7 @@ protected boolean isWriteActionRequired() {
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
   public void testCyclicDefinition()          { doTest(); }
+  public void testEmbeddedInterfacePointer()  { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -59,7 +59,8 @@ public void setUp() throws Exception {
       GoStructTagInspection.class,
       GoUsedAsValueInCondition.class,
       GoDeferInLoop.class,
-      GoCommentStartInspection.class
+      GoCommentStartInspection.class,
+      GoEmbeddedInterfacePointerInspection.class
     );
   }
 
@@ -127,6 +128,7 @@ protected boolean isWriteActionRequired() {
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
   public void testCyclicDefinition()          { doTest(); }
+  public void testEmbeddedInterfacePointer()  { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -126,6 +126,7 @@ protected boolean isWriteActionRequired() {
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
+  public void testCyclicDefinition()          { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -126,6 +126,7 @@ protected boolean isWriteActionRequired() {
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
+  public void testCyclicDefinition()          { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -126,7 +126,6 @@ protected boolean isWriteActionRequired() {
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
-  public void testDeclaredButNotUsed()        { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -126,7 +126,6 @@ protected boolean isWriteActionRequired() {
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
-  public void testDeclaredButNotUsed()        { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -126,6 +126,7 @@ protected boolean isWriteActionRequired() {
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
+  public void testDeclaredButNotUsed()        { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -126,6 +126,7 @@ protected boolean isWriteActionRequired() {
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
   public void testGithubIssue2099()           { doTest(); }
+  public void testDeclaredButNotUsed()        { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -534,7 +534,8 @@ public static GoType getGoTypeInner(@NotNull GoVarDefinition o, @Nullable Resolv
 
   @Nullable
   private static GoType findTypeInVarSpec(@NotNull GoVarDefinition o, @Nullable ResolveState context) {
-    GoVarSpec parent = (GoVarSpec)o.getParent();
+    GoVarSpec parent = (GoVarSpec)PsiTreeUtil.getStubOrPsiParent(o);
+    if (parent == null) return null;
     GoType commonType = parent.getType();
     if (commonType != null) return commonType;
     List<GoVarDefinition> varList = parent.getVarDefinitionList();

File: src/com/goide/GoFileElementType.java
Patch:
@@ -31,7 +31,7 @@
 
 public class GoFileElementType extends IStubFileElementType<GoFileStub> {
   public static final IStubFileElementType INSTANCE = new GoFileElementType();
-  public static final int VERSION = 13;
+  public static final int VERSION = 14;
 
   private GoFileElementType() {
     super("GO_FILE", GoLanguage.INSTANCE);

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -125,6 +125,7 @@ protected boolean isWriteActionRequired() {
   public void testEqualinif()                 { doTest(); }
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
+  public void testGithubIssue2099()           { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -125,6 +125,7 @@ protected boolean isWriteActionRequired() {
   public void testEqualinif()                 { doTest(); }
   public void testSpecTypes()                 { doTest(); }
   public void testFunctionTypes()             { doTest(); }
+  public void testGithubIssue2099()           { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -343,7 +343,7 @@ protected boolean parse_root_(IElementType t, PsiBuilder b, int l) {
       SELECTOR_EXPR),
     create_token_set_(ARRAY_OR_SLICE_TYPE, CHANNEL_TYPE, FUNCTION_TYPE, INTERFACE_TYPE,
       MAP_TYPE, PAR_TYPE, POINTER_TYPE, RECEIVER_TYPE,
-      SPEC_TYPE, STRUCT_TYPE, TYPE, TYPE_LIST),
+      STRUCT_TYPE, TYPE, TYPE_LIST),
     create_token_set_(ASSIGNMENT_STATEMENT, BREAK_STATEMENT, CONTINUE_STATEMENT, DEFER_STATEMENT,
       ELSE_STATEMENT, EXPR_SWITCH_STATEMENT, FALLTHROUGH_STATEMENT, FOR_STATEMENT,
       GOTO_STATEMENT, GO_STATEMENT, IF_STATEMENT, LABELED_STATEMENT,

File: gen/com/goide/psi/GoSpecType.java
Patch:
@@ -4,8 +4,10 @@
 import java.util.List;
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
+import com.intellij.psi.StubBasedPsiElement;
+import com.goide.stubs.GoTypeStub;
 
-public interface GoSpecType extends GoType {
+public interface GoSpecType extends GoType, StubBasedPsiElement<GoTypeStub> {
 
   @NotNull
   GoType getType();

File: gen/com/goide/psi/impl/GoSpecTypeImpl.java
Patch:
@@ -33,7 +33,7 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   @Override
   @NotNull
   public GoType getType() {
-    return findNotNullChildByClass(GoType.class);
+    return findNotNullChildByClass(GoType.class, com.goide.stubs.GoTypeStub.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoTypeSpecImpl.java
Patch:
@@ -35,7 +35,7 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   @Override
   @NotNull
   public GoSpecType getSpecType() {
-    return findNotNullChildByClass(GoSpecType.class);
+    return findNotNullChildByClass(GoSpecType.class, com.goide.stubs.GoTypeStub.class);
   }
 
   @Nullable

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -99,6 +99,7 @@ protected boolean isWriteActionRequired() {
   public void testCheck()                     { doTest(); }
   public void testCheck_test()                { doTest(); }
   public void testFuncCall()                  { doTest(); }
+  public void testBuiltinFuncCalls()          { doTest(); }
   public void testBackticks()                 { doTest(); }
   public void testConsts()                    { doTest(); }
   public void testFields()                    { doTest(); }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -123,6 +123,7 @@ protected boolean isWriteActionRequired() {
   public void testBreak()                     { doTest(); }
   public void testEqualinif()                 { doTest(); }
   public void testSpecTypes()                 { doTest(); }
+  public void testFunctionTypes()             { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: utils/src/com/goide/GoConstants.java
Patch:
@@ -52,6 +52,7 @@ public class GoConstants {
 
   @NonNls public static final String LIB_EXEC_DIRECTORY = "libexec";
   @NonNls public static final String GO_VERSION_FILE_PATH = "runtime/zversion.go";
+  @NonNls public static final String GO_VERSION_NEW_FILE_PATH = "runtime/internal/sys/zversion.go";
   public static final String BUILTIN_FILE_NAME = "builtin.go";
   public static final String BUILTIN_PACKAGE_NAME = "builtin";
   public static final String BUILTIN_FILE_PATH = BUILTIN_PACKAGE_NAME + "/" + BUILTIN_FILE_NAME;

File: src/com/goide/psi/impl/GoLightType.java
Patch:
@@ -48,7 +48,7 @@ public boolean shouldGoDeeper() {
 
   @Override
   public String toString() {
-    return null;
+    return getClass().getSimpleName() + "{" + myElement + "}";
   }
 
   @Override

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -786,7 +786,7 @@ public static GoType getGoTypeInner(@NotNull GoAnonymousFieldDefinition o, @Supp
   }
 
   @Nullable
-  public static GoType findBaseType(@Nullable GoType type) {
+  public static GoType findBaseSpecType(@Nullable GoType type) {
     while (type instanceof GoSpecType && ((GoSpecType)type).getType().getTypeReferenceExpression() != null) {
       GoType inner = findTypeFromTypeRef(((GoSpecType)type).getType().getTypeReferenceExpression());
       if (inner == null || type.isEquivalentTo(inner) || builtin(inner)) return type;
@@ -800,7 +800,7 @@ public static GoType findBaseType(@Nullable GoType type) {
    */  
   @Nullable
   public static GoType findBaseTypeFromRef(@Nullable GoTypeReferenceExpression expression) {
-    return findBaseType(findTypeFromTypeRef(expression));
+    return findBaseSpecType(findTypeFromTypeRef(expression));
   }
 
   @Nullable

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -195,7 +195,7 @@ private boolean processExistingType(@NotNull GoType type,
     if (canProcessMethods && parent != null && !processNamedElements(processor, state, parent.getMethods(), localResolve, true)) return false;
 
     if (type instanceof GoSpecType) {
-      GoType theLatestSpec = findBaseType(type);
+      GoType theLatestSpec = findBaseSpecType(type);
       type = theLatestSpec instanceof GoSpecType ? ((GoSpecType)theLatestSpec).getType() : theLatestSpec;
     }
     if (type instanceof GoStructType) {

File: tests/com/goide/editor/GoParameterInfoHandlerTest.java
Patch:
@@ -42,6 +42,7 @@ protected void setUp() throws Exception {
   public void testMethParamNone()             { doTest("<html>&lt;no parameters&gt;</html>"); }
   public void testFieldMethCall()             { doTest("<html><b>a int</b>, b int</html>"); }
   public void testFuncTypes()                 { doTest("<html><b>string</b></html>"); }
+  public void testFunctionTypeByRef()         { doTest("<html><b>intParam int</b></html>"); }
   public void testFuncParam()                 { doTest(1, "<html>num int, <b>text string</b></html>"); }
   public void testFuncParamMulti()            { doTest(4, "<html>a int, b int, c int, d string, <b>e string</b>, f string</html>"); }
   public void testFuncParamEllipsis()         { doTest(5, "<html>num int, text string, <b>more ...int</b></html>"); }

File: src/com/goide/actions/internal/GoShowTypeInternalAction.java
Patch:
@@ -22,6 +22,7 @@
 import com.goide.psi.GoType;
 import com.intellij.internal.SelectionBasedPsiElementInternalAction;
 import com.intellij.openapi.editor.Editor;
+import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.PsiFile;
 import com.intellij.psi.util.PsiTreeUtil;
@@ -40,7 +41,7 @@ public GoShowTypeInternalAction() {
   @Override
   protected String getInformationHint(@NotNull GoExpression element) {
     GoType type = element.getGoType(null);
-    return type != null ? type.getText() : "<null>";
+    return StringUtil.escapeXml(type != null ? type.getText() : "<null>");
   }
 
   @NotNull

File: src/com/goide/psi/impl/GoCompositeElementImpl.java
Patch:
@@ -49,6 +49,8 @@ public static boolean processDeclarationsDefault(@NotNull GoCompositeElement o,
                                                    @NotNull ResolveState state,
                                                    @Nullable PsiElement lastParent,
                                                    @NotNull PsiElement place) {
+    if (o instanceof GoLeftHandExprList || o instanceof GoExpression) return true;
+
     if (!o.shouldGoDeeper()) return processor.execute(o, state);
     if (!processor.execute(o, state)) return false;
     if ((

File: src/com/goide/psi/impl/GoScopeProcessorBase.java
Patch:
@@ -29,8 +29,7 @@
 import java.util.List;
 
 public abstract class GoScopeProcessorBase extends GoScopeProcessor {
-  @NotNull protected final OrderedSet<GoNamedElement> myResult = new OrderedSet<GoNamedElement>();
-
+  @NotNull private final OrderedSet<GoNamedElement> myResult = new OrderedSet<GoNamedElement>();
   @NotNull protected final PsiElement myOrigin;
   @NotNull private final PsiElement myRequestedNameElement;
   protected final boolean myIsCompletion;

File: tests/com/goide/psi/legacy/GoLegacyResolveVarsTest.java
Patch:
@@ -62,6 +62,7 @@ public class GoLegacyResolveVarsTest extends GoLegacyResolveTestBase {
   public void testVarVsInnerTypes()                                 { doFileTest(); }
   public void testVarTypeGuard()                                    { doFileTest(); }
   public void testResolveMethodReceiver()                           { doFileTest(); }
+  public void testDontProcessExpressions()                          { doFileTest(); }
 
   public void testFromDefaultImportedPackage()                      { doDirTest(); }
   public void testLocalPackageDefinitionsShouldBeResolvedFirst()    { doDirTest(); }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -122,7 +122,7 @@ protected boolean isWriteActionRequired() {
   public void testContinue()                  { doTest(); }
   public void testBreak()                     { doTest(); }
   public void testEqualinif()                 { doTest(); }
-  public void testSpecs()                     { doTest(); }
+  public void testSpecTypes()                 { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -122,6 +122,7 @@ protected boolean isWriteActionRequired() {
   public void testContinue()                  { doTest(); }
   public void testBreak()                     { doTest(); }
   public void testEqualinif()                 { doTest(); }
+  public void testSpecs()                     { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: tests/com/goide/psi/legacy/GoLegacyResolveTypesTest.java
Patch:
@@ -29,6 +29,7 @@ public class GoLegacyResolveTypesTest extends GoLegacyResolveTestBase {
   public void testResolveTypeInCast()                             { doFileTest(); } 
   public void testResolveArrayInRange()                           { doFileTest(); } 
   public void testMethodsOrder()                                  { doFileTest(); }
+  public void testFunctionTypeByRef()                             { doFileTest(); }
 
   public void testFromDefaultImportedPackage()                    { doDirTest(); } 
   public void testFromInjectedPackage()                           { doDirTest(); } 

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -38,6 +38,7 @@
 import java.util.List;
 import java.util.Map;
 
+import static com.goide.psi.impl.GoLightType.*;
 import static com.goide.psi.impl.GoPsiImplUtil.*;
 
 public class GoReference extends PsiPolyVariantReferenceBase<GoReferenceExpressionBase> {

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -131,6 +131,7 @@ private boolean processQualifierExpression(@NotNull GoFile file,
     if (target instanceof PsiDirectory && !processDirectory((PsiDirectory)target, file, null, processor, state, false)) return false;
     if (target instanceof GoTypeOwner) {
       GoType type = typeOrParameterType((GoTypeOwner)target, createContext());
+      if (type instanceof MyCType) return processor.execute(myElement, state);
       if (type != null) {
         if (!processGoType(type, processor, state)) return false;
         GoTypeReferenceExpression ref = getTypeRefExpression(type);

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -139,15 +139,15 @@ private static String getSignature(PsiElement element) {
     if (element instanceof GoConstDefinition) {
       String name = ((GoConstDefinition)element).getName();
       if (StringUtil.isNotEmpty(name)) {
-        String type = getTypePresentation(((GoConstDefinition)element).getGoTypeInner(null));
+        String type = getTypePresentation(((GoConstDefinition)element).getGoType(null));
         GoExpression value = ((GoConstDefinition)element).getValue();
         return "const " + name + (!type.isEmpty() ? " " + type : "") + (value != null ? " = " + value.getText() : "");
       }
     }
     if (element instanceof GoVarDefinition) {
       String name = ((GoVarDefinition)element).getName();
       if (StringUtil.isNotEmpty(name)) {
-        String type = getTypePresentation(((GoVarDefinition)element).getGoTypeInner(null));
+        String type = getTypePresentation(((GoVarDefinition)element).getGoType(null));
         GoExpression value = ((GoVarDefinition)element).getValue();
         return "var " + name + (!type.isEmpty() ? " " + type : "") + (value != null ? " = " + value.getText() : "");
       }

File: tests/com/goide/quickfix/GoDeleteVarDefinitionQuickFixTest.java
Patch:
@@ -34,6 +34,8 @@ public void testSimple() {
   public void testRemoveFromMultiSpec() {
     myFixture.configureByText("a.go", "package main; func main() { var (\nfo<caret>o, bar int = 2, 3\n) }");
     applySingleQuickFix("Delete variable 'foo'");
-    myFixture.checkResult("package pack; import _ \"fmt\"");
+    myFixture.checkResult("package main; func main() { var (\n" +
+                          "bar int = 3\n" +
+                          ") }");
   }
 }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -37,6 +37,7 @@ public void setUp() throws Exception {
       GoDuplicateFieldsOrMethodsInspection.class,
       GoUnusedImportInspection.class,
       GoUnusedVariableInspection.class,
+      GoUnusedConstInspection.class,
       GoUnusedGlobalVariableInspection.class,
       GoUnusedFunctionInspection.class,
       GoAssignmentToConstantInspection.class,

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -57,6 +57,8 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testTypeTopDefinition()                 { doTest(); }
   public void testTypeInnerDefinitionWithoutComment() { doTest(); }
   public void testConstants()                         { doTest(); }
+  public void testVarShortDefinition()                { doTest(); }
+  public void testSpecType()                          { doTest(); }
 
   public void testMultiBlockDoc()                     { doConverterTest(); }
   public void testIndentedBlock()                     { doConverterTest(); }

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -51,6 +51,7 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testMultilineVariable_3()               { doTest(); }
   public void testMultilineVariable_4()               { doTest(); }
   public void testMultilineVariable_5()               { doTest(); }
+  public void testFieldDeclaration()                  { doTest(); }
   public void testSignature()                         { doTest(); }
   public void testTypeSpec()                          { doTest(); }
   public void testTypeTopDefinition()                 { doTest(); }

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -36,6 +36,7 @@ protected String getBasePath() {
   public void testSwitchEnter()                     { doTestEnter(); }
   public void testTypeEnter()                       { doTestEnter(); }
   public void testSpacesInArithmeticExpressions()   { doTest(); }
+  public void testConstDeclaration()                { doTest(); }
 
   private void doTest() { doTest(null); }
 

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -55,7 +55,8 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testTypeSpec()                          { doTest(); }
   public void testTypeTopDefinition()                 { doTest(); }
   public void testTypeInnerDefinitionWithoutComment() { doTest(); }
-  
+  public void testConstants()                         { doTest(); }
+
   public void testMultiBlockDoc()                     { doConverterTest(); }
   public void testIndentedBlock()                     { doConverterTest(); }
   public void testCommentEndsWithIndentedBlock()      { doConverterTest(); }

File: src/com/goide/formatter/settings/GoLanguageCodeStyleSettingsProvider.java
Patch:
@@ -46,9 +46,9 @@ public IndentOptionsEditor getIndentOptionsEditor() {
   public CommonCodeStyleSettings getDefaultCommonSettings() {
     CommonCodeStyleSettings defaultSettings = new CommonCodeStyleSettings(getLanguage());
     CommonCodeStyleSettings.IndentOptions indentOptions = defaultSettings.initIndentOptions();
-    indentOptions.INDENT_SIZE = 4;
-    indentOptions.CONTINUATION_INDENT_SIZE = 4;
-    indentOptions.TAB_SIZE = 4;
+    indentOptions.INDENT_SIZE = 8;
+    indentOptions.CONTINUATION_INDENT_SIZE = 8;
+    indentOptions.TAB_SIZE = 8;
     indentOptions.USE_TAB_CHARACTER = true;
     return defaultSettings;
   }

File: src/com/goide/util/GoExecutor.java
Patch:
@@ -325,7 +325,9 @@ public GeneralCommandLine createCommandLine() throws ExecutionException {
       throw new ExecutionException("Sdk is not set or Sdk home path is empty for module");
     }
 
-    GeneralCommandLine commandLine = !myPtyDisabled ? new PtyCommandLine() : new GeneralCommandLine();
+    GeneralCommandLine commandLine = !myPtyDisabled && (!SystemInfo.isWindows || PtyCommandLine.isEnabled()) 
+                                     ? new PtyCommandLine() 
+                                     : new GeneralCommandLine();
     commandLine.setExePath(ObjectUtils.notNull(myExePath, GoSdkService.getGoExecutablePath(myGoRoot)));
     commandLine.getEnvironment().putAll(myExtraEnvironment);
     commandLine.getEnvironment().put(GoConstants.GO_ROOT, StringUtil.notNullize(myGoRoot));

File: src/com/goide/codeInsight/imports/GoGetPackageFix.java
Patch:
@@ -43,9 +43,7 @@ public GoGetPackageFix(@NotNull String packageName) {
   @Override
   public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {
     PsiElement element = descriptor.getPsiElement();
-    Module module = ModuleUtilCore.findModuleForPsiElement(element);
-    if (module == null) return;
-    applyFix(project, module, myPackage, true);
+    applyFix(project, ModuleUtilCore.findModuleForPsiElement(element), myPackage, true);
   }
 
   public static void applyFix(@NotNull final Project project,

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -138,7 +138,8 @@ private static String getPackageComment(@Nullable GoFile file) {
     return null;
   }
 
-  private static PsiElement adjustDocElement(PsiElement element) {
+  @Nullable
+  private static PsiElement adjustDocElement(@Nullable PsiElement element) {
     return element instanceof GoImportSpec ? ((GoImportSpec)element).getImportString().resolve() : element;
   }
 
@@ -280,7 +281,7 @@ private static String replaceInnerTypes(@NotNull GoType type, @NotNull List<GoTy
   }
 
   @Nullable
-  private static String getReferenceText(@NotNull PsiElement element) {
+  private static String getReferenceText(@Nullable PsiElement element) {
     if (element instanceof GoNamedElement) {
       PsiFile file = element.getContainingFile();
       if (file instanceof GoFile) {

File: src/com/goide/configuration/GoBuildTargetConfigurable.java
Patch:
@@ -195,7 +195,7 @@ public void disposeUIResources() {
   @Nls
   @Override
   public String getDisplayName() {
-    return "Build Flags";
+    return "Build Tags";
   }
 
   @NotNull

File: src/com/goide/highlighting/exitpoint/GoHighlightExitPointsHandlerFactory.java
Patch:
@@ -39,13 +39,13 @@ public HighlightUsagesHandlerBase createHighlightUsagesHandler(@NotNull Editor e
     if (target instanceof LeafPsiElement) {
       IElementType elementType = ((LeafPsiElement)target).getElementType();
       if (elementType == GoTypes.RETURN || elementType == GoTypes.FUNC || isPanicCall(target)) {
-        return FunctionExitPointHandler.createForElement(editor, file, target);
+        return GoFunctionExitPointHandler.createForElement(editor, file, target);
       }
       else if (elementType == GoTypes.BREAK ||
                elementType == GoTypes.SWITCH ||
                elementType == GoTypes.FOR ||
                elementType == GoTypes.SELECT) {
-        return BreakStmtExitPointHandler.createForElement(editor, file, target);
+        return GoBreakStatementExitPointHandler.createForElement(editor, file, target);
       }
     }
     return null;

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -118,7 +118,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
     }
 
     if (myCoverageFilePath != null) {
-      executor.withParameters("-coverprofile=" + myCoverageFilePath, "-covermode=count");
+      executor.withParameters("-coverprofile=" + myCoverageFilePath, "-covermode=atomic");
     }
 
     return executor;

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -118,7 +118,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
     }
 
     if (myCoverageFilePath != null) {
-      executor.withParameters("-coverprofile=" + myCoverageFilePath, "-covermode=count");
+      executor.withParameters("-coverprofile=" + myCoverageFilePath, "-covermode=atomic");
     }
 
     return executor;

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -47,6 +47,9 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testTypeResultDefinition()          { doTest(); }
   public void testMultilineTypeListDefinition()   { doTest(); }
   public void testSignature()                     { doTest(); }
+  public void testTypeSpec()                      { doTest(); }
+  public void testTypeTopDefinition()                 { doTest(); }
+  
 
   public void testMultiBlockDoc()                 { doConverterTest(); }
   public void testIndentedBlock()                 { doConverterTest(); }

File: tests/com/goide/GoDocumentationProviderTest.java
Patch:
@@ -46,6 +46,7 @@ protected LightProjectDescriptor getProjectDescriptor() {
   public void testPackageOnImportAlias()          { doTest(); }
   public void testTypeResultDefinition()          { doTest(); }
   public void testMultilineTypeListDefinition()   { doTest(); }
+  public void testSignature()                     { doTest(); }
 
   public void testMultiBlockDoc()                 { doConverterTest(); }
   public void testIndentedBlock()                 { doConverterTest(); }

File: src/com/goide/inspections/GoDeferInLoop.java
Patch:
@@ -34,7 +34,7 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNul
       @Override
       public void visitDeferStatement(@NotNull GoDeferStatement o) {
         if (PsiTreeUtil.getParentOfType(o, GoForStatement.class, GoFunctionLit.class) instanceof GoForStatement) {
-          holder.registerProblem(o.getDefer(), "Possible resource leak, \"defer\" is called in a for loop.", 
+          holder.registerProblem(o.getDefer(), "Possible resource leak, 'defer' is called in a for loop.", 
                                  ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
         }
       }

File: tests/com/goide/editor/GoFoldingBuilderTest.java
Patch:
@@ -37,6 +37,7 @@ protected String getBasePath() {
   public void testImportListWithNewLineAfterKeyword()             { doTest(); }
   public void testImportListWithOnlyThreeSymbolsToFold()          { doTest(); }
   public void testVarDeclaration()                                { doTest(); }
+  public void testConstDeclaration()                              { doTest(); }
   public void testTypeDeclaration()                               { doTest(); }
   public void testCompositeLiteral()                              { doTest(); }
 }

File: tests/com/goide/editor/GoFoldingBuilderTest.java
Patch:
@@ -37,6 +37,7 @@ protected String getBasePath() {
   public void testImportListWithNewLineAfterKeyword()             { doTest(); }
   public void testImportListWithOnlyThreeSymbolsToFold()          { doTest(); }
   public void testVarDeclaration()                                { doTest(); }
+  public void testConstDeclaration()                              { doTest(); }
   public void testTypeDeclaration()                               { doTest(); }
   public void testCompositeLiteral()                              { doTest(); }
 }

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -46,7 +46,7 @@ public String generateDoc(PsiElement element, PsiElement originalElement) {
       String signature = getSignature(element);
       signature = StringUtil.isNotEmpty(signature) ? "<b>" + signature + "</b>\n" : signature;
       String commentText = getCommentText(getCommentsForElement(alone ? topLevel : element));
-      return StringUtil.isNotEmpty(commentText) ? signature + commentText : signature;
+      return StringUtil.nullize(signature + commentText);
     }
     else if (element instanceof PsiDirectory) {
       return getPackageComment(findDocFileForDirectory(((PsiDirectory)element)));

File: src/com/goide/dlv/DlvDebugProcess.java
Patch:
@@ -264,7 +264,7 @@ public void registerBreakpoint(@NotNull final XLineBreakpoint<DlvBreakpointPrope
       if (breakpointPosition == null) return;
       VirtualFile file = breakpointPosition.getFile();
       int line = breakpointPosition.getLine();
-      send(new DlvRequest.CreateBreakpoint(file.getCanonicalPath(), line + 1))
+      send(new DlvRequest.CreateBreakpoint(file.getPath(), line + 1))
         .done(new Consumer<Breakpoint>() {
           @Override
           public void consume(@NotNull Breakpoint b) {

File: src/com/goide/dlv/DlvDebugProcess.java
Patch:
@@ -264,7 +264,7 @@ public void registerBreakpoint(@NotNull final XLineBreakpoint<DlvBreakpointPrope
       if (breakpointPosition == null) return;
       VirtualFile file = breakpointPosition.getFile();
       int line = breakpointPosition.getLine();
-      send(new DlvRequest.CreateBreakpoint(file.getCanonicalPath(), line + 1))
+      send(new DlvRequest.CreateBreakpoint(file.getPath(), line + 1))
         .done(new Consumer<Breakpoint>() {
           @Override
           public void consume(@NotNull Breakpoint b) {

File: src/com/goide/actions/tool/GoDownloadableFileAction.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.actions.fmt;
+package com.goide.actions.tool;
 
 import com.goide.GoConstants;
 import com.goide.codeInsight.imports.GoGetPackageFix;

File: src/com/goide/actions/tool/GoExternalToolsAction.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.actions.fmt;
+package com.goide.actions.tool;
 
 import com.goide.GoConstants;
 import com.goide.GoFileType;

File: src/com/goide/actions/tool/GoFmtCheckinFactory.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.actions.fmt;
+package com.goide.actions.tool;
 
 import com.goide.psi.GoFile;
 import com.intellij.CommonBundle;

File: src/com/goide/actions/tool/GoFmtFileAction.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.actions.fmt;
+package com.goide.actions.tool;
 
 import com.goide.util.GoExecutor;
 import com.intellij.openapi.module.Module;

File: src/com/goide/actions/tool/GoFmtProjectAction.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.actions.fmt;
+package com.goide.actions.tool;
 
 import com.goide.sdk.GoSdkService;
 import com.goide.sdk.GoSdkUtil;

File: src/com/goide/actions/tool/GoImportsFileAction.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.actions.fmt;
+package com.goide.actions.tool;
 
 import com.goide.util.GoExecutor;
 import com.intellij.openapi.module.Module;

File: src/com/goide/actions/tool/GoTypeFileAction.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.goide.actions.fmt;
+package com.goide.actions.tool;
 
 import com.goide.util.GoExecutor;
 import com.intellij.openapi.module.Module;

File: src/com/goide/dlv/DlvXValue.java
Patch:
@@ -235,7 +235,7 @@ public void computeTypeSourcePosition(@NotNull XNavigatable navigatable) {
     Project project = getProject();
     if (project == null) return;
     String dlvType = myVariable.type;
-    String fqn = isPtr ? dlvType.replaceFirst("\\*struct ", "") : dlvType;
+    String fqn = isPtr ? dlvType.replaceFirst("\\*struct ", "") : dlvType.replaceFirst("struct ", "");
     List<String> split = StringUtil.split(fqn, ".");
     boolean noFqn = split.size() == 1;
     if (split.size() == 2 || noFqn) {

File: src/com/goide/dlv/DlvDebugProcess.java
Patch:
@@ -92,7 +92,7 @@ public void consume(@NotNull final DebuggerState o) {
         .done(new Consumer<List<DlvApi.Location>>() {
           @Override
           public void consume(@NotNull List<DlvApi.Location> locations) {
-            DlvSuspendContext context = new DlvSuspendContext(o.currentThread.id, locations, getProcessor());
+            DlvSuspendContext context = new DlvSuspendContext(DlvDebugProcess.this, o.currentThread.id, locations, getProcessor());
             XDebugSession session = getSession();
             if (find == null) {
               session.positionReached(context);

File: tests/com/goide/editor/GoParameterInfoHandlerTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.goide.GoCodeInsightFixtureTestCase;
 import com.goide.psi.GoArgumentList;
-import com.intellij.codeInsight.CodeInsightBundle;
 import com.intellij.codeInsight.hint.ParameterInfoComponent;
 import com.intellij.lang.parameterInfo.CreateParameterInfoContext;
 import com.intellij.lang.parameterInfo.ParameterInfoUIContextEx;
@@ -38,9 +37,9 @@ protected void setUp() throws Exception {
   // @formatter:off
   public void testUnnamedParameters()         { doTest("<html><b>string</b>, interface{}</html>"); }
   public void testUnnamedAndNamedParameters() { doTest("<html><b>a string</b>, interface{}</html>"); }
-  public void testFuncParamNone()             { doTest(CodeInsightBundle.message("parameter.info.no.parameters")); }
+  public void testFuncParamNone()             { doTest("<html>&lt;no parameters&gt;</html>"); }
   public void testChainedCall()               { doTest("<html><b>param1 string</b>, param2 int</html>"); }
-  public void testMethParamNone()             { doTest(CodeInsightBundle.message("parameter.info.no.parameters")); }
+  public void testMethParamNone()             { doTest("<html>&lt;no parameters&gt;</html>"); }
   public void testFieldMethCall()             { doTest("<html><b>a int</b>, b int</html>"); }
   public void testFuncTypes()                 { doTest("<html><b>string</b></html>"); }
   public void testFuncParam()                 { doTest(1, "<html>num int, <b>text string</b></html>"); }

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -3567,14 +3567,13 @@ private static boolean SwitchStatement_1(PsiBuilder b, int l) {
   }
 
   /* ********************************************************** */
-  // string | raw_string
+  // StringLiteral
   public static boolean Tag(PsiBuilder b, int l) {
     if (!recursion_guard_(b, l, "Tag")) return false;
     if (!nextTokenIs(b, "<tag>", RAW_STRING, STRING)) return false;
     boolean r;
     Marker m = enter_section_(b, l, _NONE_, "<tag>");
-    r = consumeToken(b, STRING);
-    if (!r) r = consumeToken(b, RAW_STRING);
+    r = StringLiteral(b, l + 1);
     exit_section_(b, l, m, TAG, r, false, null);
     return r;
   }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -54,7 +54,8 @@ public void setUp() throws Exception {
       GoMultiplePackagesInspection.class,
       GoCgoInTestInspection.class,
       GoTestSignaturesInspection.class,
-      GoAssignmentNilWithoutExplicitTypeInspection.class
+      GoAssignmentNilWithoutExplicitTypeInspection.class,
+      GoStructTagInspection.class
     );
   }
 
@@ -111,6 +112,7 @@ protected boolean isWriteActionRequired() {
   public void testMethodExpr()  { doTest(); }
   public void testVarToImport() { doTest(); }
   public void testCgotest()     { doTest(); }
+  public void testStructTags()  { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: gen/com/goide/psi/impl/GoAnonymousFieldDefinitionImpl.java
Patch:
@@ -1,12 +1,11 @@
 // This is a generated file. Not intended for manual editing.
 package com.goide.psi.impl;
 
-import java.util.List;
 import org.jetbrains.annotations.*;
 import com.intellij.lang.ASTNode;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.PsiElementVisitor;
-import com.intellij.psi.util.PsiTreeUtil;
+
 import static com.goide.GoTypes.*;
 import com.goide.stubs.GoAnonymousFieldDefinitionStub;
 import com.goide.psi.*;
@@ -56,7 +55,7 @@ public int getTextOffset() {
 
   @Nullable
   public GoType getGoTypeInner(ResolveState context) {
-    return GoPsiImplUtil.getGoTypeInner(this, context);
+    return GoFieldNameReference.findTypeFromRef(getTypeReferenceExpression());
   }
 
 }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -343,7 +343,7 @@ else if (o instanceof GoCompositeLit) {
       GoType type = ((GoCompositeLit)o).getType();
       if (type != null) return type;
       GoTypeReferenceExpression expression = ((GoCompositeLit)o).getTypeReferenceExpression();
-      return findTypeFromRef(expression);
+      return findTypeFromRefInner(expression);
     }
     else if (o instanceof GoFunctionLit) {
       return new MyFunType((GoFunctionLit)o);

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -419,7 +419,7 @@ else if (o instanceof GoStringLiteral) {
     else if (o instanceof GoLiteral) {
       GoLiteral l = (GoLiteral)o;
       if (l.getChar() != null) return getBuiltinType(o, "rune");
-      if (l.getInt() != null || l.getHex() != null) return getBuiltinType(o, "int");
+      if (l.getInt() != null || l.getHex() != null || ((GoLiteral)o).getOct() != null) return getBuiltinType(o, "int");
       if (l.getFloat() != null) return getBuiltinType(o, "float64");
       if (l.getFloati() != null) return getBuiltinType(o, "complex64");
       if (l.getDecimali() != null) return getBuiltinType(o, "complex128");

File: gen/com/goide/psi/GoSignature.java
Patch:
@@ -15,6 +15,4 @@ public interface GoSignature extends GoCompositeElement, StubBasedPsiElement<GoS
   @Nullable
   GoResult getResult();
 
-  boolean shouldGoDeeper();
-
 }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -1011,7 +1011,7 @@ public static GoStringLiteralEscaper createLiteralTextEscaper(@NotNull GoStringL
   }
 
   public static boolean shouldGoDeeper(@SuppressWarnings("UnusedParameters") GoSignature o) {
-    return false;
+    return true;
   }
 
   public static boolean prevDot(@Nullable PsiElement e) {

File: src/com/goide/completion/GoAutoImportInsertHandler.java
Patch:
@@ -58,7 +58,6 @@ public InsertHandler<LookupElement> fun(T o) {
     }, clazz);
   }
 
-
   public GoAutoImportInsertHandler(@Nullable Function<T, InsertHandler<LookupElement>> delegateGetter, @Nullable Class<T> clazz) {
     myDelegateGetter = delegateGetter;
     myClass = clazz;

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -416,7 +416,7 @@ else if (o instanceof GoStringLiteral) {
     else if (o instanceof GoLiteral) {
       GoLiteral l = (GoLiteral)o;
       if (l.getChar() != null) return getBuiltinType(o, "rune");
-      if (l.getInt() != null) return getBuiltinType(o, "int");
+      if (l.getInt() != null || l.getHex() != null) return getBuiltinType(o, "int");
       if (l.getFloat() != null) return getBuiltinType(o, "float64");
       if (l.getFloati() != null) return getBuiltinType(o, "complex64");
       if (l.getDecimali() != null) return getBuiltinType(o, "complex128");

File: src/com/goide/util/GoExecutor.java
Patch:
@@ -40,6 +40,7 @@
 import com.intellij.openapi.project.Project;
 import com.intellij.openapi.util.Disposer;
 import com.intellij.openapi.util.Ref;
+import com.intellij.openapi.util.SystemInfo;
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.openapi.vfs.CharsetToolkit;
 import com.intellij.openapi.vfs.VfsUtilCore;
@@ -208,7 +209,8 @@ public boolean execute() {
         public void processTerminated(@NotNull ProcessEvent event) {
           super.processTerminated(event);
           final boolean success = event.getExitCode() == 0 && myProcessOutput.getStderr().isEmpty();
-          final boolean cancelledByUser = event.getExitCode() == PtyHelpers.SIGINT && myProcessOutput.getStderr().isEmpty();
+          boolean nothingToShow = myProcessOutput.getStdout().isEmpty() && myProcessOutput.getStderr().isEmpty();
+          final boolean cancelledByUser = (SystemInfo.isWindows || event.getExitCode() == PtyHelpers.SIGINT) && nothingToShow;
           result.set(success);
           if (success && myShowNotificationsOnSuccess) {
             showNotification("Finished successfully", NotificationType.INFORMATION);

File: src/com/goide/dlv/DlvStackFrame.java
Patch:
@@ -97,12 +97,11 @@ public void run() {
               PsiElement elementAtCursor =
                 DebuggerUtilsEx.findElementAt(PsiDocumentManager.getInstance(project).getPsiFile(document), offset);
               GoTypeOwner e = PsiTreeUtil.getParentOfType(elementAtCursor,
-                                                          GoReferenceExpression.class,
+                                                          GoExpression.class,
                                                           GoVarDefinition.class,
                                                           GoConstDefinition.class,
                                                           GoParamDefinition.class);
-              if (e instanceof GoReferenceExpression && ((GoReferenceExpression)e).getQualifier() == null ||
-                  e != null && !(e instanceof GoReferenceExpression)) {
+              if (e != null) {
                 currentRange.set(e.getTextRange());
               }
             }

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -119,7 +119,7 @@ public static VirtualFile findExecutableInGoPath(@NotNull String executableName,
     executableName = GoEnvironmentUtil.getBinaryFileNameForPath(executableName);
     Collection<VirtualFile> roots = getGoPathRoots(project, module);
     for (VirtualFile file : roots) {
-      VirtualFile child = file.findChild("bin/" + executableName);
+      VirtualFile child = VfsUtil.findRelativeFile(file, "bin", executableName);
       if (child != null) return child;
     }
     File fromPath = PathEnvironmentVariableUtil.findInPath(executableName);

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -957,10 +957,11 @@ public static String getPath(@NotNull GoImportString importString) {
     int startOffset = isQuote(quote) ? 1 : 0;
     int endOffset = text.length();
     if (text.length() > 1) {
-      if (isQuote(quote) && text.charAt(text.length() - 1) == quote) {
+      char lastChar = text.charAt(text.length() - 1);
+      if (isQuote(quote) && lastChar == quote) {
         endOffset = text.length() - 1;
       }
-      if (!isQuote(quote) && isQuote(text.charAt(text.length()))){
+      if (!isQuote(quote) && isQuote(lastChar)){
         endOffset = text.length() - 1;
       }
     }

File: src/com/goide/appengine/run/GoAppEngineRunConfiguration.java
Patch:
@@ -116,7 +116,7 @@ public void checkConfiguration() throws RuntimeConfigurationException {
 
     Module module = getConfigurationModule().getModule();
     if (module != null) {
-      if (!GoSdkService.isAppEngineSdkPath(GoSdkService.getInstance(module.getProject()).getSdkHomePath(module))) {
+      if (!GoSdkService.getInstance(module.getProject()).isAppEngineSdk(module)) {
         throw new RuntimeConfigurationWarning("Go SDK is not specified for module '" + module.getName() + "'");
       }
     }

File: src/com/goide/runconfig/GoRunningState.java
Patch:
@@ -40,7 +40,7 @@ public GoRunningState(@NotNull ExecutionEnvironment env, @NotNull Module module,
     super(env);
     myModule = module;
     myConfiguration = configuration;
-    addConsoleFilters(new GoConsoleFilter(myConfiguration.getProject(), myModule, myConfiguration.getWorkingDirectory()));
+    addConsoleFilters(new GoConsoleFilter(myConfiguration.getProject(), myModule, myConfiguration.getWorkingDirectoryUrl()));
   }
 
   @NotNull

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -67,7 +67,7 @@ public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunne
                                                                                         consoleProperties, getEnvironment(),
                                                                                         new GoTestLocationProvider());
     consoleView.attachToProcess(processHandler);
-    consoleView.addMessageFilter(new GoConsoleFilter(myConfiguration.getProject(), myModule, myConfiguration.getWorkingDirectory()));
+    consoleView.addMessageFilter(new GoConsoleFilter(myConfiguration.getProject(), myModule, myConfiguration.getWorkingDirectoryUrl()));
 
     DefaultExecutionResult executionResult = new DefaultExecutionResult(consoleView, processHandler);
     executionResult.setRestartActions(new ToggleAutoTestAction());

File: src/com/goide/util/GoExecutor.java
Patch:
@@ -42,6 +42,7 @@
 import com.intellij.openapi.util.Ref;
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.openapi.vfs.CharsetToolkit;
+import com.intellij.openapi.vfs.VfsUtilCore;
 import com.intellij.util.Consumer;
 import com.intellij.util.EnvironmentUtil;
 import com.intellij.util.ObjectUtils;
@@ -301,7 +302,7 @@ private void showOutput(@NotNull OSProcessHandler originalHandler, @NotNull GoHi
       RunContentExecutor runContentExecutor = new RunContentExecutor(myProject, outputHandler)
         .withTitle(getPresentableName())
         .withActivateToolWindow(myShowOutputOnError)
-        .withFilter(new GoConsoleFilter(myProject, myModule, myWorkDirectory));
+        .withFilter(new GoConsoleFilter(myProject, myModule, myWorkDirectory != null ? VfsUtilCore.pathToUrl(myWorkDirectory) : null));
       Disposer.register(myProject, runContentExecutor);
       runContentExecutor.run();
       historyProcessListener.apply(outputHandler);

File: src/com/goide/dlv/protocol/DlvApi.java
Patch:
@@ -29,9 +29,9 @@ public static class DebuggerState {
     // CurrentThread is the currently selected debugger thread.
     public Thread currentThread; //`json:"currentThread,omitempty"`
     // SelectedGoroutine is the currently selected goroutine
-    public Goroutine SelectedGoroutine; //`json:"currentGoroutine,omitempty"`
+    public Goroutine currentGoroutine; //`json:"currentGoroutine,omitempty"`
     // Information requested by the current breakpoint
-    public BreakpointInfo breakpointInfo; //`json:"breakPointInfo,omitrempty"`
+    public BreakpointInfo breakPointInfo; //`json:"breakPointInfo,omitrempty"`
     // Exited indicates whether the debugged process has exited.
     public boolean exited; //`json:"exited"`
     public int exitStatus; //`json:"exitStatus"`
@@ -153,7 +153,7 @@ public static class DebuggerCommand {
     public int threadID; //`json:"threadID,omitempty"`
     // GoroutineID is used to specify which thread to use with the SwitchGoroutine
     // command.
-    public int GoroutineID; // `json:"goroutineID,omitempty"`
+    public int goroutineID; // `json:"goroutineID,omitempty"`
   }
 
   // Informations about the current breakpoint

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -110,6 +110,7 @@ protected boolean isWriteActionRequired() {
   public void testAssignmentUsages()  { doTest(); }
   public void testMethodExpr()  { doTest(); }
   public void testVarToImport() { doTest(); }
+  public void testCgotest()     { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: src/com/goide/dlv/breakpoint/DlvBreakpointType.java
Patch:
@@ -59,7 +59,7 @@ public boolean canPutAt(@NotNull VirtualFile file, int line, @NotNull Project pr
 
   private static boolean isLineBreakpointAvailable(@NotNull VirtualFile file, int line, @NotNull Project project) {
     Document document = FileDocumentManager.getInstance().getDocument(file);
-    if (document == null || document.getLineEndOffset(line) == document.getLineStartOffset(line)) return false;
+    if (document == null || line == -1 || document.getLineEndOffset(line) == document.getLineStartOffset(line)) return false;
     Checker canPutAtChecker = new Checker();
     XDebuggerUtil.getInstance().iterateLine(project, document, line, canPutAtChecker);
     return canPutAtChecker.isLineBreakpointAvailable();

File: tests/com/goide/editor/GoFoldingBuilderTest.java
Patch:
@@ -36,4 +36,7 @@ protected String getBasePath() {
   public void testEmptyImportList()                               { doTest(); }
   public void testImportListWithNewLineAfterKeyword()             { doTest(); }
   public void testImportListWithOnlyThreeSymbolsToFold()          { doTest(); }
+  public void testVarDeclaration()                                { doTest(); }
+  public void testTypeDeclaration()                               { doTest(); }
+  public void testCompositeLiteral()                              { doTest(); }
 }

File: src/com/goide/psi/impl/GoCompositeElementImpl.java
Patch:
@@ -55,6 +55,7 @@ public static boolean processDeclarationsDefault(@NotNull GoCompositeElement o,
           o instanceof GoSwitchStatement ||
           o instanceof GoIfStatement ||
           o instanceof GoForStatement ||
+          o instanceof GoCommClause ||
           o instanceof GoBlock
         ) 
         && processor instanceof GoScopeProcessorBase) {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -652,6 +652,9 @@ private static GoType processRangeClause(@NotNull GoVarDefinition o, @NotNull Go
       else if (type instanceof GoParType) {
         type = ((GoParType)type).getType();
       }
+      else if (type instanceof GoSpecType) {
+        type = ((GoSpecType)type).getType();
+      }
       GoTypeReferenceExpression typeRef = type != null ? type.getTypeReferenceExpression() : null;
       if (typeRef != null) {
         PsiElement resolve = typeRef.getReference().resolve();

File: src/com/goide/GoFindUsagesProvider.java
Patch:
@@ -69,6 +69,7 @@ public String getType(@NotNull PsiElement element) {
     if (element instanceof GoReceiver) return "receiver";
     if (element instanceof GoMethodSpec) return "method specification";
     if (element instanceof GoLabelDefinition) return "label";
+    if (element instanceof GoPackageClause) return "package statement";
     
     // should be last
     if (element instanceof GoStatement) return "statement";

File: src/com/goide/project/migration/GoProjectModelConverterProvider.java
Patch:
@@ -44,7 +44,6 @@
 import java.util.Collection;
 
 public class GoProjectModelConverterProvider extends ConverterProvider {
-
   public static final String PROJECT_ROOT_MANAGER = "ProjectRootManager";
 
   protected GoProjectModelConverterProvider() {
@@ -173,7 +172,7 @@ public void process(ModuleSettings settings) throws CannotConvertException {
       settings.setModuleType(GoConstants.MODULE_TYPE_ID);
       for (Element element : settings.getOrderEntries()) {
         if (isGoSdkType(element.getAttributeValue("jdkType"))) {
-          element.setAttribute("jdkName", GoConstants.SDK_TYPE_ID);
+          element.setAttribute("jdkType", GoConstants.SDK_TYPE_ID);
         }
       }
       convertSdks();

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -106,6 +106,7 @@ protected boolean isWriteActionRequired() {
   public void testStubParams()  { doTest(); }
   public void testNil()         { doTest(); }
   public void testAssignmentUsages()  { doTest(); }
+  public void testMethodExpr()  { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {
     myFixture.getTempDirFixture().findOrCreateDir("to_import/testdata");

File: src/com/goide/dlv/DlvStackFrame.java
Patch:
@@ -167,7 +167,9 @@ public void setValue(@NotNull String newValue, @NotNull final XModificationCallb
               .processed(new Consumer<Object>() {
               @Override
               public void consume(Object o) {
-                callback.valueModified();
+                if (o != null) {
+                  callback.valueModified();
+                }
               }
             })
               .rejected(new Consumer<Throwable>() {

File: src/com/goide/project/GoModuleLibrariesInitializer.java
Patch:
@@ -291,7 +291,7 @@ private static void showNotification(@NotNull final Project project) {
 
     if (!shownAlready) {
       Notification notification = GoConstants.GO_NOTIFICATION_GROUP.createNotification("GOPATH was detected",
-                                                         "We've been detected some libraries from your GOPATH.\n" +
+                                                         "We've detected some libraries from your GOPATH.\n" +
                                                          "You may want to add extra libraries in <a href='configure'>Go Libraries configuration</a>.",
                                                          NotificationType.INFORMATION, new NotificationListener.Adapter() {
         @Override

File: src/com/goide/project/GoModuleLibrariesInitializer.java
Patch:
@@ -291,7 +291,7 @@ private static void showNotification(@NotNull final Project project) {
 
     if (!shownAlready) {
       Notification notification = GoConstants.GO_NOTIFICATION_GROUP.createNotification("GOPATH was detected",
-                                                         "We've been detected some libraries from your GOPATH.\n" +
+                                                         "We've detected some libraries from your GOPATH.\n" +
                                                          "You may want to add extra libraries in <a href='configure'>Go Libraries configuration</a>.",
                                                          NotificationType.INFORMATION, new NotificationListener.Adapter() {
         @Override

File: src/com/goide/dlv/DlvStackFrame.java
Patch:
@@ -176,7 +176,7 @@ public XSourcePosition getSourcePosition() {
     String url = myLocation.file;
     VirtualFile file = LocalFileSystem.getInstance().findFileByPath(url);
     if (file == null) return null;
-    return XDebuggerUtil.getInstance().createPosition(file, myLocation.line);
+    return XDebuggerUtil.getInstance().createPosition(file, myLocation.line - 1);
   }
 
   @Override

File: src/com/goide/parser/GoParserUtil.java
Patch:
@@ -167,7 +167,7 @@ public static boolean exitModeSafe(@NotNull PsiBuilder builder_, @SuppressWarnin
   public static boolean isBuiltin(@NotNull PsiBuilder builder_, @SuppressWarnings("UnusedParameters") int level) {
     LighterASTNode marker = builder_.getLatestDoneMarker();
     if (marker == null) return false;
-    String text = String.valueOf(builder_.getOriginalText().subSequence(marker.getStartOffset(), marker.getEndOffset()));
+    String text = String.valueOf(builder_.getOriginalText().subSequence(marker.getStartOffset(), marker.getEndOffset())).trim();
     return "make".equals(text) || "new".equals(text);
   }
 

File: src/com/goide/util/GoUtil.java
Patch:
@@ -216,7 +216,7 @@ public static Collection<String> getAllPackagesInDirectory(@Nullable final PsiDi
       public Result<Collection<String>> compute() {
         Collection<String> set = ContainerUtil.newLinkedHashSet();
         for (PsiFile file : dir.getFiles()) {
-          if (file instanceof GoFile && !directoryToIgnore(file.getName())) {
+          if (file instanceof GoFile && !directoryToIgnore(file.getName()) && allowed(file)) {
             String name = ((GoFile)file).getPackageName();
             if (StringUtil.isNotEmpty(name)) {
               set.add(trimTestSuffices && GoTestFinder.isTestFile(file) ? StringUtil.trimEnd(name, GoConstants.TEST_SUFFIX) : name);

File: tests/com/goide/util/GoUtilTest.java
Patch:
@@ -26,6 +26,7 @@ public void testPackageNameOfTestPackageInNonTestFile() {
     myFixture.configureByText("docs.go", "package documentation");
     myFixture.configureByText("bar_test.go", "package tricky_package_name");
     myFixture.configureByText("non_test_file.go", "package non_test");
+    myFixture.configureByText("ignored.go", "// +build ignored\n\npackage ignored");
     
     assertSameElements(GoUtil.getAllPackagesInDirectory(myFixture.getFile().getContainingDirectory(), true), 
                        "foo", "main", "non_test", "documentation", "tricky_package_name");

File: src/com/goide/util/GoUtil.java
Patch:
@@ -216,7 +216,7 @@ public static Collection<String> getAllPackagesInDirectory(@Nullable final PsiDi
       public Result<Collection<String>> compute() {
         Collection<String> set = ContainerUtil.newLinkedHashSet();
         for (PsiFile file : dir.getFiles()) {
-          if (file instanceof GoFile && !directoryToIgnore(file.getName())) {
+          if (file instanceof GoFile && !directoryToIgnore(file.getName()) && allowed(file)) {
             String name = ((GoFile)file).getPackageName();
             if (StringUtil.isNotEmpty(name)) {
               set.add(trimTestSuffices && GoTestFinder.isTestFile(file) ? StringUtil.trimEnd(name, GoConstants.TEST_SUFFIX) : name);

File: tests/com/goide/util/GoUtilTest.java
Patch:
@@ -26,6 +26,7 @@ public void testPackageNameOfTestPackageInNonTestFile() {
     myFixture.configureByText("docs.go", "package documentation");
     myFixture.configureByText("bar_test.go", "package tricky_package_name");
     myFixture.configureByText("non_test_file.go", "package non_test");
+    myFixture.configureByText("ignored.go", "// +build ignored\n\npackage ignored");
     
     assertSameElements(GoUtil.getAllPackagesInDirectory(myFixture.getFile().getContainingDirectory(), true), 
                        "foo", "main", "non_test", "documentation", "tricky_package_name");

File: src/com/goide/psi/GoFile.java
Patch:
@@ -48,6 +48,7 @@
 import com.intellij.util.ArrayUtil;
 import com.intellij.util.Processor;
 import com.intellij.util.containers.ContainerUtil;
+import com.intellij.util.containers.LinkedMultiMap;
 import com.intellij.util.containers.MultiMap;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -219,7 +220,7 @@ public Result<Map<String, GoImportSpec>> compute() {
    */
   @NotNull
   public MultiMap<String, GoImportSpec> getImportMap() {
-    MultiMap<String, GoImportSpec> map = MultiMap.create();
+    MultiMap<String, GoImportSpec> map = LinkedMultiMap.create();
     for (GoImportSpec spec : getImports()) {
       String alias = spec.getAlias();
       if (alias != null) {

File: src/com/goide/runconfig/testing/frameworks/gotest/GotestEventsConverter.java
Patch:
@@ -56,7 +56,7 @@ public boolean processServiceMessages(@NotNull String text, Key outputType, Serv
 
     if ((matcher = RUN.matcher(text)).find()) {
       myOutputAppeared = false;
-      String testName = StringUtil.notNullize(matcher.group(1), "<test>");
+      String testName = StringUtil.notNullize(matcher.group(1), "<test>").trim();
       ServiceMessageBuilder testStarted = ServiceMessageBuilder.testStarted(testName).addAttribute("locationHint", testUrl(testName));
       boolean result = processNotFinishedMessage(testStarted.toString(), outputType, visitor);
       myCurrentTestStart = System.currentTimeMillis();

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -610,6 +610,9 @@ private static GoType processRangeClause(@NotNull GoVarDefinition o, @NotNull Go
       if (type instanceof GoPointerType) {
         type = ((GoPointerType)type).getType();
       }
+      else if (type instanceof GoParType) {
+        type = ((GoParType)type).getType();
+      }
       GoTypeReferenceExpression typeRef = type != null ? type.getTypeReferenceExpression() : null;
       if (typeRef != null) {
         PsiElement resolve = typeRef.getReference().resolve();

File: tests/com/goide/quickfix/GoCreateTypeQuickFixTest.java
Patch:
@@ -33,5 +33,6 @@ protected String getBasePath() {
   }
 
   public void testSimple()      { doTest(CREATE_TYPE_A);      }
+  public void testGlobal()      { doTest(CREATE_TYPE_A);      }
   public void testProhibited()  { doTestNoFix(CREATE_TYPE_A); }
 }

File: src/com/goide/psi/impl/GoVarProcessor.java
Patch:
@@ -63,7 +63,7 @@ private boolean differentBlocks(@Nullable GoNamedElement o) {
   }
 
   @Nullable
-  private static GoCompositeElement getScope(@Nullable PsiElement o) {
+  public static GoCompositeElement getScope(@Nullable PsiElement o) {
     GoForStatement forStatement = PsiTreeUtil.getParentOfType(o, GoForStatement.class);
     if (forStatement != null) return forStatement.getBlock();
     GoIfStatement ifStatement = PsiTreeUtil.getParentOfType(o, GoIfStatement.class);

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -607,6 +607,9 @@ private static GoType processRangeClause(@NotNull GoVarDefinition o, @NotNull Go
       if (type instanceof GoChannelType) {
         return ((GoChannelType)type).getType();
       }
+      if (type instanceof GoPointerType) {
+        type = ((GoPointerType)type).getType();
+      }
       GoTypeReferenceExpression typeRef = type != null ? type.getTypeReferenceExpression() : null;
       if (typeRef != null) {
         PsiElement resolve = typeRef.getReference().resolve();

File: src/com/goide/runconfig/before/GoBeforeRunTaskProvider.java
Patch:
@@ -134,7 +134,7 @@ public void run() {
         if (!sdkService.isGoModule(module)) return;
 
         done.down();
-        GoExecutor.in(module).withParameters(task.getCommand())
+        GoExecutor.in(module).withParameterString(task.getCommand())
           .withWorkDirectory(workingDirectory)
           .showOutputOnError()
           .showNotifications(false)

File: tests/com/goide/completion/GoExcludedPackagesTest.java
Patch:
@@ -19,7 +19,7 @@
 import com.goide.project.GoExcludedPathsSettings;
 import com.intellij.util.ArrayUtil;
 
-public class GoExcludePackagesTest extends GoCompletionSdkAwareTest {
+public class GoExcludedPackagesTest extends GoCompletionSdkAwareTestBase {
   @Override
   protected void tearDown() throws Exception {
     GoExcludedPathsSettings.getInstance(getProject()).setExcludedPackages(ArrayUtil.EMPTY_STRING_ARRAY);

File: tests/com/goide/completion/GoExcludedPackagesTest.java
Patch:
@@ -19,7 +19,7 @@
 import com.goide.project.GoExcludedPathsSettings;
 import com.intellij.util.ArrayUtil;
 
-public class GoExcludePackagesTest extends GoCompletionSdkAwareTest {
+public class GoExcludedPackagesTest extends GoCompletionSdkAwareTestBase {
   @Override
   protected void tearDown() throws Exception {
     GoExcludedPathsSettings.getInstance(getProject()).setExcludedPackages(ArrayUtil.EMPTY_STRING_ARRAY);

File: src/com/goide/runconfig/application/GoApplicationRunningState.java
Patch:
@@ -104,7 +104,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
         dlv.setExecutable(true, false);
       }
       return executor.withExePath(dlv.getAbsolutePath())
-        .withParameters("--listen=localhost:" + myDebugPort, "--headless=true", "debug", myOutputFilePath, "--");
+        .withParameters("--listen=localhost:" + myDebugPort, "--headless=true", "exec", myOutputFilePath, "--");
     }
     return executor.withExePath(myOutputFilePath);
   }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -148,7 +148,7 @@ public static PsiReference getReference(@NotNull GoLabelRef o) {
   @Nullable
   public static PsiReference getReference(@NotNull GoVarDefinition o) {
     GoShortVarDeclaration shortDeclaration = PsiTreeUtil.getParentOfType(o, GoShortVarDeclaration.class);
-    boolean createRef = PsiTreeUtil.getParentOfType(shortDeclaration, GoBlock.class, GoIfStatement.class, GoSwitchStatement.class, GoSelectStatement.class) instanceof GoBlock;
+    boolean createRef = PsiTreeUtil.getParentOfType(shortDeclaration, GoBlock.class, GoForStatement.class, GoIfStatement.class, GoSwitchStatement.class, GoSelectStatement.class) instanceof GoBlock;
     return createRef ? new GoVarReference(o) : null;
   }
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -148,7 +148,7 @@ public static PsiReference getReference(@NotNull GoLabelRef o) {
   @Nullable
   public static PsiReference getReference(@NotNull GoVarDefinition o) {
     GoShortVarDeclaration shortDeclaration = PsiTreeUtil.getParentOfType(o, GoShortVarDeclaration.class);
-    boolean createRef = PsiTreeUtil.getParentOfType(shortDeclaration, GoBlock.class, GoIfStatement.class, GoSwitchStatement.class, GoSelectStatement.class) instanceof GoBlock;
+    boolean createRef = PsiTreeUtil.getParentOfType(shortDeclaration, GoBlock.class, GoForStatement.class, GoIfStatement.class, GoSwitchStatement.class, GoSelectStatement.class) instanceof GoBlock;
     return createRef ? new GoVarReference(o) : null;
   }
 

File: src/com/goide/runconfig/application/GoApplicationRunningState.java
Patch:
@@ -103,7 +103,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
         dlv.setExecutable(true, false);
       }
       return executor.withExePath(dlv.getAbsolutePath())
-        .withParameters("--listen=localhost:" + myDebugPort, "--headless=true", "run", myOutputFilePath, "--");
+        .withParameters("--listen=localhost:" + myDebugPort, "--headless=true", "debug", myOutputFilePath, "--");
     }
     return executor.withExePath(myOutputFilePath);
   }

File: tests/com/goide/quickfix/GoMultiplePackagesQuickFixTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.goide.quickfix;
 
 import com.goide.inspections.GoMultiplePackagesInspection;
+import com.goide.inspections.GoMultiplePackagesQuickFix;
 
 public class GoMultiplePackagesQuickFixTest extends GoQuickFixTestBase {
   @Override
@@ -36,6 +37,7 @@ public void testMultiplePackagesQuickFix() {
     myFixture.configureByFile("b_test.go");
     myFixture.configureByFile("a.go");
 
+    GoMultiplePackagesQuickFix.setTestingPackageName("a", getTestRootDisposable());
     applySingleQuickFix("Rename packages");
 
     myFixture.checkResultByFile("a.go", "a-after.go", true);

File: tests/com/goide/quickfix/GoMultiplePackagesQuickFixTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.goide.quickfix;
 
 import com.goide.inspections.GoMultiplePackagesInspection;
+import com.goide.inspections.GoMultiplePackagesQuickFix;
 
 public class GoMultiplePackagesQuickFixTest extends GoQuickFixTestBase {
   @Override
@@ -36,6 +37,7 @@ public void testMultiplePackagesQuickFix() {
     myFixture.configureByFile("b_test.go");
     myFixture.configureByFile("a.go");
 
+    GoMultiplePackagesQuickFix.setTestingPackageName("a", getTestRootDisposable());
     applySingleQuickFix("Rename packages");
 
     myFixture.checkResultByFile("a.go", "a-after.go", true);

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -359,7 +359,7 @@ public static Collection<Object> getSdkAndLibrariesCacheDependencies(@NotNull Ps
 
   @NotNull
   public static Collection<Object> getSdkAndLibrariesCacheDependencies(@NotNull Project project, @Nullable Module module, Object... extra) {
-    Collection<Object> dependencies = ContainerUtil.<Object>newArrayList(GoLibrariesService.getModificationTrackers(project, module));
+    Collection<Object> dependencies = ContainerUtil.newArrayList((Object[])GoLibrariesService.getModificationTrackers(project, module));
     ContainerUtil.addAllNotNull(dependencies, GoSdkService.getInstance(project));
     ContainerUtil.addAllNotNull(dependencies, extra);
     return dependencies;

File: src/com/goide/completion/GoKeywordCompletionContributor.java
Patch:
@@ -133,7 +133,7 @@ private static ElementPattern<? extends PsiElement> anonymousFunction() {
   private static PsiElementPattern.Capture<PsiElement> insideBlockPattern(@NotNull IElementType tokenType) {
     return onStatementBeginning(tokenType)
       .withParent(psiElement(GoExpression.class).withParent(psiElement(GoLeftHandExprList.class).withParent(
-        psiElement(GoStatement.class).withParent(GoBlock.class))));
+        psiElement(GoStatement.class).inside(GoBlock.class))));
   }
 
   private static PsiElementPattern.Capture<PsiElement> topLevelPattern() {
@@ -154,7 +154,7 @@ private static PsiElementPattern.Capture<PsiElement> packagePattern() {
   private static PsiElementPattern.Capture<PsiElement> onStatementBeginning(@NotNull IElementType... tokenTypes) {
     return psiElement().withElementType(TokenSet.create(tokenTypes))
       .afterLeafSkipping(psiElement().whitespaceCommentEmptyOrError().withoutText(string().containsChars("\n")),
-                         or(psiElement(GoTypes.SEMICOLON), psiElement(GoTypes.LBRACE),
+                         or(psiElement(GoTypes.SEMICOLON), psiElement(GoTypes.LBRACE), psiElement(GoTypes.COLON),
                             psiElement().withText(string().containsChars("\n"))));
   }
 

File: src/com/goide/codeInsight/imports/GoExcludePathLookupActionProvider.java
Patch:
@@ -27,6 +27,7 @@
 import com.intellij.openapi.options.ShowSettingsUtil;
 import com.intellij.openapi.project.Project;
 import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
 import com.intellij.util.Consumer;
 import com.intellij.util.containers.ContainerUtil;
 import org.jetbrains.annotations.NotNull;
@@ -37,9 +38,8 @@ public class GoExcludePathLookupActionProvider implements LookupActionProvider {
   @Override
   public void fillActions(LookupElement element, final Lookup lookup, Consumer<LookupElementAction> consumer) {
     PsiElement psiElement = element.getPsiElement();
-    if (psiElement == null) return;
-
-    String importPath = ((GoFile)psiElement.getContainingFile()).getImportPath();
+    PsiFile file = psiElement != null ? psiElement.getContainingFile() : null;
+    String importPath = file instanceof GoFile ? ((GoFile)file).getImportPath() : null;
     if (importPath != null) {
       Project project = psiElement.getProject();
       for (String path : getPaths(importPath)) {

File: src/com/goide/codeInsight/imports/GoExcludePathLookupActionProvider.java
Patch:
@@ -27,6 +27,7 @@
 import com.intellij.openapi.options.ShowSettingsUtil;
 import com.intellij.openapi.project.Project;
 import com.intellij.psi.PsiElement;
+import com.intellij.psi.PsiFile;
 import com.intellij.util.Consumer;
 import com.intellij.util.containers.ContainerUtil;
 import org.jetbrains.annotations.NotNull;
@@ -37,9 +38,8 @@ public class GoExcludePathLookupActionProvider implements LookupActionProvider {
   @Override
   public void fillActions(LookupElement element, final Lookup lookup, Consumer<LookupElementAction> consumer) {
     PsiElement psiElement = element.getPsiElement();
-    if (psiElement == null) return;
-
-    String importPath = ((GoFile)psiElement.getContainingFile()).getImportPath();
+    PsiFile file = psiElement != null ? psiElement.getContainingFile() : null;
+    String importPath = file instanceof GoFile ? ((GoFile)file).getImportPath() : null;
     if (importPath != null) {
       Project project = psiElement.getProject();
       for (String path : getPaths(importPath)) {

File: src/com/goide/runconfig/GoBuildingRunner.java
Patch:
@@ -69,7 +69,8 @@ public String getRunnerId() {
   @Override
   public boolean canRun(@NotNull String executorId, @NotNull RunProfile profile) {
     if (profile instanceof GoApplicationConfiguration) {
-      return DefaultRunExecutor.EXECUTOR_ID.equals(executorId) || DefaultDebugExecutor.EXECUTOR_ID.equals(executorId);
+      return DefaultRunExecutor.EXECUTOR_ID.equals(executorId) 
+             || DefaultDebugExecutor.EXECUTOR_ID.equals(executorId) && !DlvDebugProcess.isDlvDisabled();
     }
     return false;
   }

File: src/com/goide/runconfig/application/GoApplicationRunningState.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.goide.runconfig.application;
 
-import com.goide.dlv.DlvDebugProcess;
 import com.goide.runconfig.GoRunningState;
 import com.goide.util.GoExecutor;
 import com.goide.util.GoHistoryProcessListener;
@@ -59,7 +58,6 @@ public String getGoBuildParams() {
   }
 
   public boolean isDebug() {
-    if (DlvDebugProcess.isDlvDisabled()) return false;
     return DefaultDebugExecutor.EXECUTOR_ID.equals(getEnvironment().getExecutor().getId());
   }
 

File: src/com/goide/codeInsight/imports/GoCodeInsightSettings.java
Patch:
@@ -26,7 +26,7 @@
 )
 public class GoCodeInsightSettings implements PersistentStateComponent<GoCodeInsightSettings> {
   private boolean myShowImportPopup = true;
-  private boolean myAddUnambiguousImportsOnTheFly = false;
+  private boolean myAddUnambiguousImportsOnTheFly = true;
 
   public static GoCodeInsightSettings getInstance() {
     return ServiceManager.getService(GoCodeInsightSettings.class);

File: src/com/goide/inspections/GoNoNewVariablesInspection.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.goide.inspections;
 
-import com.goide.psi.GoForClause;
 import com.goide.psi.GoShortVarDeclaration;
 import com.goide.psi.GoVarDefinition;
 import com.goide.psi.GoVisitor;
@@ -25,7 +24,6 @@
 import com.intellij.openapi.util.TextRange;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.PsiReference;
-import com.intellij.psi.util.PsiTreeUtil;
 import com.intellij.util.containers.ContainerUtil;
 import org.jetbrains.annotations.NotNull;
 
@@ -40,7 +38,7 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
       @Override
       public void visitShortVarDeclaration(@NotNull GoShortVarDeclaration o) {
         List<GoVarDefinition> list = o.getVarDefinitionList();
-        if (list.isEmpty() || PsiTreeUtil.getParentOfType(o, GoForClause.class) != null) return;
+        if (list.isEmpty()) return;
 
         GoVarDefinition first = ContainerUtil.getFirstItem(list);
         GoVarDefinition last = ContainerUtil.getLastItem(list);

File: src/com/goide/codeInsight/imports/GoCodeInsightSettings.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.intellij.openapi.components.*;
 import com.intellij.openapi.util.SimpleModificationTracker;
+import com.intellij.openapi.util.io.FileUtil;
 import com.intellij.util.ArrayUtil;
 import com.intellij.util.xmlb.XmlSerializerUtil;
 import org.jetbrains.annotations.NotNull;
@@ -74,7 +75,7 @@ public void setExcludedPackages(String... excludedPackages) {
 
   public boolean isExcluded(@NotNull String importPath) {
     for (String excludedPath : myExcludedPackages) {
-      if (importPath.startsWith(excludedPath)) return true;
+      if (FileUtil.isAncestor(excludedPath, importPath, false)) return true;
     }
     return false;
   }

File: src/com/goide/inspections/GoNoNewVariablesInspection.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.goide.inspections;
 
+import com.goide.psi.GoForClause;
 import com.goide.psi.GoShortVarDeclaration;
 import com.goide.psi.GoVarDefinition;
 import com.goide.psi.GoVisitor;
@@ -24,6 +25,7 @@
 import com.intellij.openapi.util.TextRange;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.PsiReference;
+import com.intellij.psi.util.PsiTreeUtil;
 import com.intellij.util.containers.ContainerUtil;
 import org.jetbrains.annotations.NotNull;
 
@@ -38,7 +40,7 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
       @Override
       public void visitShortVarDeclaration(@NotNull GoShortVarDeclaration o) {
         List<GoVarDefinition> list = o.getVarDefinitionList();
-        if (list.isEmpty()) return;
+        if (list.isEmpty() || PsiTreeUtil.getParentOfType(o, GoForClause.class) != null) return;
 
         GoVarDefinition first = ContainerUtil.getFirstItem(list);
         GoVarDefinition last = ContainerUtil.getLastItem(list);

File: src/com/goide/inspections/GoNoNewVariablesInspection.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.goide.inspections;
 
+import com.goide.psi.GoForClause;
 import com.goide.psi.GoShortVarDeclaration;
 import com.goide.psi.GoVarDefinition;
 import com.goide.psi.GoVisitor;
@@ -24,6 +25,7 @@
 import com.intellij.openapi.util.TextRange;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.PsiReference;
+import com.intellij.psi.util.PsiTreeUtil;
 import com.intellij.util.containers.ContainerUtil;
 import org.jetbrains.annotations.NotNull;
 
@@ -38,7 +40,7 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
       @Override
       public void visitShortVarDeclaration(@NotNull GoShortVarDeclaration o) {
         List<GoVarDefinition> list = o.getVarDefinitionList();
-        if (list.isEmpty()) return;
+        if (list.isEmpty() || PsiTreeUtil.getParentOfType(o, GoForClause.class) != null) return;
 
         GoVarDefinition first = ContainerUtil.getFirstItem(list);
         GoVarDefinition last = ContainerUtil.getLastItem(list);

File: tests/com/goide/quickfix/GoQuickFixTestBase.java
Patch:
@@ -34,7 +34,7 @@ protected void doTest(@NotNull String quickFixName) {
     myFixture.configureByFile(testName + ".go");
     applySingleQuickFix(quickFixName);
     String after = String.format("%s-after.go", testName);
-    myFixture.checkResultByFile(after);
+    myFixture.checkResultByFile(after, true);
   }
 
   protected void applySingleQuickFix(@NotNull String quickFixName) {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -103,6 +103,7 @@ protected boolean isWriteActionRequired() {
   public void testForRange()    { doTest(); }
   public void testMismatch()    { doTest(); }
   public void testStubParams()  { doTest(); }
+  public void testNil()         { doTest(); }
   public void testAssignmentUsages()  { doTest(); }
 
   public void testRelativeImportIgnoringDirectories() throws IOException {

File: src/com/goide/psi/GoFile.java
Patch:
@@ -431,7 +431,7 @@ public GoFileStub getStub() {
   }
 
   public boolean hasCPathImport() {
-    return getImportedPackagesMap().keySet().contains(GoConstants.C_PATH);
+    return getImportMap().containsKey(GoConstants.C_PATH);
   }
 
   private static boolean processChildrenDummyAware(@NotNull GoFile file, @NotNull final Processor<PsiElement> processor) {

File: src/com/goide/inspections/GoInspectionUtil.java
Patch:
@@ -97,7 +97,7 @@ public static void checkExpressionShouldReturnOneResult(@NotNull List<GoExpressi
           text = ((GoCallExpr)expr).getExpression().getText();
         }
 
-        String msg = "Multiple-value " + text + "() in single-value context";
+        String msg = count == 0 ? text + "() doesn't return a value" : "Multiple-value " + text + "() in single-value context";
         result.registerProblem(expr, msg, ProblemHighlightType.GENERIC_ERROR);
       }
     }

File: src/com/goide/dlv/protocol/Api.java
Patch:
@@ -73,8 +73,7 @@ public static class Function {
     // Name is the function name.
     public String name; //`json:"name"`
     public int value; //`json:"value"`
-    @SerializedName("class")
-    public byte clazz; //`json:"class"`
+    public byte type; //`json:"type"`
     public int goclass; //`json:"goclass"`
     // Args are the function arguments in a thread context.
     public List<Variable> args; //`json:"args"`

File: src/com/goide/dlv/DlvDebugProcess.java
Patch:
@@ -327,19 +327,19 @@ public void computeChildren(@NotNull final XCompositeNode node) {
             public void consume(List<Api.Variable> variables) {
               XValueChildrenList xVars = new XValueChildrenList(variables.size());
               for (Api.Variable v : variables) {
-                xVars.add(v.name, getVariableValue(v.name, v.value, v.clazz));
+                xVars.add(v.name, getVariableValue(v.name, v.value, v.type));
               }
               node.addChildren(xVars, true);
             }
           });
           varPromise.rejected(THROWABLE_CONSUMER);
         }
 
-        private static XValue getVariableValue(String name, final String value, final String clazz) {
+        private static XValue getVariableValue(String name, final String value, final String type) {
           return new XNamedValue(name) {
             @Override
             public void computePresentation(@NotNull XValueNode node, @NotNull XValuePlace place) {
-              node.setPresentation(GoIcons.VARIABLE, clazz, value, false);
+              node.setPresentation(GoIcons.VARIABLE, type, value, false);
             }
           };
         }

File: src/com/goide/dlv/protocol/Api.java
Patch:
@@ -86,8 +86,7 @@ public class Function {
   public class Variable {
     public String name; //`json:"name"`
     public String value; //`json:"value"`
-    @SerializedName("class")
-    public String clazz; //`json:"class"`
+    public String type; //`json:"type"`
   }
 
   // Goroutine represents the information relevant to Delve from the runtime's

File: utils/src/com/goide/GoConstants.java
Patch:
@@ -62,6 +62,7 @@ public class GoConstants {
   @NonNls public static final String GAE_EXECUTABLE_NAME = "goapp";
   @NonNls public static final String GAE_BAT_EXECUTABLE_NAME = "goapp.bat";
   @NonNls public static final String GAE_CMD_EXECUTABLE_NAME = "goapp.cmd";
+  @NonNls public static final String DELVE_EXECUTABLE_NAME = "dlv";
 
   @NonNls public static final String GO_EXECUTABLE_NAME = "go";
   public static final String BUILD_FLAG = "+build";

File: src/com/goide/dlv/DlvDebugProcess.java
Patch:
@@ -92,7 +92,7 @@ public void addBreakpoint(@NotNull final XLineBreakpoint<DlvLineBreakpointProper
     VirtualFile file = breakpointPosition.getFile();
     int line = breakpointPosition.getLine();
     DlvVm vm = (DlvVm)getVm();
-    Promise<Breakpoint> promise = vm.getCommandProcessor().send(new DlvSetBreakpoint(file.getCanonicalPath(), line));
+    Promise<Breakpoint> promise = vm.getCommandProcessor().send(new DlvSetBreakpoint(file.getCanonicalPath(), line + 1));
     promise.processed(new Consumer<Breakpoint>() {
       @Override
       public void consume(Breakpoint b) {

File: src/com/goide/runconfig/GoRunUtil.java
Patch:
@@ -76,8 +76,9 @@ public static PsiElement getContextElement(@Nullable ConfigurationContext contex
 
     FileIndexFacade indexFacade = FileIndexFacade.getInstance(psiElement.getProject());
     PsiFileSystemItem psiFile = psiElement instanceof PsiFileSystemItem ? (PsiFileSystemItem)psiElement : psiElement.getContainingFile();
-    VirtualFile file = psiFile.getVirtualFile();
-    if (file.getFileType() != ScratchFileType.INSTANCE && (!indexFacade.isInContent(file) || indexFacade.isExcludedFile(file))) {
+    VirtualFile file = psiFile != null ? psiFile.getVirtualFile() : null;
+    if (file != null && file.getFileType() != ScratchFileType.INSTANCE && 
+        (!indexFacade.isInContent(file) || indexFacade.isExcludedFile(file))) {
       return null;
     }
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -412,7 +412,7 @@ public boolean value(GoTypeSpec spec) {
         }
       });
       if (spec != null) {
-        return spec.getSpecType(); // todo
+        return spec.getSpecType().getType(); // todo
       }
     }
     return null;

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -202,7 +202,7 @@ public static LookupElement createTypeConversionLookupElement(@NotNull GoTypeSpe
 
   @NotNull
   public static InsertHandler<LookupElement> getTypeConversionInsertHandler(@NotNull GoTypeSpec t) {
-    GoType type = t.getType();
+    GoType type = t.getSpecType().getType();
     return type instanceof GoStructType || type instanceof GoArrayOrSliceType || type instanceof GoMapType
            ? BracesInsertHandler.ONE_LINER
            : ParenthesesInsertHandler.WITH_PARAMETERS;

File: src/com/goide/completion/GoKeywordCompletionContributor.java
Patch:
@@ -116,7 +116,7 @@ private static ElementPattern<? extends PsiElement> insideSwitchStatement() {
 
   private static ElementPattern<? extends PsiElement> typeDeclaration() {
     return psiElement(GoTypes.IDENTIFIER)
-      .withParent(psiElement(GoTypeReferenceExpression.class).withParent(psiElement(GoType.class).withParent(GoTypeSpec.class)));
+      .withParent(psiElement(GoTypeReferenceExpression.class).withParent(psiElement(GoType.class).withParent(GoSpecType.class)));
   }
 
   private static PsiElementPattern.Capture<PsiElement> insideGoOrDeferStatements(@NotNull IElementType tokenType) {

File: src/com/goide/editor/GoFoldingBuilder.java
Patch:
@@ -71,7 +71,7 @@ public FoldingDescriptor[] buildFoldRegions(@NotNull PsiElement root, @NotNull D
     }
 
     for (GoTypeSpec type : file.getTypes()) {
-      foldTypes(type.getType(), result);
+      foldTypes(type.getSpecType().getType(), result);
     }
 
     if (!quick) {

File: src/com/goide/psi/impl/GoFieldNameReference.java
Patch:
@@ -65,12 +65,12 @@ public boolean execute(@NotNull PsiElement psiElement, @NotNull ResolveState res
   }
 
   @Nullable
-  private GoType getType(GoType type) { // todo: rethink and unify this algorithm
+  private GoType getType(@Nullable GoType type) { // todo: rethink and unify this algorithm
     boolean inValue = myValue != null;
     
     if (inValue && type instanceof GoArrayOrSliceType) type = ((GoArrayOrSliceType)type).getType();
     else if (type instanceof GoMapType) type = inValue ? ((GoMapType)type).getValueType() : ((GoMapType)type).getKeyType();
-    else if (inValue && type instanceof GoStructType) {
+    else if (inValue && type instanceof GoSpecType && ((GoSpecType)type).getType() instanceof GoStructType) {
       GoKey key = PsiTreeUtil.getPrevSiblingOfType(myValue, GoKey.class);
       GoFieldName field = key != null ? key.getFieldName() : null;
       PsiReference reference = field != null ? field.getReference() : null;
@@ -91,7 +91,7 @@ else if (inValue && type instanceof GoStructType) {
       }
     }
 
-    return type;
+    return type instanceof GoSpecType ? ((GoSpecType)type).getType() : type;
   }
 
   @Nullable

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -49,8 +49,7 @@
 
 import javax.swing.*;
 
-public abstract class GoNamedElementImpl<T extends GoNamedStub<?>> extends GoStubbedElementImpl<T>
-  implements GoCompositeElement, GoNamedElement {
+public abstract class GoNamedElementImpl<T extends GoNamedStub<?>> extends GoStubbedElementImpl<T> implements GoCompositeElement, GoNamedElement {
 
   public GoNamedElementImpl(@NotNull T stub, @NotNull IStubElementType nodeType) {
     super(stub, nodeType);

File: src/com/goide/psi/impl/GoTypeReference.java
Patch:
@@ -175,7 +175,7 @@ private boolean processNamedElements(@NotNull PsiScopeProcessor processor,
   }
 
   public boolean allowed(@NotNull GoTypeSpec definition) {
-    return !myInsideInterfaceType || (definition.getType() instanceof GoInterfaceType);
+    return !myInsideInterfaceType || (definition.getSpecType().getType() instanceof GoInterfaceType);
   }
 
   @Override

File: src/com/goide/stubs/GoStubElementTypeFactory.java
Patch:
@@ -40,6 +40,7 @@ public class GoStubElementTypeFactory {
       put("STRUCT_TYPE", GoStructTypeImpl.class);
       put("TYPE", GoTypeImpl.class);
       put("PAR_TYPE", GoParTypeImpl.class);
+      put("SPEC_TYPE", GoSpecTypeImpl.class);
       put("TYPE_LIST", GoTypeListImpl.class);
     }
   };

File: src/com/goide/tree/GoStructureViewFactory.java
Patch:
@@ -196,7 +196,7 @@ public TreeElement[] getChildren() {
       }
       else if (myElement instanceof GoTypeSpec) {
         GoTypeSpec typeSpec = (GoTypeSpec)myElement;
-        GoType type = (typeSpec).getType();
+        GoType type = typeSpec.getSpecType().getType();
         for (GoMethodDeclaration m : GoPsiImplUtil.getMethods(typeSpec)) result.add(new Element(m));
         if (type instanceof GoStructType) {
           for (GoFieldDeclaration field : ((GoStructType)type).getFieldDeclarationList()) {
@@ -223,10 +223,10 @@ else if (myElement instanceof GoNamedSignatureOwner) {
         return (id != null ? id.getText() : "") + signatureText;
       }
       else if (myElement instanceof GoTypeSpec) {
-        GoType type = ((GoTypeSpec)myElement).getType();
+        GoType type = ((GoTypeSpec)myElement).getSpecType().getType();
         String appendix = type instanceof GoStructType || type instanceof GoInterfaceType ?
                           "" :
-                          (type != null ? separator + GoPsiImplUtil.getText(type) : "");
+                          separator + GoPsiImplUtil.getText(type);
         return ((GoTypeSpec)myElement).getName() + appendix;
       }
       else if (myElement instanceof GoNamedElement) {

File: src/com/goide/inspections/GoInspectionUtil.java
Patch:
@@ -29,8 +29,8 @@ public class GoInspectionUtil {
   public static final int UNKNOWN_COUNT = -1;
 
   public static int getExpressionResultCount(GoExpression call) {
-    if (call instanceof GoLiteral || call instanceof GoBinaryExpr || call instanceof GoParenthesesExpr ||
-        (call instanceof GoUnaryExpr && ((GoUnaryExpr)call).getSendChannel() == null)) {
+    if (call instanceof GoLiteral || call instanceof GoStringLiteral || call instanceof GoBinaryExpr || call instanceof GoParenthesesExpr ||
+        (call instanceof GoUnaryExpr && ((GoUnaryExpr)call).getSendChannel() == null) || call instanceof GoBuiltinCallExpr) {
       return 1;
     }
     else if (call instanceof GoTypeAssertionExpr) {

File: src/com/goide/inspections/GoInspectionUtil.java
Patch:
@@ -30,7 +30,7 @@ public class GoInspectionUtil {
 
   public static int getExpressionResultCount(GoExpression call) {
     if (call instanceof GoLiteral || call instanceof GoBinaryExpr || call instanceof GoParenthesesExpr ||
-        (call instanceof GoUnaryExpr && ((GoUnaryExpr)call).getSendChannel() == null)) {
+        (call instanceof GoUnaryExpr && ((GoUnaryExpr)call).getSendChannel() == null) || call instanceof GoBuiltinCallExpr) {
       return 1;
     }
     else if (call instanceof GoTypeAssertionExpr) {

File: tests/com/goide/psi/legacy/GoLegacyResolveCallsTest.java
Patch:
@@ -55,4 +55,6 @@ public class GoLegacyResolveCallsTest extends GoLegacyResolveTestBase {
   public void testCallToMethodViaShortVar()                              { doDirTest(); } 
   public void testImportedEmbeddedTypeMethod()                           { doDirTest(); } 
   public void testCallToMethodWithTheSameNameAsFunctionAcrossPackages()  { doDirTest(); }
+  public void testCallFromTestToMethodDefinedInTestFile()                { doDirTest(); }
+  public void testCallToMethodDefinedInTestFile()                        { doDirTest(); }
 }

File: tests/com/goide/psi/legacy/GoLegacyResolvePackageTest.java
Patch:
@@ -20,5 +20,5 @@ public class GoLegacyResolvePackageTest extends GoLegacyResolveTestBase {
   @Override
   protected String getBasePath() { return "psi/resolve/package"; }
 
-  public void testAliasedImport() { doFileTest(); } 
+  public void testImportAlias() { doFileTest(); } 
 }

File: src/com/goide/inspections/unresolved/GoUnusedFunctionInspection.java
Patch:
@@ -24,6 +24,7 @@
 import com.goide.psi.GoFunctionDeclaration;
 import com.goide.psi.GoVisitor;
 import com.goide.runconfig.testing.GoTestFinder;
+import com.goide.runconfig.testing.GoTestFunctionType;
 import com.intellij.codeInspection.LocalInspectionToolSession;
 import com.intellij.codeInspection.ProblemHighlightType;
 import com.intellij.codeInspection.ProblemsHolder;
@@ -47,7 +48,7 @@ public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
         String name = o.getName();
         if (GoConstants.MAIN.equals(file.getPackageName()) && GoConstants.MAIN.equals(name)) return;
         if (GoConstants.INIT.equals(name)) return;
-        if (GoTestFinder.isTestFile(file) && (GoTestFinder.isTestFunctionName(name) || GoTestFinder.isBenchmarkFunctionName(name))) return;
+        if (GoTestFinder.isTestFile(file) && GoTestFunctionType.fromName(name) != null) return;
         Query<PsiReference> search = ReferencesSearch.search(o, o.getUseScope());
         if (search.findFirst() == null) {
           PsiElement id = o.getIdentifier();

File: src/com/goide/runconfig/testing/GoTestRunConfigurationProducerBase.java
Patch:
@@ -158,6 +158,6 @@ public boolean isConfigurationFromContext(@NotNull GoTestRunConfiguration config
   @Nullable
   private static GoFunctionOrMethodDeclaration findTestFunctionInContext(@NotNull PsiElement contextElement) {
     GoFunctionOrMethodDeclaration function = PsiTreeUtil.getNonStrictParentOfType(contextElement, GoFunctionOrMethodDeclaration.class);
-    return function != null && GoTestFinder.isTestFunctionName(function.getName()) ? function : null;
+    return function != null && GoTestFunctionType.fromName(function.getName()) == GoTestFunctionType.TEST ? function : null;
   }
 }

File: src/com/goide/runconfig/GoBuildingRunner.java
Patch:
@@ -68,7 +68,7 @@ protected Promise<RunProfileStarter> prepare(@NotNull ExecutionEnvironment envir
     String configurationName = settings != null ? settings.getName() : "application";
     if (StringUtil.isEmpty(outputDirectoryPath)) {
       try {
-        outputFile = FileUtil.createTempFile(configurationName, "go", true);
+        outputFile = FileUtil.createTempFile(configurationName, GoEnvironmentUtil.getBinaryFileNameForPath("go"), true);
       }
       catch (IOException e) {
         throw new ExecutionException("Cannot create temporary output file", e);

File: src/com/goide/configuration/GoLibrariesConfigurable.java
Patch:
@@ -48,7 +48,7 @@
 
 public class GoLibrariesConfigurable implements SearchableConfigurable, Configurable.NoScroll {
   @NotNull private final String myDisplayName;
-  private final GoLibrariesService myLibrariesService;
+  private final GoLibrariesService<?> myLibrariesService;
   private final String[] myReadOnlyPaths;
   private final JBCheckBox myUseEnvGoPathCheckBox = new JBCheckBox("Use GOPATH that's defined in system environment");
   private final JPanel myPanel = new JPanel(new BorderLayout());

File: src/com/goide/project/GoModuleLibrariesService.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2014 Sergey Ignatov, Alexander Zolotov, Mihai Toader
+ * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Mihai Toader, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package com.goide.project;
 
 import com.goide.GoConstants;
+import com.goide.GoLibrariesState;
 import com.intellij.openapi.components.State;
 import com.intellij.openapi.components.Storage;
 import com.intellij.openapi.components.StoragePathMacros;
@@ -28,7 +29,7 @@
   name = GoConstants.GO_LIBRARIES_SERVICE_NAME,
   storages = @Storage(file = StoragePathMacros.MODULE_FILE)
 )
-public class GoModuleLibrariesService extends GoLibrariesService {
+public class GoModuleLibrariesService extends GoLibrariesService<GoLibrariesState> {
   public static GoModuleLibrariesService getInstance(@NotNull Module module) {
     return ModuleServiceManager.getService(module, GoModuleLibrariesService.class);
   }

File: src/com/goide/actions/GoCreateFileAction.java
Patch:
@@ -42,8 +42,9 @@ public class GoCreateFileAction extends CreateFileFromTemplateAction implements
 
   @Override
   protected PsiFile createFile(String name, @NotNull String templateName, @NotNull PsiDirectory dir) {
-    FileTemplate template = FileTemplateManager.getInstance(dir.getProject()).getInternalTemplate(templateName);
-    Properties properties = new Properties();
+    FileTemplateManager templateManager = FileTemplateManager.getInstance(dir.getProject());
+    FileTemplate template = templateManager.getInternalTemplate(templateName);
+    Properties properties = templateManager.getDefaultProperties();
     String packageName = ContainerUtil.getFirstItem(GoUtil.getAllPackagesInDirectory(dir, true));
     if (packageName == null) {
       packageName = GoPsiImplUtil.getLocalPackageName(dir.getName());

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -546,6 +546,9 @@ public static GoType getGoTypeInner(@NotNull GoVarDefinition o, @Nullable Resolv
     if (parent instanceof GoTypeSwitchGuard) {
       SmartPsiElementPointer<GoReferenceExpressionBase> pointer = context == null ? null : context.get(GoReference.CONTEXT);
       GoTypeCaseClause typeCase = PsiTreeUtil.getParentOfType(pointer != null ? pointer.getElement() : null, GoTypeCaseClause.class);
+      if (typeCase != null && typeCase.getDefault() != null) {
+        return ((GoTypeSwitchGuard)parent).getExpression().getGoType(context);  
+      }
       return typeCase != null ? typeCase.getType() : null;
     }
     return null;

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -111,11 +111,12 @@ public PsiElement setName(@NonNls @NotNull String newName) throws IncorrectOpera
   @Nullable
   @Override
   public GoType getGoType(@Nullable final ResolveState context) {
+    if (context != null) return getGoTypeInner(context);
     return CachedValuesManager.getCachedValue(this, new CachedValueProvider<GoType>() {
       @Nullable
       @Override
       public Result<GoType> compute() {
-        return Result.create(getGoTypeInner(context), PsiModificationTracker.MODIFICATION_COUNT);
+        return Result.create(getGoTypeInner(null), PsiModificationTracker.MODIFICATION_COUNT);
       }
     });
   }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -300,11 +300,12 @@ private static GoType findTypeInConstSpec(@NotNull GoConstDefinition o) {
 
   @Nullable
   public static GoType getGoType(@NotNull final GoExpression o, @Nullable final ResolveState context) {
+    if (context != null) return getGoTypeInner(o, context);
     return CachedValuesManager.getCachedValue(o, new CachedValueProvider<GoType>() {
       @Nullable
       @Override
       public Result<GoType> compute() {
-        return Result.create(getGoTypeInner(o, context), PsiModificationTracker.MODIFICATION_COUNT);
+        return Result.create(getGoTypeInner(o, null), PsiModificationTracker.MODIFICATION_COUNT);
       }
     });
   }

File: src/com/goide/inspections/GoMultiplePackagesInspection.java
Patch:
@@ -22,6 +22,7 @@
 import com.goide.util.GoUtil;
 import com.intellij.codeInspection.LocalQuickFix;
 import com.intellij.codeInspection.ProblemsHolder;
+import com.intellij.ide.scratch.ScratchFileType;
 import com.intellij.psi.PsiDirectory;
 import com.intellij.util.containers.ContainerUtil;
 import org.jetbrains.annotations.NotNull;
@@ -32,7 +33,7 @@ public class GoMultiplePackagesInspection extends GoInspectionBase {
 
   @Override
   protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsHolder) {
-    if (!GoUtil.allowed(file)) return;
+    if (GoUtil.directoryToIgnore(file.getName()) || ((ScratchFileType)ScratchFileType.INSTANCE).isMyFileType(file.getVirtualFile())) return;
     GoPackageClause packageClause = file.getPackage();
     if (packageClause != null) {
       String packageName = file.getPackageName();

File: src/com/goide/psi/impl/GoTypeProcessor.java
Patch:
@@ -16,13 +16,14 @@
 
 package com.goide.psi.impl;
 
+import com.goide.psi.GoTypeReferenceExpression;
 import com.goide.psi.GoTypeSpec;
 import com.intellij.psi.PsiElement;
 import org.jetbrains.annotations.NotNull;
 
 public class GoTypeProcessor extends GoScopeProcessorBase {
-  public GoTypeProcessor(String requestedName, PsiElement origin, boolean completion) {
-    super(requestedName, origin, completion);
+  public GoTypeProcessor(@NotNull GoTypeReferenceExpression origin, boolean completion) {
+    super(origin.getIdentifier().getText(), origin, completion);
   }
 
   @Override

File: tests/com/goide/quickfix/GoMultiplePackagesQuickFixTest.java
Patch:
@@ -31,6 +31,7 @@ protected String getBasePath() {
   }
 
   public void testMultiplePackagesQuickFix() {
+    myFixture.configureByFile("c_test.go");
     myFixture.configureByFile("b.go");
     myFixture.configureByFile("b_test.go");
     myFixture.configureByFile("a.go");
@@ -40,5 +41,6 @@ public void testMultiplePackagesQuickFix() {
     myFixture.checkResultByFile("a.go", "a-after.go", true);
     myFixture.checkResultByFile("b.go", "b-after.go", true);
     myFixture.checkResultByFile("b_test.go", "b_test-after.go", true);
+    myFixture.checkResultByFile("c_test.go", "c_test-after.go", true);
   }
 }

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -253,7 +253,7 @@ private Indent calcIndent(@NotNull ASTNode child) {
       if (parentType == BLOCK && type == SELECT_STATEMENT) return Indent.getNoneIndent();
       if (parentType == SELECT_STATEMENT && type == RBRACE) return Indent.getNormalIndent();
       if (parentType == ARGUMENT_LIST && type != LPAREN && type != RPAREN) return Indent.getNormalIndent();
-      if ((parentType == EXPR_CASE_CLAUSE || parentType == TYPE_CASE_CLAUSE) && (type == CASE || type == TYPE_SWITCH_CASE || type == DEFAULT)) return Indent.getNoneIndent();
+      if ((parentType == EXPR_CASE_CLAUSE || parentType == TYPE_CASE_CLAUSE) && (type == CASE || type == DEFAULT)) return Indent.getNoneIndent();
       if (BLOCKS_TOKEN_SET.contains(parentType)) return indentIfNotBrace(child);
       if (parentType == IMPORT_DECLARATION && type == IMPORT_SPEC) return Indent.getNormalIndent();
       if (parentType == CONST_DECLARATION && type == CONST_SPEC) return Indent.getNormalIndent();

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -545,8 +545,7 @@ public static GoType getGoTypeInner(@NotNull GoVarDefinition o, @Nullable Resolv
     if (parent instanceof GoTypeSwitchGuard) {
       SmartPsiElementPointer<GoReferenceExpressionBase> pointer = context == null ? null : context.get(GoReference.CONTEXT);
       GoTypeCaseClause typeCase = PsiTreeUtil.getParentOfType(pointer != null ? pointer.getElement() : null, GoTypeCaseClause.class);
-      GoTypeSwitchCase switchCase = typeCase != null ? typeCase.getTypeSwitchCase() : null;
-      return switchCase != null ? switchCase.getType() : null;
+      return typeCase != null ? typeCase.getType() : null;
     }
     return null;
   }

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -14,6 +14,7 @@ protected String getBasePath() {
   public void testSimple()      { doTest(); }
   public void testCaseE()       { doTest('e'); }
   public void testCaseEnter()   { doTestEnter(); }
+  public void testCase2Enter()  { doTestEnter(); }
   public void testSwitchEnter() { doTestEnter(); }
   public void testTypeEnter()   { doTestEnter(); }
 

File: src/com/goide/inspections/GoDuplicateMethodInspection.java
Patch:
@@ -21,6 +21,7 @@
 import com.goide.psi.impl.GoPsiImplUtil;
 import com.goide.stubs.index.GoMethodIndex;
 import com.goide.stubs.types.GoMethodDeclarationStubElementType;
+import com.goide.util.GoUtil;
 import com.intellij.codeInspection.ProblemsHolder;
 import com.intellij.openapi.project.Project;
 import com.intellij.openapi.util.Comparing;
@@ -35,6 +36,7 @@
 public class GoDuplicateMethodInspection extends GoInspectionBase {
   @Override
   protected void checkFile(@NotNull GoFile file, @NotNull final ProblemsHolder problemsHolder) {
+    if (!GoUtil.allowed(file)) return;
     final Project project = file.getProject();
     final String packageName = file.getPackageName();
     final GlobalSearchScope scope = GoPsiImplUtil.packageScope(file);
@@ -52,7 +54,7 @@ protected void checkFile(@NotNull GoFile file, @NotNull final ProblemsHolder pro
       declarations = ContainerUtil.filter(declarations, new Condition<GoMethodDeclaration>() {
         @Override
         public boolean value(GoMethodDeclaration d) {
-          return !method.isEquivalentTo(d) && Comparing.equal(d.getName(), methodName);
+          return !method.isEquivalentTo(d) && Comparing.equal(d.getName(), methodName) && GoUtil.allowed(d.getContainingFile());
         }
       });
 

File: src/com/goide/configuration/GoLibrariesConfigurableProvider.java
Patch:
@@ -97,7 +97,7 @@ public JComponent createComponent() {
           }
         }
         if (dialogMode) {
-          rootPanel.setPreferredSize(new Dimension(400, -1));
+          rootPanel.setPreferredSize(new Dimension(400, 600));
         }
         rootPanel.revalidate();
         return rootPanel;

File: tests/com/goide/editor/GoParameterInfoHandlerTest.java
Patch:
@@ -48,6 +48,7 @@ protected void setUp() throws Exception {
   public void testMethParamEllipsis() { doTest(5, "<html>num int, text string, <b>more ...int</b></html>"); }
   public void testFieldMethCall()     { doTest(0, "<html><b>a int</b>, b int</html>"); }
   public void testClosure()           { doTest(1, "<html>param1 string, <b>param2 string</b></html>"); }
+  public void testFuncTypes()         { doTest(0, "<html><b>string</b></html>"); }
 
   private void doTest(int expectedParamIdx, String expectedPresentation) {
     // Given

File: gen/com/goide/psi/GoFunctionType.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoFunctionType extends GoType {
+public interface GoFunctionType extends GoType, GoSignatureOwner {
 
   @Nullable
   GoSignature getSignature();

File: gen/com/goide/psi/GoVisitor.java
Patch:
@@ -154,6 +154,7 @@ public void visitFunctionLit(@NotNull GoFunctionLit o) {
 
   public void visitFunctionType(@NotNull GoFunctionType o) {
     visitType(o);
+    // visitSignatureOwner(o);
   }
 
   public void visitGoStatement(@NotNull GoGoStatement o) {

File: tests/com/goide/completion/GoCompletionSdkAwareTest.java
Patch:
@@ -301,7 +301,7 @@ public void testDoNotCompleteExampleFunctions() throws IOException {
   
   public void testCompleteTestBenchmarkExamplesFromNonTestFiles() throws IOException {
     myFixture.getTempDirFixture().createFile("pack/pack.go", "package pack; func TestFoo() {} func BenchmarkFoo() {} func ExampleFoo() {}");
-    myFixture.configureByText("my_test.go", "package a; func main() { _ = <caret>");
+    myFixture.configureByText("my_test.go", "package a; func main() { _ = Foo<caret>");
     myFixture.completeBasic();
     assertContainsElements(myFixture.getLookupElementStrings(), "pack.TestFoo", "pack.BenchmarkFoo", "pack.ExampleFoo");
   }

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -60,4 +60,5 @@ protected void setUp() throws Exception {
   public void testBlockRecover()                    { doTest(false); }
   public void testMethodWithoutReceiverIdentifier() { doTest(false); }
   public void testExpressionPerformance()           { doTest(false); }
+  public void testElementRecover()                  { doTest(false); }
 }

File: src/com/goide/tree/GoStructureViewFactory.java
Patch:
@@ -216,10 +216,10 @@ else if (type instanceof GoInterfaceType) {
     public String getPresentableText() {
       String separator = ": ";      
       if (myElement instanceof GoFile) return ((GoFile)myElement).getName();
-      else if (myElement instanceof GoFunctionOrMethodDeclaration) {
-        GoSignature signature = ((GoFunctionOrMethodDeclaration)myElement).getSignature();
+      else if (myElement instanceof GoNamedSignatureOwner) {
+        GoSignature signature = ((GoNamedSignatureOwner)myElement).getSignature();
         String signatureText = signature != null ? signature.getText() : "";
-        PsiElement id = ((GoFunctionOrMethodDeclaration)myElement).getIdentifier();
+        PsiElement id = ((GoNamedSignatureOwner)myElement).getIdentifier();
         return (id != null ? id.getText() : "") + signatureText;
       }
       else if (myElement instanceof GoTypeSpec) {

File: gen/com/goide/psi/GoAnonymousFieldDefinition.java
Patch:
@@ -25,6 +25,6 @@ public interface GoAnonymousFieldDefinition extends GoNamedElement, StubBasedPsi
   int getTextOffset();
 
   @Nullable
-  GoType getGoType(ResolveState context);
+  GoType getGoTypeInner(ResolveState context);
 
 }

File: gen/com/goide/psi/GoConstDefinition.java
Patch:
@@ -14,6 +14,6 @@ public interface GoConstDefinition extends GoNamedElement, StubBasedPsiElement<G
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType(ResolveState context);
+  GoType getGoTypeInner(ResolveState context);
 
 }

File: gen/com/goide/psi/GoMethodSpec.java
Patch:
@@ -20,7 +20,7 @@ public interface GoMethodSpec extends GoNamedSignatureOwner, StubBasedPsiElement
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType(ResolveState context);
+  GoType getGoTypeInner(ResolveState context);
 
   @Nullable
   String getName();

File: gen/com/goide/psi/GoReceiver.java
Patch:
@@ -29,6 +29,6 @@ public interface GoReceiver extends GoNamedElement, StubBasedPsiElement<GoReceiv
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType(ResolveState context);
+  GoType getGoTypeInner(ResolveState context);
 
 }

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -17,7 +17,7 @@ public interface GoTypeSpec extends GoNamedElement, StubBasedPsiElement<GoTypeSp
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType(ResolveState context);
+  GoType getGoTypeInner(ResolveState context);
 
   @NotNull
   List<GoMethodDeclaration> getMethods();

File: gen/com/goide/psi/GoVarDefinition.java
Patch:
@@ -15,7 +15,7 @@ public interface GoVarDefinition extends GoNamedElement, StubBasedPsiElement<GoV
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType(ResolveState context);
+  GoType getGoTypeInner(ResolveState context);
 
   @Nullable
   PsiReference getReference();

File: gen/com/goide/psi/impl/GoAnonymousFieldDefinitionImpl.java
Patch:
@@ -55,8 +55,8 @@ public int getTextOffset() {
   }
 
   @Nullable
-  public GoType getGoType(ResolveState context) {
-    return GoPsiImplUtil.getGoType(this, context);
+  public GoType getGoTypeInner(ResolveState context) {
+    return GoPsiImplUtil.getGoTypeInner(this, context);
   }
 
 }

File: gen/com/goide/psi/impl/GoConstDefinitionImpl.java
Patch:
@@ -35,8 +35,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType(ResolveState context) {
-    return GoPsiImplUtil.getGoType(this, context);
+  public GoType getGoTypeInner(ResolveState context) {
+    return GoPsiImplUtil.getGoTypeInner(this, context);
   }
 
 }

File: gen/com/goide/psi/impl/GoMethodSpecImpl.java
Patch:
@@ -47,8 +47,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType(ResolveState context) {
-    return GoPsiImplUtil.getGoType(this, context);
+  public GoType getGoTypeInner(ResolveState context) {
+    return GoPsiImplUtil.getGoTypeInner(this, context);
   }
 
   @Nullable

File: gen/com/goide/psi/impl/GoReceiverImpl.java
Patch:
@@ -65,8 +65,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType(ResolveState context) {
-    return GoPsiImplUtil.getGoType(this, context);
+  public GoType getGoTypeInner(ResolveState context) {
+    return GoPsiImplUtil.getGoTypeInner(this, context);
   }
 
 }

File: gen/com/goide/psi/impl/GoTypeSpecImpl.java
Patch:
@@ -41,8 +41,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType(ResolveState context) {
-    return GoPsiImplUtil.getGoType(this, context);
+  public GoType getGoTypeInner(ResolveState context) {
+    return GoPsiImplUtil.getGoTypeInner(this, context);
   }
 
   @NotNull

File: gen/com/goide/psi/impl/GoVarDefinitionImpl.java
Patch:
@@ -36,8 +36,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType(ResolveState context) {
-    return GoPsiImplUtil.getGoType(this, context);
+  public GoType getGoTypeInner(ResolveState context) {
+    return GoPsiImplUtil.getGoTypeInner(this, context);
   }
 
   @Nullable

File: utils/src/com/goide/GoConstants.java
Patch:
@@ -39,6 +39,7 @@ public class GoConstants {
   public static final String TEST_SUFFIX_WITH_EXTENSION = "_test.go";
   public static final String MAIN = "main";
   public static final String INIT = "init";
+  public static final String DOCUMENTATION = "documentation";
 
   public static final NotificationGroup GO_NOTIFICATION_GROUP = NotificationGroup.balloonGroup("Go plugin notifications");
   public static final NotificationGroup GO_EXECUTION_NOTIFICATION_GROUP = NotificationGroup.toolWindowGroup("Go Execution", ToolWindowId.RUN);

File: src/com/goide/template/GoLiveTemplatesProvider.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2014 Sergey Ignatov, Alexander Zolotov
+ * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Mihai Toader, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,6 +30,6 @@ public String[] getDefaultLiveTemplateFiles() {
   @Nullable
   @Override
   public String[] getHiddenLiveTemplateFiles() {
-    return new String[]{"/liveTemplates/hidden"};
+    return new String[]{"/liveTemplates/goHidden"};
   }
 }

File: src/com/goide/completion/GoAutoImportInsertHandler.java
Patch:
@@ -29,7 +29,7 @@
 import org.jetbrains.annotations.Nullable;
 
 public class GoAutoImportInsertHandler<T extends GoNamedElement> implements InsertHandler<LookupElement> {
-  public static final InsertHandler<LookupElement> TYPE_INSERT_HANDLER = new GoAutoImportInsertHandler<GoNamedElement>();
+  public static final InsertHandler<LookupElement> SIMPLE_INSERT_HANDLER = new GoAutoImportInsertHandler<GoNamedElement>();
   public static final InsertHandler<LookupElement> TYPE_CONVERSION_INSERT_HANDLER = new GoAutoImportInsertHandler<GoTypeSpec>(
     new Function<GoTypeSpec, InsertHandler<LookupElement>>() {
       @Override

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -253,7 +253,7 @@ private Indent calcIndent(@NotNull ASTNode child) {
       if (parentType == BLOCK && type == SELECT_STATEMENT) return Indent.getNoneIndent();
       if (parentType == SELECT_STATEMENT && type == RBRACE) return Indent.getNormalIndent();
       if (parentType == ARGUMENT_LIST && type != LPAREN && type != RPAREN) return Indent.getNormalIndent();
-      if ((parentType == EXPR_CASE_CLAUSE || parentType == TYPE_CASE_CLAUSE) && (type == CASE || type == DEFAULT)) return Indent.getNoneIndent();
+      if ((parentType == EXPR_CASE_CLAUSE || parentType == TYPE_CASE_CLAUSE) && (type == CASE || type == TYPE_SWITCH_CASE || type == DEFAULT)) return Indent.getNoneIndent();
       if (BLOCKS_TOKEN_SET.contains(parentType)) return indentIfNotBrace(child);
       if (parentType == IMPORT_DECLARATION && type == IMPORT_SPEC) return Indent.getNormalIndent();
       if (parentType == CONST_DECLARATION && type == CONST_SPEC) return Indent.getNormalIndent();

File: gen/com/goide/psi/GoTypeCaseClause.java
Patch:
@@ -10,10 +10,10 @@ public interface GoTypeCaseClause extends GoCompositeElement {
   @NotNull
   List<GoStatement> getStatementList();
 
-  @NotNull
+  @Nullable
   GoTypeSwitchCase getTypeSwitchCase();
 
-  @NotNull
+  @Nullable
   PsiElement getColon();
 
 }

File: src/com/goide/inspections/GoReturnInspection.java
Patch:
@@ -112,7 +112,8 @@ else if (s instanceof GoTypeSwitchStatement) { // todo: almost the same code
       boolean hasDefault = false;
       List<GoTypeCaseClause> list = ((GoTypeSwitchStatement)s).getTypeCaseClauseList();
       for (GoTypeCaseClause clause : list) {
-        PsiElement child = clause.getTypeSwitchCase().getFirstChild();
+        GoTypeSwitchCase switchCase = clause.getTypeSwitchCase();
+        PsiElement child = switchCase == null ? null : switchCase.getFirstChild();
         if (child != null && child.getNode().getElementType() == GoTypes.DEFAULT) {
           hasDefault = true;
         }

File: src/com/goide/inspections/unresolved/GoUnusedVariableInspection.java
Patch:
@@ -38,7 +38,7 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
       @Override
       public void visitVarDefinition(@NotNull GoVarDefinition o) {
         if (o.isBlank()) return;
-        GoVarSpec varSpec = PsiTreeUtil.getParentOfType(o, GoVarSpec.class);
+        GoCompositeElement varSpec = PsiTreeUtil.getParentOfType(o, GoVarSpec.class, GoTypeSwitchGuard.class);
         GoVarDeclaration decl = PsiTreeUtil.getParentOfType(o, GoVarDeclaration.class);
         if (varSpec != null || decl != null) {
           PsiReference reference = o.getReference();

File: tests/com/goide/psi/legacy/GoLegacyResolveVarsTest.java
Patch:
@@ -57,6 +57,7 @@ public class GoLegacyResolveVarsTest extends GoLegacyResolveTestBase {
   public void testVarDeclarationInSelectCommClauseSend()            { doTest(); }
   public void testVarDeclarationOutsideSwitch()                     { doTest(); }
   public void testVarVsInnerTypes()                                 { doTest(); }
+  public void testVarTypeGuard()                                    { doTest(); }
 
   public void testFromDefaultImportedPackage()                      { doDirTest(); }
   public void testLocalPackageDefinitionsShouldBeResolvedFirst()    { doDirTest(); }

File: src/com/goide/completion/GoAutoImportInsertHandler.java
Patch:
@@ -29,7 +29,7 @@
 import org.jetbrains.annotations.Nullable;
 
 public class GoAutoImportInsertHandler<T extends GoNamedElement> implements InsertHandler<LookupElement> {
-  public static final InsertHandler<LookupElement> TYPE_INSERT_HANDLER = new GoAutoImportInsertHandler<GoNamedElement>();
+  public static final InsertHandler<LookupElement> SIMPLE_INSERT_HANDLER = new GoAutoImportInsertHandler<GoNamedElement>();
   public static final InsertHandler<LookupElement> TYPE_CONVERSION_INSERT_HANDLER = new GoAutoImportInsertHandler<GoTypeSpec>(
     new Function<GoTypeSpec, InsertHandler<LookupElement>>() {
       @Override

File: src/com/goide/runconfig/GoRunConfigurationBase.java
Patch:
@@ -40,7 +40,8 @@
 import java.util.Map;
 
 public abstract class GoRunConfigurationBase<RunningState extends GoRunningState>
-  extends ModuleBasedConfiguration<GoModuleBasedConfiguration> implements RunConfigurationWithSuppressedDefaultRunAction {
+  extends ModuleBasedConfiguration<GoModuleBasedConfiguration> implements RunConfigurationWithSuppressedDefaultRunAction,
+                                                                          RunConfigurationWithSuppressedDefaultDebugAction {
 
   private static final String WORKING_DIRECTORY_NAME = "working_directory";
   private static final String GO_PARAMETERS_NAME = "go_parameters";

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -59,7 +59,7 @@
 import static com.intellij.util.containers.ContainerUtil.newLinkedHashSet;
 
 public class GoSdkUtil {
-  private static final Pattern GO_VERSION_PATTERN = Pattern.compile("theVersion\\s*=\\s*`go([\\d.]+)`");
+  private static final Pattern GO_VERSION_PATTERN = Pattern.compile("theVersion\\s*=\\s*`go([\\d.]+(rc\\d+)?)`");
   private static final Pattern GAE_VERSION_PATTERN = Pattern.compile("theVersion\\s*=\\s*`go([\\d.]+)( \\(appengine-[\\d.]+\\))?`");
   private static final Pattern GO_DEVEL_VERSION_PATTERN = Pattern.compile("theVersion\\s*=\\s*`(devel.*)`");
 
@@ -130,7 +130,7 @@ private static Collection<VirtualFile> getGoPathRoots(@NotNull Project project,
   public static Collection<VirtualFile> getGoPathSources(@NotNull final Project project, @Nullable final Module module) {
     Collection<VirtualFile> result = newLinkedHashSet();
     if (module != null && GoSdkService.getInstance(project).isAppEngineSdk(module)) {
-      ContainerUtil.addAllNotNull(result, ContainerUtil.mapNotNull(YamlFilesModificationTracker.getYamlFiles(project, module), 
+      ContainerUtil.addAllNotNull(result, ContainerUtil.mapNotNull(YamlFilesModificationTracker.getYamlFiles(project, module),
                                                                    GoUtil.RETRIEVE_FILE_PARENT_FUNCTION));
     }
     result.addAll(ContainerUtil.mapNotNull(getGoPathRoots(project, module), new RetrieveSubDirectoryOrSelfFunction("src")));

File: src/com/goide/runconfig/ui/GoCommonSettingsPanel.java
Patch:
@@ -39,6 +39,8 @@ public class GoCommonSettingsPanel extends JPanel {
 
   public void init(@NotNull Project project) {
     GoRunUtil.installFileChooser(project, myWorkingDirectoryField, true);
+    myGoToolParamsField.setDialogCaption("Go tool arguments");
+    myParamsField.setDialogCaption("Program arguments");
   }
 
   public void resetEditorFrom(@NotNull GoRunConfigurationBase<?> configuration) {

File: src/com/goide/appengine/run/GoAppEngineRunningState.java
Patch:
@@ -47,7 +47,7 @@ protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws Executio
     if (StringUtil.isNotEmpty(adminPort)) {
       executor.withParameters("-admin_port", adminPort);
     }
-    executor.withParameters(".");
+    executor.withParameters(StringUtil.notNullize(myConfiguration.getConfigFile(), "."));
     return executor;
   }
 }

File: src/com/goide/runconfig/testing/GoTestRunConfiguration.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.goide.runconfig.GoModuleBasedConfiguration;
 import com.goide.runconfig.GoRunConfigurationBase;
+import com.goide.runconfig.testing.frameworks.gotest.GotestFramework;
 import com.goide.runconfig.testing.ui.GoTestRunConfigurationEditorForm;
 import com.goide.sdk.GoSdkUtil;
 import com.intellij.execution.configurations.*;
@@ -53,7 +54,7 @@ public class GoTestRunConfiguration extends GoRunConfigurationBase<GoTestRunning
 
   @NotNull private String myPattern = "";
   @NotNull private Kind myKind = Kind.DIRECTORY;
-  private GoTestFramework myTestFramework;
+  private GoTestFramework myTestFramework = GotestFramework.INSTANCE;
 
   public GoTestRunConfiguration(@NotNull Project project, String name, @NotNull ConfigurationType configurationType) {
     super(name, new GoModuleBasedConfiguration(project), configurationType.getConfigurationFactories()[0]);

File: src/com/goide/runconfig/testing/GoTestFramework.java
Patch:
@@ -17,7 +17,7 @@
 package com.goide.runconfig.testing;
 
 import com.goide.runconfig.testing.frameworks.gocheck.GocheckFramework;
-import com.goide.runconfig.testing.frameworks.gotest.GoTestFrameworkImpl;
+import com.goide.runconfig.testing.frameworks.gotest.GotestFramework;
 import com.intellij.execution.runners.ExecutionEnvironment;
 import com.intellij.execution.testframework.TestConsoleProperties;
 import com.intellij.execution.testframework.sm.runner.OutputToGeneralTestEventsConverter;
@@ -31,7 +31,7 @@ public static GoTestFramework fromName(@Nullable String name) {
     if (GocheckFramework.NAME.equals(name)) {
       return GocheckFramework.INSTANCE;
     }
-    return GoTestFrameworkImpl.INSTANCE;
+    return GotestFramework.INSTANCE;
   }
   
   @NotNull

File: src/com/goide/runconfig/testing/frameworks/gotest/GotestFramework.java
Patch:
@@ -26,11 +26,11 @@
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public class GoTestFrameworkImpl extends GoTestFramework {
+public class GotestFramework extends GoTestFramework {
   public static final String NAME = "gotest";
-  public static final GoTestFrameworkImpl INSTANCE = new GoTestFrameworkImpl();
+  public static final GotestFramework INSTANCE = new GotestFramework();
 
-  private GoTestFrameworkImpl() {
+  private GotestFramework() {
   }
 
   @NotNull

File: src/com/goide/runconfig/testing/frameworks/gotest/GotestRunConfigurationProducer.java
Patch:
@@ -24,7 +24,7 @@
 
 public class GotestRunConfigurationProducer extends GoTestRunConfigurationProducerBase implements Cloneable {
   public GotestRunConfigurationProducer() {
-    super(GoTestFrameworkImpl.INSTANCE);
+    super(GotestFramework.INSTANCE);
   }
   
   @Override

File: tests/com/goide/runconfig/testing/GotestEventsConverterTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.goide.runconfig.testing;
 
-import com.goide.runconfig.testing.frameworks.gotest.GoTestFrameworkImpl;
+import com.goide.runconfig.testing.frameworks.gotest.GotestFramework;
 import org.jetbrains.annotations.NotNull;
 
 public class GotestEventsConverterTest extends GoEventsConverterTestCase {
@@ -56,6 +56,6 @@ protected String getBasePath() {
   @NotNull
   @Override
   protected GoTestFramework getTestFramework() {
-    return GoTestFrameworkImpl.INSTANCE;
+    return GotestFramework.INSTANCE;
   }
 }

File: src/com/goide/editor/GoWordSelectioner.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2014 Sergey Ignatov, Alexander Zolotov
+ * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Mihai Toader, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,7 +37,7 @@ public boolean canSelect(@NotNull PsiElement e) {
   public List<TextRange> select(@NotNull PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {
     final PsiElement parent = e.getParent();
     List<TextRange> result = super.select(e, editorText, cursorOffset, editor);
-    if (parent instanceof GoImportString) {
+    if (parent instanceof GoImportString || parent instanceof GoStringLiteral) {
       result.add(ElementManipulators.getValueTextRange(parent).shiftRight(parent.getTextRange().getStartOffset()));
     }
     else if (parent instanceof GoImportDeclaration) {

File: src/com/goide/actions/fmt/GoFmtCheckinFactory.java
Patch:
@@ -77,7 +77,7 @@ public ReturnResult beforeCheckin(@Nullable CommitExecutor executor, PairConsume
           for (PsiFile file : getPsiFiles()) {
             try {
               VirtualFile virtualFile = file.getVirtualFile();
-              new GoFmtFileAction().doSomething(virtualFile, ModuleUtilCore.findModuleForPsiElement(file), file.getProject(), "Go fmt");
+              new GoFmtFileAction().doSomething(virtualFile, ModuleUtilCore.findModuleForPsiElement(file), file.getProject(), "Go fmt", true);
             }
             catch (ExecutionException ignored) {
             }

File: src/com/goide/GoDocumentationProvider.java
Patch:
@@ -144,9 +144,9 @@ private static String getSignature(PsiElement element) {
       else if (signatureResult.getType() != null) {
         GoType signatureResultType = signatureResult.getType();
         if (signatureResultType instanceof GoTypeList) {
-          result.append(" (").append(signatureResult.getType().getText()).append(')');
+          result.append(" (").append(XmlStringUtil.escapeString(signatureResult.getType().getText())).append(')');
         } else {
-          result.append(' ').append(signatureResult.getType().getText());
+          result.append(' ').append(XmlStringUtil.escapeString(signatureResult.getType().getText()));
         }
       }
     }

File: src/com/goide/inspections/GoReservedWordUsedAsName.java
Patch:
@@ -21,10 +21,10 @@
 import com.intellij.codeInspection.LocalInspectionToolSession;
 import com.intellij.codeInspection.ProblemHighlightType;
 import com.intellij.codeInspection.ProblemsHolder;
+import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.psi.ElementDescriptionUtil;
 import com.intellij.psi.PsiElement;
 import com.intellij.usageView.UsageViewTypeLocation;
-import freemarker.template.utility.StringUtil;
 import org.jetbrains.annotations.NotNull;
 
 public class GoReservedWordUsedAsName extends GoInspectionBase {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -172,12 +172,12 @@ public void testMainInMainPackage() {
   }
 
   public void testDuplicateBuiltinFunction() {
-    myFixture.configureByText("a.go", "package main; func main() {new()}; func <warning descr=\"Function 'new' collides with builtin function 'new'\">new</warning>() {}");
+    myFixture.configureByText("a.go", "package main; func main() {new()}; func <warning descr=\"Function 'new' collides with builtin function\">new</warning>() {}");
     myFixture.checkHighlighting();
   }
 
   public void testDuplicateBuiltinType() {
-    myFixture.configureByText("a.go", "package main; func main() {<warning descr=\"Variable 'string' collides with builtin type 'string'\">string</warning> := 3; _ = string}");
+    myFixture.configureByText("a.go", "package main; func main() {<warning descr=\"Variable 'string' collides with builtin type\">string</warning> := 3; _ = string}");
     myFixture.checkHighlighting();
   }
 

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -254,11 +254,11 @@ private Indent calcIndent(@NotNull ASTNode child) {
       if (parentType == SELECT_STATEMENT && type == RBRACE) return Indent.getNormalIndent();
       if (parentType == ARGUMENT_LIST && type != LPAREN && type != RPAREN) return Indent.getNormalIndent();
       if ((parentType == EXPR_CASE_CLAUSE || parentType == TYPE_CASE_CLAUSE) && (type == CASE || type == DEFAULT)) return Indent.getNoneIndent();
-      if (parentType == TYPE_DECLARATION && type == TYPE_SPEC) return Indent.getNormalIndent();
       if (BLOCKS_TOKEN_SET.contains(parentType)) return indentIfNotBrace(child);
       if (parentType == IMPORT_DECLARATION && type == IMPORT_SPEC) return Indent.getNormalIndent();
       if (parentType == CONST_DECLARATION && type == CONST_SPEC) return Indent.getNormalIndent();
       if (parentType == VAR_DECLARATION && type == VAR_SPEC) return Indent.getNormalIndent();
+      if (parentType == TYPE_DECLARATION && type == TYPE_SPEC) return Indent.getNormalIndent();
       if (parentType == COMM_CLAUSE && child.getPsi() instanceof GoStatement) return Indent.getNormalIndent();
       return Indent.getNoneIndent();
     }
@@ -299,6 +299,7 @@ public ChildAttributes getChildAttributes(int newChildIndex) {
           parentType == IMPORT_DECLARATION ||
           parentType == CONST_DECLARATION ||
           parentType == VAR_DECLARATION ||
+          parentType == TYPE_DECLARATION ||
           parentType == ARGUMENT_LIST) {
         childIndent = Indent.getNormalIndent();
       }

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -13,6 +13,7 @@ protected String getBasePath() {
   public void testSimple()      { doTest(); }
   public void testCaseEnter()   { doTest(false); }
   public void testSwitchEnter() { doTest(false); }
+  public void testTypeEnter()   { doTest(false); }
 
   public void doTest() {
     doTest(true);

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -160,7 +160,7 @@ public static LookupElement createTypeConversionLookupElement(@NotNull GoTypeSpe
   @NotNull
   public static InsertHandler<LookupElement> getTypeConversionInsertHandler(@NotNull GoTypeSpec t) {
     GoType type = t.getType();
-    return type instanceof GoStructType || type instanceof GoArrayOrSliceType
+    return type instanceof GoStructType || type instanceof GoArrayOrSliceType || type instanceof GoMapType
            ? BracesInsertHandler.ONE_LINER
            : ParenthesesInsertHandler.WITH_PARAMETERS;
   }

File: src/com/goide/psi/GoNamedElement.java
Patch:
@@ -16,12 +16,13 @@
 
 package com.goide.psi;
 
+import com.intellij.navigation.NavigationItem;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.PsiNameIdentifierOwner;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public interface GoNamedElement extends GoCompositeElement, GoTypeOwner, PsiNameIdentifierOwner {
+public interface GoNamedElement extends GoCompositeElement, GoTypeOwner, PsiNameIdentifierOwner, NavigationItem {
   boolean isPublic();
 
   @Nullable

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -204,9 +204,8 @@ public void handleInsert(@NotNull InsertionContext context, LookupElement item)
       } : null;
     return PrioritizedLookupElement.withPriority(
       LookupElementBuilder.createWithSmartPointer(name, v)
-        //.withLookupString(name.toLowerCase())
+        .withLookupString(name.toLowerCase())
         .withIcon(icon)
-        .withCaseSensitivity(false)
         .withTailText(calcTailTextForFields(v), true)
         .withTypeText(text, true)
         .withInsertHandler(handler)

File: src/com/goide/actions/GoCreateFileAction.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2014 Sergey Ignatov, Alexander Zolotov
+ * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Mihai Toader, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,7 +39,7 @@ public class GoCreateFileAction extends CreateFileFromTemplateAction implements
 
   @Override
   protected PsiFile createFile(String name, @NotNull String templateName, @NotNull PsiDirectory dir) {
-    FileTemplate template = FileTemplateManager.getInstance().getInternalTemplate(templateName);
+    FileTemplate template = FileTemplateManager.getInstance(dir.getProject()).getInternalTemplate(templateName);
     Properties properties = new Properties();
     properties.setProperty(PACKAGE, ContainerUtil.getLastItem(StringUtil.split(dir.getName(), "-")));
     try {

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -195,6 +195,8 @@ public void handleInsert(@NotNull InsertionContext context, LookupElement item)
           context.commitDocument();
           int offset = context.getStartOffset();
           PsiElement at = file.findElementAt(offset);
+          GoCompositeElement ref = PsiTreeUtil.getParentOfType(at, GoValue.class, GoReferenceExpression.class);
+          if (ref instanceof GoReferenceExpression && (((GoReferenceExpression)ref).getQualifier() != null || GoPsiImplUtil.prevDot(ref))) return;
           GoValue value = PsiTreeUtil.getParentOfType(at, GoValue.class);
           if (value == null || PsiTreeUtil.getPrevSiblingOfType(value, GoKey.class) != null) return;
           super.handleInsert(context, item);

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -226,8 +226,6 @@ private boolean processExistingType(@NotNull GoType type,
     }
 
     if (type instanceof GoStructType) {
-      GoScopeProcessorBase delegate = createDelegate(processor);
-      type.processDeclarations(delegate, ResolveState.initial(), null, myElement);
       final List<GoTypeReferenceExpression> interfaceRefs = ContainerUtil.newArrayList();
       final List<GoTypeReferenceExpression> structRefs = ContainerUtil.newArrayList();
       for (GoFieldDeclaration d : ((GoStructType)type).getFieldDeclarationList()) {

File: src/com/goide/util/GoBuildMatcher.java
Patch:
@@ -95,15 +95,14 @@ public boolean matchBuildFlag(@NotNull String name) {
     if (name.startsWith("!")) return !matchBuildFlag(name.substring(1));
 
     if (matchOS(name)) return true;
-    if ("gc".equals(name) || "gccgo".equals(name)) {
+    if (GoConstants.KNOWN_COMPILERS.contains(name)) {
       return myTarget.compiler == null || name.equals(myTarget.compiler);
     }
     if (GoConstants.KNOWN_VERSIONS.contains(name)) {
       return myTarget.goVersion == null || GoSdkUtil.compareVersions(myTarget.goVersion, StringUtil.trimStart(name, "go")) >= 0;
     }
     if ("cgo".equals(name)) {
-      return myTarget.cgoEnabled == ThreeState.YES
-             || myTarget.cgoEnabled == ThreeState.UNSURE && GoConstants.KNOWN_CGO.contains(myTarget.os + "/" + myTarget.arch);
+      return myTarget.cgoEnabled == ThreeState.YES;
     }
     if (myTarget.supportsFlag(name)) return true;
     return false;

File: tests/com/goide/util/GoBuildMatcherTest.java
Patch:
@@ -98,9 +98,6 @@ public void testMatchVersion() {
   }
   
   public void testMatchCgo() {
-    assertTrue(new GoBuildMatcher(new GoTargetSystem("linux", "amd64", "1.4", null, ThreeState.UNSURE)).matchBuildFlag("cgo"));
-    assertFalse(new GoBuildMatcher(new GoTargetSystem("darwin", "arm", "1.4", null, ThreeState.UNSURE)).matchBuildFlag("cgo"));
-    
     assertTrue(new GoBuildMatcher(new GoTargetSystem("linux", "amd64", "1.4", null, ThreeState.YES)).matchBuildFlag("cgo"));
     assertFalse(new GoBuildMatcher(new GoTargetSystem("linux", "amd64", "1.4", null, ThreeState.NO)).matchBuildFlag("cgo"));
   }

File: tests/com/goide/formatter/GoFormatterTest.java
Patch:
@@ -10,9 +10,9 @@ protected String getBasePath() {
     return "formatting";
   }
 
-  public void testSimple() {
-    doTest();
-  }
+  public void testSimple()      { doTest(); }
+  public void testCaseEnter()   { doTest(false); }
+  public void testSwitchEnter() { doTest(false); }
 
   public void doTest() {
     doTest(true);

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -254,6 +254,7 @@ private Indent calcIndent(@NotNull ASTNode child) {
       if (parentType == SELECT_STATEMENT && type == RBRACE) return Indent.getNormalIndent();
       if (parentType == ARGUMENT_LIST && type != LPAREN && type != RPAREN) return Indent.getNormalIndent();
       if ((parentType == EXPR_CASE_CLAUSE || parentType == TYPE_CASE_CLAUSE) && (type == CASE || type == DEFAULT)) return Indent.getNoneIndent();
+      if (parentType == TYPE_DECLARATION && type == TYPE_SPEC) return Indent.getNormalIndent();
       if (BLOCKS_TOKEN_SET.contains(parentType)) return indentIfNotBrace(child);
       if (parentType == IMPORT_DECLARATION && type == IMPORT_SPEC) return Indent.getNormalIndent();
       if (parentType == CONST_DECLARATION && type == CONST_SPEC) return Indent.getNormalIndent();

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -169,7 +169,8 @@ public static LookupElement createTypeConversionLookupElement(@NotNull GoTypeSpe
 
   @NotNull
   public static InsertHandler<LookupElement> getTypeConversionInsertHandler(@NotNull GoTypeSpec t) {
-    return t.getType() instanceof GoStructType ? BracesInsertHandler.ONE_LINER : ParenthesesInsertHandler.WITH_PARAMETERS;
+    GoType type = t.getType();
+    return type instanceof GoStructType || type instanceof GoArrayOrSliceType ? BracesInsertHandler.ONE_LINER : ParenthesesInsertHandler.WITH_PARAMETERS;
   }
 
   @NotNull

File: src/com/goide/inspections/GoFunctionCallInspection.java
Patch:
@@ -60,8 +60,8 @@ public void visitCallExpr(@NotNull GoCallExpr o) {
               GoExpression first = ContainerUtil.getFirstItem(list);
               PsiReference firstRef = GoPsiImplUtil.getCallReference(first);
               PsiElement firstResolve = firstRef != null ? firstRef.resolve() : null;
-              if (firstResolve instanceof GoFunctionOrMethodDeclaration) {
-                actualSize = GoInspectionUtil.getFunctionResultCount((GoFunctionOrMethodDeclaration)firstResolve);
+              if (firstResolve instanceof GoNamedSignatureOwner) {
+                actualSize = GoInspectionUtil.getFunctionResultCount((GoNamedSignatureOwner)firstResolve);
               }
             }
             

File: src/com/goide/inspections/unresolved/GoUnusedFunctionInspection.java
Patch:
@@ -19,6 +19,7 @@
 import com.goide.GoConstants;
 import com.goide.inspections.GoDeleteQuickFix;
 import com.goide.inspections.GoInspectionBase;
+import com.goide.inspections.GoRenameToBlankQuickFix;
 import com.goide.psi.GoFile;
 import com.goide.psi.GoFunctionDeclaration;
 import com.goide.psi.GoVisitor;
@@ -52,7 +53,7 @@ public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
           PsiElement id = o.getIdentifier();
           TextRange range = TextRange.from(id.getStartOffsetInParent(), id.getTextLength());
           holder.registerProblem(o, "Unused function " + "'" + name + "'", ProblemHighlightType.LIKE_UNUSED_SYMBOL, range,
-                                 new GoDeleteQuickFix("Delete function '" + name + "'"));
+                                 new GoDeleteQuickFix("Delete function '" + name + "'"), new GoRenameToBlankQuickFix(o));
         }
       }
     };

File: src/com/goide/inspections/unresolved/GoUnusedFunctionInspection.java
Patch:
@@ -41,6 +41,7 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
     return new GoVisitor() {
       @Override
       public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
+        if (o.isBlank()) return;
         GoFile file = o.getContainingFile();
         String name = o.getName();
         if (GoConstants.MAIN.equals(file.getPackageName()) && GoConstants.MAIN.equals(name)) return;

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -655,6 +655,7 @@ public static GoType getGoType(@NotNull GoSignatureOwner o, @SuppressWarnings("U
             composite.add(definition.getGoType(context));
           }
         }
+        if (composite.size() == 1) return composite.get(0);
         class MyGoTypeList extends LightElement implements GoTypeList {
           @NotNull private final List<GoType> myTypes;
 

File: src/com/goide/util/GoUtil.java
Patch:
@@ -42,7 +42,6 @@
 import com.intellij.util.containers.ContainerUtil;
 import com.intellij.util.text.CharSequenceHashingStrategy;
 import gnu.trove.THashSet;
-import io.netty.util.internal.SystemPropertyUtil;
 import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -99,7 +98,7 @@ public static boolean libraryDirectoryToIgnore(@NotNull String name) {
   }
 
   private static boolean os(@NotNull String os) {
-    String targetOs = SystemPropertyUtil.get("go.target.os");
+    String targetOs = System.getProperty("go.target.os");
     if ("linux".equals(targetOs)) return LINUX.contains(os);
     else if ("mac".equals(targetOs)) return MAC.contains(os);
     else if ("windows".equals(targetOs)) return WINDOWS.contains(os);

File: src/com/goide/util/GoUtil.java
Patch:
@@ -196,7 +196,7 @@ public Result<Collection<String>> compute() {
           if (file instanceof GoFile) {
             String name = ((GoFile)file).getPackageName();
             if (name != null && !GoConstants.MAIN.equals(name)) {
-              set.add(StringUtil.trimEnd(name, GoConstants.TEST_SUFFIX));
+              set.add(name);
             }
           }
         }

File: tests/com/goide/completion/GoCompletionTest.java
Patch:
@@ -421,7 +421,7 @@ public void testPackageNames() {
     myFixture.configureByText("test_file.go", "package fromFile");
     myFixture.configureByText("test.go", "package <caret>");
     myFixture.completeBasic();
-    assertSameElements(myFixture.getLookupElementStrings(), "fromTest", "fromFile", "main");
+    assertSameElements(myFixture.getLookupElementStrings(), "fromTest", "fromTest_test", "fromFile", "main");
   }
 
   @SuppressWarnings("ConstantConditions")

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -858,7 +858,7 @@ public static boolean shouldGoDeeper(@SuppressWarnings("UnusedParameters") GoSig
   }
 
   public static boolean prevDot(@Nullable PsiElement parent) {
-    PsiElement prev = parent == null ? null : PsiTreeUtil.prevLeaf(parent, true);
+    PsiElement prev = parent == null ? null : PsiTreeUtil.prevVisibleLeaf(parent);
     return prev instanceof LeafElement && ((LeafElement)prev).getElementType() == GoTypes.DOT;
   }
 

File: src/com/goide/project/GoModuleLibrariesInitializer.java
Patch:
@@ -242,7 +242,6 @@ public void run() {
   private static Set<VirtualFile> gatherExclusions(@NotNull Collection<VirtualFile> roots, @NotNull final VirtualFile... exclusions) {
     final Set<VirtualFile> result = ContainerUtil.newHashSet(exclusions);
 
-    // todo: remove ancestors removing after 15.1
     Iterator<VirtualFile> iterator = roots.iterator();
     while (iterator.hasNext()) {
       VirtualFile file = iterator.next();

File: src/com/goide/psi/impl/imports/GoImportReferenceHelper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2014 Sergey Ignatov, Alexander Zolotov
+ * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Mihai Toader, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -103,7 +103,7 @@ public boolean isMine(Project project, @NotNull VirtualFile file) {
   @NotNull
   private static Collection<? extends VirtualFile> getPathsToLookup(@NotNull PsiElement element) {
     Module module = ModuleUtilCore.findModuleForPsiElement(element);
-    Set<VirtualFile> result = ContainerUtil.newLinkedHashSet(GoSdkUtil.getGoPathsSources(element.getProject(), module));
+    Set<VirtualFile> result = ContainerUtil.newLinkedHashSet(GoSdkUtil.getGoPathSources(element.getProject(), module));
     ContainerUtil.addIfNotNull(result, GoSdkUtil.getSdkSrcDir(element));
     return result;
   }

File: src/com/goide/runconfig/GoConsoleFilter.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2014 Sergey Ignatov, Alexander Zolotov
+ * Copyright 2013-2015 Sergey Ignatov, Alexander Zolotov, Mihai Toader, Florin Patan
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -122,7 +122,7 @@ public Result applyFilter(@NotNull String line, int entireLength) {
 
   @Nullable
   private VirtualFile findInGoPath(@NotNull String fileName) {
-    for (VirtualFile goPathSrc : GoSdkUtil.getGoPathsSources(myProject, myModule)) {
+    for (VirtualFile goPathSrc : GoSdkUtil.getGoPathSources(myProject, myModule)) {
       VirtualFile virtualFile = goPathSrc.findFileByRelativePath(fileName);
       if (virtualFile != null) return virtualFile;
     }

File: src/com/goide/ui/ProjectTutorialNotification.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.goide.GoConstants;
 import com.intellij.ide.util.PropertiesComponent;
-import com.intellij.notification.Notification;
 import com.intellij.notification.NotificationListener;
 import com.intellij.notification.NotificationType;
 import com.intellij.notification.Notifications;
@@ -47,8 +46,7 @@ public void initComponent() {
       return;
     }
 
-    Notifications.Bus.notify(new Notification(
-      GoConstants.GO_NOTIFICATION_GROUP, "Learn how to setup a new Go project",
+    Notifications.Bus.notify(GoConstants.GO_NOTIFICATION_GROUP.createNotification("Learn how to setup a new Go project",
       "Please visit our " +
       "<a href=\"https://github.com/go-lang-plugin-org/go-lang-idea-plugin/wiki/v1.0.0-Setup-initial-project\">wiki page<a/>" +
       " to learn how to setup a new Go project",

File: utils/src/com/goide/GoConstants.java
Patch:
@@ -33,9 +33,9 @@ public class GoConstants {
   public static final String TEST_SUFFIX_WITH_EXTENSION = "_test.go";
   public static final String MAIN = "main";
   public static final String INIT = "init";
-
-  public static final String GO_NOTIFICATION_GROUP = "Go plugin notifications";
-  public static NotificationGroup GO_EXECUTION_NOTIFICATION_GROUP = NotificationGroup.toolWindowGroup("Go Execution", ToolWindowId.RUN);
+  
+  public static final NotificationGroup GO_NOTIFICATION_GROUP = NotificationGroup.balloonGroup("Go plugin notifications");
+  public static final NotificationGroup GO_EXECUTION_NOTIFICATION_GROUP = NotificationGroup.toolWindowGroup("Go Execution", ToolWindowId.RUN);
   
   @NonNls public static final String LIB_EXEC_DIRECTORY = "libexec";
   @NonNls public static final String GO_VERSION_FILE_PATH = "runtime/zversion.go";

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -22,4 +22,6 @@ public interface GoTypeSpec extends GoNamedElement, StubBasedPsiElement<GoTypeSp
   @NotNull
   List<GoMethodDeclaration> getMethods();
 
+  boolean shouldGoDeeper();
+
 }

File: tests/com/goide/psi/legacy/GoLegacyResolveVarsTest.java
Patch:
@@ -56,6 +56,7 @@ public class GoLegacyResolveVarsTest extends GoLegacyResolveTestBase {
   public void testVarInSwitchTypeWithNamedSwitchGuard()             { doTest(); }
   public void testVarDeclarationInSelectCommClauseSend()            { doTest(); }
   public void testVarDeclarationOutsideSwitch()                     { doTest(); }
+  public void testVarVsInnerTypes()                                 { doTest(); }
 
   public void testFromDefaultImportedPackage()                      { doDirTest(); }
   public void testLocalPackageDefinitionsShouldBeResolvedFirst()    { doDirTest(); }

File: tests/com/goide/psi/legacy/GoLegacyResolveVarsTest.java
Patch:
@@ -55,6 +55,7 @@ public class GoLegacyResolveVarsTest extends GoLegacyResolveTestBase {
   public void testResolveToFunctionName()                           { doTest(); }
   public void testVarInSwitchTypeWithNamedSwitchGuard()             { doTest(); }
   public void testVarDeclarationInSelectCommClauseSend()            { doTest(); }
+  public void testVarDeclarationOutsideSwitch()                     { doTest(); }
 
   public void testFromDefaultImportedPackage()                      { doDirTest(); }
   public void testLocalPackageDefinitionsShouldBeResolvedFirst()    { doDirTest(); }

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -37,6 +37,7 @@
 import com.intellij.psi.PsiFile;
 import com.intellij.psi.util.CachedValueProvider;
 import com.intellij.psi.util.CachedValuesManager;
+import com.intellij.util.ArrayUtil;
 import com.intellij.util.Function;
 import com.intellij.util.ObjectUtils;
 import com.intellij.util.SystemProperties;
@@ -312,7 +313,8 @@ public static Collection<VirtualFile> getSdkDirectoriesToAttach(@NotNull String
 
   @NotNull
   public static Collection<Object> getSdkAndLibrariesCacheDependencies(@NotNull PsiElement context, Object... extra) {
-    return getSdkAndLibrariesCacheDependencies(context.getProject(), ModuleUtilCore.findModuleForPsiElement(context), extra);
+    return getSdkAndLibrariesCacheDependencies(context.getProject(), ModuleUtilCore.findModuleForPsiElement(context),
+                                               ArrayUtil.append(extra, context));
   }
   
   @NotNull

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -105,6 +105,8 @@ private static SpacingBuilder createSpacingBuilder(@NotNull CodeStyleSettings se
       .beforeInside(TYPE, VAR_SPEC).spaces(1)
       .after(GoParserDefinition.LINE_COMMENT).lineBreakInCodeIf(true)
       .after(GoParserDefinition.MULTILINE_COMMENT).lineBreakInCodeIf(true)
+      .between(COMM_CASE, COLON).none()
+      .afterInside(COLON, COMM_CLAUSE).lineBreakInCode()
       ;
   }
 

File: src/com/goide/inspections/unresolved/GoUnresolvedReferenceInspection.java
Patch:
@@ -31,6 +31,7 @@
 import com.intellij.psi.ResolveResult;
 import com.intellij.psi.formatter.FormatterUtil;
 import com.intellij.psi.impl.source.resolve.reference.impl.providers.FileReference;
+import com.intellij.psi.util.PsiTreeUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -137,6 +138,7 @@ private static LocalQuickFix[] createImportPackageFixes(@NotNull PsiElement targ
   }
 
   private static boolean isProhibited(@NotNull GoCompositeElement o, @Nullable GoCompositeElement qualifier) {
+    if (PsiTreeUtil.getPrevSiblingOfType(o, GoReceiverType.class) != null) return true;
     ASTNode next = FormatterUtil.getNextNonWhitespaceSibling(o.getNode());
     boolean isDot = next != null && next.getElementType() == GoTypes.DOT;
     return isDot || qualifier != null;

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -51,6 +51,7 @@ public class GoReference extends PsiPolyVariantReferenceBase<GoReferenceExpressi
   public static final Key<List<? extends PsiElement>> IMPORT_USERS = Key.create("IMPORT_USERS");
   public static final Key<String > ACTUAL_NAME = Key.create("ACTUAL_NAME");
   public static final Key<Object> POINTER = Key.create("POINTER");
+  public static final Key<Object> RECEIVER = Key.create("RECEIVER");
   public static final Key<SmartPsiElementPointer<GoReferenceExpressionBase>> CONTEXT = Key.create("CONTEXT");
   
   private static final ResolveCache.PolyVariantResolver<PsiPolyVariantReferenceBase> MY_RESOLVER =
@@ -186,13 +187,15 @@ private boolean processQualifierExpression(@NotNull GoFile file,
 
   private boolean processGoType(@NotNull GoType type, @NotNull MyScopeProcessor processor, @NotNull ResolveState state) {
     if (type instanceof GoParType) return processGoType(((GoParType)type).getType(), processor, state);
+    if (type instanceof GoReceiverType) state = state.put(RECEIVER, Boolean.TRUE);
     if (!processExistingType(type, processor, state)) return false;
     if (type instanceof GoPointerType) {
       if (!processPointer((GoPointerType)type, processor, state.put(POINTER, Boolean.TRUE))) return false;
       GoType pointer = ((GoPointerType)type).getType();
       if (pointer instanceof GoPointerType) {
         return processPointer((GoPointerType)pointer, processor, state.put(POINTER, Boolean.TRUE));
       }
+      else if (pointer != null && state.get(RECEIVER) != null && !processGoType(pointer, processor, state)) return false;
     }
     return processTypeRef(type, processor, state);
   }

File: src/com/goide/psi/impl/GoFieldNameReference.java
Patch:
@@ -78,7 +78,7 @@ private boolean processFields(@NotNull GoScopeProcessorBase processor) {
   private GoType getType(GoType type) { // todo: rethink and unify this algorithm
     boolean inValue = myValue != null;
     
-    if (inValue && type instanceof GoArrayOrSliceType) type = type.getType();
+    if (inValue && type instanceof GoArrayOrSliceType) type = ((GoArrayOrSliceType)type).getType();
     else if (type instanceof GoMapType) type = inValue ? ((GoMapType)type).getValueType() : ((GoMapType)type).getKeyType();
     else if (inValue && type instanceof GoStructType) {
       GoKey key = PsiTreeUtil.getPrevSiblingOfType(myValue, GoKey.class);
@@ -95,7 +95,7 @@ else if (inValue && type instanceof GoStructType) {
     }
 
     if (type instanceof GoPointerType) {
-      GoType inner = type.getType();
+      GoType inner = ((GoPointerType)type).getType();
       if (inner != null && inner.getTypeReferenceExpression() != null) {
         type = GoPsiImplUtil.getType(inner.getTypeReferenceExpression());
       }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -185,10 +185,11 @@ private boolean processQualifierExpression(@NotNull GoFile file,
   }
 
   private boolean processGoType(@NotNull GoType type, @NotNull MyScopeProcessor processor, @NotNull ResolveState state) {
+    if (type instanceof GoParType) return processGoType(((GoParType)type).getType(), processor, state);
     if (!processExistingType(type, processor, state)) return false;
     if (type instanceof GoPointerType) {
       if (!processPointer((GoPointerType)type, processor, state.put(POINTER, Boolean.TRUE))) return false;
-      GoType pointer = type.getType();
+      GoType pointer = ((GoPointerType)type).getType();
       if (pointer instanceof GoPointerType) {
         return processPointer((GoPointerType)pointer, processor, state.put(POINTER, Boolean.TRUE));
       }

File: tests/com/goide/psi/legacy/GoLegacyResolveTypesTest.java
Patch:
@@ -24,6 +24,7 @@ public class GoLegacyResolveTypesTest extends GoLegacyResolveTestBase {
   public void testFromMethodReceiver()                            { doTest(); } 
   public void testResolveTypeNameInTypeSpec()                     { doTest(); } 
   public void testResolveTypeInCast()                             { doTest(); } 
+  public void testResolveArrayInRange()                           { doTest(); } 
   public void testMethodsOrder()                                  { doTest(); } 
   public void testFromDefaultImportedPackage()                    { doDirTest(); } 
   public void testFromInjectedPackage()                           { doDirTest(); } 

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -212,7 +212,9 @@ private boolean processExistingType(@NotNull GoType type,
     if (!(file instanceof GoFile)) return true;
     PsiFile myFile = myElement.getContainingFile();
     if (!(myFile instanceof GoFile)) return true;
-    boolean localResolve = Comparing.equal(((GoFile)myFile.getOriginalFile()).getImportPath(), ((GoFile)file.getOriginalFile()).getImportPath());
+    GoFile o1 = (GoFile)myFile.getOriginalFile();
+    GoFile o2 = (GoFile)file.getOriginalFile();
+    boolean localResolve = Comparing.equal(o1.getImportPath(), o2.getImportPath()) && Comparing.equal(o1.getPackageName(), o2.getPackageName());
 
     PsiElement parent = type.getStub() == null ? type.getParent() : type.getStub().getParentStub().getPsi();
     if (parent instanceof GoTypeSpec && !processNamedElements(processor, state, ((GoTypeSpec)parent).getMethods(), localResolve)) {

File: src/com/goide/formatter/settings/GoLanguageCodeStyleSettingsProvider.java
Patch:
@@ -49,7 +49,7 @@ public CommonCodeStyleSettings getDefaultCommonSettings() {
     indentOptions.INDENT_SIZE = 4;
     indentOptions.CONTINUATION_INDENT_SIZE = 4;
     indentOptions.TAB_SIZE = 4;
-    indentOptions.USE_TAB_CHARACTER = false; // todo: should be true
+    indentOptions.USE_TAB_CHARACTER = true;
     return defaultSettings;
   }
 

File: tests/com/goide/completion/GoCompletionSdkAwareTest.java
Patch:
@@ -51,8 +51,8 @@ public void testForceAutoImportBlankImports() {
                   "func test(){Fprintl<caret>}",
                   "package main;\n" +
                   "import (\n" +
-                  "    _ \"fmt\"\n" +
-                  "    \"fmt\"\n" +
+                  "\t_ \"fmt\"\n" +
+                  "\t\"fmt\"\n" +
                   ")\n" +
                   "func test(){fmt.Fprintln()}");
   }
@@ -89,7 +89,7 @@ public void testUseImportPathInsteadOfPackageNameForAutoImport() {
                   "\n" +
                   "import (\n" +
                   "    \"fmt\"\n" +
-                  "    \"dirName\"\n" +
+                  "\t\"dirName\"\n" +
                   ")\n" +
                   "\n" +
                   "func main() {\n" +

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -191,7 +191,8 @@ public void handleInsert(@NotNull InsertionContext context, LookupElement item)
           context.commitDocument();
           int offset = context.getStartOffset();
           PsiElement at = file.findElementAt(offset);
-          if (PsiTreeUtil.getParentOfType(at, GoValue.class) == null) return;
+          GoValue value = PsiTreeUtil.getParentOfType(at, GoValue.class);
+          if (value == null || PsiTreeUtil.getPrevSiblingOfType(value, GoKey.class) != null) return;
           super.handleInsert(context, item);
         }
       } : null;

File: tests/com/goide/GoPerformanceTest.java
Patch:
@@ -78,7 +78,7 @@ public void run() throws Throwable {
         InspectionTestUtil.runTool(wrapper, scope, globalContext);
         InspectionTestUtil.compareToolResults(globalContext, wrapper, false, new File(getTestDataPath(), wrapper.getShortName()).getPath());
       }
-    }).cpuBound().attempts(3).usesAllCPUCores().assertTiming();
+    }).cpuBound().usesAllCPUCores().assertTiming();
   }
 
   public void testParserAndStubs() {

File: src/com/goide/actions/fmt/GoImportsFileAction.java
Patch:
@@ -50,7 +50,7 @@ protected boolean doSomething(@NotNull VirtualFile virtualFile, @NotNull Project
   protected GoExecutor createExecutor(Module module, @NotNull String title, @NotNull String filePath) {
     File executable = getExecutable();
     assert executable != null;
-    return GoExecutor.in(module).withExePath(executable.getAbsolutePath()).withParameters(filePath).showOutputOnError();
+    return GoExecutor.in(module).withExePath(executable.getAbsolutePath()).withParameters("-w", filePath).showOutputOnError();
   }
 
   @Nullable

File: tests/com/goide/GoPerformanceTest.java
Patch:
@@ -104,6 +104,7 @@ public Result visitFileEx(@NotNull VirtualFile file) {
               String path = file.getPath();
               String trim = FileUtil.loadFile(new File(path), "UTF-8", true).trim();
               PsiFile psi = PsiFileFactory.getInstance(getProject()).createFileFromText(file.getName(), file.getFileType(), trim);
+              System.out.print(".");
               boolean contains = DebugUtil.psiToString(psi, true).contains("PsiErrorElement");
               if (contains) System.err.println(path);
               //assertFalse(path + " contains error elements", DebugUtil.psiToString(psi, true).contains("PsiErrorElement"));

File: gen/com/goide/psi/GoAssignmentStatement.java
Patch:
@@ -10,6 +10,9 @@ public interface GoAssignmentStatement extends GoStatement {
   @NotNull
   List<GoExpression> getExpressionList();
 
+  @NotNull
+  GoLeftHandExprList getLeftHandExprList();
+
   @NotNull
   GoAssignOp getAssignOp();
 

File: gen/com/goide/psi/GoSendStatement.java
Patch:
@@ -10,6 +10,9 @@ public interface GoSendStatement extends GoStatement {
   @NotNull
   List<GoExpression> getExpressionList();
 
+  @Nullable
+  GoLeftHandExprList getLeftHandExprList();
+
   @NotNull
   PsiElement getSendChannel();
 

File: src/com/goide/inspections/GoReturnInspection.java
Patch:
@@ -71,7 +71,8 @@ private static boolean isTerminating(@Nullable GoCompositeElement s) {
       return true;
     }
     else if (s instanceof GoSimpleStatement) {
-      GoExpression expression = ((GoSimpleStatement)s).getExpression();
+      GoLeftHandExprList list = ((GoSimpleStatement)s).getLeftHandExprList();
+      GoExpression expression = ContainerUtil.getFirstItem(list != null ? list.getExpressionList() : null);
       if (expression instanceof GoCallExpr && GoPsiImplUtil.isPanic((GoCallExpr)expression)) return true;
     }
     else if (s instanceof GoBlock) {

File: src/com/goide/template/GoLiveTemplateContextType.java
Patch:
@@ -92,7 +92,7 @@ protected GoBlockContextType() {
   
     @Override
     protected boolean isInContext(@NotNull PsiElement element) {
-      return element instanceof GoSimpleStatement && PsiTreeUtil.getParentOfType(element, GoBlock.class) != null;
+      return (element instanceof GoLeftHandExprList || element instanceof GoSimpleStatement) && PsiTreeUtil.getParentOfType(element, GoBlock.class) != null;
     }
   }
 }

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -59,4 +59,5 @@ protected void setUp() throws Exception {
   public void testLabels()                          { doTest(false); }
   public void testBlockRecover()                    { doTest(false); }
   public void testMethodWithoutReceiverIdentifier() { doTest(false); }
+  public void testExpressionPerformance()           { doTest(false); }
 }

File: src/com/goide/sdk/GoSdkService.java
Patch:
@@ -75,7 +75,7 @@ public static String getGoExecutablePath(@Nullable String sdkHomePath) {
         
         boolean gcloudInstallation = sdkHomePath.endsWith(GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH);
         if (gcloudInstallation) {
-          goExecutablePath = FileUtil.join(StringUtil.trimEnd(sdkHomePath, GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH), "bin");
+          goExecutablePath = FileUtil.join(StringUtil.trimEnd(goExecutablePath, GoConstants.GCLOUD_APP_ENGINE_DIRECTORY_PATH), "bin");
         }
         return FileUtil.join(goExecutablePath, GoEnvironmentUtil.getGaeExecutableFileName(gcloudInstallation));
       }

File: src/com/goide/psi/impl/GoFieldNameReference.java
Patch:
@@ -39,7 +39,7 @@ private GoScopeProcessorBase getProcessor(final boolean completion) {
     return new GoScopeProcessorBase(myElement.getText(), myElement, completion) {
       @Override
       protected boolean condition(@NotNull PsiElement element) {
-        return !(element instanceof GoFieldDefinition);
+        return !(element instanceof GoFieldDefinition) && !(element instanceof GoAnonymousFieldDefinition);
       }
     };
   }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -77,6 +77,7 @@ protected boolean isWriteActionRequired() {
   public void testReceiverType(){ doTest(); }
   public void testForRange()    { doTest(); }
   public void testMismatch()    { doTest(); }
+  public void testStubParams()  { doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -98,7 +98,7 @@ private static SpacingBuilder createSpacingBuilder(@NotNull CodeStyleSettings se
       .afterInside(MAP, MAP_TYPE).none()
       .aroundInside(LBRACK, MAP_TYPE).none()
       .aroundInside(RBRACK, MAP_TYPE).none()
-      .between(LITERAL_TYPE_EXPR, LITERAL_VALUE).none()
+      .beforeInside(LITERAL_VALUE, COMPOSITE_LIT).none()
       .afterInside(LBRACE, LITERAL_VALUE).none()
       .beforeInside(LBRACE, LITERAL_VALUE).none()
       .afterInside(BIT_AND, UNARY_EXPR).none()

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -309,9 +309,9 @@ public static GoType getGoType(@NotNull final GoExpression o, @Nullable ResolveS
       return null;
     }
     else if (o instanceof GoCompositeLit) {
-      GoType type = ((GoCompositeLit)o).getLiteralTypeExpr().getType();
+      GoType type = ((GoCompositeLit)o).getType();
       if (type != null) return type;
-      GoTypeReferenceExpression expression = ((GoCompositeLit)o).getLiteralTypeExpr().getTypeReferenceExpression();
+      GoTypeReferenceExpression expression = ((GoCompositeLit)o).getTypeReferenceExpression();
       return getType(expression);
     }
     else if (o instanceof GoFunctionLit) {
@@ -499,7 +499,7 @@ public static GoType getGoType(@NotNull GoVarDefinition o, @Nullable ResolveStat
     }
     GoCompositeLit literal = PsiTreeUtil.getNextSiblingOfType(o, GoCompositeLit.class);
     if (literal != null) {
-      return literal.getLiteralTypeExpr().getType();
+      return literal.getType();
     }
     GoType siblingType = o.findSiblingType();
     if (siblingType != null) return siblingType;

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -49,6 +49,8 @@ protected void setUp() throws Exception {
   public void testTorture()                         { doTest(true);  }
   public void testLiteralValues()                   { doTest(true);  }
   public void testIfComposite()                     { doTest(true);  }
+  public void testArrayTypes()                      { doTest(true);  }
+  public void testArrayTypesInRanges()              { doTest(true);  }
   public void testIf()                              { doTest(false); }
   public void testSimple()                          { doTest(false); }
   public void testRecover()                         { doTest(false); }

File: src/com/goide/codeInsight/imports/GoGetPackageFix.java
Patch:
@@ -60,7 +60,7 @@ public static void applyFix(@NotNull final Project project,
       @Override
       public void run() {
         GoExecutor.in(module).withPresentableName("go get " + packageName)
-          .withParameters("get", packageName).showNotifications().showOutputOnError().executeWithProgress(!startInBackground);
+          .withParameters("get", packageName).showNotifications(false).showOutputOnError().executeWithProgress(!startInBackground);
       }
     });
   }

File: src/com/goide/runconfig/GoBuildingRunner.java
Patch:
@@ -74,7 +74,7 @@ protected Promise<RunProfileStarter> prepare(@NotNull ExecutionEnvironment envir
     final AsyncPromise<RunProfileStarter> promise = new AsyncPromise<RunProfileStarter>();
     FileDocumentManager.getInstance().saveAllDocuments();
     ((GoApplicationRunningState)state).createCommonExecutor().withParameters("build", "-o", tmpFile.getAbsolutePath())
-      .showNotifications()
+      .showNotifications(true)
       .showOutputOnError()
       .withPresentableName("go build")
       .withProcessListener(new ProcessAdapter() {

File: src/com/goide/runconfig/GoConsoleFilter.java
Patch:
@@ -78,7 +78,7 @@ public void navigate(Project project) {
     int columnNumber = 0;
     if (matcher.groupCount() > 3) {
       columnNumber = StringUtil.parseInt(matcher.group(4), 0);
-      endOffset = matcher.end(4);
+      endOffset = Math.max(endOffset, matcher.end(4));
     }
 
     Matcher appEnginePathMatcher = APP_ENGINE_PATH_PATTERN.matcher(fileName);

File: gen/com/goide/psi/GoReceiver.java
Patch:
@@ -13,6 +13,9 @@ public interface GoReceiver extends GoNamedElement, StubBasedPsiElement<GoReceiv
   @Nullable
   GoType getType();
 
+  @Nullable
+  PsiElement getComma();
+
   @NotNull
   PsiElement getLparen();
 

File: src/com/goide/runconfig/application/GoApplicationRunningState.java
Patch:
@@ -79,6 +79,7 @@ public void run(@NotNull ProgressIndicator indicator) {
           }
           myExecutor = GoExecutor.in(myModule).withPresentableName("go build")
             .withParameters("build", "-o", myTempFile.getAbsolutePath(), myConfiguration.getFilePath())
+            .withWorkDirectory(myConfiguration.getWorkingDirectory())
             .withProcessOutput(processOutput).showOutputOnError();
           success.set(myExecutor.execute());
         }

File: src/com/goide/sdk/GoSdkService.java
Patch:
@@ -69,7 +69,7 @@ public static String getGoExecutablePath(@Nullable String sdkHomePath) {
     if (sdkHomePath != null) {
       return isAppEngineSdkPath(sdkHomePath)
              ? FileUtil.join(StringUtil.trimEnd(sdkHomePath, GoConstants.APP_ENGINE_GO_ROOT_DIRECTORY_PATH), GoConstants.GAE_EXECUTABLE_NAME)
-             : FileUtil.join(sdkHomePath, GoConstants.GO_EXECUTABLE_NAME);
+             : FileUtil.join(sdkHomePath, "bin", GoConstants.GO_EXECUTABLE_NAME);
     }
     return null;
   }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -76,6 +76,7 @@ protected boolean isWriteActionRequired() {
   public void testInterfaces()  { doTest(); }
   public void testReceiverType(){ doTest(); }
   public void testForRange()    { doTest(); }
+  public void testMismatch()    { doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: src/com/goide/inspections/GoVarDeclarationInspection.java
Patch:
@@ -87,7 +87,7 @@ private static Pair<List<? extends GoCompositeElement>, List<GoExpression>> getP
     if (assign == null) {
       return Pair.<List<? extends GoCompositeElement>, List<GoExpression>>create(ContainerUtil.<GoCompositeElement>emptyList(), ContainerUtil.<GoExpression>emptyList());
     }
-    if (varDeclaration instanceof GoRecvStatement) {
+    if (varDeclaration instanceof GoRecvStatement || varDeclaration instanceof GoRangeClause) {
       List<GoCompositeElement> v= ContainerUtil.newArrayList();
       List<GoExpression> e = ContainerUtil.newArrayList();
       for (PsiElement c : varDeclaration.getChildren()) {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -75,6 +75,7 @@ protected boolean isWriteActionRequired() {
   public void testTemplates()   { doTest(); }
   public void testInterfaces()  { doTest(); }
   public void testReceiverType(){ doTest(); }
+  public void testForRange()    { doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: gen/com/goide/psi/GoMethodExpr.java
Patch:
@@ -10,10 +10,10 @@ public interface GoMethodExpr extends GoExpression {
   @NotNull
   GoReceiverType getReceiverType();
 
-  @NotNull
-  PsiElement getDot();
+  @Nullable
+  GoReferenceExpression getReferenceExpression();
 
   @NotNull
-  PsiElement getIdentifier();
+  PsiElement getDot();
 
 }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -254,6 +254,9 @@ public static GoTypeReferenceExpression getTypeReference(@Nullable GoType o) {
       GoType type = o.getType();
       return type != null ? type.getTypeReferenceExpression() : null;
     }
+    if (o instanceof GoReceiverType) {
+      return PsiTreeUtil.findChildOfAnyType(o, GoTypeReferenceExpression.class);
+    }
     return o.getTypeReferenceExpression();
   }
 

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -74,6 +74,7 @@ protected boolean isWriteActionRequired() {
   public void testFuncType()    { doTest(); }
   public void testTemplates()   { doTest(); }
   public void testInterfaces()  { doTest(); }
+  public void testReceiverType(){ doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: tests/com/goide/psi/legacy/GoLegacyResolveStructTest.java
Patch:
@@ -23,6 +23,8 @@ public class GoLegacyResolveStructTest extends GoLegacyResolveTestBase {
   public void testDirectStructField()                       { doTest(); } 
   public void testAnonymousDirectStructField()              { doTest(); } 
   public void testPromotedStructField()                     { doTest(); } 
+  public void testFieldVsParam()                            { doTest(); } 
+  public void testFieldVsParam2()                           { doTest(); } 
   public void testDirectExportedFieldFromImportedPackage()  { doDirTest(); } 
   public void testDirectPrivateFieldFromImportedPackage()   { doDirTest(); }
 }

File: gen/com/goide/psi/GoLiteralValue.java
Patch:
@@ -13,7 +13,7 @@ public interface GoLiteralValue extends GoCompositeElement {
   @NotNull
   PsiElement getLbrace();
 
-  @NotNull
+  @Nullable
   PsiElement getRbrace();
 
 }

File: gen/com/goide/psi/impl/GoLiteralValueImpl.java
Patch:
@@ -34,9 +34,9 @@ public PsiElement getLbrace() {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public PsiElement getRbrace() {
-    return findNotNullChildByType(RBRACE);
+    return findChildByType(RBRACE);
   }
 
 }

File: tests/com/goide/editor/GoParameterInfoHandlerTest.java
Patch:
@@ -46,7 +46,8 @@ protected void setUp() throws Exception {
   public void testMethParam()         { doTest(1, "<html>num int, <b>text string</b></html>"); } 
   public void testMethParamNone()     { doTest(0, ""); } 
   public void testMethParamEllipsis() { doTest(5, "<html>num int, text string, <b>more ...int</b></html>"); }
-  
+  public void testFieldMethCall()     { doTest(0, "<html><b>a int</b>, b int</html>"); }
+
   private void doTest(int expectedParamIdx, String expectedPresentation) {
     // Given
     myFixture.configureByFile(getTestName(true) + ".go");

File: gen/com/goide/psi/GoIndexOrSliceExpr.java
Patch:
@@ -13,7 +13,7 @@ public interface GoIndexOrSliceExpr extends GoExpression {
   @NotNull
   PsiElement getLbrack();
 
-  @NotNull
+  @Nullable
   PsiElement getRbrack();
 
 }

File: gen/com/goide/psi/impl/GoIndexOrSliceExprImpl.java
Patch:
@@ -34,9 +34,9 @@ public PsiElement getLbrack() {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public PsiElement getRbrack() {
-    return findNotNullChildByType(RBRACK);
+    return findChildByType(RBRACK);
   }
 
 }

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -48,6 +48,7 @@ protected void setUp() throws Exception {
   public void testRanges()                          { doTest(true);  }
   public void testTorture()                         { doTest(true);  }
   public void testLiteralValues()                   { doTest(true);  }
+  public void testIfComposite()                     { doTest(true);  }
   public void testIf()                              { doTest(false); }
   public void testSimple()                          { doTest(false); }
   public void testRecover()                         { doTest(false); }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -631,7 +631,9 @@ public static GoType getGoType(@NotNull GoSignatureOwner o, @SuppressWarnings("U
         if (parametersType != null) return parametersType;
         List<GoType> composite = ContainerUtil.newArrayList();
         for (GoParameterDeclaration p : parameters.getParameterDeclarationList()) {
-          composite.add(p.getType());
+          for (GoParamDefinition definition : p.getParamDefinitionList()) {
+            composite.add(definition.getGoType(context));
+          }
         }
         class MyGoTypeList extends LightElement implements GoTypeList {
           @NotNull private final List<GoType> myTypes;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -51,6 +51,7 @@ protected boolean isWriteActionRequired() {
   public void testBoxes()       { doTest(); }
   public void testRanges()      { doTest(); }
   public void testSelector()    { doTest(); }
+  public void testComposite()   { doTest(); }
   public void testVars()        { doTest(); }
   public void testRecv()        { doTest(); }
   public void testPointers()    { doTest(); }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -850,7 +850,7 @@ public static boolean shouldGoDeeper(@SuppressWarnings("UnusedParameters") GoSig
   }
 
   public static boolean prevDot(@Nullable PsiElement parent) {
-    PsiElement prev = parent == null ? null : PsiTreeUtil.prevLeaf(parent);
+    PsiElement prev = parent == null ? null : PsiTreeUtil.prevLeaf(parent, true);
     return prev instanceof LeafElement && ((LeafElement)prev).getElementType() == GoTypes.DOT;
   }
 

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -316,7 +316,7 @@ private boolean processUnqualifiedResolve(@NotNull GoFile file,
     if (parent instanceof GoSelectorExpr) {
       boolean result = processSelector((GoSelectorExpr)parent, processor, state, myElement);
       if (processor.isCompletion()) return result;
-      if (!result) return false;
+      if (!result || prevDot(myElement)) return false;
     }
 
     PsiElement grandPa = parent.getParent();

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -50,6 +50,7 @@ protected boolean isWriteActionRequired() {
   public void testStruct()      { doTest(); }
   public void testBoxes()       { doTest(); }
   public void testRanges()      { doTest(); }
+  public void testSelector()    { doTest(); }
   public void testVars()        { doTest(); }
   public void testRecv()        { doTest(); }
   public void testPointers()    { doTest(); }

File: src/com/goide/GoAnnotator.java
Patch:
@@ -22,6 +22,7 @@
 import com.goide.psi.impl.GoReference;
 import com.intellij.lang.annotation.AnnotationHolder;
 import com.intellij.lang.annotation.Annotator;
+import com.intellij.openapi.application.ApplicationManager;
 import com.intellij.openapi.editor.colors.TextAttributesKey;
 import com.intellij.openapi.editor.markup.TextAttributes;
 import com.intellij.openapi.util.text.StringUtil;
@@ -193,7 +194,7 @@ private static void setHighlighting(@NotNull PsiElement element,
                                       @NotNull TextAttributesKey key,
                                       @Nullable String description) {
     holder.createInfoAnnotation(element, null).setEnforcedTextAttributes(TextAttributes.ERASE_MARKER);
-    holder.createInfoAnnotation(element, description).setTextAttributes(key);
+    holder.createInfoAnnotation(element, ApplicationManager.getApplication().isUnitTestMode() ? description : null).setTextAttributes(key);
   }
 
   private static boolean isPackageWide(@NotNull GoVarDefinition o) {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -529,6 +529,9 @@ private static GoType processRangeClause(@NotNull GoVarDefinition o, @NotNull Go
         PsiElement resolve = typeRef.getReference().resolve();
         if (resolve instanceof GoTypeSpec) {
           type = ((GoTypeSpec)resolve).getType();
+          if (type instanceof GoChannelType) {
+            return type.getType();
+          }
         }
       }
       if (type instanceof GoArrayOrSliceType && i == 1) return type.getType();

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -28,6 +28,7 @@
 import com.intellij.psi.PsiDirectory;
 import com.intellij.psi.PsiElement;
 import com.intellij.util.ObjectUtils;
+import com.intellij.util.PlatformIcons;
 import com.intellij.util.ui.UIUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -201,6 +202,7 @@ public static LookupElement createPackageLookupElement(@NotNull String str, bool
   @NotNull
   public static LookupElementBuilder createDirectoryLookupElement(@NotNull PsiDirectory dir) {
     int files = dir.getFiles().length;
-    return LookupElementBuilder.create(dir).withIcon(GoIcons.PACKAGE).withInsertHandler(files == 0 ? Lazy.DIR_INSERT_HANDLER : null);
+    return LookupElementBuilder.create(dir).withIcon(PlatformIcons.DIRECTORY_CLOSED_ICON)
+      .withInsertHandler(files == 0 ? Lazy.DIR_INSERT_HANDLER : null);
   }
 }

File: tests/com/goide/editor/GoParameterInfoHandlerTest.java
Patch:
@@ -34,6 +34,8 @@ protected void setUp() throws Exception {
     myParameterInfoHandler = new GoParameterInfoHandler();
   }
 
+  public void testUnnamedAndNamedParameters() { doTest(0, "<html><b>a string</b>, interface{}</html>"); }
+  public void testUnnamedParameters() { doTest(0, "<html><b>string</b>, interface{}</html>"); } 
   public void testFuncParam()         { doTest(1, "<html>num int, <b>text string</b></html>"); } 
   public void testFuncParamMulti()    { doTest(4, "<html>a int, b int, c int, d string, <b>e string</b>, f string</html>"); } 
   public void testFuncParamNone()     { doTest(0, ""); } 

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -48,6 +48,7 @@ protected void setUp() throws Exception {
   public void testRanges()                          { doTest(true);  }
   public void testTorture()                         { doTest(true);  }
   public void testLiteralValues()                   { doTest(true);  }
+  public void testIf()                              { doTest(false); }
   public void testSimple()                          { doTest(false); }
   public void testRecover()                         { doTest(false); }
   public void testRecover2()                        { doTest(false); }

File: tests/com/goide/completion/GoCompletionSdkAwareTest.java
Patch:
@@ -147,7 +147,7 @@ public void testImportedFunctionsPriority() {
                                       "func test(){ReadA<caret>}");
     failOnFileLoading();
     myFixture.completeBasic();
-    myFixture.assertPreferredCompletionItems(0, "ReadAtLeast", "ReaderAt", "ReadAtLeastCustom", "ReaderAtCustom");
+    myFixture.assertPreferredCompletionItems(0, "ReadAtLeast", "ReadAtLeastCustom", "ReaderAt", "ReaderAtCustom");
   }
 
   public void testImportedTypesPriority() {

File: src/com/goide/psi/impl/GoScopeProcessorBase.java
Patch:
@@ -33,7 +33,7 @@ public abstract class GoScopeProcessorBase extends BaseScopeProcessor {
 
   @NotNull protected final PsiElement myOrigin;
   @NotNull private final String myRequestedName;
-  private final boolean myIsCompletion;
+  protected final boolean myIsCompletion;
 
   public GoScopeProcessorBase(@NotNull String requestedName, @NotNull PsiElement origin, boolean completion) {
     myRequestedName = requestedName;

File: src/com/goide/psi/impl/GoVarProcessor.java
Patch:
@@ -44,7 +44,7 @@ protected boolean add(@NotNull GoNamedElement o) {
     boolean differentBlocks = differentBlocks(o);
     boolean inShortVar = PsiTreeUtil.getParentOfType(o, GoShortVarDeclaration.class, GoRecvStatement.class) != null;
     if (inShortVar && differentBlocks && myImShortVarDeclaration) return true;
-    if (differentBlocks && inShortVar && !inVarOrRange && getResult() != null) return true;
+    if (differentBlocks && inShortVar && !inVarOrRange && getResult() != null && !myIsCompletion) return true;
     if (inShortVar && fromNotAncestorBlock(o)) return true;
     return super.add(o) || !inVarOrRange;
   }

File: tests/com/goide/GoPerformanceTest.java
Patch:
@@ -46,7 +46,7 @@ public void testUnusedImport() {
 
   private void doInspectionTest(@NotNull InspectionProfileEntry tool, int expected) {
     if (!new File(myFixture.getTestDataPath(), "docker").exists()) {
-      System.err.println("For performance tests you need to have a docker project inside testData directory");
+      System.err.println("For performance tests you need to have a docker project inside testData/" + getBasePath() + " directory");
       return;
     }
 

File: src/com/goide/runconfig/GoRunningState.java
Patch:
@@ -44,11 +44,11 @@ protected ProcessHandler startProcess() throws ExecutionException {
   }
 
   @NotNull
-  private GoExecutor createExecutor() throws ExecutionException {
+  public GoExecutor createExecutor() throws ExecutionException {
     return patchExecutor(GoExecutor.in(myModule).withWorkDirectory(myConfiguration.getWorkingDirectory()))
       .withExtraEnvironment(myConfiguration.getCustomEnvironment())
       .withPassParentEnvironment(myConfiguration.isPassParentEnvironment())
-      .addParameterString(myConfiguration.getParams());
+      .withParameterString(myConfiguration.getParams());
   }
 
   protected GoExecutor patchExecutor(@NotNull GoExecutor executor) throws ExecutionException {

File: src/com/goide/runconfig/GoConsoleFilter.java
Patch:
@@ -53,7 +53,7 @@ public Result applyFilter(@NotNull String line, int entireLength) {
       HyperlinkInfo hyperlinkInfo = new HyperlinkInfo() {
         @Override
         public void navigate(Project project) {
-          GoGetPackageFix.applyFix(project, myModule, packageName);
+          GoGetPackageFix.applyFix(project, myModule, packageName, false);
         }
       };
       int lineStart = entireLength - line.length();

File: gen/com/goide/GoTypes.java
Patch:
@@ -76,7 +76,7 @@ public interface GoTypes {
   IElementType PARAM_DEFINITION = GoStubElementTypeFactory.factory("PARAM_DEFINITION");
   IElementType PARENTHESES_EXPR = new GoCompositeElementType("PARENTHESES_EXPR");
   IElementType POINTER_TYPE = GoStubElementTypeFactory.factory("POINTER_TYPE");
-  IElementType RANGE_CLAUSE = new GoCompositeElementType("RANGE_CLAUSE");
+  IElementType RANGE_CLAUSE = GoStubElementTypeFactory.factory("RANGE_CLAUSE");
   IElementType RECEIVER = GoStubElementTypeFactory.factory("RECEIVER");
   IElementType RECEIVER_TYPE = GoStubElementTypeFactory.factory("RECEIVER_TYPE");
   IElementType RECV_STATEMENT = GoStubElementTypeFactory.factory("RECV_STATEMENT");

File: gen/com/goide/parser/GoParser.java
Patch:
@@ -333,8 +333,8 @@ protected boolean parse_root_(IElementType t, PsiBuilder b, int l) {
   }
 
   public static final TokenSet[] EXTENDS_SETS_ = new TokenSet[] {
-    create_token_set_(RECV_STATEMENT, SHORT_VAR_DECLARATION, VAR_SPEC),
     create_token_set_(EXPR_SWITCH_STATEMENT, SWITCH_STATEMENT, TYPE_SWITCH_STATEMENT),
+    create_token_set_(RANGE_CLAUSE, RECV_STATEMENT, SHORT_VAR_DECLARATION, VAR_SPEC),
     create_token_set_(ADD_EXPR, CONVERSION_EXPR, MUL_EXPR, OR_EXPR),
     create_token_set_(ARRAY_OR_SLICE_TYPE, CHANNEL_TYPE, FUNCTION_TYPE, INTERFACE_TYPE,
       MAP_TYPE, POINTER_TYPE, RECEIVER_TYPE, STRUCT_TYPE,

File: gen/com/goide/psi/GoRangeClause.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoRangeClause extends GoCompositeElement {
+public interface GoRangeClause extends GoVarSpec {
 
   @NotNull
   List<GoExpression> getExpressionList();

File: gen/com/goide/psi/GoVisitor.java
Patch:
@@ -269,7 +269,7 @@ public void visitPointerType(@NotNull GoPointerType o) {
   }
 
   public void visitRangeClause(@NotNull GoRangeClause o) {
-    visitCompositeElement(o);
+    visitVarSpec(o);
   }
 
   public void visitReceiver(@NotNull GoReceiver o) {

File: src/com/goide/GoFileElementType.java
Patch:
@@ -30,7 +30,7 @@
 
 public class GoFileElementType extends IStubFileElementType<GoFileStub> {
   public static final IStubFileElementType INSTANCE = new GoFileElementType();
-  public static final int VERSION = 4;
+  public static final int VERSION = 5;
 
   public GoFileElementType() {
     super("GO_FILE", GoLanguage.INSTANCE);

File: src/com/goide/inspections/unresolved/GoUnusedVariableInspection.java
Patch:
@@ -38,9 +38,9 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
       @Override
       public void visitVarDefinition(@NotNull GoVarDefinition o) {
         if (o.isBlank()) return;
-        GoVarSpec shortDecl = PsiTreeUtil.getParentOfType(o, GoShortVarDeclaration.class, GoRecvStatement.class);
+        GoVarSpec varSpec = PsiTreeUtil.getParentOfType(o, GoVarSpec.class);
         GoVarDeclaration decl = PsiTreeUtil.getParentOfType(o, GoVarDeclaration.class);
-        if (shortDecl != null || decl != null) {
+        if (varSpec != null || decl != null) {
           PsiReference reference = o.getReference();
           PsiElement resolve = reference != null ? reference.resolve() : null;
           if (resolve != null) return;

File: src/com/goide/completion/GoAutoImportCompletionContributor.java
Patch:
@@ -78,7 +78,8 @@ protected void addCompletions(@NotNull CompletionParameters parameters,
         PsiElement position = parameters.getPosition();
         PsiElement parent = position.getParent();
         if (prevDot(parent)) return;
-
+        result = adjustMatcher(parameters, result, parent);
+        
         final PsiFile file = parameters.getOriginalFile();
         if (!(file instanceof GoFile)) return;
 
@@ -89,7 +90,6 @@ protected void addCompletions(@NotNull CompletionParameters parameters,
         if (parent instanceof GoReferenceExpression) {
           GoReferenceExpression qualifier = ((GoReferenceExpression)parent).getQualifier();
           if (qualifier == null || qualifier.getReference().resolve() == null) {
-            result = adjustMatcher(parameters, result, parent);
             for (String name : StubIndex.getInstance().getAllKeys(GoFunctionIndex.KEY, project)) {
               if (StringUtil.isCapitalized(name) && !StringUtil.startsWith(name, "Test") && !StringUtil.startsWith(name, "Benchmark")) {
                 for (GoFunctionDeclaration declaration : GoFunctionIndex.find(name, project, scope)) {

File: src/com/goide/runconfig/GoRunConfigurationBase.java
Patch:
@@ -65,7 +65,6 @@ public GoRunConfigurationBase(String name, GoModuleBasedConfiguration configurat
       }
     }
 
-
     if (module != null) {
       myWorkingDirectory = StringUtil.trimEnd(PathUtil.getParentPath(module.getModuleFilePath()), ".idea");
     }

File: src/com/goide/runconfig/ui/GoCommonSettingsPanel.java
Patch:
@@ -13,11 +13,14 @@
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import javax.swing.*;
+
 public class GoCommonSettingsPanel extends JBPanel {
   private RawCommandLineEditor myParamsField;
   private TextFieldWithBrowseButton myWorkingDirectoryField;
   private EnvironmentVariablesTextFieldWithBrowseButton myEnvironmentField;
   private ModulesComboBox myModulesComboBox;
+  @SuppressWarnings("unused") private JPanel myRoot;
 
   public void init(@NotNull Project project) {
     GoUtil.installFileChooser(project, myWorkingDirectoryField, true);

File: src/com/goide/psi/impl/imports/GoImportReference.java
Patch:
@@ -83,8 +83,8 @@ public boolean isReferenceTo(PsiElement element) {
       return true;
     }
 
-    if (element instanceof PsiPackage) {
-      for (PsiDirectory directory : ((PsiPackage)element).getDirectories()) {
+    if (element instanceof PsiDirectoryContainer) {
+      for (PsiDirectory directory : ((PsiDirectoryContainer)element).getDirectories()) {
         if (super.isReferenceTo(directory)) {
           return true;
         }

File: src/com/goide/configuration/ListenableHideableDecorator.java
Patch:
@@ -17,14 +17,15 @@
 package com.goide.configuration;
 
 import com.intellij.ui.HideableDecorator;
-import com.intellij.util.containers.ContainerUtil;
+import com.intellij.util.SmartList;
 import org.jetbrains.annotations.NotNull;
 
 import javax.swing.*;
 import java.util.Collection;
 
 class ListenableHideableDecorator extends HideableDecorator {
-  private final Collection<MyListener> myListeners = ContainerUtil.newSmartList();
+  // ContainerUtil.newSmartList() exists since 14.1
+  private final Collection<MyListener> myListeners = new SmartList<MyListener>();
 
   public ListenableHideableDecorator(@NotNull JPanel panel, @NotNull String displayName, @NotNull JComponent content) {
     super(panel, displayName, false);

File: src/com/goide/runconfig/GoRunConfigurationWithMain.java
Patch:
@@ -48,9 +48,9 @@ public String getWorkingDirectory() {
 
   @Override
   public void checkConfiguration() throws RuntimeConfigurationException {
+    super.checkConfiguration();
+    
     GoModuleBasedConfiguration configurationModule = getConfigurationModule();
-    configurationModule.checkForWarning();
-
     Module module = configurationModule.getModule();
     if (module == null) return;
     VirtualFile file = VfsUtil.findFileByIoFile(new File(getFilePath()), false);

File: src/com/goide/runconfig/testing/GoTestRunConfiguration.java
Patch:
@@ -68,8 +68,8 @@ protected GoTestRunningState newRunningState(@NotNull ExecutionEnvironment env,
 
   @Override
   public void checkConfiguration() throws RuntimeConfigurationException {
+    super.checkConfiguration();
     GoModuleBasedConfiguration configurationModule = getConfigurationModule();
-    configurationModule.checkForWarning();
     if (myWorkingDirectory.isEmpty()) {
       throw new RuntimeConfigurationError("Working directory is not specified");
     }

File: src/com/goide/GoAnnotator.java
Patch:
@@ -40,6 +40,9 @@ public void annotate(@NotNull PsiElement o, @NotNull AnnotationHolder holder) {
         o.putUserData(GoReference.IMPORT_USERS, ContainerUtil.<PsiElement>newArrayListWithCapacity(0));
       }
     }
+    else if (o instanceof GoLiteral) {
+      setHighlighting(o, holder, GoSyntaxHighlightingColors.NUMBER);
+    }
     else if (o instanceof GoReferenceExpression) {
       PsiElement resolve = ((GoReferenceExpression)o).getReference().resolve();
       highlightRefIfNeeded((GoReferenceExpression)o, resolve, holder);      

File: gen/com/goide/psi/GoElement.java
Patch:
@@ -10,7 +10,7 @@ public interface GoElement extends GoCompositeElement {
   @Nullable
   GoKey getKey();
 
-  @NotNull
+  @Nullable
   GoValue getValue();
 
   @Nullable

File: gen/com/goide/psi/impl/GoElementImpl.java
Patch:
@@ -28,9 +28,9 @@ public GoKey getKey() {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public GoValue getValue() {
-    return findNotNullChildByClass(GoValue.class);
+    return findChildByClass(GoValue.class);
   }
 
   @Override

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -47,6 +47,7 @@ protected void setUp() throws Exception {
   public void testIfWithNew()                       { doTest(true);  }
   public void testRanges()                          { doTest(true);  }
   public void testTorture()                         { doTest(true);  }
+  public void testLiteralValues()                   { doTest(true);  }
   public void testSimple()                          { doTest(false); }
   public void testRecover()                         { doTest(false); }
   public void testRecover2()                        { doTest(false); }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -73,6 +73,7 @@ protected boolean isWriteActionRequired() {
   public void testFuncLiteral() { doTest(); }
   public void testFuncType()    { doTest(); }
   public void testTemplates()   { doTest(); }
+  public void testInterfaces()  { doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -101,8 +101,7 @@ private void fillCommandLineWithParameters(@NotNull GeneralCommandLine commandLi
     }
     String pattern = myConfiguration.getPattern();
     if (StringUtil.isNotEmpty(pattern)) {
-      commandLine.addParameter("-run");
-      commandLine.addParameter(pattern);
+      commandLine.addParameters("-run", pattern);
     }
   }
 }

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -101,7 +101,8 @@ private void fillCommandLineWithParameters(@NotNull GeneralCommandLine commandLi
     }
     String pattern = myConfiguration.getPattern();
     if (StringUtil.isNotEmpty(pattern)) {
-      commandLine.addParameter("--run='" + pattern + "'");
+      commandLine.addParameter("-run");
+      commandLine.addParameter(pattern);
     }
   }
 }

File: src/com/goide/runconfig/before/GoBeforeRunTaskProvider.java
Patch:
@@ -28,12 +28,12 @@
 import com.intellij.openapi.ui.Messages;
 import com.intellij.openapi.util.Key;
 import com.intellij.openapi.util.Ref;
+import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.openapi.vfs.VirtualFileManager;
 import com.intellij.util.concurrency.Semaphore;
 import com.intellij.util.ui.UIUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.jetbrains.generate.tostring.util.StringUtil;
 
 import javax.swing.*;
 import java.util.ArrayList;

File: src/com/goide/runconfig/before/GoBeforeRunTaskProvider.java
Patch:
@@ -28,12 +28,12 @@
 import com.intellij.openapi.ui.Messages;
 import com.intellij.openapi.util.Key;
 import com.intellij.openapi.util.Ref;
+import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.openapi.vfs.VirtualFileManager;
 import com.intellij.util.concurrency.Semaphore;
 import com.intellij.util.ui.UIUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.jetbrains.generate.tostring.util.StringUtil;
 
 import javax.swing.*;
 import java.util.ArrayList;

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -71,8 +71,7 @@ protected GeneralCommandLine getCommand(String sdkHomePath) throws ExecutionExce
     GeneralCommandLine runTests = new GeneralCommandLine();
     runTests.getEnvironment().put(GoConstants.GO_PATH, GoSdkUtil.retrieveGoPath(myModule));
     runTests.setExePath(executable);
-    runTests.addParameter("test");
-    runTests.addParameter("-v");
+    runTests.addParameters("test", "-v");
     fillCommandLineWithParameters(runTests);
     runTests.getParametersList().addParametersString(myConfiguration.getParams());
     return runTests;

File: src/com/goide/runconfig/before/GoBeforeRunTaskProvider.java
Patch:
@@ -176,7 +176,7 @@ public void run() {
                 processHandler.startNotify();
                 ExecutionHelper.executeExternalProcess(project, processHandler, new ExecutionModes.SameThreadMode(60), commandLine);
 
-                ExecutionHelper.showOutput(project, processAdapter.getOutput(), "Executing `" + task.toString() + "`", null, true);
+                ExecutionHelper.showOutput(project, processAdapter.getOutput(), "Executing `" + task.toString() + "`", null, !result.get());
               }
               catch (ExecutionException e) {
                 exceptions.add(e);

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -143,6 +143,9 @@ public String fun(VirtualFile file) {
 
   @NotNull
   public static String getSrcLocation(@NotNull String version) {
+    if (version.contains("devel")) {
+      return "src";
+    }
     return compareVersions(version, "1.4") < 0 ? "src/pkg" : "src";
   }
 

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -143,6 +143,9 @@ public String fun(VirtualFile file) {
 
   @NotNull
   public static String getSrcLocation(@NotNull String version) {
+    if (version.contains("devel")) {
+      return "src";
+    }
     return compareVersions(version, "1.4") < 0 ? "src/pkg" : "src";
   }
 

File: src/com/goide/debugger/ideagdb/run/GdbRunner.java
Patch:
@@ -73,7 +73,7 @@ env, contentToReuse, new XDebugProcessStarter() {
       @NotNull
       @Override
       public XDebugProcess start(@NotNull XDebugSession session) throws ExecutionException {
-        session.setAutoInitBreakpoints(false);
+        //session.setAutoInitBreakpoints(false); // todo[vova]: ?
         final ExecutionResult result = state.execute(executor, GdbRunner.this);
         return new GdbDebugProcess(session, (GdbExecutionResult)result);
       }

File: src/com/goide/codeInsight/imports/GoImportOptimizer.java
Patch:
@@ -105,7 +105,7 @@ public static MultiMap<String, GoImportSpec> filterUnusedImports(@NotNull PsiFil
     for (GoImportSpec importEntry : implicitImports) {
       GoImportSpec spec = getImportSpec(importEntry);
       if (spec != null && spec.getDot() != null) {
-        List<PsiElement> list = spec.getUserData(GoReference.IMPORT_USERS);
+        List<? extends PsiElement> list = spec.getUserData(GoReference.IMPORT_USERS);
         if (list != null) {
           for (PsiElement e : list) {
             if (e.isValid()) {

File: src/com/goide/codeInsight/imports/GoImportPackageQuickFix.java
Patch:
@@ -153,8 +153,9 @@ public boolean isAvailable(@NotNull Project project,
                              @NotNull PsiFile file,
                              @NotNull PsiElement startElement,
                              @NotNull PsiElement endElement) {
-    return !isPerformed && file instanceof GoFile && file.getManager().isInProject(file) && !getPackagesToImport(startElement).isEmpty()
-           && notQualified(startElement);
+    return !isPerformed && file instanceof GoFile && file.getManager().isInProject(file) && myReference.resolve() == null
+           && !myPackageName.endsWith("_test")
+           && !getPackagesToImport(startElement).isEmpty() && notQualified(startElement);
   }
 
   private static boolean notQualified(@Nullable PsiElement startElement) {

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -234,7 +234,7 @@ private boolean processExistingType(@NotNull GoType type,
           if (!processNamedElements(processor, state, ContainerUtil.createMaybeSingletonList(anon), localResolve)) return false;
         }
       }
-      if (!processCollectedRefs(type, refs, processor, state)) return false;
+      if (!processCollectedRefs(type, refs, processor, state.put(POINTER, null))) return false;
     }
     else if (state.get(POINTER) == null && type instanceof GoInterfaceType) {
       if (!processNamedElements(processor, state, ((GoInterfaceType)type).getMethods(), localResolve)) return false;

File: src/com/goide/completion/GoAutoImportCompletionContributor.java
Patch:
@@ -114,7 +114,7 @@ protected void addCompletions(@NotNull CompletionParameters parameters,
                     }
                     priority = GoCompletionUtil.TYPE_PRIORITY;
                   }
-                  result.addElement(GoCompletionUtil.createTypeLookupElement(declaration, true, TYPE_INSERT_HANDLER, priority));
+                  result.addElement(GoCompletionUtil.createTypeLookupElement(declaration, name, true, TYPE_INSERT_HANDLER, priority));
                 }
               }
             }

File: tests/com/goide/psi/legacy/GoLegacyResolveTypesTest.java
Patch:
@@ -24,6 +24,7 @@ public class GoLegacyResolveTypesTest extends GoLegacyResolveTestBase {
   public void testFromMethodReceiver()                            { doTest(); } 
   public void testResolveTypeNameInTypeSpec()                     { doTest(); } 
   public void testResolveTypeInCast()                             { doTest(); } 
+  public void testMethodsOrder()                                  { doTest(); } 
   public void testFromDefaultImportedPackage()                    { doDirTest(); } 
   public void testFromInjectedPackage()                           { doDirTest(); } 
   public void testFromCustomImportedPackage()                     { doDirTest(); } 

File: src/com/goide/util/GoStringLiteralEscaper.java
Patch:
@@ -296,11 +296,9 @@ public static void escapeString(@NotNull String chars, @NotNull StringBuilder ou
         default:
           switch (Character.getType(c)) {
             case Character.CONTROL:
-            case Character.FORMAT:
             case Character.PRIVATE_USE:
             case Character.UNASSIGNED:
-              outChars.append("\\u");
-              outChars.append(String.format(Locale.US, "%04X", c));
+              outChars.append("\\u").append(String.format(Locale.US, "%04X", c));
               break;
 
             default:

File: src/com/goide/actions/GoCreateFileAction.java
Patch:
@@ -42,7 +42,7 @@ public class GoCreateFileAction extends CreateFileFromTemplateAction implements
 
   @Override
   protected PsiFile createFile(String name, @NotNull String templateName, @NotNull PsiDirectory dir) {
-    FileTemplate template = FileTemplateManager.getDefaultInstance().getInternalTemplate(templateName);
+    FileTemplate template = FileTemplateManager.getInstance().getInternalTemplate(templateName);
     Properties properties = new Properties();
     properties.setProperty(PACKAGE, ContainerUtil.getLastItem(StringUtil.split(dir.getName(), "-")));
     try {

File: src/com/goide/runconfig/testing/GoTestRunningState.java
Patch:
@@ -56,7 +56,7 @@ public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunne
     consoleView.addMessageFilter(new GoTestConsoleFilter(myModule, myConfiguration.getWorkingDirectory()));
 
     DefaultExecutionResult executionResult = new DefaultExecutionResult(consoleView, processHandler);
-    executionResult.setRestartActions(new ToggleAutoTestAction());
+    executionResult.setRestartActions(new ToggleAutoTestAction(getEnvironment()));
     return executionResult;
   }
 

File: gen/com/goide/psi/GoAnonymousFieldDefinition.java
Patch:
@@ -6,6 +6,7 @@
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.StubBasedPsiElement;
 import com.goide.stubs.GoAnonymousFieldDefinitionStub;
+import com.intellij.psi.ResolveState;
 
 public interface GoAnonymousFieldDefinition extends GoNamedElement, StubBasedPsiElement<GoAnonymousFieldDefinitionStub> {
 
@@ -24,6 +25,6 @@ public interface GoAnonymousFieldDefinition extends GoNamedElement, StubBasedPsi
   int getTextOffset();
 
   @Nullable
-  GoType getGoType();
+  GoType getGoType(ResolveState context);
 
 }

File: gen/com/goide/psi/GoConstDefinition.java
Patch:
@@ -6,13 +6,14 @@
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.StubBasedPsiElement;
 import com.goide.stubs.GoConstDefinitionStub;
+import com.intellij.psi.ResolveState;
 
 public interface GoConstDefinition extends GoNamedElement, StubBasedPsiElement<GoConstDefinitionStub> {
 
   @NotNull
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType();
+  GoType getGoType(ResolveState context);
 
 }

File: gen/com/goide/psi/GoExpression.java
Patch:
@@ -4,10 +4,11 @@
 import java.util.List;
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
+import com.intellij.psi.ResolveState;
 
 public interface GoExpression extends GoTypeOwner {
 
   @Nullable
-  GoType getGoType();
+  GoType getGoType(ResolveState context);
 
 }

File: gen/com/goide/psi/GoMethodSpec.java
Patch:
@@ -6,6 +6,7 @@
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.StubBasedPsiElement;
 import com.goide.stubs.GoMethodSpecStub;
+import com.intellij.psi.ResolveState;
 
 public interface GoMethodSpec extends GoNamedSignatureOwner, StubBasedPsiElement<GoMethodSpecStub> {
 
@@ -19,7 +20,7 @@ public interface GoMethodSpec extends GoNamedSignatureOwner, StubBasedPsiElement
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType();
+  GoType getGoType(ResolveState context);
 
   @Nullable
   String getName();

File: gen/com/goide/psi/GoReceiver.java
Patch:
@@ -6,6 +6,7 @@
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.StubBasedPsiElement;
 import com.goide.stubs.GoReceiverStub;
+import com.intellij.psi.ResolveState;
 
 public interface GoReceiver extends GoNamedElement, StubBasedPsiElement<GoReceiverStub> {
 
@@ -25,6 +26,6 @@ public interface GoReceiver extends GoNamedElement, StubBasedPsiElement<GoReceiv
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType();
+  GoType getGoType(ResolveState context);
 
 }

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -6,6 +6,7 @@
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.StubBasedPsiElement;
 import com.goide.stubs.GoTypeSpecStub;
+import com.intellij.psi.ResolveState;
 
 public interface GoTypeSpec extends GoNamedElement, StubBasedPsiElement<GoTypeSpecStub> {
 
@@ -16,7 +17,7 @@ public interface GoTypeSpec extends GoNamedElement, StubBasedPsiElement<GoTypeSp
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType();
+  GoType getGoType(ResolveState context);
 
   @NotNull
   List<GoMethodDeclaration> getMethods();

File: gen/com/goide/psi/GoVarDefinition.java
Patch:
@@ -7,14 +7,15 @@
 import com.intellij.psi.StubBasedPsiElement;
 import com.goide.stubs.GoVarDefinitionStub;
 import com.intellij.psi.PsiReference;
+import com.intellij.psi.ResolveState;
 
 public interface GoVarDefinition extends GoNamedElement, StubBasedPsiElement<GoVarDefinitionStub> {
 
   @NotNull
   PsiElement getIdentifier();
 
   @Nullable
-  GoType getGoType();
+  GoType getGoType(ResolveState context);
 
   @Nullable
   PsiReference getReference();

File: gen/com/goide/psi/impl/GoAnonymousFieldDefinitionImpl.java
Patch:
@@ -10,6 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.stubs.GoAnonymousFieldDefinitionStub;
 import com.goide.psi.*;
+import com.intellij.psi.ResolveState;
 import com.intellij.psi.stubs.IStubElementType;
 
 public class GoAnonymousFieldDefinitionImpl extends GoNamedElementImpl<GoAnonymousFieldDefinitionStub> implements GoAnonymousFieldDefinition {
@@ -54,8 +55,8 @@ public int getTextOffset() {
   }
 
   @Nullable
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 
 }

File: gen/com/goide/psi/impl/GoConstDefinitionImpl.java
Patch:
@@ -10,6 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.stubs.GoConstDefinitionStub;
 import com.goide.psi.*;
+import com.intellij.psi.ResolveState;
 import com.intellij.psi.stubs.IStubElementType;
 
 public class GoConstDefinitionImpl extends GoNamedElementImpl<GoConstDefinitionStub> implements GoConstDefinition {
@@ -34,8 +35,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 
 }

File: gen/com/goide/psi/impl/GoExpressionImpl.java
Patch:
@@ -9,6 +9,7 @@
 import com.intellij.psi.util.PsiTreeUtil;
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
+import com.intellij.psi.ResolveState;
 
 public class GoExpressionImpl extends GoCompositeElementImpl implements GoExpression {
 
@@ -22,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Nullable
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 
 }

File: gen/com/goide/psi/impl/GoMethodSpecImpl.java
Patch:
@@ -10,6 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.stubs.GoMethodSpecStub;
 import com.goide.psi.*;
+import com.intellij.psi.ResolveState;
 import com.intellij.psi.stubs.IStubElementType;
 
 public class GoMethodSpecImpl extends GoNamedElementImpl<GoMethodSpecStub> implements GoMethodSpec {
@@ -46,8 +47,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 
   @Nullable

File: gen/com/goide/psi/impl/GoReceiverImpl.java
Patch:
@@ -10,6 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.stubs.GoReceiverStub;
 import com.goide.psi.*;
+import com.intellij.psi.ResolveState;
 import com.intellij.psi.stubs.IStubElementType;
 
 public class GoReceiverImpl extends GoNamedElementImpl<GoReceiverStub> implements GoReceiver {
@@ -58,8 +59,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 
 }

File: gen/com/goide/psi/impl/GoTypeSpecImpl.java
Patch:
@@ -10,6 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.stubs.GoTypeSpecStub;
 import com.goide.psi.*;
+import com.intellij.psi.ResolveState;
 import com.intellij.psi.stubs.IStubElementType;
 
 public class GoTypeSpecImpl extends GoNamedElementImpl<GoTypeSpecStub> implements GoTypeSpec {
@@ -40,8 +41,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 
   @NotNull

File: gen/com/goide/psi/impl/GoVarDefinitionImpl.java
Patch:
@@ -11,6 +11,7 @@
 import com.goide.stubs.GoVarDefinitionStub;
 import com.goide.psi.*;
 import com.intellij.psi.PsiReference;
+import com.intellij.psi.ResolveState;
 import com.intellij.psi.stubs.IStubElementType;
 
 public class GoVarDefinitionImpl extends GoNamedElementImpl<GoVarDefinitionStub> implements GoVarDefinition {
@@ -35,8 +36,8 @@ public PsiElement getIdentifier() {
   }
 
   @Nullable
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 
   @Nullable

File: src/com/goide/actions/internal/GoShowTypeInternalAction.java
Patch:
@@ -39,7 +39,7 @@ public GoShowTypeInternalAction() {
   @Nullable
   @Override
   protected String getInformationHint(@NotNull GoExpression element) {
-    GoType type = element.getGoType();
+    GoType type = element.getGoType(null);
     return type != null ? type.getText() : "<null>";
   }
 

File: src/com/goide/completion/GoCompletionUtil.java
Patch:
@@ -164,7 +164,7 @@ public static LookupElement createVariableLikeLookupElement(@NotNull GoNamedElem
                 v instanceof GoConstDefinition ? GoIcons.CONST :
                 v instanceof GoAnonymousFieldDefinition ? GoIcons.FIELD :
                 null;
-    GoType type = v.getGoType();
+    GoType type = v.getGoType(null);
     String text = GoPsiImplUtil.getText(type);
     return PrioritizedLookupElement.withPriority(
       LookupElementBuilder

File: src/com/goide/editor/GoTypeDeclarationProvider.java
Patch:
@@ -22,14 +22,15 @@
 import com.intellij.codeInsight.navigation.actions.TypeDeclarationProvider;
 import com.intellij.psi.PsiElement;
 import com.intellij.psi.PsiReference;
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 public class GoTypeDeclarationProvider implements TypeDeclarationProvider {
   @Nullable
   @Override
-  public PsiElement[] getSymbolTypeDeclarations(PsiElement element) {
+  public PsiElement[] getSymbolTypeDeclarations(@NotNull PsiElement element) {
     if (!(element instanceof GoNamedElement)) return PsiElement.EMPTY_ARRAY;
-    GoType type = ((GoNamedElement)element).getGoType();
+    GoType type = ((GoNamedElement)element).getGoType(null);
     GoTypeReferenceExpression ref = type != null ? type.getTypeReferenceExpression() : null;
     PsiReference reference = ref != null ? ref.getReference() : null;
     PsiElement resolve = reference != null ? reference.resolve() : type; // todo: think about better fallback instead of `type`

File: src/com/goide/psi/GoTypeOwner.java
Patch:
@@ -16,9 +16,10 @@
 
 package com.goide.psi;
 
+import com.intellij.psi.ResolveState;
 import org.jetbrains.annotations.Nullable;
 
 public interface GoTypeOwner extends GoCompositeElement {
   @Nullable
-  GoType getGoType();
+  GoType getGoType(@Nullable ResolveState context);
 }

File: src/com/goide/psi/impl/GoFunctionOrMethodDeclarationImpl.java
Patch:
@@ -20,6 +20,7 @@
 import com.goide.psi.GoType;
 import com.goide.stubs.GoFunctionOrMethodDeclarationStub;
 import com.intellij.lang.ASTNode;
+import com.intellij.psi.ResolveState;
 import com.intellij.psi.stubs.IStubElementType;
 import org.jetbrains.annotations.NotNull;
 
@@ -33,7 +34,7 @@ public GoFunctionOrMethodDeclarationImpl(@NotNull ASTNode node) {
     super(node);
   }
 
-  public GoType getGoType() {
-    return GoPsiImplUtil.getGoType(this);
+  public GoType getGoType(ResolveState context) {
+    return GoPsiImplUtil.getGoType(this, context);
   }
 }
\ No newline at end of file

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -88,7 +88,7 @@ public PsiElement setName(@NonNls @NotNull String newName) throws IncorrectOpera
 
   @Nullable
   @Override
-  public GoType getGoType() {
+  public GoType getGoType(ResolveState context) {
     return findSiblingType();
   }
 

File: src/com/goide/tree/GoStructureViewFactory.java
Patch:
@@ -162,7 +162,7 @@ else if (myElement instanceof GoTypeSpec) {
         return ((GoTypeSpec)myElement).getName() + appendix;
       }
       else if (myElement instanceof GoNamedElement) {
-        GoType type = ((GoNamedElement)myElement).getGoType();
+        GoType type = ((GoNamedElement)myElement).getGoType(null);
         String typeText = type == null || myElement instanceof GoAnonymousFieldDefinition ? "" : separator + GoPsiImplUtil.getText(type);
         return ((GoNamedElement)myElement).getName() + typeText;
       }

File: gen/com/goide/psi/GoSignature.java
Patch:
@@ -15,4 +15,6 @@ public interface GoSignature extends GoCompositeElement, StubBasedPsiElement<GoS
   @Nullable
   GoResult getResult();
 
+  boolean shouldGoDeeper();
+
 }

File: src/com/goide/psi/GoCompositeElement.java
Patch:
@@ -19,4 +19,5 @@
 import com.intellij.psi.PsiElement;
 
 public interface GoCompositeElement extends PsiElement {
+  boolean shouldGoDeeper();
 }

File: gen/com/goide/psi/GoLiteral.java
Patch:
@@ -34,7 +34,4 @@ public interface GoLiteral extends GoExpression {
   @Nullable
   PsiElement getRune();
 
-  @Nullable
-  PsiElement getString();
-
 }

File: src/com/goide/GoParserDefinition.java
Patch:
@@ -44,7 +44,7 @@ public class GoParserDefinition implements ParserDefinition {
 
   public static final TokenSet WHITESPACES = TokenSet.create(WS, NLS);
   public static final TokenSet COMMENTS = TokenSet.create(LINE_COMMENT, MULTILINE_COMMENT);
-  public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, CHAR);
+  public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, RAW_STRING, CHAR);
   public static final TokenSet NUMBERS = TokenSet.create(INT, FLOAT, IMAGINARY, DECIMALI, FLOATI); // todo: HEX, OCT,
   public static final TokenSet KEYWORDS = TokenSet.create(
     PACKAGE, IMPORT, BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT,

File: src/com/goide/editor/GoQuoteHandler.java
Patch:
@@ -24,7 +24,7 @@
 
 public class GoQuoteHandler extends SimpleTokenSetQuoteHandler {
   public GoQuoteHandler() {
-    super(GoTypes.STRING, GoTypes.CHAR, TokenType.BAD_CHARACTER);
+    super(GoTypes.STRING, GoTypes.RAW_STRING, GoTypes.CHAR, TokenType.BAD_CHARACTER);
   }
 
   @Override

File: gen/com/goide/psi/GoLiteral.java
Patch:
@@ -34,7 +34,4 @@ public interface GoLiteral extends GoExpression {
   @Nullable
   PsiElement getRune();
 
-  @Nullable
-  PsiElement getString();
-
 }

File: src/com/goide/GoParserDefinition.java
Patch:
@@ -44,7 +44,7 @@ public class GoParserDefinition implements ParserDefinition {
 
   public static final TokenSet WHITESPACES = TokenSet.create(WS, NLS);
   public static final TokenSet COMMENTS = TokenSet.create(LINE_COMMENT, MULTILINE_COMMENT);
-  public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, CHAR);
+  public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, RAW_STRING, CHAR);
   public static final TokenSet NUMBERS = TokenSet.create(INT, FLOAT, IMAGINARY, DECIMALI, FLOATI); // todo: HEX, OCT,
   public static final TokenSet KEYWORDS = TokenSet.create(
     PACKAGE, IMPORT, BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT,

File: src/com/goide/editor/GoQuoteHandler.java
Patch:
@@ -24,7 +24,7 @@
 
 public class GoQuoteHandler extends SimpleTokenSetQuoteHandler {
   public GoQuoteHandler() {
-    super(GoTypes.STRING, GoTypes.CHAR, TokenType.BAD_CHARACTER);
+    super(GoTypes.STRING, GoTypes.RAW_STRING, GoTypes.CHAR, TokenType.BAD_CHARACTER);
   }
 
   @Override

File: gen/com/goide/GoTypes.java
Patch:
@@ -176,6 +176,7 @@ public interface GoTypes {
   IElementType QUOTIENT = new GoTokenType("/");
   IElementType QUOTIENT_ASSIGN = new GoTokenType("/=");
   IElementType RANGE = new GoTokenType("range");
+  IElementType RAW_STRING = new GoTokenType("raw_string");
   IElementType RBRACE = new GoTokenType("}");
   IElementType RBRACK = new GoTokenType("]");
   IElementType REMAINDER = new GoTokenType("%");

File: src/com/goide/GoParserDefinition.java
Patch:
@@ -44,7 +44,7 @@ public class GoParserDefinition implements ParserDefinition {
 
   public static final TokenSet WHITESPACES = TokenSet.create(WS, NLS);
   public static final TokenSet COMMENTS = TokenSet.create(LINE_COMMENT, MULTILINE_COMMENT);
-  public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, CHAR);
+  public static final TokenSet STRING_LITERALS = TokenSet.create(STRING, RAW_STRING, CHAR);
   public static final TokenSet NUMBERS = TokenSet.create(INT, FLOAT, IMAGINARY, DECIMALI, FLOATI); // todo: HEX, OCT,
   public static final TokenSet KEYWORDS = TokenSet.create(
     PACKAGE, IMPORT, BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT,

File: src/com/goide/editor/GoQuoteHandler.java
Patch:
@@ -24,7 +24,7 @@
 
 public class GoQuoteHandler extends SimpleTokenSetQuoteHandler {
   public GoQuoteHandler() {
-    super(GoTypes.STRING, GoTypes.CHAR, TokenType.BAD_CHARACTER);
+    super(GoTypes.STRING, GoTypes.RAW_STRING, GoTypes.CHAR, TokenType.BAD_CHARACTER);
   }
 
   @Override

File: gen/com/goide/psi/GoLiteral.java
Patch:
@@ -34,7 +34,4 @@ public interface GoLiteral extends GoExpression {
   @Nullable
   PsiElement getRune();
 
-  @Nullable
-  PsiElement getString();
-
 }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -70,6 +70,7 @@ protected boolean isWriteActionRequired() {
   public void testConsts()      { doTest(); }
   public void testFields()      { doTest(); }
   public void testFuncLiteral() { doTest(); }
+  public void testFuncType()    { doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: src/com/goide/go/GoGotoUtil.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.goide.go;
 
-import com.goide.GoStructureViewFactory;
 import com.goide.psi.GoFile;
 import com.goide.psi.GoNamedElement;
+import com.goide.tree.GoStructureViewFactory;
 import com.intellij.navigation.NavigationItem;
 import com.intellij.openapi.project.Project;
 import com.intellij.psi.search.GlobalSearchScope;

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -29,7 +29,8 @@ public void setUp() throws Exception {
       GoVarDeclarationInspection.class,
       GoNoNewVariablesInspection.class,
       GoReturnInspection.class,
-      GoFunctionCallInspection.class
+      GoFunctionCallInspection.class,
+      GoDeferGoInspection.class
     );
   }
 

File: src/com/goide/runconfig/file/GoRunFileRunningState.java
Patch:
@@ -49,6 +49,7 @@ protected GeneralCommandLine getCommand(String sdkHomePath) throws ExecutionExce
     list.add("run");
     String filePath = myConfiguration.getFilePath();
     list.addParametersString(filePath);
+    list.addParametersString(myConfiguration.getParams());
     commandLine.withWorkDirectory(PathUtil.getParentPath(filePath));
     TextConsoleBuilder consoleBuilder = TextConsoleBuilderFactory.getInstance().createBuilder(myModule.getProject());
     setConsoleBuilder(consoleBuilder);

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -70,6 +70,7 @@ protected boolean isWriteActionRequired() {
   public void testBackticks()   { doTest(); }
   public void testConsts()      { doTest(); }
   public void testFields()      { doTest(); }
+  public void testFuncLiteral() { doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: src/com/goide/sdk/GoSdkUtil.java
Patch:
@@ -116,8 +116,8 @@ public static Collection<VirtualFile> getGoPathsSourcesFromEnvironment() {
   }
   
   @Nullable
-  private static VirtualFile findSourceDirectory(VirtualFile file) {
-    return FileUtil.namesEqual("src", file.getName()) ? file : file.findChild("src");
+  private static VirtualFile findSourceDirectory(@Nullable VirtualFile file) {
+    return file == null || FileUtil.namesEqual("src", file.getName()) ? file : file.findChild("src");
   }
 
   @NotNull

File: src/com/goide/inspections/GoUnusedImportDeclaration.java
Patch:
@@ -60,9 +60,8 @@ protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsH
     for (GoImportSpec duplicatedImportSpec : GoImportOptimizer.findDuplicatedEntries(importMap)) {
       problemsHolder.registerProblem(duplicatedImportSpec, "Redeclared import", ProblemHighlightType.GENERIC_ERROR, OPTIMIZE_QUICK_FIX);
     }
-
-    GoImportOptimizer.filterUnusedImports(file, importMap);
-    for (PsiElement importEntry : importMap.values()) {
+    
+    for (PsiElement importEntry : GoImportOptimizer.filterUnusedImports(file, importMap).values()) {
       GoImportSpec spec = GoImportOptimizer.getImportSpec(importEntry);
       if (spec != null && !spec.isBlank()) {
         if (spec.getImportString().resolve() != null) {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -723,7 +723,9 @@ public static GoImportSpec addImportSpec(@NotNull GoImportDeclaration declaratio
     PsiElement rParen = declaration.getRparen();
     assert rParen != null;
     declaration.addBefore(GoElementFactory.createNewLine(declaration.getProject()), rParen);
-    return (GoImportSpec)declaration.addBefore(GoElementFactory.createImportSpec(declaration.getProject(), packagePath, alias), rParen);
+    GoImportSpec spec = (GoImportSpec)declaration.addBefore(GoElementFactory.createImportSpec(declaration.getProject(), packagePath, alias), rParen);
+    declaration.addBefore(GoElementFactory.createNewLine(declaration.getProject()), rParen);
+    return spec;
   }
 
   public static String getLocalPackageName(@NotNull GoImportSpec importSpec, boolean treatAliasAsLocalName) {

File: gen/com/goide/psi/GoIndexOrSliceExpr.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoIndexExpr extends GoExpression {
+public interface GoIndexOrSliceExpr extends GoExpression {
 
   @NotNull
   List<GoExpression> getExpressionList();

File: gen/com/goide/psi/impl/GoIndexOrSliceExprImpl.java
Patch:
@@ -10,14 +10,14 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoIndexExprImpl extends GoExpressionImpl implements GoIndexExpr {
+public class GoIndexOrSliceExprImpl extends GoExpressionImpl implements GoIndexOrSliceExpr {
 
-  public GoIndexExprImpl(ASTNode node) {
+  public GoIndexOrSliceExprImpl(ASTNode node) {
     super(node);
   }
 
   public void accept(@NotNull PsiElementVisitor visitor) {
-    if (visitor instanceof GoVisitor) ((GoVisitor)visitor).visitIndexExpr(this);
+    if (visitor instanceof GoVisitor) ((GoVisitor)visitor).visitIndexOrSliceExpr(this);
     else super.accept(visitor);
   }
 

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -46,6 +46,7 @@ protected void setUp() throws Exception {
   public void testCars()                            { doTest(true);  }
   public void testIfWithNew()                       { doTest(true);  }
   public void testRanges()                          { doTest(true);  }
+  public void testTorture()                         { doTest(true);  }
   public void testSimple()                          { doTest(false); }
   public void testRecover()                         { doTest(false); }
   public void testRecover2()                        { doTest(false); }

File: src/com/goide/psi/impl/GoVarProcessor.java
Patch:
@@ -45,6 +45,7 @@ protected boolean add(@NotNull GoNamedElement o) {
     boolean inShortVar = PsiTreeUtil.getParentOfType(o, GoShortVarDeclaration.class, GoRecvStatement.class) != null;
     if (inShortVar && differentBlocks && myImShortVarDeclaration) return true;
     if (differentBlocks && inShortVar && !inVarOrRange && getResult() != null) return true;
+    if (inShortVar && myScope instanceof GoExprCaseClause && !PsiTreeUtil.isAncestor(getScope(o), myOrigin, false)) return true;
     return super.add(o) || !inVarOrRange;
   }
 
@@ -60,6 +61,8 @@ private static GoCompositeElement getScope(@Nullable PsiElement o) {
     if (ifStatement != null) return ifStatement.getBlock();
     GoElseStatement elseStatement = PsiTreeUtil.getParentOfType(o, GoElseStatement.class);
     if (elseStatement != null) return elseStatement.getBlock();
+    GoExprCaseClause exprCaseClause = PsiTreeUtil.getParentOfType(o, GoExprCaseClause.class);
+    if (exprCaseClause != null) return exprCaseClause;
     return PsiTreeUtil.getParentOfType(o, GoBlock.class);
   }
 

File: gen/com/goide/psi/GoVisitor.java
Patch:
@@ -139,7 +139,7 @@ public void visitFieldDefinition(@NotNull GoFieldDefinition o) {
   }
 
   public void visitFieldName(@NotNull GoFieldName o) {
-    visitCompositeElement(o);
+    visitReferenceExpressionBase(o);
   }
 
   public void visitForClause(@NotNull GoForClause o) {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -69,6 +69,7 @@ protected boolean isWriteActionRequired() {
   public void testFuncCall()    { doTest(); }
   public void testBackticks()   { doTest(); }
   public void testConsts()      { doTest(); }
+  public void testFields()      { doTest(); }
   
   public void testDoNotReportNonLastMultiResolvedImport() throws IOException {
     final VirtualFile root1 = myFixture.getTempDirFixture().findOrCreateDir("root1");

File: src/com/goide/psi/GoFile.java
Patch:
@@ -58,6 +58,7 @@ public GoFile(@NotNull FileViewProvider viewProvider) {
     super(viewProvider, GoLanguage.INSTANCE);
   }
 
+  // todo: optimize + use go libraries urls instead of source roots + cache
   @Nullable
   public String getFullPackageName() {
     VirtualFile virtualFile = getOriginalFile().getVirtualFile();

File: gen/com/goide/psi/GoImportSpec.java
Patch:
@@ -18,4 +18,6 @@ public interface GoImportSpec extends GoNamedElement, StubBasedPsiElement<GoImpo
   @Nullable
   PsiElement getIdentifier();
 
+  String getAlias();
+
 }

File: src/com/goide/highlighting/GoSyntaxHighlightingColors.java
Patch:
@@ -43,6 +43,7 @@ public class GoSyntaxHighlightingColors {
   public static final TextAttributesKey BUILTIN_TYPE_REFERENCE = createTextAttributesKey("GO_BUILTIN_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
   public static final TextAttributesKey CONSTANT = createTextAttributesKey("GO_CONSTANT", DefaultLanguageHighlighterColors.CONSTANT);
   public static final TextAttributesKey FUNCTION_DECLARATION = createTextAttributesKey("GO_FUNCTION_DECLARATION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
+  public static final TextAttributesKey GLOBAL_VARIABLE = createTextAttributesKey("GO_GLOBAL_VARIABLE", DefaultLanguageHighlighterColors.GLOBAL_VARIABLE);
 
   private GoSyntaxHighlightingColors() {
   }

File: src/com/goide/highlighting/GoSyntaxHighlightingColors.java
Patch:
@@ -42,6 +42,7 @@ public class GoSyntaxHighlightingColors {
   public static final TextAttributesKey TYPE_REFERENCE = createTextAttributesKey("GO_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
   public static final TextAttributesKey BUILTIN_TYPE_REFERENCE = createTextAttributesKey("GO_BUILTIN_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
   public static final TextAttributesKey CONSTANT = createTextAttributesKey("GO_CONSTANT", DefaultLanguageHighlighterColors.CONSTANT);
+  public static final TextAttributesKey FUNCTION_DECLARATION = createTextAttributesKey("GO_FUNCTION_DECLARATION", DefaultLanguageHighlighterColors.FUNCTION_DECLARATION);
 
   private GoSyntaxHighlightingColors() {
   }

File: gen/com/goide/psi/GoConstDefinition.java
Patch:
@@ -12,4 +12,7 @@ public interface GoConstDefinition extends GoNamedElement, StubBasedPsiElement<G
   @NotNull
   PsiElement getIdentifier();
 
+  @Nullable
+  GoType getGoType();
+
 }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -62,6 +62,7 @@ protected boolean isWriteActionRequired() {
   public void testCheck_test()  { doTest(); }
   public void testFuncCall()    { doTest(); }
   public void testBackticks()   { doTest(); }
+  public void testConsts()      { doTest(); }
   
   public void testLocalScope() {
     myFixture.configureByText("a.go", "package foo; func bar() {}");

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -38,7 +38,6 @@ protected void setUp() throws Exception {
       Extensions.getRootArea(), "com.intellij.lang.braceMatcher", LanguageExtensionPoint.class);
   }
 
-  public void testSimple()                          { doTest(true);  }
   public void testError()                           { doTest(true);  }
   public void testWriter()                          { doTest(true);  }
   public void testPrimer()                          { doTest(true);  }
@@ -47,6 +46,7 @@ protected void setUp() throws Exception {
   public void testCars()                            { doTest(true);  }
   public void testIfWithNew()                       { doTest(true);  }
   public void testRanges()                          { doTest(true);  }
+  public void testSimple()                          { doTest(false); }
   public void testRecover()                         { doTest(false); }
   public void testRecover2()                        { doTest(false); }
   public void testMethodExpr()                      { doTest(false); }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -615,6 +615,9 @@ private static GoType processRangeClause(@NotNull GoVarDefinition o, @NotNull Go
       int i = varList.indexOf(o);
       i = i == -1 ? 0 : i;
       GoType type = last.getGoType();
+      if (type instanceof GoChannelType) {
+        return type.getType();
+      }
       GoTypeReferenceExpression typeRef = type != null ? type.getTypeReferenceExpression() : null;
       if (typeRef != null) {
         PsiElement resolve = typeRef.getReference().resolve();

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -539,11 +539,10 @@ public GoTypeStub getStub() {
   }
 
   @Nullable
-  private static GoType getType(@Nullable GoTypeReferenceExpression expression) {
+  public static GoType getType(@Nullable GoTypeReferenceExpression expression) {
     PsiReference reference = expression != null ? expression.getReference() : null;
     PsiElement resolve = reference != null ? reference.resolve() : null;
-    if (resolve instanceof GoTypeSpec) return ((GoTypeSpec)resolve).getType();
-    return null;
+    return resolve instanceof GoTypeSpec ? ((GoTypeSpec)resolve).getType() : null;
   }
 
   public static boolean isVariadic(@NotNull GoParamDefinition o) {

File: src/com/goide/project/GoModuleLibrariesInitializer.java
Patch:
@@ -261,7 +261,7 @@ protected void hyperlinkActivated(@NotNull Notification notification, @NotNull H
   }
 
   private boolean isAppropriateModule() {
-    return !myModule.isDisposed() && (PlatformUtils.isIntelliJ() || ModuleUtil.getModuleType(myModule) == GoModuleType.getInstance());
+    return !myModule.isDisposed() && (!PlatformUtils.isIntelliJ() || ModuleUtil.getModuleType(myModule) == GoModuleType.getInstance());
   }
 
   @Override

File: tests/com/goide/GoCodeInsightFixtureTestCase.java
Patch:
@@ -23,6 +23,7 @@
 import com.intellij.openapi.projectRoots.SdkModificator;
 import com.intellij.openapi.projectRoots.impl.ProjectJdkImpl;
 import com.intellij.openapi.roots.ProjectRootManager;
+import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.openapi.vfs.VfsUtilCore;
 import com.intellij.openapi.vfs.VirtualFile;
 import com.intellij.testFramework.fixtures.DefaultLightProjectDescriptor;
@@ -75,7 +76,7 @@ private static Sdk createMockSdk(@NotNull String sdkHome, @NotNull String versio
   @NotNull
   protected static String loadText(@NotNull VirtualFile file) {
     try {
-      return VfsUtilCore.loadText(file);
+      return StringUtil.convertLineSeparators(VfsUtilCore.loadText(file));
     }
     catch (IOException e) {
       throw new RuntimeException(e);

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -73,6 +73,8 @@ public void testDuplicatesInOnePackage() {
     myFixture.configureByText("b.go", "package foo; func <error>bar</error>() {}");
     myFixture.checkHighlighting();
   }
+
+  public void testFuncCall(){ doTest(); }
   
   @Override
   protected LightProjectDescriptor getProjectDescriptor() {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -435,6 +435,9 @@ else if (o instanceof GoSliceExpr) {
     else if (o instanceof GoTypeAssertionExpr) {
       return ((GoTypeAssertionExpr)o).getType();
     }
+    else if (o instanceof GoConversionExpr) {
+      return ((GoConversionExpr)o).getType().getType();
+    }
     return null;
   }
 

File: tests/com/goide/psi/legacy/GoLegacyResolveTypesTest.java
Patch:
@@ -23,6 +23,7 @@ public class GoLegacyResolveTypesTest extends GoLegacyResolveTestBase {
   public void testLocalType()                                     { doTest(); } 
   public void testFromMethodReceiver()                            { doTest(); } 
   public void testResolveTypeNameInTypeSpec()                     { doTest(); } 
+  public void testResolveTypeInCast()                             { doTest(); } 
   public void testFromDefaultImportedPackage()                    { doDirTest(); } 
   public void testFromInjectedPackage()                           { doDirTest(); } 
   public void testFromCustomImportedPackage()                     { doDirTest(); } 

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -58,6 +58,9 @@ protected boolean isWriteActionRequired() {
   public void testBlankImport() { doTest(); }
   public void testVariadic()  { doTest(); }
   
+  public void testCheck()       { doTest(); }
+  public void testCheck_test()  { doTest(); }
+  
   public void testLocalScope() {
     myFixture.configureByText("a.go", "package foo; func bar() {}");
     myFixture.configureByText("b.go", "package foo; func init(){bar()}");

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -56,6 +56,7 @@ protected boolean isWriteActionRequired() {
   public void testStop()      { doTest(); }
   public void testVarBlocks() { doTest(); }
   public void testBlankImport() { doTest(); }
+  public void testVariadic()  { doTest(); }
   
   public void testLocalScope() {
     myFixture.configureByText("a.go", "package foo; func bar() {}");

File: gen/com/goide/psi/GoParamDefinition.java
Patch:
@@ -12,4 +12,7 @@ public interface GoParamDefinition extends GoNamedElement, StubBasedPsiElement<G
   @NotNull
   PsiElement getIdentifier();
 
+  @NotNull
+  boolean isVariadic();
+
 }

File: gen/com/goide/psi/GoType.java
Patch:
@@ -4,8 +4,10 @@
 import java.util.List;
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
+import com.intellij.psi.StubBasedPsiElement;
+import com.goide.stubs.GoTypeStub;
 
-public interface GoType extends GoCompositeElement {
+public interface GoType extends GoCompositeElement, StubBasedPsiElement<GoTypeStub> {
 
   @Nullable
   GoType getType();

File: gen/com/goide/psi/impl/GoParameterDeclarationImpl.java
Patch:
@@ -36,7 +36,7 @@ public List<GoParamDefinition> getParamDefinitionList() {
   @Override
   @NotNull
   public GoType getType() {
-    return findNotNullChildByClass(GoType.class);
+    return findNotNullChildByClass(GoType.class, com.goide.stubs.GoTypeStub.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoParametersImpl.java
Patch:
@@ -36,7 +36,7 @@ public List<GoParameterDeclaration> getParameterDeclarationList() {
   @Override
   @Nullable
   public GoType getType() {
-    return findChildByClass(GoType.class);
+    return findChildByClass(GoType.class, com.goide.stubs.GoTypeStub.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoReceiverImpl.java
Patch:
@@ -30,7 +30,7 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   @Override
   @Nullable
   public GoType getType() {
-    return findChildByClass(GoType.class);
+    return findChildByClass(GoType.class, com.goide.stubs.GoTypeStub.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoResultImpl.java
Patch:
@@ -36,7 +36,7 @@ public GoParameters getParameters() {
   @Override
   @Nullable
   public GoType getType() {
-    return findChildByClass(GoType.class);
+    return findChildByClass(GoType.class, com.goide.stubs.GoTypeStub.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoTypeSpecImpl.java
Patch:
@@ -30,7 +30,7 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   @Override
   @Nullable
   public GoType getType() {
-    return findChildByClass(GoType.class);
+    return findChildByClass(GoType.class, com.goide.stubs.GoTypeStub.class);
   }
 
   @Override

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -90,7 +90,7 @@ public GoType getGoType() {
   }
 
   @Nullable
-  public static GoType getType(GoNamedElement o) {
+  public static GoType getType(GoNamedElement o) { // todo: use stubs
     return PsiTreeUtil.getNextSiblingOfType(o, GoType.class);
   }
   

File: src/com/goide/stubs/index/GoAllNamesIndex.java
Patch:
@@ -26,7 +26,7 @@ public class GoAllNamesIndex extends StringStubIndexExtension<GoNamedElement> {
 
   @Override
   public int getVersion() {
-    return 14;
+    return 15;
   }
 
   @NotNull

File: src/com/goide/inspections/GoUnusedImportDeclaration.java
Patch:
@@ -64,7 +64,7 @@ protected void checkFile(@NotNull GoFile file, @NotNull ProblemsHolder problemsH
     GoImportOptimizer.filterUnusedImports(file, importMap);
     for (PsiElement importEntry : importMap.values()) {
       GoImportSpec spec = GoImportOptimizer.getImportSpec(importEntry);
-      if (spec != null) {
+      if (spec != null && !spec.isBlank()) {
         if (spec.getImportString().resolve() != null) {
           problemsHolder.registerProblem(spec, "Unused import", ProblemHighlightType.GENERIC_ERROR, OPTIMIZE_QUICK_FIX);
         }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -55,6 +55,7 @@ protected boolean isWriteActionRequired() {
   public void testRequest()   { doTest(); }
   public void testStop()      { doTest(); }
   public void testVarBlocks() { doTest(); }
+  public void testBlankImport() { doTest(); }
   
   public void testLocalScope() {
     myFixture.configureByText("a.go", "package foo; func bar() {}");

File: src/com/goide/completion/GoKeywordCompletionContributor.java
Patch:
@@ -35,7 +35,7 @@
 import static com.intellij.patterns.StandardPatterns.*;
 
 public class GoKeywordCompletionContributor extends CompletionContributor {
-  private static final AddBracesInsertHandler ADD_BRACES_INSERT_HANDLER = new AddBracesInsertHandler();
+  private static final BracesInsertHandler ADD_BRACES_INSERT_HANDLER = new BracesInsertHandler();
   private static final InsertHandler<LookupElement> ADD_BRACKETS_INSERT_HANDLER = new AddBracketsInsertHandler();
 
   public GoKeywordCompletionContributor() {

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -104,7 +104,8 @@ boolean isCompletion() {
   }
 
   @NotNull
-  static MyScopeProcessor createCompletionProcessor(@NotNull final Collection<LookupElement> variants, final boolean forTypes,
+  static MyScopeProcessor createCompletionProcessor(@NotNull final Collection<LookupElement> variants, 
+                                                    final boolean forTypes,
                                                     @NotNull final Condition<PsiElement> filter) {
     return new MyScopeProcessor() {
       @Override
@@ -124,7 +125,7 @@ private boolean printOrPrintln(@NotNull PsiElement o) {
       private LookupElement createLookup(@NotNull PsiElement element) {
         // @formatter:off
         if (element instanceof GoNamedSignatureOwner)return createFunctionOrMethodLookupElement((GoNamedSignatureOwner)element);
-        else if (element instanceof GoTypeSpec)      return forTypes ? createTypeLookupElement((GoTypeSpec)element) :createTypeConversionLookupElement((GoTypeSpec)element);
+        else if (element instanceof GoTypeSpec)      return forTypes ? createTypeLookupElement((GoTypeSpec)element) : createTypeConversionLookupElement((GoTypeSpec)element);
         else if (element instanceof GoImportSpec)    return createPackageLookupElement(((GoImportSpec)element));
         else if (element instanceof PsiDirectory)    return createPackageLookupElement(((PsiDirectory)element).getName(), true);
         else if (element instanceof GoNamedElement)  return createVariableLikeLookupElement((GoNamedElement)element);

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -366,6 +366,7 @@ public static GoType getGoType(@NotNull GoExpression o) {
       if (expression != null) {
         GoType type = expression.getGoType();
         if (type instanceof GoChannelType && ((GoUnaryExpr)o).getSendChannel() != null) return type.getType();
+        if (type instanceof GoPointerType && ((GoUnaryExpr)o).getMul() != null) return type.getType();
         return type;
       }
       return null;
@@ -415,7 +416,6 @@ else if (o instanceof GoIndexExpr) {
           return list.get(1);
         }
       }
-      type = type instanceof GoPointerType ? type.getType() : type;
       if (type instanceof GoArrayOrSliceType) {
         return type.getType();
       }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -415,7 +415,8 @@ else if (o instanceof GoIndexExpr) {
           return list.get(1);
         }
       }
-      else if (type instanceof GoArrayOrSliceType) {
+      type = type instanceof GoPointerType ? type.getType() : type;
+      if (type instanceof GoArrayOrSliceType) {
         return type.getType();
       }
     }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -376,7 +376,7 @@ private boolean processSelector(@NotNull GoSelectorExpr parent,
 
   @NotNull
   private GoVarProcessor createDelegate(@NotNull MyScopeProcessor processor) {
-    return new GoVarProcessor(getName(), myElement, processor.isCompletion());
+    return new GoVarProcessor(getName(), myElement, processor.isCompletion(), true);
   }
 
   private static boolean processFileEntities(@NotNull GoFile file,

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -54,6 +54,7 @@ protected boolean isWriteActionRequired() {
   public void testReturns()   { doTest(); }
   public void testRequest()   { doTest(); }
   public void testStop()      { doTest(); }
+  public void testVarBlocks() { doTest(); }
   
   public void testLocalScope() {
     myFixture.configureByText("a.go", "package foo; func bar() {}");

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -45,6 +45,7 @@ public GoNamedElementImpl(@NotNull ASTNode node) {
   }
 
   public boolean isPublic() {
+    if (GoPsiImplUtil.builtin(this)) return true;
     T stub = getStub();
     return stub != null ? stub.isPublic() : StringUtil.isCapitalized(getName());
   }

File: tests/com/goide/completion/GoCompletionTest.java
Patch:
@@ -229,7 +229,7 @@ public void testLabel() {
   }
   
   public void testNoMainAnymore() {
-    doTestExclude("package foo; func mai<caret> { }", "main");
+    doTestEquals("package foo; func ma<caret> { }");
   }
 
   public void testPackageBeforeDot() {

File: src/com/goide/inspections/unresolved/GoUnusedVariableInspection.java
Patch:
@@ -38,7 +38,7 @@ protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder,
       @Override
       public void visitVarDefinition(@NotNull GoVarDefinition o) {
         if (GoPsiImplUtil.isBlank(o.getIdentifier())) return;
-        GoShortVarDeclaration shortDecl = PsiTreeUtil.getParentOfType(o, GoShortVarDeclaration.class);
+        GoVarSpec shortDecl = PsiTreeUtil.getParentOfType(o, GoShortVarDeclaration.class, GoRecvStatement.class);
         GoVarDeclaration decl = PsiTreeUtil.getParentOfType(o, GoVarDeclaration.class);
         if (shortDecl != null || decl != null) {
           PsiReference reference = o.getReference();

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -47,6 +47,7 @@ protected boolean isWriteActionRequired() {
   public void testBoxes()     { doTest(); }
   public void testRanges()    { doTest(); }
   public void testVars()      { doTest(); }
+  public void testRecv()      { doTest(); }
   public void testPointers()  { doTest(); }
   public void testSlices()    { doTest(); }
   public void testShortVars() { doTest(); }

File: src/com/goide/inspections/unresolved/GoUnusedFunctionInspection.java
Patch:
@@ -43,6 +43,7 @@ public void visitFunctionDeclaration(@NotNull GoFunctionDeclaration o) {
         GoFile file = o.getContainingFile();
         String name = o.getName();
         if ("main".equals(file.getPackageName()) && "main".equals(name)) return;
+        if ("init".equals(name)) return;
         if (GoTestFinder.isTestFile(file) && name != null && (name.startsWith("Test") || name.startsWith("Benchmark"))) return;
         Query<PsiReference> search = ReferencesSearch.search(o, o.getUseScope());
         if (search.findFirst() == null) {

File: src/com/goide/inspections/GoNoNewVariablesInspection.java
Patch:
@@ -19,6 +19,7 @@
 import com.goide.psi.GoShortVarDeclaration;
 import com.goide.psi.GoVarDefinition;
 import com.goide.psi.GoVisitor;
+import com.goide.psi.impl.GoPsiImplUtil;
 import com.intellij.codeInspection.LocalInspectionToolSession;
 import com.intellij.codeInspection.ProblemsHolder;
 import com.intellij.openapi.util.TextRange;
@@ -49,6 +50,7 @@ public void visitShortVarDeclaration(@NotNull GoShortVarDeclaration o) {
         int end = last.getStartOffsetInParent() + last.getTextLength();
 
         for (GoVarDefinition def : list) {
+          if (GoPsiImplUtil.isBlank(def)) continue;
           PsiReference reference = def.getReference();
           PsiElement resolve = reference != null ? reference.resolve() : null;
           if (resolve == null) return;

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -270,10 +270,10 @@ protected static boolean processDirectory(@Nullable PsiDirectory dir,
                                             @NotNull MyScopeProcessor processor,
                                             @NotNull ResolveState state,
                                             boolean localProcessing) {
-    String fileName = file != null ? file.getName() : null;
+    String filePath = file != null ? file.getVirtualFile().getPath() : null;
     if (dir != null) {
       for (PsiFile psiFile : dir.getFiles()) {
-        if (psiFile instanceof GoFile && GoUtil.allowed(psiFile) && !psiFile.getName().equals(fileName)) {
+        if (psiFile instanceof GoFile && GoUtil.allowed(psiFile) && !Comparing.equal(psiFile.getVirtualFile().getPath(), filePath)) {
           if (packageName != null && !packageName.equals(((GoFile)psiFile).getPackageName())) continue;
           if (!processFileEntities((GoFile)psiFile, processor, state, localProcessing)) return false;
         }

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -51,6 +51,7 @@ protected boolean isWriteActionRequired() {
   public void testSlices()    { doTest(); }
   public void testShortVars() { doTest(); }
   public void testReturns()   { doTest(); }
+  public void testRequest()   { doTest(); }
   
   @Override
   protected LightProjectDescriptor getProjectDescriptor() {

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -15,6 +15,9 @@ public interface GoTypeSpec extends GoNamedElement, StubBasedPsiElement<GoTypeSp
   @NotNull
   PsiElement getIdentifier();
 
+  @Nullable
+  GoType getGoType();
+
   @NotNull
   List<GoMethodDeclaration> getMethods();
 

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -22,7 +22,8 @@ public void setUp() throws Exception {
       new GoDuplicateArgumentInspection(),
       new GoDuplicateReturnArgumentInspection(),
       new GoFunctionVariadicParameterInspection(),
-      new GoVarDeclarationInspection()
+      new GoVarDeclarationInspection(),
+      new GoNoNewVariablesInspection()
     );
   }
 
@@ -47,6 +48,7 @@ protected boolean isWriteActionRequired() {
   public void testVars()      { doTest(); }
   public void testPointers()  { doTest(); }
   public void testSlices()    { doTest(); }
+  public void testShortVars() { doTest(); }
   
   @Override
   protected LightProjectDescriptor getProjectDescriptor() {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -46,6 +46,7 @@ protected boolean isWriteActionRequired() {
   public void testRanges()    { doTest(); }
   public void testVars()      { doTest(); }
   public void testPointers()  { doTest(); }
+  public void testSlices()    { doTest(); }
   
   @Override
   protected LightProjectDescriptor getProjectDescriptor() {

File: tests/com/goide/inspections/GoHighlightingTest.java
Patch:
@@ -21,7 +21,8 @@ public void setUp() throws Exception {
       new GoDuplicateFunctionInspection(),
       new GoDuplicateArgumentInspection(),
       new GoDuplicateReturnArgumentInspection(),
-      new GoFunctionVariadicParameterInspection()
+      new GoFunctionVariadicParameterInspection(),
+      new GoVarDeclarationInspection()
     );
   }
 

File: tests/com/goide/completion/GoCompletionTest.java
Patch:
@@ -92,11 +92,11 @@ public void testAddSpaceAfterKeyword() {
   }
 
   public void testTypeKeywords() {
-    myFixture.testCompletionVariants(getTestName(true) + ".go", "struct", "interface", "chan", "map", "Bar", "Bar");
+    myFixture.testCompletionVariants(getTestName(true) + ".go", "struct", "interface", "chan", "map");
   }
 
   public void testTypeKeywordsInsideParentheses() {
-    myFixture.testCompletionVariants(getTestName(true) + ".go", "chan", "map", "Bar", "Bar");
+    myFixture.testCompletionVariants(getTestName(true) + ".go", "chan", "map");
   }
 
   public void testSelectKeywordInsertHandler() {

File: src/com/goide/completion/GoCompletionContributor.java
Patch:
@@ -213,6 +213,7 @@ protected void addCompletions(@NotNull CompletionParameters parameters,
               for (String name : StubIndex.getInstance().getAllKeys(GoTypesIndex.KEY, project)) {
                 if (StringUtil.isCapitalized(name)) {
                   for (GoTypeSpec declaration : GoTypesIndex.find(name, project, GlobalSearchScope.allScope(project))) {
+                    if (declaration.getContainingFile() == parameters.getOriginalFile()) continue;
                     PsiReference reference = parent.getReference();
                     if (reference instanceof GoTypeReference && !((GoTypeReference)reference).allowed(declaration)) continue;
                     if (!allowed(declaration)) continue;

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -329,7 +329,8 @@ public static String getName(@NotNull GoMethodSpec o) {
   public static GoTypeReferenceExpression getTypeReference(@Nullable GoType o) {
     if (o == null) return null;
     if (o instanceof GoChannelType) {
-      return ((GoChannelType)o).getType().getTypeReferenceExpression();
+      GoType type = o.getType();
+      return type != null ? type.getTypeReferenceExpression() : null;
     }
     return o.getTypeReferenceExpression();
   }
@@ -340,7 +341,7 @@ public static GoType getGoType(@NotNull GoExpression o) {
       GoExpression expression = ((GoUnaryExpr)o).getExpression();
       if (expression != null) {
         GoType type = expression.getGoType();
-        if (type instanceof GoChannelType && ((GoUnaryExpr)o).getSendChannel() != null) return ((GoChannelType)type).getType();
+        if (type instanceof GoChannelType && ((GoUnaryExpr)o).getSendChannel() != null) return type.getType();
         return type;
       }
       return null;

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -247,7 +247,7 @@ private boolean processInTypeRef(@Nullable GoTypeReferenceExpression refExpr,
     if (resolve instanceof GoTypeSpec) {
       GoType resolveType = ((GoTypeSpec)resolve).getType();
       if (resolveType != null && (recursiveStopper == null || !resolveType.textMatches(recursiveStopper)) &&
-          !processExistingType(resolveType, processor, state)) {
+          !processGoType(resolveType, processor, state)) {
         return false;
       }
     }

File: src/com/goide/psi/impl/GoNamedElementImpl.java
Patch:
@@ -3,7 +3,6 @@
 import com.goide.GoIcons;
 import com.goide.psi.*;
 import com.goide.stubs.GoNamedStub;
-import com.goide.stubs.TextHolder;
 import com.intellij.lang.ASTNode;
 import com.intellij.openapi.util.text.StringUtil;
 import com.intellij.psi.PsiElement;
@@ -18,7 +17,7 @@
 
 import javax.swing.*;
 
-public abstract class GoNamedElementImpl<T extends GoNamedStub<?> & TextHolder> extends GoStubbedElementImpl<T> implements GoCompositeElement, GoNamedElement {
+public abstract class GoNamedElementImpl<T extends GoNamedStub<?>> extends GoStubbedElementImpl<T> implements GoCompositeElement, GoNamedElement {
 
   public GoNamedElementImpl(@NotNull T stub, @NotNull IStubElementType nodeType) {
     super(stub, nodeType);

File: src/com/goide/psi/impl/GoStubbedElementImpl.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.List;
 
-public abstract class GoStubbedElementImpl<T extends StubBase<?> & TextHolder> extends StubBasedPsiElementBase<T> implements GoCompositeElement {
+public abstract class GoStubbedElementImpl<T extends StubBase<?>> extends StubBasedPsiElementBase<T> implements GoCompositeElement {
   public GoStubbedElementImpl(@NotNull T stub, @NotNull IStubElementType nodeType) {
     super(stub, nodeType);
   }
@@ -36,8 +36,8 @@ public String toString() {
   @Override
   public String getText() {
     T stub = getStub();
-    if (stub != null) {
-      String text = stub.getText();
+    if (stub instanceof TextHolder) {
+      String text = ((TextHolder)stub).getText();
       if (text != null) return text;
     }
     return super.getText();

File: src/com/goide/completion/GoCompletionContributor.java
Patch:
@@ -87,8 +87,8 @@ private static PsiElementPattern.Capture<PsiElement> packagePattern() {
   }
 
   private static PsiElementPattern.Capture<PsiElement> onNewLine() {
-    return psiElement().afterLeafSkipping(psiElement().whitespaceCommentEmptyOrError().withoutText(string().contains("\n")),
-                                          or(psiElement(GoTypes.SEMICOLON), psiElement().withText(string().contains("\n"))));
+    return psiElement().afterLeafSkipping(psiElement().whitespaceCommentEmptyOrError().withoutText(string().containsChars("\n")),
+                                          or(psiElement(GoTypes.SEMICOLON), psiElement().withText(string().containsChars("\n"))));
   }
 
   private static PsiFilePattern.Capture<GoFile> goFileWithPackage() {

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -314,7 +314,7 @@ public static GoTypeReferenceExpression getTypeReference(@Nullable GoType o) {
   @Nullable
   public static GoType getGoType(@NotNull GoExpression o) {
     if (o instanceof GoUnaryExpr) {
-      GoExpression expression = ((GoUnaryExpr)o).getExpression();
+      GoExpression expression = ((GoUnaryExpr)o).getExpression(); // todo: check for <- chan
       return expression != null ? getGoType(expression) : null;
     }
     else if (o instanceof GoCompositeLit) {
@@ -328,8 +328,7 @@ else if (o instanceof GoBuiltinCallExpr) {
       if ("new".equals(text) || "make".equals(text)) {
         GoBuiltinArgs args = ((GoBuiltinCallExpr)o).getBuiltinArgs();
         GoType type = args != null ? args.getType() : null;
-        if (type instanceof GoMapType) return type;
-        if (type instanceof GoArrayOrSliceType) return type;
+        if (type instanceof GoMapType || type instanceof GoArrayOrSliceType || type instanceof GoChannelType) return type;
         if (type != null) {
           GoTypeReferenceExpression expression = getTypeReference(type);
           return getType(expression);

File: tests/com/goide/GoCodeInsightFixtureTestCase.java
Patch:
@@ -15,7 +15,7 @@
 abstract public class GoCodeInsightFixtureTestCase extends LightPlatformCodeInsightFixtureTestCase {
   @Override
   protected String getTestDataPath() {
-    return new File("testData/lexer/" + getTestName(true) + ".txt").getAbsolutePath();
+    return new File("testData/" + getBasePath()).getAbsolutePath();
   }
 
   protected static DefaultLightProjectDescriptor createMockProjectDescriptor() {

File: tests/com/goide/GoCodeInsightFixtureTestCase.java
Patch:
@@ -10,10 +10,12 @@
 import com.intellij.testFramework.fixtures.LightPlatformCodeInsightFixtureTestCase;
 import org.jetbrains.annotations.NotNull;
 
+import java.io.File;
+
 abstract public class GoCodeInsightFixtureTestCase extends LightPlatformCodeInsightFixtureTestCase {
   @Override
   protected String getTestDataPath() {
-    return "testData/" + getBasePath();
+    return new File("testData/lexer/" + getTestName(true) + ".txt").getAbsolutePath();
   }
 
   protected static DefaultLightProjectDescriptor createMockProjectDescriptor() {

File: src/com/goide/formatter/GoFormattingModelBuilder.java
Patch:
@@ -79,6 +79,7 @@ private static SpacingBuilder createSpacingBuilder(@NotNull CodeStyleSettings se
       .afterInside(LBRACE, LITERAL_VALUE).none()
       .beforeInside(LBRACE, LITERAL_VALUE).none()
       .afterInside(BIT_AND, UNARY_EXPR).none()
+      .beforeInside(TYPE, VAR_SPEC).spaces(1)
       .after(GoParserDefinition.LINE_COMMENT).lineBreakInCodeIf(true)
       .after(GoParserDefinition.MULTILINE_COMMENT).lineBreakInCodeIf(true)
       ;

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -45,6 +45,7 @@ protected void setUp() throws Exception {
   public void testTypes()       { doTest(true);  }
   public void testStr2Num()     { doTest(true);  }
   public void testCars()        { doTest(true);  }
+  public void testIfWithNew()   { doTest(true);  }
   public void testRecover()     { doTest(false); }
   public void testMethodExpr()  { doTest(false); }
   public void testLabels()      { doTest(false); }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -247,7 +247,7 @@ protected boolean processDirectory(@Nullable PsiDirectory dir,
     return true;
   }
 
-  private static boolean allowed(@NotNull PsiFile file) {
+  static boolean allowed(@NotNull PsiFile file) {
     String name = GoUtil.replaceLast(FileUtil.getNameWithoutExtension(file.getName()), "_test");
     Matcher matcher = FULL.matcher(name);
     if (matcher.matches()) {

File: src/com/goide/psi/impl/GoTypeReference.java
Patch:
@@ -96,6 +96,8 @@ protected PsiElement processUnqualified(@NotNull GoFile file, boolean localResol
     for (PsiElement o : file.getImportMap().values()) {
       if (o instanceof GoImportSpec && ((GoImportSpec)o).getDot() != null) {
         PsiDirectory resolve = ((GoImportSpec)o).getImportString().resolve();
+        PsiDirectory parent = file.getOriginalFile().getParent();
+        if (Comparing.equal(parent, resolve)) continue;
         PsiElement result = processDirectory(resolve, null, null, false);
         if (result != null) {
           GoReference.putIfAbsent(o, myElement);

File: src/com/goide/highlighting/GoSyntaxHighlightingColors.java
Patch:
@@ -24,6 +24,7 @@ public class GoSyntaxHighlightingColors {
   public static final TextAttributesKey BAD_CHARACTER = createTextAttributesKey("GO_BAD_TOKEN", HighlighterColors.BAD_CHARACTER);
   public static final TextAttributesKey TYPE_SPECIFICATION = createTextAttributesKey("GO_TYPE_SPECIFICATION", DefaultLanguageHighlighterColors.CLASS_NAME);
   public static final TextAttributesKey TYPE_REFERENCE = createTextAttributesKey("GO_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
+  public static final TextAttributesKey BUILTIN_TYPE_REFERENCE = createTextAttributesKey("GO_BUILTIN_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
 
   private GoSyntaxHighlightingColors() {
   }

File: src/com/goide/highlighting/GoSyntaxHighlightingColors.java
Patch:
@@ -22,6 +22,8 @@ public class GoSyntaxHighlightingColors {
   public static final TextAttributesKey COLON = createTextAttributesKey("GO_COLON", HighlighterColors.TEXT);
   public static final TextAttributesKey COMMA = createTextAttributesKey("GO_COMMA", DefaultLanguageHighlighterColors.COMMA);
   public static final TextAttributesKey BAD_CHARACTER = createTextAttributesKey("GO_BAD_TOKEN", HighlighterColors.BAD_CHARACTER);
+  public static final TextAttributesKey TYPE_SPECIFICATION = createTextAttributesKey("GO_TYPE_SPECIFICATION", DefaultLanguageHighlighterColors.CLASS_NAME);
+  public static final TextAttributesKey TYPE_REFERENCE = createTextAttributesKey("GO_TYPE_REFERENCE", DefaultLanguageHighlighterColors.CLASS_REFERENCE);
 
   private GoSyntaxHighlightingColors() {
   }

File: src/com/goide/stubs/GoMethodDeclarationStub.java
Patch:
@@ -19,6 +19,6 @@ public GoMethodDeclarationStub(StubElement parent, IStubElementType elementType,
   }
 
   public String getTypeName() {
-    return myTypeName.getString();
+    return myTypeName == null ? null : myTypeName.getString();
   }
 }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -252,6 +252,7 @@ else if (o instanceof GoBuiltinCallExpr) {
         GoBuiltinArgs args = ((GoBuiltinCallExpr)o).getBuiltinArgs();
         GoType type = args != null ? args.getType() : null;
         if (type instanceof GoMapType) return type;
+        if (type instanceof GoArrayOrSliceType) return type;
         if (type != null) {
           GoTypeReferenceExpression expression = getTypeReference(type);
           return getType(expression);

File: gen/com/goide/psi/GoMethodDeclaration.java
Patch:
@@ -21,7 +21,7 @@ public interface GoMethodDeclaration extends GoFunctionOrMethodDeclaration, Stub
   @NotNull
   PsiElement getFunc();
 
-  @NotNull
+  @Nullable
   PsiElement getIdentifier();
 
 }

File: gen/com/goide/psi/GoReceiver.java
Patch:
@@ -9,7 +9,7 @@
 
 public interface GoReceiver extends GoNamedElement, StubBasedPsiElement<GoReceiverStub> {
 
-  @NotNull
+  @Nullable
   GoType getType();
 
   @NotNull
@@ -18,7 +18,7 @@ public interface GoReceiver extends GoNamedElement, StubBasedPsiElement<GoReceiv
   @Nullable
   PsiElement getMul();
 
-  @NotNull
+  @Nullable
   PsiElement getRparen();
 
   @Nullable

File: gen/com/goide/psi/impl/GoMethodDeclarationImpl.java
Patch:
@@ -52,9 +52,9 @@ public PsiElement getFunc() {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public PsiElement getIdentifier() {
-    return findNotNullChildByType(IDENTIFIER);
+    return findChildByType(IDENTIFIER);
   }
 
 }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -231,6 +231,8 @@ public static GoType getGoType(@NotNull GoExpression o) {
       return expression != null ? getGoType(expression) : null;
     }
     else if (o instanceof GoCompositeLit) {
+      GoType type = ((GoCompositeLit)o).getLiteralTypeExpr().getType();
+      if (type != null) return type;
       GoTypeReferenceExpression expression = ((GoCompositeLit)o).getLiteralTypeExpr().getTypeReferenceExpression();
       return getType(expression);
     }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -263,6 +263,9 @@ else if (type instanceof GoArrayOrSliceType) {
         return ((GoArrayOrSliceType)type).getType();
       }
     }
+    else if (o instanceof GoTypeAssertionExpr) {
+      return ((GoTypeAssertionExpr)o).getType();
+    }
     return null;
   }
 

File: src/com/goide/stubs/index/GoTypesIndex.java
Patch:
@@ -10,7 +10,7 @@ public class GoTypesIndex extends StringStubIndexExtension<GoTypeSpec> {
 
   @Override
   public int getVersion() {
-    return 1;
+    return 2;
   }
 
   @NotNull

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -232,8 +232,8 @@ private boolean processUnqualifiedResolve(@NotNull GoFile file,
 
     PsiElement parent = myElement.getParent();
 
-    if (parent instanceof GoSelectorExpr) return processSelector((GoSelectorExpr)parent, processor, state, myElement);
-
+    if (parent instanceof GoSelectorExpr && !processSelector((GoSelectorExpr)parent, processor, state, myElement)) return false;
+    
     PsiElement grandPa = parent.getParent();
     if (grandPa instanceof GoSelectorExpr && !processSelector((GoSelectorExpr)grandPa, processor, state, parent)) return false;
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -419,7 +419,9 @@ private static GoImportSpec addImportDeclaration(@NotNull GoImportList importLis
                                                    @NotNull GoImportDeclaration newImportDeclaration,
                                                    @Nullable PsiElement anchor) {
     GoImportDeclaration importDeclaration = (GoImportDeclaration)importList.addAfter(newImportDeclaration, anchor);
-    importList.addAfter(GoElementFactory.createNewLine(importList.getProject()), importDeclaration);
+    if (!(importList.getNextSibling() instanceof PsiWhiteSpace)) {
+      importList.addAfter(GoElementFactory.createNewLine(importList.getProject()), importDeclaration);
+    }
     importList.addBefore(GoElementFactory.createNewLine(importList.getProject()), importDeclaration);
     GoImportSpec result = ContainerUtil.getFirstItem(importDeclaration.getImportSpecList());
     assert result != null;

File: src/com/goide/psi/impl/GoElementFactory.java
Patch:
@@ -35,9 +35,10 @@ public static PsiElement createIdentifierFromText(@NotNull Project project, Stri
   public static GoImportDeclaration createImportDeclaration(@NotNull Project project, @NotNull String importString,
                                                             @Nullable String alias, boolean withParens) {
     importString = StringUtil.isQuotedString(importString) ? importString : StringUtil.wrapWithDoubleQuote(importString);
+    alias = alias != null ? alias + " " : "";
     GoFile file = withParens
-                  ? createFileFromText(project, "package main\nimport (\n" + StringUtil.notNullize(alias) + " " + importString + "\n)")
-                  : createFileFromText(project, "package main\nimport " + StringUtil.notNullize(alias) + " " + importString);
+                  ? createFileFromText(project, "package main\nimport (\n" + alias + importString + "\n)")
+                  : createFileFromText(project, "package main\nimport " + alias + importString);
     return PsiTreeUtil.findChildOfType(file, GoImportDeclaration.class);
   }
 

File: gen/com/goide/psi/GoMethodSpec.java
Patch:
@@ -18,4 +18,7 @@ public interface GoMethodSpec extends GoReceiverHolder, StubBasedPsiElement<GoMe
   @Nullable
   PsiElement getIdentifier();
 
+  @Nullable
+  GoType getGoType();
+
 }

File: gen/com/goide/psi/GoExpression.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoExpression extends GoCompositeElement {
+public interface GoExpression extends GoTypeOwner {
 
   @Nullable
   GoType getGoType();

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -240,6 +240,9 @@ else if (o instanceof GoCallExpr) {
           GoResult result = signature != null ? signature.getResult() : null;
           if (result != null) {
             GoType type = result.getType();
+            if (type instanceof GoTypeList && ((GoTypeList)type).getTypeList().size() == 1) {
+              return ((GoTypeList)type).getTypeList().get(0);
+            }
             if (type != null) return type;
             final GoParameters parameters = result.getParameters();
             if (parameters != null) {

File: src/com/goide/editor/GoFoldingBuilder.java
Patch:
@@ -44,7 +44,7 @@ public FoldingDescriptor[] buildFoldRegions(@NotNull PsiElement root, @NotNull D
 
     for (GoFunctionOrMethodDeclaration method : ContainerUtil.concat(file.getMethods(), file.getFunctions())) {
       GoBlock block = method.getBlock();
-      if (block != null) result.add(new FoldingDescriptor(block, block.getTextRange()));
+      if (block != null && block.getTextRange().getLength() > 1) result.add(new FoldingDescriptor(block, block.getTextRange()));
     }
 
     if (!quick) {

File: src/com/goide/psi/GoFile.java
Patch:
@@ -53,7 +53,7 @@ public GoFile(@NotNull FileViewProvider viewProvider) {
 
   @Nullable
   public String getFullPackageName() {
-    VirtualFile virtualFile = getVirtualFile();
+    VirtualFile virtualFile = getOriginalFile().getVirtualFile();
     VirtualFile root = ProjectFileIndexImpl.SERVICE.getInstance(getProject()).getSourceRootForFile(virtualFile);
     if (root != null) {
       String fullPackageName = FileUtil.getRelativePath(root.getPath(), virtualFile.getPath(), '/');

File: src/com/goide/editor/GoFoldingBuilder.java
Patch:
@@ -27,6 +27,7 @@ public class GoFoldingBuilder extends FoldingBuilderEx implements DumbAware {
   public FoldingDescriptor[] buildFoldRegions(@NotNull PsiElement root, @NotNull Document document, boolean quick) {
     if (!(root instanceof GoFile)) return FoldingDescriptor.EMPTY;
     GoFile file = (GoFile)root;
+    if (!file.isContentsLoaded()) return FoldingDescriptor.EMPTY;
 
     final List<FoldingDescriptor> result = ContainerUtil.newArrayList();
 

File: src/com/goide/formatter/settings/GoLanguageCodeStyleSettingsProvider.java
Patch:
@@ -29,10 +29,10 @@ public IndentOptionsEditor getIndentOptionsEditor() {
   public CommonCodeStyleSettings getDefaultCommonSettings() {
     CommonCodeStyleSettings defaultSettings = new CommonCodeStyleSettings(getLanguage());
     CommonCodeStyleSettings.IndentOptions indentOptions = defaultSettings.initIndentOptions();
-    indentOptions.INDENT_SIZE = 2;
+    indentOptions.INDENT_SIZE = 4;
     indentOptions.CONTINUATION_INDENT_SIZE = 4;
-    indentOptions.TAB_SIZE = 2;
-    indentOptions.USE_TAB_CHARACTER = true;
+    indentOptions.TAB_SIZE = 4;
+    indentOptions.USE_TAB_CHARACTER = false; // todo: should be true
     return defaultSettings;
   }
 

File: src/com/goide/inspections/GoUnresolvedReferenceInspection.java
Patch:
@@ -1,6 +1,7 @@
 package com.goide.inspections;
 
 import com.goide.GoTypes;
+import com.goide.inspections.unresolved.GoIntroduceGlobalConstantFix;
 import com.goide.inspections.unresolved.GoIntroduceGlobalVariableFix;
 import com.goide.inspections.unresolved.GoIntroduceLocalVariableFix;
 import com.goide.inspections.unresolved.GoIntroduceTypeFix;
@@ -40,6 +41,7 @@ public void visitReferenceExpression(@NotNull GoReferenceExpression o) {
                                   new LocalQuickFix[]{
                                     new GoIntroduceLocalVariableFix(id, name),
                                     new GoIntroduceGlobalVariableFix(id, name),
+                                    new GoIntroduceGlobalConstantFix(id, name),
                                   } :
                                   new LocalQuickFix[]{};
           problemsHolder.registerProblem(id, "Unresolved reference " + "'" + name + "'", LIKE_UNKNOWN_SYMBOL, fixes);

File: gen/com/goide/psi/GoMethodSpec.java
Patch:
@@ -7,7 +7,7 @@
 import com.intellij.psi.StubBasedPsiElement;
 import com.goide.stubs.GoMethodSpecStub;
 
-public interface GoMethodSpec extends GoNamedElement, StubBasedPsiElement<GoMethodSpecStub> {
+public interface GoMethodSpec extends GoReceiverHolder, StubBasedPsiElement<GoMethodSpecStub> {
 
   @Nullable
   GoSignature getSignature();

File: src/com/goide/psi/GoFunctionOrMethodDeclaration.java
Patch:
@@ -4,7 +4,7 @@
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public interface GoFunctionOrMethodDeclaration extends GoNamedElement, GoTopLevelDeclaration {
+public interface GoFunctionOrMethodDeclaration extends GoNamedElement, GoTopLevelDeclaration, GoReceiverHolder {
 
   @Nullable
   GoBlock getBlock();

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -101,8 +101,8 @@ public static boolean processDeclarations(@NotNull GoCompositeElement o,
   }
 
   @NotNull
-  public static LookupElement createFunctionOrMethodLookupElement(@NotNull GoFunctionOrMethodDeclaration f) {
-    Icon icon = f instanceof GoMethodDeclaration ? GoIcons.METHOD : GoIcons.FUNCTION;
+  public static LookupElement createFunctionOrMethodLookupElement(@NotNull GoReceiverHolder f) {
+    Icon icon = f instanceof GoMethodDeclaration || f instanceof GoMethodSpec ? GoIcons.METHOD : GoIcons.FUNCTION;
     GoSignature signature = f.getSignature();
     int paramsCount = 0;
     String resultText = "";

File: gen/com/goide/GoTypes.java
Patch:
@@ -65,7 +65,7 @@ public interface GoTypes {
   IElementType MAP_TYPE = new GoCompositeElementType("MAP_TYPE");
   IElementType METHOD_DECLARATION = GoStubElementTypeFactory.factory("METHOD_DECLARATION");
   IElementType METHOD_EXPR = new GoCompositeElementType("METHOD_EXPR");
-  IElementType METHOD_SPEC = new GoCompositeElementType("METHOD_SPEC");
+  IElementType METHOD_SPEC = GoStubElementTypeFactory.factory("METHOD_SPEC");
   IElementType MUL_EXPR = new GoCompositeElementType("MUL_EXPR");
   IElementType OR_EXPR = new GoCompositeElementType("OR_EXPR");
   IElementType PACKAGE_CLAUSE = new GoCompositeElementType("PACKAGE_CLAUSE");

File: gen/com/goide/psi/GoMethodSpec.java
Patch:
@@ -4,8 +4,10 @@
 import java.util.List;
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
+import com.intellij.psi.StubBasedPsiElement;
+import com.goide.stubs.GoMethodSpecStub;
 
-public interface GoMethodSpec extends GoCompositeElement {
+public interface GoMethodSpec extends GoNamedElement, StubBasedPsiElement<GoMethodSpecStub> {
 
   @Nullable
   GoSignature getSignature();

File: gen/com/goide/psi/GoVisitor.java
Patch:
@@ -219,7 +219,7 @@ public void visitMethodExpr(@NotNull GoMethodExpr o) {
   }
 
   public void visitMethodSpec(@NotNull GoMethodSpec o) {
-    visitCompositeElement(o);
+    visitNamedElement(o);
   }
 
   public void visitMulExpr(@NotNull GoMulExpr o) {

File: src/com/goide/stubs/GoStubElementTypeFactory.java
Patch:
@@ -16,6 +16,7 @@ public static IElementType factory(@NotNull String name) {
     if (name.equals("PARAM_DEFINITION")) return new GoParamDefinitionStubElementType(name);
     if (name.equals("RECEIVER")) return new GoReceiverStubElementType(name);
     if (name.equals("TYPE_SPEC")) return new GoTypeSpecStubElementType(name);
+    if (name.equals("METHOD_SPEC")) return new GoMethodSpecStubElementType(name);
     if (name.equals("VAR_DEFINITION")) return new GoVarDefinitionStubElementType(name);
 
     throw new RuntimeException("Unknown element type: " + name);

File: src/com/goide/stubs/index/GoAllNamesIndex.java
Patch:
@@ -10,7 +10,7 @@ public class GoAllNamesIndex extends StringStubIndexExtension<GoNamedElement> {
 
   @Override
   public int getVersion() {
-    return 3;
+    return 4;
   }
 
   @NotNull

File: src/com/goide/codeInsight/imports/GoGetPackageFix.java
Patch:
@@ -1,6 +1,7 @@
 package com.goide.codeInsight.imports;
 
 import com.goide.jps.model.JpsGoSdkType;
+import com.intellij.codeInsight.intention.HighPriorityAction;
 import com.intellij.codeInspection.LocalQuickFixBase;
 import com.intellij.codeInspection.ProblemDescriptor;
 import com.intellij.execution.ExecutionException;
@@ -32,7 +33,7 @@
 
 import java.util.List;
 
-public class GoGetPackageFix extends LocalQuickFixBase {
+public class GoGetPackageFix extends LocalQuickFixBase implements HighPriorityAction {
   private static final String TITLE = "Something went wrong with `go get`";
   @NotNull private final String myPackage;
 

File: src/com/goide/psi/impl/GoReferenceBase.java
Patch:
@@ -146,8 +146,7 @@ protected PsiElement processGoType(@Nullable GoType type) {
 
     if (type instanceof GoPointerType) type = ((GoPointerType)type).getType();
 
-    GoTypeReferenceExpression refExpr = type != null ? type.getTypeReferenceExpression() : null;
-    return processInTypeRef(refExpr, type);
+    return processInTypeRef(GoPsiImplUtil.getTypeReference(type), type);
   }
 
   @Nullable
@@ -225,7 +224,7 @@ public Object[] getVariants() {
             processInType(result, goType.getParent(), goType);
           }
 
-          GoTypeReferenceExpression expression = goType != null ? goType.getTypeReferenceExpression() : null;
+          GoTypeReferenceExpression expression = GoPsiImplUtil.getTypeReference(goType);
           PsiReference reference = expression != null ? expression.getReference() : null;
           PsiElement resolve = reference != null ? reference.resolve() : null;
           if (resolve instanceof GoTypeSpec) {

File: src/com/goide/stubs/types/GoMethodDeclarationStubElementType.java
Patch:
@@ -3,6 +3,7 @@
 import com.goide.psi.GoMethodDeclaration;
 import com.goide.psi.GoTypeReferenceExpression;
 import com.goide.psi.impl.GoMethodDeclarationImpl;
+import com.goide.psi.impl.GoPsiImplUtil;
 import com.goide.stubs.GoFileStub;
 import com.goide.stubs.GoMethodDeclarationStub;
 import com.goide.stubs.index.GoMethodIndex;
@@ -27,7 +28,7 @@ public GoMethodDeclaration createPsi(@NotNull GoMethodDeclarationStub stub) {
 
   @Override
   public GoMethodDeclarationStub createStub(@NotNull GoMethodDeclaration psi, StubElement parentStub) {
-    GoTypeReferenceExpression reference = psi.getReceiver().getType().getTypeReferenceExpression();
+    GoTypeReferenceExpression reference = GoPsiImplUtil.getTypeReference(psi.getReceiver().getType());
     String text = reference != null ? reference.getIdentifier().getText() : null;
     return new GoMethodDeclarationStub(parentStub, this, psi.getName(), psi.isPublic(), text);
   }

File: src/com/goide/completion/GoCompletionContributor.java
Patch:
@@ -33,6 +33,7 @@
 public class GoCompletionContributor extends CompletionContributor {
   public static final int FUNCTION_PRIORITY = 10;
   public static final int TYPE_PRIORITY = 15;
+  public static final int TYPE_CONVERSION = 15;
   public static final int VAR_PRIORITY = 15;
   public static final int PACKAGE_PRIORITY = 5;
 

File: gen/com/goide/psi/GoConstDeclaration.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoConstDeclaration extends GoCompositeElement {
+public interface GoConstDeclaration extends GoTopLevelDeclaration {
 
   @NotNull
   List<GoConstSpec> getConstSpecList();

File: gen/com/goide/psi/GoTypeDeclaration.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoTypeDeclaration extends GoCompositeElement {
+public interface GoTypeDeclaration extends GoTopLevelDeclaration {
 
   @NotNull
   List<GoTypeSpec> getTypeSpecList();

File: gen/com/goide/psi/GoVarDeclaration.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoVarDeclaration extends GoCompositeElement {
+public interface GoVarDeclaration extends GoTopLevelDeclaration {
 
   @NotNull
   List<GoVarSpec> getVarSpecList();

File: src/com/goide/psi/GoFunctionOrMethodDeclaration.java
Patch:
@@ -4,7 +4,7 @@
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public interface GoFunctionOrMethodDeclaration extends GoNamedElement {
+public interface GoFunctionOrMethodDeclaration extends GoNamedElement, GoTopLevelDeclaration {
 
   @Nullable
   GoBlock getBlock();

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -47,4 +47,5 @@ protected void setUp() throws Exception {
   public void testCars()        { doTest(true);  }
   public void testRecover()     { doTest(false); }
   public void testMethodExpr()  { doTest(false); }
+  public void testMethodWithoutReceiverIdentifier()  { doTest(false); }
 }

File: src/com/goide/codeInsight/imports/GoGetPackageFix.java
Patch:
@@ -1,4 +1,4 @@
-package com.goide.psi.impl.imports;
+package com.goide.codeInsight.imports;
 
 import com.goide.jps.model.JpsGoSdkType;
 import com.intellij.codeInspection.LocalQuickFixBase;

File: src/com/goide/psi/impl/imports/GoImportReferenceHelper.java
Patch:
@@ -1,6 +1,7 @@
 package com.goide.psi.impl.imports;
 
 import com.goide.GoSdkType;
+import com.goide.codeInsight.imports.GoGetPackageFix;
 import com.goide.psi.GoFile;
 import com.intellij.codeInsight.daemon.quickFix.CreateFileFix;
 import com.intellij.codeInspection.LocalQuickFix;

File: src/com/goide/psi/impl/imports/GoGetPackageFix.java
Patch:
@@ -94,8 +94,7 @@ public void processTerminated(ProcessEvent event) {
           indicator.setText2("Refreshing");
         }
         catch (ExecutionException e) {
-          Notifications.Bus.notify(
-            new Notification("Go", TITLE, StringUtil.notNullize(e.getMessage()), NotificationType.WARNING), project);
+          Notifications.Bus.notify(new Notification("Go", TITLE, StringUtil.notNullize(e.getMessage()), NotificationType.WARNING), project);
         }
         finally {
           LocalFileSystem.getInstance().refresh(false);

File: src/com/goide/debugger/gdb/gdbmi/GdbMiLexer.java
Patch:
@@ -136,6 +136,7 @@ public void process(byte[] data, int length) {
               break;
 
             case '\r':
+            case '\n':
               m_tokens.add(new GdbMiToken(GdbMiToken.Type.NewLine));
               m_state = FsmState.CrLf;
               break;

File: src/com/goide/debugger/ideagdb/debug/breakpoints/GdbBreakpointType.java
Patch:
@@ -35,6 +35,7 @@ public boolean canPutAt(@NotNull VirtualFile file, int line, @NotNull Project pr
          extension.equals("h") ||
          extension.equals("hpp") ||
          extension.equals("hh") ||
+         extension.equals("go") ||
          extension.equals("hxx"))) {
       return true;
     }

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -244,7 +244,7 @@ public static String getText(@Nullable PsiElement o) {
 
   @NotNull
   public static List<GoMethodDeclaration> getMethods(@NotNull final GoTypeSpec o) {
-    final PsiDirectory dir = o.getContainingFile().getParent();
+    final PsiDirectory dir = o.getContainingFile().getOriginalFile().getParent();
     if (dir != null) {
       return CachedValuesManager.getCachedValue(o, new CachedValueProvider<List<GoMethodDeclaration>>() {
         @Nullable
@@ -259,8 +259,7 @@ public Result<List<GoMethodDeclaration>> compute() {
 
   @NotNull
   private static List<GoMethodDeclaration> calcMethods(@NotNull GoTypeSpec o) {
-    PsiFile file = o.getContainingFile().getOriginalFile();
-    PsiDirectory dir = file.getParent();
+    PsiDirectory dir = o.getContainingFile().getOriginalFile().getParent();
     if (dir == null) return ContainerUtil.emptyList();
     List<GoMethodDeclaration> result = ContainerUtil.newArrayList();
     for (PsiFile psiFile : dir.getFiles()) {

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -15,4 +15,7 @@ public interface GoTypeSpec extends GoNamedElement, StubBasedPsiElement<GoTypeSp
   @NotNull
   PsiElement getIdentifier();
 
+  @NotNull
+  List<GoMethodDeclaration> getMethods();
+
 }

File: src/com/goide/runconfig/testing/GoTestConsoleFilter.java
Patch:
@@ -13,7 +13,7 @@
 import java.util.regex.Pattern;
 
 class GoTestConsoleFilter implements Filter {
-  private static final Pattern MESSAGE_PATTERN = Pattern.compile("(\\S+\\.\\w+):(\\d+)[:\\s].*\n");
+  private static final Pattern MESSAGE_PATTERN = Pattern.compile("[ \t]*(\\S+\\.\\w+):(\\d+)[:\\s].*\n");
 
   @NotNull
   private final Module myModule;

File: gen/com/goide/psi/GoAnonymousFieldDefinition.java
Patch:
@@ -23,4 +23,7 @@ public interface GoAnonymousFieldDefinition extends GoNamedElement, StubBasedPsi
 
   int getTextOffset();
 
+  @Nullable
+  GoType getGoType();
+
 }

File: src/com/goide/psi/impl/GoReference.java
Patch:
@@ -100,7 +100,7 @@ protected void processFile(@NotNull List<LookupElement> result, @NotNull GoFile
       if (list.size() > 1 && list.get(1).isEquivalentTo(myElement)) {
         GoType type = list.get(0).getGoType();
         if (type != null) {
-          processInType(result, type, type);
+          processInType(result, type.getParent(), type);
         }
       }
       return;

File: src/com/goide/GoStructureViewFactory.java
Patch:
@@ -131,7 +131,9 @@ else if (myElement instanceof GoTypeSpec) {
         return ((GoTypeSpec)myElement).getIdentifier().getText() + appendix;
       }
       else if (myElement instanceof GoNamedElement) {
-        return ((GoNamedElement)myElement).getName();
+        GoType type = ((GoNamedElement)myElement).getGoType();
+        String typeText = type == null ? "" : ":" + GoPsiImplUtil.getText(type);
+        return ((GoNamedElement)myElement).getName() + typeText;
       }
       throw new AssertionError(myElement.getClass().getName());
     }

File: src/com/goide/GoStructureViewFactory.java
Patch:
@@ -1,6 +1,7 @@
 package com.goide;
 
 import com.goide.psi.*;
+import com.goide.psi.impl.GoPsiImplUtil;
 import com.intellij.ide.structureView.*;
 import com.intellij.ide.util.treeView.smartTree.TreeElement;
 import com.intellij.lang.PsiStructureViewFactory;
@@ -126,7 +127,7 @@ else if (myElement instanceof GoFunctionOrMethodDeclaration) {
       }
       else if (myElement instanceof GoTypeSpec) {
         GoType type = ((GoTypeSpec)myElement).getType();
-        String appendix = type instanceof GoStructType ? "" : (type != null ? ":" + type.getText().replaceAll("\\s+", " ") : "");
+        String appendix = type instanceof GoStructType ? "" : (type != null ? ":" + GoPsiImplUtil.getTypeText(type) : "");
         return ((GoTypeSpec)myElement).getIdentifier().getText() + appendix;
       }
       else if (myElement instanceof GoNamedElement) {

File: tests/com/goide/spellchecker/GoHighlightingTest.java
Patch:
@@ -25,4 +25,5 @@ protected boolean isWriteActionRequired() {
   }
 
   public void testSimple() throws Exception { doTest(); }
+  public void testStruct() throws Exception { doTest(); }
 }

File: src/com/goide/psi/impl/GoReferenceBase.java
Patch:
@@ -54,7 +54,7 @@ private static PsiElement calcQualifierResolve(PsiElement qualifier) {
 
   @Nullable
   protected PsiDirectory resolvePackage(@NotNull String str) {
-    if (str.startsWith("/")) return null;
+    if (str.startsWith("/") || str.isEmpty()) return null;
     for (VirtualFile file : getPathsToLookup()) {
       VirtualFile child = file != null ? file.findFileByRelativePath(str) : null;
       if (child != null) return PsiManager.getInstance(myElement.getProject()).findDirectory(child);

File: src/com/goide/psi/impl/GoReferenceBase.java
Patch:
@@ -220,6 +220,7 @@ public Object[] getVariants() {
         PsiElement qualifierResolve = calcQualifierResolve(qualifier);
         if (qualifierResolve instanceof GoNamedElement) {
           GoType goType = ((GoNamedElement)qualifierResolve).getGoType();
+          if (goType instanceof GoPointerType) goType = ((GoPointerType)goType).getType();
           GoTypeReferenceExpression expression = goType != null ? goType.getTypeReferenceExpression() : null;
           PsiReference reference = expression != null ? expression.getReference() : null;
           PsiElement resolve = reference != null ? reference.resolve() : null;

File: src/com/goide/psi/impl/GoReferenceBase.java
Patch:
@@ -154,7 +154,7 @@ private PsiElement processGoType(@Nullable GoType type) {
 
     if (type instanceof GoPointerType) type = ((GoPointerType)type).getType();
 
-    GoTypeReferenceExpression refExpr = type.getTypeReferenceExpression();
+    GoTypeReferenceExpression refExpr = type != null ? type.getTypeReferenceExpression() : null;
     PsiReference reference = refExpr != null ? refExpr.getReference() : null;
     PsiElement resolve = reference != null ? reference.resolve() : null;
     if (resolve instanceof GoTypeSpec) {

File: src/com/goide/psi/impl/GoReferenceBase.java
Patch:
@@ -152,6 +152,8 @@ private PsiElement processGoType(@Nullable GoType type) {
     PsiElement fromExistingType = processExistingType(type);
     if (fromExistingType != null) return fromExistingType;
 
+    if (type instanceof GoPointerType) type = ((GoPointerType)type).getType();
+
     GoTypeReferenceExpression refExpr = type.getTypeReferenceExpression();
     PsiReference reference = refExpr != null ? refExpr.getReference() : null;
     PsiElement resolve = reference != null ? reference.resolve() : null;

File: src/com/goide/GoParserDefinition.java
Patch:
@@ -52,7 +52,7 @@ public PsiParser createParser(Project project) {
 
   @Override
   public IFileElementType getFileNodeType() {
-    return GoElementTypes.FILE;
+    return GoFileElementType.INSTANCE;
   }
 
   @NotNull

File: src/com/goide/runconfig/testing/GoTestRunConfigurationProducer.java
Patch:
@@ -89,7 +89,7 @@ public boolean isConfigurationFromContext(GoTestRunConfiguration configuration,
         return isPackageContext(contextElement) && 
                StringUtil.notNullize(((GoFile)file).getPackageName()).equals(configuration.getPackage());
       case FILE:
-        if (!FileUtil.pathsEqual(configuration.getFilePath(), file.getVirtualFile().getPath())) {
+        if (file == null || !FileUtil.pathsEqual(configuration.getFilePath(), file.getVirtualFile().getPath())) {
           return false;
         }
         String functionNameFromContext = findFunctionNameFromContext(contextElement);

File: src/com/goide/psi/impl/GoVarProcessor.java
Patch:
@@ -26,7 +26,7 @@ public GoVarProcessor(String requestedName, PsiElement origin, boolean completio
 
   @Override
   public boolean execute(@NotNull PsiElement psiElement, ResolveState resolveState) {
-    if (psiElement instanceof GoFunctionDeclaration) return false;
+    if (psiElement instanceof GoFunctionOrMethodDeclaration) return false;
     if (!(psiElement instanceof GoNamedElement)) return true;
     if (!(psiElement instanceof GoVarDefinition) &&
         !(psiElement instanceof GoParamDefinition) &&

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -4,8 +4,10 @@
 import java.util.List;
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
+import com.intellij.psi.StubBasedPsiElement;
+import com.goide.stubs.GoTypeSpecStub;
 
-public interface GoTypeSpec extends GoNamedElement {
+public interface GoTypeSpec extends GoNamedElement, StubBasedPsiElement<GoTypeSpecStub> {
 
   @Nullable
   GoType getType();

File: gen/com/goide/psi/impl/GoTypeSpecImpl.java
Patch:
@@ -8,16 +8,17 @@
 import com.intellij.psi.PsiElementVisitor;
 import com.intellij.psi.util.PsiTreeUtil;
 import static com.goide.GoTypes.*;
+import com.goide.stubs.GoTypeSpecStub;
 import com.goide.psi.*;
 import com.intellij.psi.stubs.IStubElementType;
 
-public class GoTypeSpecImpl extends GoNamedElementImpl<?> implements GoTypeSpec {
+public class GoTypeSpecImpl extends GoNamedElementImpl<GoTypeSpecStub> implements GoTypeSpec {
 
   public GoTypeSpecImpl(ASTNode node) {
     super(node);
   }
 
-  public GoTypeSpecImpl(? stub, IStubElementType nodeType) {
+  public GoTypeSpecImpl(GoTypeSpecStub stub, IStubElementType nodeType) {
     super(stub, nodeType);
   }
 

File: src/com/goide/runconfig/testing/GoTestConsoleProperties.java
Patch:
@@ -76,13 +76,14 @@ protected boolean processServiceMessages(String text, Key outputType, ServiceMes
       if (myFailed) {
         if (!StringUtil.isEmptyOrSpaces(text) && !FINISHED.matcher(text).find()) {
           myStdOut.append(text);
+          return true;
         }
         else {
           return processFailedMessage(outputType, visitor);
         }
       }
 
-      return true;
+      return super.processServiceMessages(text, outputType, visitor);
     }
 
     private boolean processNotFinishedMessage(String message, Key outputType, ServiceMessageVisitor visitor) throws ParseException {

File: src/com/goide/runconfig/testing/GoTestRunConfigurationProducer.java
Patch:
@@ -80,6 +80,9 @@ public boolean isConfigurationFromContext(GoTestRunConfiguration configuration,
     PsiFile file = contextElement.getContainingFile();
     switch (configuration.getKind()) {
       case DIRECTORY:
+        if (!(contextElement instanceof PsiDirectory)) {
+          return false;
+        }
         String directoryPath = ((PsiDirectory)contextElement).getVirtualFile().getPath();
         return FileUtil.pathsEqual(configuration.getDirectoryPath(), directoryPath) &&
                FileUtil.pathsEqual(configuration.getWorkingDirectory(), directoryPath);

File: gen/com/goide/psi/GoExpression.java
Patch:
@@ -7,4 +7,7 @@
 
 public interface GoExpression extends GoCompositeElement {
 
+  @Nullable
+  GoType getGoType();
+
 }

File: gen/com/goide/psi/GoVarDefinition.java
Patch:
@@ -10,4 +10,7 @@ public interface GoVarDefinition extends GoNamedElement {
   @NotNull
   PsiElement getIdentifier();
 
+  @Nullable
+  GoType getGoType();
+
 }

File: src/com/goide/parser/GoParserUtil.java
Patch:
@@ -31,7 +31,7 @@ public static boolean exitMode(PsiBuilder builder_, @SuppressWarnings("UnusedPar
     TObjectIntHashMap<String> flags = getParsingModes(builder_);
     int count = flags.get(mode);
     if (count == 1) flags.remove(mode);
-    else if (count > 1) flags.put(mode, count -1);
+    else if (count > 1) flags.put(mode, count -1 );
     else builder_.error("Could not exit inactive '" + mode + "' mode at offset " + builder_.getCurrentOffset());
     return true;
   }

File: src/com/goide/GoSdkType.java
Patch:
@@ -140,9 +140,9 @@ public String getPresentableName() {
   public void setupSdkPaths(@NotNull Sdk sdk) {
     SdkModificator modificator = sdk.getSdkModificator();
     add(modificator, new File(sdk.getHomePath(), "src/pkg")); // scr/pkg is enough at the moment, possible process binaries from pkg
-    for (VirtualFile file : getGoPathsSources()) {
-      add(modificator, file);
-    }
+    //for (VirtualFile file : getGoPathsSources()) {
+    //  add(modificator, file);
+    //}
     modificator.commitChanges();
   }
 

File: src/com/goide/psi/impl/GoPsiImplUtil.java
Patch:
@@ -60,7 +60,7 @@ public static boolean processDeclarations(@NotNull GoCompositeElement o,
         o instanceof GoCommClause ||
         o instanceof GoTypeCaseClause ||
         o instanceof GoExprCaseClause) {
-      return false;
+      return processor.execute(o, state);
     }
     return GoCompositeElementImpl.precessDeclarationDefault(o, processor, state, lastParent, place);
   }

File: src/com/goide/runconfig/GoRunConfigurationBase.java
Patch:
@@ -45,7 +45,7 @@ public final RunningState createRunningState(ExecutionEnvironment env) throws Ex
     GoModuleBasedConfiguration configuration = getConfigurationModule();
     Module module = configuration.getModule();
     if (module == null) {
-      throw new ExecutionException("No Erlang configuration for run configuration: " + getName());
+      throw new ExecutionException("Go isn't configured for run configuration: " + getName());
     }
     return newRunningState(env, module);
   }

File: src/com/goide/runconfig/testing/GoTestConsoleProperties.java
Patch:
@@ -78,9 +78,10 @@ protected boolean processServiceMessages(String text, Key outputType, ServiceMes
           myStdOut.append(text);
         }
         else {
+          String failedMessage = ServiceMessageBuilder.testFailed(myCurrentTest).addAttribute("message", myStdOut.toString()).toString();
           myFailed = false;
           myStdOut = new StringBuilder();
-          return super.processServiceMessages(failedMessage(), outputType, visitor)
+          return super.processServiceMessages(failedMessage, outputType, visitor)
                  && super.processServiceMessages(ServiceMessageBuilder.testFinished(myCurrentTest).toString(), outputType, visitor);
         }
       }

File: src/com/goide/refactor/GoDescriptionProvider.java
Patch:
@@ -29,6 +29,7 @@ public String getElementDescription(@NotNull PsiElement o, @NotNull ElementDescr
       if (o instanceof GoVarDefinition) return "Variable";
       if (o instanceof GoParamDefinition) return "Parameter";
       if (o instanceof GoTypeSpec) return "Type";
+      if (o instanceof GoImportSpec) return "Import alias";
     }
     return null;
   }

File: jps-plugin/src/com/goide/jps/builder/GoCompilerProcessAdapter.java
Patch:
@@ -27,8 +27,9 @@ public void onTextAvailable(@NotNull ProcessEvent event, Key outputType) {
     if (error != null) {
       boolean isError = error.getCategory() == CompilerMessageCategory.ERROR;
       BuildMessage.Kind kind = isError ? BuildMessage.Kind.ERROR : BuildMessage.Kind.WARNING;
-      CompilerMessage msg = new CompilerMessage(myBuilderName, kind, error.getErrorMessage(),
-        VirtualFileManager.extractPath(error.getUrl()), -1, -1, -1, error.getLine(), -1);
+      String errorUrl = error.getUrl();
+      String sourcePath = errorUrl != null ? VirtualFileManager.extractPath(errorUrl) : null;
+      CompilerMessage msg = new CompilerMessage(myBuilderName, kind, error.getErrorMessage(), sourcePath, -1, -1, -1, error.getLine(), -1);
       myContext.processMessage(msg);
     }
   }

File: jps-plugin/src/com/goide/jps/builder/GoCompilerError.java
Patch:
@@ -11,7 +11,6 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-//TODO
 public class GoCompilerError {
   private static final Pattern COMPILER_MESSAGE_PATTERN = Pattern.compile("^(.+):(\\d+):\\s*(.+)$");
 

File: gen/com/goide/psi/GoTypeReferenceExpression.java
Patch:
@@ -14,4 +14,7 @@ public interface GoTypeReferenceExpression extends GoCompositeElement {
   @Nullable
   PsiReference getReference();
 
+  @Nullable
+  GoTypeReferenceExpression getQualifier();
+
 }

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoTypeSpec extends GoCompositeElement {
+public interface GoTypeSpec extends GoNamedElement {
 
   @Nullable
   GoType getType();

File: gen/com/goide/psi/GoVisitor.java
Patch:
@@ -327,7 +327,7 @@ public void visitTypeReferenceExpression(@NotNull GoTypeReferenceExpression o) {
   }
 
   public void visitTypeSpec(@NotNull GoTypeSpec o) {
-    visitCompositeElement(o);
+    visitNamedElement(o);
   }
 
   public void visitTypeSwitchCase(@NotNull GoTypeSwitchCase o) {

File: gen/com/goide/psi/impl/GoTypeSpecImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoTypeSpecImpl extends GoCompositeElementImpl implements GoTypeSpec {
+public class GoTypeSpecImpl extends GoTypeDeclImpl implements GoTypeSpec {
 
   public GoTypeSpecImpl(ASTNode node) {
     super(node);

File: src/com/goide/completion/GoCompletionContributor.java
Patch:
@@ -23,6 +23,7 @@
 
 public class GoCompletionContributor extends CompletionContributor {
   public static final int FUNCTION_PRIORITY = 10;
+  public static final int TYPE_PRIORITY = 5;
 
   public GoCompletionContributor() {
     extend(CompletionType.BASIC, psiElement().inFile(instanceOf(GoFile.class)), new CompletionProvider<CompletionParameters>() {

File: gen/com/goide/psi/GoForClause.java
Patch:
@@ -7,7 +7,7 @@
 
 public interface GoForClause extends GoCompositeElement {
 
-  @NotNull
+  @Nullable
   GoExpression getExpression();
 
   @NotNull

File: gen/com/goide/psi/GoForStatement.java
Patch:
@@ -10,6 +10,9 @@ public interface GoForStatement extends GoStatement {
   @Nullable
   GoBlock getBlock();
 
+  @Nullable
+  GoExpression getExpression();
+
   @Nullable
   GoForClause getForClause();
 

File: gen/com/goide/psi/impl/GoForClauseImpl.java
Patch:
@@ -22,9 +22,9 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public GoExpression getExpression() {
-    return findNotNullChildByClass(GoExpression.class);
+    return findChildByClass(GoExpression.class);
   }
 
   @Override

File: gen/com/goide/psi/GoParameters.java
Patch:
@@ -10,4 +10,7 @@ public interface GoParameters extends GoCompositeElement {
   @NotNull
   List<GoParameterDeclaration> getParameterDeclarationList();
 
+  @NotNull
+  List<GoType> getTypeList();
+
 }

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -42,4 +42,5 @@ protected void setUp() throws Exception {
   public void testError()  { doTest(true); }
   public void testWriter() { doTest(true); }
   public void testPrimer() { doTest(true); }
+  public void testTypes()  { doTest(true); }
 }

File: jps-plugin/src/com/goide/jps/builder/GoBuilder.java
Patch:
@@ -113,7 +113,7 @@ private static JpsSdk<JpsDummyElement> getSdk(@NotNull CompileContext context,
     return sdk;
   }
 
-  private static void runBuildProcess(@NotNull CompileContext context, @NotNull GeneralCommandLine commandLine, String path)
+  private static void runBuildProcess(@NotNull CompileContext context, @NotNull GeneralCommandLine commandLine, @NotNull String path)
     throws ProjectBuildException {
     Process process;
     try {

File: jps-plugin/tests/com/goide/jps/JpsBuildTestCase.java
Patch:
@@ -239,6 +239,7 @@ protected String getTestDataRootPath() {
     return null;
   }
 
+  @NotNull
   protected <T extends JpsElement> JpsModule addModule(@NotNull String moduleName,
                                                        @NotNull String[] srcPaths,
                                                        @Nullable String outputPath,
@@ -351,6 +352,7 @@ public String getAbsolutePath(@NotNull final String pathRelativeToProjectRoot) {
     return FileUtil.toSystemIndependentName(new File(getOrCreateProjectDir(), pathRelativeToProjectRoot).getAbsolutePath());
   }
 
+  @NotNull
   public JpsModule addModule(@NotNull String moduleName, @NotNull String... srcPaths) {
     if (myJdk == null) {
       myJdk = addJdk("1.6");

File: gen/com/goide/psi/GoResult.java
Patch:
@@ -10,7 +10,7 @@ public interface GoResult extends GoCompositeElement {
   @Nullable
   GoParameters getParameters();
 
-  @Nullable
-  GoType getType();
+  @NotNull
+  List<GoType> getTypeList();
 
 }

File: gen/com/goide/psi/GoTypeSwitchCase.java
Patch:
@@ -7,8 +7,8 @@
 
 public interface GoTypeSwitchCase extends GoCompositeElement {
 
-  @Nullable
-  GoTypeList getTypeList();
+  @NotNull
+  List<GoType> getTypeList();
 
   @Nullable
   PsiElement getCase();

File: gen/com/goide/psi/impl/GoResultImpl.java
Patch:
@@ -28,9 +28,9 @@ public GoParameters getParameters() {
   }
 
   @Override
-  @Nullable
-  public GoType getType() {
-    return findChildByClass(GoType.class);
+  @NotNull
+  public List<GoType> getTypeList() {
+    return PsiTreeUtil.getChildrenOfTypeAsList(this, GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoTypeSwitchCaseImpl.java
Patch:
@@ -22,9 +22,9 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Override
-  @Nullable
-  public GoTypeList getTypeList() {
-    return findChildByClass(GoTypeList.class);
+  @NotNull
+  public List<GoType> getTypeList() {
+    return PsiTreeUtil.getChildrenOfTypeAsList(this, GoType.class);
   }
 
   @Override

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -41,4 +41,5 @@ protected void setUp() throws Exception {
   public void testSimple() { doTest(true); }
   public void testError()  { doTest(true); }
   public void testWriter() { doTest(true); }
+  public void testPrimer() { doTest(true); }
 }

File: gen/com/goide/psi/GoMethodSpec.java
Patch:
@@ -8,10 +8,10 @@
 public interface GoMethodSpec extends GoCompositeElement {
 
   @Nullable
-  GoInterfaceTypeName getInterfaceTypeName();
+  GoSignature getSignature();
 
   @Nullable
-  GoSignature getSignature();
+  GoTypeName getTypeName();
 
   @Nullable
   PsiElement getIdentifier();

File: gen/com/goide/psi/GoType.java
Patch:
@@ -7,9 +7,6 @@
 
 public interface GoType extends GoCompositeElement {
 
-  @Nullable
-  GoTypeLit getTypeLit();
-
   @Nullable
   GoTypeName getTypeName();
 

File: tests/com/goide/parser/GoParserTest.java
Patch:
@@ -39,4 +39,5 @@ protected void setUp() throws Exception {
   }
 
   public void testSimple() { doTest(true); }
+  public void testError()  { doTest(true); }
 }

File: src/com/goide/GoFileType.java
Patch:
@@ -1,15 +1,13 @@
 package com.goide;
 
 import com.intellij.openapi.fileTypes.LanguageFileType;
-import com.intellij.openapi.util.IconLoader;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import javax.swing.*;
 
 public class GoFileType extends LanguageFileType {
   public static final LanguageFileType INSTANCE = new GoFileType();
-  private static final Icon ICON = IconLoader.findIcon("/icons/go.png");
 
   protected GoFileType() {
     super(GoLanguage.INSTANCE);
@@ -36,6 +34,6 @@ public String getDefaultExtension() {
   @Nullable
   @Override
   public Icon getIcon() {
-    return ICON;
+    return GoIcons.ICON;
   }
 }

File: gen/com/goide/psi/GoFunctionType.java
Patch:
@@ -7,7 +7,7 @@
 
 public interface GoFunctionType extends GoType {
 
-  @NotNull
+  @Nullable
   GoSignature getSignature();
 
   @NotNull

File: gen/com/goide/psi/GoLabeledStatement.java
Patch:
@@ -7,7 +7,7 @@
 
 public interface GoLabeledStatement extends GoStatement {
 
-  @NotNull
+  @Nullable
   GoStatement getStatement();
 
   @NotNull

File: gen/com/goide/psi/GoMethodDeclaration.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoMethodDeclaration extends GoTopLevelDeclaration {
+public interface GoMethodDeclaration extends GoFunctionDeclaration {
 
   @Nullable
   GoFunction getFunction();

File: gen/com/goide/psi/GoPointerType.java
Patch:
@@ -7,7 +7,7 @@
 
 public interface GoPointerType extends GoType {
 
-  @NotNull
+  @Nullable
   GoType getType();
 
 }

File: gen/com/goide/psi/GoVisitor.java
Patch:
@@ -219,7 +219,7 @@ public void visitMapType(@NotNull GoMapType o) {
   }
 
   public void visitMethodDeclaration(@NotNull GoMethodDeclaration o) {
-    visitTopLevelDeclaration(o);
+    visitFunctionDeclaration(o);
   }
 
   public void visitMethodExpr(@NotNull GoMethodExpr o) {

File: gen/com/goide/psi/impl/GoFunctionTypeImpl.java
Patch:
@@ -22,9 +22,9 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public GoSignature getSignature() {
-    return findNotNullChildByClass(GoSignature.class);
+    return findChildByClass(GoSignature.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoLabeledStatementImpl.java
Patch:
@@ -22,9 +22,9 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public GoStatement getStatement() {
-    return findNotNullChildByClass(GoStatement.class);
+    return findChildByClass(GoStatement.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoMethodDeclarationImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoMethodDeclarationImpl extends GoTopLevelDeclarationImpl implements GoMethodDeclaration {
+public class GoMethodDeclarationImpl extends GoFunctionDeclarationImpl implements GoMethodDeclaration {
 
   public GoMethodDeclarationImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoPointerTypeImpl.java
Patch:
@@ -22,9 +22,9 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public GoType getType() {
-    return findNotNullChildByClass(GoType.class);
+    return findChildByClass(GoType.class);
   }
 
 }

File: src/com/goide/GoStructureViewFactory.java
Patch:
@@ -101,7 +101,6 @@ public TreeElement[] getChildren() {
           List<GoTopLevelDeclaration> declarations = ((GoFile) myElement).getDeclarations();
           for (GoTopLevelDeclaration o : declarations) result.add(new Element(o));
         }
-
         return result.toArray(new TreeElement[result.size()]);
       }
 

File: gen/com/goide/GoTypes.java
Patch:
@@ -61,7 +61,7 @@ public interface GoTypes {
   IElementType KEY = new GoCompositeElementType("KEY");
   IElementType LABELED_STATEMENT = new GoCompositeElementType("LABELED_STATEMENT");
   IElementType LITERAL = new GoCompositeElementType("LITERAL");
-  IElementType LITERAL_TYPE = new GoCompositeElementType("LITERAL_TYPE");
+  IElementType LITERAL_TYPE_EXPR = new GoCompositeElementType("LITERAL_TYPE_EXPR");
   IElementType LITERAL_VALUE = new GoCompositeElementType("LITERAL_VALUE");
   IElementType MAP_TYPE = new GoCompositeElementType("MAP_TYPE");
   IElementType METHOD_DECLARATION = new GoCompositeElementType("METHOD_DECLARATION");
@@ -350,8 +350,8 @@ else if (type == LABELED_STATEMENT) {
       else if (type == LITERAL) {
         return new GoLiteralImpl(node);
       }
-      else if (type == LITERAL_TYPE) {
-        return new GoLiteralTypeImpl(node);
+      else if (type == LITERAL_TYPE_EXPR) {
+        return new GoLiteralTypeExprImpl(node);
       }
       else if (type == LITERAL_VALUE) {
         return new GoLiteralValueImpl(node);

File: gen/com/goide/psi/GoCompositeLit.java
Patch:
@@ -8,7 +8,7 @@
 public interface GoCompositeLit extends GoExpression {
 
   @NotNull
-  GoLiteralType getLiteralType();
+  GoExpression getExpression();
 
   @NotNull
   GoLiteralValue getLiteralValue();

File: gen/com/goide/psi/GoFunctionLit.java
Patch:
@@ -7,7 +7,7 @@
 
 public interface GoFunctionLit extends GoExpression {
 
-  @NotNull
+  @Nullable
   GoFunction getFunction();
 
   @NotNull

File: gen/com/goide/psi/GoLabeledStatement.java
Patch:
@@ -7,7 +7,7 @@
 
 public interface GoLabeledStatement extends GoStatement {
 
-  @Nullable
+  @NotNull
   GoStatement getStatement();
 
   @NotNull

File: gen/com/goide/psi/GoVisitor.java
Patch:
@@ -206,8 +206,8 @@ public void visitLiteral(@NotNull GoLiteral o) {
     visitExpression(o);
   }
 
-  public void visitLiteralType(@NotNull GoLiteralType o) {
-    visitType(o);
+  public void visitLiteralTypeExpr(@NotNull GoLiteralTypeExpr o) {
+    visitExpression(o);
   }
 
   public void visitLiteralValue(@NotNull GoLiteralValue o) {

File: gen/com/goide/psi/impl/GoCompositeLitImpl.java
Patch:
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @NotNull
-  public GoLiteralType getLiteralType() {
-    return findNotNullChildByClass(GoLiteralType.class);
+  public GoExpression getExpression() {
+    return findNotNullChildByClass(GoExpression.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoFunctionLitImpl.java
Patch:
@@ -22,9 +22,9 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Override
-  @NotNull
+  @Nullable
   public GoFunction getFunction() {
-    return findNotNullChildByClass(GoFunction.class);
+    return findChildByClass(GoFunction.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoLabeledStatementImpl.java
Patch:
@@ -22,9 +22,9 @@ public void accept(@NotNull PsiElementVisitor visitor) {
   }
 
   @Override
-  @Nullable
+  @NotNull
   public GoStatement getStatement() {
-    return findChildByClass(GoStatement.class);
+    return findNotNullChildByClass(GoStatement.class);
   }
 
   @Override

File: src/com/goide/GoParserDefinition.java
Patch:
@@ -32,7 +32,7 @@ public class GoParserDefinition implements ParserDefinition {
   public static final TokenSet NUMBERS = TokenSet.create(INT, FLOAT, IMAGINARY, DECIMALI, FLOATI); // todo: HEX, OCT,
   public static final TokenSet KEYWORDS = TokenSet.create(PACKAGE, IMPORT, BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT, DEFER,
       ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO, IF, IMPORT, INTERFACE, MAP, PACKAGE, RANGE, RETURN,
-      SELECT, STRUCT, SWITCH, TYPE, VAR);
+      SELECT, STRUCT, SWITCH, TYPE_, VAR);
   public static final TokenSet OPERATORS = TokenSet.create(EQ, ASSIGN, NOT_EQ, NOT, PLUS_PLUS,
       PLUS_ASSIGN, PLUS, MINUS_MINUS, MINUS_ASSIGN, MINUS, COND_OR, BIT_OR_ASSIGN, BIT_OR, BIT_CLEAR_ASSIGN,
       BIT_CLEAR, COND_AND, BIT_AND_ASSIGN, BIT_AND, SHIFT_LEFT_ASSIGN, SHIFT_LEFT, SEND_CHANNEL, LESS_OR_EQUAL,

File: gen/com/goide/psi/GoBaseType.java
Patch:
@@ -5,6 +5,6 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoBaseType extends GoGoType {
+public interface GoBaseType extends GoType {
 
 }

File: gen/com/goide/psi/GoBuiltinArgs.java
Patch:
@@ -11,6 +11,6 @@ public interface GoBuiltinArgs extends GoCompositeElement {
   List<GoExpression> getExpressionList();
 
   @Nullable
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoChannelType.java
Patch:
@@ -5,10 +5,10 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoChannelType extends GoGoType {
+public interface GoChannelType extends GoType {
 
   @NotNull
-  GoGoType getGoType();
+  GoType getType();
 
   @NotNull
   PsiElement getChan();

File: gen/com/goide/psi/GoConstSpec.java
Patch:
@@ -11,6 +11,6 @@ public interface GoConstSpec extends GoCompositeElement {
   List<GoExpression> getExpressionList();
 
   @Nullable
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoConversionExpr.java
Patch:
@@ -11,6 +11,6 @@ public interface GoConversionExpr extends GoExpression {
   GoExpression getExpression();
 
   @NotNull
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoFieldDecl.java
Patch:
@@ -11,9 +11,9 @@ public interface GoFieldDecl extends GoCompositeElement {
   GoAnonymousField getAnonymousField();
 
   @Nullable
-  GoGoType getGoType();
+  GoTag getTag();
 
   @Nullable
-  GoTag getTag();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoFunctionType.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoFunctionType extends GoGoType {
+public interface GoFunctionType extends GoType {
 
   @NotNull
   GoSignature getSignature();

File: gen/com/goide/psi/GoInterfaceType.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoInterfaceType extends GoGoType {
+public interface GoInterfaceType extends GoType {
 
   @NotNull
   List<GoMethodSpec> getMethodSpecList();

File: gen/com/goide/psi/GoKeyType.java
Patch:
@@ -5,6 +5,6 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoKeyType extends GoGoType {
+public interface GoKeyType extends GoType {
 
 }

File: gen/com/goide/psi/GoLiteralType.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoLiteralType extends GoGoType {
+public interface GoLiteralType extends GoType {
 
   @Nullable
   GoTypeName getTypeName();

File: gen/com/goide/psi/GoMapType.java
Patch:
@@ -5,10 +5,10 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoMapType extends GoGoType {
+public interface GoMapType extends GoType {
 
   @NotNull
-  List<GoGoType> getGoTypeList();
+  List<GoType> getTypeList();
 
   @NotNull
   PsiElement getMap();

File: gen/com/goide/psi/GoMethodDecl.java
Patch:
@@ -10,9 +10,6 @@ public interface GoMethodDecl extends GoCompositeElement {
   @Nullable
   GoFunction getFunction();
 
-  @Nullable
-  GoMethodName getMethodName();
-
   @Nullable
   GoReceiver getReceiver();
 
@@ -22,4 +19,7 @@ public interface GoMethodDecl extends GoCompositeElement {
   @NotNull
   PsiElement getFunc();
 
+  @Nullable
+  PsiElement getIdentifier();
+
 }

File: gen/com/goide/psi/GoMethodExpr.java
Patch:
@@ -8,9 +8,9 @@
 public interface GoMethodExpr extends GoExpression {
 
   @NotNull
-  GoMethodName getMethodName();
+  GoReceiverType getReceiverType();
 
   @NotNull
-  GoReceiverType getReceiverType();
+  PsiElement getIdentifier();
 
 }

File: gen/com/goide/psi/GoMethodSpec.java
Patch:
@@ -11,9 +11,9 @@ public interface GoMethodSpec extends GoCompositeElement {
   GoInterfaceTypeName getInterfaceTypeName();
 
   @Nullable
-  GoMethodName getMethodName();
+  GoSignature getSignature();
 
   @Nullable
-  GoSignature getSignature();
+  PsiElement getIdentifier();
 
 }

File: gen/com/goide/psi/GoParameterDecl.java
Patch:
@@ -8,6 +8,6 @@
 public interface GoParameterDecl extends GoCompositeElement {
 
   @NotNull
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoPointerType.java
Patch:
@@ -5,9 +5,9 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoPointerType extends GoGoType {
+public interface GoPointerType extends GoType {
 
   @NotNull
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoReceiverType.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoReceiverType extends GoGoType {
+public interface GoReceiverType extends GoType {
 
   @Nullable
   GoTypeName getTypeName();

File: gen/com/goide/psi/GoResult.java
Patch:
@@ -8,9 +8,9 @@
 public interface GoResult extends GoCompositeElement {
 
   @Nullable
-  GoGoType getGoType();
+  GoParameters getParameters();
 
   @Nullable
-  GoParameters getParameters();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoStructType.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoStructType extends GoGoType {
+public interface GoStructType extends GoType {
 
   @NotNull
   List<GoFieldDecl> getFieldDeclList();

File: gen/com/goide/psi/GoType.java
Patch:
@@ -5,7 +5,7 @@
 import org.jetbrains.annotations.*;
 import com.intellij.psi.PsiElement;
 
-public interface GoGoType extends GoCompositeElement {
+public interface GoType extends GoCompositeElement {
 
   @Nullable
   GoTypeLit getTypeLit();

File: gen/com/goide/psi/GoTypeAssertionExpr.java
Patch:
@@ -11,6 +11,6 @@ public interface GoTypeAssertionExpr extends GoExpression {
   GoExpression getExpression();
 
   @NotNull
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoTypeDecl.java
Patch:
@@ -10,7 +10,4 @@ public interface GoTypeDecl extends GoCompositeElement {
   @NotNull
   List<GoTypeSpec> getTypeSpecList();
 
-  @NotNull
-  PsiElement getType();
-
 }

File: gen/com/goide/psi/GoTypeList.java
Patch:
@@ -8,6 +8,6 @@
 public interface GoTypeList extends GoCompositeElement {
 
   @NotNull
-  List<GoGoType> getGoTypeList();
+  List<GoType> getTypeList();
 
 }

File: gen/com/goide/psi/GoTypeLit.java
Patch:
@@ -8,6 +8,6 @@
 public interface GoTypeLit extends GoExpression {
 
   @NotNull
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/GoTypeSpec.java
Patch:
@@ -8,7 +8,7 @@
 public interface GoTypeSpec extends GoCompositeElement {
 
   @Nullable
-  GoGoType getGoType();
+  GoType getType();
 
   @NotNull
   PsiElement getIdentifier();

File: gen/com/goide/psi/GoVarSpec.java
Patch:
@@ -11,6 +11,6 @@ public interface GoVarSpec extends GoCompositeElement {
   List<GoExpression> getExpressionList();
 
   @Nullable
-  GoGoType getGoType();
+  GoType getType();
 
 }

File: gen/com/goide/psi/impl/GoBaseTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoBaseTypeImpl extends GoGoTypeImpl implements GoBaseType {
+public class GoBaseTypeImpl extends GoTypeImpl implements GoBaseType {
 
   public GoBaseTypeImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoBuiltinArgsImpl.java
Patch:
@@ -29,8 +29,8 @@ public List<GoExpression> getExpressionList() {
 
   @Override
   @Nullable
-  public GoGoType getGoType() {
-    return findChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findChildByClass(GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoChannelTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoChannelTypeImpl extends GoGoTypeImpl implements GoChannelType {
+public class GoChannelTypeImpl extends GoTypeImpl implements GoChannelType {
 
   public GoChannelTypeImpl(ASTNode node) {
     super(node);
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @NotNull
-  public GoGoType getGoType() {
-    return findNotNullChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findNotNullChildByClass(GoType.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoConstSpecImpl.java
Patch:
@@ -29,8 +29,8 @@ public List<GoExpression> getExpressionList() {
 
   @Override
   @Nullable
-  public GoGoType getGoType() {
-    return findChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findChildByClass(GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoConversionExprImpl.java
Patch:
@@ -29,8 +29,8 @@ public GoExpression getExpression() {
 
   @Override
   @NotNull
-  public GoGoType getGoType() {
-    return findNotNullChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findNotNullChildByClass(GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoFunctionTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoFunctionTypeImpl extends GoGoTypeImpl implements GoFunctionType {
+public class GoFunctionTypeImpl extends GoTypeImpl implements GoFunctionType {
 
   public GoFunctionTypeImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoInterfaceTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoInterfaceTypeImpl extends GoGoTypeImpl implements GoInterfaceType {
+public class GoInterfaceTypeImpl extends GoTypeImpl implements GoInterfaceType {
 
   public GoInterfaceTypeImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoKeyTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoKeyTypeImpl extends GoGoTypeImpl implements GoKeyType {
+public class GoKeyTypeImpl extends GoTypeImpl implements GoKeyType {
 
   public GoKeyTypeImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoLiteralTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoLiteralTypeImpl extends GoGoTypeImpl implements GoLiteralType {
+public class GoLiteralTypeImpl extends GoTypeImpl implements GoLiteralType {
 
   public GoLiteralTypeImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoMapTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoMapTypeImpl extends GoGoTypeImpl implements GoMapType {
+public class GoMapTypeImpl extends GoTypeImpl implements GoMapType {
 
   public GoMapTypeImpl(ASTNode node) {
     super(node);
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @NotNull
-  public List<GoGoType> getGoTypeList() {
-    return PsiTreeUtil.getChildrenOfTypeAsList(this, GoGoType.class);
+  public List<GoType> getTypeList() {
+    return PsiTreeUtil.getChildrenOfTypeAsList(this, GoType.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoParameterDeclImpl.java
Patch:
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @NotNull
-  public GoGoType getGoType() {
-    return findNotNullChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findNotNullChildByClass(GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoPointerTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoPointerTypeImpl extends GoGoTypeImpl implements GoPointerType {
+public class GoPointerTypeImpl extends GoTypeImpl implements GoPointerType {
 
   public GoPointerTypeImpl(ASTNode node) {
     super(node);
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @NotNull
-  public GoGoType getGoType() {
-    return findNotNullChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findNotNullChildByClass(GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoReceiverTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoReceiverTypeImpl extends GoGoTypeImpl implements GoReceiverType {
+public class GoReceiverTypeImpl extends GoTypeImpl implements GoReceiverType {
 
   public GoReceiverTypeImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoStructTypeImpl.java
Patch:
@@ -10,7 +10,7 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoStructTypeImpl extends GoGoTypeImpl implements GoStructType {
+public class GoStructTypeImpl extends GoTypeImpl implements GoStructType {
 
   public GoStructTypeImpl(ASTNode node) {
     super(node);

File: gen/com/goide/psi/impl/GoTypeAssertionExprImpl.java
Patch:
@@ -29,8 +29,8 @@ public GoExpression getExpression() {
 
   @Override
   @NotNull
-  public GoGoType getGoType() {
-    return findNotNullChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findNotNullChildByClass(GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoTypeImpl.java
Patch:
@@ -10,14 +10,14 @@
 import static com.goide.GoTypes.*;
 import com.goide.psi.*;
 
-public class GoGoTypeImpl extends GoCompositeElementImpl implements GoGoType {
+public class GoTypeImpl extends GoCompositeElementImpl implements GoType {
 
-  public GoGoTypeImpl(ASTNode node) {
+  public GoTypeImpl(ASTNode node) {
     super(node);
   }
 
   public void accept(@NotNull PsiElementVisitor visitor) {
-    if (visitor instanceof GoVisitor) ((GoVisitor)visitor).visitGoType(this);
+    if (visitor instanceof GoVisitor) ((GoVisitor)visitor).visitType(this);
     else super.accept(visitor);
   }
 

File: gen/com/goide/psi/impl/GoTypeListImpl.java
Patch:
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @NotNull
-  public List<GoGoType> getGoTypeList() {
-    return PsiTreeUtil.getChildrenOfTypeAsList(this, GoGoType.class);
+  public List<GoType> getTypeList() {
+    return PsiTreeUtil.getChildrenOfTypeAsList(this, GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoTypeLitImpl.java
Patch:
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @NotNull
-  public GoGoType getGoType() {
-    return findNotNullChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findNotNullChildByClass(GoType.class);
   }
 
 }

File: gen/com/goide/psi/impl/GoTypeSpecImpl.java
Patch:
@@ -23,8 +23,8 @@ public void accept(@NotNull PsiElementVisitor visitor) {
 
   @Override
   @Nullable
-  public GoGoType getGoType() {
-    return findChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findChildByClass(GoType.class);
   }
 
   @Override

File: gen/com/goide/psi/impl/GoVarSpecImpl.java
Patch:
@@ -29,8 +29,8 @@ public List<GoExpression> getExpressionList() {
 
   @Override
   @Nullable
-  public GoGoType getGoType() {
-    return findChildByClass(GoGoType.class);
+  public GoType getType() {
+    return findChildByClass(GoType.class);
   }
 
 }

File: src/com/goide/GoLanguage.java
Patch:
@@ -8,7 +8,7 @@ public class GoLanguage extends Language {
   public static final Language INSTANCE = new GoLanguage();
 
   protected GoLanguage() {
-    super("go", "application/go");
+    super("go", "text/go", "text/x-go", "application/x-go");
   }
 
   @Nullable

