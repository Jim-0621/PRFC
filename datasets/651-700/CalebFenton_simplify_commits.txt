File: smalivm/src/main/java/org/cf/smalivm/context/HeapItem.java
Patch:
@@ -90,7 +90,7 @@ Object getValue() {
     }
 
     public String getValueType() {
-        return isNull() ? "null" : ClassNameUtils.toInternal(getValue().getClass());
+        return isNull() ? getType() : ClassNameUtils.toInternal(getValue().getClass());
     }
 
     @Override

File: smalivm/src/main/java/org/cf/smalivm/context/HeapItem.java
Patch:
@@ -90,7 +90,7 @@ Object getValue() {
     }
 
     public String getValueType() {
-        return ClassNameUtils.toInternal(getValue().getClass());
+        return isNull() ? "null" : ClassNameUtils.toInternal(getValue().getClass());
     }
 
     @Override

File: smalivm/src/main/java/org/cf/smalivm/emulate/MethodEmulator.java
Patch:
@@ -17,6 +17,7 @@ public class MethodEmulator {
     private static Map<String, Class<? extends EmulatedMethod>> emulatedMethods = new HashMap<>();
 
     static {
+        addMethod("Landroid/text/TextUtils;->isEmpty(Ljava/lang/CharSequence;)Z", android_text_TextUtils_isEmpty.class);
         addMethod("Lorg/cf/simplify/Utils;->breakpoint()V", org_cf_simplify_Utils_breakpoint.class);
         addMethod("Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;", java_lang_Class_forName.class);
         addMethod("Ljava/lang/reflect/Field;->get(Ljava/lang/Object;)Ljava/lang/Object;", java_lang_reflect_Field_get.class);

File: smalivm/src/main/java/org/cf/smalivm/emulate/MethodEmulator.java
Patch:
@@ -17,6 +17,7 @@ public class MethodEmulator {
     private static Map<String, Class<? extends EmulatedMethod>> emulatedMethods = new HashMap<>();
 
     static {
+        addMethod("Landroid/text/TextUtils;->isEmpty(Ljava/lang/CharSequence;)Z", android_text_TextUtils_isEmpty.class);
         addMethod("Lorg/cf/simplify/Utils;->breakpoint()V", org_cf_simplify_Utils_breakpoint.class);
         addMethod("Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;", java_lang_Class_forName.class);
         addMethod("Ljava/lang/reflect/Field;->get(Ljava/lang/Object;)Ljava/lang/Object;", java_lang_reflect_Field_get.class);

File: smalivm/src/test/java/org/cf/smalivm/type/VirtualArrayTest.java
Patch:
@@ -6,20 +6,20 @@
 import java.util.Arrays;
 import java.util.Set;
 import java.util.stream.Collectors;
+import org.cf.smalivm.VMTester;
 import org.cf.smalivm.dex.CommonTypes;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
 
 public class VirtualArrayTest {
 
-    private static final String TEST_DIRECTORY = "resources/test/smali";
 
     private static ClassManager classManager;
     private VirtualArray virtualArray;
 
     @BeforeAll
     public static void getClassManager() throws IOException {
-        classManager = new ClassManagerFactory().build(TEST_DIRECTORY);
+        classManager = new ClassManagerFactory().build(VMTester.TEST_CLASS_PATH);
     }
 
     @Test

File: simplify/src/main/java/org/cf/simplify/ExecutionGraphManipulator.java
Patch:
@@ -39,8 +39,7 @@ public class ExecutionGraphManipulator extends ExecutionGraph {
     private final OpCreator opCreator;
     private boolean recreateOrExecuteAgain;
 
-    public ExecutionGraphManipulator(ExecutionGraph graph, VirtualMethod method, VirtualMachine vm,
-                                     DexBuilder dexBuilder) {
+    public ExecutionGraphManipulator(ExecutionGraph graph, VirtualMethod method, VirtualMachine vm, DexBuilder dexBuilder) {
         super(graph, true);
 
         this.dexBuilder = dexBuilder;

File: smalivm/src/main/java/org/cf/smalivm/dex/SmaliFile.java
Patch:
@@ -25,7 +25,7 @@ public class SmaliFile {
     private boolean isResource;
     private boolean isSafeFramework;
 
-    SmaliFile(File file) throws FileNotFoundException {
+    SmaliFile(File file) {
         this(file.getAbsolutePath(), getClassName(file));
     }
 
@@ -34,7 +34,7 @@ public class SmaliFile {
         this.className = className;
     }
 
-    private static String getClassName(File inputFile) throws FileNotFoundException {
+    private static String getClassName(File inputFile) {
         try {
             Path myPath = Paths.get(inputFile.toURI());
             Stream<String> lines = Files.lines(myPath);

File: smalivm/src/main/java/org/cf/smalivm/type/ClassManagerFactory.java
Patch:
@@ -14,8 +14,9 @@ public class ClassManagerFactory {
 
     private static File disassemble(File file) throws IOException {
         Path tempDir = Files.createTempDirectory(TEMP_DIR_NAME);
-        String[] args = new String[]{"disassemble", "--use-locals", "--sequential-labels", "--code-offsets", file.getAbsolutePath(),
-                "--output", tempDir.toString(),};
+        String[] args = new String[]{
+            "disassemble", "--use-locals", "--sequential-labels", "--code-offsets", file.getAbsolutePath(), "--output", tempDir.toString(),
+        };
         org.jf.baksmali.Main.main(args);
 
         return tempDir.toFile();

File: smalivm/src/main/java/org/cf/smalivm/NodeExecutor.java
Patch:
@@ -89,7 +89,7 @@ public void execute(ExecutionNode node) throws UnhandledVirtualException {
             int childAddress = exceptionResolver.resolve(e, node.getAddress());
             if (childAddress <= 0) {
                 throw new RuntimeException("Real exception was thrown executing " + node +
-                                           " and was not handled. This could be a bug in smalivm.\nException: " + e);
+                                           " and was not handled. This could be a bug in smalivm.", e);
             } else {
                 if (log.isWarnEnabled()) {
                     log.warn("{} threw a real exception but was caught by an exception handler. " +

File: simplify/src/test/java/org/cf/simplify/strategy/PeepholeStrategyTest.java
Patch:
@@ -128,7 +128,7 @@ public void uselessCheckCastWithMultiplePathsIsRemoved() {
 
             int[] addresses = manipulator.getAddresses();
             assertArrayEquals(new int[] { 0, 2, 4 }, addresses);
-            assertEquals("if-eqz r0, #4", manipulator.getOp(0).toString());
+            assertEquals("if-eqz r0, :addr_4", manipulator.getOp(0).toString());
             assertEquals("sget r0, Ljava/lang/Integer;->MAX_VALUE:I", manipulator.getOp(2).toString());
             assertEquals("return-void", manipulator.getOp(4).toString());
         }
@@ -151,7 +151,7 @@ public void activeCheckCastWithMultiplePathsIsNotRemoved() {
                     getOptimizedGraph(methodName, 0, new UnknownValue(), "Ljava/lang/Object;");
 
             assertArrayEquals(new int[] { 0, 2, 3, 6, 7, 9 }, manipulator.getAddresses());
-            assertEquals("if-eqz r1, #7", manipulator.getOp(0).toString());
+            assertEquals("if-eqz r1, :addr_7", manipulator.getOp(0).toString());
             assertEquals("const/4 r0, 0x0", manipulator.getOp(2).toString());
             assertEquals("invoke-static {r0}, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;",
                     manipulator.getOp(3).toString());

File: smalivm/src/test/java/org/cf/smalivm/opcode/IfOpTest.java
Patch:
@@ -339,7 +339,7 @@ public void hasExpectedToStringValue() {
             op = (IfOp) opFactory.create(location, addressToLocation, vm);
             op.execute(node, mState);
 
-            assertEquals("if-ge r2, r4, #0", op.toString());
+            assertEquals("if-ge r2, r4, :addr_0", op.toString());
         }
 
         @Before

File: smalivm/src/test/java/org/cf/smalivm/opcode/SwitchPayloadOpTest.java
Patch:
@@ -52,7 +52,7 @@ public void payloadOpHasExpectedToString() {
 
             op = (SwitchPayloadOp) opFactory.create(location, addressToLocation, vm);
 
-            assertEquals("packed-switch-payload [1 -> #10, 2 -> #20]", op.toString());
+            assertEquals("packed-switch-payload [1 -> :addr_10, 2 -> :addr_20]", op.toString());
         }
 
         @Before

File: simplify/src/main/java/org/cf/simplify/ConstantBuilder.java
Patch:
@@ -194,7 +194,9 @@ public static BuilderInstruction buildConstant(int address, ExecutionGraphManipu
         OneRegisterInstruction instruction = (OneRegisterInstruction) manipulator.getInstruction(address);
         int register = instruction.getRegisterA();
         HeapItem item = manipulator.getRegisterConsensus(address, register);
-        BuilderInstruction constant = buildConstant(item.getValue(), item.getUnboxedType(), register, dexBuilder);
+        Object value = item.getValue();
+        String type = item.isPrimitive() ? item.getType() : item.getUnboxedValueType();
+        BuilderInstruction constant = buildConstant(value, type, register, dexBuilder);
 
         return constant;
     }

File: simplify/src/main/java/org/cf/simplify/strategy/ConstantPropagationStrategy.java
Patch:
@@ -94,7 +94,7 @@ private boolean canConstantizeAddress(int address) {
             return false;
         }
 
-        String type = consensus.getType();
+        String type = consensus.isPrimitive() ? consensus.getType() : consensus.getValueType();
         if (!constantBuilder.canConstantizeType(type)) {
             return false;
         }

File: smalivm/src/test/java/org/cf/smalivm/VMTester.java
Patch:
@@ -299,6 +299,7 @@ private static void testValueEquals(HeapItem expected, HeapItem consensus) {
             assertEquals(expectedValue.toString(), consensusValue.toString());
         } else {
             assertEquals(expectedValue, consensusValue);
+            assertEquals(expected.getType(), consensus.getType());
         }
     }
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/AGetOpTest.java
Patch:
@@ -129,7 +129,7 @@ public void canGetWide() {
     public void canGetWithShortIndex() {
         Short index = 0;
         initial.setRegisters(0, new int[] { 0x42 }, "[I", 1, index, "S");
-        expected.setRegisters(index.intValue(), 0x42, "S");
+        expected.setRegisters(index.intValue(), 0x42, "I", 1, Short.valueOf(index.shortValue()), "S");
 
         VMTester.test(CLASS_NAME, "get()V", initial, expected);
     }

File: smalivm/src/test/java/org/cf/smalivm/opcode/CheckCastOpTest.java
Patch:
@@ -55,7 +55,7 @@ public void canCastStringWithObjectTypeToString() {
     @Test
     public void canCastStringWithStringTypeToObject() {
         initial.setRegisters(0, "great maker", "Ljava/lang/String;");
-        expected = initial;
+        expected.setRegisters(0, "great maker", "Ljava/lang/Object;");
 
         VMTester.test(CLASS_NAME, "castToObject()V", initial, expected);
     }

File: smalivm/src/test/java/org/cf/smalivm/opcode/ConstOpTest.java
Patch:
@@ -29,8 +29,8 @@ public static class IntegrationTest {
         private VMState expected;
 
         @Test
-        public void canConst() throws NoSuchFieldException, SecurityException {
-            expected.setRegisters(0, 0x42424242, "D");
+        public void canConst() {
+            expected.setRegisters(0, 0x42424242, "I");
 
             VMTester.test(CLASS_NAME, "const()V", expected);
         }
@@ -92,7 +92,7 @@ public void canConstStringJumbo() {
 
         @Test
         public void canConstWide() {
-            expected.setRegisters(0, 0x4242424242424242L, "J");
+            expected.setRegisters(0, 0x4242424242424242L, "D");
 
             VMTester.test(CLASS_NAME, "constWide()V", expected);
         }

File: smalivm/src/test/java/org/cf/smalivm/opcode/SGetOpTest.java
Patch:
@@ -142,7 +142,7 @@ public void getStaticLong() {
 
     @Test
     public void getStaticLongLiteral() {
-        expected.setRegisters(0, 0xFFFFFFFFFL, "L");
+        expected.setRegisters(0, 0xFFFFFFFFFL, "J");
 
         VMTester.test(CLASS_NAME, "getStaticLongLiteral()V", initial, expected);
     }

File: smalivm/src/test/java/org/cf/smalivm/opcode/UnaryMathOpTest.java
Patch:
@@ -213,7 +213,7 @@ public void testNegInt() {
         public void testNegIntWithShort() {
             Short value = 0x42;
             initial.setRegisters(0, value, "S");
-            expected.setRegisters(0, -value, "S");
+            expected.setRegisters(0, -value, "I");
 
             VMTester.test(CLASS_NAME, "negInt()V", initial, expected);
         }
@@ -238,7 +238,7 @@ public void testNotInt() {
         public void testNotIntWithShort() {
             Short value = 0x42;
             initial.setRegisters(0, value, "S");
-            expected.setRegisters(0, ~value, "S");
+            expected.setRegisters(0, ~value, "I");
 
             VMTester.test(CLASS_NAME, "notInt()V", initial, expected);
         }

File: smalivm/src/main/java/org/cf/smalivm/MethodReflector.java
Patch:
@@ -54,7 +54,7 @@ public void reflect(MethodState mState) throws Exception {
 
         if (!method.returnsVoid()) {
             HeapItem returnItem;
-            if (returnValue != null) {
+            if (returnValue != null && !ClassNameUtils.isPrimitive(method.getReturnType())) {
                 returnItem = new HeapItem(returnValue, ClassNameUtils.toInternal(returnValue.getClass()));
             } else {
                 returnItem = new HeapItem(returnValue, method.getReturnType());

File: simplify/Obfuscated/app/src/main/java/org/cf/crypto/XORCrypt.java
Patch:
@@ -1,4 +1,4 @@
-package org.cf.obfuscated;
+package org.cf.crypto;
 
 public class XORCrypt {
 

File: smalivm/src/main/java/org/cf/smalivm/TemplateStateFactory.java
Patch:
@@ -6,8 +6,8 @@
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.type.UninitializedInstance;
 import org.cf.smalivm.type.VirtualField;
-import org.cf.smalivm.type.VirtualType;
 import org.cf.smalivm.type.VirtualMethod;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.util.Utils;
 
 import java.util.List;
@@ -25,7 +25,7 @@ public static MethodState forMethod(ExecutionContext context) {
 
         for (String type : parameterTypes) {
             HeapItem item;
-            if (parameterRegister == firstParameter && !method.isStatic()) {
+            if (parameterRegister == firstParameter && !method.isStatic() && method.getName().equals("<init>")) {
                 UninitializedInstance instance = new UninitializedInstance(method.getDefiningClass());
                 item = new HeapItem(instance, type);
             } else {

File: smalivm/src/main/java/org/cf/smalivm/opcode/APutOp.java
Patch:
@@ -75,7 +75,7 @@ private static boolean throwsArrayStoreException(HeapItem arrayItem, HeapItem va
         VirtualArray arrayType = (VirtualArray) classManager.getVirtualType(arrayItem.getType());
         VirtualType arrayComponentType = arrayType.getComponentType();
 
-        if (arrayComponentType.instanceOf(valueType)) {
+        if (valueType.instanceOf(arrayComponentType)) {
             return false;
         }
 

File: smalivm/src/main/java/org/cf/smalivm/type/ClassManager.java
Patch:
@@ -50,7 +50,6 @@ private ClassManager(DexBuilder dexBuilder, boolean internalOnly) {
 
     ClassManager(DexBuilder dexBuilder, File smaliPath) throws IOException {
         this(dexBuilder, false);
-        System.out.println("Creating class manager with this path: " + smaliPath.getAbsolutePath());
         cacheSmaliFiles(smaliFileFactory.getSmaliFiles(smaliPath));
     }
 

File: demoapp/src/main/java/org/cf/demoapp/java_io_PrintStream_println.java
Patch:
@@ -8,9 +8,9 @@
 import org.cf.smalivm.emulate.UnknownValuesMethod;
 import org.cf.smalivm.opcode.Op;
 
-class java_io_PrintStream_println extends MethodStateMethod implements UnknownValuesMethod {
+public class java_io_PrintStream_println extends MethodStateMethod implements UnknownValuesMethod {
 
-    java_io_PrintStream_println() {
+    public java_io_PrintStream_println() {
         super();
 
         // Writing bytes over any kind of IO affects state outside of the VM.

File: simplify/src/main/java/org/cf/simplify/Launcher.java
Patch:
@@ -110,7 +110,7 @@ private static void setLogLevel(SimplifyOptions bean) {
 
     private static void updateZip(File zip, File entry, String entryName) throws IOException {
         Map<String, String> env = new HashMap<>();
-        String uriPath = "jar:file:" + zip.getAbsolutePath();
+        String uriPath = "jar:" + zip.toURI().toString();
         URI uri = URI.create(uriPath);
         try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
             fs.provider().checkAccess(fs.getPath(entryName), AccessMode.READ);
@@ -182,7 +182,7 @@ private int executeClass(VirtualMachine vm, String className) {
                 System.out.println("Skipping method without implementation: " + method);
                 continue;
             }
-            
+
             boolean executeAgain;
             do {
                 System.out.println("Executing: " + method);

File: simplify/src/test/java/org/cf/simplify/LauncherTest.java
Patch:
@@ -26,11 +26,10 @@ public void runsWithoutMajorFailureWithSmaliFolder() throws IOException, Unhandl
     public void runsWithoutMajorFailureWithDexFile() throws IOException, UnhandledVirtualException {
         Launcher launcher = new Launcher(new VirtualMachineFactory());
         File outFile = File.createTempFile("simplify-test", ".tmp");
-        launcher.run(new String[] { "resources/test/obfuscated-example.zip", "-it", "WhiteNoise", "-o",
+        launcher.run(new String[] { "src/test/resources/obfuscated-example.zip", "-it", "WhiteNoise", "-o",
                                     outFile.getAbsolutePath() });
 
         assertTrue(outFile.exists());
         Files.delete(outFile.toPath());
     }
-
 }

File: smalivm/src/main/java/org/cf/smalivm/type/ClassManager.java
Patch:
@@ -50,6 +50,7 @@ private ClassManager(DexBuilder dexBuilder, boolean internalOnly) {
 
     ClassManager(DexBuilder dexBuilder, File smaliPath) throws IOException {
         this(dexBuilder, false);
+        System.out.println("Creating class manager with this path: " + smaliPath.getAbsolutePath());
         cacheSmaliFiles(smaliFileFactory.getSmaliFiles(smaliPath));
     }
 
@@ -179,6 +180,7 @@ private void parseClassIfNecessary(String className) {
         SmaliFile smaliFile = classNameToSmaliFile.get(className);
         if (smaliFile == null) {
             throw new RuntimeException("Can't find Smali file for " + className);
+
         }
 
         boolean isFramework = smaliFileFactory.isFrameworkClass(className);

File: smalivm/src/test/java/org/cf/smalivm/dex/ClassBuilderTest.java
Patch:
@@ -15,7 +15,7 @@
 
 public class ClassBuilderTest {
 
-    private static final String TEST_SMALI_PATH = "resources/test/smali/class_builder";
+    private static final String TEST_SMALI_PATH = VMTester.TEST_CLASS_PATH + "/class_builder";
 //    @Rule
 //    public final ExpectedException exception = ExpectedException.none();
     private ClassBuilder classBuilder;

File: smalivm/src/test/java/org/cf/smalivm/dex/SmaliParserTest.java
Patch:
@@ -1,5 +1,6 @@
 package org.cf.smalivm.dex;
 
+import org.cf.smalivm.VMTester;
 import org.jf.dexlib2.writer.builder.BuilderClassDef;
 import org.junit.Test;
 
@@ -9,11 +10,9 @@
 
 public class SmaliParserTest {
 
-    private static final String SMALI_PATH = "resources/test/smali/ops";
-
     @Test
     public void canParseSmaliDirectory() throws Exception {
-        List<BuilderClassDef> classDefs = SmaliParser.parse(SMALI_PATH);
+        List<BuilderClassDef> classDefs = SmaliParser.parse(VMTester.TEST_CLASS_PATH);
         assertTrue(classDefs.size() > 0);
     }
 }

File: smalivm/src/main/java/org/cf/smalivm/type/ClassManager.java
Patch:
@@ -50,6 +50,7 @@ private ClassManager(DexBuilder dexBuilder, boolean internalOnly) {
 
     ClassManager(DexBuilder dexBuilder, File smaliPath) throws IOException {
         this(dexBuilder, false);
+        System.out.println("Creating class manager with this path: " + smaliPath.getAbsolutePath());
         cacheSmaliFiles(smaliFileFactory.getSmaliFiles(smaliPath));
     }
 
@@ -179,6 +180,7 @@ private void parseClassIfNecessary(String className) {
         SmaliFile smaliFile = classNameToSmaliFile.get(className);
         if (smaliFile == null) {
             throw new RuntimeException("Can't find Smali file for " + className);
+
         }
 
         boolean isFramework = smaliFileFactory.isFrameworkClass(className);

File: smalivm/src/test/java/org/cf/smalivm/VMTester.java
Patch:
@@ -8,6 +8,7 @@
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
+import org.cf.smalivm.dex.CommonTypes;
 import org.cf.smalivm.dex.SmaliParser;
 import org.cf.smalivm.type.ClassManager;
 import org.cf.smalivm.type.ClassManagerFactory;
@@ -41,7 +42,7 @@
 
 public class VMTester {
 
-    private static final String TEST_CLASS_PATH = "src/test/resources/smali";
+    public static final String TEST_CLASS_PATH = "src/test/resources/smali";
 
     private static ClassManager classManager;
 
@@ -81,7 +82,7 @@ public static DexBuilder getDexBuilder() {
     public static void setRegisterMock(MethodState mState, int register, Object value, String type) {
         HeapItem item = mock(HeapItem.class);
         when(item.getValue()).thenReturn(value);
-        if ("I".equals(type) && value instanceof Number) {
+        if (CommonTypes.INTEGER.equals(type) && value instanceof Number) {
             when(item.asInteger()).thenReturn((Integer) value);
         } else if (value instanceof UnknownValue) {
             when(item.isUnknown()).thenReturn(true);

File: smalivm/src/test/java/org/cf/smalivm/dex/ClassBuilderTest.java
Patch:
@@ -15,7 +15,7 @@
 
 public class ClassBuilderTest {
 
-    private static final String TEST_SMALI_PATH = "resources/test/smali/class_builder";
+    private static final String TEST_SMALI_PATH = VMTester.TEST_CLASS_PATH + "/class_builder";
 //    @Rule
 //    public final ExpectedException exception = ExpectedException.none();
     private ClassBuilder classBuilder;

File: smalivm/src/test/java/org/cf/smalivm/dex/SmaliParserTest.java
Patch:
@@ -1,5 +1,6 @@
 package org.cf.smalivm.dex;
 
+import org.cf.smalivm.VMTester;
 import org.jf.dexlib2.writer.builder.BuilderClassDef;
 import org.junit.Test;
 
@@ -9,11 +10,9 @@
 
 public class SmaliParserTest {
 
-    private static final String SMALI_PATH = "resources/test/smali/ops";
-
     @Test
     public void canParseSmaliDirectory() throws Exception {
-        List<BuilderClassDef> classDefs = SmaliParser.parse(SMALI_PATH);
+        List<BuilderClassDef> classDefs = SmaliParser.parse(VMTester.TEST_CLASS_PATH);
         assertTrue(classDefs.size() > 0);
     }
 }

File: smalivm/src/test/java/org/cf/smalivm/opcode/APutOpTest.java
Patch:
@@ -268,7 +268,7 @@ public void unknownValueItemMakesArrayUnknownAndDoesNotClearExceptions() {
         assertTrue(exceptionClasses.contains(NullPointerException.class));
 
         HeapItem item = graph.getTerminatingRegisterConsensus(0);
-        assertEquals(CommonTypes.UNKNOWN, item.getType());
+        assertEquals(CommonTypes.OBJECT, item.getType());
         assertEquals(UnknownValue.class, item.getValue().getClass());
     }
 

File: smalivm/src/main/java/org/cf/smalivm/TemplateStateFactory.java
Patch:
@@ -5,9 +5,8 @@
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.type.UninitializedInstance;
-import org.cf.smalivm.type.VirtualClass;
 import org.cf.smalivm.type.VirtualField;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.smalivm.type.VirtualMethod;
 import org.cf.util.Utils;
 
@@ -39,7 +38,7 @@ public static MethodState forMethod(ExecutionContext context) {
         return mState;
     }
 
-    public static ClassState forClass(ExecutionContext context, VirtualGeneric virtualClass) {
+    public static ClassState forClass(ExecutionContext context, VirtualType virtualClass) {
         ClassState cState = new ClassState(virtualClass, context);
         for (VirtualField field : virtualClass.getFields()) {
             Object value = field.getInitialValue();

File: smalivm/src/main/java/org/cf/smalivm/VirtualMachine.java
Patch:
@@ -11,7 +11,7 @@
 import org.cf.smalivm.type.ClassManager;
 import org.cf.smalivm.type.VirtualClass;
 import org.cf.smalivm.type.VirtualField;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.smalivm.type.VirtualMethod;
 import org.cf.util.Utils;
 import org.slf4j.Logger;
@@ -152,7 +152,7 @@ public StaticFieldAccessor getStaticFieldAccessor() {
         return staticFieldAccessor;
     }
 
-    public boolean isSafe(VirtualGeneric virtualClass) {
+    public boolean isSafe(VirtualType virtualClass) {
         return getConfiguration().isSafe(virtualClass.toString());
     }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/APutOp.java
Patch:
@@ -7,7 +7,7 @@
 import org.cf.smalivm.dex.CommonTypes;
 import org.cf.smalivm.type.ClassManager;
 import org.cf.smalivm.type.VirtualArray;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.util.ClassNameUtils;
 import org.cf.util.Utils;
 import org.jf.dexlib2.builder.MethodLocation;
@@ -71,9 +71,9 @@ private static boolean isOverloadedPrimitiveType(String type) {
 
     private static boolean throwsArrayStoreException(HeapItem arrayItem, HeapItem valueItem,
                                                      ClassManager classManager) {
-        VirtualGeneric valueType = classManager.getVirtualType(valueItem.getType());
+        VirtualType valueType = classManager.getVirtualType(valueItem.getType());
         VirtualArray arrayType = (VirtualArray) classManager.getVirtualType(arrayItem.getType());
-        VirtualGeneric arrayComponentType = arrayType.getComponentType();
+        VirtualType arrayComponentType = arrayType.getComponentType();
 
         if (arrayComponentType.instanceOf(valueType)) {
             return false;

File: smalivm/src/main/java/org/cf/smalivm/opcode/CheckCastOpFactory.java
Patch:
@@ -3,7 +3,7 @@
 import gnu.trove.map.TIntObjectMap;
 
 import org.cf.smalivm.VirtualMachine;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.util.Utils;
 import org.jf.dexlib2.builder.MethodLocation;
 import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
@@ -17,7 +17,7 @@ public Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressT
         Instruction21c instr = (Instruction21c) location.getInstruction();
         int targetRegister = instr.getRegisterA();
         TypeReference reference = (TypeReference) instr.getReference();
-        VirtualGeneric referenceType = vm.getClassManager().getVirtualType(reference);
+        VirtualType referenceType = vm.getClassManager().getVirtualType(reference);
 
         return new CheckCastOp(location, child, targetRegister, referenceType, vm.getClassManager(), vm.getExceptionFactory());
     }

File: smalivm/src/main/java/org/cf/smalivm/opcode/InstanceOfOpFactory.java
Patch:
@@ -3,7 +3,7 @@
 import gnu.trove.map.TIntObjectMap;
 
 import org.cf.smalivm.VirtualMachine;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.util.Utils;
 import org.jf.dexlib2.builder.MethodLocation;
 import org.jf.dexlib2.iface.instruction.formats.Instruction22c;
@@ -18,7 +18,7 @@ public Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressT
         int destRegister = instr.getRegisterA();
         int arg1Register = instr.getRegisterB();
         TypeReference typeReference = (TypeReference) instr.getReference();
-        VirtualGeneric referenceType = vm.getClassManager().getVirtualType(typeReference);
+        VirtualType referenceType = vm.getClassManager().getVirtualType(typeReference);
 
         return new InstanceOfOp(location, child, destRegister, arg1Register, referenceType, vm);
     }

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOpFactory.java
Patch:
@@ -5,8 +5,7 @@
 import gnu.trove.map.TIntObjectMap;
 
 import org.cf.smalivm.VirtualMachine;
-import org.cf.smalivm.type.VirtualClass;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.smalivm.type.VirtualMethod;
 import org.cf.util.Utils;
 import org.jf.dexlib2.builder.MethodLocation;
@@ -81,7 +80,7 @@ public Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressT
         int[] registers = buildRegisters(location.getInstruction());
 
         String className = methodReference.getDefiningClass();
-        VirtualGeneric type = vm.getClassManager().getVirtualType(className);
+        VirtualType type = vm.getClassManager().getVirtualType(className);
         String methodSignature = ReferenceUtil.getMethodDescriptor(methodReference);
         String methodDescriptor = methodSignature.split("->")[1];
         VirtualMethod method = type.getMethod(methodDescriptor);

File: smalivm/src/main/java/org/cf/smalivm/type/InitializedInstance.java
Patch:
@@ -11,7 +11,7 @@ public class InitializedInstance extends Instance {
 
     private InstanceState iState;
 
-    public InitializedInstance(VirtualGeneric type) {
+    public InitializedInstance(VirtualType type) {
         super(type);
         iState = null;
     }

File: smalivm/src/main/java/org/cf/smalivm/type/Instance.java
Patch:
@@ -2,13 +2,13 @@
 
 public abstract class Instance {
 
-    private final VirtualGeneric type;
+    private final VirtualType type;
 
-    protected Instance(VirtualGeneric type) {
+    protected Instance(VirtualType type) {
         this.type = type;
     }
 
-    public VirtualGeneric getType() {
+    public VirtualType getType() {
         return type;
     }
 

File: smalivm/src/main/java/org/cf/smalivm/type/UninitializedInstance.java
Patch:
@@ -5,7 +5,7 @@
 
 public class UninitializedInstance extends Instance {
 
-    public UninitializedInstance(VirtualGeneric type) {
+    public UninitializedInstance(VirtualType type) {
         super(type);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/type/VirtualArrayMethod.java
Patch:
@@ -13,9 +13,9 @@
 public class VirtualArrayMethod extends VirtualMethod {
 
     private final Reference reference;
-    private final VirtualGeneric type;
+    private final VirtualType type;
 
-    VirtualArrayMethod(Reference reference, VirtualGeneric type) {
+    VirtualArrayMethod(Reference reference, VirtualType type) {
         super(reference, type);
         this.reference = reference;
         this.type = type;

File: smalivm/src/main/java/org/cf/smalivm/type/VirtualClassItem.java
Patch:
@@ -5,9 +5,9 @@
 public abstract class VirtualClassItem {
 
     private final Reference reference;
-    private final VirtualGeneric definingClass;
+    private final VirtualType definingClass;
 
-    protected VirtualClassItem(Reference reference, VirtualGeneric definingClass) {
+    protected VirtualClassItem(Reference reference, VirtualType definingClass) {
         this.reference = reference;
         this.definingClass = definingClass;
     }
@@ -20,7 +20,7 @@ public final String getClassName() {
         return getDefiningClass().getName();
     }
 
-    public VirtualGeneric getDefiningClass() {
+    public VirtualType getDefiningClass() {
         return definingClass;
     }
 

File: smalivm/src/main/java/org/cf/smalivm/type/VirtualMethod.java
Patch:
@@ -9,7 +9,7 @@
 
 public abstract class VirtualMethod extends VirtualClassItem {
 
-    VirtualMethod(Reference reference, VirtualGeneric type) {
+    VirtualMethod(Reference reference, VirtualType type) {
         super(reference, type);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/type/VirtualRealMethod.java
Patch:
@@ -15,7 +15,7 @@
 public class VirtualRealMethod extends VirtualMethod {
 
     private final BuilderMethod method;
-    private final VirtualGeneric type;
+    private final VirtualType type;
 
     VirtualRealMethod(BuilderMethod method, VirtualClass type) {
         super(method, type);

File: smalivm/src/test/java/org/cf/smalivm/emulate/java_lang_reflect_Field_get_Test.java
Patch:
@@ -8,7 +8,7 @@
 import org.cf.smalivm.type.UnknownValue;
 import org.cf.smalivm.type.VirtualClass;
 import org.cf.smalivm.type.VirtualField;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.cf.smalivm.type.VirtualMethod;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
@@ -72,7 +72,7 @@ private static void testNegativeCase(String fieldName, String callingMethodSigna
         Set<Throwable> exceptions = fieldGet.getExceptions();
         assertEquals("Should have one exception", 1, exceptions.size());
 
-        VirtualGeneric callingClass = context.getCallerContext().getMethod().getDefiningClass();
+        VirtualType callingClass = context.getCallerContext().getMethod().getDefiningClass();
         VirtualField field = context.getMethod().getDefiningClass().getField(fieldName);
         String error = callingClass.getBinaryName() + " can't access a member of " + DUMMY_CLASS_NAME_BINARY +
                        " with modifiers \"" + Modifier.toString(field.getField().getAccessFlags()) + "\"";

File: smalivm/src/test/java/org/cf/smalivm/opcode/NewInstanceOpTest.java
Patch:
@@ -5,7 +5,7 @@
 import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.ExecutionGraph;
 import org.cf.smalivm.type.UninitializedInstance;
-import org.cf.smalivm.type.VirtualGeneric;
+import org.cf.smalivm.type.VirtualType;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -23,7 +23,7 @@ public void canCreateLocalInstance() throws ClassNotFoundException {
         initial.setRegisters(0, 1, "I");
         ExecutionGraph graph = VMTester.execute(vm, CLASS_NAME, "newLocalInstance()V", initial);
 
-        VirtualGeneric instanceType = vm.getClassManager().getVirtualType(CLASS_NAME);
+        VirtualType instanceType = vm.getClassManager().getVirtualType(CLASS_NAME);
         expected.setRegisters(0, new UninitializedInstance(instanceType), CLASS_NAME);
         VMTester.testState(graph, expected);
     }
@@ -33,7 +33,7 @@ public void canCreateNonLocalInstance() {
         initial.setRegisters(0, 1, "I");
         ExecutionGraph graph = VMTester.execute(vm, CLASS_NAME, "newNonLocalInstance()V", initial);
 
-        VirtualGeneric instanceType = vm.getClassManager().getVirtualType("Ljava/lang/Integer;");
+        VirtualType instanceType = vm.getClassManager().getVirtualType("Ljava/lang/Integer;");
         expected.setRegisters(0, new UninitializedInstance(instanceType), "Ljava/lang/Integer;");
         VMTester.testState(graph, expected);
     }

File: smalivm/src/main/java/org/cf/smalivm/dex/SmaliClassLoader.java
Patch:
@@ -1,5 +1,6 @@
 package org.cf.smalivm.dex;
 
+import org.cf.smalivm.configuration.Configuration;
 import org.cf.smalivm.type.ClassManager;
 import org.cf.smalivm.type.ClassManagerFactory;
 import org.cf.smalivm.type.VirtualClass;
@@ -20,7 +21,7 @@ public class SmaliClassLoader extends ClassLoader {
 
     // This jar is produced by FrameworkJarBuilder so that framework classes don't have to be built with ASM
     // every time they're needed. Instead, they can be loaded from here.
-    private static final String FRAMEWORK_STUBS_JAR = "/framework/android-framework.jar";
+    public static final String FRAMEWORK_STUBS_JAR = "/framework/android-framework.jar";
 
     private final Map<String, Class<?>> cachedClasses;
     private final ClassBuilder classBuilder;
@@ -30,7 +31,7 @@ public class SmaliClassLoader extends ClassLoader {
     public SmaliClassLoader(ClassManager classManager) {
         super(SmaliClassLoader.class.getClassLoader());
         cachedClasses = new HashMap<>();
-        URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);
+        URL jarURL = SmaliClassLoader.class.getResource(SmaliClassLoader.FRAMEWORK_STUBS_JAR);
         jarLoader = new URLClassLoader(new URL[] { jarURL });
         this.classBuilder = new ClassBuilder(classManager);
         this.classManager = classManager;

File: smalivm/src/main/java/org/cf/smalivm/dex/SmaliFileFactory.java
Patch:
@@ -1,5 +1,6 @@
 package org.cf.smalivm.dex;
 
+import org.cf.smalivm.configuration.Configuration;
 import org.cf.smalivm.configuration.ConfigurationLoader;
 import org.cf.util.Utils;
 import org.slf4j.Logger;
@@ -38,8 +39,8 @@ private static synchronized void cacheFramework() {
     private static Map<String, SmaliFile> parseFramework() {
         Map<String, SmaliFile> frameworkFiles = new HashMap<>();
         // framework_classes.cfg is built by FrameworkCacheBuilder
-        List<String> frameworkClassesCfg = ConfigurationLoader.load("framework_classes.cfg");
-        Set<String> safeFrameworkClasses = new HashSet<>(ConfigurationLoader.load("safe_framework_classes.cfg"));
+        List<String> frameworkClassesCfg = ConfigurationLoader.load(Configuration.FRAMEWORK_CLASSES_PATH);
+        Set<String> safeFrameworkClasses = new HashSet<>(ConfigurationLoader.load(Configuration.SAFE_FRAMEWORK_CLASSES_PATH));
         for (String line : frameworkClassesCfg) {
             String[] parts = line.split(":");
             String className = parts[0];

File: smalivm/src/main/java/org/cf/smalivm/NodeExecutor.java
Patch:
@@ -86,7 +86,7 @@ public void execute(ExecutionNode node) throws UnhandledVirtualException {
             int childAddress = exceptionResolver.resolve(e, node.getAddress());
             if (childAddress <= 0) {
                 throw new RuntimeException("Real exception was thrown executing " + node +
-                                           " and was not handled. This could be a bug in smalivm.\nException: " + e, e);
+                                           " and was not handled. This could be a bug in smalivm.\nException: " + e);
             } else {
                 if (log.isWarnEnabled()) {
                     log.warn("{} threw a real exception but was caught by an exception handler. " +

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionContext.java
Patch:
@@ -168,6 +168,7 @@ public void staticallyInitializeClassIfNecessary(VirtualClass virtualClass) {
          * that are both static and final, and are initialized by a compile-time constant expression.
          */
         if (vm.isSafe(virtualClass) || isClassInitialized(virtualClass)) {
+            // Safe classes are OK to reflect to get fields. Don't need to also put them in VM.
             return;
         }
 

File: simplify/src/main/java/org/cf/simplify/strategy/ConstantPropagationStrategy.java
Patch:
@@ -35,7 +35,7 @@ public ConstantPropagationStrategy(ExecutionGraphManipulator manipulator) {
 
     @Override
     public Map<String, Integer> getOptimizationCounts() {
-        Map<String, Integer> counts = new HashMap<String, Integer>();
+        Map<String, Integer> counts = new HashMap<>();
         counts.put("constantized ops", constantCount);
 
         return counts;
@@ -103,7 +103,7 @@ private boolean canConstantizeAddress(int address) {
     }
 
     private List<Integer> getValidAddresses() {
-        return IntStream.of(manipulator.getAddresses()).boxed().filter(a -> canConstantizeAddress(a))
+        return IntStream.of(manipulator.getAddresses()).boxed().filter(this::canConstantizeAddress)
                        .collect(Collectors.toList());
     }
 

File: smalivm/src/main/java/org/cf/smalivm/ExceptionHandlerAddressResolver.java
Patch:
@@ -30,7 +30,7 @@ public class ExceptionHandlerAddressResolver {
      * parent, and so on. If catchAll is true, it'll look for catch-all exception handlers.
      */
     private int findHandlerCodeAddress(VirtualClass exceptionClass, int address, boolean catchAll) {
-        List<VirtualClass> lineage = new LinkedList<VirtualClass>();
+        List<VirtualClass> lineage = new LinkedList<>();
         lineage.add(exceptionClass);
         lineage.addAll(exceptionClass.getAncestors());
 

File: smalivm/src/main/java/org/cf/smalivm/MethodExecutor.java
Patch:
@@ -51,7 +51,7 @@ ExecutionGraph execute(ExecutionGraph graph) throws VirtualMachineException {
         }
 
         NodeExecutor nodeExecutor = new NodeExecutor(graph, classManager);
-        Deque<ExecutionNode> stack = new ArrayDeque<ExecutionNode>();
+        Deque<ExecutionNode> stack = new ArrayDeque<>();
         stack.push(node);
         long endTime = System.currentTimeMillis() + (maxExecutionTime * 1000);
         boolean warnedMultipleExecutionPaths = false;

File: smalivm/src/main/java/org/cf/smalivm/TemplateStateFactory.java
Patch:
@@ -24,7 +24,7 @@ public static MethodState forMethod(ExecutionContext context) {
         int parameterRegister = firstParameter;
 
         for (String type : parameterTypes) {
-            HeapItem item = null;
+            HeapItem item;
             if (parameterRegister == 0 && !method.isStatic()) {
                 UninitializedInstance instance = new UninitializedInstance(method.getDefiningClass());
                 item = new HeapItem(instance, type);

File: smalivm/src/main/java/org/cf/smalivm/VirtualMachine.java
Patch:
@@ -40,7 +40,7 @@ public class VirtualMachine {
         classLoader = new SmaliClassLoader(classManager);
         methodExecutor =
                 new MethodExecutor(classManager, maxCallDepth, maxAddressVisits, maxMethodVisits, maxExecutionTime);
-        methodToTemplateExecutionGraph = new HashMap<VirtualMethod, ExecutionGraph>();
+        methodToTemplateExecutionGraph = new HashMap<>();
         staticFieldAccessor = new StaticFieldAccessor(this);
         configuration = Configuration.instance();
         exceptionFactory = new ExceptionFactory(this);

File: smalivm/src/main/java/org/cf/smalivm/configuration/ConfigurationLoader.java
Patch:
@@ -13,7 +13,7 @@ public class ConfigurationLoader {
 
     public static List<String> load(String path) {
         URL url = Resources.getResource(path);
-        List<String> lines = new LinkedList<String>();
+        List<String> lines = new LinkedList<>();
         try {
             lines = Resources.readLines(url, Charsets.UTF_8);
         } catch (IOException e) {

File: smalivm/src/main/java/org/cf/smalivm/context/CallStack.java
Patch:
@@ -12,7 +12,7 @@ public class CallStack {
     private TIntList addressStack;
 
     CallStack() {
-        methodStack = new LinkedList<String>();
+        methodStack = new LinkedList<>();
         addressStack = new TIntLinkedList();
     }
 
@@ -22,7 +22,7 @@ public class CallStack {
     }
 
     CallStack(CallStack callerStack) {
-        this.methodStack = new LinkedList<String>(callerStack.methodStack);
+        this.methodStack = new LinkedList<>(callerStack.methodStack);
         this.addressStack = new TIntLinkedList(callerStack.addressStack);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/context/ClassState.java
Patch:
@@ -19,8 +19,8 @@ public ClassState(VirtualClass virtualClass, ExecutionContext context) {
         this.virtualClass = virtualClass;
     }
 
-    private ClassState(ClassState parent, ExecutionContext ectx) {
-        this(parent.virtualClass, ectx);
+    private ClassState(ClassState parent, ExecutionContext context) {
+        this(parent.virtualClass, context);
     }
 
     public void assignField(VirtualField field, Object value) {

File: smalivm/src/main/java/org/cf/smalivm/context/ClonerFactory.java
Patch:
@@ -17,7 +17,7 @@ public class ClonerFactory {
 
     private static final Logger log = LoggerFactory.getLogger(ClonerFactory.class.getSimpleName());
 
-    private static final Map<ClassManager, Cloner> cache = new WeakHashMap<ClassManager, Cloner>();
+    private static final Map<ClassManager, Cloner> cache = new WeakHashMap<>();
 
     /**
      * This builds a fresh cloner. This is necessary because Cloner does some caching of classes which is a problem

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionContext.java
Patch:
@@ -44,7 +44,7 @@ public ExecutionContext(VirtualMachine vm, VirtualMethod method) {
          * Since there's an ExecutionContext for each execution of each op and these maps are only populated when
          * they're needed (by pulling from ancestors), so be frugal with size.
          */
-        classToStatus = new HashMap<VirtualClass, ClassStatus>(0);
+        classToStatus = new HashMap<>(0);
     }
 
     public int getCallDepth() {

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGraphIterator.java
Patch:
@@ -9,7 +9,7 @@ class ExecutionGraphIterator implements Iterator<ExecutionNode> {
     private final Deque<ExecutionNode> stack;
 
     ExecutionGraphIterator(ExecutionGraph graph) {
-        stack = new ArrayDeque<ExecutionNode>();
+        stack = new ArrayDeque<>();
         ExecutionNode rootNode = graph.getRoot();
 
         if (rootNode != null) {

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGrapher.java
Patch:
@@ -10,7 +10,7 @@ public class ExecutionGrapher {
     public static String graph(ExecutionGraph graph) {
         ExecutionNode node = graph.getRoot();
         StringBuilder sb = new StringBuilder("digraph {\n");
-        getGraph(node, graph, sb, new ArrayList<ExecutionNode>());
+        getGraph(node, graph, sb, new ArrayList<>());
         sb.append("labelloc=\"t\"\n");
         sb.append("label=\"").append(graph.getMethod()).append("\";\n");
         sb.append('}');

File: smalivm/src/main/java/org/cf/smalivm/context/Heap.java
Patch:
@@ -19,7 +19,7 @@ class Heap {
     private Heap parent;
 
     Heap(Cloner cloner) {
-        keyToHeapItem = new HashMap<String, HeapItem>();
+        keyToHeapItem = new HashMap<>();
         this.cloner = cloner;
     }
 
@@ -166,7 +166,7 @@ private void set(String key, HeapItem item) {
 
     private static Set<String> getReassignedKeysBetweenChildAndAncestor(Heap child, Heap ancestor) {
         Heap current = child;
-        Set<String> reassigned = new HashSet<String>();
+        Set<String> reassigned = new HashSet<>();
         while (current != ancestor) {
             reassigned.addAll(current.keySet());
             current = current.getParent();

File: smalivm/src/main/java/org/cf/smalivm/dex/Dexifier.java
Patch:
@@ -39,7 +39,7 @@ public static List<BuilderClassDef> dexifySmaliFiles(File file, DexBuilder dexBu
         if (file.isDirectory()) {
             smaliFiles = Utils.getFilesWithSmaliExtension(file);
         } else {
-            smaliFiles = new ArrayList<File>();
+            smaliFiles = new ArrayList<>();
             smaliFiles.add(file);
         }
 
@@ -48,7 +48,7 @@ public static List<BuilderClassDef> dexifySmaliFiles(File file, DexBuilder dexBu
 
     public static List<BuilderClassDef> dexifySmaliFiles(List<File> smaliFiles, DexBuilder dexBuilder) throws
             Exception {
-        List<BuilderClassDef> result = new ArrayList<BuilderClassDef>();
+        List<BuilderClassDef> result = new ArrayList<>();
         for (File smaliFile : smaliFiles) {
             result.add(dexifySmaliFile(smaliFile, dexBuilder));
         }

File: smalivm/src/main/java/org/cf/smalivm/dex/FrameworkCacheBuilder.java
Patch:
@@ -42,7 +42,7 @@ public static String buildFrameworkCache() throws Exception {
     }
 
     public static String buildFrameworkCache(String resPath) throws Exception {
-        List<File> resFiles = new LinkedList<File>();
+        List<File> resFiles = new LinkedList<>();
         try {
             URL url = FrameworkCacheBuilder.class.getResource(resPath);
             File file = new File(url.toURI());

File: smalivm/src/main/java/org/cf/smalivm/emulate/MethodEmulator.java
Patch:
@@ -14,8 +14,7 @@
 public class MethodEmulator {
 
     private static final Logger log = LoggerFactory.getLogger(MethodEmulator.class.getSimpleName());
-    private static Map<String, Class<? extends EmulatedMethod>> emulatedMethods =
-            new HashMap<String, Class<? extends EmulatedMethod>>();
+    private static Map<String, Class<? extends EmulatedMethod>> emulatedMethods = new HashMap<>();
     static {
         addMethod("Lorg/cf/simplify/Utils;->breakpoint()V", org_cf_simplify_Utils_breakpoint.class);
         addMethod("Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;", java_lang_Class_forName.class);

File: smalivm/src/main/java/org/cf/smalivm/emulate/java_lang_Class_forName.java
Patch:
@@ -23,7 +23,7 @@ public void execute(VirtualMachine vm, Op op, ExecutionContext context) {
         String binaryClassName = (String) mState.peekParameter(0).getValue();
         String className = ClassNameUtils.binaryToInternal(binaryClassName);
 
-        Class<?> value = null;
+        Class<?> value;
         try {
             if (vm.getConfiguration().isSafe(className)) {
                 value = Class.forName(binaryClassName);
@@ -36,7 +36,7 @@ public void execute(VirtualMachine vm, Op op, ExecutionContext context) {
                  * is loaded and only the local values are used.
                  * Note: this is done *after* trying to load the class in case there's an exception
                  */
-                VirtualClass virtualClass = null;
+                VirtualClass virtualClass;
                 try {
                     virtualClass = vm.getClassManager().getVirtualClass(className);
                 } catch (RuntimeException e) {

File: smalivm/src/main/java/org/cf/smalivm/opcode/ConstOp.java
Patch:
@@ -81,7 +81,7 @@ public String toString() {
     }
 
     private Object buildConstant() {
-        Object constant = null;
+        Object constant;
         if (ConstantType.CLASS == constantType) {
             String className = (String) literal;
             try {

File: smalivm/src/main/java/org/cf/smalivm/opcode/IfOp.java
Patch:
@@ -24,6 +24,7 @@ public class IfOp extends MethodStateOp {
         this.register1 = register1;
         compareToZero = true;
     }
+
     IfOp(MethodLocation location, MethodLocation child, IfType ifType, MethodLocation target, int register1,
          int register2) {
         this(location, child, ifType, target, register1);
@@ -69,7 +70,7 @@ public void execute(ExecutionNode node, MethodState mState) {
 
         Object lhs = lhsItem.getValue();
         Object rhs = rhsItem.getValue();
-        int cmp = Integer.MIN_VALUE;
+        int cmp;
         if (compareToZero) {
             if (lhs == null) {
                 // if-*z ops are used to check for null refs

File: smalivm/src/main/java/org/cf/smalivm/opcode/Op.java
Patch:
@@ -20,7 +20,7 @@ public abstract class Op {
     Op(MethodLocation location, MethodLocation[] children) {
         this.location = location;
         this.children = children;
-        exceptions = new HashSet<Throwable>();
+        exceptions = new HashSet<>();
     }
 
     public final int getAddress() {

File: smalivm/src/main/java/org/cf/smalivm/opcode/SPutOpFactory.java
Patch:
@@ -6,7 +6,6 @@
 import org.cf.smalivm.type.VirtualClass;
 import org.cf.smalivm.type.VirtualField;
 import org.cf.util.Utils;
-import org.jf.dexlib2.builder.BuilderInstruction;
 import org.jf.dexlib2.builder.MethodLocation;
 import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
 import org.jf.dexlib2.iface.reference.FieldReference;

File: smalivm/src/main/java/org/cf/smalivm/opcode/SwitchPayloadOp.java
Patch:
@@ -78,9 +78,9 @@ public String toString() {
 
     private List<MethodLocation> getTargets(int branchFromAddress, TIntIntMap targetKeyToOffset) {
         int[] offsets = targetKeyToOffset.values();
-        List<MethodLocation> targets = new LinkedList<MethodLocation>();
-        for (int i = 0; i < offsets.length; i++) {
-            int targetOffset = branchFromAddress + offsets[i];
+        List<MethodLocation> targets = new LinkedList<>();
+        for (int offset : offsets) {
+            int targetOffset = branchFromAddress + offset;
             targets.add(addressToLocation.get(targetOffset));
         }
 

File: smalivm/src/main/java/org/cf/smalivm/type/VirtualArray.java
Patch:
@@ -34,7 +34,7 @@ public Set<? extends VirtualGeneric> getAncestors() {
         if (ancestors != null) {
             return ancestors;
         }
-        ancestors = new LinkedHashSet<VirtualGeneric>();
+        ancestors = new LinkedHashSet<>();
 
         TypeReference typeReference = getTypeReference();
         String baseType = ClassNameUtils.getComponentBase(typeReference.getType());

File: smalivm/src/main/java/org/cf/smalivm/type/VirtualMethod.java
Patch:
@@ -84,7 +84,7 @@ public final String getReturnType() {
     public List<BuilderTryBlock> getTryBlocks() {
         MutableMethodImplementation implementation = (MutableMethodImplementation) method.getImplementation();
         if (implementation == null) {
-            return new LinkedList<BuilderTryBlock>();
+            return new LinkedList<>();
         }
 
         return implementation.getTryBlocks();

File: smalivm/src/main/java/org/cf/smalivm/type/VirtualPrimitive.java
Patch:
@@ -17,7 +17,7 @@ public class VirtualPrimitive extends VirtualGeneric {
 
     @Override
     public Set<VirtualPrimitive> getAncestors() {
-        return new HashSet<VirtualPrimitive>(0);
+        return new HashSet<>(0);
     }
 
     @Override

File: smalivm/src/main/java/org/cf/util/ClassNameUtils.java
Patch:
@@ -29,7 +29,7 @@ public class ClassNameUtils {
         internalPrimitiveToWrapper.put("C", Character.class.getName());
         internalPrimitiveToWrapper.put("V", Void.class.getName());
 
-        internalPrimitiveToClass = new HashMap<String, Class<?>>(8);
+        internalPrimitiveToClass = new HashMap<>(8);
         internalPrimitiveToClass.put("I", int.class);
         internalPrimitiveToClass.put("S", short.class);
         internalPrimitiveToClass.put("J", long.class);
@@ -52,7 +52,7 @@ public class ClassNameUtils {
         // Note: Void is not technically a primitive.
         internalPrimitiveToBinaryName.put("V", void.class.getName());
 
-        binaryNameToType = new HashMap<String, Class<?>>(9);
+        binaryNameToType = new HashMap<>(9);
         binaryNameToType.put("int", Integer.TYPE);
         binaryNameToType.put("short", Short.TYPE);
         binaryNameToType.put("long", Long.TYPE);
@@ -423,7 +423,7 @@ public static String toInternal(Class<?> klazz) {
      * @return list of internal format class names in the same order as arguments
      */
     public static List<String> toInternal(Class<?>... classes) {
-        List<String> names = new LinkedList<String>();
+        List<String> names = new LinkedList<>();
         for (Class<?> klazz : classes) {
             names.add(toInternal(klazz));
         }

File: simplify/src/test/java/org/cf/simplify/strategy/UnreflectionStrategyTest.java
Patch:
@@ -183,7 +183,7 @@ public void testUnknownMethodIsNotOptimized() {
         }
 
         @Test
-        public void testUnknownParametersOfPubilcMethodIsNotOptimized() {
+        public void testUnknownParametersOfPublccMethodIsNotOptimized() {
             ExecutionGraphManipulator manipulator =
                     getOptimizedGraph(METHOD_WITH_3_LOCALS_AND_0_AVAILABLE, 0, METHOD, METHOD_TYPE, 1, 0, "I", 2,
                             new UnknownValue(), "[Ljava/lang/Object;");

File: smalivm/src/main/java/org/cf/smalivm/opcode/Op.java
Patch:
@@ -4,8 +4,6 @@
 import java.util.Set;
 
 import org.cf.smalivm.SideEffect;
-import org.cf.smalivm.VirtualException;
-import org.cf.smalivm.VirtualMachine;
 import org.jf.dexlib2.builder.BuilderInstruction;
 import org.jf.dexlib2.builder.MethodLocation;
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/MoveOpTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.cf.smalivm.VMState;
 import org.cf.smalivm.VMTester;
-import org.cf.smalivm.VirtualException;
 import org.cf.smalivm.context.ExecutionGraph;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
@@ -23,7 +22,7 @@ public class MoveOpTest {
 
     @Test
     public void canMoveException() {
-        VirtualException exception = new VirtualException("Ljava/lang/Exception;");
+        String exception = "any object would do";
         initial.setRegisters(MethodState.ExceptionRegister, exception, "Ljava/lang/Exception;");
         expected.setRegisters(0, exception, "Ljava/lang/Exception;");
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/ThrowOpTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.cf.smalivm.VMState;
 import org.cf.smalivm.VMTester;
-import org.cf.smalivm.VirtualException;
 import org.cf.smalivm.context.ExecutionGraph;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;

File: smalivm/src/test/java/org/cf/smalivm/opcode/InvokeOpTest.java
Patch:
@@ -449,11 +449,11 @@ public void setUp() {
 
             classManager = mock(ClassManager.class);
             when(vm.getClassManager()).thenReturn(classManager);
-            when(classManager.isFrameworkClass(METHOD_SIGNATURE)).thenReturn(false);
-            when(classManager.isSafeFrameworkClass(METHOD_SIGNATURE)).thenReturn(false);
 
             VirtualClass methodClass = mock(VirtualClass.class);
             when(classManager.getVirtualClass(eq(METHOD_CLASS))).thenReturn(methodClass);
+            when(classManager.isFrameworkClass(methodClass)).thenReturn(false);
+            when(classManager.isSafeFrameworkClass(methodClass)).thenReturn(false);
 
             VirtualMethod method = mock(VirtualMethod.class);
             when(method.getName()).thenReturn(METHOD_SIGNATURE);

File: demoapp/src/main/java/org/cf/demoapp/java_io_PrintStream_println.java
Patch:
@@ -24,14 +24,15 @@ public void execute(VirtualMachine vm, MethodState mState) {
         System.out.println(valueStr);
     }
 
+    @Override
     public SideEffect.Level getSideEffectLevel() {
         // Do not optimize this away.
         return SideEffect.Level.STRONG;
     }
 
     @Override
     public Set<VirtualException> getExceptions() {
-        return new HashSet<VirtualException>();
+        return new HashSet<>();
     }
 
 }

File: demoapp/src/main/java/org/cf/demosmali/TestExceptionHandling.java
Patch:
@@ -11,7 +11,7 @@ public static void main(String... argv) {
     }
 
     public void testCasting() {
-        Object o = Integer.valueOf(5);
+        Object o = 5;
         int x = (int) o;
         System.out.println(x);
     }

File: simplify/src/main/java/org/cf/simplify/ConstantBuilder.java
Patch:
@@ -29,7 +29,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class ConstantBuilder implements Dependancy {
+public class ConstantBuilder implements Dependency {
 
     @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(ConstantBuilder.class.getSimpleName());

File: simplify/src/main/java/org/cf/simplify/Launcher.java
Patch:
@@ -84,7 +84,7 @@ public void run(String[] args) throws IOException, UnhandledVirtualException {
         }
     }
 
-    private int executeClass(VirtualMachine vm, String className) throws UnhandledVirtualException {
+    private int executeClass(VirtualMachine vm, String className) {
         ClassManager classManager = vm.getClassManager();
         DexBuilder dexBuilder = classManager.getDexBuilder();
         Collection<VirtualMethod> methods = classManager.getVirtualClass(className).getMethods();

File: simplify/src/main/java/org/cf/simplify/Optimizer.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 
-import org.cf.simplify.strategy.ConstantPropigationStrategy;
+import org.cf.simplify.strategy.ConstantPropagationStrategy;
 import org.cf.simplify.strategy.DeadRemovalStrategy;
 import org.cf.simplify.strategy.OptimizationStrategy;
 import org.cf.simplify.strategy.PeepholeStrategy;
@@ -45,7 +45,7 @@ public Optimizer(ExecutionGraph graph, VirtualMethod method, VirtualMachine vm,
         DeadRemovalStrategy strategy = new DeadRemovalStrategy(manipulator);
         strategy.setRemoveWeak(opts.isRemoveWeak());
         reoptimizeStrategies.add(strategy);
-        reoptimizeStrategies.add(new ConstantPropigationStrategy(manipulator));
+        reoptimizeStrategies.add(new ConstantPropagationStrategy(manipulator));
         reoptimizeStrategies.add(new PeepholeStrategy(manipulator));
 
         /*

File: simplify/src/main/java/org/cf/simplify/strategy/OptimizationStrategy.java
Patch:
@@ -4,8 +4,8 @@
 
 public interface OptimizationStrategy {
 
-    public Map<String, Integer> getOptimizationCounts();
+    Map<String, Integer> getOptimizationCounts();
 
-    public boolean perform();
+    boolean perform();
 
 }

File: smalivm/src/main/java/org/cf/smalivm/SideEffect.java
Patch:
@@ -2,7 +2,7 @@
 
 public class SideEffect {
 
-    public static enum Level {
+    public enum Level {
         NONE(0), // reflected, emulated, white listed, or otherwise safe
         WEAK(1), // not white listed, unknown
         STRONG(2), // member variable modification

File: smalivm/src/main/java/org/cf/smalivm/context/ClassState.java
Patch:
@@ -13,8 +13,8 @@ public class ClassState extends BaseState {
 
     private final VirtualClass virtualClass;
 
-    public ClassState(VirtualClass virtualClass, ExecutionContext ectx) {
-        super(ectx, virtualClass.getFields().size());
+    public ClassState(VirtualClass virtualClass, ExecutionContext context) {
+        super(context, virtualClass.getFields().size());
 
         this.virtualClass = virtualClass;
     }

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGraph.java
Patch:
@@ -205,8 +205,8 @@ public Set<HeapItem> getFieldItems(int address, VirtualField field) {
         List<ExecutionNode> nodePile = getNodePile(address);
         Set<HeapItem> items = new HashSet<HeapItem>(nodePile.size());
         for (ExecutionNode node : nodePile) {
-            ExecutionContext ectx = node.getContext();
-            ClassState cState = ectx.peekClassState(field.getDefiningClass());
+            ExecutionContext context = node.getContext();
+            ClassState cState = context.peekClassState(field.getDefiningClass());
             HeapItem item = cState.peekField(field);
             items.add(item);
         }

File: smalivm/src/main/java/org/cf/smalivm/context/Heap.java
Patch:
@@ -152,7 +152,7 @@ private Heap getAncestorWithKey(String key) {
     }
 
     private Set<String> keySet() {
-        // Note: mutating this directly alters keytoHeapItem's keys
+        // Note: mutating this directly alters keyToHeapItem's keys
         return keyToHeapItem.keySet();
     }
 

File: smalivm/src/main/java/org/cf/smalivm/context/HeapItem.java
Patch:
@@ -18,14 +18,15 @@
 public class HeapItem {
 
     // private static final Cloner cloner = new Cloner();
-    private final Cloner cloner = new Cloner(new ObjenesisInstantiationStrategy());
+    private static final Cloner cloner = new Cloner(new ObjenesisInstantiationStrategy());
+    //private final Cloner cloner = new Cloner(new ObjenesisInstantiationStrategy());
 
     private String type;
     private Object value;
 
     public HeapItem(Object value, String type) {
         this.value = value;
-        this.type = type;
+        this.type = type.intern();
     }
 
     HeapItem(HeapItem other) {

File: smalivm/src/main/java/org/cf/smalivm/context/InstanceState.java
Patch:
@@ -2,8 +2,8 @@
 
 public class InstanceState extends BaseState {
 
-    InstanceState(ExecutionContext ectx) {
-        super(ectx);
+    InstanceState(ExecutionContext context) {
+        super(context);
     }
 
 }

File: smalivm/src/main/java/org/cf/smalivm/context/MethodState.java
Patch:
@@ -76,7 +76,7 @@ public void assignRegister(int register, Object value, String type) {
      * stored in the target register with the new value.
      */
     public void assignRegisterAndUpdateIdentities(int register, HeapItem item) {
-        super.assignRegisterAndUpdateIdentities(register, item, METHOD_HEAP);
+        assignRegisterAndUpdateIdentities(register, item, METHOD_HEAP);
     }
 
     public void assignResultRegister(HeapItem item) {
@@ -140,7 +140,7 @@ public HeapItem peekRegister(int register) {
     }
 
     public void pokeRegister(int register, HeapItem item) {
-        super.pokeRegister(register, item, METHOD_HEAP);
+        pokeRegister(register, item, METHOD_HEAP);
     }
 
     public void pokeRegister(int register, Object value, String type) {

File: smalivm/src/main/java/org/cf/smalivm/context/StackTraceBuilder.java
Patch:
@@ -4,8 +4,8 @@
 
 public class StackTraceBuilder {
 
-    static StackTraceElement[] buildCallStack(VirtualMachine vm, ExecutionContext ectx) {
-        // List<String> callStackList = ectx.getCallStack();
+    static StackTraceElement[] buildCallStack(VirtualMachine vm, ExecutionContext context) {
+        // List<String> callStackList = context.getCallStack();
 
         // For each MD in list
         // Get filename for class

File: smalivm/src/main/java/org/cf/smalivm/dex/ClassBuilder.java
Patch:
@@ -138,7 +138,7 @@ private void visitMethod(ClassDef classDef, Method method, MethodVisitor mv) {
         } else if (method.getName().equals("<init>")) {
             visitInitStub(classDef, mv);
         } else {
-            visitMethodStub(method, mv);
+            visitMethodStub(mv);
         }
         // Do this at the end so ASM can calculate max stack and locals sizes
         mv.visitMaxs(0, 0);
@@ -268,7 +268,7 @@ private void visitMethods(ClassDef classDef, Iterable<? extends Method> methods,
         }
     }
 
-    private void visitMethodStub(Method method, MethodVisitor mv) {
+    private void visitMethodStub(MethodVisitor mv) {
         mv.visitTypeInsn(Opcodes.NEW, "java/lang/RuntimeException");
         mv.visitInsn(Opcodes.DUP);
         mv.visitLdcInsn("Stub!");

File: smalivm/src/main/java/org/cf/smalivm/dex/SmaliFile.java
Patch:
@@ -76,7 +76,7 @@ public boolean isSafeFrameworkClass() {
         return isSafeFramework;
     }
 
-    public InputStream open() throws URISyntaxException, IOException {
+    public InputStream open() throws IOException {
         if (isResource) {
             return SmaliFile.class.getClassLoader().getResourceAsStream(getPath());
         } else {

File: smalivm/src/main/java/org/cf/smalivm/emulate/EmulatedMethod.java
Patch:
@@ -7,8 +7,8 @@
 
 public interface EmulatedMethod {
 
-    public Level getSideEffectLevel();
+    Level getSideEffectLevel();
 
-    public Set<VirtualException> getExceptions();
+    Set<VirtualException> getExceptions();
 
 }

File: smalivm/src/main/java/org/cf/smalivm/emulate/ExecutionContextMethod.java
Patch:
@@ -5,6 +5,6 @@
 
 public interface ExecutionContextMethod extends EmulatedMethod {
 
-    public void execute(VirtualMachine vm, ExecutionContext ectx) throws Exception;
+    void execute(VirtualMachine vm, ExecutionContext context);
 
 }

File: smalivm/src/main/java/org/cf/smalivm/emulate/MethodStateMethod.java
Patch:
@@ -5,6 +5,6 @@
 
 public interface MethodStateMethod extends EmulatedMethod {
 
-    public void execute(VirtualMachine vm, MethodState mState) throws Exception;
+    void execute(VirtualMachine vm, MethodState mState);
 
 }

File: smalivm/src/main/java/org/cf/smalivm/opcode/ExecutionContextOp.java
Patch:
@@ -14,6 +14,6 @@ public abstract class ExecutionContextOp extends Op {
         super(location, children);
     }
 
-    public abstract void execute(ExecutionNode executionNode, ExecutionContext ectx);
+    public abstract void execute(ExecutionNode executionNode, ExecutionContext context);
 
 }

File: smalivm/src/main/java/org/cf/smalivm/opcode/FillArrayDataPayloadOp.java
Patch:
@@ -24,7 +24,7 @@ private static Object getProperValue(Number number, Class<?> expectedClass) {
         if (klazz == byte.class) {
             value = number.byteValue();
             if (expectedClass == boolean.class) {
-                value = (byte) value == 1 ? true : false;
+                value = (byte) value == 1;
             }
         } else if (klazz == short.class) {
             value = number.shortValue();

File: smalivm/src/main/java/org/cf/smalivm/opcode/IPutOp.java
Patch:
@@ -31,8 +31,8 @@ public class IPutOp extends ExecutionContextOp {
     }
 
     @Override
-    public void execute(ExecutionNode node, ExecutionContext ectx) {
-        MethodState mState = ectx.getMethodState();
+    public void execute(ExecutionNode node, ExecutionContext context) {
+        MethodState mState = context.getMethodState();
         HeapItem valueItem = mState.readRegister(valueRegister);
         HeapItem instanceItem = mState.readRegister(instanceRegister);
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/IfOpFactory.java
Patch:
@@ -26,7 +26,7 @@ private static IfType getIfType(String opName) {
         } else if (opName.contains("-gt")) {
             result = IfType.GREATER;
         } else if (opName.contains("-ge")) {
-            result = IfType.GREATOR_OR_EQUAL;
+            result = IfType.GREATER_OR_EQUAL;
         }
 
         return result;

File: smalivm/src/main/java/org/cf/smalivm/opcode/OpFactory.java
Patch:
@@ -7,6 +7,6 @@
 
 public interface OpFactory {
 
-    public Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressToLocation, VirtualMachine vm);
+    Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressToLocation, VirtualMachine vm);
 
 }

File: smalivm/src/main/java/org/cf/smalivm/opcode/SGetOp.java
Patch:
@@ -34,16 +34,16 @@ public class SGetOp extends ExecutionContextOp {
     }
 
     @Override
-    public void execute(ExecutionNode node, ExecutionContext ectx) {
+    public void execute(ExecutionNode node, ExecutionContext context) {
         StaticFieldAccessor accessor = vm.getStaticFieldAccessor();
-        HeapItem item = accessor.getField(ectx, actualField);
+        HeapItem item = accessor.getField(context, actualField);
         if (item.isUnknown()) {
             log.warn("Accessing unknown static member and class hasn't been initialized as it " +
                      "would during actual execution. This can lead to errors. Perhaps you are" +
                      "executing methods out of order or need to specify additional class state?\n" +
                      "referenced={}, actual={}", fieldReference.toString(), actualField);
         }
-        MethodState mState = ectx.getMethodState();
+        MethodState mState = context.getMethodState();
         mState.assignRegister(destRegister, item);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/SPutOp.java
Patch:
@@ -34,11 +34,11 @@ public SPutOp(MethodLocation location, MethodLocation child, int valueRegister,
     }
 
     @Override
-    public void execute(ExecutionNode node, ExecutionContext ectx) {
-        MethodState mState = ectx.getMethodState();
+    public void execute(ExecutionNode node, ExecutionContext context) {
+        MethodState mState = context.getMethodState();
         HeapItem item = mState.readRegister(valueRegister);
         // TODO: check if this is <clinit> and only allow static final fields to be initialized here
-        vm.getStaticFieldAccessor().putField(ectx, actualField, item);
+        vm.getStaticFieldAccessor().putField(context, actualField, item);
     }
 
     @Override

File: smalivm/src/main/java/org/cf/smalivm/opcode/SPutOpFactory.java
Patch:
@@ -16,7 +16,7 @@ public class SPutOpFactory implements OpFactory {
     @Override
     public Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressToLocation, VirtualMachine vm) {
         MethodLocation child = Utils.getNextLocation(location, addressToLocation);
-        Instruction21c instr = (Instruction21c) (BuilderInstruction) location.getInstruction();
+        Instruction21c instr = (Instruction21c) location.getInstruction();
         int destRegister = instr.getRegisterA();
         FieldReference fieldReference = (FieldReference) instr.getReference();
         VirtualClass fieldClass = vm.getClassManager().getVirtualClass(fieldReference.getDefiningClass());

File: smalivm/src/main/java/org/cf/smalivm/opcode/UnimplementedOp.java
Patch:
@@ -52,7 +52,7 @@ public String toString() {
         if (registerA >= 0) {
             sb.append(" r").append(registerA);
         }
-        sb.append(" (unimplmented)");
+        sb.append(" (unimplemented)");
 
         return sb.toString();
     }

File: smalivm/src/main/java/org/cf/util/Utils.java
Patch:
@@ -89,7 +89,7 @@ public static Object castToPrimitive(Object value, String targetType) {
             } else if ("C".equals(targetType) || "Ljava/lang/Character;".equals(targetType)) {
                 return (char) castValue.intValue();
             } else if ("Z".equals(targetType) || "Ljava/lang/Boolean;".equals(targetType)) {
-                return castValue.intValue() != 0 ? true : false;
+                return castValue.intValue() != 0;
             }
         } else if (value instanceof Boolean) {
             Boolean castValue = (Boolean) value;
@@ -106,7 +106,7 @@ public static Object castToPrimitive(Object value, String targetType) {
             Character castValue = (Character) value;
             Integer intValue = (int) castValue;
             if ("Z".equals(targetType) || "Ljava/lang/Boolean;".equals(targetType)) {
-                return (int) castValue != 0 ? true : false;
+                return (int) castValue != 0;
             } else if ("B".equals(targetType) || "Ljava/lang/Byte;".equals(targetType)) {
                 return intValue.byteValue();
             } else if ("I".equals(targetType) || "Ljava/lang/Integer;".equals(targetType)) {
@@ -180,7 +180,7 @@ public static Integer getIntegerValue(Object obj) {
         return intValue;
     }
 
-    public static final MethodLocation[] getLocations(BuilderInstruction... instructions) {
+    public static MethodLocation[] getLocations(BuilderInstruction... instructions) {
         MethodLocation[] locations = new MethodLocation[instructions.length];
         for (int i = 0; i < locations.length; i++) {
             locations[i] = instructions[i].getLocation();

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOp.java
Patch:
@@ -341,9 +341,6 @@ private void executeLocalObjectInit(MethodState callerMethodState) throws ClassN
                                                                                       InvocationTargetException {
         int instanceRegister = parameterRegisters[0];
         HeapItem instanceItem = callerMethodState.peekRegister(instanceRegister);
-        if (instanceItem.getValue() instanceof UnknownValue) {
-            System.out.println("delme");
-        }
         UninitializedInstance uninitializedInstance = (UninitializedInstance) instanceItem.getValue();
         VirtualGeneric instanceType = uninitializedInstance.getType();
 

File: simplify/src/main/java/org/cf/simplify/ConstantBuilder.java
Patch:
@@ -169,7 +169,7 @@ public static BuilderInstruction buildConstant(Object value, String type, int re
         } else if (type.equals("F")) {
             constant = buildConstant(Utils.getFloatValue(value), register);
         } else if (type.equals("D")) {
-            // const op has no notion of actual type, just wide/narrow and bits
+            // const op has no notion of actual class, just wide/narrow and bits
             // must coax correct value when needed
             constant = buildConstant(Utils.getDoubleValue(value), register);
         } else if (type.equals("Ljava/lang/String;")) {
@@ -182,7 +182,7 @@ public static BuilderInstruction buildConstant(Object value, String type, int re
             constant = new BuilderInstruction21c(Opcode.CONST_CLASS, register, typeRef);
         } else {
             if (log.isWarnEnabled()) {
-                log.warn("Unrecognized constant type: {} for value: {}. This will cause failures.", type, value);
+                log.warn("Unrecognized constant class: {} for value: {}. This will cause failures.", type, value);
             }
         }
 

File: simplify/src/main/java/org/cf/simplify/Main.java
Patch:
@@ -3,7 +3,7 @@
 import java.io.IOException;
 
 import org.cf.smalivm.VirtualMachineFactory;
-import org.cf.smalivm.exception.UnhandledVirtualException;
+import org.cf.smalivm.UnhandledVirtualException;
 
 public class Main {
 

File: simplify/src/main/java/org/cf/simplify/SimplifyOptions.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.Arrays;
 import java.util.regex.Pattern;
 
-import org.cf.smalivm.smali.Dexifier;
+import org.cf.smalivm.dex.Dexifier;
 
 public class SimplifyOptions implements Serializable {
 
@@ -53,7 +53,7 @@ private InputType determineInputType() throws IOException {
         } else if (Arrays.equals(PK_ZIP_MAGIC, buf)) {
             return InputType.ZIP;
         } else {
-            throw new RuntimeException("Unknown input file type. Magic: " + Arrays.toString(buf));
+            throw new RuntimeException("Unknown input file type; magic: " + Arrays.toString(buf));
         }
     }
 

File: simplify/src/test/java/org/cf/simplify/ExecutionGraphManipulatorTest.java
Patch:
@@ -13,7 +13,7 @@
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.opcode.Op;
-import org.cf.smalivm.smali.ClassManager;
+import org.cf.smalivm.type.ClassManager;
 import org.jf.dexlib2.Opcode;
 import org.jf.dexlib2.builder.BuilderInstruction;
 import org.jf.dexlib2.builder.Label;

File: simplify/src/test/java/org/cf/simplify/LauncherTest.java
Patch:
@@ -7,7 +7,7 @@
 import java.nio.file.Files;
 
 import org.cf.smalivm.VirtualMachineFactory;
-import org.cf.smalivm.exception.UnhandledVirtualException;
+import org.cf.smalivm.UnhandledVirtualException;
 import org.junit.Test;
 
 public class LauncherTest {

File: simplify/src/test/java/org/cf/simplify/MainTest.java
Patch:
@@ -7,7 +7,7 @@
 
 import java.io.IOException;
 
-import org.cf.smalivm.exception.UnhandledVirtualException;
+import org.cf.smalivm.UnhandledVirtualException;
 import org.junit.Test;
 
 public class MainTest {

File: smalivm/src/main/java/org/cf/smalivm/MaxAddressVisitsExceededException.java
Patch:
@@ -1,12 +1,12 @@
-package org.cf.smalivm.exception;
+package org.cf.smalivm;
 
 import org.cf.smalivm.context.ExecutionNode;
 
-public class MaxAddressVisitsExceeded extends VirtualMachineException {
+public class MaxAddressVisitsExceededException extends VirtualMachineException {
 
     private static final long serialVersionUID = 7115169814850980339L;
 
-    public MaxAddressVisitsExceeded(ExecutionNode node, String methodDescriptor) {
+    public MaxAddressVisitsExceededException(ExecutionNode node, String methodDescriptor) {
         super("Exceeded max address visits @" + node.getAddress() + " " + node + " in " + methodDescriptor);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/UnhandledVirtualException.java
Patch:
@@ -1,6 +1,4 @@
-package org.cf.smalivm.exception;
-
-import org.cf.smalivm.VirtualException;
+package org.cf.smalivm;
 
 public class UnhandledVirtualException extends VirtualMachineException {
 

File: smalivm/src/main/java/org/cf/smalivm/VirtualMachineException.java
Patch:
@@ -1,4 +1,4 @@
-package org.cf.smalivm.exception;
+package org.cf.smalivm;
 
 public abstract class VirtualMachineException extends Exception {
 

File: smalivm/src/main/java/org/cf/smalivm/VirtualMachineFactory.java
Patch:
@@ -3,9 +3,9 @@
 import java.io.File;
 import java.io.IOException;
 
-import org.cf.smalivm.smali.ClassManager;
-import org.cf.smalivm.smali.ClassManagerFactory;
-import org.cf.smalivm.smali.Dexifier;
+import org.cf.smalivm.type.ClassManager;
+import org.cf.smalivm.type.ClassManagerFactory;
+import org.cf.smalivm.dex.Dexifier;
 
 public class VirtualMachineFactory {
 

File: smalivm/src/main/java/org/cf/smalivm/context/ClonerFactory.java
Patch:
@@ -5,7 +5,7 @@
 import java.util.WeakHashMap;
 
 import org.cf.smalivm.VirtualMachine;
-import org.cf.smalivm.smali.ClassManager;
+import org.cf.smalivm.type.ClassManager;
 import org.cf.util.ClassNameUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -24,10 +24,10 @@ public class ClonerFactory {
      * because classes are dynamically generated. If multiple virtual machines are used, any classes of instances that
      * were cloned in the first virtual machine will be cached. The second virtual machine will have a different class
      * loader and will dynamically generate different classes.
-     * 
+     *
      * The reason there is some ClassManager related caching is to speed up tests, i.e. to prevent having to read
      * configuration, create classes, and create a new cloner for every test.
-     * 
+     *
      * @param vm
      * @return
      */

File: smalivm/src/main/java/org/cf/smalivm/dex/ClassBuilder.java
Patch:
@@ -1,4 +1,4 @@
-package org.cf.smalivm.smali;
+package org.cf.smalivm.dex;
 
 import java.util.HashSet;
 import java.util.List;
@@ -26,7 +26,7 @@ public class ClassBuilder {
     private static final Logger log = LoggerFactory.getLogger(ClassBuilder.class.getSimpleName());
 
     public byte[] build(ClassDef classDef) {
-        log.debug("building class: " + classDef);
+        log.debug("Building input class: {}", classDef);
 
         ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
         visitClass(classDef, classWriter);

File: smalivm/src/main/java/org/cf/smalivm/dex/FrameworkCacheBuilder.java
Patch:
@@ -1,4 +1,4 @@
-package org.cf.smalivm.smali;
+package org.cf.smalivm.dex;
 
 import java.io.File;
 import java.io.InputStream;
@@ -18,7 +18,7 @@
 /**
  * This builds a list of all framework files and is used to create framework_classes.cfg.
  * The file is used to cache all the names and paths so they don't have to be enumerated when smalivm starts.
- * 
+ *
  * @author caleb
  *
  */

File: smalivm/src/main/java/org/cf/smalivm/emulate/org_cf_simplify_Utils_breakpoint.java
Patch:
@@ -10,7 +10,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class org_cf_simplify_Utils_breakpoint implements MethodStateMethod {
+class org_cf_simplify_Utils_breakpoint implements MethodStateMethod {
 
     private static final Logger log = LoggerFactory.getLogger(org_cf_simplify_Utils_breakpoint.class.getSimpleName());
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/ArrayLengthOp.java
Patch:
@@ -43,7 +43,7 @@ public void execute(ExecutionNode node, MethodState mState) {
                 node.clearChildren();
                 return;
             } else {
-                // Won't pass verifier if it's not an array type. Probably our fault, so error.
+                // Won't pass verifier if it's not an array virtual. Probably our fault, so error.
                 if (log.isErrorEnabled()) {
                     log.error("Unexpected non-array class: {}, {}", array.getClass(), array);
                 }

File: smalivm/src/main/java/org/cf/smalivm/opcode/BinaryMathOp.java
Patch:
@@ -17,7 +17,7 @@ public class BinaryMathOp extends MethodStateOp {
     @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(BinaryMathOp.class.getSimpleName());
 
-    private static enum MathOperandType {
+    private enum MathOperandType {
         DOUBLE("D"), FLOAT("F"), INT("I"), LONG("J"), ;
 
         private final String type;
@@ -31,7 +31,7 @@ public String getType() {
         }
     };
 
-    private static enum MathOperator {
+    private enum MathOperator {
         ADD, AND, DIV, MUL, OR, REM, RSUB, SHL, SHR, SUB, USHR, XOR,
     };
 
@@ -140,7 +140,7 @@ public String toString() {
             result = doDoubleOperation(mathOperator, (Double) lhs, (Double) rhs);
             break;
         default:
-            throw new RuntimeException("Unknown math operand type!");
+            throw new RuntimeException("Unknown math operand virtual!");
         }
 
         return result;

File: smalivm/src/main/java/org/cf/smalivm/opcode/FilledNewArrayOp.java
Patch:
@@ -26,7 +26,7 @@ public void execute(ExecutionNode node, MethodState mState) {
         /*
          * This populates a 1-dimensional integer array with values from the parameters. It does NOT create
          * n-dimensional arrays. It's usually used to create parameter for Arrays.newInstance(). If you use anything but
-         * [I as the type reference, the code fails verification and a few decompilers (not disassemblers) choke.
+         * [I as the virtual parse, the code fails verification and a few decompilers (not disassemblers) choke.
          */
         int[] dimensions = new int[dimensionRegisters.length];
         boolean foundUnknown = false;
@@ -44,7 +44,7 @@ public void execute(ExecutionNode node, MethodState mState) {
             } else {
                 if (!item.isUnknown()) {
                     if (log.isWarnEnabled()) {
-                        log.warn("Unexpected value type for " + toString() + ": " + item);
+                        log.warn("Unexpected value virtual for " + toString() + ": " + item);
                     }
                 }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/IfOp.java
Patch:
@@ -69,7 +69,7 @@ public void execute(ExecutionNode node, MethodState mState) {
         HeapItem lhsItem = mState.readRegister(register1);
         HeapItem rhsItem = compareToZero ? new HeapItem(0, "I") : mState.readRegister(register2);
 
-        // Ambiguous predicate. Follow both branches.
+        // Ambiguous predicate. Return to add both possible branches as children.
         if (lhsItem.isUnknown() || rhsItem.isUnknown()) {
             return;
         }

File: smalivm/src/main/java/org/cf/smalivm/opcode/NewInstanceOpFactory.java
Patch:
@@ -3,6 +3,7 @@
 import gnu.trove.map.TIntObjectMap;
 
 import org.cf.smalivm.VirtualMachine;
+import org.cf.smalivm.type.VirtualClass;
 import org.cf.util.Utils;
 import org.jf.dexlib2.builder.MethodLocation;
 import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
@@ -17,8 +18,9 @@ public Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressT
         int destRegister = instr.getRegisterA();
         TypeReference typeRef = (TypeReference) instr.getReference();
         String className = typeRef.getType();
+        VirtualClass virtualClass = vm.getClassManager().getVirtualClass(className);
 
-        return new NewInstanceOp(location, child, destRegister, className, vm);
+        return new NewInstanceOp(location, child, destRegister, virtualClass, vm);
     }
 
 }

File: smalivm/src/test/java/org/cf/smalivm/TestMethodInheritence.java
Patch:
@@ -5,7 +5,6 @@
 import org.cf.smalivm.context.ExecutionGraph;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
-import org.cf.smalivm.exception.VirtualMachineException;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;

File: smalivm/src/test/java/org/cf/smalivm/VMState.java
Patch:
@@ -52,6 +52,7 @@ public void setRegister(Integer register, HeapItem item) {
     }
 
     public void setRegisters(Object... params) {
+        // register, value, type
         for (int i = 0; i < params.length; i += 3) {
             Integer register = (Integer) params[i];
             String type = (String) params[i + 2];

File: smalivm/src/test/java/org/cf/smalivm/context/ExecutionGrapherTest.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.LinkedList;
 import java.util.List;
 
-import org.cf.smalivm.reference.LocalMethod;
+import org.cf.smalivm.type.VirtualMethod;
 import org.junit.Test;
 
 public class ExecutionGrapherTest {
@@ -32,7 +32,7 @@ public void testHasExpectedGraph() {
         children.add(child);
         when(root.getChildren()).thenReturn(children);
 
-        LocalMethod localMethod = mock(LocalMethod.class);
+        VirtualMethod localMethod = mock(VirtualMethod.class);
         when(localMethod.toString()).thenReturn(METHOD_SIGNATURE);
 
         ExecutionGraph graph = mock(ExecutionGraph.class);

File: smalivm/src/test/java/org/cf/smalivm/opcode/BinaryMathOpTest.java
Patch:
@@ -406,7 +406,7 @@ public void canDivIntLit8() {
         }
 
         @Test
-        public void canDivIntWithCatchWithUnkownValueVisitsExceptionHandler() {
+        public void canDivIntWithCatchWithUnknownValueVisitsExceptionHandler() {
             initial.setRegisters(0, new UnknownValue(), "I", 1, 5, "I");
             int[] expected = new int[] { 0, 2, 3, 4 };
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/MoveOpTest.java
Patch:
@@ -32,7 +32,7 @@ public void canMoveException() {
     public void canMoveRegisterObject() {
         initial.setRegisters(0, new Object(), "Ljava/lang/Object;");
 
-        // Must invoke VM directly to ensure reference identity
+        // Must invoke VM directly to ensure parse identity
         ExecutionGraph graph = VMTester.execute(CLASS_NAME, "moveRegisterObject()V", initial);
         int[] addresses = graph.getConnectedTerminatingAddresses();
         assertTrue("Should terminate when expected: " + Arrays.toString(addresses) + " == {1}",

File: smalivm/src/test/java/org/cf/smalivm/opcode/SwitchPayloadOpTest.java
Patch:
@@ -12,7 +12,7 @@
 import java.util.List;
 
 import org.cf.smalivm.VirtualMachine;
-import org.cf.smalivm.smali.ClassManager;
+import org.cf.smalivm.type.ClassManager;
 import org.jf.dexlib2.Opcode;
 import org.jf.dexlib2.builder.BuilderInstruction;
 import org.jf.dexlib2.builder.MethodLocation;

File: simplify/src/test/java/org/cf/simplify/strategy/UnreflectionStrategyTest.java
Patch:
@@ -128,7 +128,7 @@ public void testUnknownMethodIsNotOptimized() {
         @Test
         public void testUnknownParametersOfPubilcMethodIsNotOptimized() {
             ExecutionGraphManipulator manipulator = getOptimizedGraph(METHOD_WITH_3_LOCALS_AND_0_AVAILABLE, 0, METHOD,
-                            METHOD_TYPE, 1, 0, "I", 2, new UnknownValue(), "[Ljava/lang/Object");
+                            METHOD_TYPE, 1, 0, "I", 2, new UnknownValue(), "[Ljava/lang/Object;");
 
             testSmali(manipulator, EXPECTED_SHARED_SMALI);
             testRegisterCount(manipulator, METHOD_WITH_3_LOCALS_AND_0_AVAILABLE, 3);

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionContext.java
Patch:
@@ -8,6 +8,7 @@
 import java.util.Set;
 
 import org.cf.smalivm.SideEffect;
+import org.cf.smalivm.TemplateStateFactory;
 import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.exception.MaxAddressVisitsExceeded;
 import org.cf.smalivm.exception.MaxCallDepthExceeded;
@@ -142,7 +143,7 @@ public boolean isClassInitialized(String className) {
     public ClassState peekClassState(String className) {
         ExecutionContext ancestor = getAncestorWithClassName(className);
         if (ancestor == null) {
-            ClassState templateClassState = vm.getTemplateClassState(this, className);
+            ClassState templateClassState = TemplateStateFactory.forClass(this, className, this.vm.getClassManager());
             setClassState(className, templateClassState);
 
             return templateClassState;

File: smalivm/src/main/java/org/cf/util/Utils.java
Patch:
@@ -68,8 +68,6 @@ public static String buildFieldDescriptor(Field field) {
     }
 
     public static Object castToPrimitive(Object value, String targetType) {
-        // TODO: add tests for this + confirm dalvik works this way
-
         // Type information is not always available beyond "const" because Dalvik handles multiple types like integers.
         // This is to make easier the casting of that number to the correct type.
         if (value instanceof Number) {

File: smalivm/src/test/java/org/cf/smalivm/VMTester.java
Patch:
@@ -251,8 +251,6 @@ private static void testValueEquals(HeapItem expected, HeapItem consensus) {
             assertEquals(expected.toString(), consensus.toString());
         } else if (expectedValue.getClass().isArray()) {
             assertEquals(expected.getType(), consensus.getType());
-
-            // TODO: why does an array of local instances equal an array of actual instances?
             assertEquals(expectedValue.getClass(), consensusValue.getClass());
 
             if (expectedValue instanceof Object[] && consensusValue instanceof Object[])

File: smalivm/src/main/java/org/cf/smalivm/opcode/SGetOp.java
Patch:
@@ -29,6 +29,9 @@ public class SGetOp extends ExecutionContextOp {
     @Override
     public void execute(ExecutionNode node, ExecutionContext ectx) {
         HeapItem item = vm.getStaticFieldAccessor().getField(ectx, fieldDescriptor);
+        if (item.isUnknown()) {
+            log.warn("Accessing unknown static member {}. This implies class hasn't been initialized as it would during normal execution and may lead to errors.", fieldDescriptor);
+        }
         MethodState mState = ectx.getMethodState();
         mState.assignRegister(destRegister, item);
     }

File: simplify/src/main/java/org/cf/simplify/strategy/DeadRemovalStrategy.java
Patch:
@@ -152,7 +152,7 @@ List<Integer> getValidAddresses(ExecutionGraphManipulator manipulator) {
             }
 
             if (op.getName().startsWith("invoke-direct")) {
-                if (manipulator.getMethodSignature().contains(";-><init>(")) {
+                if (manipulator.getMethod().getSignature().contains(";-><init>(")) {
                     // Can't remove init method without breaking the object
                     ExecutionNode node = manipulator.getNodePile(address).get(0);
                     ExecutionContext ectx = node.getContext();

File: simplify/src/main/java/org/cf/simplify/strategy/PeepholeStrategy.java
Patch:
@@ -127,7 +127,7 @@ boolean canPeepCheckCast(int address) {
             // check-cast is first op with no parents
             // this implies it's acting on a parameter register
             // look at freshly spawned execution context type
-            ExecutionContext ectx = manipulator.getVM().spawnRootExecutionContext(manipulator.getMethodSignature());
+            ExecutionContext ectx = manipulator.getVM().spawnRootExecutionContext(manipulator.getMethod());
             HeapItem item = ectx.getMethodState().peekRegister(registerA);
             preCastType = item.getType();
         }

File: smalivm/src/main/java/org/cf/smalivm/ExceptionHandlerAddressResolver.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.cf.smalivm.reference.LocalMethod;
 import org.cf.smalivm.smali.ClassManager;
 import org.cf.util.ClassNameUtils;
 import org.jf.dexlib2.builder.BuilderTryBlock;
@@ -17,9 +18,9 @@ public class ExceptionHandlerAddressResolver {
     private final ClassManager classManager;
     private final List<BuilderTryBlock> tryBlocks;
 
-    ExceptionHandlerAddressResolver(ClassManager classManager, String methodDescriptor) {
+    ExceptionHandlerAddressResolver(ClassManager classManager, LocalMethod localMethod) {
         this.classManager = classManager;
-        tryBlocks = classManager.getTryBlocks(methodDescriptor);
+        tryBlocks = localMethod.getTryBlocks();
     }
 
     int resolve(Exception ex, int address) {

File: smalivm/src/main/java/org/cf/smalivm/NodeExecutor.java
Patch:
@@ -18,8 +18,7 @@ public class NodeExecutor {
 
     public NodeExecutor(ExecutionGraph graph, ClassManager classManager) {
         this.graph = graph;
-        String methodDescriptor = graph.getMethodSignature();
-        exceptionResolver = new ExceptionHandlerAddressResolver(classManager, methodDescriptor);
+        exceptionResolver = new ExceptionHandlerAddressResolver(classManager, graph.getMethod());
     }
 
     public void execute(ExecutionNode node) throws UnhandledVirtualException {

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGrapher.java
Patch:
@@ -12,7 +12,7 @@ public static String graph(ExecutionGraph graph) {
         StringBuilder sb = new StringBuilder("digraph {\n");
         getGraph(node, graph, sb, new ArrayList<ExecutionNode>());
         sb.append("labelloc=\"t\"\n");
-        sb.append("label=\"").append(graph.getMethodSignature()).append("\";\n");
+        sb.append("label=\"").append(graph.getMethod()).append("\";\n");
         sb.append('}');
 
         return sb.toString();

File: smalivm/src/test/java/org/cf/smalivm/opcode/InvokeOpTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
+import org.cf.smalivm.reference.MethodFactory;
 import org.cf.smalivm.smali.ClassManager;
 import org.cf.smalivm.type.UninitializedInstance;
 import org.cf.smalivm.type.UnknownValue;
@@ -416,7 +417,9 @@ public void hasExpectedToString() {
         public void setUp() {
             vm = mock(VirtualMachine.class);
 
+            MethodFactory methodFactory = new MethodFactory();
             classManager = mock(ClassManager.class);
+            when(classManager.getMethodFactory()).thenReturn(methodFactory);
             when(classManager.isLocalClass(METHOD_CLASS)).thenReturn(true);
             when(classManager.isFrameworkClass(METHOD_SIGNATURE)).thenReturn(false);
             when(classManager.isSafeFrameworkClass(METHOD_SIGNATURE)).thenReturn(false);

File: simplify/src/main/java/org/cf/simplify/strategy/ConstantPropigationStrategy.java
Patch:
@@ -96,8 +96,8 @@ private boolean canConstantizeAddress(int address) {
             return false;
         }
 
-        String valueType = consensus.getType();
-        if (!constantBuilder.canConstantizeType(valueType)) {
+        String type = consensus.getType();
+        if (!constantBuilder.canConstantizeType(type)) {
             return false;
         }
 

File: simplify/src/main/java/org/cf/simplify/strategy/DeadRemovalStrategy.java
Patch:
@@ -152,7 +152,7 @@ List<Integer> getValidAddresses(ExecutionGraphManipulator manipulator) {
             }
 
             if (op.getName().startsWith("invoke-direct")) {
-                if (manipulator.getMethodDescriptor().contains(";-><init>(")) {
+                if (manipulator.getMethodSignature().contains(";-><init>(")) {
                     // Can't remove init method without breaking the object
                     ExecutionNode node = manipulator.getNodePile(address).get(0);
                     ExecutionContext ectx = node.getContext();

File: simplify/src/main/java/org/cf/simplify/strategy/PeepholeStrategy.java
Patch:
@@ -259,7 +259,7 @@ void peepStringInit() {
             Instruction35c instr = (Instruction35c) original;
             int instanceRegister = instr.getRegisterC();
             HeapItem item = manipulator.getRegisterConsensus(address, instanceRegister);
-            BuilderInstruction replacement = ConstantBuilder.buildConstant(item.getValue(), item.getUnboxedValueType(),
+            BuilderInstruction replacement = ConstantBuilder.buildConstant(item.getValue(), item.getUnboxedType(),
                             instanceRegister, manipulator.getDexBuilder());
             if (log.isDebugEnabled()) {
                 log.debug("Peeping string init @{} {}", address, manipulator.getOp(address));
@@ -301,7 +301,7 @@ void peepCheckCast() {
                 // this implies it's acting on a parameter register
                 // look at freshly spawned execution context type
                 ExecutionContext ectx = manipulator.getVM()
-                                .spawnRootExecutionContext(manipulator.getMethodDescriptor());
+                                .spawnRootExecutionContext(manipulator.getMethodSignature());
                 HeapItem item = ectx.getMethodState().peekRegister(registerA);
                 preCastType = item.getType();
             }

File: simplify/src/test/java/org/cf/simplify/strategy/ConstantPropigationStrategyTest.java
Patch:
@@ -43,7 +43,7 @@ public void addInt2AddrConstantizesToExpectedInstruction() {
         }
 
         @Test
-        public void aGetIsConstable() {
+        public void canConstantizeAGet() {
             ExecutionGraphManipulator manipulator = getOptimizedGraph("arrayGetFromV0AtV1ToV0()V", 0,
                             new int[] { 0, 7 }, "[I", 1, 1, "I");
             BuilderInstruction expected = ConstantBuilder.buildConstant(7, 0);
@@ -61,7 +61,7 @@ public void moveOpIsWithConst16ConstantizesToExpectedInstruction() {
         }
 
         @Test
-        public void testNonDeterministicallyExecuteConstableOpConstantizesToExpectedInstruction() {
+        public void nonDeterministicallyExecuteConstableOpConstantizesToExpectedInstruction() {
             ExecutionGraphManipulator manipulator = getOptimizedGraph(
                             "nonDeterministicallyStaticGetIntegerMaxValue(I)V", 1, new UnknownValue(), "I");
             BuilderInstruction expected = ConstantBuilder.buildConstant(Integer.MAX_VALUE, 0);
@@ -70,7 +70,7 @@ public void testNonDeterministicallyExecuteConstableOpConstantizesToExpectedInst
         }
 
         @Test
-        public void testSGetIsConstable() {
+        public void canConstantizeSGet() {
             ExecutionGraphManipulator manipulator = getOptimizedGraph("getStaticIntegerMaxValue()V");
             BuilderInstruction expected = ConstantBuilder.buildConstant(Integer.MAX_VALUE, 0);
 

File: smalivm/src/main/java/org/cf/smalivm/MethodExecutor.java
Patch:
@@ -41,7 +41,7 @@ public class MethodExecutor {
     ExecutionGraph execute(ExecutionGraph graph) throws MaxAddressVisitsExceeded, MaxCallDepthExceeded,
                     MaxMethodVisitsExceeded, UnhandledVirtualException, MaxExecutionTimeExceeded {
         TIntIntMap addressToVisitCount = new TIntIntHashMap();
-        String methodDescriptor = graph.getMethodDescriptor();
+        String methodDescriptor = graph.getMethodSignature();
         ExecutionNode node = graph.getRoot();
         int callDepth = node.getCallDepth();
         log.info("Executing {}, depth={}", methodDescriptor, callDepth);

File: smalivm/src/main/java/org/cf/smalivm/NodeExecutor.java
Patch:
@@ -18,7 +18,7 @@ public class NodeExecutor {
 
     public NodeExecutor(ExecutionGraph graph, ClassManager classManager) {
         this.graph = graph;
-        String methodDescriptor = graph.getMethodDescriptor();
+        String methodDescriptor = graph.getMethodSignature();
         exceptionResolver = new ExceptionHandlerAddressResolver(classManager, methodDescriptor);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGraph.java
Patch:
@@ -286,7 +286,7 @@ public SideEffect.Level getHighestSideEffectLevel() {
         return result;
     }
 
-    public String getMethodDescriptor() {
+    public String getMethodSignature() {
         return methodDescriptor;
     }
 

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGrapher.java
Patch:
@@ -12,7 +12,7 @@ public static String graph(ExecutionGraph graph) {
         StringBuilder sb = new StringBuilder("digraph {\n");
         getGraph(node, graph, sb, new ArrayList<ExecutionNode>());
         sb.append("labelloc=\"t\"\n");
-        sb.append("label=\"").append(graph.getMethodDescriptor()).append("\";\n");
+        sb.append("label=\"").append(graph.getMethodSignature()).append("\";\n");
         sb.append('}');
 
         return sb.toString();

File: smalivm/src/test/java/org/cf/smalivm/context/ExecutionGrapherTest.java
Patch:
@@ -33,7 +33,7 @@ public void testHasExpectedGraph() {
 
         ExecutionGraph graph = mock(ExecutionGraph.class);
         when(graph.getRoot()).thenReturn(root);
-        when(graph.getMethodDescriptor()).thenReturn(METHOD_DESCRIPTOR);
+        when(graph.getMethodSignature()).thenReturn(METHOD_DESCRIPTOR);
         when(graph.getNodeIndex(root)).thenReturn(0);
         when(graph.getNodeIndex(child)).thenReturn(0);
         String digraph = ExecutionGrapher.graph(graph);

File: smalivm/src/test/java/org/cf/smalivm/VMTester.java
Patch:
@@ -29,6 +29,7 @@
 import org.cf.smalivm.smali.ClassManagerFactory;
 import org.cf.smalivm.smali.Dexifier;
 import org.cf.smalivm.type.UnknownValue;
+import org.cf.util.ClassNameUtils;
 import org.jf.dexlib2.Opcodes;
 import org.jf.dexlib2.builder.MethodLocation;
 import org.jf.dexlib2.writer.builder.DexBuilder;
@@ -49,6 +50,7 @@ public static void setRegisterMock(MethodState mState, int register, Object valu
         } else if (value instanceof UnknownValue) {
             when(item.isUnknown()).thenReturn(true);
         }
+        when(item.getComponentBase()).thenReturn(ClassNameUtils.getComponentBase(type));
         when(item.getType()).thenReturn(type);
         when(mState.readRegister(eq(register))).thenReturn(item);
     }

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOp.java
Patch:
@@ -103,7 +103,8 @@ public void execute(ExecutionNode node, ExecutionContext ectx) {
             if (classManager.isLocalMethod(targetMethod)) {
                 if (classManager.isFrameworkClass(targetMethod) && !classManager.isSafeFrameworkClass(targetMethod)) {
                     if (log.isDebugEnabled()) {
-                        log.debug("Not executing unsafe local method: {}. Assuming maxiumum ambiguity.", targetMethod);
+                        log.debug("Not executing unsafe framework method: {}. Assuming maxiumum ambiguity.",
+                                        targetMethod);
                     }
                     assumeMaximumUnknown(callerMethodState);
                     return;

File: smalivm/src/test/java/org/cf/smalivm/VMTester.java
Patch:
@@ -41,7 +41,7 @@ public class VMTester {
 
     private static ClassManager classManager;
 
-    public static void addHeapItem(MethodState mState, int register, Object value, String type) {
+    public static void setRegisterMock(MethodState mState, int register, Object value, String type) {
         HeapItem item = mock(HeapItem.class);
         when(item.getValue()).thenReturn(value);
         if ("I".equals(type) && value instanceof Number) {

File: smalivm/src/test/java/org/cf/smalivm/opcode/ArrayLengthOpTest.java
Patch:
@@ -144,7 +144,7 @@ public static class UnitTest {
 
         @Test
         public void nullArrayThrowsExpectedException() {
-            VMTester.addHeapItem(mState, ARG1_REGISTER, null, "[I");
+            VMTester.setRegisterMock(mState, ARG1_REGISTER, null, "[I");
 
             op = (ArrayLengthOp) opFactory.create(location, addressToLocation, vm);
             op.execute(node, mState);

File: smalivm/src/test/java/org/cf/smalivm/opcode/CheckCastOpTest.java
Patch:
@@ -92,7 +92,7 @@ public void nullValueWithCastableTypeThrowsNoExceptionAndIsConverted() throws Un
             String registerType = "Lmoneylol;";
             when(castTypeRef.getType()).thenReturn(castType);
             when(classManager.isInstance(eq(registerType), eq(castType))).thenReturn(true);
-            VMTester.addHeapItem(mState, ARG1_REGISTER, null, registerType);
+            VMTester.setRegisterMock(mState, ARG1_REGISTER, null, registerType);
 
             op = (CheckCastOp) opFactory.create(location, addressToLocation, vm);
             op.execute(node, mState);
@@ -107,7 +107,7 @@ public void objectNotOfCastTypeThrowsClassCastException() throws UnknownAncestor
             String registerType = "Lmoneylol;";
             when(castTypeRef.getType()).thenReturn(castType);
             when(classManager.isInstance(eq(registerType), eq(castType))).thenReturn(false);
-            VMTester.addHeapItem(mState, ARG1_REGISTER, new Object(), registerType);
+            VMTester.setRegisterMock(mState, ARG1_REGISTER, new Object(), registerType);
 
             op = (CheckCastOp) opFactory.create(location, addressToLocation, vm);
             op.execute(node, mState);

File: smalivm/src/test/java/org/cf/smalivm/opcode/IfOpTest.java
Patch:
@@ -331,8 +331,8 @@ public static class UnitTest {
         @Test
         public void hasExpectedToStringValue() {
             int value = 0;
-            VMTester.addHeapItem(mState, ARG1_REGISTER, value, "D");
-            VMTester.addHeapItem(mState, ARG2_REGISTER, value, "D");
+            VMTester.setRegisterMock(mState, ARG1_REGISTER, value, "D");
+            VMTester.setRegisterMock(mState, ARG2_REGISTER, value, "D");
 
             instruction = buildInstruction22t(Opcode.IF_GE, 0);
             op = (IfOp) opFactory.create(location, addressToLocation, vm);

File: smalivm/src/test/java/org/cf/smalivm/opcode/NewArrayOpTest.java
Patch:
@@ -132,7 +132,7 @@ public static class UnitTest {
         @Test
         public void canCreateNewArray() throws ClassNotFoundException {
             int size = 5;
-            VMTester.addHeapItem(mState, SIZE_REGISTER, size, "I");
+            VMTester.setRegisterMock(mState, SIZE_REGISTER, size, "I");
 
             String type = "[Ljava/lang/String;";
             buildInstruction22c(Opcode.NEW_ARRAY, type);
@@ -147,7 +147,7 @@ public void canCreateNewArray() throws ClassNotFoundException {
         @Test
         public void nonExistantClassNameThrowsException() throws ClassNotFoundException {
             int size = 5;
-            VMTester.addHeapItem(mState, SIZE_REGISTER, size, "I");
+            VMTester.setRegisterMock(mState, SIZE_REGISTER, size, "I");
 
             String type = "Ldoes/not/123Exist;";
             buildInstruction22c(Opcode.NEW_ARRAY, type);

File: smalivm/src/main/java/org/cf/smalivm/opcode/NewArrayOp.java
Patch:
@@ -13,6 +13,7 @@
 
 public class NewArrayOp extends MethodStateOp {
 
+    @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(NewArrayOp.class.getSimpleName());
 
     private final int destRegister;

File: smalivm/src/main/java/org/cf/smalivm/opcode/NewArrayOpFactory.java
Patch:
@@ -12,6 +12,7 @@
 
 public class NewArrayOpFactory implements OpFactory {
 
+    @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(NewArrayOpFactory.class.getSimpleName());
 
     @Override

File: smalivm/src/main/java/org/cf/smalivm/smali/SmaliFileFactory.java
Patch:
@@ -40,8 +40,9 @@ public Set<SmaliFile> getSmaliFiles(File[] files) throws IOException {
                 SmaliFile smaliFile = new SmaliFile(match);
                 // DalvikVM rejects classes that are already defined.
                 // Framework classes take precedence over local classes.
-                if (isFrameworkClass(smaliFile.getClassName())) {
-                    log.warn("'{}' has an earlier definition; blocking out", smaliFile.getClassName());
+                String className = smaliFile.getClassName();
+                if (isFrameworkClass(className) && !className.startsWith("Landroid/support/")) {
+                    log.warn("Input class '{}' has an earlier definition; ignoring", className);
                 } else {
                     smaliFiles.add(smaliFile);
                 }

File: smalivm/src/main/java/org/cf/smalivm/type/UninitializedInstance.java
Patch:
@@ -37,7 +37,7 @@ public String getName() {
 
     @Override
     public String toString() {
-        return "Uninitialized " + smaliType;
+        return new StringBuilder("Uninitialized ").append(smaliType).toString();
     }
 
 }

File: smalivm/src/main/java/org/cf/smalivm/type/UnknownValue.java
Patch:
@@ -8,7 +8,7 @@ public UnknownValue() {
 
     @Override
     public boolean equals(Object other) {
-        // i.e. NULL != NULL
+        // This is similar to NULL != NULL
         return false;
     }
 

File: smalivm/src/main/java/org/cf/smalivm/smali/SmaliClassLoader.java
Patch:
@@ -16,14 +16,14 @@ public class SmaliClassLoader extends ClassLoader {
 
     private static final String FRAMEWORK_STUBS_JAR = "/framework/framework-23.jar";
 
-    private Map<String, Class<?>> cachedClasses;
+    private static final Map<String, Class<?>> cachedClasses = new HashMap<String, Class<?>>();
     private final ClassBuilder classBuilder;
     private final ClassManager classManager;
-    private URLClassLoader jarLoader;
+    private final URLClassLoader jarLoader;
 
     public SmaliClassLoader(ClassManager classManager) {
         super(SmaliClassLoader.class.getClassLoader());
-        cachedClasses = new HashMap<String, Class<?>>();
+        // cachedClasses = new HashMap<String, Class<?>>();
         URL jarURL = SmaliClassLoader.class.getResource(FRAMEWORK_STUBS_JAR);
         jarLoader = new URLClassLoader(new URL[] { jarURL });
         this.classBuilder = new ClassBuilder();

File: simplify/src/main/java/org/cf/simplify/ExecutionGraphManipulator.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import org.cf.smalivm.SideEffect;
@@ -306,7 +307,7 @@ private void addToNodePile(MethodLocation newLocation) {
         }
     }
 
-    private void reparentNode(ExecutionNode child, ExecutionNode parent) {
+    private void reparentNode(@Nonnull ExecutionNode child, @Nonnull ExecutionNode parent) {
         ExecutionContext newContext = parent.getContext().spawnChild();
         child.setContext(newContext);
         child.setParent(parent);

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionContext.java
Patch:
@@ -34,7 +34,7 @@ public class ExecutionContext {
     private int callerAddress;
     private int callDepth;
 
-    private class ClassStatus {
+    private static class ClassStatus {
 
         private boolean isInitialized;
         private ClassState cState;

File: smalivm/src/main/java/org/cf/smalivm/context/HeapItem.java
Patch:
@@ -73,7 +73,7 @@ public boolean equals(Object obj) {
 
     @Override
     public int hashCode() {
-        return new HashCodeBuilder(113, 21).append(getType()).append(getValue()).hashCode();
+        return new HashCodeBuilder(123, 51).append(getType()).append(getValue()).hashCode();
     }
 
     public boolean valueIdentity(HeapItem other) {

File: smalivm/src/main/java/org/cf/smalivm/opcode/BinaryMathOp.java
Patch:
@@ -329,6 +329,8 @@ public String toString() {
             rhs = Utils.getDoubleValue(rhs);
             result = doDoubleOperation(mathOperator, (Double) lhs, (Double) rhs);
             break;
+        default:
+            throw new RuntimeException("Unknown math operand type!");
         }
 
         return result;

File: smalivm/src/main/java/org/cf/smalivm/opcode/IfOp.java
Patch:
@@ -80,7 +80,7 @@ public void execute(ExecutionNode node, MethodState mState) {
         if (compareToZero) {
             if (lhs == null) {
                 // if-*z ops are used to check for null refs
-                cmp = lhs == null ? 0 : 1;
+                cmp = 0;
             } else if ((lhs instanceof Number || lhs instanceof Boolean || lhs instanceof Character) && (rhs instanceof Number || rhs instanceof Boolean || rhs instanceof Character)) {
                 Integer aIntValue = Utils.getIntegerValue(lhs);
                 cmp = aIntValue.compareTo((Integer) rhs);

File: smalivm/src/main/java/org/cf/smalivm/type/LocalClass.java
Patch:
@@ -28,9 +28,10 @@ public boolean equals(Object other) {
 
     @Override
     public int hashCode() {
-        return new HashCodeBuilder().append(className).toHashCode();
+        return new HashCodeBuilder(607, 23).append(className).toHashCode();
     }
 
+    @Override
     public String getName() {
         return className;
     }

File: smalivm/src/main/java/org/cf/util/ImmutableUtils.java
Patch:
@@ -18,7 +18,7 @@ public class ImmutableUtils {
     private static Set<String> getImmutableClasses() {
         List<String> lines = new ArrayList<String>();
         try {
-            lines = ConfigLoader.loadConfig("immutable_classes.cfg");
+            lines = ConfigurationLoader.loadConfig("immutable_classes.cfg");
         } catch (IOException e) {
             log.warn("Error loading immutable classes.", e);
         }

File: smalivm/src/test/java/org/cf/smalivm/opcode/TestMoveOp.java
Patch:
@@ -31,7 +31,7 @@ public void testMoveRegisterObject() {
         // Must invoke VM directly to ensure reference identity
         ExecutionGraph graph = VMTester.execute(CLASS_NAME, "TestMoveRegisterObject()V", initial);
         int[] addresses = graph.getConnectedTerminatingAddresses();
-        assertTrue("Should terminate when expected: " + addresses + " == {1}",
+        assertTrue("Should terminate when expected: " + Arrays.toString(addresses) + " == {1}",
                         Arrays.equals(addresses, new int[] { 1 }));
 
         HeapItem register0 = graph.getRegisterConsensus(1, 0);

File: simplify/src/main/java/org/cf/simplify/Options.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.regex.Pattern;
 
 import org.apache.commons.io.FilenameUtils;
+import org.cf.util.Dexifier;
 import org.kohsuke.args4j.Option;
 import org.kohsuke.args4j.spi.FileOptionHandler;
 import org.kohsuke.args4j.spi.PatternOptionHandler;
@@ -46,7 +47,7 @@ public class Options implements Serializable {
     private File outFile;
 
     @Option(name = "--output-api-level", usage = "Output DEX API compatibility level.")
-    private int outputAPILevel = 15;
+    private int outputAPILevel = Dexifier.DEFAULT_API_LEVEL;
 
     @Option(name = "-v", aliases = { "--verbose" }, usage = "Be verbose")
     private boolean verbose;

File: smalivm/src/test/java/org/cf/smalivm/TestClassManager.java
Patch:
@@ -24,7 +24,7 @@ public class TestClassManager {
 
     @BeforeClass
     public static void getClassManager() throws IOException {
-        manager = new ClassManager(TEST_DIRECTORY);
+        manager = new ClassManagerFactory().build(TEST_DIRECTORY);
     }
 
     @Test

File: demoapp/src/main/java/org/cf/demoapp/java_io_PrintStream_println.java
Patch:
@@ -9,8 +9,9 @@
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.emulate.MethodStateMethod;
+import org.cf.smalivm.emulate.UnknownValuesMethod;
 
-public class java_io_PrintStream_println implements MethodStateMethod {
+public class java_io_PrintStream_println implements MethodStateMethod, UnknownValuesMethod {
 
     @Override
     public void execute(VirtualMachine vm, MethodState mState) {

File: smalivm/src/main/java/org/cf/smalivm/MethodExecutor.java
Patch:
@@ -93,6 +93,7 @@ ExecutionGraph execute(ExecutionGraph graph) throws MaxAddressVisitsExceeded, Ma
         while ((node = stack.poll()) != null) {
             totalVisits += 1;
             checkMaxVisits(node, methodDescriptor, addressToVisitCount);
+
             nodeExecutor.execute(node);
             stack.addAll(node.getChildren());
             checkMaxExecutionTime(endTime, methodDescriptor);

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionContext.java
Patch:
@@ -227,7 +227,7 @@ public void staticallyInitializeClassIfNecessary(String className) {
     public String toString() {
         StringBuilder sb = new StringBuilder();
         if (mState != null) {
-            sb.append("Method: ").append(mState.toString());
+            sb.append("Method state: ").append(mState.toString());
         }
         if (sb.length() > 0) {
             sb.append('\n');
@@ -238,7 +238,7 @@ public String toString() {
             for (String className : initializedClasses) {
                 // ClassState cState = peekClassState(className);
                 ClassState cState = classNameToStatus.get(className).getClassState();
-                sb.append("Class: ").append(className).append(' ').append(cState);
+                sb.append("Class state: ").append(className).append(' ').append(cState);
             }
         }
 

File: smalivm/src/main/java/org/cf/smalivm/emulate/MethodEmulator.java
Patch:
@@ -68,7 +68,7 @@ public static boolean canEmulate(String methodDescriptor) {
     public static boolean canHandleUnknownValues(String methodDescriptor) {
         Class<? extends EmulatedMethod> methodClass = emulatedMethods.get(methodDescriptor);
 
-        return (methodClass != null) && (methodClass.isAssignableFrom(UnknownValuesMethod.class));
+        return (methodClass != null) && (UnknownValuesMethod.class.isAssignableFrom(methodClass));
     }
 
     public static void clearMethods() {

File: simplify/src/main/java/org/cf/simplify/Launcher.java
Patch:
@@ -24,6 +24,7 @@
 import org.cf.smalivm.exception.MaxCallDepthExceeded;
 import org.cf.smalivm.exception.MaxMethodVisitsExceeded;
 import org.cf.smalivm.exception.UnhandledVirtualException;
+import org.jf.dexlib2.Opcodes;
 import org.jf.dexlib2.writer.builder.BuilderMethod;
 import org.jf.dexlib2.writer.builder.DexBuilder;
 import org.jf.dexlib2.writer.io.FileDataStore;
@@ -52,7 +53,7 @@ public void run(String[] args) throws IOException, UnhandledVirtualException {
         }
 
         long startTime = System.currentTimeMillis();
-        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(opts.getOutputAPILevel());
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Opcodes.forApi(opts.getOutputAPILevel()));
         ClassManager classManager = getClassManager(opts.getInFile(), opts.isApk() | opts.isDex(), dexBuilder);
         VirtualMachine vm = new VirtualMachine(classManager, opts.getMaxAddressVisits(), opts.getMaxCallDepth(),
                         opts.getMaxMethodVisits());

File: smalivm/src/main/java/org/cf/util/Dexifier.java
Patch:
@@ -12,6 +12,7 @@
 import org.antlr.runtime.tree.CommonTree;
 import org.antlr.runtime.tree.CommonTreeNodeStream;
 import org.apache.commons.io.FileUtils;
+import org.jf.dexlib2.Opcodes;
 import org.jf.dexlib2.writer.builder.BuilderClassDef;
 import org.jf.dexlib2.writer.builder.DexBuilder;
 import org.jf.smali.LexerErrorInterface;
@@ -88,7 +89,7 @@ public static List<BuilderClassDef> dexifySmaliFiles(List<File> smaliFiles, DexB
     }
 
     public static List<BuilderClassDef> dexifySmaliFiles(String path) throws Exception {
-        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Dexifier.DEFAULT_API_LEVEL);
+        DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Opcodes.forApi(Dexifier.DEFAULT_API_LEVEL));
 
         return dexifySmaliFiles(new File(path), dexBuilder);
     }

File: simplify/src/main/java/org/cf/simplify/MethodBackedGraph.java
Patch:
@@ -203,13 +203,13 @@ public void replaceInstruction(int address, BuilderInstruction instruction) {
     }
 
     public void replaceInstruction(int insertAddress, List<BuilderInstruction> instructions) {
-        MethodLocation location = getLocation(insertAddress);
-        int address = location.getCodeAddress();
-        removeInstruction(location);
+        int address = insertAddress;
         for (BuilderInstruction instruction : instructions) {
             addInstruction(address, instruction);
             address += instruction.getCodeUnits();
         }
+        MethodLocation location = getLocation(address);
+        removeInstruction(location);
     }
 
     public String toSmali() {

File: smalivm/src/main/java/org/cf/smalivm/opcode/IfOp.java
Patch:
@@ -110,7 +110,7 @@ public String toString() {
         if (!compareToZero) {
             sb.append(", r").append(register2);
         }
-        sb.append(", #").append(target);
+        sb.append(", #").append(target.getCodeAddress());
 
         return sb.toString();
     }

File: simplify/src/main/java/org/cf/simplify/MethodBackedGraph.java
Patch:
@@ -191,6 +191,7 @@ public void removeInstruction(int address) {
     public void removeInstructions(TIntList addresses) {
         addresses.sort();
         addresses.reverse();
+        log.debug("Removing instructions: " + addresses);
         for (int address : addresses.toArray()) {
             removeInstruction(address);
         }

File: simplify/src/main/java/org/cf/simplify/Launcher.java
Patch:
@@ -169,9 +169,7 @@ private static void filterMethods(Collection<String> methodDescriptors, Pattern
             String name = it.next();
             if ((positive != null) && !positive.matcher(name).find()) {
                 it.remove();
-            }
-
-            if ((negative != null) && negative.matcher(name).find()) {
+            } else if ((negative != null) && negative.matcher(name).find()) {
                 it.remove();
             }
         }

File: simplify/src/test/java/org/cf/simplify/strategy/TestReflectionRemovalStrategy.java
Patch:
@@ -127,6 +127,7 @@ public void testOptimizesToExpectedLinesWith3LocalsAnd0Available() {
             testRegisterCount(mbgraph, METHOD_WITH_3_LOCALS_AND_0_AVAILABLE, 3);
         }
     }
+
     public static class TestInvokeNonOptimizableScenarios {
 
         private static final String[] EXPECTED_LINES = new String[] {
@@ -168,6 +169,7 @@ public void testUnknownParametersIsNotOptimized() {
             testRegisterCount(mbgraph, METHOD_WITH_3_LOCALS_AND_0_AVAILABLE, 3);
         }
     }
+
     public static class TestInvokeStaticNonLocalMethodWithNoParameters {
 
         private static final Method METHOD = getMethod(System.class, "gc", new Class<?>[0]);
@@ -199,6 +201,7 @@ public void testOptimizesToExpectedLinesWith7ContiguousAvailable() {
             testRegisterCount(mbgraph, METHOD_WITH_10_LOCALS_AND_7_CONTIGUOUS_AVAILABLE, 10);
         }
     }
+
     public static class TestInvokeStaticPrivateLocalMethod {
 
         private static final LocalMethod METHOD = new LocalMethod(CLASS_NAME + "->FourParameterMethod(IIII)V");

File: smalivm/src/main/java/org/cf/smalivm/context/BaseState.java
Patch:
@@ -119,11 +119,11 @@ void removeRegister(int register, String heapId) {
     }
 
     boolean wasRegisterRead(int register, String heapId) {
-        HeapItem item = peekRegister(register, heapId);
         if (getRegistersRead().contains(register)) {
             return true;
         }
 
+        HeapItem item = peekRegister(register, heapId);
         if (null == item) {
             return false;
         }

File: smalivm/src/main/java/org/cf/smalivm/context/MethodState.java
Patch:
@@ -135,9 +135,8 @@ public HeapItem peekRegister(int register) {
                 if (getParent() != null && !getParent().hasRegister(register, METHOD_HEAP)) {
                     // ResultRegister can only be read by the instruction immediately after it's set.
                     // It's not in this instruction or its parent, so it effectively doesn't exist.
-                    log.warn("Attempting to read result register but it's not in current or parent context! Assuming unknown type!");
-
-                    return HeapItem.newUnknown("?");
+                    log.warn("Attempting to read result register but it's not in current or parent context! Returning null.");
+                    return null;
                 }
 
             }

File: simplify/src/main/java/org/cf/simplify/Options.java
Patch:
@@ -18,7 +18,7 @@ public class Options implements Serializable {
     private boolean help;
 
     @Option(name = "-et", aliases = { "--exclude-types" }, metaVar = "regex", handler = PatternOptionHandler.class,
-                    usage = "Don't simplify matching types. Aapplied after include.")
+                    usage = "Don't simplify matching types. Applied after include.")
     private Pattern excludeFilter;
 
     @Option(name = "-it", aliases = { "--include-types" }, metaVar = "regex", handler = PatternOptionHandler.class,

File: simplify/src/main/java/org/cf/simplify/strategy/ReflectionRemovalStrategy.java
Patch:
@@ -331,7 +331,7 @@ private void replaceMethodInvoke() {
                 e.printStackTrace();
             }
 
-            mbgraph.replaceWithMultipleInstructions(address, replacements);
+            mbgraph.replaceInstruction(address, replacements);
         }
     }
 

File: smalivm/src/main/java/org/cf/smalivm/ExceptionHandlerAddressResolver.java
Patch:
@@ -24,6 +24,7 @@ public class ExceptionHandlerAddressResolver {
     @Deprecated
     int resolve(Exception ex, int address) {
         String exceptionClass = SmaliClassUtils.javaClassToSmali(ex.getClass().getName());
+
         return resolve(exceptionClass, address);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/IGetOp.java
Patch:
@@ -5,7 +5,7 @@
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -19,9 +19,9 @@ public class IGetOp extends ExecutionContextOp {
     private final String fieldDescriptor;
     private final VirtualMachine vm;
 
-    public IGetOp(BuilderInstruction instruction, BuilderInstruction child, int destRegister, int instanceRegister,
+    public IGetOp(MethodLocation location, MethodLocation child, int destRegister, int instanceRegister,
                     String fieldDescriptor, VirtualMachine vm) {
-        super(instruction, child);
+        super(location, child);
 
         this.destRegister = destRegister;
         this.instanceRegister = instanceRegister;

File: smalivm/src/main/java/org/cf/smalivm/opcode/IPutOp.java
Patch:
@@ -6,7 +6,7 @@
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -20,9 +20,9 @@ public class IPutOp extends ExecutionContextOp {
     private final int instanceRegister;
     private final VirtualMachine vm;
 
-    IPutOp(BuilderInstruction instruction, BuilderInstruction child, int valueRegister, int instanceRegister,
+    IPutOp(MethodLocation location, MethodLocation child, int valueRegister, int instanceRegister,
                     String fieldDescriptor, VirtualMachine vm) {
-        super(instruction, child);
+        super(location, child);
 
         this.valueRegister = valueRegister;
         this.instanceRegister = instanceRegister;

File: smalivm/src/main/java/org/cf/smalivm/opcode/NopOp.java
Patch:
@@ -2,12 +2,12 @@
 
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.MethodState;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 
 public class NopOp extends MethodStateOp {
 
-    NopOp(BuilderInstruction instruction, BuilderInstruction child) {
-        super(instruction, child);
+    NopOp(MethodLocation location, MethodLocation child) {
+        super(location, child);
     }
 
     @Override

File: smalivm/src/main/java/org/cf/smalivm/opcode/OpFactory.java
Patch:
@@ -3,11 +3,10 @@
 import gnu.trove.map.TIntObjectMap;
 
 import org.cf.smalivm.VirtualMachine;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 
 public interface OpFactory {
 
-    public Op create(BuilderInstruction instruction, TIntObjectMap<BuilderInstruction> addressToInstruction,
-                    VirtualMachine vm);
+    public Op create(MethodLocation location, TIntObjectMap<MethodLocation> addressToLocation, VirtualMachine vm);
 
 }

File: smalivm/src/main/java/org/cf/smalivm/opcode/ReturnOp.java
Patch:
@@ -3,7 +3,7 @@
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -14,8 +14,8 @@ public class ReturnOp extends MethodStateOp {
 
     private final int register;
 
-    ReturnOp(BuilderInstruction instruction, int register) {
-        super(instruction);
+    ReturnOp(MethodLocation location, int register) {
+        super(location);
 
         this.register = register;
     }

File: smalivm/src/main/java/org/cf/smalivm/opcode/ReturnVoidOp.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.MethodState;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -11,8 +11,8 @@ public class ReturnVoidOp extends MethodStateOp {
     @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(ReturnVoidOp.class.getSimpleName());
 
-    ReturnVoidOp(BuilderInstruction instruction) {
-        super(instruction);
+    ReturnVoidOp(MethodLocation location) {
+        super(location);
     }
 
     @Override

File: smalivm/src/main/java/org/cf/smalivm/opcode/SPutOp.java
Patch:
@@ -6,7 +6,7 @@
 import org.cf.smalivm.context.ExecutionNode;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -19,9 +19,9 @@ public class SPutOp extends ExecutionContextOp {
     private final int valueRegister;
     private final VirtualMachine vm;
 
-    public SPutOp(BuilderInstruction instruction, BuilderInstruction child, int valueRegister, String fieldDescriptor,
+    public SPutOp(MethodLocation location, MethodLocation child, int valueRegister, String fieldDescriptor,
                     VirtualMachine vm) {
-        super(instruction, child);
+        super(location, child);
 
         this.valueRegister = valueRegister;
         this.fieldDescriptor = fieldDescriptor;

File: smalivm/src/main/java/org/cf/smalivm/opcode/UnaryMathOp.java
Patch:
@@ -4,7 +4,7 @@
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
 import org.cf.util.Utils;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 
 public class UnaryMathOp extends MethodStateOp {
 
@@ -34,8 +34,8 @@ private static String getResultTypeName(String opName) {
     private final int destRegister;
     private final int srcRegister;
 
-    UnaryMathOp(BuilderInstruction instruction, BuilderInstruction child, int destRegister, int srcRegister) {
-        super(instruction, child);
+    UnaryMathOp(MethodLocation location, MethodLocation child, int destRegister, int srcRegister) {
+        super(location, child);
 
         this.destRegister = destRegister;
         this.srcRegister = srcRegister;

File: smalivm/src/test/java/org/cf/smalivm/VMTester.java
Patch:
@@ -32,7 +32,7 @@
 import org.cf.smalivm.exception.UnhandledVirtualException;
 import org.cf.smalivm.type.UnknownValue;
 import org.cf.util.Dexifier;
-import org.jf.dexlib2.builder.BuilderInstruction;
+import org.jf.dexlib2.builder.MethodLocation;
 import org.jf.dexlib2.writer.builder.DexBuilder;
 
 import com.google.common.collect.Sets;
@@ -344,15 +344,15 @@ public static void verifyExceptionHandling(VirtualException expectedException, E
                     MethodState mState) {
         verify(node).setException(eq(expectedException));
         verify(node).clearChildren();
-        verify(node, times(0)).setChildren(any(BuilderInstruction[].class));
+        verify(node, times(0)).setChildLocations(any(MethodLocation[].class));
         verify(mState, times(0)).assignRegister(any(Integer.class), any(HeapItem.class));
     }
 
     public static void verifyExceptionHandling(Set<VirtualException> expectedExceptions, ExecutionNode node,
                     MethodState mState) {
         verify(node).setExceptions(eq(expectedExceptions));
         verify(node).clearChildren();
-        verify(node, times(0)).setChildren(any(BuilderInstruction[].class));
+        verify(node, times(0)).setChildLocations(any(MethodLocation[].class));
         verify(mState, times(0)).assignRegister(any(Integer.class), any(HeapItem.class));
     }
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/TestIfOp.java
Patch:
@@ -512,14 +512,14 @@ public void testIfNotEqualZeroWithTrueIsTrue() {
             VMTester.testVisitation(CLASS_NAME, methodSignature, initial, IF_TRUE_VISITATIONS);
         }
     }
-    private static final String CLASS_NAME = "Lif_test;";
     private static final int ADDRESS_IF = 0;
     private static final int ADDRESS_NOP = 2;
-
     private static final int ADDRESS_RETURN = 3;
 
-    private static final int[] IF_TRUE_VISITATIONS = new int[] { ADDRESS_IF, ADDRESS_RETURN };
+    private static final String CLASS_NAME = "Lif_test;";
 
     private static final int[] IF_FALSE_VISITATIONS = new int[] { ADDRESS_IF, ADDRESS_NOP, ADDRESS_RETURN };
 
+    private static final int[] IF_TRUE_VISITATIONS = new int[] { ADDRESS_IF, ADDRESS_RETURN };
+
 }

File: smalivm/src/main/java/org/cf/smalivm/MethodExecutor.java
Patch:
@@ -71,13 +71,13 @@ ExecutionGraph execute(ExecutionGraph graph) throws MaxAddressVisitsExceeded, Ma
 
             try {
                 currentNode.execute();
-            } catch (Exception ex) {
+            } catch (Exception e) {
                 // TODO: this exception handler should be REMOVED when ops set exceptions properly
                 // These exceptions could be from bugs in simplify, not real exceptions
                 if (log.isWarnEnabled()) {
-                    log.warn("{} generated a real exception: {}", currentNode, ex);
+                    log.warn("{} generated a real exception:", currentNode, e);
                 }
-                int childAddress = exceptionResolver.resolve(ex, currentNode.getAddress());
+                int childAddress = exceptionResolver.resolve(e, currentNode.getAddress());
                 spawnChild(graph, currentNode, childAddress);
             }
 

File: smalivm/src/main/java/org/cf/smalivm/emulate/MethodEmulator.java
Patch:
@@ -84,7 +84,7 @@ public void emulate() {
             }
         } catch (Exception e) {
             if (log.isWarnEnabled()) {
-                log.warn("Unexpected real excetion emulating " + methodDescriptor, e);
+                log.warn("Unexpected real exception emulating " + methodDescriptor, e);
             }
         }
     }

File: simplify/src/main/java/org/cf/simplify/strategy/ReflectionRemovalStrategy.java
Patch:
@@ -203,7 +203,6 @@ List<BuilderInstruction> buildMethodInvokeReplacement(int address) throws Except
             parameterRegisterCount = Utils.getRegisterSize(methodDef.getParameterTypes());
             methodRef = mbgraph.getDexBuilder().internMethodReference(methodDef);
         }
-        // TODO: easy - replace bitwise logic with Modifier.isStatic(int mod)
         boolean isStatic = Modifier.isStatic(methodAccessFlags);
         int invokeRegisterCount = parameterRegisterCount + (isStatic ? 0 : 1);
 

File: smalivm/src/main/java/org/cf/smalivm/context/StackTraceElement.java
Patch:
@@ -12,7 +12,7 @@ public class StackTraceElement {
     public StackTraceElement(String methodDescriptor, String fileName, int lineNumber) {
         String[] parts = methodDescriptor.split("->");
         definingClass = SmaliClassUtils.smaliClassToJava(parts[0]);
-        methodName = parts[1].split("(")[0];
+        methodName = parts[1].split("\\(")[0];
         this.fileName = fileName;
         this.lineNumber = lineNumber;
     }

File: smalivm/src/main/java/org/cf/smalivm/type/UninitializedInstance.java
Patch:
@@ -16,15 +16,15 @@ public boolean equals(Object other) {
             return false;
         } else if (other == this) {
             return true;
-        } else if (!(other instanceof UninitializedInstance)) {
+        } else if (other.getClass() != getClass()) {
             return false;
         }
-
         UninitializedInstance rhs = (UninitializedInstance) other;
 
         return new EqualsBuilder().append(smaliType, rhs.getName()).isEquals();
     }
 
+    @Override
     public String getName() {
         return smaliType;
     }
@@ -33,4 +33,5 @@ public String getName() {
     public String toString() {
         return "Uninitialized " + smaliType;
     }
+    
 }

File: smalivm/src/main/java/org/cf/util/SmaliFileFactory.java
Patch:
@@ -52,7 +52,7 @@ public boolean isSafeFrameworkClass(String className) {
         return smaliFile.isSafeFrameworkClass();
     }
 
-    private void cacheFramework() throws IOException {
+    private synchronized void cacheFramework() throws IOException {
         if (frameworkCache != null) {
             return;
         }
@@ -76,8 +76,8 @@ private void cacheFramework() throws IOException {
             long endTime = System.currentTimeMillis();
             long totalTime = endTime - startTime; // assuming time has not gone backwards
             StringBuilder sb = new StringBuilder();
-            sb.append("Cached ").append(frameworkCache.size()).append(" framework classes in ")
-                            .append(totalTime).append(" ms.");
+            sb.append("Cached ").append(frameworkCache.size()).append(" framework classes in ").append(totalTime)
+                            .append(" ms.");
             log.debug(sb.toString());
         }
     }

File: smalivm/src/test/java/org/cf/smalivm/opcode/TestFilledNewArray.java
Patch:
@@ -209,7 +209,7 @@ public void setUp() {
 
             Reference ref = new ImmutableTypeReference("[I");
             when(((ReferenceInstruction) instruction).getReference()).thenReturn(ref);
-
+            node = mock(ExecutionNode.class);
             mState = mock(MethodState.class);
         }
 

File: simplify/src/main/java/org/cf/simplify/strategy/PeepholeStrategy.java
Patch:
@@ -148,7 +148,7 @@ BuilderInstruction buildClassForNameReplacement(int address) {
         String javaClassName = (String) mbgraph.getRegisterConsensusValue(address, register);
         String smaliClassName = SmaliClassUtils.javaClassToSmali(javaClassName);
         HeapItem klazz = mbgraph.getRegisterConsensus(address, MethodState.ResultRegister);
-        if (klazz.isUnknown()) {
+        if (klazz == null) {
             log.warn("Optimizing Class.forName of potentially non-existant class: " + smaliClassName);
         }
         BuilderTypeReference classRef = mbgraph.getDexBuilder().internTypeReference(smaliClassName);

File: simplify/src/test/java/org/cf/simplify/strategy/TestPeepholeStrategy.java
Patch:
@@ -56,7 +56,7 @@ private void testForExpectedInstruction(String register0, String expectedClassNa
 
         @Test
         public void testInvokeClassForNameForImaginaryClassIsReplaced() {
-            testForExpectedInstruction("com.funky.unknown.class", "Lcom/funky/unknown/class;");
+            testForExpectedInstruction("com.funky.imaginary.class", "Lcom/funky/imaginary/class;");
         }
 
         @Test

File: smalivm/src/test/java/org/cf/smalivm/emulate/Test_java_lang_Class_forName.java
Patch:
@@ -108,7 +108,7 @@ public void testUnknownClassNameThrowsExceptionAndAssignsNothing() throws Except
         method.execute(vm, ectx);
 
         Set<VirtualException> expectedExceptions = new HashSet<VirtualException>();
-        expectedExceptions.add(new VirtualException(ClassNotFoundException.class, CLASS_TYPE));
+        expectedExceptions.add(new VirtualException(ClassNotFoundException.class, UNKNOWN_CLASS_NAME_SMALI));
         assertEquals(expectedExceptions, method.getExceptions());
         verify(mState, times(0)).assignReturnRegister(any(UnknownValue.class), eq(CLASS_TYPE));
         assertEquals(SideEffect.Level.NONE, method.getSideEffectLevel());

File: smalivm/src/main/java/org/cf/smalivm/VirtualMachine.java
Patch:
@@ -217,6 +217,7 @@ public void updateInstructionGraph(String methodDescriptor) {
 
     public void addTemplateClassState(ExecutionContext ectx, String className) {
         List<String> fieldNameAndTypes = classManager.getFieldNameAndTypes(className);
+        // https://github.com/CalebFenton/simplify/issues/36
         ClassState cState = new ClassState(ectx, className, fieldNameAndTypes.size());
         ectx.setClassState(className, cState, SideEffect.Level.NONE);
         for (String fieldNameAndType : fieldNameAndTypes) {

File: smalivm/src/main/java/org/cf/smalivm/opcode/FillArrayDataPayloadOp.java
Patch:
@@ -87,6 +87,7 @@ public int[] execute(MethodState mState) {
 
         int returnAddress = mState.getParent().getPseudoInstructionReturnAddress();
 
+        setChildren(returnAddress);
         return new int[] { returnAddress };
     }
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/TestAGetOp.java
Patch:
@@ -108,7 +108,7 @@ public void nullPointerExceptionIsCaughtAndHasNoChildrenAndAssignsNoRegisters()
             int[] children = op.execute(mState);
 
             VirtualException[] expectedExceptions = new VirtualException[] { new VirtualException(
-                            SmaliClassUtils.javaClassToSmali(ArrayIndexOutOfBoundsException.class)) };
+                            SmaliClassUtils.javaClassToSmali(NullPointerException.class)) };
             assertArrayEquals(expectedExceptions, op.getExceptions());
 
             assertArrayEquals(new int[0], children);

File: simplify/src/main/java/org/cf/simplify/OptionBean.java
Patch:
@@ -26,10 +26,10 @@ public class OptionBean implements Serializable {
     private int maxCallDepth = 50;
 
     @Option(name = "--max-address-visits", usage = "Maximum visits of particular address. Raise for long loops.")
-    private int maxAddressVisits = 10000;
+    private int maxAddressVisits = 5000;
 
     @Option(name = "--max-method-visits", usage = "Maximum visits over all addresses in method. Higher for longer methods + loops.")
-    private int maxMethodVisits = maxAddressVisits * 200;
+    private int maxMethodVisits = maxAddressVisits * 20;
 
     @Option(name = "--max-passes", usage = "Limit optimization passes.")
     private int maxOptimizationPasses = 100;

File: smalivm/src/main/java/org/cf/smalivm/opcode/FillArrayDataPayloadOp.java
Patch:
@@ -6,7 +6,6 @@
 import org.apache.commons.lang3.ClassUtils;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
-import org.cf.util.SmaliClassUtils;
 import org.jf.dexlib2.iface.instruction.Instruction;
 import org.jf.dexlib2.iface.instruction.formats.ArrayPayload;
 import org.slf4j.Logger;
@@ -83,8 +82,7 @@ public int[] execute(MethodState mState) {
                 Array.set(array, i, value);
             }
             // Poke rather than assign for the optimizer.
-            String type = SmaliClassUtils.javaClassToSmali(expectedClass);
-            mState.pokeRegister(targetRegister, arrayItem, type);
+            mState.pokeRegister(targetRegister, arrayItem);
         }
 
         int returnAddress = mState.getParent().getPseudoInstructionReturnAddress();

File: demoapp/src/main/java/org/cf/demoapp/java_io_PrintStream_println.java
Patch:
@@ -4,9 +4,9 @@
 import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.HeapItem;
 import org.cf.smalivm.context.MethodState;
-import org.cf.smalivm.emulate.EmulatedMethod;
+import org.cf.smalivm.emulate.MethodStateMethod;
 
-public class java_io_PrintStream_println implements EmulatedMethod {
+public class java_io_PrintStream_println implements MethodStateMethod {
 
     @Override
     public void execute(VirtualMachine vm, MethodState mState) {

File: smalivm/src/main/java/org/cf/smalivm/emulate/java_lang_Class_getMethod.java
Patch:
@@ -17,7 +17,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class java_lang_Class_getMethod implements EmulatedMethod {
+public class java_lang_Class_getMethod implements MethodStateMethod {
 
     private static final Logger log = LoggerFactory.getLogger(java_lang_Class_getMethod.class.getSimpleName());
 

File: smalivm/src/main/java/org/cf/smalivm/emulate/java_lang_Class_getPackage.java
Patch:
@@ -10,7 +10,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class java_lang_Class_getPackage implements EmulatedMethod {
+public class java_lang_Class_getPackage implements MethodStateMethod {
 
     @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(java_lang_Class_getPackage.class.getSimpleName());

File: smalivm/src/main/java/org/cf/smalivm/emulate/java_lang_Package_getName.java
Patch:
@@ -9,7 +9,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class java_lang_Package_getName implements EmulatedMethod {
+public class java_lang_Package_getName implements MethodStateMethod {
 
     @SuppressWarnings("unused")
     private static final Logger log = LoggerFactory.getLogger(java_lang_Package_getName.class.getSimpleName());

File: smalivm/src/main/java/org/cf/smalivm/emulate/org_cf_simplify_Utils_breakpoint.java
Patch:
@@ -6,7 +6,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class org_cf_simplify_Utils_breakpoint implements EmulatedMethod {
+public class org_cf_simplify_Utils_breakpoint implements MethodStateMethod {
 
     private static final Logger log = LoggerFactory.getLogger(org_cf_simplify_Utils_breakpoint.class.getSimpleName());
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/NewArrayOp.java
Patch:
@@ -61,7 +61,7 @@ public int[] execute(MethodState mState) {
         } else {
             int dimension = dimensionItem.getIntegerValue();
             try {
-                // TODO: easy, determine if dalvik clinit's classes on new-array
+                // Dalvik does not statically initialize classes because of new-array
                 Object instance = Utils.getArrayInstanceFromSmaliTypeReference(arrayType, dimension, useLocalClass);
                 instanceItem = new HeapItem(instance, arrayType);
             } catch (ClassNotFoundException e) {

File: smalivm/src/test/java/org/cf/smalivm/emulate/Test_java_lang_Class_getMethod.java
Patch:
@@ -17,7 +17,7 @@
 @RunWith(Enclosed.class)
 public class Test_java_lang_Class_getMethod {
 
-    private static final EmulatedMethod emulatedMethod = new java_lang_Class_getMethod();
+    private static final MethodStateMethod emulatedMethod = new java_lang_Class_getMethod();
     private static final String METHOD_TYPE = "Ljava/lang/reflect/Method;";
 
     private static MethodState getMethodState(VirtualMachine vm, Object klazz, String methodName,

File: smalivm/src/test/java/org/cf/smalivm/emulate/Test_java_lang_Class_getPackage.java
Patch:
@@ -15,7 +15,7 @@
 
 public class Test_java_lang_Class_getPackage {
 
-    private static EmulatedMethod emulatedMethod = new java_lang_Class_getPackage();
+    private static MethodStateMethod emulatedMethod = new java_lang_Class_getPackage();
 
     private VirtualMachine vm;
 

File: smalivm/src/main/java/org/cf/smalivm/SmaliClassManager.java
Patch:
@@ -258,10 +258,9 @@ public boolean methodHasImplementation(String methodDescriptor) {
     }
 
     /**
-     * Return whether a method is native or not
      * 
      * @param methodDescriptor
-     * @return
+     * @return true if method is native, false otherwise
      */
     public boolean methodIsNative(String methodDescriptor) {
         BuilderMethod method = getMethod(methodDescriptor);

File: simplify/src/main/java/org/cf/simplify/strategy/DeadRemovalStrategy.java
Patch:
@@ -188,9 +188,6 @@ private boolean isDeadAssignment(int address) {
             log.debug("Read assignments test @" + address + " for: " + op);
         }
 
-        if (address == 130) {
-            System.out.println("wtf");
-        }
         if (isAnyRegisterUsed(address, assigned, mbgraph)) {
             return false;
         }

File: simplify/src/main/java/org/cf/simplify/MethodBackedGraph.java
Patch:
@@ -91,7 +91,7 @@ public MethodBackedGraph(ExecutionGraph graph, BuilderMethod method, VirtualMach
         implementation = (MutableMethodImplementation) method.getImplementation();
         addressToInstruction = buildAddressToInstruction(implementation.getInstructions());
         this.vm = vm;
-        opFactory = new OpFactory(vm, methodDescriptor);
+        opFactory = new OpFactory(vm);
     }
 
     public TIntObjectMap<BuilderInstruction> getAddressToInstruction() {

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGraph.java
Patch:
@@ -35,8 +35,8 @@ public class ExecutionGraph implements Iterable<ExecutionNode> {
     protected static final int METHOD_ROOT_ADDRESS = 0;
 
     private static TIntObjectMap<List<ExecutionNode>> buildAddressToNodePile(VirtualMachine vm,
-                    String methodDescriptor, List<BuilderInstruction> instructions) {
-        OpFactory opFactory = new OpFactory(vm, methodDescriptor);
+                    List<BuilderInstruction> instructions) {
+        OpFactory opFactory = new OpFactory(vm);
         TIntObjectMap<List<ExecutionNode>> result = new TIntObjectHashMap<List<ExecutionNode>>();
         for (BuilderInstruction instruction : instructions) {
             int address = instruction.getLocation().getCodeAddress();
@@ -99,7 +99,7 @@ public ExecutionGraph(VirtualMachine vm, BuilderMethod method) {
         methodDescriptor = ReferenceUtil.getMethodDescriptor(method);
         MutableMethodImplementation implementation = (MutableMethodImplementation) method.getImplementation();
         List<BuilderInstruction> instructions = implementation.getInstructions();
-        addressToNodePile = buildAddressToNodePile(vm, methodDescriptor, instructions);
+        addressToNodePile = buildAddressToNodePile(vm, instructions);
         terminatingAddresses = buildTerminatingAddresses(instructions);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/OpFactory.java
Patch:
@@ -362,7 +362,7 @@ private static OpType getFactoryType(Opcode op) {
 
     private final VirtualMachine vm;
 
-    public OpFactory(VirtualMachine vm, String methodDescriptor) {
+    public OpFactory(VirtualMachine vm) {
         this.vm = vm;
     }
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/TestBinaryMathOp.java
Patch:
@@ -41,7 +41,7 @@ public void setUp() {
             mockBi = mock(BuilderInstruction.class,
                             withSettings().extraInterfaces(TwoRegisterInstruction.class, Instruction23x.class));
 
-            opFactory = new OpFactory(mockVm, null);
+            opFactory = new OpFactory(mockVm);
 
         }
 

File: simplify/src/main/java/org/cf/simplify/MethodBackedGraph.java
Patch:
@@ -91,7 +91,7 @@ public MethodBackedGraph(ExecutionGraph graph, BuilderMethod method, VirtualMach
         implementation = (MutableMethodImplementation) method.getImplementation();
         addressToInstruction = buildAddressToInstruction(implementation.getInstructions());
         this.vm = vm;
-        opFactory = new OpFactory(vm, methodDescriptor);
+        opFactory = new OpFactory(vm);
     }
 
     public TIntObjectMap<BuilderInstruction> getAddressToInstruction() {

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGraph.java
Patch:
@@ -35,8 +35,8 @@ public class ExecutionGraph implements Iterable<ExecutionNode> {
     protected static final int METHOD_ROOT_ADDRESS = 0;
 
     private static TIntObjectMap<List<ExecutionNode>> buildAddressToNodePile(VirtualMachine vm,
-                    String methodDescriptor, List<BuilderInstruction> instructions) {
-        OpFactory opFactory = new OpFactory(vm, methodDescriptor);
+                    List<BuilderInstruction> instructions) {
+        OpFactory opFactory = new OpFactory(vm);
         TIntObjectMap<List<ExecutionNode>> result = new TIntObjectHashMap<List<ExecutionNode>>();
         for (BuilderInstruction instruction : instructions) {
             int address = instruction.getLocation().getCodeAddress();
@@ -99,7 +99,7 @@ public ExecutionGraph(VirtualMachine vm, BuilderMethod method) {
         methodDescriptor = ReferenceUtil.getMethodDescriptor(method);
         MutableMethodImplementation implementation = (MutableMethodImplementation) method.getImplementation();
         List<BuilderInstruction> instructions = implementation.getInstructions();
-        addressToNodePile = buildAddressToNodePile(vm, methodDescriptor, instructions);
+        addressToNodePile = buildAddressToNodePile(vm, instructions);
         terminatingAddresses = buildTerminatingAddresses(instructions);
     }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/OpFactory.java
Patch:
@@ -362,7 +362,7 @@ private static OpType getFactoryType(Opcode op) {
 
     private final VirtualMachine vm;
 
-    public OpFactory(VirtualMachine vm, String methodDescriptor) {
+    public OpFactory(VirtualMachine vm) {
         this.vm = vm;
     }
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/TestBinaryMathOp.java
Patch:
@@ -41,7 +41,7 @@ public void setUp() {
             mockBi = mock(BuilderInstruction.class,
                             withSettings().extraInterfaces(TwoRegisterInstruction.class, Instruction23x.class));
 
-            opFactory = new OpFactory(mockVm, null);
+            opFactory = new OpFactory(mockVm);
 
         }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/FillArrayDataPayloadOp.java
Patch:
@@ -71,7 +71,7 @@ private FillArrayDataPayloadOp(int address, String opName, int elementWidth, Lis
     @Override
     public int[] execute(MethodState mState) {
         MethodState parent = mState.getParent();
-        int register = parent.getRegistersAssigned().get(0);
+        int register = parent.getRegistersAssigned().toArray()[0];
         // Peek rather than read. This pseudo-instruction shouldn't count as an actual usage for the optimizer.
         Object array = mState.peekRegister(register);
         if (!(array instanceof UnknownValue)) {

File: simplify/src/main/java/org/cf/simplify/ConstantBuilder.java
Patch:
@@ -27,7 +27,7 @@
 import org.jf.dexlib2.writer.builder.BuilderTypeReference;
 import org.jf.dexlib2.writer.builder.DexBuilder;
 
-public class ConstantBuilder {
+public class ConstantBuilder implements Dependancy {
 
     private static final String LAST_16_BITS_ZERO = "0000000000000000";
     private static final String LAST_48_BITS_ZERO = "000000000000000000000000000000000000000000000000";
@@ -38,11 +38,11 @@ public class ConstantBuilder {
     private static final Set<String> ConstantizableTypes = new HashSet<String>(Arrays.asList("I", "Z", "B", "S", "C",
                     "J", "F", "D", "Ljava/lang/String;", "Ljava/lang/Class;"));
 
-    public static boolean canConstantizeOp(Op op) {
+    public boolean canConstantizeOp(Op op) {
         return ConstantizableOps.contains(op.getClass());
     }
 
-    public static boolean canConstantizeType(String type) {
+    public boolean canConstantizeType(String type) {
         return ConstantizableTypes.contains(type);
     }
 

File: simplify/src/main/java/org/cf/simplify/strategy/DeadRemovalStrategy.java
Patch:
@@ -18,6 +18,7 @@
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.opcode.GotoOp;
 import org.cf.smalivm.opcode.InvokeOp;
+import org.cf.smalivm.opcode.NopOp;
 import org.cf.smalivm.opcode.Op;
 import org.jf.dexlib2.builder.BuilderExceptionHandler;
 import org.jf.dexlib2.builder.BuilderInstruction;
@@ -274,8 +275,7 @@ TIntList getValidAddresses(MethodBackedGraph mbgraph) {
                 continue;
             }
 
-            // TODO: replace with class ref when implemented
-            if (op.getName().equals("nop")) {
+            if (op instanceof NopOp) {
                 // Usually, the only reason a nop exists is because it was generated by the compiler.
                 // Most decompilers are smart enough to deal with them.
                 validAddresses.remove(address);

File: smalivm/src/main/java/org/cf/smalivm/opcode/CheckCastOp.java
Patch:
@@ -51,7 +51,7 @@ public int[] execute(MethodState mState) {
 
         try {
             if (!vm.getClassManager().isInstance(type, className)) {
-                // TODO: exception should be filled with spoofed stack trace
+                // TODO: https://github.com/CalebFenton/simplify/issues/12
                 // throw new ClassCastException("Class - " + className);
             }
         } catch (UnknownAncestors e) {

File: smalivm/src/main/java/org/cf/smalivm/opcode/IGetOp.java
Patch:
@@ -46,8 +46,7 @@ public IGetOp(int address, String opName, int childAddress, int destRegister, in
 
     @Override
     public int[] execute(ExecutionContext ectx) {
-        // TODO: build option to allow instance member lookups
-        // disabled because fidelity concerns, i.e. they may have been modified by another thread
+        // TODO: https://github.com/CalebFenton/simplify/issues/22
         MethodState mState = ectx.getMethodState();
         mState.readRegister(instanceRegister);
         String type = fieldDescriptor.split(":")[1];

File: smalivm/src/main/java/org/cf/smalivm/opcode/IPutOp.java
Patch:
@@ -48,9 +48,6 @@ public IPutOp(int address, String opName, int childAddress, int valueRegister, i
     public int[] execute(ExecutionContext ectx) {
         MethodState mState = ectx.getMethodState();
         Object value = mState.readRegister(valueRegister);
-
-        // TODO: make option to allow instance variable mutation
-        // for now, just mark it read and assigned for the optimizer
         Object instance = mState.readRegister(instanceRegister);
 
         return getPossibleChildren();

File: smalivm/src/main/java/org/cf/smalivm/opcode/MoveOp.java
Patch:
@@ -67,7 +67,6 @@ private MoveOp(int address, String opName, int childAddress, int toRegister, Mov
     public int[] execute(MethodState mState) {
         switch (moveType) {
         case EXCEPTION:
-            // TODO: implement with try/catch stuff?
             moveException(mState, toRegister);
             break;
         case RESULT:

File: smalivm/src/main/java/org/cf/smalivm/opcode/OpFactory.java
Patch:
@@ -263,7 +263,7 @@ private static OpType getFactoryType(Opcode op) {
             break;
 
         case INSTANCE_OF:
-            // TODO: implement
+            // TODO: https://github.com/CalebFenton/simplify/issues/2
             break;
 
         case INVOKE_DIRECT:
@@ -353,7 +353,7 @@ private static OpType getFactoryType(Opcode op) {
             break;
 
         case THROW:
-            // TODO: implement
+            // TODO: https://github.com/CalebFenton/simplify/issues/8
             break;
         }
 
@@ -416,7 +416,7 @@ public Op create(BuilderInstruction instruction, int address) {
             result = FillArrayDataOp.create(instruction, address);
             break;
         case INSTANCE_OF:
-            // TODO: implement
+            // TODO: https://github.com/CalebFenton/simplify/issues/2
             break;
         case INVOKE:
             result = InvokeOp.create(instruction, address, vm);

File: smalivm/src/test/java/org/cf/smalivm/emulate/Test_java_lang_Class_getMethod.java
Patch:
@@ -64,7 +64,8 @@ public void testGetExistantMethodWithOneParameterTypesReturnsExpectedLocalMethod
 
         @Test
         public void testGetNonExistantMethodReturnsUnknownValue() throws Exception {
-            // TODO: should return unknown value and also say it "may" have thrown an exception
+            // TODO: https://github.com/CalebFenton/simplify/issues/5
+            // should return unknown value and also say it "may" have thrown an exception
             MethodState mState = getMethodState(vm, CLASS, "yoDawgThisMethodWillNeverExist", null);
             emulatedMethod.execute(vm, mState);
             Object expected = new UnknownValue("Ljava/lang/reflect/Method;");

File: simplify/src/main/java/org/cf/simplify/strategy/PeepholeStrategy.java
Patch:
@@ -6,6 +6,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import org.cf.simplify.ConstantBuilder;
 import org.cf.simplify.MethodBackedGraph;
 import org.cf.smalivm.opcode.InvokeOp;
 import org.cf.smalivm.opcode.Op;
@@ -118,7 +119,7 @@ void peepStringInit() {
             Instruction35c instr = (Instruction35c) original;
             int instanceRegister = instr.getRegisterC();
             Object value = mbgraph.getRegisterConsensus(address, instanceRegister);
-            BuilderInstruction replacement = ConstantPropigationStrategy.buildConstant(value, instanceRegister,
+            BuilderInstruction replacement = ConstantBuilder.buildConstant(value, instanceRegister,
                             mbgraph.getDexBuilder());
             if (log.isDebugEnabled()) {
                 log.debug("Peeping string init @" + address + " " + mbgraph.getOp(address));

File: simplify/src/main/java/org/cf/simplify/strategy/ReflectionRemovalStrategy.java
Patch:
@@ -10,6 +10,7 @@
 import java.util.List;
 import java.util.Map;
 
+import org.cf.simplify.ConstantBuilder;
 import org.cf.simplify.MethodBackedGraph;
 import org.cf.smalivm.SmaliClassManager;
 import org.cf.smalivm.opcode.InvokeOp;
@@ -107,7 +108,7 @@ private List<BuilderInstruction> getArrayAccessorInstructions(int arrayRegister,
         List<BuilderInstruction> instructions = new LinkedList<BuilderInstruction>();
         for (int index = 0; index < parameterTypes.size(); index++) {
             int register = registers.get(index);
-            BuilderInstruction constInstruction = ConstantPropigationStrategy.buildConstant(index, register);
+            BuilderInstruction constInstruction = ConstantBuilder.buildConstant(index, register);
             BuilderInstruction arrayGet = new BuilderInstruction23x(Opcode.AGET_OBJECT, register, arrayRegister,
                             register);
             String typeName = parameterTypes.get(index);

File: simplify/src/main/java/org/cf/simplify/strategy/DeadRemovalStrategy.java
Patch:
@@ -33,7 +33,7 @@ public class DeadRemovalStrategy implements OptimizationStrategy {
     private static final SideEffect.Level SIDE_EFFECT_THRESHOLD = SideEffect.Level.WEAK;
 
     private static boolean areRegistersRead(int address, TIntList registerList, MethodBackedGraph graph) {
-        Deque<ExecutionNode> stack = new ArrayDeque<ExecutionNode>(graph.getChildrenAtAddress(address));
+        Deque<ExecutionNode> stack = new ArrayDeque<ExecutionNode>(graph.getChildren(address));
         ExecutionNode node;
         int[] registers = registerList.toArray();
         while ((node = stack.poll()) != null) {

File: simplify/src/test/java/org/cf/simplify/OptimizerTester.java
Patch:
@@ -31,9 +31,10 @@ public static MethodBackedGraph getMethodBackedGraph(String className, String me
                     TIntObjectMap<Object> initial, Map<String, Map<String, Object>> classNameToFieldValue) {
         VirtualMachine vm = VMTester.getTestVM();
         String methodDescriptor = className + "->" + methodSignature;
+        ExecutionGraph graph = VMTester.execute(vm, className, methodSignature, initial, classNameToFieldValue);
+
         BuilderMethod method = vm.getClassManager().getMethod(methodDescriptor);
         DexBuilder dexBuilder = VMTester.getDexBuilder();
-        ExecutionGraph graph = VMTester.execute(vm, className, methodSignature, initial, classNameToFieldValue);
 
         return new MethodBackedGraph(graph, method, vm, dexBuilder);
     }

File: smalivm/src/main/java/org/cf/smalivm/context/Heap.java
Patch:
@@ -16,7 +16,6 @@ class Heap {
 
     private static final Logger log = LoggerFactory.getLogger(Heap.class.getSimpleName());
 
-    // TODO: add immutable classes to cloner so it avoids cloning them
     private static final Cloner cloner = new Cloner();
 
     private final Map<String, Object> keyToValue;

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOp.java
Patch:
@@ -291,7 +291,7 @@ private ExecutionContext buildLocalCalleeContext(String methodDescriptor, Execut
 
     private MethodState buildNonLocalCalleeContext(MethodState callerMethodState) {
         ExecutionContext ectx = new ExecutionContext(vm);
-        int parameterSize = VirtualMachine.getParameterSize(parameterTypes);
+        int parameterSize = Utils.getRegisterSize(parameterTypes);
         int registerCount = parameterSize;
         MethodState calleeMethodState = new MethodState(ectx, registerCount, parameterTypes.size(), parameterSize);
         assignCalleeMethodStateParameters(callerMethodState, calleeMethodState);
@@ -345,8 +345,8 @@ private void executeNonLocalMethod(String methodDescriptor, MethodState callerCo
         }
 
         if (!"V".equals(returnType)) {
-            Object returnRegister = calleeContext.readReturnRegister();
-            callerContext.assignResultRegister(returnRegister);
+            Object returnValue = calleeContext.readReturnRegister();
+            callerContext.assignResultRegister(returnValue);
         }
     }
 

File: smalivm/src/main/java/org/cf/smalivm/opcode/MoveOp.java
Patch:
@@ -24,10 +24,12 @@ private static void moveRegister(MethodState mState, int toRegister, int fromReg
         Object value = mState.readRegister(fromRegister);
         mState.assignRegister(toRegister, value);
     }
+
     private static void moveResult(MethodState mState, int toRegister) {
         Object value = mState.readResultRegister();
         mState.assignRegister(toRegister, value);
     }
+
     static MoveOp create(Instruction instruction, int address) {
         String opName = instruction.getOpcode().name;
         int childAddress = address + instruction.getCodeUnits();
@@ -47,9 +49,7 @@ static MoveOp create(Instruction instruction, int address) {
     }
 
     private final MoveType moveType;
-
     private int targetRegister;
-
     private final int toRegister;
 
     private MoveOp(int address, String opName, int nextInstructionAddress, int toRegister, int targetRegister) {

File: smalivm/src/main/java/org/cf/util/ImmutableUtils.java
Patch:
@@ -33,12 +33,12 @@ private static void loadImmutableClasses() {
 
     public static boolean isImmutableClass(String smaliClassName) {
         if (smaliClassName.startsWith("[")) {
-            // Array elements can always be mutated
+            // Array contents can always be mutated
             return false;
         }
 
         if (smaliClassName.equals("?")) {
-            // Unknown type. Was probably lazy somewhere and didn't get implied type.
+            // Unknown type. Probably lazy and didn't get implied type.
             return false;
         }
 

File: demoapp/src/main/java/org/cf/demoapp/java_io_PrintStream_println.java
Patch:
@@ -1,13 +1,14 @@
 package org.cf.demoapp;
 
 import org.cf.smalivm.SideEffect;
+import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.emulate.EmulatedMethod;
 
 public class java_io_PrintStream_println implements EmulatedMethod {
 
     @Override
-    public void execute(MethodState mState) {
+    public void execute(VirtualMachine vm, MethodState mState) {
         // Virtual method, register 0 is System.out (or something else)
         Object value = mState.peekParameter(1);
         String valueStr = (String) value;

File: smalivm/src/main/java/org/cf/smalivm/emulate/EmulatedMethod.java
Patch:
@@ -1,11 +1,12 @@
 package org.cf.smalivm.emulate;
 
 import org.cf.smalivm.SideEffect.Level;
+import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.MethodState;
 
 public interface EmulatedMethod {
 
-    public void execute(MethodState mState) throws Exception;
+    public void execute(VirtualMachine vm, MethodState mState) throws Exception;
 
     public Level getSideEffectLevel();
 

File: smalivm/src/main/java/org/cf/smalivm/emulate/java_lang_Class_forName.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.cf.smalivm.MethodReflector;
 import org.cf.smalivm.SideEffect;
+import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.type.UnknownValue;
 import org.cf.util.SmaliClassUtils;
@@ -12,7 +13,7 @@ public class java_lang_Class_forName implements EmulatedMethod {
 
     private static final Logger log = LoggerFactory.getLogger(java_lang_Class_forName.class.getSimpleName());
 
-    public void execute(MethodState mState) throws Exception {
+    public void execute(VirtualMachine vm, MethodState mState) throws Exception {
         // No checks because emulated methods require all known args.
         String javaClassName = (String) mState.peekParameter(0);
         String className = SmaliClassUtils.javaClassToSmali(javaClassName);

File: smalivm/src/main/java/org/cf/smalivm/emulate/java_lang_Package_getName.java
Patch:
@@ -1,6 +1,7 @@
 package org.cf.smalivm.emulate;
 
 import org.cf.smalivm.SideEffect;
+import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.type.EmulatedType;
 import org.cf.smalivm.type.UnknownValue;
@@ -11,7 +12,7 @@ public class java_lang_Package_getName implements EmulatedMethod {
 
     private static final Logger log = LoggerFactory.getLogger(java_lang_Package_getName.class.getSimpleName());
 
-    public void execute(MethodState mState) throws Exception {
+    public void execute(VirtualMachine vm, MethodState mState) throws Exception {
         // No checks because emulated methods require all known args.
         Object instance = mState.peekParameter(0);
         Object value = new UnknownValue("Ljava/lang/String;");

File: smalivm/src/main/java/org/cf/smalivm/emulate/org_cf_simplify_Utils_breakpoint.java
Patch:
@@ -1,6 +1,7 @@
 package org.cf.smalivm.emulate;
 
 import org.cf.smalivm.SideEffect;
+import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.MethodState;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -9,7 +10,7 @@ public class org_cf_simplify_Utils_breakpoint implements EmulatedMethod {
 
     private static final Logger log = LoggerFactory.getLogger(org_cf_simplify_Utils_breakpoint.class.getSimpleName());
 
-    public void execute(MethodState mState) {
+    public void execute(VirtualMachine vm, MethodState mState) {
         // To use, add invoke-static {}, Lorg/cf/simplify/Utils;->breakpoint()V, and set a breakpoint here.
         log.trace("For a good time, set a breakpoint here!");
     }

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOp.java
Patch:
@@ -321,7 +321,7 @@ private void executeLocalMethod(String methodDescriptor, ExecutionContext caller
     private void executeNonLocalMethod(String methodDescriptor, MethodState callerContext, MethodState calleeContext) {
         assert allArgumentsKnown(calleeContext);
         if (MethodEmulator.canEmulate(methodDescriptor)) {
-            sideEffectLevel = MethodEmulator.emulate(calleeContext, methodDescriptor, getParameterRegisters());
+            sideEffectLevel = MethodEmulator.emulate(vm, calleeContext, methodDescriptor, getParameterRegisters());
         } else if (MethodReflector.canReflect(methodDescriptor)) {
             MethodReflector reflector = new MethodReflector(methodDescriptor, returnType, parameterTypes, isStatic);
             reflector.reflect(calleeContext); // playa play

File: smalivm/src/main/java/org/cf/smalivm/context/MethodState.java
Patch:
@@ -77,7 +77,7 @@ public void pokeRegister(int register, Object value) {
     }
 
     public Object readRegister(int register) {
-        return super.readRegister(register, METHOD_HEAP);
+        return readRegister(register, METHOD_HEAP);
     }
 
     public Object peekParameter(int parameterRegister) {
@@ -114,7 +114,6 @@ public Object peekRegister(int register) {
 
     public Object readResultRegister() {
         Object result = readRegister(ResultRegister, METHOD_HEAP);
-        // TODO: removeRegister and see what breaks..
         ectx.getHeap().remove(METHOD_HEAP, ResultRegister);
 
         return result;

File: smalivm/src/main/java/org/cf/smalivm/opcode/AGetOp.java
Patch:
@@ -15,7 +15,7 @@ public class AGetOp extends MethodStateOp {
     private static final Logger log = LoggerFactory.getLogger(AGetOp.class.getSimpleName());
 
     private static String getUnknownArrayInnerType(UnknownValue array) {
-        String outerType = array.getType();
+        String outerType = array.getName();
         String result = null;
         if (outerType.equals("?")) {
             result = "?";

File: smalivm/src/main/java/org/cf/smalivm/opcode/CheckCastOp.java
Patch:
@@ -3,7 +3,7 @@
 import org.cf.smalivm.VirtualMachine;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.exception.UnknownAncestors;
-import org.cf.smalivm.type.Type;
+import org.cf.smalivm.type.LocalType;
 import org.cf.util.SmaliClassUtils;
 import org.jf.dexlib2.iface.instruction.Instruction;
 import org.jf.dexlib2.iface.instruction.formats.Instruction21c;
@@ -43,8 +43,8 @@ static CheckCastOp create(Instruction instruction, int address, VirtualMachine v
     public int[] execute(MethodState mState) {
         Object value = mState.readRegister(targetRegister);
         String type;
-        if (value instanceof Type) {
-            type = ((Type) value).getType();
+        if (value instanceof LocalType) {
+            type = ((LocalType) value).getName();
         } else {
             type = SmaliClassUtils.javaClassToSmali(value.getClass());
         }

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOp.java
Patch:
@@ -15,7 +15,7 @@
 import org.cf.smalivm.context.ExecutionGraph;
 import org.cf.smalivm.context.MethodState;
 import org.cf.smalivm.emulate.MethodEmulator;
-import org.cf.smalivm.type.Type;
+import org.cf.smalivm.type.LocalType;
 import org.cf.smalivm.type.TypeUtil;
 import org.cf.smalivm.type.UnknownValue;
 import org.cf.util.ImmutableUtils;
@@ -352,8 +352,8 @@ private void executeNonLocalMethod(String methodDescriptor, MethodState callerCo
 
     private String getLocalTargetForVirtualMethod(Object value) {
         String actualType;
-        if (value instanceof Type) {
-            actualType = ((Type) value).getType();
+        if (value instanceof LocalType) {
+            actualType = ((LocalType) value).getName();
         } else {
             actualType = SmaliClassUtils.javaClassToSmali(value.getClass().getName());
         }

File: smalivm/src/main/java/org/cf/smalivm/type/LocalInstance.java
Patch:
@@ -3,7 +3,7 @@
 import org.apache.commons.lang3.builder.EqualsBuilder;
 import org.cf.smalivm.context.InstanceState;
 
-public class LocalInstance implements Type {
+public class LocalInstance implements LocalType {
 
     private InstanceState iState;
 
@@ -34,7 +34,7 @@ public InstanceState getState() {
         return iState;
     }
 
-    public String getType() {
+    public String getName() {
         return smaliType;
     }
 

File: smalivm/src/main/java/org/cf/smalivm/type/LocalType.java
Patch:
@@ -1,8 +1,8 @@
 package org.cf.smalivm.type;
 
-public interface Type {
+public interface LocalType {
 
-    public String getType();
+    public String getName();
 
     public String toString();
 

File: smalivm/src/main/java/org/cf/smalivm/type/TypeUtil.java
Patch:
@@ -6,8 +6,8 @@ public static String getValueType(Object value) {
         String result;
         if (value == null) {
             result = "null";
-        } else if (value instanceof Type) {
-            result = ((Type) value).getType();
+        } else if (value instanceof LocalType) {
+            result = ((LocalType) value).getName();
         } else {
             result = value.getClass().getName();
         }

File: smalivm/src/main/java/org/cf/smalivm/type/UninitializedInstance.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.apache.commons.lang3.builder.EqualsBuilder;
 
-public class UninitializedInstance implements Type {
+public class UninitializedInstance implements LocalType {
 
     private final String smaliType;
 
@@ -22,10 +22,10 @@ public boolean equals(Object other) {
 
         UninitializedInstance rhs = (UninitializedInstance) other;
 
-        return new EqualsBuilder().append(smaliType, rhs.getType()).isEquals();
+        return new EqualsBuilder().append(smaliType, rhs.getName()).isEquals();
     }
 
-    public String getType() {
+    public String getName() {
         return smaliType;
     }
 

File: smalivm/src/main/java/org/cf/smalivm/type/UnknownValue.java
Patch:
@@ -1,6 +1,7 @@
 package org.cf.smalivm.type;
 
-public class UnknownValue implements Type {
+
+public class UnknownValue implements LocalType {
 
     private String smaliType;
 
@@ -14,7 +15,7 @@ public boolean equals(Object other) {
         return false;
     }
 
-    public String getType() {
+    public String getName() {
         return smaliType;
     }
 

File: smalivm/src/test/java/org/cf/smalivm/opcode/TestConstOp.java
Patch:
@@ -3,7 +3,7 @@
 import gnu.trove.map.TIntObjectMap;
 
 import org.cf.smalivm.VMTester;
-import org.cf.smalivm.type.LocalInstance;
+import org.cf.smalivm.type.LocalClass;
 import org.cf.smalivm.type.UnknownValue;
 import org.junit.Test;
 
@@ -34,7 +34,7 @@ public void testConst4() {
 
     @Test
     public void testConstClassLocal() {
-        TIntObjectMap<Object> expected = VMTester.buildRegisterState(0, new LocalInstance(CLASS_NAME));
+        TIntObjectMap<Object> expected = VMTester.buildRegisterState(0, new LocalClass(CLASS_NAME));
 
         VMTester.testMethodState(CLASS_NAME, "TestConstClassLocal()V", expected);
     }

File: simplify/src/test/java/org/cf/simplify/strategy/TestDeadRemovalStrategy.java
Patch:
@@ -24,7 +24,7 @@ public void TestDeadCodeIsRemoved() {
         DeadRemovalStrategy strategy = new DeadRemovalStrategy(mbgraph);
         TIntList found = strategy.getDeadAddresses();
         found.sort();
-        TIntList expected = new TIntArrayList(new int[] { 2, 3, 4, 5 });
+        TIntList expected = new TIntArrayList(new int[] { 2 });
 
         assertEquals(expected, found);
     }

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOp.java
Patch:
@@ -146,7 +146,7 @@ public int[] execute(ExecutionContext ectx) {
 
             SmaliClassManager classManager = vm.getClassManager();
             if (classManager.isLocalMethod(targetMethod)) {
-                ExecutionContext calleeContext = buildLocalCalleeContext(methodDescriptor, ectx);
+                ExecutionContext calleeContext = buildLocalCalleeContext(targetMethod, ectx);
                 if (classManager.methodHasImplementation(targetMethod)) {
                     executeLocalMethod(targetMethod, ectx, calleeContext);
                 } else {
@@ -188,7 +188,7 @@ public String toString() {
         sb.append(" {");
         if (getOpName().contains("/range")) {
             sb.append("r").append(parameterRegisters[0]).append(" .. r")
-            .append(parameterRegisters[parameterRegisters.length - 1]);
+                            .append(parameterRegisters[parameterRegisters.length - 1]);
         } else {
             if (parameterRegisters.length > 0) {
                 for (int register : parameterRegisters) {

File: smalivm/src/test/java/org/cf/smalivm/TestMethodInheritence.java
Patch:
@@ -48,7 +48,6 @@ public void TestInvokingParentMethodWorks() {
 
             assertEquals("parentMethod", value);
         }
-
     }
 
     public static class ParentClass {

File: smalivm/src/main/java/org/cf/smalivm/context/Heap.java
Patch:
@@ -90,9 +90,9 @@ Object get(String key) {
          */
         Heap ancestor = getAncestorWithKey(key);
         if (ancestor == null) {
-            if (log.isWarnEnabled()) {
+            if (log.isTraceEnabled()) {
                 Exception e = new Exception();
-                log.warn("Undefined value for " + key + " Possibly a mistake!", e);
+                log.trace("Undefined value for " + key + " Possibly a mistake!", e);
             }
 
             return null;

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGraph.java
Patch:
@@ -245,6 +245,7 @@ public Object getRegisterConsensus(TIntList addressList, int register) {
             if (values.size() != 1) {
                 log.trace("No conensus for register #" + register + ", returning unknown");
                 String type = SmaliClassUtils.javaClassToSmali(TypeUtil.getValueType(value));
+
                 return new UnknownValue(type);
             }
         }

File: smalivm/src/main/java/org/cf/smalivm/opcode/InvokeOp.java
Patch:
@@ -146,7 +146,7 @@ public String toString() {
         sb.append(" {");
         if (getOpName().contains("/range")) {
             sb.append("r").append(parameterRegisters[0]).append(" .. r")
-                            .append(parameterRegisters[parameterRegisters.length - 1]);
+            .append(parameterRegisters[parameterRegisters.length - 1]);
         } else {
             if (parameterRegisters.length > 0) {
                 for (int register : parameterRegisters) {
@@ -228,7 +228,7 @@ private void executeLocalMethod(String methodDescriptor, ExecutionContext caller
         ExecutionGraph graph = vm.execute(methodDescriptor, calleeContext, callerContext, parameterRegisters);
         if (graph == null) {
             // Problem executing the method. Maybe node visits or call depth exceeded?
-            log.info("Problem executing " + methodDescriptor + ", propigating ambiguity.");
+            log.info("Problem executing " + methodDescriptor + ", propagating ambiguity.");
             assumeMaximumUnknown(callerContext.getMethodState());
 
             return;

File: smalivm/src/main/java/org/cf/smalivm/context/BaseState.java
Patch:
@@ -88,13 +88,13 @@ public String peekRegisterType(int register, String heapId) {
     }
 
     public void pokeRegister(int register, Object value, String heapId) {
-        if (log.isDebugEnabled()) {
+        if (log.isTraceEnabled()) {
             StringBuilder sb = new StringBuilder();
             // StackTraceElement[] ste = Thread.currentThread().getStackTrace();
             // for (int i = 2; i < ste.length; i++) {
             // sb.append("\n\t").append(ste[i]);
             // }
-            log.debug("Setting r" + register + " = " + registerValueToString(value) + sb.toString());
+            log.trace("Setting r" + register + " = " + registerValueToString(value) + sb.toString());
         }
 
         ectx.getHeap().set(heapId, register, value);
@@ -153,7 +153,7 @@ protected String registerValueToString(Object value) {
             sb.append("type=null, value=null");
         } else {
             sb.append("type=").append(TypeUtil.getValueType(value)).append(", value=").append(value.toString())
-            .append(", hc=").append(value.hashCode());
+                            .append(", hc=").append(value.hashCode());
         }
 
         return sb.toString();

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionNode.java
Patch:
@@ -34,8 +34,8 @@ public int[] execute() {
         ExecutionContext ectx = getContext();
         if (log.isDebugEnabled()) {
             StringBuilder sb = new StringBuilder();
-            sb.append("HANDLING @").append(op.getAddress()).append(": ").append(op).append("\nContext before:\n")
-            .append(ectx);
+            sb.append("HANDLING @").append(op.getAddress()).append(": ").append(op);
+            sb.append("\nContext before:\n").append(ectx);
             log.debug(sb.toString());
         }
 

File: smalivm/src/main/java/org/cf/util/Dexifier.java
Patch:
@@ -27,7 +27,9 @@ public class Dexifier {
     private static final Logger log = LoggerFactory.getLogger(Dexifier.class.getSimpleName());
 
     public static BuilderClassDef dexifySmaliFile(File smaliFile, DexBuilder dexBuilder) throws Exception {
-        log.info("Dexifying: " + smaliFile);
+        if (log.isInfoEnabled()) {
+            log.info("Dexifying: " + smaliFile);
+        }
 
         FileInputStream fis = new FileInputStream(smaliFile.getAbsolutePath());
         InputStreamReader reader = new InputStreamReader(fis, "UTF-8");

File: simplify/src/main/java/org/cf/simplify/strategy/DeadRemovalStrategy.java
Patch:
@@ -287,9 +287,9 @@ TIntList getValidAddresses(MethodBackedGraph mbgraph) {
 
         // This is a hack to prevent handlers from being removed
         // And it's probably not a good idea to remove the last op in a method because it either returns or jumps.
-        result.removeAll(getHandlerCodeAddresses(mbgraph));
         result.sort();
         result.removeAt(result.size() - 1);
+        result.removeAll(getHandlerCodeAddresses(mbgraph));
 
         for (int address : result.toArray()) {
             Op op = mbgraph.getOp(address);

File: simplify/src/test/java/org/cf/simplify/strategy/TestDeadRemovalStrategy.java
Patch:
@@ -79,7 +79,6 @@ public void TestDeadTryCatchBlockIsRemoved() {
         MethodBackedGraph mbgraph = OptimizerTester.getMethodBackedGraph(CLASS_NAME, methodSignature);
         DeadRemovalStrategy strategy = new DeadRemovalStrategy(mbgraph);
         TIntList found = strategy.getDeadAssignmentAddresses();
-        strategy.perform();
         TIntList expected = new TIntArrayList(new int[] { 0 });
 
         assertEquals(expected, found);

File: smalivm/src/main/java/org/cf/smalivm/MethodExecutor.java
Patch:
@@ -29,7 +29,7 @@ public class MethodExecutor {
     ExecutionGraph execute(ExecutionGraph graph) throws MaxNodeVisitsExceeded, MaxCallDepthExceeded {
         String methodDescriptor = graph.getMethodDescriptor();
         ExecutionNode currentNode = graph.getRoot();
-        if (log.isDebugEnabled()) {
+        if (log.isInfoEnabled()) {
             log.info("Executing " + methodDescriptor + ", depth=" + currentNode.getCallDepth());
         }
         if (currentNode.getCallDepth() > vm.getMaxCallDepth()) {

File: smalivm/src/main/java/org/cf/smalivm/MethodReflector.java
Patch:
@@ -118,7 +118,9 @@ public MethodReflector(String methodDescriptor, String returnType, List<String>
     }
 
     public void reflect(MethodState calleeContext) {
-        log.debug("Reflecting " + methodDescriptor + " with context:\n" + calleeContext);
+        if (log.isDebugEnabled()) {
+            log.debug("Reflecting " + methodDescriptor + " with context:\n" + calleeContext);
+        }
 
         Object result = null;
         try {

File: smalivm/src/main/java/org/cf/smalivm/context/BaseState.java
Patch:
@@ -153,7 +153,7 @@ protected String registerValueToString(Object value) {
             sb.append("type=null, value=null");
         } else {
             sb.append("type=").append(TypeUtil.getValueType(value)).append(", value=").append(value.toString())
-                            .append(", hc=").append(value.hashCode());
+            .append(", hc=").append(value.hashCode());
         }
 
         return sb.toString();

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionContext.java
Patch:
@@ -145,7 +145,7 @@ public void staticallyInitializeClassIfNecessary(String className) {
                 }
             }
 
-            ExecutionGraph graph = vm.execute(clinitDescriptor, initContext);
+            ExecutionGraph graph = vm.execute(clinitDescriptor, initContext, this, null);
             if (graph == null) {
                 // Error executing. Assume the worst.
                 setClassSideEffectType(className, SideEffect.Level.STRONG);
@@ -221,7 +221,7 @@ void setClassSideEffectType(String className, SideEffect.Level sideEffectLevel)
     public String toString() {
         StringBuilder sb = new StringBuilder();
         if (mState != null) {
-            sb.append(mState.toString());
+            sb.append("Method: ").append(mState.toString());
         }
         if (sb.length() > 0) {
             sb.append("\n");

File: smalivm/src/main/java/org/cf/smalivm/context/Heap.java
Patch:
@@ -19,6 +19,7 @@ class Heap {
 
     private static final Logger log = LoggerFactory.getLogger(Heap.class.getSimpleName());
 
+    // TODO: rework all *State classes to build keys and perfomr lookups by key
     private final TMap<HeapKey, Object> heapKeyToValue;
     private Heap parent;
 

File: smalivm/src/main/java/org/cf/smalivm/exception/MaxNodeVisitsExceeded.java
Patch:
@@ -6,8 +6,8 @@ public class MaxNodeVisitsExceeded extends Exception {
 
     private static final long serialVersionUID = 7115169814850980339L;
 
-    public MaxNodeVisitsExceeded(ExecutionNode currentNode, String methodDescriptor) {
-        this("Exceeded max node visits for " + currentNode + " in " + methodDescriptor);
+    public MaxNodeVisitsExceeded(ExecutionNode node, String methodDescriptor) {
+        this("Exceeded max node visits @" + node.getAddress() + " " + node + " in " + methodDescriptor);
     }
 
     private MaxNodeVisitsExceeded(String message) {

File: smalivm/src/main/java/org/cf/smalivm/MethodReflector.java
Patch:
@@ -34,7 +34,7 @@ public class MethodReflector {
         SafeClasses.add("Ljava/lang/Number;");
         SafeClasses.add("Ljava/lang/Short;");
         SafeClasses.add("Ljava/lang/String;");
-        SafeClasses.add("Ljava/lang/System;");
+        // SafeClasses.add("Ljava/lang/System;"); System.currentTimeMillis?
 
         SafeClasses.add("Ljava/lang/StringBuffer;");
         SafeClasses.add("Ljava/lang/StringBuilder;");

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionGraph.java
Patch:
@@ -227,9 +227,6 @@ public SideEffect.Level getHighestSideEffectLevel() {
         for (ExecutionNode node : this) {
             Op op = node.getOp();
             SideEffect.Level level = op.sideEffectLevel();
-            if (level == null) {
-                System.out.println("break");
-            }
             switch (level) {
             case STRONG:
                 return level;

File: smalivm/src/main/java/org/cf/smalivm/context/ExecutionNode.java
Patch:
@@ -35,7 +35,7 @@ public int[] execute() {
         if (log.isDebugEnabled()) {
             StringBuilder sb = new StringBuilder();
             sb.append("HANDLING @").append(op.getAddress()).append(": ").append(op).append("\nContext before:\n")
-                            .append(ectx);
+            .append(ectx);
             log.debug(sb.toString());
         }
 
@@ -103,7 +103,6 @@ public void replaceChild(ExecutionNode oldChild, ExecutionNode newChild) {
         // http://stream1.gifsoup.com/view/773318/not-the-father-dance-o.gif
         assert index >= 0;
         children.remove(index);
-        children.add(index, newChild);
         newChild.setParent(this);
     }
 

File: smalivm/src/test/java/org/cf/smalivm/TestConstantPropigator.java
Patch:
@@ -10,7 +10,7 @@ public void TestArrayGet() {
         TIntObjectMap<Object> initial = VMTester.buildRegisterState(0, new int[] { 0x42 }, 1, 0);
         TIntObjectMap<Object> expected = VMTester.buildRegisterState(0, 0x42);
 
-        VMTester.testState(CLASS_NAME, "TestArrayGet()V", initial, expected);
+        VMTester.testMethodState(CLASS_NAME, "TestArrayGet()V", initial, expected);
     }
 
 }

File: smalivm/src/test/java/org/cf/smalivm/ops/TestFilledNewArray.java
Patch:
@@ -16,6 +16,6 @@ public void TestFilledNewArrayOp() {
         TIntObjectMap<Object> expected = VMTester.buildRegisterState(MethodContext.ResultRegister,
                         new int[] { 2, 3, 5 });
 
-        VMTester.testState(CLASS_NAME, "TestFilledNewArray()V", initial, expected);
+        VMTester.testMethodState(CLASS_NAME, "TestFilledNewArray()V", initial, expected);
     }
 }

File: smalivm/src/test/java/org/cf/smalivm/ops/TestMoveOp.java
Patch:
@@ -21,7 +21,7 @@ public void TestMoveRegisterPrimitive() {
         TIntObjectMap<Object> initial = VMTester.buildRegisterState(0, 42);
         TIntObjectMap<Object> expected = VMTester.buildRegisterState(0, 42, 1, 42);
 
-        VMTester.testState(CLASS_NAME, "TestMoveRegisterPrimitive()V", initial, expected);
+        VMTester.testMethodState(CLASS_NAME, "TestMoveRegisterPrimitive()V", initial, expected);
     }
 
     @Test
@@ -46,14 +46,14 @@ public void TestMoveResult() {
         TIntObjectMap<Object> initial = VMTester.buildRegisterState(MethodContext.ResultRegister, 42);
         TIntObjectMap<Object> expected = VMTester.buildRegisterState(0, 42);
 
-        VMTester.testState(CLASS_NAME, "TestMoveResult()V", initial, expected);
+        VMTester.testMethodState(CLASS_NAME, "TestMoveResult()V", initial, expected);
     }
 
     @Test
     public void TestMoveException() {
         TIntObjectMap<Object> expected = VMTester.buildRegisterState(0, new UnknownValue("Ljava/lang/Exception;"));
 
-        VMTester.test(CLASS_NAME, "TestMoveException()V", expected);
+        VMTester.testMethodState(CLASS_NAME, "TestMoveException()V", expected);
     }
 
 }

File: smalivm/src/test/java/org/cf/smalivm/ops/TestNewInstanceOp.java
Patch:
@@ -16,7 +16,7 @@ public void TestLocalClass() {
         TIntObjectMap<Object> initial = VMTester.buildRegisterState(0, 1);
         TIntObjectMap<Object> expected = VMTester.buildRegisterState(0, new LocalInstance(CLASS_NAME));
 
-        VMTester.testState(CLASS_NAME, "TestLocalClass()V", initial, expected);
+        VMTester.testMethodState(CLASS_NAME, "TestLocalClass()V", initial, expected);
     }
 
     @Test
@@ -25,7 +25,7 @@ public void TestNonLocalClass() {
         TIntObjectMap<Object> expected = VMTester.buildRegisterState(0,
                         new UninitializedInstance("Ljava/lang/Integer;"));
 
-        VMTester.testState(CLASS_NAME, "TestNonLocalClass()V", initial, expected);
+        VMTester.testMethodState(CLASS_NAME, "TestNonLocalClass()V", initial, expected);
     }
 
 }

File: smalivm/src/main/java/org/cf/smalivm/emulate/EmulatedMethod.java
Patch:
@@ -1,9 +1,12 @@
 package org.cf.smalivm.emulate;
 
+import org.cf.smalivm.SideEffect.Type;
 import org.cf.smalivm.context.MethodContext;
 
 public interface EmulatedMethod {
 
     public void execute(MethodContext mctx);
 
+    public Type getSideEffectType();
+
 }

File: smalivm/src/main/java/org/cf/smalivm/MethodReflector.java
Patch:
@@ -42,9 +42,9 @@ public class MethodReflector {
         SafeClasses.add("Ljava/math/BigDecimal;");
         SafeClasses.add("Ljava/math/BigInteger;");
 
-        SafeClasses.add("Ljava/org.cf.util/Map;");
-        SafeClasses.add("Ljava/org.cf.util/HashMap;");
-        SafeClasses.add("Ljava/org.cf.util/Hashtable;");
+        SafeClasses.add("Ljava/util/Map;");
+        SafeClasses.add("Ljava/util/HashMap;");
+        SafeClasses.add("Ljava/util/Hashtable;");
 
         SafeClasses.add("Ljava/util/List;");
         SafeClasses.add("Ljava/util/ArrayList;");

File: smalivm/src/main/java/org/cf/smalivm/op_handler/InvokeOp.java
Patch:
@@ -176,7 +176,7 @@ public String toString() {
         sb.append(" {");
         if (getOpName().contains("/range")) {
             sb.append("r").append(parameterRegisters[0]).append(" .. r")
-            .append(parameterRegisters[parameterRegisters.length - 1]);
+                            .append(parameterRegisters[parameterRegisters.length - 1]);
         } else {
             if (parameterRegisters.length > 0) {
                 for (int register : parameterRegisters) {
@@ -198,7 +198,7 @@ private void assumeMaximumUnknown(MethodContext callerContext) {
                 continue;
             }
 
-            log.debug(type + " is mutable and passed into strange method, marking unknown");
+            log.debug(type + " is mutable and passed into unresolvable method execution, making Unknown");
             int register = parameterRegisters[i];
             Object value = new UnknownValue(type);
             callerContext.pokeRegister(register, value);

File: smalivm/src/main/java/org/cf/smalivm/op_handler/InvokeOp.java
Patch:
@@ -176,7 +176,7 @@ public String toString() {
         sb.append(" {");
         if (getOpName().contains("/range")) {
             sb.append("r").append(parameterRegisters[0]).append(" .. r")
-                            .append(parameterRegisters[parameterRegisters.length - 1]);
+            .append(parameterRegisters[parameterRegisters.length - 1]);
         } else {
             if (parameterRegisters.length > 0) {
                 for (int register : parameterRegisters) {
@@ -268,7 +268,7 @@ private void executeNonLocalMethod(String methodDescriptor, MethodContext caller
             sideEffectType = SideEffect.Type.NONE;
         } else if (allArgumentsKnown && MethodReflector.canReflect(methodDescriptor)) {
             MethodReflector reflector = new MethodReflector(methodDescriptor, returnType, parameterTypes, isStatic);
-            reflector.reflect(calleeContext); // player play
+            reflector.reflect(calleeContext); // playa play
 
             // Only safe, non-side-effect methods are allowed to be reflected.
             sideEffectType = SideEffect.Type.NONE;

File: smalivm/src/main/java/org/cf/smalivm/op_handler/NewInstanceOp.java
Patch:
@@ -66,7 +66,6 @@ public SideEffect.Type sideEffectType() {
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder(getOpName());
-
         sb.append(" r").append(destRegister).append(", ").append(className);
 
         return sb.toString();

File: smalivm/src/main/java/org/cf/smalivm/type/UninitializedInstance.java
Patch:
@@ -16,7 +16,7 @@ public String getType() {
 
     @Override
     public String toString() {
-        return smaliType;
+        return "Uninitialized " + smaliType;
     }
 
     @Override

File: smalivm/src/test/java/org/cf/smalivm/VMTester.java
Patch:
@@ -152,7 +152,7 @@ public static void testState(String className, String methodSignature, TIntObjec
 
         VirtualMachine vm = new VirtualMachine(Arrays.asList(classDef), MAX_NODE_VISITS, MAX_CALL_DEPTH);
         for (String contextClassName : classNameToInitialFieldValue.keySet()) {
-            ClassContext cctx = vm.peekStaticClassContext(contextClassName);
+            ClassContext cctx = vm.getStaticClassContext(contextClassName);
             Map<String, Object> fieldNameToValue = classNameToInitialFieldValue.get(contextClassName);
             for (String fieldReference : fieldNameToValue.keySet()) {
                 Object value = fieldNameToValue.get(fieldReference);
@@ -173,7 +173,7 @@ public static void testState(String className, String methodSignature, TIntObjec
 
         for (String contextClassName : classNameToExpectedFieldValue.keySet()) {
             Map<String, Object> check = classNameToExpectedFieldValue.get(contextClassName);
-            ClassContext actual = vm.peekStaticClassContext(contextClassName);
+            ClassContext actual = vm.getStaticClassContext(contextClassName);
 
             for (String fieldReference : check.keySet()) {
                 Object checkValue = check.get(fieldReference);
@@ -196,7 +196,7 @@ private static String getClassName(Object obj) {
     private static void testEquals(Object value, Object consensus, String methodDescriptor, int register) {
         StringBuilder sb = new StringBuilder();
         sb.append("r").append(register).append(" class(expected=").append(getClassName(value)).append(", consensus=")
-        .append(getClassName(consensus)).append(")");
+                        .append(getClassName(consensus)).append(")");
         String msg = sb.toString();
 
         if (value == null) {

File: smalivm/src/main/java/org/cf/util/SmaliClassUtils.java
Patch:
@@ -52,7 +52,7 @@ public static String smaliPrimitiveToJavaWrapper(String className) {
     }
 
     public static String javaClassToSmali(String className) {
-        if (className.endsWith(";")) {
+        if (className.endsWith(";") || (className.length() == 1)) {
             // Already Smali format
             return className;
         }

File: smalivm/src/main/java/org/cf/smalivm/MethodReflector.java
Patch:
@@ -163,7 +163,7 @@ private Object[] getArguments(MethodContext mctx) {
             }
             args.add(arg);
 
-            if (type.equals("J")) {
+            if (type.equals("J") || type.equals("D")) {
                 // Long tried every diet but is still fat and takes 2 registers. Could be thyroid.
                 i++;
             }

File: smalivm/src/main/java/org/cf/smalivm/op_handler/InvokeOp.java
Patch:
@@ -113,7 +113,7 @@ static InvokeOp create(Instruction instruction, int address, VirtualMachine vm)
         for (int i = 0; i < parameterTypes.size(); i++) {
             parameterRegisters.add(registers[i]);
             String type = parameterTypes.get(i);
-            if (type.equals("J")) {
+            if (type.equals("J") || type.equals("D")) {
                 i++;
             }
         }

File: smalivm/src/main/java/org/cf/smalivm/op_handler/SGetOp.java
Patch:
@@ -26,7 +26,7 @@ static SGetOp create(Instruction instruction, int address, VirtualMachine vm) {
         String parts[] = fieldDescriptor.split("->");
         String className = parts[0];
         String fieldReference = parts[1];
-        ClassContext classCtx = vm.peekClassContext(className);
+        ClassContext classCtx = vm.peekStaticClassContext(className);
 
         return new SGetOp(address, opName, childAddress, destRegister, classCtx, className, fieldReference);
     }

File: smalivm/src/main/java/org/cf/smalivm/op_handler/SPutOp.java
Patch:
@@ -27,7 +27,7 @@ static SPutOp create(Instruction instruction, int address, VirtualMachine vm) {
         String parts[] = fieldDescriptor.split("->");
         String className = parts[0];
         String fieldReference = parts[1];
-        ClassContext classCtx = vm.peekClassContext(className);
+        ClassContext classCtx = vm.peekStaticClassContext(className);
 
         return new SPutOp(address, opName, childAddress, destRegister, classCtx, className, fieldReference);
     }

File: src/main/java/simplify/emulate/MethodEmulator.java
Patch:
@@ -10,8 +10,7 @@ public class MethodEmulator {
     private static Map<String, EmulatedMethod> emulatedMethods;
     static {
         emulatedMethods = new HashMap<String, EmulatedMethod>();
-
-        // emulatedMethods.put("Ljava/lang/Integer;-><init>(I)V", new java_lang_Integer_init());
+        emulatedMethods.put("Lsimplifier/Utils;->breakpoint()V", new Breakpoint());
     }
 
     public static boolean canEmulate(String methodDescriptor) {

File: src/main/java/simplify/Main.java
Patch:
@@ -82,7 +82,7 @@ public static void main(String[] argv) throws Exception {
                 }
 
                 sweeps++;
-            } while (madeChanges && (sweeps < 4));
+            } while (madeChanges && (sweeps < 20));
         }
 
         String outputDexFile = "out_simple.dex";

File: src/main/java/simplify/vm/VirtualMachineContext.java
Patch:
@@ -117,8 +117,7 @@ static TIntSet getReassignedRegistersBetweenChildAndAncestorContext(VirtualMachi
                     VirtualMachineContext ancestor) {
         VirtualMachineContext current = child;
         TIntSet result = new TIntHashSet();
-        // Up to, but not including ancestor
-        while ((current.getParent() != ancestor) && (current != ancestor)) {
+        while (current != ancestor) {
             result.addAll(current.getRegisterToValue().keys());
             current = current.getParent();
         }
@@ -262,7 +261,7 @@ public boolean wasRegisterRead(int register) {
     protected String registerValueToString(Object value) {
         StringBuilder result = new StringBuilder();
         result.append("type=").append(SmaliClassUtils.getValueType(value)).append(", value=").append(value.toString())
-        .append(", hc=").append(value.hashCode());
+                        .append(", hc=").append(value.hashCode());
 
         return result.toString();
     }

File: src/main/java/simplify/vm/ContextGraph.java
Patch:
@@ -187,6 +187,8 @@ public SideEffect.Type getStrongestSideEffectType() {
             case WEAK:
                 result = type;
                 break;
+            case NONE:
+                break;
             }
         }
 

File: src/main/java/simplify/MethodReflector.java
Patch:
@@ -120,8 +120,6 @@ public void reflect(MethodContext calleeContext) {
                 // This class is used by the JVM to do instance initialization, i.e. newInstance. Can't just reflect it.
                 log.fine("Reflecting " + methodDescriptor + ", clazz=" + clazz + " args=" + Arrays.toString(args));
                 result = ConstructorUtils.invokeConstructor(clazz, args);
-
-                System.out.println("reflecting init and this is result: " + result);
                 calleeContext.assignRegister(0, result);
             } else {
                 if (isStatic) {

File: src/main/java/simplify/vm/VirtualMachineContext.java
Patch:
@@ -102,7 +102,6 @@ public boolean hasRegister(int register) {
     VirtualMachineContext getAncestorWithRegister(int register) {
         VirtualMachineContext result = this;
         do {
-            // System.out.println("looking for register: " + register + ", rtvs: " + registerToValue.size());
             if (result.hasRegister(register)) {
                 return result;
             }
@@ -259,7 +258,7 @@ public boolean wasRegisterRead(int register) {
     protected String registerValueToString(Object value) {
         StringBuilder result = new StringBuilder();
         result.append("type=").append(SmaliClassUtils.getValueType(value)).append(", value=").append(value.toString())
-        .append(", hc=").append(value.hashCode());
+                        .append(", hc=").append(value.hashCode());
 
         return result.toString();
     }

File: src/test/java/simplify/vm/VMTester.java
Patch:
@@ -203,6 +203,8 @@ private static void testEquals(Object value, Object consensus, String methodDesc
             // Type is "object" so can't use instanceof, but you knew that.
             boolean result = ArrayUtils.isEquals(value, consensus);
             Assert.assertTrue(msg, result);
+        } else if (value instanceof StringBuilder) {
+            assertTrue(msg, value.toString().equals(consensus.toString()));
         } else {
             Assert.assertTrue(msg, value.equals(consensus));
         }

File: src/test/java/simplify/vm/VMTester.java
Patch:
@@ -157,6 +157,7 @@ public static void testState(String className, String methodSignature, SparseArr
 
         ContextGraph graph = vm.execute(methodDescriptor, ctx);
 
+        // TODO: use getTerminatingRegisterConsensus
         TIntList terminalAddresses = graph.getConnectedTerminatingAddresses();
         for (int i = 0; i < expected.size(); i++) {
             int register = expected.keyAt(i);

File: src/simplify/Main.java
Patch:
@@ -27,7 +27,7 @@ public class Main {
     private static final Level LOG_LEVEL = Level.FINE;
     // private static final Level LOG_LEVEL = Level.OFF;
 
-    private static final int MAX_NODE_VISITS = 20;
+    private static final int MAX_NODE_VISITS = 30;
     private static final int MAX_CALL_DEPTH = 3;
 
     public static void main(String[] argv) throws Exception {

File: src/simplify/vm/ops/IfOp.java
Patch:
@@ -136,9 +136,10 @@ public int[] execute(MethodContext mctx) {
         int cmp = Integer.MIN_VALUE;
         if (compareToZero) {
             if (A instanceof Number) {
-                cmp = ((Number) A).equals(B) ? 1 : 0;
+                // like other compare methods, 0=no difference, 1=difference
+                cmp = ((Number) A).equals(B) ? 0 : 1;
             } else {
-                cmp = A == null ? 1 : 0;
+                cmp = A == null ? 0 : 1;
             }
         } else {
             cmp = CompareToBuilder.reflectionCompare(A, B);

File: test/simplify/vm/ops/TestUnaryMathOp.java
Patch:
@@ -66,8 +66,9 @@ public void TestFloatToLong() {
 
     @Test
     public void TestIntToByte() {
-        SparseArray<Object> initial = VMTester.buildRegisterState(0, 0x5);
-        SparseArray<Object> expected = VMTester.buildRegisterState(0, (byte) 0x5);
+        Integer val = 128;
+        SparseArray<Object> initial = VMTester.buildRegisterState(0, val);
+        SparseArray<Object> expected = VMTester.buildRegisterState(0, val.byteValue());
 
         VMTester.testState(CLASS_NAME, "TestIntToByte()V", initial, expected);
     }

File: src/simplify/vm/VirtualMachine.java
Patch:
@@ -229,7 +229,7 @@ void staticallyInitializeClassIfNecessary(String className) {
         initializedClasses.add(className);
 
         String clinitDescriptor = className + "-><clinit>()V";
-        if (!methodDescriptorToInstructionGraph.containsKey(clinitDescriptor)) {
+        if (!methodDescriptorToBuilderMethod.containsKey(clinitDescriptor)) {
             // No clinit for this class.
             return;
         }

File: src/simplify/SmaliClassUtils.java
Patch:
@@ -69,7 +69,7 @@ public static String getValueType(Object value) {
         if (value instanceof Type) {
             result = ((Type) value).getType();
         } else {
-            result = value.getClass().getCanonicalName();
+            result = value.getClass().getName();
         }
 
         return result;

File: src/simplify/Utils.java
Patch:
@@ -16,7 +16,7 @@
 public class Utils {
 
     private static final Pattern ParameterIsolator = Pattern.compile("\\([^\\)]+\\)");
-    private static final Pattern ParameterIndividuator = Pattern.compile("([BCDFIJSZ]|L[^;]+;)");
+    private static final Pattern ParameterIndividuator = Pattern.compile("(\\[*(?:[BCDFIJSZ]|L[^;]+;))");
 
     public static void deDuplicate(TIntList list) {
         for (int i = 0; i < list.size(); i++) {

File: src/simplify/optimize/Simplifier.java
Patch:
@@ -14,6 +14,7 @@
 
 public class Simplifier {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     public static boolean simplify(DexBuilder dexBuilder, BuilderMethod method, ContextGraph graph) {

File: src/simplify/vm/ContextGraph.java
Patch:
@@ -21,7 +21,7 @@
 import simplify.vm.ops.OpFactory;
 import simplify.vm.types.UnknownValue;
 
-public class ContextGraph implements Iterable {
+public class ContextGraph implements Iterable<ContextNode> {
 
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 

File: src/simplify/vm/ops/AGetOp.java
Patch:
@@ -12,6 +12,7 @@
 
 public class AGetOp extends Op {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     static AGetOp create(Instruction instruction, int address) {

File: src/simplify/vm/ops/APutOp.java
Patch:
@@ -12,6 +12,7 @@
 
 public class APutOp extends Op {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     static APutOp create(Instruction instruction, int address) {

File: src/simplify/vm/ops/ConstOp.java
Patch:
@@ -21,6 +21,7 @@
 
 public class ConstOp extends Op {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     private static enum ConstType {

File: src/simplify/vm/ops/FillArrayDataPayloadOp.java
Patch:
@@ -14,6 +14,7 @@
 
 public class FillArrayDataPayloadOp extends Op {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     static FillArrayDataPayloadOp create(Instruction instruction, int address) {

File: src/simplify/vm/ops/InvokeOp.java
Patch:
@@ -216,7 +216,7 @@ public int[] execute(MethodContext callerContext) {
         /*
          * Side-effects are things like changing class state or any kind of IO. True implies this call can't be
          * optimized away without changing behavior. Doing a good job of determining if a method causes side-effects is
-         * tricky. For now, this is only false in a very specific set of circumstances.
+         * tricky (impossible?). It's only known to be false for a very specific set of circumstances.
          */
         hasSideEffects = true;
 
@@ -258,7 +258,8 @@ public int[] execute(MethodContext callerContext) {
                 reflector.reflect(calleeContext); // player play
 
                 // TOOD: investigate better marking of side effects. This is very conservative and depends on reflected
-                // methods not actually having side effects. Emulated methods could also keep track of this.
+                // methods not actually having side effects.
+                // Emulated methods should keep track of this.
                 hasSideEffects = false;
             } else {
                 log.fine("Unknown argument(s) or can't find/emulate/reflect " + methodDescriptor

File: src/simplify/vm/ops/OpFactory.java
Patch:
@@ -41,6 +41,7 @@ private enum OpType {
         UNIMPLEMENTED
     }
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());;
 
     @SuppressWarnings("incomplete-switch")

File: src/simplify/vm/ops/ReturnOp.java
Patch:
@@ -10,6 +10,7 @@
 
 public class ReturnOp extends Op {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     static ReturnOp create(Instruction instruction, int address) {

File: src/simplify/vm/ops/ReturnVoidOp.java
Patch:
@@ -9,6 +9,7 @@
 
 public class ReturnVoidOp extends Op {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     static ReturnVoidOp create(Instruction instruction, int address) {

File: src/simplify/vm/ops/SwitchPayloadOp.java
Patch:
@@ -23,6 +23,7 @@ private static enum SwitchType {
         SPARSE
     }
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     private static int[] determineChildren(List<? extends SwitchElement> switchElements) {

File: test/simplify/vm/TestConstantPropigator.java
Patch:
@@ -9,8 +9,9 @@
 
 public class TestConstantPropigator {
 
-    private static final String CLASS_NAME = "Laget_test;";
+    private static final String CLASS_NAME = "Lconstant_propigator_test;";
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     @Test

File: test/simplify/vm/ops/TestAGetOp.java
Patch:
@@ -15,6 +15,7 @@ public class TestAGetOp {
 
     private static final String CLASS_NAME = "Laget_test;";
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     @Test

File: test/simplify/vm/ops/TestAPutOp.java
Patch:
@@ -15,6 +15,7 @@ public class TestAPutOp {
 
     private static final String CLASS_NAME = "Laput_test;";
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     @Test

File: test/simplify/vm/ops/TestFillArrayDataOps.java
Patch:
@@ -11,6 +11,7 @@
 
 public class TestFillArrayDataOps {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     private static final String CLASS_NAME = "Lfill_array_data_test;";

File: test/simplify/vm/ops/TestFilledNewArray.java
Patch:
@@ -11,6 +11,7 @@
 
 public class TestFilledNewArray {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     private static final String CLASS_NAME = "Lfilled_new_array_test;";

File: test/simplify/vm/ops/TestMoveOp.java
Patch:
@@ -17,6 +17,7 @@
 
 public class TestMoveOp {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     private static final String CLASS_NAME = "Lmove_test;";
@@ -67,4 +68,5 @@ public void TestMoveException() {
 
         VMTester.test(CLASS_NAME, "TestMoveException()V", expected);
     }
+
 }

File: test/simplify/vm/ops/TestNewArrayOp.java
Patch:
@@ -13,6 +13,7 @@
 
 public class TestNewArrayOp {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     private static final String CLASS_NAME = "Lnew_array_test;";

File: test/simplify/vm/ops/TestNewInstanceOp.java
Patch:
@@ -13,6 +13,7 @@
 
 public class TestNewInstanceOp {
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     private static final String CLASS_NAME = "Lnew_instance_test;";

File: test/simplify/vm/ops/TestSwitchOp.java
Patch:
@@ -14,6 +14,7 @@ public class TestSwitchOp {
 
     private static final String CLASS_NAME = "Lswitch_test;";
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     @Test

File: test/simplify/vm/ops/TestUnaryMathOp.java
Patch:
@@ -14,6 +14,7 @@ public class TestUnaryMathOp {
 
     private static final String CLASS_NAME = "Lunary_math_test;";
 
+    @SuppressWarnings("unused")
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
     @Test

File: src/simplify/Main.java
Patch:
@@ -24,8 +24,8 @@ public class Main {
 
     private static final Level LOG_LEVEL = Level.FINE;
 
-    private static final int MAX_NODE_VISITS = 1000;
-    private static final int MAX_CALL_DEPTH = 10;
+    private static final int MAX_NODE_VISITS = 20;
+    private static final int MAX_CALL_DEPTH = 3;
 
     public static void main(String[] argv) throws Exception {
         setupLogger();
@@ -69,7 +69,7 @@ public static void main(String[] argv) throws Exception {
                 madeChanges = Simplifier.simplify(dexBuilder, method, graph);
                 if (madeChanges) {
                     // Method implementations will have changed, so prepare to execute this again with the changes.
-                    vm.updateInstructionGraph(method);
+                    vm.updateInstructionGraph(methodDescriptor);
                 }
 
                 sweeps++;

File: src/simplify/vm/VirtualMachineContext.java
Patch:
@@ -128,7 +128,7 @@ public Object peekRegister(int register) {
 
         if (result == null) {
             log.warning("r" + register + " is being read but is null, likely a mistake!");
-            Thread.currentThread().dumpStack();
+            Thread.dumpStack();
         } else {
             if (currentContext != this) {
                 // Got context from an ancestor. Store a clone to not alter history.

File: src/simplify/vm/ops/OpFactory.java
Patch:
@@ -206,6 +206,7 @@ private static OpType getFactoryType(Opcode op) {
         case NEG_LONG:
         case NOT_INT:
         case NOT_LONG:
+            result = OpType.UNARY_MATH;
             break;
 
         case FILLED_NEW_ARRAY:
@@ -430,6 +431,7 @@ public Op create(BuilderInstruction instruction, int address) {
             result = ReturnVoidOp.create(instruction, address);
             break;
         case UNARY_MATH:
+            result = UnaryMathOp.create(instruction, address);
             break;
         }
 

File: src/simplify/Main.java
Patch:
@@ -54,7 +54,7 @@ public static void main(String[] argv) throws Exception {
             int sweeps = 0;
             do {
                 if (sweeps >= 1) {
-                    // break;
+                    break;
                 }
 
                 ContextGraph graph = vm.execute(methodDescriptor);

File: src/simplify/optimize/ConstantPropigator.java
Patch:
@@ -38,8 +38,8 @@ public class ConstantPropigator {
 
     private static final Logger log = Logger.getLogger(Main.class.getSimpleName());
 
-    private static final Class<?>[] OpHandlersToMakeConst = new Class<?>[] { BinaryMathOp.class,
-                    UnaryMathOp.class, ReturnOp.class, MoveOp.class };
+    private static final Class<?>[] OpHandlersToMakeConst = new Class<?>[] { BinaryMathOp.class, UnaryMathOp.class,
+                    ReturnOp.class, MoveOp.class };
 
     private static int getBitSize(long x) {
         int result = 1;

File: src/simplify/vm/ContextGraph.java
Patch:
@@ -55,7 +55,8 @@ private static TIntList buildTerminatingAddresses(List<BuilderInstruction> instr
              * be to make it easier for operations to execute other operations, perhaps looking up by address. This
              * would eliminate the need for MethodContext.pseudoInstructionReturnAddress, and Context's getParent().
              */
-            if (instruction.getOpcode().canContinue() || (instruction.getOpcode() == Opcode.ARRAY_PAYLOAD)) {
+            Opcode op = instruction.getOpcode();
+            if (op.canContinue() || (op == Opcode.ARRAY_PAYLOAD) || op.name.startsWith("goto")) {
                 continue;
             }
             result.add(address);

File: src/simplify/vm/VirtualMachineContext.java
Patch:
@@ -128,6 +128,7 @@ public Object peekRegister(int register) {
 
         if (result == null) {
             log.warning("r" + register + " is being read but is null, likely a mistake!");
+            Thread.currentThread().dumpStack();
         } else {
             if (currentContext != this) {
                 // Got context from an ancestor. Store a clone to not alter history.

File: src/simplify/vm/ops/APutOp.java
Patch:
@@ -47,7 +47,6 @@ public int[] execute(MethodContext mctx) {
         if (getOpName().endsWith("-wide")) {
             value = (long) value;
         } else if (getOpName().endsWith("-boolean")) {
-            System.out.println("value == " + value);
             value = ((int) value == 1 ? true : false);
         } else if (getOpName().endsWith("-byte")) {
             value = (byte) ((int) value);

File: src/simplify/vm/ops/FillArrayDataPayloadOp.java
Patch:
@@ -62,7 +62,6 @@ private static Object getProperValue(Number number, Class<?> expectedClass) {
             value = number.byteValue();
             if (expectedClass == boolean.class) {
                 value = (byte) value == 1 ? true : false;
-                System.out.println("boolean = " + value);
             }
         } else if (klazz == short.class) {
             value = number.shortValue();

File: src/simplify/SmaliClassUtils.java
Patch:
@@ -5,7 +5,7 @@
 
 import org.apache.commons.lang3.ClassUtils;
 
-import simplify.vm.types.SmaliClassInstance;
+import simplify.vm.types.LocalInstance;
 
 public class SmaliClassUtils {
 
@@ -66,8 +66,8 @@ public static String javaClassToSmali(String className) {
 
     public static String getValueType(Object value) {
         String result = null;
-        if (value instanceof SmaliClassInstance) {
-            result = ((SmaliClassInstance) value).getType();
+        if (value instanceof LocalInstance) {
+            result = ((LocalInstance) value).getType();
         } else {
             result = value.getClass().getCanonicalName();
         }

File: src/simplify/vm/VirtualMachine.java
Patch:
@@ -15,7 +15,7 @@
 import org.jf.dexlib2.writer.builder.BuilderMethodParameter;
 
 import simplify.Main;
-import simplify.vm.types.SmaliClassInstance;
+import simplify.vm.types.LocalInstance;
 import simplify.vm.types.UnknownValue;
 
 public class VirtualMachine {
@@ -33,7 +33,7 @@ private static MethodContext buildRootContext(BuilderMethod method) {
         if (!isStatic) {
             // For instance methods, the instance reference p0 is stored before the first parameter.
             String type = method.getDefiningClass();
-            result.pokeRegister(result.getParameterStart() - 1, new SmaliClassInstance(type));
+            result.pokeRegister(result.getParameterStart() - 1, new LocalInstance(type));
         }
 
         // IMPORTANT: Assume all input values are unknown.

File: src/simplify/vm/ops/NewInstanceOp.java
Patch:
@@ -6,7 +6,7 @@
 
 import simplify.vm.MethodContext;
 import simplify.vm.VirtualMachine;
-import simplify.vm.types.SmaliClassInstance;
+import simplify.vm.types.LocalInstance;
 import simplify.vm.types.UninitializedInstance;
 
 public class NewInstanceOp extends Op {
@@ -40,7 +40,7 @@ static NewInstanceOp create(Instruction instruction, int address, VirtualMachine
     public int[] execute(MethodContext mctx) {
         Object instance = null;
         if (vm.isClassDefinedLocally(className)) {
-            instance = new SmaliClassInstance(className);
+            instance = new LocalInstance(className);
         } else {
             instance = new UninitializedInstance(className);
         }

File: src/simplify/vm/types/Type.java
Patch:
@@ -1,6 +1,6 @@
 package simplify.vm.types;
 
-public interface LocalType {
+public interface Type {
 
     public String getType();
 

File: src/simplify/vm/types/UninitializedInstance.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.apache.commons.lang3.builder.EqualsBuilder;
 
-public class UninitializedInstance implements LocalType {
+public class UninitializedInstance implements Type {
 
     private final String type;
 

File: src/simplify/vm/types/UnknownValue.java
Patch:
@@ -1,6 +1,6 @@
 package simplify.vm.types;
 
-public class UnknownValue implements LocalType {
+public class UnknownValue implements Type {
 
     private final String type;
 

File: test/simplify/vm/VMTester.java
Patch:
@@ -11,6 +11,7 @@
 
 import junit.framework.Assert;
 
+import org.apache.commons.io.FileUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.jf.dexlib2.writer.builder.BuilderClassDef;
 import org.jf.dexlib2.writer.builder.DexBuilder;
@@ -26,11 +27,10 @@ public class VMTester {
 
     static {
         File testDir = new File(TEST_DIRECTORY);
-        List<File> smaliFiles = new ArrayList<File>();
-        smaliFiles.addAll(Arrays.asList(testDir.listFiles()));
+        String[] extensions = new String[] { "smali" };
+        List<File> smaliFiles = new ArrayList<File>(FileUtils.listFiles(testDir, extensions, true));
 
         DexBuilder dexBuilder = DexBuilder.makeDexBuilder(Dexifier.API_LEVEL);
-
         classNameToDef = new HashMap<String, BuilderClassDef>();
         try {
             List<BuilderClassDef> classDefs = Dexifier.dexifySmaliFiles(smaliFiles, dexBuilder);

File: src/simplify/vm/ContextGraph.java
Patch:
@@ -126,8 +126,8 @@ public Object getRegisterConsensus(int address, int register) {
     }
 
     public Object getRegisterConsensus(TIntList addresses, int register) {
-        ContextNode fistNode = getNodePile(addresses.get(0)).get(0);
-        Object value = fistNode.getContext().peekRegister(register);
+        ContextNode firstNode = getNodePile(addresses.get(0)).get(0);
+        Object value = firstNode.getContext().peekRegister(register);
         for (int i = 0; i < addresses.size(); i++) {
             int address = addresses.get(i);
             for (ContextNode node : getNodePile(address)) {

File: test/simplify/vm/TestVirtualMachine.java
Patch:
@@ -13,8 +13,9 @@ public void setUp() throws Exception {
 
     @Test
     public void test() {
-        // test class static initilization
-        // look at instruction graph
+        // test class static initialization
+        // examine instruction graph
+        // test some public methods
         fail("Not yet implemented");
     }
 

File: test/simplify/vm/VMTester.java
Patch:
@@ -56,13 +56,14 @@ public static void executeAndEnsureContextState(String className, String methodS
             int register = registerState.keyAt(i);
             Object value = registerState.get(register);
             Object consensus = graph.getRegisterConsensus(terminalAddresses, register);
-            String msg = methodDescriptor + ", r" + register + " = " + consensus + ", should be " + value;
+            String msg = methodDescriptor + ", r" + register + " = " + consensus + "(" + consensus.getClass().getName()
+                            + "), should be " + value + "(" + value.getClass().getName() + ")";
 
             // Type is "object" so can't use instanceof, but you knew that.
             if (value.getClass().isArray()) {
                 Assert.assertTrue(msg, Arrays.deepEquals((Object[]) value, (Object[]) consensus));
             } else {
-                Assert.assertTrue(msg, (value == consensus));
+                Assert.assertTrue(msg, value.equals(consensus));
             }
         }
     }

File: src/simplify/vm/MethodContext.java
Patch:
@@ -40,7 +40,7 @@ public void assignResultRegister(Object value) {
 
     public Object readResultRegister() {
         Object result = readRegister(ResultRegister);
-        removeRegister(ResultRegister);
+        // removeRegister(ResultRegister);
 
         return result;
     }

File: src/simplify/vm/VirtualMachineContext.java
Patch:
@@ -197,7 +197,7 @@ public void assignRegisterAndUpdateIdentities(int register, Object value) {
             int currentRegister = registerToValue.keyAt(i);
             Object currentValue = registerToValue.get(currentRegister);
             if (oldValue == currentValue) {
-                registerToValue.put(currentRegister, value);
+                assignRegister(currentRegister, value);
             }
         }
     }

File: src/optimize/ConstantPropigator.java
Patch:
@@ -187,8 +187,8 @@ boolean perform() {
 
             int index = originalInstruction.getLocation().getIndex();
             if (originalInstruction.getOpcode().name.startsWith("return")) {
-                // Add const before return only if previous instruction not const, otherwise repeated sweeps will always
-                // add one.
+                // Add const before return only if previous instruction is not a const. Otherwise repeated sweeps will
+                // always add one.
                 BuilderInstruction prevInstr = implementation.getInstructions().get(index - 1);
                 boolean previousConst = prevInstr.getOpcode().name.startsWith("const");
                 if (previousConst) {

File: src/simplify/Main.java
Patch:
@@ -36,7 +36,7 @@ public class Main {
     private static final Level LOG_LEVEL = Level.INFO;
 
     private static final int API_LEVEL = 15;
-    private static final int MAX_NODE_VISITS = 100;
+    private static final int MAX_NODE_VISITS = 1000;
     private static final int MAX_CALL_DEPTH = 10;
 
     public static void main(String[] argv) throws Exception {
@@ -85,7 +85,6 @@ public static void main(String[] argv) throws Exception {
                 madeChanges = Simplifier.simplify(dexBuilder, method, graph);
 
                 if (madeChanges) {
-                    System.out.println("!!! MADE CHANGES !!!");
                     // Method implementations will have changed, so prepare to execute this again with the changes.
                     vm.updateInstructionGraph(method);
                 }

File: src/simplify/vm/ContextGraph.java
Patch:
@@ -128,7 +128,7 @@ public RegisterStore getRegisterConsensus(TIntList addresses, int register) {
         RegisterStore registerStore = fistNode.getContext().peekRegister(register);
         String type = registerStore.getType();
         Object value = registerStore.getValue();
-        for (int i = 1; i < addresses.size(); i++) {
+        for (int i = 0; i < addresses.size(); i++) {
             int address = addresses.get(i);
             for (ContextNode node : getNodePile(address)) {
                 RegisterStore rs = node.getContext().peekRegister(register);

File: src/simplify/vm/VirtualMachine.java
Patch:
@@ -123,7 +123,8 @@ public ContextGraph execute(String methodDescriptor, MethodContext mctx) {
         try {
             result = methodExecutor.execute(methodDescriptor, mctx);
         } catch (MaxNodeVisitsExceeded | MaxCallDepthExceeded e) {
-            log.warning("Exceeded max node visits for " + e.getMessage() + " in " + methodDescriptor);
+            log.warning("Exceeded max node visits for " + e.getMessage() + " in " + methodDescriptor + "\nContext: "
+                            + mctx);
         }
 
         return result;

File: src/simplify/vm/VirtualMachineContext.java
Patch:
@@ -158,10 +158,10 @@ public String toString() {
             sb.append("[");
             for (int i = 0; i < registers.size(); i++) {
                 int register = registers.keyAt(i);
-                RegisterStore rs = registers.get(register);
                 if (register < 0) {
                     continue;
                 }
+                RegisterStore rs = registers.get(register);
 
                 sb.append("r").append(register).append(": ").append(rs).append(",\n");
             }

File: src/simplify/vm/ContextNode.java
Patch:
@@ -38,7 +38,7 @@ public void addChild(ContextNode child) {
     }
 
     public int[] execute() {
-        log.fine("Handling @" + handler.getAddress() + ": " + handler + ", context before: ");
+        log.fine("HANDLING @" + handler.getAddress() + ": " + handler + "\nContext before: " + mctx);
 
         int[] result = handler.execute(mctx);
 

File: src/simplify/vm/MethodContext.java
Patch:
@@ -40,7 +40,7 @@ public void setResultRegister(RegisterStore registerStore) {
 
     public RegisterStore getResultRegister(int address) {
         RegisterStore result = getRegister(ResultRegister, address);
-        pokeRegister(ResultRegister, null);
+        removeRegister(ResultRegister);
 
         return result;
     }

File: src/simplify/Main.java
Patch:
@@ -32,10 +32,10 @@ public class Main {
 
     private static Logger log = Logger.getLogger(Main.class.getSimpleName());
 
-    private static final Level LOG_LEVEL = Level.OFF;
+    private static final Level LOG_LEVEL = Level.FINE;
 
     private static final int API_LEVEL = 15;
-    private static final int MAX_NODE_VISITS = 10000;
+    private static final int MAX_NODE_VISITS = 1000;
     private static final int MAX_CALL_DEPTH = 10;
 
     public static void main(String[] argv) throws Exception {

File: src/simplify/MethodSimplifier.java
Patch:
@@ -134,7 +134,7 @@ private static BuilderInstruction getConstantInstruction(DexBuilder dexBuilder,
                     Object value) {
         BuilderInstruction result = null;
 
-        System.out.println("get constant for " + registerA + " + type: " + type + " value: " + value);
+        log.fine("build constant for r" + registerA + ", type=" + type + ", value=" + value);
 
         if (type.equals("I") || type.equals("B") || type.equals("S") || type.equals("C")) {
             // Bytes, shorts and characters are all represented by const/4 or const/16.

File: src/simplify/exec/MethodExecutionContext.java
Patch:
@@ -170,7 +170,6 @@ public Object peekRegisterValue(int register) {
     }
 
     public void setResultRegister(RegisterStore rs) {
-        // Basically make a shallow copy. Don't want updates to this to update the argument.
         resultRegister = new RegisterStore(rs.getType(), rs.getValue());
     }
 

File: src/simplify/Main.java
Patch:
@@ -37,7 +37,7 @@ public class Main {
 
     private static Logger log = Logger.getLogger(Main.class.getSimpleName());
 
-    private static final Level LOG_LEVEL = Level.INFO;
+    private static final Level LOG_LEVEL = Level.FINER;
 
     private static final int API_LEVEL = 15;
     private static final int MAX_NODE_VISITS = 10000;

File: MethodSimplifier.java
Patch:
@@ -98,8 +98,8 @@ private static boolean propagateConstants(DexBuilder dexBuilder, BuilderMethod m
 
                 if (opName.startsWith("return")) {
                     /*
-                     * Only emit a constant before a return if instruction directly before it is not a constant. This
-                     * will cover some cases of an "unknown" return, but many "known" cases look like this as well.
+                     * Only emit a constant before a "return" if instruction directly before it is not a constant type.
+                     * This will cover some cases of an "unknown" return, but many "known" cases look like this as well.
                      * That's fine because this step will *ensure* previous instruction is a constant if it's known. So
                      * this should only happen once, at most.
                      */

File: exec/InstructionExecutor.java
Patch:
@@ -506,7 +506,7 @@ public static List<Integer> execute(List<BuilderClassDef> classes,
             }
         }
 
-        // If the op is unhandled, take any branches or set any values to unknown.
+        // If the op is unhandled, take all possible branches or set any values to unknown.
         if (!handled) {
             if (instruction instanceof OffsetInstruction) {
                 int branchOffset = ((OffsetInstruction) instruction).getCodeOffset();

File: exec/RegisterStore.java
Patch:
@@ -26,7 +26,7 @@ public RegisterStore(String type, Object value, Set<Integer> used, Set<Integer>
     @Override
     public RegisterStore clone() {
         Cloner cloner = new Cloner();
-        Object valueClone = cloner.shallowClone(getValue());
+        Object valueClone = cloner.deepClone(getValue());
         Set<Integer> newUsed = new HashSet<Integer>(getUsed());
         Set<Integer> newReferenced = new HashSet<Integer>(getReferenced());
 

File: exec/instruction/InvokeInstruction.java
Patch:
@@ -41,9 +41,11 @@ public static void execute(MethodExecutionContext ectx, Instruction instruction,
             MethodEmulator.emulate(calledMethodContext, methodDescriptor);
 
             if (!method.getReturnType().equals("V")) {
+                // Non-void method should have a return type.
                 ectx.setResultRegister(calledMethodContext.getReturnRegister());
             }
         } else {
+            // Not an emulated method
             List<BuilderMethod> methods = new ArrayList<BuilderMethod>();
             for (BuilderClassDef classDef : classes) {
                 methods.addAll(classDef.getMethods());
@@ -60,7 +62,7 @@ public static void execute(MethodExecutionContext ectx, Instruction instruction,
                 ectx.setResultRegister(new RegisterStore("?", new UnknownValue()));
             }
 
-            // Also, any non-final classes passed as non-final parameters could have changed.
+            // Any non-final classes passed as non-final parameters could have changed.
             int paramStart = calledMethodContext.getParameterStart();
             for (int i = paramStart; i < calledMethodContext.getRegisterCount(); i++) {
                 RegisterStore rs = calledMethodContext.getRegister(i, 0);

File: exec/instruction/MoveInstruction.java
Patch:
@@ -15,9 +15,7 @@ public class MoveInstruction {
     public static void execute(MethodExecutionContext ectx, TwoRegisterInstruction instruction, int index) {
         int registerA = instruction.getRegisterA();
         int registerB = instruction.getRegisterB();
-        // log.finer("moving to " + registerA + " from " + registerB);
         RegisterStore rs = ectx.getRegister(registerB, index);
-
         ectx.addRegister(registerA, rs);
     }
 

File: Simplifier.java
Patch:
@@ -37,10 +37,10 @@ public class Simplifier {
 
     private static Logger log = Logger.getLogger(Simplifier.class.getSimpleName());
 
-    private static final Level LOG_LEVEL = Level.FINER;
+    private static final Level LOG_LEVEL = Level.INFO;
 
     private static final int API_LEVEL = 15;
-    private static final int MAX_NODE_VISITS = 10;
+    private static final int MAX_NODE_VISITS = 100;
     private static final int MAX_CALL_DEPTH = 10;
 
     public static void main(String[] argv) throws Exception {

File: emulate/EmulatedMethod.java
Patch:
@@ -1,5 +1,7 @@
 package simplify.emulate;
 
-public interface EmulatedMethod {
+import simplify.exec.MethodExecutionContext;
 
+public interface EmulatedMethod {
+    public void execute(MethodExecutionContext ectx);
 }

File: emulate/java_lang_Integer_init.java
Patch:
@@ -2,11 +2,13 @@
 
 import simplify.exec.MethodExecutionContext;
 
-public class java_lang_Integer_init implements EmulatedVirtualMethod {
+public class java_lang_Integer_init implements EmulatedMethod {
+
     public void execute(MethodExecutionContext ectx) {
         int paramStart = ectx.getParameterStart();
         Object value = ectx.peekRegisterValue(paramStart + 1);
 
         ectx.updateOrAddRegister(paramStart, "Ljava/lang/Integer;", value, 0);
     }
+
 }
\ No newline at end of file

File: emulate/java_lang_Integer_intValue.java
Patch:
@@ -2,14 +2,14 @@
 
 import simplify.exec.MethodExecutionContext;
 
-public class java_lang_Integer_intValue implements EmulatedVirtualMethod {
+public class java_lang_Integer_intValue implements EmulatedMethod {
 
-    @Override
     public void execute(MethodExecutionContext ectx) {
         int paramStart = ectx.getParameterStart();
         Object value = ectx.getRegisterValue(paramStart, 0);
 
         ectx.addRegister(paramStart, "I", value, 0);
         ectx.setReturnRegister(paramStart, 0);
     }
+
 }

File: emulate/EmulatedMethod.java
Patch:
@@ -1,4 +1,5 @@
 package simplify.emulate;
 
 public interface EmulatedMethod {
+
 }

File: emulate/java_lang_Integer_init.java
Patch:
@@ -5,8 +5,8 @@
 public class java_lang_Integer_init implements EmulatedVirtualMethod {
     public void execute(MethodExecutionContext ectx) {
         int paramStart = ectx.getParameterStart();
-        System.out.println("init! : " + paramStart);
         Object value = ectx.peekRegisterValue(paramStart + 1);
-        ectx.updateOrAddRegister(paramStart, "java.lang.Integer", value, 0);
+
+        ectx.updateOrAddRegister(paramStart, "Ljava/lang/Integer;", value, 0);
     }
 }
\ No newline at end of file

