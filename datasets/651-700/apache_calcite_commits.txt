File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -210,7 +210,7 @@ private SqlValidatorNamespace resolveImpl(SqlIdentifier id) {
       }
     }
 
-    this.mustFilterFields = resolvedNamespace.getMustFilterFields();
+    filterRequirement = resolvedNamespace.getFilterRequirement();
     RelDataType rowType = resolvedNamespace.getRowType();
 
     if (extendList != null) {

File: core/src/main/java/org/apache/calcite/sql/validate/WithItemNamespace.java
Patch:
@@ -41,7 +41,7 @@ class WithItemNamespace extends AbstractNamespace {
     final SqlValidatorNamespace childNs =
         validator.getNamespaceOrThrow(getQuery());
     final RelDataType rowType = childNs.getRowTypeSansSystemColumns();
-    mustFilterFields = childNs.getMustFilterFields();
+    filterRequirement = childNs.getFilterRequirement();
     SqlNodeList columnList = withItem.columnList;
     if (columnList == null) {
       return rowType;

File: core/src/main/java/org/apache/calcite/sql/validate/WithNamespace.java
Patch:
@@ -64,7 +64,7 @@ public class WithNamespace extends AbstractNamespace {
     validator.validateQuery(with.body, scope2, targetRowType);
     final RelDataType rowType = validator.getValidatedNodeType(with.body);
     validator.setValidatedNodeType(with, rowType);
-    mustFilterFields = bodyNamespace.getMustFilterFields();
+    filterRequirement = bodyNamespace.getFilterRequirement();
     return rowType;
   }
 

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
Patch:
@@ -66,7 +66,7 @@
  *
  * <p>The sections which contain windowed agg functions become instances of
  * {@link org.apache.calcite.rel.logical.LogicalWindow}.
- * If the {@link org.apache.calcite.rel.logical.LogicalCalc} does not contain
+ * If the {@link org.apache.calcite.rel.core.Project} does not contain
  * any windowed agg functions, does nothing.
  *
  * <p>There is also a variant that matches

File: core/src/main/java/org/apache/calcite/sql/SqlUnknownLiteral.java
Patch:
@@ -65,6 +65,8 @@ public SqlLiteral resolve(SqlTypeName typeName) {
       return SqlParserUtil.parseTimestampWithLocalTimeZoneLiteral(getValue(), pos);
     case TIMESTAMP_TZ:
       return SqlParserUtil.parseTimestampTzLiteral(getValue(), pos);
+    case UUID:
+      return SqlParserUtil.parseUuidLiteral(getValue(), pos);
     default:
       throw Util.unexpected(typeName);
     }

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
Patch:
@@ -204,6 +204,9 @@ private SqlTypeAssignmentRule(
     // SYMBOL is assignable from ...
     rules.add(SqlTypeName.SYMBOL, EnumSet.of(SqlTypeName.SYMBOL));
 
+    // UUID is assignable from
+    rules.add(SqlTypeName.UUID, EnumSet.of(SqlTypeName.UUID));
+
     // ANY is assignable from ...
     rule.clear();
     rule.add(SqlTypeName.TINYINT);

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -133,6 +133,7 @@ public enum SqlTypeName {
   MEASURE(PrecScale.NO_NO, true, Types.OTHER, SqlTypeFamily.ANY),
   FUNCTION(PrecScale.NO_NO, true, Types.OTHER, SqlTypeFamily.FUNCTION),
   SARG(PrecScale.NO_NO, true, Types.OTHER, SqlTypeFamily.ANY),
+  UUID(PrecScale.NO_NO, false, Types.OTHER, SqlTypeFamily.UUID),
   /** VARIANT data type, a dynamically-typed value that can have at runtime
    * any of the other data types in this table. */
   VARIANT(PrecScale.NO_NO, false, Types.OTHER, SqlTypeFamily.VARIANT);
@@ -174,7 +175,7 @@ public enum SqlTypeName {
       ImmutableList.of(BOOLEAN);
 
   public static final List<SqlTypeName> BINARY_TYPES =
-      ImmutableList.of(BINARY, VARBINARY);
+      ImmutableList.of(BINARY, VARBINARY, UUID);
 
   public static final List<SqlTypeName> INT_TYPES =
       ImmutableList.of(TINYINT, SMALLINT, INTEGER, BIGINT);

File: core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.calcite.util.Util;
 
 import java.math.BigDecimal;
+import java.util.UUID;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -92,6 +93,8 @@ public class SqlNodeToRexConverterImpl implements SqlNodeToRexConverter {
     }
 
     switch (literal.getTypeName()) {
+    case UUID:
+      return rexBuilder.makeUuidLiteral(literal.getValueAs(UUID.class));
     case DECIMAL:
       // exact number
       BigDecimal bd = literal.getValueAs(BigDecimal.class);

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -327,7 +327,7 @@ private static ResultSet getTableTypes(Connection connection) {
     CalciteAssert.hr()
         .with(CalciteRemoteDriverTest::getRemoteConnection)
         .metaData(CalciteRemoteDriverTest::getTypeInfo)
-        .returns(CalciteAssert.checkResultCount(is(44)));
+        .returns(CalciteAssert.checkResultCount(is(45)));
   }
 
   @Test void testRemoteTableTypes() {

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -249,6 +249,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(UNKNOWN)",
           "KEYWORD(UPPER)",
           "KEYWORD(USER)",
+          "KEYWORD(UUID)",
           "KEYWORD(VAR_POP)",
           "KEYWORD(VAR_SAMP)",
           "KEYWORD(YEAR)");

File: testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -571,6 +571,7 @@ public class SqlParserTest {
       "USAGE",                         "92", "99",
       "USER",                          "92", "99", "2003", "2011", "2014", "c",
       "USING",                         "92", "99", "2003", "2011", "2014", "c",
+      "UUID",                                                              "c",
       "VALUE",                         "92", "99", "2003", "2011", "2014", "c",
       "VALUES",                        "92", "99", "2003", "2011", "2014", "c",
       "VALUE_OF",                                                  "2014", "c",

File: testkit/src/main/java/org/apache/calcite/util/TestUtil.java
Patch:
@@ -229,6 +229,7 @@ public static String quotePattern(String s) {
         .replace(")", "\\)")
         .replace("[", "\\[")
         .replace("]", "\\]")
+        .replace("\n", "\\n")
         .replace("^", "\\^");
   }
 

File: arrow/src/main/java/org/apache/calcite/adapter/arrow/ArrowFieldTypeFactory.java
Patch:
@@ -80,6 +80,8 @@ private static RelDataType of(ArrowType arrowType, JavaTypeFactory typeFactory)
       return typeFactory.createSqlType(SqlTypeName.DECIMAL,
           ((ArrowType.Decimal) arrowType).getPrecision(),
           ((ArrowType.Decimal) arrowType).getScale());
+    case Time:
+      return typeFactory.createSqlType(SqlTypeName.TIME);
     default:
       throw new IllegalArgumentException("Unsupported type: " + arrowType);
     }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -4480,7 +4480,7 @@ private void checkNegWindow(String s, String msg) {
     expr("(1,2) in ((1,2), (3,4))")
         .columnType("BOOLEAN NOT NULL");
     expr("'medium' in (cast(null as varchar(10)), 'bc')")
-        .columnType("BOOLEAN NOT NULL");
+        .columnType("BOOLEAN");
 
     // nullability depends on nullability of both sides
     sql("select empno in (1, 2) from emp")

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -1945,6 +1945,8 @@ void testLikeAndSimilarFails() {
     sql("select row((select deptno from dept where dept.deptno = emp.deptno), emp.ename)\n"
         + "from emp")
         .columnType("RecordType(INTEGER EXPR$0, VARCHAR(20) NOT NULL EXPR$1) NOT NULL");
+    sql("select ROW^(x'12') <> ROW(0.01)^")
+        .fails("Cannot apply '<>' to arguments of type.*");
   }
 
   @Test void testRowWithValidDot() {

File: core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java
Patch:
@@ -404,6 +404,8 @@ private static ImmutableList<RelDataType> combine(
         null);
     f.comparisonCommonType(f.recordType("a", f.intType),
         f.recordType("a", f.intType), f.recordType("a", f.intType));
+    f.comparisonCommonType(f.recordType("a", f.intType),
+        f.recordType("a", f.charType), f.recordType("a", f.intType));
     f.comparisonCommonType(f.recordType("a", f.arrayType(f.intType)),
         f.recordType("a", f.arrayType(f.intType)),
         f.recordType("a", f.arrayType(f.intType)));

File: piglet/src/test/java/org/apache/calcite/test/PigRelOpTest.java
Patch:
@@ -1531,7 +1531,7 @@ private Fluent pig(String script) {
     final String plan = ""
         + "LogicalSort(sort0=[$6], dir0=[ASC])\n"
         + "  LogicalProject(DEPTNO=[$0.DEPTNO], MGR=[$0.MGR], HIREDATE=[$0.HIREDATE], "
-        + "$f3=[COUNT(PIG_BAG($1))], newCol=[1:BIGINT], comArray=[MULTISET_PROJECTION($1, 6)], "
+        + "$f3=[COUNT(PIG_BAG($1))], newCol=[1:BIGINT], comArray=[CAST(MULTISET_PROJECTION($1, 6)):RecordType(DECIMAL(19, 0) COMM) MULTISET], "
         + "salSum=[BigDecimalSum(PIG_BAG(MULTISET_PROJECTION($1, 5)))])\n"
         + "    LogicalProject(group=[ROW($0, $1, $2)], A=[$3])\n"
         + "      LogicalAggregate(group=[{0, 1, 2}], A=[COLLECT($3)])\n"
@@ -1541,14 +1541,14 @@ private Fluent pig(String script) {
     final String optimizedPlan = ""
         + "LogicalSort(sort0=[$6], dir0=[ASC])\n"
         + "  LogicalProject(DEPTNO=[$0], MGR=[$1], HIREDATE=[$2], $f3=[CAST($3):BIGINT], "
-        + "newCol=[1:BIGINT], comArray=[$4], salSum=[CAST($5):DECIMAL(19, 0)])\n"
+        + "newCol=[1:BIGINT], comArray=[CAST($4):RecordType(DECIMAL(19, 0) COMM) MULTISET], salSum=[CAST($5):DECIMAL(19, 0)])\n"
         + "    LogicalAggregate(group=[{0, 1, 2}], agg#0=[COUNT()], agg#1=[COLLECT($3)], "
         + "agg#2=[SUM($4)])\n"
         + "      LogicalProject(DEPTNO=[$7], MGR=[$3], HIREDATE=[$4], COMM=[$6], SAL=[$5])\n"
         + "        LogicalTableScan(table=[[scott, EMP]])\n";
     final String sql = ""
         + "SELECT DEPTNO, MGR, HIREDATE, CAST(COUNT(*) AS BIGINT) AS $f3, 1 AS newCol, "
-        + "COLLECT(COMM) AS comArray, CAST(SUM(SAL) AS DECIMAL(19, 0)) AS salSum\n"
+        + "CAST(COLLECT(COMM) AS ROW(COMM DECIMAL(19, 0)) MULTISET) AS comArray, CAST(SUM(SAL) AS DECIMAL(19, 0)) AS salSum\n"
         + "FROM scott.EMP\n"
         + "GROUP BY DEPTNO, MGR, HIREDATE\n"
         + "ORDER BY 7";

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -859,8 +859,7 @@ boolean canRemoveCastFromLiteral(RelDataType toType,
       return true;
     }
     final SqlTypeName sqlType = toType.getSqlTypeName();
-    if (sqlType == SqlTypeName.MEASURE
-        || sqlType == SqlTypeName.VARIANT) {
+    if (sqlType == SqlTypeName.MEASURE || sqlType == SqlTypeName.VARIANT) {
       return false;
     }
     if (!RexLiteral.valueMatchesType(value, sqlType, false)) {

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.runtime.FlatLists;
 import org.apache.calcite.runtime.SpatialTypeFunctions;
+import org.apache.calcite.runtime.variant.VariantValue;
 import org.apache.calcite.sql.SqlCollation;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlOperator;
@@ -43,7 +44,6 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.TimestampWithTimeZoneString;
 import org.apache.calcite.util.Util;
-import org.apache.calcite.util.Variant;
 
 import com.google.common.collect.ImmutableList;
 
@@ -317,7 +317,7 @@ public static boolean valueMatchesType(
     }
     switch (typeName) {
     case VARIANT:
-      return value instanceof Variant;
+      return value instanceof VariantValue;
     case BOOLEAN:
       // Unlike SqlLiteral, we do not allow boolean null.
       return value instanceof Boolean;

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.calcite.rel.type.TimeFrame;
 import org.apache.calcite.rel.type.TimeFrameSet;
 import org.apache.calcite.runtime.FlatLists.ComparableList;
+import org.apache.calcite.runtime.variant.VariantValue;
 import org.apache.calcite.sql.SqlIntervalQualifier;
 import org.apache.calcite.sql.SqlUtil;
 import org.apache.calcite.sql.fun.SqlLibraryOperators;
@@ -47,7 +48,6 @@
 import org.apache.calcite.util.TryThreadLocal;
 import org.apache.calcite.util.Unsafe;
 import org.apache.calcite.util.Util;
-import org.apache.calcite.util.Variant;
 import org.apache.calcite.util.format.FormatElement;
 import org.apache.calcite.util.format.FormatModel;
 import org.apache.calcite.util.format.FormatModels;
@@ -5767,8 +5767,8 @@ public static String replace(String s, String search, String replacement) {
    * known until runtime.
    */
   public static @Nullable Object item(Object object, Object index) {
-    if (object instanceof Variant) {
-      return ((Variant) object).item(index);
+    if (object instanceof VariantValue) {
+      return ((VariantValue) object).item(index);
     }
     if (object instanceof Map) {
       return mapItem((Map) object, index);

File: core/src/main/java/org/apache/calcite/runtime/rtti/package-info.java
Patch:
@@ -18,4 +18,4 @@
 /**
  * Support for runtime type information.
  */
-package org.apache.calcite.util.rtti;
+package org.apache.calcite.runtime.rtti;

File: core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
Patch:
@@ -401,6 +401,9 @@ public static SqlOperandTypeChecker variadic(
   public static final SqlSingleOperandTypeChecker INTEGER_INTEGER =
       family(SqlTypeFamily.INTEGER, SqlTypeFamily.INTEGER);
 
+  public static final SqlSingleOperandTypeChecker VARIANT =
+      family(SqlTypeFamily.VARIANT);
+
   public static final SqlSingleOperandTypeChecker NUMERIC_OPTIONAL_NUMERIC =
       family(ImmutableList.of(SqlTypeFamily.NUMERIC, SqlTypeFamily.NUMERIC),
           // Second operand optional (operand index 0, 1)

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.TimestampWithTimeZoneString;
 import org.apache.calcite.util.Util;
+import org.apache.calcite.util.Variant;
 
 import com.google.common.collect.ImmutableList;
 
@@ -315,6 +316,8 @@ public static boolean valueMatchesType(
       return true;
     }
     switch (typeName) {
+    case VARIANT:
+      return value instanceof Variant;
     case BOOLEAN:
       // Unlike SqlLiteral, we do not allow boolean null.
       return value instanceof Boolean;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlItemOperator.java
Patch:
@@ -137,8 +137,8 @@ private static SqlSingleOperandTypeChecker getChecker(SqlCallBinding callBinding
     if (name.equals("ITEM")) {
       return "<ARRAY>[<INTEGER>]\n"
           + "<MAP>[<ANY>]\n"
-          + "<ROW>[<CHARACTER>|<INTEGER>]"
-          + "<VARIANT>[<CHARACTER>|<INTEGER>]";
+          + "<ROW>[<CHARACTER>|<INTEGER>]\n"
+          + "<VARIANT>[<ANY>]";
     } else {
       return "<ARRAY>[" + name + "(<INTEGER>)]";
     }

File: core/src/main/java/org/apache/calcite/sql/type/JavaToSqlTypeConversionRules.java
Patch:
@@ -81,7 +81,6 @@ public class JavaToSqlTypeConversionRules {
           .put(List.class, SqlTypeName.ARRAY)
           .put(Map.class, SqlTypeName.MAP)
           .put(Void.class, SqlTypeName.NULL)
-          .put(Object.class, SqlTypeName.VARIANT)
           .build();
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -277,7 +277,6 @@ public enum SqlTypeName {
           .put(Types.DISTINCT, DISTINCT)
           .put(Types.STRUCT, STRUCTURED)
           .put(Types.ARRAY, ARRAY)
-          .put(Types.JAVA_OBJECT, VARIANT)
           .build();
 
   /**

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -116,6 +116,7 @@
 import org.apache.calcite.sql.SqlJsonQueryEmptyOrErrorBehavior;
 import org.apache.calcite.sql.SqlJsonQueryWrapperBehavior;
 import org.apache.calcite.sql.SqlJsonValueEmptyOrErrorBehavior;
+import org.apache.calcite.util.rtti.RuntimeTypeInformation;
 
 import com.google.common.collect.ImmutableMap;
 
@@ -935,7 +936,8 @@ public enum BuiltInMethod {
       long.class),
   BIG_DECIMAL_ADD(BigDecimal.class, "add", BigDecimal.class),
   BIG_DECIMAL_NEGATE(BigDecimal.class, "negate"),
-  COMPARE_TO(Comparable.class, "compareTo", Object.class);
+  COMPARE_TO(Comparable.class, "compareTo", Object.class),
+  VARIANT_CAST(Variant.class, "cast", Object.class, RuntimeTypeInformation.class);
 
   @SuppressWarnings("ImmutableEnumChecker")
   public final Method method;

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -327,7 +327,7 @@ private static ResultSet getTableTypes(Connection connection) {
     CalciteAssert.hr()
         .with(CalciteRemoteDriverTest::getRemoteConnection)
         .metaData(CalciteRemoteDriverTest::getTypeInfo)
-        .returns(CalciteAssert.checkResultCount(is(43)));
+        .returns(CalciteAssert.checkResultCount(is(44)));
   }
 
   @Test void testRemoteTableTypes() {

File: testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -576,6 +576,7 @@ public class SqlParserTest {
       "VALUE_OF",                                                  "2014", "c",
       "VARBINARY",                                         "2011", "2014", "c",
       "VARCHAR",                       "92", "99", "2003", "2011", "2014", "c",
+      "VARIANT",                                                           "c",
       "VARYING",                       "92", "99", "2003", "2011", "2014", "c",
       "VAR_POP",                                           "2011", "2014", "c",
       "VAR_SAMP",                                          "2011", "2014", "c",

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -2226,7 +2226,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
    * <p>MAP is not standard SQL.
    */
   public static final SqlOperator ITEM =
-      new SqlItemOperator("ITEM", OperandTypes.ARRAY_OR_MAP, 1, true);
+      new SqlItemOperator("ITEM", OperandTypes.ARRAY_OR_MAP_OR_VARIANT, 1, true);
 
   /**
    * The ARRAY Value Constructor. e.g. "<code>ARRAY[1, 2, 3]</code>".

File: core/src/main/java/org/apache/calcite/sql/type/JavaToSqlTypeConversionRules.java
Patch:
@@ -81,6 +81,7 @@ public class JavaToSqlTypeConversionRules {
           .put(List.class, SqlTypeName.ARRAY)
           .put(Map.class, SqlTypeName.MAP)
           .put(Void.class, SqlTypeName.NULL)
+          .put(Object.class, SqlTypeName.VARIANT)
           .build();
 
   //~ Methods ----------------------------------------------------------------

File: core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java
Patch:
@@ -384,9 +384,11 @@ private static ImmutableList<RelDataType> combine(
         f.typeFactory.createSqlType(SqlTypeName.DECIMAL, 7, 1);
     RelDataType decimal104 =
         f.typeFactory.createSqlType(SqlTypeName.DECIMAL, 10, 4);
+    RelDataType decimal144 =
+        f.typeFactory.createSqlType(SqlTypeName.DECIMAL, 14, 4);
     f.comparisonCommonType(decimal54, decimal71, decimal104);
     f.comparisonCommonType(decimal54, f.doubleType, f.doubleType);
-    f.comparisonCommonType(decimal54, f.intType, decimal104);
+    f.comparisonCommonType(decimal54, f.intType, decimal144);
     // CHAR/VARCHAR
     f.comparisonCommonType(f.charType, f.varcharType, f.varcharType);
     f.comparisonCommonType(f.intType, f.charType, f.intType);

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -2604,7 +2604,7 @@ public static byte checkedDivide(byte b0, byte b1) {
   }
 
   public static short checkedDivide(short b0, short b1) {
-    return intToShort(b0 * b1);
+    return intToShort(b0 / b1);
   }
 
   public static int checkedDivide(int b0, int b1) {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -303,8 +303,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
   @LibraryOperator(libraries = {ORACLE, REDSHIFT, SPARK})
   public static final SqlBasicFunction NVL2 =
       SqlBasicFunction.create(SqlKind.NVL2,
-          ReturnTypes.NVL2_RESTRICTIVE
-              .andThen(SqlTypeTransforms.TO_NULLABLE_ALL),
+          ReturnTypes.NVL2_RESTRICTIVE,
           OperandTypes.SECOND_THIRD_SAME);
 
   /** The "IFNULL(value, value)" function. */

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -11692,9 +11692,9 @@ void assertSubFunReturns(boolean binary, String s, int start,
       f12.checkScalar("NVL2(NULL, 3.0, 2.111)", "2.111", "DECIMAL(4, 3) NOT NULL");
       f12.checkScalar("NVL2(3.111, 3.1415926, 2.111)", "3.1415926", "DECIMAL(8, 7) NOT NULL");
 
-      f12.checkNull("nvl2('ab', CAST(NULL AS VARCHAR(6)), 'def')");
-      f12.checkNull("nvl2(NULL, 'abc', NULL)");
-      f12.checkNull("nvl2(NULL, NULL, NULL)");
+      f12.checkNullValueWithNullableType("nvl2('ab', CAST(NULL AS VARCHAR(6)), 'def')");
+      f12.checkNullValueWithNullableType("nvl2(NULL, 'abc', NULL)");
+      f12.checkNullValueWithNullableType("nvl2(NULL, NULL, NULL)");
 
       f12.checkFails("^NVL2(2.0, 2.0, true)^", "Parameters must be of the same type", false);
       f12.checkFails("^NVL2(NULL, 2.0, true)^", "Parameters must be of the same type", false);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -468,7 +468,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding,
   @LibraryOperator(libraries = {HIVE, SPARK})
   public static final SqlFunction PARSE_URL =
       SqlBasicFunction.create("PARSE_URL",
-              ReturnTypes.VARCHAR_NULLABLE,
+              ReturnTypes.VARCHAR_FORCE_NULLABLE,
               OperandTypes.STRING_STRING_OPTIONAL_STRING,
               SqlFunctionCategory.STRING);
 
@@ -1836,7 +1836,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   @LibraryOperator(libraries = {BIG_QUERY, MYSQL})
   public static final SqlFunction FROM_BASE64 =
       SqlBasicFunction.create("FROM_BASE64",
-          ReturnTypes.VARBINARY_NULLABLE,
+          ReturnTypes.VARBINARY_FORCE_NULLABLE,
           OperandTypes.STRING, SqlFunctionCategory.STRING);
 
   @LibraryOperator(libraries = {MYSQL})

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -2284,7 +2284,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   @LibraryOperator(libraries = {BIG_QUERY, ORACLE, POSTGRESQL})
   public static final SqlFunction CHR =
       SqlBasicFunction.create("CHR",
-          ReturnTypes.CHAR,
+          ReturnTypes.CHAR_NULLABLE_IF_ARGS_NULLABLE,
           OperandTypes.INTEGER,
           SqlFunctionCategory.STRING);
 

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -2213,6 +2213,9 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
       f.checkScalar("chr(48)", "0", "CHAR(1) NOT NULL");
       f.checkScalar("chr(0)", String.valueOf('\u0000'), "CHAR(1) NOT NULL");
       f.checkNull("chr(null)");
+      // Test case for [CALCITE-6707] Type inference for CHR function is wrong
+      // https://issues.apache.org/jira/browse/CALCITE-6707
+      f.checkType("chr(CAST(null AS INTEGER))", "CHAR(1)");
     };
     final List<SqlLibrary> libraries =
         list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE, SqlLibrary.POSTGRESQL);

File: innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java
Patch:
@@ -73,8 +73,7 @@ protected InnodbToEnumerableConverter(
 
   @Override public @Nullable RelOptCost computeSelfCost(RelOptPlanner planner,
       RelMetadataQuery mq) {
-    final RelOptCost cost = requireNonNull(super.computeSelfCost(planner, mq));
-    return cost.multiplyBy(.1);
+    return requireNonNull(super.computeSelfCost(planner, mq));
   }
 
   static List<String> innodbFieldNames(final RelDataType rowType) {

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -502,7 +502,7 @@ ExInst<SqlValidatorException> intervalFieldExceedsPrecision(Number a0,
   @BaseMessage("QUALIFY expression ''{0}'' must contain a window function")
   ExInst<SqlValidatorException> qualifyExpressionMustContainWindowFunction(String a0);
 
-  @BaseMessage("ROW/RANGE not allowed with RANK, DENSE_RANK, ROW_NUMBER or PERCENTILE_CONT/DISC functions")
+  @BaseMessage("ROW/RANGE not allowed with RANK, DENSE_RANK, ROW_NUMBER, PERCENTILE_CONT/DISC or LAG/LEAD functions")
   ExInst<SqlValidatorException> rankWithFrame();
 
   @BaseMessage("RANK or DENSE_RANK functions require ORDER BY clause in window specification")

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -421,14 +421,14 @@ protected void registerMaterializations() {
       return false;
     }
 
+    final boolean isTransFormRule = rule instanceof TransformationRule;
     // Each of this rule's operands is an 'entry point' for a rule call.
     // Register each operand against all concrete sub-classes that could match
     // it.
     for (RelOptRuleOperand operand : rule.getOperands()) {
       for (Class<? extends RelNode> subClass
           : subClasses(operand.getMatchedClass())) {
-        if (PhysicalNode.class.isAssignableFrom(subClass)
-            && rule instanceof TransformationRule) {
+        if (isTransFormRule && PhysicalNode.class.isAssignableFrom(subClass)) {
           continue;
         }
         classOperands.put(subClass, operand);

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -4100,7 +4100,6 @@ protected void validateSelect(
 
     validateWhereClause(select);
     validateGroupClause(select);
-    validateHavingClause(select);
     validateWindowClause(select);
     validateQualifyClause(select);
     handleOffsetFetch(select.getOffset(), select.getFetch());
@@ -4111,6 +4110,7 @@ protected void validateSelect(
     final RelDataType rowType =
         validateSelectList(selectItems, select, targetRowType);
     ns.setType(rowType);
+    validateHavingClause(select);
 
     // Deduce which columns must be filtered.
     ns.mustFilterFields = ImmutableBitSet.of();
@@ -4995,8 +4995,8 @@ protected void validateHavingClause(SqlSelect select) {
     if (SqlUtil.containsCall(having, call -> call.getOperator() instanceof SqlOverOperator)) {
       throw newValidationError(originalHaving, RESOURCE.windowInHavingNotAllowed());
     }
-    havingScope.checkAggregateExpr(having, true);
     inferUnknownTypes(booleanType, havingScope, having);
+    havingScope.checkAggregateExpr(having, true);
     having.validate(this, havingScope);
     final RelDataType type = deriveType(havingScope, having);
     if (!SqlTypeUtil.inBooleanFamily(type)) {

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -2001,7 +2001,7 @@ public RexNode makeLiteral(@Nullable Object value, RelDataType type,
     case CHAR:
       final NlsString nlsString = (NlsString) value;
       if (trim) {
-        return makeCharLiteral(nlsString.rtrim());
+        return makeCharLiteral(nlsString.rtrim(type.getPrecision()));
       } else {
         return makeCharLiteral(padRight(nlsString, type.getPrecision()));
       }

File: arrow/src/main/java/org/apache/calcite/adapter/arrow/ArrowFieldType.java
Patch:
@@ -24,7 +24,7 @@
 import org.apache.arrow.vector.types.pojo.ArrowType;
 
 import java.math.BigDecimal;
-import java.util.Date;
+import java.sql.Date;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;

File: core/src/main/java/org/apache/calcite/plan/RelOptRules.java
Patch:
@@ -131,6 +131,7 @@ private RelOptRules() {
           CoreRules.JOIN_TO_SEMI_JOIN,
           CoreRules.AGGREGATE_REMOVE,
           CoreRules.UNION_TO_DISTINCT,
+          CoreRules.UNION_TO_VALUES,
           CoreRules.PROJECT_REMOVE,
           CoreRules.PROJECT_AGGREGATE_MERGE,
           CoreRules.AGGREGATE_JOIN_TRANSPOSE,

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -5017,7 +5017,7 @@ private void startOfGroupStep3(String startOfGroup) {
             + "group by grouping sets (deptno, deptno, deptno, (), ())\n"
             + "having group_id() > 0")
         .explainContains("EnumerableCalc(expr#0..2=[{inputs}], expr#3=[1], expr#4=[+($t1, $t3)], "
-            + "expr#5=[0], expr#6=[>($t1, $t5)], DEPTNO=[$t0], G=[$t4], C=[$t2], $condition=[$t6])\n"
+            + "expr#5=[0:BIGINT], expr#6=[>($t1, $t5)], DEPTNO=[$t0], G=[$t4], C=[$t2], $condition=[$t6])\n"
             + "  EnumerableUnion(all=[true])\n"
             + "    EnumerableCalc(expr#0..1=[{inputs}], expr#2=[0:BIGINT], DEPTNO=[$t0], $f1=[$t2], C=[$t1])\n"
             + "      EnumerableAggregate(group=[{7}], groups=[[{7}, {}]], C=[COUNT()])\n"

File: core/src/test/java/org/apache/calcite/test/StreamTest.java
Patch:
@@ -142,7 +142,7 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz
                 + "      LogicalProject(ROWTIME=[FLOOR($0, FLAG(HOUR))], PRODUCT=[$2])\n"
                 + "        LogicalTableScan(table=[[STREAMS, ORDERS]])\n")
         .explainContains(
-            "EnumerableCalc(expr#0..2=[{inputs}], expr#3=[1], expr#4=[>($t2, $t3)], proj#0..2=[{exprs}], $condition=[$t4])\n"
+            "EnumerableCalc(expr#0..2=[{inputs}], expr#3=[1:BIGINT], expr#4=[>($t2, $t3)], proj#0..2=[{exprs}], $condition=[$t4])\n"
                 + "  EnumerableAggregate(group=[{0, 1}], C=[COUNT()])\n"
                 + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[FLAG(HOUR)], expr#5=[FLOOR($t0, $t4)], ROWTIME=[$t5], PRODUCT=[$t2])\n"
                 + "      EnumerableInterpreter\n"

File: kafka/src/test/java/org/apache/calcite/adapter/kafka/KafkaAdapterTest.java
Patch:
@@ -84,7 +84,7 @@ private CalciteAssert.AssertThat assertModel(URL url) {
         .returnsUnordered(
             "MSG_PARTITION=0; MSG_OFFSET=1; MSG_VALUE_BYTES=myvalue1")
         .explainContains(
-            "PLAN=EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], expr#6=[>($t2, $t5)], MSG_PARTITION=[$t0], MSG_OFFSET=[$t2], MSG_VALUE_BYTES=[$t4], $condition=[$t6])\n"
+            "PLAN=EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0:BIGINT], expr#6=[>($t2, $t5)], MSG_PARTITION=[$t0], MSG_OFFSET=[$t2], MSG_VALUE_BYTES=[$t4], $condition=[$t6])\n"
                 + "  EnumerableInterpreter\n"
                 + "    BindableTableScan(table=[[KAFKA, MOCKTABLE, (STREAM)]])");
   }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -331,7 +331,7 @@ private RexNode reduceAgg(
         return reduceStddev(oldAggRel, oldCall, true, true, newCalls,
             aggCallMapping, inputExprs);
       case STDDEV_SAMP:
-        // replace original STDDEV_POP(x) with
+        // replace original STDDEV_SAMP(x) with
         //   SQRT(
         //     (SUM(x * x) - SUM(x) * SUM(x) / COUNT(x))
         //     / CASE COUNT(x) WHEN 1 THEN NULL ELSE COUNT(x) - 1 END)
@@ -344,7 +344,7 @@ private RexNode reduceAgg(
         return reduceStddev(oldAggRel, oldCall, true, false, newCalls,
             aggCallMapping, inputExprs);
       case VAR_SAMP:
-        // replace original VAR_POP(x) with
+        // replace original VAR_SAMP(x) with
         //     (SUM(x * x) - SUM(x) * SUM(x) / COUNT(x))
         //     / CASE COUNT(x) WHEN 1 THEN NULL ELSE COUNT(x) - 1 END
         return reduceStddev(oldAggRel, oldCall, false, false, newCalls,

File: file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java
Patch:
@@ -83,7 +83,7 @@ private static String resourcePath(String path) {
     assumeTrue(!r.equals("OpenJDK Runtime Environment")
             || getJavaMajorVersion() > 10,
         "Java 10+ should have root certificates (JEP 319). Runtime is "
-            + r + ", Jave major version is " + getJavaMajorVersion());
+            + r + ", Java major version is " + getJavaMajorVersion());
 
     FileReader t = new FileReader(STATES_SOURCE);
     t.refresh();

File: arrow/src/test/java/org/apache/calcite/adapter/arrow/ArrowAdapterTest.java
Patch:
@@ -374,7 +374,7 @@ static void initializeArrowState(@TempDir Path sharedTempDir)
     String sql = "select * from arrowdata\n"
         + " where \"floatField\"=15.0";
     String plan = "PLAN=ArrowToEnumerableConverter\n"
-        + "  ArrowFilter(condition=[=(CAST($2):DOUBLE, 15.0E0)])\n"
+        + "  ArrowFilter(condition=[=($2, 15.0E0)])\n"
         + "    ArrowTableScan(table=[[ARROW, ARROWDATA]], fields=[[0, 1, 2, 3]])\n\n";
     String result = "intField=15; stringField=15; floatField=15.0; longField=15\n";
 
@@ -666,7 +666,7 @@ static void initializeArrowState(@TempDir Path sharedTempDir)
   @Test void testFilteredAgg() {
     String sql = "select SUM(SAL) FILTER (WHERE COMM > 400) as SALESSUM from EMP";
     String plan = "PLAN=EnumerableAggregate(group=[{}], SALESSUM=[SUM($0) FILTER $1])\n"
-        + "  EnumerableCalc(expr#0..7=[{inputs}], expr#8=[400], expr#9=[>($t6, $t8)], "
+        + "  EnumerableCalc(expr#0..7=[{inputs}], expr#8=[400:DECIMAL(19, 0)], expr#9=[>($t6, $t8)], "
         + "expr#10=[IS TRUE($t9)], SAL=[$t5], $f1=[$t10])\n"
         + "    ArrowToEnumerableConverter\n"
         + "      ArrowTableScan(table=[[ARROW, EMP]], fields=[[0, 1, 2, 3, 4, 5, 6, 7]])\n\n";
@@ -684,7 +684,7 @@ static void initializeArrowState(@TempDir Path sharedTempDir)
     String sql = "select SUM(SAL) FILTER (WHERE COMM > 400) as SALESSUM from EMP group by EMPNO";
     String plan = "PLAN=EnumerableCalc(expr#0..1=[{inputs}], SALESSUM=[$t1])\n"
         + "  EnumerableAggregate(group=[{0}], SALESSUM=[SUM($1) FILTER $2])\n"
-        + "    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[400], expr#9=[>($t6, $t8)], "
+        + "    EnumerableCalc(expr#0..7=[{inputs}], expr#8=[400:DECIMAL(19, 0)], expr#9=[>($t6, $t8)], "
         + "expr#10=[IS TRUE($t9)], EMPNO=[$t0], SAL=[$t5], $f2=[$t10])\n"
         + "      ArrowToEnumerableConverter\n"
         + "        ArrowTableScan(table=[[ARROW, EMP]], fields=[[0, 1, 2, 3, 4, 5, 6, 7]])\n\n";

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercion.java
Patch:
@@ -93,8 +93,7 @@ public interface TypeCoercion {
       @Nullable RelDataType type1, @Nullable RelDataType type2);
 
   /**
-   * Determines common type for a comparison operator whose operands are STRING
-   * type and the other (non STRING) type.
+   * Determines common type for a comparison operator.
    */
   @Nullable RelDataType commonTypeForBinaryComparison(
       @Nullable RelDataType type1, @Nullable RelDataType type2);

File: core/src/test/java/org/apache/calcite/test/TCatalogReader.java
Patch:
@@ -49,7 +49,7 @@ public class TCatalogReader extends MockCatalogReader {
     t1.addColumn("t1_smallint", f.smallintType);
     t1.addColumn("t1_int", f.intType);
     t1.addColumn("t1_bigint", f.bigintType);
-    t1.addColumn("t1_float", f.floatType);
+    t1.addColumn("t1_real", f.realType);
     t1.addColumn("t1_double", f.doubleType);
     t1.addColumn("t1_decimal", f.decimalType);
     t1.addColumn("t1_timestamp", f.timestampType);
@@ -64,7 +64,7 @@ public class TCatalogReader extends MockCatalogReader {
     t2.addColumn("t2_smallint", f.smallintType);
     t2.addColumn("t2_int", f.intType);
     t2.addColumn("t2_bigint", f.bigintType);
-    t2.addColumn("t2_float", f.floatType);
+    t2.addColumn("t2_real", f.realType);
     t2.addColumn("t2_double", f.doubleType);
     t2.addColumn("t2_decimal", f.decimalType);
     t2.addColumn("t2_timestamp", f.timestampType);

File: core/src/test/java/org/apache/calcite/test/TypeCoercionConverterTest.java
Patch:
@@ -161,14 +161,14 @@ public static void checkActualAndReferenceFiles() {
     // char decimal float double
     // char decimal smallint double
     final String sql = "select t1_int, t1_decimal, t1_smallint, t1_double from t1 "
-        + "union select t2_varchar20, t2_decimal, t2_float, t2_bigint from t2 "
-        + "union select t1_varchar20, t1_decimal, t1_float, t1_double from t1 "
+        + "union select t2_varchar20, t2_decimal, t2_real, t2_bigint from t2 "
+        + "union select t1_varchar20, t1_decimal, t1_real, t1_double from t1 "
         + "union select t2_varchar20, t2_decimal, t2_smallint, t2_double from t2";
     sql(sql).ok();
   }
 
   @Test void testInsertQuerySourceCoercion() {
-    final String sql = "insert into t1 select t2_smallint, t2_int, t2_bigint, t2_float,\n"
+    final String sql = "insert into t1 select t2_smallint, t2_int, t2_bigint, t2_real,\n"
         + "t2_double, t2_decimal, t2_int, t2_date, t2_timestamp, t2_varchar20, t2_int from t2";
     sql(sql).ok();
   }

File: core/src/main/java/org/apache/calcite/rel/type/DelegatingTypeSystem.java
Patch:
@@ -56,10 +56,12 @@ protected DelegatingTypeSystem(RelDataTypeSystem typeSystem) {
     return typeSystem.getMinPrecision(typeName);
   }
 
+  @SuppressWarnings("deprecation")
   @Override public int getMaxNumericScale() {
     return typeSystem.getMaxNumericScale();
   }
 
+  @SuppressWarnings("deprecation")
   @Override public int getMaxNumericPrecision() {
     return typeSystem.getMaxNumericPrecision();
   }

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -1365,6 +1365,7 @@ public RexLiteral makeLiteral(boolean b) {
   /**
    * Creates a numeric literal.
    */
+  @SuppressWarnings("deprecation") // [CALCITE-6598]
   public RexLiteral makeExactLiteral(BigDecimal bd) {
     RelDataType relType;
     int scale = bd.scale();

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -1805,6 +1805,7 @@ public static boolean isAtomic(RelDataType type) {
 
   /** Returns a DECIMAL type with the maximum precision for the current
    * type system. */
+  @SuppressWarnings("deprecation") // [CALCITE-6598]
   public static RelDataType getMaxPrecisionScaleDecimal(RelDataTypeFactory factory) {
     int maxPrecision = factory.getTypeSystem().getMaxNumericPrecision();
     int maxScale = factory.getTypeSystem().getMaxNumericScale();

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -3419,6 +3419,7 @@ private void registerOperandSubQueries(
     }
   }
 
+  @SuppressWarnings("deprecation") // [CALCITE-6598]
   @Override public void validateLiteral(SqlLiteral literal) {
     switch (literal.getTypeName()) {
     case DECIMAL:

File: core/src/main/java/org/apache/calcite/plan/RelTraitDef.java
Patch:
@@ -59,7 +59,6 @@ public abstract class RelTraitDef<T extends RelTrait> {
    *
    * <p>Uses weak interner to allow GC.
    */
-  @SuppressWarnings("BetaApi")
   private final Interner<T> interner = Interners.newWeakInterner();
 
   //~ Constructors -----------------------------------------------------------
@@ -98,7 +97,6 @@ public boolean multiple() {
    * @param trait a possibly non-canonical RelTrait
    * @return a canonical RelTrait.
    */
-  @SuppressWarnings("BetaApi")
   public final T canonize(T trait) {
     if (!(trait instanceof RelCompositeTrait)) {
       assert getTraitClass().isInstance(trait)

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -917,7 +917,6 @@ protected RexCall reverseCall(RexCall call) {
 
     /** Converts a Sarg to SQL, generating "operand IN (c1, c2, ...)" if the
      * ranges are all points. */
-    @SuppressWarnings({"BetaApi", "UnstableApiUsage"})
     private <C extends Comparable<C>> SqlNode toSql(@Nullable RexProgram program,
         RexNode operand, RelDataType type, Sarg<C> sarg) {
       final List<SqlNode> orList = new ArrayList<>();
@@ -946,7 +945,6 @@ private <C extends Comparable<C>> SqlNode toSql(@Nullable RexProgram program,
       return SqlUtil.createCall(SqlStdOperatorTable.OR, POS, orList);
     }
 
-    @SuppressWarnings("BetaApi")
     private <C extends Comparable<C>> SqlNode toIn(SqlNode operandSql,
         SqlBinaryOperator eqOp, SqlBinaryOperator inOp,
         @Nullable RexProgram program, RelDataType type, RangeSet<C> rangeSet) {

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -147,7 +147,6 @@ static ImmutableSortedSet<TimeUnitRange> extractTimeUnits(RexNode e) {
 
   /** Replaces calls to EXTRACT, FLOOR and CEIL in an expression. */
   @VisibleForTesting
-  @SuppressWarnings("BetaApi")
   public static RexNode replaceTimeUnits(RexBuilder rexBuilder, RexNode e,
       String timeZone) {
     ImmutableSortedSet<TimeUnitRange> timeUnits = extractTimeUnits(e);
@@ -277,7 +276,6 @@ private ExtractFinder() {
   /** Walks over an expression, replacing calls to
    * {@code EXTRACT}, {@code FLOOR} and {@code CEIL} with date ranges. */
   @VisibleForTesting
-  @SuppressWarnings("BetaApi")
   static class ExtractShuttle extends RexShuttle {
     private final RexBuilder rexBuilder;
     private final TimeUnitRange timeUnit;

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -73,7 +73,6 @@ public abstract class RelDataTypeFactoryImpl implements RelDataTypeFactory {
   /**
    * Global cache for RelDataType.
    */
-  @SuppressWarnings("BetaApi")
   private static final Interner<RelDataType> DATATYPE_CACHE =
       Interners.newWeakInterner();
 
@@ -417,7 +416,6 @@ private RelDataType copyRecordType(
    *
    * @throws NullPointerException if type is null
    */
-  @SuppressWarnings("BetaApi")
   protected RelDataType canonize(final RelDataType type) {
     return DATATYPE_CACHE.intern(type);
   }

File: core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
Patch:
@@ -54,7 +54,6 @@ public RexAnalyzer(RexNode e, RelOptPredicateList predicates) {
 
   /** Generates a map of variables and lists of values that could be assigned
    * to them. */
-  @SuppressWarnings("BetaApi")
   public Iterable<Map<RexNode, Comparable>> assignments() {
     final List<List<Comparable>> generators =
         variables.stream().map(RexAnalyzer::getComparables)

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -1786,7 +1786,6 @@ private static boolean areAssignable(RexNode arg, List<? extends RexNode> bounds
    * <p>If the expressions are all literals of compatible type, creates a call
    * to {@link Sarg} literal, {@code SEARCH(arg, SARG([lower..upper])};
    * otherwise creates a disjunction, {@code arg >= lower AND arg <= upper}. */
-  @SuppressWarnings("BetaApi")
   public RexNode makeBetween(RexNode arg, RexNode lower, RexNode upper) {
     final Comparable lowerValue = toComparable(Comparable.class, lower);
     final Comparable upperValue = toComparable(Comparable.class, upper);
@@ -1811,7 +1810,6 @@ && areAssignable(arg, Arrays.asList(lower, upper))) {
 
   /** Converts a list of expressions to a search argument, or returns null if
    * not possible. */
-  @SuppressWarnings({"BetaApi", "UnstableApiUsage"})
   private static <C extends Comparable<C>> @Nullable Sarg<C> toSarg(Class<C> clazz,
       List<? extends RexNode> ranges, RexUnknownAs unknownAs) {
     if (ranges.isEmpty()) {

File: core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
Patch:
@@ -296,7 +296,7 @@ private Comparable similar(List<Comparable> values) {
     }
   }
 
-  @SuppressWarnings({"BetaApi", "rawtypes", "unchecked", "UnstableApiUsage"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   private static Comparable search(SqlTypeName typeName, List<Comparable> values) {
     final Comparable value = values.get(0);
     final Sarg sarg = (Sarg) values.get(1);
@@ -316,7 +316,7 @@ private static Comparable search(SqlTypeName typeName, List<Comparable> values)
   /** Translates the values in a RangeSet from literal format to runtime format.
    * For example the DATE SQL type uses DateString for literals and Integer at
    * runtime. */
-  @SuppressWarnings({"BetaApi", "rawtypes", "unchecked", "UnstableApiUsage"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   private static RangeSet translate(RangeSet rangeSet, SqlTypeName typeName) {
     switch (typeName) {
     case DATE:

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -620,7 +620,6 @@ public static RexShuttle searchShuttle(RexBuilder rexBuilder,
     return new SearchExpandingShuttle(program, rexBuilder, maxComplexity);
   }
 
-  @SuppressWarnings("BetaApi")
   public static <C extends Comparable<C>> RexNode sargRef(RexBuilder rexBuilder,
       RexNode ref, Sarg<C> sarg, RelDataType type, RexUnknownAs unknownAs) {
     if (sarg.isAll() || sarg.isNone()) {

File: core/src/main/java/org/apache/calcite/sql/SqlUtil.java
Patch:
@@ -1054,7 +1054,6 @@ public static Charset getCharset(String charsetName) {
    * @throws RuntimeException If the given value cannot be represented in the
    *     given charset
    */
-  @SuppressWarnings("BetaApi")
   public static void validateCharset(ByteString value, Charset charset) {
     if (charset == StandardCharsets.UTF_8) {
       final byte[] bytes = value.getBytes();

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -248,7 +248,6 @@
  * <p>The public entry points are: {@link #convertQuery},
  * {@link #convertExpression(SqlNode)}.
  */
-@SuppressWarnings("UnstableApiUsage")
 @Value.Enclosing
 public class SqlToRelConverter {
   //~ Static fields/initializers ---------------------------------------------

File: core/src/main/java/org/apache/calcite/util/RangeSets.java
Patch:
@@ -32,11 +32,10 @@
 import static java.util.Objects.requireNonNull;
 
 /** Utilities for Guava {@link com.google.common.collect.RangeSet}. */
-@SuppressWarnings({"BetaApi", "UnstableApiUsage"})
 public class RangeSets {
   private RangeSets() {}
 
-  @SuppressWarnings({"BetaApi", "rawtypes"})
+  @SuppressWarnings("rawtypes")
   private static final ImmutableRangeSet ALL =
       ImmutableRangeSet.of().complement();
 

File: core/src/main/java/org/apache/calcite/util/Sarg.java
Patch:
@@ -65,7 +65,7 @@
  *
  * @see SqlStdOperatorTable#SEARCH
  */
-@SuppressWarnings({"BetaApi", "type.argument.type.incompatible", "UnstableApiUsage"})
+@SuppressWarnings("type.argument.type.incompatible")
 public class Sarg<C extends Comparable<C>> implements Comparable<Sarg<C>> {
   public final RangeSet<C> rangeSet;
   public final RexUnknownAs nullAs;

File: core/src/test/java/org/apache/calcite/rex/RexProgramTest.java
Patch:
@@ -1423,7 +1423,6 @@ private void checkExponentialCnf(int n) {
         "false");
   }
 
-  @SuppressWarnings("UnstableApiUsage")
   @Test void testRangeSetMinus() {
     final RangeSet<Integer> setNone = ImmutableRangeSet.of();
     final RangeSet<Integer> setAll = setNone.complement();
@@ -3359,7 +3358,6 @@ private void checkSarg(String message, Sarg sarg,
   }
 
   /** Tests {@link Sarg#complexity()}. */
-  @SuppressWarnings("UnstableApiUsage")
   @Test void testSargComplexity() {
     checkSarg("complexity of 'x is not null'",
         Sarg.of(RexUnknownAs.FALSE, RangeSets.<Integer>rangeSetAll()),
@@ -3424,7 +3422,6 @@ private void checkSarg(String message, Sarg sarg,
    * <a href="https://issues.apache.org/jira/browse/CALCITE-5722">[CALCITE-5722]
    * {@code Sarg.isComplementedPoints} fails with anti-points which are equal
    * under {@code compareTo} but not {@code equals}</a>. */
-  @SuppressWarnings("UnstableApiUsage")
   @Test void testSargAntiPoint() {
     final Sarg<BigDecimal> sarg =
         Sarg.of(RexUnknownAs.UNKNOWN,

File: core/src/test/java/org/apache/calcite/test/fuzzer/RexFuzzer.java
Patch:
@@ -260,7 +260,6 @@ public RexNode fuzzCase(Random r, int depth, Function<Random, RexNode> resultFac
     return case_(args);
   }
 
-  @SuppressWarnings("UnstableApiUsage")
   public RexNode fuzzSearch(Random r, RexNode intExpression) {
     final RangeSet<BigDecimal> rangeSet = TreeRangeSet.create();
     final Generator<BigDecimal> integerGenerator = RexFuzzer::fuzzInt;

File: core/src/test/java/org/apache/calcite/util/RangeSetTest.java
Patch:
@@ -49,7 +49,6 @@
  * Unit test for {@link RangeSets} and other utilities relating to Guava
  * {@link Range} and {@link RangeSet}.
  */
-@SuppressWarnings("UnstableApiUsage")
 class RangeSetTest {
 
   /** Tests {@link org.apache.calcite.rel.externalize.RelJson#toJson(Range)}
@@ -107,7 +106,6 @@ class RangeSetTest {
   }
 
   /** Tests {@link RangeSets#minus(RangeSet, Range)}. */
-  @SuppressWarnings("UnstableApiUsage")
   @Test void testRangeSetMinus() {
     final RangeSet<Integer> setNone = ImmutableRangeSet.of();
     final RangeSet<Integer> setAll = setNone.complement();

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
Patch:
@@ -64,7 +64,6 @@ private DruidDateTimeUtils() {
    * expression. Assumes that all the predicates in the input
    * reference a single column: the timestamp column.
    */
-  @SuppressWarnings("BetaApi")
   public static @Nullable List<Interval> createInterval(RexNode e) {
     final List<Range<Long>> ranges = extractRanges(e, false);
     if (ranges == null) {
@@ -166,7 +165,6 @@ protected static List<Interval> toInterval(
     }
   }
 
-  @SuppressWarnings("BetaApi")
   protected static @Nullable List<Range<Long>> leafToRanges(RexCall call, boolean withNot) {
     final ImmutableList.Builder<Range<Long>> ranges;
     switch (call.getKind()) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -269,7 +269,6 @@ protected DruidFilterRule(DruidFilterRuleConfig config) {
      * 2-m) condition filters that can be pushed to Druid,
      * 3-r) condition filters that cannot be pushed to Druid.
      */
-    @SuppressWarnings("BetaApi")
     private static Triple<List<RexNode>, List<RexNode>, List<RexNode>> splitFilters(
         final List<RexNode> validPreds,
         final List<RexNode> nonValidPreds, final int timestampFieldIdx) {

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
Patch:
@@ -218,14 +218,12 @@ static boolean canBeTranslatedToTermsQuery(RexCall search) {
       return isSearchWithPoints(search) || isSearchWithComplementedPoints(search);
     }
 
-    @SuppressWarnings("BetaApi")
     static boolean isSearchWithPoints(RexCall search) {
       RexLiteral literal = (RexLiteral) search.getOperands().get(1);
       final Sarg<?> sarg = requireNonNull(literal.getValueAs(Sarg.class), "Sarg");
       return sarg.isPoints();
     }
 
-    @SuppressWarnings("BetaApi")
     static boolean isSearchWithComplementedPoints(RexCall search) {
       RexLiteral literal = (RexLiteral) search.getOperands().get(1);
       final Sarg<?> sarg = requireNonNull(literal.getValueAs(Sarg.class), "Sarg");
@@ -1035,7 +1033,6 @@ String stringValue() {
       return RexLiteral.stringValue(literal);
     }
 
-    @SuppressWarnings("BetaApi")
     List<Object> sargValue() {
       final Sarg sarg = requireNonNull(literal.getValueAs(Sarg.class), "Sarg");
       final RelDataType type = literal.getType();

File: testkit/src/main/java/org/apache/calcite/test/Matchers.java
Patch:
@@ -295,7 +295,7 @@ public static Matcher<RelNode> hasHints(final String value) {
    * <p>This method is necessary because {@link RangeSet#toString()} changed
    * behavior. Guava 19 - 28 used a unicode symbol; Guava 29 onwards uses "..".
    */
-  @SuppressWarnings({"BetaApi", "rawtypes"})
+  @SuppressWarnings("rawtypes")
   public static Matcher<RangeSet> isRangeSet(final String value) {
     return compose(Is.is(value), input -> sanitizeRangeSet(input.toString()));
   }

File: testkit/src/main/java/org/apache/calcite/test/QuidemTest.java
Patch:
@@ -115,7 +115,6 @@ public abstract class QuidemTest {
     return m;
   }
 
-  @SuppressWarnings({"BetaApi", "UnstableApiUsage"})
   protected static Collection<String> data(String first) {
     // inUrl = "file:/home/fred/calcite/core/target/test-classes/sql/agg.iq"
     final URL inUrl = QuidemTest.class.getResource("/" + n2u(first));

File: core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
Patch:
@@ -517,7 +517,7 @@ private ImmutableList<MetaTypeInfo> getAllDefaultType() {
               false,
               false,
               typeSystem.isAutoincrement(sqlTypeName),
-              (short) sqlTypeName.getMinScale(),
+              (short) typeSystem.getMinScale(sqlTypeName),
               (short) typeSystem.getMaxScale(sqlTypeName),
               typeSystem.getNumTypeRadix(sqlTypeName)));
     }

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -343,7 +343,7 @@ public static int combineStartPrecisionPreservingDefault(
 
   public int getFractionalSecondPrecision(RelDataTypeSystem typeSystem) {
     if (fractionalSecondPrecision == RelDataType.PRECISION_NOT_SPECIFIED) {
-      return typeName().getDefaultScale();
+      return typeSystem.getDefaultScale(typeName());
     } else {
       return fractionalSecondPrecision;
     }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -3523,8 +3523,8 @@ private void validateLiteralAsDouble(SqlLiteral literal) {
     final int fracPrecision =
         qualifier.getFractionalSecondPrecision(typeSystem);
     final int maxPrecision = typeSystem.getMaxPrecision(qualifier.typeName());
-    final int minPrecision = qualifier.typeName().getMinPrecision();
-    final int minScale = qualifier.typeName().getMinScale();
+    final int minPrecision = typeSystem.getMinPrecision(qualifier.typeName());
+    final int minScale = typeSystem.getMinScale(qualifier.typeName());
     final int maxScale = typeSystem.getMaxScale(qualifier.typeName());
     if (startPrecision < minPrecision || startPrecision > maxPrecision) {
       startPrecisionOutOfRange = true;

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -2295,12 +2295,12 @@ void testLikeAndSimilarFails() {
         fixture().factory.getTypeFactory().getTypeSystem();
     final RelDataTypeSystem defTypeSystem = RelDataTypeSystem.DEFAULT;
     for (SqlTypeName typeName : SqlTypeName.INTERVAL_TYPES) {
-      assertThat(typeName.getMinPrecision(), is(1));
+      assertThat(typeSystem.getMinPrecision(typeName), is(1));
       assertThat(typeSystem.getMaxPrecision(typeName), is(10));
       assertThat(typeSystem.getDefaultPrecision(typeName), is(2));
-      assertThat(typeName.getMinScale(), is(0));
+      assertThat(typeSystem.getMinScale(typeName), is(0));
       assertThat(typeSystem.getMaxScale(typeName), is(9));
-      assertThat(typeName.getDefaultScale(), is(6));
+      assertThat(typeSystem.getDefaultScale(typeName), is(6));
     }
 
     final SqlValidatorFixture f = fixture();

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -369,6 +369,7 @@ public enum BuiltInMethod {
   COLLECTION_RETAIN_ALL(Collection.class, "retainAll", Collection.class),
   LIST_CONTAINS(List.class, "contains", Object.class),
   LIST_GET(List.class, "get", int.class),
+  LIST_TO_ARRAY(List.class, "toArray"),
   ITERATOR_HAS_NEXT(Iterator.class, "hasNext"),
   ITERATOR_NEXT(Iterator.class, "next"),
   MATH_MAX(Math.class, "max", int.class, int.class),

File: core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java
Patch:
@@ -418,7 +418,7 @@ public final class CalciteSystemProperty<T> {
    * cache in Calcite. The default value is 1,000.
    */
   public static final CalciteSystemProperty<Integer> FUNCTION_LEVEL_CACHE_MAX_SIZE =
-      intProperty("calcite.function.cache.maxSize", 0, v -> v >= 0);
+      intProperty("calcite.function.cache.maxSize", 1_000, v -> v >= 0);
 
   private static CalciteSystemProperty<Boolean> booleanProperty(String key,
       boolean defaultValue) {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -653,7 +653,7 @@ private static void addFields(List<RelDataTypeField> fieldList,
     final Table t = table == null ? null : table.unwrap(Table.class);
     if (!(t instanceof CustomColumnResolvingTable)) {
       final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();
-      return nameMatcher.field(rowType, id.getSimple());
+      return nameMatcher.field(rowType, Util.last(id.names));
     }
 
     final List<Pair<RelDataTypeField, List<String>>> entries =

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
Patch:
@@ -117,7 +117,7 @@ static QueryBuilder analyze(RexNode expression) throws ExpressionNotAnalyzableEx
       }
       return e != null ? e.builder() : null;
     } catch (Throwable e) {
-      Throwables.propagateIfPossible(e, UnsupportedOperationException.class);
+      Throwables.throwIfInstanceOf(e, UnsupportedOperationException.class);
       throw new ExpressionNotAnalyzableException("Can't convert " + expression, e);
     }
   }

File: piglet/src/test/java/org/apache/calcite/test/PigRelTestBase.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.piglet.PigConverter;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.tools.FrameworkConfig;
+import org.apache.calcite.util.TestUtil;
 
 import org.junit.jupiter.api.BeforeEach;
 
@@ -39,6 +40,8 @@ public abstract class PigRelTestBase {
   public void testSetup() throws Exception {
     assumeFalse(getProperty("os.name").startsWith("Windows"),
         "Skip: Pig/Hadoop tests do not work on Windows");
+    assumeFalse(TestUtil.getJavaMajorVersion() >= 23,
+        "Skip: Pig/Hadoop tests do not work on JDK 23 and higher");
 
     final FrameworkConfig config = config().build();
     converter = create(config);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -4781,7 +4781,7 @@ private static class QuantifyCollectionImplementor extends AbstractRexCallImplem
       final ParameterExpression lambdaArg =
           Expressions.parameter(translator.typeFactory.getJavaClass(rightComponentType), "el");
       final RexCall binaryImplementorRexCall =
-          (RexCall) translator.builder.makeCall(binaryOperator, leftRex,
+          (RexCall) translator.builder.makeCall(call.getParserPosition(), binaryOperator, leftRex,
               translator.builder.makeDynamicParam(rightComponentType, 0));
       final List<RexToLixTranslator.Result> binaryImplementorArgs =
           ImmutableList.of(

File: core/src/main/java/org/apache/calcite/rel/core/Window.java
Patch:
@@ -384,7 +384,7 @@ public List<AggregateCall> getAggregateCalls(Window windowRel) {
         @Override public AggregateCall get(int index) {
           final RexWinAggCall aggCall = aggCalls.get(index);
           final SqlAggFunction op = (SqlAggFunction) aggCall.getOperator();
-          return AggregateCall.create(op, aggCall.distinct, false,
+          return AggregateCall.create(aggCall.getParserPosition(), op, aggCall.distinct, false,
               aggCall.ignoreNulls, ImmutableList.of(),
               getProjectOrdinals(aggCall.getOperands()),
               -1, null, RelCollations.EMPTY,

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -1697,7 +1697,7 @@ private JoinContext(SqlDialect dialect, Context leftContext,
             && ((RexInputRef) op0).getIndex() >= leftContext.fieldCount) {
           // Arguments were of form 'op1 = op0'
           final SqlOperator op2 = requireNonNull(call.getOperator().reverse());
-          return (RexCall) rexBuilder.makeCall(op2, op1, op0);
+          return (RexCall) rexBuilder.makeCall(call.getParserPosition(), op2, op1, op0);
         }
         // fall through
       default:

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
Patch:
@@ -347,7 +347,7 @@ int getCount(int filterArg) {
     Ord.forEach(aggCallList, (c, i) -> {
       if (c.distinctKeys == null) {
         RelBuilder.AggCall aggCall =
-            b.aggregateCall(c.getAggregation(), b.fields(c.getArgList()));
+            b.aggregateCall(c.getParserPosition(), c.getAggregation(), b.fields(c.getArgList()));
         registrar.registerAgg(i,
             c.hasFilter()
                 ? aggCall.filter(b.field(c.filterArg))
@@ -411,7 +411,7 @@ int getCount(int filterArg) {
       RelBuilder.AggCall aggCall;
       if (c.distinctKeys == null) {
         aggCall =
-            b.aggregateCall(SqlStdOperatorTable.MIN,
+            b.aggregateCall(c.getParserPosition(), SqlStdOperatorTable.MIN,
                 b.field(registrar.getAgg(i)));
       } else {
         // The inputs to this aggregate are outputs from MIN() calls from the
@@ -423,7 +423,7 @@ int getCount(int filterArg) {
         // ignore null inputs, we add a filter based on a COUNT() in the inner
         // aggregate.
         aggCall =
-            b.aggregateCall(c.getAggregation(),
+            b.aggregateCall(c.getParserPosition(), c.getAggregation(),
                 b.fields(registrar.fields(c.getArgList(), c.filterArg)));
 
         if (mustBeCounted(c)) {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -145,7 +145,8 @@ public AggregateFilterTransposeRule(RelOptRuleOperand operand,
           return;
         }
         topAggCallList.add(
-            AggregateCall.create(rollup, aggregateCall.isDistinct(),
+            AggregateCall.create(aggregateCall.getParserPosition(),
+                rollup, aggregateCall.isDistinct(),
                 aggregateCall.isApproximate(), aggregateCall.ignoreNulls(),
                 aggregateCall.rexList, ImmutableList.of(i++), -1,
                 aggregateCall.distinctKeys, aggregateCall.collation,

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateRemoveRule.java
Patch:
@@ -133,7 +133,7 @@ public static boolean canFlattenStatic(AggregateCall aggregateCall) {
                 aggregate.getGroupSet(), aggregate.groupSets, aggCall);
         if (constant != null) {
           final RexNode cast =
-              rexBuilder.ensureType(aggCall.type, constant, false);
+              rexBuilder.ensureType(aggCall.getParserPosition(), aggCall.type, constant, false);
           projects.add(cast);
           continue;
         }
@@ -143,7 +143,8 @@ public static boolean canFlattenStatic(AggregateCall aggregateCall) {
       final RexNode singleton =
           splitter.singleton(rexBuilder, input.getRowType(), aggCall);
       final RexNode cast =
-          rexBuilder.ensureType(aggCall.type, singleton, false);
+          rexBuilder.ensureType(
+              aggCall.getParserPosition(), aggCall.type, singleton, false);
       projects.add(cast);
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
Patch:
@@ -214,7 +214,7 @@ protected void apply(RelOptRuleCall call, @Nullable Project postProject,
       if (roll == null) {
         break tryRoll;
       }
-      return AggregateCall.create(roll, false, call.isApproximate(),
+      return AggregateCall.create(call.getParserPosition(), roll, false, call.isApproximate(),
           call.ignoreNulls(), call.rexList, ImmutableList.of(offset + i), -1,
           call.distinctKeys, call.collation,
           groupCount, relBuilder.peek(), null, call.name);
@@ -231,7 +231,7 @@ protected void apply(RelOptRuleCall call, @Nullable Project postProject,
         }
         newArgs.add(z);
       }
-      return AggregateCall.create(aggregation, false,
+      return AggregateCall.create(call.getParserPosition(), aggregation, false,
           call.isApproximate(), call.ignoreNulls(), call.rexList,
           newArgs, -1, call.distinctKeys, call.collation,
           groupCount, relBuilder.peek(), null, call.name);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -213,7 +213,7 @@ public AggregateUnionTransposeRule(Class<? extends Aggregate> aggregateClass,
         aggType = origCall.getType();
       }
       AggregateCall newCall =
-          AggregateCall.create(aggFun, origCall.isDistinct(),
+          AggregateCall.create(ord.e.getParserPosition(), aggFun, origCall.isDistinct(),
               origCall.isApproximate(), origCall.ignoreNulls(),
               origCall.rexList, ImmutableList.of(groupCount + ord.i), -1,
               origCall.distinctKeys, origCall.collation,

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectAggregateMergeRule.java
Patch:
@@ -164,7 +164,7 @@ && kindCount(project.getProjects(), SqlKind.CASE) == 0) {
   private static int findSum0(RelDataTypeFactory typeFactory, AggregateCall sum,
       List<AggregateCall> aggCallList) {
     final AggregateCall sum0 =
-        AggregateCall.create(SqlStdOperatorTable.SUM0, sum.isDistinct(),
+        AggregateCall.create(sum.getParserPosition(), SqlStdOperatorTable.SUM0, sum.isDistinct(),
             sum.isApproximate(), sum.ignoreNulls(), sum.rexList,
             sum.getArgList(), sum.filterArg, sum.distinctKeys, sum.collation,
             typeFactory.createTypeWithNullability(sum.type, false), null);

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
Patch:
@@ -348,7 +348,7 @@ public abstract class MaterializedViewAggregateRule<C extends MaterializedViewAg
           rexBuilder.makeInputRef(relBuilder.peek(),
               aggregate.getGroupCount() + i);
       aggregateCalls.add(
-          relBuilder.aggregateCall(rollupAgg, operand)
+          relBuilder.aggregateCall(aggCall.getParserPosition(), rollupAgg, operand)
               .distinct(aggCall.isDistinct())
               .approximate(aggCall.isApproximate())
               .as(aggCall.name));
@@ -606,7 +606,7 @@ public abstract class MaterializedViewAggregateRule<C extends MaterializedViewAg
             queryAggregate.getGroupCount() + aggregateCalls.size());
         final RexInputRef operand = rexBuilder.makeInputRef(input, k);
         aggregateCalls.add(
-            relBuilder.aggregateCall(rollupAgg, operand)
+            relBuilder.aggregateCall(queryAggCall.getParserPosition(), rollupAgg, operand)
                 .approximate(queryAggCall.isApproximate())
                 .distinct(queryAggCall.isDistinct())
                 .as(queryAggCall.name));

File: core/src/main/java/org/apache/calcite/rex/RexCopier.java
Patch:
@@ -57,7 +57,7 @@ private RelDataType copy(RelDataType type) {
 
   @Override public RexNode visitCall(final RexCall call) {
     final boolean[] update = null;
-    return builder.makeCall(copy(call.getType()),
+    return builder.makeCall(call.getParserPosition(), copy(call.getType()),
         call.getOperator(),
         visitList(call.getOperands(), update));
   }

File: core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java
Patch:
@@ -539,6 +539,7 @@ private void translateAgg(SqlCall call, @Nullable SqlNode filter,
     }
     final AggregateCall aggCall =
         AggregateCall.create(
+            call.getParserPosition(),
             aggFunction,
             distinct,
             approximate,

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -1843,6 +1843,7 @@ private RexNode createCaseExpression(
         }
         newCall =
             rexBuilder.makeCall(
+                call.getParserPosition(),
                 newType,
                 operator,
                 clonedOperands);

File: core/src/test/java/org/apache/calcite/materialize/NormalizationTrimFieldTest.java
Patch:
@@ -84,7 +84,7 @@ public static Frameworks.ConfigBuilder config() {
     final ImmutableBitSet groupSet = ImmutableBitSet.of(4);
     final AggregateCall count = aggregate.getAggCallList().get(0);
     final AggregateCall call =
-        AggregateCall.create(count.getAggregation(),
+        AggregateCall.create(count.getParserPosition(), count.getAggregation(),
             count.isDistinct(), count.isApproximate(),
             count.ignoreNulls(), count.rexList, ImmutableList.of(3),
             count.filterArg, null, count.collation,

File: core/src/test/java/org/apache/calcite/test/fuzzer/RexShrinker.java
Patch:
@@ -76,7 +76,7 @@ public class RexShrinker extends RexShuttle {
       if (res != null) {
         didWork = true;
         if (!res.getType().equals(type)) {
-          return rexBuilder.makeCast(type, res);
+          return rexBuilder.makeCast(call.getParserPosition(), type, res);
         }
         return res;
       }

File: core/src/main/java/org/apache/calcite/util/format/postgresql/NumberFormatPattern.java
Patch:
@@ -88,7 +88,7 @@ protected NumberFormatPattern(ChronoUnitEnum chronoUnit, int minValue,
   }
 
   @Override public @Nullable String convert(ParsePosition parsePosition, String formatString,
-      ZonedDateTime dateTime) {
+      ZonedDateTime dateTime, Locale locale) {
     String formatStringTrimmed = formatString.substring(parsePosition.getIndex());
 
     boolean haveFillMode = false;

File: core/src/main/java/org/apache/calcite/util/format/postgresql/StringFormatPattern.java
Patch:
@@ -42,7 +42,7 @@ protected StringFormatPattern(ChronoUnitEnum chronoUnit, String... patterns) {
   }
 
   @Override public @Nullable String convert(ParsePosition parsePosition, String formatString,
-      ZonedDateTime dateTime) {
+      ZonedDateTime dateTime, Locale locale) {
     String formatStringTrimmed = formatString.substring(parsePosition.getIndex());
 
     boolean haveFillMode = false;
@@ -86,7 +86,7 @@ protected StringFormatPattern(ChronoUnitEnum chronoUnit, String... patterns) {
         dateTime,
         haveFillMode,
         suffix,
-        haveTranslationMode ? Locale.getDefault() : Locale.US);
+        haveTranslationMode ? locale : Locale.US);
   }
 
   @Override public ChronoUnitEnum getChronoUnit() {

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -612,6 +612,9 @@ ExInst<SqlValidatorException> intervalFractionalSecondPrecisionOutOfRange(
   @BaseMessage("Argument to function ''{0}'' must not be NULL")
   ExInst<SqlValidatorException> argumentMustNotBeNull(String a0);
 
+  @BaseMessage("At least one argument to function ''{0}'' must not be NULL")
+  ExInst<SqlValidatorException> atLeastOneArgumentMustNotBeNull(String a0);
+
   @BaseMessage("Illegal use of ''NULL''")
   ExInst<SqlValidatorException> nullIllegal();
 

File: core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
Patch:
@@ -398,6 +398,9 @@ public static SqlOperandTypeChecker variadic(
   public static final SqlSingleOperandTypeChecker INTEGER =
       family(SqlTypeFamily.INTEGER);
 
+  public static final SqlSingleOperandTypeChecker INTEGER_INTEGER =
+      family(SqlTypeFamily.INTEGER, SqlTypeFamily.INTEGER);
+
   public static final SqlSingleOperandTypeChecker NUMERIC_OPTIONAL_NUMERIC =
       family(ImmutableList.of(SqlTypeFamily.NUMERIC, SqlTypeFamily.NUMERIC),
           // Second operand optional (operand index 0, 1)

File: core/src/main/java/org/apache/calcite/sql/SqlSplittableAggFunction.java
Patch:
@@ -304,7 +304,7 @@ abstract class AbstractSumSplitter implements SqlSplittableAggFunction {
             bottom.isDistinct(), bottom.isApproximate(), false,
             bottom.rexList, bottom.getArgList(), bottom.filterArg,
             bottom.distinctKeys, bottom.getCollation(),
-            bottom.getType(), top.getName());
+            top.getType(), top.getName());
       } else {
         return null;
       }

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraEnumerator.java
Patch:
@@ -42,6 +42,8 @@
 import java.util.Objects;
 import java.util.stream.IntStream;
 
+import static java.util.Objects.requireNonNull;
+
 /** Enumerator that reads from a Cassandra column family. */
 class CassandraEnumerator implements Enumerator<Object> {
   private final Iterator<Row> iterator;
@@ -86,7 +88,7 @@ class CassandraEnumerator implements Enumerator<Object> {
    * @param index Index of the field within the Row object
    */
   private @Nullable Object currentRowField(int index) {
-    assert current != null;
+    requireNonNull(current, "current");
     final Object o =
          current.get(index,
              CodecRegistry.DEFAULT.codecFor(

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
Patch:
@@ -62,11 +62,12 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Schema mapped onto a Cassandra column family.
  */
@@ -297,7 +298,7 @@ private void addMaterializedViews() {
           + "WHERE keyspace_name='" + keyspace + "' AND view_name='"
           + view.getName().asInternal() + "'";
 
-      Row whereClauseRow = Objects.requireNonNull(session.execute(whereQuery).one());
+      Row whereClauseRow = requireNonNull(session.execute(whereQuery).one());
 
       queryBuilder.append(" WHERE ")
           .append(whereClauseRow.getString(0));

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchemaFactory.java
Patch:
@@ -34,6 +34,8 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.stream.Collectors;
 
+import static java.lang.Integer.parseInt;
+
 /**
  * Factory that creates a {@link CassandraSchema}.
  */
@@ -107,7 +109,7 @@ private static int getPort(Map<String, Object> map) {
     if (map.containsKey("port")) {
       Object portObj = map.get("port");
       if (portObj instanceof String) {
-        return Integer.parseInt((String) portObj);
+        return parseInt((String) portObj);
       } else {
         return (int) portObj;
       }

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSort.java
Patch:
@@ -33,6 +33,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of {@link org.apache.calcite.rel.core.Sort}
  * relational expression in Cassandra.
@@ -48,7 +50,7 @@ public CassandraSort(RelOptCluster cluster, RelTraitSet traitSet,
 
   @Override public @Nullable RelOptCost computeSelfCost(RelOptPlanner planner,
       RelMetadataQuery mq) {
-    RelOptCost cost = super.computeSelfCost(planner, mq);
+    RelOptCost cost = requireNonNull(super.computeSelfCost(planner, mq));
     if (!collation.getFieldCollations().isEmpty()) {
       return cost.multiplyBy(0.05);
     } else {

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java
Patch:
@@ -57,9 +57,9 @@
 public class CassandraTable extends AbstractQueryableTable
     implements TranslatableTable {
   final RelProtoDataType protoRowType;
-  List<String> partitionKeys;
-  List<String> clusteringKeys;
-  List<RelFieldCollation> clusteringOrder;
+  final List<String> partitionKeys;
+  final List<String> clusteringKeys;
+  final List<RelFieldCollation> clusteringOrder;
   private final Optional<String> keyspace;
   private final String columnFamily;
 

File: core/src/main/java/org/apache/calcite/DataContexts.java
Patch:
@@ -109,8 +109,8 @@ private static class FunctionDataContext extends EmptyDataContext {
 
   /** Implementation of {@link DataContext} backed by a Map. */
   private static class DataContextImpl extends MapDataContext {
-    private CalciteConnection connection;
-    private @Nullable SchemaPlus rootSchema;
+    private final CalciteConnection connection;
+    private final @Nullable SchemaPlus rootSchema;
 
     DataContextImpl(CalciteConnection connection,
         @Nullable SchemaPlus rootSchema, Map<String, Object> map) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableConvention.java
Patch:
@@ -28,8 +28,6 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.RelFactories;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
-
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -55,7 +53,7 @@ public enum EnumerableConvention implements Convention {
     return "ENUMERABLE";
   }
 
-  @Override public @Nullable RelNode enforce(
+  @Override public RelNode enforce(
       final RelNode input,
       final RelTraitSet required) {
     RelNode rel = input;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
Patch:
@@ -65,7 +65,7 @@ protected EnumerableMergeJoinRule(Config config) {
       // EnumerableMergeJoin only supports certain join types.
       return null;
     }
-    if (info.pairs().size() == 0) {
+    if (info.pairs().isEmpty()) {
       // EnumerableMergeJoin CAN support cartesian join, but disable it for now.
       return null;
     }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMinus.java
Patch:
@@ -53,7 +53,7 @@ public EnumerableMinus(RelOptCluster cluster, RelTraitSet traitSet,
           builder.append(
               "child" + ord.i,
               result.block);
-      assert childExp != null : "childExp must not be null";
+      requireNonNull(childExp, "childExp");
 
       if (minusExp == null) {
         minusExp = childExp;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -529,7 +529,7 @@ private static void sampleOfTheGeneratedWindowedAggregate() {
     return implementor.result(inputPhysType, builder.toBlock());
   }
 
-  private Statement buildExcludeGuard(Group group, Expression comparator,
+  private static Statement buildExcludeGuard(Group group, Expression comparator,
       ParameterExpression currentRow,
       DeclarationStatement jDecl, Expression rows, BlockStatement forBlock) {
     if (group.exclude == RexWindowExclusion.EXCLUDE_CURRENT_ROW) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java
Patch:
@@ -277,7 +277,7 @@ public enum JavaRowFormat {
       return Expressions.assign(e, value);
     }
 
-    @Override public @Nullable Expression copy(ParameterExpression parameter,
+    @Override public Expression copy(ParameterExpression parameter,
         ParameterExpression outputArray, int outputStartIndex, int length) {
       return Expressions.call(ARRAY_COPY.method, parameter, Expressions.constant(0),
           outputArray, Expressions.constant(outputStartIndex), Expressions.constant(length));

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -2600,7 +2600,7 @@ private static class SafeArithmeticImplementor extends MethodImplementor {
 
     @Override Expression implementSafe(final RexToLixTranslator translator,
         final RexCall call, final List<Expression> argValueList) {
-      List<Expression> args = new ArrayList<Expression>();
+      List<Expression> args = new ArrayList<>();
       args.add(convertType(argValueList.get(0), call.operands.get(0)));
       // SAFE_NEGATE only has one argument so create constant -1L to use
       // SAFE_MULTIPLY implementation.
@@ -2893,7 +2893,7 @@ private static class JsonValueImplementor extends MethodImplementor {
       Expression errorBehavior = Expressions.constant(SqlJsonValueEmptyOrErrorBehavior.NULL);
       Expression defaultValueOnError = Expressions.constant(null);
       // Patched up with user defines.
-      if (leftExprs.size() > 0) {
+      if (!leftExprs.isEmpty()) {
         for (int i = 0; i < leftExprs.size(); i++) {
           Expression expr = leftExprs.get(i);
           final Object exprVal = translator.getLiteralValue(expr);
@@ -4291,7 +4291,7 @@ private static List<Expression> args(RexCall call,
       }
       operand0 = operands.left;
       operand1 = operands.right;
-      boolean nonPositiveIsNull = library == SqlLibrary.MYSQL ? true : false;
+      boolean nonPositiveIsNull = library == SqlLibrary.MYSQL;
       final Expressions.FluentList<Expression> list = Expressions.list(operand0);
       switch (call.getOperator().getName()) {
       case "LOG":

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggAddContextImpl.java
Patch:
@@ -42,7 +42,8 @@ protected WinAggAddContextImpl(BlockBuilder block, List<Expression> accumulator,
   @Deprecated // to be removed before 2.0
   protected WinAggAddContextImpl(BlockBuilder block, List<Expression> accumulator,
       com.google.common.base.Function<BlockBuilder, WinAggFrameResultContext> frame) {
-    this(block, accumulator, (Function<BlockBuilder, WinAggFrameResultContext>) frame::apply);
+    this(block, accumulator,
+        (Function<BlockBuilder, WinAggFrameResultContext>) frame);
   }
 
   @Override public final RexToLixTranslator rowTranslator() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggResultContextImpl.java
Patch:
@@ -55,7 +55,7 @@ protected WinAggResultContextImpl(BlockBuilder block,
       List<Expression> accumulator,
       com.google.common.base.Function<BlockBuilder, WinAggFrameResultContext> frameContextBuilder) {
     this(block, accumulator,
-        (Function<BlockBuilder, WinAggFrameResultContext>) frameContextBuilder::apply);
+        (Function<BlockBuilder, WinAggFrameResultContext>) frameContextBuilder);
   }
 
   private WinAggFrameResultContext getFrame() {

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java
Patch:
@@ -27,7 +27,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
@@ -46,7 +45,7 @@ protected JdbcTableScan(
       JdbcTable jdbcTable,
       JdbcConvention jdbcConvention) {
     super(cluster, cluster.traitSetOf(jdbcConvention), hints, table);
-    this.jdbcTable = Objects.requireNonNull(jdbcTable, "jdbcTable");
+    this.jdbcTable = requireNonNull(jdbcTable, "jdbcTable");
   }
 
   @Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -238,7 +238,7 @@ private static void generateGet(EnumerableRelImplementor implementor,
     boolean offset = false;
     switch (calendarPolicy) {
     case LOCAL:
-      assert calendar_ != null : "calendar must not be null";
+      requireNonNull(calendar_, "calendar_");
       dateTimeArgs.add(calendar_);
       break;
     case NULL:

File: core/src/main/java/org/apache/calcite/interpreter/JaninoRexCompiler.java
Patch:
@@ -54,7 +54,8 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Compiles a scalar expression ({@link RexNode}) to an expression that
@@ -200,7 +201,7 @@ static Scalar.Producer getScalar(ClassDeclaration expr, String s)
       throws CompileException, IOException {
     ICompilerFactory compilerFactory;
     ClassLoader classLoader =
-        Objects.requireNonNull(JaninoRexCompiler.class.getClassLoader(), "classLoader");
+        requireNonNull(JaninoRexCompiler.class.getClassLoader(), "classLoader");
     try {
       compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory(classLoader);
     } catch (Exception e) {

File: core/src/main/java/org/apache/calcite/jdbc/CalciteConnection.java
Patch:
@@ -22,6 +22,8 @@
 import org.apache.calcite.linq4j.QueryProvider;
 import org.apache.calcite.schema.SchemaPlus;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
+
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Properties;
@@ -74,7 +76,7 @@ public interface CalciteConnection extends Connection, QueryProvider {
   @Override void setSchema(String schema) throws SQLException;
 
   // in java.sql.Connection from JDK 1.7, but declare here to allow other JDKs
-  @Override String getSchema() throws SQLException;
+  @Override @Nullable String getSchema() throws SQLException;
 
   CalciteConnectionConfig config();
 

File: core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
Patch:
@@ -24,6 +24,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Record type based on a Java class. The fields of the type are the fields
  * of the class.
@@ -36,7 +38,7 @@ public class JavaRecordType extends RelRecordType {
 
   public JavaRecordType(List<RelDataTypeField> fields, Class clazz) {
     super(fields);
-    this.clazz = Objects.requireNonNull(clazz, "clazz");
+    this.clazz = requireNonNull(clazz, "clazz");
   }
 
   @Override public boolean equals(@Nullable Object obj) {

File: core/src/main/java/org/apache/calcite/materialize/LatticeTable.java
Patch:
@@ -22,16 +22,16 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** Table registered in the graph. */
 public class LatticeTable {
   public final RelOptTable t;
   public final String alias;
 
   LatticeTable(RelOptTable table) {
-    t = Objects.requireNonNull(table, "table");
-    alias = Objects.requireNonNull(Util.last(table.getQualifiedName()));
+    t = requireNonNull(table, "table");
+    alias = requireNonNull(Util.last(table.getQualifiedName()));
   }
 
   @Override public int hashCode() {

File: core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
Patch:
@@ -32,9 +32,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Objects;
 import java.util.function.Supplier;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of {@link LatticeStatisticProvider} that uses a
  * {@link org.apache.calcite.profile.Profiler}.
@@ -46,7 +47,7 @@ class ProfilerLatticeStatisticProvider implements LatticeStatisticProvider {
 
   /** Creates a ProfilerLatticeStatisticProvider. */
   private ProfilerLatticeStatisticProvider(Lattice lattice) {
-    Objects.requireNonNull(lattice, "lattice");
+    requireNonNull(lattice, "lattice");
     this.profile = Suppliers.memoize(() -> {
       final ProfilerImpl profiler =
           ProfilerImpl.builder()

File: core/src/main/java/org/apache/calcite/model/JsonView.java
Patch:
@@ -22,7 +22,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * View schema element.
@@ -96,7 +97,7 @@ public JsonView(
       @JsonProperty("path") @Nullable List<String> path,
       @JsonProperty("modifiable") @Nullable Boolean modifiable) {
     super(name, stream);
-    this.sql = Objects.requireNonNull(sql, "sql");
+    this.sql = requireNonNull(sql, "sql");
     this.path = path;
     this.modifiable = modifiable;
   }

File: core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
Patch:
@@ -23,7 +23,8 @@
 
 import java.util.Arrays;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A trait that consists of a list of traits, all of the same type.
@@ -42,7 +43,7 @@ class RelCompositeTrait<T extends RelMultipleTrait> implements RelTrait {
   // Must remain private. Does not copy the array.
   private RelCompositeTrait(RelTraitDef traitDef, T[] traits) {
     this.traitDef = traitDef;
-    this.traits = Objects.requireNonNull(traits, "traits");
+    this.traits = requireNonNull(traits, "traits");
     //noinspection unchecked
     assert Ordering.natural()
         .isStrictlyOrdered(Arrays.asList((Comparable[]) traits))

File: core/src/main/java/org/apache/calcite/plan/RelOptQuery.java
Patch:
@@ -27,6 +27,8 @@
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static java.lang.Integer.parseInt;
+
 /**
  * A <code>RelOptQuery</code> represents a set of
  * {@link RelNode relational expressions} which derive from the same
@@ -83,7 +85,7 @@ public RelOptQuery(RelOptPlanner planner) {
   @Deprecated // to be removed before 2.0
   public static int getCorrelOrdinal(String correlName) {
     assert correlName.startsWith(CORREL_PREFIX);
-    return Integer.parseInt(correlName.substring(CORREL_PREFIX.length()));
+    return parseInt(correlName.substring(CORREL_PREFIX.length()));
   }
 
   /**

File: core/src/main/java/org/apache/calcite/plan/RelOptSchema.java
Patch:
@@ -49,8 +49,8 @@ public interface RelOptSchema {
   RelDataTypeFactory getTypeFactory();
 
   /**
-   * Registers all of the rules supported by this schema. Only called by
+   * Registers all the rules supported by this schema. Only called by
    * {@link RelOptPlanner#registerSchema}.
    */
-  void registerRules(RelOptPlanner planner) throws Exception;
+  void registerRules(RelOptPlanner planner);
 }

File: core/src/main/java/org/apache/calcite/plan/RelTraitSet.java
Patch:
@@ -33,6 +33,8 @@
 import java.util.Map;
 import java.util.function.Supplier;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * RelTraitSet represents an ordered set of {@link RelTrait}s.
  */
@@ -638,7 +640,7 @@ public RelTraitSet plus(RelTrait trait) {
       return replace(i, trait);
     }
     final RelTrait canonizedTrait = canonize(trait);
-    assert canonizedTrait != null;
+    requireNonNull(canonizedTrait, "canonizedTrait");
     RelTrait[] newTraits = new RelTrait[traits.length + 1];
     System.arraycopy(traits, 0, newTraits, 0, traits.length);
     newTraits[traits.length] = canonizedTrait;

File: core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
Patch:
@@ -219,7 +219,7 @@ private boolean implies2(RexNode first, RexNode second) {
         : firstUsageFinder.usageMap.entrySet()) {
       ImmutableSet.Builder<Pair<RexInputRef, @Nullable RexNode>> usageBuilder =
           ImmutableSet.builder();
-      if (entry.getValue().usageList.size() > 0) {
+      if (!entry.getValue().usageList.isEmpty()) {
         entry.getValue().usageList.rightList().forEach(v ->
             usageBuilder.add(Pair.of(entry.getKey(), v)));
         usagesBuilder.add(usageBuilder.build());

File: core/src/main/java/org/apache/calcite/plan/hep/HepRuleCall.java
Patch:
@@ -37,7 +37,7 @@
 public class HepRuleCall extends RelOptRuleCall {
   //~ Instance fields --------------------------------------------------------
 
-  private List<RelNode> results;
+  private final List<RelNode> results = new ArrayList<>();
 
   //~ Constructors -----------------------------------------------------------
 
@@ -48,8 +48,6 @@ public class HepRuleCall extends RelOptRuleCall {
       Map<RelNode, List<RelNode>> nodeChildren,
       @Nullable List<RelNode> parents) {
     super(planner, operand, rels, nodeChildren, parents);
-
-    results = new ArrayList<>();
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java
Patch:
@@ -62,7 +62,7 @@ void updateAttribute(final String attr, final Object newValue) {
     }
 
     if (newValue instanceof List
-        && ((List<?>) newValue).size() == 0
+        && ((List<?>) newValue).isEmpty()
         && !update.containsKey(attr)) {
       return;
     }

File: core/src/main/java/org/apache/calcite/plan/volcano/IterativeRuleDriver.java
Patch:
@@ -21,6 +21,8 @@
 
 import org.slf4j.Logger;
 
+import static java.util.Objects.requireNonNull;
+
 /***
  * The algorithm executes repeatedly. The exact rules
  * that may be fired varies.
@@ -46,7 +48,7 @@ class IterativeRuleDriver implements RuleDriver {
 
   @Override public void drive() {
     while (true) {
-      assert planner.root != null : "RelSubset must not be null at this point";
+      requireNonNull(planner.root, "RelSubset must not be null at this point");
       LOGGER.debug("Best cost before rule match: {}", planner.root.bestCost);
 
       VolcanoRuleMatch match = ruleQueue.popMatch();

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
Patch:
@@ -136,7 +136,8 @@ public Set<RelSet> getChildSets(VolcanoPlanner planner) {
         continue;
       }
       for (RelNode child : node.getInputs()) {
-        RelSet childSet = planner.equivRoot(((RelSubset) child).getSet());
+        RelSet childSet =
+            VolcanoPlanner.equivRoot(((RelSubset) child).getSet());
         if (childSet.id != this.id) {
           childSets.add(childSet);
         }
@@ -387,7 +388,7 @@ void mergeWith(
         subset = getOrCreateSubset(cluster, otherTraits, true);
       }
 
-      assert subset != null;
+      requireNonNull(subset, "subset");
       if (subset.passThroughCache == null) {
         subset.passThroughCache = otherSubset.passThroughCache;
       } else if (otherSubset.passThroughCache != null) {

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
Patch:
@@ -605,12 +605,12 @@ private boolean visitRel(RelNode p) {
    * with the cheapest implementation of the expression.
    */
   static class CheapestPlanReplacer {
-    VolcanoPlanner planner;
+    final VolcanoPlanner planner;
     final Map<Integer, RelNode> visited = new HashMap<>();
 
     CheapestPlanReplacer(VolcanoPlanner planner) {
       super();
-      this.planner = planner;
+      this.planner = requireNonNull(planner, "planner");
     }
 
     private static String traitDiff(RelTraitSet original, RelTraitSet desired) {

File: core/src/main/java/org/apache/calcite/plan/volcano/TopDownRuleDriver.java
Patch:
@@ -264,7 +264,7 @@ private interface Task {
    */
   private static class TaskDescriptor {
     private boolean first = true;
-    private StringBuilder builder = new StringBuilder();
+    private final StringBuilder builder = new StringBuilder();
 
     void log(Task task) {
       if (!LOGGER.isDebugEnabled()) {
@@ -308,7 +308,7 @@ default boolean onProduce(RelNode node) {
    */
   private class OptimizeGroup implements Task {
     private final RelSubset group;
-    private RelOptCost upperBound;
+    private final RelOptCost upperBound;
 
     OptimizeGroup(RelSubset group, RelOptCost upperBound) {
       this.group = group;

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -92,10 +92,10 @@ public class PlannerImpl implements Planner, ViewExpander {
   private boolean open;
 
   // set in STATE_2_READY
-  private @Nullable SchemaPlus defaultSchema;
+  private final @Nullable SchemaPlus defaultSchema;
   private @Nullable JavaTypeFactory typeFactory;
   private @Nullable RelOptPlanner planner;
-  private @Nullable RexExecutor executor;
+  private final @Nullable RexExecutor executor;
 
   // set in STATE_4_VALIDATE
   private @Nullable SqlValidator validator;

File: core/src/main/java/org/apache/calcite/rel/RelDistributions.java
Patch:
@@ -32,6 +32,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Utilities concerning {@link org.apache.calcite.rel.RelDistribution}.
  */
@@ -96,7 +98,7 @@ private static class RelDistributionImpl implements RelDistribution {
     private final ImmutableIntList keys;
 
     private RelDistributionImpl(Type type, ImmutableIntList keys) {
-      this.type = Objects.requireNonNull(type, "type");
+      this.type = requireNonNull(type, "type");
       this.keys = ImmutableIntList.copyOf(keys);
       assert type != Type.HASH_DISTRIBUTED
           || keys.size() < 2

File: core/src/main/java/org/apache/calcite/rel/convert/ConverterImpl.java
Patch:
@@ -34,7 +34,7 @@ public abstract class ConverterImpl extends SingleRel
     implements Converter {
   //~ Instance fields --------------------------------------------------------
 
-  protected RelTraitSet inTraits;
+  protected final RelTraitSet inTraits;
   protected final @Nullable RelTraitDef traitDef;
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
Patch:
@@ -535,8 +535,8 @@ public static boolean isRollup(ImmutableBitSet groupSet,
         }
         g = bitSet;
       }
-      assert g != null : "groupSet must not be empty";
-      assert g.isEmpty();
+      requireNonNull(g, "groupSet must not be empty");
+      checkArgument(g.isEmpty());
       return true;
     }
 

File: core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
Patch:
@@ -390,7 +390,7 @@ public AggregateCall rename(@Nullable String name) {
       buf.append("APPROXIMATE ");
     }
     if (distinct) {
-      buf.append((argList.size() == 0) ? "DISTINCT" : "DISTINCT ");
+      buf.append(argList.isEmpty() ? "DISTINCT" : "DISTINCT ");
     }
     int i = -1;
     for (RexNode rexNode : rexList) {

File: core/src/main/java/org/apache/calcite/rel/core/CorrelationId.java
Patch:
@@ -22,6 +22,8 @@
 
 import java.util.Set;
 
+import static java.lang.Integer.parseInt;
+
 /**
  * Describes the necessary parameters for an implementation in order to
  * identify and set dynamic variables.
@@ -59,7 +61,7 @@ public CorrelationId(int id) {
    * @param name     variable name
    */
   public CorrelationId(String name) {
-    this(Integer.parseInt(name.substring(CORREL_PREFIX.length())), name);
+    this(parseInt(name.substring(CORREL_PREFIX.length())), name);
     assert name.startsWith(CORREL_PREFIX)
         : "Correlation name should start with " + CORREL_PREFIX
         + " actual name is " + name;

File: core/src/main/java/org/apache/calcite/rel/core/Exchange.java
Patch:
@@ -33,7 +33,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that imposes a particular distribution on its input
@@ -59,7 +60,7 @@ public abstract class Exchange extends SingleRel {
   protected Exchange(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
       RelDistribution distribution) {
     super(cluster, traitSet, input);
-    this.distribution = Objects.requireNonNull(distribution, "distribution");
+    this.distribution = requireNonNull(distribution, "distribution");
 
     assert traitSet.containsIfApplicable(distribution)
         : "traits=" + traitSet + ", distribution=" + distribution;

File: core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
Patch:
@@ -31,7 +31,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that computes a repeat union (recursive union in SQL
@@ -80,7 +81,7 @@ protected RepeatUnion(RelOptCluster cluster, RelTraitSet traitSet,
     this.all = all;
     this.transientTable = transientTable;
     if (transientTable != null) {
-      Objects.requireNonNull(transientTable.unwrap(TransientTable.class));
+      requireNonNull(transientTable.unwrap(TransientTable.class));
     }
   }
 

File: core/src/main/java/org/apache/calcite/rel/core/Snapshot.java
Patch:
@@ -35,7 +35,6 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
 
 import static java.util.Objects.requireNonNull;
 
@@ -84,7 +83,7 @@ public Snapshot(RelInput input) {
   protected Snapshot(RelOptCluster cluster, RelTraitSet traitSet, List<RelHint> hints,
       RelNode input, RexNode period) {
     super(cluster, traitSet, input);
-    this.period = Objects.requireNonNull(period, "period");
+    this.period = requireNonNull(period, "period");
     this.hints = ImmutableList.copyOf(hints);
     assert isValid(Litmus.THROW, null);
   }

File: core/src/main/java/org/apache/calcite/rel/core/SortExchange.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that performs {@link Exchange} and {@link Sort}
@@ -57,7 +57,7 @@ public abstract class SortExchange extends Exchange {
   protected SortExchange(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode input, RelDistribution distribution, RelCollation collation) {
     super(cluster, traitSet, input, distribution);
-    this.collation = Objects.requireNonNull(collation, "collation");
+    this.collation = requireNonNull(collation, "collation");
 
     assert traitSet.containsIfApplicable(collation)
         : "traits=" + traitSet + ", collation=" + collation;

File: core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
Patch:
@@ -194,7 +194,7 @@ public abstract TableFunctionScan copy(
     // for a no-input UDX, behave like an AbstractRelNode; for a one-input
     // UDX, behave like a SingleRel; for a multi-input UDX, behave like
     // UNION ALL.  TODO jvs 10-Sep-2007: UDX-supplied costing metadata.
-    if (inputs.size() == 0) {
+    if (inputs.isEmpty()) {
       return super.estimateRowCount(mq);
     }
     double nRows = 0.0;

File: core/src/main/java/org/apache/calcite/rel/core/TableScan.java
Patch:
@@ -44,9 +44,10 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Relational operator that returns the contents of a table.
  */
@@ -69,7 +70,7 @@ public abstract class TableScan
   protected TableScan(RelOptCluster cluster, RelTraitSet traitSet,
       List<RelHint> hints, RelOptTable table) {
     super(cluster, traitSet);
-    this.table = Objects.requireNonNull(table, "table");
+    this.table = requireNonNull(table, "table");
     RelOptSchema relOptSchema = table.getRelOptSchema();
     if (relOptSchema != null) {
       cluster.getPlanner().registerSchema(relOptSchema);

File: core/src/main/java/org/apache/calcite/rel/core/TableSpool.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Spool that writes into a table.
@@ -39,7 +39,7 @@ public abstract class TableSpool extends Spool {
   protected TableSpool(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode input, Type readType, Type writeType, RelOptTable table) {
     super(cluster, traitSet, input, readType, writeType);
-    this.table = Objects.requireNonNull(table, "table");
+    this.table = requireNonNull(table, "table");
   }
 
   @Override public RelOptTable getTable() {

File: core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
Patch:
@@ -37,6 +37,8 @@
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Relational expression that unnests its input's columns into a relation.
  *
@@ -77,7 +79,7 @@ public Uncollect(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
     super(cluster, traitSet, input);
     this.withOrdinality = withOrdinality;
     this.itemAliases = ImmutableList.copyOf(itemAliases);
-    assert deriveRowType() != null : "invalid child rowtype";
+    requireNonNull(deriveRowType(), "invalid child rowType");
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/core/Values.java
Patch:
@@ -190,7 +190,9 @@ private boolean assertRowType() {
   }
 
   @Override protected RelDataType deriveRowType() {
-    assert rowType != null : "rowType must not be null for " + this;
+    if (rowType == null) {
+      throw new AssertionError("rowType must not be null for " + this);
+    }
     return rowType;
   }
 

File: core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java
Patch:
@@ -50,9 +50,9 @@ public class RelDotWriter extends RelWriterImpl {
    */
   private final Map<RelNode, List<RelNode>> outArcTable = new LinkedHashMap<>();
 
-  private Map<RelNode, String> nodeLabels = new HashMap<>();
+  private final Map<RelNode, String> nodeLabels = new HashMap<>();
 
-  private Multimap<RelNode, String> nodeStyles = HashMultimap.create();
+  private final Multimap<RelNode, String> nodeStyles = HashMultimap.create();
 
   private final WriteOption option;
 

File: core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
Patch:
@@ -155,7 +155,7 @@ private void explainInputs(List<RelNode> inputs) {
 
   private boolean checkInputsPresentInExplain(RelNode node) {
     int i = 0;
-    if (values.size() > 0 && values.get(0).left.equals("subset")) {
+    if (!values.isEmpty() && values.get(0).left.equals("subset")) {
       ++i;
     }
     for (RelNode input : node.getInputs()) {

File: core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
Patch:
@@ -35,7 +35,7 @@ public class RelXmlWriter extends RelWriterImpl {
   //~ Instance fields --------------------------------------------------------
 
   private final XmlOutput xmlOutput;
-  boolean generic = true;
+  final boolean generic = true;
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/rel/hint/HintStrategy.java
Patch:
@@ -23,7 +23,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Represents a hint strategy entry of {@link HintStrategyTable}.
@@ -85,14 +85,14 @@ public static class Builder {
     private ImmutableSet<ConverterRule> converterRules;
 
     private Builder(HintPredicate predicate) {
-      this.predicate = Objects.requireNonNull(predicate, "predicate");
+      this.predicate = requireNonNull(predicate, "predicate");
       this.excludedRules = ImmutableSet.of();
       this.converterRules = ImmutableSet.of();
     }
 
     /** Registers a hint option checker to validate the hint options. */
     public Builder optionChecker(HintOptionChecker optionChecker) {
-      this.optionChecker = Objects.requireNonNull(optionChecker, "optionChecker");
+      this.optionChecker = requireNonNull(optionChecker, "optionChecker");
       return this;
     }
 

File: core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
Patch:
@@ -119,7 +119,7 @@ public boolean validateHint(RelHint hint) {
    * the given {@code rule} should be excluded. */
   public boolean isRuleExcluded(Hintable hintable, RelOptRule rule) {
     final List<RelHint> hints = hintable.getHints();
-    if (hints.size() == 0) {
+    if (hints.isEmpty()) {
       return false;
     }
 
@@ -141,7 +141,7 @@ private static boolean isDesiredConversionPossible(
       Set<ConverterRule> converterRules,
       Hintable hintable) {
     // If no converter rules are specified, we assume the conversion is possible.
-    return converterRules.size() == 0
+    return converterRules.isEmpty()
         || converterRules.stream()
             .anyMatch(converterRule -> converterRule.convert((RelNode) hintable) != null);
   }

File: core/src/main/java/org/apache/calcite/rel/hint/Hintable.java
Patch:
@@ -24,9 +24,10 @@
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * {@link Hintable} is a kind of {@link RelNode} that can attach {@link RelHint}s.
  *
@@ -60,9 +61,8 @@ public interface Hintable {
    * @return Relational expression with the hints {@code hintList} attached
    */
   default RelNode attachHints(List<RelHint> hintList) {
-    Objects.requireNonNull(hintList, "hintList");
     final Set<RelHint> hints = new LinkedHashSet<>(getHints());
-    hints.addAll(hintList);
+    hints.addAll(requireNonNull(hintList, "hintList"));
     return withHints(new ArrayList<>(hints));
   }
 

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalAsofJoin.java
Patch:
@@ -124,8 +124,7 @@ public LogicalAsofJoin copy(
     if (this == obj) {
       return true;
     }
-    LogicalAsofJoin asofObj = (LogicalAsofJoin) obj;
-    assert asofObj != null;
+    LogicalAsofJoin asofObj = requireNonNull((LogicalAsofJoin) obj);
     return deepEquals0(obj)
         && matchCondition.equals(asofObj.matchCondition)
         && systemFieldList.equals(asofObj.systemFieldList);

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java
Patch:
@@ -42,6 +42,8 @@
 import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Sub-class of {@link org.apache.calcite.rel.core.Filter}
  * not targeted at any particular engine or calling convention.
@@ -71,7 +73,7 @@ public LogicalFilter(
       RexNode condition,
       ImmutableSet<CorrelationId> variablesSet) {
     super(cluster, traitSet, hints, child, condition);
-    this.variablesSet = Objects.requireNonNull(variablesSet, "variablesSet");
+    this.variablesSet = requireNonNull(variablesSet, "variablesSet");
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalJoin.java
Patch:
@@ -35,7 +35,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
@@ -145,7 +144,7 @@ public LogicalJoin(RelOptCluster cluster, RelNode left, RelNode right,
    */
   public LogicalJoin(RelInput input) {
     this(input.getCluster(), input.getCluster().traitSetOf(Convention.NONE),
-        new ArrayList<>(),
+        ImmutableList.of(),
         input.getInputs().get(0), input.getInputs().get(1),
         requireNonNull(input.getExpression("condition"), "condition"),
         ImmutableSet.of(),

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
Patch:
@@ -57,6 +57,8 @@
 import java.util.Map;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Sub-class of {@link org.apache.calcite.rel.core.Window}
  * not targeted at any particular engine or calling convention.
@@ -245,8 +247,7 @@ public static RelNode create(RelOptCluster cluster,
           @Override public RexNode visitOver(RexOver over) {
             // Look up the aggCall which this expr was translated to.
             final Window.RexWinAggCall aggCall =
-                aggMap.get(origToNewOver.get(over));
-            assert aggCall != null;
+                requireNonNull(aggMap.get(origToNewOver.get(over)));
             assert RelOptUtil.eq(
                 "over",
                 over.getType(),

File: core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
Patch:
@@ -370,7 +370,7 @@ Method find(final Class<? extends RelNode> relNodeClass, Method method) {
   /** Extended work space. */
   @Deprecated // to be removed before 2.0
   static class Space2 extends Space {
-    private Class<Metadata> metadataClass0;
+    private final Class<Metadata> metadataClass0;
 
     Space2(Class<Metadata> metadataClass0,
         ImmutableMultimap<Method, MetadataHandler<?>> providerMap) {
@@ -382,7 +382,7 @@ static class Space2 extends Space {
     public static Space2 create(
         MetadataHandler<?> target,
         ImmutableList<Method> methods) {
-      assert methods.size() > 0;
+      assert !methods.isEmpty();
       final Method method0 = methods.get(0);
       //noinspection unchecked
       Class<Metadata> metadataClass0 = (Class) method0.getDeclaringClass();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
Patch:
@@ -70,11 +70,12 @@
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableSet;
-import java.util.Objects;
 import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.stream.Collectors;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * RelMdCollation supplies a default implementation of
  * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#collations}
@@ -246,7 +247,7 @@ private RelMdCollation() {}
   public @Nullable ImmutableList<RelCollation> collations(RelSubset rel,
       RelMetadataQuery mq) {
     return copyOf(
-        Objects.requireNonNull(
+        requireNonNull(
             rel.getTraitSet().getTraits(RelCollationTraitDef.INSTANCE)));
   }
 

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java
Patch:
@@ -130,7 +130,7 @@ public Double getPercentageOriginalRows(Union rel, RelMetadataQuery mq) {
       return null;
     }
 
-    if (rel.getInputs().size() == 0) {
+    if (rel.getInputs().isEmpty()) {
       // Assume no filtering happening at leaf.
       return 1.0;
     }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
Patch:
@@ -567,7 +567,7 @@ public RelOptPredicateList getPredicates(Exchange exchange,
    */
   public RelOptPredicateList getPredicates(Values values, RelMetadataQuery mq) {
     ImmutableList<ImmutableList<RexLiteral>> tuples = values.tuples;
-    if (tuples.size() > 0) {
+    if (!tuples.isEmpty()) {
       Set<Integer> constants = new HashSet<>();
       IntStream.range(0, tuples.size()).boxed().forEach(constants::add);
       List<RexLiteral> firstTuple = new ArrayList<>(tuples.get(0));
@@ -826,7 +826,7 @@ public RelOptPredicateList inferPredicates(
             RelOptUtil.conjunctions(rightChildPredicates),
             inferredPredicates, EMPTY_LIST);
       default:
-        assert inferredPredicates.size() == 0;
+        assert inferredPredicates.isEmpty();
         return RelOptPredicateList.EMPTY;
       }
     }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java
Patch:
@@ -73,7 +73,7 @@ protected RelMdSelectivity() {
 
   public @Nullable Double getSelectivity(Union rel, RelMetadataQuery mq,
       @Nullable RexNode predicate) {
-    if ((rel.getInputs().size() == 0) || (predicate == null)) {
+    if (rel.getInputs().isEmpty() || predicate == null) {
       return 1.0;
     }
 

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
Patch:
@@ -446,7 +446,7 @@ public static RelMetadataQuery instance() {
       return null;
     }
     final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0);
-    if (colOrigins == null || colOrigins.size() == 0) {
+    if (colOrigins == null || colOrigins.isEmpty()) {
       return null;
     }
     return colOrigins.iterator().next().getOriginTable();

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
Patch:
@@ -106,7 +106,7 @@ private static boolean isAggregateSupported(AggregateCall aggCall) {
     final List<AggregateCall> finalCalls = new ArrayList<>();
     for (AggregateCall topCall : topAgg.getAggCallList()) {
       if (!isAggregateSupported(topCall)
-          || topCall.getArgList().size() == 0) {
+          || topCall.getArgList().isEmpty()) {
         return;
       }
       // Make sure top aggregate argument refers to one of the aggregate

File: core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
Patch:
@@ -74,7 +74,7 @@ public JoinAddRedundantSemiJoinRule(Class<? extends Join> clazz,
 
     // determine if we have a valid join condition
     final JoinInfo joinInfo = origJoinRel.analyzeCondition();
-    if (joinInfo.leftKeys.size() == 0) {
+    if (joinInfo.leftKeys.isEmpty()) {
       return;
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
Patch:
@@ -82,15 +82,15 @@ public JoinPushTransitivePredicatesRule(Class<? extends Join> joinClass,
     final RelBuilder relBuilder = call.builder();
 
     RelNode left = join.getLeft();
-    if (preds.leftInferredPredicates.size() > 0) {
+    if (!preds.leftInferredPredicates.isEmpty()) {
       RelNode curr = left;
       left = relBuilder.push(left)
           .filter(preds.leftInferredPredicates).build();
       call.getPlanner().onCopy(curr, left);
     }
 
     RelNode right = join.getRight();
-    if (preds.rightInferredPredicates.size() > 0) {
+    if (!preds.rightInferredPredicates.isEmpty()) {
       RelNode curr = right;
       right = relBuilder.push(right)
           .filter(preds.rightInferredPredicates).build();

File: core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
Patch:
@@ -74,7 +74,7 @@ public class LoptSemiJoinOptimizer {
    * Semijoins corresponding to each join factor, if they are going to be
    * filtered by semijoins. Otherwise, the entry is the original join factor.
    */
-  private RelNode [] chosenSemiJoins;
+  private final RelNode [] chosenSemiJoins;
 
   /**
    * Associates potential semijoins with each fact table factor. The first
@@ -265,7 +265,7 @@ private static int isSuitableFilter(
     RelNode factRel = multiJoin.getJoinFactor(factIdx);
     RelNode dimRel = multiJoin.getJoinFactor(dimIdx);
     final JoinInfo joinInfo = JoinInfo.of(factRel, dimRel, semiJoinCondition);
-    assert joinInfo.leftKeys.size() > 0;
+    assert !joinInfo.leftKeys.isEmpty();
 
     // mutable copies
     final List<Integer> leftKeys = Lists.newArrayList(joinInfo.leftKeys);

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
Patch:
@@ -46,11 +46,12 @@
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.rel.rules.LoptMultiJoin.Edge;
 import static org.apache.calcite.util.mapping.Mappings.TargetMapping;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Planner rule that finds an approximately optimal ordering for join operators
  * using a heuristic algorithm.
@@ -398,7 +399,7 @@ static class JoinVertex extends Vertex {
       super(id, factors, cost);
       this.leftFactor = leftFactor;
       this.rightFactor = rightFactor;
-      this.conditions = Objects.requireNonNull(conditions, "conditions");
+      this.conditions = requireNonNull(conditions, "conditions");
     }
 
     @Override public String toString() {

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectTableScanRule.java
Patch:
@@ -41,6 +41,8 @@
 import java.util.List;
 import java.util.stream.Collectors;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Planner rule that converts a {@link Project}
  * on a {@link org.apache.calcite.rel.core.TableScan}
@@ -102,7 +104,7 @@ protected static boolean test(TableScan scan) {
 
   protected void apply(RelOptRuleCall call, Project project, TableScan scan) {
     final RelOptTable table = scan.getTable();
-    assert table.unwrap(ProjectableFilterableTable.class) != null;
+    requireNonNull(table.unwrap(ProjectableFilterableTable.class));
 
     final List<Integer> selectedColumns = new ArrayList<>();
     final RexVisitorImpl<Void> visitor = new RexVisitorImpl<Void>(true) {

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -220,11 +220,10 @@ private RexExpander getExpander(RexCall call) {
    * Maps a RexCall to a RexExpander.
    */
   private static class ExpanderMap {
-    private final Map<SqlOperator, RexExpander> map;
-    private RexExpander defaultExpander;
+    private final Map<SqlOperator, RexExpander> map = new HashMap<>();
+    private final RexExpander defaultExpander;
 
     private ExpanderMap(RexBuilder rexBuilder) {
-      map = new HashMap<>();
       defaultExpander = new CastArgAsDoubleExpander(rexBuilder);
       registerExpanders(map, rexBuilder);
     }

File: core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java
Patch:
@@ -44,7 +44,8 @@
 import org.immutables.value.Value;
 
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Planner rule that pushes
@@ -131,7 +132,7 @@ protected SortProjectTransposeRule(RelOptRuleOperand operand) {
       if (node.isA(SqlKind.CAST)) {
         // Check whether it is a monotonic preserving cast, otherwise we cannot push
         final RexCall cast = (RexCall) node;
-        RelFieldCollation newFc = Objects.requireNonNull(RexUtil.apply(map, fc));
+        RelFieldCollation newFc = requireNonNull(RexUtil.apply(map, fc));
         final RexCallBinding binding =
             RexCallBinding.create(cluster.getTypeFactory(), cast,
                 ImmutableList.of(RelCollations.of(newFc)));

File: core/src/main/java/org/apache/calcite/rel/rules/SortRemoveRedundantRule.java
Patch:
@@ -127,7 +127,7 @@ protected SortRemoveRedundantRule(final SortRemoveRedundantRule.Config config) {
     }
   }
 
-  private Optional<Integer> getRowCountThreshold(Sort sort) {
+  private static Optional<Integer> getRowCountThreshold(Sort sort) {
     if (RelOptUtil.isLimit(sort)) {
       final int fetch =
           sort.fetch instanceof RexLiteral ? RexLiteral.intValue(sort.fetch) : 0;

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
Patch:
@@ -31,7 +31,8 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * RelDataTypeFactory is a factory for datatype descriptors. It defines methods
@@ -468,7 +469,7 @@ class Builder {
      * Creates a Builder with the given type factory.
      */
     public Builder(RelDataTypeFactory typeFactory) {
-      this.typeFactory = Objects.requireNonNull(typeFactory, "typeFactory");
+      this.typeFactory = requireNonNull(typeFactory, "typeFactory");
     }
 
     /**

File: core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
Patch:
@@ -166,10 +166,10 @@ private Object writeReplace() {
    * immutable list.
    */
   private static class SerializableRelRecordType implements Serializable {
-    private List<RelDataTypeField> fields;
+    private final List<RelDataTypeField> fields;
 
     private SerializableRelRecordType(List<RelDataTypeField> fields) {
-      this.fields = fields;
+      this.fields = requireNonNull(fields, "fields");
     }
 
     /**

File: core/src/main/java/org/apache/calcite/rex/RexCall.java
Patch:
@@ -81,7 +81,6 @@ protected RexCall(
     this.op = requireNonNull(operator, "operator");
     this.operands = ImmutableList.copyOf(operands);
     this.nodeCount = RexUtil.nodeCount(1, this.operands);
-    assert operator.getKind() != null : operator;
     assert operator.validRexOperands(operands.size(), Litmus.THROW) : this;
     assert operator.kind != SqlKind.IN || this instanceof RexSubQuery;
   }
@@ -158,8 +157,8 @@ private static String computeDigest(RexLiteral literal, RexDigestIncludeType inc
 
   protected String computeDigest(boolean withType) {
     final StringBuilder sb = new StringBuilder(op.getName());
-    if ((operands.size() == 0)
-        && (op.getSyntax() == SqlSyntax.FUNCTION_ID)) {
+    if (operands.isEmpty()
+        && op.getSyntax() == SqlSyntax.FUNCTION_ID) {
       // Don't print params for empty arg list. For example, we want
       // "SYSTEM_USER", not "SYSTEM_USER()".
     } else {

File: core/src/main/java/org/apache/calcite/rex/RexCorrelVariable.java
Patch:
@@ -24,6 +24,8 @@
 
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Reference to the current row of a correlating relational expression.
  *
@@ -40,7 +42,7 @@ public class RexCorrelVariable extends RexVariable {
       CorrelationId id,
       RelDataType type) {
     super(id.getName(), type);
-    this.id = Objects.requireNonNull(id, "id");
+    this.id = requireNonNull(id, "id");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rex/RexLambda.java
Patch:
@@ -27,6 +27,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Represents a lambda expression.
  */
@@ -40,7 +42,7 @@ public class RexLambda extends RexNode {
 
   RexLambda(List<RexLambdaRef> parameters, RexNode expression) {
     this.parameters = ImmutableList.copyOf(parameters);
-    this.expression = Objects.requireNonNull(expression, "expression");
+    this.expression = requireNonNull(expression, "expression");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rex/RexLocalRef.java
Patch:
@@ -24,6 +24,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Local variable.
  *
@@ -52,8 +54,7 @@ public class RexLocalRef extends RexSlot {
    */
   public RexLocalRef(int index, RelDataType type) {
     super(createName(index), index, type);
-    assert type != null;
-    assert index >= 0;
+    checkArgument(index >= 0);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -29,6 +29,8 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Call to an aggregate function over a window.
  */
@@ -71,7 +73,7 @@ public class RexOver extends RexCall {
       boolean ignoreNulls) {
     super(type, op, operands);
     checkArgument(op.isAggregator());
-    this.window = Objects.requireNonNull(window, "window");
+    this.window = requireNonNull(window, "window");
     this.distinct = distinct;
     this.ignoreNulls = ignoreNulls;
   }

File: core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
Patch:
@@ -28,11 +28,12 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.ImmutableList.toImmutableList;
 
+import static java.util.Objects.requireNonNull;
+
 /** Builds a state-transition graph for deterministic finite automaton. */
 public class AutomatonBuilder {
   private final Map<String, Integer> symbolIds = new HashMap<>();
@@ -121,7 +122,7 @@ public Automaton build() {
   /** Adds a symbol transition. */
   AutomatonBuilder symbol(State fromState, State toState,
       String name) {
-    Objects.requireNonNull(name, "name");
+    requireNonNull(name, "name");
     final int symbolId =
         symbolIds.computeIfAbsent(name, k -> symbolIds.size());
     transitionList.add(new SymbolTransition(fromState, toState, symbolId));

File: core/src/main/java/org/apache/calcite/runtime/BufferStyle.java
Patch:
@@ -20,6 +20,8 @@
 
 import java.util.Locale;
 
+import static java.lang.Integer.parseInt;
+
 /**
  * A parser for buffer styles as defined by PostGIS.
  */
@@ -48,7 +50,7 @@ public BufferStyle(String style) {
       switch (key) {
       case "quad_segs":
         try {
-          quadrantSegments = Integer.parseInt(value);
+          quadrantSegments = parseInt(value);
           break;
         } catch (NumberFormatException e) {
           throw new IllegalArgumentException("Invalid buffer style: " + style);

File: core/src/main/java/org/apache/calcite/runtime/CalciteContextException.java
Patch:
@@ -23,6 +23,8 @@
 import org.checkerframework.checker.initialization.qual.UnknownInitialization;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Exception which contains information about the textual context of the causing
  * exception.
@@ -79,8 +81,7 @@ public CalciteContextException(
       int posColumn,
       int endPosLine,
       int endPosColumn) {
-    super(message, cause);
-    assert cause != null;
+    super(message, requireNonNull(cause, "cause"));
     setPosition(posLine, posColumn, endPosLine, endPosColumn);
   }
 

File: core/src/main/java/org/apache/calcite/runtime/Enumerables.java
Patch:
@@ -29,11 +29,12 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Utilities for processing {@link org.apache.calcite.linq4j.Enumerable}
  * collections.
@@ -96,7 +97,7 @@ public static <E, TKey, TResult> Enumerable<TResult> match(
           final AtomicInteger matchCounter = new AtomicInteger(1);
 
           @Override public TResult current() {
-            Objects.requireNonNull(resultRow, "resultRow");
+            requireNonNull(resultRow, "resultRow");
             return resultRow;
           }
 

File: core/src/main/java/org/apache/calcite/runtime/SocketFactoryImpl.java
Patch:
@@ -93,7 +93,7 @@ public class SocketFactoryImpl extends SocketFactory {
    */
   public static final int LINGER = 0;
 
-  @Override public Socket createSocket() throws IOException {
+  @Override public Socket createSocket() {
     Socket s = new Socket();
     return applySettings(s);
   }

File: core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java
Patch:
@@ -40,6 +40,8 @@
 import java.util.regex.Pattern;
 import javax.xml.parsers.ParserConfigurationException;
 
+import static java.lang.Integer.parseInt;
+
 /**
  * Utilities for spatial types.
  */
@@ -177,7 +179,7 @@ public static Geometry fromEwkt(String ewkt) {
     Geometry geometry = fromWkt(wkt);
     String srid = matcher.group(1);
     if (srid != null) {
-      geometry.setSRID(Integer.parseInt(srid));
+      geometry.setSRID(parseInt(srid));
     }
 
     return geometry;

File: core/src/main/java/org/apache/calcite/schema/impl/ModifiableViewTable.java
Patch:
@@ -115,8 +115,8 @@ public ModifiableViewTable(Type elementType, RelProtoDataType rowType,
    */
   public final ModifiableViewTable extend(
       List<RelDataTypeField> extendedColumns, RelDataTypeFactory typeFactory) {
-    final ExtensibleTable underlying = unwrap(ExtensibleTable.class);
-    assert underlying != null;
+    final ExtensibleTable underlying =
+        requireNonNull(unwrap(ExtensibleTable.class));
 
     final RelDataTypeFactory.Builder builder = typeFactory.builder();
     final RelDataType rowType = getRowType(typeFactory);

File: core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
Patch:
@@ -41,10 +41,11 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Virtual table that is composed of two or more tables joined together.
  *
@@ -68,7 +69,7 @@ public class StarTable extends AbstractTable implements TranslatableTable {
 
   /** Creates a StarTable. */
   private StarTable(Lattice lattice, ImmutableList<Table> tables) {
-    this.lattice = Objects.requireNonNull(lattice, "lattice");
+    this.lattice = requireNonNull(lattice, "lattice");
     this.tables = tables;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlBinaryStringLiteral.java
Patch:
@@ -22,7 +22,8 @@
 import org.apache.calcite.util.Util;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A binary (or hexadecimal) string literal.
@@ -52,7 +53,7 @@ public BitString getBitString() {
   }
 
   private BitString getValueNonNull() {
-    return (BitString) Objects.requireNonNull(value, "value");
+    return (BitString) requireNonNull(value, "value");
   }
 
   @Override public SqlBinaryStringLiteral clone(SqlParserPos pos) {

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -32,10 +32,11 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>SqlCall</code> is a call to an {@link SqlOperator operator}.
  * (Operators can be used to describe any syntactic construct, so in practice,
@@ -198,8 +199,7 @@ public String getCallSignature(
     List<String> signatureList = new ArrayList<>();
     for (final SqlNode operand : getOperandList()) {
       final RelDataType argType =
-          validator.deriveType(Objects.requireNonNull(scope, "scope"),
-              operand);
+          validator.deriveType(requireNonNull(scope, "scope"), operand);
       if (null == argType) {
         continue;
       }

File: core/src/main/java/org/apache/calcite/sql/SqlCharStringLiteral.java
Patch:
@@ -25,7 +25,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A character string literal.
@@ -54,7 +55,7 @@ public NlsString getNlsString() {
   }
 
   private NlsString getValueNonNull() {
-    return (NlsString) Objects.requireNonNull(value, "value");
+    return (NlsString) requireNonNull(value, "value");
   }
   /**
    * Returns the collation.

File: core/src/main/java/org/apache/calcite/sql/SqlDateLiteral.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.DateString;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * A SQL literal representing a DATE value, such as <code>DATE
@@ -41,7 +41,7 @@ public class SqlDateLiteral extends SqlAbstractDateTimeLiteral {
 
   /** Converts this literal to a {@link DateString}. */
   protected DateString getDate() {
-    return (DateString) Objects.requireNonNull(value, "value");
+    return (DateString) requireNonNull(value, "value");
   }
 
   @Override public SqlDateLiteral clone(SqlParserPos pos) {

File: core/src/main/java/org/apache/calcite/sql/SqlDdl.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.sql.parser.SqlParserPos;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** Base class for CREATE, DROP and other DDL statements. */
 public abstract class SqlDdl extends SqlCall {
@@ -31,7 +31,7 @@ public abstract class SqlDdl extends SqlCall {
   /** Creates a SqlDdl. */
   protected SqlDdl(SqlOperator operator, SqlParserPos pos) {
     super(pos);
-    this.operator = Objects.requireNonNull(operator, "operator");
+    this.operator = requireNonNull(operator, "operator");
   }
 
   @Override public SqlOperator getOperator() {

File: core/src/main/java/org/apache/calcite/sql/SqlDescribeTable.java
Patch:
@@ -22,7 +22,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A <code>SqlDescribeTable</code> is a node of a parse tree that represents a
@@ -48,7 +49,7 @@ public SqlDescribeTable(SqlParserPos pos,
       SqlIdentifier table,
       @Nullable SqlIdentifier column) {
     super(pos);
-    this.table = Objects.requireNonNull(table, "table");
+    this.table = requireNonNull(table, "table");
     this.column = column;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlFunction.java
Patch:
@@ -34,11 +34,12 @@
 import org.checkerframework.dataflow.qual.Pure;
 
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>SqlFunction</code> is a type of operator which has conventional
  * function-call syntax.
@@ -132,7 +133,7 @@ protected SqlFunction(
         operandTypeChecker);
 
     this.sqlIdentifier = sqlIdentifier;
-    this.category = Objects.requireNonNull(category, "category");
+    this.category = requireNonNull(category, "category");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlHint.java
Patch:
@@ -161,8 +161,9 @@ public Map<String, String> getOptionKVPairs() {
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
     name.unparse(writer, leftPrec, rightPrec);
-    if (this.options.size() > 0) {
-      SqlWriter.Frame frame = writer.startList(SqlWriter.FrameTypeEnum.FUN_CALL, "(", ")");
+    if (!this.options.isEmpty()) {
+      SqlWriter.Frame frame =
+          writer.startList(SqlWriter.FrameTypeEnum.FUN_CALL, "(", ")");
       for (int i = 0; i < options.size(); i++) {
         SqlNode option = options.get(i);
         SqlNode nextOption = i < options.size() - 1 ? options.get(i + 1) : null;

File: core/src/main/java/org/apache/calcite/sql/SqlInsert.java
Patch:
@@ -26,6 +26,8 @@
 
 import java.util.List;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>SqlInsert</code> is a node of a parse tree which represents an INSERT
  * statement.
@@ -59,11 +61,10 @@ public SqlInsert(SqlParserPos pos,
       SqlNode source,
       @Nullable SqlNodeList columnList) {
     super(pos);
-    this.keywords = keywords;
+    this.keywords = requireNonNull(keywords, "keywords");
     this.targetTable = targetTable;
     this.source = source;
     this.columnList = columnList;
-    assert keywords != null;
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlNode.java
Patch:
@@ -33,11 +33,12 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 import java.util.function.UnaryOperator;
 import java.util.stream.Collector;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>SqlNode</code> is a SQL parse tree.
  *
@@ -62,7 +63,7 @@ public abstract class SqlNode implements Cloneable {
    * @param pos Parser position, must not be null.
    */
   SqlNode(SqlParserPos pos) {
-    this.pos = Objects.requireNonNull(pos, "pos");
+    this.pos = requireNonNull(pos, "pos");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -78,7 +78,7 @@
 public abstract class SqlOperator {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final String NL = System.getProperty("line.separator");
+  public static final String NL = System.lineSeparator();
 
   /**
    * Maximum precedence.
@@ -134,9 +134,8 @@ protected SqlOperator(
       @Nullable SqlReturnTypeInference returnTypeInference,
       @Nullable SqlOperandTypeInference operandTypeInference,
       @Nullable SqlOperandTypeChecker operandTypeChecker) {
-    assert kind != null;
     this.name = name;
-    this.kind = kind;
+    this.kind = requireNonNull(kind, "kind");
     this.leftPrec = leftPrecedence;
     this.rightPrec = rightPrecedence;
     this.returnTypeInference = returnTypeInference;

File: core/src/main/java/org/apache/calcite/sql/SqlSelect.java
Patch:
@@ -275,7 +275,7 @@ public void setHints(@Nullable SqlNodeList hints) {
   @EnsuresNonNullIf(expression = "hints", result = true)
   public boolean hasHints() {
     // The hints may be passed as null explicitly.
-    return this.hints != null && this.hints.size() > 0;
+    return this.hints != null && !this.hints.isEmpty();
   }
 
   @Override public void validate(SqlValidator validator, SqlValidatorScope scope) {
@@ -307,7 +307,7 @@ public boolean hasHints() {
   }
 
   public boolean hasOrderBy() {
-    return orderBy != null && orderBy.size() != 0;
+    return orderBy != null && !orderBy.isEmpty();
   }
 
   public boolean hasWhere() {

File: core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java
Patch:
@@ -206,7 +206,7 @@ public SqlSelect createCall(
     }
     if (select.groupBy != null) {
       SqlNodeList groupBy =
-          select.groupBy.size() == 0 ? SqlNodeList.SINGLETON_EMPTY
+          select.groupBy.isEmpty() ? SqlNodeList.SINGLETON_EMPTY
               : select.groupBy;
       // if the DISTINCT keyword of GROUP BY is present it can be the only item
       if (groupBy.size() == 1 && groupBy.get(0) != null
@@ -224,7 +224,7 @@ public SqlSelect createCall(
       writer.sep("HAVING");
       select.having.unparse(writer, 0, 0);
     }
-    if (select.windowDecls.size() > 0) {
+    if (!select.windowDecls.isEmpty()) {
       writer.sep("WINDOW");
       writer.list(SqlWriter.FrameTypeEnum.WINDOW_DECL_LIST, SqlWriter.COMMA,
           select.windowDecls);
@@ -233,7 +233,7 @@ public SqlSelect createCall(
       writer.sep("QUALIFY");
       select.qualify.unparse(writer, 0, 0);
     }
-    if (select.orderBy != null && select.orderBy.size() > 0) {
+    if (select.orderBy != null && !select.orderBy.isEmpty()) {
       writer.sep("ORDER BY");
       writer.list(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, SqlWriter.COMMA,
           select.orderBy);

File: core/src/main/java/org/apache/calcite/sql/SqlSetOption.java
Patch:
@@ -97,9 +97,8 @@ public SqlSetOption(SqlParserPos pos, @Nullable String scope, SqlIdentifier name
       @Nullable SqlNode value) {
     super(pos, scope);
     this.scope = scope;
-    this.name = name;
+    this.name = requireNonNull(name, "name");
     this.value = value;
-    assert name != null;
   }
 
   @Override public SqlKind getKind() {

File: core/src/main/java/org/apache/calcite/sql/SqlTableRef.java
Patch:
@@ -72,7 +72,7 @@ public SqlTableRef(SqlParserPos pos, SqlIdentifier tableName, SqlNodeList hints)
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
     tableName.unparse(writer, leftPrec, rightPrec);
-    if (this.hints != null && this.hints.size() > 0) {
+    if (!this.hints.isEmpty()) {
       writer.getDialect().unparseTableScanHints(writer, this.hints, leftPrec, rightPrec);
     }
   }

File: core/src/main/java/org/apache/calcite/sql/SqlTimeLiteral.java
Patch:
@@ -20,10 +20,10 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimeString;
 
-import java.util.Objects;
-
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A SQL literal representing a TIME value, for example <code>TIME
  * '14:33:44.567'</code>.
@@ -43,7 +43,7 @@ public class SqlTimeLiteral extends SqlAbstractDateTimeLiteral {
 
   /** Converts this literal to a {@link TimeString}. */
   protected TimeString getTime() {
-    return (TimeString) Objects.requireNonNull(value, "value");
+    return (TimeString) requireNonNull(value, "value");
   }
 
   @Override public SqlTimeLiteral clone(SqlParserPos pos) {

File: core/src/main/java/org/apache/calcite/sql/SqlTimeTzLiteral.java
Patch:
@@ -20,10 +20,10 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimeWithTimeZoneString;
 
-import java.util.Objects;
-
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A SQL literal representing a TIME WITH TIME ZONE value, for example <code>TIME WITH TIME ZONE
  * '14:33:44.567 GMT+08'</code>.
@@ -43,7 +43,7 @@ public class SqlTimeTzLiteral extends SqlAbstractDateTimeLiteral {
 
   /** Converts this literal to a {@link TimeWithTimeZoneString}. */
   protected TimeWithTimeZoneString getTime() {
-    return (TimeWithTimeZoneString) Objects.requireNonNull(value, "value");
+    return (TimeWithTimeZoneString) requireNonNull(value, "value");
   }
 
   @Override public SqlTimeTzLiteral clone(SqlParserPos pos) {

File: core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java
Patch:
@@ -20,10 +20,10 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimestampString;
 
-import java.util.Objects;
-
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A SQL literal representing a TIMESTAMP value, for example <code>TIMESTAMP
  * '1969-07-21 03:15'</code>.
@@ -45,7 +45,7 @@ public class SqlTimestampLiteral extends SqlAbstractDateTimeLiteral {
 
   @Override public SqlTimestampLiteral clone(SqlParserPos pos) {
     return new SqlTimestampLiteral(
-        (TimestampString) Objects.requireNonNull(value, "value"),
+        (TimestampString) requireNonNull(value, "value"),
         precision,
         getTypeName(), pos);
   }

File: core/src/main/java/org/apache/calcite/sql/SqlTimestampTzLiteral.java
Patch:
@@ -20,10 +20,10 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimestampWithTimeZoneString;
 
-import java.util.Objects;
-
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A SQL literal representing a TIMESTAMP WITH TIME ZONE value, for example <code>TIMESTAMP
  * '1969-07-21 03:15 GMT+00:00'</code>.
@@ -58,7 +58,7 @@ public class SqlTimestampTzLiteral extends SqlAbstractDateTimeLiteral {
   }
 
   TimestampWithTimeZoneString getTimestampTz() {
-    return (TimestampWithTimeZoneString) Objects.requireNonNull(value, "value");
+    return (TimestampWithTimeZoneString) requireNonNull(value, "value");
   }
 
   @Override public void unparse(

File: core/src/main/java/org/apache/calcite/sql/SqlTypeConstructorFunction.java
Patch:
@@ -27,7 +27,7 @@
  */
 public class SqlTypeConstructorFunction extends SqlFunction {
 
-  private RelDataType type;
+  private final RelDataType type;
 
   /**
    * Creates a constructor function for types.

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateForeignSchema.java
Patch:
@@ -34,12 +34,13 @@
 
 import java.util.AbstractList;
 import java.util.List;
-import java.util.Objects;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Parse tree for {@code CREATE FOREIGN SCHEMA} statement.
  */
@@ -58,7 +59,7 @@ public class SqlCreateForeignSchema extends SqlCreate {
       SqlIdentifier name, @Nullable SqlNode type, @Nullable SqlNode library,
       @Nullable SqlNodeList optionList) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.type = type;
     this.library = library;
     checkArgument((type == null) != (library == null),

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateSchema.java
Patch:
@@ -27,7 +27,8 @@
 import org.apache.calcite.util.ImmutableNullableList;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Parse tree for {@code CREATE SCHEMA} statement.
@@ -42,7 +43,7 @@ public class SqlCreateSchema extends SqlCreate {
   SqlCreateSchema(SqlParserPos pos, boolean replace, boolean ifNotExists,
       SqlIdentifier name) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
   }
 
   @Override public List<SqlNode> getOperandList() {

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateTable.java
Patch:
@@ -30,7 +30,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Parse tree for {@code CREATE TABLE} statement.
@@ -47,7 +48,7 @@ public class SqlCreateTable extends SqlCreate {
   protected SqlCreateTable(SqlParserPos pos, boolean replace, boolean ifNotExists,
       SqlIdentifier name, @Nullable SqlNodeList columnList, @Nullable SqlNode query) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.columnList = columnList; // may be null
     this.query = query; // for "CREATE TABLE ... AS query"; may be null
   }

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateType.java
Patch:
@@ -31,7 +31,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Parse tree for {@code CREATE TYPE} statement.
@@ -48,7 +49,7 @@ public class SqlCreateType extends SqlCreate {
   SqlCreateType(SqlParserPos pos, boolean replace, SqlIdentifier name,
       @Nullable SqlNodeList attributeDefs, @Nullable SqlDataTypeSpec dataType) {
     super(OPERATOR, pos, replace, false);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.attributeDefs = attributeDefs; // may be null
     this.dataType = dataType; // may be null
   }

File: core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
Patch:
@@ -55,6 +55,7 @@
 import java.util.Locale;
 import java.util.regex.Pattern;
 
+import static java.lang.Long.parseLong;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -229,7 +230,7 @@ public BigQuerySqlDialect(SqlDialect.Context context) {
       writer.print("-");
     }
     try {
-      Long.parseLong(interval.getIntervalLiteral());
+      parseLong(interval.getIntervalLiteral());
     } catch (NumberFormatException e) {
       throw new RuntimeException("Only INT64 is supported as the interval value for BigQuery.");
     }

File: core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java
Patch:
@@ -46,6 +46,8 @@
 import java.util.Locale;
 import java.util.regex.Pattern;
 
+import static java.lang.Long.parseLong;
+
 /**
  * A SqlDialect implementation for the Firebolt database.
  */
@@ -214,7 +216,7 @@ public FireboltSqlDialect(Context context) {
     writer.keyword("INTERVAL");
     writer.print("'");
     try {
-      Long.parseLong(interval.getIntervalLiteral());
+      parseLong(interval.getIntervalLiteral());
     } catch (NumberFormatException e) {
       throw new RuntimeException("Only INT64 is supported as the interval value for Firebolt.");
     }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlAbstractGroupFunction.java
Patch:
@@ -36,6 +36,8 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Base class for grouping functions {@code GROUP_ID}, {@code GROUPING_ID},
  * {@code GROUPING}.
@@ -65,8 +67,7 @@ public SqlAbstractGroupFunction(String name,
       SqlValidatorScope scope, SqlValidatorScope operandScope) {
     super.validateCall(call, validator, scope, operandScope);
     final SelectScope selectScope =
-        SqlValidatorUtil.getEnclosingSelectScope(scope);
-    assert selectScope != null;
+        requireNonNull(SqlValidatorUtil.getEnclosingSelectScope(scope));
     final SqlSelect select = selectScope.getNode();
     if (!validator.isAggregate(select)) {
       throw validator.newValidationError(call,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlBasicAggFunction.java
Patch:
@@ -69,7 +69,8 @@ private SqlBasicAggFunction(String name, @Nullable SqlIdentifier sqlIdentifier,
       SqlSyntax syntax, boolean allowsNullTreatment, boolean allowsSeparator,
       boolean percentile, boolean allowsFraming) {
     super(name, sqlIdentifier, kind,
-        requireNonNull(returnTypeInference, "returnTypeInference"), operandTypeInference,
+        requireNonNull(returnTypeInference, "returnTypeInference"),
+        operandTypeInference,
         requireNonNull(operandTypeChecker, "operandTypeChecker"),
         requireNonNull(funcType, "funcType"), requiresOrder, requiresOver,
         requiresGroupOrder);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlDotOperator.java
Patch:
@@ -100,8 +100,7 @@ public class SqlDotOperator extends SqlSpecialOperator {
       SqlValidatorScope scope, SqlCall call) {
     final SqlNode operand = call.getOperandList().get(0);
     final RelDataType nodeType =
-        validator.deriveType(scope, operand);
-    assert nodeType != null;
+        requireNonNull(validator.deriveType(scope, operand));
     if (!nodeType.isStruct()) {
       throw SqlUtil.newContextException(operand.getParserPosition(),
           Static.RESOURCE.incompatibleTypes());

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java
Patch:
@@ -36,7 +36,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * The <code>JSON_OBJECTAGG</code> aggregate function.
@@ -49,7 +49,7 @@ public SqlJsonArrayAggAggFunction(SqlKind kind,
     super(kind + "_" + nullClause.name(), null, kind, ReturnTypes.VARCHAR_2000,
         InferTypes.ANY_NULLABLE, OperandTypes.family(SqlTypeFamily.ANY),
         SqlFunctionCategory.SYSTEM, false, false, Optionality.OPTIONAL);
-    this.nullClause = Objects.requireNonNull(nullClause, "nullClause");
+    this.nullClause = requireNonNull(nullClause, "nullClause");
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.Optionality;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * The <code>JSON_OBJECTAGG</code> aggregate function.
@@ -54,7 +54,7 @@ public SqlJsonObjectAggAggFunction(SqlKind kind,
         },
         OperandTypes.family(SqlTypeFamily.CHARACTER, SqlTypeFamily.ANY),
         SqlFunctionCategory.SYSTEM, false, false, Optionality.FORBIDDEN);
-    this.nullClause = Objects.requireNonNull(nullClause, "nullClause");
+    this.nullClause = requireNonNull(nullClause, "nullClause");
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java
Patch:
@@ -46,6 +46,8 @@
 import java.util.Optional;
 import java.util.stream.Collectors;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * The <code>JSON_VALUE</code> function.
  */
@@ -65,7 +67,7 @@ public SqlJsonValueFunction(String name) {
 
   private static RelDataType deriveExplicitType(SqlOperatorBinding opBinding, RelDataType type) {
     if (SqlTypeName.ARRAY == type.getSqlTypeName()) {
-      RelDataType elementType = Objects.requireNonNull(type.getComponentType());
+      RelDataType elementType = requireNonNull(type.getComponentType());
       RelDataType nullableElementType = deriveExplicitType(opBinding, elementType);
       return SqlTypeUtil.createArrayType(
           opBinding.getTypeFactory(),

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -196,7 +196,7 @@ private static boolean argTypesValid(SqlCallBinding callBinding) {
    */
   public static SqlLiteral concatenateOperands(SqlCall call) {
     final List<SqlNode> operandList = call.getOperandList();
-    assert operandList.size() > 0;
+    assert !operandList.isEmpty();
     assert operandList.get(0) instanceof SqlLiteral
         : operandList.get(0).getClass();
     return SqlUtil.concatenateLiterals(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
Patch:
@@ -66,7 +66,7 @@ public SqlMapValueConstructor() {
       SqlCallBinding callBinding,
       boolean throwOnFailure) {
     final List<RelDataType> argTypes = SqlTypeUtil.deriveType(callBinding, callBinding.operands());
-    if (argTypes.size() == 0) {
+    if (argTypes.isEmpty()) {
       throw callBinding.newValidationError(RESOURCE.mapRequiresTwoOrMoreArgs());
     }
     if (argTypes.size() % 2 > 0) {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
Patch:
@@ -96,7 +96,7 @@ protected SqlMultisetValueConstructor(
       boolean throwOnFailure) {
     final List<RelDataType> argTypes =
         SqlTypeUtil.deriveType(callBinding, callBinding.operands());
-    if (argTypes.size() == 0) {
+    if (argTypes.isEmpty()) {
       throw callBinding.newValidationError(RESOURCE.requireAtLeastOneArg());
     }
     final RelDataType componentType =

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
Patch:
@@ -90,7 +90,7 @@ private static void unparseCube(SqlWriter writer, SqlCall call) {
         }
         writer.endList(frame2);
       } else if (operand instanceof SqlNodeList
-          && ((SqlNodeList) operand).size() == 0) {
+          && ((SqlNodeList) operand).isEmpty()) {
         writer.keyword("()");
       } else {
         operand.unparse(writer, 0, 0);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSpatialTypeFunctions.java
Patch:
@@ -125,7 +125,7 @@ public static class GridTable implements ScannableTable {
     private final Geometry geom;
     private final BigDecimal deltaX;
     private final BigDecimal deltaY;
-    private boolean point;
+    private final boolean point;
 
     GridTable(Geometry geom, BigDecimal deltaX, BigDecimal deltaY,
         boolean point) {

File: core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
Patch:
@@ -206,7 +206,7 @@ public static SqlParserPos sum(final SqlNode[] nodes) {
    * which spans from the beginning of the first to the end of the last.
    */
   public static SqlParserPos sum(final List<? extends SqlNode> nodes) {
-    if (nodes.size() == 0) {
+    if (nodes.isEmpty()) {
       throw new AssertionError();
     }
     SqlParserPos pos0 = nodes.get(0).getParserPosition();
@@ -228,7 +228,7 @@ public static SqlParserPos sum(Iterable<SqlParserPos> poses) {
         poses instanceof List
             ? (List<SqlParserPos>) poses
             : Lists.newArrayList(poses);
-    if (list.size() == 0) {
+    if (list.isEmpty()) {
       throw new AssertionError();
     }
     final SqlParserPos pos0 = list.get(0);

File: core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java
Patch:
@@ -23,10 +23,11 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.nio.charset.Charset;
-import java.util.Objects;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * BasicSqlType represents a standard atomic SQL type (excluding interval
  * types).
@@ -102,7 +103,7 @@ private BasicSqlType(
       @Nullable SqlCollation collation,
       @Nullable SerializableCharset wrappedCharset) {
     super(typeName, nullable, null);
-    this.typeSystem = Objects.requireNonNull(typeSystem, "typeSystem");
+    this.typeSystem = requireNonNull(typeSystem, "typeSystem");
     this.precision = precision;
     this.scale = scale;
     this.collation = collation;

File: core/src/main/java/org/apache/calcite/sql/type/ComparableOperandTypeChecker.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.SqlOperatorBinding;
 import org.apache.calcite.sql.validate.implicit.TypeCoercion;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Type checking strategy which verifies that types have the required attributes
@@ -46,7 +46,7 @@ public ComparableOperandTypeChecker(int nOperands,
       RelDataTypeComparability requiredComparability, Consistency consistency) {
     super(nOperands);
     this.requiredComparability = requiredComparability;
-    this.consistency = Objects.requireNonNull(consistency, "consistency");
+    this.consistency = requireNonNull(consistency, "consistency");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/ExplicitOperandTypeChecker.java
Patch:
@@ -24,7 +24,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 
 import static java.util.Objects.requireNonNull;
 
@@ -37,7 +36,7 @@ public class ExplicitOperandTypeChecker implements SqlOperandTypeChecker {
   private final RelDataType type;
 
   public ExplicitOperandTypeChecker(RelDataType type) {
-    this.type = Objects.requireNonNull(type, "type");
+    this.type = requireNonNull(type, "type");
   }
 
   @Override public boolean checkOperandTypes(

File: core/src/main/java/org/apache/calcite/sql/type/ExplicitReturnTypeInference.java
Patch:
@@ -21,6 +21,8 @@
 import org.apache.calcite.rel.type.RelProtoDataType;
 import org.apache.calcite.sql.SqlOperatorBinding;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A {@link SqlReturnTypeInference} which always returns the same SQL type.
  */
@@ -45,8 +47,7 @@ public class ExplicitReturnTypeInference implements SqlReturnTypeInference {
    * @param protoType Type object
    */
   protected ExplicitReturnTypeInference(RelProtoDataType protoType) {
-    assert protoType != null;
-    this.protoType = protoType;
+    this.protoType = requireNonNull(protoType, "protoType");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/FunctionSqlType.java
Patch:
@@ -21,7 +21,7 @@
 import org.apache.calcite.rel.type.RelDataTypeFamily;
 import org.apache.calcite.rel.type.RelDataTypeField;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Function type.
@@ -34,8 +34,8 @@ public class FunctionSqlType extends AbstractSqlType {
   public FunctionSqlType(
       RelDataType parameterType, RelDataType returnType) {
     super(SqlTypeName.FUNCTION, true, null);
-    this.parameterType = Objects.requireNonNull(parameterType, "parameterType");
-    this.returnType = Objects.requireNonNull(returnType, "returnType");
+    this.parameterType = requireNonNull(parameterType, "parameterType");
+    this.returnType = requireNonNull(returnType, "returnType");
     computeDigest();
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
Patch:
@@ -617,7 +617,7 @@ public static SqlOperandTypeChecker variadic(
             SqlTypeFamily family =
                 cast != null ? SqlTypeFamily.STRING
                     : operandType.getSqlTypeName().getFamily();
-            assert family != null;
+            requireNonNull(family, "family");
             builder.add(family);
           }
           ImmutableList<SqlTypeFamily> families = builder.build();

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
Patch:
@@ -23,9 +23,10 @@
 
 import java.util.HashSet;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Rules that determine whether a type is castable from another type.
  *
@@ -357,7 +358,7 @@ private SqlTypeCoercionRule(Map<SqlTypeName, ImmutableSet<SqlTypeName>> map) {
 
   /** Returns an instance. */
   public static SqlTypeCoercionRule instance() {
-    return Objects.requireNonNull(THREAD_PROVIDERS.get(), "threadProviders");
+    return requireNonNull(THREAD_PROVIDERS.get(), "threadProviders");
   }
 
   /** Returns an instance that allows more lenient type coercion. */

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransformCascade.java
Patch:
@@ -23,10 +23,10 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
-
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Strategy to infer the type of an operator call from the type of the operands
  * by using one {@link SqlReturnTypeInference} rule and a combination of
@@ -48,7 +48,7 @@ public SqlTypeTransformCascade(
       SqlReturnTypeInference rule,
       SqlTypeTransform... transforms) {
     checkArgument(transforms.length > 0);
-    this.rule = Objects.requireNonNull(rule, "rule");
+    this.rule = requireNonNull(rule, "rule");
     this.transforms = ImmutableList.copyOf(transforms);
   }
 

File: core/src/main/java/org/apache/calcite/sql/util/SqlShuttle.java
Patch:
@@ -100,7 +100,7 @@ public class SqlShuttle extends SqlBasicVisitor<@Nullable SqlNode> {
    */
   protected class CallCopyingArgHandler implements ArgHandler<@Nullable SqlNode> {
     boolean update;
-    @Nullable SqlNode[] clonedOperands;
+    final @Nullable SqlNode[] clonedOperands;
     private final SqlCall call;
     private final boolean alwaysCopy;
 

File: core/src/main/java/org/apache/calcite/sql/validate/FieldNamespace.java
Patch:
@@ -44,8 +44,7 @@ class FieldNamespace extends AbstractNamespace {
       SqlValidatorImpl validator,
       RelDataType dataType) {
     super(validator, null);
-    assert dataType != null;
-    this.rowType = dataType;
+    this.rowType = requireNonNull(dataType, "dataType");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -251,7 +251,9 @@ public SqlIdentifier getId() {
   }
 
   @Override public SqlValidatorNamespace resolve() {
-    assert resolvedNamespace != null : "must call validate first";
+    if (resolvedNamespace == null) {
+      throw new IllegalStateException("must call validate first");
+    }
     return resolvedNamespace.resolve();
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
Patch:
@@ -158,7 +158,7 @@ public class SelectScope extends ListScope {
 
     // TODO: compare fully qualified names
     final SqlNodeList orderList = getOrderList();
-    if (orderList.size() > 0) {
+    if (!orderList.isEmpty()) {
       SqlNode order0 = orderList.get(0);
       monotonicity = SqlMonotonicity.INCREASING;
       if ((order0 instanceof SqlCall)
@@ -183,7 +183,7 @@ public class SelectScope extends ListScope {
         final SqlValidatorNamespace child = children.get(0).namespace;
         final List<Pair<SqlNode, SqlMonotonicity>> monotonicExprs =
             child.getMonotonicExprs();
-        if (monotonicExprs.size() > 0) {
+        if (!monotonicExprs.isEmpty()) {
           orderList.add(monotonicExprs.get(0).left);
         }
       }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java
Patch:
@@ -19,7 +19,8 @@
 import org.apache.calcite.sql.SqlIdentifier;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * An implementation of {@link SqlMoniker} that encapsulates the normalized name
@@ -36,7 +37,7 @@ public class SqlIdentifierMoniker implements SqlMoniker {
    * Creates an SqlIdentifierMoniker.
    */
   public SqlIdentifierMoniker(SqlIdentifier id) {
-    this.id = Objects.requireNonNull(id, "id");
+    this.id = requireNonNull(id, "id");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/validate/SqlMonikerImpl.java
Patch:
@@ -27,6 +27,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A generic implementation of {@link SqlMoniker}.
  */
@@ -43,7 +45,7 @@ public class SqlMonikerImpl implements SqlMoniker {
    */
   public SqlMonikerImpl(List<String> names, SqlMonikerType type) {
     this.names = ImmutableList.copyOf(names);
-    this.type = Objects.requireNonNull(type, "type");
+    this.type = requireNonNull(type, "type");
   }
 
   /**

File: core/src/main/java/org/apache/calcite/sql/validate/TableNamespace.java
Patch:
@@ -136,8 +136,8 @@ private RelDataType getBaseRowType() {
             () -> "can't unwrap Table from " + table);
     if (schemaTable instanceof ModifiableViewTable) {
       final Table underlying =
-          ((ModifiableViewTable) schemaTable).unwrap(Table.class);
-      assert underlying != null;
+          requireNonNull(
+              ((ModifiableViewTable) schemaTable).unwrap(Table.class));
       return underlying.getRowType(validator.typeFactory);
     }
     return schemaTable.getRowType(validator.typeFactory);

File: core/src/main/java/org/apache/calcite/sql/validate/TableScope.java
Patch:
@@ -19,7 +19,7 @@
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlSelect;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * The name-resolution scope of a LATERAL TABLE clause.
@@ -40,8 +40,8 @@ class TableScope extends ListScope {
    * @param parent  Parent scope
    */
   TableScope(SqlValidatorScope parent, SqlNode node) {
-    super(Objects.requireNonNull(parent, "parent"));
-    this.node = Objects.requireNonNull(node, "node");
+    super(parent);
+    this.node = requireNonNull(node, "node");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
Patch:
@@ -75,8 +75,8 @@
  * {@link #commonTypeForBinaryComparison} for the detail strategies.
  */
 public abstract class AbstractTypeCoercion implements TypeCoercion {
-  protected SqlValidator validator;
-  protected RelDataTypeFactory factory;
+  protected final SqlValidator validator;
+  protected final RelDataTypeFactory factory;
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
Patch:
@@ -1401,7 +1401,8 @@ private static RelDataType multivalentStringWithSepSumPrecision(
     final RelDataType relDataType =
         typeFactory.getTypeSystem().deriveAvgAggType(typeFactory,
             opBinding.getOperandType(0));
-    if (opBinding.getGroupCount() == 0 || opBinding.hasFilter()) {
+    if (opBinding.getGroupCount() == 0 || opBinding.hasFilter()
+        || opBinding.getOperator().kind == SqlKind.STDDEV_SAMP) {
       return typeFactory.createTypeWithNullability(relDataType, true);
     } else {
       return relDataType;

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -14897,7 +14897,7 @@ void testTimestampDiff(boolean coercionEnabled) {
             false);
     f.checkType("stddev_samp(cast(null as varchar(2)))", "DECIMAL(19, 9)");
     f.checkType("stddev_samp(CAST(NULL AS INTEGER))", "INTEGER");
-    f.checkAggType("stddev_samp(DISTINCT 1.5)", "DECIMAL(2, 1) NOT NULL");
+    f.checkAggType("stddev_samp(DISTINCT 1.5)", "DECIMAL(2, 1)");
     final String[] values = {"0", "CAST(null AS FLOAT)", "3", "3"};
     if (f.brokenTestsEnabled()) {
       // verified on Oracle 10g
@@ -14929,7 +14929,7 @@ void testTimestampDiff(boolean coercionEnabled) {
             false);
     f.checkType("stddev(cast(null as varchar(2)))", "DECIMAL(19, 9)");
     f.checkType("stddev(CAST(NULL AS INTEGER))", "INTEGER");
-    f.checkAggType("stddev(DISTINCT 1.5)", "DECIMAL(2, 1) NOT NULL");
+    f.checkAggType("stddev(DISTINCT 1.5)", "DECIMAL(2, 1)");
     // with one value
     f.checkAgg("stddev(x)", new String[]{"5"}, isNullValue());
     // with zero values

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/UnaryExpression.java
Patch:
@@ -59,12 +59,12 @@ public class UnaryExpression extends Expression {
       if (!writer.requireParentheses(this, lprec, rprec)) {
         // Generate Java code that looks like e.g.,
         // ((Number)org.apache.calcite.linq4j.tree.Primitive.of(int.class)
-        //     .numberValue(literal_value)).intValue();
+        //     .numberValueRoundDown(literal_value)).intValue();
         writer.append("((Number)")
             .append("org.apache.calcite.linq4j.tree.Primitive.of(")
             .append(type)
             .append(".class)")
-            .append(".numberValue(");
+            .append(".numberValueRoundDown(");
         expression.accept(writer, nodeType.rprec, rprec);
         writer.append(")).").append(type).append("Value()");
       }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -401,7 +401,7 @@ private static void sampleOfTheGeneratedWindowedAggregate() {
       }
 
       Expression lowerBoundCanChange =
-          group.lowerBound.isUnbounded() && group.lowerBound.isPreceding()
+          group.lowerBound.isUnboundedPreceding()
           ? Expressions.constant(false)
           : Expressions.notEqual(startX, prevStart);
 

File: core/src/test/java/org/apache/calcite/rex/RexProgramTest.java
Patch:
@@ -3616,12 +3616,12 @@ private void checkSarg(String message, Sarg sarg,
     final RelDataType bigintType = typeFactory.createSqlType(SqlTypeName.BIGINT);
     final RexCall countCall =
         new RexCall(bigintType, SqlStdOperatorTable.COUNT, ImmutableList.of());
-    checkSimplify(m2v(v2m(countCall)), "COUNT() OVER ()");
+    checkSimplify(m2v(v2m(countCall)), "COUNT() OVER (ROWS CURRENT ROW)");
     // "m2v(v2m(sum($0))" -> "sum($0) over (rows current row)"
     final RexInputRef i0 = rexBuilder.makeInputRef(bigintType, 0);
     final RexCall sumCall =
         new RexCall(bigintType, SqlStdOperatorTable.SUM, ImmutableList.of(i0));
-    checkSimplify(m2v(v2m(sumCall)), "SUM($0) OVER ()");
+    checkSimplify(m2v(v2m(sumCall)), "SUM($0) OVER (ROWS CURRENT ROW)");
   }
 
   @Test void testSimplifyUnaryMinus() {

File: piglet/src/test/java/org/apache/calcite/test/PigRelOpTest.java
Patch:
@@ -1667,8 +1667,7 @@ private Fluent pig(String script) {
         + "    LogicalTableScan(table=[[emp1]])\n";
 
     final String sql = "SELECT w0$o0 AS rank_A, id, name, age, city\n"
-        + "FROM (SELECT id, name, age, city, RANK() OVER (RANGE BETWEEN "
-        + "UNBOUNDED PRECEDING AND CURRENT ROW)\n"
+        + "FROM (SELECT id, name, age, city, RANK() OVER ()\n"
         + "    FROM emp1) AS t\n"
         + "WHERE w0$o0 > 1";
     pig(script).assertRel(hasTree(plan))

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
Patch:
@@ -297,6 +297,7 @@ default boolean shouldUseDoubleMultiplication(RelDataTypeFactory typeFactory,
         int six = Math.min(6, getMaxNumericScale());
         int d = p1 - s1 + s2;
         int scale = Math.max(six, s1 + p2 + 1);
+        scale = Math.min(scale, getMaxNumericScale());
         int precision = d + scale;
 
   // Rules from
@@ -320,7 +321,7 @@ default boolean shouldUseDoubleMultiplication(RelDataTypeFactory typeFactory,
         //   can't fit into 32 digits.
         int bound = getMaxNumericPrecision() - six;  // This was '32' in the MS documentation
         if (precision <= bound) {
-          scale = Math.min(scale, getMaxNumericScale() - (precision - scale));
+          scale = Math.min(scale, getMaxNumericPrecision() - (precision - scale));
         } else {
           // precision > bound
           scale = Math.min(six, scale);

File: core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java
Patch:
@@ -309,9 +309,9 @@ private static ImmutableList<RelDataType> combine(
     expr("'12.3'/cast(5 as double)")
         .columnType("DOUBLE NOT NULL");
     expr("'12.3'/5.1")
-        .columnType("DECIMAL(19, 8) NOT NULL");
+        .columnType("DECIMAL(19, 6) NOT NULL");
     expr("12.3/'5.1'")
-        .columnType("DECIMAL(19, 8) NOT NULL");
+        .columnType("DECIMAL(19, 6) NOT NULL");
     // test binary arithmetic with two strings.
     expr("'12.3' + '5'")
         .columnType("DECIMAL(19, 9) NOT NULL");
@@ -320,7 +320,7 @@ private static ImmutableList<RelDataType> combine(
     expr("'12.3' * '5'")
         .columnType("DECIMAL(19, 18) NOT NULL");
     expr("'12.3' / '5'")
-        .columnType("DECIMAL(19, 0) NOT NULL");
+        .columnType("DECIMAL(19, 6) NOT NULL");
   }
 
   /** Test cases for binary comparison expressions. */

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java
Patch:
@@ -5393,7 +5393,8 @@ private void checkLiteral2(String expression, String expected) {
    * is greater than maximum numeric scale</a>. */
   @Test void testNumericScaleMod() {
     final String sql = "SELECT MOD(CAST(2 AS DECIMAL(39, 20)), 2)";
-    final String expected = "SELECT MOD(2, 2)\nFROM (VALUES (0)) AS \"t\" (\"ZERO\")";
+    final String expected =
+        "SELECT MOD(2.00000000000000000000, 2)\nFROM (VALUES (0)) AS \"t\" (\"ZERO\")";
     sql(sql).withPostgresqlModifiedDecimalTypeSystem()
         .ok(expected);
   }

File: core/src/test/java/org/apache/calcite/rex/RexProgramTest.java
Patch:
@@ -3851,7 +3851,7 @@ private SqlSpecialOperatorWithPolicy(String name, SqlKind kind, int prec, boolea
     checkSimplify(div(a, one), "?0.notNullInt1");
     checkSimplify(div(a, nullInt), "null:INTEGER");
 
-    checkSimplifyUnchanged(add(b, half));
+    checkSimplify(add(b, half), "?0.notNullDecimal2");
 
     checkSimplify(add(zero, sub(nullInt, nullInt)), "null:INTEGER");
   }
@@ -3863,5 +3863,4 @@ private SqlSpecialOperatorWithPolicy(String name, SqlKind kind, int prec, boolea
     RexNode cast = rexBuilder.makeCast(nullableDateType, dateStr);
     checkSimplify(cast, "2020-10-30");
   }
-
 }

File: core/src/test/java/org/apache/calcite/test/InterpreterTest.java
Patch:
@@ -579,7 +579,7 @@ private static void assertRows(Interpreter interpreter,
     final String sql = "select x, min(y), max(y), sum(y), avg(y)\n"
         + "from (values ('a', -1.2), ('a', 2.3), ('a', 15)) as t(x, y)\n"
         + "group by x";
-    sql(sql).returnsRows("[a, -1.2, 15.0, 16.1, 5.366666666666667]");
+    sql(sql).returnsRows("[a, -1.2, 15.0, 16.1, 5.3]");
   }
 
   @Test void testInterpretUnnest() {

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -8349,7 +8349,7 @@ private void checkGetTimestamp(Connection con) throws SQLException {
   @Test void testIntAndBigDecimalInArray() {
     CalciteAssert.that()
         .query("select array[1, 1.1]")
-        .returns("EXPR$0=[1, 1.1]\n");
+        .returns("EXPR$0=[1.0, 1.1]\n");
   }
 
   /** Test case for

File: innodb/src/test/java/org/apache/calcite/adapter/innodb/InnodbAdapterTest.java
Patch:
@@ -913,7 +913,7 @@ public class InnodbAdapterTest {
     sql("SELECT * FROM \"EMP\" WHERE DEPTNO = 30 AND SAL = 1250 AND COMM = 500.00")
         .explainContains("PLAN=InnodbToEnumerableConverter\n"
             + "  InnodbFilter(condition=[(SK_POINT_QUERY, index=DEPTNO_SAL_COMM_KEY, "
-            + "DEPTNO=30,SAL=1250,COMM=500.00)])\n"
+            + "DEPTNO=30,SAL=1250.00,COMM=500.00)])\n"
             + "    InnodbTableScan(table=[[test, EMP]])\n")
         .returns(some(7521));
   }
@@ -923,7 +923,7 @@ public class InnodbAdapterTest {
         .explainContains("PLAN=InnodbToEnumerableConverter\n"
             + "  InnodbProject(EMPNO=[$0], ENAME=[$1])\n"
             + "    InnodbFilter(condition=[(SK_POINT_QUERY, index=DEPTNO_SAL_COMM_KEY, "
-            + "DEPTNO=30,SAL=1250,COMM=500.00)])\n"
+            + "DEPTNO=30,SAL=1250.00,COMM=500.00)])\n"
             + "      InnodbTableScan(table=[[test, EMP]])")
         .returns("EMPNO=7521; ENAME=WARD\n");
   }

File: core/src/main/java/org/apache/calcite/sql/SqlNumericLiteral.java
Patch:
@@ -103,7 +103,7 @@ public boolean isExact() {
           BigDecimal bd = getValueNonNull();
           SqlTypeName result;
           // Will throw if the number cannot be represented as a long.
-          long l = bd.longValue();
+          long l = bd.longValueExact();
           if ((l >= Integer.MIN_VALUE) && (l <= Integer.MAX_VALUE)) {
             result = SqlTypeName.INTEGER;
           } else {
@@ -115,7 +115,6 @@ public boolean isExact() {
           // Fallback to DECIMAL.
         }
       }
-
       // else we have a decimal
       return typeFactory.createSqlType(
           SqlTypeName.DECIMAL,

File: core/src/main/java/org/apache/calcite/sql/SqlJoin.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class SqlJoin extends SqlCall {
   static final SqlJoinOperator COMMA_OPERATOR =
-      new SqlJoinOperator("COMMA-JOIN", 16);
+      new SqlJoinOperator("COMMA-JOIN", 18);
   public static final SqlJoinOperator OPERATOR =
       new SqlJoinOperator("JOIN", 18);
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -320,6 +320,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
   public static final SqlBasicFunction RAND = SqlBasicFunction
       .create("RAND", ReturnTypes.DOUBLE,
           OperandTypes.NILADIC.or(OperandTypes.NUMERIC), SqlFunctionCategory.NUMERIC)
+      .withDeterministic(false)
       .withDynamic(true);
 
   /**

File: core/src/main/java/org/apache/calcite/sql/fun/SqlOverlayFunction.java
Patch:
@@ -74,7 +74,7 @@ public SqlOverlayFunction() {
     case 4:
       return "{0}({1} PLACING {2} FROM {3} FOR {4})";
     default:
-      throw new IllegalArgumentException("operandsCount shuld be 3 or 4, got " + operandsCount);
+      throw new IllegalArgumentException("operandsCount should be 3 or 4, got " + operandsCount);
     }
   }
 }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableProjectRule.java
Patch:
@@ -22,6 +22,7 @@
 import org.apache.calcite.rel.convert.ConverterRule;
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.logical.LogicalProject;
+import org.apache.calcite.rex.RexUtil;
 
 /**
  * Rule to convert a {@link LogicalProject} to an {@link EnumerableProject}.
@@ -33,7 +34,8 @@ class EnumerableProjectRule extends ConverterRule {
   /** Default configuration. */
   static final Config DEFAULT_CONFIG = Config.INSTANCE
       .as(Config.class)
-      .withConversion(LogicalProject.class, p -> !p.containsOver(),
+      .withConversion(LogicalProject.class,
+          p -> !p.containsOver() && !RexUtil.M2V_FINDER.inProject(p),
           Convention.NONE, EnumerableConvention.INSTANCE,
           "EnumerableProjectRule")
       .withRuleFactory(EnumerableProjectRule::new);

File: core/src/main/java/org/apache/calcite/rel/core/Calc.java
Patch:
@@ -153,6 +153,9 @@ public final boolean containsOver() {
     if (!program.isNormalized(litmus, getCluster().getRexBuilder())) {
       return litmus.fail(null);
     }
+    if (RexUtil.M2V_FINDER.inProgram(program)) {
+      return litmus.fail("program contains M2V");
+    }
     return litmus.succeed();
   }
 

File: core/src/main/java/org/apache/calcite/rel/metadata/DefaultRelMetadataProvider.java
Patch:
@@ -56,6 +56,7 @@ protected DefaultRelMetadataProvider() {
             RelMdParallelism.SOURCE,
             RelMdDistribution.SOURCE,
             RelMdLowerBoundCost.SOURCE,
+            RelMdMeasure.SOURCE,
             RelMdMemory.SOURCE,
             RelMdDistinctRowCount.SOURCE,
             RelMdSelectivity.SOURCE,

File: core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
Patch:
@@ -135,7 +135,9 @@ private static class VariableCollector extends RexVisitorImpl<Void> {
     @Override public Void visitCall(RexCall call) {
       switch (call.getKind()) {
       case CAST:
+      case M2V:
       case OTHER_FUNCTION:
+      case V2M:
         ++unsupportedCount;
         return null;
       default:

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransforms.java
Patch:
@@ -254,7 +254,7 @@ private SqlTypeName toVar(RelDataType type) {
    * {@code T} for some type T. Inverse of {@link #TO_MEASURE}. */
   public static final SqlTypeTransform FROM_MEASURE =
       (opBinding, typeToTransform) ->
-          ((MeasureSqlType) typeToTransform).types.get(0);
+          SqlTypeUtil.fromMeasure(opBinding.getTypeFactory(), typeToTransform);
 
   /** Parameter type-inference transform that transforms {@code MEASURE<T>} to
    * {@code T} for some type T, and does nothing to other types. */

File: core/src/main/java/org/apache/calcite/sql/validate/SelectNamespace.java
Patch:
@@ -53,6 +53,7 @@ public SelectNamespace(
 
   //~ Methods ----------------------------------------------------------------
 
+  // implement SqlValidatorNamespace, overriding return type
   @Override public SqlSelect getNode() {
     return select;
   }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
Patch:
@@ -25,7 +25,6 @@
 import org.apache.calcite.sql.SqlNodeList;
 import org.apache.calcite.sql.SqlSelect;
 import org.apache.calcite.sql.SqlWindow;
-import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
@@ -140,7 +139,7 @@ default boolean isMeasureRef(SqlNode node) {
               && SqlValidatorUtil.isMeasure(select.getSelectList().get(f.getIndex()));
         }
         return f != null
-            && f.getType().getSqlTypeName() == SqlTypeName.MEASURE;
+            && f.getType().isMeasure();
       }
     }
     return false;

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -584,8 +584,6 @@ protected RexNode removeCorrelationExpr(
       }
     }
 
-    assert newPos == newInputOutput.size();
-
     // This Project will be what the old input maps to,
     // replacing any previous mapping from old input).
     RelNode newProject = relBuilder.push(newInput)

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -1045,9 +1045,9 @@ private RexNode flattenComparison(
       }
       RexNode conjunction = null;
       for (int i = 0; i < n; ++i) {
-        final List<RexNode> leftList = flattenedExps.leftList();
         RexNode comparison =
-            rexBuilder.makeCall(op, leftList.get(i), leftList.get(i + n));
+            rexBuilder.makeCall(op, flattenedExps.left(i),
+                flattenedExps.left(i + n));
         if (conjunction == null) {
           conjunction = comparison;
         } else {

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -64,6 +64,7 @@
 import org.apache.calcite.rel.metadata.BuiltInMetadata.ExpressionLineage;
 import org.apache.calcite.rel.metadata.BuiltInMetadata.LowerBoundCost;
 import org.apache.calcite.rel.metadata.BuiltInMetadata.MaxRowCount;
+import org.apache.calcite.rel.metadata.BuiltInMetadata.Measure;
 import org.apache.calcite.rel.metadata.BuiltInMetadata.Memory;
 import org.apache.calcite.rel.metadata.BuiltInMetadata.MinRowCount;
 import org.apache.calcite.rel.metadata.BuiltInMetadata.NodeTypes;
@@ -827,6 +828,8 @@ public enum BuiltInMethod {
   CUMULATIVE_MEMORY_WITHIN_PHASE(Memory.class, "cumulativeMemoryWithinPhase"),
   CUMULATIVE_MEMORY_WITHIN_PHASE_SPLIT(Memory.class,
       "cumulativeMemoryWithinPhaseSplit"),
+  IS_MEASURE(Measure.class, "isMeasure", int.class),
+  MEASURE_EXPAND(Measure.class, "expand", int.class, Measure.Context.class),
   COLUMN_UNIQUENESS(ColumnUniqueness.class, "areColumnsUnique",
       ImmutableBitSet.class, boolean.class),
   COLLATIONS(Collation.class, "collations"),

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -37,6 +37,7 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.parallel.Execution;
 import org.junit.jupiter.api.parallel.ExecutionMode;
@@ -614,6 +615,7 @@ public static Connection makeConnectionWithMeasures() throws Exception {
     assertThat(count, is(101));
   }
 
+  @Disabled("Cannot yet execute query with virtual measures")
   @Test void testLocalStatementResultSetMeasureMetadata() throws Exception {
     Connection conn = makeConnectionWithMeasures();
     String sql = "select * from \"foo\".\"bar\"";

File: core/src/test/java/org/apache/calcite/test/CoreQuidemTest.java
Patch:
@@ -65,6 +65,7 @@ public static void main(String[] args) throws Exception {
           return CalciteAssert.that()
               .with(CalciteConnectionProperty.PARSER_FACTORY,
                   ExtensionDdlExecutor.class.getName() + "#PARSER_FACTORY")
+              .with(CalciteConnectionProperty.FUN, SqlLibrary.CALCITE.fun)
               .with(CalciteAssert.Config.SCOTT)
               .connect();
         case "scott-lenient":

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -98,7 +98,8 @@ private SqlLibraryOperators() {
   @LibraryOperator(libraries = {CALCITE})
   public static final SqlFunction AGGREGATE =
       SqlBasicAggFunction.create("AGGREGATE", SqlKind.AGGREGATE_FN,
-          ReturnTypes.ARG0, OperandTypes.MEASURE);
+          ReturnTypes.ARG0.andThen(SqlTypeTransforms.FROM_MEASURE),
+          OperandTypes.MEASURE);
 
   /** The "CONVERT_TIMEZONE(tz1, tz2, datetime)" function;
    * converts the timezone of {@code datetime} from {@code tz1} to {@code tz2}.

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -442,6 +442,9 @@ public enum SqlKind {
   /** The {@code CONCAT_WS} function (MSSQL). */
   CONCAT_WS_MSSQL,
 
+  /** The {@code CONCAT_WS} function (Postgresql). */
+  CONCAT_WS_POSTGRESQL,
+
 
   /** The {@code CONCAT_WS} function (Spark). */
   CONCAT_WS_SPARK,

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -483,6 +483,8 @@ public enum BuiltInMethod {
       "concatMultiWithSeparator", String[].class),
   MULTI_TYPE_STRING_ARRAY_CONCAT_WITH_SEPARATOR(SqlFunctions.class,
       "concatMultiTypeWithSeparator", String.class, Object[].class),
+  MULTI_TYPE_OBJECT_CONCAT_WITH_SEPARATOR(SqlFunctions.class,
+      "concatMultiObjectWithSeparator", String.class, Object[].class),
   FLOOR_DIV(Math.class, "floorDiv", long.class, long.class),
   FLOOR_MOD(Math.class, "floorMod", long.class, long.class),
   ADD_MONTHS(DateTimeUtils.class, "addMonths", long.class, int.class),

File: druid/src/test/java/org/apache/calcite/test/DruidAdapter2IT.java
Patch:
@@ -1030,7 +1030,7 @@ private void checkGroupBySingleSortLimit(boolean approx) {
         + "intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], "
         + "filter=[AND("
         + "=($3, 'High Top Dried Mushrooms'), "
-        + "SEARCH($87, Sarg['Q2', 'Q3']:CHAR(2)), "
+        + "SEARCH($87, Sarg['Q2':VARCHAR, 'Q3':VARCHAR]:VARCHAR), "
         + "=($30, 'WA'))], "
         + "projects=[[$30, $29, $3]], groups=[{0, 1, 2}], aggs=[[]])\n";
     sql(sql)
@@ -1072,7 +1072,7 @@ private void checkGroupBySingleSortLimit(boolean approx) {
         + "intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], "
         + "filter=[AND("
         + "=($3, 'High Top Dried Mushrooms'), "
-        + "SEARCH($87, Sarg['Q2', 'Q3']:CHAR(2)), "
+        + "SEARCH($87, Sarg['Q2':VARCHAR, 'Q3':VARCHAR]:VARCHAR), "
         + "=($30, 'WA'))], "
         + "projects=[[$30, $29, $3]])\n";
     sql(sql)

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java
Patch:
@@ -1305,7 +1305,7 @@ private void checkGroupBySingleSortLimit(boolean approx) {
         + "intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], "
         + "filter=[AND("
         + "=($3, 'High Top Dried Mushrooms'), "
-        + "SEARCH($87, Sarg['Q2', 'Q3']:CHAR(2)), "
+        + "SEARCH($87, Sarg['Q2':VARCHAR, 'Q3':VARCHAR]:VARCHAR), "
         + "=($30, 'WA'))], "
         + "projects=[[$30, $29, $3]], groups=[{0, 1, 2}], aggs=[[]])\n";
     sql(sql)
@@ -1347,7 +1347,7 @@ private void checkGroupBySingleSortLimit(boolean approx) {
         + "intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], "
         + "filter=[AND("
         + "=($3, 'High Top Dried Mushrooms'), "
-        + "SEARCH($87, Sarg['Q2', 'Q3']:CHAR(2)), "
+        + "SEARCH($87, Sarg['Q2':VARCHAR, 'Q3':VARCHAR]:VARCHAR), "
         + "=($30, 'WA'))], "
         + "projects=[[$30, $29, $3]])\n";
     sql(sql)

File: babel/src/test/java/org/apache/calcite/test/BabelQuidemTest.java
Patch:
@@ -107,7 +107,7 @@ public static void main(String[] args) throws Exception {
         case "scott-redshift":
           return CalciteAssert.that()
               .with(CalciteAssert.Config.SCOTT)
-              .with(CalciteConnectionProperty.FUN, "standard,postgresql,oracle")
+              .with(CalciteConnectionProperty.FUN, "standard,redshift")
               .with(CalciteConnectionProperty.PARSER_FACTORY,
                   SqlBabelParserImpl.class.getName() + "#FACTORY")
               .with(CalciteConnectionProperty.CONFORMANCE,

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -666,6 +666,7 @@ private boolean expandStar(List<SqlNode> selectItems, Set<String> aliases,
     if (!identifier.isStar()) {
       return false;
     }
+    final int originalSize = selectItems.size();
     final SqlParserPos startPosition = identifier.getParserPosition();
     switch (identifier.names.size()) {
     case 1:
@@ -736,7 +737,7 @@ private boolean expandStar(List<SqlNode> selectItems, Set<String> aliases,
       if (!hasDynamicStruct || Bug.CALCITE_2400_FIXED) {
         // If some fields before star identifier,
         // we should move offset.
-        int offset = calculatePermuteOffset(selectItems);
+        int offset = Math.min(calculatePermuteOffset(selectItems), originalSize);
         new Permute(from, offset).permute(selectItems, fields);
       }
       return true;

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -48,7 +48,7 @@
 import org.apache.calcite.util.format.FormatElement;
 import org.apache.calcite.util.format.FormatModel;
 import org.apache.calcite.util.format.FormatModels;
-import org.apache.calcite.util.format.PostgresqlDateTimeFormatter;
+import org.apache.calcite.util.format.postgresql.PostgresqlDateTimeFormatter;
 
 import org.apache.commons.codec.DecoderException;
 import org.apache.commons.codec.binary.Base32;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -279,6 +279,7 @@
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_BASE32;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_BASE64;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_CHAR;
+import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_CHAR_PG;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_CODE_POINTS;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_DATE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_HEX;
@@ -787,6 +788,7 @@ Builder populate2() {
 
       // Datetime formatting methods
       defineReflective(TO_CHAR, BuiltInMethod.TO_CHAR.method);
+      defineReflective(TO_CHAR_PG, BuiltInMethod.TO_CHAR_PG.method);
       defineReflective(TO_DATE, BuiltInMethod.TO_DATE.method);
       defineReflective(TO_TIMESTAMP, BuiltInMethod.TO_TIMESTAMP.method);
       final FormatDatetimeImplementor datetimeFormatImpl =

File: core/src/main/java/org/apache/calcite/sql/SqlBasicFunction.java
Patch:
@@ -67,7 +67,7 @@ public class SqlBasicFunction extends SqlFunction {
    * @param category Categorization for function
    * @param monotonicityInference Strategy to infer monotonicity of a call
    */
-  private SqlBasicFunction(String name, SqlKind kind, SqlSyntax syntax,
+  protected SqlBasicFunction(String name, SqlKind kind, SqlSyntax syntax,
       boolean deterministic, SqlReturnTypeInference returnTypeInference,
       @Nullable SqlOperandTypeInference operandTypeInference,
       SqlOperandHandler operandHandler,

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -652,6 +652,8 @@ public enum BuiltInMethod {
       String.class, long.class),
   TO_CHAR(SqlFunctions.DateFormatFunction.class, "toChar", long.class,
       String.class),
+  TO_CHAR_PG(SqlFunctions.DateFormatFunction.class, "toCharPg", long.class,
+      String.class),
   TO_DATE(SqlFunctions.DateFormatFunction.class, "toDate", String.class,
       String.class),
   TO_TIMESTAMP(SqlFunctions.DateFormatFunction.class, "toTimestamp", String.class,

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -941,6 +941,9 @@ ExInst<CalciteException> invalidTypesForComparison(String clazzName0, String op,
   @BaseMessage("Invalid character for cast: {0}")
   ExInst<CalciteException> invalidCharacterForCast(String s);
 
+  @BaseMessage("UNNEST argument must be a collection")
+  ExInst<CalciteException> unnestArgument();
+
   @BaseMessage("More than one value in list: {0}")
   ExInst<CalciteException> moreThanOneValueInList(String list);
 

File: core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
Patch:
@@ -37,7 +37,9 @@
 import static java.util.Objects.requireNonNull;
 
 /**
- * Parameter type-checking strategy where all operand types must be the same.
+ * Parameter type-checking strategy where the type of operand I must
+ * be <b>comparable</b> with the type of operand I-1, for all legal values of I.
+ * See {@link SqlTypeUtil#isComparable} for a definition of "comparable" types.
  */
 public class SameOperandTypeChecker implements SqlSingleOperandTypeChecker {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -1467,6 +1467,8 @@ public static boolean isFlat(RelDataType type) {
   /**
    * Returns whether two types are comparable. They need to be scalar types of
    * the same family, or struct types whose fields are pairwise comparable.
+   * Note that types in the CHARACTER family are comparable with many other types
+   * (see {@link #canConvertStringInCompare}).
    *
    * @param type1 First type
    * @param type2 Second type

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
Patch:
@@ -354,6 +354,9 @@ public static Expression convert(Expression operand, Type fromType,
     if (!Types.needTypeCast(fromType, toType)) {
       return operand;
     }
+
+    // TODO use Expressions#convertChecked to throw exception in case of overflow (CALCITE-6366)
+
     // E.g. from "Short" to "int".
     // Generate "x.intValue()".
     final Primitive toPrimitive = Primitive.of(toType);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -601,7 +601,7 @@ Builder populate() {
       defineReflective(PARSE_URL, BuiltInMethod.PARSE_URL2.method,
           BuiltInMethod.PARSE_URL3.method);
       defineReflective(REGEXP, BuiltInMethod.RLIKE.method);
-      defineReflective(REGEXP_LIKE, BuiltInMethod.RLIKE.method);
+      defineReflective(REGEXP_LIKE, BuiltInMethod.RLIKE.method, BuiltInMethod.REGEXP_LIKE3.method);
       defineReflective(REGEXP_CONTAINS, BuiltInMethod.REGEXP_CONTAINS.method);
       defineReflective(REGEXP_EXTRACT, BuiltInMethod.REGEXP_EXTRACT2.method,
           BuiltInMethod.REGEXP_EXTRACT3.method, BuiltInMethod.REGEXP_EXTRACT4.method);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -557,10 +557,10 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding,
           SqlFunctionCategory.STRING);
 
   /** The "REGEXP_LIKE(value, regexp)" function, equivalent to {@link #RLIKE}. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = {SPARK, MYSQL, POSTGRESQL, ORACLE})
   public static final SqlFunction REGEXP_LIKE =
       SqlBasicFunction.create("REGEXP_LIKE", ReturnTypes.BOOLEAN_NULLABLE,
-          OperandTypes.STRING_STRING,
+          OperandTypes.STRING_STRING_OPTIONAL_STRING,
           SqlFunctionCategory.STRING);
 
   @LibraryOperator(libraries = {MYSQL})

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -563,6 +563,8 @@ public enum BuiltInMethod {
       String.class, String.class, int.class, int.class),
   REGEXP_INSTR5(SqlFunctions.RegexFunction.class, "regexpInstr",
       String.class, String.class, int.class, int.class, int.class),
+  REGEXP_LIKE3(SqlFunctions.RegexFunction.class, "regexpLike",
+      String.class, String.class, String.class),
   REGEXP_REPLACE3(SqlFunctions.RegexFunction.class, "regexpReplace",
       String.class, String.class, String.class),
   REGEXP_REPLACE4(SqlFunctions.RegexFunction.class, "regexpReplace",

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -191,7 +191,7 @@ public int operandCount() {
    * Returns a string describing the actual argument types of a call, e.g.
    * "SUBSTR(VARCHAR(12), NUMBER(3,2), INTEGER)".
    */
-  protected String getCallSignature(
+  public String getCallSignature(
       SqlValidator validator,
       @Nullable SqlValidatorScope scope) {
     List<String> signatureList = new ArrayList<>();

File: core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
Patch:
@@ -1100,7 +1100,8 @@ public static SqlSingleOperandTypeChecker same(int operandCount,
       family(SqlTypeFamily.DATETIME_INTERVAL, SqlTypeFamily.DATETIME);
 
   public static final SqlSingleOperandTypeChecker INTERVALINTERVAL_INTERVALDATETIME =
-      INTERVAL_SAME_SAME.or(INTERVAL_DATETIME);
+      INTERVAL_SAME_SAME.or(INTERVAL_DATETIME)
+          .or(family(SqlTypeFamily.INTERVAL_DAY_TIME, SqlTypeFamily.INTERVAL_YEAR_MONTH));
 
   // TODO: datetime+interval checking missing
   // TODO: interval+datetime checking missing

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1869,7 +1869,7 @@ protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
     }
     final SqlNode original = originalExprs.get(node);
     if (original != null && original != node) {
-      return getValidatedNodeType(original);
+      return getValidatedNodeTypeIfKnown(original);
     }
     if (node instanceof SqlIdentifier) {
       return getCatalogReader().getNamedType((SqlIdentifier) node);

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -7067,9 +7067,8 @@ void testGroupExpressionEquivalenceParams() {
         .columnType("BIGINT NOT NULL");
     expr("extract(minute from interval '1.1' second)").ok();
     expr("extract(year from DATE '2008-2-2')").ok();
+    expr("extract(minute from interval '11' month)").ok();
 
-    wholeExpr("extract(minute from interval '11' month)")
-        .fails("(?s).*Cannot apply.*");
     wholeExpr("extract(year from interval '11' second)")
         .fails("(?s).*Cannot apply.*");
   }

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -632,6 +632,7 @@ public Object toJson(RexNode node) {
         switch (node.getKind()) {
         case MINUS:
         case CAST:
+        case SAFE_CAST:
           map.put("type", toJson(node.getType()));
           break;
         default:

File: core/src/main/java/org/apache/calcite/sql/SqlTimeTzLiteral.java
Patch:
@@ -20,10 +20,10 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimeWithTimeZoneString;
 
-import com.google.common.base.Preconditions;
-
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * A SQL literal representing a TIME WITH TIME ZONE value, for example <code>TIME WITH TIME ZONE
  * '14:33:44.567 GMT+08'</code>.
@@ -36,7 +36,7 @@ public class SqlTimeTzLiteral extends SqlAbstractDateTimeLiteral {
   SqlTimeTzLiteral(TimeWithTimeZoneString t, int precision,
                              SqlParserPos pos) {
     super(t, true, SqlTypeName.TIME_TZ, precision, pos);
-    Preconditions.checkArgument(this.precision >= 0);
+    checkArgument(this.precision >= 0);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlTimestampTzLiteral.java
Patch:
@@ -20,10 +20,10 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimestampWithTimeZoneString;
 
-import com.google.common.base.Preconditions;
-
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * A SQL literal representing a TIMESTAMP WITH TIME ZONE value, for example <code>TIMESTAMP
  * '1969-07-21 03:15 GMT+00:00'</code>.
@@ -35,7 +35,7 @@ public class SqlTimestampTzLiteral extends SqlAbstractDateTimeLiteral {
 
   SqlTimestampTzLiteral(TimestampWithTimeZoneString ts, int precision, SqlParserPos pos) {
     super(ts, false, SqlTypeName.TIMESTAMP_TZ, precision, pos);
-    Preconditions.checkArgument(this.precision >= 0);
+    checkArgument(this.precision >= 0);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -180,13 +180,15 @@ private static Type fieldType(Field field) {
       case DATE:
       case TIME:
       case TIME_WITH_LOCAL_TIME_ZONE:
+      case TIME_TZ:
       case INTEGER:
       case INTERVAL_YEAR:
       case INTERVAL_YEAR_MONTH:
       case INTERVAL_MONTH:
         return type.isNullable() ? Integer.class : int.class;
       case TIMESTAMP:
       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
+      case TIMESTAMP_TZ:
       case BIGINT:
       case INTERVAL_DAY:
       case INTERVAL_DAY_HOUR:

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
Patch:
@@ -775,7 +775,8 @@ private static int find(RelNode rel, int ref) {
       exprsLineage.put(expr, i);
       SqlTypeName sqlTypeName = expr.getType().getSqlTypeName();
       if (sqlTypeName == SqlTypeName.TIMESTAMP
-          || sqlTypeName == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE) {
+          || sqlTypeName == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE
+          || sqlTypeName == SqlTypeName.TIMESTAMP_TZ) {
         timestampExprs.add(expr);
       }
     }

File: core/src/main/java/org/apache/calcite/sql/SqlAbstractDateTimeLiteral.java
Patch:
@@ -56,7 +56,7 @@ protected SqlAbstractDateTimeLiteral(Object d, boolean tz,
   //~ Methods ----------------------------------------------------------------
 
   /** Converts this literal to a {@link TimestampString}. */
-  protected TimestampString getTimestamp() {
+  public TimestampString getTimestamp() {
     return (TimestampString) requireNonNull(value, "value");
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcDataTypeName.java
Patch:
@@ -37,8 +37,10 @@ public enum SqlJdbcDataTypeName implements Symbolizable {
   SQL_DATE(SqlTypeName.DATE),
   SQL_TIME(SqlTypeName.TIME),
   SQL_TIME_WITH_LOCAL_TIME_ZONE(SqlTypeName.TIME_WITH_LOCAL_TIME_ZONE),
+  SQL_TIME_WITH_TIME_ZONE(SqlTypeName.TIME_TZ),
   SQL_TIMESTAMP(SqlTypeName.TIMESTAMP),
   SQL_TIMESTAMP_WITH_LOCAL_TIME_ZONE(SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE),
+  SQL_TIMESTAMP_WITH_TIME_ZONE(SqlTypeName.TIMESTAMP_TZ),
   SQL_DECIMAL(SqlTypeName.DECIMAL),
   SQL_NUMERIC(SqlTypeName.DECIMAL),
   SQL_BOOLEAN(SqlTypeName.BOOLEAN),

File: core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * A SQL literal representing a TIMESTAMP value, for example <code>TIMESTAMP
- * '1969-07-21 03:15 GMT'</code>.
+ * '1969-07-21 03:15'</code>.
  *
  * <p>Create values using {@link SqlLiteral#createTimestamp}.
  */

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -319,7 +319,7 @@ private static ResultSet getTableTypes(Connection connection) {
     CalciteAssert.hr()
         .with(CalciteRemoteDriverTest::getRemoteConnection)
         .metaData(CalciteRemoteDriverTest::getTypeInfo)
-        .returns(CalciteAssert.checkResultCount(is(41)));
+        .returns(CalciteAssert.checkResultCount(is(43)));
   }
 
   @Test void testRemoteTableTypes() {

File: core/src/test/java/org/apache/calcite/sql/type/SqlTypeFactoryTest.java
Patch:
@@ -284,7 +284,9 @@ private void checkPrecision(int p0, int p1, int expectedMax,
     checkCreateSqlTypeWithPrecision(f.typeFactory, SqlTypeName.TIME);
     checkCreateSqlTypeWithPrecision(f.typeFactory, SqlTypeName.TIMESTAMP);
     checkCreateSqlTypeWithPrecision(f.typeFactory, SqlTypeName.TIME_WITH_LOCAL_TIME_ZONE);
+    checkCreateSqlTypeWithPrecision(f.typeFactory, SqlTypeName.TIME_TZ);
     checkCreateSqlTypeWithPrecision(f.typeFactory, SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE);
+    checkCreateSqlTypeWithPrecision(f.typeFactory, SqlTypeName.TIMESTAMP_TZ);
   }
 
   private void checkCreateSqlTypeWithPrecision(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlAbstractTimeFunction.java
Patch:
@@ -69,11 +69,12 @@ protected SqlAbstractTimeFunction(String name, SqlTypeName typeName) {
       }
     }
     assert precision >= 0;
-    if (precision > SqlTypeName.MAX_DATETIME_PRECISION) {
+    final int maxPrecision = opBinding.getTypeFactory().getTypeSystem().getMaxPrecision(typeName);
+    if (precision > maxPrecision) {
       throw opBinding.newError(
           RESOURCE.argumentMustBeValidPrecision(
               opBinding.getOperator().getName(), 0,
-              SqlTypeName.MAX_DATETIME_PRECISION));
+              maxPrecision));
     }
     return opBinding.getTypeFactory().createSqlType(typeName, precision);
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -278,7 +278,7 @@
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_CODE_POINTS;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TO_HEX;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TRANSLATE3;
-import static org.apache.calcite.sql.fun.SqlLibraryOperators.TRUNC;
+import static org.apache.calcite.sql.fun.SqlLibraryOperators.TRUNC_BIG_QUERY;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.TRY_CAST;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.UNIX_DATE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.UNIX_MICROS;
@@ -677,7 +677,7 @@ Builder populate() {
       defineMethod(SINH, BuiltInMethod.SINH.method, NullPolicy.STRICT);
       defineMethod(TAN, BuiltInMethod.TAN.method, NullPolicy.STRICT);
       defineMethod(TANH, BuiltInMethod.TANH.method, NullPolicy.STRICT);
-      defineMethod(TRUNC, BuiltInMethod.STRUNCATE.method, NullPolicy.STRICT);
+      defineMethod(TRUNC_BIG_QUERY, BuiltInMethod.STRUNCATE.method, NullPolicy.STRICT);
       defineMethod(TRUNCATE, BuiltInMethod.STRUNCATE.method, NullPolicy.STRICT);
 
       map.put(SAFE_ADD,

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -1085,6 +1085,9 @@ ExInst<RuntimeException> multipleCapturingGroupsForRegexpFunctions(String value,
   @BaseMessage("A table function at most has one input table with row semantics. Table function ''{0}'' has multiple input tables with row semantics")
   ExInst<SqlValidatorException> multipleRowSemanticsTables(String funcName);
 
+  @BaseMessage("SQL statement did not contain filters on the following fields: {0}")
+  ExInst<SqlValidatorException> mustFilterFieldsMissing(String mustFilterFields);
+
   @BaseMessage("BIT_GET/GETBIT error: negative position {0,number} not allowed")
   ExInst<CalciteException> illegalNegativeBitGetPosition(int position);
 

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -210,6 +210,7 @@ private SqlValidatorNamespace resolveImpl(SqlIdentifier id) {
       }
     }
 
+    this.mustFilterFields = resolvedNamespace.getMustFilterFields();
     RelDataType rowType = resolvedNamespace.getRowType();
 
     if (extendList != null) {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -381,8 +381,7 @@ public static SqlValidatorWithHints newValidator(
       SqlValidatorCatalogReader catalogReader,
       RelDataTypeFactory typeFactory,
       SqlValidator.Config config) {
-    return new SqlValidatorImpl(opTab, catalogReader, typeFactory,
-        config);
+    return new SqlValidatorImpl(opTab, catalogReader, typeFactory, config);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/sql/validate/WithItemNamespace.java
Patch:
@@ -41,6 +41,7 @@ class WithItemNamespace extends AbstractNamespace {
     final SqlValidatorNamespace childNs =
         validator.getNamespaceOrThrow(getQuery());
     final RelDataType rowType = childNs.getRowTypeSansSystemColumns();
+    mustFilterFields = childNs.getMustFilterFields();
     SqlNodeList columnList = withItem.columnList;
     if (columnList == null) {
       return rowType;

File: core/src/main/java/org/apache/calcite/util/format/FormatModels.java
Patch:
@@ -34,6 +34,7 @@
 import static org.apache.calcite.util.format.FormatElementEnum.DD;
 import static org.apache.calcite.util.format.FormatElementEnum.DDD;
 import static org.apache.calcite.util.format.FormatElementEnum.DY;
+import static org.apache.calcite.util.format.FormatElementEnum.E;
 import static org.apache.calcite.util.format.FormatElementEnum.FF1;
 import static org.apache.calcite.util.format.FormatElementEnum.FF2;
 import static org.apache.calcite.util.format.FormatElementEnum.FF3;
@@ -114,7 +115,7 @@ MI, literalElement(":"), SS, literalElement(" "),
     map.put("%E4S", FF4);
     map.put("%E5S", FF5);
     map.put("%E*S", FF6);
-    map.put("%e", DD);
+    map.put("%e", E);
     map.put("%F",
         compositeElement("The date in the format %Y-%m-%d.", YYYY, literalElement("-"), MM,
             literalElement("-"), DD));

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -2103,7 +2103,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
    */
   public static final SqlFunction ELEMENT =
       SqlBasicFunction.create("ELEMENT",
-          ReturnTypes.MULTISET_ELEMENT_NULLABLE,
+          ReturnTypes.MULTISET_ELEMENT_FORCE_NULLABLE,
           OperandTypes.COLLECTION);
 
   /**

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -9816,7 +9816,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
   @Test void testElementFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ELEMENT, VM_FENNEL, VM_JAVA);
-    f.checkString("element(multiset['abc'])", "abc", "CHAR(3) NOT NULL");
+    f.checkString("element(multiset['abc'])", "abc", "CHAR(3)");
     f.checkNull("element(multiset[cast(null as integer)])");
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -1351,7 +1351,7 @@ public enum DatabaseProduct {
     INTERBASE("Interbase", null, NullCollation.HIGH),
     PHOENIX("Phoenix", "\"", NullCollation.HIGH),
     POSTGRESQL("PostgreSQL", "\"", NullCollation.HIGH),
-    PRESTO("Presto", "\"", NullCollation.LOW),
+    PRESTO("Presto", "\"", NullCollation.LAST),
     NETEZZA("Netezza", "\"", NullCollation.HIGH),
     INFOBRIGHT("Infobright", "`", NullCollation.HIGH),
     NEOVIEW("Neoview", null, NullCollation.HIGH),

File: core/src/main/java/org/apache/calcite/sql/dialect/PrestoSqlDialect.java
Patch:
@@ -41,7 +41,7 @@ public class PrestoSqlDialect extends SqlDialect {
       .withDatabaseProduct(DatabaseProduct.PRESTO)
       .withIdentifierQuoteString("\"")
       .withUnquotedCasing(Casing.UNCHANGED)
-      .withNullCollation(NullCollation.LOW);
+      .withNullCollation(NullCollation.LAST);
 
   public static final SqlDialect DEFAULT = new PrestoSqlDialect(DEFAULT_CONTEXT);
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -291,6 +291,7 @@ public enum BuiltInMethod {
   ENUMERABLE_TO_LIST(ExtendedEnumerable.class, "toList"),
   ENUMERABLE_TO_MAP(ExtendedEnumerable.class, "toMap", Function1.class, Function1.class),
   AS_LIST(Primitive.class, "asList", Object.class),
+  INTEGER_CAST(Primitive.class, "integerCast", Primitive.class, Object.class),
   MEMORY_GET0(MemoryFactory.Memory.class, "get"),
   MEMORY_GET1(MemoryFactory.Memory.class, "get", int.class),
   ENUMERATOR_CURRENT(Enumerator.class, "current"),

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -174,6 +174,7 @@
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.DAYNAME;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.DIFFERENCE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.ENDS_WITH;
+import static org.apache.calcite.sql.fun.SqlLibraryOperators.EXISTS;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.EXISTS_NODE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.EXTRACT_VALUE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.EXTRACT_XML;
@@ -839,6 +840,7 @@ Builder populate2() {
       defineMethod(ARRAY_UNION, BuiltInMethod.ARRAY_UNION.method, NullPolicy.ANY);
       defineMethod(ARRAYS_OVERLAP, BuiltInMethod.ARRAYS_OVERLAP.method, NullPolicy.ANY);
       defineMethod(ARRAYS_ZIP, BuiltInMethod.ARRAYS_ZIP.method, NullPolicy.ANY);
+      defineMethod(EXISTS, BuiltInMethod.EXISTS.method, NullPolicy.ANY);
       defineMethod(MAP_CONCAT, BuiltInMethod.MAP_CONCAT.method, NullPolicy.ANY);
       defineMethod(MAP_ENTRIES, BuiltInMethod.MAP_ENTRIES.method, NullPolicy.STRICT);
       defineMethod(MAP_KEYS, BuiltInMethod.MAP_KEYS.method, NullPolicy.STRICT);

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -773,6 +773,7 @@ public enum BuiltInMethod {
   ARRAY_REVERSE(SqlFunctions.class, "reverse", List.class),
   ARRAYS_OVERLAP(SqlFunctions.class, "arraysOverlap", List.class, List.class),
   ARRAYS_ZIP(SqlFunctions.class, "arraysZip", List.class, List.class),
+  EXISTS(SqlFunctions.class, "exists", List.class, Function1.class),
   SORT_ARRAY(SqlFunctions.class, "sortArray", List.class, boolean.class),
   MAP(SqlFunctions.class, "map", Object[].class),
   MAP_CONCAT(SqlFunctions.class, "mapConcat", Map[].class),

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -6696,7 +6696,7 @@ void testGroupExpressionEquivalenceParams() {
     s.withSql("select HIGHER_ORDER_FUNCTION(1, (x, y) -> x + 1)").ok();
     s.withSql("select HIGHER_ORDER_FUNCTION(1, (x, y) -> y)").ok();
     s.withSql("select HIGHER_ORDER_FUNCTION(1, (x, y) -> char_length(x) + 1)").ok();
-    s.withSql("select HIGHER_ORDER_FUNCTION(1, (x, y) -> null)").ok();
+    s.withSql("select HIGHER_ORDER_FUNCTION(1, (x, y) -> cast(null as integer))").ok();
     s.withSql("select HIGHER_ORDER_FUNCTION2(1, () -> 0.1)").ok();
     s.withSql("select emp.deptno, HIGHER_ORDER_FUNCTION(1, (x, deptno) -> deptno) from emp").ok();
     s.withSql("select HIGHER_ORDER_FUNCTION(1, (x, y) -> char_length(x) + 1)")

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
Patch:
@@ -478,8 +478,8 @@ private RelDataType getTightestCommonTypeOrThrow(
     }
 
     if (null != resultType) {
-      resultType = factory.createTypeWithNullability(resultType,
-          type1.isNullable() || type2.isNullable());
+      resultType =
+          factory.createTypeWithNullability(resultType, type1.isNullable() || type2.isNullable());
     }
 
     return resultType;

File: core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java
Patch:
@@ -216,7 +216,7 @@ private static ImmutableList<RelDataType> combine(
     sql("select '1' from (values(true)) union values 2")
         .type("RecordType(VARCHAR NOT NULL EXPR$0) NOT NULL");
     sql("select (select 1+2 from (values true)) tt from (values(true)) union values '2'")
-        .type("RecordType(VARCHAR NOT NULL TT) NOT NULL");
+        .type("RecordType(VARCHAR TT) NOT NULL");
     // union with star
     sql("select * from (values(1, '3')) union select * from (values('2', 4))")
         .type("RecordType(VARCHAR NOT NULL EXPR$0, VARCHAR NOT NULL EXPR$1) NOT NULL");

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -490,7 +490,7 @@ ExInst<SqlValidatorException> intervalFieldExceedsPrecision(Number a0,
   @BaseMessage("QUALIFY expression ''{0}'' must contain a window function")
   ExInst<SqlValidatorException> qualifyExpressionMustContainWindowFunction(String a0);
 
-  @BaseMessage("ROW/RANGE not allowed with RANK, DENSE_RANK or ROW_NUMBER functions")
+  @BaseMessage("ROW/RANGE not allowed with RANK, DENSE_RANK, ROW_NUMBER or PERCENTILE_CONT/DISC functions")
   ExInst<SqlValidatorException> rankWithFrame();
 
   @BaseMessage("RANK or DENSE_RANK functions require ORDER BY clause in window specification")

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -150,7 +150,7 @@ public class SqlValidatorTest extends SqlValidatorTestCase {
       "Set operator cannot combine streaming and non-streaming inputs";
 
   private static final String ROW_RANGE_NOT_ALLOWED_WITH_RANK =
-      "ROW/RANGE not allowed with RANK, DENSE_RANK or ROW_NUMBER functions";
+      "ROW/RANGE not allowed with RANK, DENSE_RANK, ROW_NUMBER or PERCENTILE_CONT/DISC functions";
 
   private static final String RANK_REQUIRES_ORDER_BY = "RANK or DENSE_RANK "
       + "functions require ORDER BY clause in window specification";

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -137,7 +137,7 @@ public enum SqlTypeName {
   public static final int DEFAULT_INTERVAL_START_PRECISION = 2;
   public static final int DEFAULT_INTERVAL_FRACTIONAL_SECOND_PRECISION = 6;
   public static final int MIN_INTERVAL_START_PRECISION = 1;
-  public static final int MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION = 1;
+  public static final int MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION = 0;
   public static final int MAX_INTERVAL_START_PRECISION = 10;
   public static final int MAX_INTERVAL_FRACTIONAL_SECOND_PRECISION = 9;
 

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -2277,7 +2277,7 @@ void testLikeAndSimilarFails() {
       assertThat(typeName.getMinPrecision(), is(1));
       assertThat(typeSystem.getMaxPrecision(typeName), is(10));
       assertThat(typeSystem.getDefaultPrecision(typeName), is(2));
-      assertThat(typeName.getMinScale(), is(1));
+      assertThat(typeName.getMinScale(), is(0));
       assertThat(typeSystem.getMaxScale(typeName), is(9));
       assertThat(typeName.getDefaultScale(), is(6));
     }
@@ -2335,6 +2335,8 @@ private IntervalTest.Fixture2 getFixture2(SqlValidatorFixture f2) {
         .columnType("INTERVAL HOUR NOT NULL");
     sql("select interval emp.mgr hour as h from emp")
         .columnType("INTERVAL HOUR");
+    expr("interval '1' second(1, 0)")
+        .columnType("INTERVAL SECOND(1, 0) NOT NULL");
   }
 
   @Test void testIntervalOperators() {

File: core/src/test/java/org/apache/calcite/sql/type/SqlTypeUtilTest.java
Patch:
@@ -76,7 +76,7 @@ class SqlTypeUtilTest {
         is(true));
     assertThat(areSameFamily(ImmutableList.of(bigIntAndFloat, bigIntAndFloat)),
         is(true));
-    assertThat(areSameFamily(ImmutableList.of(bigIntAndFloat, bigIntAndFloat)),
+    assertThat(areSameFamily(ImmutableList.of(floatAndBigInt, bigIntAndFloat)),
         is(true));
     assertThat(areSameFamily(ImmutableList.of(floatAndBigInt, floatAndBigInt)),
         is(true));

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
Patch:
@@ -191,7 +191,7 @@ default boolean shouldUseDoubleMultiplication(RelDataTypeFactory typeFactory,
    * <li>Let d be the number of whole digits in the result</li>
    * <li>Then the result type is a decimal with:
    *   <ul>
-   *   <li>p = p1 + p2)</li>
+   *   <li>p = p1 + p2</li>
    *   <li>s = s1 + s2</li>
    *   </ul>
    * </li>

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -338,7 +338,7 @@ public boolean allowsScale() {
    * true</code>, because the VARCHAR type allows a precision parameter, as in
    * <code>VARCHAR(10)</code>.</li>
    * <li><code>Varchar.allowsPrecScale(true, true)</code> returns <code>
-   * true</code>, because the VARCHAR type does not allow a precision and a
+   * false</code>, because the VARCHAR type does not allow a precision and a
    * scale parameter, as in <code>VARCHAR(10, 4)</code>.</li>
    * <li><code>allowsPrecScale(false, true)</code> returns <code>false</code>
    * for every type.</li>

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -814,6 +814,7 @@ private SqlNode callToSql(@Nullable RexProgram program, RexCall call0,
       final List<SqlNode> nodeList = toSql(program, call.getOperands());
       switch (call.getKind()) {
       case CAST:
+      case SAFE_CAST:
         // CURSOR is used inside CAST, like 'CAST ($0): CURSOR NOT NULL',
         // convert it to sql call of {@link SqlStdOperatorTable#CURSOR}.
         final RelDataType dataType = call.getType();

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -622,6 +622,7 @@ public Object toJson(RexNode node) {
         }
         map.put("operands", list);
         switch (node.getKind()) {
+        case MINUS:
         case CAST:
           map.put("type", toJson(node.getType()));
           break;

File: core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
Patch:
@@ -110,7 +110,8 @@ public int getArity() {
         litmus.withMessageArgs("{} != {}", this, node))) {
       return litmus.fail("{} != {}", this, node);
     }
-    if (!this.fieldTypes.equals(that.fieldTypes)) {
+    if (!SqlNode.equalDeep(this.fieldTypes, that.fieldTypes,
+        litmus.withMessageArgs("{} != {}", this, node))) {
       return litmus.fail("{} != {}", this, node);
     }
     return litmus.succeed();

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -298,7 +298,7 @@ ExInst<CalciteException> invalidCompare(String a0, String a1, String a2,
   @BaseMessage("Date literal ''{0}'' out of range")
   ExInst<SqlValidatorException> dateLiteralOutOfRange(String a0);
 
-  @BaseMessage("Input arguments of {0} out of range: {1,number,#}; should be in the range of {2}")
+  @BaseMessage("Input arguments of {0} out of range: {1,number,#.#}; should be in the range of {2}")
   ExInst<CalciteException> inputArgumentsOfFunctionOutOfRange(String a0, Number a1, String a2);
 
   @BaseMessage("String literal continued on same line")

File: testkit/src/main/java/org/apache/calcite/sql/test/SqlOperatorFixture.java
Patch:
@@ -96,7 +96,7 @@ public interface SqlOperatorFixture extends AutoCloseable {
   // Error messages when an invalid time unit is given as
   // input to extract for a particular input type.
   String INVALID_EXTRACT_UNIT_CONVERTLET_ERROR =
-      "Extract.*from.*type data is not supported";
+      "Was not expecting value '.*' for enumeration.*";
 
   String INVALID_EXTRACT_UNIT_VALIDATION_ERROR =
       "Cannot apply 'EXTRACT' to arguments of type .*'\n.*";

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
Patch:
@@ -163,6 +163,7 @@ void forEachQueryValidateAndThen(StringAndPos expression,
       SqlValidator validator = factory.createValidator();
       SqlNode n = parseAndValidate(validator, sql);
       assertNotNull(n);
+      tester.checkFails(factory, sap, expectedError, runtime);
     } else {
       checkQueryFails(StringAndPos.of(sql),
           expectedError);
@@ -185,6 +186,7 @@ void forEachQueryValidateAndThen(StringAndPos expression,
       SqlValidator validator = factory.createValidator();
       SqlNode n = parseAndValidate(validator, sql);
       assertNotNull(n);
+      tester.checkAggFails(factory, expr, inputValues, expectedError, runtime);
     } else {
       checkQueryFails(StringAndPos.of(sql), expectedError);
     }

File: testkit/src/main/java/org/apache/calcite/test/SqlRuntimeTester.java
Patch:
@@ -36,9 +36,7 @@ class SqlRuntimeTester extends AbstractSqlTester {
 
   @Override public void checkFails(SqlTestFactory factory, StringAndPos sap,
       String expectedError, boolean runtime) {
-    final StringAndPos sap2 =
-        StringAndPos.of(runtime ? buildQuery2(factory, sap.addCarets())
-            : buildQuery(sap.addCarets()));
+    final StringAndPos sap2 = StringAndPos.of(buildQuery(sap.addCarets()));
     assertExceptionIsThrown(factory, sap2, expectedError, runtime);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
Patch:
@@ -42,7 +42,8 @@
  */
 public class SqlMapValueConstructor extends SqlMultisetValueConstructor {
   public SqlMapValueConstructor() {
-    super("MAP", SqlKind.MAP_VALUE_CONSTRUCTOR);
+    // no need to deduce NULL operand type
+    super("MAP", SqlKind.MAP_VALUE_CONSTRUCTOR, null);
   }
 
   @SuppressWarnings("argument.type.incompatible")

File: testkit/src/main/java/org/apache/calcite/util/TestUtil.java
Patch:
@@ -54,6 +54,8 @@ public abstract class TestUtil {
   private static final String JAVA_VERSION =
       System.getProperties().getProperty("java.version");
 
+  public static final String AVATICA_VERSION =
+      System.getProperty("calcite.avatica.version");
   private static final Supplier<Integer> GUAVA_MAJOR_VERSION =
       Suppliers.memoize(TestUtil::computeGuavaMajorVersion);
 

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
Patch:
@@ -76,7 +76,7 @@ class SqlOperatorFixtureImpl implements SqlOperatorFixture {
     return tester;
   }
 
-  @Override public SqlOperatorFixtureImpl withFactory(
+  @Override public SqlOperatorFixture withFactory(
       UnaryOperator<SqlTestFactory> transform) {
     final SqlTestFactory factory = transform.apply(this.factory);
     if (factory == this.factory) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
Patch:
@@ -614,7 +614,7 @@ static List<Expression> convertAssignableTypes(Class<?>[] targetTypes,
       }
     } else {
       int j = 0;
-      for (Expression argument: arguments) {
+      for (Expression argument : arguments) {
         Class<?> type;
         if (!targetTypes[j].isArray()) {
           type = targetTypes[j];

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -3762,7 +3762,7 @@ private abstract static class AbstractRexCallImplementor
         final List<RexToLixTranslator.Result> arguments) {
       final List<Expression> argIsNullList = new ArrayList<>();
       final List<Expression> argValueList = new ArrayList<>();
-      for (RexToLixTranslator.Result result: arguments) {
+      for (RexToLixTranslator.Result result : arguments) {
         argIsNullList.add(result.isNullVariable);
         argValueList.add(result.valueVariable);
       }
@@ -3950,7 +3950,7 @@ private static class LogicalAndImplementor extends AbstractRexCallImplementor {
     @Override public RexToLixTranslator.Result implement(final RexToLixTranslator translator,
         final RexCall call, final List<RexToLixTranslator.Result> arguments) {
       final List<Expression> argIsNullList = new ArrayList<>();
-      for (RexToLixTranslator.Result result: arguments) {
+      for (RexToLixTranslator.Result result : arguments) {
         argIsNullList.add(result.isNullVariable);
       }
       final List<Expression> nullAsTrue =
@@ -4004,7 +4004,7 @@ private static class LogicalOrImplementor extends AbstractRexCallImplementor {
     @Override public RexToLixTranslator.Result implement(final RexToLixTranslator translator,
         final RexCall call, final List<RexToLixTranslator.Result> arguments) {
       final List<Expression> argIsNullList = new ArrayList<>();
-      for (RexToLixTranslator.Result result: arguments) {
+      for (RexToLixTranslator.Result result : arguments) {
         argIsNullList.add(result.isNullVariable);
       }
       final List<Expression> nullAsFalse =

File: core/src/main/java/org/apache/calcite/interpreter/JoinNode.java
Patch:
@@ -92,7 +92,7 @@ public JoinNode(Compiler compiler, Join rel) {
       // send un-match rows for full join on right source
       List<Row> empty = new ArrayList<>();
       // TODO: CALCITE-4308, JointNode in Interpreter might fail with NPE for FULL join
-      for (Row row: requireNonNull(innerRows, "innerRows")) {
+      for (Row row : requireNonNull(innerRows, "innerRows")) {
         if (matchRowSet.contains(row)) {
           continue;
         }
@@ -109,7 +109,7 @@ private List<Row> doJoin(Row outerRow, List<Row> innerRows,
     boolean outerRowOnLeft = joinRelType != JoinRelType.RIGHT;
     copyToContext(outerRow, outerRowOnLeft);
     List<Row> matchInnerRows = new ArrayList<>();
-    for (Row innerRow: innerRows) {
+    for (Row innerRow : innerRows) {
       copyToContext(innerRow, !outerRowOnLeft);
       final Boolean execute = (Boolean) condition.execute(context);
       if (execute != null && execute) {
@@ -135,7 +135,7 @@ private void doSend(Row outerRow, List<Row> matchInnerRows,
         boolean outerRowOnLeft = joinRelType != JoinRelType.RIGHT;
         copyToContext(outerRow, outerRowOnLeft);
         requireNonNull(context.values, "context.values");
-        for (Row row: matchInnerRows) {
+        for (Row row : matchInnerRows) {
           copyToContext(row, !outerRowOnLeft);
           sink.send(Row.asCopy(context.values));
         }

File: core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java
Patch:
@@ -35,7 +35,7 @@ public UncollectNode(Compiler compiler, Uncollect uncollect) {
   @Override public void run() throws InterruptedException {
     Row row = null;
     while ((row = source.receive()) != null) {
-      for (Object value: row.getValues()) {
+      for (Object value : row.getValues()) {
         if (value == null) {
           throw new NullPointerException("NULL value for unnest.");
         }

File: core/src/main/java/org/apache/calcite/jdbc/SimpleCalciteSchema.java
Patch:
@@ -92,7 +92,7 @@ private SimpleCalciteSchema(@Nullable CalciteSchema parent,
       return lowerCaseName;
     }
     // Fall through: Set iteration
-    for (String candidate: candidates) {
+    for (String candidate : candidates) {
       if (candidate.equalsIgnoreCase(name)) {
         return candidate;
       }

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1746,7 +1746,7 @@ private static boolean sameRelCollectionNoOrderConsidered(
     if (list0.size() != list1.size()) {
       return false;
     }
-    for (MutableRel rel: list0) {
+    for (MutableRel rel : list0) {
       int index = list1.indexOf(rel);
       if (index == -1) {
         return false;
@@ -1766,7 +1766,7 @@ public static Pair<RexNode, List<RexNode>> explainCalc(MutableCalc calc) {
     final RexShuttle shuttle = getExpandShuttle(calc.program);
     final RexNode condition = shuttle.apply(calc.program.getCondition());
     final List<RexNode> projects = new ArrayList<>();
-    for (RexNode rex: shuttle.apply(calc.program.getProjectList())) {
+    for (RexNode rex : shuttle.apply(calc.program.getProjectList())) {
       projects.add(rex);
     }
     if (condition == null) {
@@ -1836,7 +1836,7 @@ private static boolean implies(
   private static boolean referenceByMapping(
       RexNode joinCondition, List<RexNode>... projectsOfInputs) {
     List<RexNode> projects = new ArrayList<>();
-    for (List<RexNode> projectsOfInput: projectsOfInputs) {
+    for (List<RexNode> projectsOfInput : projectsOfInputs) {
       projects.addAll(projectsOfInput);
     }
 

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -234,8 +234,9 @@ public VolcanoPlanner(@Nullable RelOptCostFactory costFactory,
     this.zeroCost = this.costFactory.makeZeroCost();
     this.infCost = this.costFactory.makeInfiniteCost();
     // If LOGGER is debug enabled, enable provenance information to be captured
-    this.provenanceMap = LOGGER.isDebugEnabled() ? new HashMap<>()
-        : Util.blackholeMap();
+    this.provenanceMap =
+        LOGGER.isDebugEnabled() ? new HashMap<>()
+            : Util.blackholeMap();
     initRuleQueue();
   }
 

File: core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
Patch:
@@ -61,8 +61,9 @@ protected ConverterRule(Config config) {
 
     // Most sub-classes are concerned with converting one convention to
     // another, and for them, the "out" field is a convenient short-cut.
-    this.out = outTrait instanceof Convention ? (Convention) outTrait
-        : castNonNull(null);
+    this.out =
+        outTrait instanceof Convention ? (Convention) outTrait
+            : castNonNull(null);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/hint/CompositeHintPredicate.java
Patch:
@@ -65,15 +65,15 @@ public enum Composition {
   private boolean apply(Composition composition, RelHint hint, RelNode rel) {
     switch (composition) {
     case AND:
-      for (HintPredicate predicate: predicates) {
+      for (HintPredicate predicate : predicates) {
         if (!predicate.apply(hint, rel)) {
           return false;
         }
       }
       return true;
     case OR:
     default:
-      for (HintPredicate predicate: predicates) {
+      for (HintPredicate predicate : predicates) {
         if (predicate.apply(hint, rel)) {
           return true;
         }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
Patch:
@@ -152,7 +152,7 @@ private RelMdColumnOrigins() {}
       }
     };
     final List<RexNode> projects = new ArrayList<>();
-    for (RexNode rex: rexShuttle.apply(rel.getProgram().getProjectList())) {
+    for (RexNode rex : rexShuttle.apply(rel.getProgram().getProjectList())) {
       projects.add(rex);
     }
     final RexNode rexNode = projects.get(iOutputColumn);

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -369,7 +369,7 @@ public Boolean areColumnsUnique(Intersect rel, RelMetadataQuery mq,
         return false;
       }
       final ImmutableBitSet.Builder targetColumns = ImmutableBitSet.builder();
-      for (int key: commonKeys) {
+      for (int key : commonKeys) {
         targetColumns.set(rel.getGroupSet().nth(key));
       }
 

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
Patch:
@@ -476,7 +476,7 @@ public RelOptPredicateList getPredicates(Intersect intersect, RelMetadataQuery m
         continue;
       }
 
-      for (RexNode pred: info.pulledUpPredicates) {
+      for (RexNode pred : info.pulledUpPredicates) {
         if (finalPredicates.stream().anyMatch(
             finalPred -> rexImplicationChecker.implies(finalPred, pred))) {
           // There's already a stricter predicate in finalPredicates,

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -501,16 +501,16 @@ public Result visit(Window e) {
     final RelNode input = e.getInput();
     final int inputFieldCount = input.getRowType().getFieldCount();
     final List<SqlNode> rexOvers = new ArrayList<>();
-    for (Window.Group group: e.groups) {
+    for (Window.Group group : e.groups) {
       rexOvers.addAll(builder.context.toSql(group, e.constants, inputFieldCount));
     }
     final List<SqlNode> selectList = new ArrayList<>();
 
-    for (RelDataTypeField field: input.getRowType().getFieldList()) {
+    for (RelDataTypeField field : input.getRowType().getFieldList()) {
       addSelect(selectList, builder.context.field(field.getIndex()), e.getRowType());
     }
 
-    for (SqlNode rexOver: rexOvers) {
+    for (SqlNode rexOver : rexOvers) {
       addSelect(selectList, rexOver, e.getRowType());
     }
 

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -943,10 +943,10 @@ public List<SqlNode> toSql(Window.Group group, ImmutableList<RexLiteral> constan
       final List<SqlNode> rexOvers = new ArrayList<>();
       final List<SqlNode> partitionKeys = new ArrayList<>();
       final List<SqlNode> orderByKeys = new ArrayList<>();
-      for (int partition: group.keys) {
+      for (int partition : group.keys) {
         partitionKeys.add(this.field(partition));
       }
-      for (RelFieldCollation collation: group.orderKeys.getFieldCollations()) {
+      for (RelFieldCollation collation : group.orderKeys.getFieldCollations()) {
         this.addOrderItem(orderByKeys, collation);
       }
       SqlLiteral isRows = SqlLiteral.createBoolean(group.isRows, POS);
@@ -955,7 +955,7 @@ public List<SqlNode> toSql(Window.Group group, ImmutableList<RexLiteral> constan
 
       final SqlLiteral allowPartial = null;
 
-      for (Window.RexWinAggCall winAggCall: group.aggCalls) {
+      for (Window.RexWinAggCall winAggCall : group.aggCalls) {
         SqlAggFunction aggFunction = (SqlAggFunction) winAggCall.getOperator();
         final SqlWindow sqlWindow =
                 SqlWindow.create(null, null,

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -463,9 +463,9 @@ private static void rewriteUsingGroupingSets(RelOptRuleCall call,
     // Get the base ordinal of filter args for different groupSets.
     final Map<Pair<ImmutableBitSet, Integer>, Integer> filters = new LinkedHashMap<>();
     int z = groupCount + distinctAggCalls.size();
-    for (ImmutableBitSet groupSet: groupSets) {
+    for (ImmutableBitSet groupSet : groupSets) {
       Set<Integer> filterArgList = distinctFilterArgMap.get(groupSet);
-      for (Integer filterArg: requireNonNull(filterArgList, "filterArgList")) {
+      for (Integer filterArg : requireNonNull(filterArgList, "filterArgList")) {
         filters.put(Pair.of(groupSet, filterArg), z);
         z += 1;
       }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinRemoveRule.java
Patch:
@@ -86,8 +86,9 @@ public AggregateJoinRemoveRule(
     boolean isLeftJoin = join.getJoinType() == JoinRelType.LEFT;
     int lower = isLeftJoin
         ? join.getLeft().getRowType().getFieldCount() : 0;
-    int upper = isLeftJoin ? join.getRowType().getFieldCount()
-        : join.getLeft().getRowType().getFieldCount();
+    int upper =
+        isLeftJoin ? join.getRowType().getFieldCount()
+            : join.getLeft().getRowType().getFieldCount();
 
     // Check whether the aggregate uses columns whose index is between
     // lower(included) and upper(excluded).

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectConstantToDummyJoinRule.java
Patch:
@@ -65,7 +65,7 @@ private AggregateProjectConstantToDummyJoinRule(Config config) {
     final Aggregate aggregate = call.rel(0);
     final Project project = call.rel(1);
 
-    for (int groupKey: aggregate.getGroupSet().asList()) {
+    for (int groupKey : aggregate.getGroupSet().asList()) {
       if (groupKey >= aggregate.getRowType().getFieldCount()) {
         continue;
       }

File: core/src/main/java/org/apache/calcite/rel/rules/MinusToDistinctRule.java
Patch:
@@ -149,8 +149,9 @@ public MinusToDistinctRule(Class<? extends Minus> minusClass,
 
     ImmutableList.Builder<RexNode> filters = ImmutableList.builder();
     for (int i = 0; i < branchCount; i++) {
-      SqlOperator operator = i == 0 ? SqlStdOperatorTable.GREATER_THAN
-          : SqlStdOperatorTable.EQUALS;
+      SqlOperator operator =
+          i == 0 ? SqlStdOperatorTable.GREATER_THAN
+              : SqlStdOperatorTable.EQUALS;
       filters.add(
           rexBuilder.makeCall(operator, relBuilder.field(originalFieldCnt + i),
           relBuilder.literal(new BigDecimal(0))));

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinJoinRemoveRule.java
Patch:
@@ -89,7 +89,7 @@ public ProjectJoinJoinRemoveRule(
     int leftBottomChildSize = bottomJoin.getLeft().getRowType().getFieldCount();
 
     // Check whether the project uses columns in the right input of bottom join.
-    for (RexNode expr: project.getProjects()) {
+    for (RexNode expr : project.getProjects()) {
       if (RelOptUtil.InputFinder.bits(expr).asList().stream().anyMatch(
           i -> i >= leftBottomChildSize
               && i < bottomJoin.getRowType().getFieldCount())) {

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinRemoveRule.java
Patch:
@@ -86,7 +86,7 @@ public ProjectJoinRemoveRule(
 
     // Check whether the project uses columns whose index is between
     // lower(included) and upper(excluded).
-    for (RexNode expr: project.getProjects()) {
+    for (RexNode expr : project.getProjects()) {
       if (RelOptUtil.InputFinder.bits(expr).asList().stream().anyMatch(
           i -> i >= lower && i < upper)) {
         return;

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -262,7 +262,7 @@ private RelDataType createStructType(
       final List<RelDataType> types, SqlTypeName sqlTypeName) {
     assert sqlTypeName == SqlTypeName.ARRAY || sqlTypeName == SqlTypeName.MULTISET;
     boolean isNullable = false;
-    for (RelDataType type: types) {
+    for (RelDataType type : types) {
       if (type.getComponentType() == null) {
         return null;
       }
@@ -286,7 +286,7 @@ private RelDataType createStructType(
       final List<RelDataType> types, SqlTypeName sqlTypeName) {
     assert sqlTypeName == SqlTypeName.MAP;
     boolean isNullable = false;
-    for (RelDataType type: types) {
+    for (RelDataType type : types) {
       if (!(type instanceof MapSqlType)) {
         return null;
       }

File: core/src/main/java/org/apache/calcite/rex/RexProgram.java
Patch:
@@ -250,7 +250,7 @@ public static RexProgram create(RelInput input) {
     final List<RexNode> projectRexNodes =
         requireNonNull(input.getExpressionList("projects"), "projects");
     final List<RexLocalRef> projects = new ArrayList<>(projectRexNodes.size());
-    for (RexNode rexNode: projectRexNodes) {
+    for (RexNode rexNode : projectRexNodes) {
       projects.add((RexLocalRef) rexNode);
     }
     final RelDataType inputType = input.getRowType("inputRowType");

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -1221,7 +1221,7 @@ public static String charFromUtf8(int n) {
    */
   public static @Nullable String codePointsToString(List codePoints) {
     StringBuilder sb = new StringBuilder();
-    for (Object codePoint: codePoints) {
+    for (Object codePoint : codePoints) {
       if (codePoint == null) {
         return null;
       }
@@ -5314,7 +5314,7 @@ public static Map mapFromArrays(List keysArray, List valuesArray) {
   /** Support the MAP_FROM_ENTRIES function. */
   public static @Nullable Map mapFromEntries(List entries) {
     final Map map = new LinkedHashMap<>();
-    for (Object entry: entries) {
+    for (Object entry : entries) {
       if (entry == null) {
         return null;
       }

File: core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
Patch:
@@ -164,8 +164,9 @@ public SqlDataTypeSpec withNullable(Boolean nullable) {
   /** Returns a copy of this data type specification with a given
    * nullability, extending the parser position. */
   public SqlDataTypeSpec withNullable(Boolean nullable, SqlParserPos pos) {
-    final SqlParserPos newPos = pos == SqlParserPos.ZERO ? this.pos
-        : this.pos.plus(pos);
+    final SqlParserPos newPos =
+        pos == SqlParserPos.ZERO ? this.pos
+            : this.pos.plus(pos);
     if (Objects.equals(nullable, this.nullable)
         && newPos.equals(this.pos)) {
       return this;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -1326,7 +1326,7 @@ private static RelDataType deriveTypeMapConcat(SqlOperatorBinding opBinding) {
       return SqlTypeUtil.createMapType(typeFactory, type, type, true);
     } else {
       final List<RelDataType> operandTypes = opBinding.collectOperandTypes();
-      for (RelDataType operandType: operandTypes) {
+      for (RelDataType operandType : operandTypes) {
         if (!SqlTypeUtil.isMap(operandType)) {
           throw opBinding.newError(
               RESOURCE.typesShouldAllBeMap(

File: core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
Patch:
@@ -1044,7 +1044,7 @@ public static SqlCall stripSeparator(SqlCall call) {
         List<RelDataType> operandTypes = opBinding.collectOperandTypes();
         final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();
         final RelDataTypeSystem typeSystem = typeFactory.getTypeSystem();
-        for (RelDataType operandType: operandTypes) {
+        for (RelDataType operandType : operandTypes) {
           int operandPrecision = operandType.getPrecision();
           amount = (long) operandPrecision + amount;
           if (operandPrecision == RelDataType.PRECISION_NOT_SPECIFIED) {

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -158,8 +158,9 @@ private SqlValidatorNamespace resolveImpl(SqlIdentifier id) {
           // If previousResolve is null, we matched nothing case-sensitive and
           // everything case-insensitive, so the mismatch must have been at
           // position 0.
-          final int i = previousResolve == null ? 0
-              : previousResolve.path.stepCount();
+          final int i =
+              previousResolve == null ? 0
+                  : previousResolve.path.stepCount();
           final int offset = resolve.path.stepCount()
               + resolve.remainingNames.size() - names.size();
           final List<String> prefix =

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -4901,7 +4901,7 @@ private void checkConstraint(
 
       // Validate insert values against the view constraint.
       final List<SqlNode> values = ((SqlCall) source).getOperandList();
-      for (final int colIndex: constrainedTargetColumns) {
+      for (final int colIndex : constrainedTargetColumns) {
         final String colName = tableFields.get(colIndex).getName();
         final RelDataTypeField targetField = tableIndexToTargetField.get(colIndex);
         for (SqlNode row : values) {

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -5118,7 +5118,7 @@ public RelNode reRegister(RelNode root) {
       setRoot(root, false);
       List<RegisterArgs> registerCopy = registered;
       registered = new ArrayList<>();
-      for (RegisterArgs reg: registerCopy) {
+      for (RegisterArgs reg : registerCopy) {
         RelNode relNode = reg.rel;
         relBuilder.push(relNode);
         final RelMetadataQuery mq = relBuilder.getCluster().getMetadataQuery();

File: core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java
Patch:
@@ -184,7 +184,7 @@ protected final VertexInfo<V, E> getVertex(V vertex) {
     }
 
     // remove all edges ref from this.edges
-    for (V v: collection) {
+    for (V v : collection) {
       edges.removeIf(e -> e.source.equals(v) || e.target.equals(v));
     }
   }

File: core/src/test/java/org/apache/calcite/plan/RelWriterTest.java
Patch:
@@ -1355,11 +1355,11 @@ private RelNode mockCountOver(RelBuilder builder, String table,
     final RelDataType type = rexBuilder.getTypeFactory().createSqlType(SqlTypeName.BIGINT);
     List<RexNode> partitionKeys = new ArrayList<>(partitionKeyNames.size());
     builder.scan(table);
-    for (String partitionkeyName: partitionKeyNames) {
+    for (String partitionkeyName : partitionKeyNames) {
       partitionKeys.add(builder.field(partitionkeyName));
     }
     List<RexFieldCollation> orderKeys = new ArrayList<>(orderKeyNames.size());
-    for (String orderKeyName: orderKeyNames) {
+    for (String orderKeyName : orderKeyNames) {
       orderKeys.add(new RexFieldCollation(builder.field(orderKeyName), ImmutableSet.of()));
     }
     final RelNode rel = builder

File: core/src/test/java/org/apache/calcite/sql/SqlNodeTest.java
Patch:
@@ -68,7 +68,7 @@ private <E> void checkLists(List<E> list0, List<E> list1, int depth) {
 
   private static <E> List<E> collect(Iterable<E> iterable) {
     final List<E> list = new ArrayList<>();
-    for (E e: iterable) {
+    for (E e : iterable) {
       list.add(e);
     }
     return list;

File: core/src/test/java/org/apache/calcite/test/MaterializedViewTester.java
Patch:
@@ -79,7 +79,7 @@ void checkMaterialize(MaterializedViewFixture f) {
     if (substitutes.stream()
         .noneMatch(sub -> checker.test(RelOptUtil.toString(sub)))) {
       StringBuilder substituteMessages = new StringBuilder();
-      for (RelNode sub: substitutes) {
+      for (RelNode sub : substitutes) {
         substituteMessages.append(RelOptUtil.toString(sub)).append("\n");
       }
       throw new AssertionError("Materialized view failed to be matched by optimized results:\n"
@@ -100,7 +100,7 @@ void checkNoMaterialize(MaterializedViewFixture f) {
     }
     final StringBuilder errMsgBuilder = new StringBuilder();
     errMsgBuilder.append("Optimization succeeds out of expectation: ");
-    for (RelNode res: results) {
+    for (RelNode res : results) {
       errMsgBuilder.append(RelOptUtil.toString(res)).append("\n");
     }
     throw new AssertionError(errMsgBuilder.toString());
@@ -124,7 +124,7 @@ private TestConfig build(MaterializedViewFixture f) {
             RelFactories.LOGICAL_BUILDER.create(cluster, relOptSchema);
         final MaterializationService.DefaultTableFactory tableFactory =
             new MaterializationService.DefaultTableFactory();
-        for (Pair<String, String> pair: f.materializationList) {
+        for (Pair<String, String> pair : f.materializationList) {
           String sql = requireNonNull(pair.left, "sql");
           final RelNode mvRel = toRel(cluster, rootSchema, defaultSchema, sql);
           final Table table =

File: core/src/test/java/org/apache/calcite/test/MutableRelTest.java
Patch:
@@ -200,7 +200,7 @@ class MutableRelTest {
     MutableRel mutableRel =
         createMutableRel("select sal from emp where deptno = 10"
             + "union select sal from emp where ename like 'John%'");
-    for (MutableRel input: mutableRel.getInputs()) {
+    for (MutableRel input : mutableRel.getInputs()) {
       assertSame(input.getParent(), mutableRel);
     }
   }

File: core/src/test/java/org/apache/calcite/util/SourceTest.java
Patch:
@@ -67,7 +67,7 @@ private static String getRootPrefix() {
    */
   @Test void charSource() throws IOException {
     Source source = Sources.fromCharSource(CharSource.wrap("a\nb"));
-    for (Reader r: Arrays.asList(source.reader(),
+    for (Reader r : Arrays.asList(source.reader(),
         new InputStreamReader(source.openStream(), StandardCharsets.UTF_8.name()))) {
       try (BufferedReader reader = new BufferedReader(r)) {
         assertEquals("a", reader.readLine());

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
Patch:
@@ -718,7 +718,7 @@ private static Aggregation parseBuckets(JsonParser parser, String name, ArrayNod
         throws JsonProcessingException {
 
       List<Bucket> buckets = new ArrayList<>(nodes.size());
-      for (JsonNode b: nodes) {
+      for (JsonNode b : nodes) {
         buckets.add(parseBucket(parser, name, (ObjectNode) b));
       }
 

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMethod.java
Patch:
@@ -47,7 +47,7 @@ enum ElasticsearchMethod {
 
   static {
     final ImmutableMap.Builder<Method, ElasticsearchMethod> builder = ImmutableMap.builder();
-    for (ElasticsearchMethod value: ElasticsearchMethod.values()) {
+    for (ElasticsearchMethod value : ElasticsearchMethod.values()) {
       builder.put(value.method, value);
     }
     MAP = builder.build();

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
Patch:
@@ -72,7 +72,7 @@ public class ElasticsearchProject extends Project implements ElasticsearchRel {
     final List<String> scriptFields = new ArrayList<>();
     // registers wherever "select *" is present
     boolean hasSelectStar = false;
-    for (Pair<RexNode, String> pair: getNamedProjects()) {
+    for (Pair<RexNode, String> pair : getNamedProjects()) {
       final String name = pair.right;
       final String expr = pair.left.accept(translator);
 
@@ -115,7 +115,7 @@ public class ElasticsearchProject extends Project implements ElasticsearchRel {
       query.append("\"_source\" : [").append(findString).append("]");
     } else {
       // if scripted fields are present, ES ignores _source attribute
-      for (String field: fields) {
+      for (String field : fields) {
         scriptFields.add(ElasticsearchRules.quote(field) + ":{\"script\": "
                 // _source (ES2) vs params._source (ES5)
                 + "\"" + implementor.elasticsearchTable.scriptedFieldPrefix() + "."

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTableScan.java
Patch:
@@ -81,7 +81,7 @@ public class ElasticsearchTableScan extends TableScan implements ElasticsearchRe
 
   @Override public void register(RelOptPlanner planner) {
     planner.addRule(ElasticsearchToEnumerableConverterRule.INSTANCE);
-    for (RelOptRule rule: ElasticsearchRules.RULES) {
+    for (RelOptRule rule : ElasticsearchRules.RULES) {
       planner.addRule(rule);
     }
 

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
Patch:
@@ -282,7 +282,7 @@ private static void writeJsonArray(String field, List<QueryBuilder> clauses, Jso
         clauses.get(0).writeJson(gen);
       } else {
         gen.writeArrayFieldStart(field);
-        for (QueryBuilder clause: clauses) {
+        for (QueryBuilder clause : clauses) {
           clause.writeJson(gen);
         }
         gen.writeEndArray();
@@ -331,7 +331,7 @@ private TermsQueryBuilder(final String fieldName, final Iterable<?> values) {
       generator.writeStartObject();
       generator.writeFieldName(fieldName);
       generator.writeStartArray();
-      for (Object value: values) {
+      for (Object value : values) {
         writeObject(generator, value);
       }
       generator.writeEndArray();
@@ -384,7 +384,7 @@ private MatchesQueryBuilder(final String fieldName, final Iterable<?> values) {
       generator.writeStartObject();
       generator.writeFieldName(fieldName);
       generator.writeStartArray();
-      for (Object value: values) {
+      for (Object value : values) {
         writeObject(generator, value);
       }
       generator.writeEndArray();

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/AggregationTest.java
Patch:
@@ -77,7 +77,7 @@ public static void setupInstance() throws Exception {
         .enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES); // avoid too much quoting
 
     final List<ObjectNode> docs = new ArrayList<>();
-    for (String text: Arrays.asList(doc1, doc2, doc3)) {
+    for (String text : Arrays.asList(doc1, doc2, doc3)) {
       docs.add((ObjectNode) mapper.readTree(text));
     }
 

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/EmbeddedElasticsearchNode.java
Patch:
@@ -150,7 +150,7 @@ public Client client() {
   @Override public void close() throws Exception {
     node.close();
     // cleanup data dirs
-    for (String name: Arrays.asList("path.data", "path.home")) {
+    for (String name : Arrays.asList("path.data", "path.home")) {
       if (node.settings().get(name) != null) {
         File file = new File(node.settings().get(name));
         if (file.exists()) {

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/EmbeddedElasticsearchPolicy.java
Patch:
@@ -119,7 +119,7 @@ void createIndex(String index, Map<String, String> mapping) throws IOException {
 
     ObjectNode properties = mappings.withObject("/mappings")
         .withObject("/properties");
-    for (Map.Entry<String, String> entry: mapping.entrySet()) {
+    for (Map.Entry<String, String> entry : mapping.entrySet()) {
       applyMapping(properties, entry.getKey(), entry.getValue());
     }
 
@@ -206,7 +206,7 @@ void insertBulk(String index, List<ObjectNode> documents) throws IOException {
     }
 
     List<String> bulk = new ArrayList<>(documents.size() * 2);
-    for (ObjectNode doc: documents) {
+    for (ObjectNode doc : documents) {
       bulk.add(String.format(Locale.ROOT, "{\"index\": {\"_index\":\"%s\"}}", index));
       bulk.add(mapper().writeValueAsString(doc));
     }

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/ScrollingTest.java
Patch:
@@ -86,7 +86,7 @@ private ConnectionFactory newConnectionFactory(int fetchSize) {
     final String query = String.format(Locale.ROOT, "select _MAP['value'] as v from "
         + "\"elastic\".\"%s\"", NAME);
 
-    for (int fetchSize: Arrays.asList(1, 2, 3, SIZE / 2, SIZE - 1, SIZE, SIZE + 1, 2 * SIZE)) {
+    for (int fetchSize : Arrays.asList(1, 2, 3, SIZE / 2, SIZE - 1, SIZE, SIZE + 1, 2 * SIZE)) {
       CalciteAssert.that()
           .with(newConnectionFactory(fetchSize))
           .query(query)

File: elasticsearch/src/test/java/org/apache/calcite/test/ElasticsearchChecker.java
Patch:
@@ -55,8 +55,8 @@ private ElasticsearchChecker() {}
   public static Consumer<List> elasticsearchChecker(final String... strings) {
     Objects.requireNonNull(strings, "strings");
     return a -> {
-      ObjectNode actual = a == null || a.isEmpty() ? null
-            : ((ObjectNode) a.get(0));
+      ObjectNode actual =
+          a == null || a.isEmpty() ? null : (ObjectNode) a.get(0);
 
       actual = expandDots(actual);
       try {

File: file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
Patch:
@@ -93,8 +93,9 @@ public CsvEnumerator(Source source, AtomicBoolean cancelFlag, boolean stream,
       @Nullable String @Nullable [] filterValues, RowConverter<E> rowConverter) {
     this.cancelFlag = cancelFlag;
     this.rowConverter = rowConverter;
-    this.filterValues = filterValues == null ? null
-        : ImmutableNullableList.copyOf(filterValues);
+    this.filterValues =
+        filterValues == null ? null
+            : ImmutableNullableList.copyOf(filterValues);
     try {
       if (stream) {
         this.reader = new CsvStreamReader(source);

File: file/src/main/java/org/apache/calcite/adapter/file/FileSchema.java
Patch:
@@ -49,8 +49,9 @@ class FileSchema extends AbstractSchema {
    */
   FileSchema(SchemaPlus parentSchema, String name, File baseDirectory,
       List<Map<String, Object>> tables) {
-    this.tables = tables == null ? ImmutableList.of()
-        : ImmutableList.copyOf(tables);
+    this.tables =
+        tables == null ? ImmutableList.of()
+            : ImmutableList.copyOf(tables);
     this.baseDirectory = baseDirectory;
   }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/TryStatement.java
Patch:
@@ -42,7 +42,7 @@ public TryStatement(Statement body, List<CatchBlock> catchBlocks,
     shuttle = shuttle.preVisit(this);
     Statement body1 = body.accept(shuttle);
     List<CatchBlock> catchBlocks1 = new ArrayList<>();
-    for (CatchBlock cb: catchBlocks) {
+    for (CatchBlock cb : catchBlocks) {
       Statement cbBody = cb.body.accept(shuttle);
       catchBlocks1.add(
           Expressions.catch_(cb.parameter, cbBody));

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoTableScan.java
Patch:
@@ -74,8 +74,9 @@ protected MongoTableScan(RelOptCluster cluster, RelTraitSet traitSet,
   @Override public @Nullable RelOptCost computeSelfCost(RelOptPlanner planner,
       RelMetadataQuery mq) {
     // scans with a small project list are cheaper
-    final float f = projectRowType == null ? 1f
-        : (float) projectRowType.getFieldCount() / 100f;
+    final float f =
+        projectRowType == null ? 1f
+            : (float) projectRowType.getFieldCount() / 100f;
     return super.computeSelfCost(planner, mq).multiplyBy(.1 * f);
   }
 

File: plus/src/test/java/org/apache/calcite/slt/SqlLogicTests.java
Patch:
@@ -177,7 +177,7 @@ boolean regression(TestSummary summary) {
       List<TestSummary> results = new ArrayList<>(this.testResults.values());
       results.sort(Comparator.comparing(left -> left.file));
       StringBuilder result = new StringBuilder();
-      for (TestSummary summary: results) {
+      for (TestSummary summary : results) {
         result.append(summary.toString());
         result.append(System.lineSeparator());
       }
@@ -291,7 +291,7 @@ List<DynamicTest> testAll() {
    */
   private List<DynamicTest> generateTests(Set<String> testFiles) {
     List<DynamicTest> result = new ArrayList<>();
-    for (String test: testFiles) {
+    for (String test : testFiles) {
       DynamicTest dynamicTest = DynamicTest.dynamicTest(test, () -> runTestFile(test));
       result.add(dynamicTest);
     }

File: redis/src/main/java/org/apache/calcite/adapter/redis/RedisTable.java
Patch:
@@ -60,8 +60,9 @@ public RedisTable(
     this.schema = schema;
     this.tableName = tableName;
     this.protoRowType = protoRowType;
-    this.allFields = allFields == null ? ImmutableMap.of()
-        : ImmutableMap.copyOf(allFields);
+    this.allFields =
+        allFields == null ? ImmutableMap.of()
+            : ImmutableMap.copyOf(allFields);
     this.dataFormat = dataFormat;
     this.redisConfig = redisConfig;
   }

File: server/src/main/java/org/apache/calcite/server/ServerDdlExecutor.java
Patch:
@@ -146,8 +146,9 @@ static Pair<CalciteSchema, String> schema(CalcitePrepare.Context context,
       path = Util.skipLast(id.names);
       name = Util.last(id.names);
     }
-    CalciteSchema schema = mutable ? context.getMutableRootSchema()
-        : context.getRootSchema();
+    CalciteSchema schema =
+        mutable ? context.getMutableRootSchema()
+            : context.getRootSchema();
     for (String p : path) {
       schema = schema.getSubSchema(p, true);
     }

File: testkit/src/main/java/org/apache/calcite/test/MockDdlExecutor.java
Patch:
@@ -93,8 +93,9 @@ static Pair<CalciteSchema, String> schema(CalcitePrepare.Context context,
       path = Util.skipLast(id.names);
       name = Util.last(id.names);
     }
-    CalciteSchema schema = mutable ? context.getMutableRootSchema()
-        : context.getRootSchema();
+    CalciteSchema schema =
+        mutable ? context.getMutableRootSchema()
+            : context.getRootSchema();
     for (String p : path) {
       schema = requireNonNull(schema.getSubSchema(p, true));
     }

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -8144,10 +8144,9 @@ private void checkGetTimestamp(Connection con) throws SQLException {
    * ClassCastException retrieving from ARRAY that has mixed INTEGER and DECIMAL
    * elements</a>. */
   @Test void testIntAndBigDecimalInArray() {
-    // Result should be "EXPR$0=[1, 1.1]\n"; [CALCITE-4850] logged.
     CalciteAssert.that()
         .query("select array[1, 1.1]")
-        .returns("EXPR$0=[0E+1, 1.1]\n");
+        .returns("EXPR$0=[1, 1.1]\n");
   }
 
   /** Test case for

File: core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
Patch:
@@ -53,8 +53,8 @@
  *
  * @see org.apache.calcite.rel.logical.LogicalTableFunctionScan
  */
-public abstract class TableFunctionScan extends AbstractRelNode implements
-    Hintable {
+public abstract class TableFunctionScan extends AbstractRelNode
+    implements Hintable {
   //~ Instance fields --------------------------------------------------------
 
   private final RexNode rexCall;

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSort.java
Patch:
@@ -66,7 +66,7 @@ public MongoSort(RelOptCluster cluster, RelTraitSet traitSet,
       for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {
         final String name =
             fields.get(fieldCollation.getFieldIndex()).getName();
-        keys.add(name + ": " + direction(fieldCollation));
+        keys.add(MongoRules.maybeQuote(name) + ": " + direction(fieldCollation));
         if (false) {
           // TODO: NULLS FIRST and NULLS LAST
           switch (fieldCollation.nullDirection) {

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -8903,7 +8903,7 @@ void assertSubFunReturns(boolean binary, String s, int start,
           "INTEGER");
       f.checkScalar("least(false, true)", false, "BOOLEAN NOT NULL");
 
-      final SqlOperatorFixture f12 = f0.forOracle(SqlConformanceEnum.ORACLE_12);
+      final SqlOperatorFixture f12 = f.forOracle(SqlConformanceEnum.ORACLE_12);
       f12.checkString("least('on', 'earth')", "earth", "VARCHAR(5) NOT NULL");
       f12.checkString("least('show', 'on', 'earth')", "earth",
           "VARCHAR(5) NOT NULL");

File: testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java
Patch:
@@ -35,7 +35,7 @@
  * CREATE TABLE "emps" (
  *   "empid" INTEGER NOT NULL,
  *   "deptno" INTEGER NOT NULL,
- *   "name" VARCHAR2(10) NOT NULL,
+ *   "name" VARCHAR(10) NOT NULL,
  *   "salary" NUMBER(6, 2) NOT NULL,
  *   "commission" INTEGER);
  * INSERT INTO "emps" VALUES (100, 10, 'Bill', 10000, 1000);
@@ -45,7 +45,7 @@
  *
  * CREATE TABLE "depts" (
  *   "deptno" INTEGER NOT NULL,
- *   "name" VARCHAR2(10) NOT NULL,
+ *   "name" VARCHAR(10) NOT NULL,
  *   "employees" ARRAY OF "Employee",
  *   "location" "Location");
  * INSERT INTO "depts" VALUES (10, 'Sales', null, (-122, 38));

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableSample.java
Patch:
@@ -57,7 +57,7 @@ public static MutableSample of(
     return buf.append("Sample(mode: ")
         .append(params.isBernoulli() ? "bernoulli" : "system")
         .append("rate")
-        .append(params.getSamplingPercentage())
+        .append(params.sampleRate)
         .append("repeatableSeed")
         .append(params.isRepeatable() ? params.getRepeatableSeed() : "-")
         .append(")");

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1574,7 +1574,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
   /** The {@code REPLACE(string, search, replace)} function. Not standard SQL,
    * but in Oracle and Postgres. */
   public static final SqlFunction REPLACE =
-      SqlBasicFunction.create("REPLACE", ReturnTypes.ARG0_NULLABLE_VARYING,
+      SqlBasicFunction.create("REPLACE", ReturnTypes.VARCHAR_NULLABLE,
           OperandTypes.STRING_STRING_STRING, SqlFunctionCategory.STRING);
 
   /** The {@code CONVERT(charValue, srcCharsetName, destCharsetName)}

File: core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
Patch:
@@ -180,7 +180,7 @@ public int getPrecision() {
       writer.keyword("WITH LOCAL TIME ZONE");
     }
 
-    if (charSetName != null) {
+    if (writer.getDialect().supportsCharSet() && charSetName != null) {
       writer.keyword("CHARACTER SET");
       writer.identifier(charSetName, true);
     }

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -22,7 +22,6 @@
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.parser.SqlParserPos;
-import org.apache.calcite.sql.type.MeasureSqlType;
 import org.apache.calcite.sql.type.SqlOperandTypeChecker;
 import org.apache.calcite.sql.type.SqlOperandTypeInference;
 import org.apache.calcite.sql.type.SqlReturnTypeInference;
@@ -49,6 +48,7 @@
 import java.util.function.Supplier;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
+import static org.apache.calcite.sql.type.SqlTypeUtil.isMeasure;
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -539,8 +539,8 @@ public RelDataType inferReturnType(
       }
 
       // MEASURE wrapper should be removed, e.g. MEASURE<DOUBLE> should just be DOUBLE
-      if (returnType instanceof MeasureSqlType) {
-        returnType = returnType.getMeasureElementType();
+      if (isMeasure(returnType) && returnType.getMeasureElementType() != null) {
+        returnType = Objects.requireNonNull(returnType.getMeasureElementType());
       }
 
       if (operandTypeInference != null

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -783,7 +783,7 @@ private static boolean isAny(RelDataType t) {
     return t.getFamily() == SqlTypeFamily.ANY;
   }
 
-  private static boolean isMeasure(RelDataType t) {
+  public static boolean isMeasure(RelDataType t) {
     return t instanceof MeasureSqlType;
   }
 

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -3853,7 +3853,7 @@ private void checkNegWindow(String s, String msg) {
         + "group by deptno, ename";
     f.withSql(sql3)
         .type("RecordType(INTEGER NOT NULL DEPTNO, "
-            + "MEASURE<INTEGER NOT NULL> NOT NULL X, "
+            + "INTEGER NOT NULL X, "
             + "VARCHAR(20) NOT NULL ENAME) NOT NULL");
 
     // you can apply the AGGREGATE function only to measures
@@ -3884,8 +3884,7 @@ private void checkNegWindow(String s, String msg) {
         fixture().withExtendedCatalog()
             .withOperatorTable(operatorTableFor(SqlLibrary.BIG_QUERY));
     f.withSql("select ifnull(count_times_100, 0) from empm")
-        .type("RecordType(MEASURE<DECIMAL(19, 0) NOT NULL> "
-            + "NOT NULL EXPR$0) NOT NULL");
+        .type("RecordType(DECIMAL(19, 0) NOT NULL EXPR$0) NOT NULL");
   }
 
   @Test void testAmbiguousColumnInIn() {

File: testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderExtended.java
Patch:
@@ -139,7 +139,7 @@ protected MockCatalogReaderExtended(RelDataTypeFactory typeFactory,
     registerTable(mockEmpViewTable3);
 
     // Register "EMPM" table.
-    // Same as "EMP" but with a "COUNT_PLUS_100" measure column.
+    // Same as "EMP" but with "COUNT_PLUS_100" and "COUNT_TIMES_100" measure columns.
     final MockTable empmTable =
         MockTable.create(this, salesSchema, "EMPM", false, 14);
     empmTable.addColumn("EMPNO", f.intType, true);
@@ -153,6 +153,8 @@ protected MockCatalogReaderExtended(RelDataTypeFactory typeFactory,
     empmTable.addColumn("SLACKER", f.booleanType);
     empmTable.addColumn("COUNT_PLUS_100",
         f.typeFactory.createMeasureType(f.intType));
+    empmTable.addColumn("COUNT_TIMES_100",
+        f.typeFactory.createMeasureType(f.decimalType));
     registerTable(empmTable);
 
     MockSchema structTypeSchema = new MockSchema("STRUCT");

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -333,7 +333,9 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding,
           Static.RESOURCE.delimiterIsRequired(
               operatorBinding.getOperator().getName(), type.toString()));
     }
-    return type;
+
+    SqlTypeName typeName = SqlTypeUtil.isBinary(type) ? SqlTypeName.VARBINARY : SqlTypeName.VARCHAR;
+    return operatorBinding.getTypeFactory().createSqlType(typeName);
   }
 
   /** The "STRPOS(string, substring)" function. */

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -317,7 +317,8 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
       SqlBasicFunction.create("SPLIT",
           ReturnTypes.ARG0
               .andThen(SqlLibraryOperators::deriveTypeSplit)
-              .andThen(SqlTypeTransforms.TO_ARRAY),
+              .andThen(SqlTypeTransforms.TO_ARRAY)
+              .andThen(SqlTypeTransforms.TO_NULLABLE),
           OperandTypes.or(OperandTypes.CHARACTER_CHARACTER,
               OperandTypes.CHARACTER,
               OperandTypes.BINARY_BINARY,

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java
Patch:
@@ -72,9 +72,9 @@ public static class Builder {
     }
 
     /** Add a map entry to the existing {@link Builder} mapping. */
-    void add(SqlTypeName fromType, Set<SqlTypeName> toTypes) {
+    void add(SqlTypeName toType, Set<SqlTypeName> fromTypes) {
       try {
-        map.put(fromType, sets.get(toTypes));
+        map.put(toType, sets.get(fromTypes));
       } catch (UncheckedExecutionException | ExecutionException e) {
         throw Util.throwAsRuntime("populating SqlTypeAssignmentRules", Util.causeOrSelf(e));
       }

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
Patch:
@@ -379,9 +379,7 @@ default boolean shouldUseDoubleMultiplication(RelDataTypeFactory typeFactory,
           return type2;
         }
 
-        int scale = Math.max(s1, s2);
-        assert scale <= getMaxNumericScale();
-
+        int scale = Math.min(Math.max(s1, s2), getMaxNumericScale());
         int precision = Math.min(p1 - s1, p2 - s2) + Math.max(s1, s2);
         precision = Math.min(precision, getMaxNumericPrecision());
         assert precision > 0;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java
Patch:
@@ -185,7 +185,7 @@ static class StaticFieldDetector extends VisitorImpl<Void> {
     boolean containsStaticField = false;
 
     @Override public Void visit(final FieldDeclaration fieldDeclaration) {
-      containsStaticField = (fieldDeclaration.modifier & Modifier.STATIC) != 0;
+      containsStaticField |= (fieldDeclaration.modifier & Modifier.STATIC) != 0;
       return containsStaticField ? null : super.visit(fieldDeclaration);
     }
   }

File: core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
Patch:
@@ -312,7 +312,7 @@ private boolean check(SqlCallBinding callBinding, boolean throwOnFailure) {
         if (!((SqlSingleOperandTypeChecker) rule).checkSingleOperandType(
             callBinding,
             callBinding.getCall().operand(ord.i),
-            rule.getClass() == FamilyOperandTypeChecker.class ? 0 : ord.i,
+            ord.i,
             throwOnFailure)) {
           if (callBinding.isTypeCoercionEnabled()) {
             return coerceOperands(callBinding, false);

File: core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java
Patch:
@@ -64,7 +64,7 @@ public class CompositeSingleOperandTypeChecker
         getRules();
     if (composition == Composition.SEQUENCE) {
       return rules.get(iFormalOperand).checkSingleOperandType(
-          callBinding, node, 0, throwOnFailure);
+          callBinding, node, iFormalOperand, throwOnFailure);
     }
 
     int typeErrorCount = 0;

File: core/src/main/java/org/apache/calcite/sql/type/IntervalOperandTypeChecker.java
Patch:
@@ -37,8 +37,7 @@ public class IntervalOperandTypeChecker implements SqlSingleOperandTypeChecker {
   }
 
   @Override public boolean checkSingleOperandType(SqlCallBinding callBinding,
-      SqlNode node, int iFormalOperand, boolean throwOnFailure) {
-    final SqlNode operand = callBinding.operand(iFormalOperand);
+      SqlNode operand, int iFormalOperand, boolean throwOnFailure) {
     if (operand instanceof SqlIntervalQualifier) {
       final SqlIntervalQualifier interval = (SqlIntervalQualifier) operand;
       if (predicate.test(interval)) {

File: core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java
Patch:
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.config;
 
+import org.apache.calcite.util.Bug;
+
 import com.google.common.collect.ImmutableSet;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -437,7 +439,7 @@ private static CalciteSystemProperty<String> stringProperty(
   }
 
   private static <T> T firstNonEmpty(@CheckForNull T t0, T t1) {
-    //Bug.upgrade("remove when 18.0 is the minimum Guava version");
+    Bug.upgrade("remove when 18.0 is the minimum Guava version");
     if (t0 != null) {
       return t0;
     }

File: core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
Patch:
@@ -549,7 +549,7 @@ Enumerable<MetaFunction> functions(final MetaSchema schema_, final String catalo
     return Linq4j.asEnumerable(schema.calciteSchema.getFunctionNames())
         .selectMany(name ->
             Linq4j.asEnumerable(schema.calciteSchema.getFunctions(name, true))
-                //exclude materialized views from the result set
+                // exclude materialized views from the result set
                 .where(fn -> !(fn instanceof MaterializedViewTable.MaterializedViewTableMacro))
                 .select(fnx ->
                     new MetaFunction(

File: core/src/main/java/org/apache/calcite/plan/Strong.java
Patch:
@@ -165,7 +165,7 @@ public static boolean allStrong(List<RexNode> operands) {
    * (equivalently, will definitely return null or false). */
   public boolean isNotTrue(RexNode node) {
     switch (node.getKind()) {
-    //TODO Enrich with more possible cases?
+    // TODO Enrich with more possible cases?
     case IS_NOT_NULL:
       return isNull(((RexCall) node).getOperands().get(0));
     case OR:

File: core/src/main/java/org/apache/calcite/rel/metadata/janino/CacheGeneratorUtil.java
Patch:
@@ -209,7 +209,7 @@ private enum CacheKeyStrategy {
 
       /** Returns e.g. ", ignoreNulls". */
       private StringBuilder safeArgList(StringBuilder buff, Method method) {
-        //We ignore the first 2 arguments since they are included other ways.
+        // We ignore the first 2 arguments since they are included other ways.
         for (Ord<Class<?>> t : Ord.zip(method.getParameterTypes())
             .subList(2, method.getParameterCount())) {
           if (Primitive.is(t.e) || RexNode.class.isAssignableFrom(t.e)) {

File: core/src/main/java/org/apache/calcite/rex/package-info.java
Patch:
@@ -33,7 +33,6 @@
  *
  * <h2>Expressions</h2>
  *
- *
  * <p>Every row-expression has a type. (Compare with
  * {@link org.apache.calcite.sql.SqlNode}, which is created before validation,
  * and therefore types may not be available.)

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -479,8 +479,8 @@ public void unparseSqlDatetimeArithmetic(SqlWriter writer,
     writer.sep((SqlKind.PLUS == sqlKind) ? "+" : "-");
     call.operand(1).unparse(writer, leftPrec, rightPrec);
     writer.endList(frame);
-    //Only two parameters are present normally
-    //Checking parameter count to prevent errors
+    // Only two parameters are present normally.
+    // Checking parameter count to prevent errors.
     if (call.getOperandList().size() > 2) {
       call.operand(2).unparse(writer, leftPrec, rightPrec);
     }

File: core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
Patch:
@@ -225,7 +225,7 @@ private static void unparseFloor(SqlWriter writer, SqlCall call) {
     final SqlWriter.Frame frame = writer.startFunCall("DATEADD");
     SqlNode operand = call.operand(1);
     if (operand instanceof SqlIntervalLiteral) {
-      //There is no DATESUB method available, so change the sign.
+      // There is no DATESUB method available, so change the sign.
       unparseSqlIntervalLiteralMssql(
           writer, (SqlIntervalLiteral) operand, sqlKind == SqlKind.MINUS ? -1 : 1);
     } else {

File: core/src/main/java/org/apache/calcite/sql/type/InferTypes.java
Patch:
@@ -54,7 +54,7 @@ private InferTypes() {}
         // because SqlAdvisorValidator produces
         // unknown types for incomplete expressions.
         // Maybe we need to distinguish the two kinds of unknown.
-        //assert !knownType.equals(unknownType);
+        //   assert !knownType.equals(unknownType);
         Arrays.fill(operandTypes, knownType);
       };
 

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -2084,7 +2084,8 @@ private static class TimestampSubConvertlet implements SqlRexConvertlet {
       final TimeUnit unit = first(timeFrame.unit(), TimeUnit.EPOCH);
       final RexNode interval2Sub;
       switch (unit) {
-      //Fractional second units are converted to seconds using their associated multiplier.
+      // Fractional second units are converted to seconds using their
+      // associated multiplier.
       case MICROSECOND:
       case NANOSECOND:
         interval2Sub =

File: core/src/main/java/org/apache/calcite/util/Permutation.java
Patch:
@@ -433,8 +433,6 @@ private void setInternal(int source, int target) {
   /**
    * Checks whether this permutation is valid.
    *
-   *
-   *
    * @param fail Whether to assert if invalid
    * @return Whether valid
    */

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -6417,7 +6417,7 @@ private void checkGetTimestamp(Connection con) throws SQLException {
     Statement statement = con.createStatement();
 
     // Not supported yet. We set timezone using connect-string parameters.
-    //statement.executeUpdate("alter session set timezone = 'gmt-3'");
+    //   statement.executeUpdate("alter session set timezone = 'gmt-3'");
 
     ResultSet rs = statement.executeQuery("SELECT * FROM (VALUES(\n"
         + " TIMESTAMP '1970-01-01 00:00:00',\n"

File: core/src/test/java/org/apache/calcite/test/concurrent/package-info.java
Patch:
@@ -87,7 +87,6 @@
  * <p>The directive &#64;disable means "skip this script". The deault is the
  * antonym &#64;enable.
  *
- *
  * <h3>Error handling:</h3>
  *
  * <p>When a sql command fails, the rest of its section is skipped. However, if
@@ -207,7 +206,6 @@
  *     VAR=VALUE : binds the script variable VAR to the VALUE; VAR must be
  *     declared at the beginning of the script(s) in a &#64;var command.
  *
- *
  * <h3>Example Script</h3>
  *
  * <blockquote><pre>-- redundant:

File: core/src/test/java/org/apache/calcite/util/UtilTest.java
Patch:
@@ -2967,7 +2967,7 @@ private void checkNameMultimap(String s, NameMultimap<Integer> map) {
     assertThat(describe(isLinux("X")), is("is \"X\""));
     assertThat(Unsafe.matches(isLinux("x\ny"), "x\ny"), is(true));
     assertThat(Unsafe.matches(isLinux("x\ny"), "x\r\ny"), is(true));
-    //\n\r is not a valid windows line ending
+    // "\n\r" is not a valid windows line ending
     assertThat(Unsafe.matches(isLinux("x\ny"), "x\n\ry"), is(false));
     assertThat(Unsafe.matches(isLinux("x\ny"), "x\n\ryz"), is(false));
     // left-hand side must be linux or will never match

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidExpressions.java
Patch:
@@ -123,7 +123,7 @@ private DruidExpressions() {
       final DruidSqlOperatorConverter conversion = druidRel.getOperatorConversionMap()
           .get(operator);
       if (conversion == null) {
-        //unknown operator can not translate
+        // unknown operator; can not translate
         return null;
       } else {
         return conversion.toDruidExpression(rexNode, inputRowType, druidRel);
@@ -132,7 +132,8 @@ private DruidExpressions() {
     if (kind == SqlKind.LITERAL) {
       // Translate literal.
       if (RexLiteral.isNullLiteral(rexNode)) {
-        //case the filter/project might yield to unknown let Calcite deal with this for now
+        // case the filter/project might yield to unknown; let Calcite
+        // deal with this for now
         return null;
       } else if (SqlTypeName.NUMERIC_TYPES.contains(sqlTypeName)) {
         return DruidExpressions.numberLiteral((Number) RexLiteral

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
Patch:
@@ -108,7 +108,7 @@ abstract class DruidJsonFilter implements DruidJson {
     }
     final DruidJsonFilter partialFilter;
     if (isNumeric) {
-      //need bound filter since it one of operands is numeric
+      // need bound filter since it one of operands is numeric
       partialFilter =
           new JsonBound(columnName, literalValue, false, literalValue,
               false, true, extractionFunction);

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -851,7 +851,8 @@ protected CalciteConnectionConfig getConnectionConfig() {
       } else if (druidColumn.left != null && druidColumn.right != null) {
        // CASE it is an extraction Dimension
         final String columnPrefix;
-        //@TODO Remove it! if else statement is not really needed it is here to make tests pass.
+        // TODO Remove it! if else statement is not really needed it
+        // is here to make tests pass.
         if (project.getKind() == SqlKind.EXTRACT) {
           columnPrefix =
               EXTRACT_COLUMN_NAME_PREFIX + "_" + requireNonNull(DruidDateTimeUtils

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidSqlCastConverter.java
Patch:
@@ -64,13 +64,13 @@ public class DruidSqlCastConverter implements DruidSqlOperatorConverter {
 
     if (SqlTypeName.CHAR_TYPES.contains(fromType)
         && SqlTypeName.DATETIME_TYPES.contains(toType)) {
-      //case chars to dates
+      // case chars to dates
       return castCharToDateTime(toType == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE
               ? timeZone : DateTimeUtils.UTC_ZONE,
           operandExpression, toType, fromTypeString);
     } else if (SqlTypeName.DATETIME_TYPES.contains(fromType)
         && SqlTypeName.CHAR_TYPES.contains(toType)) {
-      //case dates to chars
+      // case dates to chars
       return castDateTimeToChar(fromType == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE
           ? timeZone : DateTimeUtils.UTC_ZONE, operandExpression, fromType);
     } else if (SqlTypeName.DATETIME_TYPES.contains(fromType)

File: druid/src/main/java/org/apache/calcite/adapter/druid/SubstringOperatorConversion.java
Patch:
@@ -63,7 +63,7 @@ public class SubstringOperatorConversion implements DruidSqlOperatorConverter {
     }
 
     if (call.getOperands().size() > 2) {
-      //case substring from start index with length
+      // case substring from start index with length
       if (!call.getOperands().get(2).isA(SqlKind.LITERAL)) {
         // case it is an expression try to parse it
         length =
@@ -80,7 +80,7 @@ public class SubstringOperatorConversion implements DruidSqlOperatorConverter {
       }
 
     } else {
-      //case substring from index to the end
+      // case substring from index to the end
       length = DruidExpressions.numberLiteral(-1);
     }
     return DruidQuery.format("substring(%s, %s, %s)", arg, startIndex, length);

File: druid/src/test/java/org/apache/calcite/test/DruidAdapter2IT.java
Patch:
@@ -2003,7 +2003,7 @@ private void checkGroupBySingleSortLimit(boolean approx) {
     sql(sqlQuery)
         .explainContains(plan)
         .throws_("Server returned HTTP response code: 500");
-    //@TODO It seems like calcite is not handling 500 error,
+    // TODO It seems like calcite is not handling 500 error,
     // need to catch it and parse exception message from druid,
     // e.g., throws_("/ by zero");
   }

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java
Patch:
@@ -2310,7 +2310,7 @@ private void checkGroupBySingleSortLimit(boolean approx) {
     sql(sqlQuery, FOODMART)
         .explainContains(plan)
         .throws_("Server returned HTTP response code: 500");
-    //@TODO It seems like calcite is not handling 500 error,
+    // TODO It seems like calcite is not handling 500 error,
     // need to catch it and parse exception message from druid,
     // e.g., throws_("/ by zero");
   }

File: file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
Patch:
@@ -161,8 +161,7 @@ Elements getHeadings() throws FileReaderException {
 
     // if we haven't cached the headings, get them
     // TODO: this needs to be reworked to properly cache the headings
-    //if (this.headings == null) {
-    if (true) {
+    if (/* this.headings == null */ true) {
       // first row must contain headings
       Elements headings = iterator.next("th");
       // if not, generate some default column names

File: file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
Patch:
@@ -259,7 +259,7 @@ String read(Element cell) {
             .get(this.selectedElement).ownText());
       } else {
         for (Element child : cell.select(this.selector)) {
-          //String tagName = child.tag().getName();
+          // String tagName = child.tag().getName();
           cellText.add(child.ownText());
         }
       }

File: kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaMessageEnumerator.java
Patch:
@@ -46,7 +46,7 @@ public class KafkaMessageEnumerator<K, V> implements Enumerator<@Nullable Object
   final KafkaRowConverter<K, V> rowConverter;
   private final AtomicBoolean cancelFlag;
 
-  //runtime
+  // runtime
   private final Deque<ConsumerRecord<K, V>> bufferedRecords = new ArrayDeque<>();
   private @Nullable ConsumerRecord<K, V> curRecord;
 

File: kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java
Patch:
@@ -70,7 +70,7 @@ public class KafkaStreamTable implements ScannableTable, StreamableTable {
         Properties consumerConfig = new Properties();
         consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,
             tableOptions.getBootstrapServers());
-        //by default it's <byte[], byte[]>
+        // by default it's <byte[], byte[]>
         consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,
             "org.apache.kafka.common.serialization.ByteArrayDeserializer");
         consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,

File: kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableOptions.java
Patch:
@@ -28,7 +28,7 @@ public final class KafkaTableOptions {
   private String topicName;
   private KafkaRowConverter rowConverter;
   private Map<String, String> consumerParams;
-  //added to inject MockConsumer for testing.
+  // added to inject MockConsumer for testing.
   private Consumer consumer;
 
   public String getBootstrapServers() {

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -1461,7 +1461,7 @@ private static <TSource, TInner, TKey, TResult> Enumerable<TResult> hashJoinWith
                   innerEnumerable = null;
                 } else {
                   innerEnumerable = innerLookup.get(outerKey);
-                  //apply predicate to filter per-row
+                  // apply predicate to filter per-row
                   if (innerEnumerable != null) {
                     final List<TInner> matchedInners = new ArrayList<>();
                     try (Enumerator<TInner> innerEnumerator =

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
Patch:
@@ -320,7 +320,6 @@ protected boolean isMethodDeterministic(Method method) {
    * Checks if new instance creation can be reused. For instance {@code new
    * BigInteger("42")} is effectively final and can be reused.
    *
-   *
    * @param newExpression method to test
    * @return true when the method is deterministic
    */

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
Patch:
@@ -1902,7 +1902,7 @@ public static UnaryExpression negateChecked(Expression expression) {
   public static UnaryExpression negateChecked(Expression expression,
       Method method) {
     throw new UnsupportedOperationException("not implemented");
-    //return makeUnary(ExpressionType.NegateChecked, expression, null, method);
+    // return makeUnary(ExpressionType.NegateChecked, expression, null, method);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMonotonicUnaryFunction.java
Patch:
@@ -37,9 +37,9 @@ public class SqlMonotonicUnaryFunction extends SqlFunction {
   protected SqlMonotonicUnaryFunction(
       String name,
       SqlKind kind,
-      SqlReturnTypeInference returnTypeInference,
+      @Nullable SqlReturnTypeInference returnTypeInference,
       @Nullable SqlOperandTypeInference operandTypeInference,
-      SqlOperandTypeChecker operandTypeChecker,
+      @Nullable SqlOperandTypeChecker operandTypeChecker,
       SqlFunctionCategory funcType) {
     super(
         name,

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -774,6 +774,9 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
   @BaseMessage("SELECT must have a FROM clause")
   ExInst<SqlValidatorException> selectMissingFrom();
 
+  @BaseMessage("SELECT * requires a FROM clause")
+  ExInst<SqlValidatorException> selectStarRequiresFrom();
+
   @BaseMessage("Group function ''{0}'' can only appear in GROUP BY clause")
   ExInst<SqlValidatorException> groupFunctionMustAppearInGroupByClause(String funcName);
 

File: core/src/main/java/org/apache/calcite/sql/SqlAsOperator.java
Patch:
@@ -34,6 +34,8 @@
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * The <code>AS</code> operator associates an expression with an alias.
  */
@@ -131,7 +133,7 @@ protected SqlAsOperator(String name, SqlKind kind, int prec,
     // special case for AS:  never try to derive type for alias
     RelDataType nodeType =
         validator.deriveType(scope, call.operand(0));
-    assert nodeType != null;
+    requireNonNull(nodeType, "nodeType");
     return validateOperands(validator, scope, call);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -207,8 +207,7 @@ protected String getCallSignature(
     return SqlUtil.getOperatorSignature(getOperator(), signatureList);
   }
 
-  @Override public SqlMonotonicity getMonotonicity(@Nullable SqlValidatorScope scope) {
-    Objects.requireNonNull(scope, "scope");
+  @Override public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     // Delegate to operator.
     final SqlCallBinding binding =
         new SqlCallBinding(scope.getValidator(), scope, this);

File: core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
Patch:
@@ -128,7 +128,7 @@ public SqlDataTypeSpec(
     return new SqlDataTypeSpec(typeNameSpec, timeZone, pos);
   }
 
-  @Override public SqlMonotonicity getMonotonicity(@Nullable SqlValidatorScope scope) {
+  @Override public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     return SqlMonotonicity.CONSTANT;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlDynamicParam.java
Patch:
@@ -70,7 +70,7 @@ public int getIndex() {
     validator.validateDynamicParam(this);
   }
 
-  @Override public SqlMonotonicity getMonotonicity(@Nullable SqlValidatorScope scope) {
+  @Override public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     return SqlMonotonicity.CONSTANT;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlIdentifier.java
Patch:
@@ -33,7 +33,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 
 /**
  * A <code>SqlIdentifier</code> is an identifier, possibly compound.
@@ -373,13 +372,12 @@ public boolean isComponentQuoted(int i) {
         && componentPositions.get(i).isQuoted();
   }
 
-  @Override public SqlMonotonicity getMonotonicity(@Nullable SqlValidatorScope scope) {
+  @Override public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     // for "star" column, whether it's static or dynamic return not_monotonic directly.
     if (Util.last(names).equals("") || DynamicRecordType.isDynamicStarColName(Util.last(names))) {
       return SqlMonotonicity.NOT_MONOTONIC;
     }
 
-    Objects.requireNonNull(scope, "scope");
     // First check for builtin functions which don't have parentheses,
     // like "LOCALTIME".
     final SqlValidator validator = scope.getValidator();

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -593,7 +593,7 @@ public static SqlLiteral unchain(SqlNode node) {
     return litmus.succeed();
   }
 
-  @Override public SqlMonotonicity getMonotonicity(@Nullable SqlValidatorScope scope) {
+  @Override public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     return SqlMonotonicity.CONSTANT;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlNode.java
Patch:
@@ -337,7 +337,7 @@ public static boolean equalDeep(
    *
    * @param scope Scope
    */
-  public SqlMonotonicity getMonotonicity(@Nullable SqlValidatorScope scope) {
+  public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     return SqlMonotonicity.NOT_MONOTONIC;
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
Patch:
@@ -107,12 +107,12 @@ public abstract class DelegatingScope implements SqlValidatorScope {
   }
 
   /** If a record type allows implicit references to fields, recursively looks
-   * into the fields. Otherwise returns immediately. */
+   * into the fields. Otherwise, returns immediately. */
   void resolveInNamespace(SqlValidatorNamespace ns, boolean nullable,
       List<String> names, SqlNameMatcher nameMatcher, Path path,
       Resolved resolved) {
     if (names.isEmpty()) {
-      resolved.found(ns, nullable, this, path, null);
+      resolved.found(ns, nullable, this, path, names);
       return;
     }
     final RelDataType rowType = ns.getRowType();

File: core/src/main/java/org/apache/calcite/sql/validate/EmptyScope.java
Patch:
@@ -162,13 +162,13 @@ private void resolve_(final CalciteSchema rootSchema, List<String> names,
           table2 = RelOptTableImpl.create(relOptSchema, rowType, entry, null);
         }
         namespace = new TableNamespace(validator, table2);
-        resolved.found(namespace, false, null, path, remainingNames);
+        resolved.found(namespace, false, this, path, remainingNames);
         return;
       }
       // neither sub-schema nor table
       if (namespace != null
           && !remainingNames.equals(names)) {
-        resolved.found(namespace, false, null, path, remainingNames);
+        resolved.found(namespace, false, this, path, remainingNames);
       }
       return;
     }

File: core/src/main/java/org/apache/calcite/sql/validate/JoinScope.java
Patch:
@@ -97,7 +97,7 @@ public class JoinScope extends ListScope {
     return usingScope;
   }
 
-  @Override public boolean isWithin(@Nullable SqlValidatorScope scope2) {
+  @Override public boolean isWithin(SqlValidatorScope scope2) {
     if (this == scope2) {
       return true;
     }

File: core/src/main/java/org/apache/calcite/sql/validate/ListScope.java
Patch:
@@ -202,7 +202,8 @@ public boolean isChildNullable(int i) {
       final Step path =
           Path.EMPTY.plus(child0.namespace.getRowType(), child0.ordinal,
               child0.name, StructKind.FULLY_QUALIFIED);
-      resolved.found(child0.namespace, child0.nullable, this, path, null);
+      resolved.found(child0.namespace, child0.nullable, this, path,
+          ImmutableList.of());
       return;
     }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -696,7 +696,7 @@ public static void getSchemaObjectMonikers(
     }
   }
 
-  public static @Nullable SelectScope getEnclosingSelectScope(@Nullable SqlValidatorScope scope) {
+  public static @Nullable SelectScope getEnclosingSelectScope(SqlValidatorScope scope) {
     while (scope instanceof DelegatingScope) {
       if (scope instanceof SelectScope) {
         return (SelectScope) scope;

File: core/src/main/java/org/apache/calcite/sql/validate/TableScope.java
Patch:
@@ -19,8 +19,6 @@
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlSelect;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
-
 import java.util.Objects;
 
 /**
@@ -52,7 +50,7 @@ class TableScope extends ListScope {
     return node;
   }
 
-  @Override public boolean isWithin(@Nullable SqlValidatorScope scope2) {
+  @Override public boolean isWithin(SqlValidatorScope scope2) {
     if (this == scope2) {
       return true;
     }

File: core/src/main/java/org/apache/calcite/sql/validate/WithScope.java
Patch:
@@ -20,6 +20,8 @@
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlWithItem;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
@@ -63,7 +65,7 @@ class WithScope extends ListScope {
       final SqlValidatorNamespace ns = validator.getNamespaceOrThrow(withItem);
       final Step path2 = path
           .plus(ns.getRowType(), 0, names.get(0), StructKind.FULLY_QUALIFIED);
-      resolved.found(ns, false, null, path2, null);
+      resolved.found(ns, false, this, path2, ImmutableList.of());
       return;
     }
     super.resolveTable(names, nameMatcher, path, resolved);

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionFactory.java
Patch:
@@ -32,6 +32,7 @@
  * @see SqlValidator.Config#withTypeCoercionFactory
  */
 @API(status = API.Status.EXPERIMENTAL, since = "1.23")
+@FunctionalInterface
 public interface TypeCoercionFactory {
 
   /**

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -877,7 +877,7 @@ protected UnifyRule(int slotCount, Operand queryOperand,
     }
 
     /**
-     * <p>Applies this rule to a particular node in a query. The goal is
+     * Applies this rule to a particular node in a query. The goal is
      * to convert {@code query} into {@code target}. Before the rule is
      * invoked, Calcite has made sure that query's children are equivalent
      * to target's children.

File: core/src/main/java/org/apache/calcite/plan/volcano/IterativeRuleDriver.java
Patch:
@@ -22,7 +22,7 @@
 import org.slf4j.Logger;
 
 /***
- * <p>The algorithm executes repeatedly. The exact rules
+ * The algorithm executes repeatedly. The exact rules
  * that may be fired varies.
  *
  * <p>The planner iterates over the rule matches presented

File: core/src/main/java/org/apache/calcite/rex/RexVisitorImpl.java
Patch:
@@ -119,7 +119,7 @@ protected RexVisitorImpl(boolean deep) {
   }
 
   /**
-   * <p>Visits an array of expressions, returning the logical 'and' of their
+   * Visits an array of expressions, returning the logical 'and' of their
    * results.
    *
    * <p>If any of them returns false, returns false immediately; if they all
@@ -141,7 +141,7 @@ public static boolean visitArrayAnd(
   }
 
   /**
-   * <p>Visits an array of expressions, returning the logical 'or' of their
+   * Visits an array of expressions, returning the logical 'or' of their
    * results.
    *
    * <p>If any of them returns true, returns true immediately; if they all

File: core/src/main/java/org/apache/calcite/sql/SqlDescriptorOperator.java
Patch:
@@ -25,7 +25,7 @@
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
- * <p>DESCRIPTOR appears as an argument in a function. DESCRIPTOR accepts a list of
+ * DESCRIPTOR appears as an argument in a function. DESCRIPTOR accepts a list of
  * identifiers that represent a list of names. The interpretation of names is left
  * to the function.
  *

File: core/src/main/java/org/apache/calcite/util/Glossary.java
Patch:
@@ -29,7 +29,7 @@ public interface Glossary {
 
   // CHECKSTYLE: OFF
   /**
-   * <p>This table shows how and where the Gang of Four patterns are applied.
+   * This table shows how and where the Gang of Four patterns are applied.
    * The table uses information from the GoF book and from a course on
    * advanced object design taught by Craig Larman.
    *

File: core/src/test/java/org/apache/calcite/rex/RexProgramBuilderBase.java
Patch:
@@ -251,7 +251,7 @@ protected RexNode abstractCast(RexNode e, RelDataType type) {
    * <p>Tries to expand the cast, and therefore the result may be something
    * other than a {@link RexCall} to the CAST operator, such as a
    * {@link RexLiteral}.
-
+   *
    * @param e input node
    * @param type type to cast to
    * @return input node converted to given type

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -474,8 +474,7 @@ private void addTableMacro(Connection connection, Method method) throws SQLExcep
     connection.close();
   }
 
-  /**
-   * <p>Test case for
+  /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-3423">[CALCITE-3423]
    * Support using CAST operation and BOOLEAN type value in table macro</a>. */
   @Test void testTableMacroWithCastOrBoolean() throws SQLException {

File: core/src/test/java/org/apache/calcite/util/graph/DirectedGraphTest.java
Patch:
@@ -33,9 +33,9 @@
 import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.hasToString;
-import static org.hamcrest.collection.IsEmptyCollection.empty;
 import static org.hamcrest.collection.IsIterableWithSize.iterableWithSize;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertNotNull;

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.function.Consumer;
 
 /**
- * <p>"Iterator" which retrieves results lazily and in batches. Uses
+ * "Iterator" which retrieves results lazily and in batches. Uses
  * <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html">Elastic Scrolling API</a>
  * to optimally consume large search results.
  *

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -321,7 +321,7 @@ public static <TSource> Float average(Enumerable<TSource> source,
   }
 
   /**
-   * <p>Analogous to LINQ's Enumerable.Cast extension method.
+   * Analogous to LINQ's Enumerable.Cast extension method.
    *
    * @param clazz Target type
    * @param <T2> Target type
@@ -1644,7 +1644,7 @@ public static <TSource> TSource last(Enumerable<TSource> enumerable) {
   }
 
   /**
-   * <p>Fetches blocks of size {@code batchSize} from {@code outer},
+   * Fetches blocks of size {@code batchSize} from {@code outer},
    * storing each block into a list ({@code outerValues}).
    * For each block, it uses the {@code inner} function to
    * obtain an enumerable with the correlated rows from the right (inner) input.

File: linq4j/src/main/java/org/apache/calcite/linq4j/QueryableDefaults.java
Patch:
@@ -218,7 +218,7 @@ public static <T> Long averageNullableLong(Queryable<T> queryable,
   }
 
   /**
-   * <p>Analogous to LINQ's Enumerable.Cast extension method.
+   * Analogous to LINQ's Enumerable.Cast extension method.
    *
    * @param clazz Target type
    * @param <T2> Target type

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Blocks.java
Patch:
@@ -19,7 +19,7 @@
 import static java.util.Objects.requireNonNull;
 
 /**
- * <p>Helper methods concerning {@link BlockStatement}s.
+ * Helper methods concerning {@link BlockStatement}s.
  *
  * @see BlockBuilder
  */

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expression.java
Patch:
@@ -19,7 +19,7 @@
 import java.lang.reflect.Type;
 
 /**
- * <p>Analogous to LINQ's System.Linq.Expression.
+ * Analogous to LINQ's System.Linq.Expression.
  */
 public abstract class Expression extends AbstractNode {
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Statement.java
Patch:
@@ -19,7 +19,7 @@
 import java.lang.reflect.Type;
 
 /**
- * <p>Statement.
+ * Statement.
  */
 public abstract class Statement extends AbstractNode {
   protected Statement(ExpressionType nodeType, Type type) {

File: core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
Patch:
@@ -426,6 +426,9 @@ public static SqlOperandTypeChecker variadic(
   public static final SqlSingleOperandTypeChecker TIMESTAMP =
       family(SqlTypeFamily.TIMESTAMP);
 
+  public static final SqlSingleOperandTypeChecker DATE_OR_TIMESTAMP =
+      DATE.or(TIMESTAMP);
+
   /** Type-checker that matches "TIMESTAMP WITH LOCAL TIME ZONE" but not other
    * members of the "TIMESTAMP" family (e.g. "TIMESTAMP"). */
   public static final SqlSingleOperandTypeChecker TIMESTAMP_LTZ =

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -8232,7 +8232,7 @@ public Table create(
         if (employees == null) {
           employees = Collections.emptyList();
         }
-        return JdbcFrontLinqBackTest.mutable(name, employees);
+        return JdbcFrontLinqBackTest.mutable(name, employees, false);
       case "DEPARTMENTS":
         clazz = Department.class;
         array = new HrSchema().depts;

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -1542,7 +1542,7 @@ private static Comparable zeroValue(RelDataType type) {
     case TIME_WITH_LOCAL_TIME_ZONE:
       return new TimeString(0, 0, 0);
     case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
-      return new TimestampString(0, 0, 0, 0, 0, 0);
+      return new TimestampString(0, 1, 1, 0, 0, 0);
     default:
       throw Util.unexpected(type.getSqlTypeName());
     }

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -720,9 +720,8 @@ private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,
         builder.push(e.rel);
         // fall through
       default:
-        fields.add(builder.alias(trueLiteral, "i"));
-        builder.project(fields);
-        builder.distinct();
+        builder.aggregate(builder.groupKey(fields),
+            builder.literalAgg(true).as("i"));
       }
     }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlAnyValueAggFunction.java
Patch:
@@ -56,7 +56,7 @@ public SqlAnyValueAggFunction(SqlKind kind) {
   //~ Methods ----------------------------------------------------------------
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
-    if (clazz == SqlSplittableAggFunction.class) {
+    if (clazz.isInstance(SqlSplittableAggFunction.SelfSplitter.INSTANCE)) {
       return clazz.cast(SqlSplittableAggFunction.SelfSplitter.INSTANCE);
     }
     return super.unwrap(clazz);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlBitOpAggFunction.java
Patch:
@@ -57,7 +57,7 @@ public SqlBitOpAggFunction(SqlKind kind) {
   }
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
-    if (clazz == SqlSplittableAggFunction.class) {
+    if (clazz.isInstance(SqlSplittableAggFunction.SelfSplitter.INSTANCE)) {
       return clazz.cast(SqlSplittableAggFunction.SelfSplitter.INSTANCE);
     }
     return super.unwrap(clazz);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCountAggFunction.java
Patch:
@@ -92,7 +92,7 @@ public SqlCountAggFunction(String name,
   }
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
-    if (clazz == SqlSplittableAggFunction.class) {
+    if (clazz.isInstance(SqlSplittableAggFunction.CountSplitter.INSTANCE)) {
       return clazz.cast(SqlSplittableAggFunction.CountSplitter.INSTANCE);
     }
     return super.unwrap(clazz);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMinMaxAggFunction.java
Patch:
@@ -146,7 +146,7 @@ public int getMinMaxKind() {
   }
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
-    if (clazz == SqlSplittableAggFunction.class) {
+    if (clazz.isInstance(SqlSplittableAggFunction.SelfSplitter.INSTANCE)) {
       return clazz.cast(SqlSplittableAggFunction.SelfSplitter.INSTANCE);
     }
     return super.unwrap(clazz);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSingleValueAggFunction.java
Patch:
@@ -82,7 +82,7 @@ public RelDataType getType() {
   }
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
-    if (clazz == SqlSplittableAggFunction.class) {
+    if (clazz.isInstance(SqlSplittableAggFunction.SelfSplitter.INSTANCE)) {
       return clazz.cast(SqlSplittableAggFunction.SelfSplitter.INSTANCE);
     }
     return super.unwrap(clazz);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSumAggFunction.java
Patch:
@@ -80,7 +80,7 @@ public RelDataType getType() {
   }
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
-    if (clazz == SqlSplittableAggFunction.class) {
+    if (clazz.isInstance(SqlSplittableAggFunction.SumSplitter.INSTANCE)) {
       return clazz.cast(SqlSplittableAggFunction.SumSplitter.INSTANCE);
     }
     return super.unwrap(clazz);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java
Patch:
@@ -71,7 +71,7 @@ public SqlSumEmptyIsZeroAggFunction() {
   }
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
-    if (clazz == SqlSplittableAggFunction.class) {
+    if (clazz.isInstance(SqlSplittableAggFunction.Sum0Splitter.INSTANCE)) {
       return clazz.cast(SqlSplittableAggFunction.Sum0Splitter.INSTANCE);
     }
     return super.unwrap(clazz);

File: core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
Patch:
@@ -92,7 +92,7 @@ public enum MappingType {
    * An inverse function has a source for every target, but a source might
    * have 0, 1 or more targets.
    *
-   * <p>Obeys the constaints {@link MappingType#isMandatorySource()},
+   * <p>Obeys the constraints {@link MappingType#isMandatorySource()},
    * {@link MappingType#isSingleSource()}.
    *
    * <p>Similar types:

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -959,8 +959,8 @@ public static RelNode createSingleValueAggRel(
     for (int i = 0; i < aggCallCnt; i++) {
       aggCalls.add(
           AggregateCall.create(SqlStdOperatorTable.SINGLE_VALUE, false, false,
-              false, ImmutableList.of(i), -1, null, RelCollations.EMPTY, 0, rel,
-              null, null));
+              false, ImmutableList.of(), ImmutableList.of(i), -1,
+              null, RelCollations.EMPTY, 0, rel, null, null));
     }
 
     return LogicalAggregate.create(rel, ImmutableList.of(), ImmutableBitSet.of(),

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1979,6 +1979,7 @@ public static MutableAggregate permute(MutableAggregate aggregate,
               newAggCall =
                   AggregateCall.create(aggFunction, aggregateCall.isDistinct(),
                       aggregateCall.isApproximate(), aggregateCall.ignoreNulls(),
+                      aggregateCall.rexList,
                       ImmutableList.of(target.groupSet.cardinality() + i), -1,
                       aggregateCall.distinctKeys, aggregateCall.collation,
                       aggregateCall.type, aggregateCall.name);
@@ -2048,7 +2049,7 @@ public static MutableAggregate permute(MutableAggregate aggregate,
     }
     return AggregateCall.create(aggregation,
         queryAggCall.isDistinct(), queryAggCall.isApproximate(),
-        queryAggCall.ignoreNulls(),
+        queryAggCall.ignoreNulls(), queryAggCall.rexList,
         newArgList, -1, queryAggCall.distinctKeys,
         queryAggCall.collation, queryAggCall.type,
         queryAggCall.name);

File: core/src/main/java/org/apache/calcite/rel/core/Window.java
Patch:
@@ -368,7 +368,8 @@ public List<AggregateCall> getAggregateCalls(Window windowRel) {
           final RexWinAggCall aggCall = aggCalls.get(index);
           final SqlAggFunction op = (SqlAggFunction) aggCall.getOperator();
           return AggregateCall.create(op, aggCall.distinct, false,
-              aggCall.ignoreNulls, getProjectOrdinals(aggCall.getOperands()),
+              aggCall.ignoreNulls, ImmutableList.of(),
+              getProjectOrdinals(aggCall.getOperands()),
               -1, null, RelCollations.EMPTY,
               aggCall.getType(), fieldNames.get(aggCall.ordinal));
         }

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
Patch:
@@ -338,7 +338,8 @@ private AggregateCall toAggCall(Map<String, Object> jsonAggCall) {
     final RelDataType type =
         relJson.toType(cluster.getTypeFactory(), jsonAggType);
     final String name = (String) jsonAggCall.get("name");
-    return AggregateCall.create(aggregation, distinct, false, false, operands,
+    return AggregateCall.create(aggregation, distinct, false, false,
+        ImmutableList.of(), operands,
         filterOperand == null ? -1 : filterOperand,
         null, RelCollations.EMPTY, type, name);
   }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -147,7 +147,7 @@ public AggregateFilterTransposeRule(RelOptRuleOperand operand,
         topAggCallList.add(
             AggregateCall.create(rollup, aggregateCall.isDistinct(),
                 aggregateCall.isApproximate(), aggregateCall.ignoreNulls(),
-                ImmutableList.of(i++), -1,
+                aggregateCall.rexList, ImmutableList.of(i++), -1,
                 aggregateCall.distinctKeys, aggregateCall.collation,
                 aggregateCall.type, aggregateCall.name));
       }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -215,7 +215,7 @@ public AggregateUnionTransposeRule(Class<? extends Aggregate> aggregateClass,
       AggregateCall newCall =
           AggregateCall.create(aggFun, origCall.isDistinct(),
               origCall.isApproximate(), origCall.ignoreNulls(),
-              ImmutableList.of(groupCount + ord.i), -1,
+              origCall.rexList, ImmutableList.of(groupCount + ord.i), -1,
               origCall.distinctKeys, origCall.collation,
               groupCount, input, aggType, origCall.getName());
       newCalls.add(newCall);

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectAggregateMergeRule.java
Patch:
@@ -165,8 +165,8 @@ private static int findSum0(RelDataTypeFactory typeFactory, AggregateCall sum,
       List<AggregateCall> aggCallList) {
     final AggregateCall sum0 =
         AggregateCall.create(SqlStdOperatorTable.SUM0, sum.isDistinct(),
-            sum.isApproximate(), sum.ignoreNulls(), sum.getArgList(),
-            sum.filterArg, sum.distinctKeys, sum.collation,
+            sum.isApproximate(), sum.ignoreNulls(), sum.rexList,
+            sum.getArgList(), sum.filterArg, sum.distinctKeys, sum.collation,
             typeFactory.createTypeWithNullability(sum.type, false), null);
     final int i = aggCallList.indexOf(sum0);
     if (i >= 0) {

File: core/src/test/java/org/apache/calcite/materialize/NormalizationTrimFieldTest.java
Patch:
@@ -86,7 +86,7 @@ public static Frameworks.ConfigBuilder config() {
     final AggregateCall call =
         AggregateCall.create(count.getAggregation(),
             count.isDistinct(), count.isApproximate(),
-            count.ignoreNulls(), ImmutableList.of(3),
+            count.ignoreNulls(), count.rexList, ImmutableList.of(3),
             count.filterArg, null, count.collation,
             count.getType(), count.getName());
     final RelNode query =

File: core/src/test/java/org/apache/calcite/plan/volcano/TraitPropagationTest.java
Patch:
@@ -171,7 +171,8 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
       // aggregate on s, count
       AggregateCall aggCall =
           AggregateCall.create(SqlStdOperatorTable.COUNT,
-              false, false, false, Collections.singletonList(1), -1,
+              false, false, false, ImmutableList.of(),
+              Collections.singletonList(1), -1,
               null, RelCollations.EMPTY, sqlBigInt, "cnt");
       RelNode agg =
           new LogicalAggregate(cluster,

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java
Patch:
@@ -684,8 +684,7 @@ private static String toSql(RelNode root, SqlDialect dialect,
         + "INNER JOIN "
         + "(SELECT 1 AS \"K\"\n"
         + "FROM (SELECT COUNT(\"ENAME\") AS \"DUMMY\"\n"
-        + "FROM \"scott\".\"EMP\") AS \"t0\") AS \"t1\" "
-        + "ON \"t\".\"K\" = \"t1\".\"K\"");
+        + "FROM \"scott\".\"EMP\") AS \"t0\") AS \"t1\" ON \"t\".\"K\" = \"t1\".\"K\"");
   }
 
   /** Tests GROUP BY ROLLUP of two columns. The SQL for MySQL has

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1898,8 +1898,8 @@ private void checkAverageRowSize(RelOptCluster cluster, RelOptTable empTable,
             bitSetOf(2, 0),
             ImmutableList.of(),
             ImmutableList.of(
-                AggregateCall.create(SqlStdOperatorTable.COUNT,
-                    false, false, false, ImmutableIntList.of(),
+                AggregateCall.create(SqlStdOperatorTable.COUNT, false, false,
+                    false, ImmutableList.of(), ImmutableIntList.of(),
                     -1, null, RelCollations.EMPTY, 2, join, null, null)));
     rowSize = mq.getAverageRowSize(aggregate);
     columnSizes = mq.getAverageColumnSizes(aggregate);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCastFunction.java
Patch:
@@ -147,7 +147,7 @@ private static RelDataType createTypeWithNullabilityFromExpr(RelDataTypeFactory
       RelDataType newElementType =
           createTypeWithNullabilityFromExpr(
               typeFactory, expressionElementType, targetElementType, safe);
-      return isArray(expressionType)
+      return isArray(targetType)
           ? SqlTypeUtil.createArrayType(typeFactory, newElementType, isNullable)
           : SqlTypeUtil.createMultisetType(typeFactory, newElementType, isNullable);
     }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -6990,6 +6990,8 @@ void testGroupExpressionEquivalenceParams() {
         .columnType("VARCHAR(5) ARRAY NOT NULL");
     sql("select cast(multiset[1,null,2] as int multiset) from (values (1))")
         .columnType("INTEGER MULTISET NOT NULL");
+    sql("select cast(array[1,null,2] as int multiset) from (values (1))")
+        .columnType("INTEGER MULTISET NOT NULL");
 
     // test array type.
     sql("select cast(\"intArrayType\" as int array) from COMPLEXTYPES.CTC_T1")

File: core/src/main/java/org/apache/calcite/sql/validate/SqlAbstractConformance.java
Patch:
@@ -141,7 +141,7 @@ public abstract class SqlAbstractConformance implements SqlConformance {
     return SqlConformanceEnum.DEFAULT.semantics();
   }
 
-  @Override public boolean allowCoercionStringToArray() {
-    return SqlConformanceEnum.DEFAULT.allowCoercionStringToArray();
+  @Override public boolean allowLenientCoercion() {
+    return SqlConformanceEnum.DEFAULT.allowLenientCoercion();
   }
 }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlDelegatingConformance.java
Patch:
@@ -147,8 +147,7 @@ protected SqlDelegatingConformance(SqlConformance delegate) {
     return delegate.semantics();
   }
 
-  @Override public boolean allowCoercionStringToArray() {
-    return delegate.allowCoercionStringToArray();
+  @Override public boolean allowLenientCoercion() {
+    return delegate.allowLenientCoercion();
   }
-
 }

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.SqlOperandMetadata;
 import org.apache.calcite.sql.type.SqlTypeFamily;
+import org.apache.calcite.sql.type.SqlTypeMappingRule;
 import org.apache.calcite.sql.type.SqlTypeUtil;
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
@@ -630,11 +631,12 @@ && coerceOperandType(binding.getScope(), binding.getCall(), i, implicitType)
     final List<RelDataTypeField> sourceFields = sourceRowType.getFieldList();
     final List<RelDataTypeField> targetFields = targetRowType.getFieldList();
     final int sourceCount = sourceFields.size();
+    SqlTypeMappingRule mappingRule = validator.getTypeMappingRule();
     for (int i = 0; i < sourceCount; i++) {
       RelDataType sourceType = sourceFields.get(i).getType();
       RelDataType targetType = targetFields.get(i).getType();
       if (!SqlTypeUtil.equalSansNullability(validator.getTypeFactory(), sourceType, targetType)
-          && !SqlTypeUtil.canCastFrom(targetType, sourceType, true)) {
+          && !SqlTypeUtil.canCastFrom(targetType, sourceType, mappingRule)) {
         // Returns early if types not equals and can not do type coercion.
         return false;
       }

File: core/src/main/java/org/apache/calcite/model/JsonType.java
Patch:
@@ -29,7 +29,8 @@
 /**
  * Type schema element.
  *
- * <p>Occurs within {@link JsonMapSchema#tables}.
+ * <p>Occurs within {@link JsonMapSchema#types},
+ * {@link JsonRoot#types}.
  *
  * @see JsonRoot Description of schema elements
  */

File: core/src/main/java/org/apache/calcite/model/ModelHandler.java
Patch:
@@ -196,6 +196,9 @@ public void visit(JsonRoot jsonRoot) {
     final Pair<@Nullable String, SchemaPlus> pair =
         Pair.of(null, connection.getRootSchema());
     schemaStack.push(pair);
+    for (JsonType rootType : jsonRoot.types) {
+      rootType.accept(this);
+    }
     for (JsonSchema schema : jsonRoot.schemas) {
       schema.accept(this);
     }

File: core/src/test/java/org/apache/calcite/util/format/FormatElementEnumTest.java
Patch:
@@ -28,8 +28,9 @@
  */
 class FormatElementEnumTest {
   @Test void testDay() {
-    assertEquals(
-        FormatElementEnum.DAY.format(Date.from(Instant.parse("2014-09-30T10:00:00Z"))),
+    StringBuilder ts = new StringBuilder();
+    FormatElementEnum.DAY.format(ts, Date.from(Instant.parse("2014-09-30T10:00:00Z")));
+    assertEquals(ts.toString(),
         "Tuesday");
   }
 }

File: core/src/main/java/org/apache/calcite/rel/rules/JoinDeriveIsNotNullFilterRule.java
Patch:
@@ -62,9 +62,9 @@ public JoinDeriveIsNotNullFilterRule(Config config) {
     final RelMetadataQuery mq = call.getMetadataQuery();
 
     final ImmutableBitSet.Builder notNullableKeys = ImmutableBitSet.builder();
-    RelOptUtil.conjunctions(join.getCondition()).forEach(node -> {
-      if (Strong.isStrong(node)) {
-        notNullableKeys.addAll(RelOptUtil.InputFinder.bits(node));
+    RelOptUtil.InputFinder.bits(join.getCondition()).forEach(bit -> {
+      if (Strong.isNotTrue(join.getCondition(), ImmutableBitSet.of(bit))) {
+        notNullableKeys.set(bit);
       }
     });
     final List<Integer> leftKeys = new ArrayList<>();

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -90,6 +90,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "TABLE(CATALOG.SALES.EMPTY_PRODUCTS)",
           "TABLE(CATALOG.SALES.EMP_ADDRESS)",
           "TABLE(CATALOG.SALES.DEPT)",
+          "TABLE(CATALOG.SALES.DEPTNULLABLES)",
           "TABLE(CATALOG.SALES.DEPT_SINGLE)",
           "TABLE(CATALOG.SALES.DEPT_NESTED)",
           "TABLE(CATALOG.SALES.DEPT_NESTED_EXPANDED)",

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -502,6 +502,9 @@ ExInst<SqlValidatorException> intervalFieldExceedsPrecision(Number a0,
   @BaseMessage("Invalid type ''{0}'' in ORDER BY clause of ''{1}'' function. Only NUMERIC types are supported")
   ExInst<SqlValidatorException> unsupportedTypeInOrderBy(String a0, String a1);
 
+  @BaseMessage("Invalid type ''{0}'' in ''{1}'' function. Only ''{2}'' type is supported")
+  ExInst<SqlValidatorException> unsupportedTypeInConvertFunc(String a0, String a1, String a2);
+
   @BaseMessage("''{0}'' requires precisely one ORDER BY key")
   ExInst<SqlValidatorException> orderByRequiresOneKey(String a0);
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -347,6 +347,8 @@ public enum BuiltInMethod {
   ASCII(SqlFunctions.class, "ascii", String.class),
   CHAR_FROM_ASCII(SqlFunctions.class, "charFromAscii", int.class),
   CHAR_FROM_UTF8(SqlFunctions.class, "charFromUtf8", int.class),
+  CONVERT(SqlFunctions.class, "convertWithCharset", String.class, String.class,
+      String.class),
   REPEAT(SqlFunctions.class, "repeat", String.class, int.class),
   SPACE(SqlFunctions.class, "space", int.class),
   SOUNDEX(SqlFunctions.class, "soundex", String.class),

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterStructsTest.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.rel.rel2sql;
 
-import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.sql.dialect.CalciteSqlDialect;
 import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.test.CalciteAssert;
@@ -37,7 +36,7 @@ class RelToSqlConverterStructsTest {
   private RelToSqlConverterTest.Sql sql(String sql) {
     return new RelToSqlConverterTest.Sql(CalciteAssert.SchemaSpec.MY_DB, sql,
         CalciteSqlDialect.DEFAULT, SqlParser.Config.DEFAULT, ImmutableSet.of(),
-        UnaryOperator.identity(), null, ImmutableList.of(), RelDataTypeSystem.DEFAULT);
+        UnaryOperator.identity(), null, ImmutableList.of());
   }
 
   @Test void testNestedSchemaSelectStar() {

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -5358,7 +5358,7 @@ private static String list(String sep, String before, int count) {
   }
 
   @Test void testUserDefinedConformance() {
-    final SqlAbstractConformance custom =
+    final SqlConformance custom =
         new SqlDelegatingConformance(SqlConformanceEnum.DEFAULT) {
           public boolean isBangEqualAllowed() {
             return true;

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectPullUpConstantsRule.java
Patch:
@@ -160,7 +160,7 @@ public AggregateProjectPullUpConstantsRule(
           RelDataType originalType =
               aggregate.getRowType().getFieldList().get(projects.size()).getType();
           if (!originalType.equals(rexNode.getType())) {
-            expr = rexBuilder.makeCast(originalType, rexNode, true);
+            expr = rexBuilder.makeCast(originalType, rexNode, true, false);
           } else {
             expr = rexNode;
           }

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.calcite.rel.logical.LogicalProject;
 import org.apache.calcite.rel.logical.LogicalWindow;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
+import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rex.RexBuilder;
 import org.apache.calcite.rex.RexCall;
@@ -959,8 +960,8 @@ protected static class RexReplacer extends RexShuttle {
         // If we make 'abc' of type VARCHAR(4), we may later encounter
         // the same expression in a Project's digest where it has
         // type VARCHAR(3), and that's wrong.
-        replacement =
-            simplify.rexBuilder.makeAbstractCast(call.getType(), replacement);
+        RelDataType type = call.getType();
+        replacement = simplify.rexBuilder.makeAbstractCast(type, replacement, false);
       }
       return replacement;
     }

File: core/src/main/java/org/apache/calcite/rel/rules/UnionPullUpConstantsRule.java
Patch:
@@ -98,7 +98,7 @@ public UnionPullUpConstantsRule(Class<? extends Union> unionClass,
         if (constant.getType().equals(field.getType())) {
           topChildExprs.add(constant);
         } else {
-          topChildExprs.add(rexBuilder.makeCast(field.getType(), constant, true));
+          topChildExprs.add(rexBuilder.makeCast(field.getType(), constant, true, false));
         }
         topChildExprsFields.add(field.getName());
       } else {

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -156,9 +156,9 @@ protected void apply(RelOptRuleCall call, @Nullable LogicalProject project,
           ++k;
           RexNode e = projectExpr.accept(shuttle);
           if (RexLiteral.isNullLiteral(e)) {
-            e =
-                rexBuilder.makeAbstractCast(
-                    project.getRowType().getFieldList().get(k).getType(), e);
+            RelDataType type =
+                project.getRowType().getFieldList().get(k).getType();
+            e = rexBuilder.makeAbstractCast(type, e, false);
           }
           reducibleExps.add(e);
         }

File: core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
Patch:
@@ -74,6 +74,7 @@ public static RexCallBinding create(RelDataTypeFactory typeFactory,
             : call.getOperands();
     switch (call.getKind()) {
     case CAST:
+    case SAFE_CAST:
       return new RexCastCallBinding(typeFactory, call.getOperator(),
           operands, call.getType(), inputCollations);
     default:

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -2973,7 +2973,8 @@ public ExprSimplifier(RexSimplify simplify, RexUnknownAs unknownAs,
       if (simplifiedNode.getType().equals(call.getType())) {
         return simplifiedNode;
       }
-      return simplify.rexBuilder.makeCast(call.getType(), simplifiedNode, matchNullability);
+      return simplify.rexBuilder.makeCast(call.getType(), simplifiedNode,
+          matchNullability, false);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlSplittableAggFunction.java
Patch:
@@ -302,7 +302,7 @@ abstract class AbstractSumSplitter implements SqlSplittableAggFunction {
         break;
       case 2:
         node = rexBuilder.makeCall(SqlStdOperatorTable.MULTIPLY, merges);
-        node = rexBuilder.makeAbstractCast(aggregateCall.type, node);
+        node = rexBuilder.makeAbstractCast(aggregateCall.type, node, false);
         break;
       default:
         throw new AssertionError("unexpected count " + merges);

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -5454,7 +5454,7 @@ ImmutableList<RelNode> retrieveCursors() {
         subQuery = requireNonNull(getSubQuery(expr, null));
         rex = requireNonNull(subQuery.expr);
         return StandardConvertletTable.castToValidatedType(expr, rex,
-            validator(), rexBuilder);
+            validator(), rexBuilder, false);
 
       case SELECT:
       case EXISTS:

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -303,6 +303,7 @@ public enum BuiltInMethod {
       Calendar.class),
   TIME_ZONE_GET_OFFSET(TimeZone.class, "getOffset", long.class),
   LONG_VALUE(Number.class, "longValue"),
+  STRING_TO_UPPER(String.class, "toUpperCase"),
   COMPARATOR_COMPARE(Comparator.class, "compare", Object.class, Object.class),
   COLLECTIONS_REVERSE_ORDER(Collections.class, "reverseOrder"),
   COLLECTIONS_EMPTY_LIST(Collections.class, "emptyList"),

File: core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java
Patch:
@@ -664,12 +664,12 @@ private void splitJoinConditionHelper(RexNode joinCond, List<Integer> expLeftKey
             rexBuilder.makeCast(
                 fieldTypeEmpnoNullable,
                 RexInputRef.of(0, agg.getRowType()),
-                true),
+                true, false),
             RexInputRef.of(1, agg.getRowType()),
             rexBuilder.makeCast(
                 fieldTypeJobCntNullable,
                 RexInputRef.of(2, agg.getRowType()),
-                true))
+                true, false))
         .build();
     assertThat(castNode.explain(), is(expectNode.explain()));
 

File: core/src/test/java/org/apache/calcite/rex/RexProgramBuilderBase.java
Patch:
@@ -241,7 +241,7 @@ protected RexNode case_(Iterable<? extends RexNode> nodes) {
    * @return call to CAST operator
    */
   protected RexNode abstractCast(RexNode e, RelDataType type) {
-    return rexBuilder.makeAbstractCast(type, e);
+    return rexBuilder.makeAbstractCast(type, e, false);
   }
 
   /**

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -224,6 +224,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(ROW)",
           "KEYWORD(ROW_NUMBER)",
           "KEYWORD(RUNNING)",
+          "KEYWORD(SAFE_CAST)",
           "KEYWORD(SECOND)",
           "KEYWORD(SESSION_USER)",
           "KEYWORD(SOME)",

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
Patch:
@@ -357,7 +357,8 @@ private List<RexNode> projects(RelDataType inputType, RelDataType outputType) {
           projectionExprs.add(fieldProject);
         } else {
           // Different types, CAST is required
-          projectionExprs.add(getRexBuilder().makeCast(outputField.getType(), fieldProject));
+          projectionExprs.add(
+              getRexBuilder().makeCast(outputField.getType(), fieldProject));
         }
       } else {
         final RelDataType columnType = outputField.getType();

File: testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java
Patch:
@@ -230,7 +230,7 @@ public RexNode timeLiteral(TimeString t) {
     }
 
     public RexNode cast(RelDataType type, RexNode exp) {
-      return rexBuilder.makeCast(type, exp, true);
+      return rexBuilder.makeCast(type, exp, true, false);
     }
 
     void checkImplies(RexNode node1, RexNode node2) {

File: testkit/src/main/java/org/apache/calcite/sql/test/AbstractSqlTester.java
Patch:
@@ -325,9 +325,10 @@ public static String buildQueryAgg(String expression) {
    * @return Query that evaluates a scalar expression
    */
   protected String buildQuery2(SqlTestFactory factory, String expression) {
-    if (expression.matches("(?i).*percentile_(cont|disc).*")) {
+    if (expression.matches("(?i).*(percentile_(cont|disc)|convert)\\(.*")) {
       // PERCENTILE_CONT requires its argument to be a literal,
       // so converting its argument to a column will cause false errors.
+      // Similarly, MSSQL-style CONVERT.
       return buildQuery(expression);
     }
     // "values (1 < 5)"

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -90,6 +90,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "TABLE(CATALOG.SALES.EMPTY_PRODUCTS)",
           "TABLE(CATALOG.SALES.EMP_ADDRESS)",
           "TABLE(CATALOG.SALES.DEPT)",
+          "TABLE(CATALOG.SALES.DEPT_SINGLE)",
           "TABLE(CATALOG.SALES.DEPT_NESTED)",
           "TABLE(CATALOG.SALES.DEPT_NESTED_EXPANDED)",
           "TABLE(CATALOG.SALES.BONUS)",

File: testkit/src/main/java/org/apache/calcite/test/catalog/Fixture.java
Patch:
@@ -68,6 +68,9 @@ final class Fixture extends AbstractFixture {
               .build())
       .kind(StructKind.PEEK_FIELDS_NO_EXPAND)
       .build();
+  final RelDataType singleRecordType = typeFactory.builder()
+      .add("TYPE", varchar10Type)
+      .build();
   final RelDataType abRecordType = typeFactory.builder()
       .add("A", varchar10Type)
       .add("B", varchar10Type)

File: core/src/main/java/org/apache/calcite/jdbc/CalciteStatement.java
Patch:
@@ -68,7 +68,7 @@ public abstract class CalciteStatement extends AvaticaStatement {
   protected <T> CalcitePrepare.CalciteSignature<T> prepare(
       Queryable<T> queryable) {
     final CalciteConnectionImpl calciteConnection = getConnection();
-    final CalcitePrepare prepare = calciteConnection.prepareFactory.apply();
+    final CalcitePrepare prepare = calciteConnection.prepareFactory.get();
     final CalciteServerStatement serverStatement;
     try {
       serverStatement = calciteConnection.server.getStatement(handle);

File: testkit/src/main/java/org/apache/calcite/test/RelOptFixture.java
Patch:
@@ -77,7 +77,7 @@
  * set up (for example, the same SQL expression and set of planner rules), it is
  * safe to use the same fixture object as a starting point for both tests.
  */
-class RelOptFixture {
+public class RelOptFixture {
   static final RelOptFixture DEFAULT =
       new RelOptFixture(SqlToRelFixture.TESTER, SqlTestFactory.INSTANCE,
           null, RelSupplier.NONE, null, null,

File: core/src/test/java/org/apache/calcite/sql/type/SqlTypeFixture.java
Patch:
@@ -50,7 +50,9 @@ class SqlTypeFixture {
       typeFactory.createSqlType(SqlTypeName.ANY), false);
   final RelDataType sqlFloat = typeFactory.createTypeWithNullability(
       typeFactory.createSqlType(SqlTypeName.FLOAT), false);
-  final RelDataType sqlTimestamp = typeFactory.createTypeWithNullability(
+  final RelDataType sqlTimestampPrec0 = typeFactory.createTypeWithNullability(
+      typeFactory.createSqlType(SqlTypeName.TIMESTAMP, 0), false);
+  final RelDataType sqlTimestampPrec3 = typeFactory.createTypeWithNullability(
       typeFactory.createSqlType(SqlTypeName.TIMESTAMP, 3), false);
   final RelDataType sqlGeometry = typeFactory.createTypeWithNullability(
       typeFactory.createSqlType(SqlTypeName.GEOMETRY), false);

File: core/src/test/java/org/apache/calcite/sql/type/SqlTypeUtilTest.java
Patch:
@@ -120,10 +120,10 @@ class SqlTypeUtilTest {
 
     // Initialize a SqlTypeCoercionRules with the new builder mappings.
     SqlTypeCoercionRule typeCoercionRules = SqlTypeCoercionRule.instance(builder.map);
-    assertThat(SqlTypeUtil.canCastFrom(f.sqlTimestamp, f.sqlBoolean, true),
+    assertThat(SqlTypeUtil.canCastFrom(f.sqlTimestampPrec3, f.sqlBoolean, true),
         is(false));
     SqlTypeCoercionRule.THREAD_PROVIDERS.set(typeCoercionRules);
-    assertThat(SqlTypeUtil.canCastFrom(f.sqlTimestamp, f.sqlBoolean, true),
+    assertThat(SqlTypeUtil.canCastFrom(f.sqlTimestampPrec3, f.sqlBoolean, true),
         is(true));
     // Recover the mappings to default.
     SqlTypeCoercionRule.THREAD_PROVIDERS.set(defaultRules);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.calcite.sql.SqlSyntax;
 import org.apache.calcite.sql.SqlWriter;
 import org.apache.calcite.sql.type.InferTypes;
+import org.apache.calcite.sql.type.OperandHandlers;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlOperandCountRanges;
@@ -837,7 +838,8 @@ private SqlLibraryOperators() {
           ReturnTypes.DATE_NULLABLE,
           OperandTypes.sequence("'DATE_TRUNC(<DATE>, <DATETIME_INTERVAL>)'",
               OperandTypes.DATE, OperandTypes.dateInterval()),
-          SqlFunctionCategory.TIMEDATE);
+          SqlFunctionCategory.TIMEDATE)
+          .withOperandHandler(OperandHandlers.OPERAND_1_MIGHT_BE_TIME_FRAME);
 
   /** The "TIME_SUB(time, interval)" function (BigQuery);
    * subtracts an interval from a time, independent of any time zone.

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -2758,7 +2758,7 @@ protected void checkTimeUnitCodes(Map<String, TimeUnit> timeUnitCodes) {
 
     // Check that each invalid code fails each query that it should.
     Consumer<String> invalidConsumer = weekday -> {
-      String errorMessage = "'" + weekday + "' is not a valid time frame";
+      String errorMessage = "Column '" + weekday + "' not found in any table";
       f.withSql("select date_trunc(" + ds + ", ^" + weekday + "^)")
           .fails(errorMessage);
     };

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -8537,7 +8537,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         .withLibrary(SqlLibrary.BIG_QUERY)
         .setFor(SqlLibraryOperators.DATE_TRUNC);
     f.checkFails("date_trunc(date '2015-02-19', ^foo^)",
-        "'FOO' is not a valid time frame", false);
+        "Column 'FOO' not found in any table", false);
     f.checkScalar("date_trunc(date '2015-02-19', day)",
         "2015-02-19", "DATE NOT NULL");
     f.checkScalar("date_trunc(date '2015-02-19', week)",

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java
Patch:
@@ -150,7 +150,7 @@ SqlString generateSql() {
     final SqlNodeList selectList = SqlNodeList.SINGLETON_STAR;
     SqlSelect node =
         new SqlSelect(SqlParserPos.ZERO, SqlNodeList.EMPTY, selectList,
-            tableName(), null, null, null, null, null, null, null, null);
+            tableName(), null, null, null, null, null, null, null, null, null);
     final SqlWriterConfig config = SqlPrettyWriter.config()
         .withAlwaysUseParentheses(true)
         .withDialect(jdbcSchema.dialect);

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -545,7 +545,7 @@ SqlSelect wrapSelect(SqlNode node) {
       node = as(node, "t");
     }
     return new SqlSelect(POS, SqlNodeList.EMPTY, SqlNodeList.SINGLETON_STAR,
-        node, null, null, null, SqlNodeList.EMPTY, null, null, null, null);
+        node, null, null, null, SqlNodeList.EMPTY, null, null, null, null, null);
   }
 
   /** Returns whether we need to add an alias if this node is to be the FROM

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -478,6 +478,9 @@ ExInst<SqlValidatorException> intervalFieldExceedsPrecision(Number a0,
   @BaseMessage("Duplicate window specification not allowed in the same window clause")
   ExInst<SqlValidatorException> dupWindowSpec();
 
+  @BaseMessage("QUALIFY expression ''{0}'' must contain a window function")
+  ExInst<SqlValidatorException> qualifyExpressionMustContainWindowFunction(String a0);
+
   @BaseMessage("ROW/RANGE not allowed with RANK, DENSE_RANK or ROW_NUMBER functions")
   ExInst<SqlValidatorException> rankWithFrame();
 
@@ -1018,5 +1021,4 @@ ExInstWithCause<CalciteException> failedToAccessField(
 
   @BaseMessage("A table function at most has one input table with row semantics. Table function ''{0}'' has multiple input tables with row semantics")
   ExInst<SqlValidatorException> multipleRowSemanticsTables(String funcName);
-
 }

File: core/src/main/java/org/apache/calcite/sql/SqlJoin.java
Patch:
@@ -274,7 +274,7 @@ private SqlJoinOperator(String name, int prec) {
     SqlNode selectWrapper =
         new SqlSelect(SqlParserPos.ZERO, SqlNodeList.EMPTY,
             SqlNodeList.SINGLETON_STAR, this, null, null, null,
-            SqlNodeList.EMPTY, null, null, null, SqlNodeList.EMPTY);
+            SqlNodeList.EMPTY, null, null, null, null, SqlNodeList.EMPTY);
     return selectWrapper.toSqlString(transform);
   }
 }

File: core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
Patch:
@@ -57,6 +57,7 @@ public SqlProcedureCallOperator() {
         null,
         null,
         null,
+        null,
         null);
   }
 }

File: core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
Patch:
@@ -189,7 +189,7 @@ public MysqlSqlDialect(Context context) {
     final SqlLiteral nullLiteral = SqlLiteral.createNull(SqlParserPos.ZERO);
     final SqlNode unionOperand = new SqlSelect(SqlParserPos.ZERO, SqlNodeList.EMPTY,
         SqlNodeList.of(nullLiteral), null, null, null, null,
-        SqlNodeList.EMPTY, null, null, null, SqlNodeList.EMPTY);
+        SqlNodeList.EMPTY, null, null, null, null, SqlNodeList.EMPTY);
     // For MySQL, generate
     //   CASE COUNT(*)
     //   WHEN 0 THEN NULL

File: core/src/main/java/org/apache/calcite/sql/validate/GroupByScope.java
Patch:
@@ -56,7 +56,8 @@ public class GroupByScope extends DelegatingScope {
   }
 
   @Override public void validateExpr(SqlNode expr) {
-    SqlNode expanded = validator.expandGroupByOrHavingExpr(expr, this, select, false);
+    SqlNode expanded =
+        validator.extendedExpandGroupBy(expr, this, select);
 
     // expression needs to be valid in parent scope too
     parent.validateExpr(expanded);

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -1200,7 +1200,7 @@ public static Pair<SqlNode, RelDataType> validateExprWithRowType(
     final SqlSelect select0 = new SqlSelect(SqlParserPos.ZERO, null,
         new SqlNodeList(Collections.singletonList(expr), SqlParserPos.ZERO),
         new SqlIdentifier(tableName, SqlParserPos.ZERO),
-        null, null, null, null, null, null, null, null);
+        null, null, null, null, null, null, null, null, null);
     Prepare.CatalogReader catalogReader = createSingleTableCatalogReader(
         caseSensitive,
         tableName,

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -338,6 +338,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(LIMIT)",
           "KEYWORD(GROUP)",
           "KEYWORD(HAVING)",
+          "KEYWORD(QUALIFY)",
           "KEYWORD(INTERSECT)",
           "KEYWORD(ORDER)",
           "KEYWORD(UNION)",
@@ -363,6 +364,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(USING)",
           "KEYWORD(OUTER)",
           "KEYWORD(RIGHT)",
+          "KEYWORD(QUALIFY)",
           "KEYWORD(GROUP)",
           "KEYWORD(CROSS)",
           "KEYWORD(,)",

File: server/src/main/java/org/apache/calcite/server/ServerDdlExecutor.java
Patch:
@@ -179,7 +179,7 @@ static SqlNode renameColumns(@Nullable SqlNodeList columnList,
                 .addAll(columnList)
                 .build());
     return new SqlSelect(p, null, selectList, from, null, null, null, null,
-        null, null, null, null);
+        null, null, null, null, null);
   }
 
   /** Populates the table called {@code name} by executing {@code query}. */

File: testkit/src/main/java/org/apache/calcite/test/MockDdlExecutor.java
Patch:
@@ -118,7 +118,7 @@ static SqlNode renameColumns(@Nullable SqlNodeList columnList,
                 .addAll(columnList)
                 .build());
     return new SqlSelect(p, null, selectList, from, null, null, null, null,
-        null, null, null, null);
+        null, null, null, null, null);
   }
 
   /** Executes a {@code CREATE TABLE} command. Called via reflection. */

File: core/src/main/java/org/apache/calcite/prepare/Prepare.java
Patch:
@@ -235,7 +235,7 @@ public PreparedResult prepareSql(
     final SqlToRelConverter.Config config =
         SqlToRelConverter.config()
             .withTrimUnusedFields(true)
-            .withExpand(castNonNull(THREAD_EXPAND.get()))
+            .withExpand(THREAD_EXPAND.get())
             .withInSubQueryThreshold(castNonNull(THREAD_INSUBQUERY_THRESHOLD.get()))
             .withExplain(sqlQuery.getKind() == SqlKind.EXPLAIN);
     final Holder<SqlToRelConverter.Config> configHolder = Holder.of(config);
@@ -374,7 +374,7 @@ protected abstract RelNode decorrelate(SqlToRelConverter sqlToRelConverter,
   protected RelRoot trimUnusedFields(RelRoot root) {
     final SqlToRelConverter.Config config = SqlToRelConverter.config()
         .withTrimUnusedFields(shouldTrim(root.rel))
-        .withExpand(castNonNull(THREAD_EXPAND.get()))
+        .withExpand(THREAD_EXPAND.get())
         .withInSubQueryThreshold(castNonNull(THREAD_INSUBQUERY_THRESHOLD.get()));
     final SqlToRelConverter converter =
         getSqlToRelConverter(getSqlValidator(), catalogReader, config);

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -1747,7 +1747,8 @@ void checkCorrelatedMapSubQuery(boolean expand) {
   @Test void testUniqueWithExpand() {
     final String sql = "select * from emp\n"
         + "where unique (select 1 from dept where deptno=55)";
-    sql(sql).withExpand(true).throws_("UNIQUE is only supported if expand = false");
+    sql(sql).withExpand(true)
+        .throws_("UNIQUE is only supported if expand = false");
   }
 
   @Test void testUniqueWithProjectLateral() {

File: core/src/test/java/org/apache/calcite/test/TopDownOptTest.java
Patch:
@@ -277,7 +277,7 @@ RelOptFixture sql(String sql, Consumer<VolcanoPlanner> init) {
       p.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);
       p.removeRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);
       p.removeRule(EnumerableRules.ENUMERABLE_SORT_RULE);
-    }).check();
+    }).withExpand(true).check();
   }
 
   // test if "order by mgr desc nulls last" can be pushed through the projection ("select mgr").

File: testkit/src/main/java/org/apache/calcite/test/RelOptFixture.java
Patch:
@@ -83,8 +83,8 @@ class RelOptFixture {
           null, RelSupplier.NONE, null, null,
           ImmutableMap.of(), (f, r) -> r, (f, r) -> r, false, false)
           .withFactory(f ->
-              f.withValidatorConfig(c ->
-                  c.withIdentifierExpansion(true)))
+              f.withValidatorConfig(c -> c.withIdentifierExpansion(true))
+                  .withSqlToRelConfig(c -> c.withExpand(false)))
           .withRelBuilderConfig(b -> b.withPruneInputOfAggregate(false));
 
   /**

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -8157,7 +8157,7 @@ public Customer(int customer_id) {
 
   /** Factory for EMP and DEPT tables. */
   public static class EmpDeptTableFactory implements TableFactory<Table> {
-    public static final TryThreadLocal<List<Employee>> THREAD_COLLECTION =
+    public static final TryThreadLocal<@Nullable List<Employee>> THREAD_COLLECTION =
         TryThreadLocal.of(null);
 
     public Table create(
@@ -8253,7 +8253,7 @@ public static class AutoTempDriver
 
   /** Mock driver that a given {@link Handler}. */
   public static class HandlerDriver extends org.apache.calcite.jdbc.Driver {
-    private static final TryThreadLocal<Handler> HANDLERS =
+    private static final TryThreadLocal<@Nullable Handler> HANDLERS =
         TryThreadLocal.of(null);
 
     public HandlerDriver() {

File: core/src/test/java/org/apache/calcite/util/UtilTest.java
Patch:
@@ -2345,7 +2345,8 @@ private void checkListToString(String... strings) {
     memo1.close();
     assertThat(local1.get(), is("foo"));
 
-    final TryThreadLocal<String> local2 = TryThreadLocal.of(null);
+    final TryThreadLocal<@org.checkerframework.checker.nullness.qual.Nullable String> local2 =
+        TryThreadLocal.of(null);
     assertThat(local2.get(), nullValue());
     TryThreadLocal.Memo memo2 = local2.push("a");
     assertThat(local2.get(), is("a"));

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -881,7 +881,7 @@ public static SqlTimestampLiteral createTimestamp(
     return createTimestamp(SqlTypeName.TIMESTAMP, ts, precision, pos);
   }
 
-  /** Creates a TIMESTAMP or TIMESTAMP WITH TIME ZONE literal. */
+  /** Creates a TIMESTAMP or TIMESTAMP WITH LOCAL TIME ZONE literal. */
   public static SqlTimestampLiteral createTimestamp(
       SqlTypeName typeName,
       TimestampString ts,

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -69,8 +69,8 @@ public enum SqlTypeName {
       SqlTypeFamily.TIME),
   TIMESTAMP(PrecScale.NO_NO | PrecScale.YES_NO, false, Types.TIMESTAMP,
       SqlTypeFamily.TIMESTAMP),
-  TIMESTAMP_WITH_LOCAL_TIME_ZONE(PrecScale.NO_NO | PrecScale.YES_NO, false, Types.OTHER,
-      SqlTypeFamily.TIMESTAMP),
+  TIMESTAMP_WITH_LOCAL_TIME_ZONE(PrecScale.NO_NO | PrecScale.YES_NO, false,
+      Types.TIMESTAMP, SqlTypeFamily.TIMESTAMP),
   INTERVAL_YEAR(PrecScale.NO_NO, false, Types.OTHER,
       SqlTypeFamily.INTERVAL_YEAR_MONTH),
   INTERVAL_YEAR_MONTH(PrecScale.NO_NO, false, Types.OTHER,

File: innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbEnumerator.java
Patch:
@@ -97,6 +97,7 @@ private static Object convertToEnumeratorObject(Object obj, RelDataType relDataT
     case VARBINARY:
       return new ByteString((byte[]) obj);
     case TIMESTAMP:
+    case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
       Timestamp timestamp = Utils.convertDateTime((String) obj,
           relDataType.getPrecision());
       return shift(timestamp).getTime();

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -387,7 +387,9 @@ public static void verifyTypeEquivalence(
         + "set type is " + expectedRowType.getFullTypeString()
         + "\nexpression type is " + actualRowType.getFullTypeString()
         + "\nset is " + equivalenceClass.toString()
-        + "\nexpression is " + RelOptUtil.toString(newRel);
+        + "\nexpression is " + RelOptUtil.toString(newRel)
+        + getFullTypeDifferenceString("rowtype of original rel", expectedRowType,
+        "rowtype of new rel", actualRowType);
     throw new AssertionError(s);
   }
 

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -1409,7 +1409,7 @@ public static SqlNode toSql(RexLiteral literal) {
       return SqlLiteral.createTime(castNonNull(literal.getValueAs(TimeString.class)),
           literal.getType().getPrecision(), POS);
     case TIMESTAMP:
-      return SqlLiteral.createTimestamp(
+      return SqlLiteral.createTimestamp(typeName,
           castNonNull(literal.getValueAs(TimestampString.class)),
           literal.getType().getPrecision(), POS);
     case ANY:

File: core/src/main/java/org/apache/calcite/rex/RexToSqlNodeConverterImpl.java
Patch:
@@ -85,7 +85,7 @@ public RexToSqlNodeConverterImpl(RexSqlConvertletTable convertletTable) {
     // Timestamp
     if (SqlTypeFamily.TIMESTAMP.getTypeNames().contains(
         literal.getTypeName())) {
-      return SqlLiteral.createTimestamp(
+      return SqlLiteral.createTimestamp(literal.getTypeName(),
           requireNonNull(literal.getValueAs(TimestampString.class),
               "literal.getValueAs(TimestampString.class)"),
           0,

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -162,6 +162,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(CURRENT_USER)",
           "KEYWORD(CURSOR)",
           "KEYWORD(DATE)",
+          "KEYWORD(DATETIME)",
           "KEYWORD(DENSE_RANK)",
           "KEYWORD(ELEMENT)",
           "KEYWORD(EVERY)",

File: server/src/test/java/org/apache/calcite/test/ServerParserTest.java
Patch:
@@ -74,7 +74,7 @@ class ServerParserTest extends SqlParserTest {
         + "OPTIONS (`ABOOLEAN` TRUE,"
         + " `ANINTEGER` -45,"
         + " `ADATE` DATE '1970-03-21',"
-        + " `quoted.id` TIMESTAMP '1970-03-21 12:04:56.78',"
+        + " `quoted.id` TIMESTAMP '1970-03-21 12:4:56.78',"
         + " `ASTRING` 'foo''bar')";
     sql(sql).ok(expected);
   }

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -9814,8 +9814,8 @@ private SqlNode literal(RelDataType type, Object value) {
         return SqlLiteral.createCharString(value.toString(), SqlParserPos.ZERO);
       case TIMESTAMP:
         TimestampString ts = TimestampString.fromMillisSinceEpoch((Long) value);
-        return SqlLiteral.createTimestamp(ts, type.getPrecision(),
-            SqlParserPos.ZERO);
+        return SqlLiteral.createTimestamp(type.getSqlTypeName(), ts,
+            type.getPrecision(), SqlParserPos.ZERO);
       default:
         throw new AssertionError(type);
       }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -2181,6 +2181,7 @@ private static class FloorImplementor extends MethodNameImplementor {
             "timeUnitRange");
         switch (timeUnitRange) {
         case YEAR:
+        case ISOYEAR:
         case QUARTER:
         case MONTH:
         case WEEK:

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1903,8 +1903,8 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
   /** The <code>TIMESTAMPDIFF</code> function. */
   public static final SqlFunction TIMESTAMP_DIFF =
       new SqlTimestampDiffFunction("TIMESTAMPDIFF",
-          OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.TIMESTAMP,
-              SqlTypeFamily.TIMESTAMP));
+          OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.DATETIME,
+              SqlTypeFamily.DATETIME));
 
   /**
    * Use of the <code>IN_FENNEL</code> operator forces the argument to be

File: testkit/src/main/java/org/apache/calcite/test/QuidemTest.java
Patch:
@@ -293,6 +293,7 @@ public Connection connect(String name) throws Exception {
             .connect();
       case "catchall":
         return CalciteAssert.that()
+            .with(CalciteConnectionProperty.TIME_ZONE, "UTC")
             .withSchema("s",
                 new ReflectiveSchema(
                     new CatchallSchema()))

File: core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
Patch:
@@ -429,7 +429,8 @@ public Aggregate.AggCallBinding createBinding(
       Aggregate aggregateRelBase) {
     final RelDataType rowType = aggregateRelBase.getInput().getRowType();
 
-    if (aggFunction.getKind() == SqlKind.PERCENTILE_DISC) {
+    if (aggFunction.getKind() == SqlKind.PERCENTILE_DISC
+        || aggFunction.getKind() == SqlKind.PERCENTILE_CONT) {
       assert collation.getKeys().size() == 1;
       return new Aggregate.PercentileDiscAggCallBinding(
           aggregateRelBase.getCluster().getTypeFactory(), aggFunction,

File: core/src/main/java/org/apache/calcite/sql/SqlWithinGroupOperator.java
Patch:
@@ -91,7 +91,8 @@ public SqlWithinGroupOperator() {
       throw validator.newValidationError(call, RESOURCE.withinGroupNotAllowed(operator.getName()));
     }
 
-    if (inner.getOperator().getKind() == SqlKind.PERCENTILE_DISC) {
+    if (inner.getOperator().getKind() == SqlKind.PERCENTILE_DISC
+        || inner.getOperator().getKind() == SqlKind.PERCENTILE_CONT) {
       // We first check the percentile call operands, and then derive the correct type using
       // PercentileDiscCallBinding (See CALCITE-5230).
       SqlCallBinding opBinding =

File: core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
Patch:
@@ -1002,6 +1002,6 @@ public static SqlCall stripSeparator(SqlCall call) {
     }
   };
 
-  public static final SqlReturnTypeInference PERCENTILE_DISC = opBinding ->
+  public static final SqlReturnTypeInference PERCENTILE_DISC_CONT = opBinding ->
       opBinding.getCollationType();
 }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -7935,7 +7935,7 @@ public void _testGroupExpressionEquivalenceParams() {
         + "from emp\n"
         + "group by deptno";
     sql(sql)
-        .type("RecordType(DOUBLE NOT NULL C, INTEGER NOT NULL D) NOT NULL");
+        .type("RecordType(INTEGER NOT NULL C, INTEGER NOT NULL D) NOT NULL");
   }
 
   /** Tests that {@code PERCENTILE_CONT} only allows numeric fields. */

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -8033,7 +8033,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENTILE_CONT, VM_FENNEL, VM_JAVA);
     f.checkType("percentile_cont(0.25) within group (order by 1)",
-        "DOUBLE NOT NULL");
+        "INTEGER NOT NULL");
     f.checkFails("percentile_cont(0.25) within group (^order by 'a'^)",
         "Invalid type 'CHAR' in ORDER BY clause of 'PERCENTILE_CONT' function. "
             + "Only NUMERIC types are supported", false);

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -66,6 +66,9 @@ public interface CalciteResource {
   @BaseMessage("Geo-spatial extensions and the GEOMETRY data type are not enabled")
   ExInst<SqlValidatorException> geometryDisabled();
 
+  @BaseMessage("Proj4J EPSG is missing from the classpath; to resolve this problem, download the EPSG data set and agree to its terms of use")
+  ExInst<CalciteException> proj4jEpsgIsMissing();
+
   @BaseMessage("Illegal INTERVAL literal {0}; at {1}")
   @Property(name = "SQLSTATE", value = "42000")
   ExInst<CalciteException> illegalIntervalLiteral(String a0, String a1);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -301,7 +301,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
           SqlKind.MOD,
           60,
           true,
-          ReturnTypes.ARG1_NULLABLE,
+          ReturnTypes.NULLABLE_MOD,
           null,
           OperandTypes.EXACT_NUMERIC_EXACT_NUMERIC);
 

File: core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
Patch:
@@ -1001,4 +1001,7 @@ public static SqlCall stripSeparator(SqlCall call) {
       return relDataType;
     }
   };
+
+  public static final SqlReturnTypeInference PERCENTILE_DISC = opBinding ->
+      opBinding.getCollationType();
 }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -7929,7 +7929,7 @@ public void _testGroupExpressionEquivalenceParams() {
         + "from emp\n"
         + "group by deptno";
     sql(sql)
-        .type("RecordType(DOUBLE NOT NULL C, DOUBLE NOT NULL D) NOT NULL");
+        .type("RecordType(DOUBLE NOT NULL C, INTEGER NOT NULL D) NOT NULL");
   }
 
   /** Tests that {@code PERCENTILE_CONT} only allows numeric fields. */

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -7894,7 +7894,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENTILE_DISC, VM_FENNEL, VM_JAVA);
     f.checkType("percentile_disc(0.25) within group (order by 1)",
-        "DOUBLE NOT NULL");
+        "INTEGER NOT NULL");
     f.checkFails("percentile_disc(0.25) within group (^order by 'a'^)",
         "Invalid type 'CHAR' in ORDER BY clause of 'PERCENTILE_DISC' function. "
             + "Only NUMERIC types are supported", false);

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinRule.java
Patch:
@@ -283,7 +283,7 @@ protected JoinOnUniqueToSemiJoinRule(JoinOnUniqueToSemiJoinRuleConfig config) {
         default:
           throw new AssertionError(join.getJoinType());
         }
-        builder.project(project.getProjects());
+        builder.project(project.getProjects(), project.getRowType().getFieldNames());
         call.transformTo(builder.build());
       }
     }

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -891,6 +891,9 @@ public enum SqlKind {
   /** The {@code SINGLE_VALUE} aggregate function. */
   SINGLE_VALUE,
 
+  /** The {@code AGGREGATE} aggregate function. */
+  AGGREGATE_FN,
+
   /** The {@code BIT_AND} aggregate function. */
   BIT_AND,
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
Patch:
@@ -50,6 +50,8 @@ public enum SqlLibrary {
   /** A collection of operators that are in Google BigQuery but not in standard
    * SQL. */
   BIG_QUERY("b", "bigquery"),
+  /** Calcite-specific extensions. */
+  CALCITE("c", "calcite"),
   /** A collection of operators that are in Apache Hive but not in standard
    * SQL. */
   HIVE("h", "hive"),

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -126,6 +126,7 @@ public enum SqlTypeName {
   /** Spatial type. Though not standard, it is common to several DBs, so we
    * do not flag it 'special' (internal). */
   GEOMETRY(PrecScale.NO_NO, false, ExtraSqlTypes.GEOMETRY, SqlTypeFamily.GEO),
+  MEASURE(PrecScale.NO_NO, true, Types.OTHER, SqlTypeFamily.ANY),
   SARG(PrecScale.NO_NO, true, Types.OTHER, SqlTypeFamily.ANY);
 
   public static final int MAX_DATETIME_PRECISION = 3;

File: testkit/src/main/java/org/apache/calcite/test/SqlToRelTestBase.java
Patch:
@@ -60,7 +60,7 @@ public SqlToRelFixture fixture() {
    * Default catalog: {@link org.apache.calcite.test.catalog.MockCatalogReaderSimple#init()}.
    */
   public final SqlToRelFixture sql(String sql) {
-    return fixture().expression(false).withSql(sql);
+    return fixture().withSql(sql);
   }
 
   public final SqlToRelFixture expr(String sql) {

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
Patch:
@@ -193,6 +193,9 @@ private SqlTypeAssignmentRule(
     // MAP is assignable from ...
     rules.add(SqlTypeName.MAP, EnumSet.of(SqlTypeName.MAP));
 
+    // SYMBOL is assignable from ...
+    rules.add(SqlTypeName.SYMBOL, EnumSet.of(SqlTypeName.SYMBOL));
+
     // ANY is assignable from ...
     rule.clear();
     rule.add(SqlTypeName.TINYINT);

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -1790,10 +1790,11 @@ private RexNode createCaseExpression(
 
     @Override public RexNode visitLiteral(RexLiteral literal) {
       // Use nullIndicator to decide whether to project null.
-      // Do nothing if the literal is null.
+      // Do nothing if the literal is null or symbol.
       if (!RexUtil.isNull(literal)
           && projectPulledAboveLeftCorrelator
-          && (nullIndicator != null)) {
+          && (nullIndicator != null)
+          && !RexUtil.isSymbolLiteral(literal)) {
         return createCaseExpression(nullIndicator, null, literal);
       }
       return literal;

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -584,8 +584,8 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
   @BaseMessage("Cannot call table function here: ''{0}''")
   ExInst<CalciteException> cannotCallTableFunctionHere(String a0);
 
-  @BaseMessage("''{0}'' is not a valid datetime format")
-  ExInst<CalciteException> invalidDatetimeFormat(String a0);
+  @BaseMessage("''{0}'' is not a valid time frame")
+  ExInst<SqlValidatorException> invalidTimeFrame(String a0);
 
   @BaseMessage("Cannot INSERT into generated column ''{0}''")
   ExInst<SqlValidatorException> insertIntoAlwaysGenerated(String a0);

File: core/src/main/java/org/apache/calcite/util/DateTimeStringUtils.java
Patch:
@@ -24,6 +24,8 @@
 
 /**
  * Utility methods to manipulate String representation of DateTime values.
+ *
+ * @see DateTimeUtils
  */
 public class DateTimeStringUtils {
 

File: core/src/main/java/org/apache/calcite/util/NameMap.java
Patch:
@@ -62,7 +62,7 @@ public NameMap() {
   }
 
   /** Creates a NameMap that is an immutable copy of a given map. */
-  public static <V> NameMap immutableCopyOf(Map<String, V> names) {
+  public static <V> NameMap<V> immutableCopyOf(Map<String, V> names) {
     return new NameMap<>(ImmutableSortedMap.copyOf(names, COMPARATOR));
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlAbstractTimeFunction.java
Patch:
@@ -38,8 +38,7 @@ public class SqlAbstractTimeFunction extends SqlFunction {
   //~ Static fields/initializers ---------------------------------------------
 
   private static final SqlOperandTypeChecker OTC_CUSTOM =
-      OperandTypes.or(
-          OperandTypes.POSITIVE_INTEGER_LITERAL, OperandTypes.NILADIC);
+      OperandTypes.POSITIVE_INTEGER_LITERAL.or(OperandTypes.NILADIC);
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlBitOpAggFunction.java
Patch:
@@ -46,7 +46,7 @@ public SqlBitOpAggFunction(SqlKind kind) {
         kind,
         ReturnTypes.ARG0_NULLABLE_IF_EMPTY,
         null,
-        OperandTypes.or(OperandTypes.INTEGER, OperandTypes.BINARY),
+        OperandTypes.INTEGER.or(OperandTypes.BINARY),
         SqlFunctionCategory.NUMERIC,
         false,
         false,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonExistsFunction.java
Patch:
@@ -33,8 +33,7 @@ public class SqlJsonExistsFunction extends SqlFunction {
   public SqlJsonExistsFunction() {
     super("JSON_EXISTS", SqlKind.OTHER_FUNCTION,
         ReturnTypes.BOOLEAN.andThen(SqlTypeTransforms.FORCE_NULLABLE), null,
-        OperandTypes.or(
-            OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER),
+        OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER).or(
             OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER,
                 SqlTypeFamily.ANY)),
         SqlFunctionCategory.SYSTEM);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonKeysFunction.java
Patch:
@@ -32,7 +32,7 @@ public SqlJsonKeysFunction() {
     super("JSON_KEYS", SqlKind.OTHER_FUNCTION,
         ReturnTypes.VARCHAR_2000.andThen(SqlTypeTransforms.FORCE_NULLABLE),
         null,
-        OperandTypes.or(OperandTypes.ANY,
+        OperandTypes.ANY.or(
             OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER)),
         SqlFunctionCategory.SYSTEM);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonLengthFunction.java
Patch:
@@ -32,7 +32,7 @@ public SqlJsonLengthFunction() {
     super("JSON_LENGTH", SqlKind.OTHER_FUNCTION,
         ReturnTypes.INTEGER.andThen(SqlTypeTransforms.FORCE_NULLABLE),
         null,
-        OperandTypes.or(OperandTypes.ANY,
+        OperandTypes.ANY.or(
             OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER)),
         SqlFunctionCategory.SYSTEM);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlListaggAggFunction.java
Patch:
@@ -31,7 +31,7 @@ class SqlListaggAggFunction extends SqlAggFunction {
   SqlListaggAggFunction(SqlKind kind,
       SqlReturnTypeInference returnTypeInference) {
     super(kind.name(), null, kind, returnTypeInference,
-        null, OperandTypes.or(OperandTypes.STRING, OperandTypes.STRING_STRING),
+        null, OperandTypes.STRING.or(OperandTypes.STRING_STRING),
         SqlFunctionCategory.SYSTEM, false, false, Optionality.OPTIONAL);
   }
 }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlOverlayFunction.java
Patch:
@@ -32,9 +32,8 @@ public class SqlOverlayFunction extends SqlFunction {
   //~ Static fields/initializers ---------------------------------------------
 
   private static final SqlOperandTypeChecker OTC_CUSTOM =
-      OperandTypes.or(
-          OperandTypes.STRING_STRING_INTEGER,
-          OperandTypes.STRING_STRING_INTEGER_INTEGER);
+      OperandTypes.STRING_STRING_INTEGER
+          .or(OperandTypes.STRING_STRING_INTEGER_INTEGER);
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlPositionFunction.java
Patch:
@@ -37,8 +37,8 @@ public class SqlPositionFunction extends SqlFunction {
   // as part of rtiDyadicStringSumPrecision
 
   private static final SqlOperandTypeChecker OTC_CUSTOM =
-      OperandTypes.or(OperandTypes.STRING_SAME_SAME,
-          OperandTypes.STRING_SAME_SAME_INTEGER);
+      OperandTypes.STRING_SAME_SAME
+          .or(OperandTypes.STRING_SAME_SAME_INTEGER);
 
   public SqlPositionFunction() {
     super(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRandFunction.java
Patch:
@@ -40,7 +40,7 @@ public SqlRandFunction() {
         SqlKind.OTHER_FUNCTION,
         ReturnTypes.DOUBLE,
         null,
-        OperandTypes.or(OperandTypes.NILADIC, OperandTypes.NUMERIC),
+        OperandTypes.NILADIC.or(OperandTypes.NUMERIC),
         SqlFunctionCategory.NUMERIC);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRandIntegerFunction.java
Patch:
@@ -40,7 +40,7 @@ public SqlRandIntegerFunction() {
         SqlKind.OTHER_FUNCTION,
         ReturnTypes.INTEGER,
         null,
-        OperandTypes.or(OperandTypes.NUMERIC, OperandTypes.NUMERIC_NUMERIC),
+        OperandTypes.NUMERIC.or(OperandTypes.NUMERIC_NUMERIC),
         SqlFunctionCategory.NUMERIC);
   }
 

File: core/src/main/java/org/apache/calcite/runtime/CompressionFunctions.java
Patch:
@@ -39,7 +39,7 @@ private CompressionFunctions() {
 
   /**
    * MySql Compression is based on zlib.
-   * <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/Deflater.html">Deflater</a>
+   * <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/zip/Deflater.html">Deflater</a>
    * is used to implement compression.
    */
   public static @Nullable ByteString compress(@Nullable String data) {

File: core/src/main/java/org/apache/calcite/rel/metadata/janino/CacheGeneratorUtil.java
Patch:
@@ -197,7 +197,7 @@ private enum CacheKeyStrategy {
       @Override void cacheKeyBlock(StringBuilder buff, Method method, int methodIndex) {
         buff.append("    key = ")
             .append(
-                (method.getParameterTypes().length < 6
+                (method.getParameterCount() < 6
                     ? org.apache.calcite.runtime.FlatLists.class
                     : ImmutableList.class).getName())
             .append(".of(");

File: core/src/main/java/org/apache/calcite/schema/impl/ReflectiveFunctionBase.java
Patch:
@@ -71,7 +71,7 @@ protected ReflectiveFunctionBase(Method method) {
    */
   static boolean classHasPublicZeroArgsConstructor(Class<?> clazz) {
     for (Constructor<?> constructor : clazz.getConstructors()) {
-      if (constructor.getParameterTypes().length == 0
+      if (constructor.getParameterCount() == 0
           && Modifier.isPublic(constructor.getModifiers())) {
         return true;
       }
@@ -89,7 +89,7 @@ static boolean classHasPublicZeroArgsConstructor(Class<?> clazz) {
    */
   static boolean classHasPublicFunctionContextConstructor(Class<?> clazz) {
     for (Constructor<?> constructor : clazz.getConstructors()) {
-      if (constructor.getParameterTypes().length == 1
+      if (constructor.getParameterCount() == 1
           && constructor.getParameterTypes()[0] == FunctionContext.class
           && Modifier.isPublic(constructor.getModifiers())) {
         return true;

File: core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -1388,7 +1388,7 @@ private static class Bean {
       for (Method method : o.getClass().getMethods()) {
         if (method.getName().startsWith("set")
             && (method.getReturnType() == Void.class)
-            && (method.getParameterTypes().length == 1)) {
+            && (method.getParameterCount() == 1)) {
           String attributeName =
               stripPrefix(
                   method.getName(),
@@ -1397,7 +1397,7 @@ private static class Bean {
         }
         if (method.getName().startsWith("get")
             && (method.getReturnType() != Void.class)
-            && (method.getParameterTypes().length == 0)) {
+            && (method.getParameterCount() == 0)) {
           String attributeName =
               stripPrefix(
                   method.getName(),
@@ -1406,7 +1406,7 @@ private static class Bean {
         }
         if (method.getName().startsWith("is")
             && (method.getReturnType() == Boolean.class)
-            && (method.getParameterTypes().length == 0)) {
+            && (method.getParameterCount() == 0)) {
           String attributeName =
               stripPrefix(
                   method.getName(),

File: core/src/test/java/org/apache/calcite/test/SqlTestGen.java
Patch:
@@ -77,7 +77,7 @@ private static List<Method> getJunitMethods(Class<SqlValidatorSpooler> clazz) {
       if (method.getName().startsWith("test")
           && Modifier.isPublic(method.getModifiers())
           && !Modifier.isStatic(method.getModifiers())
-          && (method.getParameterTypes().length == 0)
+          && (method.getParameterCount() == 0)
           && (method.getReturnType() == Void.TYPE)) {
         list.add(method);
       }

File: testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java
Patch:
@@ -723,7 +723,7 @@ static Method method(Object o, String methodName, Object[] args) {
     loop:
       for (Method method1 : aClass.getMethods()) {
         if (method1.getName().equals(methodName)
-            && method1.getParameterTypes().length == args.length
+            && method1.getParameterCount() == args.length
             && Modifier.isPublic(method1.getDeclaringClass().getModifiers())) {
           for (Pair<Object, Class> pair
               : Pair.zip(args, (Class[]) method1.getParameterTypes())) {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdMaxRowCount.java
Patch:
@@ -208,7 +208,7 @@ public Double getMaxRowCount(RelSubset rel, RelMetadataQuery mq) {
     for (RelNode node : rel.getRels()) {
       if (node instanceof Sort) {
         Sort sort = (Sort) node;
-        if (sort.fetch != null) {
+        if (sort.fetch instanceof RexLiteral) {
           return (double) RexLiteral.intValue(sort.fetch);
         }
       }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdMinRowCount.java
Patch:
@@ -168,7 +168,7 @@ public Double getMinRowCount(RelSubset rel, RelMetadataQuery mq) {
     for (RelNode node : rel.getRels()) {
       if (node instanceof Sort) {
         Sort sort = (Sort) node;
-        if (sort.fetch != null) {
+        if (sort.fetch instanceof RexLiteral) {
           return (double) RexLiteral.intValue(sort.fetch);
         }
       }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -235,8 +235,6 @@ public class SqlValidatorImpl implements SqlValidatorWithHints {
 
   private int nextGeneratedId;
   protected final RelDataTypeFactory typeFactory;
-
-  /** The type of dynamic parameters until a type is imposed on them. */
   protected final RelDataType unknownType;
   private final RelDataType booleanType;
 
@@ -296,7 +294,8 @@ protected SqlValidatorImpl(
     this.typeFactory = requireNonNull(typeFactory, "typeFactory");
     this.config = requireNonNull(config, "config");
 
-    unknownType = typeFactory.createUnknownType();
+    // It is assumed that unknown type is nullable by default
+    unknownType = typeFactory.createTypeWithNullability(typeFactory.createUnknownType(), true);
     booleanType = typeFactory.createSqlType(SqlTypeName.BOOLEAN);
 
     final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();

File: testkit/src/main/java/org/apache/calcite/sql/test/AbstractSqlTester.java
Patch:
@@ -119,7 +119,7 @@ protected void checkParseEx(Throwable e, @Nullable String expectedMsgPattern,
       if (expectedMsgPattern == null) {
         throw new RuntimeException("Error while parsing query:" + sap, spe);
       } else if (errMessage == null
-          || !errMessage.matches(expectedMsgPattern)) {
+          || !Util.toLinux(errMessage).matches(expectedMsgPattern)) {
         throw new RuntimeException("Error did not match expected ["
             + expectedMsgPattern + "] while parsing query ["
             + sap + "]", spe);

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -27,7 +27,6 @@
 import org.apache.calcite.rel.type.RelDataTypeFieldImpl;
 import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.rel.type.RelRecordType;
-import org.apache.calcite.runtime.Geometries;
 import org.apache.calcite.runtime.Unit;
 import org.apache.calcite.sql.type.BasicSqlType;
 import org.apache.calcite.sql.type.IntervalSqlType;
@@ -39,6 +38,7 @@
 import org.apache.calcite.util.Util;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
+import org.locationtech.jts.geom.Geometry;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -216,7 +216,7 @@ private static Type fieldType(Field field) {
       case VARBINARY:
         return ByteString.class;
       case GEOMETRY:
-        return Geometries.Geom.class;
+        return Geometry.class;
       case SYMBOL:
         return Enum.class;
       case ANY:

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -27,7 +27,6 @@
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.runtime.FlatLists;
-import org.apache.calcite.runtime.Geometries;
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.SqlCollation;
 import org.apache.calcite.sql.SqlIntervalQualifier;
@@ -60,6 +59,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.checker.nullness.qual.PolyNull;
+import org.locationtech.jts.geom.Geometry;
 
 import java.math.BigDecimal;
 import java.math.MathContext;
@@ -1834,7 +1834,7 @@ private RelDataType guessType(@Nullable Object value) {
       return typeFactory.createSqlType(SqlTypeName.BINARY,
           ((ByteString) value).length());
     }
-    if (value instanceof Geometries.Geom) {
+    if (value instanceof Geometry) {
       return typeFactory.createSqlType(SqlTypeName.GEOMETRY);
     }
     throw new AssertionError("unknown type " + value.getClass());

File: core/src/main/java/org/apache/calcite/sql/type/JavaToSqlTypeConversionRules.java
Patch:
@@ -17,11 +17,11 @@
 package org.apache.calcite.sql.type;
 
 import org.apache.calcite.avatica.util.ArrayImpl;
-import org.apache.calcite.runtime.Geometries;
 
 import com.google.common.collect.ImmutableMap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
+import org.locationtech.jts.geom.Geometry;
 
 import java.math.BigDecimal;
 import java.sql.Date;
@@ -73,7 +73,7 @@ public class JavaToSqlTypeConversionRules {
           .put(Time.class, SqlTypeName.TIME)
           .put(BigDecimal.class, SqlTypeName.DECIMAL)
 
-          .put(Geometries.Geom.class, SqlTypeName.GEOMETRY)
+          .put(Geometry.class, SqlTypeName.GEOMETRY)
 
           .put(ResultSet.class, SqlTypeName.CURSOR)
           .put(ColumnList.class, SqlTypeName.COLUMN_LIST)

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -87,13 +87,13 @@
 import org.apache.calcite.runtime.Enumerables;
 import org.apache.calcite.runtime.FlatLists;
 import org.apache.calcite.runtime.FunctionContexts;
-import org.apache.calcite.runtime.GeoFunctions;
 import org.apache.calcite.runtime.JsonFunctions;
 import org.apache.calcite.runtime.Matcher;
 import org.apache.calcite.runtime.Pattern;
 import org.apache.calcite.runtime.RandomFunction;
 import org.apache.calcite.runtime.ResultSetEnumerable;
 import org.apache.calcite.runtime.SortedMultiMap;
+import org.apache.calcite.runtime.SpatialTypeFunctions;
 import org.apache.calcite.runtime.SqlFunctions;
 import org.apache.calcite.runtime.SqlFunctions.FlatProductInputType;
 import org.apache.calcite.runtime.Utilities;
@@ -391,7 +391,7 @@ public enum BuiltInMethod {
   IS_JSON_OBJECT(JsonFunctions.class, "isJsonObject", String.class),
   IS_JSON_ARRAY(JsonFunctions.class, "isJsonArray", String.class),
   IS_JSON_SCALAR(JsonFunctions.class, "isJsonScalar", String.class),
-  ST_GEOM_FROM_TEXT(GeoFunctions.class, "ST_GeomFromText", String.class),
+  ST_GEOM_FROM_TEXT(SpatialTypeFunctions.class, "ST_GeomFromText", String.class),
   INITCAP(SqlFunctions.class, "initcap", String.class),
   SUBSTRING(SqlFunctions.class, "substring", String.class, int.class,
       int.class),

File: core/src/test/java/org/apache/calcite/adapter/enumerable/EnumUtilsTest.java
Patch:
@@ -21,7 +21,7 @@
 import org.apache.calcite.linq4j.tree.Expressions;
 import org.apache.calcite.linq4j.tree.MethodCallExpression;
 import org.apache.calcite.linq4j.tree.ParameterExpression;
-import org.apache.calcite.runtime.GeoFunctions;
+import org.apache.calcite.runtime.SpatialTypeFunctions;
 import org.apache.calcite.runtime.SqlFunctions;
 import org.apache.calcite.runtime.XmlFunctions;
 import org.apache.calcite.util.BuiltInMethod;
@@ -205,10 +205,10 @@ public final class EnumUtilsTest {
     final ConstantExpression arg4 = Expressions.constant(1, int.class);
     final ConstantExpression arg5 = Expressions.constant(2, int.class);
     final MethodCallExpression geoMethodCall =
-        EnumUtils.call(null, GeoFunctions.class, "ST_MakePoint",
+        EnumUtils.call(null, SpatialTypeFunctions.class, "ST_MakePoint",
             Arrays.asList(arg4, arg5));
     assertThat(Expressions.toString(geoMethodCall),
-        is("org.apache.calcite.runtime.GeoFunctions.ST_MakePoint("
+        is("org.apache.calcite.runtime.SpatialTypeFunctions.ST_MakePoint("
             + "new java.math.BigDecimal(\n  1), "
             + "new java.math.BigDecimal(\n  2))"));
   }

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -6548,7 +6548,7 @@ private RelOptFixture spatial(String sql) {
   /** Constant reduction on geo-spatial expression. */
   @Test void testSpatialReduce() {
     final String sql = "select\n"
-        + "  ST_Buffer(ST_Point(0.0, 1.0), 2) as b\n"
+        + "  ST_Buffer(ST_Point(0.0, 0.0), 1, 4) as b\n"
         + "from GEO.Restaurants as r";
     spatial(sql)
         .withRelBuilderSimplify(false)

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSchemaFactory.java
Patch:
@@ -17,7 +17,7 @@
 package org.apache.calcite.adapter.geode.rel;
 
 import org.apache.calcite.model.ModelHandler;
-import org.apache.calcite.runtime.GeoFunctions;
+import org.apache.calcite.runtime.SpatialTypeFunctions;
 import org.apache.calcite.schema.Schema;
 import org.apache.calcite.schema.SchemaFactory;
 import org.apache.calcite.schema.SchemaPlus;
@@ -61,7 +61,7 @@ public GeodeSchemaFactory() {
 
     if (allowSpatialFunctions) {
       ModelHandler.addFunctions(parentSchema, null, ImmutableList.of(),
-          GeoFunctions.class.getName(), "*", true);
+          SpatialTypeFunctions.class.getName(), "*", true);
     }
 
     return new GeodeSchema(

File: core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
Patch:
@@ -276,7 +276,8 @@ protected List<RexNode> inferJoinEqualConditions(List<RexNode> rexNodes, Join jo
    * @param leftNodes where the conditions not feasible for equal sets are put
    * @return the equal sets
    */
-  private List<Set<RexInputRef>> splitEqualSets(List<RexNode> rexNodes, List<RexNode> leftNodes) {
+  private static List<Set<RexInputRef>> splitEqualSets(List<RexNode> rexNodes,
+      List<RexNode> leftNodes) {
     final List<Set<RexInputRef>> equalSets = new ArrayList<>();
     for (RexNode rexNode : rexNodes) {
       if (rexNode.isA(SqlKind.EQUALS)) {

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -48,9 +48,6 @@ public interface CalciteResource {
   @BaseMessage("APPLY operator is not allowed under the current SQL conformance level")
   ExInst<CalciteException> applyNotAllowed();
 
-  @BaseMessage("JSON path expression must be specified after the JSON value expression")
-  ExInst<CalciteException> jsonPathMustBeSpecified();
-
   @BaseMessage("Illegal {0} literal ''{1}'': {2}")
   ExInst<CalciteException> illegalLiteral(String a0, String a1, String a2);
 

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -72,7 +72,7 @@
  * <caption>Allowable types for SqlLiteral</caption>
  * <tr>
  * <th>TypeName</th>
- * <th>Meaing</th>
+ * <th>Meaning</th>
  * <th>Value type</th>
  * </tr>
  * <tr>

File: core/src/main/java/org/apache/calcite/sql/parser/Span.java
Patch:
@@ -19,6 +19,8 @@
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlNodeList;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -94,7 +96,7 @@ public Span add(SqlNode n) {
 
   /** Adds a node's position to the list if the node is not null,
    * and returns this Span. */
-  public Span addIf(SqlNode n) {
+  public Span addIf(@Nullable SqlNode n) {
     return n == null ? this : add(n);
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -4372,7 +4372,7 @@ protected void validateWhereOrOn(
     }
   }
 
-  private boolean isReturnBooleanType(RelDataType relDataType) {
+  private static boolean isReturnBooleanType(RelDataType relDataType) {
     if (relDataType instanceof RelRecordType) {
       RelRecordType recordType = (RelRecordType) relDataType;
       Preconditions.checkState(recordType.getFieldList().size() == 1,

File: core/src/main/java/org/apache/calcite/util/JsonBuilder.java
Patch:
@@ -135,7 +135,7 @@ public void append(StringBuilder buf, int indent, @Nullable Object o) {
     }
   }
 
-  private void appendString(StringBuilder buf, String s) {
+  private static void appendString(StringBuilder buf, String s) {
     buf.append('"');
     final int n = s.length();
     for (int i = 0; i < n; i++) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/MatchUtils.java
Patch:
@@ -27,7 +27,7 @@ private MatchUtils() {
   }
 
   /**
-   * Returns the row with the highest index whose corresponding symbol matches, null otherwese.
+   * Returns the row with the highest index whose corresponding symbol matches, null otherwise.
    * @param symbol Target Symbol
    * @param rows List of passed rows
    * @param symbols Corresponding symbols to rows

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -283,7 +283,7 @@ RexExpander getExpander(RexCall call) {
    * decoded, SqlOperators can then operate on the integer representations. The
    * value can later be recoded as a decimal.
    *
-   * <p>For example, suppose one casts 2.0 as a decima(10,4). The value is
+   * <p>For example, suppose one casts 2.0 as a decimal(10,4). The value is
    * decoded (20), multiplied by a scale factor (1000), for a result of
    * (20000) which is encoded as a decimal(10,4), in this case 2.0000
    *
@@ -877,7 +877,7 @@ private BinaryArithmeticExpander(RexBuilder builder) {
     /**
      * Convenience method for reading characteristics of operands (such as
      * scale, precision, whole digits) into an ArithmeticExpander. The
-     * operands are restricted by the following contraints:
+     * operands are restricted by the following constraints:
      *
      * <ul>
      * <li>there are exactly two operands

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -853,7 +853,7 @@ public static RexCall pushPredicateIntoCase(RexCall call) {
     case OR:
       return call; // don't push CASE into CASE!
     case EQUALS: {
-      // checks that the EQUALS operands may be splitted and
+      // checks that the EQUALS operands may be split and
       // doesn't push EQUALS into CASE
       List<RexNode> equalsOperands = call.getOperands();
       ImmutableBitSet left = RelOptUtil.InputFinder.bits(equalsOperands.get(0));

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -446,7 +446,7 @@ private static String toJavaString(
   }
 
   /**
-   * Computes if data type can be omitted from the digset.
+   * Computes if data type can be omitted from the digest.
    * <p>For instance, {@code 1:BIGINT} has to keep data type while {@code 1:INT}
    * should be represented as just {@code 1}.
    *

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -2142,7 +2142,7 @@ private RexNode simplifyCast(RexCall e) {
       return operand;
     }
     if (RexUtil.isLosslessCast(operand)) {
-      // x :: y below means cast(x as y) (which is PostgreSQL-specifiic cast by the way)
+      // x :: y below means cast(x as y) (which is PostgreSQL-specific cast by the way)
       // A) Remove lossless casts:
       // A.1) intExpr :: bigint :: int => intExpr
       // A.2) char2Expr :: char(5) :: char(2) => char2Expr

File: core/src/main/java/org/apache/calcite/sql/fun/SqlThrowOperator.java
Patch:
@@ -33,7 +33,7 @@
  * of it in constructs such as the following:</p>
  *
  * <blockquote><code>CASE<br>
- * WHEN &lt;conditionn&gt; THEN true<br>
+ * WHEN &lt;condition&gt; THEN true<br>
  * ELSE throw("what's wrong with you man?")<br>
  * END</code></blockquote>
  */

File: core/src/main/java/org/apache/calcite/util/ReflectiveVisitor.java
Patch:
@@ -22,7 +22,7 @@
  *
  * <p>This is a tagging interface: it has no methods, and is not even required
  * in order to use reflective visitation, but serves to advise users of the
- * class of the intended use of the class and refer them to auxilliary classes.
+ * class of the intended use of the class and refer them to auxiliary classes.
  */
 public interface ReflectiveVisitor {
 }

File: core/src/main/java/org/apache/calcite/rel/RelDistributions.java
Patch:
@@ -103,7 +103,7 @@ private RelDistributionImpl(Type type, ImmutableIntList keys) {
           || Ordering.natural().isOrdered(keys)
           : "key columns of hash distribution must be in order";
       assert type == Type.HASH_DISTRIBUTED
-          || type == Type.RANDOM_DISTRIBUTED
+          || type == Type.RANGE_DISTRIBUTED
           || keys.isEmpty();
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -196,7 +196,7 @@ public AggregateExpandDistinctAggregatesRule(
       return;
     }
 
-    if (((Config) config).isUsingGroupingSets()) {
+    if (config.isUsingGroupingSets()) {
       rewriteUsingGroupingSets(call, aggregate);
       return;
     }

File: core/src/main/java/org/apache/calcite/rex/RexInputRef.java
Patch:
@@ -101,8 +101,7 @@ public static Pair<RexNode, String> of2(
       int index,
       List<RelDataTypeField> fields) {
     final RelDataTypeField field = fields.get(index);
-    return Pair.of(
-        (RexNode) new RexInputRef(index, field.getType()),
+    return Pair.of(new RexInputRef(index, field.getType()),
         field.getName());
   }
 

File: core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java
Patch:
@@ -98,7 +98,7 @@ private AggregateFunctionImpl(Class<?> declaringClass,
 
       // V is remaining args of add by definition
       final List<Class> addParamTypes =
-          ImmutableList.copyOf((Class[]) addMethod.getParameterTypes());
+          ImmutableList.copyOf(addMethod.getParameterTypes());
       if (addParamTypes.isEmpty() || addParamTypes.get(0) != accumulatorType) {
         throw RESOURCE.firstParameterOfAdd(clazz.getName()).ex();
       }

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -234,7 +234,7 @@ private SqlValidatorNamespace resolveImpl(SqlIdentifier id) {
           resolvedNamespace.getMonotonicity(fieldName);
       if (monotonicity != null && monotonicity != SqlMonotonicity.NOT_MONOTONIC) {
         builder.add(
-            Pair.of((SqlNode) new SqlIdentifier(fieldName, SqlParserPos.ZERO),
+            Pair.of(new SqlIdentifier(fieldName, SqlParserPos.ZERO),
                 monotonicity));
       }
     }

File: core/src/test/java/org/apache/calcite/rex/RexBuilderTest.java
Patch:
@@ -566,7 +566,7 @@ private void checkDate(RexLiteral literal) {
         SqlCollation.IMPLICIT);
     assertEquals("_UTF8'foobar'", literal.toString());
     assertEquals("_UTF8'foobar':CHAR(6) CHARACTER SET \"UTF-8\"",
-        ((RexLiteral) literal).computeDigest(RexDigestIncludeType.ALWAYS));
+        literal.computeDigest(RexDigestIncludeType.ALWAYS));
     literal = builder.makePreciseStringLiteral(
         new ByteString("\u82f1\u56fd".getBytes(StandardCharsets.UTF_8)),
         "UTF8",

File: core/src/test/java/org/apache/calcite/test/concurrent/SamplePlugin.java
Patch:
@@ -48,8 +48,7 @@ public Iterable<String> getSupportedThreadCommands() {
   /** Command that describes a result set. */
   static class DescribeResultSet implements ConcurrentTestPluginCommand {
     public void execute(TestContext testContext) throws IOException {
-      Statement stmt =
-          (PreparedStatement) testContext.getCurrentStatement();
+      Statement stmt = testContext.getCurrentStatement();
       if (stmt == null) {
         testContext.storeMessage("No current statement");
       } else if (stmt instanceof PreparedStatement) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -280,7 +280,7 @@ protected static Pair<String, ExtractionFunction> toDruidColumn(RexNode rexNode,
         // unknown Granularity
         return Pair.of(null, null);
       }
-      if (!TimeExtractionFunction.isValidTimeExtract((RexCall) rexNode)) {
+      if (!TimeExtractionFunction.isValidTimeExtract(rexNode)) {
         return Pair.of(null, null);
       }
       RexNode extractValueNode = ((RexCall) rexNode).getOperands().get(1);
@@ -309,7 +309,7 @@ protected static Pair<String, ExtractionFunction> toDruidColumn(RexNode rexNode,
         // unknown Granularity
         return Pair.of(null, null);
       }
-      if (!TimeExtractionFunction.isValidTimeFloor((RexCall) rexNode)) {
+      if (!TimeExtractionFunction.isValidTimeFloor(rexNode)) {
         return Pair.of(null, null);
       }
       RexNode floorValueNode = ((RexCall) rexNode).getOperands().get(0);

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
Patch:
@@ -442,7 +442,7 @@ private static int optSize(List<Operator> list) {
     RelNode referencedRel = builder.getRel(
         ((LogicalRelationalOperator) op.getImplicitReferencedOperator()).getAlias());
     builder.push(referencedRel);
-    List<RexNode> projectCol = Lists.newArrayList((RexNode) builder.field(index));
+    List<RexNode> projectCol = Lists.newArrayList(builder.field(index));
     builder.project(projectCol);
 
     stack.push(RexSubQuery.scalar(builder.build()));

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkSchema.java
Patch:
@@ -32,7 +32,7 @@ public class SplunkSchema extends AbstractSchema {
   public static final String SPLUNK_TABLE_NAME = "splunk";
 
   public static final ImmutableMap<String, Table> TABLE_MAP =
-      ImmutableMap.of(SPLUNK_TABLE_NAME, (Table) SplunkTable.INSTANCE);
+      ImmutableMap.of(SPLUNK_TABLE_NAME, SplunkTable.INSTANCE);
 
   public final SplunkConnection splunkConnection;
 

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
Patch:
@@ -23,7 +23,6 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.validate.SqlValidator;
-import org.apache.calcite.sql.validate.SqlValidatorImpl;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 
 import com.google.common.collect.ImmutableMap;
@@ -480,7 +479,7 @@ public SqlCall getLookupCall() {
 
     for (SqlNode operand : call.getOperandList()) {
       RelDataType nodeType = validator.deriveType(scope, operand);
-      ((SqlValidatorImpl) validator).setValidatedNodeType(operand, nodeType);
+      validator.setValidatedNodeType(operand, nodeType);
     }
     return validateOperands(validator, scope, call);
   }

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -675,7 +675,7 @@ protected List<RelDataType> constructArgTypeList(
       if (operand.getKind() == SqlKind.ROW && convertRowArgToColumnList) {
         RelDataTypeFactory typeFactory = validator.getTypeFactory();
         nodeType = typeFactory.createSqlType(SqlTypeName.COLUMN_LIST);
-        ((SqlValidatorImpl) validator).setValidatedNodeType(operand, nodeType);
+        validator.setValidatedNodeType(operand, nodeType);
       } else {
         nodeType = validator.deriveType(operandScope, operand);
       }

File: core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
Patch:
@@ -23,7 +23,6 @@
 import org.apache.calcite.sql.util.SqlBasicVisitor;
 import org.apache.calcite.sql.util.SqlVisitor;
 import org.apache.calcite.sql.validate.SqlValidator;
-import org.apache.calcite.sql.validate.SqlValidatorImpl;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 
 import static org.apache.calcite.util.Static.RESOURCE;
@@ -115,8 +114,8 @@ public SqlOverOperator() {
     RelDataType ret = aggCall.getOperator().inferReturnType(opBinding);
 
     // Copied from validateOperands
-    ((SqlValidatorImpl) validator).setValidatedNodeType(call, ret);
-    ((SqlValidatorImpl) validator).setValidatedNodeType(agg, ret);
+    validator.setValidatedNodeType(call, ret);
+    validator.setValidatedNodeType(agg, ret);
     return ret;
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
Patch:
@@ -34,7 +34,6 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql.type.SqlTypeUtil;
 import org.apache.calcite.sql.validate.SqlValidator;
-import org.apache.calcite.sql.validate.SqlValidatorImpl;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.Litmus;
 
@@ -145,7 +144,7 @@ private static SqlBinaryOperator of(SqlKind kind) {
       }
 
       // Record the RHS type for use by SqlToRelConverter.
-      ((SqlValidatorImpl) validator).setValidatedNodeType(nodeList, rightType);
+      validator.setValidatedNodeType(nodeList, rightType);
     } else {
       // Handle the 'IN (query)' form.
       rightType = validator.deriveType(scope, right);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlTypeFamily;
 import org.apache.calcite.sql.validate.SqlValidator;
-import org.apache.calcite.sql.validate.SqlValidatorImpl;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.Optionality;
 
@@ -67,7 +66,7 @@ public SqlJsonArrayAggAggFunction(SqlKind kind,
     // To prevent operator rewriting by SqlFunction#deriveType.
     for (SqlNode operand : call.getOperandList()) {
       RelDataType nodeType = validator.deriveType(scope, operand);
-      ((SqlValidatorImpl) validator).setValidatedNodeType(operand, nodeType);
+      validator.setValidatedNodeType(operand, nodeType);
     }
     return validateOperands(validator, scope, call);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java
Patch:
@@ -30,7 +30,6 @@
 import org.apache.calcite.sql.type.SqlTypeFamily;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql.validate.SqlValidator;
-import org.apache.calcite.sql.validate.SqlValidatorImpl;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.Optionality;
 
@@ -74,7 +73,7 @@ public SqlJsonObjectAggAggFunction(SqlKind kind,
     // To prevent operator rewriting by SqlFunction#deriveType.
     for (SqlNode operand : call.getOperandList()) {
       RelDataType nodeType = validator.deriveType(scope, operand);
-      ((SqlValidatorImpl) validator).setValidatedNodeType(operand, nodeType);
+      validator.setValidatedNodeType(operand, nodeType);
     }
     return validateOperands(validator, scope, call);
   }

File: core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
Patch:
@@ -55,7 +55,7 @@
  *     f.lte(g) returns true, then e.lte(g) must return true.</li>
  * </ul>
  *
- * <p>Note that not all pairs of elements are related. If is OK if e.lte(f)
+ * <p>Note that not all pairs of elements are related. It is OK if e.lte(f)
  * returns false and f.lte(e) returns false also.</p>
  *
  * <p>In addition to the usual set methods, there are methods to determine the

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.calcite.rel.core.Union;
 import org.apache.calcite.rex.RexBuilder;
 import org.apache.calcite.rex.RexCall;
+import org.apache.calcite.rex.RexDynamicParam;
 import org.apache.calcite.rex.RexInputRef;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexLocalRef;
@@ -911,7 +912,7 @@ private static boolean alreadySmaller(RelMetadataQuery mq, RelNode input,
       return true;
     }
     final Double rowCount = mq.getMaxRowCount(input);
-    if (rowCount == null) {
+    if (rowCount == null || offset instanceof RexDynamicParam || fetch instanceof RexDynamicParam) {
       // Cannot be determined
       return false;
     }

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -682,7 +682,7 @@ public boolean hasImplicitTableAlias() {
    * @return SQL timestamp literal
    */
   public String quoteTimestampLiteral(Timestamp timestamp) {
-    final SimpleDateFormat format = getDateFormatter("'TIMESTAMP' ''yyyy-MM-DD HH:mm:SS''");
+    final SimpleDateFormat format = getDateFormatter("'TIMESTAMP' ''yyyy-MM-dd HH:mm:ss''");
     return format.format(timestamp);
   }
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -241,6 +241,7 @@
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_OBJECT;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_OBJECTAGG;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_QUERY;
+import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_TYPE_OPERATOR;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_VALUE;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_VALUE_EXPRESSION;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.LAG;
@@ -577,6 +578,8 @@ public class RexImpTable {
     // Json Operators
     defineMethod(JSON_VALUE_EXPRESSION,
         BuiltInMethod.JSON_VALUE_EXPRESSION.method, NullPolicy.STRICT);
+    defineMethod(JSON_TYPE_OPERATOR,
+        BuiltInMethod.JSON_VALUE_EXPRESSION.method, NullPolicy.STRICT);
     defineMethod(JSON_EXISTS, BuiltInMethod.JSON_EXISTS.method, NullPolicy.ARG0);
     map.put(JSON_VALUE,
         new JsonValueImplementor(BuiltInMethod.JSON_VALUE.method));

File: core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java
Patch:
@@ -803,7 +803,7 @@ public boolean hasException() {
     }
 
     @Override public String toString() {
-      return Objects.toString(obj);
+      return jsonize(obj);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -674,6 +674,9 @@ public enum SqlKind {
   /** {@code JSON_OBJECTAGG} aggregate function. */
   JSON_OBJECTAGG,
 
+  /** {@code JSON} type function. */
+  JSON_TYPE,
+
   /** {@code UNNEST} operator. */
   UNNEST,
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -842,6 +842,9 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
   public static final SqlPostfixOperator JSON_VALUE_EXPRESSION =
       new SqlJsonValueExpressionOperator();
 
+  public static final SqlJsonTypeOperator JSON_TYPE_OPERATOR =
+      new SqlJsonTypeOperator();
+
 
   //-------------------------------------------------------------
   //                   PREFIX OPERATORS

File: testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
Patch:
@@ -4394,7 +4394,7 @@ private void checkIf(SqlOperatorFixture f) {
     f.checkString("json_object('foo': 100)",
         "{\"foo\":100}", "VARCHAR(2000) NOT NULL");
     f.checkString("json_object('foo': json_object('foo': 'bar'))",
-        "{\"foo\":\"{\\\"foo\\\":\\\"bar\\\"}\"}", "VARCHAR(2000) NOT NULL");
+        "{\"foo\":{\"foo\":\"bar\"}}", "VARCHAR(2000) NOT NULL");
     f.checkString("json_object('foo': json_object('foo': 'bar') format json)",
         "{\"foo\":{\"foo\":\"bar\"}}", "VARCHAR(2000) NOT NULL");
   }
@@ -4425,7 +4425,7 @@ private void checkIf(SqlOperatorFixture f) {
   @Test void testJsonValueExpressionOperator() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("'{}' format json", "{}", "ANY NOT NULL");
-    f.checkScalar("'[1, 2, 3]' format json", "[1, 2, 3]", "ANY NOT NULL");
+    f.checkScalar("'[1, 2, 3]' format json", "[1,2,3]", "ANY NOT NULL");
     f.checkNull("cast(null as varchar) format json");
     f.checkScalar("'null' format json", "null", "ANY NOT NULL");
     f.enableTypeCoercion(false)
@@ -4449,7 +4449,7 @@ private void checkIf(SqlOperatorFixture f) {
     f.checkString("json_array(100)",
         "[100]", "VARCHAR(2000) NOT NULL");
     f.checkString("json_array(json_array('foo'))",
-        "[\"[\\\"foo\\\"]\"]", "VARCHAR(2000) NOT NULL");
+        "[[\"foo\"]]", "VARCHAR(2000) NOT NULL");
     f.checkString("json_array(json_array('foo') format json)",
         "[[\"foo\"]]", "VARCHAR(2000) NOT NULL");
   }

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraEnumerator.java
Patch:
@@ -27,6 +27,7 @@
 import com.datastax.oss.driver.api.core.cql.ResultSet;
 import com.datastax.oss.driver.api.core.cql.Row;
 import com.datastax.oss.driver.api.core.data.TupleValue;
+import com.datastax.oss.driver.api.core.type.codec.registry.CodecRegistry;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -87,7 +88,7 @@ class CassandraEnumerator implements Enumerator<Object> {
   private @Nullable Object currentRowField(int index) {
     assert current != null;
     final Object o =  current.get(index,
-        CassandraSchema.CODEC_REGISTRY.codecFor(
+        CodecRegistry.DEFAULT.codecFor(
             current.getColumnDefinitions().get(index).getType()));
 
     return convertToEnumeratorObject(o);
@@ -124,7 +125,7 @@ class CassandraEnumerator implements Enumerator<Object> {
       return IntStream.range(0, numComponents)
           .mapToObj(i ->
               tupleValue.get(i,
-                  CassandraSchema.CODEC_REGISTRY.codecFor(
+                  CodecRegistry.DEFAULT.codecFor(
                       tupleValue.getType().getComponentTypes().get(i)))
           ).map(this::convertToEnumeratorObject)
           .map(Objects::requireNonNull) // "null" cannot appear inside collections

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -4688,7 +4688,9 @@ public RexNode register(
               currentProjection);
         }
 
-        setRoot(newLeftInput, false);
+        // if the original root rel is a leaf rel, the new root should be a leaf.
+        // otherwise the field offset will be wrong.
+        setRoot(newLeftInput, leaves.remove(root()) != null);
 
         // right fields appear after the LHS fields.
         final int rightOffset = root().getRowType().getFieldCount()

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -854,7 +854,7 @@ public TrimResult trimFields(
 
     if (changeCount == 0
         && mapping.isIdentity()) {
-      return result(join, Mappings.createIdentity(fieldCount));
+      return result(join, Mappings.createIdentity(join.getRowType().getFieldCount()));
     }
 
     // Build new join.

File: core/src/main/java/org/apache/calcite/plan/visualizer/RuleMatchVisualizer.java
Patch:
@@ -46,7 +46,6 @@
 import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -173,7 +172,7 @@ private void updateInitialPlan(RelNode node) {
    * Get the inputs for a node, unwrapping {@link HepRelVertex} nodes.
    * (Workaround for HepPlanner)
    */
-  private Collection<RelNode> getInputs(final RelNode node) {
+  private static List<RelNode> getInputs(final RelNode node) {
     return node.getInputs().stream().map(n -> {
       if (n instanceof HepRelVertex) {
         return ((HepRelVertex) n).getCurrentRel();

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRule.java
Patch:
@@ -44,9 +44,9 @@ default boolean canApplyFrom(SqlTypeName to, SqlTypeName from) {
     Objects.requireNonNull(to, "to");
     Objects.requireNonNull(from, "from");
 
-    if (to == SqlTypeName.NULL) {
+    if (to == SqlTypeName.NULL || to == SqlTypeName.UNKNOWN) {
       return false;
-    } else if (from == SqlTypeName.NULL) {
+    } else if (from == SqlTypeName.NULL || from == SqlTypeName.UNKNOWN) {
       return true;
     }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -106,6 +106,7 @@ public enum SqlTypeName {
   VARBINARY(PrecScale.NO_NO | PrecScale.YES_NO, false, Types.VARBINARY,
       SqlTypeFamily.BINARY),
   NULL(PrecScale.NO_NO, true, Types.NULL, SqlTypeFamily.NULL),
+  UNKNOWN(PrecScale.NO_NO, true, Types.NULL, SqlTypeFamily.NULL),
   ANY(PrecScale.NO_NO | PrecScale.YES_NO | PrecScale.YES_YES, true,
       Types.JAVA_OBJECT, SqlTypeFamily.ANY),
   SYMBOL(PrecScale.NO_NO, true, Types.OTHER, null),

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransforms.java
Patch:
@@ -145,6 +145,8 @@ private SqlTypeName toVar(RelDataType type) {
             return SqlTypeName.ANY;
           case NULL:
             return SqlTypeName.NULL;
+          case UNKNOWN:
+            return SqlTypeName.UNKNOWN;
           default:
             throw Util.unexpected(sqlTypeName);
           }

File: core/src/test/java/org/apache/calcite/sql/type/SqlTypeFixture.java
Patch:
@@ -44,6 +44,8 @@ class SqlTypeFixture {
       typeFactory.createSqlType(SqlTypeName.VARCHAR), true);
   final RelDataType sqlNull = typeFactory.createTypeWithNullability(
       typeFactory.createSqlType(SqlTypeName.NULL), false);
+  final RelDataType sqlUnknown = typeFactory.createTypeWithNullability(
+      typeFactory.createSqlType(SqlTypeName.UNKNOWN), false);
   final RelDataType sqlAny = typeFactory.createTypeWithNullability(
       typeFactory.createSqlType(SqlTypeName.ANY), false);
   final RelDataType sqlFloat = typeFactory.createTypeWithNullability(

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -348,7 +348,7 @@ private SqlString generateSql(SqlDialect dialect) {
         new JdbcImplementor(dialect,
             (JavaTypeFactory) getCluster().getTypeFactory());
     final JdbcImplementor.Result result =
-        jdbcImplementor.visitInput(this, 0);
+        jdbcImplementor.visitRoot(this.getInput());
     return result.asStatement().toSqlString(dialect);
   }
 }

File: spark/src/main/java/org/apache/calcite/adapter/spark/JdbcToSparkConverter.java
Patch:
@@ -115,7 +115,7 @@ private String generateSql(SqlDialect dialect) {
         new JdbcImplementor(dialect,
             (JavaTypeFactory) getCluster().getTypeFactory());
     final JdbcImplementor.Result result =
-        jdbcImplementor.visitInput(this, 0);
+        jdbcImplementor.visitRoot(this.getInput());
     return result.asStatement().toSqlString(dialect).getSql();
   }
 }

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -2052,14 +2052,14 @@ private static void registerCalcRules(RelOptPlanner planner) {
 
   @Experimental
   public static void registerDefaultRules(RelOptPlanner planner,
-      boolean enableMaterialziations, boolean enableBindable) {
+      boolean enableMaterializations, boolean enableBindable) {
     if (CalciteSystemProperty.ENABLE_COLLATION_TRAIT.value()) {
       registerAbstractRelationalRules(planner);
     }
     registerAbstractRules(planner);
     registerBaseRules(planner);
 
-    if (enableMaterialziations) {
+    if (enableMaterializations) {
       registerMaterializationRules(planner);
     }
     if (enableBindable) {

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -338,7 +338,7 @@ private SqlValidator createSqlValidator(CalciteCatalogReader catalogReader) {
         sqlValidatorConfig
             .withDefaultNullCollation(connectionConfig.defaultNullCollation())
             .withLenientOperatorLookup(connectionConfig.lenientOperatorLookup())
-            .withSqlConformance(connectionConfig.conformance())
+            .withConformance(connectionConfig.conformance())
             .withIdentifierExpansion(true));
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlUnnestOperator.java
Patch:
@@ -106,7 +106,7 @@ private static boolean allowAliasUnnestItems(SqlOperatorBinding operatorBinding)
         && ((SqlCallBinding) operatorBinding)
         .getValidator()
         .config()
-        .sqlConformance()
+        .conformance()
         .allowAliasUnnestItems();
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/OrderByScope.java
Patch:
@@ -73,7 +73,7 @@ public class OrderByScope extends DelegatingScope {
   @Override public SqlQualified fullyQualify(SqlIdentifier identifier) {
     // If it's a simple identifier, look for an alias.
     if (identifier.isSimple()
-        && validator.config().sqlConformance().isSortByAlias()) {
+        && validator.config().conformance().isSortByAlias()) {
       final String name = identifier.names.get(0);
       final SqlValidatorNamespace selectNs =
           validator.getNamespaceOrThrow(select);

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -1143,7 +1143,7 @@ public RexNode convertSubstring(
       SqlSubstringFunction op,
       SqlCall call) {
     final SqlLibrary library =
-        cx.getValidator().config().sqlConformance().semantics();
+        cx.getValidator().config().conformance().semantics();
     final SqlBasicCall basicCall = (SqlBasicCall) call;
     switch (library) {
     case BIG_QUERY:

File: core/src/test/java/org/apache/calcite/plan/RelWriterTest.java
Patch:
@@ -585,7 +585,7 @@ static Stream<SqlExplainFormat> explainFormats() {
     assertThat(s, is(XX2));
   }
 
-  @Test public void testExchange() {
+  @Test void testExchange() {
     final FrameworkConfig config = RelBuilderTest.config().build();
     final RelBuilder builder = RelBuilder.create(config);
     final RelNode rel = builder

File: core/src/test/java/org/apache/calcite/plan/volcano/MultipleTraitConversionTest.java
Patch:
@@ -46,7 +46,7 @@
  */
 public class MultipleTraitConversionTest {
   @SuppressWarnings("ConstantConditions")
-  @Test public void testMultipleTraitConversion() {
+  @Test void testMultipleTraitConversion() {
     VolcanoPlanner planner = new VolcanoPlanner();
 
     planner.addRelTraitDef(ConventionTraitDef.INSTANCE);

File: core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java
Patch:
@@ -565,7 +565,7 @@ private void removeTrivialProject(boolean useRule) {
         isLinux(plan));
   }
 
-  @Test public void testPruneNode() {
+  @Test void testPruneNode() {
     VolcanoPlanner planner = new VolcanoPlanner();
     planner.addRelTraitDef(ConventionTraitDef.INSTANCE);
 

File: core/src/test/java/org/apache/calcite/sql/test/DocumentationTest.java
Patch:
@@ -73,7 +73,7 @@ class DocumentationTest {
         if (line.equals("{% comment %} start {% endcomment %}")) {
           ++stage;
           SqlAbstractParserImpl.Metadata metadata =
-              new SqlParserTest().getSqlParser("").getMetadata();
+              new SqlParserTest().fixture().parser().getMetadata();
           int z = 0;
           for (String s : metadata.getTokens()) {
             if (z++ > 0) {

File: core/src/test/java/org/apache/calcite/sql/type/SqlTypeUtilTest.java
Patch:
@@ -182,7 +182,7 @@ class SqlTypeUtilTest {
     assertThat(fieldTypeNames, is(Arrays.asList("INTEGER", "INTEGER")));
   }
 
-  @Test public void testGetMaxPrecisionScaleDecimal() {
+  @Test void testGetMaxPrecisionScaleDecimal() {
     RelDataType decimal = SqlTypeUtil.getMaxPrecisionScaleDecimal(f.typeFactory);
     assertThat(decimal, is(f.typeFactory.createSqlType(SqlTypeName.DECIMAL, 19, 9)));
   }
@@ -210,7 +210,7 @@ private void compareTypesIgnoringNullability(
         SqlTypeUtil.equalSansNullability(type1, type2), is(expectedResult));
   }
 
-  @Test public void testEqualSansNullability() {
+  @Test void testEqualSansNullability() {
     RelDataType bigIntType = f.sqlBigInt;
     RelDataType nullableBigIntType = f.sqlBigIntNullable;
     RelDataType varCharType = f.sqlVarchar;

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -446,7 +446,7 @@ class JdbcAdapterTest {
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-1382">[CALCITE-1382]
    * ClassCastException in JDBC adapter</a>. */
-  @Test public void testJoinPlan3() {
+  @Test void testJoinPlan3() {
     final String sql = "SELECT count(*) AS c FROM (\n"
         + "  SELECT count(emp.empno) `Count Emp`,\n"
         + "      dept.dname `Department Name`\n"

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -4670,7 +4670,6 @@ private static RelNode buildCorrelateWithJoin(JoinRelType type) {
   @Test void testExecuteNotLike() {
     CalciteAssert.that()
         .withSchema("s", new ReflectiveSchema(new HrSchema()))
-        .query("?")
         .withRel(
             builder -> builder
                 .scan("s", "emps")

File: core/src/test/java/org/apache/calcite/test/RexTransformerTest.java
Patch:
@@ -68,9 +68,7 @@ class RexTransformerTest {
 
   /** Converts a SQL string to a relational expression using mock schema. */
   private static RelNode toRel(String sql) {
-    final SqlToRelTestBase test = new SqlToRelTestBase() {
-    };
-    return test.createTester().convertSqlToRel(sql).rel;
+    return SqlToRelFixture.DEFAULT.withSql(sql).toRel();
   }
 
   @BeforeEach public void setUp() {

File: core/src/test/java/org/apache/calcite/test/ScannableTableTest.java
Patch:
@@ -456,7 +456,7 @@ private static Pair<Integer, Object> getFilter(boolean cooperative, List<RexNode
    * <a href="https://issues.apache.org/jira/browse/CALCITE-3758">[CALCITE-3758]
    * FilterTableScanRule generate wrong mapping for filter condition
    * when underlying is BindableTableScan</a>. */
-  @Test public void testPFTableInBindableConvention() {
+  @Test void testPFTableInBindableConvention() {
     final StringBuilder buf = new StringBuilder();
     final Table table = new BeatlesProjectableFilterableTable(buf, true);
     try (Hook.Closeable ignored = Hook.ENABLE_BINDABLE.addThread(Hook.propertyJ(true))) {

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCalcTest.java
Patch:
@@ -38,7 +38,6 @@ class EnumerableCalcTest {
   @Test void testCoalesceImplementation() {
     CalciteAssert.that()
         .withSchema("s", new ReflectiveSchema(new HrSchema()))
-        .query("?")
         .withRel(
             builder -> builder
                 .scan("s", "emps")
@@ -94,7 +93,6 @@ private void checkPosixRegex(
       String... expectedResult) {
     CalciteAssert.that()
         .withSchema("s", new ReflectiveSchema(new HrSchema()))
-        .query("?")
         .withRel(
             builder -> builder
                 .scan("s", "emps")

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCorrelateTest.java
Patch:
@@ -173,7 +173,6 @@ class EnumerableCorrelateTest {
    * RelBuilder: new method to create an anti-join</a>. */
   @Test void antiJoinCorrelate() {
     tester(false, new HrSchema())
-        .query("?")
         .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {
           // force the antijoin to run via EnumerableCorrelate
           // instead of EnumerableHashJoin(ANTI)
@@ -202,7 +201,6 @@ class EnumerableCorrelateTest {
 
   @Test void nonEquiAntiJoinCorrelate() {
     tester(false, new HrSchema())
-        .query("?")
         .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {
           // force the antijoin to run via EnumerableCorrelate
           // instead of EnumerableNestedLoopJoin
@@ -242,7 +240,6 @@ class EnumerableCorrelateTest {
   @Test void antiJoinCorrelateWithNullValues() {
     final Integer salesDeptNo = 10;
     tester(false, new HrSchema())
-        .query("?")
         .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {
           // force the antijoin to run via EnumerableCorrelate
           // instead of EnumerableHashJoin(ANTI)

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableHashJoinTest.java
Patch:
@@ -42,7 +42,7 @@ class EnumerableHashJoinTest {
             "select e.empid, e.name, d.name as dept from emps e join depts "
                 + "d on e.deptno=d.deptno")
         .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner ->
-        planner.removeRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE))
+            planner.removeRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE))
         .explainContains("EnumerableCalc(expr#0..4=[{inputs}], empid=[$t0], "
             + "name=[$t2], dept=[$t4])\n"
             + "  EnumerableHashJoin(condition=[=($1, $3)], joinType=[inner])\n"
@@ -174,7 +174,6 @@ class EnumerableHashJoinTest {
 
   @Test void semiJoinWithPredicate() {
     tester(false, new HrSchema())
-        .query("?")
         .withRel(
             // Retrieve employees with the top salary in their department. Equivalent SQL:
             //   SELECT e.name, e.salary FROM emps e

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableRepeatUnionHierarchyTest.java
Patch:
@@ -127,7 +127,6 @@ public void testHierarchy(
     final Schema schema = new ReflectiveSchema(new HierarchySchema());
     CalciteAssert.that()
         .withSchema("s", schema)
-        .query("?")
         .withRel(buildHierarchy(all, startIds, fromField, toField, maxDepth))
         .returnsOrdered(expected);
   }

File: core/src/test/java/org/apache/calcite/tools/PlannerTest.java
Patch:
@@ -97,7 +97,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.apache.calcite.test.RelMetadataTest.sortsAs;
+import static org.apache.calcite.test.Matchers.sortsAs;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.equalTo;

File: server/src/test/java/org/apache/calcite/test/ServerTest.java
Patch:
@@ -534,7 +534,7 @@ static Connection connect() throws SQLException {
     }
   }
 
-  @Test public void testDropWithFullyQualifiedNameWhenSchemaDoesntExist() throws Exception {
+  @Test void testDropWithFullyQualifiedNameWhenSchemaDoesntExist() throws Exception {
     try (Connection c = connect();
          Statement s = c.createStatement()) {
       checkDropWithFullyQualifiedNameWhenSchemaDoesntExist(s, "schema", "Schema");

File: core/src/main/java/org/apache/calcite/adapter/enumerable/NullPolicy.java
Patch:
@@ -25,6 +25,9 @@
  * ANY whenever possible.</p>
  */
 public enum NullPolicy {
+  /** Returns null if and only if all of the arguments are null;
+   * If all of the arguments are false return false otherwise true. */
+  ALL,
   /** Returns null if and only if one of the arguments are null. */
   STRICT,
   /** Returns null if one of the arguments is null, and possibly other times. */

File: piglet/src/test/java/org/apache/calcite/test/PigRelOpTest.java
Patch:
@@ -977,7 +977,7 @@ private Fluent pig(String script) {
         + "({20, ANALYST},2)\n"
         + "({10, MANAGER},1)\n"
         + "({null, CLERK},4)\n"
-        + "({null, null},14)\n"
+        + "(null,14)\n"
         + "({20, null},5)\n"
         + "({10, PRESIDENT},1)\n"
         + "({null, ANALYST},2)\n"
@@ -1028,7 +1028,7 @@ private Fluent pig(String script) {
         + "({20, ANALYST},2)\n"
         + "({10, MANAGER},1)\n"
         + "({null, CLERK},4)\n"
-        + "({null, null},14)\n"
+        + "(null,14)\n"
         + "({10, PRESIDENT},1)\n"
         + "({null, ANALYST},2)\n"
         + "({null, SALESMAN},4)\n"

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -417,7 +417,9 @@ private Object toJson(RelDataTypeField node) {
     if (node.getType().isStruct()) {
       map = jsonBuilder().map();
       map.put("fields", toJson(node.getType()));
+      map.put("nullable", node.getType().isNullable());
     } else {
+      //noinspection unchecked
       map = (Map<String, @Nullable Object>) toJson(node.getType());
     }
     map.put("name", node.getName());

File: core/src/main/java/org/apache/calcite/sql/fun/SqlArrayQueryConstructor.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.sql.fun;
 
 import org.apache.calcite.sql.SqlKind;
+import org.apache.calcite.sql.type.SqlTypeTransforms;
 
 /**
  * Definition of the SQL:2003 standard ARRAY query constructor, <code>
@@ -26,6 +27,6 @@ public class SqlArrayQueryConstructor extends SqlMultisetQueryConstructor {
   //~ Constructors -----------------------------------------------------------
 
   public SqlArrayQueryConstructor() {
-    super("ARRAY", SqlKind.ARRAY_QUERY_CONSTRUCTOR);
+    super("ARRAY", SqlKind.ARRAY_QUERY_CONSTRUCTOR, SqlTypeTransforms.TO_ARRAY);
   }
 }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMapQueryConstructor.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.sql.fun;
 
 import org.apache.calcite.sql.SqlKind;
+import org.apache.calcite.sql.type.SqlTypeTransforms;
 
 /**
  * Definition of the MAP query constructor, <code>
@@ -28,6 +29,6 @@ public class SqlMapQueryConstructor extends SqlMultisetQueryConstructor {
   //~ Constructors -----------------------------------------------------------
 
   public SqlMapQueryConstructor() {
-    super("MAP", SqlKind.MAP_QUERY_CONSTRUCTOR);
+    super("MAP", SqlKind.MAP_QUERY_CONSTRUCTOR, SqlTypeTransforms.TO_MAP);
   }
 }

File: core/src/test/java/org/apache/calcite/test/RelOptTestBase.java
Patch:
@@ -221,8 +221,8 @@ public Sql withPreRule(RelOptRule... rules) {
       return withPre(builder.build());
     }
 
-    public Sql with(HepPlanner hepPlanner) {
-      return new Sql(tester, sql, preProgram, hepPlanner, hooks, transforms, relFn);
+    public Sql with(RelOptPlanner planner) {
+      return new Sql(tester, sql, preProgram, planner, hooks, transforms, relFn);
     }
 
     public Sql with(HepProgram program) {

File: core/src/main/java/org/apache/calcite/rel/metadata/MetadataDef.java
Patch:
@@ -40,7 +40,8 @@ private MetadataDef(Class<M> metadataClass,
     this.metadataClass = metadataClass;
     this.handlerClass = handlerClass;
     this.methods = ImmutableList.copyOf(methods);
-    final Method[] handlerMethods = handlerClass.getDeclaredMethods();
+    final Method[] handlerMethods = Arrays.stream(handlerClass.getDeclaredMethods())
+        .filter(m -> !m.getName().equals("getDef")).toArray(i -> new Method[i]);
 
     // Handler must have the same methods as Metadata, each method having
     // additional "subclass-of-RelNode, RelMetadataQuery" parameters.

File: core/src/main/java/org/apache/calcite/rel/metadata/janino/RelMetadataHandlerGeneratorUtil.java
Patch:
@@ -62,7 +62,8 @@ public static HandlerNameAndGeneratedCode generateHandler(
         .getName();
     final String name =
         "GeneratedMetadata_" + simpleNameForHandler(handlerClass);
-    final Method[] declaredMethods = handlerClass.getDeclaredMethods();
+    final Method[] declaredMethods = Arrays.stream(handlerClass.getDeclaredMethods())
+        .filter(m -> !m.getName().equals("getDef")).toArray(i -> new Method[i]);
     Arrays.sort(declaredMethods, Comparator.comparing(Method::getName));
 
     final Map<MetadataHandler<?>, String> handlerToName = new LinkedHashMap<>();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java
Patch:
@@ -493,9 +493,8 @@ private static void createExpressions(RexBuilder rexBuilder,
       Map<RexInputRef, RexNode> singleMapping, Set<RexNode> result) {
     if (mapping.isEmpty()) {
       final RexReplacer replacer = new RexReplacer(singleMapping);
-      final List<RexNode> updatedPreds = new ArrayList<>(
-          RelOptUtil.conjunctions(
-              rexBuilder.copy(expr)));
+      final List<RexNode> updatedPreds = new ArrayList<>(1);
+      updatedPreds.add(rexBuilder.copy(expr));
       replacer.mutate(updatedPreds);
       result.addAll(updatedPreds);
     } else {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvFilterableTable.java
Patch:
@@ -18,11 +18,11 @@
 
 import org.apache.calcite.DataContext;
 import org.apache.calcite.adapter.file.CsvEnumerator;
-import org.apache.calcite.adapter.file.CsvFieldType;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.linq4j.AbstractEnumerable;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.Enumerator;
+import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelProtoDataType;
 import org.apache.calcite.rex.RexCall;
 import org.apache.calcite.rex.RexInputRef;
@@ -57,7 +57,7 @@ public CsvFilterableTable(Source source, RelProtoDataType protoRowType) {
 
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root, List<RexNode> filters) {
     JavaTypeFactory typeFactory = root.getTypeFactory();
-    final List<CsvFieldType> fieldTypes = getFieldTypes(typeFactory);
+    final List<RelDataType> fieldTypes = getFieldTypes(typeFactory);
     final @Nullable String[] filterValues = new String[fieldTypes.size()];
     filters.removeIf(filter -> addFilter(filter, filterValues));
     final List<Integer> fields = ImmutableIntList.identity(fieldTypes.size());

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvScannableTable.java
Patch:
@@ -18,11 +18,11 @@
 
 import org.apache.calcite.DataContext;
 import org.apache.calcite.adapter.file.CsvEnumerator;
-import org.apache.calcite.adapter.file.CsvFieldType;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.linq4j.AbstractEnumerable;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.Enumerator;
+import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelProtoDataType;
 import org.apache.calcite.schema.ScannableTable;
 import org.apache.calcite.util.ImmutableIntList;
@@ -52,7 +52,7 @@ public class CsvScannableTable extends CsvTable
 
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
     JavaTypeFactory typeFactory = root.getTypeFactory();
-    final List<CsvFieldType> fieldTypes = getFieldTypes(typeFactory);
+    final List<RelDataType> fieldTypes = getFieldTypes(typeFactory);
     final List<Integer> fields = ImmutableIntList.identity(fieldTypes.size());
     final AtomicBoolean cancelFlag = DataContext.Variable.CANCEL_FLAG.get(root);
     return new AbstractEnumerable<@Nullable Object[]>() {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvStreamScannableTable.java
Patch:
@@ -18,11 +18,11 @@
 
 import org.apache.calcite.DataContext;
 import org.apache.calcite.adapter.file.CsvEnumerator;
-import org.apache.calcite.adapter.file.CsvFieldType;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.linq4j.AbstractEnumerable;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.Enumerator;
+import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelProtoDataType;
 import org.apache.calcite.schema.ScannableTable;
 import org.apache.calcite.schema.StreamableTable;
@@ -58,7 +58,7 @@ public class CsvStreamScannableTable extends CsvScannableTable
 
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
     JavaTypeFactory typeFactory = root.getTypeFactory();
-    final List<CsvFieldType> fieldTypes = getFieldTypes(typeFactory);
+    final List<RelDataType> fieldTypes = getFieldTypes(typeFactory);
     final List<Integer> fields = ImmutableIntList.identity(fieldTypes.size());
     final AtomicBoolean cancelFlag = DataContext.Variable.CANCEL_FLAG.get(root);
     return new AbstractEnumerable<@Nullable Object[]>() {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvTable.java
Patch:
@@ -17,7 +17,6 @@
 package org.apache.calcite.adapter.csv;
 
 import org.apache.calcite.adapter.file.CsvEnumerator;
-import org.apache.calcite.adapter.file.CsvFieldType;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
@@ -37,7 +36,7 @@ public abstract class CsvTable extends AbstractTable {
   protected final Source source;
   protected final @Nullable RelProtoDataType protoRowType;
   private @Nullable RelDataType rowType;
-  private @Nullable List<CsvFieldType> fieldTypes;
+  private @Nullable List<RelDataType> fieldTypes;
 
   /** Creates a CsvTable. */
   CsvTable(Source source, @Nullable RelProtoDataType protoRowType) {
@@ -57,7 +56,7 @@ public abstract class CsvTable extends AbstractTable {
   }
 
   /** Returns the field types of this CSV table. */
-  public List<CsvFieldType> getFieldTypes(RelDataTypeFactory typeFactory) {
+  public List<RelDataType> getFieldTypes(RelDataTypeFactory typeFactory) {
     if (fieldTypes == null) {
       fieldTypes = new ArrayList<>();
       CsvEnumerator.deduceRowType((JavaTypeFactory) typeFactory, source,

File: file/src/main/java/org/apache/calcite/adapter/file/CsvTable.java
Patch:
@@ -36,7 +36,7 @@ public abstract class CsvTable extends AbstractTable {
   protected final Source source;
   protected final RelProtoDataType protoRowType;
   private RelDataType rowType;
-  private List<CsvFieldType> fieldTypes;
+  private List<RelDataType> fieldTypes;
 
   /** Creates a CsvTable. */
   CsvTable(Source source, RelProtoDataType protoRowType) {
@@ -56,7 +56,7 @@ public abstract class CsvTable extends AbstractTable {
   }
 
   /** Returns the field types of this CSV table. */
-  public List<CsvFieldType> getFieldTypes(RelDataTypeFactory typeFactory) {
+  public List<RelDataType> getFieldTypes(RelDataTypeFactory typeFactory) {
     if (fieldTypes == null) {
       fieldTypes = new ArrayList<>();
       CsvEnumerator.deduceRowType((JavaTypeFactory) typeFactory, source,

File: file/src/main/java/org/apache/calcite/adapter/file/FileFieldType.java
Patch:
@@ -30,8 +30,6 @@
  * <p>Usually, and unless specified explicitly in the header row, a field is
  * of type {@link #STRING}. But specifying the field type in the fields
  * makes it easier to write SQL.
- *
- * <p>Trivially modified from CsvFieldType.
  */
 enum FileFieldType {
   STRING(null, String.class),

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -174,7 +174,7 @@ protected void apply(RelOptRuleCall call, @Nullable LogicalProject project,
     // Compute the values they reduce to.
     final RelOptPredicateList predicates = RelOptPredicateList.EMPTY;
     ReduceExpressionsRule.reduceExpressions(values, reducibleExps, predicates,
-        false, true);
+        false, true, false);
 
     int changeCount = 0;
     final ImmutableList.Builder<ImmutableList<RexLiteral>> tuplesBuilder =

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -1682,13 +1682,14 @@ private Builder builder(RelNode rel, Set<Clause> clauses) {
             switch (selectItem.getKind()) {
             case AS:
               final SqlCall asCall = (SqlCall) selectItem;
-              if (aliasRef) {
+              SqlNode alias = asCall.operand(1);
+              if (aliasRef && !SqlUtil.isGeneratedAlias(((SqlIdentifier) alias).getSimple())) {
                 // For BigQuery, given the query
                 //   SELECT SUM(x) AS x FROM t HAVING(SUM(t.x) > 0)
                 // we can generate
                 //   SELECT SUM(x) AS x FROM t HAVING(x > 0)
                 // because 'x' in HAVING resolves to the 'AS x' not 't.x'.
-                return asCall.operand(1);
+                return alias;
               }
               return asCall.operand(0);
             default:

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -105,7 +105,6 @@
 import java.util.Deque;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedSet;
@@ -1163,7 +1162,7 @@ public List<SqlNode> createAsFullOperands(RelDataType rowType, SqlNode leftOpera
     result.add(leftOperand);
     result.add(new SqlIdentifier(alias, POS));
     Ord.forEach(rowType.getFieldNames(), (fieldName, i) -> {
-      if (fieldName.toLowerCase(Locale.ROOT).startsWith("expr$")) {
+      if (SqlUtil.isGeneratedAlias(fieldName)) {
         fieldName = "col_" + i;
       }
       result.add(new SqlIdentifier(fieldName, POS));

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -116,7 +116,6 @@
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.function.Function;
@@ -1888,8 +1887,7 @@ public void stripTrivialAliases(SqlNode node) {
             if (n.getKind() == SqlKind.AS) {
               final SqlCall call = (SqlCall) n;
               final SqlIdentifier identifier = call.operand(1);
-              if (identifier.getSimple().toLowerCase(Locale.ROOT)
-                  .startsWith("expr$")) {
+              if (SqlUtil.isGeneratedAlias(identifier.getSimple())) {
                 nodeList.set(i, call.operand(0));
               }
             }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -1332,7 +1332,8 @@ public interface Suggester {
   }
 
   public static final Suggester EXPR_SUGGESTER =
-      (original, attempt, size) -> Util.first(original, "EXPR$") + attempt;
+      (original, attempt, size) ->
+          Util.first(original, SqlUtil.GENERATED_EXPR_ALIAS_PREFIX) + attempt;
 
   public static final Suggester F_SUGGESTER =
       (original, attempt, size) -> Util.first(original, "$f")

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -4378,8 +4378,8 @@ private String deriveAlias(
       Collection<String> aliases,
       final int ordinal) {
     String alias = validator().deriveAlias(node, ordinal);
-    if ((alias == null) || aliases.contains(alias)) {
-      String aliasBase = (alias == null) ? "EXPR$" : alias;
+    if (alias == null || aliases.contains(alias)) {
+      final String aliasBase = Util.first(alias, SqlUtil.GENERATED_EXPR_ALIAS_PREFIX);
       for (int j = 0;; j++) {
         alias = aliasBase + j;
         if (!aliases.contains(alias)) {

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -86,6 +86,7 @@
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlOperator;
+import org.apache.calcite.sql.SqlUtil;
 import org.apache.calcite.sql.SqlWindow;
 import org.apache.calcite.sql.fun.SqlCountAggFunction;
 import org.apache.calcite.sql.fun.SqlLikeOperator;
@@ -2686,7 +2687,7 @@ public RelBuilder values(@Nullable String[] fieldNames, @Nullable Object... valu
     assert tupleList.size() == rowCount;
     final List<String> fieldNameList =
         Util.transformIndexed(Arrays.asList(fieldNames), (name, i) ->
-            name != null ? name : "expr$" + i);
+            name != null ? name : SqlUtil.deriveAliasFromOrdinal(i));
     return values(tupleList, fieldNameList);
   }
 

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -3043,7 +3043,7 @@ private static RelNode groupIdRel(RelBuilder builder, boolean extra) {
         "LogicalValues(tuples=[[{ null, 1, 'abc' }, { false, null, 'longer string' }]])\n";
     assertThat(root, hasTree(expected));
     final String expectedType =
-        "RecordType(BOOLEAN a, INTEGER expr$1, CHAR(13) NOT NULL c) NOT NULL";
+        "RecordType(BOOLEAN a, INTEGER EXPR$1, CHAR(13) NOT NULL c) NOT NULL";
     assertThat(root.getRowType().getFullTypeString(), is(expectedType));
   }
 

File: core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
Patch:
@@ -575,7 +575,7 @@ Iterable<Object> _createIterable(StatementHandle handle,
       //noinspection unchecked
       final CalcitePrepare.CalciteSignature<Object> calciteSignature =
           (CalcitePrepare.CalciteSignature<Object>) signature;
-      return getConnection().enumerable(handle, calciteSignature);
+      return getConnection().enumerable(handle, calciteSignature, parameterValues);
     } catch (SQLException e) {
       throw new RuntimeException(e.getMessage());
     }

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -837,7 +837,7 @@ public static boolean canCastFrom(
             toType, fromType.getFieldList().get(0).getType(), coerce);
       } else if (toTypeName == SqlTypeName.ROW) {
         if (fromTypeName != SqlTypeName.ROW) {
-          return false;
+          return fromTypeName == SqlTypeName.NULL;
         }
         int n = toType.getFieldCount();
         if (fromType.getFieldCount() != n) {

File: core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java
Patch:
@@ -19,10 +19,10 @@
 import org.apache.calcite.config.CalciteSystemProperty;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
+import org.codehaus.commons.compiler.util.resource.MapResourceFinder;
+import org.codehaus.commons.compiler.util.resource.ResourceFinder;
 import org.codehaus.janino.JavaSourceClassLoader;
 import org.codehaus.janino.util.ClassFile;
-import org.codehaus.janino.util.resource.MapResourceFinder;
-import org.codehaus.janino.util.resource.ResourceFinder;
 
 import java.io.File;
 import java.io.FileOutputStream;

File: ubenchmark/src/jmh/java/org/apache/calcite/adapter/enumerable/CodeGenerationBenchmark.java
Patch:
@@ -185,7 +185,8 @@ public void setup() {
 
         ICompilerFactory compilerFactory;
         try {
-          compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory();
+          compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory(
+              CodeGenerationBenchmark.class.getClassLoader());
         } catch (Exception e) {
           throw new IllegalStateException(
               "Unable to instantiate java compiler", e);

File: core/src/main/java/org/apache/calcite/CalciteImmutable.java
Patch:
@@ -30,6 +30,7 @@
     visibility = Value.Style.ImplementationVisibility.PACKAGE,
     defaults = @Value.Immutable(builder = true, singleton = true),
     get = {"is*", "get*"},
-    init = "with*"
+    init = "with*",
+    passAnnotations = SuppressWarnings.class
 )
 public @interface CalciteImmutable { }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableBatchNestedLoopJoinRule.java
Patch:
@@ -166,7 +166,7 @@ public interface Config extends RelRule.Config {
      *
      * <p>Warning: if the batch size is around or bigger than 1000 there
      * can be an error because the generated code exceeds the size limit. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.IntDefault(100)
     @Value.Default default int batchSize() {
       return 100;

File: core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
Patch:
@@ -191,19 +191,19 @@ public interface Config extends RelRule.Config {
           }
         }).build();
 
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     RelTrait inTrait();
 
     /** Sets {@link #inTrait}. */
     Config withInTrait(RelTrait trait);
 
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     RelTrait outTrait();
 
     /** Sets {@link #outTrait}. */
     Config withOutTrait(RelTrait trait);
 
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     Function<Config, ConverterRule> ruleFactory();
 
     /** Sets {@link #outTrait}. */

File: core/src/main/java/org/apache/calcite/rel/convert/TraitMatchingRule.java
Patch:
@@ -98,7 +98,7 @@ public interface Config extends RelRule.Config {
 
     /** Returns the rule to be restricted; rule must take a single
      * operand expecting a single input. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     ConverterRule converterRule();
 
     /** Sets {@link #converterRule()}. */

File: core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java
Patch:
@@ -263,7 +263,7 @@ boolean highlightNode(RelNode node) {
   /**
    * Options for displaying the rel node plan in dot format.
    */
-  @Value.Immutable(singleton = true)
+  @Value.Immutable
   public interface WriteOption {
 
     /** Default configuration. */

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -943,7 +943,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Whether to use GROUPING SETS, default true. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(true)
     @Value.Default default boolean isUsingGroupingSets() {
       return true;

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
Patch:
@@ -530,7 +530,7 @@ public interface Config extends RelRule.Config {
      * {@code throwIfNotUnique} is true, the query would throw because of the
      * values [100, 120]; if false, the query would sum the distinct values
      * [100, 120, 150]. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(true)
     @Value.Default default boolean throwIfNotUnique() {
       return true;

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -470,7 +470,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Whether to push down aggregate functions, default false. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default
     default boolean isAllowFunctions() {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -850,7 +850,7 @@ public interface Config extends RelRule.Config {
       return new AggregateReduceFunctionsRule(this);
     }
 
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @Nullable Set<SqlKind> functionsToReduce();
 
     /** Sets {@link #functionsToReduce}. */

File: core/src/main/java/org/apache/calcite/rel/rules/CoerceInputsRule.java
Patch:
@@ -124,7 +124,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Whether to coerce names. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default default boolean isCoerceNames() {
       return false;
@@ -134,7 +134,7 @@ public interface Config extends RelRule.Config {
     Config withCoerceNames(boolean coerceNames);
 
     /** Class of {@link RelNode} to coerce to. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     Class<? extends RelNode> consumerRelClass();
 
     /** Sets {@link #consumerRelClass()}. */

File: core/src/main/java/org/apache/calcite/rel/rules/ExchangeRemoveConstantKeysRule.java
Patch:
@@ -195,7 +195,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Forwards a call to {@link #onMatch(RelOptRuleCall)}. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @Value.Parameter
     MatchHandler<ExchangeRemoveConstantKeysRule> matchHandler();
 

File: core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
Patch:
@@ -221,7 +221,7 @@ public interface Config extends RelRule.Config {
 
     /** Whether to create a {@link Filter} of the same convention as the
      * matched Filter. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(true)
     @Value.Default default boolean isCopyFilter() {
       return true;
@@ -232,7 +232,7 @@ public interface Config extends RelRule.Config {
 
     /** Whether to create a {@link Project} of the same convention as the
      * matched Project. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(true)
     @Value.Default default boolean isCopyProject() {
       return true;

File: core/src/main/java/org/apache/calcite/rel/rules/JoinAssociateRule.java
Patch:
@@ -179,7 +179,7 @@ public interface Config extends RelRule.Config {
      * Whether to emit the new join tree if the new top or bottom join has a condition which
      * is always {@code TRUE}.
      */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(true)
     @Value.Default default boolean isAllowAlwaysTrueCondition() {
       return true;

File: core/src/main/java/org/apache/calcite/rel/rules/JoinCommuteRule.java
Patch:
@@ -251,7 +251,7 @@ default Config withOperandFor(Class<? extends Join> joinClass) {
     }
 
     /** Whether to swap outer joins; default false. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default default boolean isSwapOuter() {
       return false;
@@ -262,7 +262,7 @@ default Config withOperandFor(Class<? extends Join> joinClass) {
 
     /** Whether to emit the new join tree if the join condition is {@code TRUE}
      * (that is, cartesian joins); default true. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(true)
     @Value.Default default boolean isAllowAlwaysTrueCondition() {
       return true;

File: core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
Patch:
@@ -428,7 +428,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Whether to include outer joins, default false. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default default boolean isIncludeOuter() {
       return false;

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java
Patch:
@@ -348,7 +348,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Whether to push on the right. If false, push to the left. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default default boolean isRight() {
       return false;

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectCorrelateTransposeRule.java
Patch:
@@ -219,7 +219,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Defines when an expression should not be pushed. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     PushProjector.ExprCondition preserveExprCondition();
 
     /** Sets {@link #preserveExprCondition()}. */

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectFilterTransposeRule.java
Patch:
@@ -244,7 +244,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Expressions that should be preserved in the projection. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @Value.Default default PushProjector.ExprCondition preserveExprCondition() {
       return expr -> false;
     }
@@ -254,7 +254,7 @@ public interface Config extends RelRule.Config {
 
     /** Whether to push whole expressions from the project;
      * if false (the default), only pushes references. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default default boolean isWholeProject() {
       return false;
@@ -265,7 +265,7 @@ public interface Config extends RelRule.Config {
 
     /** Whether to push whole expressions from the filter;
      * if false (the default), only pushes references. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default default boolean isWholeFilter() {
       return false;

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinTransposeRule.java
Patch:
@@ -167,7 +167,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Defines when an expression should not be pushed. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     PushProjector.ExprCondition preserveExprCondition();
 
     /** Sets {@link #preserveExprCondition()}. */

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectMergeRule.java
Patch:
@@ -157,7 +157,7 @@ public interface Config extends RelRule.Config {
 
     /** Limit how much complexity can increase during merging.
      * Default is {@link #DEFAULT_BLOAT} (100). */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.IntDefault(ProjectMergeRule.DEFAULT_BLOAT)
     @Value.Default default int bloat() {
       return ProjectMergeRule.DEFAULT_BLOAT;
@@ -167,7 +167,7 @@ public interface Config extends RelRule.Config {
     Config withBloat(int bloat);
 
     /** Whether to always merge projects, default true. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(true)
     @Value.Default default boolean force() {
       return true;

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectSetOpTransposeRule.java
Patch:
@@ -128,7 +128,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Defines when an expression should not be pushed. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     PushProjector.ExprCondition preserveExprCondition();
 
     /** Sets {@link #preserveExprCondition()}. */

File: core/src/main/java/org/apache/calcite/rel/rules/SortUnionTransposeRule.java
Patch:
@@ -119,7 +119,7 @@ public interface Config extends RelRule.Config {
 
     /** Whether to match a Sort whose {@link Sort#fetch} is null. Generally
      * this only makes sense if the Union preserves order (and merges). */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     @Value.Default default boolean matchNullFetch() {
       return false;

File: core/src/main/java/org/apache/calcite/rel/rules/SpatialRules.java
Patch:
@@ -86,6 +86,7 @@
  * is still present, but is evaluated after the approximate predicate has
  * eliminated many potential matches.
  */
+@Value.Enclosing
 public abstract class SpatialRules {
 
   private SpatialRules() {}
@@ -316,10 +317,9 @@ private static RexNode hilbertPredicate(RexBuilder rexBuilder,
     }
 
     /** Rule configuration. */
-    @Value.Immutable(singleton = true)
-    @Value.Style(typeImmutable = "ImmutableFilterHilbertRuleConfig")
+    @Value.Immutable
     public interface Config extends RelRule.Config {
-      Config DEFAULT = ImmutableFilterHilbertRuleConfig.of()
+      Config DEFAULT = ImmutableSpatialRules.Config.of()
           .withOperandSupplier(b ->
               b.operand(Filter.class)
                   .predicate(f -> DWITHIN_FINDER.inFilter(f)

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -890,7 +890,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Forwards a call to {@link #onMatch(RelOptRuleCall)}. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     MatchHandler<SubQueryRemoveRule> matchHandler();
 
     /** Sets {@link #matchHandler()}. */

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -287,7 +287,7 @@ public interface Config extends RelRule.Config {
     }
 
     /** Forwards a call to {@link #onMatch(RelOptRuleCall)}. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @Value.Parameter
     MatchHandler<ValuesReduceRule> matchHandler();
 

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
Patch:
@@ -1393,23 +1393,23 @@ protected enum MatchModality {
   public interface Config extends RelRule.Config {
     /** Whether to generate rewritings containing union if the query results
      * are contained within the view results. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     boolean generateUnionRewriting();
 
     /** Sets {@link #generateUnionRewriting()}. */
     Config withGenerateUnionRewriting(boolean b);
 
     /** If we generate union rewriting, we might want to pull up projections
      * from the query itself to maximize rewriting opportunities. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     @Nullable HepProgram unionRewritingPullProgram();
 
     /** Sets {@link #unionRewritingPullProgram()}. */
     Config withUnionRewritingPullProgram(@Nullable HepProgram program);
 
     /** Whether we should create the rewriting in the minimal subtree of plan
      * operators. */
-    @ImmutableBeans.Property
+    @SuppressWarnings("deprecation") @ImmutableBeans.Property
     boolean fastBailOut();
 
     /** Sets {@link #fastBailOut()}. */

File: core/src/main/java/org/apache/calcite/sql/SqlWriterConfig.java
Patch:
@@ -22,7 +22,7 @@
 import org.immutables.value.Value;
 
 /** Configuration for {@link SqlWriter} and {@link SqlPrettyWriter}. */
-@Value.Immutable(singleton = true)
+@Value.Immutable
 public interface SqlWriterConfig {
   /** Returns the dialect. */
   @Nullable SqlDialect dialect();

File: pig/src/test/java/org/apache/calcite/test/PigRelBuilderStyleTest.java
Patch:
@@ -262,10 +262,9 @@ private RelOptPlanner getVolcanoPlanner(RelNode root) {
                 b0.operand(Filter.class).oneInput(b1 ->
                     b1.operand(Join.class).anyInputs()))
             .withDescription("FilterJoinRule:filter")
-            .as(FilterIntoJoinRule.Config.class)
+            .as(FilterIntoJoinRule.FilterIntoJoinRuleConfig.class)
             .withSmart(true)
             .withPredicate((join, joinType, exp) -> true)
-            .as(FilterIntoJoinRule.Config.class)
             .toRule());
     planner.setRoot(root);
     return planner;

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -36,7 +36,6 @@
 import org.apache.calcite.rel.RelCollationTraitDef;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelRoot;
-import org.apache.calcite.rel.metadata.CachingRelMetadataProvider;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.rex.RexBuilder;
@@ -367,7 +366,7 @@ private RexBuilder createRexBuilder() {
       RelNode rel) {
     ensure(State.STATE_5_CONVERTED);
     rel.getCluster().setMetadataProvider(
-        new CachingRelMetadataProvider(
+        new org.apache.calcite.rel.metadata.CachingRelMetadataProvider(
             requireNonNull(rel.getCluster().getMetadataProvider(), "metadataProvider"),
             rel.getCluster().getPlanner()));
     Program program = programs.get(ruleSetIndex);

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1548,7 +1548,7 @@ private RelNode convertProjectAsCalc(String s) {
     } catch (IllegalArgumentException e) {
       final String value = "No handler for method [public abstract java.lang.String "
           + "org.apache.calcite.test.RelMetadataTest$ColType.getColType(int)] "
-          + "applied to argument of type [interface org.apache.calcite.rel.RelNode]; "
+          + "applied to argument of type [class org.apache.calcite.rel.logical.LogicalFilter]; "
           + "we recommend you create a catch-all (RelNode) handler";
       assertThat(e.getMessage(), is(value));
     }
@@ -1582,7 +1582,7 @@ private RelNode convertProjectAsCalc(String s) {
     } catch (IllegalArgumentException e) {
       final String value = "No handler for method [public abstract java.lang.String "
           + "org.apache.calcite.test.RelMetadataTest$ColType.getColType(int)] "
-          + "applied to argument of type [interface org.apache.calcite.rel.RelNode]; "
+          + "applied to argument of type [class org.apache.calcite.rel.logical.LogicalFilter]; "
           + "we recommend you create a catch-all (RelNode) handler";
       assertThat(e.getMessage(), is(value));
     }

File: core/src/test/java/org/apache/calcite/test/MaterializationTest.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.calcite.test.schemata.hr.Dependent;
 import org.apache.calcite.test.schemata.hr.Employee;
 import org.apache.calcite.test.schemata.hr.Event;
+import org.apache.calcite.test.schemata.hr.HrSchema;
 import org.apache.calcite.test.schemata.hr.Location;
 import org.apache.calcite.util.JsonBuilder;
 import org.apache.calcite.util.Smalls;
@@ -220,7 +221,7 @@ public class MaterializationTest {
           + "      name: 'hr',\n"
           + "      factory: 'org.apache.calcite.adapter.java.ReflectiveSchema$Factory',\n"
           + "      operand: {\n"
-          + "        class: 'org.apache.calcite.test.JdbcTest$HrSchema'\n"
+          + "        class: '" + HrSchema.class.getName() + "'\n"
           + "      }\n"
           + "    }\n"
           + "  ]\n"

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -5033,7 +5033,6 @@ private CalciteAssert.AssertQuery predicate(String foo) {
         .convertMatches(relNode -> {
           String s = RelOptUtil.toString(relNode);
           assertThat(s, not(containsString("Correlate")));
-          return null;
         });
   }
 

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -381,7 +381,6 @@ private static CalciteAssert.AssertThat modelWithLattices(
                   containsStringLinux(
                       "LogicalAggregate(group=[{2, 10}])\n"
                           + "  StarTableScan(table=[[adhoc, star]])\n")));
-          return null;
         });
     assertThat(counter.intValue(), equalTo(2));
     that.explainContains(""

File: plus/src/test/java/org/apache/calcite/adapter/tpch/TpchTest.java
Patch:
@@ -828,7 +828,6 @@ private CalciteAssert.AssertThat with() {
         .convertMatches(relNode -> {
           String s = RelOptUtil.toString(relNode);
           assertThat(s, not(containsString("Correlator")));
-          return null;
         });
   }
 

File: testkit/src/main/java/org/apache/calcite/sql/test/AbstractSqlTester.java
Patch:
@@ -675,7 +675,7 @@ private boolean isNull(SqlNode sqlNode) {
               sql,
               pos.getEndLineNum(),
               pos.getEndColumnNum()) + 1;
-      String param = "p" + (p++);
+      String param = "p" + p++;
       values.add(Pair.of(sql2.substring(start, end), param));
       sql2 = sql2.substring(0, start)
           + param

File: testkit/src/main/java/org/apache/calcite/test/ConnectionSpec.java
Patch:
@@ -16,9 +16,12 @@
  */
 package org.apache.calcite.test;
 
+import com.google.errorprone.annotations.Immutable;
+
 /** Information necessary to create a JDBC connection.
  *
  * <p>Specify one to run tests against a different database. */
+@Immutable
 public class ConnectionSpec {
   public final String url;
   public final String username;

File: testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java
Patch:
@@ -204,7 +204,6 @@ protected void diffTestLog() throws IOException {
    * @param refFile Reference log
    */
   protected void diffFile(File logFile, File refFile) throws IOException {
-    int n = 0;
     BufferedReader logReader = null;
     BufferedReader refReader = null;
     try {

File: testkit/src/main/java/org/apache/calcite/test/Matchers.java
Patch:
@@ -242,6 +242,7 @@ public static Matcher<RelNode> hasHints(final String value) {
    * <p>This method is necessary because {@link RangeSet#toString()} changed
    * behavior. Guava 19 - 28 used a unicode symbol;Guava 29 onwards uses "..".
    */
+  @SuppressWarnings("BetaApi")
   public static Matcher<RangeSet> isRangeSet(final String value) {
     return compose(Is.is(value), input -> {
       // Change all '\u2025' (a unicode symbol denoting a range) to '..',

File: testkit/src/main/java/org/apache/calcite/test/QuidemTest.java
Patch:
@@ -100,6 +100,7 @@ private Method findMethod(String path) {
     return m;
   }
 
+  @SuppressWarnings("BetaApi")
   protected static Collection<Object[]> data(String first) {
     // inUrl = "file:/home/fred/calcite/core/target/test-classes/sql/agg.iq"
     final URL inUrl = QuidemTest.class.getResource("/" + n2u(first));

File: testkit/src/main/java/org/apache/calcite/test/schemata/catchall/CatchallSchema.java
Patch:
@@ -35,6 +35,7 @@
  * Object whose fields are relations. Called "catch-all" because it's OK
  * if tests add new fields.
  */
+@SuppressWarnings("UnusedVariable")
 public class CatchallSchema {
   public final Enumerable<Employee> enumerable =
       Linq4j.asEnumerable(
@@ -45,6 +46,7 @@ public class CatchallSchema {
 
   public final BitSet bitSet = new BitSet(1);
 
+  @SuppressWarnings("JavaUtilDate")
   public final EveryType[] everyTypes = {
       new EveryType(
           false, (byte) 0, (char) 0, (short) 0, 0, 0L, 0F, 0D,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableProjectToCalcRule.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.adapter.enumerable;
 
 import org.apache.calcite.plan.RelOptRuleCall;
+import org.apache.calcite.plan.RelRule;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.rules.ProjectToCalcRule;
 import org.apache.calcite.rex.RexProgram;
@@ -53,7 +54,7 @@ public EnumerableProjectToCalcRule(RelBuilderFactory relBuilderFactory) {
 
   /** Rule configuration. */
   public interface Config extends ProjectToCalcRule.Config {
-    Config DEFAULT = ProjectToCalcRule.Config.DEFAULT
+    Config DEFAULT = RelRule.Config.EMPTY
         .withOperandSupplier(b ->
             b.operand(EnumerableProject.class).anyInputs())
         .as(Config.class);

File: core/src/main/java/org/apache/calcite/package-info.java
Patch:
@@ -18,4 +18,5 @@
 /**
  * Main package for Calcite, the dynamic data management platform.
  */
+@CalciteImmutable
 package org.apache.calcite;

File: core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -26,7 +26,6 @@
 import org.apache.calcite.sql.dialect.AnsiSqlDialect;
 import org.apache.calcite.sql.dialect.CalciteSqlDialect;
 import org.apache.calcite.sql.util.SqlString;
-import org.apache.calcite.util.ImmutableBeans;
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.trace.CalciteLogger;
 
@@ -259,7 +258,7 @@ public class SqlPrettyWriter implements SqlWriter {
    * Default SqlWriterConfig, reduce the overhead of "ImmutableBeans.create"
    */
   private static final SqlWriterConfig CONFIG =
-      ImmutableBeans.create(SqlWriterConfig.class)
+      SqlWriterConfig.of()
           .withDialect(CalciteSqlDialect.DEFAULT);
 
   /**

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java
Patch:
@@ -80,7 +80,7 @@ public class JdbcTable extends AbstractQueryableTable
     implements TranslatableTable, ScannableTable, ModifiableTable {
   @SuppressWarnings("methodref.receiver.bound.invalid")
   private final Supplier<RelProtoDataType> protoRowTypeSupplier =
-      Suppliers.memoize(this::supplyProto);
+      Suppliers.memoize(this::supplyProto)::get;
   public final JdbcSchema jdbcSchema;
   public final String jdbcCatalogName;
   public final String jdbcSchemaName;

File: core/src/main/java/org/apache/calcite/tools/Frameworks.java
Patch:
@@ -62,7 +62,7 @@ public class Frameworks {
 
   /** Caches an instance of the JDBC driver. */
   private static final Supplier<Driver> DRIVER_SUPPLIER =
-      Suppliers.memoize(Driver::new);
+      Suppliers.memoize(Driver::new)::get;
 
   private Frameworks() {
   }

File: core/src/test/java/org/apache/calcite/test/SqlToRelTestBase.java
Patch:
@@ -102,8 +102,10 @@ public abstract class SqlToRelTestBase {
   //~ Static fields/initializers ---------------------------------------------
 
   protected static final String NL = System.getProperty("line.separator");
+
   protected static final Supplier<RelDataTypeFactory> DEFAULT_TYPE_FACTORY_SUPPLIER =
-      Suppliers.memoize(() -> new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT));
+      Suppliers.memoize(() ->
+          new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT))::get;
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/sql/SqlDialectFactoryImpl.java
Patch:
@@ -129,7 +129,8 @@ public class SqlDialectFactoryImpl implements SqlDialectFactory {
       return new MysqlSqlDialect(
           c.withDataTypeSystem(MysqlSqlDialect.MYSQL_TYPE_SYSTEM));
     case "REDSHIFT":
-      return new RedshiftSqlDialect(c);
+      return new RedshiftSqlDialect(
+          c.withDataTypeSystem(RedshiftSqlDialect.TYPE_SYSTEM));
     case "SNOWFLAKE":
       return new SnowflakeSqlDialect(c);
     case "SPARK":

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterStructsTest.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.rel.rel2sql;
 
+import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.sql.dialect.CalciteSqlDialect;
 import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.test.CalciteAssert;
@@ -36,7 +37,7 @@ class RelToSqlConverterStructsTest {
   private RelToSqlConverterTest.Sql sql(String sql) {
     return new RelToSqlConverterTest.Sql(CalciteAssert.SchemaSpec.MY_DB, sql,
         CalciteSqlDialect.DEFAULT, SqlParser.Config.DEFAULT, ImmutableSet.of(),
-        UnaryOperator.identity(), null, ImmutableList.of());
+        UnaryOperator.identity(), null, ImmutableList.of(), RelDataTypeSystem.DEFAULT);
   }
 
   @Test void testNestedSchemaSelectStar() {

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -76,6 +76,7 @@ public class PlannerImpl implements Planner, ViewExpander {
   private final @Nullable RelOptCostFactory costFactory;
   private final Context context;
   private final CalciteConnectionConfig connectionConfig;
+  private final RelDataTypeSystem typeSystem;
 
   /** Holds the trait definitions to be registered with planner. May be null. */
   private final @Nullable ImmutableList<RelTraitDef> traitDefs;
@@ -118,6 +119,7 @@ public PlannerImpl(FrameworkConfig config) {
     this.executor = config.getExecutor();
     this.context = config.getContext();
     this.connectionConfig = connConfig(context, parserConfig);
+    this.typeSystem = config.getTypeSystem();
     reset();
   }
 
@@ -176,9 +178,6 @@ private void ready() {
     }
     ensure(State.STATE_1_RESET);
 
-    RelDataTypeSystem typeSystem =
-        connectionConfig.typeSystem(RelDataTypeSystem.class,
-            RelDataTypeSystem.DEFAULT);
     typeFactory = new JavaTypeFactoryImpl(typeSystem);
     RelOptPlanner planner = this.planner = new VolcanoPlanner(costFactory, context);
     RelOptUtil.registerDefaultRules(planner,

File: core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.rex.RexVisitorImpl;
 import org.apache.calcite.sql.SqlOperator;
+import org.apache.calcite.sql.SqlUtil;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.util.BitSets;
 import org.apache.calcite.util.ImmutableBitSet;
@@ -540,6 +541,7 @@ public Project createProjectRefsAndExprs(
         adjustments[idx] = -offset;
       }
     }
+    int preserveExpOrdinal = 0;
     for (RexNode projExpr : preserveExprs) {
       RexNode newExpr;
       if (adjust) {
@@ -564,7 +566,7 @@ public Project createProjectRefsAndExprs(
       newProjects.add(
           Pair.of(
               newExpr,
-              ((RexCall) projExpr).getOperator().getName()));
+              SqlUtil.deriveAliasFromOrdinal(preserveExpOrdinal++)));
     }
 
     return (Project) relBuilder.push(projChild)

File: core/src/test/java/org/apache/calcite/test/TopDownOptTest.java
Patch:
@@ -820,7 +820,7 @@ public void check() {
 
     final Sql sql =
         new Sql(tester, this.sql, null, planner, ImmutableMap.of(),
-            ImmutableList.of());
+            ImmutableList.of(), null);
     sql.check();
   }
 }

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -198,6 +198,8 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(NULLIF)",
           "KEYWORD(OCTET_LENGTH)",
           "KEYWORD(OVERLAY)",
+          "KEYWORD(PERCENTILE_CONT)",
+          "KEYWORD(PERCENTILE_DISC)",
           "KEYWORD(PERCENT_RANK)",
           "KEYWORD(PERIOD)",
           "KEYWORD(POSITION)",

File: core/src/main/java/org/apache/calcite/schema/SchemaFactory.java
Patch:
@@ -24,7 +24,7 @@
  * <p>A schema factory allows you to include a custom schema in a model file.
  * For example, here is a model that contains a custom schema whose tables
  * read CSV files. (See the
- * <a href="http://calcite.apache.org/apidocs/org/apache/calcite/adapter/csv/package-summary.html">example CSV adapter</a>
+ * <a href="https://calcite.apache.org/javadocAggregate/org/apache/calcite/adapter/csv/package-summary.html">example CSV adapter</a>
  * for more details about this particular adapter.)
  *
  * <blockquote><pre>{

File: core/src/main/java/org/apache/calcite/interpreter/ValuesNode.java
Patch:
@@ -53,8 +53,8 @@ private static ImmutableList<Row> createRows(Compiler compiler,
     scalar.execute(context, values);
     final ImmutableList.Builder<Row> rows = ImmutableList.builder();
     Object[] subValues = new Object[fieldCount];
-    for (int i = 0; i < values.length; i += fieldCount) {
-      System.arraycopy(values, i, subValues, 0, fieldCount);
+    for (int r = 0, n = tuples.size(); r < n; ++r) {
+      System.arraycopy(values, r * fieldCount, subValues, 0, fieldCount);
       rows.add(Row.asCopy(subValues));
     }
     return rows.build();

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -967,6 +967,9 @@ public static RuntimeException throwAsRuntime(String message, Throwable throwabl
       throwable.addSuppressed(new Throwable(message));
       throw (Error) throwable;
     }
+    if (throwable instanceof IOException) {
+      return new UncheckedIOException(message, (IOException) throwable);
+    }
     throw new RuntimeException(message, throwable);
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -60,6 +60,7 @@
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
+import static org.apache.calcite.rel.type.RelDataTypeImpl.NON_NULLABLE_SUFFIX;
 import static org.apache.calcite.sql.type.NonNullableAccessors.getCharset;
 import static org.apache.calcite.sql.type.NonNullableAccessors.getCollation;
 import static org.apache.calcite.sql.type.NonNullableAccessors.getComponentTypeOrThrow;
@@ -1194,8 +1195,8 @@ public static boolean equalSansNullability(RelDataType type1, RelDataType type2)
     }
 
     return (x.length() == y.length()
-        || x.length() == y.length() + 9 && x.endsWith(" NOT NULL"))
-        && x.startsWith(y);
+        || x.length() == y.length() + NON_NULLABLE_SUFFIX.length()
+        && x.endsWith(NON_NULLABLE_SUFFIX)) && x.startsWith(y);
   }
 
   /**

File: core/src/test/java/org/apache/calcite/rex/RexProgramTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.calcite.rel.metadata.NullSentinel;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.calcite.rel.type.RelDataTypeImpl;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlOperator;
 import org.apache.calcite.sql.SqlSpecialOperator;
@@ -2524,7 +2525,8 @@ private void assertTypeAndToString(
       RexNode rexNode, String representation, String type) {
     assertEquals(representation, rexNode.toString());
     assertEquals(type, rexNode.getType().toString()
-        + (rexNode.getType().isNullable() ? "" : " NOT NULL"), "type of " + rexNode);
+        + (rexNode.getType().isNullable() ? "" : RelDataTypeImpl.NON_NULLABLE_SUFFIX),
+        "type of " + rexNode);
   }
 
   @Test void testIsDeterministic() {

File: core/src/test/java/org/apache/calcite/rex/RexProgramTestBase.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.rex;
 
 import org.apache.calcite.plan.RelOptPredicateList;
+import org.apache.calcite.rel.type.RelDataTypeImpl;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.test.Matchers;
@@ -78,7 +79,8 @@ protected void assertNode(String message, String expected, RexNode node) {
       // toString contains type (see RexCall.toString)
       actual = node.toString();
     } else {
-      actual = node + ":" + node.getType() + (node.getType().isNullable() ? "" : " NOT NULL");
+      actual = node + ":" + node.getType() + (node.getType().isNullable() ? ""
+          : RelDataTypeImpl.NON_NULLABLE_SUFFIX);
     }
     assertEquals(expected, actual, message);
   }

File: core/src/test/java/org/apache/calcite/sql/test/SqlTests.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.apache.calcite.avatica.ColumnMetaData;
 import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rel.type.RelDataTypeImpl;
 import org.apache.calcite.runtime.CalciteContextException;
 import org.apache.calcite.sql.parser.SqlParseException;
 import org.apache.calcite.sql.parser.SqlParserUtil;
@@ -104,7 +105,7 @@ public static String getTypeString(RelDataType sqlType) {
         actual = actual + "(" + sqlType.getPrecision() + ")";
       }
       if (!sqlType.isNullable()) {
-        actual += " NOT NULL";
+        actual += RelDataTypeImpl.NON_NULLABLE_SUFFIX;
       }
       return actual;
 

File: core/src/test/java/org/apache/calcite/test/CalciteAssert.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.calcite.rel.RelRoot;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.calcite.rel.type.RelDataTypeImpl;
 import org.apache.calcite.runtime.CalciteException;
 import org.apache.calcite.runtime.FlatLists;
 import org.apache.calcite.runtime.GeoFunctions;
@@ -487,7 +488,7 @@ private static String typeString(ResultSetMetaData metaData)
               + " "
               + metaData.getColumnTypeName(i + 1)
               + (metaData.isNullable(i + 1) == ResultSetMetaData.columnNoNulls
-              ? " NOT NULL"
+              ? RelDataTypeImpl.NON_NULLABLE_SUFFIX
               : ""));
     }
     return list.toString();

File: core/src/test/java/org/apache/calcite/rel/logical/ToLogicalConverterTest.java
Patch:
@@ -333,7 +333,7 @@ private void verify(RelNode rel, String expectedPhysical, String expectedLogical
             ImmutableSet.of(v.get().id))
         .build();
     String expectedPhysical = ""
-        + "EnumerableCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{}])\n"
+        + "EnumerableCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{5}])\n"
         + "  EnumerableTableScan(table=[[scott, EMP]])\n"
         + "  EnumerableFilter(condition=[=($cor0.SAL, 1000)])\n"
         + "    EnumerableTableScan(table=[[scott, DEPT]])\n";

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableCalc.java
Patch:
@@ -194,6 +194,7 @@ public static EnumerableCalc create(final RelNode input,
             typeFactory,
             conformance,
             builder3,
+            null,
             physType,
             DataContext.ROOT,
             new RexToLixTranslator.InputGetterImpl(input, result.physType),

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
Patch:
@@ -290,7 +290,7 @@ int getAgg(int i) {
     //
     // or in algebra,
     //
-    //   Aggregate($0, SUM($2 WHERE $4 = 0), SUM($3 WHERE $4 = 0))
+    //   Aggregate($0, SUM($2 WHERE $4 = 0), SUM($3 WHERE $4 = 1))
     //     Aggregate([($0), ($0, $2)], SUM($2), MIN($2), GROUPING($0, $4))
     //       Scan(emp)
     //

File: core/src/main/java/org/apache/calcite/rex/RexExecutorImpl.java
Patch:
@@ -92,7 +92,7 @@ private static String compile(RexBuilder rexBuilder, List<RexNode> constExps,
     final RexProgram program = programBuilder.getProgram();
     final List<Expression> expressions =
         RexToLixTranslator.translateProjects(program, javaTypeFactory,
-            conformance, blockBuilder, null, root_, getter, null);
+            conformance, blockBuilder, null, null, root_, getter, null);
     blockBuilder.add(
         Expressions.return_(null,
             Expressions.newArrayInit(Object[].class, expressions)));

File: core/src/main/java/org/apache/calcite/runtime/Enumerables.java
Patch:
@@ -48,7 +48,6 @@ private Enumerables() {}
   /** Converts an enumerable over singleton arrays into the enumerable of their
    * first elements. */
   public static <E> Enumerable<E> slice0(Enumerable<E[]> enumerable) {
-    //noinspection unchecked
     return enumerable.select(elements -> elements[0]);
   }
 

File: core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
Patch:
@@ -130,8 +130,9 @@ public static ImmutableMultimap<String, Function> functions(Class<?> clazz) {
    */
   public static ScalarFunction create(Method method) {
     if (!Modifier.isStatic(method.getModifiers())) {
-      Class clazz = method.getDeclaringClass();
-      if (!classHasPublicZeroArgsConstructor(clazz)) {
+      Class<?> clazz = method.getDeclaringClass();
+      if (!classHasPublicZeroArgsConstructor(clazz)
+          && !classHasPublicFunctionContextConstructor(clazz)) {
         throw RESOURCE.requireDefaultConstructor(clazz.getName()).ex();
       }
     }

File: core/src/test/java/org/apache/calcite/tools/PlannerTest.java
Patch:
@@ -247,7 +247,7 @@ private String toString(RelNode rel) {
   @Test void testValidateUserDefinedFunctionInSchema() throws Exception {
     SchemaPlus rootSchema = Frameworks.createRootSchema(true);
     rootSchema.add("my_plus",
-        ScalarFunctionImpl.create(Smalls.MyPlusFunction.class, "eval"));
+        ScalarFunctionImpl.create(Smalls.MY_PLUS_EVAL_METHOD));
     final FrameworkConfig config = Frameworks.newConfigBuilder()
         .defaultSchema(
             CalciteAssert.addSchema(rootSchema, CalciteAssert.SchemaSpec.HR))

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
Patch:
@@ -393,6 +393,7 @@ public int getFlags() {
               conformance,
               builder2,
               null,
+              null,
               DataContext.ROOT,
               new RexToLixTranslator.InputGetterImpl(e_, result.physType),
               null);

File: core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Describes the type of a mapping, from the most general
  * {@link #MULTI_FUNCTION} (every element in the source and target domain can
- * participate in many mappings) to the most retricted {@link #BIJECTION} (every
+ * participate in many mappings) to the most restricted {@link #BIJECTION} (every
  * element in the source and target domain must be paired with precisely one
  * element in the other domain).
  *

File: core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
Patch:
@@ -145,8 +145,8 @@ public static Mapping divide(Mapping mapping1, Mapping mapping2) {
   /**
    * Multiplies one mapping by another.
    *
-   * <p>{@code divide(A, B)} returns a mapping C such that B . C (the mapping
-   * B followed by the mapping C) is equivalent to A.
+   * <p>{@code multiply(A, B)} returns a mapping C such that A . B (the mapping
+   * A followed by the mapping B) is equivalent to C.
    *
    * @param mapping1 First mapping
    * @param mapping2 Second mapping

File: core/src/main/java/org/apache/calcite/rel/core/Correlate.java
Patch:
@@ -87,6 +87,7 @@ public abstract class Correlate extends BiRel {
    * @param requiredColumns Set of columns that are used by correlation
    * @param joinType Join type
    */
+  @SuppressWarnings("method.invocation.invalid")
   protected Correlate(
       RelOptCluster cluster,
       RelTraitSet traitSet,
@@ -100,6 +101,7 @@ protected Correlate(
     this.joinType = requireNonNull(joinType, "joinType");
     this.correlationId = requireNonNull(correlationId, "correlationId");
     this.requiredColumns = requireNonNull(requiredColumns, "requiredColumns");
+    assert isValid(Litmus.THROW, null);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/core/Filter.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.rel.core;
 
-import org.apache.calcite.config.CalciteSystemProperty;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelOptCost;
 import org.apache.calcite.plan.RelOptPlanner;
@@ -79,8 +78,7 @@ protected Filter(
     super(cluster, traits, child);
     this.condition = requireNonNull(condition, "condition");
     assert RexUtil.isFlat(condition) : "RexUtil.isFlat should be true for condition " + condition;
-    // Too expensive for everyday use:
-    assert !CalciteSystemProperty.DEBUG.value() || isValid(Litmus.THROW, null);
+    assert isValid(Litmus.THROW, null);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/core/Snapshot.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.rel.core;
 
-import org.apache.calcite.config.CalciteSystemProperty;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
@@ -65,8 +64,7 @@ protected Snapshot(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
       RexNode period) {
     super(cluster, traitSet, input);
     this.period = Objects.requireNonNull(period, "period");
-    // Too expensive for everyday use:
-    assert !CalciteSystemProperty.DEBUG.value() || isValid(Litmus.THROW, null);
+    assert isValid(Litmus.THROW, null);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalCorrelate.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.rel.logical;
 
-import org.apache.calcite.config.CalciteSystemProperty;
 import org.apache.calcite.plan.Convention;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelTraitSet;
@@ -27,7 +26,6 @@
 import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.util.ImmutableBitSet;
-import org.apache.calcite.util.Litmus;
 
 import static java.util.Objects.requireNonNull;
 
@@ -73,7 +71,6 @@ public LogicalCorrelate(
         correlationId,
         requiredColumns,
         joinType);
-    assert !CalciteSystemProperty.DEBUG.value() || isValid(Litmus.THROW, null);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.calcite.rel.metadata.RelMdDistribution;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.util.Litmus;
 
 import com.google.common.collect.ImmutableSet;
 
@@ -69,7 +68,6 @@ public LogicalFilter(
       ImmutableSet<CorrelationId> variablesSet) {
     super(cluster, traitSet, child, condition);
     this.variablesSet = Objects.requireNonNull(variablesSet, "variablesSet");
-    assert isValid(Litmus.THROW, null);
   }
 
   @Deprecated // to be removed before 2.0

File: core/src/test/java/org/apache/calcite/test/TableFunctionTest.java
Patch:
@@ -57,7 +57,7 @@ private CalciteAssert.AssertThat with() {
     final String c = Smalls.class.getName();
     final String m = Smalls.MULTIPLICATION_TABLE_METHOD.getName();
     final String m2 = Smalls.FIBONACCI_TABLE_METHOD.getName();
-    final String m3 = Smalls.FIBONACCI2_TABLE_METHOD.getName();
+    final String m3 = Smalls.FIBONACCI_LIMIT_TABLE_METHOD.getName();
     return CalciteAssert.model("{\n"
         + "  version: '1.0',\n"
         + "   schemas: [\n"

File: core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
Patch:
@@ -241,6 +241,9 @@ private void load(final RelDataType elementType,
    * {@link Integer}. */
   private static List<? extends @Nullable Object> wrap(ColumnMetaData.Rep rep, List<?> list,
       RelDataType type) {
+    if (true) {
+      return list;
+    }
     switch (type.getSqlTypeName()) {
     case TIMESTAMP:
       switch (rep) {

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java
Patch:
@@ -180,7 +180,7 @@ public SqlIdentifier tableName() {
   }
 
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
-    JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+    JavaTypeFactory typeFactory = root.getTypeFactory();
     final SqlString sql = generateSql();
     return ResultSetEnumerable.of(jdbcSchema.getDataSource(), sql.getSql(),
         JdbcUtils.ObjectArrayRowBuilder.factory(fieldClasses(typeFactory)));

File: core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
Patch:
@@ -129,8 +129,9 @@ private static TableScanNode createQueryable(Compiler compiler,
     final Type elementType = queryableTable.getElementType();
     SchemaPlus schema = root.getRootSchema();
     for (String name : Util.skipLast(relOptTable.getQualifiedName())) {
-      requireNonNull(schema, () -> "schema is null while resolving " + name + " for table"
-          + relOptTable.getQualifiedName());
+      requireNonNull(schema, () ->
+          "schema is null while resolving " + name + " for table"
+              + relOptTable.getQualifiedName());
       schema = schema.getSubSchema(name);
     }
     final Enumerable<Row> rowEnumerable;

File: core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
Patch:
@@ -16,12 +16,12 @@
  */
 package org.apache.calcite.materialize;
 
+import org.apache.calcite.DataContexts;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.profile.Profiler;
 import org.apache.calcite.profile.ProfilerImpl;
 import org.apache.calcite.rel.metadata.NullSentinel;
 import org.apache.calcite.schema.ScannableTable;
-import org.apache.calcite.schema.Schemas;
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.schema.impl.MaterializedViewTable;
 import org.apache.calcite.util.ImmutableBitSet;
@@ -67,7 +67,7 @@ private ProfilerLatticeStatisticProvider(Lattice lattice) {
           ImmutableList.of();
       final Enumerable<List<Comparable>> rows =
           ((ScannableTable) table).scan(
-              Schemas.createDataContext(MaterializedViewTable.MATERIALIZATION_CONNECTION,
+              DataContexts.of(MaterializedViewTable.MATERIALIZATION_CONNECTION,
                   lattice.rootSchema.plus()))
               .select(values -> {
                 for (int i = 0; i < values.length; i++) {

File: core/src/main/java/org/apache/calcite/materialize/SqlLatticeStatisticProvider.java
Patch:
@@ -16,8 +16,8 @@
  */
 package org.apache.calcite.materialize;
 
+import org.apache.calcite.DataContexts;
 import org.apache.calcite.schema.ScannableTable;
-import org.apache.calcite.schema.Schemas;
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.schema.impl.MaterializedViewTable;
 import org.apache.calcite.util.ImmutableBitSet;
@@ -67,8 +67,8 @@ private static double cardinality(Lattice lattice, Lattice.Column column) {
     final @Nullable Object[] values =
         Iterables.getOnlyElement(
             ((ScannableTable) table).scan(
-            Schemas.createDataContext(MaterializedViewTable.MATERIALIZATION_CONNECTION,
-                lattice.rootSchema.plus())));
+                DataContexts.of(MaterializedViewTable.MATERIALIZATION_CONNECTION,
+                    lattice.rootSchema.plus())));
     Number value = (Number) values[0];
     requireNonNull(value, () -> "count(*) produced null in " + sql);
     return value.doubleValue();

File: core/src/main/java/org/apache/calcite/model/ModelHandler.java
Patch:
@@ -447,7 +447,7 @@ private List<String> currentSchemaPath() {
   }
 
   private Pair<? extends @Nullable String, SchemaPlus> nameAndSchema() {
-    return requireNonNull(schemaStack.peek(), "schemaStack.peek()");
+    return schemaStack.getFirst();
   }
 
   private SchemaPlus currentSchema() {

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -1200,7 +1200,7 @@ private RelSet merge(RelSet set1, RelSet set2) {
   /** Returns whether {@code set1} is less popular than {@code set2}
    * (or smaller, or younger). If so, it will be more efficient to merge set1
    * into set2 than set2 into set1. */
-  private boolean isSmaller(RelSet set1, RelSet set2) {
+  private static boolean isSmaller(RelSet set1, RelSet set2) {
     if (set1.parents.size() != set2.parents.size()) {
       return set1.parents.size() < set2.parents.size(); // true if set1 is less popular than set2
     }

File: core/src/main/java/org/apache/calcite/rel/core/TableScan.java
Patch:
@@ -44,6 +44,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 
 /**
@@ -68,7 +69,7 @@ public abstract class TableScan
   protected TableScan(RelOptCluster cluster, RelTraitSet traitSet,
       List<RelHint> hints, RelOptTable table) {
     super(cluster, traitSet);
-    this.table = table;
+    this.table = Objects.requireNonNull(table, "table");
     RelOptSchema relOptSchema = table.getRelOptSchema();
     if (relOptSchema != null) {
       cluster.getPlanner().registerSchema(relOptSchema);

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -396,7 +396,7 @@ private boolean canRewriteExtract(RexNode operand) {
       if (exprs.isEmpty()) {
         return ImmutableList.of(); // a bit more efficient
       }
-      switch (requireNonNull(calls.peek(), "calls.peek()").getKind()) {
+      switch (calls.getFirst().getKind()) {
       case AND:
         return super.visitList(exprs, update);
       default:

File: core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
Patch:
@@ -208,7 +208,6 @@ protected void perform(RelOptRuleCall call, @Nullable Filter filter,
             joinType,
             join.isSemiJoinDone());
     call.getPlanner().onCopy(join, newJoinRel);
-    // TODO: review if filter can be nullable here or not
     if (!leftFilters.isEmpty() && filter != null) {
       call.getPlanner().onCopy(filter, leftRel);
     }

File: core/src/main/java/org/apache/calcite/sql/validate/AggChecker.java
Patch:
@@ -107,8 +107,7 @@ boolean isGroupExpr(SqlNode expr) {
     // it fully-qualified.
     // TODO: It would be better if we always compared fully-qualified
     // to fully-qualified.
-    final SqlQualified fqId = requireNonNull(scopes.peek(), "scopes.peek()")
-        .fullyQualify(id);
+    final SqlQualified fqId = scopes.getFirst().fullyQualify(id);
     if (isGroupExpr(fqId.identifier)) {
       return null;
     }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -1185,9 +1185,7 @@ public static Pair<SqlNode, RelDataType> validateExprWithRowType(
         typeFactory,
         SqlValidator.Config.DEFAULT);
     final SqlSelect select = (SqlSelect) validator.validate(select0);
-    SqlNodeList selectList = requireNonNull(
-        select.getSelectList(),
-        () -> "selectList in " + select);
+    SqlNodeList selectList = select.getSelectList();
     assert selectList.size() == 1
         : "Expression " + expr + " should be atom expression";
     final SqlNode node = selectList.get(0);

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java
Patch:
@@ -5885,7 +5885,8 @@ Sql withLibrarySet(Iterable<? extends SqlLibrary> librarySet) {
           ImmutableSet.copyOf(librarySet), config, relFn, transforms);
     }
 
-    Sql optimize(final RuleSet ruleSet, final RelOptPlanner relOptPlanner) {
+    Sql optimize(final RuleSet ruleSet,
+        final @Nullable RelOptPlanner relOptPlanner) {
       final List<Function<RelNode, RelNode>> transforms =
           FlatLists.append(this.transforms, r -> {
             Program program = Programs.of(ruleSet);

File: core/src/test/java/org/apache/calcite/test/AbstractMaterializedViewTest.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.test;
 
+import org.apache.calcite.DataContexts;
 import org.apache.calcite.adapter.enumerable.EnumerableTableScan;
 import org.apache.calcite.adapter.java.ReflectiveSchema;
 import org.apache.calcite.config.CalciteConnectionConfig;
@@ -32,7 +33,6 @@
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rex.RexExecutorImpl;
 import org.apache.calcite.schema.SchemaPlus;
-import org.apache.calcite.schema.Schemas;
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlOperatorTable;
@@ -136,8 +136,7 @@ private void checkNoMaterialize(Sql sql) {
   private TestConfig build(Sql sql) {
     assert sql != null;
     return Frameworks.withPlanner((cluster, relOptSchema, rootSchema) -> {
-      cluster.getPlanner().setExecutor(
-          new RexExecutorImpl(Schemas.createDataContext(null, null)));
+      cluster.getPlanner().setExecutor(new RexExecutorImpl(DataContexts.EMPTY));
       try {
         final SchemaPlus defaultSchema;
         if (sql.getDefaultSchemaSpec() == null) {

File: core/src/test/java/org/apache/calcite/test/InterpreterTest.java
Patch:
@@ -71,7 +71,7 @@ public SchemaPlus getRootSchema() {
       return rootSchema;
     }
 
-    public @Nullable JavaTypeFactory getTypeFactory() {
+    public JavaTypeFactory getTypeFactory() {
       return (JavaTypeFactory) planner.getTypeFactory();
     }
 

File: core/src/test/java/org/apache/calcite/test/LinqFrontJdbcBackTest.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.test;
 
+import org.apache.calcite.DataContexts;
 import org.apache.calcite.jdbc.CalciteConnection;
 import org.apache.calcite.linq4j.tree.Expressions;
 import org.apache.calcite.linq4j.tree.ParameterExpression;
@@ -42,7 +43,7 @@ class LinqFrontJdbcBackTest {
     ParameterExpression c =
         Expressions.parameter(JdbcTest.Customer.class, "c");
     String s =
-        Schemas.queryable(Schemas.createDataContext(connection, rootSchema),
+        Schemas.queryable(DataContexts.of(calciteConnection, rootSchema),
             rootSchema.getSubSchema("foodmart"),
             JdbcTest.Customer.class, "customer")
             .where(

File: core/src/test/java/org/apache/calcite/test/MockRelOptPlanner.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.test;
 
+import org.apache.calcite.DataContexts;
 import org.apache.calcite.plan.AbstractRelOptPlanner;
 import org.apache.calcite.plan.Context;
 import org.apache.calcite.plan.RelHintsPropagator;
@@ -27,7 +28,6 @@
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rex.RexExecutorImpl;
-import org.apache.calcite.schema.Schemas;
 import org.apache.calcite.util.Pair;
 
 import com.google.common.collect.ImmutableList;
@@ -59,7 +59,7 @@ public class MockRelOptPlanner extends AbstractRelOptPlanner {
   /** Creates MockRelOptPlanner. */
   public MockRelOptPlanner(Context context) {
     super(RelOptCostImpl.FACTORY, context);
-    setExecutor(new RexExecutorImpl(Schemas.createDataContext(null, null)));
+    setExecutor(new RexExecutorImpl(DataContexts.EMPTY));
   }
 
   // implement RelOptPlanner

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvFilterableTable.java
Patch:
@@ -38,8 +38,6 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table based on a CSV file that can implement simple filtering.
  *
@@ -58,7 +56,7 @@ public CsvFilterableTable(Source source, RelProtoDataType protoRowType) {
   }
 
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root, List<RexNode> filters) {
-    JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "typeFactory");
+    JavaTypeFactory typeFactory = root.getTypeFactory();
     final List<CsvFieldType> fieldTypes = getFieldTypes(typeFactory);
     final @Nullable String[] filterValues = new String[fieldTypes.size()];
     filters.removeIf(filter -> addFilter(filter, filterValues));

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvScannableTable.java
Patch:
@@ -33,8 +33,6 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table based on a CSV file.
  *
@@ -53,7 +51,7 @@ public class CsvScannableTable extends CsvTable
   }
 
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
-    JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+    JavaTypeFactory typeFactory = root.getTypeFactory();
     final List<CsvFieldType> fieldTypes = getFieldTypes(typeFactory);
     final List<Integer> fields = ImmutableIntList.identity(fieldTypes.size());
     final AtomicBoolean cancelFlag = DataContext.Variable.CANCEL_FLAG.get(root);

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvStreamScannableTable.java
Patch:
@@ -35,8 +35,6 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table based on a CSV file.
  *
@@ -59,7 +57,7 @@ public class CsvStreamScannableTable extends CsvScannableTable
   }
 
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
-    JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+    JavaTypeFactory typeFactory = root.getTypeFactory();
     final List<CsvFieldType> fieldTypes = getFieldTypes(typeFactory);
     final List<Integer> fields = ImmutableIntList.identity(fieldTypes.size());
     final AtomicBoolean cancelFlag = DataContext.Variable.CANCEL_FLAG.get(root);

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvTranslatableTable.java
Patch:
@@ -38,8 +38,6 @@
 import java.lang.reflect.Type;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table based on a CSV file.
  */
@@ -61,7 +59,7 @@ public Enumerable<Object> project(final DataContext root,
     final AtomicBoolean cancelFlag = DataContext.Variable.CANCEL_FLAG.get(root);
     return new AbstractEnumerable<Object>() {
       @Override public Enumerator<Object> enumerator() {
-        JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+        JavaTypeFactory typeFactory = root.getTypeFactory();
         return new CsvEnumerator<>(
             source,
             cancelFlag,

File: file/src/main/java/org/apache/calcite/adapter/file/CsvTranslatableTable.java
Patch:
@@ -37,8 +37,6 @@
 import java.lang.reflect.Type;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table based on a CSV file.
  *
@@ -63,7 +61,7 @@ public Enumerable<Object> project(final DataContext root,
     final AtomicBoolean cancelFlag = DataContext.Variable.CANCEL_FLAG.get(root);
     return new AbstractEnumerable<Object>() {
       @Override public Enumerator<Object> enumerator() {
-        JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+        JavaTypeFactory typeFactory = root.getTypeFactory();
         return new CsvEnumerator<>(source, cancelFlag,
             getFieldTypes(typeFactory), ImmutableIntList.of(fields));
       }

File: file/src/main/java/org/apache/calcite/adapter/file/JsonScannableTable.java
Patch:
@@ -26,8 +26,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table based on a JSON file.
  *
@@ -50,7 +48,7 @@ public JsonScannableTable(Source source) {
   @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
     return new AbstractEnumerable<@Nullable Object[]>() {
       @Override public Enumerator<@Nullable Object[]> enumerator() {
-        JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+        JavaTypeFactory typeFactory = root.getTypeFactory();
         return new JsonEnumerator(getDataList(typeFactory));
       }
     };

File: plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
Patch:
@@ -150,7 +150,7 @@ private Enumerable<String> sourceMacOs() {
       }
 
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
-        JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+        JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
         final List<String> fieldNames =
             ImmutableList.copyOf(rowType.getFieldNames());

File: plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java
Patch:
@@ -42,8 +42,6 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table function that executes the OS "ps" command
  * to list processes.
@@ -59,7 +57,7 @@ private PsTableFunction() {}
   public static ScannableTable eval(boolean b) {
     return new ScannableTable() {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
-        JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+        JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
         final List<String> fieldNames =
             ImmutableList.copyOf(rowType.getFieldNames());

File: plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
Patch:
@@ -39,8 +39,6 @@
 
 import java.util.List;
 
-import static java.util.Objects.requireNonNull;
-
 /**
  * Table function that executes the OS "vmstat" command
  * to share memory statistics.
@@ -52,7 +50,7 @@ private VmstatTableFunction() {}
   public static ScannableTable eval(boolean b) {
     return new ScannableTable() {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
-        JavaTypeFactory typeFactory = requireNonNull(root.getTypeFactory(), "root.getTypeFactory");
+        JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
         final List<String> fieldNames =
             ImmutableList.copyOf(rowType.getFieldNames());

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
Patch:
@@ -80,7 +80,7 @@ public class EnumerableRelImplementor extends JavaRelImplementor {
   public final Map<String, Object> map;
   private final Map<String, RexToLixTranslator.InputGetter> corrVars =
       new HashMap<>();
-  private final Map<Object, ParameterExpression> stashedParameters =
+  private final IdentityHashMap<Object, ParameterExpression> stashedParameters =
       new IdentityHashMap<>();
 
   @SuppressWarnings("methodref.receiver.bound.invalid")

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -837,7 +837,7 @@ public Builder(LatticeSpace space, CalciteSchema schema, String sql) {
       // Convert the graph into a tree of nodes, each connected to a parent and
       // with a join condition to that parent.
       MutableNode root = null;
-      final Map<LatticeTable, MutableNode> map = new IdentityHashMap<>();
+      final IdentityHashMap<LatticeTable, MutableNode> map = new IdentityHashMap<>();
       for (Vertex vertex : TopologicalOrderIterator.of(graph)) {
         final List<Edge> edges = graph.getInwardEdges(vertex);
         MutableNode node;

File: core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
Patch:
@@ -175,7 +175,7 @@ private void addFrame(Query q, Frame frame, List<Lattice> lattices) {
     }
 
     // Translate the query graph to mutable nodes
-    final Map<TableRef, @Nullable MutableNode> nodes = new IdentityHashMap<>();
+    final IdentityHashMap<TableRef, @Nullable MutableNode> nodes = new IdentityHashMap<>();
     final Map<List, MutableNode> nodesByParent = new HashMap<>();
     final List<MutableNode> rootNodes = new ArrayList<>();
     for (TableRef tableRef : TopologicalOrderIterator.of(g)) {

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java
Patch:
@@ -42,7 +42,7 @@ public class RelJsonWriter implements RelWriter {
 
   protected final JsonBuilder jsonBuilder;
   protected final RelJson relJson;
-  private final Map<RelNode, String> relIdMap = new IdentityHashMap<>();
+  private final IdentityHashMap<RelNode, String> relIdMap = new IdentityHashMap<>();
   protected final List<@Nullable Object> relList;
   private final List<Pair<String, @Nullable Object>> values = new ArrayList<>();
   private @Nullable String previousId;

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
Patch:
@@ -134,7 +134,7 @@ public static RelNode create(RelOptCluster cluster,
     // Build a list of groups, partitions, and aggregate functions. Each
     // aggregate function will add its arguments as outputs of the input
     // program.
-    final Map<RexOver, RexOver> origToNewOver = new IdentityHashMap<>();
+    final IdentityHashMap<RexOver, RexOver> origToNewOver = new IdentityHashMap<>();
     for (RexNode agg : program.getExprList()) {
       if (agg instanceof RexOver) {
         final RexOver origOver = (RexOver) agg;

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
Patch:
@@ -371,7 +371,7 @@ private static AggregateCall unDistinct(AggregateCall aggregateCall,
     return aggregateCall;
   }
 
-  private ImmutableBitSet union(ImmutableBitSet s0,
+  private static ImmutableBitSet union(ImmutableBitSet s0,
       @Nullable ImmutableBitSet s1) {
     return s1 == null ? s0 : s0.union(s1);
   }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -48,7 +48,6 @@
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
 import java.util.List;
-import java.util.Map;
 
 /**
  * Planner rule that pushes an
@@ -61,7 +60,7 @@ public class AggregateUnionTransposeRule
     extends RelRule<AggregateUnionTransposeRule.Config>
     implements TransformationRule {
 
-  private static final Map<Class<? extends SqlAggFunction>, Boolean>
+  private static final IdentityHashMap<Class<? extends SqlAggFunction>, Boolean>
       SUPPORTED_AGGREGATES = new IdentityHashMap<>();
 
   static {

File: core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
Patch:
@@ -329,7 +329,7 @@ public <R extends SingleRel> RemoveEmptySingleRule(Class<R> clazz,
           .withOperandFor(clazz, predicate));
     }
 
-    @SuppressWarnings("Guava")
+    @SuppressWarnings({"Guava", "UnnecessaryMethodReference"})
     @Deprecated // to be removed before 2.0
     public <R extends SingleRel> RemoveEmptySingleRule(Class<R> clazz,
         com.google.common.base.Predicate<R> predicate,

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -1989,7 +1989,7 @@ public static long toLong(Timestamp v) {
   }
 
   // mainly intended for java.sql.Timestamp but works for other dates also
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings("JavaUtilDate")
   public static long toLong(java.util.Date v, TimeZone timeZone) {
     final long time = v.getTime();
     return time + timeZone.getOffset(time);

File: core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
Patch:
@@ -113,11 +113,12 @@ public PartiallyOrderedSet(Ordering<E> ordering,
     this(ordering, new HashMap<>(), childFunction, parentFunction);
   }
 
-  @SuppressWarnings("Guava")
+  @SuppressWarnings({"Guava", "UnnecessaryMethodReference"})
   @Deprecated // to be removed before 2.0
   public PartiallyOrderedSet(Ordering<E> ordering,
       com.google.common.base.Function<E, Iterable<E>> childFunction,
       com.google.common.base.Function<E, Iterable<E>> parentFunction) {
+    //noinspection FunctionalExpressionCanBeFolded
     this(ordering, (Function<E, Iterable<E>>) childFunction::apply,
         parentFunction::apply);
   }

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -648,7 +648,7 @@ public static URL toURL(File file) throws MalformedURLException {
    * string reflects the current time.
    */
   @Deprecated // to be removed before 2.0
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings("JavaUtilDate")
   public static String getFileTimestamp() {
     SimpleDateFormat sdf =
         new SimpleDateFormat(FILE_TIMESTAMP_FORMAT, Locale.ROOT);
@@ -2425,7 +2425,7 @@ public static <K, V> Map<K, V> asIndexMapJ(
     };
   }
 
-  @SuppressWarnings("Guava")
+  @SuppressWarnings({"Guava", "UnnecessaryMethodReference"})
   @Deprecated
   public static <K, V> Map<K, V> asIndexMap(
       final Collection<V> values,

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
Patch:
@@ -312,7 +312,7 @@ private static void parseField(List<String> fieldNames, List<ColumnMetaData.Rep>
     parseFieldForName(fieldNames, fieldTypes, posTimestampField, rowBuilder, parser, fieldName);
   }
 
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings("JavaUtilDate")
   private static void parseFieldForName(List<String> fieldNames,
       List<ColumnMetaData.Rep> fieldTypes,
       int posTimestampField, Row.RowBuilder rowBuilder, JsonParser parser, String fieldName)
@@ -498,7 +498,7 @@ private static void expectObjectField(JsonParser parser, String name)
     }
   }
 
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings("JavaUtilDate")
   private static Long extractTimestampField(JsonParser parser)
       throws IOException {
     expect(parser, JsonToken.FIELD_NAME);

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchEnumerators.java
Patch:
@@ -118,7 +118,7 @@ static Function1<ElasticsearchJson.SearchHit, Object> getter(
     return getter;
   }
 
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings("JavaUtilDate")
   private static Object convert(Object o, Class clazz) {
     if (o == null) {
       return null;

File: file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
Patch:
@@ -243,7 +243,7 @@ public static int[] identityList(int n) {
   abstract static class RowConverter<E> {
     abstract E convertRow(@Nullable String[] rows);
 
-    @SuppressWarnings("JdkObsolete")
+    @SuppressWarnings("JavaUtilDate")
     protected @Nullable Object convert(@Nullable CsvFieldType fieldType, @Nullable String string) {
       if (fieldType == null || string == null) {
         return string;

File: file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
Patch:
@@ -327,7 +327,7 @@ private java.util.Date parseDate(String string) {
       return group.getDates().get(0);
     }
 
-    @SuppressWarnings("JdkObsolete")
+    @SuppressWarnings("JavaUtilDate")
     private Object toObject(FileFieldType fieldType, String string) {
       if ((string == null) || (string.length() == 0)) {
         return null;

File: geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
Patch:
@@ -246,7 +246,7 @@ private static Object handleJavaObjectEntry(
     return values;
   }
 
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings("JavaUtilDate")
   private static Object convert(Object o, Class clazz) {
     if (o == null) {
       return null;

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
Patch:
@@ -49,7 +49,7 @@ public class DeterministicCodeOptimizer extends ClassDeclarationFinder {
    * For instance, cast expression will not be factored to a field,
    * but we still need to track its constant status.
    */
-  protected final Map<Expression, Boolean> constants = new IdentityHashMap<>();
+  protected final IdentityHashMap<Expression, Boolean> constants = new IdentityHashMap<>();
 
   /**
    * The map that de-duplicates expressions, so the same expressions may reuse

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoEnumerator.java
Patch:
@@ -115,7 +115,7 @@ static Function1<Document, Object> getter(
             : (Function1) listGetter(fields);
   }
 
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings("JavaUtilDate")
   private static Object convert(Object o, Class clazz) {
     if (o == null) {
       return null;

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -36,10 +36,9 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
-import static org.checkerframework.checker.nullness.NullnessUtil.castNonNull;
-
 /**
  * Represents an INTERVAL qualifier.
  *

File: core/src/main/java/org/apache/calcite/sql/validate/AbstractNamespace.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.List;
 import java.util.Objects;
 
-import static org.checkerframework.checker.nullness.NullnessUtil.castNonNull;
+import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 /**
  * Abstract implementation of {@link SqlValidatorNamespace}.

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1759,6 +1759,9 @@ protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
   @Override public RelDataType getValidatedNodeType(SqlNode node) {
     RelDataType type = getValidatedNodeTypeIfKnown(node);
     if (type == null) {
+      if (node.getKind() == SqlKind.IDENTIFIER) {
+        throw newValidationError(node, RESOURCE.unknownIdentifier(node.toString()));
+      }
       throw Util.needToImplement(node);
     } else {
       return type;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -103,6 +103,7 @@
 import static org.apache.calcite.linq4j.tree.ExpressionType.NotEqual;
 import static org.apache.calcite.linq4j.tree.ExpressionType.Subtract;
 import static org.apache.calcite.linq4j.tree.ExpressionType.UnaryPlus;
+import static org.apache.calcite.sql.fun.SqlInternalOperators.THROW_UNLESS;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.ARRAY_AGG;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.ARRAY_CONCAT_AGG;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.BOOL_AND;
@@ -341,6 +342,7 @@ public class RexImpTable {
 
   @SuppressWarnings("method.invocation.invalid")
   RexImpTable() {
+    defineMethod(THROW_UNLESS, BuiltInMethod.THROW_UNLESS.method, NullPolicy.NONE);
     defineMethod(ROW, BuiltInMethod.ARRAY.method, NullPolicy.NONE);
     defineMethod(UPPER, BuiltInMethod.UPPER.method, NullPolicy.STRICT);
     defineMethod(LOWER, BuiltInMethod.LOWER.method, NullPolicy.STRICT);

File: core/src/main/java/org/apache/calcite/plan/RelOptRules.java
Patch:
@@ -77,6 +77,7 @@ private RelOptRules() {
       CoreRules.FILTER_INTO_JOIN,
       CoreRules.JOIN_PUSH_EXPRESSIONS,
       CoreRules.AGGREGATE_EXPAND_DISTINCT_AGGREGATES,
+      CoreRules.AGGREGATE_EXPAND_WITHIN_DISTINCT,
       CoreRules.AGGREGATE_CASE_TO_FILTER,
       CoreRules.AGGREGATE_REDUCE_FUNCTIONS,
       CoreRules.FILTER_AGGREGATE_TRANSPOSE,

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1949,7 +1949,7 @@ public static MutableAggregate permute(MutableAggregate aggregate,
                 AggregateCall.create(aggregateCall.getAggregation(),
                     aggregateCall.isDistinct(), aggregateCall.isApproximate(),
                     aggregateCall.ignoreNulls(),
-                    ImmutableList.of(newIndex), -1,
+                    ImmutableList.of(newIndex), -1, aggregateCall.distinctKeys,
                     aggregateCall.collation, aggregateCall.type,
                     aggregateCall.name));
             continue;
@@ -1971,8 +1971,8 @@ public static MutableAggregate permute(MutableAggregate aggregate,
                 aggregateCall.isDistinct(), aggregateCall.isApproximate(),
                 aggregateCall.ignoreNulls(),
                 ImmutableList.of(target.groupSet.cardinality() + i), -1,
-                aggregateCall.collation, aggregateCall.type,
-                aggregateCall.name));
+                aggregateCall.distinctKeys, aggregateCall.collation,
+                aggregateCall.type, aggregateCall.name));
       }
       if (targetCond != null && !targetCond.isAlwaysTrue()) {
         RexProgram compenRexProgram = RexProgram.create(

File: core/src/main/java/org/apache/calcite/rel/core/Window.java
Patch:
@@ -341,7 +341,7 @@ public List<AggregateCall> getAggregateCalls(Window windowRel) {
           final SqlAggFunction op = (SqlAggFunction) aggCall.getOperator();
           return AggregateCall.create(op, aggCall.distinct, false,
               aggCall.ignoreNulls, getProjectOrdinals(aggCall.getOperands()),
-              -1, RelCollations.EMPTY,
+              -1, null, RelCollations.EMPTY,
               aggCall.getType(), fieldNames.get(aggCall.ordinal));
         }
       };

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
Patch:
@@ -309,8 +309,7 @@ private AggregateCall toAggCall(Map<String, Object> jsonAggCall) {
     final String name = (String) jsonAggCall.get("name");
     return AggregateCall.create(aggregation, distinct, false, false, operands,
         filterOperand == null ? -1 : filterOperand,
-        RelCollations.EMPTY,
-        type, name);
+        null, RelCollations.EMPTY, type, name);
   }
 
   private RelNode lookupInput(String jsonInput) {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -146,7 +146,8 @@ public AggregateFilterTransposeRule(RelOptRuleOperand operand,
         topAggCallList.add(
             AggregateCall.create(rollup, aggregateCall.isDistinct(),
                 aggregateCall.isApproximate(), aggregateCall.ignoreNulls(),
-                ImmutableList.of(i++), -1, aggregateCall.collation,
+                ImmutableList.of(i++), -1,
+                aggregateCall.distinctKeys, aggregateCall.collation,
                 aggregateCall.type, aggregateCall.name));
       }
       final Aggregate topAggregate =

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
Patch:
@@ -214,7 +214,7 @@ protected void apply(RelOptRuleCall call, @Nullable Project postProject,
       }
       return AggregateCall.create(roll, false, aggregateCall.isApproximate(),
           aggregateCall.ignoreNulls(), ImmutableList.of(offset + i), -1,
-          aggregateCall.collation,
+          aggregateCall.distinctKeys, aggregateCall.collation,
           groupCount, relBuilder.peek(), null, aggregateCall.name);
     }
 
@@ -231,7 +231,7 @@ protected void apply(RelOptRuleCall call, @Nullable Project postProject,
       }
       return AggregateCall.create(aggregation, false,
           aggregateCall.isApproximate(), aggregateCall.ignoreNulls(),
-          newArgs, -1, aggregateCall.collation,
+          newArgs, -1, aggregateCall.distinctKeys, aggregateCall.collation,
           groupCount, relBuilder.peek(), null, aggregateCall.name);
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -185,7 +185,8 @@ public AggregateUnionTransposeRule(Class<? extends Aggregate> aggregateClass,
       AggregateCall newCall =
           AggregateCall.create(aggFun, origCall.isDistinct(),
               origCall.isApproximate(), origCall.ignoreNulls(),
-              ImmutableList.of(groupCount + ord.i), -1, origCall.collation,
+              ImmutableList.of(groupCount + ord.i), -1,
+              origCall.distinctKeys, origCall.collation,
               groupCount, input, aggType, origCall.getName());
       newCalls.add(newCall);
     }

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectAggregateMergeRule.java
Patch:
@@ -163,7 +163,7 @@ private static int findSum0(RelDataTypeFactory typeFactory, AggregateCall sum,
     final AggregateCall sum0 =
         AggregateCall.create(SqlStdOperatorTable.SUM0, sum.isDistinct(),
             sum.isApproximate(), sum.ignoreNulls(), sum.getArgList(),
-            sum.filterArg, sum.collation,
+            sum.filterArg, sum.distinctKeys, sum.collation,
             typeFactory.createTypeWithNullability(sum.type, false), null);
     final int i = aggCallList.indexOf(sum0);
     if (i >= 0) {

File: core/src/main/java/org/apache/calcite/sql/SqlAggFunction.java
Patch:
@@ -133,7 +133,7 @@ protected SqlAggFunction(
       SqlValidatorScope scope,
       SqlValidatorScope operandScope) {
     super.validateCall(call, validator, scope, operandScope);
-    validator.validateAggregateParams(call, null, null, scope);
+    validator.validateAggregateParams(call, null, null, null, scope);
   }
 
   @Override public final boolean requiresOrder() {

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -209,6 +209,9 @@ public enum SqlKind {
   /** {@code WITHIN GROUP} operator. */
   WITHIN_GROUP,
 
+  /** {@code WITHIN DISTINCT} operator. */
+  WITHIN_DISTINCT,
+
   /** Window specification. */
   WINDOW,
 

File: core/src/main/java/org/apache/calcite/sql/validate/AggChecker.java
Patch:
@@ -157,6 +157,7 @@ boolean isGroupExpr(SqlNode expr) {
     case WITHIN_GROUP:
     case RESPECT_NULLS:
     case IGNORE_NULLS:
+    case WITHIN_DISTINCT:
       call.operand(0).accept(this);
       return null;
     default:

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -1010,6 +1010,9 @@ public TrimResult trimFields(
       if (aggCall.filterArg >= 0) {
         inputFieldsUsed.set(aggCall.filterArg);
       }
+      if (aggCall.distinctKeys != null) {
+        inputFieldsUsed.addAll(aggCall.distinctKeys);
+      }
       inputFieldsUsed.addAll(RelCollations.ordinals(aggCall.collation));
     }
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -344,6 +344,7 @@ public enum BuiltInMethod {
   FROM_BASE64(SqlFunctions.class, "fromBase64", String.class),
   MD5(SqlFunctions.class, "md5", String.class),
   SHA1(SqlFunctions.class, "sha1", String.class),
+  THROW_UNLESS(SqlFunctions.class, "throwUnless", boolean.class, String.class),
   COMPRESS(CompressionFunctions.class, "compress", String.class),
   EXTRACT_VALUE(XmlFunctions.class, "extractValue", String.class, String.class),
   XML_TRANSFORM(XmlFunctions.class, "xmlTransform", String.class, String.class),

File: core/src/test/java/org/apache/calcite/materialize/NormalizationTrimFieldTest.java
Patch:
@@ -87,7 +87,8 @@ public static Frameworks.ConfigBuilder config() {
     final AggregateCall call = AggregateCall.create(count.getAggregation(),
         count.isDistinct(), count.isApproximate(),
         count.ignoreNulls(), ImmutableList.of(3),
-        count.filterArg, count.collation, count.getType(), count.getName());
+        count.filterArg, null, count.collation,
+        count.getType(), count.getName());
     final RelNode query = LogicalAggregate.create(project, aggregate.getHints(),
         groupSet, ImmutableList.of(groupSet), ImmutableList.of(call));
     final RelNode target = aggregate;

File: core/src/test/java/org/apache/calcite/plan/RelWriterTest.java
Patch:
@@ -456,10 +456,10 @@ static Stream<SqlExplainFormat> explainFormats() {
                   null,
                   ImmutableList.of(
                       AggregateCall.create(SqlStdOperatorTable.COUNT,
-                          true, false, false, ImmutableList.of(1), -1,
+                          true, false, false, ImmutableList.of(1), -1, null,
                           RelCollations.EMPTY, bigIntType, "c"),
                       AggregateCall.create(SqlStdOperatorTable.COUNT,
-                          false, false, false, ImmutableList.of(), -1,
+                          false, false, false, ImmutableList.of(), -1, null,
                           RelCollations.EMPTY, bigIntType, "d")));
           aggregate.explain(writer);
           return writer.asString();

File: core/src/test/java/org/apache/calcite/plan/volcano/TraitPropagationTest.java
Patch:
@@ -168,8 +168,8 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
 
       // aggregate on s, count
       AggregateCall aggCall = AggregateCall.create(SqlStdOperatorTable.COUNT,
-          false, false, false, Collections.singletonList(1), -1, RelCollations.EMPTY,
-          sqlBigInt, "cnt");
+          false, false, false, Collections.singletonList(1), -1,
+          null, RelCollations.EMPTY, sqlBigInt, "cnt");
       RelNode agg = new LogicalAggregate(cluster,
           cluster.traitSetOf(Convention.NONE), ImmutableList.of(), project,
           ImmutableBitSet.of(0), null, Collections.singletonList(aggCall));

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1893,7 +1893,7 @@ private void checkAverageRowSize(RelOptCluster cluster, RelOptTable empTable,
             ImmutableList.of(
                 AggregateCall.create(SqlStdOperatorTable.COUNT,
                     false, false, false, ImmutableIntList.of(),
-                    -1, RelCollations.EMPTY, 2, join, null, null)));
+                    -1, null, RelCollations.EMPTY, 2, join, null, null)));
     rowSize = mq.getAverageRowSize(aggregate);
     columnSizes = mq.getAverageColumnSizes(aggregate);
     assertThat(columnSizes.size(), equalTo(3));

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -9398,6 +9398,7 @@ private static int prec(SqlOperator op) {
         + "NEXT_VALUE -\n"
         + "PATTERN_EXCLUDE -\n"
         + "PATTERN_PERMUTE -\n"
+        + "WITHIN DISTINCT left\n"
         + "WITHIN GROUP left\n"
         + "\n"
         + "PATTERN_QUANTIFIER -\n"

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -672,7 +672,7 @@ private static DruidQuery optimizeFilteredAggregations(RelOptRuleCall call,
       // Erase references to filters
       for (AggregateCall aggCall : aggregate.getAggCallList()) {
         if ((uniqueFilterRefs.size() == 1
-            && allHaveFilters) // filters get extracted
+                && allHaveFilters) // filters get extracted
             || aggCall.hasFilter()
             && project.getProjects().get(aggCall.filterArg).isAlwaysTrue()) {
           aggCall = aggCall.withFilter(-1);

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java
Patch:
@@ -68,9 +68,9 @@ public class JdbcCatalogSchema extends AbstractSchema {
   /** Creates a JdbcCatalogSchema. */
   public JdbcCatalogSchema(DataSource dataSource, SqlDialect dialect,
       JdbcConvention convention, String catalog) {
-    this.dataSource = requireNonNull(dataSource);
-    this.dialect = requireNonNull(dialect);
-    this.convention = requireNonNull(convention);
+    this.dataSource = requireNonNull(dataSource, "dataSource");
+    this.dialect = requireNonNull(dialect, "dialect");
+    this.convention = requireNonNull(convention, "convention");
     this.catalog = catalog;
   }
 

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java
Patch:
@@ -86,11 +86,11 @@ public class JdbcTable extends AbstractQueryableTable
       String jdbcSchemaName, String jdbcTableName,
       Schema.TableType jdbcTableType) {
     super(Object[].class);
-    this.jdbcSchema = requireNonNull(jdbcSchema);
+    this.jdbcSchema = requireNonNull(jdbcSchema, "jdbcSchema");
     this.jdbcCatalogName = jdbcCatalogName;
     this.jdbcSchemaName = jdbcSchemaName;
-    this.jdbcTableName = requireNonNull(jdbcTableName);
-    this.jdbcTableType = requireNonNull(jdbcTableType);
+    this.jdbcTableName = requireNonNull(jdbcTableName, "jdbcTableName");
+    this.jdbcTableType = requireNonNull(jdbcTableType, "jdbcTableType");
   }
 
   @Override public String toString() {

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java
Patch:
@@ -41,7 +41,7 @@ protected JdbcTableScan(
       JdbcTable jdbcTable,
       JdbcConvention jdbcConvention) {
     super(cluster, cluster.traitSetOf(jdbcConvention), ImmutableList.of(), table);
-    this.jdbcTable = Objects.requireNonNull(jdbcTable);
+    this.jdbcTable = Objects.requireNonNull(jdbcTable, "jdbcTable");
   }
 
   @Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {

File: core/src/main/java/org/apache/calcite/config/Lex.java
Patch:
@@ -87,9 +87,9 @@ public enum Lex {
       Casing quotedCasing,
       boolean caseSensitive,
       CharLiteralStyle... charLiteralStyles) {
-    this.quoting = Objects.requireNonNull(quoting);
-    this.unquotedCasing = Objects.requireNonNull(unquotedCasing);
-    this.quotedCasing = Objects.requireNonNull(quotedCasing);
+    this.quoting = Objects.requireNonNull(quoting, "quoting");
+    this.unquotedCasing = Objects.requireNonNull(unquotedCasing, "unquotedCasing");
+    this.quotedCasing = Objects.requireNonNull(quotedCasing, "quotedCasing");
     this.caseSensitive = caseSensitive;
     this.charLiteralStyles = ImmutableSet.copyOf(charLiteralStyles);
   }

File: core/src/main/java/org/apache/calcite/interpreter/Bindables.java
Patch:
@@ -214,8 +214,8 @@ public static class BindableTableScan
         RelOptTable table, ImmutableList<RexNode> filters,
         ImmutableIntList projects) {
       super(cluster, traitSet, ImmutableList.of(), table);
-      this.filters = Objects.requireNonNull(filters);
-      this.projects = Objects.requireNonNull(projects);
+      this.filters = Objects.requireNonNull(filters, "filters");
+      this.projects = Objects.requireNonNull(projects, "projects");
       Preconditions.checkArgument(canHandle(table));
     }
 

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -87,7 +87,7 @@ public class Interpreter extends AbstractEnumerable<@Nullable Object[]>
 
   /** Creates an Interpreter. */
   public Interpreter(DataContext dataContext, RelNode rootRel) {
-    this.dataContext = requireNonNull(dataContext);
+    this.dataContext = requireNonNull(dataContext, "dataContext");
     final RelNode rel = optimize(rootRel);
     final CompilerImpl compiler =
         new Nodes.CoreCompiler(this, rootRel.getCluster());
@@ -280,7 +280,7 @@ private static class EnumeratorSource implements Source {
     private final Enumerator<Row> enumerator;
 
     EnumeratorSource(final Enumerator<Row> enumerator) {
-      this.enumerator = requireNonNull(enumerator);
+      this.enumerator = requireNonNull(enumerator, "enumerator");
     }
 
     @Override public @Nullable Row receive() {

File: core/src/main/java/org/apache/calcite/jdbc/CalciteConnectionImpl.java
Patch:
@@ -509,7 +509,7 @@ static class ContextImpl implements CalcitePrepare.Context {
     private final CalciteSchema rootSchema;
 
     ContextImpl(CalciteConnectionImpl connection) {
-      this.connection = requireNonNull(connection);
+      this.connection = requireNonNull(connection, "connection");
       long now = System.currentTimeMillis();
       SchemaVersion schemaVersion = new LongSchemaVersion(now);
       this.mutableRootSchema = connection.rootSchema;
@@ -601,7 +601,7 @@ static class CalciteServerStatementImpl
     private final AtomicBoolean cancelFlag = new AtomicBoolean();
 
     CalciteServerStatementImpl(CalciteConnectionImpl connection) {
-      this.connection = requireNonNull(connection);
+      this.connection = requireNonNull(connection, "connection");
     }
 
     @Override public Context createPrepareContext() {

File: core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
Patch:
@@ -165,7 +165,7 @@ public static Pattern likeToRegex(Pat pattern) {
 
   private <E> MetaResultSet createResultSet(Enumerable<E> enumerable,
       Class clazz, String... names) {
-    requireNonNull(names);
+    requireNonNull(names, "names");
     final List<ColumnMetaData> columns = new ArrayList<>(names.length);
     final List<Field> fields = new ArrayList<>(names.length);
     final List<String> fieldNames = new ArrayList<>(names.length);
@@ -752,7 +752,7 @@ private static class CalciteMetaTable extends MetaTable {
         String tableSchem, String tableName) {
       super(tableCat, tableSchem, tableName,
           calciteTable.getJdbcTableType().jdbcName);
-      this.calciteTable = requireNonNull(calciteTable);
+      this.calciteTable = requireNonNull(calciteTable, "calciteTable");
     }
   }
 

File: core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
Patch:
@@ -36,7 +36,7 @@ public class JavaRecordType extends RelRecordType {
 
   public JavaRecordType(List<RelDataTypeField> fields, Class clazz) {
     super(fields);
-    this.clazz = Objects.requireNonNull(clazz);
+    this.clazz = Objects.requireNonNull(clazz, "clazz");
   }
 
   @Override public boolean equals(@Nullable Object obj) {

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -402,9 +402,9 @@ private static class RecordFieldImpl implements Types.RecordField {
         Type type,
         boolean nullable,
         int modifiers) {
-      this.syntheticType = requireNonNull(syntheticType);
-      this.name = requireNonNull(name);
-      this.type = requireNonNull(type);
+      this.syntheticType = requireNonNull(syntheticType, "syntheticType");
+      this.name = requireNonNull(name, "name");
+      this.type = requireNonNull(type, "type");
       this.nullable = nullable;
       this.modifiers = modifiers;
       assert !(nullable && Primitive.is(type))

File: core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java
Patch:
@@ -51,7 +51,7 @@ class LatticeSpace {
   final Map<LatticeTable, List<RexNode>> tableExpressions = new HashMap<>();
 
   LatticeSpace(SqlStatisticProvider statisticProvider) {
-    this.statisticProvider = Objects.requireNonNull(statisticProvider);
+    this.statisticProvider = Objects.requireNonNull(statisticProvider, "statisticProvider");
   }
 
   /** Derives a unique name for a table, qualifying with schema name only if

File: core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
Patch:
@@ -633,7 +633,7 @@ private static class TableRef {
     private final int ordinalInQuery;
 
     private TableRef(LatticeTable table, int ordinalInQuery) {
-      this.table = requireNonNull(table);
+      this.table = requireNonNull(table, "table");
       this.ordinalInQuery = ordinalInQuery;
     }
 
@@ -659,7 +659,7 @@ private static class StepRef extends DefaultEdge {
 
     StepRef(TableRef source, TableRef target, Step step, int ordinalInQuery) {
       super(source, target);
-      this.step = requireNonNull(step);
+      this.step = requireNonNull(step, "step");
       this.ordinalInQuery = ordinalInQuery;
     }
 

File: core/src/main/java/org/apache/calcite/materialize/LatticeTable.java
Patch:
@@ -30,7 +30,7 @@ public class LatticeTable {
   public final String alias;
 
   LatticeTable(RelOptTable table) {
-    t = Objects.requireNonNull(table);
+    t = Objects.requireNonNull(table, "table");
     alias = Objects.requireNonNull(Util.last(table.getQualifiedName()));
   }
 

File: core/src/main/java/org/apache/calcite/materialize/MaterializationActor.java
Patch:
@@ -77,7 +77,7 @@ static class Materialization {
         RelDataType rowType,
         @Nullable List<String> viewSchemaPath) {
       this.key = key;
-      this.rootSchema = Objects.requireNonNull(rootSchema);
+      this.rootSchema = Objects.requireNonNull(rootSchema, "rootSchema");
       Preconditions.checkArgument(rootSchema.isRoot(), "must be root schema");
       this.materializedTable = materializedTable; // may be null
       this.sql = sql;

File: core/src/main/java/org/apache/calcite/materialize/MutableNode.java
Patch:
@@ -66,7 +66,7 @@ class MutableNode {
   /** Creates a non-root node. */
   @SuppressWarnings("argument.type.incompatible")
   MutableNode(LatticeTable table, @Nullable MutableNode parent, @Nullable Step step) {
-    this.table = Objects.requireNonNull(table);
+    this.table = Objects.requireNonNull(table, "table");
     this.parent = parent;
     this.step = step;
     if (parent != null) {

File: core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
Patch:
@@ -46,7 +46,7 @@ class ProfilerLatticeStatisticProvider implements LatticeStatisticProvider {
 
   /** Creates a ProfilerLatticeStatisticProvider. */
   private ProfilerLatticeStatisticProvider(Lattice lattice) {
-    Objects.requireNonNull(lattice);
+    Objects.requireNonNull(lattice, "lattice");
     this.profile = Suppliers.memoize(() -> {
       final ProfilerImpl profiler =
           ProfilerImpl.builder()

File: core/src/main/java/org/apache/calcite/materialize/SqlLatticeStatisticProvider.java
Patch:
@@ -48,7 +48,7 @@ class SqlLatticeStatisticProvider implements LatticeStatisticProvider {
 
   /** Creates a SqlLatticeStatisticProvider. */
   private SqlLatticeStatisticProvider(Lattice lattice) {
-    this.lattice = requireNonNull(lattice);
+    this.lattice = requireNonNull(lattice, "lattice");
   }
 
   @Override public double cardinality(List<Lattice.Column> columns) {

File: core/src/main/java/org/apache/calcite/materialize/Step.java
Patch:
@@ -51,7 +51,7 @@ private Step(LatticeTable source, LatticeTable target,
       List<IntPair> keys, String keyString) {
     super(source, target);
     this.keys = ImmutableList.copyOf(keys);
-    this.keyString = Objects.requireNonNull(keyString);
+    this.keyString = Objects.requireNonNull(keyString, "keyString");
     assert IntPair.ORDERING.isStrictlyOrdered(keys); // ordered and unique
   }
 
@@ -147,7 +147,7 @@ static class Factory implements AttributedDirectedGraph.AttributedEdgeFactory<
 
     @SuppressWarnings("type.argument.type.incompatible")
     Factory(@UnderInitialization LatticeSpace space) {
-      this.space = Objects.requireNonNull(space);
+      this.space = Objects.requireNonNull(space, "space");
     }
 
     @Override public Step createEdge(LatticeTable source, LatticeTable target) {

File: core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
Patch:
@@ -94,7 +94,7 @@ public abstract class AbstractRelOptPlanner implements RelOptPlanner {
    */
   protected AbstractRelOptPlanner(RelOptCostFactory costFactory,
       @Nullable Context context) {
-    this.costFactory = Objects.requireNonNull(costFactory);
+    this.costFactory = Objects.requireNonNull(costFactory, "costFactory");
     if (context == null) {
       context = Contexts.empty();
     }

File: core/src/main/java/org/apache/calcite/plan/Contexts.java
Patch:
@@ -117,7 +117,7 @@ private static class WrapContext implements Context {
     final Object target;
 
     WrapContext(Object target) {
-      this.target = Objects.requireNonNull(target);
+      this.target = Objects.requireNonNull(target, "target");
     }
 
     @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
@@ -140,7 +140,7 @@ private static final class ChainContext implements Context {
     final ImmutableList<Context> contexts;
 
     ChainContext(ImmutableList<Context> contexts) {
-      this.contexts = Objects.requireNonNull(contexts);
+      this.contexts = Objects.requireNonNull(contexts, "contexts");
       for (Context context : contexts) {
         assert !(context instanceof ChainContext) : "must be flat";
       }

File: core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
Patch:
@@ -42,7 +42,7 @@ class RelCompositeTrait<T extends RelMultipleTrait> implements RelTrait {
   // Must remain private. Does not copy the array.
   private RelCompositeTrait(RelTraitDef traitDef, T[] traits) {
     this.traitDef = traitDef;
-    this.traits = Objects.requireNonNull(traits);
+    this.traits = Objects.requireNonNull(traits, "traits");
     //noinspection unchecked
     assert Ordering.natural()
         .isStrictlyOrdered(Arrays.asList((Comparable[]) traits))

File: core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
Patch:
@@ -87,8 +87,8 @@ public class RelOptCluster {
       Map<String, RelNode> mapCorrelToRel) {
     this.nextCorrel = nextCorrel;
     this.mapCorrelToRel = mapCorrelToRel;
-    this.planner = Objects.requireNonNull(planner);
-    this.typeFactory = Objects.requireNonNull(typeFactory);
+    this.planner = Objects.requireNonNull(planner, "planner");
+    this.typeFactory = Objects.requireNonNull(typeFactory, "typeFactory");
     this.rexBuilder = rexBuilder;
     this.originalExpression = rexBuilder.makeLiteral("?");
 
@@ -220,7 +220,7 @@ public void invalidateMetadataQuery() {
    * @param hintStrategies The specified hint strategies to override the default one(empty)
    */
   public void setHintStrategies(HintStrategyTable hintStrategies) {
-    Objects.requireNonNull(hintStrategies);
+    Objects.requireNonNull(hintStrategies, "hintStrategies");
     this.hintStrategies = hintStrategies;
   }
 

File: core/src/main/java/org/apache/calcite/plan/RelOptMaterialization.java
Patch:
@@ -222,7 +222,7 @@ private ProjectFilterTable(@Nullable RexNode condition,
         Mappings.@Nullable TargetMapping mapping, TableScan scan) {
       this.condition = condition;
       this.mapping = mapping;
-      this.scan = Objects.requireNonNull(scan);
+      this.scan = Objects.requireNonNull(scan, "scan");
     }
 
     static @Nullable ProjectFilterTable of(RelNode node) {

File: core/src/main/java/org/apache/calcite/plan/RelOptRule.java
Patch:
@@ -99,8 +99,8 @@ protected RelOptRule(RelOptRuleOperand operand, String description) {
    */
   protected RelOptRule(RelOptRuleOperand operand,
       RelBuilderFactory relBuilderFactory, @Nullable String description) {
-    this.operand = Objects.requireNonNull(operand);
-    this.relBuilderFactory = Objects.requireNonNull(relBuilderFactory);
+    this.operand = Objects.requireNonNull(operand, "operand");
+    this.relBuilderFactory = Objects.requireNonNull(relBuilderFactory, "relBuilderFactory");
     if (description == null) {
       description = guessDescription(getClass().getName());
     }

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
Patch:
@@ -124,7 +124,7 @@ <R extends RelNode> RelOptRuleOperand(
       assert children.size() > 0;
     }
     this.childPolicy = childPolicy;
-    this.clazz = Objects.requireNonNull(clazz);
+    this.clazz = Objects.requireNonNull(clazz, "clazz");
     this.trait = trait;
     //noinspection unchecked
     this.predicate = Objects.requireNonNull((Predicate) predicate);

File: core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
Patch:
@@ -71,9 +71,9 @@ public RexImplicationChecker(
       RexBuilder builder,
       RexExecutor executor,
       RelDataType rowType) {
-    this.builder = Objects.requireNonNull(builder);
-    this.executor = Objects.requireNonNull(executor);
-    this.rowType = Objects.requireNonNull(rowType);
+    this.builder = Objects.requireNonNull(builder, "builder");
+    this.executor = Objects.requireNonNull(executor, "executor");
+    this.rowType = Objects.requireNonNull(rowType, "rowType");
   }
 
   /**

File: core/src/main/java/org/apache/calcite/plan/hep/HepProgramBuilder.java
Patch:
@@ -115,7 +115,7 @@ public HepProgramBuilder addRuleCollection(Collection<RelOptRule> rules) {
   public HepProgramBuilder addRuleInstance(RelOptRule rule) {
     HepInstruction.RuleInstance instruction =
         new HepInstruction.RuleInstance();
-    instruction.rule = requireNonNull(rule);
+    instruction.rule = requireNonNull(rule, "rule");
     instructions.add(instruction);
     return this;
   }

File: core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
Patch:
@@ -92,15 +92,15 @@ public class CalciteCatalogReader implements Prepare.CatalogReader {
   public CalciteCatalogReader(CalciteSchema rootSchema,
       List<String> defaultSchema, RelDataTypeFactory typeFactory, CalciteConnectionConfig config) {
     this(rootSchema, SqlNameMatchers.withCaseSensitive(config != null && config.caseSensitive()),
-        ImmutableList.of(Objects.requireNonNull(defaultSchema),
+        ImmutableList.of(Objects.requireNonNull(defaultSchema, "defaultSchema"),
             ImmutableList.of()),
         typeFactory, config);
   }
 
   protected CalciteCatalogReader(CalciteSchema rootSchema,
       SqlNameMatcher nameMatcher, List<List<String>> schemaPaths,
       RelDataTypeFactory typeFactory, CalciteConnectionConfig config) {
-    this.rootSchema = Objects.requireNonNull(rootSchema);
+    this.rootSchema = Objects.requireNonNull(rootSchema, "rootSchema");
     this.nameMatcher = nameMatcher;
     this.schemaPaths =
         Util.immutableCopy(Util.isDistinct(schemaPaths)

File: core/src/main/java/org/apache/calcite/prepare/RelOptTableImpl.java
Patch:
@@ -97,7 +97,7 @@ private RelOptTableImpl(
       @Nullable Function<Class, Expression> expressionFunction,
       @Nullable Double rowCount) {
     this.schema = schema;
-    this.rowType = requireNonNull(rowType);
+    this.rowType = requireNonNull(rowType, "rowType");
     this.names = ImmutableList.copyOf(names);
     this.table = table; // may be null
     this.expressionFunction = expressionFunction; // may be null

File: core/src/main/java/org/apache/calcite/rel/RelDistributions.java
Patch:
@@ -96,7 +96,7 @@ private static class RelDistributionImpl implements RelDistribution {
     private final ImmutableIntList keys;
 
     private RelDistributionImpl(Type type, ImmutableIntList keys) {
-      this.type = Objects.requireNonNull(type);
+      this.type = Objects.requireNonNull(type, "type");
       this.keys = ImmutableIntList.copyOf(keys);
       assert type != Type.HASH_DISTRIBUTED
           || keys.size() < 2

File: core/src/main/java/org/apache/calcite/rel/RelFieldCollation.java
Patch:
@@ -241,8 +241,8 @@ public RelFieldCollation(
       Direction direction,
       NullDirection nullDirection) {
     this.fieldIndex = fieldIndex;
-    this.direction = Objects.requireNonNull(direction);
-    this.nullDirection = Objects.requireNonNull(nullDirection);
+    this.direction = Objects.requireNonNull(direction, "direction");
+    this.nullDirection = Objects.requireNonNull(nullDirection, "nullDirection");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/RelRoot.java
Patch:
@@ -94,7 +94,7 @@ public RelRoot(RelNode rel, RelDataType validatedRowType, SqlKind kind,
     this.validatedRowType = validatedRowType;
     this.kind = kind;
     this.fields = ImmutableList.copyOf(fields);
-    this.collation = Objects.requireNonNull(collation);
+    this.collation = Objects.requireNonNull(collation, "collation");
     this.hints = ImmutableList.copyOf(hints);
   }
 

File: core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
Patch:
@@ -155,7 +155,7 @@ protected Aggregate(
     super(cluster, traitSet, input);
     this.hints = ImmutableList.copyOf(hints);
     this.aggCalls = ImmutableList.copyOf(aggCalls);
-    this.groupSet = Objects.requireNonNull(groupSet);
+    this.groupSet = Objects.requireNonNull(groupSet, "groupSet");
     if (groupSets == null) {
       this.groupSets = ImmutableList.of(groupSet);
     } else {

File: core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
Patch:
@@ -95,12 +95,12 @@ public AggregateCall(
   private AggregateCall(SqlAggFunction aggFunction, boolean distinct,
       boolean approximate, boolean ignoreNulls, List<Integer> argList,
       int filterArg, RelCollation collation, RelDataType type, @Nullable String name) {
-    this.type = Objects.requireNonNull(type);
+    this.type = Objects.requireNonNull(type, "type");
     this.name = name;
-    this.aggFunction = Objects.requireNonNull(aggFunction);
+    this.aggFunction = Objects.requireNonNull(aggFunction, "aggFunction");
     this.argList = ImmutableList.copyOf(argList);
     this.filterArg = filterArg;
-    this.collation = Objects.requireNonNull(collation);
+    this.collation = Objects.requireNonNull(collation, "collation");
     this.distinct = distinct;
     this.approximate = approximate;
     this.ignoreNulls = ignoreNulls;

File: core/src/main/java/org/apache/calcite/rel/core/Correlate.java
Patch:
@@ -97,9 +97,9 @@ protected Correlate(
       JoinRelType joinType) {
     super(cluster, traitSet, left, right);
     assert !joinType.generatesNullsOnLeft() : "Correlate has invalid join type " + joinType;
-    this.joinType = requireNonNull(joinType);
-    this.correlationId = requireNonNull(correlationId);
-    this.requiredColumns = requireNonNull(requiredColumns);
+    this.joinType = requireNonNull(joinType, "joinType");
+    this.correlationId = requireNonNull(correlationId, "correlationId");
+    this.requiredColumns = requireNonNull(requiredColumns, "requiredColumns");
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/core/EquiJoin.java
Patch:
@@ -67,8 +67,8 @@ protected EquiJoin(RelOptCluster cluster, RelTraitSet traits, RelNode left,
       ImmutableIntList rightKeys, Set<CorrelationId> variablesSet,
       JoinRelType joinType) {
     super(cluster, traits, ImmutableList.of(), left, right, condition, variablesSet, joinType);
-    this.leftKeys = Objects.requireNonNull(leftKeys);
-    this.rightKeys = Objects.requireNonNull(rightKeys);
+    this.leftKeys = Objects.requireNonNull(leftKeys, "leftKeys");
+    this.rightKeys = Objects.requireNonNull(rightKeys, "rightKeys");
   }
 
   @Deprecated // to be removed before 2.0

File: core/src/main/java/org/apache/calcite/rel/core/Exchange.java
Patch:
@@ -59,7 +59,7 @@ public abstract class Exchange extends SingleRel {
   protected Exchange(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
       RelDistribution distribution) {
     super(cluster, traitSet, input);
-    this.distribution = Objects.requireNonNull(distribution);
+    this.distribution = Objects.requireNonNull(distribution, "distribution");
 
     assert traitSet.containsIfApplicable(distribution)
         : "traits=" + traitSet + ", distribution" + distribution;

File: core/src/main/java/org/apache/calcite/rel/core/Join.java
Patch:
@@ -99,9 +99,9 @@ protected Join(
       Set<CorrelationId> variablesSet,
       JoinRelType joinType) {
     super(cluster, traitSet, left, right);
-    this.condition = Objects.requireNonNull(condition);
+    this.condition = Objects.requireNonNull(condition, "condition");
     this.variablesSet = ImmutableSet.copyOf(variablesSet);
-    this.joinType = Objects.requireNonNull(joinType);
+    this.joinType = Objects.requireNonNull(joinType, "joinType");
     this.joinInfo = JoinInfo.of(left, right, condition);
     this.hints = ImmutableList.copyOf(hints);
   }

File: core/src/main/java/org/apache/calcite/rel/core/JoinInfo.java
Patch:
@@ -50,9 +50,9 @@ public class JoinInfo {
   /** Creates a JoinInfo. */
   protected JoinInfo(ImmutableIntList leftKeys, ImmutableIntList rightKeys,
       ImmutableList<RexNode> nonEquiConditions) {
-    this.leftKeys = Objects.requireNonNull(leftKeys);
-    this.rightKeys = Objects.requireNonNull(rightKeys);
-    this.nonEquiConditions = Objects.requireNonNull(nonEquiConditions);
+    this.leftKeys = Objects.requireNonNull(leftKeys, "leftKeys");
+    this.rightKeys = Objects.requireNonNull(rightKeys, "rightKeys");
+    this.nonEquiConditions = Objects.requireNonNull(nonEquiConditions, "nonEquiConditions");
     assert leftKeys.size() == rightKeys.size();
   }
 

File: core/src/main/java/org/apache/calcite/rel/core/Snapshot.java
Patch:
@@ -64,7 +64,7 @@ public abstract class Snapshot extends SingleRel  {
   protected Snapshot(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
       RexNode period) {
     super(cluster, traitSet, input);
-    this.period = Objects.requireNonNull(period);
+    this.period = Objects.requireNonNull(period, "period");
     // Too expensive for everyday use:
     assert !CalciteSystemProperty.DEBUG.value() || isValid(Litmus.THROW, null);
   }

File: core/src/main/java/org/apache/calcite/rel/core/Sort.java
Patch:
@@ -173,7 +173,7 @@ public List<RexNode> getSortExps() {
     //noinspection StaticPseudoFunctionalStyleMethod
     return Util.transform(collation.getFieldCollations(), field ->
         getCluster().getRexBuilder().makeInputRef(input,
-            Objects.requireNonNull(field).getFieldIndex()));
+            Objects.requireNonNull(field, "field").getFieldIndex()));
   }
 
   @Override public RelWriter explainTerms(RelWriter pw) {

File: core/src/main/java/org/apache/calcite/rel/core/SortExchange.java
Patch:
@@ -57,7 +57,7 @@ public abstract class SortExchange extends Exchange {
   protected SortExchange(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode input, RelDistribution distribution, RelCollation collation) {
     super(cluster, traitSet, input, distribution);
-    this.collation = Objects.requireNonNull(collation);
+    this.collation = Objects.requireNonNull(collation, "collation");
 
     assert traitSet.containsIfApplicable(collation)
         : "traits=" + traitSet + ", collation=" + collation;

File: core/src/main/java/org/apache/calcite/rel/core/Spool.java
Patch:
@@ -73,8 +73,8 @@ public enum Type {
   protected Spool(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
       Type readType, Type writeType) {
     super(cluster, traitSet, input);
-    this.readType = Objects.requireNonNull(readType);
-    this.writeType = Objects.requireNonNull(writeType);
+    this.readType = Objects.requireNonNull(readType, "readType");
+    this.writeType = Objects.requireNonNull(writeType, "writeType");
   }
 
   @Override public final RelNode copy(RelTraitSet traitSet,

File: core/src/main/java/org/apache/calcite/rel/core/TableModify.java
Patch:
@@ -124,13 +124,13 @@ protected TableModify(
     this.updateColumnList = updateColumnList;
     this.sourceExpressionList = sourceExpressionList;
     if (operation == Operation.UPDATE) {
-      requireNonNull(updateColumnList);
-      requireNonNull(sourceExpressionList);
+      requireNonNull(updateColumnList, "updateColumnList");
+      requireNonNull(sourceExpressionList, "sourceExpressionList");
       Preconditions.checkArgument(sourceExpressionList.size()
           == updateColumnList.size());
     } else {
       if (operation == Operation.MERGE) {
-        requireNonNull(updateColumnList);
+        requireNonNull(updateColumnList, "updateColumnList");
       } else {
         Preconditions.checkArgument(updateColumnList == null);
       }

File: core/src/main/java/org/apache/calcite/rel/core/TableSpool.java
Patch:
@@ -39,7 +39,7 @@ public abstract class TableSpool extends Spool {
   protected TableSpool(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode input, Type readType, Type writeType, RelOptTable table) {
     super(cluster, traitSet, input, readType, writeType);
-    this.table = Objects.requireNonNull(table);
+    this.table = Objects.requireNonNull(table, "table");
   }
 
   @Override public RelOptTable getTable() {

File: core/src/main/java/org/apache/calcite/rel/hint/HintStrategy.java
Patch:
@@ -85,14 +85,14 @@ public static class Builder {
     private ImmutableSet<ConverterRule> converterRules;
 
     private Builder(HintPredicate predicate) {
-      this.predicate = Objects.requireNonNull(predicate);
+      this.predicate = Objects.requireNonNull(predicate, "predicate");
       this.excludedRules = ImmutableSet.of();
       this.converterRules = ImmutableSet.of();
     }
 
     /** Registers a hint option checker to validate the hint options. */
     public Builder optionChecker(HintOptionChecker optionChecker) {
-      this.optionChecker = Objects.requireNonNull(optionChecker);
+      this.optionChecker = Objects.requireNonNull(optionChecker, "optionChecker");
       return this;
     }
 

File: core/src/main/java/org/apache/calcite/rel/hint/Hintable.java
Patch:
@@ -60,7 +60,7 @@ public interface Hintable {
    * @return Relational expression with the hints {@code hintList} attached
    */
   default RelNode attachHints(List<RelHint> hintList) {
-    Objects.requireNonNull(hintList);
+    Objects.requireNonNull(hintList, "hintList");
     final Set<RelHint> hints = new LinkedHashSet<>(getHints());
     hints.addAll(hintList);
     return withHints(new ArrayList<>(hints));

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java
Patch:
@@ -68,7 +68,7 @@ public LogicalFilter(
       RexNode condition,
       ImmutableSet<CorrelationId> variablesSet) {
     super(cluster, traitSet, child, condition);
-    this.variablesSet = Objects.requireNonNull(variablesSet);
+    this.variablesSet = Objects.requireNonNull(variablesSet, "variablesSet");
     assert isValid(Litmus.THROW, null);
   }
 

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalJoin.java
Patch:
@@ -105,7 +105,7 @@ public LogicalJoin(
       ImmutableList<RelDataTypeField> systemFieldList) {
     super(cluster, traitSet, hints, left, right, condition, variablesSet, joinType);
     this.semiJoinDone = semiJoinDone;
-    this.systemFieldList = requireNonNull(systemFieldList);
+    this.systemFieldList = requireNonNull(systemFieldList, "systemFieldList");
   }
 
   @Deprecated // to be removed before 2.0

File: core/src/main/java/org/apache/calcite/rel/metadata/CachingRelMetadataProvider.java
Patch:
@@ -107,7 +107,7 @@ private class CachingInvocationHandler implements InvocationHandler {
     private final Metadata metadata;
 
     CachingInvocationHandler(Metadata metadata) {
-      this.metadata = requireNonNull(metadata);
+      this.metadata = requireNonNull(metadata, "metadata");
     }
 
     @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)

File: core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
Patch:
@@ -304,7 +304,7 @@ static class Space {
      * {@code map}. */
     @SuppressWarnings({ "unchecked", "SuspiciousMethodCalls" })
     Method find(final Class<? extends RelNode> relNodeClass, Method method) {
-      Objects.requireNonNull(relNodeClass);
+      Objects.requireNonNull(relNodeClass, "relNodeClass");
       for (Class r = relNodeClass;;) {
         Method implementingMethod = handlerMap.get(Pair.of(r, method));
         if (implementingMethod != null) {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
Patch:
@@ -147,7 +147,7 @@ private RelMetadataQuery(@SuppressWarnings("unused") boolean dummy) {
 
   private RelMetadataQuery(JaninoRelMetadataProvider metadataProvider,
       RelMetadataQuery prototype) {
-    super(requireNonNull(metadataProvider));
+    super(requireNonNull(metadataProvider, "metadataProvider"));
     this.collationHandler = prototype.collationHandler;
     this.columnOriginHandler = prototype.columnOriginHandler;
     this.expressionLineageHandler = prototype.expressionLineageHandler;

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableRel.java
Patch:
@@ -71,9 +71,9 @@ public abstract class MutableRel {
 
   protected MutableRel(RelOptCluster cluster,
       RelDataType rowType, MutableRelType type) {
-    this.cluster = Objects.requireNonNull(cluster);
-    this.rowType = Objects.requireNonNull(rowType);
-    this.type = Objects.requireNonNull(type);
+    this.cluster = Objects.requireNonNull(cluster, "cluster");
+    this.rowType = Objects.requireNonNull(rowType, "rowType");
+    this.type = Objects.requireNonNull(type, "type");
   }
 
   public @Nullable MutableRel getParent() {

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -1050,9 +1050,9 @@ private static class Frame {
 
     Frame(RelNode parent, int ordinalInParent, RelNode r, boolean anon,
         boolean ignoreClauses, Iterable<? extends Clause> expectedClauses) {
-      this.parent = requireNonNull(parent);
+      this.parent = requireNonNull(parent, "parent");
       this.ordinalInParent = ordinalInParent;
-      this.r = requireNonNull(r);
+      this.r = requireNonNull(r, "r");
       this.anon = anon;
       this.ignoreClauses = ignoreClauses;
       this.expectedClauses = ImmutableSet.copyOf(expectedClauses);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -146,7 +146,7 @@ public AggregateReduceFunctionsRule(Class<? extends Aggregate> aggregateClass,
         .as(Config.class)
         .withOperandFor(aggregateClass)
         // reduce specific functions provided by the client
-        .withFunctionsToReduce(Objects.requireNonNull(functionsToReduce)));
+        .withFunctionsToReduce(Objects.requireNonNull(functionsToReduce, "functionsToReduce")));
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/rules/LoptJoinTree.java
Patch:
@@ -198,8 +198,8 @@ protected static class Node extends BinaryTree {
 
     public Node(BinaryTree left, BinaryTree right, @UnderInitialization LoptJoinTree parent) {
       super(parent);
-      this.left = Objects.requireNonNull(left);
-      this.right = Objects.requireNonNull(right);
+      this.left = Objects.requireNonNull(left, "left");
+      this.right = Objects.requireNonNull(right, "right");
     }
 
     public BinaryTree getLeft() {

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
Patch:
@@ -385,7 +385,7 @@ static class JoinVertex extends Vertex {
       super(id, factors, cost);
       this.leftFactor = leftFactor;
       this.rightFactor = rightFactor;
-      this.conditions = Objects.requireNonNull(conditions);
+      this.conditions = Objects.requireNonNull(conditions, "conditions");
     }
 
     @Override public String toString() {

File: core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
Patch:
@@ -216,7 +216,7 @@ public PushProjector(
     this.origFilter = origFilter;
     this.childRel = childRel;
     this.preserveExprCondition = preserveExprCondition;
-    this.relBuilder = requireNonNull(relBuilder);
+    this.relBuilder = requireNonNull(relBuilder, "relBuilder");
     if (origProj == null) {
       origProjExprs = ImmutableList.of();
     } else {

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
Patch:
@@ -429,7 +429,7 @@ class Builder {
      * Creates a Builder with the given type factory.
      */
     public Builder(RelDataTypeFactory typeFactory) {
-      this.typeFactory = Objects.requireNonNull(typeFactory);
+      this.typeFactory = Objects.requireNonNull(typeFactory, "typeFactory");
     }
 
     /**

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -106,7 +106,7 @@ private static RelDataType keyToType(Key key) {
 
   /** Creates a type factory. */
   protected RelDataTypeFactoryImpl(RelDataTypeSystem typeSystem) {
-    this.typeSystem = Objects.requireNonNull(typeSystem);
+    this.typeSystem = Objects.requireNonNull(typeSystem, "typeSystem");
   }
 
   //~ Methods ----------------------------------------------------------------
@@ -318,7 +318,7 @@ private RelDataType copyRecordType(
   @Override public RelDataType createTypeWithNullability(
       final RelDataType type,
       final boolean nullable) {
-    Objects.requireNonNull(type);
+    Objects.requireNonNull(type, "type");
     RelDataType newType;
     if (type.isNullable() == nullable) {
       newType = type;

File: core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
Patch:
@@ -44,7 +44,7 @@ public class RelRecordType extends RelDataTypeImpl implements Serializable {
   public RelRecordType(StructKind kind, List<RelDataTypeField> fields, boolean nullable) {
     super(fields);
     this.nullable = nullable;
-    this.kind = requireNonNull(kind);
+    this.kind = requireNonNull(kind, "kind");
     computeDigest();
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexCorrelVariable.java
Patch:
@@ -40,7 +40,7 @@ public class RexCorrelVariable extends RexVariable {
       CorrelationId id,
       RelDataType type) {
     super(id.getName(), type);
-    this.id = Objects.requireNonNull(id);
+    this.id = Objects.requireNonNull(id, "id");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -225,8 +225,8 @@ public class RexLiteral extends RexNode {
       RelDataType type,
       SqlTypeName typeName) {
     this.value = value;
-    this.type = requireNonNull(type);
-    this.typeName = requireNonNull(typeName);
+    this.type = requireNonNull(type, "type");
+    this.typeName = requireNonNull(typeName, "typeName");
     Preconditions.checkArgument(valueMatchesType(value, typeName, true));
     Preconditions.checkArgument((value == null) == type.isNullable());
     Preconditions.checkArgument(typeName != SqlTypeName.ANY);

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -71,7 +71,7 @@ public class RexOver extends RexCall {
       boolean ignoreNulls) {
     super(type, op, operands);
     Preconditions.checkArgument(op.isAggregator());
-    this.window = Objects.requireNonNull(window);
+    this.window = Objects.requireNonNull(window, "window");
     this.distinct = distinct;
     this.ignoreNulls = ignoreNulls;
   }

File: core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
Patch:
@@ -71,8 +71,8 @@ public RexProgramBuilder(RelDataType inputRowType, RexBuilder rexBuilder) {
   @SuppressWarnings("method.invocation.invalid")
   private RexProgramBuilder(RelDataType inputRowType, RexBuilder rexBuilder,
       @Nullable RexSimplify simplify) {
-    this.inputRowType = requireNonNull(inputRowType);
-    this.rexBuilder = requireNonNull(rexBuilder);
+    this.inputRowType = requireNonNull(inputRowType, "inputRowType");
+    this.rexBuilder = requireNonNull(rexBuilder, "rexBuilder");
     this.simplify = simplify; // may be null
     this.validating = assertionsAreEnabled();
 

File: core/src/main/java/org/apache/calcite/rex/RexVariable.java
Patch:
@@ -34,9 +34,9 @@ public abstract class RexVariable extends RexNode {
   protected RexVariable(
       String name,
       RelDataType type) {
-    this.name = Objects.requireNonNull(name);
-    this.digest = Objects.requireNonNull(name);
-    this.type = Objects.requireNonNull(type);
+    this.name = Objects.requireNonNull(name, "name");
+    this.digest = Objects.requireNonNull(name, "name");
+    this.type = Objects.requireNonNull(type, "type");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rex/RexWindow.java
Patch:
@@ -78,8 +78,8 @@ public class RexWindow {
       boolean isRows) {
     this.partitionKeys = ImmutableList.copyOf(partitionKeys);
     this.orderKeys = ImmutableList.copyOf(orderKeys);
-    this.lowerBound = Objects.requireNonNull(lowerBound);
-    this.upperBound = Objects.requireNonNull(upperBound);
+    this.lowerBound = Objects.requireNonNull(lowerBound, "lowerBound");
+    this.upperBound = Objects.requireNonNull(upperBound, "upperBound");
     this.isRows = isRows;
     this.nodeCount = computeCodeCount();
     this.digest = computeDigest();

File: core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
Patch:
@@ -120,7 +120,7 @@ public Automaton build() {
   /** Adds a symbol transition. */
   AutomatonBuilder symbol(State fromState, State toState,
       String name) {
-    Objects.requireNonNull(name);
+    Objects.requireNonNull(name, "name");
     final int symbolId =
         symbolIds.computeIfAbsent(name, k -> symbolIds.size());
     transitionList.add(new SymbolTransition(fromState, toState, symbolId));

File: core/src/main/java/org/apache/calcite/runtime/Enumerables.java
Patch:
@@ -97,7 +97,7 @@ public static <E, TKey, TResult> Enumerable<TResult> match(
           final AtomicInteger matchCounter = new AtomicInteger(1);
 
           @Override public TResult current() {
-            Objects.requireNonNull(resultRow);
+            Objects.requireNonNull(resultRow, "resultRow");
             return resultRow;
           }
 

File: core/src/main/java/org/apache/calcite/runtime/GeoFunctions.java
Patch:
@@ -194,7 +194,7 @@ public static Geom ST_MakeEnvelope(BigDecimal xMin, BigDecimal yMin,
         + xMax + " " + yMax + ", "
         + xMax + " " + yMin + ", "
         + xMin + " " + yMin + "))", srid);
-    return Objects.requireNonNull(geom);
+    return Objects.requireNonNull(geom, "geom");
   }
 
   /** Creates a rectangular Polygon. */

File: core/src/main/java/org/apache/calcite/runtime/Geometries.java
Patch:
@@ -213,7 +213,7 @@ static class SimpleGeom implements Geom {
     final Geometry g;
 
     SimpleGeom(Geometry g) {
-      this.g = Objects.requireNonNull(g);
+      this.g = Objects.requireNonNull(g, "g");
     }
 
     @Override public String toString() {
@@ -253,7 +253,7 @@ static class MapGeom implements Geom {
     final MapGeometry mg;
 
     MapGeom(MapGeometry mg) {
-      this.mg = Objects.requireNonNull(mg);
+      this.mg = Objects.requireNonNull(mg, "mg");
     }
 
     @Override public String toString() {

File: core/src/main/java/org/apache/calcite/runtime/Matcher.java
Patch:
@@ -58,7 +58,7 @@ public class Matcher<E> {
    */
   private Matcher(Automaton automaton,
       ImmutableMap<String, Predicate<MemoryFactory.Memory<E>>> predicates) {
-    this.predicates = Objects.requireNonNull(predicates);
+    this.predicates = Objects.requireNonNull(predicates, "predicates");
     final ImmutableBitSet.Builder startSetBuilder =
         ImmutableBitSet.builder();
     startSetBuilder.set(automaton.startState.id);

File: core/src/main/java/org/apache/calcite/runtime/Pattern.java
Patch:
@@ -152,7 +152,7 @@ abstract class AbstractPattern implements Pattern {
     final Op op;
 
     AbstractPattern(Op op) {
-      this.op = Objects.requireNonNull(op);
+      this.op = Objects.requireNonNull(op, "op");
     }
 
     @Override public Automaton toAutomaton() {
@@ -166,7 +166,7 @@ class SymbolPattern extends AbstractPattern {
 
     SymbolPattern(String name) {
       super(Op.SYMBOL);
-      this.name = Objects.requireNonNull(name);
+      this.name = Objects.requireNonNull(name, "name");
     }
 
     @Override public String toString() {

File: core/src/main/java/org/apache/calcite/schema/Schemas.java
Patch:
@@ -464,7 +464,7 @@ public static List<CalciteSchema.TableEntry> getStarTables(
     final List<CalciteSchema.LatticeEntry> list = getLatticeEntries(schema);
     return Util.transform(list, entry -> {
       final CalciteSchema.TableEntry starTable =
-          requireNonNull(entry).getStarTable();
+          requireNonNull(entry, "entry").getStarTable();
       assert starTable.getTable().getJdbcTableType()
           == Schema.TableType.STAR;
       return entry.getStarTable();
@@ -517,7 +517,7 @@ private static void gatherLattices(CalciteSchema schema,
 
   /** Generates a table name that is unique within the given schema. */
   public static String uniqueTableName(CalciteSchema schema, String base) {
-    String t = requireNonNull(base);
+    String t = requireNonNull(base, "base");
     for (int x = 0; schema.getTable(t, true) != null; x++) {
       t = base + x;
     }

File: core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java
Patch:
@@ -72,8 +72,8 @@ private AggregateFunctionImpl(Class<?> declaringClass,
     this.parameters = params;
     this.accumulatorType = accumulatorType;
     this.resultType = resultType;
-    this.initMethod = Objects.requireNonNull(initMethod);
-    this.addMethod = Objects.requireNonNull(addMethod);
+    this.initMethod = Objects.requireNonNull(initMethod, "initMethod");
+    this.addMethod = Objects.requireNonNull(addMethod, "addMethod");
     this.mergeMethod = mergeMethod;
     this.resultMethod = resultMethod;
     this.isStatic = Modifier.isStatic(initMethod.getModifiers());

File: core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
Patch:
@@ -68,7 +68,7 @@ public class StarTable extends AbstractTable implements TranslatableTable {
 
   /** Creates a StarTable. */
   private StarTable(Lattice lattice, ImmutableList<Table> tables) {
-    this.lattice = Objects.requireNonNull(lattice);
+    this.lattice = Objects.requireNonNull(lattice, "lattice");
     this.tables = tables;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlAbstractDateTimeLiteral.java
Patch:
@@ -57,7 +57,7 @@ protected SqlAbstractDateTimeLiteral(Object d, boolean tz,
 
   /** Converts this literal to a {@link TimestampString}. */
   protected TimestampString getTimestamp() {
-    return (TimestampString) requireNonNull(value);
+    return (TimestampString) requireNonNull(value, "value");
   }
 
   public int getPrec() {

File: core/src/main/java/org/apache/calcite/sql/SqlAggFunction.java
Patch:
@@ -110,7 +110,7 @@ protected SqlAggFunction(
         operandTypeChecker, funcType);
     this.requiresOrder = requiresOrder;
     this.requiresOver = requiresOver;
-    this.requiresGroupOrder = Objects.requireNonNull(requiresGroupOrder);
+    this.requiresGroupOrder = Objects.requireNonNull(requiresGroupOrder, "requiresGroupOrder");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlBasicCall.java
Patch:
@@ -49,7 +49,7 @@ public SqlBasicCall(
       boolean expanded,
       @Nullable SqlLiteral functionQualifier) {
     super(pos);
-    this.operator = Objects.requireNonNull(operator);
+    this.operator = Objects.requireNonNull(operator, "operator");
     this.operands = operands;
     this.expanded = expanded;
     this.functionQuantifier = functionQualifier;
@@ -68,7 +68,7 @@ public SqlBasicCall(
   }
 
   public void setOperator(SqlOperator operator) {
-    this.operator = Objects.requireNonNull(operator);
+    this.operator = Objects.requireNonNull(operator, "operator");
   }
 
   @Override public SqlOperator getOperator() {

File: core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
Patch:
@@ -139,7 +139,7 @@ private RelDataType convertType(SqlValidator validator, SqlCall call, RelDataTyp
                 .createTypeWithCharsetAndCollation(
                     type,
                     type.getCharset(),
-                    requireNonNull(resultCol));
+                    requireNonNull(resultCol, "resultCol"));
       }
     }
     return type;

File: core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java
Patch:
@@ -69,8 +69,8 @@ public SqlCollectionTypeNameSpec(SqlTypeNameSpec elementTypeName,
       SqlTypeName collectionTypeName,
       SqlParserPos pos) {
     super(new SqlIdentifier(collectionTypeName.name(), pos), pos);
-    this.elementTypeName = Objects.requireNonNull(elementTypeName);
-    this.collectionTypeName = Objects.requireNonNull(collectionTypeName);
+    this.elementTypeName = Objects.requireNonNull(elementTypeName, "elementTypeName");
+    this.collectionTypeName = Objects.requireNonNull(collectionTypeName, "collectionTypeName");
   }
 
   public SqlTypeNameSpec getElementTypeName() {

File: core/src/main/java/org/apache/calcite/sql/SqlDdl.java
Patch:
@@ -31,7 +31,7 @@ public abstract class SqlDdl extends SqlCall {
   /** Creates a SqlDdl. */
   protected SqlDdl(SqlOperator operator, SqlParserPos pos) {
     super(pos);
-    this.operator = Objects.requireNonNull(operator);
+    this.operator = Objects.requireNonNull(operator, "operator");
   }
 
   @Override public SqlOperator getOperator() {

File: core/src/main/java/org/apache/calcite/sql/SqlDescribeTable.java
Patch:
@@ -48,7 +48,7 @@ public SqlDescribeTable(SqlParserPos pos,
       SqlIdentifier table,
       @Nullable SqlIdentifier column) {
     super(pos);
-    this.table = Objects.requireNonNull(table);
+    this.table = Objects.requireNonNull(table, "table");
     this.column = column;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlFunction.java
Patch:
@@ -132,7 +132,7 @@ protected SqlFunction(
         operandTypeChecker);
 
     this.sqlIdentifier = sqlIdentifier;
-    this.category = Objects.requireNonNull(category);
+    this.category = Objects.requireNonNull(category, "category");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
Patch:
@@ -616,7 +616,7 @@ private static class PermutingMakeCall extends SimpleMakeCall {
      */
     PermutingMakeCall(SqlOperator operator, int[] order) {
       super(operator);
-      this.order = requireNonNull(order);
+      this.order = requireNonNull(order, "order");
     }
 
     @Override public SqlCall createCall(SqlParserPos pos,

File: core/src/main/java/org/apache/calcite/sql/SqlJoin.java
Patch:
@@ -64,10 +64,10 @@ public SqlJoin(SqlParserPos pos, SqlNode left, SqlLiteral natural,
       @Nullable SqlNode condition) {
     super(pos);
     this.left = left;
-    this.natural = requireNonNull(natural);
-    this.joinType = requireNonNull(joinType);
+    this.natural = requireNonNull(natural, "natural");
+    this.joinType = requireNonNull(joinType, "joinType");
     this.right = right;
-    this.conditionType = requireNonNull(conditionType);
+    this.conditionType = requireNonNull(conditionType, "conditionType");
     this.condition = condition;
 
     Preconditions.checkArgument(natural.getTypeName() == SqlTypeName.BOOLEAN);

File: core/src/main/java/org/apache/calcite/sql/SqlNode.java
Patch:
@@ -62,7 +62,7 @@ public abstract class SqlNode implements Cloneable {
    * @param pos Parser position, must not be null.
    */
   SqlNode(SqlParserPos pos) {
-    this.pos = Objects.requireNonNull(pos);
+    this.pos = Objects.requireNonNull(pos, "pos");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlNodeList.java
Patch:
@@ -78,7 +78,7 @@ public class SqlNodeList extends SqlNode implements List<SqlNode>, RandomAccess
    * should allow O(1) access to elements. */
   private SqlNodeList(SqlParserPos pos, List<@Nullable SqlNode> list) {
     super(pos);
-    this.list = Objects.requireNonNull(list);
+    this.list = Objects.requireNonNull(list, "list");
   }
 
   /**

File: core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
Patch:
@@ -66,8 +66,8 @@ public SqlRowTypeNameSpec(
       List<SqlIdentifier> fieldNames,
       List<SqlDataTypeSpec> fieldTypes) {
     super(new SqlIdentifier(SqlTypeName.ROW.getName(), pos), pos);
-    Objects.requireNonNull(fieldNames);
-    Objects.requireNonNull(fieldTypes);
+    Objects.requireNonNull(fieldNames, "fieldNames");
+    Objects.requireNonNull(fieldTypes, "fieldTypes");
     assert fieldNames.size() > 0; // there must be at least one field.
     this.fieldNames = fieldNames;
     this.fieldTypes = fieldTypes;

File: core/src/main/java/org/apache/calcite/sql/SqlSetOption.java
Patch:
@@ -133,7 +133,7 @@ public SqlSetOption(SqlParserPos pos, @Nullable String scope, SqlIdentifier name
       }
       break;
     case 1:
-      name = (SqlIdentifier) requireNonNull(operand, "name");
+      name = (SqlIdentifier) requireNonNull(operand, /**/ "name");
       break;
     case 2:
       value = operand;

File: core/src/main/java/org/apache/calcite/sql/SqlUtil.java
Patch:
@@ -497,7 +497,7 @@ public static SqlLiteral concatenateLiterals(List<SqlLiteral> lits) {
   private static Iterator<SqlOperator> filterOperatorRoutinesByKind(
       Iterator<SqlOperator> routines, final SqlKind sqlKind) {
     return Iterators.filter(routines,
-        operator -> Objects.requireNonNull(operator).getKind() == sqlKind);
+        operator -> Objects.requireNonNull(operator, "operator").getKind() == sqlKind);
   }
 
   /**
@@ -607,15 +607,15 @@ private static Iterator<SqlOperator> lookupSubjectRoutinesByName(
           Predicates.instanceOf(SqlFunction.class));
     default:
       return Iterators.filter(sqlOperators.iterator(),
-          operator -> Objects.requireNonNull(operator).getSyntax() == syntax);
+          operator -> Objects.requireNonNull(operator, "operator").getSyntax() == syntax);
     }
   }
 
   private static Iterator<SqlOperator> filterRoutinesByParameterCount(
       Iterator<SqlOperator> routines,
       final List<RelDataType> argTypes) {
     return Iterators.filter(routines,
-        operator -> Objects.requireNonNull(operator)
+        operator -> Objects.requireNonNull(operator, "operator")
             .getOperandCountRange().isValidCount(argTypes.size()));
   }
 

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -372,7 +372,7 @@ private static boolean isSelectListItem(SqlNode root,
     List<SqlNode> nodes = SqlUtil.getAncestry(root,
         input -> input instanceof SqlIdentifier
             && ((SqlIdentifier) input).names.contains(hintToken),
-        input -> Objects.requireNonNull(input).getParserPosition()
+        input -> Objects.requireNonNull(input, "input").getParserPosition()
             .startsAt(pos));
     assert nodes.get(0) == root;
     nodes = Lists.reverse(nodes);

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateForeignSchema.java
Patch:
@@ -57,7 +57,7 @@ public class SqlCreateForeignSchema extends SqlCreate {
       SqlIdentifier name, @Nullable SqlNode type, @Nullable SqlNode library,
       @Nullable SqlNodeList optionList) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
     this.type = type;
     this.library = library;
     Preconditions.checkArgument((type == null) != (library == null),

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java
Patch:
@@ -51,9 +51,9 @@ public SqlCreateFunction(SqlParserPos pos, boolean replace,
       boolean ifNotExists, SqlIdentifier name,
       SqlNode className, SqlNodeList usingList) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
     this.className = className;
-    this.usingList = Objects.requireNonNull(usingList);
+    this.usingList = Objects.requireNonNull(usingList, "usingList");
     Preconditions.checkArgument(usingList.size() % 2 == 0);
   }
 

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateMaterializedView.java
Patch:
@@ -49,9 +49,9 @@ public class SqlCreateMaterializedView extends SqlCreate {
       boolean ifNotExists, SqlIdentifier name, @Nullable SqlNodeList columnList,
       SqlNode query) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
     this.columnList = columnList; // may be null
-    this.query = Objects.requireNonNull(query);
+    this.query = Objects.requireNonNull(query, "query");
   }
 
   @SuppressWarnings("nullness")

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateSchema.java
Patch:
@@ -42,7 +42,7 @@ public class SqlCreateSchema extends SqlCreate {
   SqlCreateSchema(SqlParserPos pos, boolean replace, boolean ifNotExists,
       SqlIdentifier name) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
   }
 
   @Override public List<SqlNode> getOperandList() {

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateTable.java
Patch:
@@ -47,7 +47,7 @@ public class SqlCreateTable extends SqlCreate {
   protected SqlCreateTable(SqlParserPos pos, boolean replace, boolean ifNotExists,
       SqlIdentifier name, @Nullable SqlNodeList columnList, @Nullable SqlNode query) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
     this.columnList = columnList; // may be null
     this.query = query; // for "CREATE TABLE ... AS query"; may be null
   }

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateType.java
Patch:
@@ -48,7 +48,7 @@ public class SqlCreateType extends SqlCreate {
   SqlCreateType(SqlParserPos pos, boolean replace, SqlIdentifier name,
       @Nullable SqlNodeList attributeDefs, @Nullable SqlDataTypeSpec dataType) {
     super(OPERATOR, pos, replace, false);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
     this.attributeDefs = attributeDefs; // may be null
     this.dataType = dataType; // may be null
   }

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateView.java
Patch:
@@ -47,9 +47,9 @@ public class SqlCreateView extends SqlCreate {
   SqlCreateView(SqlParserPos pos, boolean replace, SqlIdentifier name,
       @Nullable SqlNodeList columnList, SqlNode query) {
     super(OPERATOR, pos, replace, false);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
     this.columnList = columnList; // may be null
-    this.query = Objects.requireNonNull(query);
+    this.query = Objects.requireNonNull(query, "query");
   }
 
   @SuppressWarnings("nullness")

File: core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
Patch:
@@ -128,7 +128,7 @@ static class JethroSupportedFunction {
     private final List<SqlTypeName> operandTypes;
 
     JethroSupportedFunction(String name, String operands) {
-      Objects.requireNonNull(name); // not currently used
+      Objects.requireNonNull(name, "name"); // not currently used
       final ImmutableList.Builder<SqlTypeName> b = ImmutableList.builder();
       for (String strType : operands.split(":")) {
         b.add(parse(strType));

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java
Patch:
@@ -50,7 +50,7 @@ public SqlJsonArrayAggAggFunction(SqlKind kind,
     super(kind + "_" + nullClause.name(), null, kind, ReturnTypes.VARCHAR_2000,
         InferTypes.ANY_NULLABLE, OperandTypes.family(SqlTypeFamily.ANY),
         SqlFunctionCategory.SYSTEM, false, false, Optionality.OPTIONAL);
-    this.nullClause = Objects.requireNonNull(nullClause);
+    this.nullClause = Objects.requireNonNull(nullClause, "nullClause");
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java
Patch:
@@ -54,7 +54,7 @@ public SqlJsonObjectAggAggFunction(SqlKind kind,
         }, OperandTypes.family(SqlTypeFamily.CHARACTER,
             SqlTypeFamily.ANY),
         SqlFunctionCategory.SYSTEM, false, false, Optionality.FORBIDDEN);
-    this.nullClause = Objects.requireNonNull(nullClause);
+    this.nullClause = Objects.requireNonNull(nullClause, "nullClause");
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
Patch:
@@ -72,8 +72,8 @@ public enum SqlLibrary {
   public final String fun;
 
   SqlLibrary(String abbrev, String fun) {
-    this.abbrev = Objects.requireNonNull(abbrev);
-    this.fun = Objects.requireNonNull(fun);
+    this.abbrev = Objects.requireNonNull(abbrev, "abbrev");
+    this.fun = Objects.requireNonNull(fun, "fun");
     Preconditions.checkArgument(
         fun.equals(name().toLowerCase(Locale.ROOT).replace("_", "")));
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlQuantifyOperator.java
Patch:
@@ -49,7 +49,7 @@ public class SqlQuantifyOperator extends SqlInOperator {
    */
   SqlQuantifyOperator(SqlKind kind, SqlKind comparisonKind) {
     super(comparisonKind.sql + " " + kind, kind);
-    this.comparisonKind = Objects.requireNonNull(comparisonKind);
+    this.comparisonKind = Objects.requireNonNull(comparisonKind, "comparisonKind");
     Preconditions.checkArgument(comparisonKind == SqlKind.EQUALS
         || comparisonKind == SqlKind.NOT_EQUALS
         || comparisonKind == SqlKind.LESS_THAN_OR_EQUAL

File: core/src/main/java/org/apache/calcite/sql/type/AbstractSqlType.java
Patch:
@@ -53,7 +53,7 @@ protected AbstractSqlType(
       boolean isNullable,
       @Nullable List<? extends RelDataTypeField> fields) {
     super(fields);
-    this.typeName = Objects.requireNonNull(typeName);
+    this.typeName = Objects.requireNonNull(typeName, "typeName");
     this.isNullable = isNullable || (typeName == SqlTypeName.NULL);
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
Patch:
@@ -40,7 +40,7 @@ public class ArraySqlType extends AbstractSqlType {
    */
   public ArraySqlType(RelDataType elementType, boolean isNullable) {
     super(SqlTypeName.ARRAY, isNullable, null);
-    this.elementType = requireNonNull(elementType);
+    this.elementType = requireNonNull(elementType, "elementType");
     computeDigest();
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java
Patch:
@@ -107,7 +107,7 @@ private BasicSqlType(
       @Nullable SqlCollation collation,
       @Nullable SerializableCharset wrappedCharset) {
     super(typeName, nullable, null);
-    this.typeSystem = Objects.requireNonNull(typeSystem);
+    this.typeSystem = Objects.requireNonNull(typeSystem, "typeSystem");
     this.precision = precision;
     this.scale = scale;
     this.collation = collation;

File: core/src/main/java/org/apache/calcite/sql/type/ComparableOperandTypeChecker.java
Patch:
@@ -46,7 +46,7 @@ public ComparableOperandTypeChecker(int nOperands,
       RelDataTypeComparability requiredComparability, Consistency consistency) {
     super(nOperands);
     this.requiredComparability = requiredComparability;
-    this.consistency = Objects.requireNonNull(consistency);
+    this.consistency = Objects.requireNonNull(consistency, "consistency");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
Patch:
@@ -104,8 +104,8 @@ public enum Composition {
       ImmutableList<? extends SqlOperandTypeChecker> allowedRules,
       @Nullable String allowedSignatures,
       @Nullable SqlOperandCountRange range) {
-    this.allowedRules = requireNonNull(allowedRules);
-    this.composition = requireNonNull(composition);
+    this.allowedRules = requireNonNull(allowedRules, "allowedRules");
+    this.composition = requireNonNull(composition, "composition");
     this.allowedSignatures = allowedSignatures;
     this.range = range;
     assert (range != null) == (composition == Composition.REPEAT);

File: core/src/main/java/org/apache/calcite/sql/type/ExplicitOperandTypeChecker.java
Patch:
@@ -37,7 +37,7 @@ public class ExplicitOperandTypeChecker implements SqlOperandTypeChecker {
   private final RelDataType type;
 
   public ExplicitOperandTypeChecker(RelDataType type) {
-    this.type = Objects.requireNonNull(type);
+    this.type = Objects.requireNonNull(type, "type");
   }
 
   @Override public boolean isOptional(int i) {

File: core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java
Patch:
@@ -49,8 +49,8 @@ public IntervalSqlType(RelDataTypeSystem typeSystem,
       SqlIntervalQualifier intervalQualifier,
       boolean isNullable) {
     super(intervalQualifier.typeName(), isNullable, null);
-    this.typeSystem = Objects.requireNonNull(typeSystem);
-    this.intervalQualifier = Objects.requireNonNull(intervalQualifier);
+    this.typeSystem = Objects.requireNonNull(typeSystem, "typeSystem");
+    this.intervalQualifier = Objects.requireNonNull(intervalQualifier, "intervalQualifier");
     computeDigest();
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/OperandMetadataImpl.java
Patch:
@@ -49,7 +49,7 @@ public class OperandMetadataImpl extends FamilyOperandTypeChecker
       Function<RelDataTypeFactory, List<RelDataType>> paramTypesFactory,
       IntFunction<String> paramNameFn, Predicate<Integer> optional) {
     super(families, optional);
-    this.paramTypesFactory = Objects.requireNonNull(paramTypesFactory);
+    this.paramTypesFactory = Objects.requireNonNull(paramTypesFactory, "paramTypesFactory");
     this.paramNameFn = paramNameFn;
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRule.java
Patch:
@@ -41,8 +41,8 @@ public interface SqlTypeMappingRule {
   /** Returns whether it is valid to apply the defined rules from type {@code from} to
    * type {@code to}. */
   default boolean canApplyFrom(SqlTypeName to, SqlTypeName from) {
-    Objects.requireNonNull(to);
-    Objects.requireNonNull(from);
+    Objects.requireNonNull(to, "to");
+    Objects.requireNonNull(from, "from");
 
     if (to == SqlTypeName.NULL) {
       return false;

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransformCascade.java
Patch:
@@ -47,7 +47,7 @@ public SqlTypeTransformCascade(
       SqlReturnTypeInference rule,
       SqlTypeTransform... transforms) {
     Preconditions.checkArgument(transforms.length > 0);
-    this.rule = Objects.requireNonNull(rule);
+    this.rule = Objects.requireNonNull(rule, "rule");
     this.transforms = ImmutableList.copyOf(transforms);
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransforms.java
Patch:
@@ -50,7 +50,7 @@ public abstract class SqlTypeTransforms {
       (opBinding, typeToTransform) ->
           SqlTypeUtil.makeNullableIfOperandsAre(opBinding.getTypeFactory(),
               opBinding.collectOperandTypes(),
-              requireNonNull(typeToTransform));
+              requireNonNull(typeToTransform, "typeToTransform"));
 
   /**
    * Parameter type-inference transform strategy where a derived type is
@@ -70,7 +70,7 @@ public abstract class SqlTypeTransforms {
   public static final SqlTypeTransform TO_NOT_NULLABLE =
       (opBinding, typeToTransform) ->
           opBinding.getTypeFactory().createTypeWithNullability(
-              requireNonNull(typeToTransform), false);
+              requireNonNull(typeToTransform, "typeToTransform"), false);
 
   /**
    * Parameter type-inference transform strategy where a derived type is
@@ -79,7 +79,7 @@ public abstract class SqlTypeTransforms {
   public static final SqlTypeTransform FORCE_NULLABLE =
       (opBinding, typeToTransform) ->
           opBinding.getTypeFactory().createTypeWithNullability(
-              requireNonNull(typeToTransform), true);
+              requireNonNull(typeToTransform, "typeToTransform"), true);
 
   /**
    * Type-inference strategy whereby the result is NOT NULL if any of

File: core/src/main/java/org/apache/calcite/sql/util/IdPair.java
Patch:
@@ -41,8 +41,8 @@ public static <L, R> IdPair<L, R> of(L left, R right) {
   }
 
   protected IdPair(L left, R right) {
-    this.left = Objects.requireNonNull(left);
-    this.right = Objects.requireNonNull(right);
+    this.left = Objects.requireNonNull(left, "left");
+    this.right = Objects.requireNonNull(right, "right");
   }
 
   @Override public String toString() {

File: core/src/main/java/org/apache/calcite/sql/validate/AggVisitor.java
Patch:
@@ -64,8 +64,8 @@ abstract class AggVisitor extends SqlBasicVisitor<Void> {
     this.over = over;
     this.aggregate = aggregate;
     this.delegate = delegate;
-    this.opTab = Objects.requireNonNull(opTab);
-    this.nameMatcher = Objects.requireNonNull(nameMatcher);
+    this.opTab = Objects.requireNonNull(opTab, "opTab");
+    this.nameMatcher = Objects.requireNonNull(nameMatcher, "nameMatcher");
   }
 
   @Override public Void visit(SqlCall call) {

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -77,7 +77,7 @@ public class IdentifierNamespace extends AbstractNamespace {
     super(validator, enclosingNode);
     this.id = id;
     this.extendList = extendList;
-    this.parentScope = Objects.requireNonNull(parentScope);
+    this.parentScope = Objects.requireNonNull(parentScope, "parentScope");
   }
 
   IdentifierNamespace(SqlValidatorImpl validator, SqlNode node,

File: core/src/main/java/org/apache/calcite/sql/validate/ListScope.java
Patch:
@@ -58,7 +58,7 @@ protected ListScope(SqlValidatorScope parent) {
 
   @Override public void addChild(SqlValidatorNamespace ns, String alias,
       boolean nullable) {
-    Objects.requireNonNull(alias);
+    Objects.requireNonNull(alias, "alias");
     children.add(new ScopeChild(children.size(), alias, ns, nullable));
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SchemaNamespace.java
Patch:
@@ -41,7 +41,7 @@ class SchemaNamespace extends AbstractNamespace {
   /** Creates a SchemaNamespace. */
   SchemaNamespace(SqlValidatorImpl validator, ImmutableList<String> names) {
     super(validator, null);
-    this.names = Objects.requireNonNull(names);
+    this.names = Objects.requireNonNull(names, "names");
   }
 
   @Override protected RelDataType validateImpl(RelDataType targetRowType) {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java
Patch:
@@ -36,7 +36,7 @@ public class SqlIdentifierMoniker implements SqlMoniker {
    * Creates an SqlIdentifierMoniker.
    */
   public SqlIdentifierMoniker(SqlIdentifier id) {
-    this.id = Objects.requireNonNull(id);
+    this.id = Objects.requireNonNull(id, "id");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/validate/SqlMonikerImpl.java
Patch:
@@ -43,7 +43,7 @@ public class SqlMonikerImpl implements SqlMoniker {
    */
   public SqlMonikerImpl(List<String> names, SqlMonikerType type) {
     this.names = ImmutableList.copyOf(names);
-    this.type = Objects.requireNonNull(type);
+    this.type = Objects.requireNonNull(type, "type");
   }
 
   /**

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -280,7 +280,7 @@ public static void checkCharsetAndCollateConsistentIfCharType(
   static void checkIdentifierListForDuplicates(List<? extends @Nullable SqlNode> columnList,
       SqlValidatorImpl.ValidationErrorFunction validationErrorFunction) {
     final List<List<String>> names = Util.transform(columnList,
-        o -> ((SqlIdentifier) requireNonNull(o, "sqlNode")).names);
+        sqlNode -> ((SqlIdentifier) requireNonNull(sqlNode, "sqlNode")).names);
     final int i = Util.firstDuplicate(names);
     if (i >= 0) {
       throw validationErrorFunction.apply(
@@ -1331,7 +1331,7 @@ private static class ExplicitRowTypeTable extends AbstractTable {
     private final RelDataType rowType;
 
     ExplicitRowTypeTable(RelDataType rowType) {
-      this.rowType = requireNonNull(rowType);
+      this.rowType = requireNonNull(rowType, "rowType");
     }
 
     @Override public RelDataType getRowType(RelDataTypeFactory typeFactory) {
@@ -1346,7 +1346,7 @@ private static class ExplicitTableSchema extends AbstractSchema {
     private final Map<String, Table> tableMap;
 
     ExplicitTableSchema(Map<String, Table> tableMap) {
-      this.tableMap = requireNonNull(tableMap);
+      this.tableMap = requireNonNull(tableMap, "tableMap");
     }
 
     @Override protected Map<String, Table> getTableMap() {

File: core/src/main/java/org/apache/calcite/sql/validate/TableNamespace.java
Patch:
@@ -48,7 +48,7 @@ class TableNamespace extends AbstractNamespace {
   private TableNamespace(SqlValidatorImpl validator, SqlValidatorTable table,
       List<RelDataTypeField> fields) {
     super(validator, null);
-    this.table = Objects.requireNonNull(table);
+    this.table = Objects.requireNonNull(table, "table");
     this.extendedFields = ImmutableList.copyOf(fields);
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/TableScope.java
Patch:
@@ -42,8 +42,8 @@ class TableScope extends ListScope {
    * @param parent  Parent scope
    */
   TableScope(SqlValidatorScope parent, SqlNode node) {
-    super(Objects.requireNonNull(parent));
-    this.node = Objects.requireNonNull(node);
+    super(Objects.requireNonNull(parent, "parent"));
+    this.node = Objects.requireNonNull(node, "node");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
Patch:
@@ -76,8 +76,8 @@ public abstract class AbstractTypeCoercion implements TypeCoercion {
   //~ Constructors -----------------------------------------------------------
 
   AbstractTypeCoercion(RelDataTypeFactory typeFactory, SqlValidator validator) {
-    this.factory = requireNonNull(typeFactory);
-    this.validator = requireNonNull(validator);
+    this.factory = requireNonNull(typeFactory, "typeFactory");
+    this.validator = requireNonNull(validator, "validator");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -336,13 +336,13 @@ public SqlToRelConverter(
     this.typeFactory = rexBuilder.getTypeFactory();
     this.exprConverter = new SqlNodeToRexConverterImpl(convertletTable);
     this.explainParamCount = 0;
-    this.config = requireNonNull(config);
+    this.config = requireNonNull(config, "config");
     this.relBuilder = config.getRelBuilderFactory().create(cluster, null)
         .transform(config.getRelBuilderConfigTransform());
     this.hintStrategies = config.getHintStrategyTable();
 
     cluster.setHintStrategies(this.hintStrategies);
-    this.cluster = requireNonNull(cluster);
+    this.cluster = requireNonNull(cluster, "cluster");
   }
 
   //~ Methods ----------------------------------------------------------------
@@ -5088,7 +5088,7 @@ && isConvertedSubq(rex)) {
 
       // Apply standard conversions.
       rex = expr.accept(this);
-      return requireNonNull(rex);
+      return requireNonNull(rex, "rex");
     }
 
     /**

File: core/src/main/java/org/apache/calcite/statistic/QuerySqlStatisticProvider.java
Patch:
@@ -77,7 +77,7 @@ public class QuerySqlStatisticProvider implements SqlStatisticProvider {
    * @param sqlConsumer Called when each SQL statement is generated
    */
   public QuerySqlStatisticProvider(Consumer<String> sqlConsumer) {
-    this.sqlConsumer = requireNonNull(sqlConsumer);
+    this.sqlConsumer = requireNonNull(sqlConsumer, "sqlConsumer");
   }
 
   @Override public double tableCardinality(RelOptTable table) {

File: core/src/main/java/org/apache/calcite/tools/Hoist.java
Patch:
@@ -77,7 +77,7 @@ public static Hoist create(Config config) {
   }
 
   private Hoist(Config config) {
-    this.config = Objects.requireNonNull(config);
+    this.config = Objects.requireNonNull(config, "config");
   }
 
   /** Converts a {@link Variable} to a string "?N",
@@ -141,9 +141,9 @@ public static class Variable {
     public final int end;
 
     private Variable(String originalSql, int ordinal, SqlNode node) {
-      this.originalSql = Objects.requireNonNull(originalSql);
+      this.originalSql = Objects.requireNonNull(originalSql, "originalSql");
       this.ordinal = ordinal;
-      this.node = Objects.requireNonNull(node);
+      this.node = Objects.requireNonNull(node, "node");
       final SqlParserPos pos = node.getParserPosition();
       start = SqlParserUtil.lineColToIndex(originalSql,
           pos.getLineNum(), pos.getColumnNum());

File: core/src/main/java/org/apache/calcite/util/BitString.java
Patch:
@@ -208,7 +208,7 @@ public static BitString concat(List<BitString> args) {
    * @return BitString
    */
   public static BitString createFromBytes(byte[] bytes) {
-    int bitCount = Objects.requireNonNull(bytes).length * 8;
+    int bitCount = Objects.requireNonNull(bytes, "bytes").length * 8;
     StringBuilder sb = new StringBuilder(bitCount);
     for (byte b : bytes) {
       final String s = Integer.toBinaryString(Byte.toUnsignedInt(b));

File: core/src/main/java/org/apache/calcite/util/CancelFlag.java
Patch:
@@ -35,7 +35,7 @@ public class CancelFlag {
   public final AtomicBoolean atomicBoolean;
 
   public CancelFlag(AtomicBoolean atomicBoolean) {
-    this.atomicBoolean = Objects.requireNonNull(atomicBoolean);
+    this.atomicBoolean = Objects.requireNonNull(atomicBoolean, "atomicBoolean");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/util/EquivalenceSet.java
Patch:
@@ -56,7 +56,7 @@ public class EquivalenceSet<E extends Comparable<E>> {
   /** Adds an element, and returns the element (which is its own parent).
    * If already present, returns the element's parent. */
   public E add(E e) {
-    final E parent = parents.get(Objects.requireNonNull(e));
+    final E parent = parents.get(Objects.requireNonNull(e, "e"));
     if (parent == null) {
       // Element is new. Add it to the map, as its own parent.
       parents.put(e, e);

File: core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java
Patch:
@@ -57,7 +57,7 @@ public class ImmutableNullableSet<E> extends AbstractSet<E> {
   private final ImmutableSet<Object> elements;
 
   private ImmutableNullableSet(ImmutableSet<Object> elements) {
-    this.elements = Objects.requireNonNull(elements);
+    this.elements = Objects.requireNonNull(elements, "elements");
   }
 
   @Override public Iterator<E> iterator() {

File: core/src/main/java/org/apache/calcite/util/NlsString.java
Patch:
@@ -94,8 +94,8 @@ public class NlsString implements Comparable<NlsString>, Cloneable {
    */
   public NlsString(ByteString bytesValue, String charsetName,
       @Nullable SqlCollation collation) {
-    this(null, Objects.requireNonNull(bytesValue),
-        Objects.requireNonNull(charsetName), collation);
+    this(null, Objects.requireNonNull(bytesValue, "bytesValue"),
+        Objects.requireNonNull(charsetName, "charsetName"), collation);
   }
 
   /**
@@ -113,7 +113,7 @@ public NlsString(ByteString bytesValue, String charsetName,
    */
   public NlsString(String stringValue, @Nullable String charsetName,
       @Nullable SqlCollation collation) {
-    this(Objects.requireNonNull(stringValue), null, charsetName, collation);
+    this(Objects.requireNonNull(stringValue, "stringValue"), null, charsetName, collation);
   }
 
   /** Internal constructor; other constructors must call it. */

File: core/src/main/java/org/apache/calcite/util/PrecedenceClimbingParser.java
Patch:
@@ -119,7 +119,7 @@ public void partialParse() {
       }
       case SPECIAL: {
         Result r = ((SpecialOp) op).special.apply(this, (SpecialOp) op);
-        requireNonNull(r);
+        requireNonNull(r, "r");
         replace(r.replacement, r.first.previous, r.last.next);
         break;
       }

File: core/src/main/java/org/apache/calcite/util/Sarg.java
Patch:
@@ -70,7 +70,7 @@ public class Sarg<C extends Comparable<C>> implements Comparable<Sarg<C>> {
   public final int pointCount;
 
   private Sarg(ImmutableRangeSet<C> rangeSet, boolean containsNull) {
-    this.rangeSet = Objects.requireNonNull(rangeSet);
+    this.rangeSet = Objects.requireNonNull(rangeSet, "rangeSet");
     this.containsNull = containsNull;
     this.pointCount = RangeSets.countPoints(rangeSet);
   }

File: core/src/main/java/org/apache/calcite/util/SourceStringReader.java
Patch:
@@ -32,7 +32,7 @@ public class SourceStringReader extends StringReader {
    * @param s String providing the character stream
    */
   public SourceStringReader(String s) {
-    super(Objects.requireNonNull(s));
+    super(Objects.requireNonNull(s, "s"));
     this.s = s;
   }
 

File: core/src/main/java/org/apache/calcite/util/Sources.java
Patch:
@@ -167,13 +167,13 @@ private static class FileSource implements Source {
     private final boolean urlGenerated;
 
     private FileSource(URL url) {
-      this.url = Objects.requireNonNull(url);
+      this.url = Objects.requireNonNull(url, "url");
       this.file = urlToFile(url);
       this.urlGenerated = false;
     }
 
     private FileSource(File file) {
-      this.file = Objects.requireNonNull(file);
+      this.file = Objects.requireNonNull(file, "file");
       this.url = fileToUrl(file);
       this.urlGenerated = true;
     }

File: core/src/main/java/org/apache/calcite/util/UnmodifiableArrayList.java
Patch:
@@ -39,7 +39,7 @@ public class UnmodifiableArrayList<E>
   private final E[] elements;
 
   private UnmodifiableArrayList(E[] elements) {
-    this.elements = Objects.requireNonNull(elements);
+    this.elements = Objects.requireNonNull(elements, "elements");
   }
 
   public static <E> UnmodifiableArrayList<E> of(E... elements) {

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -914,7 +914,7 @@ public static Error newInternal(Throwable e, String s) {
    * but we don't require Guava version 20 yet. */
   public static void throwIfUnchecked(Throwable throwable) {
     Bug.upgrade("Remove when minimum Guava version is 20");
-    Objects.requireNonNull(throwable);
+    Objects.requireNonNull(throwable, "throwable");
     if (throwable instanceof RuntimeException) {
       throw (RuntimeException) throwable;
     }

File: core/src/main/java/org/apache/calcite/util/graph/DefaultEdge.java
Patch:
@@ -28,8 +28,8 @@ public class DefaultEdge {
   public final Object target;
 
   public DefaultEdge(Object source, Object target) {
-    this.source = Objects.requireNonNull(source);
-    this.target = Objects.requireNonNull(target);
+    this.source = Objects.requireNonNull(source, "source");
+    this.target = Objects.requireNonNull(target, "target");
   }
 
   @Override public int hashCode() {

File: core/src/test/java/org/apache/calcite/profile/ProfilerTest.java
Patch:
@@ -468,10 +468,10 @@ public int compare(Profiler.Statistic left,
         Predicate<Profiler.Statistic> predicate,
         Comparator<Profiler.Statistic> comparator, int limit,
         List<String> columns) {
-      this.sql = Objects.requireNonNull(sql);
-      this.factory = Objects.requireNonNull(factory);
+      this.sql = Objects.requireNonNull(sql, "sql");
+      this.factory = Objects.requireNonNull(factory, "factory");
       this.columns = ImmutableList.copyOf(columns);
-      this.predicate = Objects.requireNonNull(predicate);
+      this.predicate = Objects.requireNonNull(predicate, "predicate");
       this.comparator = comparator; // null means sort on JSON representation
       this.limit = limit;
       this.config = config;

File: core/src/test/java/org/apache/calcite/rex/RexProgramTestBase.java
Patch:
@@ -197,8 +197,8 @@ static class Node {
     final RexNode node;
 
     Node(RexBuilder rexBuilder, RexNode node) {
-      this.rexBuilder = Objects.requireNonNull(rexBuilder);
-      this.node = Objects.requireNonNull(node);
+      this.rexBuilder = Objects.requireNonNull(rexBuilder, "rexBuilder");
+      this.node = Objects.requireNonNull(node, "node");
     }
   }
 

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -9926,10 +9926,10 @@ protected class Sql {
 
     Sql(StringAndPos sap, boolean expression, SqlDialect dialect,
         Consumer<SqlParser> parserChecker) {
-      this.sap = Objects.requireNonNull(sap);
+      this.sap = Objects.requireNonNull(sap, "sap");
       this.expression = expression;
       this.dialect = dialect;
-      this.parserChecker = Objects.requireNonNull(parserChecker);
+      this.parserChecker = Objects.requireNonNull(parserChecker, "parserChecker");
     }
 
     public Sql same() {

File: core/src/test/java/org/apache/calcite/sql/parser/parserextensiontesting/SqlCreateTable.java
Patch:
@@ -49,7 +49,7 @@ public class SqlCreateTable extends SqlCreate {
   public SqlCreateTable(SqlParserPos pos, SqlIdentifier name,
       SqlNodeList columnList, SqlNode query) {
     super(OPERATOR, pos, false, false);
-    this.name = Objects.requireNonNull(name);
+    this.name = Objects.requireNonNull(name, "name");
     this.columnList = columnList; // may be null
     this.query = query; // for "CREATE TABLE ... AS query"; may be null
   }

File: core/src/test/java/org/apache/calcite/sql/test/AbstractSqlTester.java
Patch:
@@ -87,8 +87,8 @@ public abstract class AbstractSqlTester implements SqlTester, AutoCloseable {
 
   public AbstractSqlTester(SqlTestFactory factory,
       UnaryOperator<SqlValidator> validatorTransform) {
-    this.factory = Objects.requireNonNull(factory);
-    this.validatorTransform = Objects.requireNonNull(validatorTransform);
+    this.factory = Objects.requireNonNull(factory, "factory");
+    this.validatorTransform = Objects.requireNonNull(validatorTransform, "validatorTransform");
   }
 
   public final SqlTestFactory getFactory() {

File: core/src/test/java/org/apache/calcite/test/DiffRepository.java
Patch:
@@ -794,7 +794,7 @@ private static class Key {
     private final Filter filter;
 
     Key(Class<?> clazz, DiffRepository baseRepository, Filter filter) {
-      this.clazz = Objects.requireNonNull(clazz);
+      this.clazz = Objects.requireNonNull(clazz, "clazz");
       this.baseRepository = baseRepository;
       this.filter = filter;
     }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTestCase.java
Patch:
@@ -324,7 +324,7 @@ Sql ok() {
      * Checks that a SQL expression gives a particular error.
      */
     Sql fails(String expected) {
-      Objects.requireNonNull(expected);
+      Objects.requireNonNull(expected, "expected");
       tester.assertExceptionIsThrown(toSql(true), expected);
       return this;
     }

File: core/src/test/java/org/apache/calcite/util/PartiallyOrderedSetTest.java
Patch:
@@ -222,7 +222,7 @@ private static boolean isBitSuperset(Integer e1, Integer e2) {
     final PartiallyOrderedSet<Integer> poset =
         new PartiallyOrderedSet<>(PartiallyOrderedSetTest::isBitSuperset,
             (Function<Integer, Iterable<Integer>>) i -> {
-              int r = Objects.requireNonNull(i); // bits not yet cleared
+              int r = Objects.requireNonNull(i, "i"); // bits not yet cleared
               final List<Integer> list = new ArrayList<>();
               for (int z = 1; r != 0; z <<= 1) {
                 if ((i & z) != 0) {
@@ -233,7 +233,7 @@ private static boolean isBitSuperset(Integer e1, Integer e2) {
               return list;
             },
             i -> {
-              Objects.requireNonNull(i);
+              Objects.requireNonNull(i, "i");
               final List<Integer> list = new ArrayList<>();
               for (int z = 1; z <= n; z <<= 1) {
                 if ((i & z) == 0) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DefaultDimensionSpec.java
Patch:
@@ -34,8 +34,8 @@ public class DefaultDimensionSpec implements DimensionSpec {
   private final DruidType outputType;
 
   public DefaultDimensionSpec(String dimension, String outputName, DruidType outputType) {
-    this.dimension = Objects.requireNonNull(dimension);
-    this.outputName = Objects.requireNonNull(outputName);
+    this.dimension = Objects.requireNonNull(dimension, "dimension");
+    this.outputName = Objects.requireNonNull(outputName, "outputName");
     this.outputType = outputType == null ? DruidType.STRING : outputType;
   }
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
Patch:
@@ -81,8 +81,8 @@ class DruidConnectionImpl implements DruidConnection {
   }
 
   DruidConnectionImpl(String url, String coordinatorUrl) {
-    this.url = Objects.requireNonNull(url);
-    this.coordinatorUrl = Objects.requireNonNull(coordinatorUrl);
+    this.url = Objects.requireNonNull(url, "url");
+    this.coordinatorUrl = Objects.requireNonNull(coordinatorUrl, "coordinatorUrl");
   }
 
   /** Executes a query request.

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
Patch:
@@ -460,7 +460,7 @@ public static class JsonExpressionFilter extends DruidJsonFilter {
 
     JsonExpressionFilter(String expression) {
       super(Type.EXPRESSION);
-      this.expression = Objects.requireNonNull(expression);
+      this.expression = Objects.requireNonNull(expression, "expression");
     }
 
     @Override public void write(JsonGenerator generator) throws IOException {
@@ -627,7 +627,7 @@ protected JsonInFilter(String dimension, List<String> values,
 
   public static DruidJsonFilter getSelectorFilter(String column, String value,
       ExtractionFunction extractionFunction) {
-    Objects.requireNonNull(column);
+    Objects.requireNonNull(column, "column");
     return new JsonSelector(column, value, extractionFunction);
   }
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -1544,8 +1544,8 @@ public static class QuerySpec {
 
     QuerySpec(QueryType queryType, String queryString,
         List<String> fieldNames) {
-      this.queryType = Objects.requireNonNull(queryType);
-      this.queryString = Objects.requireNonNull(queryString);
+      this.queryType = Objects.requireNonNull(queryType, "queryType");
+      this.queryString = Objects.requireNonNull(queryString, "queryString");
       this.fieldNames = ImmutableList.copyOf(fieldNames);
     }
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
Patch:
@@ -54,8 +54,8 @@ public class DruidSchema extends AbstractSchema {
    */
   public DruidSchema(String url, String coordinatorUrl,
       boolean discoverTables) {
-    this.url = Objects.requireNonNull(url);
-    this.coordinatorUrl = Objects.requireNonNull(coordinatorUrl);
+    this.url = Objects.requireNonNull(url, "url");
+    this.coordinatorUrl = Objects.requireNonNull(coordinatorUrl, "coordinatorUrl");
     this.discoverTables = discoverTables;
   }
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
Patch:
@@ -86,9 +86,9 @@ public DruidTable(DruidSchema schema, String dataSource,
       RelProtoDataType protoRowType, Set<String> metricFieldNames,
       String timestampFieldName, List<Interval> intervals,
       Map<String, List<ComplexMetric>> complexMetrics, Map<String, SqlTypeName> allFields) {
-    this.timestampFieldName = Objects.requireNonNull(timestampFieldName);
-    this.schema = Objects.requireNonNull(schema);
-    this.dataSource = Objects.requireNonNull(dataSource);
+    this.timestampFieldName = Objects.requireNonNull(timestampFieldName, "timestampFieldName");
+    this.schema = Objects.requireNonNull(schema, "schema");
+    this.dataSource = Objects.requireNonNull(dataSource, "dataSource");
     this.protoRowType = protoRowType;
     this.metricFieldNames = ImmutableSet.copyOf(metricFieldNames);
     this.intervals = intervals != null ? ImmutableList.copyOf(intervals)

File: druid/src/main/java/org/apache/calcite/adapter/druid/ExtractionDimensionSpec.java
Patch:
@@ -46,8 +46,8 @@ public ExtractionDimensionSpec(String dimension, ExtractionFunction extractionFu
 
   public ExtractionDimensionSpec(String dimension, ExtractionFunction extractionFunction,
       String outputName, DruidType outputType) {
-    this.dimension = Objects.requireNonNull(dimension);
-    this.extractionFunction = Objects.requireNonNull(extractionFunction);
+    this.dimension = Objects.requireNonNull(dimension, "dimension");
+    this.extractionFunction = Objects.requireNonNull(extractionFunction, "extractionFunction");
     this.outputName = outputName;
     this.outputType = outputType == null ? DruidType.STRING : outputType;
   }

File: druid/src/main/java/org/apache/calcite/adapter/druid/Granularities.java
Patch:
@@ -87,9 +87,9 @@ private static class PeriodGranularity implements Granularity {
     private final String timeZone;
 
     private PeriodGranularity(Type type, String period, String timeZone) {
-      this.type = Objects.requireNonNull(type);
-      this.period = Objects.requireNonNull(period);
-      this.timeZone = Objects.requireNonNull(timeZone);
+      this.type = Objects.requireNonNull(type, "type");
+      this.period = Objects.requireNonNull(period, "period");
+      this.timeZone = Objects.requireNonNull(timeZone, "timeZone");
     }
 
     @Override public void write(JsonGenerator generator) throws IOException {

File: druid/src/main/java/org/apache/calcite/adapter/druid/NaryOperatorConverter.java
Patch:
@@ -35,8 +35,8 @@ public class NaryOperatorConverter implements DruidSqlOperatorConverter {
   private final String druidOperatorName;
 
   public NaryOperatorConverter(SqlOperator operator, String druidOperatorName) {
-    this.operator = Objects.requireNonNull(operator);
-    this.druidOperatorName = Objects.requireNonNull(druidOperatorName);
+    this.operator = Objects.requireNonNull(operator, "operator");
+    this.druidOperatorName = Objects.requireNonNull(druidOperatorName, "druidOperatorName");
   }
 
   @Override public SqlOperator calciteOperator() {

File: druid/src/main/java/org/apache/calcite/adapter/druid/VirtualColumn.java
Patch:
@@ -36,8 +36,8 @@ public class VirtualColumn implements DruidJson {
   private final DruidType outputType;
 
   public VirtualColumn(String name, String expression, DruidType outputType) {
-    this.name = Objects.requireNonNull(name);
-    this.expression = Objects.requireNonNull(expression);
+    this.name = Objects.requireNonNull(name, "name");
+    this.expression = Objects.requireNonNull(expression, "expression");
     this.outputType = outputType == null ? DruidType.FLOAT : outputType;
   }
 

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSchema.java
Patch:
@@ -39,9 +39,9 @@ public class GeodeSchema extends AbstractSchema {
   private final List<String> regionNames;
   private ImmutableMap<String, Table> tableMap;
 
-  public GeodeSchema(final GemFireCache cache, final Iterable<String> regionNames) {
+  public GeodeSchema(final GemFireCache gemFireCache, final Iterable<String> regionNames) {
     super();
-    this.cache = Objects.requireNonNull(cache, "clientCache");
+    this.cache = Objects.requireNonNull(gemFireCache, "gemFireCache");
     this.regionNames = ImmutableList.copyOf(Objects.requireNonNull(regionNames, "regionNames"));
   }
 

File: innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
Patch:
@@ -98,8 +98,8 @@ private IndexCondition(
             : ImmutableList.copyOf(remainderConditions);
     this.queryType = queryType;
     this.pointQueryKey = pointQueryKey;
-    this.rangeQueryLowerOp = Objects.requireNonNull(rangeQueryLowerOp);
-    this.rangeQueryUpperOp = Objects.requireNonNull(rangeQueryUpperOp);
+    this.rangeQueryLowerOp = Objects.requireNonNull(rangeQueryLowerOp, "rangeQueryLowerOp");
+    this.rangeQueryUpperOp = Objects.requireNonNull(rangeQueryUpperOp, "rangeQueryUpperOp");
     this.rangeQueryLowerKey = ImmutableList.copyOf(rangeQueryLowerKey);
     this.rangeQueryUpperKey = ImmutableList.copyOf(rangeQueryUpperKey);
   }

File: innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilter.java
Patch:
@@ -48,8 +48,8 @@ private InnodbFilter(RelOptCluster cluster, RelTraitSet traitSet,
       TableDef tableDef, @Nullable String forceIndexName) {
     super(cluster, traitSet, input, condition);
 
-    this.tableDef = Objects.requireNonNull(tableDef);
-    this.indexCondition = Objects.requireNonNull(indexCondition);
+    this.tableDef = Objects.requireNonNull(tableDef, "tableDef");
+    this.indexCondition = Objects.requireNonNull(indexCondition, "indexCondition");
     this.forceIndexName = forceIndexName;
 
     assert getConvention() == InnodbRel.CONVENTION;

File: linq4j/src/main/java/org/apache/calcite/linq4j/GroupingImpl.java
Patch:
@@ -35,8 +35,8 @@ class GroupingImpl<K extends Object, V> extends AbstractEnumerable<V>
   private final List<V> values;
 
   GroupingImpl(K key, List<V> values) {
-    this.key = Objects.requireNonNull(key);
-    this.values = Objects.requireNonNull(values);
+    this.key = Objects.requireNonNull(key, "key");
+    this.values = Objects.requireNonNull(values, "values");
   }
 
   @Override public String toString() {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ArrayLengthRecordField.java
Patch:
@@ -55,7 +55,7 @@ public ArrayLengthRecordField(String fieldName, Class clazz) {
   }
 
   @Override public Object get(@Nullable Object o) throws IllegalAccessException {
-    return Array.getLength(requireNonNull(o));
+    return Array.getLength(requireNonNull(o, "o"));
   }
 
   @Override public Type getDeclaringClass() {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
Patch:
@@ -3043,7 +3043,7 @@ public static <T> FluentList<T> list(Iterable<T> ts) {
    * Evaluates an expression and returns the result.
    */
   public static @Nullable Object evaluate(Node node) {
-    requireNonNull(node);
+    requireNonNull(node, "node");
     final Evaluator evaluator = new Evaluator();
     return ((AbstractNode) node).evaluate(evaluator);
   }

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForEachStatement.java
Patch:
@@ -34,9 +34,9 @@ public class ForEachStatement extends Statement {
   public ForEachStatement(ParameterExpression parameter, Expression iterable,
       Statement body) {
     super(ExpressionType.ForEach, Void.TYPE);
-    this.parameter = Objects.requireNonNull(parameter);
-    this.iterable = Objects.requireNonNull(iterable);
-    this.body = Objects.requireNonNull(body); // may be empty block, not null
+    this.parameter = Objects.requireNonNull(parameter, "parameter");
+    this.iterable = Objects.requireNonNull(iterable, "iterable");
+    this.body = Objects.requireNonNull(body, "body"); // may be empty block, not null
   }
 
   @Override public ForEachStatement accept(Shuttle shuttle) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/FunctionExpression.java
Patch:
@@ -86,7 +86,7 @@ public Invokable compile() {
       for (int i = 0; i < args.length; i++) {
         evaluator.push(parameterList.get(i), args[i]);
       }
-      return evaluator.evaluate(requireNonNull(body));
+      return evaluator.evaluate(requireNonNull(body, "body"));
     };
   }
 
@@ -150,7 +150,7 @@ public F getFunction() {
           ? "." + requireNonNull(Primitive.of(parameterType)).primitiveName + "Value()"
           : ""));
     }
-    requireNonNull(body);
+    requireNonNull(body, "body");
     Type bridgeResultType = Functions.FUNCTION_RESULT_TYPES.get(this.type);
     if (bridgeResultType == null) {
       bridgeResultType = body.getType();

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/GotoStatement.java
Patch:
@@ -98,7 +98,7 @@ public class GotoStatement extends Statement {
     case Sequence:
       // NOTE: We ignore control flow. This is only correct if "return"
       // is the last statement in the block.
-      return requireNonNull(expression).evaluate(evaluator);
+      return requireNonNull(expression, "expression").evaluate(evaluator);
     default:
       throw new AssertionError("evaluate not implemented");
     }

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/TryStatement.java
Patch:
@@ -33,8 +33,8 @@ public class TryStatement extends Statement {
   public TryStatement(Statement body, List<CatchBlock> catchBlocks,
       @Nullable Statement fynally) {
     super(ExpressionType.Try, body.getType());
-    this.body = Objects.requireNonNull(body);
-    this.catchBlocks = Objects.requireNonNull(catchBlocks);
+    this.body = Objects.requireNonNull(body, "body");
+    this.catchBlocks = Objects.requireNonNull(catchBlocks, "catchBlocks");
     this.fynally = fynally;
   }
 

File: plus/src/main/java/org/apache/calcite/adapter/os/SqlShell.java
Patch:
@@ -59,9 +59,9 @@ public class SqlShell {
   SqlShell(InputStreamReader in, PrintWriter out,
       PrintWriter err, String... args) {
     this.args = ImmutableList.copyOf(args);
-    this.in = Objects.requireNonNull(in);
-    this.out = Objects.requireNonNull(out);
-    this.err = Objects.requireNonNull(err);
+    this.in = Objects.requireNonNull(in, "in");
+    this.out = Objects.requireNonNull(out, "out");
+    this.err = Objects.requireNonNull(err, "err");
   }
 
   private static String model() {

File: server/src/main/java/org/apache/calcite/server/MutableArrayTable.java
Patch:
@@ -59,10 +59,10 @@ class MutableArrayTable extends AbstractModifiableTable
       RelProtoDataType protoRowType,
       InitializerExpressionFactory initializerExpressionFactory) {
     super(name);
-    this.protoStoredRowType = Objects.requireNonNull(protoStoredRowType);
-    this.protoRowType = Objects.requireNonNull(protoRowType);
+    this.protoStoredRowType = Objects.requireNonNull(protoStoredRowType, "protoStoredRowType");
+    this.protoRowType = Objects.requireNonNull(protoRowType, "protoRowType");
     this.initializerExpressionFactory =
-        Objects.requireNonNull(initializerExpressionFactory);
+        Objects.requireNonNull(initializerExpressionFactory, "initializerExpressionFactory");
   }
 
   @Override public Collection getModifiableCollection() {

File: server/src/main/java/org/apache/calcite/server/ServerDdlExecutor.java
Patch:
@@ -577,7 +577,7 @@ private ColumnDef(SqlNode expr, RelDataType type,
         ColumnStrategy strategy) {
       this.expr = expr;
       this.type = type;
-      this.strategy = Objects.requireNonNull(strategy);
+      this.strategy = Objects.requireNonNull(strategy, "strategy");
       Preconditions.checkArgument(
           strategy == ColumnStrategy.NULLABLE
               || strategy == ColumnStrategy.NOT_NULLABLE

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -615,7 +615,7 @@ private Object toJson(RexWindowBound windowBound) {
         if (type.getSqlTypeName() == SqlTypeName.SYMBOL) {
           literal = RelEnumTypes.toEnum((String) literal);
         }
-        return rexBuilder.makeLiteral(literal, type, false);
+        return rexBuilder.makeLiteral(literal, type);
       }
       throw new UnsupportedOperationException("cannot convert to rex " + o);
     } else if (o instanceof Boolean) {

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -898,7 +898,7 @@ private <C extends Comparable<C>> SqlNode toSql(@Nullable RexProgram program,
         final RangeSets.Consumer<C> consumer =
             new RangeToSql<>(operandSql, orList, v ->
                 toSql(program,
-                    implementor().rexBuilder.makeLiteral(v, type, false)));
+                    implementor().rexBuilder.makeLiteral(v, type)));
         RangeSets.forEach(sarg.rangeSet, consumer);
       }
       return SqlUtil.createCall(SqlStdOperatorTable.OR, POS, orList);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateValuesRule.java
Patch:
@@ -82,8 +82,7 @@ public AggregateValuesRule(RelBuilderFactory relBuilderFactory) {
       case COUNT:
       case SUM0:
         literals.add(
-            (RexLiteral) rexBuilder.makeLiteral(
-                BigDecimal.ZERO, aggregateCall.getType(), false));
+            rexBuilder.makeLiteral(BigDecimal.ZERO, aggregateCall.getType()));
         break;
 
       case MIN:

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -411,8 +411,8 @@ private static RexNode rewriteIn(RexSubQuery e, Set<CorrelationId> variablesSet,
         .map(builder::isNull)
         .collect(Collectors.toList());
 
-    final RexLiteral trueLiteral = (RexLiteral) builder.literal(true);
-    final RexLiteral falseLiteral = (RexLiteral) builder.literal(false);
+    final RexLiteral trueLiteral = builder.literal(true);
+    final RexLiteral falseLiteral = builder.literal(false);
     final RexLiteral unknownLiteral =
         builder.getRexBuilder().makeNullLiteral(trueLiteral.getType());
     if (allLiterals) {

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -1694,8 +1694,8 @@ private static class SubstrConvertlet implements SqlRexConvertlet {
       final RexNode value = exprs.get(0);
       final RexNode start = exprs.get(1);
       final RelDataType startType = start.getType();
-      final RexNode zeroLiteral = rexBuilder.makeLiteral(0, startType, false);
-      final RexNode oneLiteral = rexBuilder.makeLiteral(1, startType, false);
+      final RexLiteral zeroLiteral = rexBuilder.makeLiteral(0, startType);
+      final RexLiteral oneLiteral = rexBuilder.makeLiteral(1, startType);
       final RexNode valueLength =
           SqlTypeUtil.isBinary(value.getType())
               ? rexBuilder.makeCall(SqlStdOperatorTable.OCTET_LENGTH, value)

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -398,7 +398,7 @@ private int inputOffset(int inputCount, int inputOrdinal) {
   // Methods that return scalar expressions
 
   /** Creates a literal (constant expression). */
-  public RexNode literal(@Nullable Object value) {
+  public RexLiteral literal(@Nullable Object value) {
     final RexBuilder rexBuilder = cluster.getRexBuilder();
     if (value == null) {
       final RelDataType type = getTypeFactory().createSqlType(SqlTypeName.NULL);
@@ -417,7 +417,7 @@ public RexNode literal(@Nullable Object value) {
       return rexBuilder.makeLiteral((String) value);
     } else if (value instanceof Enum) {
       return rexBuilder.makeLiteral(value,
-          getTypeFactory().createSqlType(SqlTypeName.SYMBOL), false);
+          getTypeFactory().createSqlType(SqlTypeName.SYMBOL));
     } else {
       throw new IllegalArgumentException("cannot convert " + value
           + " (" + value.getClass() + ") to a constant");
@@ -2573,7 +2573,7 @@ private ImmutableList<ImmutableList<RexLiteral>> tupleList(int columnCount,
     final List<RexLiteral> valueList = new ArrayList<>();
     for (int i = 0; i < values.length; i++) {
       Object value = values[i];
-      valueList.add((RexLiteral) literal(value));
+      valueList.add(literal(value));
       if ((i + 1) % columnCount == 0) {
         listBuilder.add(ImmutableList.copyOf(valueList));
         valueList.clear();

File: core/src/test/java/org/apache/calcite/rex/RexProgramTest.java
Patch:
@@ -2189,9 +2189,9 @@ trueLiteral, literal(1),
     literals.add(rexBuilder.makeLiteral("1969-07-20 12:34:56"));
     literals.add(rexBuilder.makeLiteral("1969-07-20"));
     literals.add(rexBuilder.makeLiteral("12:34:45"));
-    literals.add((RexLiteral)
+    literals.add(
         rexBuilder.makeLiteral(new ByteString(new byte[] {1, 2, -34, 0, -128}),
-            typeFactory.createSqlType(SqlTypeName.BINARY, 5), false));
+            typeFactory.createSqlType(SqlTypeName.BINARY, 5)));
     literals.add(rexBuilder.makeDateLiteral(new DateString(1974, 8, 9)));
     literals.add(rexBuilder.makeTimeLiteral(new TimeString(1, 23, 45), 0));
     literals.add(

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -807,7 +807,7 @@ private void project1(int value, SqlTypeName sqlTypeName, String message, String
             .empty()
             .project(
                 rex.makeLiteral(value,
-                    rex.getTypeFactory().createSqlType(sqlTypeName), false))
+                    rex.getTypeFactory().createSqlType(sqlTypeName)))
             .build();
     assertThat(message, actual, hasTree(expected));
   }

File: core/src/test/java/org/apache/calcite/test/fuzzer/RexFuzzer.java
Patch:
@@ -185,7 +185,8 @@ public RexNode getSimpleInt(Random r) {
     case 1: {
       int i = r.nextInt(INT_VALUES.length + 1);
       int val = i < INT_VALUES.length ? INT_VALUES[i] : r.nextInt();
-      return rexBuilder.makeLiteral(val, r.nextBoolean() ? intType : nullableIntType, false);
+      return rexBuilder.makeLiteral(val,
+          r.nextBoolean() ? intType : nullableIntType);
     }
     case 2:
       return nullInt;

File: piglet/src/main/java/org/apache/calcite/piglet/Handler.java
Patch:
@@ -219,15 +219,15 @@ private RexLiteral item(Ast.Node node, RelDataType type) {
     switch (node.op) {
     case LITERAL:
       final Ast.Literal literal = (Ast.Literal) node;
-      return (RexLiteral) rexBuilder.makeLiteral(literal.value, type, false);
+      return rexBuilder.makeLiteral(literal.value, type);
     case TUPLE:
       final Ast.Call tuple = (Ast.Call) node;
       final ImmutableList<RexLiteral> list = tuple(tuple.operands, type);
-      return (RexLiteral) rexBuilder.makeLiteral(list, type, false);
+      return rexBuilder.makeLiteral(list, type);
     case BAG:
       final Ast.Call bag = (Ast.Call) node;
       final ImmutableList<RexLiteral> list2 = bag(bag.operands, type);
-      return (RexLiteral) rexBuilder.makeLiteral(list2, type, false);
+      return rexBuilder.makeLiteral(list2, type);
     default:
       throw new IllegalArgumentException("not a literal: " + node);
     }

File: core/src/main/java/org/apache/calcite/rex/RexChecker.java
Patch:
@@ -155,7 +155,7 @@ public int getFailureCount() {
     assert refType.isStruct();
     final RelDataTypeField field = fieldAccess.getField();
     final int index = field.getIndex();
-    if ((index < 0) || (index > refType.getFieldList().size())) {
+    if ((index < 0) || (index >= refType.getFieldList().size())) {
       ++failCount;
       return litmus.fail(null);
     }

File: core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java
Patch:
@@ -73,7 +73,7 @@ private static void checkValid(RexNode expr, RelDataTypeField field) {
     RelDataType exprType = expr.getType();
     int fieldIdx = field.getIndex();
     Preconditions.checkArgument(
-        fieldIdx < exprType.getFieldList().size()
+        fieldIdx >= 0 && fieldIdx < exprType.getFieldList().size()
             && exprType.getFieldList().get(fieldIdx).equals(field),
         "Field " + field + " does not exist for expression " + expr);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -2079,7 +2079,8 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
 
   /**
    * The item operator {@code [ ... ]}, used to access a given element of an
-   * array or map. For example, {@code myArray[3]} or {@code "myMap['foo']"}.
+   * array, map or struct. For example, {@code myArray[3]}, {@code "myMap['foo']"},
+   * {@code myStruct[2]} or {@code myStruct['fieldName']}.
    *
    * <p>The SQL standard calls the ARRAY variant a
    * &lt;array element reference&gt;. Index is 1-based. The standard says

File: core/src/main/java/org/apache/calcite/sql/dialect/OracleSqlDialect.java
Patch:
@@ -142,7 +142,7 @@ public OracleSqlDialect(Context context) {
   @Override public void unparseCall(SqlWriter writer, SqlCall call,
       int leftPrec, int rightPrec) {
     if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {
-      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.ORACLE_SUBSTR, writer,
+      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.SUBSTR_ORACLE, writer,
           call, false);
     } else {
       switch (call.getKind()) {

File: core/src/main/java/org/apache/calcite/sql/fun/OracleSqlOperatorTable.java
Patch:
@@ -50,7 +50,7 @@ public class OracleSqlOperatorTable extends ReflectiveSqlOperatorTable {
   public static final SqlFunction RTRIM = SqlLibraryOperators.RTRIM;
 
   @Deprecated // to be removed before 2.0
-  public static final SqlFunction SUBSTR = SqlLibraryOperators.ORACLE_SUBSTR;
+  public static final SqlFunction SUBSTR = SqlLibraryOperators.SUBSTR_ORACLE;
 
   @Deprecated // to be removed before 2.0
   public static final SqlFunction GREATEST = SqlLibraryOperators.GREATEST;

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.calcite.adapter.enumerable.SourceSorter;
 import org.apache.calcite.adapter.java.ReflectiveSchema;
 import org.apache.calcite.adapter.jdbc.JdbcSchema;
+import org.apache.calcite.avatica.util.ByteString;
 import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.avatica.util.TimeUnitRange;
 import org.apache.calcite.interpreter.Context;
@@ -384,6 +385,7 @@ public enum BuiltInMethod {
   INITCAP(SqlFunctions.class, "initcap", String.class),
   SUBSTRING(SqlFunctions.class, "substring", String.class, int.class,
       int.class),
+  OCTET_LENGTH(SqlFunctions.class, "octetLength", ByteString.class),
   CHAR_LENGTH(SqlFunctions.class, "charLength", String.class),
   STRING_CONCAT(SqlFunctions.class, "concat", String.class, String.class),
   MULTI_STRING_CONCAT(SqlFunctions.class, "concatMulti", String[].class),

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -2838,6 +2838,9 @@ private static RelFieldCollation collation(RexNode node,
    * Creates a projection that converts the current relational expression's
    * output to a desired row type.
    *
+   * <p>The desired row type and the row type to be converted must have the
+   * same number of fields.
+   *
    * @param castRowType row type after cast
    * @param rename      if true, use field names from castRowType; if false,
    *                    preserve field names from rel

File: core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
Patch:
@@ -369,7 +369,7 @@ ArrayTable.Representation chooseRep(int ordinal) {
       return new ArrayTable.ObjectArray(ordinal);
     }
 
-    private long toLong(Object o) {
+    private static long toLong(Object o) {
       // We treat Boolean and Character as if they were subclasses of
       // Number but actually they are not.
       if (o instanceof Boolean) {
@@ -382,7 +382,7 @@ private long toLong(Object o) {
     }
 
     @EnsuresNonNullIf(result = true, expression = "#1")
-    private boolean canBeLong(@Nullable Object o) {
+    private static boolean canBeLong(@Nullable Object o) {
       return o instanceof Boolean
           || o instanceof Character
           || o instanceof Number;
@@ -397,7 +397,7 @@ private boolean canBeLong(@Nullable Object o) {
      * @param min Minimum value to be encoded
      * @param max Maximum value to be encoded (inclusive)
      */
-    private ArrayTable.Representation chooseFixedRep(
+    private static ArrayTable.Representation chooseFixedRep(
         int ordinal, Primitive p, long min, long max) {
       if (min == max) {
         return new ArrayTable.Constant(ordinal);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
Patch:
@@ -975,15 +975,15 @@ private void initialize() {
       }
     }
 
-    private boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {
+    private static boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {
       return !(b.left >= a.right);
     }
 
-    private Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {
+    private static Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {
       return new Pair<>(a.left <= b.left ? a.left : b.left, a.right >= b.right ? a.right : b.right);
     }
 
-    private Pair<Long, Long> computeInitWindow(long ts, long gap) {
+    private static Pair<Long, Long> computeInitWindow(long ts, long gap) {
       return new Pair<>(ts, ts + gap);
     }
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java
Patch:
@@ -149,7 +149,7 @@ public static EnumerableLimitSort create(
     return cost;
   }
 
-  private double getValue(@Nullable RexNode r, double defaultValue) {
+  private static double getValue(@Nullable RexNode r, double defaultValue) {
     if (r == null || r instanceof RexDynamicParam) {
       return defaultValue;
     }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
Patch:
@@ -332,7 +332,7 @@ private Mappings.TargetMapping buildMapping(boolean left2Right) {
   /**
    * This function extends collation by appending new collation fields defined on keys.
    */
-  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {
+  private static RelCollation extendCollation(RelCollation collation, List<Integer> keys) {
     List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());
     fieldsForNewCollation.addAll(collation.getFieldCollations());
 
@@ -360,7 +360,7 @@ private RelCollation extendCollation(RelCollation collation, List<Integer> keys)
    * @param collation collation defined on the JOIN
    * @param joinKeys  the join keys
    */
-  private RelCollation intersectCollationAndJoinKey(
+  private static RelCollation intersectCollationAndJoinKey(
       RelCollation collation, ImmutableIntList joinKeys) {
     List<RelFieldCollation> fieldCollations = new ArrayList<>();
     for (RelFieldCollation rf : collation.getFieldCollations()) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
Patch:
@@ -182,7 +182,7 @@ public ClassDeclaration implementRoot(EnumerableRel rootRel,
         memberDeclarations);
   }
 
-  private ClassDeclaration classDecl(
+  private static ClassDeclaration classDecl(
       JavaTypeFactoryImpl.SyntheticRecordType type) {
     ClassDeclaration classDeclaration =
         Expressions.classDecl(
@@ -545,7 +545,7 @@ static class TypeFinder extends VisitorImpl<Void> {
   }
 
   /** Adds a declaration of each synthetic type found in a code block. */
-  private class TypeRegistrar {
+  private static class TypeRegistrar {
     private final List<MemberDeclaration> memberDeclarations;
     private final Set<Type> seen = new HashSet<>();
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableFunctionScan.java
Patch:
@@ -75,7 +75,7 @@ public EnumerableTableFunctionScan(RelOptCluster cluster,
     }
   }
 
-  private boolean isImplementorDefined(RexCall call) {
+  private static boolean isImplementorDefined(RexCall call) {
     if (call.getOperator() instanceof SqlWindowTableFunction
         && RexImpTable.INSTANCE.get((SqlWindowTableFunction) call.getOperator()) != null) {
       return true;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
Patch:
@@ -209,7 +209,7 @@ private Expression getExpression(PhysType physType) {
     return toRows(physType, expression2);
   }
 
-  private Expression toEnumerable(Expression expression) {
+  private static Expression toEnumerable(Expression expression) {
     final Type type = expression.getType();
     if (Types.isArray(type)) {
       if (requireNonNull(toClass(type).getComponentType()).isPrimitive()) {
@@ -309,7 +309,7 @@ private JavaRowFormat format() {
     return JavaRowFormat.CUSTOM;
   }
 
-  private boolean hasCollectionField(RelDataType rowType) {
+  private static boolean hasCollectionField(RelDataType rowType) {
     for (RelDataTypeField field : rowType.getFieldList()) {
       switch (field.getType().getSqlTypeName()) {
       case ARRAY:

File: core/src/main/java/org/apache/calcite/adapter/enumerable/ReflectiveCallNotNullImplementor.java
Patch:
@@ -66,7 +66,7 @@ public ReflectiveCallNotNullImplementor(Method method) {
     return translator.handleMethodCheckedExceptions(callExpr);
   }
 
-  private boolean containsCheckedException(Method method) {
+  private static boolean containsCheckedException(Method method) {
     Class[] exceptions = method.getExceptionTypes();
     if (exceptions == null || exceptions.length == 0) {
       return false;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java
Patch:
@@ -1238,7 +1238,7 @@ private Result implementCaseWhen(RexCall call) {
    *      }
    * }</pre></blockquote>
    */
-  private void implementRecursively(final RexToLixTranslator currentTranslator,
+  private static void implementRecursively(final RexToLixTranslator currentTranslator,
       final List<RexNode> operandList, final ParameterExpression valueVariable, int pos) {
     final BlockBuilder currentBlockBuilder = currentTranslator.getBlockBuilder();
     final List<@Nullable Type> storageTypes = EnumUtils.internalTypes(operandList);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
Patch:
@@ -48,7 +48,7 @@ protected final int getStateSize() {
     return stateSize;
   }
 
-  protected final void accAdvance(AggAddContext add, Expression acc,
+  protected static void accAdvance(AggAddContext add, Expression acc,
       Expression next) {
     add.currentBlock().add(
         Expressions.statement(
@@ -71,7 +71,7 @@ protected final void accAdvance(AggAddContext add, Expression acc,
     return res;
   }
 
-  private boolean anyNullable(List<? extends RelDataType> types) {
+  private static boolean anyNullable(List<? extends RelDataType> types) {
     for (RelDataType type : types) {
       if (type.isNullable()) {
         return true;

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
Patch:
@@ -331,7 +331,7 @@ protected JdbcJoinRule(Config config) {
      * @param node Condition
      * @return Whether condition is supported
      */
-    private boolean canJoinOnCondition(RexNode node) {
+    private static boolean canJoinOnCondition(RexNode node) {
       final List<RexNode> operands;
       switch (node.getKind()) {
       case AND:

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -307,7 +307,7 @@ private ImmutableMap<String, JdbcTable> computeTables() {
   }
 
   /** Returns [major, minor] version from a database metadata. */
-  private List<Integer> version(DatabaseMetaData metaData) throws SQLException {
+  private static List<Integer> version(DatabaseMetaData metaData) throws SQLException {
     return ImmutableList.of(metaData.getJDBCMajorVersion(),
         metaData.getJDBCMinorVersion());
   }
@@ -407,7 +407,7 @@ RelProtoDataType getRelDataType(DatabaseMetaData metaData, String catalogName,
     return RelDataTypeImpl.proto(fieldInfo.build());
   }
 
-  private RelDataType sqlType(RelDataTypeFactory typeFactory, int dataType,
+  private static RelDataType sqlType(RelDataTypeFactory typeFactory, int dataType,
       int precision, int scale, @Nullable String typeString) {
     // Fall back to ANY if type is unknown
     final SqlTypeName sqlTypeName =
@@ -445,7 +445,7 @@ private RelDataType sqlType(RelDataTypeFactory typeFactory, int dataType,
   /** Given "INTEGER", returns BasicSqlType(INTEGER).
    * Given "VARCHAR(10)", returns BasicSqlType(VARCHAR, 10).
    * Given "NUMERIC(10, 2)", returns BasicSqlType(NUMERIC, 10, 2). */
-  private RelDataType parseTypeString(RelDataTypeFactory typeFactory,
+  private static RelDataType parseTypeString(RelDataTypeFactory typeFactory,
       String typeString) {
     int precision = -1;
     int scale = -1;

File: core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
Patch:
@@ -267,7 +267,7 @@ private AccumulatorFactory getAccumulator(final AggregateCall call,
     }
   }
 
-  private AggregateFunctionImpl getAggFunction(Class<?> clazz) {
+  private static AggregateFunctionImpl getAggFunction(Class<?> clazz) {
     return requireNonNull(
         AggregateFunctionImpl.create(clazz),
         () -> "Unable to create AggregateFunctionImpl for " + clazz);

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -151,7 +151,7 @@ private void start() {
 
   /** Not used. */
   @SuppressWarnings("unused")
-  private class FooCompiler implements ScalarCompiler {
+  private static class FooCompiler implements ScalarCompiler {
     @Override public Scalar compile(List<RexNode> nodes, RelDataType inputRowType) {
       final RexNode node = nodes.get(0);
       if (node instanceof RexCall) {

File: core/src/main/java/org/apache/calcite/interpreter/SortNode.java
Patch:
@@ -95,10 +95,10 @@ private Comparator<Row> comparator() {
     }
     return Ordering.compound(
         Util.transform(rel.getCollation().getFieldCollations(),
-            this::comparator));
+            SortNode::comparator));
   }
 
-  private Comparator<Row> comparator(RelFieldCollation fieldCollation) {
+  private static Comparator<Row> comparator(RelFieldCollation fieldCollation) {
     final int nullComparison = fieldCollation.nullDirection.nullComparison;
     final int x = fieldCollation.getFieldIndex();
     switch (fieldCollation.direction) {

File: core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
Patch:
@@ -233,7 +233,7 @@ CalciteConnectionImpl getConnection() {
     return builder.build();
   }
 
-  private ImmutableMap.Builder<DatabaseProperty, Object> addProperty(
+  private static ImmutableMap.Builder<DatabaseProperty, Object> addProperty(
       ImmutableMap.Builder<DatabaseProperty, Object> builder,
       DatabaseProperty p) {
     switch (p) {
@@ -587,8 +587,8 @@ Iterable<Object> _createIterable(StatementHandle handle,
   /** Wraps the SQL string in a
    * {@link org.apache.calcite.jdbc.CalcitePrepare.Query} object, giving the
    * {@link Hook#STRING_TO_QUERY} hook chance to override. */
-  private CalcitePrepare.Query<Object> toQuery(
-      Context context, String sql) {
+  private static CalcitePrepare.Query<Object> toQuery(
+          Context context, String sql) {
     final Holder<CalcitePrepare.Query<Object>> queryHolder =
         Holder.of(CalcitePrepare.Query.of(sql));
     final FrameworkConfig config = Frameworks.newConfigBuilder()

File: core/src/main/java/org/apache/calcite/jdbc/CalciteResultSet.java
Patch:
@@ -87,12 +87,12 @@ public class CalciteResultSet extends AvaticaResultSet {
     final CalciteResultSet resultSet =
         new CalciteResultSet(statement, signature, subResultSetMetaData,
             localCalendar.getTimeZone(), new Meta.Frame(0, true, iterable));
-    final Cursor cursor = resultSet.createCursor(elementType, iterable);
+    final Cursor cursor = CalciteResultSet.createCursor(elementType, iterable);
     return resultSet.execute2(cursor, columnMetaDataList);
   }
 
-  private Cursor createCursor(ColumnMetaData.AvaticaType elementType,
-      Iterable iterable) {
+  private static Cursor createCursor(ColumnMetaData.AvaticaType elementType,
+          Iterable iterable) {
     final Enumerator enumerator = Linq4j.iterableEnumerator(iterable);
     //noinspection unchecked
     return !(elementType instanceof ColumnMetaData.StructType)

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -94,7 +94,7 @@ public JavaTypeFactoryImpl(RelDataTypeSystem typeSystem) {
    * <p>Takes into account {@link org.apache.calcite.adapter.java.Array}
    * annotations if present.
    */
-  private Type fieldType(Field field) {
+  private static Type fieldType(Field field) {
     final Class<?> klass = field.getType();
     final org.apache.calcite.adapter.java.Array array =
         field.getAnnotation(org.apache.calcite.adapter.java.Array.class);

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -1034,7 +1034,7 @@ public Measure resolveMeasure(String aggName, boolean distinct,
       return new Measure(agg, distinct, aggName, list);
     }
 
-    private SqlAggFunction resolveAgg(String aggName) {
+    private static SqlAggFunction resolveAgg(String aggName) {
       if (aggName.equalsIgnoreCase("count")) {
         return SqlStdOperatorTable.COUNT;
       } else if (aggName.equalsIgnoreCase("sum")) {

File: core/src/main/java/org/apache/calcite/materialize/MaterializationService.java
Patch:
@@ -305,7 +305,7 @@ && allSatisfiable(measureList, tileKey2)) {
     return null;
   }
 
-  private boolean allSatisfiable(List<Lattice.Measure> measureList,
+  private static boolean allSatisfiable(List<Lattice.Measure> measureList,
       TileKey tileKey) {
     // A measure can be satisfied if it is contained in the measure list, or,
     // less obviously, if it is composed of grouping columns.

File: core/src/main/java/org/apache/calcite/materialize/SqlLatticeStatisticProvider.java
Patch:
@@ -59,7 +59,7 @@ private SqlLatticeStatisticProvider(Lattice lattice) {
     return (int) Lattice.getRowCount(lattice.getFactRowCount(), counts);
   }
 
-  private double cardinality(Lattice lattice, Lattice.Column column) {
+  private static double cardinality(Lattice lattice, Lattice.Column column) {
     final String sql = lattice.countSql(ImmutableBitSet.of(column.ordinal));
     final Table table =
         new MaterializationService.DefaultTableFactory()

File: core/src/main/java/org/apache/calcite/materialize/Step.java
Patch:
@@ -135,7 +135,7 @@ private static int compare(RelOptTable table1, List<Integer> columns1,
   /** Temporary method. We should use (inferred) primary keys to figure out
    * the direction of steps. */
   @SuppressWarnings("unused")
-  private double cardinality(SqlStatisticProvider statisticProvider,
+  private static double cardinality(SqlStatisticProvider statisticProvider,
       LatticeTable table) {
     return statisticProvider.tableCardinality(table.t);
   }

File: core/src/main/java/org/apache/calcite/plan/ConventionTraitDef.java
Patch:
@@ -176,7 +176,7 @@ private ConventionTraitDef() {
    * Tries to convert a relational expression to the target convention of an
    * arc.
    */
-  private @Nullable RelNode changeConvention(
+  private static @Nullable RelNode changeConvention(
       RelNode rel,
       Convention source,
       Convention target,

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -647,7 +647,7 @@ assert rowTypesAreEquivalent(
   /**
    * Equivalence checking for row types, but except for the field names.
    */
-  private boolean rowTypesAreEquivalent(
+  private static boolean rowTypesAreEquivalent(
       MutableRel rel0, MutableRel rel1, Litmus litmus) {
     if (rel0.rowType.getFieldCount() != rel1.rowType.getFieldCount()) {
       return litmus.fail("Mismatch for column count: [{}]", Pair.of(rel0, rel1));

File: core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
Patch:
@@ -620,7 +620,7 @@ private List<HepRelVertex> getVertexParents(HepRelVertex vertex) {
     return parents;
   }
 
-  private boolean matchOperands(
+  private static boolean matchOperands(
       RelOptRuleOperand operand,
       RelNode rel,
       List<RelNode> bindings,

File: core/src/main/java/org/apache/calcite/plan/volcano/IterativeRuleQueue.java
Patch:
@@ -137,7 +137,7 @@ class IterativeRuleQueue extends RuleQueue {
   /**
    * Dumps rules queue to the logger when debug level is set to {@code TRACE}.
    */
-  private void dumpRuleQueue(MatchList matchList) {
+  private static void dumpRuleQueue(MatchList matchList) {
     if (LOGGER.isTraceEnabled()) {
       StringBuilder b = new StringBuilder();
       b.append("Rule queue:");

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -1077,7 +1077,7 @@ void canonize() {
    * @param subset Subset
    * @return Leader of subset's equivalence class
    */
-  private RelSubset canonize(final RelSubset subset) {
+  private static RelSubset canonize(final RelSubset subset) {
     RelSet set = subset.set;
     if (set.equivalentSet == null) {
       return subset;

File: core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
Patch:
@@ -212,7 +212,7 @@ private Collection<org.apache.calcite.schema.Function> getFunctionsFrom(
     return result.build();
   }
 
-  private SqlMonikerImpl moniker(CalciteSchema schema, @Nullable String name,
+  private static SqlMonikerImpl moniker(CalciteSchema schema, @Nullable String name,
       SqlMonikerType type) {
     final List<String> path = schema.path(name);
     if (path.size() == 1

File: core/src/main/java/org/apache/calcite/prepare/Prepare.java
Patch:
@@ -377,7 +377,7 @@ protected RelRoot trimUnusedFields(RelRoot root) {
     return root.withRel(converter.trimUnusedFields(dml || ordered, root.rel));
   }
 
-  private boolean shouldTrim(RelNode rootRel) {
+  private static boolean shouldTrim(RelNode rootRel) {
     // For now, don't trim if there are more than 3 joins. The projects
     // near the leaves created by trim migrate past joins and seem to
     // prevent join-reordering.

File: core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java
Patch:
@@ -163,7 +163,7 @@ protected String getRelNodeLabel(
     return "\"" + String.join("\\n", newlabels) + "\"";
   }
 
-  private List<RelNode> getInputs(RelNode parent) {
+  private static List<RelNode> getInputs(RelNode parent) {
     return Util.transform(parent.getInputs(), child -> {
       if (child instanceof HepRelVertex) {
         return ((HepRelVertex) child).getCurrentRel();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java
Patch:
@@ -151,7 +151,7 @@ public class RelMdAllPredicates
    * Add the Filter condition to the list obtained from the input.
    * The pred comes from the parent of rel.
    */
-  private @Nullable RelOptPredicateList getAllFilterPredicates(RelNode rel,
+  private static @Nullable RelOptPredicateList getAllFilterPredicates(RelNode rel,
       RelMetadataQuery mq, RexNode pred) {
     final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
     final RelOptPredicateList predsBelow = mq.getAllPredicates(rel);

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
Patch:
@@ -253,7 +253,7 @@ private RelMdColumnOrigins() {}
     return set;
   }
 
-  private @PolyNull Set<RelColumnOrigin> createDerivedColumnOrigins(
+  private static @PolyNull Set<RelColumnOrigin> createDerivedColumnOrigins(
       @PolyNull Set<RelColumnOrigin> inputSet) {
     if (inputSet == null) {
       return null;
@@ -270,7 +270,7 @@ private RelMdColumnOrigins() {}
     return set;
   }
 
-  private Set<RelColumnOrigin> getMultipleColumns(RexNode rexNode, RelNode input,
+  private static Set<RelColumnOrigin> getMultipleColumns(RexNode rexNode, RelNode input,
       final RelMetadataQuery mq) {
     final Set<RelColumnOrigin> set = new HashSet<>();
     final RexVisitor<Void> visitor =

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -224,7 +224,7 @@ public Boolean areColumnsUnique(Intersect rel, RelMetadataQuery mq,
         Util.transform(program.getProjectList(), program::expandLocalRef));
   }
 
-  private @Nullable Boolean areProjectColumnsUnique(
+  private static @Nullable Boolean areProjectColumnsUnique(
       SingleRel rel, RelMetadataQuery mq,
       ImmutableBitSet columns, boolean ignoreNulls, List<RexNode> projExprs) {
     RelDataTypeFactory typeFactory = rel.getCluster().getTypeFactory();
@@ -421,7 +421,7 @@ public Boolean areColumnsUnique(Values rel, RelMetadataQuery mq,
     return false;
   }
 
-  private boolean simplyProjects(RelNode rel, ImmutableBitSet columns) {
+  private static boolean simplyProjects(RelNode rel, ImmutableBitSet columns) {
     if (!(rel instanceof Project)) {
       return false;
     }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdSize.java
Patch:
@@ -199,7 +199,8 @@ protected RelMdSize() {}
     return averageJoinColumnSizes(rel, mq);
   }
 
-  private @Nullable List<@Nullable Double> averageJoinColumnSizes(Join rel, RelMetadataQuery mq) {
+  private static @Nullable List<@Nullable Double> averageJoinColumnSizes(Join rel,
+      RelMetadataQuery mq) {
     boolean semiOrAntijoin = !rel.getJoinType().projectsRight();
     final RelNode left = rel.getLeft();
     final RelNode right = rel.getRight();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
Patch:
@@ -104,7 +104,7 @@ public Set<ImmutableBitSet> getUniqueKeys(Project rel, RelMetadataQuery mq,
         Util.transform(program.getProjectList(), program::expandLocalRef));
   }
 
-  private Set<ImmutableBitSet> getProjectUniqueKeys(SingleRel rel, RelMetadataQuery mq,
+  private static Set<ImmutableBitSet> getProjectUniqueKeys(SingleRel rel, RelMetadataQuery mq,
       boolean ignoreNulls, List<RexNode> projExprs) {
     // LogicalProject maps a set of rows to a different set;
     // Without knowledge of the mapping function(whether it

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -497,7 +497,7 @@ protected Result result(SqlNode node, Collection<Clause> clauses,
 
   /** Returns the row type of {@code rel}, adjusting the field names if
    * {@code node} is "(query) as tableAlias (fieldAlias, ...)". */
-  private RelDataType adjustedRowType(RelNode rel, SqlNode node) {
+  private static RelDataType adjustedRowType(RelNode rel, SqlNode node) {
     final RelDataType rowType = rel.getRowType();
     final RelDataTypeFactory.Builder builder;
     switch (node.getKind()) {
@@ -555,7 +555,7 @@ public Result result(SqlNode join, Result leftResult, Result rightResult) {
     return result(join, ImmutableList.of(Clause.FROM), null, null, aliases);
   }
 
-  private void collectAliases(ImmutableMap.Builder<String, RelDataType> builder,
+  private static void collectAliases(ImmutableMap.Builder<String, RelDataType> builder,
       SqlNode node, Iterator<RelDataType> aliases) {
     if (node instanceof SqlJoin) {
       final SqlJoin join = (SqlJoin) node;
@@ -1022,7 +1022,7 @@ private SqlCall toSql(@Nullable RexProgram program, RexOver rexOver) {
       return createOverCall(sqlAggregateFunction, nodeList, sqlWindow, rexOver.isDistinct());
     }
 
-    private SqlCall createOverCall(SqlAggFunction op, List<SqlNode> operands,
+    private static SqlCall createOverCall(SqlAggFunction op, List<SqlNode> operands,
         SqlWindow window, boolean isDistinct) {
       if (op instanceof SqlSumEmptyIsZeroAggFunction) {
         // Rewrite "SUM0(x) OVER w" to "COALESCE(SUM(x) OVER w, 0)"

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateCaseToFilterRule.java
Patch:
@@ -150,7 +150,7 @@ && isThreeArgCase(project.getProjects().get(singleArg))) {
     call.getPlanner().prune(aggregate);
   }
 
-  private @Nullable AggregateCall transform(AggregateCall aggregateCall,
+  private static @Nullable AggregateCall transform(AggregateCall aggregateCall,
       Project project, List<RexNode> newProjects) {
     final int singleArg = soleArgument(aggregateCall);
     if (singleArg < 0) {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -153,7 +153,7 @@ private static boolean isAggregateSupported(Aggregate aggregate,
   // OUTER joins are supported for group by without aggregate functions
   // FULL OUTER JOIN is not supported since it could produce wrong result
   // due to bug (CALCITE-3012)
-  private boolean isJoinSupported(final Join join, final Aggregate aggregate) {
+  private static boolean isJoinSupported(final Join join, final Aggregate aggregate) {
     return join.getJoinType() == JoinRelType.INNER || aggregate.getAggCallList().isEmpty();
   }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
Patch:
@@ -64,7 +64,7 @@ public AggregateMergeRule(RelOptRuleOperand operand,
         .as(Config.class));
   }
 
-  private boolean isAggregateSupported(AggregateCall aggCall) {
+  private static boolean isAggregateSupported(AggregateCall aggCall) {
     if (aggCall.isDistinct()
         || aggCall.hasFilter()
         || aggCall.isApproximate()

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionAggregateRule.java
Patch:
@@ -83,7 +83,7 @@ public AggregateUnionAggregateRule(Class<? extends Aggregate> aggregateClass,
    * Returns an input with the same row type with the input Aggregate,
    * create a Project node if needed.
    */
-  private RelNode getInputWithSameRowType(Aggregate bottomAggRel) {
+  private static RelNode getInputWithSameRowType(Aggregate bottomAggRel) {
     if (RelOptUtil.areRowTypesEqual(
             bottomAggRel.getRowType(),
             bottomAggRel.getInput(0).getRowType(),

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -159,7 +159,7 @@ public AggregateUnionTransposeRule(Class<? extends Aggregate> aggregateClass,
     call.transformTo(relBuilder.build());
   }
 
-  private @Nullable List<AggregateCall> transformAggCalls(RelNode input, int groupCount,
+  private static @Nullable List<AggregateCall> transformAggCalls(RelNode input, int groupCount,
       List<AggregateCall> origCalls) {
     final List<AggregateCall> newCalls = new ArrayList<>();
     for (Ord<AggregateCall> ord : Ord.zip(origCalls)) {

File: core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
Patch:
@@ -426,7 +426,7 @@ private int chooseLevels(
    * @param cohorts List of cohorts, each of which is a set of expr ordinals
    * @return Expression ordinals in topological order
    */
-  private List<Integer> computeTopologicalOrdering(
+  private static List<Integer> computeTopologicalOrdering(
       RexNode[] exprs,
       List<Set<Integer>> cohorts) {
     final DirectedGraph<Integer, DefaultEdge> graph =
@@ -480,7 +480,7 @@ private List<Integer> computeTopologicalOrdering(
     return null;
   }
 
-  private int[] identityArray(int length) {
+  private static int[] identityArray(int length) {
     final int[] ints = new int[length];
     for (int i = 0; i < ints.length; i++) {
       ints[i] = i;

File: core/src/main/java/org/apache/calcite/rel/rules/FilterAggregateTransposeRule.java
Patch:
@@ -125,7 +125,7 @@ public FilterAggregateTransposeRule(
     call.transformTo(rel);
   }
 
-  private boolean canPush(Aggregate aggregate, ImmutableBitSet rCols) {
+  private static boolean canPush(Aggregate aggregate, ImmutableBitSet rCols) {
     // If the filter references columns not in the group key, we cannot push
     final ImmutableBitSet groupKeys =
         ImmutableBitSet.range(0, aggregate.getGroupSet().cardinality());

File: core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
Patch:
@@ -238,7 +238,7 @@ protected void perform(RelOptRuleCall call, @Nullable Filter filter,
    * expressions if any
    * @see RelOptUtil#conjunctions(RexNode)
    */
-  private List<RexNode> getConjunctions(Filter filter) {
+  private static List<RexNode> getConjunctions(Filter filter) {
     List<RexNode> conjunctions = conjunctions(filter.getCondition());
     RexBuilder rexBuilder = filter.getCluster().getRexBuilder();
     for (int i = 0; i < conjunctions.size(); i++) {

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java
Patch:
@@ -106,7 +106,7 @@ public JoinPushThroughJoinRule(String description, boolean right,
     }
   }
 
-  private void onMatchRight(RelOptRuleCall call) {
+  private static void onMatchRight(RelOptRuleCall call) {
     final Join topJoin = call.rel(0);
     final Join bottomJoin = call.rel(1);
     final RelNode relC = call.rel(2);
@@ -210,7 +210,7 @@ private void onMatchRight(RelOptRuleCall call) {
    * Similar to {@link #onMatch}, but swaps the upper sibling with the left
    * of the two lower siblings, rather than the right.
    */
-  private void onMatchLeft(RelOptRuleCall call) {
+  private static void onMatchLeft(RelOptRuleCall call) {
     final Join topJoin = call.rel(0);
     final Join bottomJoin = call.rel(1);
     final RelNode relC = call.rel(2);

File: core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
Patch:
@@ -190,7 +190,7 @@ public void makePossibleSemiJoins(LoptMultiJoin multiJoin) {
    * @return index of corresponding dimension table if the filter is
    * appropriate; otherwise -1 is returned
    */
-  private int isSuitableFilter(
+  private static int isSuitableFilter(
       LoptMultiJoin multiJoin,
       RexNode joinFilter,
       int factIdx) {

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
Patch:
@@ -290,7 +290,7 @@ private double rowCountDiff(LoptMultiJoin.Edge edge) {
     call.transformTo(relBuilder.build());
   }
 
-  private void trace(List<Vertex> vertexes,
+  private static void trace(List<Vertex> vertexes,
       List<LoptMultiJoin.Edge> unusedEdges, List<LoptMultiJoin.Edge> usedEdges,
       int edgeOrdinal, PrintWriter pw) {
     pw.println("bestEdge: " + edgeOrdinal);

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
Patch:
@@ -320,7 +320,7 @@ static class WindowedAggRelSplitter extends CalcRelSplitter {
       return cohorts;
     }
 
-    private boolean isDependent(final DirectedGraph<Integer, DefaultEdge> graph,
+    private static boolean isDependent(final DirectedGraph<Integer, DefaultEdge> graph,
         final List<Integer> rank,
         final int ordinal1,
         final int ordinal2) {
@@ -355,7 +355,7 @@ private boolean isDependent(final DirectedGraph<Integer, DefaultEdge> graph,
       return false;
     }
 
-    private List<Integer> getRank(DirectedGraph<Integer, DefaultEdge> graph) {
+    private static List<Integer> getRank(DirectedGraph<Integer, DefaultEdge> graph) {
       final int[] rankArr = new int[graph.vertexSet().size()];
       int rank = 0;
       for (int i : TopologicalOrderIterator.of(graph)) {
@@ -364,7 +364,7 @@ private List<Integer> getRank(DirectedGraph<Integer, DefaultEdge> graph) {
       return ImmutableIntList.of(rankArr);
     }
 
-    private DirectedGraph<Integer, DefaultEdge> createGraphFromExpression(
+    private static DirectedGraph<Integer, DefaultEdge> createGraphFromExpression(
         final List<RexNode> exprs) {
       final DirectedGraph<Integer, DefaultEdge> graph =
           DefaultDirectedGraph.create();

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectWindowTransposeRule.java
Patch:
@@ -188,7 +188,7 @@ public ProjectWindowTransposeRule(RelBuilderFactory relBuilderFactory) {
     }
   }
 
-  private ImmutableBitSet findReference(final Project project,
+  private static ImmutableBitSet findReference(final Project project,
       final Window window) {
     final int windowInputColumn = window.getInput().getRowType().getFieldCount();
     final ImmutableBitSet.Builder beReferred = ImmutableBitSet.builder();
@@ -228,7 +228,7 @@ private ImmutableBitSet findReference(final Project project,
     return beReferred.build();
   }
 
-  private int getAdjustedIndex(final int initIndex,
+  private static int getAdjustedIndex(final int initIndex,
       final ImmutableBitSet beReferred, final int windowInputColumn) {
     if (initIndex >= windowInputColumn) {
       return beReferred.cardinality() + (initIndex - windowInputColumn);

File: core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
Patch:
@@ -807,7 +807,7 @@ private static class RefAndExprConverter extends RelOptUtil.RexInputConverter {
      * @return index in the list corresponding to the matching RexNode; -1
      * if no match
      */
-    private int findExprInLists(
+    private static int findExprInLists(
         RexNode rex,
         List<RexNode> rexList1,
         int adjust1,

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -1286,7 +1286,7 @@ private ReinterpretExpander(RexBuilder builder) {
      * @param value inner value
      * @return whether the two reinterpret casts can be removed
      */
-    private boolean canSimplify(
+    private static boolean canSimplify(
         RexCall outer,
         RexCall inner,
         RexNode value) {

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -1032,7 +1032,7 @@ private void addResult(RexNode exp) {
       }
     }
 
-    private Boolean isUdf(@SuppressWarnings("unused") @Nullable SqlOperator operator) {
+    private static Boolean isUdf(@SuppressWarnings("unused") @Nullable SqlOperator operator) {
       // return operator instanceof UserDefinedRoutine
       return false;
     }

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinJoinTransposeRule.java
Patch:
@@ -200,7 +200,7 @@ public SemiJoinJoinTransposeRule(RelBuilderFactory relBuilderFactory) {
    * @param adjustY     the amount to adjust Y by
    * @param adjustZ     the amount to adjust Z by
    */
-  private void setJoinAdjustments(
+  private static void setJoinAdjustments(
       int[] adjustments,
       int nFieldsX,
       int nFieldsY,

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinProjectTransposeRule.java
Patch:
@@ -105,7 +105,7 @@ protected SemiJoinProjectTransposeRule(Config config) {
    * @param semiJoin the semijoin
    * @return the modified semijoin condition
    */
-  private RexNode adjustCondition(Project project, Join semiJoin) {
+  private static RexNode adjustCondition(Project project, Join semiJoin) {
     // create two RexPrograms -- the bottom one representing a
     // concatenation of the project and the RHS of the semijoin and the
     // top one representing the semijoin condition

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -1342,7 +1342,7 @@ public RexNode makeIn(RexNode arg, List<? extends RexNode> ranges) {
 
   /** Returns whether and argument and bounds are have types that are
    * sufficiently compatible to be converted to a {@link Sarg}. */
-  private boolean areAssignable(RexNode arg, List<? extends RexNode> bounds) {
+  private static boolean areAssignable(RexNode arg, List<? extends RexNode> bounds) {
     for (RexNode bound : bounds) {
       if (!SqlTypeUtil.inSameFamily(arg.getType(), bound.getType())
           && !(arg.getType().isStruct() && bound.getType().isStruct())) {

File: core/src/main/java/org/apache/calcite/rex/RexSqlStandardConvertletTable.java
Patch:
@@ -163,7 +163,7 @@ public RexSqlStandardConvertletTable() {
         SqlParserPos.ZERO);
   }
 
-  private SqlNode @Nullable [] convertExpressionList(
+  private static SqlNode @Nullable [] convertExpressionList(
       RexToSqlNodeConverter converter,
       List<RexNode> nodes) {
     final SqlNode[] exprs = new SqlNode[nodes.size()];
@@ -246,7 +246,7 @@ private void registerCaseOp(final SqlOperator op) {
 
   /** Convertlet that converts a {@link SqlCall} to a {@link RexCall} of the
    * same operator. */
-  private class EquivConvertlet implements RexSqlConvertlet {
+  private static class EquivConvertlet implements RexSqlConvertlet {
     private final SqlOperator op;
 
     EquivConvertlet(SqlOperator op) {

File: core/src/main/java/org/apache/calcite/rex/RexTransformer.java
Patch:
@@ -65,12 +65,12 @@ public RexTransformer(
 
   //~ Methods ----------------------------------------------------------------
 
-  private boolean isBoolean(RexNode node) {
+  private static boolean isBoolean(RexNode node) {
     RelDataType type = node.getType();
     return SqlTypeUtil.inBooleanFamily(type);
   }
 
-  private boolean isNullable(RexNode node) {
+  private static boolean isNullable(RexNode node) {
     return node.getType().isNullable();
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -2581,7 +2581,7 @@ private List<RexNode> pullList(List<RexNode> nodes) {
       return list;
     }
 
-    private Map<RexNode, RexNode> commonFactors(List<RexNode> nodes) {
+    private static Map<RexNode, RexNode> commonFactors(List<RexNode> nodes) {
       final Map<RexNode, RexNode> map = new HashMap<>();
       int i = 0;
       for (RexNode node : nodes) {

File: core/src/main/java/org/apache/calcite/runtime/Resources.java
Patch:
@@ -428,7 +428,7 @@ public void validate(EnumSet<Validation> validations) {
       }
     }
 
-    private int countQuotesIn(String message) {
+    private static int countQuotesIn(String message) {
       int count = 0;
       for (int i = 0, n = message.length(); i < n; i++) {
         if (message.charAt(i) == '\'') {

File: core/src/main/java/org/apache/calcite/runtime/ResultSetEnumerable.java
Patch:
@@ -338,7 +338,8 @@ private void setTimeoutIfPossible(Statement statement) throws SQLException {
     }
   }
 
-  private void closeIfPossible(@Nullable Connection connection, @Nullable Statement statement) {
+  private static void closeIfPossible(@Nullable Connection connection,
+      @Nullable Statement statement) {
     if (statement != null) {
       try {
         statement.close();

File: core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
Patch:
@@ -251,7 +251,7 @@ private static boolean isWithLocalTimeZoneDef(SqlTypeName typeName) {
    * @param typeName Type name
    * @return new type name without local time zone definition
    */
-  private SqlTypeName stripLocalTimeZoneDef(SqlTypeName typeName) {
+  private static SqlTypeName stripLocalTimeZoneDef(SqlTypeName typeName) {
     switch (typeName) {
     case TIME_WITH_LOCAL_TIME_ZONE:
       return SqlTypeName.TIME;

File: core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
Patch:
@@ -288,7 +288,7 @@ public SqlCall permutedCall() {
     return EnumUtils.evaluate(o2, clazz);
   }
 
-  private <T extends Object> @Nullable T valueAs(SqlNode node, Class<T> clazz) {
+  private static <T extends Object> @Nullable T valueAs(SqlNode node, Class<T> clazz) {
     final SqlLiteral literal;
     switch (node.getKind()) {
     case ARRAY_VALUE_CONSTRUCTOR:

File: core/src/main/java/org/apache/calcite/sql/SqlFunction.java
Patch:
@@ -341,7 +341,7 @@ argTypes, argNames, getFunctionType(), SqlSyntax.FUNCTION,
     }
   }
 
-  private boolean containsRowArg(List<SqlNode> args) {
+  private static boolean containsRowArg(List<SqlNode> args) {
     for (SqlNode operand : args) {
       if (operand.getKind() == SqlKind.ROW) {
         return true;

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
Patch:
@@ -632,7 +632,7 @@ private static class PermutingMakeCall extends SimpleMakeCall {
       }
     }
 
-    private String getArgCountMismatchMsg(int... possible) {
+    private static String getArgCountMismatchMsg(int... possible) {
       StringBuilder ret = new StringBuilder();
       for (int i = 0; i < possible.length; i++) {
         if (i > 0) {
@@ -778,7 +778,7 @@ private JdbcToInternalLookupTable() {
       this.map = map.build();
     }
 
-    private MakeCall trim(SqlTrimFunction.Flag flag) {
+    private static MakeCall trim(SqlTrimFunction.Flag flag) {
       return new SimpleMakeCall(SqlStdOperatorTable.TRIM) {
         @Override public SqlCall createCall(SqlParserPos pos,
             @Nullable SqlNode... operands) {
@@ -790,7 +790,7 @@ private MakeCall trim(SqlTrimFunction.Flag flag) {
       };
     }
 
-    private MakeCall simple(SqlOperator operator) {
+    private static MakeCall simple(SqlOperator operator) {
       return new SimpleMakeCall(operator);
     }
 

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -283,7 +283,7 @@ public SqlCall createCall(
    * {@link SqlNodeList} extends {@link SqlNode}
    * and also implements {@code List<SqlNode>}. */
   @Deprecated
-  public final SqlCall createCall(
+  public static SqlCall createCall(
       @Nullable SqlLiteral functionQualifier,
       SqlParserPos pos,
       SqlNodeList operands) {

File: core/src/main/java/org/apache/calcite/sql/SqlUnnestOperator.java
Patch:
@@ -101,7 +101,7 @@ public SqlUnnestOperator(boolean withOrdinality) {
     return builder.build();
   }
 
-  private boolean allowAliasUnnestItems(SqlOperatorBinding operatorBinding) {
+  private static boolean allowAliasUnnestItems(SqlOperatorBinding operatorBinding) {
     return (operatorBinding instanceof SqlCallBinding)
         && ((SqlCallBinding) operatorBinding)
         .getValidator()

File: core/src/main/java/org/apache/calcite/sql/SqlWindow.java
Patch:
@@ -654,7 +654,7 @@ public boolean isAllowPartial() {
     }
   }
 
-  private void validateFrameBoundary(
+  private static void validateFrameBoundary(
       @Nullable SqlNode bound,
       boolean isRows,
       @Nullable SqlTypeFamily orderTypeFam,

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -306,7 +306,7 @@ private boolean matchesUnquoted(String name, String idToAppend) {
     return recasedId.regionMatches(!parserConfig.caseSensitive(), 0, name, 0, name.length());
   }
 
-  private String applyCasing(String value, Casing casing) {
+  private static String applyCasing(String value, Casing casing) {
     return SqlParserUtil.toCase(value, casing);
   }
 

File: core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java
Patch:
@@ -181,7 +181,7 @@ public String simplifySql(String sql) {
     return buf.toString();
   }
 
-  private void consumeQuery(ListIterator<Token> iter, List<Token> outList) {
+  private static void consumeQuery(ListIterator<Token> iter, List<Token> outList) {
     while (iter.hasNext()) {
       consumeSelect(iter, outList);
       if (iter.hasNext()) {
@@ -212,7 +212,7 @@ private void consumeQuery(ListIterator<Token> iter, List<Token> outList) {
     }
   }
 
-  private void consumeSelect(ListIterator<Token> iter, List<Token> outList) {
+  private static void consumeSelect(ListIterator<Token> iter, List<Token> outList) {
     boolean isQuery = false;
     int start = outList.size();
     List<Token> subQueryList = new ArrayList<>();
@@ -428,7 +428,7 @@ private Token parseQuotedIdentifier() {
       return null;
     }
 
-    private int indexOfLineEnd(String sql, int i) {
+    private static int indexOfLineEnd(String sql, int i) {
       int length = sql.length();
       while (i < length) {
         char c = sql.charAt(i);

File: core/src/main/java/org/apache/calcite/sql/dialect/ClickHouseSqlDialect.java
Patch:
@@ -103,7 +103,8 @@ public ClickHouseSqlDialect(Context context) {
     return super.getCastSpec(type);
   }
 
-  private SqlDataTypeSpec createSqlDataTypeSpecByName(String typeAlias, SqlTypeName typeName) {
+  private static SqlDataTypeSpec createSqlDataTypeSpecByName(String typeAlias,
+      SqlTypeName typeName) {
     SqlBasicTypeNameSpec spec = new SqlBasicTypeNameSpec(typeName, SqlParserPos.ZERO) {
       @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
         // unparse as an identifier to ensure that type names are cased correctly
@@ -191,7 +192,7 @@ private SqlDataTypeSpec createSqlDataTypeSpecByName(String typeAlias, SqlTypeNam
    * @param writer Writer
    * @param call Call
    */
-  private void unparseFloor(SqlWriter writer, SqlCall call) {
+  private static void unparseFloor(SqlWriter writer, SqlCall call) {
     final SqlLiteral timeUnitNode = call.operand(1);
     TimeUnitRange unit = timeUnitNode.getValueAs(TimeUnitRange.class);
 

File: core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
Patch:
@@ -198,7 +198,7 @@ private static class JethroInfoCacheImpl implements JethroInfoCache {
       }
     }
 
-    private JethroInfo makeInfo(Connection jethroConnection) {
+    private static JethroInfo makeInfo(Connection jethroConnection) {
       try (Statement jethroStatement = jethroConnection.createStatement();
            ResultSet functionsTupleSet =
                jethroStatement.executeQuery("show functions extended")) {

File: core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
Patch:
@@ -186,7 +186,7 @@ public MssqlSqlDialect(Context context) {
    * @param writer Writer
    * @param call Call
    */
-  private void unparseFloor(SqlWriter writer, SqlCall call) {
+  private static void unparseFloor(SqlWriter writer, SqlCall call) {
     SqlLiteral node = call.operand(1);
     TimeUnitRange unit = node.getValueAs(TimeUnitRange.class);
 
@@ -285,7 +285,7 @@ private void unparseSqlIntervalLiteralMssql(
     writer.literal(interval.getIntervalLiteral());
   }
 
-  private void unparseFloorWithUnit(SqlWriter writer, SqlCall call, int charLen,
+  private static void unparseFloorWithUnit(SqlWriter writer, SqlCall call, int charLen,
       String offset) {
     writer.print("CONVERT");
     SqlWriter.Frame frame = writer.startList("(", ")");

File: core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
Patch:
@@ -234,7 +234,7 @@ public MysqlSqlDialect(Context context) {
    * @param writer Writer
    * @param call Call
    */
-  private void unparseFloor(SqlWriter writer, SqlCall call) {
+  private static void unparseFloor(SqlWriter writer, SqlCall call) {
     SqlLiteral node = call.operand(1);
     TimeUnitRange unit = node.getValueAs(TimeUnitRange.class);
 
@@ -322,7 +322,7 @@ private void unparseFloor(SqlWriter writer, SqlCall call) {
     }
   }
 
-  private TimeUnit validate(TimeUnit timeUnit) {
+  private static TimeUnit validate(TimeUnit timeUnit) {
     switch (timeUnit) {
     case MICROSECOND:
     case SECOND:

File: core/src/main/java/org/apache/calcite/sql/dialect/PrestoSqlDialect.java
Patch:
@@ -66,7 +66,7 @@ public PrestoSqlDialect(Context context) {
   }
 
   /** Unparses offset/fetch using "OFFSET offset LIMIT fetch " syntax. */
-  private void unparseUsingLimit(SqlWriter writer, @Nullable SqlNode offset,
+  private static void unparseUsingLimit(SqlWriter writer, @Nullable SqlNode offset,
       @Nullable SqlNode fetch) {
     Preconditions.checkArgument(fetch != null || offset != null);
     unparseOffset(writer, offset);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
Patch:
@@ -225,7 +225,7 @@ private SqlCaseOperator() {
     return inferTypeFromValidator((SqlCallBinding) opBinding);
   }
 
-  private RelDataType inferTypeFromValidator(
+  private static RelDataType inferTypeFromValidator(
       SqlCallBinding callBinding) {
     SqlCase caseCall = (SqlCase) callBinding.getCall();
     SqlNodeList thenList = caseCall.getThenOperands();
@@ -290,7 +290,7 @@ private RelDataType inferTypeFromValidator(
     return ret;
   }
 
-  private RelDataType inferTypeFromOperands(SqlOperatorBinding opBinding) {
+  private static RelDataType inferTypeFromOperands(SqlOperatorBinding opBinding) {
     final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();
     final List<RelDataType> argTypes = opBinding.collectOperandTypes();
     assert (argTypes.size() % 2) == 1 : "odd number of arguments expected: "

File: core/src/main/java/org/apache/calcite/sql/fun/SqlDotOperator.java
Patch:
@@ -157,7 +157,7 @@ public class SqlDotOperator extends SqlSpecialOperator {
         throwOnFailure);
   }
 
-  private SqlSingleOperandTypeChecker getChecker(RelDataType operandType) {
+  private static SqlSingleOperandTypeChecker getChecker(RelDataType operandType) {
     switch (operandType.getSqlTypeName()) {
     case ROW:
       return OperandTypes.family(SqlTypeFamily.STRING);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlItemOperator.java
Patch:
@@ -100,7 +100,7 @@ class SqlItemOperator extends SqlSpecialOperator {
         throwOnFailure);
   }
 
-  private SqlSingleOperandTypeChecker getChecker(SqlCallBinding callBinding) {
+  private static SqlSingleOperandTypeChecker getChecker(SqlCallBinding callBinding) {
     final RelDataType operandType = callBinding.getOperandType(0);
     switch (operandType.getSqlTypeName()) {
     case ARRAY:

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayFunction.java
Patch:
@@ -104,7 +104,7 @@ public SqlJsonArrayFunction() {
   }
 
   @SuppressWarnings("unchecked")
-  private <E extends Enum<E>> E getEnumValue(SqlNode operand) {
+  private static <E extends Enum<E>> E getEnumValue(SqlNode operand) {
     return (E) requireNonNull(((SqlLiteral) operand).getValue(), "operand.value");
   }
 }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectFunction.java
Patch:
@@ -136,7 +136,7 @@ public SqlJsonObjectFunction() {
   }
 
   @SuppressWarnings("unchecked")
-  private <E extends Enum<E>> E getEnumValue(SqlNode operand) {
+  private static <E extends Enum<E>> E getEnumValue(SqlNode operand) {
     return (E) requireNonNull(((SqlLiteral) operand).getValue(), "operand.value");
   }
 }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonQueryFunction.java
Patch:
@@ -95,7 +95,7 @@ public SqlJsonQueryFunction() {
     return super.createCall(functionQualifier, pos, operands);
   }
 
-  private void unparseEmptyOrErrorBehavior(SqlWriter writer,
+  private static void unparseEmptyOrErrorBehavior(SqlWriter writer,
       SqlJsonQueryEmptyOrErrorBehavior emptyBehavior) {
     switch (emptyBehavior) {
     case NULL:
@@ -116,7 +116,7 @@ private void unparseEmptyOrErrorBehavior(SqlWriter writer,
   }
 
   @SuppressWarnings("unchecked")
-  private <E extends Enum<E>> E getEnumValue(SqlNode operand) {
+  private static <E extends Enum<E>> E getEnumValue(SqlNode operand) {
     return (E) requireNonNull(((SqlLiteral) operand).getValue(), "operand.value");
   }
 }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperatorTableFactory.java
Patch:
@@ -122,7 +122,7 @@ private SqlOperatorTable create(ImmutableSet<SqlLibrary> librarySet) {
   }
 
   /** Returns whether an operator is in one or more of the given libraries. */
-  private boolean operatorIsInLibrary(String operatorName, Field field,
+  private static boolean operatorIsInLibrary(String operatorName, Field field,
       Set<SqlLibrary> seekLibrarySet) {
     LibraryOperator libraryOperator =
         field.getAnnotation(LibraryOperator.class);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -76,7 +76,7 @@ public class SqlLiteralChainOperator extends SqlSpecialOperator {
   //~ Methods ----------------------------------------------------------------
 
   // all operands must be the same type
-  private boolean argTypesValid(SqlCallBinding callBinding) {
+  private static boolean argTypesValid(SqlCallBinding callBinding) {
     if (callBinding.getOperandCount() < 2) {
       return true; // nothing to compare
     }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
Patch:
@@ -77,7 +77,7 @@ public SqlMapValueConstructor() {
     return true;
   }
 
-  private Pair<@Nullable RelDataType, @Nullable RelDataType> getComponentTypes(
+  private static Pair<@Nullable RelDataType, @Nullable RelDataType> getComponentTypes(
       RelDataTypeFactory typeFactory,
       List<RelDataType> argTypes) {
     return Pair.of(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
Patch:
@@ -78,7 +78,7 @@ protected SqlMultisetQueryConstructor(String name, SqlKind kind) {
         false);
   }
 
-  private @Nullable RelDataType getComponentType(
+  private static @Nullable RelDataType getComponentType(
       RelDataTypeFactory typeFactory,
       List<RelDataType> argTypes) {
     return typeFactory.leastRestrictive(argTypes);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
Patch:
@@ -59,7 +59,7 @@ class SqlRollupOperator extends SqlInternalOperator {
     unparseCube(writer, call);
   }
 
-  private void unparseKeyword(SqlWriter writer, SqlCall call, String keyword) {
+  private static void unparseKeyword(SqlWriter writer, SqlCall call, String keyword) {
     final SqlWriter.Frame groupFrame =
         writer.startList(SqlWriter.FrameTypeEnum.GROUP_BY_LIST);
     for (SqlNode operand : call.getOperandList()) {
@@ -70,7 +70,7 @@ private void unparseKeyword(SqlWriter writer, SqlCall call, String keyword) {
     writer.keyword(keyword);
   }
 
-  private void unparseCube(SqlWriter writer, SqlCall call) {
+  private static void unparseCube(SqlWriter writer, SqlCall call) {
     writer.keyword(call.getOperator().getName());
     final SqlWriter.Frame frame =
         writer.startList(SqlWriter.FrameTypeEnum.FUN_CALL, "(", ")");

File: core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -826,7 +826,7 @@ private SqlWriterConfig.LineFolding fold(FrameTypeEnum frameType) {
     }
   }
 
-  private SqlWriterConfig.LineFolding f3(SqlWriterConfig.@Nullable LineFolding folding0,
+  private static SqlWriterConfig.LineFolding f3(SqlWriterConfig.@Nullable LineFolding folding0,
       SqlWriterConfig.@Nullable LineFolding folding1, boolean opt) {
     return folding0 != null ? folding0
         : folding1 != null ? folding1

File: core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
Patch:
@@ -216,7 +216,7 @@ public ImmutableList<? extends SqlOperandTypeChecker> getRules() {
     }
   }
 
-  private int minMin(List<SqlOperandCountRange> ranges) {
+  private static int minMin(List<SqlOperandCountRange> ranges) {
     int min = Integer.MAX_VALUE;
     for (SqlOperandCountRange range : ranges) {
       min = Math.min(min, range.getMin());

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
Patch:
@@ -218,7 +218,7 @@ public SqlTypeFactoryImpl(RelDataTypeSystem typeSystem) {
     return canonize(newType);
   }
 
-  private void assertBasic(SqlTypeName typeName) {
+  private static void assertBasic(SqlTypeName typeName) {
     assert typeName != null;
     assert typeName != SqlTypeName.MULTISET
         : "use createMultisetType() instead";
@@ -520,7 +520,7 @@ private RelDataType copyIntervalType(RelDataType type, boolean nullable) {
         nullable);
   }
 
-  private RelDataType copyObjectType(RelDataType type, boolean nullable) {
+  private static RelDataType copyObjectType(RelDataType type, boolean nullable) {
     return new ObjectSqlType(
         type.getSqlTypeName(),
         type.getSqlIdentifier(),

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -879,7 +879,7 @@ public enum Limit {
     ZERO, UNDERFLOW, OVERFLOW
   }
 
-  private @Nullable BigDecimal getNumericLimit(
+  private static @Nullable BigDecimal getNumericLimit(
       int radix,
       int exponent,
       boolean sign,

File: core/src/main/java/org/apache/calcite/sql/validate/AliasNamespace.java
Patch:
@@ -130,7 +130,7 @@ protected AliasNamespace(
     }
   }
 
-  private String getString(RelDataType rowType) {
+  private static String getString(RelDataType rowType) {
     StringBuilder buf = new StringBuilder();
     buf.append("(");
     for (RelDataTypeField field : rowType.getFieldList()) {

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
Patch:
@@ -561,7 +561,7 @@ private int worstKind(Path path) {
 
   /** Returns whether {@code rowType} contains more than one star column or
    * fields with the same name, which implies ambiguous column. */
-  private boolean hasAmbiguousField(RelDataType rowType,
+  private static boolean hasAmbiguousField(RelDataType rowType,
       RelDataTypeField field, String columnName, SqlNameMatcher nameMatcher) {
     if (field.isDynamicStar()
         && !DynamicRecordType.isDynamicStarColName(columnName)) {

File: core/src/main/java/org/apache/calcite/sql/validate/ListScope.java
Patch:
@@ -116,7 +116,7 @@ public List<SqlValidatorNamespace> getChildren() {
     return null;
   }
 
-  private @Nullable List<String> getQualifiedName(@Nullable SqlValidatorTable table) {
+  private static @Nullable List<String> getQualifiedName(@Nullable SqlValidatorTable table) {
     return table == null ? null : table.getQualifiedName();
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SetopNamespace.java
Patch:
@@ -77,7 +77,7 @@ protected SetopNamespace(
     return Util.first(monotonicity, SqlMonotonicity.NOT_MONOTONIC);
   }
 
-  private SqlMonotonicity combine(@Nullable SqlMonotonicity m0,
+  private static SqlMonotonicity combine(@Nullable SqlMonotonicity m0,
       SqlMonotonicity m1) {
     if (m0 == null) {
       return m1;

File: core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
Patch:
@@ -102,7 +102,7 @@ protected boolean listMatches(List<String> list0, List<String> list1) {
       return null;
     }
 
-    private List<String> concat(List<String> prefixNames, List<String> names) {
+    private static List<String> concat(List<String> prefixNames, List<String> names) {
       if (prefixNames.isEmpty()) {
         return names;
       } else {

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
Patch:
@@ -280,7 +280,7 @@ protected boolean needToCast(SqlValidatorScope scope, SqlNode node, RelDataType
    *
    * <p>Ignore constant reduction which should happen in RexSimplify.
    */
-  private SqlNode castTo(SqlNode node, RelDataType type) {
+  private static SqlNode castTo(SqlNode node, RelDataType type) {
     return SqlStdOperatorTable.CAST.createCall(SqlParserPos.ZERO, node,
         SqlTypeUtil.convertTypeToSpec(type).withNullable(type.isNullable()));
   }
@@ -611,7 +611,7 @@ private RelDataType getTightestCommonTypeOrThrow(
     return resultType;
   }
 
-  private List<RelDataType> partitionByCharacter(List<RelDataType> types) {
+  private static List<RelDataType> partitionByCharacter(List<RelDataType> types) {
     List<RelDataType> withCharacterTypes = new ArrayList<>();
     List<RelDataType> nonCharacterTypes = new ArrayList<>();
 

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -613,7 +613,7 @@ private void flattenProjections(RewriteRexShuttle shuttle,
     }
   }
 
-  private String extractName(@Nullable List<? extends @Nullable String> fieldNames,
+  private static String extractName(@Nullable List<? extends @Nullable String> fieldNames,
       String prefix, int i) {
     String fieldName = (fieldNames == null || fieldNames.get(i) == null)
         ? ("$" + i)
@@ -742,7 +742,7 @@ private void flattenNullLiteral(
     }
   }
 
-  private boolean isConstructor(RexNode rexNode) {
+  private static boolean isConstructor(RexNode rexNode) {
     // TODO jvs 11-Feb-2005:  share code with SqlToRelConverter
     if (!(rexNode instanceof RexCall)) {
       return false;

File: core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java
Patch:
@@ -128,7 +128,7 @@ public enum MapSqlStatisticProvider implements SqlStatisticProvider {
             .contains(columnNames(table, columns));
   }
 
-  private List<String> columnNames(RelOptTable table, List<Integer> columns) {
+  private static List<String> columnNames(RelOptTable table, List<Integer> columns) {
     return columns.stream()
         .map(columnOrdinal -> table.getRowType().getFieldNames()
             .get(columnOrdinal))

File: core/src/main/java/org/apache/calcite/statistic/QuerySqlStatisticProvider.java
Patch:
@@ -186,7 +186,7 @@ public QuerySqlStatisticProvider(Consumer<String> sqlConsumer) {
         });
   }
 
-  private RuntimeException handle(SQLException e, String sql) {
+  private static RuntimeException handle(SQLException e, String sql) {
     return new RuntimeException("Error while executing SQL for statistics: "
         + sql, e);
   }
@@ -200,7 +200,7 @@ protected String toSql(RelNode rel, SqlDialect dialect) {
     return sql;
   }
 
-  private <R> R withBuilder(BuilderAction<R> action) {
+  private static <R> R withBuilder(BuilderAction<R> action) {
     return Frameworks.withPlanner(
         (cluster, relOptSchema, rootSchema) -> {
           final RelBuilder relBuilder =

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -825,7 +825,7 @@ public GroupKey groupKey(Iterable<? extends RexNode> nodes, boolean indicator,
     return groupKey_(nodes, nodeLists);
   }
 
-  private GroupKey groupKey_(Iterable<? extends RexNode> nodes,
+  private static GroupKey groupKey_(Iterable<? extends RexNode> nodes,
       Iterable<? extends Iterable<? extends RexNode>> nodeLists) {
     final ImmutableList.Builder<ImmutableList<RexNode>> builder =
         ImmutableList.builder();
@@ -1208,7 +1208,7 @@ public RelBuilder snapshot(RexNode period) {
    * @param op operator instance
    * @return column mappings associated with this function
    */
-  private @Nullable Set<RelColumnMapping> getColumnMappings(SqlOperator op) {
+  private static @Nullable Set<RelColumnMapping> getColumnMappings(SqlOperator op) {
     SqlReturnTypeInference inference = op.getReturnTypeInference();
     if (inference instanceof TableFunctionReturnTypeInference) {
       return ((TableFunctionReturnTypeInference) inference).getColumnMappings();
@@ -2583,7 +2583,7 @@ private ImmutableList<ImmutableList<RexLiteral>> tupleList(int columnCount,
   }
 
   /** Returns whether all values for a given column are null. */
-  private boolean allNull(@Nullable Object[] values, int column, int columnCount) {
+  private static boolean allNull(@Nullable Object[] values, int column, int columnCount) {
     for (int i = column; i < values.length; i += columnCount) {
       if (values[i] != null) {
         return false;

File: core/src/main/java/org/apache/calcite/util/JsonBuilder.java
Patch:
@@ -122,7 +122,7 @@ private void appendMap(
     buf.append("}");
   }
 
-  private void newline(StringBuilder buf, int indent) {
+  private static void newline(StringBuilder buf, int indent) {
     Spaces.append(buf.append('\n'), indent * 2);
   }
 

File: core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
Patch:
@@ -364,7 +364,7 @@ private Set<Node<E>> findParentsChildren(
     return parents;
   }
 
-  private <T> void replace(List<T> list, T remove, T add) {
+  private static <T> void replace(List<T> list, T remove, T add) {
     if (list.contains(add)) {
       list.remove(remove);
     } else {

File: core/src/main/java/org/apache/calcite/util/Permutation.java
Patch:
@@ -365,7 +365,7 @@ private void increment(int x, int[] zzz) {
     }
   }
 
-  private void shuffleUp(final int[] zz, int x) {
+  private static void shuffleUp(final int[] zz, int x) {
     final int size = zz.length;
     int t = zz[size - 1];
     System.arraycopy(zz, x, zz, x + 1, size - 1 - x);

File: core/src/main/java/org/apache/calcite/util/PrecedenceClimbingParser.java
Patch:
@@ -169,7 +169,7 @@ private void replace(Token t, @Nullable Token previous, @Nullable Token next) {
   }
 
   /** Returns the right precedence of the preceding operator token. */
-  private int prevRight(@Nullable Token token) {
+  private static int prevRight(@Nullable Token token) {
     for (; token != null; token = token.previous) {
       if (token.type == Type.POSTFIX) {
         return Integer.MAX_VALUE;
@@ -182,7 +182,7 @@ private int prevRight(@Nullable Token token) {
   }
 
   /** Returns the left precedence of the following operator token. */
-  private int nextLeft(@Nullable Token token) {
+  private static int nextLeft(@Nullable Token token) {
     for (; token != null; token = token.next) {
       if (token.type == Type.PREFIX) {
         return Integer.MAX_VALUE;

File: druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java
Patch:
@@ -36,7 +36,7 @@ public ComplexMetric(String metricName, DruidType type) {
     this.type = type;
   }
 
-  private void validate(DruidType type) {
+  private static void validate(DruidType type) {
     if (!type.isComplex()) {
       throw new IllegalArgumentException("Druid type: " + type + " is not complex");
     }

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
Patch:
@@ -377,8 +377,7 @@ abstract class DruidJsonFilter implements DruidJson {
    * @return Druid Json filters, or null when cannot translate to valid Druid
    * filters
    */
-  @Nullable
-  static DruidJsonFilter toDruidFilters(RexNode rexNode, RelDataType rowType,
+  static @Nullable DruidJsonFilter toDruidFilters(RexNode rexNode, RelDataType rowType,
       DruidQuery druidQuery, RexBuilder rexBuilder) {
     rexNode = RexUtil.expandSearch(rexBuilder, null, rexNode);
     if (rexNode.isAlwaysTrue()) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -1130,7 +1130,7 @@ protected QuerySpec getQuery(RelDataType rowType, Filter filter, Project project
    * @param numericCollationIndexes flag of to determine sort comparator
    * @param queryOutputFieldNames query output fields
    */
-  private JsonLimit computeSort(@Nullable Integer fetch,
+  private static JsonLimit computeSort(@Nullable Integer fetch,
       List<Integer> collationIndexes, List<Direction> collationDirections,
       ImmutableBitSet numericCollationIndexes,
       List<String> queryOutputFieldNames) {
@@ -1616,7 +1616,7 @@ private static boolean containsLimit(QuerySpec querySpec) {
           + DRUID_QUERY_FETCH + "\":true");
     }
 
-    private ColumnMetaData.Rep getPrimitive(RelDataTypeField field) {
+    private static ColumnMetaData.Rep getPrimitive(RelDataTypeField field) {
       switch (field.getType().getSqlTypeName()) {
       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
       case TIMESTAMP:

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -603,7 +603,7 @@ protected DruidAggregateProjectRule(Config config) {
 
     /** Returns an array of unique filter references from the given list of
      * {@link org.apache.calcite.rel.core.AggregateCall}s. */
-    private Set<Integer> getUniqueFilterRefs(List<AggregateCall> calls) {
+    private static Set<Integer> getUniqueFilterRefs(List<AggregateCall> calls) {
       Set<Integer> refs = new HashSet<>();
       for (AggregateCall call : calls) {
         if (call.hasFilter()) {
@@ -628,7 +628,7 @@ private Set<Integer> getUniqueFilterRefs(List<AggregateCall> calls) {
      * <p>Should be called before pushing both the aggregate and project into
      * Druid. Assumes that at least one aggregate call has a filter attached to
      * it. */
-    private DruidQuery optimizeFilteredAggregations(RelOptRuleCall call,
+    private static DruidQuery optimizeFilteredAggregations(RelOptRuleCall call,
         DruidQuery query,
         Project project, Aggregate aggregate) {
       Filter filter = null;

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
Patch:
@@ -193,21 +193,21 @@ && isCountDistinct(call))
         && isValidParentKind(parent);
   }
 
-  private boolean isValidParentKind(SqlNode node) {
+  private static boolean isValidParentKind(SqlNode node) {
     return node.getKind() == SqlKind.SELECT
             || node.getKind() == SqlKind.FILTER
             || isSupportedPostAggOperation(node.getKind());
   }
 
-  private boolean isCountDistinct(SqlCall call) {
+  private static boolean isCountDistinct(SqlCall call) {
     return call.getKind() == SqlKind.COUNT
             && call.getFunctionQuantifier() != null
             && call.getFunctionQuantifier().getValue() == SqlSelectKeyword.DISTINCT;
   }
 
   // Post aggs support +, -, /, * so we should allow the parent of a count distinct to be any one of
   // those.
-  private boolean isSupportedPostAggOperation(SqlKind kind) {
+  private static boolean isSupportedPostAggOperation(SqlKind kind) {
     return kind == SqlKind.PLUS
             || kind == SqlKind.MINUS
             || kind == SqlKind.DIVIDE

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchAggregate.java
Patch:
@@ -180,7 +180,7 @@ private static String toElasticAggregate(AggregateCall call) {
     }
   }
 
-  private List<String> fieldNames(RelDataType relDataType) {
+  private static List<String> fieldNames(RelDataType relDataType) {
     List<String> names = new ArrayList<>();
 
     for (RelDataTypeField rdtf : relDataType.getFieldList()) {

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
Patch:
@@ -131,7 +131,7 @@ private Visitor() {
       return new LiteralExpression(literal);
     }
 
-    private boolean supportedRexCall(RexCall call) {
+    private static boolean supportedRexCall(RexCall call) {
       final SqlSyntax syntax = call.getOperator().getSyntax();
       switch (syntax) {
       case BINARY:

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
Patch:
@@ -271,7 +271,7 @@ BoolQueryBuilder should(QueryBuilder queryBuilder) {
       gen.writeEndObject();
     }
 
-    private void writeJsonArray(String field, List<QueryBuilder> clauses, JsonGenerator gen)
+    private static void writeJsonArray(String field, List<QueryBuilder> clauses, JsonGenerator gen)
         throws IOException {
       if (clauses.isEmpty()) {
         return;

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvFilterableTable.java
Patch:
@@ -72,7 +72,7 @@ public CsvFilterableTable(Source source, RelProtoDataType protoRowType) {
     };
   }
 
-  private boolean addFilter(RexNode filter, @Nullable Object[] filterValues) {
+  private static boolean addFilter(RexNode filter, @Nullable Object[] filterValues) {
     if (filter.isA(SqlKind.AND)) {
         // We cannot refine(remove) the operands of AND,
         // it will cause o.a.c.i.TableScanNode.createFilterable filters check failed.

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvProjectTableScanRule.java
Patch:
@@ -55,7 +55,7 @@ protected CsvProjectTableScanRule(Config config) {
             fields));
   }
 
-  private int[] getProjectFields(List<RexNode> exps) {
+  private static int[] getProjectFields(List<RexNode> exps) {
     final int[] fields = new int[exps.size()];
     for (int i = 0; i < exps.size(); i++) {
       final RexNode exp = exps.get(i);

File: file/src/main/java/org/apache/calcite/adapter/file/CsvProjectTableScanRule.java
Patch:
@@ -55,7 +55,7 @@ protected CsvProjectTableScanRule(Config config) {
             fields));
   }
 
-  private int[] getProjectFields(List<RexNode> exps) {
+  private static int[] getProjectFields(List<RexNode> exps) {
     final int[] fields = new int[exps.size()];
     for (int i = 0; i < exps.size(); i++) {
       final RexNode exp = exps.get(i);

File: file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
Patch:
@@ -109,7 +109,7 @@ private Element getSelectedTable(Document doc, String selector)
     }
   }
 
-  private Element getBestTable(Document doc) throws FileReaderException {
+  private static Element getBestTable(Document doc) throws FileReaderException {
     Element bestTable = null;
     int bestScore = -1;
 

File: file/src/main/java/org/apache/calcite/adapter/file/FileSchema.java
Patch:
@@ -135,7 +135,7 @@ private boolean addTable(ImmutableMap.Builder<String, Table> builder,
     return addTable(builder, source, tableName, tableDef);
   }
 
-  private boolean addTable(ImmutableMap.Builder<String, Table> builder,
+  private static boolean addTable(ImmutableMap.Builder<String, Table> builder,
       Source source, String tableName, Map<String, Object> tableDef) {
     final Source sourceSansGz = source.trim(".gz");
     final Source sourceSansJson = sourceSansGz.trimOrNull(".json");

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeAggregate.java
Patch:
@@ -129,7 +129,7 @@ public GeodeAggregate(RelOptCluster cluster,
 
   }
 
-  private List<String> fieldNames(RelDataType relDataType) {
+  private static List<String> fieldNames(RelDataType relDataType) {
     ArrayList<String> names = new ArrayList<>();
 
     for (RelDataTypeField rdtf : relDataType.getFieldList()) {

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
Patch:
@@ -383,7 +383,7 @@ private String translateBinary2(String op, RexNode left, RexNode right) {
       }
     }
 
-    private String quoteCharLiteral(RexLiteral literal) {
+    private static String quoteCharLiteral(RexLiteral literal) {
       String value = literalValue(literal);
       if (literal.getTypeName() == CHAR) {
         value = "'" + value + "'";
@@ -394,7 +394,7 @@ private String quoteCharLiteral(RexLiteral literal) {
     /**
      * Combines a field name, operator, and literal to produce a predicate string.
      */
-    private String translateOp2(String op, String name, RexLiteral right) {
+    private static String translateOp2(String op, String name, RexLiteral right) {
       String valueString = quoteCharLiteral(right);
       return name + " " + op + " " + valueString;
     }

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSort.java
Patch:
@@ -94,7 +94,7 @@ private String fieldName(int index) {
     return getRowType().getFieldList().get(index).getName();
   }
 
-  private String direction(RelFieldCollation.Direction relDirection) {
+  private static String direction(RelFieldCollation.Direction relDirection) {
     if (relDirection == RelFieldCollation.Direction.DESCENDING) {
       return DESC;
     }

File: innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
Patch:
@@ -343,7 +343,7 @@ public boolean nameMatch(String name) {
     return builder.toString();
   }
 
-  private void append(StringBuilder builder, List<String> keyColumnNames,
+  private static void append(StringBuilder builder, List<String> keyColumnNames,
       List<Object> key, String op) {
     builder.append(", ");
     for (Pair<String, Object> value : Pair.zip(keyColumnNames, key)) {

File: innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbEnumerator.java
Patch:
@@ -87,7 +87,7 @@ private Object currentRowField(RelDataTypeField relDataTypeField) {
    * @param obj         object to convert, if needed
    * @param relDataType data type
    */
-  private Object convertToEnumeratorObject(Object obj, RelDataType relDataType) {
+  private static Object convertToEnumeratorObject(Object obj, RelDataType relDataType) {
     if (obj == null) {
       return null;
     }

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
Patch:
@@ -264,7 +264,7 @@ protected void addExpressionForReuse(DeclarationStatement decl) {
     }
   }
 
-  private boolean isCostly(DeclarationStatement decl) {
+  private static boolean isCostly(DeclarationStatement decl) {
     return decl.initializer instanceof NewExpression;
   }
 
@@ -274,7 +274,7 @@ private boolean isCostly(DeclarationStatement decl) {
    * @param decl inlining candidate
    * @return normalized expression
    */
-  private Expression normalizeDeclaration(DeclarationStatement decl) {
+  private static Expression normalizeDeclaration(DeclarationStatement decl) {
     Expression expr = decl.initializer;
     Type declType = decl.parameter.getType();
     if (expr == null) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
Patch:
@@ -332,7 +332,7 @@ protected boolean isConstructorDeterministic(NewExpression newExpression) {
         && constructor.isAnnotationPresent(Deterministic.class);
   }
 
-  private <C> @Nullable Constructor<C> getConstructor(Class<C> klass) {
+  private static <C> @Nullable Constructor<C> getConstructor(Class<C> klass) {
     try {
       return klass.getConstructor();
     } catch (NoSuchMethodException e) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/OptimizeShuttle.java
Patch:
@@ -388,7 +388,7 @@ && isKnownNotNull(expression0)) {
     return super.visit(methodCallExpression, targetExpression, expressions);
   }
 
-  private boolean isConstantNull(Expression expression) {
+  private static boolean isConstantNull(Expression expression) {
     return expression instanceof ConstantExpression
         && ((ConstantExpression) expression).value == null;
   }

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
Patch:
@@ -156,7 +156,7 @@ public MongoAggregate(RelOptCluster cluster, RelTraitSet traitSet,
     }
   }
 
-  private String toMongo(SqlAggFunction aggregation, List<String> inNames,
+  private static String toMongo(SqlAggFunction aggregation, List<String> inNames,
       List<Integer> args) {
     if (aggregation == SqlStdOperatorTable.COUNT) {
       if (args.size() == 0) {

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoFilter.java
Patch:
@@ -141,7 +141,7 @@ private Map<String, Object> translateAnd(RexNode node0) {
       return map;
     }
 
-    private void addPredicate(Map<String, Object> map, String op, Object v) {
+    private static void addPredicate(Map<String, Object> map, String op, Object v) {
       if (map.containsKey(op) && stronger(op, map.get(op), v)) {
         return;
       }
@@ -154,7 +154,7 @@ private void addPredicate(Map<String, Object> map, String op, Object v) {
      * <p>For example, {@code stronger("$lt", 100, 200)} returns true, because
      * "&lt; 100" is a more powerful condition than "&lt; 200".
      */
-    private boolean stronger(String key, Object v0, Object v1) {
+    private static boolean stronger(String key, Object v0, Object v1) {
       if (key.equals("$lt") || key.equals("$lte")) {
         if (v0 instanceof Number && v1 instanceof Number) {
           return ((Number) v0).doubleValue() < ((Number) v1).doubleValue();

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -228,7 +228,7 @@ protected RexToMongoTranslator(JavaTypeFactory typeFactory,
           + " is not supported by MongoProject");
     }
 
-    private String stripQuotes(String s) {
+    private static String stripQuotes(String s) {
       return s.startsWith("'") && s.endsWith("'")
           ? s.substring(1, s.length() - 1)
           : s;

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSchemaFactory.java
Patch:
@@ -54,7 +54,7 @@ public MongoSchemaFactory() {
     return new MongoSchema(host, database, credential, options.build());
   }
 
-  private MongoCredential createCredential(Map<String, Object> map) {
+  private static MongoCredential createCredential(Map<String, Object> map) {
     final String authMechanismName = (String) map.get("authMechanism");
     final AuthenticationMechanism authenticationMechanism =
         AuthenticationMechanism.fromMechanismName(authMechanismName);

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSort.java
Patch:
@@ -92,7 +92,7 @@ public MongoSort(RelOptCluster cluster, RelTraitSet traitSet,
     }
   }
 
-  private int direction(RelFieldCollation fieldCollation) {
+  private static int direction(RelFieldCollation fieldCollation) {
     switch (fieldCollation.getDirection()) {
     case DESCENDING:
     case STRICTLY_DESCENDING:

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java
Patch:
@@ -159,7 +159,7 @@ private String getPigAggregateCall(String relAlias, AggregateCall aggCall) {
     return aggFunc.name() + "(" + fields + ") AS " + alias;
   }
 
-  private PigAggFunction toPigAggFunc(AggregateCall aggCall) {
+  private static PigAggFunction toPigAggFunc(AggregateCall aggCall) {
     return PigAggFunction.valueOf(aggCall.getAggregation().getKind(),
         aggCall.getArgList().size() < 1);
   }

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigFilter.java
Patch:
@@ -127,7 +127,7 @@ private String getSingleFilterCondition(Implementor implementor, String op, RexC
     return '(' + fieldName + ' ' + op + ' ' + literal + ')';
   }
 
-  private boolean containsOnlyConjunctions(RexNode condition) {
+  private static boolean containsOnlyConjunctions(RexNode condition) {
     return RelOptUtil.disjunctions(condition).size() == 1;
   }
 
@@ -136,7 +136,7 @@ private boolean containsOnlyConjunctions(RexNode condition) {
    *
    * <p>TODO: do proper literal to string conversion + escaping
    */
-  private String getLiteralAsString(RexLiteral literal) {
+  private static String getLiteralAsString(RexLiteral literal) {
     return '\'' + RexLiteral.stringValue(literal) + '\'';
   }
 }

File: piglet/src/main/java/org/apache/calcite/piglet/PigConverter.java
Patch:
@@ -274,7 +274,7 @@ private List<RelNode> optimizePlans(List<RelNode> originalRels,
     return optimizedPlans;
   }
 
-  private void resetPlannerRules(RelOptPlanner planner,
+  private static void resetPlannerRules(RelOptPlanner planner,
       List<RelOptRule> rulesToSet) {
     planner.clear();
     for (RelOptRule rule : rulesToSet) {

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
Patch:
@@ -295,7 +295,7 @@ private ImmutableList<RexNode> buildBinaryOperands() {
    * @param rexNode The string literal
    * @return New string literal with Pig regular expressions replaced by SQL regular expressions
    */
-  private RexNode replacePatternIfPossible(RexNode rexNode) {
+  private static RexNode replacePatternIfPossible(RexNode rexNode) {
     // Until
     //   [CALCITE-3194] Convert Pig string patterns into SQL string patterns
     // is fixed, return the pattern unchanged.
@@ -366,7 +366,7 @@ private RexNode replacePatternIfPossible(RexNode rexNode) {
     builder.registerPigUDF(className, op.getFuncSpec());
   }
 
-  private int optSize(List<Operator> list) {
+  private static int optSize(List<Operator> list) {
     return list != null ? list.size() : 0;
   }
 

File: piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
Patch:
@@ -353,7 +353,7 @@ private static RelDataType createRecordType(RelBuilder relBuilder, List<Integer>
     return TYPE_FACTORY.createStructType(destTypes, destNames);
   }
 
-  private int getGroupRefIndex(RexNode rex) {
+  private static int getGroupRefIndex(RexNode rex) {
     if (rex instanceof RexFieldAccess) {
       final RexFieldAccess fieldAccess = (RexFieldAccess) rex;
       if (fieldAccess.getReferenceExpr() instanceof RexInputRef) {
@@ -372,7 +372,7 @@ private int getGroupRefIndex(RexNode rex) {
    *
    * @param pigAggCall Pig aggregate UDF call
    */
-  private List<Integer> getAggColumns(RexCall pigAggCall) {
+  private static List<Integer> getAggColumns(RexCall pigAggCall) {
     if (isMultisetProjection(pigAggCall)) {
       return getColsFromMultisetProjection(pigAggCall);
     }
@@ -393,7 +393,7 @@ private List<Integer> getAggColumns(RexCall pigAggCall) {
     return new ArrayList<>();
   }
 
-  private List<Integer> getColsFromMultisetProjection(RexCall multisetProjection) {
+  private static List<Integer> getColsFromMultisetProjection(RexCall multisetProjection) {
     final List<Integer> columns = new ArrayList<>();
     assert multisetProjection.getOperands().size() >= 1;
     for (int i = 1; i < multisetProjection.getOperands().size(); i++) {

File: plus/src/main/java/org/apache/calcite/chinook/PreferredAlbumsTableFactory.java
Patch:
@@ -62,7 +62,7 @@ public class PreferredAlbumsTableFactory implements TableFactory<AbstractQueryab
     };
   }
 
-  private Queryable<Integer> fetchPreferredAlbums() {
+  private static Queryable<Integer> fetchPreferredAlbums() {
     if (EnvironmentFairy.getUser() == EnvironmentFairy.User.SPECIFIC_USER) {
       return Linq4j.asEnumerable(SPECIFIC_USER_PREFERRED_ALBUMS).asQueryable();
     } else {

File: plus/src/main/java/org/apache/calcite/chinook/PreferredGenresTableFactory.java
Patch:
@@ -62,7 +62,7 @@ public class PreferredGenresTableFactory implements TableFactory<AbstractQueryab
     };
   }
 
-  private Queryable<Integer> fetchPreferredGenres() {
+  private static Queryable<Integer> fetchPreferredGenres() {
     if (EnvironmentFairy.getUser() == EnvironmentFairy.User.SPECIFIC_USER) {
       return Linq4j.asEnumerable(SPECIFIC_USER_PREFERRED_GENRES).asQueryable();
     } else {

File: ubenchmark/src/jmh/java/org/apache/calcite/benchmarks/FlightRecorderProfiler.java
Patch:
@@ -58,7 +58,7 @@ public class FlightRecorderProfiler implements ExternalProfiler {
             + params.getBenchmark() + "_" + sb + ".jfr");
   }
 
-  private long getDurationSeconds(IterationParams warmup) {
+  private static long getDurationSeconds(IterationParams warmup) {
     return warmup.getTime().convertTo(TimeUnit.SECONDS) * warmup.getCount();
   }
 

File: core/src/main/java/org/apache/calcite/sql/dialect/OracleSqlDialect.java
Patch:
@@ -142,7 +142,8 @@ public OracleSqlDialect(Context context) {
   @Override public void unparseCall(SqlWriter writer, SqlCall call,
       int leftPrec, int rightPrec) {
     if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {
-      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.SUBSTR, writer, call, false);
+      SqlUtil.unparseFunctionSyntax(SqlLibraryOperators.ORACLE_SUBSTR, writer,
+          call, false);
     } else {
       switch (call.getKind()) {
       case FLOOR:

File: core/src/main/java/org/apache/calcite/sql/fun/OracleSqlOperatorTable.java
Patch:
@@ -50,7 +50,7 @@ public class OracleSqlOperatorTable extends ReflectiveSqlOperatorTable {
   public static final SqlFunction RTRIM = SqlLibraryOperators.RTRIM;
 
   @Deprecated // to be removed before 2.0
-  public static final SqlFunction SUBSTR = SqlLibraryOperators.SUBSTR;
+  public static final SqlFunction SUBSTR = SqlLibraryOperators.ORACLE_SUBSTR;
 
   @Deprecated // to be removed before 2.0
   public static final SqlFunction GREATEST = SqlLibraryOperators.GREATEST;

File: core/src/main/java/org/apache/calcite/plan/RelRule.java
Patch:
@@ -144,10 +144,10 @@ default <T extends Object> T as(Class<T> class_) {
 
     /** Description of the rule instance. */
     @ImmutableBeans.Property
-    String description();
+    @Nullable String description();
 
     /** Sets {@link #description()}. */
-    Config withDescription(String description);
+    Config withDescription(@Nullable String description);
 
     /** Creates the operands for the rule instance. */
     @ImmutableBeans.Property

File: core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java
Patch:
@@ -288,6 +288,6 @@ public interface WriteOption {
      * Predicate for nodes that need to be highlighted.
      */
     @ImmutableBeans.Property
-    Predicate<RelNode> nodePredicate();
+    @Nullable Predicate<RelNode> nodePredicate();
   }
 }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -881,7 +881,7 @@ public interface Config extends RelRule.Config {
 
     /** Returns the validated set of functions to reduce, or the default set
      * if not specified. */
-    @NonNull default Set<SqlKind> actualFunctionsToReduce() {
+    default Set<SqlKind> actualFunctionsToReduce() {
       final Set<SqlKind> set =
           Util.first(functionsToReduce(), DEFAULT_FUNCTIONS_TO_REDUCE);
       set.forEach(AggregateReduceFunctionsRule::validateFunction);

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidator.java
Patch:
@@ -892,7 +892,7 @@ public interface Config {
 
     /** Returns the type coercion rules for explicit type coercion. */
     @ImmutableBeans.Property
-    SqlTypeCoercionRule typeCoercionRules();
+    @Nullable SqlTypeCoercionRule typeCoercionRules();
 
     /**
      * Sets the {@link SqlTypeCoercionRule} instance which defines the type conversion matrix
@@ -904,7 +904,7 @@ public interface Config {
      * @param rules The {@link SqlTypeCoercionRule} instance,
      *              see its documentation for how to customize the rules
      */
-    Config withTypeCoercionRules(SqlTypeCoercionRule rules);
+    Config withTypeCoercionRules(@Nullable SqlTypeCoercionRule rules);
 
     /** Returns the dialect of SQL (SQL:2003, etc.) this validator recognizes.
      * Default is {@link SqlConformanceEnum#DEFAULT}. */

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -6136,15 +6136,15 @@ public interface Config {
 
     /** Returns the factory to create {@link RelBuilder}, never null. Default is
      * {@link RelFactories#LOGICAL_BUILDER}. */
-    @ImmutableBeans.Property(required = true)
+    @ImmutableBeans.Property
     RelBuilderFactory getRelBuilderFactory();
 
     /** Sets {@link #getRelBuilderFactory()}. */
     Config withRelBuilderFactory(RelBuilderFactory factory);
 
     /** Returns a function that takes a {@link RelBuilder.Config} and returns
      * another. Default is the identity function. */
-    @ImmutableBeans.Property(required = true)
+    @ImmutableBeans.Property
     UnaryOperator<RelBuilder.Config> getRelBuilderConfigTransform();
 
     /** Sets {@link #getRelBuilderConfigTransform()}.
@@ -6163,7 +6163,7 @@ default Config addRelBuilderConfigTransform(
     /** Returns the hint strategies used to decide how the hints are propagated to
      * the relational expressions. Default is
      * {@link HintStrategyTable#EMPTY}. */
-    @ImmutableBeans.Property(required = true)
+    @ImmutableBeans.Property
     HintStrategyTable getHintStrategyTable();
 
     /** Sets {@link #getHintStrategyTable()}. */

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -839,8 +839,9 @@ ExInst<CalciteException> invalidTypesForComparison(String clazzName0, String op,
   @BaseMessage("More than one value in list: {0}")
   ExInst<CalciteException> moreThanOneValueInList(String list);
 
-  @BaseMessage("Failed to access field ''{0}'' of object of type {1}")
-  ExInstWithCause<CalciteException> failedToAccessField(String fieldName, String typeName);
+  @BaseMessage("Failed to access field ''{0}'', index {1,number,#} of object of type {2}")
+  ExInstWithCause<CalciteException> failedToAccessField(
+      String fieldName, int fieldIndex, String typeName);
 
   @BaseMessage("Illegal jsonpath spec ''{0}'', format of the spec should be: ''<lax|strict> $'{'expr'}'''")
   ExInst<CalciteException> illegalJsonPathSpec(String pathSpec);

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -463,8 +463,8 @@ public static ByteString concat(ByteString s0, ByteString s1) {
     return s0.concat(s1);
   }
 
-  /** SQL {@code concat(arg0, arg1, arg2, ...)} function. */
-  public static String concat(String... args) {
+  /** SQL {@code CONCAT(arg0, arg1, arg2, ...)} function. */
+  public static String concatMulti(String... args) {
     return String.join("", args);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -386,6 +386,9 @@ public enum SqlKind {
   /** {@code GREATEST} function (Oracle). */
   GREATEST,
 
+  /** The two-argument {@code CONCAT} function (Oracle). */
+  CONCAT2,
+
   /** The "IF" function (BigQuery, Hive, Spark). */
   IF,
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -236,6 +236,8 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
 
   /**
    * String concatenation operator, '<code>||</code>'.
+   *
+   * @see SqlLibraryOperators#CONCAT_FUNCTION
    */
   public static final SqlBinaryOperator CONCAT =
       new SqlBinaryOperator(

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -382,7 +382,7 @@ public enum BuiltInMethod {
       int.class),
   CHAR_LENGTH(SqlFunctions.class, "charLength", String.class),
   STRING_CONCAT(SqlFunctions.class, "concat", String.class, String.class),
-  MULTI_STRING_CONCAT(SqlFunctions.class, "concat", String[].class),
+  MULTI_STRING_CONCAT(SqlFunctions.class, "concatMulti", String[].class),
   FLOOR_DIV(DateTimeUtils.class, "floorDiv", long.class, long.class),
   FLOOR_MOD(DateTimeUtils.class, "floorMod", long.class, long.class),
   ADD_MONTHS(SqlFunctions.class, "addMonths", long.class, int.class),

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
Patch:
@@ -529,6 +529,7 @@ protected boolean booleanEquality(SqlCallBinding binding,
               updateInferredType(node2, desired);
             }
           }
+          coerced = coerced || listCoerced;
         } else {
           // Another sub-query.
           SqlValidatorScope scope1 = node2 instanceof SqlSelect

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -681,7 +681,7 @@ private void checkSimplify(UnaryOperator<RelBuilder.Config> transform,
                         builder.equals(builder.field("DEPTNO"),
                             builder.literal(10)),
                         builder.and(builder.isNull(builder.field(6)),
-                            builder.not(builder.isNotNull(builder.field(7))))),
+                            builder.not(builder.isNotNull(builder.field(5))))),
                     builder.equals(builder.field("DEPTNO"),
                         builder.literal(20)),
                     builder.equals(builder.field("DEPTNO"),
@@ -695,7 +695,7 @@ private void checkSimplify(UnaryOperator<RelBuilder.Config> transform,
     final String expected = ""
         + "LogicalProject(DEPTNO=[$7], COMM=[CAST($6):SMALLINT NOT NULL], "
         + "$f2=[OR(SEARCH($7, Sarg[20, 30]), AND(null:NULL, =($7, 10), "
-        + "IS NULL($6), IS NULL($7)))], n2=[IS NULL($2)], "
+        + "IS NULL($6), IS NULL($5)))], n2=[IS NULL($2)], "
         + "nn2=[IS NOT NULL($3)], $f5=[20], COMM0=[$6], C=[$6])\n"
         + "  LogicalTableScan(table=[[scott, EMP]])\n";
     assertThat(root, hasTree(expected));

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -8490,7 +8490,8 @@ public void _testGroupExpressionEquivalenceParams() {
     sql("select ^name[0]^ from dept")
         .fails("Cannot apply 'ITEM' to arguments of type 'ITEM\\(<VARCHAR\\(10\\)>, "
             +  "<INTEGER>\\)'\\. Supported form\\(s\\): <ARRAY>\\[<INTEGER>\\]\n"
-            + "<MAP>\\[<VALUE>\\].*");
+            + "<MAP>\\[<ANY>\\]\n"
+            + "<ROW>\\[<CHARACTER>\\|<INTEGER>\\].*");
   }
 
   /** Test case for

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
Patch:
@@ -47,6 +47,7 @@
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.SqlFunction;
 import org.apache.calcite.sql.SqlKind;
+import org.apache.calcite.sql.fun.SqlMinMaxAggFunction;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.tools.RelBuilder;
@@ -848,9 +849,8 @@ protected SqlFunction getFloorSqlFunction(TimeUnitRange flag) {
    */
   protected SqlAggFunction getRollup(SqlAggFunction aggregation) {
     if (aggregation == SqlStdOperatorTable.SUM
-        || aggregation == SqlStdOperatorTable.MIN
-        || aggregation == SqlStdOperatorTable.MAX
         || aggregation == SqlStdOperatorTable.SUM0
+        || aggregation instanceof SqlMinMaxAggFunction
         || aggregation == SqlStdOperatorTable.ANY_VALUE) {
       return aggregation;
     } else if (aggregation == SqlStdOperatorTable.COUNT) {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMinMaxAggFunction.java
Patch:
@@ -39,13 +39,13 @@
  * <p>There are 3 forms:
  *
  * <dl>
- * <dt>sum(<em>primitive type</em>)
+ * <dt>min/max(<em>primitive type</em>)
  * <dd>values are compared using '&lt;'
  *
- * <dt>sum({@link java.lang.Comparable})
+ * <dt>min/max({@link java.lang.Comparable})
  * <dd>values are compared using {@link java.lang.Comparable#compareTo}
  *
- * <dt>sum({@link java.util.Comparator}, {@link java.lang.Object})
+ * <dt>min/max({@link java.util.Comparator}, {@link java.lang.Object})
  * <dd>the {@link java.util.Comparator#compare} method of the comparator is used
  * to compare pairs of objects. The comparator is a startup argument, and must
  * therefore be constant for the duration of the aggregation.

File: core/src/main/java/org/apache/calcite/util/TimeString.java
Patch:
@@ -202,7 +202,7 @@ public Calendar toCalendar() {
   }
 
   /** Converts this TimestampString to a string, truncated or padded with
-   * zeroes to a given precision. */
+   * zeros to a given precision. */
   public String toString(int precision) {
     Preconditions.checkArgument(precision >= 0);
     final int p = precision();

File: core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java
Patch:
@@ -173,7 +173,7 @@ public static TimeWithTimeZoneString fromMillisOfDay(int i) {
   }
 
   /** Converts this TimeWithTimeZoneString to a string, truncated or padded with
-   * zeroes to a given precision. */
+   * zeros to a given precision. */
   public String toString(int precision) {
     Preconditions.checkArgument(precision >= 0);
     return localTime.toString(precision) + " " + timeZone.getID();

File: core/src/main/java/org/apache/calcite/util/TimestampString.java
Patch:
@@ -181,7 +181,7 @@ public Calendar toCalendar() {
   }
 
   /** Converts this TimestampString to a string, truncated or padded with
-   * zeroes to a given precision. */
+   * zeros to a given precision. */
   public String toString(int precision) {
     Preconditions.checkArgument(precision >= 0);
     final int p = precision();

File: core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java
Patch:
@@ -171,7 +171,7 @@ public static TimestampWithTimeZoneString fromMillisSinceEpoch(long millis) {
   }
 
   /** Converts this TimestampWithTimeZoneString to a string, truncated or padded with
-   * zeroes to a given precision. */
+   * zeros to a given precision. */
   public String toString(int precision) {
     Preconditions.checkArgument(precision >= 0);
     return localDateTime.toString(precision) + " " + timeZone.getID();

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -562,7 +562,7 @@ public static String toScientificNotation(BigDecimal bd) {
             Math.min(truncateAt, len));
     ret.append(unscaled.charAt(0));
     if (scale == 0) {
-      // trim trailing zeroes since they aren't significant
+      // trim trailing zeros since they aren't significant
       int i = unscaled.length();
       while (i > 1) {
         if (unscaled.charAt(i - 1) != '0') {

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -4273,7 +4273,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("x'1234567890abcdef'=X'fFeEdDcCbBaA'")
         .ok("(X'1234567890ABCDEF' = X'FFEEDDCCBBAA')");
 
-    // Check the inital zeroes don't get trimmed somehow
+    // Check the inital zeros don't get trimmed somehow
     expr("x'001'=X'000102'")
         .ok("(X'001' = X'000102')");
   }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -3747,7 +3747,7 @@ void subTestIntervalSecondNegative() {
     // only seconds are allowed to have a fractional part
     expr("INTERVAL '1.0' SECOND")
         .columnType("INTERVAL SECOND NOT NULL");
-    // leading zeroes do not cause precision to be exceeded
+    // leading zeros do not cause precision to be exceeded
     expr("INTERVAL '0999' MONTH(3)")
         .columnType("INTERVAL MONTH(3) NOT NULL");
   }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -5635,7 +5635,7 @@ private ImmutableList<ImmutableBitSet> cube(ImmutableBitSet... sets) {
         .withTypeCoercion(false)
         .fails("(?s)Cannot apply 'SUM' to arguments of type 'SUM\\(<VARCHAR\\(20\\)>\\)'\\. .*");
     sql("select sum(ename), deptno from emp group by deptno")
-        .type("RecordType(DECIMAL(19, 19) NOT NULL EXPR$0, INTEGER NOT NULL DEPTNO) NOT NULL");
+        .type("RecordType(DECIMAL(19, 9) NOT NULL EXPR$0, INTEGER NOT NULL DEPTNO) NOT NULL");
   }
 
   @Test void testSumTooManyArgs() {

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -123,7 +123,6 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.NavigableSet;
 import java.util.Set;
 import java.util.TreeSet;
@@ -201,7 +200,7 @@ public static List<RelOptTable> findAllTables(RelNode rel) {
     final Multimap<Class<? extends RelNode>, RelNode> nodes =
         rel.getCluster().getMetadataQuery().getNodeTypes(rel);
     final List<RelOptTable> usedTables = new ArrayList<>();
-    for (Entry<Class<? extends RelNode>, Collection<RelNode>> e : nodes.asMap().entrySet()) {
+    for (Map.Entry<Class<? extends RelNode>, Collection<RelNode>> e : nodes.asMap().entrySet()) {
       if (TableScan.class.isAssignableFrom(e.getKey())) {
         for (RelNode node : e.getValue()) {
           usedTables.add(node.getTable());
@@ -232,6 +231,7 @@ public static Set<CorrelationId> getVariablesSet(RelNode rel) {
   }
 
   @Deprecated // to be removed before 2.0
+  @SuppressWarnings("MixedMutabilityReturnType")
   public static List<CorrelationId> getVariablesSetAndUsed(RelNode rel0,
       RelNode rel1) {
     Set<CorrelationId> set = getVariablesSet(rel0);

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -68,7 +68,6 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Set;
 import java.util.TimeZone;
@@ -2806,7 +2805,7 @@ private static Enumerable<FlatLists.ComparableList<Comparable>> p2(
       case MAP:
         @SuppressWarnings("unchecked") Map<Comparable, Comparable> map =
             (Map<Comparable, Comparable>) inputObject;
-        Enumerator<Entry<Comparable, Comparable>> enumerator =
+        Enumerator<Map.Entry<Comparable, Comparable>> enumerator =
             Linq4j.enumerator(map.entrySet());
 
         Enumerator<List<Comparable>> transformed = Linq4j.transform(enumerator,

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -178,7 +178,6 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -3884,7 +3883,7 @@ private RelNode convertUpdate(SqlUpdate call) {
     RelNode sourceRel = convertSelect(call.getSourceSelect(), false);
 
     bb.setRoot(sourceRel, false);
-    Builder<RexNode> rexNodeSourceExpressionListBuilder = ImmutableList.builder();
+    ImmutableList.Builder<RexNode> rexNodeSourceExpressionListBuilder = ImmutableList.builder();
     for (SqlNode n : call.getSourceExpressionList()) {
       RexNode rn = bb.convertExpression(n);
       rexNodeSourceExpressionListBuilder.add(rn);

File: core/src/main/java/org/apache/calcite/jdbc/MetadataSchema.java
Patch:
@@ -26,8 +26,8 @@
 import java.sql.SQLException;
 import java.util.Map;
 
-import static org.apache.calcite.jdbc.CalciteMetaImpl.MetaColumn;
-import static org.apache.calcite.jdbc.CalciteMetaImpl.MetaTable;
+import static org.apache.calcite.avatica.MetaImpl.MetaColumn;
+import static org.apache.calcite.avatica.MetaImpl.MetaTable;
 
 /** Schema that contains metadata tables such as "TABLES" and "COLUMNS". */
 class MetadataSchema extends AbstractSchema {

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
Patch:
@@ -44,7 +44,7 @@
  *
  * @param <C> Configuration type
  */
-public abstract class MaterializedViewJoinRule<C extends MaterializedViewJoinRule.Config>
+public abstract class MaterializedViewJoinRule<C extends MaterializedViewRule.Config>
     extends MaterializedViewRule<C> {
 
   /** Creates a MaterializedViewJoinRule. */

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewOnlyJoinRule.java
Patch:
@@ -24,7 +24,7 @@
 
 /** Rule that matches Join. */
 public class MaterializedViewOnlyJoinRule
-    extends MaterializedViewJoinRule<MaterializedViewJoinRule.Config> {
+    extends MaterializedViewJoinRule<MaterializedViewRule.Config> {
 
   MaterializedViewOnlyJoinRule(Config config) {
     super(config);

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewProjectFilterRule.java
Patch:
@@ -51,7 +51,7 @@ public MaterializedViewProjectFilterRule(RelBuilderFactory relBuilderFactory,
   }
 
   /** Rule configuration. */
-  public interface Config extends MaterializedViewJoinRule.Config {
+  public interface Config extends MaterializedViewRule.Config {
     Config DEFAULT = EMPTY.as(Config.class)
         .withRelBuilderFactory(RelFactories.LOGICAL_BUILDER)
         .withOperandSupplier(b0 ->

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewProjectJoinRule.java
Patch:
@@ -51,7 +51,7 @@ public MaterializedViewProjectJoinRule(RelBuilderFactory relBuilderFactory,
   }
 
   /** Rule configuration. */
-  public interface Config extends MaterializedViewJoinRule.Config {
+  public interface Config extends MaterializedViewRule.Config {
     Config DEFAULT = EMPTY.as(Config.class)
         .withRelBuilderFactory(RelFactories.LOGICAL_BUILDER)
         .withOperandSupplier(b0 ->

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java
Patch:
@@ -69,6 +69,7 @@ private CassandraRules() {}
       CassandraToEnumerableConverterRule.DEFAULT_CONFIG
           .toRule(CassandraToEnumerableConverterRule.class);
 
+  @SuppressWarnings("MutablePublicArray")
   public static final RelOptRule[] RULES = {
       FILTER,
       PROJECT,

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -62,6 +62,7 @@ private MongoRules() {}
 
   protected static final Logger LOGGER = CalciteTrace.getPlannerTracer();
 
+  @SuppressWarnings("MutablePublicArray")
   public static final RelOptRule[] RULES = {
       MongoSortRule.INSTANCE,
       MongoFilterRule.INSTANCE,

File: core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
Patch:
@@ -53,14 +53,14 @@
 
 import com.google.common.collect.ImmutableList;
 
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
@@ -881,7 +881,7 @@ private void clearCache(HepRelVertex vertex) {
       return;
     }
     Queue<DefaultEdge> queue =
-        new LinkedList<>(graph.getInwardEdges(vertex));
+        new ArrayDeque<>(graph.getInwardEdges(vertex));
     while (!queue.isEmpty()) {
       DefaultEdge edge = queue.remove();
       HepRelVertex source = (HepRelVertex) edge.source;

File: core/src/main/java/org/apache/calcite/plan/volcano/IterativeRuleQueue.java
Patch:
@@ -26,8 +26,8 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.util.ArrayDeque;
 import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.Queue;
 import java.util.Set;
 
@@ -172,14 +172,14 @@ private static class MatchList {
     /**
      * Rule match queue for SubstitutionRule.
      */
-    private final Queue<VolcanoRuleMatch> preQueue = new LinkedList<>();
+    private final Queue<VolcanoRuleMatch> preQueue = new ArrayDeque<>();
 
     /**
      * Current list of VolcanoRuleMatches for this phase. New rule-matches
      * are appended to the end of this queue.
      * The rules are not sorted in any way.
      */
-    private final Queue<VolcanoRuleMatch> queue = new LinkedList<>();
+    private final Queue<VolcanoRuleMatch> queue = new ArrayDeque<>();
 
     /**
      * A set of rule-match names contained in {@link #queue}. Allows fast

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
Patch:
@@ -44,7 +44,6 @@
 import com.google.common.collect.Maps;
 
 import java.util.HashSet;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -119,7 +119,6 @@
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -1192,7 +1191,7 @@ public RelBuilder functionScan(SqlOperator operator,
     }
 
     // Gets inputs.
-    final List<RelNode> inputs = new LinkedList<>();
+    final List<RelNode> inputs = new ArrayList<>();
     for (int i = 0; i < inputCount; i++) {
       inputs.add(0, build());
     }
@@ -1977,7 +1976,7 @@ private static boolean isGroupId(AggCall c) {
   }
 
   private RelBuilder setOp(boolean all, SqlKind kind, int n) {
-    List<RelNode> inputs = new LinkedList<>();
+    List<RelNode> inputs = new ArrayList<>();
     for (int i = 0; i < n; i++) {
       inputs.add(0, build());
     }

File: kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaMessageEnumerator.java
Patch:
@@ -24,7 +24,8 @@
 import org.apache.kafka.clients.consumer.ConsumerRecords;
 
 import java.time.Duration;
-import java.util.LinkedList;
+import java.util.ArrayDeque;
+import java.util.Deque;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
@@ -42,7 +43,7 @@ public class KafkaMessageEnumerator<K, V> implements Enumerator<Object[]> {
   private final AtomicBoolean cancelFlag;
 
   //runtime
-  private final LinkedList<ConsumerRecord<K, V>> bufferedRecords = new LinkedList<>();
+  private final Deque<ConsumerRecord<K, V>> bufferedRecords = new ArrayDeque<>();
   private ConsumerRecord<K, V> curRecord;
 
   KafkaMessageEnumerator(final Consumer consumer,

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
Patch:
@@ -76,7 +76,6 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 
@@ -510,7 +509,7 @@ private static GroupType getGroupType(LOCogroup pigGroup) {
     boolean[] innerFlags = new boolean[numInputs];
     for (int i = 0; i < numInputs; i++) {
       // Adding empty join keys
-      joinPlans.put(i, new LinkedList<>());
+      joinPlans.put(i, Collections.emptyList());
       innerFlags[i] = true;
     }
     joinInternal(joinPlans, innerFlags);

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkPushDownRule.java
Patch:
@@ -45,7 +45,6 @@
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 
@@ -244,7 +243,7 @@ protected RelNode appendSearchString(
     }
 
     // field renaming: to -> from
-    List<Pair<String, String>> renames = new LinkedList<>();
+    List<Pair<String, String>> renames = new ArrayList<>();
 
     // handle top projection (ie reordering and renaming)
     List<RelDataTypeField> newFields = bottomFields;

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
Patch:
@@ -19,7 +19,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.LinkedList;
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -50,7 +50,7 @@ public static StringBuilder encodeList(
   }
 
   public static List<String> decodeList(CharSequence encoded, char delim) {
-    List<String> list = new LinkedList<>();
+    List<String> list = new ArrayList<>();
     int len = encoded.length();
     int start = 0;
     int end = 0;
@@ -132,7 +132,7 @@ public static boolean parseBoolean(
 
 
   public static void main(String[] args) {
-    List<String> list = new LinkedList<>();
+    List<String> list = new ArrayList<>();
     list.add("test");
     list.add("test,with,comma");
     list.add("");

File: core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
Patch:
@@ -442,7 +442,7 @@ public Iterable<Class<? extends RelNode>> subClasses(
   }
 
   /** Listener for counting the attempts of each rule. Only enabled under DEBUG level.*/
-  private class RuleAttemptsListener implements RelOptListener {
+  private static class RuleAttemptsListener implements RelOptListener {
     private long beforeTimestamp;
     private Map<String, Pair<Long, Long>> ruleAttempts;
 

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableRel.java
Patch:
@@ -120,7 +120,7 @@ public final String deep() {
    * Implementation of MutableVisitor that dumps the details
    * of a MutableRel tree.
    */
-  private class MutableRelDumper extends MutableRelVisitor {
+  private static class MutableRelDumper extends MutableRelVisitor {
     private final StringBuilder buf = new StringBuilder();
     private int level;
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
Patch:
@@ -556,7 +556,7 @@ private List<RexNode> combinePostJoinFilters(
   /**
    * Visitor that keeps a reference count of the inputs used by an expression.
    */
-  private class InputReferenceCounter extends RexVisitorImpl<Void> {
+  private static class InputReferenceCounter extends RexVisitorImpl<Void> {
     private final int[] refCounts;
 
     InputReferenceCounter(int[] refCounts) {

File: core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
Patch:
@@ -661,7 +661,7 @@ public RelNode createNewProject(RelNode projChild, int[] adjustments) {
    * Visitor which builds a bitmap of the inputs used by an expressions, as
    * well as locating expressions corresponding to special operators.
    */
-  private class InputSpecialOpFinder extends RexVisitorImpl<Void> {
+  private static class InputSpecialOpFinder extends RexVisitorImpl<Void> {
     private final BitSet rexRefs;
     private final ImmutableBitSet leftFields;
     private final ImmutableBitSet rightFields;
@@ -748,7 +748,7 @@ private boolean preserve(RexNode call) {
    * Walks an expression tree, replacing input refs with new values to reflect
    * projection and converting special expressions to field references.
    */
-  private class RefAndExprConverter extends RelOptUtil.RexInputConverter {
+  private static class RefAndExprConverter extends RelOptUtil.RexInputConverter {
     private final List<RexNode> preserveLeft;
     private final int firstLeftRef;
     private final List<RexNode> preserveRight;
@@ -854,7 +854,7 @@ public interface ExprCondition extends Predicate<RexNode> {
    * An expression condition that evaluates to true if the expression is
    * a call to one of a set of operators.
    */
-  class OperatorExprCondition implements ExprCondition {
+  static class OperatorExprCondition implements ExprCondition {
     private final Set<SqlOperator> operatorSet;
 
     /**

File: core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
Patch:
@@ -1049,7 +1049,7 @@ private class RegisterOutputShuttle extends RegisterShuttle {
    * Shuttle that rewires {@link RexLocalRef} using a list of updated
    * references.
    */
-  private class UpdateRefShuttle extends RexShuttle {
+  private static class UpdateRefShuttle extends RexShuttle {
     private List<RexLocalRef> newRefs;
 
     private UpdateRefShuttle(List<RexLocalRef> newRefs) {

File: core/src/main/java/org/apache/calcite/sql/SqlSpecialOperator.java
Patch:
@@ -109,7 +109,7 @@ PrecedenceClimbingParser parser(int start,
   /** Result of applying
    * {@link org.apache.calcite.util.PrecedenceClimbingParser.Special#apply}.
    * Tells the caller which range of tokens to replace, and with what. */
-  public class ReduceResult {
+  public static class ReduceResult {
     public final int startOrdinal;
     public final int endOrdinal;
     public final SqlNode node;

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -607,7 +607,7 @@ protected SqlNode collectParserError(
   //~ Inner Classes ----------------------------------------------------------
 
   /** Text and position info of a validator or parser exception. */
-  public class ValidateErrorInfo {
+  public static class ValidateErrorInfo {
     private int startLineNum;
     private int startColumnNum;
     private int endLineNum;

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -5184,7 +5184,7 @@ public String getOriginalRelName() {
   /**
    * A default implementation of SubQueryConverter that does no conversion.
    */
-  private class NoOpSubQueryConverter implements SubQueryConverter {
+  private static class NoOpSubQueryConverter implements SubQueryConverter {
     @Override public boolean canConvertSubQuery() {
       return false;
     }

File: file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
Patch:
@@ -206,7 +206,7 @@ RelDataType getRowType(JavaTypeFactory typeFactory) {
   }
 
   /** Parses an an HTML table cell. */
-  private class CellReader {
+  private static class CellReader {
     @SuppressWarnings("unused")
     private String type;
     private String selector;

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
Patch:
@@ -656,7 +656,7 @@ public static boolean compatibleType(RelDataType t1, RelDataType t2) {
   /**
    * Context constructed during Pig-to-{@link RelNode} translation process.
    */
-  public class PigRelTranslationContext {
+  public static class PigRelTranslationContext {
     final Map<String, FuncSpec> pigUdfs = new HashMap<>();
   }
 }

File: core/src/main/java/org/apache/calcite/plan/RelTraitSet.java
Patch:
@@ -578,7 +578,7 @@ public boolean comprises(RelTrait... relTraits) {
    * Outputs the traits of this set as a String. Traits are output in order,
    * separated by periods.
    */
-  protected String computeString() {
+  String computeString() {
     StringBuilder s = new StringBuilder();
     for (int i = 0; i < traits.length; i++) {
       final RelTrait trait = traits[i];

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidType.java
Patch:
@@ -42,7 +42,7 @@ public boolean isComplex() {
   }
 
   /** Returns a DruidType matching the given String type from a Druid metric. */
-  protected static DruidType getTypeFromMetric(String type) {
+  static DruidType getTypeFromMetric(String type) {
     assert type != null;
     if (type.equals("hyperUnique")) {
       return HYPER_UNIQUE;

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraProject.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.adapter.cassandra;
 
-import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelOptCost;
 import org.apache.calcite.plan.RelOptPlanner;

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.adapter.enumerable.EnumerableConvention;
 import org.apache.calcite.adapter.enumerable.EnumerableLimit;
-import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.plan.Convention;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
@@ -45,7 +44,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.function.Predicate;
 
 /**
  * Rules and relational operators for

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -73,9 +73,9 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableSet;
 import java.util.Objects;
 import java.util.Set;
-import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.function.Function;
 import java.util.function.IntFunction;
@@ -768,7 +768,7 @@ public static class Builder {
     private final LatticeRootNode rootNode;
     private final ImmutableList<BaseColumn> baseColumns;
     private final ImmutableListMultimap<String, Column> columnsByAlias;
-    private final SortedSet<Measure> defaultMeasureSet =
+    private final NavigableSet<Measure> defaultMeasureSet =
         new TreeSet<>();
     private final ImmutableList.Builder<Tile> tileListBuilder =
         ImmutableList.builder();

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -124,8 +124,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.NavigableSet;
 import java.util.Set;
-import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
@@ -4169,7 +4169,7 @@ public VariableUsedVisitor(RelShuttle relShuttle) {
 
   /** Shuttle that finds the set of inputs that are used. */
   public static class InputReferencedVisitor extends RexShuttle {
-    public final SortedSet<Integer> inputPosReferenced = new TreeSet<>();
+    public final NavigableSet<Integer> inputPosReferenced = new TreeSet<>();
 
     @Override public RexNode visitInputRef(RexInputRef inputRef) {
       inputPosReferenced.add(inputRef.getIndex());

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -79,9 +79,9 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableMap;
 import java.util.Objects;
 import java.util.Set;
-import java.util.SortedMap;
 import java.util.TreeMap;
 
 import static org.apache.calcite.rex.RexUtil.andNot;
@@ -324,7 +324,7 @@ private static RexNode canonizeNode(RexBuilder rexBuilder, RexNode condition) {
     case AND:
     case OR: {
       RexCall call = (RexCall) condition;
-      SortedMap<String, RexNode> newOperands = new TreeMap<>();
+      NavigableMap<String, RexNode> newOperands = new TreeMap<>();
       for (RexNode operand : call.operands) {
         operand = canonizeNode(rexBuilder, operand);
         newOperands.put(operand.toString(), operand);

File: core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
Patch:
@@ -47,6 +47,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableSet;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
@@ -533,7 +534,7 @@ public static Collector create(Space space, int sketchThreshold) {
 
   /** Collector that collects values of a single column. */
   static class SingletonCollector extends Collector {
-    final SortedSet<Comparable> values = new TreeSet<>();
+    final NavigableSet<Comparable> values = new TreeSet<>();
     final int columnOrdinal;
     final int sketchThreshold;
     int nullCount = 0;

File: core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableSet;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
@@ -288,7 +289,7 @@ static class Space implements Comparable<Space> {
     final ImmutableBitSet columnOrdinals;
     final ImmutableSortedSet<Column> columns;
     int nullCount;
-    final SortedSet<FlatLists.ComparableList<Comparable>> values =
+    final NavigableSet<FlatLists.ComparableList<Comparable>> values =
         new TreeSet<>();
     boolean unique;
     final BitSet dependencies = new BitSet();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
Patch:
@@ -66,6 +66,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableSet;
 import java.util.Objects;
 import java.util.SortedSet;
 import java.util.TreeSet;
@@ -273,7 +274,7 @@ public static List<RelCollation> calc(RelMetadataQuery mq, RelNode input,
   /** Helper method to determine a {@link Project}'s collation. */
   public static List<RelCollation> project(RelMetadataQuery mq,
       RelNode input, List<? extends RexNode> projects) {
-    final SortedSet<RelCollation> collations = new TreeSet<>();
+    final NavigableSet<RelCollation> collations = new TreeSet<>();
     final List<RelCollation> inputCollations = mq.collations(input);
     if (inputCollations == null || inputCollations.isEmpty()) {
       return ImmutableList.of();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
Patch:
@@ -534,6 +534,7 @@ static class JoinConditionBasedPredicateInference {
     final ImmutableBitSet leftFieldsBitSet;
     final ImmutableBitSet rightFieldsBitSet;
     final ImmutableBitSet allFieldsBitSet;
+    @SuppressWarnings("JdkObsolete")
     SortedMap<Integer, BitSet> equivalence;
     final Map<RexNode, ImmutableBitSet> exprFields;
     final Set<RexNode> allExprs;
@@ -755,6 +756,7 @@ private boolean checkTarget(ImmutableBitSet inferringFields,
           && !isAlwaysTrue(tr);
     }
 
+    @SuppressWarnings("JdkObsolete")
     private void markAsEquivalent(int p1, int p2) {
       BitSet b = equivalence.get(p1);
       b.set(p2);
@@ -830,6 +832,7 @@ class ExprsItr implements Iterator<Mapping> {
       Mapping nextMapping;
       boolean firstCall;
 
+      @SuppressWarnings("JdkObsolete")
       ExprsItr(ImmutableBitSet fields) {
         nextMapping = null;
         columns = new int[fields.cardinality()];

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -56,8 +56,8 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableSet;
 import java.util.Set;
-import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
@@ -297,7 +297,7 @@ private RelBuilder convertSingletonDistinct(RelBuilder relBuilder,
 
     // Add the distinct aggregate column(s) to the group-by columns,
     // if not already a part of the group-by
-    final SortedSet<Integer> bottomGroups = new TreeSet<>(aggregate.getGroupSet().asList());
+    final NavigableSet<Integer> bottomGroups = new TreeSet<>(aggregate.getGroupSet().asList());
     for (AggregateCall aggCall : originalAggCalls) {
       if (aggCall.isDistinct()) {
         bottomGroups.addAll(aggCall.getArgList());
@@ -339,7 +339,7 @@ private RelBuilder convertSingletonDistinct(RelBuilder relBuilder,
       if (aggCall.isDistinct()) {
         List<Integer> newArgList = new ArrayList<>();
         for (int arg : aggCall.getArgList()) {
-          newArgList.add(bottomGroups.headSet(arg).size());
+          newArgList.add(bottomGroups.headSet(arg, false).size());
         }
         newCall =
             AggregateCall.create(aggCall.getAggregation(),

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -53,8 +53,8 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableMap;
 import java.util.Objects;
-import java.util.SortedMap;
 import java.util.TreeMap;
 
 /**
@@ -388,7 +388,7 @@ private boolean isJoinSupported(final Join join, final Aggregate aggregate) {
    * set, and vice versa. */
   private static ImmutableBitSet keyColumns(ImmutableBitSet aggregateColumns,
       ImmutableList<RexNode> predicates) {
-    SortedMap<Integer, BitSet> equivalence = new TreeMap<>();
+    NavigableMap<Integer, BitSet> equivalence = new TreeMap<>();
     for (RexNode predicate : predicates) {
       populateEquivalences(equivalence, predicate);
     }

File: core/src/main/java/org/apache/calcite/sql/parser/SqlAbstractParserImpl.java
Patch:
@@ -42,6 +42,7 @@
 import java.util.EnumSet;
 import java.util.HashSet;
 import java.util.List;
+import java.util.NavigableSet;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
@@ -638,7 +639,7 @@ public static class MetadataImpl implements Metadata {
     /**
      * Set of all tokens.
      */
-    private final SortedSet<String> tokenSet = new TreeSet<>();
+    private final NavigableSet<String> tokenSet = new TreeSet<>();
 
     /**
      * Immutable list of all tokens, in alphabetical order.

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -180,6 +180,7 @@ public void updateRelInMap(
     }
   }
 
+  @SuppressWarnings("JdkObsolete")
   public void updateRelInMap(
       SortedMap<CorrelationId, LogicalCorrelate> mapCorVarToCorRel) {
     for (CorrelationId corVar : mapCorVarToCorRel.keySet()) {

File: core/src/main/java/org/apache/calcite/util/EquivalenceSet.java
Patch:
@@ -24,8 +24,8 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.NavigableMap;
 import java.util.Objects;
-import java.util.SortedMap;
 import java.util.SortedSet;
 
 /** Set of elements organized into equivalence classes.
@@ -109,7 +109,7 @@ public boolean areEquivalent(E e, E f) {
   /** Returns a map of the canonical element in each equivalence class to the
    * set of elements in that class. The keys are sorted in natural order, as
    * are the elements within each key. */
-  public SortedMap<E, SortedSet<E>> map() {
+  public NavigableMap<E, SortedSet<E>> map() {
     final TreeMultimap<E, E> multimap = TreeMultimap.create();
     for (Map.Entry<E, E> entry : parents.entrySet()) {
       multimap.put(entry.getValue(), entry.getKey());

File: core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
Patch:
@@ -756,6 +756,7 @@ public int indexOf(int bit) {
    * <p>The input must have an entry for each position.
    *
    * <p>Does not modify the input map or its bit sets. */
+  @SuppressWarnings("JdkObsolete")
   public static SortedMap<Integer, ImmutableBitSet> closure(
       SortedMap<Integer, ImmutableBitSet> equivalence) {
     if (equivalence.isEmpty()) {
@@ -930,6 +931,7 @@ public static boolean allContain(Collection<ImmutableBitSet> bitSets, int bit) {
    * from lower positions and the final equivalence Set is propagated down
    * from the lowest element in the Set.
    */
+  @SuppressWarnings("JdkObsolete")
   private static class Closure {
     private SortedMap<Integer, ImmutableBitSet> equivalence;
     private final SortedMap<Integer, ImmutableBitSet> closure =

File: core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java
Patch:
@@ -48,7 +48,7 @@ private ImmutableNullableMap() {
    * <p>Behavior is as {@link ImmutableMap#copyOf(Iterable)}
    * except that this map allows nulls.
    */
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"JdkObsolete", "unchecked", "rawtypes"})
   public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
     if (map instanceof ImmutableNullableMap
         || map instanceof ImmutableMap
@@ -87,7 +87,7 @@ public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
    * <p>Behavior is as {@link ImmutableSortedMap#copyOf(Map)}
    * except that this map allows nulls.
    */
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"JdkObsolete", "unchecked", "rawtypes"})
   public static <K, V> Map<K, V> copyOf(
       SortedMap<? extends K, ? extends V> map) {
     if (map instanceof ImmutableNullableMap

File: core/src/main/java/org/apache/calcite/util/SerializableCharset.java
Patch:
@@ -63,6 +63,7 @@ private void writeObject(ObjectOutputStream out) throws IOException {
   /**
    * Per {@link Serializable}.
    */
+  @SuppressWarnings("JdkObsolete")
   private void readObject(ObjectInputStream in)
       throws IOException, ClassNotFoundException {
     charsetName = (String) in.readObject();

File: core/src/test/java/org/apache/calcite/util/UtilTest.java
Patch:
@@ -90,7 +90,6 @@
 import java.util.Random;
 import java.util.RandomAccess;
 import java.util.Set;
-import java.util.SortedMap;
 import java.util.SortedSet;
 import java.util.TimeZone;
 import java.util.TreeSet;
@@ -2886,7 +2885,7 @@ private void checkNameMultimap(String s, NameMultimap<Integer> map) {
     c.equiv("fg", "fG");
     assertThat(c.size(), is(6));
     assertThat(c.classCount(), is(3));
-    final SortedMap<String, SortedSet<String>> map = c.map();
+    final NavigableMap<String, SortedSet<String>> map = c.map();
     assertThat(map.toString(),
         is("{ABC=[ABC, Abc, abc], de=[de], fG=[fG, fg]}"));
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -2725,7 +2725,7 @@ public static <TSource, TKey> Enumerable<TSource> orderBy(
             // the offset is bigger than the number of rows in the map
             return Linq4j.emptyEnumerator();
           }
-          map.headMap(until).clear();
+          map.headMap(until, false).clear();
         }
 
         return new LookupImpl<>(map).valuesEnumerable().enumerator();

File: linq4j/src/main/java/org/apache/calcite/linq4j/GroupingImpl.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.linq4j;
 
-import java.util.Collection;
+import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
@@ -29,9 +29,9 @@
 class GroupingImpl<K, V> extends AbstractEnumerable<V>
     implements Grouping<K, V>, Map.Entry<K, Enumerable<V>> {
   private final K key;
-  private final Collection<V> values;
+  private final List<V> values;
 
-  GroupingImpl(K key, Collection<V> values) {
+  GroupingImpl(K key, List<V> values) {
     this.key = Objects.requireNonNull(key);
     this.values = Objects.requireNonNull(values);
   }

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -2663,7 +2663,7 @@ public static <TSource, TKey> Enumerable<TSource> orderBy(
 
         TreeMap<TKey, List<TSource>> map = new TreeMap<>(comparator);
         long size = 0;
-        long needed = fetch + offset;
+        long needed = fetch + (long) offset;
 
         // read the input into a tree map
         try (Enumerator<TSource> os = source.enumerator()) {

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -503,6 +503,7 @@ assert equalType(
    * are both a qualified match for replacement R, is R join B, R join R,
    * A join R.
    */
+  @SuppressWarnings("MixedMutabilityReturnType")
   public List<RelNode> go(RelNode replacement_) {
     List<List<Replacement>> matches = go(MutableRels.toMutable(replacement_));
     if (matches.isEmpty()) {

File: core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
Patch:
@@ -186,7 +186,7 @@ private Collection<org.apache.calcite.schema.Function> getFunctionsFrom(
     if (schema == null) {
       return ImmutableList.of();
     }
-    final List<SqlMoniker> result = new ArrayList<>();
+    final ImmutableList.Builder<SqlMoniker> result = new ImmutableList.Builder<>();
 
     // Add root schema if not anonymous
     if (!schema.name.equals("")) {
@@ -207,7 +207,7 @@ private Collection<org.apache.calcite.schema.Function> getFunctionsFrom(
     for (String function : functions) { // views are here as well
       result.add(moniker(schema, function, SqlMonikerType.FUNCTION));
     }
-    return result;
+    return result.build();
   }
 
   private SqlMonikerImpl moniker(CalciteSchema schema, String name,

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
Patch:
@@ -121,11 +121,11 @@ private void readRel(final Map<String, Object> jsonRel) {
         if (jsonInputs == null) {
           return ImmutableList.of(lastRel);
         }
-        final List<RelNode> inputs = new ArrayList<>();
+        final ImmutableList.Builder<RelNode> inputs = new ImmutableList.Builder<>();
         for (String jsonInput : jsonInputs) {
           inputs.add(lookupInput(jsonInput));
         }
-        return inputs;
+        return inputs.build();
       }
 
       @Override public RexNode getExpression(String tag) {

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -184,12 +184,12 @@ public List<SqlMoniker> getCompletionHints(
     }
 
     if (word.isEmpty()) {
-      return completionHints;
+      return ImmutableList.copyOf(completionHints);
     }
 
     // If cursor was part of the way through a word, only include hints
     // which start with that word in the result.
-    final List<SqlMoniker> result = new ArrayList<>();
+    final ImmutableList.Builder<SqlMoniker> result = new ImmutableList.Builder<>();
     Casing preferredCasing = getPreferredCasing(word);
 
     boolean ignoreCase = preferredCasing != Casing.UNCHANGED;
@@ -203,7 +203,7 @@ public List<SqlMoniker> getCompletionHints(
       }
     }
 
-    return result;
+    return result.build();
   }
 
   public List<SqlMoniker> getCompletionHints0(String sql, int cursor) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java
Patch:
@@ -305,6 +305,7 @@ public static <T1, R> List<R> apply(final List<T1> list,
   /** Returns a list that contains only elements of {@code list} that match
    * {@code predicate}. Avoids allocating a list if all elements match or no
    * elements match. */
+  @SuppressWarnings("MixedMutabilityReturnType")
   public static <E> List<E> filter(List<E> list, Predicate1<E> predicate) {
   sniff:
     {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
Patch:
@@ -3159,11 +3159,11 @@ static List<Expression> acceptParameterExpressions(
     if (parameterExpressions.isEmpty()) {
       return Collections.emptyList(); // short cut
     }
-    final List<Expression> parameterExpressions1 = new ArrayList<>();
+    final ImmutableList.Builder<Expression> parameterExpressions1 = new ImmutableList.Builder<>();
     for (ParameterExpression parameterExpression : parameterExpressions) {
       parameterExpressions1.add(parameterExpression.accept(shuttle));
     }
-    return parameterExpressions1;
+    return parameterExpressions1.build();
   }
 
   static List<DeclarationStatement> acceptDeclarations(

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
Patch:
@@ -411,7 +411,7 @@ private List<RexNode> getGroupRowOperands(List<RexNode> fieldRels,
           cubeRowFields.add(field);
         }
       }
-      return cubeRowFields;
+      return ImmutableList.copyOf(cubeRowFields);
     }
     return rowFields;
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java
Patch:
@@ -1207,7 +1207,7 @@ private Result implementCaseWhen(RexCall call) {
    *
    * <p>We generate code that looks like:
    *
-   * <blockquote><pre>
+   * <blockquote><pre>{@code
    *      int case_when_value;
    *      ......code for a......
    *      if (!a_isNull && a_value) {
@@ -1223,7 +1223,7 @@ private Result implementCaseWhen(RexCall call) {
    *              case_when_value = res(e_isNull, e_value);
    *          }
    *      }
-   * </pre></blockquote>
+   * }</pre></blockquote>
    */
   private void implementRecursively(final RexToLixTranslator currentTranslator,
       final List<RexNode> operandList, final ParameterExpression valueVariable, int pos) {

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -245,7 +245,7 @@ void register(MutableRel result, MutableRel query) {
    * <li>residue: y = 2</li>
    * </ul>
    *
-   * <p>Note that residue {@code x &gt; 0 AND y = 2} would also satisfy the
+   * <p>Note that residue {@code x > 0 AND y = 2} would also satisfy the
    * relation {@code condition = target AND residue} but is stronger than
    * necessary, so we prefer {@code y = 2}.</p>
    *

File: core/src/main/java/org/apache/calcite/util/Sarg.java
Patch:
@@ -84,12 +84,11 @@ public static <C extends Comparable<C>> Sarg<C> of(boolean containsNull,
    * if nulls are matched, and simplifies point ranges. For example,
    * the Sarg that allows the range set
    *
-   * <blockquote>{@code [[7&#x2025;7], [9&#x2025;9],
-   * (10&#x2025;+&infin;)]}</blockquote>
+   * <blockquote>{@code [[7..7], [9..9], (10..+∞)]}</blockquote>
    *
    * and also null is printed as
    *
-   * <blockquote>{@code Sarg[7, 9, (10&#x2025;+&infin;), null]}</blockquote>
+   * <blockquote>{@code Sarg[7, 9, (10..+∞), null]}</blockquote>
    */
   @Override public String toString() {
     final StringBuilder sb = new StringBuilder();

File: linq4j/src/main/java/org/apache/calcite/linq4j/Extensions.java
Patch:
@@ -102,7 +102,7 @@
  *
  * <li>Function types that accept primitive types in LINQ.NET have become
  * boxed types in LINQ4J. For example, a predicate function
- * {@code Func&lt;T, bool&gt;} becomes {@code Func1&lt;T, Boolean&gt;}.
+ * {@code Func<T, bool>} becomes {@code Func1<T, Boolean>}.
  * It would be wrong to infer that the function is allowed to return null.</li>
  *
  * </ul>

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ExpressionType.java
Patch:
@@ -73,7 +73,7 @@ public enum ExpressionType {
   AddChecked(" + ", false, 4, false),
 
   /**
-   * A bitwise or logical AND operation, such as {@code a &amp; b} in Java.
+   * A bitwise or logical AND operation, such as {@code a & b} in Java.
    */
   And(" & ", false, 8, false),
 
@@ -175,7 +175,7 @@ public enum ExpressionType {
   Invoke,
 
   /**
-   * A lambda expression, such as {@code a -&gt; a + a} in Java.
+   * A lambda expression, such as {@code a -> a + a} in Java.
    */
   Lambda,
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
Patch:
@@ -253,7 +253,7 @@ public static Class unbox(Class type) {
 
   /**
    * Adapts a primitive array into a {@link List}. For example,
-   * {@code asList(new double[2])} returns a {@code List&lt;Double&gt;}.
+   * {@code asList(new double[2])} returns a {@code List<Double>}.
    */
   public static List<?> asList(final Object array) {
     // REVIEW: A per-type list might be more efficient. (Or might not.)

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraProject.java
Patch:
@@ -61,7 +61,6 @@ public CassandraProject(RelOptCluster cluster, RelTraitSet traitSet,
     implementor.visitChild(0, getInput());
     final CassandraRules.RexToCassandraTranslator translator =
         new CassandraRules.RexToCassandraTranslator(
-            (JavaTypeFactory) getCluster().getTypeFactory(),
             CassandraRules.cassandraFieldNames(getInput().getRowType()));
     final Map<String, String> fields = new LinkedHashMap<>();
     for (Pair<RexNode, String> pair : getNamedProjects()) {

File: core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
Patch:
@@ -434,6 +434,7 @@ private ArrayTable.Representation chooseFixedRep(
     }
 
     /** Two's complement absolute on int value. */
+    @SuppressWarnings("unused")
     private static int abs2(int v) {
       // -128 becomes +127
       return v < 0 ? ~v : v;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMatch.java
Patch:
@@ -354,6 +354,7 @@ private Expression implementPredicate(PhysType physType,
       //   }
       final ParameterExpression row0_ =
           Expressions.parameter(Object.class, "row");
+      @SuppressWarnings("unused")
       final ParameterExpression rowsO_ =
           Expressions.parameter(Object.class, "rows");
       BlockBuilder bridgeBody = new BlockBuilder();

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableFunctionScan.java
Patch:
@@ -101,7 +101,8 @@ private boolean isQueryable() {
   }
 
   private Result defaultTableFunctionImplement(
-      EnumerableRelImplementor implementor, Prefer pref) {
+      EnumerableRelImplementor implementor,
+      @SuppressWarnings("unused") Prefer pref) { // TODO: remove or use
     BlockBuilder bb = new BlockBuilder();
     // Non-array user-specified types are not supported yet
     final JavaRowFormat format;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -111,6 +111,7 @@ private WindowRelInputGetter(Expression row,
     }
   }
 
+  @SuppressWarnings("unused")
   private void sampleOfTheGeneratedWindowedAggregate() {
     // Here's overview of the generated code
     // For each list of rows that have the same partitioning key, evaluate
@@ -902,7 +903,8 @@ private Expression translateBound(RexToLixTranslator translator,
       ParameterExpression i_, Expression row_, Expression min_,
       Expression max_, Expression rows_, Group group,
       boolean lower,
-      PhysType physType, Expression rowComparator,
+      PhysType physType,
+      @SuppressWarnings("unused") Expression rowComparator, // TODO: remove or use
       Expression keySelector, Expression keyComparator) {
     RexWindowBound bound = lower ? group.lowerBound : group.upperBound;
     if (bound.isUnbounded()) {

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -138,6 +138,7 @@ private void start() {
   }
 
   /** Not used. */
+  @SuppressWarnings("unused")
   private class FooCompiler implements ScalarCompiler {
     @Override public Scalar compile(List<RexNode> nodes, RelDataType inputRowType) {
       final RexNode node = nodes.get(0);

File: core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
Patch:
@@ -148,6 +148,7 @@ public static Pattern likeToRegex(Pat pattern) {
 
   @Override public void closeStatement(StatementHandle h) {
     final CalciteConnectionImpl calciteConnection = getConnection();
+    @SuppressWarnings("unused")
     final CalciteServerStatement stmt;
     try {
       stmt = calciteConnection.server.getStatement(h);

File: core/src/main/java/org/apache/calcite/materialize/Step.java
Patch:
@@ -130,6 +130,7 @@ private static int compare(RelOptTable table1, List<Integer> columns1,
 
   /** Temporary method. We should use (inferred) primary keys to figure out
    * the direction of steps. */
+  @SuppressWarnings("unused")
   private double cardinality(SqlStatisticProvider statisticProvider,
       LatticeTable table) {
     return statisticProvider.tableCardinality(table.t);

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -59,7 +59,6 @@
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rel.type.RelDataTypeFieldImpl;
-import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.rex.LogicVisitor;
 import org.apache.calcite.rex.RexBuilder;
 import org.apache.calcite.rex.RexCall;
@@ -1540,6 +1539,7 @@ private static void splitCorrelatedFilterCondition(
     nonEquiList.add(condition);
   }
 
+  @SuppressWarnings("unused")
   private static void splitCorrelatedFilterCondition(
       LogicalFilter filter,
       RexNode condition,
@@ -1853,8 +1853,6 @@ public static void projectJoinInputs(
     RelNode rightRel = inputRels[1];
     final RelOptCluster cluster = leftRel.getCluster();
     final RexBuilder rexBuilder = cluster.getRexBuilder();
-    final RelDataTypeSystem typeSystem =
-        cluster.getTypeFactory().getTypeSystem();
 
     int origLeftInputSize = leftRel.getRowType().getFieldCount();
     int origRightInputSize = rightRel.getRowType().getFieldCount();
@@ -2003,6 +2001,7 @@ private static void registerBaseRules(RelOptPlanner planner) {
     RelOptRules.BASE_RULES.forEach(planner::addRule);
   }
 
+  @SuppressWarnings("unused")
   private static void registerReductionRules(RelOptPlanner planner) {
     RelOptRules.CONSTANT_REDUCTION_RULES.forEach(planner::addRule);
   }
@@ -2011,6 +2010,7 @@ private static void registerMaterializationRules(RelOptPlanner planner) {
     RelOptRules.MATERIALIZATION_RULES.forEach(planner::addRule);
   }
 
+  @SuppressWarnings("unused")
   private static void registerCalcRules(RelOptPlanner planner) {
     RelOptRules.CALC_RULES.forEach(planner::addRule);
   }

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
Patch:
@@ -144,7 +144,7 @@ protected VolcanoRuleCall(
             entry.getKey(), entry.getValue());
       }
       // The subset is not used, but we need it, just for debugging
-      //noinspection unused
+      @SuppressWarnings("unused")
       RelSubset subset = volcanoPlanner.ensureRegistered(rel, rels[0]);
 
       if (volcanoPlanner.getListener() != null) {

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -819,7 +819,7 @@ private int getTypeOrdinal(RelDataType type) {
     return type.getSqlTypeName().getJdbcOrdinal();
   }
 
-  private static String getClassName(RelDataType type) {
+  private static String getClassName(@SuppressWarnings("unused") RelDataType type) {
     return Object.class.getName(); // CALCITE-2613
   }
 
@@ -940,6 +940,7 @@ static class CalcitePreparingStmt extends Prepare
     private final RelOptCluster cluster;
     private final Map<String, Object> internalParameters =
         new LinkedHashMap<>();
+    @SuppressWarnings("unused")
     private int expansionDepth;
     private SqlValidator sqlValidator;
 

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -84,6 +84,7 @@ public class PlannerImpl implements Planner, ViewExpander {
   private State state;
 
   // set in STATE_1_RESET
+  @SuppressWarnings("unused")
   private boolean open;
 
   // set in STATE_2_READY

File: core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
Patch:
@@ -499,6 +499,7 @@ public Builder withPassSize(int passSize) {
     public Builder withMinimumSurprise(double v) {
       predicate =
           spaceColumnPair -> {
+            @SuppressWarnings("unused")
             final Space space = spaceColumnPair.left;
             return false;
           };

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -633,7 +633,6 @@ private RexWindowBound toRexWindowBound(RelInput input, Map<String, Object> map)
     }
 
     final String type = (String) map.get("type");
-    final RexBuilder rexBuilder = input.getCluster().getRexBuilder();
     switch (type) {
     case "CURRENT_ROW":
       return RexWindowBounds.CURRENT_ROW;

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
Patch:
@@ -169,7 +169,7 @@ private void readRel(final Map<String, Object> jsonRel) {
         final List<Map<String, Object>> jsonAggs = (List) jsonRel.get(tag);
         final List<AggregateCall> inputs = new ArrayList<>();
         for (Map<String, Object> jsonAggCall : jsonAggs) {
-          inputs.add(toAggCall(this, jsonAggCall));
+          inputs.add(toAggCall(jsonAggCall));
         }
         return inputs;
       }
@@ -275,7 +275,7 @@ public ImmutableList<RexLiteral> getTuple(List jsonTuple) {
     }
   }
 
-  private AggregateCall toAggCall(RelInput relInput, Map<String, Object> jsonAggCall) {
+  private AggregateCall toAggCall(Map<String, Object> jsonAggCall) {
     final Map<String, Object> aggMap = (Map) jsonAggCall.get("agg");
     final SqlAggFunction aggregation =
         relJson.toAggregation(aggMap);

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
Patch:
@@ -506,12 +506,14 @@ public static List<RelCollation> enumerableSemiJoin(RelMetadataQuery mq,
     return mq.collations(left);
   }
 
+  @SuppressWarnings("unused")
   public static List<RelCollation> enumerableBatchNestedLoopJoin(RelMetadataQuery mq,
       RelNode left, RelNode right, JoinRelType joinType) {
     // The current implementation always preserve the sort order of the left input
     return mq.collations(left);
   }
 
+  @SuppressWarnings("unused")
   private static List<RelCollation> enumerableJoin0(RelMetadataQuery mq,
       RelNode left, RelNode right, JoinRelType joinType) {
     // The current implementation can preserve the sort order of the left input if one of the

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
Patch:
@@ -37,7 +37,6 @@
 import org.apache.calcite.rex.RexProgram;
 import org.apache.calcite.util.BuiltInMethod;
 import org.apache.calcite.util.ImmutableBitSet;
-import org.apache.calcite.util.Permutation;
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableMultimap;
@@ -98,7 +97,6 @@ public Set<ImmutableBitSet> getUniqueKeys(Project rel, RelMetadataQuery mq,
   public Set<ImmutableBitSet> getUniqueKeys(Calc rel, RelMetadataQuery mq,
       boolean ignoreNulls) {
     RexProgram program = rel.getProgram();
-    Permutation permutation = program.getPermutation();
     return getProjectUniqueKeys(rel, mq, ignoreNulls,
         Util.transform(program.getProjectList(), program::expandLocalRef));
   }
@@ -148,7 +146,6 @@ private Set<ImmutableBitSet> getProjectUniqueKeys(SingleRel rel, RelMetadataQuer
     // Now add to the projUniqueKeySet the child keys that are fully
     // projected.
     for (ImmutableBitSet colMask : childUniqueKeySet) {
-      ImmutableBitSet.Builder tmpMask = ImmutableBitSet.builder();
       if (!inColumnsUsed.contains(colMask)) {
         // colMask contains a column that is not projected as RexInput => the key is not unique
         continue;

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
Patch:
@@ -110,7 +110,7 @@ protected RelMetadataQuery() {
 
   /** Creates and initializes the instance that will serve as a prototype for
    * all other instances. */
-  private RelMetadataQuery(boolean dummy) {
+  private RelMetadataQuery(@SuppressWarnings("unused") boolean dummy) {
     super(null);
     this.collationHandler = initialHandler(BuiltInMetadata.Collation.Handler.class);
     this.columnOriginHandler = initialHandler(BuiltInMetadata.ColumnOrigin.Handler.class);

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -1027,6 +1027,7 @@ private void parseCorrelTable(RelNode relNode, Result x) {
   /** Stack frame. */
   private static class Frame {
     private final RelNode parent;
+    @SuppressWarnings("unused")
     private final int ordinalInParent;
     private final RelNode r;
     private final boolean anon;

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -361,7 +361,7 @@ private RexNode reduceAvg(
       AggregateCall oldCall,
       List<AggregateCall> newCalls,
       Map<AggregateCall, RexNode> aggCallMapping,
-      List<RexNode> inputExprs) {
+      @SuppressWarnings("unused") List<RexNode> inputExprs) {
     final int nGroups = oldAggRel.getGroupCount();
     final RexBuilder rexBuilder = oldAggRel.getCluster().getRexBuilder();
     final int iAvgInput = oldCall.getArgList().get(0);

File: core/src/main/java/org/apache/calcite/rel/rules/JoinAssociateRule.java
Patch:
@@ -88,6 +88,7 @@ public JoinAssociateRule(RelBuilderFactory relBuilderFactory) {
     final int bCount = relB.getRowType().getFieldCount();
     final int cCount = relC.getRowType().getFieldCount();
     final ImmutableBitSet aBitSet = ImmutableBitSet.range(0, aCount);
+    @SuppressWarnings("unused")
     final ImmutableBitSet bBitSet =
         ImmutableBitSet.range(aCount, aCount + bCount);
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
Patch:
@@ -264,7 +264,7 @@ private List<RelNode> combineInputs(
    */
   private void combineOuterJoins(
       Join joinRel,
-      List<RelNode> combinedInputs,
+      @SuppressWarnings("unused") List<RelNode> combinedInputs,
       RelNode left,
       RelNode right,
       List<Pair<JoinRelType, RexNode>> joinSpecs) {

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -1030,7 +1030,7 @@ private void addResult(RexNode exp) {
       }
     }
 
-    private Boolean isUdf(SqlOperator operator) {
+    private Boolean isUdf(@SuppressWarnings("unused") SqlOperator operator) {
       // return operator instanceof UserDefinedRoutine
       return false;
     }

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
Patch:
@@ -412,6 +412,7 @@ public abstract class MaterializedViewAggregateRule<C extends MaterializedViewAg
     }
 
     // We could map all expressions. Create aggregate mapping.
+    @SuppressWarnings("unused")
     int viewAggregateAdditionalFieldCount = rollupNodes.size();
     int viewInputFieldCount = viewAggregate.getInput().getRowType().getFieldCount();
     int viewInputDifferenceViewFieldCount =

File: core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
Patch:
@@ -48,6 +48,7 @@ public class RexProgramBuilder {
   private final List<RexLocalRef> localRefList = new ArrayList<>();
   private final List<RexLocalRef> projectRefList = new ArrayList<>();
   private final List<String> projectNameList = new ArrayList<>();
+  @SuppressWarnings("unused")
   private final RexSimplify simplify;
   private RexLocalRef conditionRef = null;
   private boolean validating;

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -1224,7 +1224,8 @@ static boolean isSafeExpression(RexNode r) {
   }
 
   private static RexNode simplifyBooleanCase(RexBuilder rexBuilder,
-      List<CaseBranch> inputBranches, RexUnknownAs unknownAs, RelDataType branchType) {
+      List<CaseBranch> inputBranches, @SuppressWarnings("unused") RexUnknownAs unknownAs,
+      RelDataType branchType) {
     RexNode result;
 
     // prepare all condition/branches for boolean interpretation

File: core/src/main/java/org/apache/calcite/runtime/Like.java
Patch:
@@ -149,7 +149,7 @@ private static void similarEscapeRuleChecking(
   private static RuntimeException invalidRegularExpression(
       String pattern, int i) {
     return new RuntimeException(
-        "Invalid regular expression '" + pattern + "'");
+        "Invalid regular expression '" + pattern + "', index " + i);
   }
 
   private static int sqlSimilarRewriteCharEnumeration(

File: core/src/main/java/org/apache/calcite/runtime/Matcher.java
Patch:
@@ -24,7 +24,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
@@ -49,9 +48,8 @@ public class Matcher<E> {
   // but only one thread can use them at a time. Putting them here saves the
   // expense of creating a fresh object each call to "match".
 
-  private final ImmutableList<Tuple<Integer>> emptyStateSet = ImmutableList.of();
+  @SuppressWarnings("unused")
   private final ImmutableBitSet startSet;
-  private final List<Integer> rowSymbols = new ArrayList<>();
 
   /**
    * Creates a Matcher; use {@link #builder}.

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -95,6 +95,7 @@
 @SuppressWarnings("UnnecessaryUnboxing")
 @Deterministic
 public class SqlFunctions {
+  @SuppressWarnings("unused")
   private static final DecimalFormat DOUBLE_FORMAT =
       NumberUtil.decimalFormat("0.0E0");
 
@@ -120,6 +121,7 @@ public class SqlFunctions {
   private static final String[] POSIX_CHARACTER_CLASSES = new String[] { "Lower", "Upper", "ASCII",
       "Alpha", "XDigit", "Digit", "Alnum", "Punct", "Graph", "Print", "Blank", "Cntrl", "Space" };
 
+  @SuppressWarnings("unused")
   private static final Function1<Object[], Enumerable<Object[]>> ARRAY_CARTESIAN_PRODUCT =
       lists -> {
         final List<Enumerator<Object>> enumerators = new ArrayList<>();

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -360,7 +360,7 @@ private String stripLeadingSign(String value) {
   }
 
   private boolean isLeadFieldInRange(RelDataTypeSystem typeSystem,
-      BigDecimal value, TimeUnit unit) {
+      BigDecimal value, @SuppressWarnings("unused") TimeUnit unit) {
     // we should never get handed a negative field value
     assert value.compareTo(ZERO) >= 0;
 

File: core/src/main/java/org/apache/calcite/sql/SqlStateCodes.java
Patch:
@@ -33,6 +33,7 @@ public enum SqlStateCodes {
 
   NUMERIC_VALUE_OUT_OF_RANGE("numeric value out of range", "22", "003");
 
+  @SuppressWarnings("unused")
   private final String msg;
   private final String stateClass;
   private final String stateSubClass;

File: core/src/main/java/org/apache/calcite/sql/SqlWindow.java
Patch:
@@ -526,6 +526,7 @@ public boolean isAllowPartial() {
       SqlValidatorScope scope) {
     SqlValidatorScope operandScope = scope; // REVIEW
 
+    @SuppressWarnings("unused")
     SqlIdentifier declName = this.declName;
     SqlIdentifier refName = this.refName;
     SqlNodeList partitionList = this.partitionList;

File: core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java
Patch:
@@ -688,6 +688,7 @@ private void purgeSelect() {
       sublist.add(new Token(TokenType.ID, "*"));
     }
 
+    @SuppressWarnings("unused")
     private void purgeSelectExprsKeepAliases() {
       List<Token> sublist = findClause(TokenType.SELECT);
       List<Token> newSelectClause = new ArrayList<>();

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetSetOperator.java
Patch:
@@ -35,6 +35,7 @@
 public class SqlMultisetSetOperator extends SqlBinaryOperator {
   //~ Instance fields --------------------------------------------------------
 
+  @SuppressWarnings("unused")
   private final boolean all;
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -279,7 +279,7 @@ public class SqlPrettyWriter implements SqlWriter {
   //~ Constructors -----------------------------------------------------------
 
   private SqlPrettyWriter(SqlWriterConfig config,
-      StringBuilder buf, boolean ignore) {
+      StringBuilder buf, @SuppressWarnings("unused") boolean ignore) {
     this.buf = Objects.requireNonNull(buf);
     this.dialect = Objects.requireNonNull(config.dialect());
     this.config = Objects.requireNonNull(config);

File: core/src/main/java/org/apache/calcite/sql/validate/CollectScope.java
Patch:
@@ -29,6 +29,7 @@
 class CollectScope extends ListScope {
   //~ Instance fields --------------------------------------------------------
 
+  @SuppressWarnings("unused")
   private final SqlValidatorScope usingScope;
   private final SqlCall child;
 

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -826,7 +826,6 @@ private RelNode createValueGenerator(
 
       if (!joinedInputs.contains(newInput)) {
         final List<Integer> positions = mapNewInputToOutputs.get(newInput);
-        final List<String> fieldNames = newInput.getRowType().getFieldNames();
 
         RelNode distinct = relBuilder.push(newInput)
             .project(relBuilder.fields(positions))

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -949,7 +949,7 @@ public TrimResult trimFields(
     // there's to do.
     if (changeCount == 0
         && mapping.isIdentity()) {
-      for (RelNode input : setOp.getInputs()) {
+      for (@SuppressWarnings("unused") RelNode input : setOp.getInputs()) {
         relBuilder.build();
       }
       return result(setOp, mapping);

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -140,6 +140,7 @@ public class RelStructuredTypeFlattener implements ReflectiveVisitor {
   private final Map<RelNode, RelNode> oldToNewRelMap = new HashMap<>();
   private RelNode currentRel;
   private int iRestructureInput;
+  @SuppressWarnings("unused")
   private RelDataType flattenedRootType;
   boolean restructured;
   private final RelOptTable.ToRelContext toRelContext;

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -2409,7 +2409,6 @@ protected void convertMatchRecognize(Blackboard bb,
   }
 
   protected void convertPivot(Blackboard bb, SqlPivot pivot) {
-    final SqlValidatorNamespace ns = validator.getNamespace(pivot);
     final SqlValidatorScope scope = validator.getJoinScope(pivot);
 
     final Blackboard pivotBb = createBlackboard(scope, null, false);

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -606,6 +606,7 @@ public RexNode convertExtract(
     return convertFunction(cx, (SqlFunction) call.getOperator(), call);
   }
 
+  @SuppressWarnings("unused")
   private RexNode mod(RexBuilder rexBuilder, RelDataType resType, RexNode res,
       BigDecimal val) {
     if (val.equals(BigDecimal.ONE)) {

File: core/src/main/java/org/apache/calcite/util/ChunkList.java
Patch:
@@ -73,7 +73,7 @@ boolean isValid(boolean fail) {
       return false;
     }
     int n = 0;
-    for (E e : this) {
+    for (@SuppressWarnings("unused") E e : this) {
       if (n++ > size) {
         assert !fail;
         return false;

File: core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
Patch:
@@ -76,6 +76,7 @@ public class PartiallyOrderedSet<E> extends AbstractSet<E> {
 
   private final Map<E, Node<E>> map;
   private final Function<E, Iterable<E>> parentFunction;
+  @SuppressWarnings("unused")
   private final Function<E, Iterable<E>> childFunction;
   private final Ordering<E> ordering;
 

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -1797,7 +1797,7 @@ public static <E> Collection<E> filter(
           // filtering values.  (Some java.util algorithms
           // call next() on the result of iterator() size() times.)
           int s = 0;
-          for (E e : this) {
+          for (@SuppressWarnings("unused") E e : this) {
             s++;
           }
           size = s;

File: core/src/main/java/org/apache/calcite/util/XmlOutput.java
Patch:
@@ -356,13 +356,15 @@ public void cdata(String data, boolean quote) {
       data = "";
     }
     boolean specials = false;
+    @SuppressWarnings("unused")
     boolean cdataEnd = false;
 
     // Scan the string for special characters
     // If special characters are found, scan the string for ']]>'
     if (stringHasXMLSpecials(data)) {
       specials = true;
       if (data.contains("]]>")) {
+        // TODO: support string that contains cdataEnd literal values
         cdataEnd = true;
       }
     }

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
Patch:
@@ -482,6 +482,7 @@ private void expectScalarField(JsonParser parser, String name)
     }
   }
 
+  @SuppressWarnings("unused")
   private void expectObjectField(JsonParser parser, String name)
       throws IOException {
     expect(parser, JsonToken.FIELD_NAME);

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
Patch:
@@ -219,8 +219,9 @@ private static DruidJsonFilter toBoundDruidFilter(RexNode rexNode, RelDataType r
    * equivalent
    */
   @Nullable
-  private static String toDruidLiteral(RexNode rexNode, RelDataType rowType,
-      DruidQuery druidQuery) {
+  private static String toDruidLiteral(RexNode rexNode,
+      @SuppressWarnings("unused") RelDataType rowType,
+      @SuppressWarnings("unused") DruidQuery druidQuery) {
     final String val;
     final RexLiteral rhsLiteral = (RexLiteral) rexNode;
     if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -214,7 +214,7 @@ protected DruidFilterRule(Config config) {
               .indexOf(query.druidTable.timestampFieldName);
       RelNode newDruidQuery = query;
       final Triple<List<RexNode>, List<RexNode>, List<RexNode>> triple =
-          splitFilters(rexBuilder, query, validPreds, nonValidPreds, timestampFieldIdx);
+          splitFilters(validPreds, nonValidPreds, timestampFieldIdx);
       if (triple.getLeft().isEmpty() && triple.getMiddle().isEmpty()) {
         // it sucks, nothing to push
         return;
@@ -259,7 +259,7 @@ protected DruidFilterRule(Config config) {
      * 3-r) condition filters that cannot be pushed to Druid.
      */
     private static Triple<List<RexNode>, List<RexNode>, List<RexNode>> splitFilters(
-        final RexBuilder rexBuilder, final DruidQuery input, final List<RexNode> validPreds,
+        final List<RexNode> validPreds,
         final List<RexNode> nonValidPreds, final int timestampFieldIdx) {
       final List<RexNode> timeRangeNodes = new ArrayList<>();
       final List<RexNode> pushableNodes = new ArrayList<>();

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchEnumerators.java
Patch:
@@ -34,6 +34,7 @@ class ElasticsearchEnumerators {
 
   private ElasticsearchEnumerators() {}
 
+  @SuppressWarnings("unused")
   private static Function1<ElasticsearchJson.SearchHit, Map> mapGetter() {
     return ElasticsearchJson.SearchHit::sourceOrFields;
   }

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
Patch:
@@ -120,6 +120,7 @@ static QueryBuilder analyze(RexNode expression) throws ExpressionNotAnalyzableEx
   /**
    * Converts expressions of the form NOT(LIKE(...)) into NOT_LIKE(...)
    */
+  @SuppressWarnings("unused")
   private static class NotLikeConverter extends RexShuttle {
     final RexBuilder rexBuilder;
 
@@ -849,6 +850,7 @@ interface TerminalExpression extends Expression {
    * SQL cast. For example, {@code cast(col as INTEGER)}.
    */
   static final class CastExpression implements TerminalExpression {
+    @SuppressWarnings("unused")
     private final RelDataType type;
     private final TerminalExpression argument;
 

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
Patch:
@@ -482,7 +482,9 @@ RangeQueryBuilder format(String format) {
    * A Query that does fuzzy matching for a specific value.
    */
   static class RegexpQueryBuilder extends QueryBuilder {
+    @SuppressWarnings("unused")
     private final String fieldName;
+    @SuppressWarnings("unused")
     private final String value;
 
     RegexpQueryBuilder(final String fieldName, final String value) {

File: file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
Patch:
@@ -207,6 +207,7 @@ RelDataType getRowType(JavaTypeFactory typeFactory) {
 
   /** Parses an an HTML table cell. */
   private class CellReader {
+    @SuppressWarnings("unused")
     private String type;
     private String selector;
     private Integer selectedElement;

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
Patch:
@@ -87,10 +87,12 @@ public class GeodeFilter extends Filter implements GeodeRel {
    * Translates {@link RexNode} expressions into Geode expression strings.
    */
   static class Translator {
+    @SuppressWarnings("unused")
     private final RelDataType rowType;
 
     private final List<String> fieldNames;
 
+    @SuppressWarnings("unused")
     private RexBuilder rexBuilder;
 
     Translator(RelDataType rowType, RexBuilder rexBuilder) {

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java
Patch:
@@ -364,14 +364,13 @@ private boolean checkConditionContainsInputRefOrLiterals(RexNode left,
 
     @Override public void onMatch(RelOptRuleCall call) {
       LogicalFilter filter = call.rel(0);
-      GeodeTableScan scan = call.rel(1);
       if (filter.getTraitSet().contains(Convention.NONE)) {
-        final RelNode converted = convert(filter, scan);
+        final RelNode converted = convert(filter);
         call.transformTo(converted);
       }
     }
 
-    private RelNode convert(LogicalFilter filter, GeodeTableScan scan) {
+    private RelNode convert(LogicalFilter filter) {
       final RelTraitSet traitSet = filter.getTraitSet().replace(GeodeRel.CONVENTION);
       return new GeodeFilter(
           filter.getCluster(),

File: geode/src/main/java/org/apache/calcite/adapter/geode/simple/GeodeSimpleEnumerator.java
Patch:
@@ -34,6 +34,7 @@ public abstract class GeodeSimpleEnumerator<E> implements Enumerator<E> {
   private Iterator results;
 
   private E current;
+  @SuppressWarnings("unused")
   private ClientCache clientCache;
 
   protected GeodeSimpleEnumerator(ClientCache clientCache, String regionName) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -852,6 +852,7 @@ public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGr
    * @param <TResult> result type */
   private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>
       implements Enumerator<TResult> {
+    @SuppressWarnings("unused")
     private final Enumerable<TSource> enumerable;
     private final Function1<TSource, TKey> keySelector;
     private final Function0<TAccumulate> accumulatorInitializer;
@@ -1007,6 +1008,7 @@ private static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> groupBy
     return new LookupResultEnumerable<>(map, resultSelector);
   }
 
+  @SuppressWarnings("unused")
   private static <TSource, TKey, TResult> Enumerable<TResult> groupBy_(
       final Set<TKey> map, Enumerable<TSource> enumerable,
       Function1<TSource, TKey> keySelector,
@@ -3016,7 +3018,6 @@ public static <TSource, TCollection, TResult> Enumerable<TResult> selectMany(
           }
 
           @Override public boolean moveNext() {
-            boolean incremented = false;
             for (;;) {
               if (resultEnumerator.moveNext()) {
                 return true;

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
Patch:
@@ -345,7 +345,6 @@ public static Constructor lookupConstructor(Type type,
       }
     }
     if (constructors.length == 0 && argumentTypes.length == 0) {
-      Constructor[] constructors1 = clazz.getConstructors();
       try {
         return clazz.getConstructor();
       } catch (NoSuchMethodException e) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
Patch:
@@ -24,6 +24,7 @@
  *
  * @param <R> Return type
  */
+@SuppressWarnings("unused")
 public class VisitorImpl<R> implements Visitor<R> {
   public VisitorImpl() {
     super();

File: plus/src/main/java/org/apache/calcite/adapter/os/SqlShell.java
Patch:
@@ -50,8 +50,10 @@ public class SqlShell {
   static final String MODEL = model();
 
   private final List<String> args;
+  @SuppressWarnings("unused")
   private final InputStreamReader in;
   private final PrintWriter out;
+  @SuppressWarnings("unused")
   private final PrintWriter err;
 
   SqlShell(InputStreamReader in, PrintWriter out,

File: plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
Patch:
@@ -85,7 +85,7 @@ public static ScannableTable eval(boolean b) {
                     return values;
                   }
 
-                  private Object field(String field, String value) {
+                  private Object field(@SuppressWarnings("unused") String field, String value) {
                     if (value.isEmpty()) {
                       return 0;
                     }

File: server/src/main/java/org/apache/calcite/server/MutableArrayTable.java
Patch:
@@ -40,6 +40,7 @@
 class MutableArrayTable extends AbstractModifiableTable
     implements Wrapper {
   final List rows = new ArrayList();
+  @SuppressWarnings("unused")
   private final RelProtoDataType protoStoredRowType;
   private final RelProtoDataType protoRowType;
   private final InitializerExpressionFactory initializerExpressionFactory;

File: spark/src/main/java/org/apache/calcite/adapter/spark/EnumerableToSparkConverter.java
Patch:
@@ -17,7 +17,6 @@
 package org.apache.calcite.adapter.spark;
 
 import org.apache.calcite.adapter.enumerable.EnumerableConvention;
-import org.apache.calcite.adapter.enumerable.EnumerableRel;
 import org.apache.calcite.adapter.enumerable.JavaRowFormat;
 import org.apache.calcite.adapter.enumerable.PhysType;
 import org.apache.calcite.adapter.enumerable.PhysTypeImpl;
@@ -65,8 +64,10 @@ protected EnumerableToSparkConverter(RelOptCluster cluster,
     // Generate:
     //   Enumerable source = ...;
     //   return SparkRuntime.createRdd(sparkContext, source);
+    if (true) {
+      throw new RuntimeException("EnumerableToSparkConverter is not implemented");
+    }
     final BlockBuilder list = new BlockBuilder();
-    final EnumerableRel child = (EnumerableRel) getInput();
     final PhysType physType =
         PhysTypeImpl.of(
             implementor.getTypeFactory(), getRowType(),

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
Patch:
@@ -353,6 +353,7 @@ public int getFlags() {
 
 
       Type outputJavaType = physType.getJavaRowType();
+      @SuppressWarnings("unused")
       final Type rddType =
           Types.of(
               JavaRDD.class, outputJavaType);

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
Patch:
@@ -90,6 +90,7 @@ protected SplunkDriver() {
   }
 
   /** Connection that looks up responses from a static map. */
+  @SuppressWarnings("unused")
   private static class MockSplunkConnection implements SplunkConnection {
     @Override public Enumerator<Object> getSearchResultEnumerator(String search,
         Map<String, String> otherArgs, List<String> fieldList) {
@@ -103,7 +104,9 @@ private static class MockSplunkConnection implements SplunkConnection {
   }
 
   /** Connection that records requests and responses. */
+  @SuppressWarnings("unused")
   private static class WrappingSplunkConnection implements SplunkConnection {
+    @SuppressWarnings("unused")
     private final SplunkConnection connection;
 
     WrappingSplunkConnection(SplunkConnection connection) {

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkPushDownRule.java
Patch:
@@ -296,6 +296,7 @@ protected RelNode appendSearchString(
 
   // ~ Private Methods ------------------------------------------------------
 
+  @SuppressWarnings("unused")
   private static RelNode addProjectionRule(LogicalProject proj, RelNode rel) {
     if (proj == null) {
       return rel;
@@ -379,6 +380,7 @@ private boolean valid(SqlKind kind) {
     return SUPPORTED_OPS.contains(kind);
   }
 
+  @SuppressWarnings("unused")
   private String toString(SqlOperator op) {
     if (op.equals(SqlStdOperatorTable.LIKE)) {
       return SqlStdOperatorTable.EQUALS.toString();

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraMethod.java
Patch:
@@ -30,6 +30,7 @@ public enum CassandraMethod {
   CASSANDRA_QUERYABLE_QUERY(CassandraTable.CassandraQueryable.class, "query",
       List.class, List.class, List.class, List.class, Integer.class, Integer.class);
 
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Method method;
 
   public static final ImmutableMap<Method, CassandraMethod> MAP;

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionProperty.java
Patch:
@@ -165,6 +165,7 @@ public enum CalciteConnectionProperty implements ConnectionProperty {
 
   private final String camelName;
   private final Type type;
+  @SuppressWarnings("ImmutableEnumChecker")
   private final Object defaultValue;
   private final boolean required;
   private final Class valueClass;

File: core/src/main/java/org/apache/calcite/config/Lex.java
Patch:
@@ -79,6 +79,7 @@ public enum Lex {
   public final Casing unquotedCasing;
   public final Casing quotedCasing;
   public final boolean caseSensitive;
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Set<CharLiteralStyle> charLiteralStyles;
 
   Lex(Quoting quoting,

File: core/src/main/java/org/apache/calcite/rel/hint/NodeTypeHintPredicate.java
Patch:
@@ -66,6 +66,7 @@ enum NodeType {
     CALC(Calc.class);
 
     /** Relational expression clazz that the hint can apply to. */
+    @SuppressWarnings("ImmutableEnumChecker")
     private Class<?> relClazz;
 
     NodeType(Class<?> relClazz) {

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -1118,6 +1118,7 @@ private static List<RexNode> toCaseOperands(List<CaseBranch> branches) {
   enum SafeRexVisitor implements RexVisitor<Boolean> {
     INSTANCE;
 
+    @SuppressWarnings("ImmutableEnumChecker")
     private final Set<SqlKind> safeOps;
 
     SafeRexVisitor() {

File: core/src/main/java/org/apache/calcite/runtime/Hook.java
Patch:
@@ -99,9 +99,11 @@ public enum Hook {
   @API(since = "1.22", status = API.Status.EXPERIMENTAL)
   PLAN_BEFORE_IMPLEMENTATION;
 
+  @SuppressWarnings("ImmutableEnumChecker")
   private final List<Consumer<Object>> handlers =
       new CopyOnWriteArrayList<>();
 
+  @SuppressWarnings("ImmutableEnumChecker")
   private final ThreadLocal<List<Consumer<Object>>> threadHandlers =
       ThreadLocal.withInitial(ArrayList::new);
 

File: core/src/main/java/org/apache/calcite/runtime/Resources.java
Patch:
@@ -1013,6 +1013,7 @@ void setParentTrojan(ResourceBundle parent) {
   enum BuiltinMethod {
     OBJECT_TO_STRING(Object.class, "toString");
 
+    @SuppressWarnings("ImmutableEnumChecker")
     public final Method method;
 
     BuiltinMethod(Class clazz, String methodName, Class... argumentTypes) {

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -1284,6 +1284,7 @@ public enum DatabaseProduct {
      */
     UNKNOWN("Unknown", "`", NullCollation.HIGH);
 
+    @SuppressWarnings("ImmutableEnumChecker")
     private final Supplier<SqlDialect> dialect;
 
     DatabaseProduct(String databaseProductName, String quoteString,

File: core/src/main/java/org/apache/calcite/sql/SqlFunctionCategory.java
Patch:
@@ -49,6 +49,7 @@ public enum SqlFunctionCategory {
       TABLE_FUNCTION, SPECIFIC),
   MATCH_RECOGNIZE("MATCH_RECOGNIZE", "MATCH_RECOGNIZE function", TABLE_FUNCTION);
 
+  @SuppressWarnings("ImmutableEnumChecker")
   private final EnumSet<Property> properties;
 
   SqlFunctionCategory(String abbrev, String description,

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -618,8 +618,11 @@ public enum BuiltInMethod {
       long.class),
   BIG_DECIMAL_NEGATE(BigDecimal.class, "negate");
 
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Method method;
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Constructor constructor;
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Field field;
 
   public static final ImmutableMap<Method, BuiltInMethod> MAP;

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMethod.java
Patch:
@@ -40,6 +40,7 @@ enum ElasticsearchMethod {
       Long.class, // offset
       Long.class); // fetch
 
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Method method;
 
   public static final ImmutableMap<Method, ElasticsearchMethod> MAP;

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoMethod.java
Patch:
@@ -32,6 +32,7 @@ public enum MongoMethod {
   MONGO_QUERYABLE_AGGREGATE(MongoTable.MongoQueryable.class, "aggregate",
       List.class, List.class);
 
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Method method;
 
   public static final ImmutableMap<Method, MongoMethod> MAP;

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigDataType.java
Patch:
@@ -29,8 +29,8 @@ public enum PigDataType {
 
   CHARARRAY(DataType.CHARARRAY, VARCHAR);
 
-  private byte pigType; // Pig defines types using bytes
-  private SqlTypeName sqlType;
+  private final byte pigType; // Pig defines types using bytes
+  private final SqlTypeName sqlType;
 
   PigDataType(byte pigType, SqlTypeName sqlType) {
     this.pigType = pigType;

File: redis/src/main/java/org/apache/calcite/adapter/redis/RedisDataFormat.java
Patch:
@@ -37,7 +37,7 @@ public enum RedisDataFormat {
    */
   JSON("json");
 
-  private String typeName;
+  private final String typeName;
 
   RedisDataFormat(String typeName) {
     this.typeName = typeName;

File: redis/src/main/java/org/apache/calcite/adapter/redis/RedisDataType.java
Patch:
@@ -68,7 +68,7 @@ public enum RedisDataType {
   PUBSUB("publish");
 
 
-  private String typeName;
+  private final String typeName;
 
   RedisDataType(String typeName) {
     this.typeName = typeName;

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkMethod.java
Patch:
@@ -42,6 +42,7 @@ public enum SparkMethod {
   RDD_FLAT_MAP(JavaRDD.class, "flatMap", FlatMapFunction.class),
   FLAT_MAP_FUNCTION_CALL(FlatMapFunction.class, "call", Object.class);
 
+  @SuppressWarnings("ImmutableEnumChecker")
   public final Method method;
 
   private static final HashMap<Method, SparkMethod> MAP = new HashMap<>();

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
Patch:
@@ -738,6 +738,8 @@ static JoinType toLinq4jJoinType(JoinRelType joinRelType) {
       return JoinType.SEMI;
     case ANTI:
       return JoinType.ANTI;
+    default:
+      break;
     }
     throw new IllegalStateException(
         "Unable to convert " + joinRelType + " to Linq4j JoinType");

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
Patch:
@@ -133,6 +133,9 @@ public ClassDeclaration implementRoot(EnumerableRel rootRel,
         result = new EnumerableRel.Result(bb.toBlock(), result.physType,
             JavaRowFormat.SCALAR);
       }
+      break;
+    default:
+      break;
     }
 
     final List<MemberDeclaration> memberDeclarations = new ArrayList<>();

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
Patch:
@@ -308,6 +308,8 @@ private boolean hasCollectionField(RelDataType rowType) {
       case ARRAY:
       case MULTISET:
         return true;
+      default:
+        break;
       }
     }
     return false;

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -422,6 +422,8 @@ private RelDataType sqlType(RelDataTypeFactory typeFactory, int dataType,
             typeFactory.createSqlType(SqlTypeName.ANY), true);
       }
       return typeFactory.createArrayType(component, -1);
+    default:
+      break;
     }
     if (precision >= 0
         && scale >= 0

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcUtils.java
Patch:
@@ -153,6 +153,8 @@ private Object value(int i) throws SQLException {
         return shift(resultSet.getTime(i + 1));
       case Types.DATE:
         return shift(resultSet.getDate(i + 1));
+      default:
+        break;
       }
       return reps[i].jdbcGet(resultSet, i + 1);
     }

File: core/src/main/java/org/apache/calcite/interpreter/SetOpNode.java
Patch:
@@ -80,6 +80,9 @@ public SetOpNode(Compiler compiler, SetOp setOp) {
       for (Row r : leftRows) {
         sink.send(r);
       }
+      break;
+    default:
+      break;
     }
   }
 }

File: core/src/main/java/org/apache/calcite/jdbc/Driver.java
Patch:
@@ -122,6 +122,8 @@ String model(CalciteConnectionImpl connection) {
             case MAP:
               schemaFactory = AbstractSchema.Factory.INSTANCE;
               break;
+            default:
+              break;
             }
           }
         }

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -992,6 +992,8 @@ public Column resolveColumn(Object name) {
             return resolveQualifiedColumn((String) table, (String) column);
           }
           break;
+        default:
+          break;
         }
       }
       throw new RuntimeException(

File: core/src/main/java/org/apache/calcite/model/ModelHandler.java
Patch:
@@ -321,6 +321,8 @@ protected Map<String, Object> operandMap(JsonSchema jsonSchema,
                 ((JsonCustomSchema) jsonSchema).tables);
           }
           break;
+        default:
+          break;
         }
       }
     }

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
Patch:
@@ -405,6 +405,9 @@ private void matchRecurse(int solve) {
             inputs.set(operand.ordinalInParent, rel);
             setChildRels(previous, inputs);
           }
+          break;
+        default:
+          break;
         }
 
         rels[operandOrdinal] = rel;

File: core/src/main/java/org/apache/calcite/prepare/RelOptTableImpl.java
Patch:
@@ -387,6 +387,9 @@ public static int realOrdinal(final RelOptTable table, int i) {
       switch (strategies.get(j)) {
       case VIRTUAL:
         ++n;
+        break;
+      default:
+        break;
       }
     }
     return i - n;

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -402,6 +402,9 @@ private Object toJson(RexNode node) {
         switch (node.getKind()) {
         case CAST:
           map.put("type", toJson(node.getType()));
+          break;
+        default:
+          break;
         }
         if (call.getOperator() instanceof SqlFunction) {
           if (((SqlFunction) call.getOperator()).getFunctionType().isUserDefined()) {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
Patch:
@@ -538,6 +538,8 @@ private static List<RelCollation> enumerableJoin0(RelMetadataQuery mq,
         }
       }
       return leftCollations;
+    default:
+      break;
     }
     return null;
   }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdSize.java
Patch:
@@ -242,6 +242,8 @@ public List<Double> averageColumnSizes(Union rel, RelMetadataQuery mq) {
       return null; // all were null
     case 1:
       return inputColumnSizeList.get(0); // all but one were null
+    default:
+      break;
     }
     final ImmutableNullableList.Builder<Double> sizes =
         ImmutableNullableList.builder();

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -198,6 +198,8 @@ public Result visit(Join e) {
     case ANTI:
     case SEMI:
       return visitAntiOrSemiJoin(e);
+    default:
+      break;
     }
     final Result leftResult = visitInput(e, 0).resetAlias();
     final Result rightResult = visitInput(e, 1).resetAlias();

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -416,6 +416,9 @@ private static void populateEquivalences(Map<Integer, BitSet> equivalence,
           populateEquivalence(equivalence, ref1.getIndex(), ref0.getIndex());
         }
       }
+      break;
+    default:
+      break;
     }
   }
 

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectAggregateMergeRule.java
Patch:
@@ -116,6 +116,9 @@ && kindCount(project.getProjects(), SqlKind.CASE) == 0) {
               }
             }
           }
+          break;
+        default:
+          break;
         }
         return super.visitCall(call);
       }

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -849,7 +849,10 @@ public static RexCall pushPredicateIntoCase(RexCall call) {
       if (!left.isEmpty() && !right.isEmpty() && left.intersect(right).isEmpty()) {
         return call;
       }
+      break;
     }
+    default:
+      break;
     }
     int caseOrdinal = -1;
     final List<RexNode> operands = call.getOperands();

File: core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
Patch:
@@ -96,6 +96,8 @@ public RelRecordType(List<RelDataTypeField> fields) {
     case PEEK_FIELDS_NO_EXPAND:
       sb.append(":peek_no_expand");
       break;
+    default:
+      break;
     }
     sb.append("(");
     for (Ord<RelDataTypeField> ord : Ord.zip(fieldList)) {

File: core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
Patch:
@@ -64,6 +64,8 @@ public static RexCallBinding create(RelDataTypeFactory typeFactory,
     case CAST:
       return new RexCastCallBinding(typeFactory, call.getOperator(),
           call.getOperands(), call.getType(), inputCollations);
+    default:
+      break;
     }
     return new RexCallBinding(typeFactory, call.getOperator(),
         call.getOperands(), inputCollations);

File: core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
Patch:
@@ -253,6 +253,8 @@ private Comparable ceil(RexCall call, List<Comparable> values) {
       default:
         return DateTimeUtils.unixTimestampCeil(unit, v);
       }
+    default:
+      break;
     }
     final TimeUnitRange subUnit = subUnit(unit);
     for (long v2 = v;;) {

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -1105,6 +1105,8 @@ public <T> T getValueAs(Class<T> clazz) {
         return clazz.cast(getValueAs(BigDecimal.class).signum() < 0);
       }
       break;
+    default:
+      break;
     }
     throw new AssertionError("cannot convert " + typeName
         + " literal to " + clazz);

File: core/src/main/java/org/apache/calcite/runtime/Resources.java
Patch:
@@ -388,6 +388,8 @@ public void validate(EnumSet<Validation> validations) {
                 + types + " and method parameters " + parameterTypeList);
           }
           break;
+        default:
+          break;
         }
       }
     }

File: core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
Patch:
@@ -195,6 +195,8 @@ public RelDataType getReturnType(RelDataTypeFactory typeFactory,
       break;
     case SEMI_STRICT:
       return typeFactory.createTypeWithNullability(returnType, true);
+    default:
+      break;
     }
     return returnType;
   }

File: core/src/main/java/org/apache/calcite/sql/SqlDialectFactoryImpl.java
Patch:
@@ -134,6 +134,8 @@ public class SqlDialectFactoryImpl implements SqlDialectFactory {
       return new SnowflakeSqlDialect(c);
     case "SPARK":
       return new SparkSqlDialect(c);
+    default:
+      break;
     }
     // Now the fuzzy matches.
     if (databaseProductName.startsWith("DB2")) {

File: core/src/main/java/org/apache/calcite/sql/SqlExplain.java
Patch:
@@ -179,6 +179,8 @@ public boolean isJson() {
     case ALL_ATTRIBUTES:
       writer.keyword("INCLUDING ALL ATTRIBUTES");
       break;
+    default:
+      break;
     }
     switch (getDepth()) {
     case TYPE:

File: core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
Patch:
@@ -70,6 +70,9 @@ public SqlOverOperator() {
     case IGNORE_NULLS:
       validator.validateCall(aggCall, scope);
       aggCall = aggCall.operand(0);
+      break;
+    default:
+      break;
     }
     if (!aggCall.getOperator().isAggregator()) {
       throw validator.newValidationError(aggCall, RESOURCE.overNonAggregate());

File: core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
Patch:
@@ -295,6 +295,8 @@ private TimeUnit validate(TimeUnit timeUnit) {
         return createSqlDataTypeSpecByName("TIME", typeName);
       case TIMESTAMP:
         return createSqlDataTypeSpecByName("TIMESTAMP", typeName);
+      default:
+        break;
       }
     }
     return super.getCastSpec(type);

File: core/src/main/java/org/apache/calcite/sql/dialect/ClickHouseSqlDialect.java
Patch:
@@ -93,6 +93,8 @@ public ClickHouseSqlDialect(Context context) {
       case TIMESTAMP:
       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
         return createSqlDataTypeSpecByName("DateTime", typeName);
+      default:
+        break;
       }
     }
 

File: core/src/main/java/org/apache/calcite/sql/dialect/HiveSqlDialect.java
Patch:
@@ -140,6 +140,8 @@ public HiveSqlDialect(Context context) {
         SqlAlienSystemTypeNameSpec typeNameSpec = new SqlAlienSystemTypeNameSpec(
             "INT", type.getSqlTypeName(), SqlParserPos.ZERO);
         return new SqlDataTypeSpec(typeNameSpec, SqlParserPos.ZERO);
+      default:
+        break;
       }
     }
     return super.getCastSpec(type);

File: core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
Patch:
@@ -90,6 +90,8 @@ public JethroDataSqlDialect(Context context) {
     case CASE:
     case CAST:
       return true;
+    default:
+      break;
     }
     final Set<JethroSupportedFunction> functions =
         info.supportedFunctions.get(operator.getName());

File: core/src/main/java/org/apache/calcite/sql/dialect/PrestoSqlDialect.java
Patch:
@@ -86,6 +86,8 @@ private void unparseUsingLimit(SqlWriter writer, SqlNode offset,
     case MAX:
     case ROLLUP:
       return true;
+    default:
+      break;
     }
     return false;
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlConvertFunction.java
Patch:
@@ -57,6 +57,8 @@ protected SqlConvertFunction(String name) {
     switch (operandsCount) {
     case 2:
       return "{0}({1} USING {2})";
+    default:
+      break;
     }
     assert false;
     return null;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlOverlayFunction.java
Patch:
@@ -74,6 +74,8 @@ public SqlOverlayFunction() {
       return "{0}({1} PLACING {2} FROM {3})";
     case 4:
       return "{0}({1} PLACING {2} FROM {3} FOR {4})";
+    default:
+      break;
     }
     assert false;
     return null;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
Patch:
@@ -53,6 +53,8 @@ class SqlRollupOperator extends SqlInternalOperator {
         return;
       }
       break;
+    default:
+      break;
     }
     unparseCube(writer, call);
   }

File: core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
Patch:
@@ -82,6 +82,8 @@ public class FamilyOperandTypeChecker implements SqlSingleOperandTypeChecker,
     case IGNORE:
       // no need to check
       return true;
+    default:
+      break;
     }
     if (SqlUtil.isNullLiteral(node, false)) {
       if (callBinding.isTypeCoercionEnabled()) {

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransforms.java
Patch:
@@ -107,6 +107,8 @@ public abstract class SqlTypeTransforms {
           case VARCHAR:
           case VARBINARY:
             return typeToTransform;
+          default:
+            break;
           }
 
           SqlTypeName retTypeName = toVar(typeToTransform);

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -1548,6 +1548,8 @@ private static boolean canConvertStringInCompare(RelDataTypeFamily family) {
       case INTEGER:
       case BOOLEAN:
         return true;
+      default:
+        break;
       }
     }
     return false;

File: core/src/main/java/org/apache/calcite/sql/util/ReflectiveSqlOperatorTable.java
Patch:
@@ -131,6 +131,8 @@ public final void init() {
         }
       }
       break;
+    default:
+      break;
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/AggChecker.java
Patch:
@@ -155,6 +155,8 @@ boolean isGroupExpr(SqlNode expr) {
     case IGNORE_NULLS:
       call.operand(0).accept(this);
       return null;
+    default:
+      break;
     }
     // Visit the operand in window function
     if (call.getKind() == SqlKind.OVER) {

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
Patch:
@@ -140,6 +140,9 @@ void resolveInNamespace(SqlValidatorNamespace ns, boolean nullable,
             final SqlValidatorNamespace ns2 = ns.lookupChild(field.getName());
             resolveInNamespace(ns2, nullable, names, nameMatcher, path2,
                 resolved);
+            break;
+          default:
+            break;
           }
         }
       }

File: core/src/main/java/org/apache/calcite/sql/validate/JoinNamespace.java
Patch:
@@ -55,6 +55,8 @@ class JoinNamespace extends AbstractNamespace {
       leftType = typeFactory.createTypeWithNullability(leftType, true);
       rightType = typeFactory.createTypeWithNullability(rightType, true);
       break;
+    default:
+      break;
     }
     return typeFactory.createJoinType(leftType, rightType);
   }

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -1017,6 +1017,9 @@ private void findCorrelationEquivalent(CorRef correlation, RexNode e)
       for (RexNode operand : ((RexCall) e).getOperands()) {
         findCorrelationEquivalent(correlation, operand);
       }
+      break;
+    default:
+      break;
     }
   }
 

File: core/src/main/java/org/apache/calcite/util/BitString.java
Patch:
@@ -134,6 +134,8 @@ public String toHexString() {
     case 7: // B'1000000' -> X'40'
     case 0: // B'10000000' -> X'80', and B'' -> X''
       return s;
+    default:
+      break;
     }
     if ((bitCount % 8) == 4) {
       return s.substring(1);

File: core/src/main/java/org/apache/calcite/util/ImmutableBeans.java
Patch:
@@ -222,6 +222,9 @@ private static <T> Def<T> makeDef(Class<T> beanClass) {
               + "' should return void, actually returns '"
               + method.getReturnType() + "'");
         }
+        break;
+      default:
+        break;
       }
       if (method.getParameterCount() != 1) {
         throw new IllegalArgumentException("method '" + methodName

File: core/src/main/java/org/apache/calcite/util/XmlOutput.java
Patch:
@@ -521,6 +521,8 @@ private static boolean stringHasXMLSpecials(String input) {
       case '\n':
       case '\r':
         return true;
+      default:
+        break;
       }
     }
     return false;

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
Patch:
@@ -422,6 +422,8 @@ static DruidJsonFilter toDruidFilters(RexNode rexNode, RelDataType rowType,
       }
       return new JsonCompositeFilter(Type.valueOf(rexNode.getKind().name()),
           jsonFilters);
+    default:
+      break;
     }
 
     final DruidJsonFilter simpleLeafFilter = toSimpleDruidFilter(rexNode, rowType, druidQuery);

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java
Patch:
@@ -154,6 +154,8 @@ private Datatype(final String name) {
             .atStartOfDay().toInstant(ZoneOffset.UTC).toEpochMilli();
         // by default elastic returns dates as longs
         return FACTORY.numberNode(millisEpoch);
+      default:
+        break;
       }
 
       // this is unknown type

File: example/function/src/main/java/org/apache/calcite/example/maze/Maze.java
Patch:
@@ -269,6 +269,9 @@ Set<Integer> solve(int x, int y) {
           dNext = directionStack.pop();
           from = fromStack.pop();
         } while (dNext == Direction.BACKTRACK);
+        break;
+      default:
+        break;
       }
       if (move) {
         directionStack.push(dNext);

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
Patch:
@@ -1622,6 +1622,9 @@ public static UnaryExpression makeUnary(ExpressionType expressionType,
       if (type == byte.class || type == short.class) {
         type = int.class;
       }
+      break;
+    default:
+      break;
     }
     return new UnaryExpression(expressionType, type, expression);
   }

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/UnaryExpression.java
Patch:
@@ -49,6 +49,8 @@ public class UnaryExpression extends Expression {
         expression.accept(writer, nodeType.rprec, rprec);
       }
       return;
+    default:
+      break;
     }
     if (nodeType.postfix) {
       expression.accept(writer, lprec, nodeType.rprec);

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSchemaFactory.java
Patch:
@@ -76,6 +76,8 @@ private MongoCredential createCredential(Map<String, Object> map) {
       return MongoCredential.createGSSAPICredential(username);
     case MONGODB_X509:
       return MongoCredential.createMongoX509Credential(username);
+    default:
+      break;
     }
     throw new IllegalArgumentException("Unsupported authentication mechanism "
         + authMechanismName);

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSort.java
Patch:
@@ -72,6 +72,8 @@ public MongoSort(RelOptCluster cluster, RelTraitSet traitSet,
             break;
           case LAST:
             break;
+          default:
+            break;
           }
         }
       }

File: plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
Patch:
@@ -212,6 +212,9 @@ private Enumerable<String> sourceMacOs() {
                       : type.equals("") || type.equals("*") ? "f"
                       : type.equals("@") ? "l"
                       : type;
+                  break;
+                default:
+                  break;
                 }
                 return true;
               }

File: plus/src/main/java/org/apache/calcite/adapter/os/SqlShell.java
Patch:
@@ -351,6 +351,9 @@ private void value(StringBuilder b, String s) {
           case Types.FLOAT:
           case Types.DOUBLE:
             rights[i] = true;
+            break;
+          default:
+            break;
           }
         }
         while (r.next()) {

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkPushDownRule.java
Patch:
@@ -325,6 +325,8 @@ private boolean getFilter(SqlOperator op, List<RexNode> operands,
     case LIKE:
       like = true;
       break;
+    default:
+      break;
     }
 
     for (int i = 0; i < operands.size(); i++) {

File: ubenchmark/src/jmh/java/org/apache/calcite/benchmarks/ParserBenchmark.java
Patch:
@@ -82,6 +82,8 @@ public void setup() throws SqlParseException {
           sb.append('\'').append(rnd.nextLong()).append(rnd.nextLong())
               .append('\'');
           break;
+        default:
+          break;
         }
       }
       if (comments && sb.length() < length) {

File: core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
Patch:
@@ -232,12 +232,10 @@ private static Enumerable toEnumerable(final Object o) {
   private static class ReflectiveTable
       extends AbstractQueryableTable
       implements Table, ScannableTable {
-    private final Type elementType;
     private final Enumerable enumerable;
 
     ReflectiveTable(Type elementType, Enumerable enumerable) {
       super(elementType);
-      this.elementType = elementType;
       this.enumerable = enumerable;
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
Patch:
@@ -49,6 +49,7 @@ public final class MultiJoin extends AbstractRelNode {
 
   private final List<RelNode> inputs;
   private final RexNode joinFilter;
+  @SuppressWarnings("HidingField")
   private final RelDataType rowType;
   private final boolean isFullOuterJoin;
   private final List<RexNode> outerJoinConditions;

File: core/src/main/java/org/apache/calcite/sql/validate/ParameterNamespace.java
Patch:
@@ -27,6 +27,7 @@
 class ParameterNamespace extends AbstractNamespace {
   //~ Instance fields --------------------------------------------------------
 
+  @SuppressWarnings("HidingField")
   private final RelDataType type;
 
   //~ Constructors -----------------------------------------------------------

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/NewExpression.java
Patch:
@@ -27,6 +27,7 @@
  * an anonymous class.</p>
  */
 public class NewExpression extends Expression {
+  @SuppressWarnings("HidingField")
   public final Type type;
   public final List<Expression> arguments;
   public final List<MemberDeclaration> memberDeclarations;

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/TypeBinaryExpression.java
Patch:
@@ -24,6 +24,7 @@
  */
 public class TypeBinaryExpression extends Expression {
   public final Expression expression;
+  @SuppressWarnings("HidingField")
   public final Type type;
 
   public TypeBinaryExpression(ExpressionType nodeType, Expression expression,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRelImplementor.java
Patch:
@@ -29,7 +29,7 @@
 public abstract class JavaRelImplementor implements RelImplementor {
   private final RexBuilder rexBuilder;
 
-  public JavaRelImplementor(RexBuilder rexBuilder) {
+  protected JavaRelImplementor(RexBuilder rexBuilder) {
     this.rexBuilder = rexBuilder;
     assert rexBuilder.getTypeFactory() instanceof JavaTypeFactory
         : "Type factory of rexBuilder should be a JavaTypeFactory";

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/AggAddContextImpl.java
Patch:
@@ -28,7 +28,7 @@
  */
 public abstract class AggAddContextImpl extends AggResultContextImpl
     implements AggAddContext {
-  public AggAddContextImpl(BlockBuilder block, List<Expression> accumulator) {
+  protected AggAddContextImpl(BlockBuilder block, List<Expression> accumulator) {
     super(block, null, accumulator, null, null);
   }
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/AggResetContextImpl.java
Patch:
@@ -39,7 +39,7 @@ public abstract class AggResetContextImpl extends NestedBlockBuilderImpl
    * @param accumulator Accumulator variables that store the intermediate
    *                    aggregate state
    */
-  public AggResetContextImpl(BlockBuilder block, List<Expression> accumulator) {
+  protected AggResetContextImpl(BlockBuilder block, List<Expression> accumulator) {
     super(block);
     this.accumulator = accumulator;
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggAddContextImpl.java
Patch:
@@ -33,14 +33,14 @@
  */
 public abstract class WinAggAddContextImpl extends WinAggResultContextImpl
     implements WinAggAddContext {
-  public WinAggAddContextImpl(BlockBuilder block, List<Expression> accumulator,
+  protected WinAggAddContextImpl(BlockBuilder block, List<Expression> accumulator,
       Function<BlockBuilder, WinAggFrameResultContext> frame) {
     super(block, accumulator, frame);
   }
 
   @SuppressWarnings("Guava")
   @Deprecated // to be removed before 2.0
-  public WinAggAddContextImpl(BlockBuilder block, List<Expression> accumulator,
+  protected WinAggAddContextImpl(BlockBuilder block, List<Expression> accumulator,
       com.google.common.base.Function<BlockBuilder, WinAggFrameResultContext> frame) {
     this(block, accumulator, (Function<BlockBuilder, WinAggFrameResultContext>) frame::apply);
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggResultContextImpl.java
Patch:
@@ -42,7 +42,7 @@ public abstract class WinAggResultContextImpl extends AggResultContextImpl
    * @param accumulator accumulator variables that store the intermediate
    *                    aggregate state
    */
-  public WinAggResultContextImpl(BlockBuilder block,
+  protected WinAggResultContextImpl(BlockBuilder block,
       List<Expression> accumulator,
       Function<BlockBuilder, WinAggFrameResultContext> frameContextBuilder) {
     super(block, null, accumulator, null, null);
@@ -51,7 +51,7 @@ public WinAggResultContextImpl(BlockBuilder block,
 
   @SuppressWarnings("Guava")
   @Deprecated // to be removed before 2.0
-  public WinAggResultContextImpl(BlockBuilder block,
+  protected WinAggResultContextImpl(BlockBuilder block,
       List<Expression> accumulator,
       com.google.common.base.Function<BlockBuilder, WinAggFrameResultContext> frameContextBuilder) {
     this(block, accumulator,

File: core/src/main/java/org/apache/calcite/plan/CommonRelSubExprRule.java
Patch:
@@ -34,7 +34,7 @@ protected CommonRelSubExprRule(Config config) {
   }
 
   @Deprecated // to be removed before 2.0
-  public CommonRelSubExprRule(RelOptRuleOperand operand) {
+  protected CommonRelSubExprRule(RelOptRuleOperand operand) {
     this(Config.EMPTY.withOperandSupplier(b -> b.exactly(operand))
         .as(Config.class));
   }

File: core/src/main/java/org/apache/calcite/plan/RelOptRule.java
Patch:
@@ -74,7 +74,7 @@ public abstract class RelOptRule {
    *
    * @param operand root operand, must not be null
    */
-  public RelOptRule(RelOptRuleOperand operand) {
+  protected RelOptRule(RelOptRuleOperand operand) {
     this(operand, RelFactories.LOGICAL_BUILDER, null);
   }
 
@@ -84,7 +84,7 @@ public RelOptRule(RelOptRuleOperand operand) {
    * @param operand     root operand, must not be null
    * @param description Description, or null to guess description
    */
-  public RelOptRule(RelOptRuleOperand operand, String description) {
+  protected RelOptRule(RelOptRuleOperand operand, String description) {
     this(operand, RelFactories.LOGICAL_BUILDER, description);
   }
 
@@ -95,7 +95,7 @@ public RelOptRule(RelOptRuleOperand operand, String description) {
    * @param description Description, or null to guess description
    * @param relBuilderFactory Builder for relational expressions
    */
-  public RelOptRule(RelOptRuleOperand operand,
+  protected RelOptRule(RelOptRuleOperand operand,
       RelBuilderFactory relBuilderFactory, String description) {
     this.operand = Objects.requireNonNull(operand);
     this.relBuilderFactory = Objects.requireNonNull(relBuilderFactory);

File: core/src/main/java/org/apache/calcite/plan/RelRule.java
Patch:
@@ -109,7 +109,7 @@ public abstract class RelRule<C extends RelRule.Config> extends RelOptRule {
   public final C config;
 
   /** Creates a RelRule. */
-  public RelRule(C config) {
+  protected RelRule(C config) {
     super(OperandBuilderImpl.operand(config.operandSupplier()),
         config.relBuilderFactory(), config.description());
     this.config = config;

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -988,7 +988,7 @@ assert equalType("query", call.query, "result", result,
 
   /** Abstract base class for implementing {@link UnifyRule}. */
   protected abstract static class AbstractUnifyRule extends UnifyRule {
-    public AbstractUnifyRule(Operand queryOperand, Operand targetOperand,
+    protected AbstractUnifyRule(Operand queryOperand, Operand targetOperand,
         int slotCount) {
       super(slotCount, queryOperand, targetOperand);
       //noinspection AssertWithSideEffects

File: core/src/main/java/org/apache/calcite/prepare/Prepare.java
Patch:
@@ -107,7 +107,7 @@ public abstract class Prepare {
   public static final TryThreadLocal<Boolean> THREAD_EXPAND =
       TryThreadLocal.of(false);
 
-  public Prepare(CalcitePrepare.Context context, CatalogReader catalogReader,
+  protected Prepare(CalcitePrepare.Context context, CatalogReader catalogReader,
       Convention resultConvention) {
     assert context != null;
     this.context = context;
@@ -469,7 +469,7 @@ public abstract static class PreparedExplain
     private final SqlExplainFormat format;
     private final SqlExplainLevel detailLevel;
 
-    public PreparedExplain(
+    protected PreparedExplain(
         RelDataType rowType,
         RelDataType parameterRowType,
         RelRoot root,
@@ -563,7 +563,7 @@ public abstract static class PreparedResultImpl
     protected final List<List<String>> fieldOrigins;
     protected final List<RelCollation> collations;
 
-    public PreparedResultImpl(
+    protected PreparedResultImpl(
         RelDataType rowType,
         RelDataType parameterRowType,
         List<List<String>> fieldOrigins,

File: core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
Patch:
@@ -87,7 +87,7 @@ public abstract class AbstractRelNode implements RelNode {
   /**
    * Creates an <code>AbstractRelNode</code>.
    */
-  public AbstractRelNode(RelOptCluster cluster, RelTraitSet traitSet) {
+  protected AbstractRelNode(RelOptCluster cluster, RelTraitSet traitSet) {
     super();
     assert cluster != null;
     this.cluster = cluster;

File: core/src/main/java/org/apache/calcite/rel/BiRel.java
Patch:
@@ -33,7 +33,7 @@ public abstract class BiRel extends AbstractRelNode {
   protected RelNode left;
   protected RelNode right;
 
-  public BiRel(
+  protected BiRel(
       RelOptCluster cluster, RelTraitSet traitSet, RelNode left,
       RelNode right) {
     super(cluster, traitSet);

File: core/src/main/java/org/apache/calcite/rel/core/Correlate.java
Patch:
@@ -104,7 +104,7 @@ protected Correlate(
    *
    * @param input Input representation
    */
-  public Correlate(RelInput input) {
+  protected Correlate(RelInput input) {
     this(
         input.getCluster(), input.getTraitSet(), input.getInputs().get(0),
         input.getInputs().get(1),

File: core/src/main/java/org/apache/calcite/rel/core/Exchange.java
Patch:
@@ -67,7 +67,7 @@ protected Exchange(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
   /**
    * Creates an Exchange by parsing serialized output.
    */
-  public Exchange(RelInput input) {
+  protected Exchange(RelInput input) {
     this(input.getCluster(), input.getTraitSet().plus(input.getCollation()),
         input.getInput(),
         RelDistributionTraitDef.INSTANCE.canonize(input.getDistribution()));

File: core/src/main/java/org/apache/calcite/rel/core/Intersect.java
Patch:
@@ -36,7 +36,7 @@ public abstract class Intersect extends SetOp {
   /**
    * Creates an Intersect.
    */
-  public Intersect(
+  protected Intersect(
       RelOptCluster cluster,
       RelTraitSet traits,
       List<RelNode> inputs,

File: core/src/main/java/org/apache/calcite/rel/core/Minus.java
Patch:
@@ -37,7 +37,7 @@
  * the results).
  */
 public abstract class Minus extends SetOp {
-  public Minus(RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs,
+  protected Minus(RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs,
       boolean all) {
     super(cluster, traits, inputs, SqlKind.EXCEPT, all);
   }

File: core/src/main/java/org/apache/calcite/rel/core/Sort.java
Patch:
@@ -57,7 +57,7 @@ public abstract class Sort extends SingleRel {
    * @param child     input relational expression
    * @param collation array of sort specifications
    */
-  public Sort(
+  protected Sort(
       RelOptCluster cluster,
       RelTraitSet traits,
       RelNode child,
@@ -76,7 +76,7 @@ public Sort(
    *                  first row
    * @param fetch     Expression for number of rows to fetch
    */
-  public Sort(
+  protected Sort(
       RelOptCluster cluster,
       RelTraitSet traits,
       RelNode child,
@@ -99,7 +99,7 @@ public Sort(
   /**
    * Creates a Sort by parsing serialized output.
    */
-  public Sort(RelInput input) {
+  protected Sort(RelInput input) {
     this(input.getCluster(), input.getTraitSet().plus(input.getCollation()),
         input.getInput(),
         RelCollationTraitDef.INSTANCE.canonize(input.getCollation()),

File: core/src/main/java/org/apache/calcite/rel/core/SortExchange.java
Patch:
@@ -66,7 +66,7 @@ protected SortExchange(RelOptCluster cluster, RelTraitSet traitSet,
   /**
    * Creates a SortExchange by parsing serialized output.
    */
-  public SortExchange(RelInput input) {
+  protected SortExchange(RelInput input) {
     this(input.getCluster(),
         input.getTraitSet().plus(input.getCollation())
             .plus(input.getDistribution()),

File: core/src/main/java/org/apache/calcite/rel/core/Values.java
Patch:
@@ -90,7 +90,7 @@ protected Values(
   /**
    * Creates a Values by parsing serialized output.
    */
-  public Values(RelInput input) {
+  protected Values(RelInput input) {
     this(input.getCluster(), input.getRowType("type"),
         input.getTuples("tuples"), input.getTraitSet());
   }

File: core/src/main/java/org/apache/calcite/rel/core/Window.java
Patch:
@@ -77,7 +77,7 @@ public abstract class Window extends SingleRel {
    * @param rowType Output row type
    * @param groups Windows
    */
-  public Window(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
+  protected Window(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
       List<RexLiteral> constants, RelDataType rowType, List<Group> groups) {
     super(cluster, traitSet, input);
     this.constants = ImmutableList.copyOf(constants);

File: core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
Patch:
@@ -746,7 +746,7 @@ protected List<Set<Integer>> getCohorts() {
   public abstract static class RelType {
     private final String name;
 
-    public RelType(String name) {
+    protected RelType(String name) {
       this.name = name;
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/EquiJoin.java
Patch:
@@ -34,7 +34,7 @@
  */
 @Deprecated // to be removed before 2.0
 public abstract class EquiJoin extends org.apache.calcite.rel.core.EquiJoin {
-  public EquiJoin(RelOptCluster cluster, RelTraitSet traits, RelNode left,
+  protected EquiJoin(RelOptCluster cluster, RelTraitSet traits, RelNode left,
       RelNode right, RexNode condition, ImmutableIntList leftKeys,
       ImmutableIntList rightKeys, JoinRelType joinType,
       Set<String> variablesStopped) {

File: core/src/main/java/org/apache/calcite/runtime/Resources.java
Patch:
@@ -574,7 +574,7 @@ public abstract static class Prop extends Element {
     protected final PropertyAccessor accessor;
     protected final boolean hasDefault;
 
-    public Prop(PropertyAccessor accessor, Method method) {
+    protected Prop(PropertyAccessor accessor, Method method) {
       super(method);
       this.accessor = accessor;
       final Default resource = method.getAnnotation(Default.class);

File: core/src/main/java/org/apache/calcite/schema/impl/AbstractTableQueryable.java
Patch:
@@ -42,7 +42,7 @@ public abstract class AbstractTableQueryable<T> extends AbstractQueryable<T> {
   public final QueryableTable table;
   public final String tableName;
 
-  public AbstractTableQueryable(QueryProvider queryProvider,
+  protected AbstractTableQueryable(QueryProvider queryProvider,
       SchemaPlus schema, QueryableTable table, String tableName) {
     this.queryProvider = queryProvider;
     this.schema = schema;

File: core/src/main/java/org/apache/calcite/schema/impl/ReflectiveFunctionBase.java
Patch:
@@ -46,7 +46,7 @@ public abstract class ReflectiveFunctionBase implements Function {
    *
    * @param method Method that is used to get type information from
    */
-  public ReflectiveFunctionBase(Method method) {
+  protected ReflectiveFunctionBase(Method method) {
     this.method = method;
     this.parameters = builder().addMethodParameters(method).build();
   }

File: core/src/main/java/org/apache/calcite/sql/SqlAlter.java
Patch:
@@ -28,11 +28,11 @@ public abstract class SqlAlter extends SqlCall {
   /** Scope of the operation. Values "SYSTEM" and "SESSION" are typical. */
   String scope;
 
-  public SqlAlter(SqlParserPos pos) {
+  protected SqlAlter(SqlParserPos pos) {
     this(pos, null);
   }
 
-  public SqlAlter(SqlParserPos pos, String scope) {
+  protected SqlAlter(SqlParserPos pos, String scope) {
     super(pos);
     this.scope = scope;
   }

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -40,7 +40,7 @@
 public abstract class SqlCall extends SqlNode {
   //~ Constructors -----------------------------------------------------------
 
-  public SqlCall(SqlParserPos pos) {
+  protected SqlCall(SqlParserPos pos) {
     super(pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlCreate.java
Patch:
@@ -32,15 +32,15 @@ public abstract class SqlCreate extends SqlDdl {
   public final boolean ifNotExists;
 
   /** Creates a SqlCreate. */
-  public SqlCreate(SqlOperator operator, SqlParserPos pos, boolean replace,
+  protected SqlCreate(SqlOperator operator, SqlParserPos pos, boolean replace,
       boolean ifNotExists) {
     super(operator, pos);
     this.replace = replace;
     this.ifNotExists = ifNotExists;
   }
 
   @Deprecated // to be removed before 2.0
-  public SqlCreate(SqlParserPos pos, boolean replace) {
+  protected SqlCreate(SqlParserPos pos, boolean replace) {
     this(SqlDdl.DDL_OPERATOR, pos, replace, false);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlDdl.java
Patch:
@@ -29,7 +29,7 @@ public abstract class SqlDdl extends SqlCall {
   private final SqlOperator operator;
 
   /** Creates a SqlDdl. */
-  public SqlDdl(SqlOperator operator, SqlParserPos pos) {
+  protected SqlDdl(SqlOperator operator, SqlParserPos pos) {
     super(pos);
     this.operator = Objects.requireNonNull(operator);
   }

File: core/src/main/java/org/apache/calcite/sql/SqlDrop.java
Patch:
@@ -29,13 +29,13 @@ public abstract class SqlDrop extends SqlDdl {
   public final boolean ifExists;
 
   /** Creates a SqlDrop. */
-  public SqlDrop(SqlOperator operator, SqlParserPos pos, boolean ifExists) {
+  protected SqlDrop(SqlOperator operator, SqlParserPos pos, boolean ifExists) {
     super(operator, pos);
     this.ifExists = ifExists;
   }
 
   @Deprecated // to be removed before 2.0
-  public SqlDrop(SqlParserPos pos) {
+  protected SqlDrop(SqlParserPos pos) {
     this(DDL_OPERATOR, pos, false);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlTypeNameSpec.java
Patch:
@@ -41,7 +41,7 @@ public abstract class SqlTypeNameSpec {
    * @param name Name of the type
    * @param pos  Parser position, must not be null
    */
-  public SqlTypeNameSpec(SqlIdentifier name, SqlParserPos pos) {
+  protected SqlTypeNameSpec(SqlIdentifier name, SqlParserPos pos) {
     this.typeName = name;
     this.pos = pos;
   }

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingSqlValidatorCatalogReader.java
Patch:
@@ -35,7 +35,7 @@ public abstract class DelegatingSqlValidatorCatalogReader
    *
    * @param catalogReader Parent catalog reader
    */
-  public DelegatingSqlValidatorCatalogReader(
+  protected DelegatingSqlValidatorCatalogReader(
       SqlValidatorCatalogReader catalogReader) {
     this.catalogReader = catalogReader;
   }

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingSqlValidatorTable.java
Patch:
@@ -33,7 +33,7 @@ public abstract class DelegatingSqlValidatorTable implements SqlValidatorTable {
    *
    * @param table Parent table
    */
-  public DelegatingSqlValidatorTable(SqlValidatorTable table) {
+  protected DelegatingSqlValidatorTable(SqlValidatorTable table) {
     this.table = table;
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/ListScope.java
Patch:
@@ -48,7 +48,7 @@ public abstract class ListScope extends DelegatingScope {
 
   //~ Constructors -----------------------------------------------------------
 
-  public ListScope(SqlValidatorScope parent) {
+  protected ListScope(SqlValidatorScope parent) {
     super(parent);
   }
 

File: core/src/main/java/org/apache/calcite/tools/Frameworks.java
Patch:
@@ -100,12 +100,12 @@ R apply(RelOptCluster cluster, RelOptSchema relOptSchema,
   public abstract static class PrepareAction<R>
       implements BasePrepareAction<R> {
     private final FrameworkConfig config;
-    public PrepareAction() {
+    protected PrepareAction() {
       this.config = newConfigBuilder()
           .defaultSchema(Frameworks.createRootSchema(true)).build();
     }
 
-    public PrepareAction(FrameworkConfig config) {
+    protected PrepareAction(FrameworkConfig config) {
       this.config = config;
     }
 

File: core/src/main/java/org/apache/calcite/util/mapping/AbstractSourceMapping.java
Patch:
@@ -30,7 +30,7 @@ public abstract class AbstractSourceMapping
   private final int sourceCount;
   private final int targetCount;
 
-  public AbstractSourceMapping(int sourceCount, int targetCount) {
+  protected AbstractSourceMapping(int sourceCount, int targetCount) {
     this.sourceCount = sourceCount;
     this.targetCount = targetCount;
   }

File: core/src/main/java/org/apache/calcite/util/mapping/AbstractTargetMapping.java
Patch:
@@ -30,7 +30,7 @@ public abstract class AbstractTargetMapping
   private final int sourceCount;
   private final int targetCount;
 
-  public AbstractTargetMapping(int sourceCount, int targetCount) {
+  protected AbstractTargetMapping(int sourceCount, int targetCount) {
     this.sourceCount = sourceCount;
     this.targetCount = targetCount;
   }

File: geode/src/main/java/org/apache/calcite/adapter/geode/simple/GeodeSimpleEnumerator.java
Patch:
@@ -36,7 +36,7 @@ public abstract class GeodeSimpleEnumerator<E> implements Enumerator<E> {
   private E current;
   private ClientCache clientCache;
 
-  public GeodeSimpleEnumerator(ClientCache clientCache, String regionName) {
+  protected GeodeSimpleEnumerator(ClientCache clientCache, String regionName) {
     this.clientCache = clientCache;
     QueryService queryService = clientCache.getQueryService();
     String oql = "select * from /" + regionName.trim();

File: linq4j/src/main/java/org/apache/calcite/linq4j/BaseQueryable.java
Patch:
@@ -36,7 +36,7 @@ public abstract class BaseQueryable<TSource>
   protected final Type elementType;
   protected final Expression expression;
 
-  public BaseQueryable(QueryProvider provider, Type elementType,
+  protected BaseQueryable(QueryProvider provider, Type elementType,
       Expression expression) {
     this.provider = provider;
     this.elementType = elementType;

File: linq4j/src/main/java/org/apache/calcite/linq4j/QueryProviderImpl.java
Patch:
@@ -29,7 +29,7 @@ public abstract class QueryProviderImpl implements QueryProvider {
   /**
    * Creates a QueryProviderImpl.
    */
-  public QueryProviderImpl() {
+  protected QueryProviderImpl() {
     super();
   }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/TransformedEnumerator.java
Patch:
@@ -25,7 +25,7 @@
 public abstract class TransformedEnumerator<F, E> implements Enumerator<E> {
   protected final Enumerator<F> enumerator;
 
-  public TransformedEnumerator(Enumerator<F> enumerator) {
+  protected TransformedEnumerator(Enumerator<F> enumerator) {
     this.enumerator = enumerator;
   }
 

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkRel.java
Patch:
@@ -35,7 +35,7 @@ public interface SparkRel extends RelNode {
   /** Extension to {@link JavaRelImplementor} that can handle Spark relational
    * expressions. */
   abstract class Implementor extends JavaRelImplementor {
-    public Implementor(RexBuilder rexBuilder) {
+    protected Implementor(RexBuilder rexBuilder) {
       super(rexBuilder);
     }
 

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1808,7 +1808,7 @@ private static RexShuttle getExpandShuttle(RexProgram rexProgram) {
   private static boolean implies(
       RelOptCluster cluster, RexNode cond0, RexNode cond1, RelDataType rowType) {
     RexExecutorImpl rexImpl =
-        (RexExecutorImpl) (cluster.getPlanner().getExecutor());
+        (RexExecutorImpl) cluster.getPlanner().getExecutor();
     RexImplicationChecker rexImplicationChecker =
         new RexImplicationChecker(cluster.getRexBuilder(), rexImpl, rowType);
     return rexImplicationChecker.implies(cond0, cond1);

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -729,7 +729,7 @@ public RelSubset getSubset(RelNode rel) {
   }
 
   public RelSubset getSubset(RelNode rel, RelTraitSet traits) {
-    if ((rel instanceof RelSubset) && (rel.getTraitSet().equals(traits))) {
+    if ((rel instanceof RelSubset) && rel.getTraitSet().equals(traits)) {
       return (RelSubset) rel;
     }
     RelSet set = getSet(rel);

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
Patch:
@@ -228,15 +228,15 @@ public Set<ImmutableBitSet> getUniqueKeys(Join rel, RelMetadataQuery mq,
     if ((rightUnique != null)
         && rightUnique
         && (leftSet != null)
-        && !(rel.getJoinType().generatesNullsOnLeft())) {
+        && !rel.getJoinType().generatesNullsOnLeft()) {
       retSet.addAll(leftSet);
     }
 
     // same as above except left and right are reversed
     if ((leftUnique != null)
         && leftUnique
         && (rightSet != null)
-        && !(rel.getJoinType().generatesNullsOnRight())) {
+        && !rel.getJoinType().generatesNullsOnRight()) {
       retSet.addAll(rightSet);
     }
 

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableMatch.java
Patch:
@@ -78,9 +78,9 @@ public static MutableMatch of(RelDataType rowType,
     return obj == this
         || obj instanceof MutableMatch
         && pattern.equals(((MutableMatch) obj).pattern)
-        && strictStart == (((MutableMatch) obj).strictStart)
-        && strictEnd == (((MutableMatch) obj).strictEnd)
-        && allRows == (((MutableMatch) obj).allRows)
+        && strictStart == ((MutableMatch) obj).strictStart
+        && strictEnd == ((MutableMatch) obj).strictEnd
+        && allRows == ((MutableMatch) obj).allRows
         && patternDefinitions.equals(((MutableMatch) obj).patternDefinitions)
         && measures.equals(((MutableMatch) obj).measures)
         && after.equals(((MutableMatch) obj).after)

File: core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
Patch:
@@ -813,7 +813,7 @@ private class FactorCostComparator
       if ((c1 == null) || (c2 == null)) {
         return -1;
       }
-      return (c1.isLt(c2)) ? -1 : ((c1.equals(c2)) ? 0 : 1);
+      return c1.isLt(c2) ? -1 : (c1.equals(c2) ? 0 : 1);
     }
   }
 

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
Patch:
@@ -621,7 +621,7 @@ protected boolean isValidRelNodePlan(RelNode node, RelMetadataQuery mq) {
       if (!TableScan.class.isAssignableFrom(c)
           && !Project.class.isAssignableFrom(c)
           && !Filter.class.isAssignableFrom(c)
-          && (!Join.class.isAssignableFrom(c))) {
+          && !Join.class.isAssignableFrom(c)) {
         // Skip it
         return false;
       }

File: core/src/main/java/org/apache/calcite/rex/RexToSqlNodeConverterImpl.java
Patch:
@@ -110,7 +110,7 @@ public RexToSqlNodeConverterImpl(RexSqlConvertletTable convertletTable) {
     if (SqlTypeFamily.CHARACTER.getTypeNames().contains(
         literal.getTypeName())) {
       return SqlLiteral.createCharString(
-          ((NlsString) (literal.getValue())).getValue(),
+          ((NlsString) literal.getValue()).getValue(),
           SqlParserPos.ZERO);
     }
 

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -509,7 +509,7 @@ public void unparseSqlIntervalQualifier(SqlWriter writer,
         writer.keyword("TO");
         final String end = qualifier.timeUnitRange.endUnit.name();
         if ((TimeUnit.SECOND == qualifier.timeUnitRange.endUnit)
-                && (!qualifier.useDefaultFractionalSecondPrecision())) {
+                && !qualifier.useDefaultFractionalSecondPrecision()) {
           final SqlWriter.Frame frame = writer.startFunCall(end);
           writer.print(fractionalSecondPrecision);
           writer.endList(frame);

File: core/src/main/java/org/apache/calcite/sql/SqlWindow.java
Patch:
@@ -675,7 +675,7 @@ private void validateFrameBoundary(
         if (boundVal instanceof SqlNumericLiteral) {
           final SqlNumericLiteral boundLiteral =
               (SqlNumericLiteral) boundVal;
-          if ((!boundLiteral.isExact())
+          if (!boundLiteral.isExact()
               || (boundLiteral.getScale() != 0)
               || (0 > boundLiteral.longValue(true))) {
             // true == throw if not exact (we just tested that - right?)

File: core/src/main/java/org/apache/calcite/sql/validate/SetopNamespace.java
Patch:
@@ -95,7 +95,7 @@ private SqlMonotonicity combine(SqlMonotonicity m0, SqlMonotonicity m1) {
     case EXCEPT:
       final SqlValidatorScope scope = validator.scopes.get(call);
       for (SqlNode operand : call.getOperandList()) {
-        if (!(operand.isA(SqlKind.QUERY))) {
+        if (!operand.isA(SqlKind.QUERY)) {
           throw validator.newValidationError(operand,
               RESOURCE.needQueryOp(operand.toString()));
         }

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -1840,7 +1840,7 @@ protected RemoveSingleAggregateRule(Config config) {
       Aggregate aggregate = call.rel(2);
 
       // check singleAggRel is single_value agg
-      if ((!singleAggregate.getGroupSet().isEmpty())
+      if (!singleAggregate.getGroupSet().isEmpty()
           || (singleAggregate.getAggCallList().size() != 1)
           || !(singleAggregate.getAggCallList().get(0).getAggregation()
           instanceof SqlSingleValueAggFunction)) {
@@ -1937,7 +1937,7 @@ protected RemoveCorrelationForScalarProjectRule(Config config) {
 
       // check that the agg is of the following type:
       // doing a single_value() on the entire input
-      if ((!aggregate.getGroupSet().isEmpty())
+      if (!aggregate.getGroupSet().isEmpty()
           || (aggregate.getAggCallList().size() != 1)
           || !(aggregate.getAggCallList().get(0).getAggregation()
           instanceof SqlSingleValueAggFunction)) {

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -707,7 +707,7 @@ private void flattenResultTypeOfRexCall(RexNode newExp,
     int nameIdx = 0;
     for (RelDataTypeField field : newExp.getType().getFieldList()) {
       RexNode fieldRef = rexBuilder.makeFieldAccess(newExp, field.getIndex());
-      String fieldRefName = fieldName + "$" + (nameIdx++);
+      String fieldRefName = fieldName + "$" + nameIdx++;
       if (fieldRef.getType().isStruct()) {
         flattenResultTypeOfRexCall(fieldRef, fieldRefName, flattenedExps);
       } else {
@@ -736,7 +736,7 @@ private boolean isConstructor(RexNode rexNode) {
     }
     RexCall call = (RexCall) rexNode;
     return call.getOperator().getName().equalsIgnoreCase("row")
-        || (call.isA(SqlKind.NEW_SPECIFICATION));
+        || call.isA(SqlKind.NEW_SPECIFICATION);
   }
 
   public void rewriteRel(TableScan rel) {

File: core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
Patch:
@@ -387,14 +387,14 @@ public boolean isValid(boolean fail) {
     // Every node's parents list it as a child.
     for (Node<E> node : map.values()) {
       if ((node == topNode)
-          != (node.parentList.isEmpty())) {
+          != node.parentList.isEmpty()) {
         assert !fail
             : "only top node should have no parents " + node
             + ", parents " + node.parentList;
         return false;
       }
       if ((node == bottomNode)
-          != (node.childList.isEmpty())) {
+          != node.childList.isEmpty()) {
         assert !fail
             : "only bottom node should have no children " + node
             + ", children " + node.childList;

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -1322,7 +1322,7 @@ public static String rtrim(String s) {
       if (s.charAt(n) != ' ') {
         return s;
       }
-      while ((--n) >= 0) {
+      while (--n >= 0) {
         if (s.charAt(n) != ' ') {
           return s.substring(0, n + 1);
         }

File: file/src/main/java/org/apache/calcite/adapter/file/JsonEnumerator.java
Patch:
@@ -94,7 +94,7 @@ static JsonDataConverter deduceRowType(RelDataTypeFactory typeFactory, Source so
       //noinspection unchecked
       list = (List<Object>) jsonObj;
       //noinspection unchecked
-      jsonFieldMap = (LinkedHashMap) (list.get(0));
+      jsonFieldMap = (LinkedHashMap) list.get(0);
     } else if (jsonObj instanceof Map) {
       //noinspection unchecked
       jsonFieldMap = (LinkedHashMap) jsonObj;

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
Patch:
@@ -488,7 +488,7 @@ public String newName(String suggestion) {
     int i = 0;
     String candidate = suggestion;
     while (hasVariable(candidate)) {
-      candidate = suggestion + (i++);
+      candidate = suggestion + i++;
     }
     return candidate;
   }

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -228,7 +228,7 @@ public RelDataType validateImpl(RelDataType targetRowType) {
       final String fieldName = field.getName();
       final SqlMonotonicity monotonicity =
           resolvedNamespace.getMonotonicity(fieldName);
-      if (monotonicity != SqlMonotonicity.NOT_MONOTONIC) {
+      if (monotonicity != null && monotonicity != SqlMonotonicity.NOT_MONOTONIC) {
         builder.add(
             Pair.of((SqlNode) new SqlIdentifier(fieldName, SqlParserPos.ZERO),
                 monotonicity));

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableBatchNestedLoopJoin.java
Patch:
@@ -162,7 +162,7 @@ public static EnumerableBatchNestedLoopJoin create(
     ParameterExpression corrArg;
     final ParameterExpression corrArgList =
         Expressions.parameter(Modifier.FINAL,
-            List.class, "corrList");
+            List.class, "corrList" + this.getId());
 
     // Declare batchSize correlation variables
     if (!Primitive.is(corrVarType)) {

File: babel/src/test/java/org/apache/calcite/test/BabelParserTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.sql.parser.SqlParserImplFactory;
 import org.apache.calcite.sql.parser.SqlParserTest;
-import org.apache.calcite.sql.parser.SqlParserUtil;
+import org.apache.calcite.sql.parser.StringAndPos;
 import org.apache.calcite.sql.parser.babel.SqlBabelParserImpl;
 import org.apache.calcite.tools.Hoist;
 
@@ -207,7 +207,7 @@ class BabelParserTest extends SqlParserTest {
   @Override protected Tester getTester() {
     return new TesterImpl() {
       @Override protected void checkEx(String expectedMsgPattern,
-          SqlParserUtil.StringAndPos sap, Throwable thrown) {
+          StringAndPos sap, Throwable thrown) {
         if (thrownByBabelTest(thrown)) {
           super.checkEx(expectedMsgPattern, sap, thrown);
         } else {
@@ -227,7 +227,7 @@ private boolean thrownByBabelTest(Throwable ex) {
         return false;
       }
 
-      private void checkExNotNull(SqlParserUtil.StringAndPos sap,
+      private void checkExNotNull(StringAndPos sap,
           Throwable thrown) {
         if (thrown == null) {
           throw new AssertionError("Expected query to throw exception, "

File: core/src/test/java/org/apache/calcite/sql/test/SqlTests.java
Patch:
@@ -21,6 +21,7 @@
 import org.apache.calcite.runtime.CalciteContextException;
 import org.apache.calcite.sql.parser.SqlParseException;
 import org.apache.calcite.sql.parser.SqlParserUtil;
+import org.apache.calcite.sql.parser.StringAndPos;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TestUtil;
 import org.apache.calcite.util.Util;
@@ -336,7 +337,7 @@ public static void compareResultSetWithDelta(
    */
   public static void checkEx(Throwable ex,
       String expectedMsgPattern,
-      SqlParserUtil.StringAndPos sap,
+      StringAndPos sap,
       Stage stage) {
     if (null == ex) {
       if (expectedMsgPattern == null) {
@@ -436,7 +437,7 @@ public static void checkEx(Throwable ex,
           + " col " + actualColumn + "]");
     }
 
-    String sqlWithCarets;
+    final String sqlWithCarets;
     if (actualColumn <= 0
         || actualLine <= 0
         || actualEndColumn <= 0

File: core/src/test/java/org/apache/calcite/test/SqlAdvisorJdbcTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.schema.impl.AbstractSchema;
 import org.apache.calcite.sql.advise.SqlAdvisorGetHintsFunction;
 import org.apache.calcite.sql.advise.SqlAdvisorGetHintsFunction2;
-import org.apache.calcite.sql.parser.SqlParserUtil;
+import org.apache.calcite.sql.parser.StringAndPos;
 
 import org.junit.jupiter.api.Test;
 
@@ -69,7 +69,7 @@ private void adviseSql(int apiVersion, String sql, Consumer<ResultSet> checker)
     }
 
     PreparedStatement ps = connection.prepareStatement(getHintsSql);
-    SqlParserUtil.StringAndPos sap = SqlParserUtil.findPos(sql);
+    StringAndPos sap = StringAndPos.of(sql);
     ps.setString(1, sap.sql);
     ps.setInt(2, sap.cursor);
     final ResultSet resultSet = ps.executeQuery();

File: core/src/test/java/org/apache/calcite/test/SqlTestGen.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.test;
 
 import org.apache.calcite.sql.SqlCollation;
+import org.apache.calcite.sql.parser.StringAndPos;
 import org.apache.calcite.sql.test.SqlTestFactory;
 import org.apache.calcite.sql.test.SqlTester;
 import org.apache.calcite.sql.test.SqlValidatorTester;
@@ -100,14 +101,14 @@ private SqlValidatorSpooler(PrintWriter pw) {
     public SqlTester getTester() {
       return new SqlValidatorTester(SPOOLER_VALIDATOR) {
         public void assertExceptionIsThrown(
-            String sql,
+            StringAndPos sap,
             String expectedMsgPattern) {
           if (expectedMsgPattern == null) {
             // This SQL statement is supposed to succeed.
             // Generate it to the file, so we can see what
             // output it produces.
             pw.println("-- " /* + getName() */);
-            pw.println(sql);
+            pw.println(sap);
             pw.println(";");
           } else {
             // Do nothing. We know that this fails the validator

File: core/src/main/java/org/apache/calcite/rel/type/RelDataType.java
Patch:
@@ -223,7 +223,7 @@ RelDataTypeField getField(String fieldName, boolean caseSensitive,
    * Gets a canonical object representing the family of this type. Two values
    * can be compared if and only if their types are in the same family.
    *
-   * @return canonical object representing type family
+   * @return canonical object representing type family, never null
    */
   RelDataTypeFamily getFamily();
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCastFunction.java
Patch:
@@ -145,8 +145,7 @@ public boolean checkOperandTypes(
     }
     RelDataType validatedNodeType =
         callBinding.getValidator().getValidatedNodeType(left);
-    RelDataType returnType =
-        callBinding.getValidator().deriveType(callBinding.getScope(), right);
+    RelDataType returnType = SqlTypeUtil.deriveType(callBinding, right);
     if (!SqlTypeUtil.canCastFrom(returnType, validatedNodeType, true)) {
       if (throwOnFailure) {
         throw callBinding.newError(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlDotOperator.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;
 import org.apache.calcite.sql.type.SqlTypeFamily;
 import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.calcite.sql.type.SqlTypeUtil;
 import org.apache.calcite.sql.util.SqlBasicVisitor;
 import org.apache.calcite.sql.util.SqlVisitor;
 import org.apache.calcite.sql.validate.SqlValidator;
@@ -137,8 +138,7 @@ public void validateCall(
       boolean throwOnFailure) {
     final SqlNode left = callBinding.operand(0);
     final SqlNode right = callBinding.operand(1);
-    final RelDataType type =
-        callBinding.getValidator().deriveType(callBinding.getScope(), left);
+    final RelDataType type = SqlTypeUtil.deriveType(callBinding, left);
     if (type.getSqlTypeName() != SqlTypeName.ROW) {
       return false;
     } else if (type.getSqlIdentifier().isStar()) {

File: core/src/main/java/org/apache/calcite/sql/type/InferTypes.java
Patch:
@@ -44,8 +44,7 @@ private InferTypes() {}
             callBinding.getValidator().getUnknownType();
         RelDataType knownType = unknownType;
         for (SqlNode operand : callBinding.operands()) {
-          knownType = callBinding.getValidator().deriveType(
-              callBinding.getScope(), operand);
+          knownType = SqlTypeUtil.deriveType(callBinding, operand);
           if (!knownType.equals(unknownType)) {
             break;
           }

File: core/src/main/java/org/apache/calcite/sql/SqlTumbleTableFunction.java
Patch:
@@ -59,7 +59,7 @@ private static class OperandMetadataImpl extends AbstractOperandMetadata {
     }
 
     @Override public String getAllowedSignatures(SqlOperator op, String opName) {
-      return opName + "(TABLE table_name, DESCRIPTOR(col1, col2 ...), datetime interval"
+      return opName + "(TABLE table_name, DESCRIPTOR(timecol), datetime interval"
           + "[, datetime interval])";
     }
   }

File: core/src/main/java/org/apache/calcite/rel/type/RelDataType.java
Patch:
@@ -187,7 +187,7 @@ RelDataTypeField getField(String fieldName, boolean caseSensitive,
   /**
    * Gets the {@link SqlTypeName} of this type.
    *
-   * @return SqlTypeName, or null if this is not an SQL predefined type
+   * @return SqlTypeName, never null
    */
   SqlTypeName getSqlTypeName();
 

File: core/src/main/java/org/apache/calcite/sql/SqlHopTableFunction.java
Patch:
@@ -48,6 +48,9 @@ private static class OperandMetadataImpl extends AbstractOperandMetadata {
       if (!checkTableAndDescriptorOperands(callBinding, 1)) {
         return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);
       }
+      if (!checkTimeColumnDescriptorOperand(callBinding, 1)) {
+        return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);
+      }
       if (!checkIntervalOperands(callBinding, 2)) {
         return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);
       }

File: core/src/main/java/org/apache/calcite/sql/SqlTumbleTableFunction.java
Patch:
@@ -49,6 +49,9 @@ private static class OperandMetadataImpl extends AbstractOperandMetadata {
       if (!checkTableAndDescriptorOperands(callBinding, 1)) {
         return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);
       }
+      if (!checkTimeColumnDescriptorOperand(callBinding, 1)) {
+        return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);
+      }
       if (!checkIntervalOperands(callBinding, 2)) {
         return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);
       }

File: core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java
Patch:
@@ -740,7 +740,7 @@ public interface Config extends RelRule.Config {
         return new SubsetRule(this);
       }
 
-      @ImmutableBeans.Property
+      @ImmutableBeans.Property(makeImmutable = false)
       List<String> buf();
 
       /** Sets {@link #buf()}. */
@@ -782,7 +782,7 @@ public interface Config extends RelRule.Config {
         return new PhysSingleSubsetRule(this);
       }
 
-      @ImmutableBeans.Property
+      @ImmutableBeans.Property(makeImmutable = false)
       List<String> buf();
 
       /** Sets {@link #buf()}. */

File: babel/src/test/java/org/apache/calcite/test/BabelParserTest.java
Patch:
@@ -227,7 +227,8 @@ private boolean thrownByBabelTest(Throwable ex) {
         return false;
       }
 
-      private void checkExNotNull(SqlParserUtil.StringAndPos sap, Throwable thrown) {
+      private void checkExNotNull(SqlParserUtil.StringAndPos sap,
+          Throwable thrown) {
         if (thrown == null) {
           throw new AssertionError("Expected query to throw exception, "
               + "but it did not; query [" + sap.sql

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -673,7 +673,7 @@ protected static <T> List<T> plus(List<T>... lists) {
     assertSimplify(sql, "SELECT ax _suggest_ FROM ( SELECT * FROM dummy a )");
   }
 
-  @Test void testSimlifySubQueryStar() {
+  @Test void testSimplifySubQueryStar() {
     String sql;
     sql = "select ax^ from (select (select * from dummy) axc from dummy a)";
     assertSimplify(sql,
@@ -697,7 +697,7 @@ protected static <T> List<T> plus(List<T>... lists) {
     assertSimplify(sql, "SELECT _suggest_ FROM ( SELECT a.x + b.y FROM dummy a , dummy b )");
   }
 
-  @Test void testSimlifySubQueryMultipleFrom() {
+  @Test void testSimplifySubQueryMultipleFrom() {
     String sql;
     // "dummy b" should be removed
     sql = "select axc from (select (select ^ from dummy) axc from dummy a), dummy b";
@@ -710,7 +710,7 @@ protected static <T> List<T> plus(List<T>... lists) {
         "SELECT * FROM ( SELECT ( SELECT _suggest_ FROM dummy ) axc FROM dummy a )");
   }
 
-  @Test void testSimlifyMinus() {
+  @Test void testSimplifyMinus() {
     String sql;
     sql = "select ^ from dummy a minus select * from dummy b";
     assertSimplify(sql, "SELECT _suggest_ FROM dummy a");

File: core/src/main/java/org/apache/calcite/plan/RelOptPredicateList.java
Patch:
@@ -217,10 +217,11 @@ public boolean isEffectivelyNotNull(RexNode e) {
       }
     }
     if (SqlKind.COMPARISON.contains(e.getKind())) {
-      // A comparison with a literal, such as 'ref < 10', is not null if 'ref'
+      // A comparison with a (non-null) literal, such as 'ref < 10', is not null if 'ref'
       // is not null.
       RexCall call = (RexCall) e;
-      if (call.getOperands().get(1) instanceof RexLiteral) {
+      if (call.getOperands().get(1) instanceof RexLiteral
+          && !((RexLiteral) call.getOperands().get(1)).isNull()) {
         return isEffectivelyNotNull(call.getOperands().get(0));
       }
     }

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
Patch:
@@ -143,16 +143,17 @@ private static void getFieldRecurse(List<Slot> slots, RelDataType type,
   }
 
   public List<RelDataTypeField> getFieldList() {
-    assert isStruct();
+    assert fieldList != null : "fieldList must not be null, type = " + this;
     return fieldList;
   }
 
   public List<String> getFieldNames() {
+    assert fieldList != null : "fieldList must not be null, type = " + this;
     return Pair.left(fieldList);
   }
 
   public int getFieldCount() {
-    assert isStruct() : this;
+    assert fieldList != null : "fieldList must not be null, type = " + this;
     return fieldList.size();
   }
 

File: core/src/test/java/org/apache/calcite/test/SqlToRelTestBase.java
Patch:
@@ -115,7 +115,8 @@ protected Tester createTester() {
         c.withTrimUnusedFields(true)
             .withExpand(true)
             .addRelBuilderConfigTransform(b ->
-                b.withPruneInputOfAggregate(false)));
+                b.withAggregateUnique(true)
+                    .withPruneInputOfAggregate(false)));
   }
 
   protected Tester getTesterWithDynamicTable() {

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
Patch:
@@ -384,9 +384,8 @@ public AggCall aggregateCall(SqlAggFunction aggFunction, String alias, RexNode..
    * @return This builder
    */
   public RelBuilder cogroup(Iterable<? extends GroupKey> groupKeys) {
-    @SuppressWarnings("unchecked") final List<GroupKeyImpl> groupKeyList =
-        ImmutableList.copyOf((Iterable) groupKeys);
-    final int groupCount = groupKeyList.get(0).nodes.size();
+    final List<GroupKey> groupKeyList = ImmutableList.copyOf(groupKeys);
+    final int groupCount = groupKeyList.get(0).groupKeyCount();
 
     // Pull out all relations needed for the group
     final int numRels = groupKeyList.size();

File: core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
Patch:
@@ -201,9 +201,9 @@ public void invalidateMetadataQuery() {
    * <p>Use <code>RelOptNode.getCluster().getHintStrategies()</code> to fetch
    * the hint strategies.
    *
-   * <p>Note that this method is only for internal use, the cluster {@code hintStrategies}
+   * <p>Note that this method is only for internal use; the cluster {@code hintStrategies}
    * would be always set up with the instance configured by
-   * {@link org.apache.calcite.sql2rel.SqlToRelConverter.ConfigBuilder}.
+   * {@link org.apache.calcite.sql2rel.SqlToRelConverter.Config}.
    *
    * @param hintStrategies The specified hint strategies to override the default one(empty)
    */

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -82,8 +82,8 @@ void populate(Materialization materialization) {
     } catch (SqlParseException e) {
       throw new RuntimeException("parse failed", e);
     }
-    final SqlToRelConverter.Config config = SqlToRelConverter.configBuilder()
-        .withTrimUnusedFields(true).build();
+    final SqlToRelConverter.Config config =
+        SqlToRelConverter.config().withTrimUnusedFields(true);
     SqlToRelConverter sqlToRelConverter2 =
         getSqlToRelConverter(getSqlValidator(), catalogReader, config);
 

File: core/src/main/java/org/apache/calcite/tools/Frameworks.java
Patch:
@@ -237,7 +237,7 @@ private ConfigBuilder() {
       context = Contexts.empty();
       parserConfig = SqlParser.Config.DEFAULT;
       sqlValidatorConfig = SqlValidator.Config.DEFAULT;
-      sqlToRelConverterConfig = SqlToRelConverter.Config.DEFAULT;
+      sqlToRelConverterConfig = SqlToRelConverter.config();
       typeSystem = RelDataTypeSystem.DEFAULT;
       evolveLattice = false;
       statisticProvider = QuerySqlStatisticProvider.SILENT_CACHING_INSTANCE;

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -3215,9 +3215,8 @@ default ConfigBuilder toBuilder() {
     /** Sets {@link #pruneInputOfAggregate}. */
     Config withPruneInputOfAggregate(boolean pruneInputOfAggregate);
 
-    /** Whether to push down join conditions; default false (but see
-     * {@link SqlToRelConverter.ConfigBuilder#withPushJoinCondition(boolean)},
-     * default true). */
+    /** Whether to push down join conditions; default false (but
+     * {@link SqlToRelConverter#config()} by default sets this to true). */
     @ImmutableBeans.Property
     @ImmutableBeans.BooleanDefault(false)
     boolean pushJoinCondition();

File: core/src/test/java/org/apache/calcite/rel/logical/ToLogicalConverterTest.java
Patch:
@@ -75,9 +75,7 @@ class ToLogicalConverterTest {
           EnumerableRules.TO_INTERPRETER);
 
   private static final SqlToRelConverter.Config DEFAULT_REL_CONFIG =
-      SqlToRelConverter.configBuilder()
-          .withTrimUnusedFields(false)
-          .build();
+      SqlToRelConverter.config().withTrimUnusedFields(false);
 
   private static FrameworkConfig frameworkConfig() {
     final SchemaPlus rootSchema = Frameworks.createRootSchema(true);

File: core/src/test/java/org/apache/calcite/test/AbstractMaterializedViewTest.java
Patch:
@@ -184,11 +184,10 @@ private RelNode toRel(RelOptCluster cluster, SchemaPlus rootSchema,
     final SqlValidator validator = new ValidatorForTest(SqlStdOperatorTable.instance(),
         catalogReader, new JavaTypeFactoryImpl(), SqlConformanceEnum.DEFAULT);
     final SqlNode validated = validator.validate(parsed);
-    final SqlToRelConverter.Config config = SqlToRelConverter.configBuilder()
+    final SqlToRelConverter.Config config = SqlToRelConverter.config()
         .withTrimUnusedFields(true)
         .withExpand(true)
-        .withDecorrelationEnabled(true)
-        .build();
+        .withDecorrelationEnabled(true);
     final SqlToRelConverter converter = new SqlToRelConverter(
         (rowType, queryString, schemaPath, viewPath) -> {
           throw new UnsupportedOperationException("cannot expand view");

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -928,4 +928,7 @@ ExInst<CalciteException> invalidTypesForComparison(String clazzName0, String op,
 
   @BaseMessage("Invalid input for EXTRACTVALUE: xml: ''{0}'', xpath expression: ''{1}''")
   ExInst<CalciteException> invalidInputForExtractValue(String xml, String xpath);
+
+  @BaseMessage("Different length for bitwise operands: the first: {0,number,#}, the second: {1,number,#}")
+  ExInst<CalciteException> differentLengthForBitwiseOperands(int l0, int l1);
 }

File: core/src/main/java/org/apache/calcite/sql/SqlAggFunction.java
Patch:
@@ -103,7 +103,7 @@ protected SqlAggFunction(
       boolean requiresOver,
       Optionality requiresGroupOrder) {
     super(name, sqlIdentifier, kind, returnTypeInference, operandTypeInference,
-        operandTypeChecker, null, funcType);
+        operandTypeChecker, funcType);
     this.requiresOrder = requiresOrder;
     this.requiresOver = requiresOver;
     this.requiresGroupOrder = Objects.requireNonNull(requiresGroupOrder);

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -522,7 +522,8 @@ public RelDataType deriveType(
     // Always disable type coercion for builtin operator operands,
     // they are handled by the TypeCoercion specifically.
     final SqlOperator sqlOperator =
-        SqlUtil.lookupRoutine(validator.getOperatorTable(), getNameAsId(),
+        SqlUtil.lookupRoutine(validator.getOperatorTable(),
+            validator.getTypeFactory(), getNameAsId(),
             argTypes, null, null, getSyntax(), getKind(),
             validator.getCatalogReader().nameMatcher(), false);
 

File: core/src/main/java/org/apache/calcite/sql/type/ExplicitOperandTypeChecker.java
Patch:
@@ -24,17 +24,18 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Parameter type-checking strategy for Explicit Type.
  */
 public class ExplicitOperandTypeChecker implements SqlOperandTypeChecker {
   //~ Methods ----------------------------------------------------------------
 
-  private RelDataType type;
+  private final RelDataType type;
 
   public ExplicitOperandTypeChecker(RelDataType type) {
-    this.type = type;
+    this.type = Objects.requireNonNull(type);
   }
 
   public boolean isOptional(int i) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
Patch:
@@ -804,7 +804,6 @@ static Expression tumblingWindowSelector(
       expressions.add(expression);
     }
     final Expression wmColExprToLong = EnumUtils.convert(wmColExpr, long.class);
-    final Expression shiftExpr = Expressions.constant(1, long.class);
 
     // Find the fixed window for a timestamp given a window size and an offset, and return the
     // window start.

File: core/src/main/java/org/apache/calcite/sql/SqlInternalOperator.java
Patch:
@@ -74,8 +74,8 @@ public SqlInternalOperator(
 
   //~ Methods ----------------------------------------------------------------
 
-  public SqlSyntax getSyntax() {
-    return SqlSyntax.FUNCTION;
+  @Override public SqlSyntax getSyntax() {
+    return SqlSyntax.INTERNAL;
   }
 
   @Override public RelDataType deriveType(SqlValidator validator,

File: core/src/main/java/org/apache/calcite/sql/type/InferTypes.java
Patch:
@@ -22,6 +22,7 @@
 
 import com.google.common.collect.ImmutableList;
 
+import java.util.Arrays;
 import java.util.List;
 
 /**
@@ -55,9 +56,7 @@ private InferTypes() {}
         // unknown types for incomplete expressions.
         // Maybe we need to distinguish the two kinds of unknown.
         //assert !knownType.equals(unknownType);
-        for (int i = 0; i < operandTypes.length; ++i) {
-          operandTypes[i] = knownType;
-        }
+        Arrays.fill(operandTypes, knownType);
       };
 
   /**

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -3768,7 +3768,7 @@ private Tester getExtendedTester() {
   /** Test case for:
    * <a href="https://issues.apache.org/jira/browse/CALCITE-3310">[CALCITE-3310]
    * Approximate and exact aggregate calls are recognized as the same
-   * during sql-to-rel conversion.</a>.
+   * during sql-to-rel conversion</a>.
    */
   @Test void testProjectApproximateAndExactAggregates() {
     final String sql = "SELECT empno, count(distinct ename),\n"

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
Patch:
@@ -583,7 +583,7 @@ private List<RelDataType> partitionByCharacter(List<RelDataType> types) {
     List<RelDataType> nonCharacterTypes = new ArrayList<>();
 
     for (RelDataType tp : types) {
-      if (SqlTypeUtil.hasCharactor(tp)) {
+      if (SqlTypeUtil.hasCharacter(tp)) {
         withCharacterTypes.add(tp);
       } else {
         nonCharacterTypes.add(tp);

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -2634,7 +2634,7 @@ public final Sql sql(String sql) {
   }
 
   @Test void testReduceConstExpr() {
-    final String sql = "select sum(case when 'y' = 'n' then ename else 1 end) from emp";
+    final String sql = "select sum(case when 'y' = 'n' then ename else 0.1 end) from emp";
     sql(sql).ok();
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperatorTableFactory.java
Patch:
@@ -86,8 +86,8 @@ private SqlOperatorTable create(ImmutableSet<SqlLibrary> librarySet) {
         break;
       case SPATIAL:
         list.addAll(
-            CalciteCatalogReader.operatorTable(GeoFunctions.class.getName())
-                .getOperatorList());
+            CalciteCatalogReader.operatorTable(GeoFunctions.class.getName(),
+                SqlGeoFunctions.class.getName()).getOperatorList());
         break;
       default:
         custom = true;

File: core/src/main/java/org/apache/calcite/model/ModelHandler.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.schema.AggregateFunction;
+import org.apache.calcite.schema.Function;
 import org.apache.calcite.schema.ScalarFunction;
 import org.apache.calcite.schema.Schema;
 import org.apache.calcite.schema.SchemaFactory;
@@ -145,8 +146,8 @@ public static void addFunctions(SchemaPlus schema, String functionName,
       return;
     }
     if (methodName != null && methodName.equals("*")) {
-      for (Map.Entry<String, ScalarFunction> entry
-          : ScalarFunctionImpl.createAll(clazz).entries()) {
+      for (Map.Entry<String, Function> entry
+          : ScalarFunctionImpl.functions(clazz).entries()) {
         String name = entry.getKey();
         if (upCase) {
           name = name.toUpperCase(Locale.ROOT);

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -554,6 +554,9 @@ ExInst<SqlValidatorException> argumentMustBeValidPrecision(String a0, int a1,
   ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
       String a1, String a2);
 
+  @BaseMessage("Cannot call table function here: ''{0}''")
+  ExInst<CalciteException> cannotCallTableFunctionHere(String a0);
+
   @BaseMessage("''{0}'' is not a valid datetime format")
   ExInst<CalciteException> invalidDatetimeFormat(String a0);
 

File: core/src/main/java/org/apache/calcite/sql/SqlAsOperator.java
Patch:
@@ -51,7 +51,7 @@ public SqlAsOperator() {
         true,
         ReturnTypes.ARG0,
         InferTypes.RETURN_TYPE,
-        OperandTypes.ANY_ANY);
+        OperandTypes.ANY_IGNORE);
   }
 
   protected SqlAsOperator(String name, SqlKind kind, int prec,

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -120,6 +120,9 @@ public enum SqlKind {
   /** A literal. */
   LITERAL,
 
+  /** Interval qualifier. */
+  INTERVAL_QUALIFIER,
+
   /**
    * Function that is not a special function.
    *

File: core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
Patch:
@@ -52,7 +52,7 @@ public SqlOverOperator() {
         true,
         ReturnTypes.ARG0_FORCE_NULLABLE,
         null,
-        OperandTypes.ANY_ANY);
+        OperandTypes.ANY_IGNORE);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlWithinGroupOperator.java
Patch:
@@ -38,7 +38,7 @@ public class SqlWithinGroupOperator extends SqlBinaryOperator {
 
   public SqlWithinGroupOperator() {
     super("WITHIN GROUP", SqlKind.WITHIN_GROUP, 100, true, ReturnTypes.ARG0,
-        null, OperandTypes.ANY_ANY);
+        null, OperandTypes.ANY_IGNORE);
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
@@ -48,7 +48,7 @@ public SqlWithinGroupOperator() {
     final SqlWriter.Frame orderFrame =
         writer.startList(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, "(", ")");
     writer.keyword("ORDER BY");
-    ((SqlNodeList) call.operand(1)).unparse(writer, 0, 0);
+    call.operand(1).unparse(writer, 0, 0);
     writer.endList(orderFrame);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlArgumentAssignmentOperator.java
Patch:
@@ -37,7 +37,7 @@
 class SqlArgumentAssignmentOperator extends SqlAsOperator {
   SqlArgumentAssignmentOperator() {
     super("=>", SqlKind.ARGUMENT_ASSIGNMENT, 20, true, ReturnTypes.ARG0,
-        InferTypes.RETURN_TYPE, OperandTypes.ANY_ANY);
+        InferTypes.RETURN_TYPE, OperandTypes.ANY_IGNORE);
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCollectionTableOperator.java
Patch:
@@ -37,7 +37,7 @@ public class SqlCollectionTableOperator extends SqlFunctionalOperator {
 
   public SqlCollectionTableOperator(String name, SqlModality modality) {
     super(name, SqlKind.COLLECTION_TABLE, 200, true, ReturnTypes.ARG0, null,
-        OperandTypes.ANY);
+        OperandTypes.CURSOR);
     this.modality = modality;
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -2480,8 +2480,7 @@ protected void convertCollectionTable(
     if (operator instanceof SqlUserDefinedTableMacro) {
       final SqlUserDefinedTableMacro udf =
           (SqlUserDefinedTableMacro) operator;
-      final TranslatableTable table =
-          udf.getTable(typeFactory, callBinding.operands());
+      final TranslatableTable table = udf.getTable(callBinding);
       final RelDataType rowType = table.getRowType(typeFactory);
       RelOptTable relOptTable = RelOptTableImpl.create(null, rowType, table,
           udf.getNameAsId().names);
@@ -2493,7 +2492,7 @@ protected void convertCollectionTable(
     Type elementType;
     if (operator instanceof SqlUserDefinedTableFunction) {
       SqlUserDefinedTableFunction udtf = (SqlUserDefinedTableFunction) operator;
-      elementType = udtf.getElementType(typeFactory, callBinding.operands());
+      elementType = udtf.getElementType(callBinding);
     } else {
       elementType = null;
     }

File: example/function/src/test/java/org/apache/calcite/test/ExampleFunctionTest.java
Patch:
@@ -75,7 +75,7 @@ class ExampleFunctionTest {
   }
 
   public void checkMazeTableFunction(Boolean solution, String maze)
-      throws SQLException, ClassNotFoundException {
+      throws SQLException {
     Connection connection = DriverManager.getConnection("jdbc:calcite:");
     CalciteConnection calciteConnection =
         connection.unwrap(CalciteConnection.class);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCoalesceFunction.java
Patch:
@@ -45,8 +45,7 @@ public SqlCoalesceFunction() {
     // strategies are used.
     super("COALESCE",
         SqlKind.COALESCE,
-        ReturnTypes.cascade(ReturnTypes.LEAST_RESTRICTIVE,
-            SqlTypeTransforms.LEAST_NULLABLE),
+        ReturnTypes.LEAST_RESTRICTIVE.andThen(SqlTypeTransforms.LEAST_NULLABLE),
         null,
         OperandTypes.SAME_VARIADIC,
         SqlFunctionCategory.SYSTEM);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonDepthFunction.java
Patch:
@@ -38,8 +38,7 @@ public class SqlJsonDepthFunction extends SqlFunction {
   public SqlJsonDepthFunction() {
     super("JSON_DEPTH",
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.cascade(ReturnTypes.INTEGER,
-            SqlTypeTransforms.FORCE_NULLABLE),
+        ReturnTypes.INTEGER.andThen(SqlTypeTransforms.FORCE_NULLABLE),
         null,
         OperandTypes.ANY,
         SqlFunctionCategory.SYSTEM);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonExistsFunction.java
Patch:
@@ -32,10 +32,11 @@
 public class SqlJsonExistsFunction extends SqlFunction {
   public SqlJsonExistsFunction() {
     super("JSON_EXISTS", SqlKind.OTHER_FUNCTION,
-        ReturnTypes.cascade(ReturnTypes.BOOLEAN, SqlTypeTransforms.FORCE_NULLABLE), null,
+        ReturnTypes.BOOLEAN.andThen(SqlTypeTransforms.FORCE_NULLABLE), null,
         OperandTypes.or(
             OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER),
-            OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER, SqlTypeFamily.ANY)),
+            OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER,
+                SqlTypeFamily.ANY)),
         SqlFunctionCategory.SYSTEM);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonLengthFunction.java
Patch:
@@ -30,8 +30,7 @@
 public class SqlJsonLengthFunction extends SqlFunction {
   public SqlJsonLengthFunction() {
     super("JSON_LENGTH", SqlKind.OTHER_FUNCTION,
-        ReturnTypes.cascade(ReturnTypes.INTEGER,
-            SqlTypeTransforms.FORCE_NULLABLE),
+        ReturnTypes.INTEGER.andThen(SqlTypeTransforms.FORCE_NULLABLE),
         null,
         OperandTypes.or(OperandTypes.ANY,
             OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER)),

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueExpressionOperator.java
Patch:
@@ -31,7 +31,8 @@ public class SqlJsonValueExpressionOperator extends SqlPostfixOperator {
 
   public SqlJsonValueExpressionOperator() {
     super("FORMAT JSON", SqlKind.JSON_VALUE_EXPRESSION, 28,
-        ReturnTypes.cascade(ReturnTypes.explicit(SqlTypeName.ANY),
-            SqlTypeTransforms.TO_NULLABLE), null, OperandTypes.CHARACTER);
+        ReturnTypes.explicit(SqlTypeName.ANY)
+            .andThen(SqlTypeTransforms.TO_NULLABLE),
+        null, OperandTypes.CHARACTER);
   }
 }

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraEnumerator.java
Patch:
@@ -57,7 +57,7 @@ class CassandraEnumerator implements Enumerator<Object> {
     this.fieldTypes = protoRowType.apply(typeFactory).getFieldList();
   }
 
-  /** Produce the next row from the results
+  /** Produces the next row from the results.
    *
    * @return A new row from the results
    */

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java
Patch:
@@ -205,7 +205,6 @@ private String compareFieldWithLiteral(RexNode left, RexNode right, List<String>
       }
     }
 
-    /** @see org.apache.calcite.rel.convert.ConverterRule */
     @Override public void onMatch(RelOptRuleCall call) {
       LogicalFilter filter = call.rel(0);
       CassandraTableScan scan = call.rel(1);
@@ -370,7 +369,6 @@ private RelFieldCollation.Direction reverseDirection(RelFieldCollation.Direction
       }
     }
 
-    /** @see org.apache.calcite.rel.convert.ConverterRule */
     @Override public void onMatch(RelOptRuleCall call) {
       final Sort sort = call.rel(0);
       CassandraFilter filter = call.rel(2);
@@ -426,7 +424,6 @@ public RelNode convert(EnumerableLimit limit) {
         convert(limit.getInput(), CassandraRel.CONVENTION), limit.offset, limit.fetch);
     }
 
-    /** @see org.apache.calcite.rel.convert.ConverterRule */
     @Override public void onMatch(RelOptRuleCall call) {
       final EnumerableLimit limit = call.rel(0);
       final RelNode converted = convert(limit);

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchemaFactory.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Map;
 
 /**
- * Factory that creates a {@link CassandraSchema}
+ * Factory that creates a {@link CassandraSchema}.
  */
 @SuppressWarnings("UnusedDeclaration")
 public class CassandraSchemaFactory implements SchemaFactory {

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java
Patch:
@@ -48,7 +48,7 @@
 import java.util.Map;
 
 /**
- * Table based on a Cassandra column family
+ * Table based on a Cassandra column family.
  */
 public class CassandraTable extends AbstractQueryableTable
     implements TranslatableTable {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java
Patch:
@@ -189,7 +189,7 @@ public Expression field(Expression expression, int field, Type fromType,
   },
 
   /**
-   * See {@link org.apache.calcite.interpreter.Row}
+   * See {@link org.apache.calcite.interpreter.Row}.
    */
   ROW {
     @Override Type javaRowClass(JavaTypeFactory typeFactory, RelDataType type) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/NestedBlockBuilder.java
Patch:
@@ -41,8 +41,7 @@ public interface NestedBlockBuilder {
   void nestBlock(BlockBuilder block);
 
   /**
-   * Returns the current code block
-   * @return current code block
+   * Returns the current code block.
    */
   BlockBuilder currentBlock();
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/NestedBlockBuilderImpl.java
Patch:
@@ -60,8 +60,7 @@ public final void nestBlock(BlockBuilder block) {
   }
 
   /**
-   * Returns the current code block
-   * @return current code block
+   * Returns the current code block.
    */
   public final BlockBuilder currentBlock() {
     return blocks.get(blocks.size() - 1);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/ReflectiveCallNotNullImplementor.java
Patch:
@@ -36,8 +36,9 @@ public class ReflectiveCallNotNullImplementor implements NotNullImplementor {
   protected final Method method;
 
   /**
-   * Constructor of {@link ReflectiveCallNotNullImplementor}
-   * @param method method that is used to implement the call
+   * Constructor of {@link ReflectiveCallNotNullImplementor}.
+   *
+   * @param method Method that is used to implement the call
    */
   public ReflectiveCallNotNullImplementor(Method method) {
     this.method = method;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java
Patch:
@@ -1097,7 +1097,7 @@ private static Expression implementCallOperand2(final RexNode operand,
 
   /**
    * For {@code PREV} operator, the offset of {@code inputGetter}
-   * should be set first
+   * should be set first.
    */
   private Result implementPrev(RexCall call) {
     final RexNode node = call.getOperands().get(0);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/AggResetContextImpl.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * Implementation of
- * {@link org.apache.calcite.adapter.enumerable.AggResetContext}
+ * {@link org.apache.calcite.adapter.enumerable.AggResetContext}.
  */
 public abstract class AggResetContextImpl extends NestedBlockBuilderImpl
     implements AggResetContext {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/AggResultContextImpl.java
Patch:
@@ -27,7 +27,7 @@
 
 /**
  * Implementation of
- * {@link org.apache.calcite.adapter.enumerable.AggResultContext}
+ * {@link org.apache.calcite.adapter.enumerable.AggResultContext}.
  */
 public class AggResultContextImpl extends AggResetContextImpl
     implements AggResultContext {

File: core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
Patch:
@@ -196,7 +196,7 @@ private <T> Table fieldRelation(final Field field) {
   }
 
   /** Deduces the element type of a collection;
-   * same logic as {@link #toEnumerable} */
+   * same logic as {@link #toEnumerable}. */
   private static Type getElementType(Class clazz) {
     if (clazz.isArray()) {
       return clazz.getComponentType();

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcImplementor.java
Patch:
@@ -33,6 +33,7 @@ public JdbcImplementor(SqlDialect dialect, JavaTypeFactory typeFactory) {
     Util.discard(typeFactory);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @see #dispatch */
   public Result visit(JdbcTableScan scan) {
     return result(scan.jdbcTable.tableName(),

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -561,7 +561,7 @@ public Schema create(
     }
   }
 
-  /** Do not use */
+  /** Do not use. */
   @Experimental
   public interface Foo
       extends BiFunction<String, String, Iterable<MetaImpl.MetaTable>> {

File: core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java
Patch:
@@ -357,8 +357,9 @@ private static CalciteSystemProperty<Integer> intProperty(String key, int defaul
   }
 
   /**
-   * Returns the value of the system property with the specified name as int, or
-   * the <code>defaultValue</code> if any of the conditions below hold:
+   * Returns the value of the system property with the specified name as {@code
+   * int}. If any of the conditions below hold, returns the
+   * <code>defaultValue</code>:
    *
    * <ol>
    * <li>the property is not defined;

File: core/src/main/java/org/apache/calcite/interpreter/Bindables.java
Patch:
@@ -109,6 +109,7 @@ private Bindables() {}
   public static final RelOptRule BINDABLE_SET_OP_RULE =
       BindableSetOpRule.DEFAULT_CONFIG.toRule(BindableSetOpRule.class);
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #BINDABLE_SET_OP_RULE}. */
   public static final RelOptRule BINDABLE_SETOP_RULE =
       BINDABLE_SET_OP_RULE;

File: core/src/main/java/org/apache/calcite/interpreter/Row.java
Patch:
@@ -113,15 +113,16 @@ private RowBuilder(int size) {
     }
 
     /**
-     * Set the value of a particular column.
+     * Sets the value of a particular column.
+     *
      * @param index Zero-indexed position of value.
      * @param value Desired column value.
      */
     public void set(int index, Object value) {
       values[index] = value;
     }
 
-    /** Return a Row object **/
+    /** Returns a Row. */
     public Row build() {
       return new Row(values);
     }

File: core/src/main/java/org/apache/calcite/model/ModelHandler.java
Patch:
@@ -100,6 +100,7 @@ public ModelHandler(CalciteConnection connection, String uri)
     visit(root);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #addFunctions}. */
   @Deprecated
   public static void create(SchemaPlus schema, String functionName,

File: core/src/main/java/org/apache/calcite/plan/Convention.java
Patch:
@@ -82,9 +82,8 @@ default boolean useAbstractConvertersForConversion(RelTraitSet fromTraits,
     return false;
   }
 
-  /**
-   * Return RelFactories struct for the convention which can be used to build RelNode
-   */
+  /** Return RelFactories struct for this convention. It can can be used to
+   * build RelNode. */
   default RelFactories.Struct getRelFactories() {
     return RelFactories.DEFAULT_STRUCT;
   }

File: core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
Patch:
@@ -235,6 +235,7 @@ public RelTraitSet traitSet() {
     return emptyTraitSet;
   }
 
+  // CHECKSTYLE: IGNORE 2
   /** @deprecated For {@code traitSetOf(t1, t2)},
    * use {@link #traitSet}().replace(t1).replace(t2). */
   @Deprecated // to be removed before 2.0

File: core/src/main/java/org/apache/calcite/plan/RelOptRule.java
Patch:
@@ -178,6 +178,7 @@ public static <R extends RelNode> RelOptRuleOperand operandJ(
         operandList.operands);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #operandJ} */
   @SuppressWarnings("Guava")
   @Deprecated // to be removed before 2.0
@@ -269,6 +270,7 @@ public static <R extends RelNode> RelOptRuleOperand operand(
     return new ConverterRelOptRuleOperand(clazz, trait, predicate);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #convertOperand(Class, Predicate, RelTrait)}. */
   @SuppressWarnings("Guava")
   @Deprecated // to be removed before 2.0
@@ -435,7 +437,7 @@ private void assignSolveOrder() {
   }
 
   /**
-   * Returns the root operand of this rule
+   * Returns the root operand of this rule.
    *
    * @return the root operand of this rule
    */

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleCall.java
Patch:
@@ -219,7 +219,7 @@ public RelMetadataQuery getMetadataQuery() {
   }
 
   /**
-   * @return list of parents of the first relational expression
+   * Returns a list of parents of the first relational expression.
    */
   public List<RelNode> getParents() {
     return parents;

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
Patch:
@@ -158,7 +158,7 @@ public RelOptRule getRule() {
   }
 
   /**
-   * Sets the rule this operand belongs to
+   * Sets the rule this operand belongs to.
    *
    * @param rule containing rule
    */
@@ -249,7 +249,7 @@ private StringBuilder describeIt(RelOptRuleOperand that) {
   }
 
   /**
-   * @return relational expression class matched by this operand
+   * Returns relational expression class matched by this operand.
    */
   public Class<? extends RelNode> getMatchedClass() {
     return clazz;

File: core/src/main/java/org/apache/calcite/plan/RelOptRules.java
Patch:
@@ -44,9 +44,8 @@ public class RelOptRules {
   private RelOptRules() {
   }
 
-  /**
-   * The calc rule set is public for use from {@link org.apache.calcite.tools.Programs}
-   */
+  /** Calc rule set; public so that {@link org.apache.calcite.tools.Programs} can
+   * use it. */
   public static final ImmutableList<RelOptRule> CALC_RULES =
       ImmutableList.of(
           Bindables.FROM_NONE_RULE,

File: core/src/main/java/org/apache/calcite/plan/RelOptTable.java
Patch:
@@ -102,7 +102,7 @@ public interface RelOptTable extends Wrapper {
 
   /**
    * Returns a list of unique keys, empty list if no key exist,
-   * the result should be consistent with {@code isKey}
+   * the result should be consistent with {@code isKey}.
    */
   List<ImmutableBitSet> getKeys();
 

File: core/src/main/java/org/apache/calcite/plan/RelTraitSet.java
Patch:
@@ -42,7 +42,7 @@ public final class RelTraitSet extends AbstractList<RelTrait> {
   private final Cache cache;
   private final RelTrait[] traits;
   private String string;
-  /** Cache the hash code for the traits */
+  /** Caches the hash code for the traits. */
   private int hash; // Default to 0
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/apache/calcite/plan/TableAccessMap.java
Patch:
@@ -91,7 +91,7 @@ public TableAccessMap(RelNode rel) {
   }
 
   /**
-   * Constructs a TableAccessMap for a single table
+   * Constructs a TableAccessMap for a single table.
    *
    * @param table fully qualified name of the table, represented as a list
    * @param mode  access mode for the table
@@ -104,7 +104,7 @@ public TableAccessMap(List<String> table, Mode mode) {
   //~ Methods ----------------------------------------------------------------
 
   /**
-   * @return set of qualified names for all tables accessed
+   * Returns a set of qualified names for all tables accessed.
    */
   public Set<List<String>> getTablesAccessed() {
     return accessMap.keySet();

File: core/src/main/java/org/apache/calcite/plan/VisitorDataContext.java
Patch:
@@ -38,7 +38,7 @@
 import java.util.List;
 
 /**
- * DataContext for evaluating an RexExpression
+ * DataContext for evaluating a RexExpression.
  */
 public class VisitorDataContext implements DataContext {
   private static final CalciteLogger LOGGER =

File: core/src/main/java/org/apache/calcite/plan/hep/HepRelVertex.java
Patch:
@@ -85,7 +85,7 @@ void replaceRel(RelNode newRel) {
   }
 
   /**
-   * @return current implementation chosen for this vertex
+   * Returns current implementation chosen for this vertex.
    */
   public RelNode getCurrentRel() {
     return currentRel;

File: core/src/main/java/org/apache/calcite/plan/volcano/IterativeRuleQueue.java
Patch:
@@ -170,7 +170,7 @@ private void dumpPlannerState() {
   private static class MatchList {
 
     /**
-     * Rule match queue for SubstitutionRule
+     * Rule match queue for SubstitutionRule.
      */
     private final Queue<VolcanoRuleMatch> preQueue = new LinkedList<>();
 

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
Patch:
@@ -124,7 +124,7 @@ public List<RelNode> getParentRels() {
   }
 
   /**
-   * Returns the child Relset for current set
+   * Returns the child RelSet for the current set.
    */
   public Set<RelSet> getChildSets(VolcanoPlanner planner) {
     Set<RelSet> childSets = new HashSet<>();
@@ -143,8 +143,8 @@ public Set<RelSet> getChildSets(VolcanoPlanner planner) {
   }
 
   /**
-   * @return all of the {@link RelNode}s contained by any subset of this set
-   * (does not include the subset objects themselves)
+   * Returns all of the {@link RelNode}s contained by any subset of this set
+   * (does not include the subset objects themselves).
    */
   public List<RelNode> getRelsFromAllSubsets() {
     return rels;

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -945,7 +945,7 @@ private void checkPruned(RelNode rel, RelNode duplicateRel) {
   }
 
   /**
-   * Find the new root subset in case the root is merged with another subset
+   * Find the new root subset in case the root is merged with another subset.
    */
   void canonize() {
     root = canonize(root);

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -118,7 +118,7 @@ public PlannerImpl(FrameworkConfig config) {
     reset();
   }
 
-  /** Gets a user defined config and appends default connection values */
+  /** Gets a user-defined config and appends default connection values. */
   private CalciteConnectionConfig connConfig() {
     CalciteConnectionConfigImpl config = Util.first(
         context.unwrap(CalciteConnectionConfigImpl.class),
@@ -256,9 +256,10 @@ public RelRoot rel(SqlNode sql) {
     return root;
   }
 
+  // CHECKSTYLE: IGNORE 2
   /** @deprecated Now {@link PlannerImpl} implements {@link ViewExpander}
    * directly. */
-  @Deprecated
+  @Deprecated // to be removed before 2.0
   public class ViewExpanderImpl implements ViewExpander {
     ViewExpanderImpl() {
     }

File: core/src/main/java/org/apache/calcite/rel/RelWriter.java
Patch:
@@ -42,9 +42,7 @@ public interface RelWriter {
    */
   void explain(RelNode rel, List<Pair<String, Object>> valueList);
 
-  /**
-   * @return detail level at which plan should be generated
-   */
+  /** Returns detail level at which plan should be generated. */
   SqlExplainLevel getDetailLevel();
 
   /**

File: core/src/main/java/org/apache/calcite/rel/convert/Converter.java
Patch:
@@ -67,7 +67,7 @@ public interface Converter extends RelNode {
   RelTraitDef getTraitDef();
 
   /**
-   * Returns the sole input relational expression
+   * Returns the sole input relational expression.
    *
    * @return child relational expression
    */

File: core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
Patch:
@@ -481,7 +481,7 @@ public Group getGroupType() {
     return Group.induce(groupSet, groupSets);
   }
 
-  /** What kind of roll-up is it? */
+  /** Describes the kind of roll-up. */
   public enum Group {
     SIMPLE,
     ROLLUP,
@@ -577,7 +577,7 @@ public static class AggCallBinding extends SqlOperatorBinding {
     private final boolean filter;
 
     /**
-     * Creates an AggCallBinding
+     * Creates an AggCallBinding.
      *
      * @param typeFactory  Type factory
      * @param aggFunction  Aggregate function

File: core/src/main/java/org/apache/calcite/rel/core/CorrelationId.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * Describes the necessary parameters for an implementation in order to
- * identify and set dynamic variables
+ * identify and set dynamic variables.
  */
 public class CorrelationId implements Cloneable, Comparable<CorrelationId> {
   /**

File: core/src/main/java/org/apache/calcite/rel/core/Join.java
Patch:
@@ -191,6 +191,7 @@ public JoinRelType getJoinType() {
     return planner.getCostFactory().makeCost(rowCount, 0, 0);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link RelMdUtil#getJoinRowCount(RelMetadataQuery, Join, RexNode)}. */
   @Deprecated // to be removed before 2.0
   public static double estimateJoinedRows(

File: core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
Patch:
@@ -59,7 +59,7 @@ public abstract class RepeatUnion extends BiRel {
 
   /**
    * Maximum number of times to repeat the iterative relational expression;
-   * negative value means no limit, 0 means only seed will be evaluated
+   * negative value means no limit, 0 means only seed will be evaluated.
    */
   public final int iterationLimit;
 

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
Patch:
@@ -485,6 +485,7 @@ public RelOptPredicateList getPredicates(Exchange exchange,
     return mq.getPulledUpPredicates(input);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @see RelMetadataQuery#getPulledUpPredicates(RelNode) */
   public RelOptPredicateList getPredicates(RelSubset r,
       RelMetadataQuery mq) {

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableCalc.java
Patch:
@@ -30,7 +30,7 @@ private MutableCalc(MutableRel input, RexProgram program) {
   }
 
   /**
-   * Creates a MutableCalc
+   * Creates a MutableCalc.
    *
    * @param input   Input relational expression
    * @param program Calc program

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableMultiRel.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-/** Base Class for relations with three or more inputs */
+/** Base Class for relations with three or more inputs. */
 abstract class MutableMultiRel extends MutableRel {
   protected final List<MutableRel> inputs;
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -178,7 +178,7 @@ private boolean containsAvgStddevVarCall(List<AggregateCall> aggCallList) {
   }
 
   /**
-   * Returns whether the aggregate call is a reducible function
+   * Returns whether the aggregate call is a reducible function.
    */
   private boolean isReducible(final SqlKind kind) {
     return functionsToReduce.contains(kind);

File: core/src/main/java/org/apache/calcite/rel/rules/LoptJoinTree.java
Patch:
@@ -175,9 +175,7 @@ public Leaf(int rootId, LoptJoinTree parent) {
       this.id = rootId;
     }
 
-    /**
-     * @return the id associated with a leaf node in a binary tree
-     */
+    /** Returns the id associated with a leaf node in a binary tree. */
     public int getId() {
       return id;
     }

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
Patch:
@@ -183,9 +183,7 @@ RelDataType createTypeWithCharsetAndCollation(
       Charset charset,
       SqlCollation collation);
 
-  /**
-   * @return the default {@link Charset} for string types
-   */
+  /** Returns the default {@link Charset} (valid if this is a string type). */
   Charset getDefaultCharset();
 
   /**

File: core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java
Patch:
@@ -32,7 +32,7 @@ public class RexMultisetUtil {
   //~ Static fields/initializers ---------------------------------------------
 
   /**
-   * A set defining all implementable multiset calls
+   * A set defining all implementable multiset calls.
    */
   private static final Set<SqlOperator> MULTISET_OPERATORS =
       ImmutableSet.of(
@@ -134,7 +134,7 @@ public static boolean isMultisetCast(RexCall call) {
 
   /**
    * Returns a reference to the first found multiset call or null if none was
-   * found
+   * found.
    */
   public static RexCall findFirstMultiset(final RexNode node, boolean deep) {
     if (node instanceof RexFieldAccess) {

File: core/src/main/java/org/apache/calcite/rex/RexPatternFieldRef.java
Patch:
@@ -20,7 +20,7 @@
 import org.apache.calcite.sql.SqlKind;
 
 /**
- * Variable which references a field of an input relational expression
+ * Variable that references a field of an input relational expression.
  */
 public class RexPatternFieldRef extends RexInputRef {
   private final String alpha;

File: core/src/main/java/org/apache/calcite/rex/RexProgram.java
Patch:
@@ -401,7 +401,7 @@ public RelDataType getInputRowType() {
   }
 
   /**
-   * Returns whether this program contains windowed aggregate functions
+   * Returns whether this program contains windowed aggregate functions.
    *
    * @return whether this program contains windowed aggregate functions
    */

File: core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
Patch:
@@ -867,7 +867,7 @@ public RexLocalRef makeInputRef(int index) {
   }
 
   /**
-   * Returns the rowtype of the input to the program
+   * Returns the row type of the input to the program.
    */
   public RelDataType getInputRowType() {
     return inputRowType;
@@ -1045,8 +1045,8 @@ public RexNode visitLocalRef(RexLocalRef local) {
   }
 
   /**
-   * Shuttle which rewires {@link RexLocalRef} using a list of updated
-   * references
+   * Shuttle that rewires {@link RexLocalRef} using a list of updated
+   * references.
    */
   private class UpdateRefShuttle extends RexShuttle {
     private List<RexLocalRef> newRefs;

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -1032,7 +1032,7 @@ private boolean sameTypeOrNarrowsNullability(RelDataType oldType, RelDataType ne
             && oldType.isNullable());
   }
 
-  /** Object to describe a Case branch */
+  /** Object to describe a CASE branch. */
   static final class CaseBranch {
 
     private final RexNode cond;
@@ -1074,7 +1074,7 @@ private static List<RexNode> toCaseOperands(List<CaseBranch> branches) {
   }
 
   /**
-   * Decides whether it is safe to flatten the given case part into AND/ORs
+   * Decides whether it is safe to flatten the given CASE part into ANDs/ORs.
    */
   enum SafeRexVisitor implements RexVisitor<Boolean> {
     INSTANCE;

File: core/src/main/java/org/apache/calcite/rex/RexSqlReflectiveConvertletTable.java
Patch:
@@ -72,7 +72,7 @@ public RexSqlConvertlet get(RexCall call) {
   }
 
   /**
-   * Registers a convertlet for a given operator instance
+   * Registers a convertlet for a given operator instance.
    *
    * @param op         Operator instance, say
    * {@link org.apache.calcite.sql.fun.SqlStdOperatorTable#MINUS}

File: core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
Patch:
@@ -94,7 +94,8 @@ public static RexTableInputRef of(RelTableRef tableRef, RexInputRef ref) {
     return SqlKind.TABLE_INPUT_REF;
   }
 
-  /** Identifies uniquely a table by its qualified name and its entity number (occurrence) */
+  /** Identifies uniquely a table by its qualified name and its entity number
+   * (occurrence). */
   public static class RelTableRef implements Comparable<RelTableRef> {
 
     private final RelOptTable table;

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -94,7 +94,7 @@ public static double getSelectivity(RexNode exp) {
   }
 
   /**
-   * Generates a cast from one row type to another
+   * Generates a cast from one row type to another.
    *
    * @param rexBuilder RexBuilder to use for constructing casts
    * @param lhsRowType target row type
@@ -629,7 +629,7 @@ public static List<RexNode> retainDeterministic(List<RexNode> list) {
   }
 
    /**
-   * Returns whether a given node contains a RexCall with a specified operator
+   * Returns whether a given node contains a RexCall with a specified operator.
    *
    * @param operator Operator to look for
    * @param node     a RexNode tree
@@ -766,7 +766,7 @@ public static boolean requiresDecimalExpansion(
   }
 
   /**
-   * Determines whether any operand of a set requires decimal expansion
+   * Determines whether any operand of a set requires decimal expansion.
    */
   public static boolean requiresDecimalExpansion(
       List<RexNode> operands,

File: core/src/main/java/org/apache/calcite/runtime/Enumerables.java
Patch:
@@ -91,7 +91,7 @@ public Enumerator<TResult> enumerator() {
           /** Current result row. Null if no row is ready. */
           TResult resultRow;
 
-          /** Match counter is 1 based in Oracle */
+          /** Match counter is 1-based in Oracle. */
           final AtomicInteger matchCounter = new AtomicInteger(1);
 
           public TResult current() {

File: core/src/main/java/org/apache/calcite/runtime/EnumeratorCursor.java
Patch:
@@ -35,7 +35,8 @@ public abstract class EnumeratorCursor<T> extends PositionedCursor<T> {
   private final Enumerator<T> enumerator;
 
   /**
-   * Creates a {@code EnumeratorCursor}
+   * Creates an {@code EnumeratorCursor}.
+   *
    * @param enumerator input enumerator
    */
   protected EnumeratorCursor(Enumerator<T> enumerator) {

File: core/src/main/java/org/apache/calcite/runtime/Hook.java
Patch:
@@ -130,6 +130,7 @@ public <T> Closeable add(final Consumer<T> handler) {
     return () -> remove(handler);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #add(Consumer)}. */
   @SuppressWarnings("Guava")
   @Deprecated // to be removed before 2.0
@@ -149,6 +150,7 @@ public <T> Closeable addThread(final Consumer<T> handler) {
     return () -> removeThread(handler);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #addThread(Consumer)}. */
   @SuppressWarnings("Guava")
   @Deprecated // to be removed before 2.0
@@ -162,6 +164,7 @@ private boolean removeThread(Consumer handler) {
     return threadHandlers.get().remove(handler);
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #propertyJ}. */
   @SuppressWarnings("Guava")
   @Deprecated // return type will change in 2.0

File: core/src/main/java/org/apache/calcite/runtime/Matcher.java
Patch:
@@ -320,7 +320,7 @@ public Matcher<E> build() {
   }
 
   /**
-   * Represents a Tuple of a symbol and a row
+   * A 2-tuple consisting of a symbol and a row.
    *
    * @param <E> Type of Row
    */

File: core/src/main/java/org/apache/calcite/runtime/Pattern.java
Patch:
@@ -38,9 +38,9 @@ static PatternBuilder builder() {
   enum Op {
     /** A leaf pattern, consisting of a single symbol. */
     SYMBOL(0, 0),
-    /** Anchor for start "^" */
+    /** Anchor for start "^". */
     ANCHOR_START(0, 0),
-    /** Anchor for end "$" */
+    /** Anchor for end "$". */
     ANCHOR_END(0, 0),
     /** Pattern that matches one pattern followed by another. */
     SEQ(2, -1),
@@ -53,7 +53,7 @@ enum Op {
     /** Pattern that matches a pattern repeated between {@code minRepeat}
      * and {@code maxRepeat} times. */
     REPEAT(1, 1),
-    /** Pattern that machtes a pattern one time or zero times */
+    /** Pattern that matches a pattern one time or zero times. */
     OPTIONAL(1, 1);
 
     private final int minArity;

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -1110,19 +1110,19 @@ private static RuntimeException notComparable(String op, Object b0,
   }
 
   // &
-  /** Helper function for implementing <code>BIT_AND</code> */
+  /** Helper function for implementing <code>BIT_AND</code>. */
   public static long bitAnd(long b0, long b1) {
     return b0 & b1;
   }
 
   // |
-  /** Helper function for implementing <code>BIT_OR</code> */
+  /** Helper function for implementing <code>BIT_OR</code>. */
   public static long bitOr(long b0, long b1) {
     return b0 | b1;
   }
 
   // ^
-  /** Helper function for implementing <code>BIT_XOR</code> */
+  /** Helper function for implementing <code>BIT_XOR</code>. */
   public static long bitXor(long b0, long b1) {
     return b0 ^ b1;
   }

File: core/src/main/java/org/apache/calcite/runtime/TrustAllSslSocketFactory.java
Patch:
@@ -76,6 +76,8 @@ protected TrustAllSslSocketFactory() {
   }
 
   /**
+   * Returns a copy of the environment's default socket factory.
+   *
    * @see javax.net.SocketFactory#getDefault()
    */
   public static TrustAllSslSocketFactory getDefault() {

File: core/src/main/java/org/apache/calcite/runtime/Utilities.java
Patch:
@@ -33,6 +33,7 @@ public class Utilities {
   protected Utilities() {
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link java.util.Objects#equals}. */
   @Deprecated // to be removed before 2.0
   public static boolean equal(Object o0, Object o1) {

File: core/src/main/java/org/apache/calcite/schema/impl/ReflectiveFunctionBase.java
Patch:
@@ -42,8 +42,9 @@ public abstract class ReflectiveFunctionBase implements Function {
   public final List<FunctionParameter> parameters;
 
   /**
-   * {@code ReflectiveFunctionBase} constructor
-   * @param method method that is used to get type information from
+   * Creates a ReflectiveFunctionBase.
+   *
+   * @param method Method that is used to get type information from
    */
   public ReflectiveFunctionBase(Method method) {
     this.method = method;

File: core/src/main/java/org/apache/calcite/sql/SqlAccessEnum.java
Patch:
@@ -17,7 +17,7 @@
 package org.apache.calcite.sql;
 
 /**
- * Enumeration representing different access types
+ * Access type.
  */
 public enum SqlAccessEnum {
   SELECT, UPDATE, INSERT, DELETE;

File: core/src/main/java/org/apache/calcite/sql/SqlAccessType.java
Patch:
@@ -20,7 +20,9 @@
 import java.util.Locale;
 
 /**
- * SqlAccessType is represented by a set of allowed access types
+ * SqlAccessType is represented by a set of allowed access types.
+ *
+ * @see SqlAccessEnum
  */
 public class SqlAccessType {
   //~ Static fields/initializers ---------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
Patch:
@@ -235,7 +235,7 @@ public String getCharSetName() {
   //~ Tools ------------------------------------------------------------------
 
   /**
-   * @return true if this type name has "local time zone" definition.
+   * Returns whether this type name has "local time zone" definition.
    */
   private static boolean isWithLocalTimeZoneDef(SqlTypeName typeName) {
     switch (typeName) {

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -183,9 +183,9 @@ public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
   }
 
   /**
-   * Test to see if it is the function COUNT(*)
+   * Returns whether it is the function {@code COUNT(*)}.
    *
-   * @return boolean true if function call to COUNT(*)
+   * @return true if function call to COUNT(*)
    */
   public boolean isCountStar() {
     SqlOperator sqlOperator = getOperator();

File: core/src/main/java/org/apache/calcite/sql/SqlCollation.java
Patch:
@@ -301,9 +301,9 @@ public final Locale getLocale() {
   }
 
   /**
-   * @return the {@link Collator} to compare values having the current collation,
-   * or {@code null} if no specific {@link Collator} is needed, in which case
-   * {@link String#compareTo} will be used.
+   * Returns the {@link Collator} to compare values having the current
+   * collation, or {@code null} if no specific {@link Collator} is needed, in
+   * which case {@link String#compareTo} will be used.
    */
   public Collator getCollator() {
     return null;

File: core/src/main/java/org/apache/calcite/sql/SqlDelete.java
Patch:
@@ -86,14 +86,14 @@ public List<SqlNode> getOperandList() {
   }
 
   /**
-   * @return the identifier for the target table of the deletion
+   * Returns the identifier for the target table of the deletion.
    */
   public SqlNode getTargetTable() {
     return targetTable;
   }
 
   /**
-   * @return the alias for the target table of the deletion
+   * Returns the alias for the target table of the deletion.
    */
   public SqlIdentifier getAlias() {
     return alias;

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -328,7 +328,7 @@ public final boolean isYearMonth() {
   }
 
   /**
-   * @return 1 or -1
+   * Returns 1 or -1.
    */
   public int getIntervalSign(String value) {
     int sign = 1; // positive until proven otherwise

File: core/src/main/java/org/apache/calcite/sql/SqlJsonConstructorNullClause.java
Patch:
@@ -17,7 +17,7 @@
 package org.apache.calcite.sql;
 
 /**
- * Indicating that how do Json constructors handle null
+ * Indicating how JSON constructors handle null.
  */
 public enum SqlJsonConstructorNullClause {
   NULL_ON_NULL("NULL ON NULL"),

File: core/src/main/java/org/apache/calcite/sql/SqlNode.java
Patch:
@@ -64,6 +64,7 @@ public abstract class SqlNode implements Cloneable {
 
   //~ Methods ----------------------------------------------------------------
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Please use {@link #clone(SqlNode)}; this method brings
    * along too much baggage from early versions of Java */
   @Deprecated

File: core/src/main/java/org/apache/calcite/sql/SqlWindow.java
Patch:
@@ -294,6 +294,7 @@ public SqlCall getWindowCall() {
     return windowCall;
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @see Util#deprecated(Object, boolean) */
   static void checkSpecialLiterals(SqlWindow window, SqlValidator validator) {
     final SqlNode lowerBound = window.getLowerBound();

File: core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java
Patch:
@@ -79,9 +79,9 @@ protected void validateColumnNames(SqlValidator validator,
   }
 
   /**
-   * Type-inference strategy whereby the result type of a table function call is a ROW,
-   * which is combined from the operand #0(TABLE parameter)'s schema and two
-   * additional fields:
+   * Type-inference strategy whereby the result type of a table function call is
+   * a ROW, which is combined from the operand #0(TABLE parameter)'s schema and
+   * two additional fields. The fields are as follows:
    *
    * <ol>
    *  <li>window_start: TIMESTAMP type to indicate a window's start.</li>

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorHint2.java
Patch:
@@ -23,7 +23,7 @@
  * {@link SqlAdvisor#getCompletionHints (String, int, String[])}.
  */
 public class SqlAdvisorHint2 extends SqlAdvisorHint {
-  /** Replacement string */
+  /** Replacement string. */
   public final String replacement;
 
   public SqlAdvisorHint2(String id, String[] names, String type, String replacement) {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java
Patch:
@@ -59,7 +59,7 @@ public SqlCase(SqlParserPos pos, SqlNode value, SqlNodeList whenList,
   }
 
   /**
-   * Creates a call to the switched form of the case operator, viz:
+   * Creates a call to the switched form of the CASE operator. For example:
    *
    * <blockquote><code>CASE value<br>
    * WHEN whenList[0] THEN thenList[0]<br>

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -166,7 +166,7 @@ public void unparse(
         writer.newlineAndIndent();
       }
       if (rand instanceof SqlCharStringLiteral) {
-        NlsString nls = ((SqlCharStringLiteral) rand).getNlsString();
+        final NlsString nls = rand.getValueAs(NlsString.class);
         if (operand.i == 0) {
           collation = nls.getCollation();
 

File: core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java
Patch:
@@ -27,8 +27,8 @@
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
- * Parameter type-checking strategy types must be [nullable] Multiset,
- * [nullable] Multiset and the two types must have the same element type
+ * Parameter type-checking strategy where types must be ([nullable] Multiset,
+ * [nullable] Multiset), and the two types must have the same element type.
  *
  * @see MultisetSqlType#getComponentType
  */

File: core/src/main/java/org/apache/calcite/sql/type/SqlOperandTypeChecker.java
Patch:
@@ -41,9 +41,7 @@ boolean checkOperandTypes(
       SqlCallBinding callBinding,
       boolean throwOnFailure);
 
-  /**
-   * @return range of operand counts allowed in a call
-   */
+  /** Returns the range of operand counts allowed in a call. */
   SqlOperandCountRange getOperandCountRange();
 
   /**

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransformCascade.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Strategy to infer the type of an operator call from the type of the operands
  * by using one {@link SqlReturnTypeInference} rule and a combination of
- * {@link SqlTypeTransform}s
+ * {@link SqlTypeTransform}s.
  */
 public class SqlTypeTransformCascade implements SqlReturnTypeInference {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransforms.java
Patch:
@@ -40,7 +40,7 @@ public abstract class SqlTypeTransforms {
   /**
    * Parameter type-inference transform strategy where a derived type is
    * transformed into the same type but nullable if any of a calls operands is
-   * nullable
+   * nullable.
    */
   public static final SqlTypeTransform TO_NULLABLE =
       (opBinding, typeToTransform) ->

File: core/src/main/java/org/apache/calcite/sql/util/SqlVisitor.java
Patch:
@@ -92,7 +92,7 @@ public interface SqlVisitor<R> {
   R visit(SqlDynamicParam param);
 
   /**
-   * Visits an interval qualifier
+   * Visits an interval qualifier.
    *
    * @param intervalQualifier Interval qualifier
    * @see SqlIntervalQualifier#accept(SqlVisitor)

File: core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
Patch:
@@ -71,7 +71,7 @@ public class AggregatingSelectScope
   //~ Constructors -----------------------------------------------------------
 
   /**
-   * Creates an AggregatingSelectScope
+   * Creates an AggregatingSelectScope.
    *
    * @param selectScope Parent scope
    * @param select      Enclosing SELECT node

File: core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
Patch:
@@ -99,9 +99,7 @@ public class SelectScope extends ListScope {
    */
   private SqlNodeList orderList;
 
-  /**
-   * Scope to use to resolve windows
-   */
+  /** Scope to use to resolve windows. */
   private final SqlValidatorScope windowParent;
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/validate/SqlMoniker.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.List;
 
 /**
- * An interface of an object identifier that represents a SqlIdentifier
+ * An interface of an object identifier that represents a SqlIdentifier.
  */
 public interface SqlMoniker {
   Comparator<SqlMoniker> COMPARATOR =

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
Patch:
@@ -70,6 +70,7 @@ public interface SqlValidatorScope {
   void resolve(List<String> names, SqlNameMatcher nameMatcher, boolean deep,
       Resolved resolved);
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use
    * {@link #findQualifyingTableNames(String, SqlNode, SqlNameMatcher)} */
   @Deprecated // to be removed before 2.0
@@ -177,6 +178,7 @@ Map<String, ScopeChild> findQualifyingTableNames(String columnName,
    */
   void validateExpr(SqlNode expr);
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use
    * {@link #resolveTable(List, SqlNameMatcher, Path, Resolved)}. */
   @Deprecated // to be removed before 2.0

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorTable.java
Patch:
@@ -42,7 +42,7 @@ public interface SqlValidatorTable extends Wrapper {
   SqlMonotonicity getMonotonicity(String columnName);
 
   /**
-   * Returns the access type of the table
+   * Returns the access type of the table.
    */
   SqlAccessType getAllowedAccess();
 

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorWithHints.java
Patch:
@@ -24,8 +24,8 @@
 
 /**
  * Extends {@link SqlValidator} to allow discovery of useful data such as fully
- * qualified names of sql objects, alternative valid sql objects that can be
- * used in the SQL statement (dubbed as hints)
+ * qualified names of SQL objects, alternative valid SQL objects that can be
+ * used in the SQL statement (dubbed as hints).
  */
 public interface SqlValidatorWithHints extends SqlValidator {
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/validate/TableNamespace.java
Patch:
@@ -111,8 +111,8 @@ public TableNamespace extend(SqlNodeList extendList) {
   }
 
   /**
-   * Gets the data-type of all columns in a table (for a view table: including
-   * columns of the underlying table)
+   * Gets the data-type of all columns in a table. For a view table, includes
+   * columns of the underlying table.
    */
   private RelDataType getBaseRowType() {
     final Table schemaTable = table.unwrap(Table.class);

File: core/src/main/java/org/apache/calcite/sql2rel/ReflectiveConvertletTable.java
Patch:
@@ -165,7 +165,7 @@ public SqlRexConvertlet get(SqlCall call) {
   }
 
   /**
-   * Registers a convertlet for a given operator instance
+   * Registers a convertlet for a given operator instance.
    *
    * @param op         Operator instance, say
    * {@link org.apache.calcite.sql.fun.SqlStdOperatorTable#MINUS}

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -1499,7 +1499,7 @@ private boolean checkCorVars(
   }
 
   /**
-   * Remove correlated variables from the tree at root corRel
+   * Removes correlated variables from the tree at root corRel.
    *
    * @param correlate Correlate
    */

File: core/src/main/java/org/apache/calcite/sql2rel/SubQueryConverter.java
Patch:
@@ -26,9 +26,7 @@
 public interface SubQueryConverter {
   //~ Methods ----------------------------------------------------------------
 
-  /**
-   * @return Whether the sub-query can be converted
-   */
+  /** Returns whether the sub-query can be converted. */
   boolean canConvertSubQuery();
 
   /**

File: core/src/main/java/org/apache/calcite/tools/FrameworkConfig.java
Patch:
@@ -112,7 +112,7 @@ public interface FrameworkConfig {
 
   /**
    * Returns the convertlet table that should be used when converting from SQL
-   * to row expressions
+   * to row expressions.
    */
   SqlRexConvertletTable getConvertletTable();
 

File: core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java
Patch:
@@ -183,11 +183,11 @@ public String getAlias() {
     return super.as(alias);
   }
 
-  /** Partitioner for group and join */
+  /** Partitioner for group and join. */
   interface Partitioner {
   }
 
-  /** Option for performing group efficiently if data set is already sorted */
+  /** Option for performing group efficiently if data set is already sorted. */
   public enum GroupOption {
     MERGE,
     COLLECTED

File: core/src/main/java/org/apache/calcite/tools/Planner.java
Patch:
@@ -90,6 +90,7 @@ default SqlNode parse(String sql) throws SqlParseException {
    */
   RelRoot rel(SqlNode sql) throws RelConversionException;
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #rel}. */
   @Deprecated // to removed before 2.0
   RelNode convert(SqlNode sql) throws RelConversionException;

File: core/src/main/java/org/apache/calcite/util/BlackholeMap.java
Patch:
@@ -101,7 +101,7 @@ private BlackholeMap() {}
   }
 
   /**
-   * Gets an instance of {@code BlackholeMap}
+   * Gets an instance of {@code BlackholeMap}.
    *
    * @param <K> type of the keys for the map
    * @param <V> type of the values for the map

File: core/src/main/java/org/apache/calcite/util/Bug.java
Patch:
@@ -168,8 +168,7 @@ public abstract class Bug {
 
   /** Whether
    * <a href="https://issues.apache.org/jira/browse/CALCITE-2401">[CALCITE-2401]
-   * Improve RelMdPredicates performance</a>
-   */
+   * Improve RelMdPredicates performance</a> is fixed. */
   public static final boolean CALCITE_2401_FIXED = false;
 
   /** Whether

File: core/src/main/java/org/apache/calcite/util/CancelFlag.java
Patch:
@@ -40,9 +40,7 @@ public CancelFlag(AtomicBoolean atomicBoolean) {
 
   //~ Methods ----------------------------------------------------------------
 
-  /**
-   * @return whether a cancellation has been requested
-   */
+  /** Returns whether a cancellation has been requested. */
   public boolean isCancelRequested() {
     return atomicBoolean.get();
   }

File: core/src/main/java/org/apache/calcite/util/ConversionUtil.java
Patch:
@@ -23,7 +23,7 @@
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
- * Utility functions for converting from one type to another
+ * Utility functions for converting from one type to another.
  */
 public class ConversionUtil {
   private ConversionUtil() {}
@@ -116,7 +116,7 @@ public static String toStringFromApprox(double d, boolean isFloat) {
   }
 
   /**
-   * Converts a string into a boolean
+   * Converts a string into a BOOLEAN.
    */
   public static Boolean toBoolean(String str) {
     if (str == null) {

File: core/src/main/java/org/apache/calcite/util/DateTimeStringUtils.java
Patch:
@@ -29,7 +29,8 @@ public class DateTimeStringUtils {
 
   private DateTimeStringUtils() {}
 
-  /** The SimpleDateFormat string for ISO timestamps, "yyyy-MM-dd'T'HH:mm:ss'Z'"*/
+  /** The SimpleDateFormat string for ISO timestamps,
+   * "yyyy-MM-dd'T'HH:mm:ss'Z'". */
   public static final String ISO_DATETIME_FORMAT =
       "yyyy-MM-dd'T'HH:mm:ss'Z'";
 

File: core/src/main/java/org/apache/calcite/util/ImmutableBeans.java
Patch:
@@ -363,7 +363,7 @@ private static Method getMethod(Class<Object> aClass,
     }
   }
 
-  /** Is the method reading or writing? */
+  /** Whether the method is reading or writing. */
   private enum Mode {
     GET, SET, WITH
   }

File: core/src/main/java/org/apache/calcite/util/graph/AttributedDirectedGraph.java
Patch:
@@ -50,6 +50,7 @@ public static <V, E extends DefaultEdge> AttributedDirectedGraph<V, E> create(
     return null;
   }
 
+  // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #addEdge(Object, Object, Object...)}. */
   @Deprecated
   public E addEdge(V vertex, V targetVertex) {

File: core/src/main/java/org/apache/calcite/util/mapping/AbstractSourceMapping.java
Patch:
@@ -21,8 +21,8 @@
 /**
  * Simple implementation of
  * {@link org.apache.calcite.util.mapping.Mappings.TargetMapping} where the
- * number of sources and targets are specified as constructor parameters and you
- * just need to implement one method,
+ * number of sources and targets are specified as constructor parameters, and you
+ * just need to implement one method.
  */
 public abstract class AbstractSourceMapping
     extends Mappings.AbstractMapping

File: core/src/main/java/org/apache/calcite/util/mapping/AbstractTargetMapping.java
Patch:
@@ -21,8 +21,8 @@
 /**
  * Simple implementation of
  * {@link org.apache.calcite.util.mapping.Mappings.TargetMapping} where the
- * number of sources and targets are specified as constructor parameters and you
- * just need to implement one method,
+ * number of sources and targets are specified as constructor parameters, and you
+ * just need to implement one method.
  */
 public abstract class AbstractTargetMapping
     extends Mappings.AbstractMapping

File: core/src/test/java/org/apache/calcite/adapter/enumerable/TypeFinderTest.java
Patch:
@@ -40,7 +40,8 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 
 /**
- * Test for {@link org.apache.calcite.adapter.enumerable.EnumerableRelImplementor.TypeFinder}
+ * Test for
+ * {@link org.apache.calcite.adapter.enumerable.EnumerableRelImplementor.TypeFinder}.
  */
 class TypeFinderTest {
 

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -859,7 +859,7 @@ public static class LocalServiceModifiableFactory implements Service.Factory {
   }
 
   /**
-   * Remote PreparedStatement insert WITHOUT bind variables
+   * Remote PreparedStatement insert WITHOUT bind variables.
    */
   @Test void testRemotePreparedStatementInsert() throws Exception {
     final Connection connection = DriverManager.getConnection(
@@ -880,7 +880,7 @@ public static class LocalServiceModifiableFactory implements Service.Factory {
   }
 
   /**
-   * Remote PreparedStatement insert WITH bind variables
+   * Remote PreparedStatement insert WITH bind variables.
    */
   @Test void testRemotePreparedStatementInsert2() throws Exception {
   }

File: core/src/test/java/org/apache/calcite/jdbc/JavaTypeFactoryTest.java
Patch:
@@ -95,12 +95,12 @@ private void assertRecordType(Type actual) {
         () -> "Type {" + actual.getTypeName() + "} is not a subtype of Types.RecordType");
   }
 
-  /***/
+  /** Struct with one field. */
   private static class OneFieldStruct {
     public Integer intField;
   }
 
-  /***/
+  /** Struct with two fields. */
   private static class TwoFieldStruct {
     public Integer intField;
     public String strField;

File: core/src/test/java/org/apache/calcite/plan/volcano/ComboRuleTest.java
Patch:
@@ -45,7 +45,7 @@
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 /**
- * Unit test for {@link VolcanoPlanner}
+ * Unit test for {@link VolcanoPlanner}.
  */
 class ComboRuleTest {
 

File: core/src/test/java/org/apache/calcite/plan/volcano/TraitConversionTest.java
Patch:
@@ -240,9 +240,8 @@ private static class SimpleDistribution implements RelTrait {
     @Override public void register(RelOptPlanner planner) {}
   }
 
-  /**
-   * Dummy distribution trait def for test (handles conversion of SimpleDistribution)
-   */
+  /** Dummy distribution trait def for test (handles conversion of
+   * SimpleDistribution). */
   private static class ConvertRelDistributionTraitDef
       extends RelTraitDef<SimpleDistribution> {
 

File: core/src/test/java/org/apache/calcite/runtime/DeterministicAutomatonTest.java
Patch:
@@ -21,7 +21,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 
-/** Tests for the {@link DeterministicAutomaton} */
+/** Tests for the {@link DeterministicAutomaton}. */
 class DeterministicAutomatonTest {
   @Test void convertAutomaton() {
     final Pattern.PatternBuilder builder = Pattern.builder();

File: core/src/test/java/org/apache/calcite/sql/test/SqlTests.java
Patch:
@@ -89,7 +89,7 @@ public abstract class SqlTests {
 
   /**
    * Helper function to get the string representation of a RelDataType
-   * (include precision/scale but no charset or collation)
+   * (include precision/scale but no charset or collation).
    *
    * @param sqlType Type
    * @return String representation of type
@@ -505,7 +505,7 @@ public static void checkEx(Throwable ex,
     }
   }
 
-  /** Stage of query processing */
+  /** Stage of query processing. */
   public enum Stage {
     PARSE("Parser"),
     VALIDATE("Validator"),

File: core/src/test/java/org/apache/calcite/sql/type/RelDataTypeSystemTest.java
Patch:
@@ -28,7 +28,7 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
 /**
- * Tests return type inference using {@code RelDataTypeSystem}
+ * Tests the inference of return types using {@code RelDataTypeSystem}.
  */
 class RelDataTypeSystemTest {
 

File: core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java
Patch:
@@ -51,6 +51,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+/** Test for {@link RelFieldTrimmer}. */
 class RelFieldTrimmerTest {
   public static Frameworks.ConfigBuilder config() {
     final SchemaPlus rootSchema = Frameworks.createRootSchema(true);

File: core/src/test/java/org/apache/calcite/test/HierarchySchema.java
Patch:
@@ -59,9 +59,7 @@ public class HierarchySchema {
       new Hierarchy(1, 4),
   };
 
-  /**
-   * Hierarchy representing manager - subordinate
-   */
+  /** Hierarchy representing manager - subordinate. */
   public static class Hierarchy {
     public final int managerid;
     public final int subordinateid;

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -85,11 +85,10 @@ class JdbcAdapterTest {
             + "FROM \"foodmart\".\"sales_fact_1998\"");
   }
 
-  /**
-   * Test case for
+  /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-3115">[CALCITE-3115]
    * Cannot add JdbcRules which have different JdbcConvention
-   * to same VolcanoPlanner's RuleSet.</a>*/
+   * to same VolcanoPlanner's RuleSet</a>. */
   @Test void testUnionPlan2() {
     CalciteAssert.model(JdbcTest.FOODMART_SCOTT_MODEL)
         .query("select \"store_name\" from \"foodmart\".\"store\" where \"store_id\" < 10\n"

File: core/src/test/java/org/apache/calcite/test/LogicalProjectDigestTest.java
Patch:
@@ -34,9 +34,7 @@
  * Verifies digest for {@link LogicalProject}.
  */
 class LogicalProjectDigestTest {
-  /**
-   * Planner does not compare
-   */
+  /** Planner does not compare. */
   @Test void fieldNamesDoNotInfluenceDigest() {
     final RelBuilder rb = RelBuilder.create(Frameworks.newConfigBuilder().build());
     final RelNode xAsEmpid = rb.values(new String[]{"x", "y", "z"}, 1, 2, 3)

File: core/src/test/java/org/apache/calcite/test/Matchers.java
Patch:
@@ -278,8 +278,8 @@ public static Matcher<? super Throwable> expectThrowable(Throwable expected) {
     };
   }
 
-  /**
-   * Is the numeric value within a given difference another value?
+  /** Matcher that tests whether the numeric value is within a given difference
+   * another value.
    *
    * @param <T> Value type
    */

File: core/src/test/java/org/apache/calcite/test/MutableRelTest.java
Patch:
@@ -219,7 +219,7 @@ class MutableRelTest {
     assertEquals(mutableRel1, mutableRel2);
   }
 
-  /** Verifies equivalence of {@link MutableScan} */
+  /** Verifies equivalence of {@link MutableScan}. */
   @Test public void testMutableScanEquivalence() {
     final FrameworkConfig config = RelBuilderTest.config().build();
     final RelBuilder builder = RelBuilder.create(config);

File: core/src/test/java/org/apache/calcite/test/RelOptTestBase.java
Patch:
@@ -203,6 +203,7 @@ public <T> Sql withHook(Hook hook, Consumer<T> handler) {
           FlatLists.append(hooks, hook, handler), transforms);
     }
 
+    // CHECKSTYLE: IGNORE 1
     /** @deprecated Use {@link #withHook(Hook, Consumer)}. */
     @SuppressWarnings("Guava")
     @Deprecated // to be removed before 2.0

File: core/src/test/java/org/apache/calcite/test/RexShuttleTest.java
Patch:
@@ -38,7 +38,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 
 /**
- * Unit tests for {@link RexShuttle}
+ * Unit tests for {@link RexShuttle}.
  */
 class RexShuttleTest {
 

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -95,6 +95,7 @@
 class SqlValidatorTest extends SqlValidatorTestCase {
   //~ Static fields/initializers ---------------------------------------------
 
+  // CHECKSTYLE: IGNORE 1
   /**
    * @deprecated Deprecated so that usages of this constant will show up in
    * yellow in Intellij and maybe someone will fix them.

File: core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java
Patch:
@@ -650,7 +650,7 @@ SqlTestFactory.MockCatalogReaderFactory getCatalogReaderFactory() {
         .type("RecordType(TIMESTAMP(0) NOT NULL EXPR$0) NOT NULL");
   }
 
-  /** Test case for {@link AbstractTypeCoercion#implicitCast} */
+  /** Test for {@link AbstractTypeCoercion#implicitCast}. */
   @Test void testImplicitCasts() {
     // TINYINT
     RelDataType checkedType1 = dataTypeFactory.createSqlType(SqlTypeName.TINYINT);

File: core/src/test/java/org/apache/calcite/test/catalog/Fixture.java
Patch:
@@ -157,7 +157,7 @@ private RelDataType array(RelDataType type) {
 }
 
 /**
- * Just a little trick to store factory ref before field init in fixture
+ * Just a little trick to store factory ref before field init in fixture.
  */
 abstract class AbstractFixture {
   final RelDataTypeFactory typeFactory;

File: core/src/test/java/org/apache/calcite/test/catalog/MockCatalogReader.java
Patch:
@@ -261,7 +261,7 @@ private static List<RelCollation> deduceMonotonicity(
 
   //~ Inner Classes ----------------------------------------------------------
 
-  /** Column resolver*/
+  /** Column resolver. */
   public interface ColumnResolver {
     List<Pair<RelDataTypeField, List<String>>> resolveColumn(
         RelDataType rowType, RelDataTypeFactory typeFactory, List<String> names);

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommand.java
Patch:
@@ -76,7 +76,7 @@ ConcurrentTestCommand markToFail(
 
   /**
    * Indicates that a command should have failed, but instead succeeded, which
-   * is a test error
+   * is a test error.
    */
   class ShouldHaveFailedException extends RuntimeException {
     private final String description;

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommandExecutor.java
Patch:
@@ -80,7 +80,7 @@ class ConcurrentTestCommandExecutor extends Thread {
   private final PrintStream debugPrintStream;
 
   /**
-   * Command throwing error *
+   * Command throwing error.
    */
   private ConcurrentTestCommand errorCommand;
 

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommandScript.java
Patch:
@@ -343,7 +343,7 @@ static int runAppProcess(
 
   /**
    * Gets ready to execute: loads script FILENAME applying external variable
-   * BINDINGS
+   * BINDINGS.
    */
   private void prepare(String filename, List<String> bindings)
       throws IOException {
@@ -367,7 +367,7 @@ private void prepare(String filename, List<String> bindings)
   }
 
   /**
-   * Executes the script
+   * Executes the script.
    */
   public void execute() throws Exception {
     scriptStartTime = System.currentTimeMillis();
@@ -497,7 +497,7 @@ private void storeResults(Integer threadId, ResultSet rset, long timeout)
   }
 
   /**
-   * Identifies the start of a comment line; same rules as sqlline
+   * Identifies the start of a comment line; same rules as sqlline.
    */
   private boolean isComment(String line) {
     return line.startsWith("--") || line.startsWith("#");

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestPlugin.java
Patch:
@@ -24,7 +24,7 @@
 public abstract class ConcurrentTestPlugin {
 
   /**
-   * Should containing test be disabled?
+   * Returns whether the containing test should be disabled.
    *
    * @return true if containing test should be disabled
    */

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableBatchNestedLoopJoinTest.java
Patch:
@@ -33,7 +33,7 @@
 
 /**
  * Unit test for
- * {@link org.apache.calcite.adapter.enumerable.EnumerableBatchNestedLoopJoin}
+ * {@link org.apache.calcite.adapter.enumerable.EnumerableBatchNestedLoopJoin}.
  */
 class EnumerableBatchNestedLoopJoinTest {
 

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCalcTest.java
Patch:
@@ -25,7 +25,7 @@
 
 /**
  * Unit test for
- * {@link org.apache.calcite.adapter.enumerable.EnumerableCalc}
+ * {@link org.apache.calcite.adapter.enumerable.EnumerableCalc}.
  */
 class EnumerableCalcTest {
 

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableSortedAggregateTest.java
Patch:
@@ -29,11 +29,12 @@
 
 import java.util.function.Consumer;
 
+/** Test for
+ * {@link org.apache.calcite.adapter.enumerable.EnumerableSortedAggregate}. */
 public class EnumerableSortedAggregateTest {
   @Test void sortedAgg() {
     tester(false, new JdbcTest.HrSchema())
-        .query(
-            "select deptno, "
+        .query("select deptno, "
             + "max(salary) as max_salary, count(name) as num_employee "
             + "from emps group by deptno")
         .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableUncollectTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
+/** Test for {@link EnumerableUncollect}. */
 class EnumerableUncollectTest {
 
   @Test void simpleUnnestArray() {

File: core/src/test/java/org/apache/calcite/test/fuzzer/RexProgramFuzzyTest.java
Patch:
@@ -91,7 +91,7 @@ class RexProgramFuzzyTest extends RexProgramBuilderBase {
   private static final Strong STRONG = Strong.of(ImmutableBitSet.of());
 
   /**
-   * A bounded variation of {@link PriorityQueue}
+   * A bounded variation of {@link PriorityQueue}.
    *
    * @param <E> the type of elements held in this collection
    */

File: core/src/test/java/org/apache/calcite/util/BitSetsTest.java
Patch:
@@ -187,9 +187,7 @@ private void assertToIterBitSet(final String expected, BitSet bitSet) {
     assertThat(BitSets.previousClearBit(BitSets.of(1, 3, 4), 1), equalTo(0));
   }
 
-  /**
-   * Tests the method {@link BitSets#closure(java.util.SortedMap)}
-   */
+  /** Tests the method {@link BitSets#closure(java.util.SortedMap)}. */
   @Test void testClosure() {
     final SortedMap<Integer, BitSet> empty = new TreeMap<>();
     assertThat(BitSets.closure(empty), equalTo(empty));

File: core/src/test/java/org/apache/calcite/util/SourceTest.java
Patch:
@@ -63,7 +63,7 @@ private static String getRootPrefix() {
   }
 
   /**
-   * Read lines from {@link CharSource}
+   * Read lines from {@link CharSource}.
    */
   @Test void charSource() throws IOException {
     Source source = Sources.fromCharSource(CharSource.wrap("a\nb"));

File: core/src/test/java/org/apache/calcite/util/TestUtilTest.java
Patch:
@@ -22,7 +22,7 @@
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 /**
- * Tests for TestUtil
+ * Tests for TestUtil.
  */
 class TestUtilTest {
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java
Patch:
@@ -24,7 +24,8 @@
 import java.util.List;
 
 /**
- * Binary operator conversion utility class used to convert expression like exp1 Operator exp2
+ * Binary operator conversion utility class; used to convert expressions like
+ * {@code exp1 Operator exp2}.
  */
 public class BinaryOperatorConversion implements DruidSqlOperatorConverter {
   private final SqlOperator operator;

File: druid/src/main/java/org/apache/calcite/adapter/druid/CeilOperatorConversion.java
Patch:
@@ -30,7 +30,8 @@
 import javax.annotation.Nullable;
 
 /**
- * DruidSqlOperatorConverter implementation that handles Ceil operations conversions
+ * DruidSqlOperatorConverter implementation that handles Ceil operations
+ * conversions.
  */
 public class CeilOperatorConversion implements DruidSqlOperatorConverter {
   @Override public SqlOperator calciteOperator() {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidSqlCastConverter.java
Patch:
@@ -31,7 +31,8 @@
 import java.util.TimeZone;
 
 /**
- * Druid cast converter operator used to translates calcite casts to Druid expression cast
+ * Druid cast converter operator; used to translates Calcite casts to Druid
+ * expression casts.
  */
 public class DruidSqlCastConverter implements DruidSqlOperatorConverter {
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidSqlOperatorConverter.java
Patch:
@@ -23,7 +23,8 @@
 import javax.annotation.Nullable;
 
 /**
- * Defines how to convert RexNode with a given calcite SQL operator to Druid expressions
+ * Defines how to convert a {@link RexNode} with a given Calcite SQL operator to
+ * a Druid expression.
  */
 public interface DruidSqlOperatorConverter {
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/ExtractionDimensionSpec.java
Patch:
@@ -76,10 +76,10 @@ public ExtractionDimensionSpec(String dimension, ExtractionFunction extractionFu
     generator.writeEndObject();
   }
 
-  /**
-   * @param dimensionSpec Druid Dimesion spec object
+  /** Returns a valid {@link Granularity} of floor extract, or null when not
+   * possible.
    *
-   * @return valid {@link Granularity} of floor extract or null when not possible.
+   * @param dimensionSpec Druid Dimension specification
    */
   @Nullable
   public static Granularity toQueryGranularity(DimensionSpec dimensionSpec) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/FloorOperatorConversion.java
Patch:
@@ -28,7 +28,8 @@
 import javax.annotation.Nullable;
 
 /**
- * DruidSqlOperatorConverter implementation that handles Floor operations conversions
+ * DruidSqlOperatorConverter implementation that handles Floor operations
+ * conversions.
  */
 public class FloorOperatorConversion implements DruidSqlOperatorConverter {
   @Override public SqlOperator calciteOperator() {

File: druid/src/main/java/org/apache/calcite/adapter/druid/NaryOperatorConverter.java
Patch:
@@ -26,7 +26,8 @@
 import javax.annotation.Nullable;
 
 /**
- * Converts Calcite n-ary operators to druid expression eg (arg1 Op arg2 Op arg3)
+ * Converts Calcite n-ary operators to Druid expressions, for example
+ * {@code arg1 Op arg2 Op arg3}.
  */
 public class NaryOperatorConverter implements DruidSqlOperatorConverter {
   private final SqlOperator operator;

File: druid/src/main/java/org/apache/calcite/adapter/druid/SubstringOperatorConversion.java
Patch:
@@ -27,7 +27,7 @@
 import javax.annotation.Nullable;
 
 /**
- * Converts Calcite SUBSTRING call to Druid Expression when possible
+ * Converts Calcite SUBSTRING call to Druid Expression when possible.
  */
 public class SubstringOperatorConversion implements DruidSqlOperatorConverter {
   @Override public SqlOperator calciteOperator() {

File: druid/src/main/java/org/apache/calcite/adapter/druid/UnaryPrefixOperatorConversion.java
Patch:
@@ -26,7 +26,8 @@
 import java.util.List;
 
 /**
- * Unary prefix Operator conversion class used to convert expression like Unary NOT and Minus
+ * Unary prefix Operator conversion class; used to convert expressions like
+ * Unary NOT and Minus.
  */
 public class UnaryPrefixOperatorConversion implements DruidSqlOperatorConverter {
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/UnarySuffixOperatorConversion.java
Patch:
@@ -26,7 +26,8 @@
 import java.util.List;
 
 /**
- * Unary suffix operator conversion, used to convert function like: expression Unary_Operator
+ * Unary suffix operator conversion; used to convert function likes expression
+ * Unary_Operator.
  */
 public class UnarySuffixOperatorConversion implements DruidSqlOperatorConverter {
   private final SqlOperator operator;

File: druid/src/main/java/org/apache/calcite/adapter/druid/VirtualColumn.java
Patch:
@@ -63,7 +63,7 @@ public DruidType getOutputType() {
   }
 
   /**
-   * Virtual Column Builder
+   * Virtual Column builder.
    */
   public static class Builder {
     private String name;

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchConstants.java
Patch:
@@ -32,7 +32,8 @@ interface ElasticsearchConstants {
   String SOURCE_GROOVY = "_source";
 
   /**
-   * Attribute which uniquely identifies a document (ID)
+   * Attribute that uniquely identifies a document (ID).
+   *
    * @see <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-id-field.html">ID Field</a>
    */
   String ID = "_id";

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRules.java
Patch:
@@ -82,9 +82,9 @@ private static String isItemCall(RexCall call) {
 
   /**
    * Checks if current node represents item access as in {@code _MAP['foo']} or
-   * {@code cast(_MAP['foo'] as integer)}
+   * {@code cast(_MAP['foo'] as integer)}.
    *
-   * @return true if expression is item, false otherwise
+   * @return whether expression is item
    */
   static boolean isItem(RexNode node) {
     final Boolean result = node.accept(new RexVisitorImpl<Boolean>(false) {

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
Patch:
@@ -102,7 +102,7 @@ private Map<String, Table> createTables(Iterable<String> indices) {
   }
 
   /**
-   * Queries {@code _alias} definition to automatically detect all indices
+   * Queries {@code _alias} definition to automatically detect all indices.
    *
    * @return list of indices
    * @throws IOException for any IO related issues

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java
Patch:
@@ -98,7 +98,8 @@ public ElasticsearchSchemaFactory() {
   }
 
   /**
-   * Builds elastic rest client from user configuration
+   * Builds Elastic rest client from user configuration.
+   *
    * @param hosts list of ES HTTP Hosts to connect to
    * @return newly initialized low-level rest http client for ES
    */

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java
Patch:
@@ -76,7 +76,8 @@ final class ElasticsearchTransport {
   final ElasticsearchMapping mapping;
 
   /**
-   * Default batch size
+   * Default batch size.
+   *
    * @see <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html">Scrolling API</a>
    */
   final int fetchSize;

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
Patch:
@@ -98,9 +98,8 @@ private static class AutoClosingIterator implements Iterator<ElasticsearchJson.R
     /** Returns whether {@link #closer} consumer was already called. */
     private boolean closed;
 
-    /**
-     * Keeps last value of {@code scrollId} in memory so scroll can be released upon termination
-     */
+    /** Keeps last value of {@code scrollId} in memory so scroll can be released
+     * upon termination. */
     private String scrollId;
 
     private AutoClosingIterator(

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/BooleanLogicTest.java
Patch:
@@ -51,7 +51,8 @@ class BooleanLogicTest {
   private static final String NAME = "booleanlogic";
 
   /**
-   * Used to create {@code zips} index and insert some data
+   * Creates {@code zips} index and inserts some data.
+   *
    * @throws Exception when ES node setup failed
    */
   @BeforeAll

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchVersionTest.java
Patch:
@@ -24,7 +24,7 @@
 import static org.junit.jupiter.api.Assertions.fail;
 
 /**
- * Basic tests for parsing ES version in different formats
+ * Basic tests for parsing Elasticsearch version in different formats.
  */
 class ElasticsearchVersionTest {
 

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/EmbeddedElasticsearchPolicy.java
Patch:
@@ -68,6 +68,7 @@ class EmbeddedElasticsearchPolicy {
   private final Closer closer;
   private RestClient client;
 
+  /** Holds the singleton policy instance. */
   static class Singleton {
     static final EmbeddedElasticsearchPolicy INSTANCE =
         new EmbeddedElasticsearchPolicy(EmbeddedElasticsearchNode.create());

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/MatchTest.java
Patch:
@@ -75,9 +75,10 @@
 @ResourceLock(value = "elasticsearch-scrolls", mode = ResourceAccessMode.READ)
 class MatchTest {
 
-  public static final EmbeddedElasticsearchPolicy NODE = EmbeddedElasticsearchPolicy.create();
+  public static final EmbeddedElasticsearchPolicy NODE =
+      EmbeddedElasticsearchPolicy.create();
 
-  /** Default index/type name */
+  /** Default index/type name. */
   private static final String ZIPS = "match-zips";
   private static final int ZIPS_SIZE = 149;
 

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/Projection2Test.java
Patch:
@@ -49,7 +49,7 @@
 
 
 /**
- * Checks renaming of fields (also upper, lower cases) during projections
+ * Checks renaming of fields (also upper, lower cases) during projections.
  */
 @Disabled("RestClient often timeout in PR CI")
 @ResourceLock(value = "elasticsearch-scrolls", mode = ResourceAccessMode.READ)
@@ -194,12 +194,12 @@ private CalciteAssert.ConnectionFactory newConnectionFactory() {
   }
 
   /**
-   * Avoid using scripting for simple projections
+   * Avoid using scripting for simple projections.
    *
    * <p> When projecting simple fields (without expression) no
    * <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html">scripting</a>
    * should be used just
-   * <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-source-filtering.html">_source</a>
+   * <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-source-filtering.html">_source</a>.
    */
   @Test void simpleProjectionNoScripting() {
     CalciteAssert.that()

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/ProjectionTest.java
Patch:
@@ -40,7 +40,7 @@
 import java.util.Map;
 
 /**
- * Checks renaming of fields (also upper, lower cases) during projections
+ * Checks renaming of fields (also upper, lower cases) during projections.
  */
 @Disabled("RestClient often timeout in PR CI")
 @ResourceLock(value = "elasticsearch-scrolls", mode = ResourceAccessMode.READ)

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/QueryBuildersTest.java
Patch:
@@ -34,7 +34,8 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
 /**
- * Check that internal queries are correctly converted to ES search query (as JSON)
+ * Check that internal queries are correctly converted to ES search query (as
+ * JSON).
  */
 class QueryBuildersTest {
 

File: elasticsearch/src/test/java/org/apache/calcite/test/ElasticsearchChecker.java
Patch:
@@ -34,7 +34,7 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
 /**
- * Internal util methods for ElasticSearch tests
+ * Internal utility methods for Elasticsearch tests.
  */
 public class ElasticsearchChecker {
 

File: file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java
Patch:
@@ -185,7 +185,7 @@ private static String resourcePath(String path) {
     assertTrue(row.get(2).text().equals("R0C2"));
   }
 
-  /** Tests {@link FileReader} iterator with static file, */
+  /** Tests {@link FileReader} iterator with a static file. */
   @Test void testFileReaderIterator() throws FileReaderException {
     final Source source = resource("tableOK.html");
     FileReader t = new FileReader(source);

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
Patch:
@@ -55,7 +55,7 @@
 import java.util.Map;
 
 /**
- * Table based on a Geode Region
+ * Table based on a Geode Region.
  */
 public class GeodeTable extends AbstractQueryableTable implements TranslatableTable {
 

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/package-info.java
Patch:
@@ -16,6 +16,6 @@
  */
 
 /**
- * Query provider based on Apache Geode (Gemfire) In Memory Data Grid
+ * Query provider based on Apache Geode (Gemfire) in-memory data grid.
  */
 package org.apache.calcite.adapter.geode.rel;

File: geode/src/main/java/org/apache/calcite/adapter/geode/simple/GeodeSimpleScannableTable.java
Patch:
@@ -30,7 +30,7 @@
 import static org.apache.calcite.adapter.geode.util.GeodeUtils.convertToRowValues;
 
 /**
- * Geode Simple Scannable Table Abstraction
+ * Geode Simple Scannable Table abstraction.
  */
 public class GeodeSimpleScannableTable extends AbstractTable implements ScannableTable {
 

File: geode/src/main/java/org/apache/calcite/adapter/geode/simple/package-info.java
Patch:
@@ -16,6 +16,6 @@
  */
 
 /**
- * Query provider based on Apache Geode (Gemfire) In Memory Data Grid
+ * Query evaluation runtime for Apache Geode adapter.
  */
 package org.apache.calcite.adapter.geode.simple;

File: geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
Patch:
@@ -116,7 +116,7 @@ public static synchronized void closeClientCache() {
   }
 
   /**
-   * Obtains a proxy pointing to an existing Region on the server
+   * Obtains a proxy pointing to an existing Region on the server.
    *
    * @param cache {@link GemFireCache} instance to interact with the Geode server
    * @param regionName  Name of the region to create proxy for.

File: geode/src/main/java/org/apache/calcite/adapter/geode/util/package-info.java
Patch:
@@ -16,6 +16,6 @@
  */
 
 /**
- * Query provider based on Apache Geode (Gemfire) In Memory Data Grid
+ * Utilities for Apache Geode adapter.
  */
 package org.apache.calcite.adapter.geode.util;

File: geode/src/test/java/org/apache/calcite/adapter/geode/rel/GeodeAllDataTypesTest.java
Patch:
@@ -39,9 +39,7 @@
 import java.util.List;
 import java.util.Map;
 
-/**
- * Test with different types of data like boolean, time, timestamp
- */
+/** Test with different types of data, like BOOLEAN, TIME, TIMESTAMP. */
 class GeodeAllDataTypesTest extends AbstractGeodeTest {
 
   @BeforeAll

File: geode/src/test/java/org/apache/calcite/adapter/geode/simple/BookMasterRegionTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.geode.pdx.ReflectionBasedAutoSerializer;
 
 /**
- *
+ * Test based on BookMaster region.
  */
 class BookMasterRegionTest {
 

File: kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaMessageEnumerator.java
Patch:
@@ -30,9 +30,10 @@
 /**
  * Enumerator to read data from {@link Consumer},
  * and converted into SQL rows with {@link KafkaRowConverter}.
- * @param <K>: type for Kafka message key,
+ *
+ * @param <K> Type for Kafka message key,
  *           refer to {@link ConsumerConfig#KEY_DESERIALIZER_CLASS_CONFIG};
- * @param <V>: type for Kafka message value,
+ * @param <V> Type for Kafka message value,
  *           refer to {@link ConsumerConfig#VALUE_DESERIALIZER_CLASS_CONFIG};
  */
 public class KafkaMessageEnumerator<K, V> implements Enumerator<Object[]> {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ArrayLengthRecordField.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Objects;
 
 /**
- * Represents a length field of a RecordType
+ * Length field of a RecordType.
  */
 public class ArrayLengthRecordField implements Types.RecordField {
   private final String fieldName;

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockStatement.java
Patch:
@@ -28,9 +28,7 @@
  */
 public class BlockStatement extends Statement {
   public final List<Statement> statements;
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cached hash code for the expression. */
   private int hash;
 
   BlockStatement(List<Statement> statements, Type type) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConstructorDeclaration.java
Patch:
@@ -31,9 +31,7 @@ public class ConstructorDeclaration extends MemberDeclaration {
   public final Type resultType;
   public final List<ParameterExpression> parameters;
   public final BlockStatement body;
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cached hash code for the expression. */
   private int hash;
 
   public ConstructorDeclaration(int modifier, Type declaredAgainst,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
Patch:
@@ -85,7 +85,7 @@ public DeterministicCodeOptimizer(ClassDeclarationFinder parent) {
   }
 
   /**
-   * Optimizes {@code new Type()} constructs,
+   * Optimizes {@code new Type()} constructs.
    *
    * @param newExpression expression to optimize
    * @return optimized expression

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForEachStatement.java
Patch:
@@ -19,14 +19,14 @@
 import java.util.Objects;
 
 /**
- * Represents a "for-each" loop, "for (T v : iterable) { f(v); }"
+ * Represents a "for-each" loop, "for (T v : iterable) { f(v); }".
  */
 public class ForEachStatement extends Statement {
   public final ParameterExpression parameter;
   public final Expression iterable;
   public final Statement body;
 
-  /** Cache the hash code for the expression */
+  /** Cached hash code for the expression. */
   private int hash;
 
   public ForEachStatement(ParameterExpression parameter, Expression iterable,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForStatement.java
Patch:
@@ -29,9 +29,7 @@ public class ForStatement extends Statement {
   public final Expression condition;
   public final Expression post;
   public final Statement body;
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cached hash code for the expression. */
   private int hash;
 
   public ForStatement(List<DeclarationStatement> declarations,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/FunctionExpression.java
Patch:
@@ -42,9 +42,7 @@ public final class FunctionExpression<F extends Function<?>>
   public final BlockStatement body;
   public final List<ParameterExpression> parameterList;
   private F dynamicFunction;
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cached hash code for the expression. */
   private int hash;
 
   private FunctionExpression(Class<F> type, F function, BlockStatement body,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/MethodCallExpression.java
Patch:
@@ -30,9 +30,7 @@ public class MethodCallExpression extends Expression {
   public final Method method;
   public final Expression targetExpression; // null for call to static method
   public final List<Expression> expressions;
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cached hash code for the expression. */
   private int hash;
 
   MethodCallExpression(Type returnType, Method method,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/NewArrayExpression.java
Patch:
@@ -28,9 +28,7 @@ public class NewArrayExpression extends Expression {
   public final int dimension;
   public final Expression bound;
   public final List<Expression> expressions;
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cached hash code for the expression. */
   private int hash;
 
   public NewArrayExpression(Type type, int dimension, Expression bound,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/NewExpression.java
Patch:
@@ -30,9 +30,7 @@ public class NewExpression extends Expression {
   public final Type type;
   public final List<Expression> arguments;
   public final List<MemberDeclaration> memberDeclarations;
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cached hash code for the expression. */
   private int hash;
 
   public NewExpression(Type type, List<Expression> arguments,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/OptimizeShuttle.java
Patch:
@@ -406,9 +406,8 @@ protected boolean isKnownNotNull(Expression expression) {
                 ((MethodCallExpression) expression).method));
   }
 
-  /**
-   * Treats two expressions equal even if they represent different null types
-   */
+  /** Compares two expressions for equality, treating them as equal even if they
+   * represent different null types. */
   private static boolean eq(Expression a, Expression b) {
     return a.equals(b)
         || (a instanceof ConstantExpression

File: core/src/test/java/org/apache/calcite/test/AbstractMaterializedViewTest.java
Patch:
@@ -108,7 +108,7 @@ private void checkMaterialize(Sql sql) {
       for (RelNode sub: substitutes) {
         substituteMessages.append(RelOptUtil.toString(sub)).append("\n");
       }
-      throw new AssertionError("Materialized view failed to be matched by optmized results:\n"
+      throw new AssertionError("Materialized view failed to be matched by optimized results:\n"
           + substituteMessages.toString());
     }
   }
@@ -124,7 +124,7 @@ private void checkNoMaterialize(Sql sql) {
       return;
     }
     final StringBuilder errMsgBuilder = new StringBuilder();
-    errMsgBuilder.append("Optmization succeeds out of expectation: ");
+    errMsgBuilder.append("Optimization succeeds out of expectation: ");
     for (RelNode res: results) {
       errMsgBuilder.append(RelOptUtil.toString(res)).append("\n");
     }

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -114,6 +114,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.math.BigDecimal;
 import java.sql.ResultSet;
 import java.sql.Time;
 import java.sql.Timestamp;
@@ -610,7 +611,8 @@ public enum BuiltInMethod {
   HOPPING(EnumUtils.class, "hopping", Enumerator.class, int.class, long.class,
       long.class, long.class),
   SESSIONIZATION(EnumUtils.class, "sessionize", Enumerator.class, int.class, int.class,
-      long.class);
+      long.class),
+  BIG_DECIMAL_NEGATE(BigDecimal.class, "negate");
 
   public final Method method;
   public final Constructor constructor;

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -1202,6 +1202,9 @@ public static boolean equalSansNullability(
    * @return true if the types are equal or the only difference is nullability
    */
   public static boolean equalSansNullability(RelDataType type1, RelDataType type2) {
+    if (type1 == type2) {
+      return true;
+    }
     String x = type1.getFullTypeString();
     String y = type2.getFullTypeString();
     if (x.length() < y.length()) {

File: core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
Patch:
@@ -179,7 +179,8 @@ public void register(RelOptPlanner planner) {
     Util.discard(planner);
   }
 
-  public final String getRelTypeName() {
+  // It is not recommended to override this method, but sub-classes can do it at their own risk.
+  public String getRelTypeName() {
     String cn = getClass().getName();
     int i = cn.length();
     while (--i >= 0) {

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -1387,9 +1387,9 @@ public enum SqlKind {
   public static final Set<SqlKind> SIMPLE_BINARY_OPS;
 
   static {
-    EnumSet<SqlKind> kinds = EnumSet.of(SqlKind.PLUS, SqlKind.MINUS, SqlKind.TIMES, SqlKind.DIVIDE);
-    kinds.addAll(SqlKind.COMPARISON);
-    kinds.remove(SqlKind.IN);
+    EnumSet<SqlKind> kinds = EnumSet.copyOf(SqlKind.BINARY_ARITHMETIC);
+    kinds.remove(SqlKind.MOD);
+    kinds.addAll(SqlKind.BINARY_COMPARISON);
     SIMPLE_BINARY_OPS = Sets.immutableEnumSet(kinds);
   }
 

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -252,7 +252,7 @@ class JdbcAdapterTest {
             + "on s.losal <= e.sal and s.hisal >= e.sal")
         .explainContains("PLAN=JdbcToEnumerableConverter\n"
             + "  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\n"
-            + "    JdbcJoin(condition=[AND(>=($2, $4), <=($2, $5))], joinType=[inner])\n"
+            + "    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\n"
             + "      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\n"
             + "        JdbcTableScan(table=[[SCOTT, EMP]])\n"
             + "      JdbcTableScan(table=[[SCOTT, SALGRADE]])")
@@ -295,7 +295,7 @@ class JdbcAdapterTest {
             + "e.mgr = m.empno and (e.sal > m.sal or m.hiredate > e.hiredate)")
         .explainContains("PLAN=JdbcToEnumerableConverter\n"
             + "  JdbcProject(EMPNO=[$0], ENAME=[$1], EMPNO0=[$0], ENAME0=[$1])\n"
-            + "    JdbcJoin(condition=[AND(=($2, $5), OR(>($4, $7), <($3, $6)))], joinType=[inner])\n"
+            + "    JdbcJoin(condition=[AND(=($2, $5), OR(>($4, $7), >($6, $3)))], joinType=[inner])\n"
             + "      JdbcProject(EMPNO=[$0], ENAME=[$1], MGR=[$3], HIREDATE=[$4], SAL=[$5])\n"
             + "        JdbcTableScan(table=[[SCOTT, EMP]])\n"
             + "      JdbcProject(EMPNO=[$0], HIREDATE=[$4], SAL=[$5])\n"

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -234,9 +234,9 @@ private static CalciteAssert.AssertThat modelWithLattices(
           final Map.Entry<String, CalciteSchema.LatticeEntry> entry =
               adhoc.unwrap(CalciteSchema.class).getLatticeMap().firstEntry();
           final Lattice lattice = entry.getValue().getLattice();
-          assertThat(lattice.firstColumn("S"), is(0));
-          assertThat(lattice.firstColumn("P"), is(8));
-          assertThat(lattice.firstColumn("T"), is(23));
+          assertThat(lattice.firstColumn("S"), is(10));
+          assertThat(lattice.firstColumn("P"), is(18));
+          assertThat(lattice.firstColumn("T"), is(0));
           assertThat(lattice.firstColumn("PC"), is(-1));
           assertThat(lattice.defaultMeasures.size(), is(1));
           assertThat(lattice.rootNode.descendants.size(), is(3));

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -1978,7 +1978,7 @@ private RelNode buildRelWithDuplicateAggregates(
         + "  LogicalTableScan(table=[[scott, DEPT]])\n";
     final String expectedWithoutSimplify = ""
         + "LogicalJoin(condition=[OR(null:NULL, "
-        + "AND(=($7, 1), =($7, 2), =($7, $8)))], joinType=[inner])\n"
+        + "AND(=($7, 1), =($7, 2), =($8, $7)))], joinType=[inner])\n"
         + "  LogicalTableScan(table=[[scott, EMP]])\n"
         + "  LogicalTableScan(table=[[scott, DEPT]])\n";
     assertThat(f.apply(createBuilder()), hasTree(expected));
@@ -2151,7 +2151,7 @@ private RelNode buildRelWithDuplicateAggregates(
                     builder.field("e", "MGR")))
             .build();
     final String expected = ""
-        + "LogicalFilter(condition=[AND(=($7, $16), =($3, $8))])\n"
+        + "LogicalFilter(condition=[AND(=($7, $16), =($8, $3))])\n"
         + "  LogicalJoin(condition=[true], joinType=[inner])\n"
         + "    LogicalTableScan(table=[[scott, EMP]])\n"
         + "    LogicalJoin(condition=[true], joinType=[inner])\n"

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCorrelateTest.java
Patch:
@@ -99,7 +99,7 @@ class EnumerableCorrelateTest {
             + "  EnumerableCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{0}])\n"
             + "    EnumerableAggregate(group=[{0}])\n"
             + "      EnumerableTableScan(table=[[s, depts]])\n"
-            + "    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[$cor1], expr#6=[$t5.deptno], expr#7=[=($t6, $t1)], proj#0..2=[{exprs}], $condition=[$t7])\n"
+            + "    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[$cor1], expr#6=[$t5.deptno], expr#7=[=($t1, $t6)], proj#0..2=[{exprs}], $condition=[$t7])\n"
             + "      EnumerableTableScan(table=[[s, emps]])")
         .returnsUnordered(
             "empid=100; name=Bill",
@@ -129,7 +129,7 @@ class EnumerableCorrelateTest {
             + "  EnumerableCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{0}])\n"
             + "    EnumerableAggregate(group=[{0}])\n"
             + "      EnumerableTableScan(table=[[s, depts]])\n"
-            + "    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[$cor1], expr#6=[$t5.deptno], expr#7=[=($t6, $t1)], expr#8=[100], expr#9=[>($t0, $t8)], expr#10=[AND($t7, $t9)], proj#0..2=[{exprs}], $condition=[$t10])\n"
+            + "    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[$cor1], expr#6=[$t5.deptno], expr#7=[=($t1, $t6)], expr#8=[100], expr#9=[>($t0, $t8)], expr#10=[AND($t7, $t9)], proj#0..2=[{exprs}], $condition=[$t10])\n"
             + "      EnumerableTableScan(table=[[s, emps]])")
         .returnsUnordered(
             "empid=110; name=Theodore",

File: core/src/main/java/org/apache/calcite/sql/fun/SqlDotOperator.java
Patch:
@@ -111,6 +111,9 @@ public class SqlDotOperator extends SqlSpecialOperator {
           Static.RESOURCE.unknownField(fieldName));
     }
     RelDataType type = field.getType();
+    if (nodeType.isNullable()) {
+      type = validator.getTypeFactory().createTypeWithNullability(type, true);
+    }
 
     // Validate and determine coercibility and resulting collation
     // name of binary operator if needed.

File: core/src/test/java/org/apache/calcite/sql/parser/parserextensiontesting/ExtensionSqlParserTest.java
Patch:
@@ -55,6 +55,6 @@ class ExtensionSqlParserTest extends SqlParserTest {
     sql("DESCRIBE SPACE POWER")
         .node(new IsNull<SqlNode>());
     sql("DESCRIBE SEA ^POWER^")
-        .fails("(?s)Encountered \"POWER\" at line 1, column 14..*");
+        .fails("(?s)Incorrect syntax near the keyword 'POWER' at line 1, column 14.*");
   }
 }

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -8350,7 +8350,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     tester.checkFails("timestampdiff(CENTURY, "
         + "timestamp '2014-02-24 12:42:25', "
         + "timestamp '2614-02-24 12:42:25')",
-        "(?s)Encountered \"CENTURY\" at .*", false);
+        "(?s)Incorrect syntax near the keyword 'CENTURY' at .*", false);
     tester.checkScalar("timestampdiff(QUARTER, "
         + "timestamp '2014-02-24 12:42:25', "
         + "cast(null as timestamp))",

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -1566,7 +1566,7 @@ public void _testLikeAndSimilarFails() {
       expr("\"TRIM\"('b')").ok();
     } else {
       expr("^\"TRIM\"('b' FROM 'a')^")
-          .fails("(?s).*Encountered \"FROM\" at .*");
+          .fails("(?s).*Incorrect syntax near the keyword 'FROM' at .*");
 
       // Without the "FROM" noise word, TRIM is parsed as a regular
       // function without quoting and built-in function with quoting.

File: core/src/main/java/org/apache/calcite/sql/SqlHopTableFunction.java
Patch:
@@ -24,9 +24,9 @@
 
 /**
  * SqlHopTableFunction implements an operator for hopping. It allows four parameters:
- * 1. a table.
- * 2. a descriptor to provide a watermarked column name from the input table.
- * 3. an interval parameter to specify the length of window shifting.
+ * 1. a table;
+ * 2. a descriptor to provide a watermarked column name from the input table;
+ * 3. an interval parameter to specify the length of window shifting;
  * 4. an interval parameter to specify the length of window size.
  */
 public class SqlHopTableFunction extends SqlWindowTableFunction {

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -1270,7 +1270,7 @@ private void substituteSubQuery(Blackboard bb, SubQuery subQuery) {
 
       // This is used when converting window table functions:
       //
-      // select * from table(table emps, descriptor(deptno), interval '3' DAY)
+      // select * from table(tumble(table emps, descriptor(deptno), interval '3' DAY))
       //
       bb.cursors.add(converted.r);
       return;

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -1240,6 +1240,7 @@ public enum SqlKind {
    * {@link #ORDER_BY},
    * {@link #COLLECTION_TABLE},
    * {@link #TABLESAMPLE},
+   * {@link #UNNEST}
    * or an aggregate function, DML or DDL.
    */
   public static final Set<SqlKind> EXPRESSION =
@@ -1254,7 +1255,7 @@ public enum SqlKind {
                   LITERAL_CHAIN, JDBC_FN, PRECEDING, FOLLOWING, ORDER_BY,
                   NULLS_FIRST, NULLS_LAST, COLLECTION_TABLE, TABLESAMPLE,
                   VALUES, WITH, WITH_ITEM, ITEM, SKIP_TO_FIRST, SKIP_TO_LAST,
-                  JSON_VALUE_EXPRESSION),
+                  JSON_VALUE_EXPRESSION, UNNEST),
               AGGREGATE, DML, DDL));
 
   /**

File: core/src/test/java/org/apache/calcite/test/SqlJsonFunctionsTest.java
Patch:
@@ -62,6 +62,9 @@ class SqlJsonFunctionsTest {
   }
 
   @Test void testJsonApiCommonSyntax() {
+    assertJsonApiCommonSyntax("{\"foo\": \"bar\"}", "$.foo",
+        contextMatches(
+            JsonFunctions.JsonPathContext.withJavaObj(JsonFunctions.PathMode.STRICT, "bar")));
     assertJsonApiCommonSyntax("{\"foo\": \"bar\"}", "lax $.foo",
         contextMatches(
             JsonFunctions.JsonPathContext.withJavaObj(JsonFunctions.PathMode.LAX, "bar")));

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -252,7 +252,9 @@ public RelDataType toType(RelDataTypeFactory typeFactory, Object o) {
               new SqlIntervalQualifier(startUnit, endUnit, SqlParserPos.ZERO));
         }
         final RelDataType type;
-        if (precision == null) {
+        if (sqlTypeName == SqlTypeName.ARRAY) {
+          type = typeFactory.createArrayType(typeFactory.createSqlType(SqlTypeName.ANY), -1);
+        } else if (precision == null) {
           type = typeFactory.createSqlType(sqlTypeName);
         } else if (scale == null) {
           type = typeFactory.createSqlType(sqlTypeName, precision);

File: core/src/main/java/org/apache/calcite/rex/RexCall.java
Patch:
@@ -327,7 +327,8 @@ public RexCall clone(RelDataType type, List<RexNode> operands) {
     }
     RexCall rexCall = (RexCall) o;
     return op.equals(rexCall.op)
-        && operands.equals(rexCall.operands);
+        && operands.equals(rexCall.operands)
+        && type.equals(rexCall.type);
   }
 
   @Override public int hashCode() {

File: core/src/main/java/org/apache/calcite/schema/impl/TableFunctionImpl.java
Patch:
@@ -137,7 +137,7 @@ public Expression implement(RexToLixTranslator translator,
             }
             return expr;
           }
-        }, NullPolicy.ANY, false);
+        }, NullPolicy.NONE, false);
   }
 
   private Table apply(List<Object> arguments) {

File: core/src/test/java/org/apache/calcite/test/MaterializedViewRelOptRulesTest.java
Patch:
@@ -821,7 +821,8 @@ public class MaterializedViewRelOptRulesTest extends AbstractMaterializedViewTes
         .withChecker(
             resultContains(""
             + "EnumerableCalc(expr#0=[{inputs}], expr#1=[CAST($t0):JavaType(int) NOT NULL], "
-            + "expr#2=[1], expr#3=[=($t2, $t0)], EXPR$0=[$t1], $condition=[$t3])\n"
+            + "expr#2=[1], expr#3=[CAST($t1):INTEGER NOT NULL], expr#4=[=($t2, $t3)], "
+            + "EXPR$0=[$t1], $condition=[$t4])\n"
             + "  EnumerableTableScan(table=[[hr, MV0]])"))
         .ok();
   }

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCalcTest.java
Patch:
@@ -47,7 +47,7 @@ class EnumerableCalcTest {
                     builder.field("commission"),
                     builder.literal(0)))
                 .build())
-        .planContains("inp4_ != null ? inp4_.intValue() : 0;")
+        .planContains("input_value != null ? input_value : 0")
         .returnsUnordered(
             "$f0=0",
             "$f0=250",

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
Patch:
@@ -159,7 +159,7 @@ public List<RelNode> getRelsFromAllSubsets() {
 
   public RelSubset getSubset(RelTraitSet traits) {
     for (RelSubset subset : subsets) {
-      if (subset.getTraitSet() == traits) {
+      if (subset.getTraitSet().equals(traits)) {
         return subset;
       }
     }

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFieldImpl.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 
 import java.io.Serializable;
+import java.util.Objects;
 
 /**
  * Default implementation of {@link RelDataTypeField}.
@@ -49,9 +50,7 @@ public RelDataTypeFieldImpl(
   //~ Methods ----------------------------------------------------------------
 
   @Override public int hashCode() {
-    return index
-        ^ name.hashCode()
-        ^ type.hashCode();
+    return Objects.hash(index, name, type);
   }
 
   @Override public boolean equals(Object obj) {

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
Patch:
@@ -449,7 +449,7 @@ public boolean caseWhenCoercion(SqlCallBinding callBinding) {
    */
   public boolean inOperationCoercion(SqlCallBinding binding) {
     SqlOperator operator = binding.getOperator();
-    if (operator.getKind() == SqlKind.IN) {
+    if (operator.getKind() == SqlKind.IN || operator.getKind() == SqlKind.NOT_IN) {
       assert binding.getOperandCount() == 2;
       final RelDataType type1 = binding.getOperandType(0);
       final RelDataType type2 = binding.getOperandType(1);

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
Patch:
@@ -523,7 +523,7 @@ public JdbcProjectRule(final JdbcConvention out,
 
     private static boolean userDefinedFunctionInProject(Project project) {
       CheckingUserDefinedFunctionVisitor visitor = new CheckingUserDefinedFunctionVisitor();
-      for (RexNode node : project.getChildExps()) {
+      for (RexNode node : project.getProjects()) {
         node.accept(visitor);
         if (visitor.containsUserDefinedFunction()) {
           return true;

File: core/src/main/java/org/apache/calcite/plan/MaterializedViewSubstitutionVisitor.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * Extension to {@link SubstitutionVisitor}.
  */
-@Deprecated // Kept for backward compatibility and to be removed before 2.0
+@Deprecated // to be removed before 2.0
 public class MaterializedViewSubstitutionVisitor extends SubstitutionVisitor {
 
   public MaterializedViewSubstitutionVisitor(RelNode target_, RelNode query_) {

File: core/src/main/java/org/apache/calcite/plan/RelOptNode.java
Patch:
@@ -47,7 +47,7 @@ public interface RelOptNode {
    *
    * @return Digest of this {@code RelNode}
    */
-  String getDigest();
+  Digest getDigest();
 
   /**
    * Retrieves this RelNode's traits. Note that although the RelTraitSet

File: core/src/main/java/org/apache/calcite/plan/hep/HepRelVertex.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.plan.hep;
 
+import org.apache.calcite.plan.Digest;
 import org.apache.calcite.plan.RelOptCost;
 import org.apache.calcite.plan.RelOptPlanner;
 import org.apache.calcite.plan.RelTraitSet;
@@ -75,8 +76,8 @@ public class HepRelVertex extends AbstractRelNode {
     return currentRel.getRowType();
   }
 
-  @Override protected String computeDigest() {
-    return "HepRelVertex(" + currentRel + ")";
+  @Override protected Digest computeDigest() {
+    return Digest.create(this, getRelTypeName() + '#' + getCurrentRel().getId());
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/RelNode.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.rel;
 
 import org.apache.calcite.plan.Convention;
+import org.apache.calcite.plan.Digest;
 import org.apache.calcite.plan.RelOptCost;
 import org.apache.calcite.plan.RelOptNode;
 import org.apache.calcite.plan.RelOptPlanner;
@@ -308,7 +309,7 @@ public interface RelNode extends RelOptNode, Cloneable {
    *
    * @return Digest of this relational expression
    */
-  String recomputeDigest();
+  Digest recomputeDigest();
 
   /**
    * Replaces the <code>ordinalInParent</code><sup>th</sup> input. You must

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java
Patch:
@@ -361,7 +361,7 @@ public Set<RexNode> getExpressionLineage(Project rel,
     // Infer column origin expressions for given references
     final Map<RexInputRef, Set<RexNode>> mapping = new LinkedHashMap<>();
     for (int idx : inputFieldsUsed) {
-      final RexNode inputExpr = rel.getChildExps().get(idx);
+      final RexNode inputExpr = rel.getProjects().get(idx);
       final Set<RexNode> originalExprs = mq.getExpressionLineage(input, inputExpr);
       if (originalExprs == null) {
         // Bail out

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -326,13 +326,13 @@ public Result visit(Project e) {
     e.getVariablesSet();
     Result x = visitChild(0, e.getInput());
     parseCorrelTable(e, x);
-    if (isStar(e.getChildExps(), e.getInput().getRowType(), e.getRowType())) {
+    if (isStar(e.getProjects(), e.getInput().getRowType(), e.getRowType())) {
       return x;
     }
     final Builder builder =
         x.builder(e, Clause.SELECT);
     final List<SqlNode> selectList = new ArrayList<>();
-    for (RexNode ref : e.getChildExps()) {
+    for (RexNode ref : e.getProjects()) {
       SqlNode sqlExpr = builder.context.toSql(null, ref);
       if (SqlUtil.isNullLiteral(sqlExpr, false)) {
         sqlExpr = castNullType(sqlExpr, e.getRowType().getFieldList().get(selectList.size()));

File: core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
Patch:
@@ -171,11 +171,11 @@ public void onMatch(RelOptRuleCall call) {
     }
 
     // Skip projects containing over clause
-    if (leftProj != null && RexOver.containsOver(leftProj.getChildExps(), null)) {
+    if (leftProj != null && RexOver.containsOver(leftProj.getProjects(), null)) {
       leftProj = null;
       leftJoinChild = joinRel.getLeft();
     }
-    if (rightProj != null && RexOver.containsOver(rightProj.getChildExps(), null)) {
+    if (rightProj != null && RexOver.containsOver(rightProj.getProjects(), null)) {
       rightProj = null;
       rightJoinChild = joinRel.getRight();
     }

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectWindowTransposeRule.java
Patch:
@@ -174,7 +174,7 @@ public ProjectWindowTransposeRule(RelBuilderFactory relBuilderFactory) {
 
     // Modify the top LogicalProject
     final List<RexNode> topProjExps =
-        indexAdjustment.visitList(project.getChildExps());
+        indexAdjustment.visitList(project.getProjects());
 
     final LogicalProject newTopProj = project.copy(
         newLogicalWindow.getTraitSet(),
@@ -205,7 +205,7 @@ private ImmutableBitSet findReference(final LogicalProject project,
     };
 
     // Reference in LogicalProject
-    referenceFinder.visitEach(project.getChildExps());
+    referenceFinder.visitEach(project.getProjects());
 
     // Reference in LogicalWindow
     for (Window.Group group : window.groups) {

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
Patch:
@@ -245,7 +245,7 @@ protected MaterializedViewJoinRule(RelOptRuleOperand operand,
       EquivalenceClasses queryEC) {
     List<RexNode> exprs = topProject == null
         ? extractReferences(rexBuilder, node)
-        : topProject.getChildExps();
+        : topProject.getProjects();
     List<RexNode> exprsLineage = new ArrayList<>(exprs.size());
     for (RexNode expr : exprs) {
       Set<RexNode> s = mq.getExpressionLineage(node, expr);
@@ -262,7 +262,7 @@ protected MaterializedViewJoinRule(RelOptRuleOperand operand,
     }
     List<RexNode> viewExprs = topViewProject == null
         ? extractReferences(rexBuilder, viewNode)
-        : topViewProject.getChildExps();
+        : topViewProject.getProjects();
     List<RexNode> rewrittenExprs = rewriteExpressions(rexBuilder, mq, input, viewNode, viewExprs,
         queryToViewTableMapping.inverse(), queryEC, true, exprsLineage);
     if (rewrittenExprs == null) {

File: core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
Patch:
@@ -428,7 +428,7 @@ protected void perform(RelOptRuleCall call, Project topProject, RelNode node) {
               // in the view output (condition 2).
               List<RexNode> viewExprs = topViewProject == null
                   ? extractReferences(rexBuilder, view)
-                  : topViewProject.getChildExps();
+                  : topViewProject.getProjects();
               // For compensationColumnsEquiPred, we use the view equivalence classes,
               // since we want to enforce the rest
               if (!compensationColumnsEquiPred.isAlwaysTrue()) {

File: core/src/test/java/org/apache/calcite/materialize/LatticeSuggesterTest.java
Patch:
@@ -670,12 +670,12 @@ private void checkDerivedColumn(Lattice lattice, List<String> tables,
     t.addQuery(q0);
     assertThat(t.s.latticeMap.size(), is(1));
     assertThat(t.s.latticeMap.keySet().iterator().next(),
-        is("sales_fact_1997 (customer:+(2, $2)):[MIN(customer.fname)]"));
+        is("sales_fact_1997 (customer:+($2, 2)):[MIN(customer.fname)]"));
     assertThat(t.s.space.g.toString(),
         is("graph(vertices: [[foodmart, customer],"
             + " [foodmart, sales_fact_1997]], "
             + "edges: [Step([foodmart, sales_fact_1997],"
-            + " [foodmart, customer], +(2, $2):+(1, $0))])"));
+            + " [foodmart, customer], +($2, 2):+($0, 1))])"));
   }
 
   /** Tests that we can run the suggester against non-JDBC schemas.

File: core/src/test/java/org/apache/calcite/plan/volcano/TraitPropagationTest.java
Patch:
@@ -242,12 +242,12 @@ public void onMatch(RelOptRuleCall call) {
             RelTraitSet outcome = child.getTraitSet().replace(PHYSICAL);
             call.transformTo(
                 new PhysProj(rel.getCluster(), outcome, convert(child, outcome),
-                    rel.getChildExps(), rel.getRowType()));
+                    rel.getProjects(), rel.getRowType()));
           }
         }
       } else {
         call.transformTo(
-            PhysProj.create(input, rel.getChildExps(), rel.getRowType()));
+            PhysProj.create(input, rel.getProjects(), rel.getRowType()));
       }
 
     }

File: core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java
Patch:
@@ -700,9 +700,9 @@ private void checkDateRange(Fixture f, RexNode e, Matcher<String> matcher) {
   private void checkDateRange(Fixture f, RexNode e, String timeZone,
       Matcher<String> matcher, Matcher<String> simplifyMatcher) {
     e = DateRangeRules.replaceTimeUnits(f.rexBuilder, e, timeZone);
-    assertThat(e.toStringRaw(), matcher);
+    assertThat(e.toString(), matcher);
     final RexNode e2 = f.simplify.simplify(e);
-    assertThat(e2.toStringRaw(), simplifyMatcher);
+    assertThat(e2.toString(), simplifyMatcher);
   }
 
   /** Common expressions across tests. */

File: core/src/test/java/org/apache/calcite/rex/RexSqlStandardConvertletTableTest.java
Patch:
@@ -44,7 +44,7 @@ class RexSqlStandardConvertletTableTest extends SqlToRelTestBase {
   @Test void testCoalesce() {
     final Project project = (Project) convertSqlToRel(
             "SELECT COALESCE(NULL, 'a')", false);
-    final RexNode rex = project.getChildExps().get(0);
+    final RexNode rex = project.getProjects().get(0);
     final RexToSqlNodeConverter rexToSqlNodeConverter = rexToSqlNodeConverter();
     final SqlNode convertedSql = rexToSqlNodeConverter.convertNode(rex);
     assertEquals(
@@ -56,7 +56,7 @@ class RexSqlStandardConvertletTableTest extends SqlToRelTestBase {
     final Project project =
             (Project) convertSqlToRel(
                     "SELECT CASE NULL WHEN NULL THEN NULL ELSE 'a' END", false);
-    final RexNode rex = project.getChildExps().get(0);
+    final RexNode rex = project.getProjects().get(0);
     final RexToSqlNodeConverter rexToSqlNodeConverter = rexToSqlNodeConverter();
     final SqlNode convertedSql = rexToSqlNodeConverter.convertNode(rex);
     assertEquals(
@@ -67,7 +67,7 @@ class RexSqlStandardConvertletTableTest extends SqlToRelTestBase {
   @Test void testCaseNoValue() {
     final Project project = (Project) convertSqlToRel(
             "SELECT CASE WHEN NULL IS NULL THEN NULL ELSE 'a' END", false);
-    final RexNode rex = project.getChildExps().get(0);
+    final RexNode rex = project.getProjects().get(0);
     final RexToSqlNodeConverter rexToSqlNodeConverter = rexToSqlNodeConverter();
     final SqlNode convertedSql = rexToSqlNodeConverter.convertNode(rex);
     assertEquals(

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -249,7 +249,7 @@ class JdbcAdapterTest {
             + "on s.losal <= e.sal and s.hisal >= e.sal")
         .explainContains("PLAN=JdbcToEnumerableConverter\n"
             + "  JdbcProject(EMPNO=[$0], ENAME=[$1], GRADE=[$3])\n"
-            + "    JdbcJoin(condition=[AND(<=($4, $2), >=($5, $2))], joinType=[inner])\n"
+            + "    JdbcJoin(condition=[AND(>=($2, $4), <=($2, $5))], joinType=[inner])\n"
             + "      JdbcProject(EMPNO=[$0], ENAME=[$1], SAL=[$5])\n"
             + "        JdbcTableScan(table=[[SCOTT, EMP]])\n"
             + "      JdbcTableScan(table=[[SCOTT, SALGRADE]])")
@@ -292,7 +292,7 @@ class JdbcAdapterTest {
             + "e.mgr = m.empno and (e.sal > m.sal or m.hiredate > e.hiredate)")
         .explainContains("PLAN=JdbcToEnumerableConverter\n"
             + "  JdbcProject(EMPNO=[$0], ENAME=[$1], EMPNO0=[$0], ENAME0=[$1])\n"
-            + "    JdbcJoin(condition=[AND(=($2, $5), OR(>($4, $7), >($6, $3)))], joinType=[inner])\n"
+            + "    JdbcJoin(condition=[AND(=($2, $5), OR(>($4, $7), <($3, $6)))], joinType=[inner])\n"
             + "      JdbcProject(EMPNO=[$0], ENAME=[$1], MGR=[$3], HIREDATE=[$4], SAL=[$5])\n"
             + "        JdbcTableScan(table=[[SCOTT, EMP]])\n"
             + "      JdbcProject(EMPNO=[$0], HIREDATE=[$4], SAL=[$5])\n"

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -239,9 +239,9 @@ private static CalciteAssert.AssertThat modelWithLattices(
           final Map.Entry<String, CalciteSchema.LatticeEntry> entry =
               adhoc.unwrap(CalciteSchema.class).getLatticeMap().firstEntry();
           final Lattice lattice = entry.getValue().getLattice();
-          assertThat(lattice.firstColumn("S"), is(10));
-          assertThat(lattice.firstColumn("P"), is(18));
-          assertThat(lattice.firstColumn("T"), is(0));
+          assertThat(lattice.firstColumn("S"), is(0));
+          assertThat(lattice.firstColumn("P"), is(8));
+          assertThat(lattice.firstColumn("T"), is(23));
           assertThat(lattice.firstColumn("PC"), is(-1));
           assertThat(lattice.defaultMeasures.size(), is(1));
           assertThat(lattice.rootNode.descendants.size(), is(3));

File: core/src/test/java/org/apache/calcite/test/MaterializedViewRelOptRulesTest.java
Patch:
@@ -821,8 +821,7 @@ public class MaterializedViewRelOptRulesTest extends AbstractMaterializedViewTes
         .withChecker(
             resultContains(""
             + "EnumerableCalc(expr#0=[{inputs}], expr#1=[CAST($t0):JavaType(int) NOT NULL], "
-            + "expr#2=[1], expr#3=[CAST($t1):INTEGER NOT NULL], expr#4=[=($t2, $t3)], "
-            + "EXPR$0=[$t1], $condition=[$t4])\n"
+            + "expr#2=[1], expr#3=[=($t2, $t0)], EXPR$0=[$t1], $condition=[$t3])\n"
             + "  EnumerableTableScan(table=[[hr, MV0]])"))
         .ok();
   }

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -1978,7 +1978,7 @@ private RelNode buildRelWithDuplicateAggregates(
         + "  LogicalTableScan(table=[[scott, DEPT]])\n";
     final String expectedWithoutSimplify = ""
         + "LogicalJoin(condition=[OR(null:NULL, "
-        + "AND(=($7, 1), =($7, 2), =($8, $7)))], joinType=[inner])\n"
+        + "AND(=($7, 1), =($7, 2), =($7, $8)))], joinType=[inner])\n"
         + "  LogicalTableScan(table=[[scott, EMP]])\n"
         + "  LogicalTableScan(table=[[scott, DEPT]])\n";
     assertThat(f.apply(createBuilder()), hasTree(expected));
@@ -2151,7 +2151,7 @@ private RelNode buildRelWithDuplicateAggregates(
                     builder.field("e", "MGR")))
             .build();
     final String expected = ""
-        + "LogicalFilter(condition=[AND(=($7, $16), =($8, $3))])\n"
+        + "LogicalFilter(condition=[AND(=($7, $16), =($3, $8))])\n"
         + "  LogicalJoin(condition=[true], joinType=[inner])\n"
         + "    LogicalTableScan(table=[[scott, EMP]])\n"
         + "    LogicalJoin(condition=[true], joinType=[inner])\n"
@@ -3544,7 +3544,7 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {
             builder.field("EMPNO"),
             builder.literal(1),
             builder.literal(5));
-    assertThat(call.toStringRaw(), is("BETWEEN ASYMMETRIC($0, 1, 5)"));
+    assertThat(call.toString(), is("BETWEEN ASYMMETRIC($0, 1, 5)"));
   }
 
   /** Test case for

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -6848,7 +6848,7 @@ private MyProjectRule(Class<? extends Project> clazz,
       final LogicalProject logicalProject = call.rel(0);
       final RelNode input = logicalProject.getInput();
       final MyProject myProject = new MyProject(input.getCluster(), input.getTraitSet(), input,
-          logicalProject.getChildExps(), logicalProject.getRowType());
+          logicalProject.getProjects(), logicalProject.getRowType());
       call.transformTo(myProject);
     }
   }

File: core/src/test/java/org/apache/calcite/test/RexTransformerTest.java
Patch:
@@ -114,7 +114,7 @@ void check(
 
     RexTransformer transformer = new RexTransformer(root, rexBuilder);
     RexNode result = transformer.transformNullSemantics();
-    String actual = result.toStringRaw();
+    String actual = result.toString();
     if (!actual.equals(expected)) {
       String msg =
           "\nExpected=<" + expected + ">\n  Actual=<" + actual + ">";
@@ -374,7 +374,7 @@ private RexNode isTrue(RexNode node) {
         null,
         null);
 
-    assertThat(remaining.toStringRaw(), is("<>($0, $9)"));
+    assertThat(remaining.toString(), is("<>($0, $9)"));
     assertThat(leftJoinKeys.isEmpty(), is(true));
     assertThat(rightJoinKeys.isEmpty(), is(true));
   }

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -384,7 +384,7 @@ public void onMatch(RelOptRuleCall call) {
         return;
       }
       boolean hasRexCalls = false;
-      for (RexNode rexNode : project.getChildExps()) {
+      for (RexNode rexNode : project.getProjects()) {
         if (rexNode instanceof RexCall) {
           hasRexCalls = true;
           break;

File: piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
Patch:
@@ -200,7 +200,7 @@ private class RexCallReplacer extends RexShuttle {
     relBuilder.push(oldBottomProject.getInput());
     // First project all group keys, just copy from old one
     for (int i = 0; i < oldAgg.getGroupCount(); i++) {
-      newBottomProjects.add(oldBottomProject.getChildExps().get(i));
+      newBottomProjects.add(oldBottomProject.getProjects().get(i));
     }
     // If grouping aggregate is needed, project the whole ROW
     if (needGoupingCol) {
@@ -235,8 +235,8 @@ private class RexCallReplacer extends RexShuttle {
         } else {
           // Add it to the projection list if we never project it before
           // First get the ROW operator call
-          final RexCall rowCall = (RexCall) oldBottomProject.getChildExps()
-                                                .get(oldAgg.getGroupCount());
+          final RexCall rowCall = (RexCall) oldBottomProject.getProjects()
+              .get(oldAgg.getGroupCount());
           // Get the corresponding column index in parent rel through the call operand list
           final RexInputRef columRef = (RexInputRef) rowCall.getOperands().get(col);
           final int newIndex = newBottomProjects.size();

File: core/src/main/java/org/apache/calcite/sql/SqlDialectFactoryImpl.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.calcite.sql.dialect.ParaccelSqlDialect;
 import org.apache.calcite.sql.dialect.PhoenixSqlDialect;
 import org.apache.calcite.sql.dialect.PostgresqlSqlDialect;
+import org.apache.calcite.sql.dialect.PrestoSqlDialect;
 import org.apache.calcite.sql.dialect.RedshiftSqlDialect;
 import org.apache.calcite.sql.dialect.SnowflakeSqlDialect;
 import org.apache.calcite.sql.dialect.SparkSqlDialect;
@@ -289,6 +290,8 @@ static SqlDialect simple(SqlDialect.DatabaseProduct databaseProduct) {
       return PhoenixSqlDialect.DEFAULT;
     case POSTGRESQL:
       return PostgresqlSqlDialect.DEFAULT;
+    case PRESTO:
+      return PrestoSqlDialect.DEFAULT;
     case REDSHIFT:
       return RedshiftSqlDialect.DEFAULT;
     case SYBASE:

File: core/src/main/java/org/apache/calcite/plan/RelOptNode.java
Patch:
@@ -35,7 +35,7 @@ public interface RelOptNode {
   /**
    * Returns a string which concisely describes the definition of this
    * relational expression. Two relational expressions are equivalent if
-   * their digests and {@link #getRowType()} are the same.
+   * their digests and {@link #getRowType()} (except the field names) are the same.
    *
    * <p>The digest does not contain the relational expression's identity --
    * that would prevent similar relational expressions from ever comparing

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
Patch:
@@ -281,7 +281,6 @@ private SqlNode castTo(SqlNode node, RelDataType type) {
   /**
    * Update inferred type for a SqlNode.
    */
-  @SuppressWarnings("deprecation")
   protected void updateInferredType(SqlNode node, RelDataType type) {
     validator.setValidatedNodeType(node, type);
     final SqlValidatorNamespace namespace = validator.getNamespace(node);

File: core/src/main/java/org/apache/calcite/rel/RelCollation.java
Patch:
@@ -39,7 +39,7 @@ public interface RelCollation extends RelMultipleTrait {
   /**
    * Returns the ordinals of the key columns.
    */
-  default @Nonnull List<Integer> getKeys() {
+  default @Nonnull ImmutableIntList getKeys() {
     final List<RelFieldCollation> collations = getFieldCollations();
     final int size = collations.size();
     final int[] keys = new int[size];

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1982,7 +1982,7 @@ private void checkPredicates(RelOptCluster cluster, RelOptTable empTable,
       final RelNode rel = convertSql(sql, false);
       final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();
       RelOptPredicateList inputSet = mq.getPulledUpPredicates(rel.getInput(0));
-      assertThat(inputSet.pulledUpPredicates.size(), is(12));
+      assertThat(inputSet.pulledUpPredicates.size(), is(11));
     }
   }
 

File: core/src/test/java/org/apache/calcite/test/RexTransformerTest.java
Patch:
@@ -374,7 +374,7 @@ private RexNode isTrue(RexNode node) {
         null,
         null);
 
-    assertThat(remaining.toStringRaw(), is("<>(CAST($0):INTEGER NOT NULL, $9)"));
+    assertThat(remaining.toStringRaw(), is("<>($0, $9)"));
     assertThat(leftJoinKeys.isEmpty(), is(true));
     assertThat(rightJoinKeys.isEmpty(), is(true));
   }

File: core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateTable.java
Patch:
@@ -42,7 +42,7 @@ public class SqlCreateTable extends SqlCreate {
       new SqlSpecialOperator("CREATE TABLE", SqlKind.CREATE_TABLE);
 
   /** Creates a SqlCreateTable. */
-  SqlCreateTable(SqlParserPos pos, boolean replace, boolean ifNotExists,
+  protected SqlCreateTable(SqlParserPos pos, boolean replace, boolean ifNotExists,
       SqlIdentifier name, SqlNodeList columnList, SqlNode query) {
     super(OPERATOR, pos, replace, ifNotExists);
     this.name = Objects.requireNonNull(name);

File: core/src/test/java/org/apache/calcite/test/AbstractMaterializedViewTest.java
Patch:
@@ -60,7 +60,7 @@
 import java.util.function.Function;
 
 /**
- * Abstract class to provide testing environment & utils for extensions.
+ * Abstract class to provide testing environment and utilities for extensions.
  */
 public abstract class AbstractMaterializedViewTest {
 

File: core/src/main/java/org/apache/calcite/jdbc/ContextSqlValidator.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.config.CalciteConnectionConfigImpl;
 import org.apache.calcite.prepare.CalciteCatalogReader;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
-import org.apache.calcite.sql.validate.SqlConformanceEnum;
 import org.apache.calcite.sql.validate.SqlValidatorImpl;
 
 import com.google.common.collect.ImmutableList;
@@ -47,7 +46,7 @@ public class ContextSqlValidator extends SqlValidatorImpl {
    */
   public ContextSqlValidator(CalcitePrepare.Context context, boolean mutable) {
     super(SqlStdOperatorTable.instance(), getCatalogReader(context, mutable),
-        context.getTypeFactory(), SqlConformanceEnum.DEFAULT);
+        context.getTypeFactory(), Config.DEFAULT);
   }
 
   private static CalciteCatalogReader getCatalogReader(

File: core/src/main/java/org/apache/calcite/rel/hint/HintStrategy.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Represents a hint strategy entry of {@link HintStrategyTable}.
  *
- * <p>A {@code HintStrategy} includes:
+ * <p>A {@code HintStrategy} defines:
  *
  * <ul>
  *   <li>{@link HintPredicate}: tests whether a hint should apply to
@@ -41,7 +41,7 @@
  *
  * <p>The {@link HintPredicate} is required, all the other items are optional.
  *
- * <p>A {@link HintStrategy} is immutable.
+ * <p>{@link HintStrategy} is immutable.
  */
 public class HintStrategy {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -36,7 +36,6 @@
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
-import org.apache.calcite.util.Bug;
 import org.apache.calcite.util.DateString;
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.TimestampWithTimeZoneString;
@@ -249,8 +248,6 @@ static class ExtractShuttle extends RexShuttle {
         ImmutableSortedSet<TimeUnitRange> timeUnitRanges, String timeZone) {
       this.rexBuilder = Objects.requireNonNull(rexBuilder);
       this.timeUnit = Objects.requireNonNull(timeUnit);
-      Bug.upgrade("Change type to Map<RexNode, RangeSet<Calendar>> when"
-          + " [CALCITE-1367] is fixed");
       this.operandRanges = Objects.requireNonNull(operandRanges);
       this.timeUnitRanges = Objects.requireNonNull(timeUnitRanges);
       this.timeZone = timeZone;

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -2031,7 +2031,7 @@ private static boolean containsTrue(Iterable<RexNode> nodes) {
    *
    * @deprecated Use {@link #not} */
   @SuppressWarnings("Guava")
-  @Deprecated // to be removed in 2.0
+  @Deprecated // to be removed before 2.0
   public static com.google.common.base.Function<RexNode, RexNode> notFn(
       final RexBuilder rexBuilder) {
     return e -> not(rexBuilder, e);

File: core/src/main/java/org/apache/calcite/runtime/Hook.java
Patch:
@@ -132,7 +132,7 @@ public <T> Closeable add(final Consumer<T> handler) {
 
   /** @deprecated Use {@link #add(Consumer)}. */
   @SuppressWarnings("Guava")
-  @Deprecated // to be removed in 2.0
+  @Deprecated // to be removed before 2.0
   public <T, R> Closeable add(final Function<T, R> handler) {
     return add((Consumer<T>) handler::apply);
   }
@@ -151,7 +151,7 @@ public <T> Closeable addThread(final Consumer<T> handler) {
 
   /** @deprecated Use {@link #addThread(Consumer)}. */
   @SuppressWarnings("Guava")
-  @Deprecated // to be removed in 2.0
+  @Deprecated // to be removed before 2.0
   public <T, R> Closeable addThread(
       final com.google.common.base.Function<T, R> handler) {
     return addThread((Consumer<T>) handler::apply);

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -84,7 +84,7 @@ public class SqlAdvisor {
    * @param validator Validator
    * @deprecated use {@link #SqlAdvisor(SqlValidatorWithHints, SqlParser.Config)}
    */
-  @Deprecated
+  @Deprecated // to be removed before 2.0
   public SqlAdvisor(
       SqlValidatorWithHints validator) {
     this(validator, SqlParser.Config.DEFAULT);

File: core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java
Patch:
@@ -101,7 +101,7 @@ public String sql() {
    * @param hintToken Hint token
    * @deprecated
    */
-  @Deprecated
+  @Deprecated // to be removed before 2.0
   public SqlSimpleParser(String hintToken) {
     this(hintToken, SqlParser.Config.DEFAULT);
   }
@@ -275,7 +275,7 @@ public static class Tokenizer {
     private int pos;
     int start = 0;
 
-    @Deprecated
+    @Deprecated // to be removed before 2.0
     public Tokenizer(String sql, String hintToken) {
       this(sql, hintToken, Quoting.DOUBLE_QUOTE);
     }

File: core/src/main/java/org/apache/calcite/plan/volcano/RuleQueue.java
Patch:
@@ -17,8 +17,8 @@
 package org.apache.calcite.plan.volcano;
 
 import org.apache.calcite.plan.RelOptRuleOperand;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.rules.SubstitutionRule;
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.trace.CalciteTrace;
 

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
Patch:
@@ -21,8 +21,8 @@
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.plan.RelOptRuleOperand;
 import org.apache.calcite.plan.RelOptRuleOperandChildPolicy;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.rules.SubstitutionRule;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;

File: core/src/main/java/org/apache/calcite/rel/rules/AbstractJoinExtractFilterRule.java
Patch:
@@ -38,7 +38,8 @@
  * <p>The constructor is parameterized to allow any sub-class of
  * {@link org.apache.calcite.rel.core.Join}.</p>
  */
-public abstract class AbstractJoinExtractFilterRule extends RelOptRule {
+public abstract class AbstractJoinExtractFilterRule extends RelOptRule
+    implements TransformationRule {
   /** Creates an AbstractJoinExtractFilterRule. */
   protected AbstractJoinExtractFilterRule(RelOptRuleOperand operand,
       RelBuilderFactory relBuilderFactory, String description) {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateCaseToFilterRule.java
Patch:
@@ -62,7 +62,8 @@
  *   FROM Emp</code>
  * </blockquote>
  */
-public class AggregateCaseToFilterRule extends RelOptRule {
+public class AggregateCaseToFilterRule extends RelOptRule
+    implements TransformationRule {
   public static final AggregateCaseToFilterRule INSTANCE =
       new AggregateCaseToFilterRule(RelFactories.LOGICAL_BUILDER, null);
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -77,7 +77,8 @@
  * the rule creates separate {@code Aggregate}s and combines using a
  * {@link org.apache.calcite.rel.core.Join}.
  */
-public final class AggregateExpandDistinctAggregatesRule extends RelOptRule {
+public final class AggregateExpandDistinctAggregatesRule extends RelOptRule
+    implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   /** The default instance of the rule; operates only on logical expressions. */

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExtractProjectRule.java
Patch:
@@ -48,7 +48,8 @@
  * <p>To prevent cycles, this rule will not extract a {@code Project} if the
  * {@code Aggregate}s input is already a {@code Project}.
  */
-public class AggregateExtractProjectRule extends RelOptRule {
+public class AggregateExtractProjectRule extends RelOptRule
+    implements TransformationRule {
 
   /**
    * Creates an AggregateExtractProjectRule.

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -55,7 +55,8 @@
  *
  * @see org.apache.calcite.rel.rules.FilterAggregateTransposeRule
  */
-public class AggregateFilterTransposeRule extends RelOptRule {
+public class AggregateFilterTransposeRule extends RelOptRule
+    implements TransformationRule {
   public static final AggregateFilterTransposeRule INSTANCE =
       new AggregateFilterTransposeRule();
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinJoinRemoveRule.java
Patch:
@@ -66,7 +66,8 @@
  * on s.product_id = pc.product_id</pre></blockquote>
  *
  */
-public class AggregateJoinJoinRemoveRule extends RelOptRule {
+public class AggregateJoinJoinRemoveRule extends RelOptRule
+    implements TransformationRule {
   public static final AggregateJoinJoinRemoveRule INSTANCE =
       new AggregateJoinJoinRemoveRule(LogicalAggregate.class,
           LogicalJoin.class, RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinRemoveRule.java
Patch:
@@ -58,7 +58,7 @@
  * <pre>select distinct s.product_id from sales as s</pre></blockquote>
  *
  */
-public class AggregateJoinRemoveRule extends RelOptRule {
+public class AggregateJoinRemoveRule extends RelOptRule implements TransformationRule {
   public static final AggregateJoinRemoveRule INSTANCE =
       new AggregateJoinRemoveRule(LogicalAggregate.class, LogicalJoin.class,
           RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -61,7 +61,7 @@
  * {@link org.apache.calcite.rel.core.Aggregate}
  * past a {@link org.apache.calcite.rel.core.Join}.
  */
-public class AggregateJoinTransposeRule extends RelOptRule {
+public class AggregateJoinTransposeRule extends RelOptRule implements TransformationRule {
   public static final AggregateJoinTransposeRule INSTANCE =
       new AggregateJoinTransposeRule(LogicalAggregate.class, LogicalJoin.class,
           RelFactories.LOGICAL_BUILDER, false);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
Patch:
@@ -46,7 +46,7 @@
  * MAX of MAX becomes MAX; MIN of MIN becomes MIN. AVG of AVG would not
  * match, nor would COUNT of COUNT.
  */
-public class AggregateMergeRule extends RelOptRule {
+public class AggregateMergeRule extends RelOptRule implements TransformationRule {
   public static final AggregateMergeRule INSTANCE =
       new AggregateMergeRule();
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectMergeRule.java
Patch:
@@ -52,7 +52,7 @@
  * <p>In some cases, this rule has the effect of trimming: the aggregate will
  * use fewer columns than the project did.
  */
-public class AggregateProjectMergeRule extends RelOptRule {
+public class AggregateProjectMergeRule extends RelOptRule implements TransformationRule {
   public static final AggregateProjectMergeRule INSTANCE =
       new AggregateProjectMergeRule(Aggregate.class, Project.class, RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectPullUpConstantsRule.java
Patch:
@@ -57,7 +57,8 @@
  * reduced aggregate. If those constants are not used, another rule will remove
  * them from the project.
  */
-public class AggregateProjectPullUpConstantsRule extends RelOptRule {
+public class AggregateProjectPullUpConstantsRule extends RelOptRule
+    implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   /** The singleton. */

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -92,7 +92,8 @@
  * forms like {@code COUNT(x)}, the rule gathers common sub-expressions as it
  * goes.
  */
-public class AggregateReduceFunctionsRule extends RelOptRule {
+public class AggregateReduceFunctionsRule extends RelOptRule
+    implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   /** The singleton. */

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateRemoveRule.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Aggregate;
 import org.apache.calcite.rel.core.AggregateCall;
@@ -124,7 +123,7 @@ public void onMatch(RelOptRuleCall call) {
       // aggregate functions, add a project for the same effect.
       relBuilder.project(relBuilder.fields(aggregate.getGroupSet()));
     }
-    call.getPlanner().setImportance(aggregate, 0d);
+    call.getPlanner().prune(aggregate);
     call.transformTo(relBuilder.build());
   }
 }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
Patch:
@@ -59,7 +59,7 @@
  * <p>This pattern indicates that an aggregate table may exist. The rule asks
  * the star table for an aggregate table at the required level of aggregation.
  */
-public class AggregateStarTableRule extends RelOptRule {
+public class AggregateStarTableRule extends RelOptRule implements TransformationRule {
   public static final AggregateStarTableRule INSTANCE =
       new AggregateStarTableRule(
           operandJ(Aggregate.class, null, Aggregate::isSimple,

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionAggregateRule.java
Patch:
@@ -39,7 +39,7 @@
  * {@link org.apache.calcite.rel.core.Union}s
  * still have only two inputs.
  */
-public class AggregateUnionAggregateRule extends RelOptRule {
+public class AggregateUnionAggregateRule extends RelOptRule implements TransformationRule {
   /** Instance that matches an {@code Aggregate} as the left input of
    * {@code Union}. */
   public static final AggregateUnionAggregateRule AGG_ON_FIRST_INPUT =

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -53,7 +53,7 @@
  * {@link org.apache.calcite.rel.core.Aggregate}
  * past a non-distinct {@link org.apache.calcite.rel.core.Union}.
  */
-public class AggregateUnionTransposeRule extends RelOptRule {
+public class AggregateUnionTransposeRule extends RelOptRule implements TransformationRule {
   public static final AggregateUnionTransposeRule INSTANCE =
       new AggregateUnionTransposeRule(LogicalAggregate.class,
           LogicalUnion.class, RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateValuesRule.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.core.Aggregate;
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.rel.core.RelFactories;

File: core/src/main/java/org/apache/calcite/rel/rules/CalcMergeRule.java
Patch:
@@ -35,7 +35,7 @@
  * {@link org.apache.calcite.rel.logical.LogicalCalc}, but expressed in terms of
  * the lower {@link org.apache.calcite.rel.logical.LogicalCalc}'s inputs.
  */
-public class CalcMergeRule extends RelOptRule {
+public class CalcMergeRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final CalcMergeRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/CalcRemoveRule.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.rel.logical.LogicalCalc;

File: core/src/main/java/org/apache/calcite/rel/rules/CalcSplitRule.java
Patch:
@@ -38,7 +38,7 @@
  * specific tasks, such as optimizing before calling an
  * {@link org.apache.calcite.interpreter.Interpreter}.
  */
-public class CalcSplitRule extends RelOptRule {
+public class CalcSplitRule extends RelOptRule implements TransformationRule {
   public static final CalcSplitRule INSTANCE =
       new CalcSplitRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/CoerceInputsRule.java
Patch:
@@ -33,7 +33,7 @@
  * assist operator implementations which impose requirements on their input
  * types.
  */
-public class CoerceInputsRule extends RelOptRule {
+public class CoerceInputsRule extends RelOptRule implements TransformationRule {
   //~ Instance fields --------------------------------------------------------
 
   private final Class consumerRelClass;

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -170,7 +170,7 @@ public static RexNode replaceTimeUnits(RexBuilder rexBuilder, RexNode e,
   /** Rule that converts EXTRACT, FLOOR and CEIL in a {@link Filter} into a date
    * range. */
   @SuppressWarnings("WeakerAccess")
-  public static class FilterDateRangeRule extends RelOptRule {
+  public static class FilterDateRangeRule extends RelOptRule implements TransformationRule {
     public FilterDateRangeRule(RelBuilderFactory relBuilderFactory) {
       super(operandJ(Filter.class, null, FILTER_PREDICATE, any()),
           relBuilderFactory, "FilterDateRangeRule");

File: core/src/main/java/org/apache/calcite/rel/rules/ExchangeRemoveConstantKeysRule.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.RelOptPredicateList;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelCollation;
 import org.apache.calcite.rel.RelCollations;
 import org.apache.calcite.rel.RelDistribution;

File: core/src/main/java/org/apache/calcite/rel/rules/FilterAggregateTransposeRule.java
Patch:
@@ -44,7 +44,7 @@
  *
  * @see org.apache.calcite.rel.rules.AggregateFilterTransposeRule
  */
-public class FilterAggregateTransposeRule extends RelOptRule {
+public class FilterAggregateTransposeRule extends RelOptRule implements TransformationRule {
 
   /** The default instance of
    * {@link FilterAggregateTransposeRule}.

File: core/src/main/java/org/apache/calcite/rel/rules/FilterCalcMergeRule.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @see FilterMergeRule
  */
-public class FilterCalcMergeRule extends RelOptRule {
+public class FilterCalcMergeRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final FilterCalcMergeRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/FilterCorrelateRule.java
Patch:
@@ -38,7 +38,7 @@
  * Planner rule that pushes a {@link Filter} above a {@link Correlate} into the
  * inputs of the Correlate.
  */
-public class FilterCorrelateRule extends RelOptRule {
+public class FilterCorrelateRule extends RelOptRule implements TransformationRule {
 
   public static final FilterCorrelateRule INSTANCE =
       new FilterCorrelateRule(RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
Patch:
@@ -47,7 +47,7 @@
  * Planner rule that pushes filters above and
  * within a join node into the join node and/or its children nodes.
  */
-public abstract class FilterJoinRule extends RelOptRule {
+public abstract class FilterJoinRule extends RelOptRule implements TransformationRule {
   /** Predicate that always returns true. With this predicate, every filter
    * will be pushed into the ON clause. */
   public static final Predicate TRUE_PREDICATE = (join, joinType, exp) -> true;

File: core/src/main/java/org/apache/calcite/rel/rules/FilterMergeRule.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.Contexts;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.tools.RelBuilder;

File: core/src/main/java/org/apache/calcite/rel/rules/FilterMultiJoinMergeRule.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @see org.apache.calcite.rel.rules.ProjectMultiJoinMergeRule
  */
-public class FilterMultiJoinMergeRule extends RelOptRule {
+public class FilterMultiJoinMergeRule extends RelOptRule implements TransformationRule {
   public static final FilterMultiJoinMergeRule INSTANCE =
       new FilterMultiJoinMergeRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
Patch:
@@ -41,7 +41,7 @@
  * a {@link org.apache.calcite.rel.core.Filter}
  * past a {@link org.apache.calcite.rel.core.Project}.
  */
-public class FilterProjectTransposeRule extends RelOptRule {
+public class FilterProjectTransposeRule extends RelOptRule implements TransformationRule {
   /** The default instance of
    * {@link org.apache.calcite.rel.rules.FilterProjectTransposeRule}.
    *

File: core/src/main/java/org/apache/calcite/rel/rules/FilterRemoveIsNotDistinctFromRule.java
Patch:
@@ -37,7 +37,8 @@
  *
  * @see org.apache.calcite.sql.fun.SqlStdOperatorTable#IS_NOT_DISTINCT_FROM
  */
-public final class FilterRemoveIsNotDistinctFromRule extends RelOptRule {
+public final class FilterRemoveIsNotDistinctFromRule extends RelOptRule
+    implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   /** The singleton. */

File: core/src/main/java/org/apache/calcite/rel/rules/FilterSetOpTransposeRule.java
Patch:
@@ -37,7 +37,7 @@
  * Planner rule that pushes a {@link org.apache.calcite.rel.core.Filter}
  * past a {@link org.apache.calcite.rel.core.SetOp}.
  */
-public class FilterSetOpTransposeRule extends RelOptRule {
+public class FilterSetOpTransposeRule extends RelOptRule implements TransformationRule {
   public static final FilterSetOpTransposeRule INSTANCE =
       new FilterSetOpTransposeRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/FilterTableFunctionTransposeRule.java
Patch:
@@ -39,7 +39,8 @@
  * a {@link org.apache.calcite.rel.logical.LogicalFilter}
  * past a {@link org.apache.calcite.rel.logical.LogicalTableFunctionScan}.
  */
-public class FilterTableFunctionTransposeRule extends RelOptRule {
+public class FilterTableFunctionTransposeRule extends RelOptRule
+    implements TransformationRule {
   public static final FilterTableFunctionTransposeRule INSTANCE =
       new FilterTableFunctionTransposeRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/FilterToCalcRule.java
Patch:
@@ -42,7 +42,7 @@
  * {@link org.apache.calcite.rel.logical.LogicalFilter} will eventually be
  * converted by {@link FilterCalcMergeRule}.
  */
-public class FilterToCalcRule extends RelOptRule {
+public class FilterToCalcRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final FilterToCalcRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
Patch:
@@ -66,7 +66,7 @@
  *
  * @see org.apache.calcite.rel.rules.UnionToDistinctRule
  */
-public class IntersectToDistinctRule extends RelOptRule {
+public class IntersectToDistinctRule extends RelOptRule implements TransformationRule {
   public static final IntersectToDistinctRule INSTANCE =
           new IntersectToDistinctRule(LogicalIntersect.class, RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
Patch:
@@ -38,7 +38,8 @@
  * {@link org.apache.calcite.rel.core.Join}, not just
  * {@link org.apache.calcite.rel.logical.LogicalJoin}.
  */
-public class JoinAddRedundantSemiJoinRule extends RelOptRule {
+public class JoinAddRedundantSemiJoinRule extends RelOptRule
+    implements TransformationRule {
   public static final JoinAddRedundantSemiJoinRule INSTANCE =
       new JoinAddRedundantSemiJoinRule(LogicalJoin.class,
           RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/JoinAssociateRule.java
Patch:
@@ -46,7 +46,7 @@
  *
  * @see JoinCommuteRule
  */
-public class JoinAssociateRule extends RelOptRule {
+public class JoinAssociateRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   /** The singleton. */

File: core/src/main/java/org/apache/calcite/rel/rules/JoinCommuteRule.java
Patch:
@@ -48,7 +48,7 @@
  * <p>To preserve the order of columns in the output row, the rule adds a
  * {@link org.apache.calcite.rel.core.Project}.
  */
-public class JoinCommuteRule extends RelOptRule {
+public class JoinCommuteRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   /** Instance of the rule that only swaps inner joins. */

File: core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
Patch:
@@ -57,7 +57,7 @@
  * {@link org.apache.calcite.rel.logical.LogicalProject} doesn't originate from
  * a null generating input in an outer join.
  */
-public class JoinProjectTransposeRule extends RelOptRule {
+public class JoinProjectTransposeRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final JoinProjectTransposeRule BOTH_PROJECT =

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushExpressionsRule.java
Patch:
@@ -35,7 +35,7 @@
  * "emp.deptno + 1". The resulting join condition is a simple combination
  * of AND, equals, and input fields, plus the remaining non-equal conditions.
  */
-public class JoinPushExpressionsRule extends RelOptRule {
+public class JoinPushExpressionsRule extends RelOptRule implements TransformationRule {
 
   public static final JoinPushExpressionsRule INSTANCE =
       new JoinPushExpressionsRule(Join.class, RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushThroughJoinRule.java
Patch:
@@ -62,7 +62,7 @@
  * <p>Before the rule, one join has two conditions and the other has none
  * ({@code ON TRUE}). After the rule, each join has one condition.</p>
  */
-public class JoinPushThroughJoinRule extends RelOptRule {
+public class JoinPushThroughJoinRule extends RelOptRule implements TransformationRule {
   /** Instance of the rule that works on logical joins only, and pushes to the
    * right. */
   public static final RelOptRule RIGHT =

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
Patch:
@@ -39,7 +39,7 @@
  * returns them in a {@link org.apache.calcite.plan.RelOptPredicateList}
  * and applies them appropriately.
  */
-public class JoinPushTransitivePredicatesRule extends RelOptRule {
+public class JoinPushTransitivePredicatesRule extends RelOptRule implements TransformationRule {
   /** The singleton. */
   public static final JoinPushTransitivePredicatesRule INSTANCE =
       new JoinPushTransitivePredicatesRule(Join.class,

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToCorrelateRule.java
Patch:
@@ -56,7 +56,7 @@
  * <p>would require emitting a NULL emp row if a certain department contained no
  * employees, and Correlator cannot do that.</p>
  */
-public class JoinToCorrelateRule extends RelOptRule {
+public class JoinToCorrelateRule extends RelOptRule implements TransformationRule {
 
   //~ Static fields/initializers ---------------------------------------------
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
Patch:
@@ -102,7 +102,7 @@
  * @see org.apache.calcite.rel.rules.FilterMultiJoinMergeRule
  * @see org.apache.calcite.rel.rules.ProjectMultiJoinMergeRule
  */
-public class JoinToMultiJoinRule extends RelOptRule {
+public class JoinToMultiJoinRule extends RelOptRule implements TransformationRule {
   public static final JoinToMultiJoinRule INSTANCE =
       new JoinToMultiJoinRule(LogicalJoin.class, RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinUnionTransposeRule.java
Patch:
@@ -34,7 +34,7 @@
  * {@link org.apache.calcite.rel.core.Join}
  * past a non-distinct {@link org.apache.calcite.rel.core.Union}.
  */
-public class JoinUnionTransposeRule extends RelOptRule {
+public class JoinUnionTransposeRule extends RelOptRule implements TransformationRule {
   public static final JoinUnionTransposeRule LEFT_UNION =
       new JoinUnionTransposeRule(
           operand(Join.class,

File: core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
Patch:
@@ -65,7 +65,7 @@
  * {@link org.apache.calcite.rel.logical.LogicalProject}
  * ({@link MultiJoin}).
  */
-public class LoptOptimizeJoinRule extends RelOptRule {
+public class LoptOptimizeJoinRule extends RelOptRule implements TransformationRule {
   public static final LoptOptimizeJoinRule INSTANCE =
       new LoptOptimizeJoinRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/MatchRule.java
Patch:
@@ -26,7 +26,7 @@
  * {@link LogicalMatch} to the result
  * of calling {@link LogicalMatch#copy}.
  */
-public class MatchRule extends RelOptRule {
+public class MatchRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final MatchRule INSTANCE = new MatchRule();

File: core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
Patch:
@@ -41,7 +41,7 @@
  * on a {@link org.apache.calcite.rel.core.TableScan}
  * to a {@link org.apache.calcite.rel.core.Filter} on Materialized View
  */
-public class MaterializedViewFilterScanRule extends RelOptRule {
+public class MaterializedViewFilterScanRule extends RelOptRule implements TransformationRule {
   public static final MaterializedViewFilterScanRule INSTANCE =
       new MaterializedViewFilterScanRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
Patch:
@@ -68,7 +68,7 @@
  *       e.g. {@code t0.c1 = t1.c1 and t1.c2 = t0.c3}
  * </ol>
  */
-public class MultiJoinOptimizeBushyRule extends RelOptRule {
+public class MultiJoinOptimizeBushyRule extends RelOptRule implements TransformationRule {
   public static final MultiJoinOptimizeBushyRule INSTANCE =
       new MultiJoinOptimizeBushyRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectCalcMergeRule.java
Patch:
@@ -42,7 +42,7 @@
  *
  * @see FilterCalcMergeRule
  */
-public class ProjectCalcMergeRule extends RelOptRule {
+public class ProjectCalcMergeRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final ProjectCalcMergeRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectCorrelateTransposeRule.java
Patch:
@@ -44,7 +44,7 @@
 /**
  * Push Project under Correlate to apply on Correlate's left and right child
  */
-public class ProjectCorrelateTransposeRule extends RelOptRule {
+public class ProjectCorrelateTransposeRule extends RelOptRule implements TransformationRule {
 
   public static final ProjectCorrelateTransposeRule INSTANCE =
       new ProjectCorrelateTransposeRule(expr -> !(expr instanceof RexOver),

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectFilterTransposeRule.java
Patch:
@@ -34,7 +34,7 @@
  * Planner rule that pushes a {@link org.apache.calcite.rel.core.Project}
  * past a {@link org.apache.calcite.rel.core.Filter}.
  */
-public class ProjectFilterTransposeRule extends RelOptRule {
+public class ProjectFilterTransposeRule extends RelOptRule implements TransformationRule {
   public static final ProjectFilterTransposeRule INSTANCE =
       new ProjectFilterTransposeRule(LogicalProject.class, LogicalFilter.class,
           RelFactories.LOGICAL_BUILDER, expr -> false);

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinJoinRemoveRule.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.plan.RelOptUtil;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinRelType;

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinRemoveRule.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.plan.RelOptUtil;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinRelType;

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinTransposeRule.java
Patch:
@@ -48,7 +48,7 @@
  * by splitting the projection into a projection on top of each child of
  * the join.
  */
-public class ProjectJoinTransposeRule extends RelOptRule {
+public class ProjectJoinTransposeRule extends RelOptRule implements TransformationRule {
   /**
    * A instance for ProjectJoinTransposeRule that pushes a
    * {@link org.apache.calcite.rel.logical.LogicalProject}

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectMultiJoinMergeRule.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @see org.apache.calcite.rel.rules.FilterMultiJoinMergeRule
  */
-public class ProjectMultiJoinMergeRule extends RelOptRule {
+public class ProjectMultiJoinMergeRule extends RelOptRule implements TransformationRule {
   public static final ProjectMultiJoinMergeRule INSTANCE =
       new ProjectMultiJoinMergeRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectRemoveRule.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.core.RelFactories;

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectSetOpTransposeRule.java
Patch:
@@ -39,7 +39,7 @@
  * only the {@link RexInputRef}s referenced in the original
  * {@code LogicalProject}.
  */
-public class ProjectSetOpTransposeRule extends RelOptRule {
+public class ProjectSetOpTransposeRule extends RelOptRule implements TransformationRule {
   public static final ProjectSetOpTransposeRule INSTANCE =
       new ProjectSetOpTransposeRule(expr -> !(expr instanceof RexOver),
           RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectSortTransposeRule.java
Patch:
@@ -34,7 +34,7 @@
  *
  * @see org.apache.calcite.rel.rules.SortProjectTransposeRule
  */
-public class ProjectSortTransposeRule extends RelOptRule {
+public class ProjectSortTransposeRule extends RelOptRule implements TransformationRule {
   public static final ProjectSortTransposeRule INSTANCE =
       new ProjectSortTransposeRule(Project.class, Sort.class,
           RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToCalcRule.java
Patch:
@@ -39,7 +39,7 @@
  *
  * @see FilterToCalcRule
  */
-public class ProjectToCalcRule extends RelOptRule {
+public class ProjectToCalcRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final ProjectToCalcRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
Patch:
@@ -72,7 +72,7 @@
  * <p>There is also a variant that matches
  * {@link org.apache.calcite.rel.core.Calc} rather than {@code Project}.
  */
-public abstract class ProjectToWindowRule extends RelOptRule {
+public abstract class ProjectToWindowRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final ProjectToWindowRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectWindowTransposeRule.java
Patch:
@@ -46,7 +46,7 @@
  * a {@link org.apache.calcite.rel.logical.LogicalProject}
  * past a {@link org.apache.calcite.rel.logical.LogicalWindow}.
  */
-public class ProjectWindowTransposeRule extends RelOptRule {
+public class ProjectWindowTransposeRule extends RelOptRule implements TransformationRule {
   /** The default instance of
    * {@link org.apache.calcite.rel.rules.ProjectWindowTransposeRule}. */
   public static final ProjectWindowTransposeRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
Patch:
@@ -21,7 +21,6 @@
 import org.apache.calcite.plan.RelOptRuleOperand;
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.plan.RelTraitSet;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.plan.hep.HepRelVertex;
 import org.apache.calcite.plan.volcano.RelSubset;
 import org.apache.calcite.rel.RelNode;

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -66,7 +66,7 @@
  * rule is optionally applied, in order to support the situation in which we
  * would like to push down decimal operations to an external database.
  */
-public class ReduceDecimalsRule extends RelOptRule {
+public class ReduceDecimalsRule extends RelOptRule implements TransformationRule {
   public static final ReduceDecimalsRule INSTANCE =
       new ReduceDecimalsRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -21,7 +21,6 @@
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.plan.RelOptUtil;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelCollation;
 import org.apache.calcite.rel.RelCollations;
 import org.apache.calcite.rel.RelFieldCollation;

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinFilterTransposeRule.java
Patch:
@@ -40,7 +40,7 @@
  *
  * @see SemiJoinProjectTransposeRule
  */
-public class SemiJoinFilterTransposeRule extends RelOptRule {
+public class SemiJoinFilterTransposeRule extends RelOptRule implements TransformationRule {
   public static final SemiJoinFilterTransposeRule INSTANCE =
       new SemiJoinFilterTransposeRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinJoinTransposeRule.java
Patch:
@@ -49,7 +49,7 @@
  * first or second conversion is applied depends on which operands actually
  * participate in the semi-join.</p>
  */
-public class SemiJoinJoinTransposeRule extends RelOptRule {
+public class SemiJoinJoinTransposeRule extends RelOptRule implements TransformationRule {
   public static final SemiJoinJoinTransposeRule INSTANCE =
       new SemiJoinJoinTransposeRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinProjectTransposeRule.java
Patch:
@@ -53,7 +53,7 @@
  *
  * @see org.apache.calcite.rel.rules.SemiJoinFilterTransposeRule
  */
-public class SemiJoinProjectTransposeRule extends RelOptRule {
+public class SemiJoinProjectTransposeRule extends RelOptRule implements TransformationRule {
   public static final SemiJoinProjectTransposeRule INSTANCE =
       new SemiJoinProjectTransposeRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinRemoveRule.java
Patch:
@@ -33,7 +33,7 @@
  * <p>It should only be enabled if all SemiJoins in the plan are advisory; that
  * is, they can be safely dropped without affecting the semantics of the query.
  */
-public class SemiJoinRemoveRule extends RelOptRule {
+public class SemiJoinRemoveRule extends RelOptRule implements TransformationRule {
   public static final SemiJoinRemoveRule INSTANCE =
       new SemiJoinRemoveRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinRule.java
Patch:
@@ -42,7 +42,7 @@
  * {@link org.apache.calcite.rel.core.Join} on top of a
  * {@link org.apache.calcite.rel.logical.LogicalAggregate}.
  */
-public abstract class SemiJoinRule extends RelOptRule {
+public abstract class SemiJoinRule extends RelOptRule implements TransformationRule {
   private static final Predicate<Join> NOT_GENERATE_NULLS_ON_LEFT =
       join -> !join.getJoinType().generatesNullsOnLeft();
 

File: core/src/main/java/org/apache/calcite/rel/rules/SortJoinCopyRule.java
Patch:
@@ -48,7 +48,7 @@
  * sorted inputs; and allowing the sort to be performed on a possibly smaller
  * result.
  */
-public class SortJoinCopyRule extends RelOptRule {
+public class SortJoinCopyRule extends RelOptRule implements TransformationRule {
 
   public static final SortJoinCopyRule INSTANCE =
       new SortJoinCopyRule(LogicalSort.class,

File: core/src/main/java/org/apache/calcite/rel/rules/SortJoinTransposeRule.java
Patch:
@@ -42,7 +42,7 @@
  * However, an extension for full outer joins for this rule could be envisioned.
  * Special attention should be paid to null values for correctness issues.
  */
-public class SortJoinTransposeRule extends RelOptRule {
+public class SortJoinTransposeRule extends RelOptRule implements TransformationRule {
 
   public static final SortJoinTransposeRule INSTANCE =
       new SortJoinTransposeRule(LogicalSort.class,

File: core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java
Patch:
@@ -53,7 +53,7 @@
  *
  * @see org.apache.calcite.rel.rules.ProjectSortTransposeRule
  */
-public class SortProjectTransposeRule extends RelOptRule {
+public class SortProjectTransposeRule extends RelOptRule implements TransformationRule {
   public static final SortProjectTransposeRule INSTANCE =
       new SortProjectTransposeRule(Sort.class, LogicalProject.class,
           RelFactories.LOGICAL_BUILDER, null);

File: core/src/main/java/org/apache/calcite/rel/rules/SortRemoveConstantKeysRule.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.RelOptPredicateList;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.RelCollationTraitDef;
 import org.apache.calcite.rel.RelCollations;
 import org.apache.calcite.rel.RelFieldCollation;

File: core/src/main/java/org/apache/calcite/rel/rules/SortRemoveRule.java
Patch:
@@ -31,7 +31,7 @@
  *
  * <p>Requires {@link RelCollationTraitDef}.
  */
-public class SortRemoveRule extends RelOptRule {
+public class SortRemoveRule extends RelOptRule implements TransformationRule {
   public static final SortRemoveRule INSTANCE =
       new SortRemoveRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/SortUnionTransposeRule.java
Patch:
@@ -34,7 +34,7 @@
  * {@link org.apache.calcite.rel.core.Union}.
  *
  */
-public class SortUnionTransposeRule extends RelOptRule {
+public class SortUnionTransposeRule extends RelOptRule implements TransformationRule {
 
   /** Rule instance for Union implementation that does not preserve the
    * ordering of its inputs. Thus, it makes no sense to match this rule

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -65,7 +65,7 @@
  * the rewrite, and the product of the rewrite will be a {@link Correlate}.
  * The Correlate can be removed using {@link RelDecorrelator}.
  */
-public abstract class SubQueryRemoveRule extends RelOptRule {
+public abstract class SubQueryRemoveRule extends RelOptRule implements TransformationRule {
   public static final SubQueryRemoveRule PROJECT =
       new SubQueryProjectRemoveRule(RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/SubstitutionRule.java
Patch:
@@ -14,15 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.plan;
+package org.apache.calcite.rel.rules;
 
 /**
  * A rule that implements this interface indicates that the new RelNode
  * is typically better than the old one. All the substitution rules will
  * be executed first until they are done. The execution order of
  * substitution rules depends on the match order.
  */
-public interface SubstitutionRule {
+public interface SubstitutionRule extends TransformationRule {
 
   /**
    * Whether the planner should automatically prune old node when

File: core/src/main/java/org/apache/calcite/rel/rules/TableScanRule.java
Patch:
@@ -34,7 +34,7 @@
  * has called {@link RelOptTable#toRel(RelOptTable.ToRelContext)}.
  */
 @Deprecated // to be removed before 2.0
-public class TableScanRule extends RelOptRule {
+public class TableScanRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final TableScanRule INSTANCE =

File: core/src/main/java/org/apache/calcite/rel/rules/UnionEliminatorRule.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
-import org.apache.calcite.plan.SubstitutionRule;
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.rel.core.Union;
 import org.apache.calcite.rel.logical.LogicalUnion;

File: core/src/main/java/org/apache/calcite/rel/rules/UnionMergeRule.java
Patch:
@@ -39,7 +39,7 @@
  * <p>Originally written for {@link Union} (hence the name),
  * but now also applies to {@link Intersect}.
  */
-public class UnionMergeRule extends RelOptRule {
+public class UnionMergeRule extends RelOptRule implements TransformationRule {
   public static final UnionMergeRule INSTANCE =
       new UnionMergeRule(LogicalUnion.class, "UnionMergeRule",
           RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/UnionPullUpConstantsRule.java
Patch:
@@ -45,7 +45,7 @@
 /**
  * Planner rule that pulls up constants through a Union operator.
  */
-public class UnionPullUpConstantsRule extends RelOptRule {
+public class UnionPullUpConstantsRule extends RelOptRule implements TransformationRule {
 
   public static final UnionPullUpConstantsRule INSTANCE =
       new UnionPullUpConstantsRule(Union.class, RelFactories.LOGICAL_BUILDER);

File: core/src/main/java/org/apache/calcite/rel/rules/UnionToDistinctRule.java
Patch:
@@ -32,7 +32,7 @@
  * on top of a non-distinct {@link org.apache.calcite.rel.core.Union}
  * (<code>all</code> = <code>true</code>).
  */
-public class UnionToDistinctRule extends RelOptRule {
+public class UnionToDistinctRule extends RelOptRule implements TransformationRule {
   public static final UnionToDistinctRule INSTANCE =
       new UnionToDistinctRule(LogicalUnion.class, RelFactories.LOGICAL_BUILDER);
 

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -63,7 +63,7 @@
  * <p>Ignores an empty {@code Values}; this is better dealt with by
  * {@link PruneEmptyRules}.
  */
-public abstract class ValuesReduceRule extends RelOptRule {
+public abstract class ValuesReduceRule extends RelOptRule implements TransformationRule {
   //~ Static fields/initializers ---------------------------------------------
 
   private static final Logger LOGGER = CalciteTrace.getPlannerTracer();

File: redis/src/main/java/org/apache/calcite/adapter/redis/RedisEnumerator.java
Patch:
@@ -49,7 +49,7 @@ class RedisEnumerator implements Enumerator<Object[]> {
     }
   }
 
-  public Map<String, Object> deduceRowType(RedisTableFieldInfo tableFieldInfo) {
+  static Map<String, Object> deduceRowType(RedisTableFieldInfo tableFieldInfo) {
     final Map<String, Object> fieldBuilder = new LinkedHashMap<>();
     String dataFormat = tableFieldInfo.getDataFormat();
     RedisDataFormat redisDataFormat = RedisDataFormat.fromTypeName(dataFormat);

File: redis/src/main/java/org/apache/calcite/adapter/redis/RedisTable.java
Patch:
@@ -84,9 +84,8 @@ static Table create(
       String tableName,
       RedisConfig redisConfig,
       RelProtoDataType protoRowType) {
-    final RedisEnumerator redisEnumerator = new RedisEnumerator(redisConfig, schema, tableName);
     RedisTableFieldInfo tableFieldInfo = schema.getTableFieldInfo(tableName);
-    Map<String, Object> allFields = redisEnumerator.deduceRowType(tableFieldInfo);
+    Map<String, Object> allFields = RedisEnumerator.deduceRowType(tableFieldInfo);
     return new RedisTable(schema, tableName, protoRowType,
         allFields, tableFieldInfo.getDataFormat(), redisConfig);
   }

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -111,7 +111,7 @@ public abstract class ReduceExpressionsRule extends RelOptRule
    * {@link org.apache.calcite.rel.logical.LogicalFilter}.
    */
   public static final ReduceExpressionsRule FILTER_INSTANCE =
-      new FilterReduceExpressionsRule(LogicalFilter.class, true,
+      new FilterReduceExpressionsRule(LogicalFilter.class, false,
           RelFactories.LOGICAL_BUILDER);
 
   /**
@@ -127,7 +127,7 @@ public abstract class ReduceExpressionsRule extends RelOptRule
    * {@link org.apache.calcite.rel.core.Join}.
    */
   public static final ReduceExpressionsRule JOIN_INSTANCE =
-      new JoinReduceExpressionsRule(Join.class, true,
+      new JoinReduceExpressionsRule(Join.class, false,
           RelFactories.LOGICAL_BUILDER);
 
   /**

File: core/src/main/java/org/apache/calcite/sql/SqlJsonEmptyOrError.java
Patch:
@@ -22,11 +22,11 @@
  * Flag to indicate if the json value is missing or an error is thrown where
  * EmptyOrErrorBehavior is invoked.
  */
-public enum SqlJsonEmptyOrError {
+public enum SqlJsonEmptyOrError implements Symbolizable {
   EMPTY,
   ERROR;
 
   @Override public String toString() {
-    return String.format(Locale.ROOT, "SqlJsonEmptyOrError[%s]", name());
+    return String.format(Locale.ROOT, "ON %s", name());
   }
 }

File: core/src/main/java/org/apache/calcite/sql/SqlJsonExistsErrorBehavior.java
Patch:
@@ -19,7 +19,7 @@
 /**
  * Categorizing Json exists error behaviors.
  */
-public enum SqlJsonExistsErrorBehavior {
+public enum SqlJsonExistsErrorBehavior implements Symbolizable {
   TRUE,
   FALSE,
   UNKNOWN,

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -337,8 +337,7 @@ public enum BuiltInMethod {
   JSON_API_COMMON_SYNTAX(JsonFunctions.class, "jsonApiCommonSyntax",
       String.class, String.class),
   JSON_EXISTS(JsonFunctions.class, "jsonExists", String.class, String.class),
-  JSON_VALUE_ANY(JsonFunctions.class, "jsonValueAny", String.class,
-      String.class,
+  JSON_VALUE(JsonFunctions.class, "jsonValue", String.class, String.class,
       SqlJsonValueEmptyOrErrorBehavior.class, Object.class,
       SqlJsonValueEmptyOrErrorBehavior.class, Object.class),
   JSON_QUERY(JsonFunctions.class, "jsonQuery", String.class,

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java
Patch:
@@ -4533,9 +4533,7 @@ private void checkLiteral2(String expression, String expected) {
 
   @Test void testJsonValue() {
     String query = "select json_value(\"product_name\", 'lax $') from \"product\"";
-    // todo translate to JSON_VALUE rather than CAST
-    final String expected = "SELECT CAST(JSON_VALUE_ANY(\"product_name\", "
-        + "'lax $' NULL ON EMPTY NULL ON ERROR) AS VARCHAR(2000) CHARACTER SET \"ISO-8859-1\")\n"
+    final String expected = "SELECT JSON_VALUE(\"product_name\", 'lax $')\n"
         + "FROM \"foodmart\".\"product\"";
     sql(query).ok(expected);
   }

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -8371,7 +8371,7 @@ public void subTestIntervalSecondFailsValidation() {
     expr("json_value('{\"foo\": \"100\"}', 'lax $.foo' "
         + "returning integer)")
         .ok("JSON_VALUE('{\"foo\": \"100\"}', 'lax $.foo' "
-            + "RETURNING INTEGER NULL ON EMPTY NULL ON ERROR)");
+            + "RETURNING INTEGER)");
     expr("json_value('{\"foo\": \"100\"}', 'lax $.foo' "
         + "returning integer default 10 on empty error on error)")
         .ok("JSON_VALUE('{\"foo\": \"100\"}', 'lax $.foo' "

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -9322,7 +9322,6 @@ protected void checkAggType(SqlTester tester, String expr, String type) {
       // to raise an error and due to the big number of operands they accept
       // they increase significantly the running time of the method.
       operatorsToSkip.add(SqlStdOperatorTable.JSON_VALUE);
-      operatorsToSkip.add(SqlStdOperatorTable.JSON_VALUE_ANY);
       operatorsToSkip.add(SqlStdOperatorTable.JSON_QUERY);
     }
     // Skip since ClassCastException is raised in SqlOperator#unparse

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -11092,6 +11092,7 @@ private void checkCustomColumnResolving(String table) {
 
   @Test void testJsonValue() {
     expr("json_value('{\"foo\":\"bar\"}', 'lax $.foo')").ok();
+    expr("json_value('{\"foo\":\"bar\"}', 123)").ok();
     expr("json_value('{\"foo\":\"bar\"}', 'lax $.foo')")
         .columnType("VARCHAR(2000)");
     expr("json_value('{\"foo\":100}', 'lax $.foo')")

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
Patch:
@@ -32,6 +32,7 @@
 import com.google.common.primitives.Ints;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /** Implementation of {@link org.apache.calcite.rel.core.Uncollect} in
@@ -48,7 +49,7 @@ public EnumerableUncollect(RelOptCluster cluster, RelTraitSet traitSet,
    * <p>Use {@link #create} unless you know what you're doing. */
   public EnumerableUncollect(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode child, boolean withOrdinality) {
-    super(cluster, traitSet, child, withOrdinality);
+    super(cluster, traitSet, child, withOrdinality, Collections.emptyList());
     assert getConvention() instanceof EnumerableConvention;
     assert getConvention() == child.getConvention();
   }

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
Patch:
@@ -64,6 +64,7 @@
 
 import java.util.AbstractList;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.stream.Collectors;
 
@@ -254,7 +255,8 @@ public static RelNode fromMutable(MutableRel node, RelBuilder relBuilder) {
     case UNCOLLECT: {
       final MutableUncollect uncollect = (MutableUncollect) node;
       final RelNode child = fromMutable(uncollect.getInput(), relBuilder);
-      return Uncollect.create(child.getTraitSet(), child, uncollect.withOrdinality);
+      return Uncollect.create(child.getTraitSet(), child, uncollect.withOrdinality,
+          Collections.emptyList());
     }
     case WINDOW: {
       final MutableWindow window = (MutableWindow) node;

File: core/src/main/java/org/apache/calcite/sql/validate/SqlAbstractConformance.java
Patch:
@@ -111,4 +111,7 @@ public boolean allowQualifyingCommonColumn() {
     return SqlConformanceEnum.DEFAULT.allowQualifyingCommonColumn();
   }
 
+  public boolean allowAliasUnnestItems() {
+    return SqlConformanceEnum.DEFAULT.allowAliasUnnestItems();
+  }
 }

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -81,6 +81,7 @@ class SqlAdvisorTest extends SqlValidatorTestCase {
           "TABLE(CATALOG.SALES.EMP_ADDRESS)",
           "TABLE(CATALOG.SALES.DEPT)",
           "TABLE(CATALOG.SALES.DEPT_NESTED)",
+          "TABLE(CATALOG.SALES.DEPT_NESTED_EXPANDED)",
           "TABLE(CATALOG.SALES.BONUS)",
           "TABLE(CATALOG.SALES.ORDERS)",
           "TABLE(CATALOG.SALES.SALGRADE)",

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -2160,7 +2160,7 @@ public static RelDataType createDmlRowType(
   }
 
   /**
-   * Returns whether two types are equal using '='.
+   * Returns whether two types are equal using 'equals'.
    *
    * @param desc1 Description of first type
    * @param type1 First type
@@ -2181,7 +2181,7 @@ public static boolean eq(
       return litmus.succeed();
     }
 
-    if (type1 != type2) {
+    if (!type1.equals(type2)) {
       return litmus.fail("type mismatch:\n{}:\n{}\n{}:\n{}",
           desc1, type1.getFullTypeString(),
           desc2, type2.getFullTypeString());

File: core/src/main/java/org/apache/calcite/rex/RexLocalRef.java
Patch:
@@ -63,7 +63,7 @@ public RexLocalRef(int index, RelDataType type) {
   public boolean equals(Object obj) {
     return this == obj
         || obj instanceof RexLocalRef
-        && this.type == ((RexLocalRef) obj).type
+        && Objects.equals(this.type, ((RexLocalRef) obj).type)
         && this.index == ((RexLocalRef) obj).index;
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -2601,13 +2601,13 @@ public FixNullabilityShuttle(RexBuilder rexBuilder,
     @Override public RexNode visitInputRef(RexInputRef ref) {
       final RelDataType rightType = typeList.get(ref.getIndex());
       final RelDataType refType = ref.getType();
-      if (refType == rightType) {
+      if (refType.equals(rightType)) {
         return ref;
       }
       final RelDataType refType2 =
           rexBuilder.getTypeFactory().createTypeWithNullability(refType,
               rightType.isNullable());
-      if (refType2 == rightType) {
+      if (refType2.equals(rightType)) {
         return new RexInputRef(ref.getIndex(), refType2);
       }
       throw new AssertionError("mismatched type " + ref + " " + rightType);

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -820,7 +820,7 @@ public static boolean canCastFrom(
       RelDataType toType,
       RelDataType fromType,
       boolean coerce) {
-    if (toType == fromType) {
+    if (toType.equals(fromType)) {
       return true;
     }
     if (isAny(toType) || isAny(fromType)) {

File: core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
Patch:
@@ -189,7 +189,7 @@ public RelNode findBestExp() {
 
     // Get rid of everything except what's in the final plan.
     collectGarbage();
-
+    dumpRuleAttemptsInfo();
     return buildFinalPlan(root);
   }
 

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
Patch:
@@ -242,7 +242,7 @@ RelSubset getOrCreateSubset(
       subsets.add(subset);
 
       final VolcanoPlanner planner = (VolcanoPlanner) cluster.getPlanner();
-      if (planner.listener != null) {
+      if (planner.getListener() != null) {
         postEquivalenceEvent(planner, subset);
       }
     } else if ((required && !subset.isRequired())
@@ -272,7 +272,7 @@ private void postEquivalenceEvent(VolcanoPlanner planner, RelNode rel) {
             rel,
             "equivalence class " + id,
             false);
-    planner.listener.relEquivalenceFound(event);
+    planner.getListener().relEquivalenceFound(event);
   }
 
   /**
@@ -291,7 +291,7 @@ void addInternal(RelNode rel) {
 
       VolcanoPlanner planner =
           (VolcanoPlanner) rel.getCluster().getPlanner();
-      if (planner.listener != null) {
+      if (planner.getListener() != null) {
         postEquivalenceEvent(planner, rel);
       }
     }

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
Patch:
@@ -62,8 +62,9 @@
  *     SqlTypeCoercionRules typeCoercionRules = SqlTypeCoercionRules.instance(builder.map);
  *
  *     // Set the SqlTypeCoercionRules instance into the SqlValidator.
- *     SqlValidator validator ...;
- *     validator.setSqlTypeCoercionRules(typeCoercionRules);
+ *     SqlValidator.Config validatorConf ...;
+ *     validatorConf.withTypeCoercionRules(typeCoercionRules);
+ *     // Use this conf to initialize the SqlValidator.
  * </pre>
  */
 public class SqlTypeCoercionRule implements SqlTypeMappingRule {

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.sql.validate.implicit;
 
 import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.sql.SqlCall;
 import org.apache.calcite.sql.SqlCallBinding;
@@ -51,8 +52,8 @@
  */
 public class TypeCoercionImpl extends AbstractTypeCoercion {
 
-  public TypeCoercionImpl(SqlValidator validator) {
-    super(validator);
+  public TypeCoercionImpl(RelDataTypeFactory typeFactory, SqlValidator validator) {
+    super(typeFactory, validator);
   }
 
   /**

File: core/src/test/java/org/apache/calcite/util/SourceTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.io.CharSource;
 
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
@@ -106,6 +107,7 @@ void testRelativeFileToUrl(String path, String expectedUrl) {
 
   @ParameterizedTest
   @MethodSource("relativePaths")
+  @Disabled // Open when we really fix that
   void testAbsoluteFileToUrl(String path, String expectedUrl) throws URISyntaxException {
     File absoluteFile = new File(path).getAbsoluteFile();
     URL url = of(absoluteFile).url();

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
Patch:
@@ -162,13 +162,11 @@ private SqlTypeAssignmentRule(
     // DATE is assignable from...
     rule.clear();
     rule.add(SqlTypeName.DATE);
-    rule.add(SqlTypeName.TIMESTAMP);
     rules.add(SqlTypeName.DATE, rule);
 
     // TIME is assignable from...
     rule.clear();
     rule.add(SqlTypeName.TIME);
-    rule.add(SqlTypeName.TIMESTAMP);
     rules.add(SqlTypeName.TIME, rule);
 
     // TIME WITH LOCAL TIME ZONE is assignable from...

File: core/src/test/java/org/apache/calcite/test/SqlFunctionsTest.java
Patch:
@@ -298,6 +298,8 @@ static String trimSpacesBoth(String s) {
     checkAddMonths(2016, 3, 31, 2016, 2, 29, -1);
     checkAddMonths(2016, 3, 31, 2116, 3, 31, 1200);
     checkAddMonths(2016, 2, 28, 2116, 2, 28, 1200);
+    checkAddMonths(2019, 9, 1, 2020, 3, 1, 6);
+    checkAddMonths(2019, 9, 1, 2016, 8, 1, -37);
   }
 
   private void checkAddMonths(int y0, int m0, int d0, int y1, int m1, int d1,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregateRule.java
Patch:
@@ -35,13 +35,13 @@ class EnumerableAggregateRule extends ConverterRule {
 
   public RelNode convert(RelNode rel) {
     final LogicalAggregate agg = (LogicalAggregate) rel;
-    final RelTraitSet traitSet =
-        agg.getTraitSet().replace(EnumerableConvention.INSTANCE);
+    final RelTraitSet traitSet = rel.getCluster()
+        .traitSet().replace(EnumerableConvention.INSTANCE);
     try {
       return new EnumerableAggregate(
           rel.getCluster(),
           traitSet,
-          convert(agg.getInput(), EnumerableConvention.INSTANCE),
+          convert(agg.getInput(), traitSet),
           agg.getGroupSet(),
           agg.getGroupSets(),
           agg.getAggCallList());

File: core/src/main/java/org/apache/calcite/plan/RelTraitDef.java
Patch:
@@ -147,6 +147,7 @@ public abstract boolean canConvert(
    * @param fromRel   the RelNode to convert from (with fromTrait)
    * @return true if fromTrait can be converted to toTrait
    */
+  @Deprecated // to be removed before 1.24
   public boolean canConvert(
       RelOptPlanner planner,
       T fromTrait,

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
Patch:
@@ -205,7 +205,7 @@ private void addAbstractConverters(
         RelTrait toTrait = to.getTraitSet().getTrait(traitDef);
 
         if (toTrait == null || !traitDef.canConvert(
-            cluster.getPlanner(), fromTrait, toTrait, from)) {
+            cluster.getPlanner(), fromTrait, toTrait)) {
           needsConverter = false;
           break;
         }

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -1755,7 +1755,7 @@ public RelBuilder aggregate(GroupKey groupKey, Iterable<AggCall> aggCalls) {
           newProjects.add(project.getProjects().get(i));
           builder.add(project.getRowType().getFieldList().get(i));
         }
-        r = project.copy(r.getTraitSet(), project.getInput(), newProjects,
+        r = project.copy(cluster.traitSet(), project.getInput(), newProjects,
             builder.build());
       }
     }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableConvention.java
Patch:
@@ -62,6 +62,6 @@ public boolean canConvertConvention(Convention toConvention) {
 
   public boolean useAbstractConvertersForConversion(RelTraitSet fromTraits,
       RelTraitSet toTraits) {
-    return false;
+    return true;
   }
 }

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -495,7 +495,8 @@ public RelNode changeTraits(final RelNode rel, RelTraitSet toTraits) {
       return rel2;
     }
 
-    return rel2.set.getOrCreateSubset(rel.getCluster(), toTraits.simplify());
+    return rel2.set.getOrCreateSubset(
+        rel.getCluster(), toTraits, true);
   }
 
   public RelOptPlanner chooseDelegate() {

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCorrelateTest.java
Patch:
@@ -93,6 +93,7 @@ class EnumerableCorrelateTest {
           // instead of EnumerableHashJoin(SEMI)
           planner.addRule(JoinToCorrelateRule.INSTANCE);
           planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);
+          planner.removeRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);
         })
         .explainContains(""
             + "EnumerableCalc(expr#0..3=[{inputs}], empid=[$t1], name=[$t3])\n"
@@ -122,6 +123,7 @@ class EnumerableCorrelateTest {
           planner.addRule(JoinToCorrelateRule.INSTANCE);
           planner.addRule(FilterCorrelateRule.INSTANCE);
           planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);
+          planner.removeRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);
         })
         .explainContains(""
             + "EnumerableCalc(expr#0..3=[{inputs}], empid=[$t1], name=[$t3])\n"

File: file/src/test/java/org/apache/calcite/adapter/file/SqlTest.java
Patch:
@@ -405,7 +405,8 @@ Fluent returnsUnordered(String... expectedLines) {
         + " NAME,\n"
         + " \"DATE\".JOINEDAT\n"
         + " from \"DATE\"\n"
-        + "join emps on emps.empno = \"DATE\".EMPNO limit 3";
+        + "join emps on emps.empno = \"DATE\".EMPNO\n"
+        + "order by empno, name, joinedat limit 3";
     final String[] lines = {
         "EMPNO=100; NAME=Fred; JOINEDAT=1996-08-03",
         "EMPNO=110; NAME=Eric; JOINEDAT=2001-01-01",

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -111,8 +111,8 @@ public boolean ignoreNulls() {
       sb.append(":");
       sb.append(type.getFullTypeString());
     }
-    sb.append(" OVER (")
-        .append(window)
+    sb.append(" OVER (");
+    window.appendDigest(sb, op.allowsFraming())
         .append(")");
     return sb.toString();
   }

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java
Patch:
@@ -2642,7 +2642,7 @@ private void checkLiteral2(String expression, String expected) {
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-3112">[CALCITE-3112]
    * Support Window in RelToSqlConverter</a>. */
-  @Test public void testConvertWinodwToSql() {
+  @Test public void testConvertWindowToSql() {
     String query0 = "SELECT row_number() over (order by \"hire_date\") FROM \"employee\"";
     String expected0 = "SELECT ROW_NUMBER() OVER (ORDER BY \"hire_date\") AS \"$0\"\n"
             + "FROM \"foodmart\".\"employee\"";

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -497,9 +497,7 @@ public class JdbcAdapterTest {
         + " last_value(\"time_id\") over () as \"last_version\"\n"
         + "from \"expense_fact\"";
     final String explain = "PLAN="
-        + "EnumerableWindow(window#0=[window(partition {} "
-        + "order by [] range between UNBOUNDED PRECEDING and "
-        + "UNBOUNDED FOLLOWING aggs [LAST_VALUE($3)])])\n"
+        + "EnumerableWindow(window#0=[window(aggs [LAST_VALUE($3)])])\n"
         + "  JdbcToEnumerableConverter\n"
         + "    JdbcTableScan(table=[[foodmart, expense_fact]])\n";
     CalciteAssert

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -4401,7 +4401,7 @@ private void startOfGroupStep3(String startOfGroup) {
               + "from \"hr\".\"emps\"\n"
               + "where \"empid\" > 10")
           .convertContains(""
-              + "LogicalProject(name=[$2], EXPR$1=[+(COUNT($3) OVER (PARTITION BY $1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), 1)])\n"
+              + "LogicalProject(name=[$2], EXPR$1=[+(COUNT($3) OVER (PARTITION BY $1), 1)])\n"
               + "  LogicalFilter(condition=[>($0, 10)])\n"
               + "    LogicalProject(empid=[$0], deptno=[$1], name=[$2], commission=[$4])\n"
               + "      LogicalTableScan(table=[[hr, emps]])\n");

File: core/src/test/java/org/apache/calcite/tools/PlannerTest.java
Patch:
@@ -664,7 +664,7 @@ private void checkUnionPruning(String sql, String plan, RelOptRule... extraRules
         + "order by deptno",
         "EnumerableSort(sort0=[$2], dir0=[ASC])\n"
         + "  EnumerableProject(emp_cnt=[$5], EXPR$1=[+($0, $1)], deptno=[$1])\n"
-        + "    EnumerableWindow(window#0=[window(partition {1} order by [] range between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING aggs [COUNT()])])\n"
+        + "    EnumerableWindow(window#0=[window(partition {1} aggs [COUNT()])])\n"
         + "      EnumerableTableScan(table=[[hr, emps]])\n");
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -158,7 +158,8 @@ public static boolean containsOver(RexProgram program) {
   /**
    * Returns whether an expression list contains an OVER clause.
    */
-  public static boolean containsOver(List<RexNode> exprs, RexNode condition) {
+  public static boolean containsOver(List<? extends RexNode> exprs,
+      RexNode condition) {
     try {
       RexUtil.apply(FINDER, exprs, condition);
       return false;

File: pig/src/test/java/org/apache/calcite/test/PigRelBuilderStyleTest.java
Patch:
@@ -62,6 +62,7 @@
  * building of {@link PigRel} relational expressions using {@link RelBuilder} and
  * associated factories in {@link PigRelFactories}.
  */
+@Disabled
 public class PigRelBuilderStyleTest extends AbstractPigTest {
 
   public PigRelBuilderStyleTest() {
@@ -153,6 +154,7 @@ public void testImplWithGroupByMultipleFields() {
         new String[] { "(a,1,1)", "(b,2,1)", "(c,3,1)" });
   }
 
+  @Disabled("CALCITE-3660")
   @Test public void testImplWithGroupByCountDistinct() {
     final SchemaPlus schema = createTestSchema();
     final RelBuilder builder = createRelBuilder(schema);

File: core/src/main/java/org/apache/calcite/rel/RelWriter.java
Patch:
@@ -16,12 +16,11 @@
  */
 package org.apache.calcite.rel;
 
+import org.apache.calcite.linq4j.API;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.sql.SqlExplainLevel;
 import org.apache.calcite.util.Pair;
 
-import org.apiguardian.api.API;
-
 import java.util.List;
 
 /**

File: core/src/main/java/org/apache/calcite/rex/RexNode.java
Patch:
@@ -17,11 +17,10 @@
 package org.apache.calcite.rex;
 
 import org.apache.calcite.config.CalciteSystemProperty;
+import org.apache.calcite.linq4j.API;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.sql.SqlKind;
 
-import org.apiguardian.api.API;
-
 import java.util.Collection;
 import java.util.concurrent.atomic.AtomicInteger;
 

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.rex;
 
+import org.apache.calcite.linq4j.API;
 import org.apache.calcite.linq4j.function.Predicate1;
 import org.apache.calcite.plan.RelOptPredicateList;
 import org.apache.calcite.plan.RelOptUtil;
@@ -50,8 +51,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 
-import org.apiguardian.api.API;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;

File: core/src/main/java/org/apache/calcite/runtime/Hook.java
Patch:
@@ -16,11 +16,10 @@
  */
 package org.apache.calcite.runtime;
 
+import org.apache.calcite.linq4j.API;
 import org.apache.calcite.rel.RelRoot;
 import org.apache.calcite.util.Holder;
 
-import org.apiguardian.api.API;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.sql;
 
-import org.apiguardian.api.API;
+import org.apache.calcite.linq4j.API;
 
 import java.util.Collection;
 import java.util.EnumSet;

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -40,8 +40,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 
-import org.apiguardian.api.API;
-
 import java.math.BigDecimal;
 import java.util.AbstractList;
 import java.util.AbstractMap;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -50,6 +50,7 @@
 import org.apache.calcite.sql.SqlJsonConstructorNullClause;
 import org.apache.calcite.sql.SqlMatchFunction;
 import org.apache.calcite.sql.SqlOperator;
+import org.apache.calcite.sql.SqlTypeConstructorFunction;
 import org.apache.calcite.sql.SqlWindowTableFunction;
 import org.apache.calcite.sql.fun.SqlJsonArrayAggAggFunction;
 import org.apache.calcite.sql.fun.SqlJsonObjectAggAggFunction;
@@ -910,6 +911,8 @@ public CallImplementor get(final SqlOperator operator) {
             + " must implement ImplementableFunction");
       }
       return ((ImplementableFunction) udf).getImplementor();
+    } else if (operator instanceof SqlTypeConstructorFunction) {
+      return map.get(SqlStdOperatorTable.ROW);
     }
     return map.get(operator);
   }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -1568,7 +1568,7 @@ public void _testLikeAndSimilarFails() {
   @Test public void testInvalidMemberFunction() {
     expr("myCol.^func()^")
         .fails("(?s).*No match found for function signature FUNC().*");
-    expr("myCol.mySubschema.^memberFunc()^")
+    expr("customer.mySubschema.^memberFunc()^")
         .fails("(?s).*No match found for function signature MEMBERFUNC().*");
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -323,7 +323,7 @@ private <C extends Comparable<C>> RexNode simplifyComparison(RexCall e,
     // Simplify "x <op> x"
     final RexNode o0 = operands.get(0);
     final RexNode o1 = operands.get(1);
-    if (o0.equals(o1)) {
+    if (o0.equals(o1) && RexUtil.isDeterministic(o0)) {
       RexNode newExpr;
       switch (e.getKind()) {
       case EQUALS:

File: core/src/test/java/org/apache/calcite/test/StreamTest.java
Patch:
@@ -290,8 +290,7 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz
             + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) NOT NULL], proj#0..4=[{exprs}])\n"
             + "      EnumerableInterpreter\n"
             + "        BindableTableScan(table=[[STREAM_JOINS, ORDERS, (STREAM)]])\n"
-            + "    EnumerableInterpreter\n"
-            + "      BindableTableScan(table=[[STREAM_JOINS, PRODUCTS]])")
+            + "    EnumerableTableScan(table=[[STREAM_JOINS, PRODUCTS]])")
         .returns(
             startsWith("ROWTIME=2015-02-15 10:15:00; ORDERID=1; SUPPLIERID=1",
                 "ROWTIME=2015-02-15 10:24:15; ORDERID=2; SUPPLIERID=0",

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvFilterableTable.java
Patch:
@@ -50,6 +50,7 @@ public String toString() {
   }
 
   public Enumerable<Object[]> scan(DataContext root, List<RexNode> filters) {
+    final List<CsvFieldType> fieldTypes = getFieldTypes(root.getTypeFactory());
     final String[] filterValues = new String[fieldTypes.size()];
     filters.removeIf(filter -> addFilter(filter, filterValues));
     final int[] fields = CsvEnumerator.identityList(fieldTypes.size());

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvScannableTable.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.calcite.schema.ScannableTable;
 import org.apache.calcite.util.Source;
 
+import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
@@ -44,6 +45,7 @@ public String toString() {
   }
 
   public Enumerable<Object[]> scan(DataContext root) {
+    final List<CsvFieldType> fieldTypes = getFieldTypes(root.getTypeFactory());
     final int[] fields = CsvEnumerator.identityList(fieldTypes.size());
     final AtomicBoolean cancelFlag = DataContext.Variable.CANCEL_FLAG.get(root);
     return new AbstractEnumerable<Object[]>() {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/JsonEnumerator.java
Patch:
@@ -61,7 +61,7 @@ public JsonEnumerator(List<Object> list) {
    * of a JSON file. */
   static JsonDataConverter deduceRowType(RelDataTypeFactory typeFactory, Source source) {
     final ObjectMapper objectMapper = new ObjectMapper();
-    List<Object> list = new ArrayList<>();
+    List<Object> list;
     LinkedHashMap<String, Object> jsonFieldMap = new LinkedHashMap<>(1);
     Object jsonObj = null;
     try {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/JsonScannableTable.java
Patch:
@@ -45,7 +45,7 @@ public String toString() {
   public Enumerable<Object[]> scan(DataContext root) {
     return new AbstractEnumerable<Object[]>() {
       public Enumerator<Object[]> enumerator() {
-        return new JsonEnumerator(list);
+        return new JsonEnumerator(getDataList(root.getTypeFactory()));
       }
     };
   }

File: example/csv/src/test/java/org/apache/calcite/test/CsvTest.java
Patch:
@@ -215,8 +215,7 @@ private static StringBuilder escapeString(StringBuilder buf, String s) {
   @Test public void testPushDownProjectDumb() throws SQLException {
     // rule does not fire, because we're using 'dumb' tables in simple model
     final String sql = "explain plan for select * from EMPS";
-    final String expected = "PLAN=EnumerableInterpreter\n"
-        + "  BindableTableScan(table=[[SALES, EMPS]])\n";
+    final String expected = "PLAN=EnumerableTableScan(table=[[SALES, EMPS]])\n";
     sql("model", sql).returns(expected).ok();
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlNodeList.java
Patch:
@@ -56,8 +56,7 @@ public void add(SqlNode node) {
    * A SqlNodeList that has a single element that is a star identifier.
    */
   public static final SqlNodeList SINGLETON_STAR =
-      new SqlNodeList(ImmutableList.of(SqlIdentifier.star(SqlParserPos.ZERO)),
-          SqlParserPos.ZERO);
+      new SqlNodeList(ImmutableList.of(SqlIdentifier.STAR), SqlParserPos.ZERO);
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -334,12 +334,11 @@ private static CalciteAssert.AssertThat modelWithLattices(
           .convertMatches(
               CalciteAssert.checkRel(""
                   + "LogicalAggregate(group=[{}], EXPR$0=[COUNT()])\n"
-                  + "  LogicalProject(DUMMY=[0])\n"
-                  + "    StarTableScan(table=[[adhoc, star]])\n",
+                  + "  StarTableScan(table=[[adhoc, star]])\n",
                   counter));
     } catch (Throwable e) {
       assertThat(Throwables.getStackTraceAsString(e),
-          containsString("java.lang.AssertionError"));
+          containsString("CannotPlanException"));
     }
     assertThat(counter.get(), equalTo(1));
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScanRule.java
Patch:
@@ -62,9 +62,7 @@ public EnumerableTableScanRule(RelBuilderFactory relBuilderFactory) {
     final Table table = relOptTable.unwrap(Table.class);
     final Expression expression = relOptTable.getExpression(Object.class);
 
-    if (table instanceof QueryableTable
-        && (expression != null
-            || EnumerableTableScan.canHandle(relOptTable))) {
+    if (table instanceof QueryableTable) {
       return EnumerableTableScan.create(scan.getCluster(), relOptTable);
     }
 

File: core/src/main/java/org/apache/calcite/plan/RelOptMaterialization.java
Patch:
@@ -23,7 +23,6 @@
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.logical.LogicalJoin;
-import org.apache.calcite.rel.logical.LogicalTableScan;
 import org.apache.calcite.rel.metadata.DefaultRelMetadataProvider;
 import org.apache.calcite.rel.rules.AggregateFilterTransposeRule;
 import org.apache.calcite.rel.rules.AggregateProjectMergeRule;
@@ -156,7 +155,7 @@ private void match(ProjectFilterTable left, ProjectFilterTable right,
                           Mappings.offsetSource(rightMapping, offset),
                           leftMapping.getTargetCount()));
               final RelNode project = RelOptUtil.createProject(
-                  LogicalTableScan.create(cluster, leftRelOptTable, ImmutableList.of()),
+                  leftRelOptTable.toRel(ViewExpanders.simpleContext(cluster)),
                   Mappings.asList(mapping.inverse()));
               final List<RexNode> conditions = new ArrayList<>();
               if (left.condition != null) {
@@ -180,7 +179,7 @@ private void match(ProjectFilterTable left, ProjectFilterTable right,
                       Mappings.offsetSource(leftMapping, offset),
                       Mappings.offsetTarget(rightMapping, leftCount));
               final RelNode project = RelOptUtil.createProject(
-                  LogicalTableScan.create(cluster, rightRelOptTable, ImmutableList.of()),
+                  rightRelOptTable.toRel(ViewExpanders.simpleContext(cluster)),
                   Mappings.asList(mapping.inverse()));
               final List<RexNode> conditions = new ArrayList<>();
               if (left.condition != null) {

File: core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
Patch:
@@ -113,7 +113,7 @@ public RelNode toRel(ToRelContext context) {
   }
 
   public Expression getExpression(Class clazz) {
-    throw new UnsupportedOperationException();
+    return null;
   }
 
   public RelOptTable extend(List<RelDataTypeField> extendedFields) {

File: core/src/main/java/org/apache/calcite/plan/RelOptRules.java
Patch:
@@ -65,7 +65,6 @@
 import org.apache.calcite.rel.rules.SortRemoveConstantKeysRule;
 import org.apache.calcite.rel.rules.SortRemoveRule;
 import org.apache.calcite.rel.rules.SortUnionTransposeRule;
-import org.apache.calcite.rel.rules.TableScanRule;
 import org.apache.calcite.rel.rules.UnionMergeRule;
 import org.apache.calcite.rel.rules.UnionPullUpConstantsRule;
 import org.apache.calcite.rel.rules.UnionToDistinctRule;
@@ -113,7 +112,6 @@ private RelOptRules() {
   static final List<RelOptRule> BASE_RULES = ImmutableList.of(
       AggregateStarTableRule.INSTANCE,
       AggregateStarTableRule.INSTANCE2,
-      TableScanRule.INSTANCE,
       CalciteSystemProperty.COMMUTE.value()
           ? JoinAssociateRule.INSTANCE
           : ProjectMergeRule.INSTANCE,

File: core/src/main/java/org/apache/calcite/plan/RelOptTable.java
Patch:
@@ -116,6 +116,8 @@ public interface RelOptTable extends Wrapper {
    * Generates code for this table.
    *
    * @param clazz The desired collection class; for example {@code Queryable}.
+   *
+   * @return the code for the table, or null if code generation is not supported
    */
   Expression getExpression(Class clazz);
 

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -2038,7 +2038,6 @@ public static void registerDefaultRules(RelOptPlanner planner,
         planner.addRule(rule);
       }
     }
-    planner.addRule(Bindables.BINDABLE_TABLE_SCAN_RULE);
     planner.addRule(ProjectTableScanRule.INSTANCE);
     planner.addRule(ProjectTableScanRule.INTERPRETER);
 

File: core/src/main/java/org/apache/calcite/rel/core/RelFactories.java
Patch:
@@ -530,7 +530,7 @@ default RelNode createScan(RelOptCluster cluster, RelOptTable table) {
    */
   private static class TableScanFactoryImpl implements TableScanFactory {
     public RelNode createScan(RelOptCluster cluster, RelOptTable table, List<RelHint> hints) {
-      return LogicalTableScan.create(cluster, table, hints);
+      return table.toRel(ViewExpanders.simpleContext(cluster, hints));
     }
   }
 

File: core/src/main/java/org/apache/calcite/tools/Programs.java
Patch:
@@ -55,7 +55,6 @@
 import org.apache.calcite.rel.rules.SemiJoinRule;
 import org.apache.calcite.rel.rules.SortProjectTransposeRule;
 import org.apache.calcite.rel.rules.SubQueryRemoveRule;
-import org.apache.calcite.rel.rules.TableScanRule;
 import org.apache.calcite.sql2rel.RelDecorrelator;
 import org.apache.calcite.sql2rel.RelFieldTrimmer;
 import org.apache.calcite.sql2rel.SqlToRelConverter;
@@ -85,6 +84,7 @@ public class Programs {
 
   public static final ImmutableSet<RelOptRule> RULE_SET =
       ImmutableSet.of(
+          EnumerableRules.ENUMERABLE_TABLE_SCAN_RULE,
           EnumerableRules.ENUMERABLE_JOIN_RULE,
           EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE,
           EnumerableRules.ENUMERABLE_CORRELATE_RULE,
@@ -102,7 +102,6 @@ public class Programs {
           EnumerableRules.ENUMERABLE_MATCH_RULE,
           SemiJoinRule.PROJECT,
           SemiJoinRule.JOIN,
-          TableScanRule.INSTANCE,
           MatchRule.INSTANCE,
           CalciteSystemProperty.COMMUTE.value()
               ? JoinAssociateRule.INSTANCE

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -122,7 +122,6 @@
 import org.apache.calcite.rel.rules.SortRemoveConstantKeysRule;
 import org.apache.calcite.rel.rules.SortUnionTransposeRule;
 import org.apache.calcite.rel.rules.SubQueryRemoveRule;
-import org.apache.calcite.rel.rules.TableScanRule;
 import org.apache.calcite.rel.rules.UnionMergeRule;
 import org.apache.calcite.rel.rules.UnionPullUpConstantsRule;
 import org.apache.calcite.rel.rules.UnionToDistinctRule;
@@ -1968,7 +1967,6 @@ private void basePushFilterPastAggWithGroupingSets(boolean unchanged)
 
   @Test public void testMergeFilterWithJoinCondition() throws Exception {
     HepProgram program = new HepProgramBuilder()
-        .addRuleInstance(TableScanRule.INSTANCE)
         .addRuleInstance(JoinExtractFilterRule.INSTANCE)
         .addRuleInstance(FilterToCalcRule.INSTANCE)
         .addRuleInstance(ProjectToCalcRule.INSTANCE)
@@ -2239,7 +2237,6 @@ private void basePushFilterPastAggWithGroupingSets(boolean unchanged)
     // of the projections, transfer it to calc, for the other,
     // keep it unchanged.
     HepProgram program = new HepProgramBuilder()
-        .addRuleInstance(TableScanRule.INSTANCE)
         // Control the calc conversion.
         .addMatchLimit(1)
         .addRuleInstance(ProjectToCalcRule.INSTANCE)

File: core/src/test/java/org/apache/calcite/tools/FrameworksTest.java
Patch:
@@ -522,7 +522,7 @@ public Type getElementType() {
 
     public Expression getExpression(SchemaPlus schema, String tableName,
         Class clazz) {
-      throw new UnsupportedOperationException();
+      return null;
     }
   }
 

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/MatchTest.java
Patch:
@@ -200,7 +200,7 @@ private CalciteAssert.ConnectionFactory newConnectionFactory() {
     String builderExpected = ""
         + "LogicalFilter(condition=[CONTAINS($1, 'waltham')])\n"
         + "  LogicalProject(_MAP=[$0], city=[ITEM($0, 'city')])\n"
-        + "    LogicalTableScan(table=[[elastic, " + ZIPS + "]])\n";
+        + "    ElasticsearchTableScan(table=[[elastic, " + ZIPS + "]])\n";
 
     RelNode root = builder.build();
 

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleCall.java
Patch:
@@ -210,11 +210,11 @@ public boolean isRuleExcluded() {
   }
 
   /**
-   * Returns the current RelMetadataQuery or its sub-class,
+   * Returns the current RelMetadataQuery
    * to be used for instance by
    * {@link RelOptRule#onMatch(RelOptRuleCall)}.
    */
-  public <M extends RelMetadataQuery> M getMetadataQuery() {
+  public RelMetadataQuery getMetadataQuery() {
     return rel(0).getCluster().getMetadataQuery();
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -331,8 +331,9 @@ public SqlToRelConverter(
     this.config = new ConfigBuilder().withConfig(config).build();
     this.relBuilder = config.getRelBuilderFactory().create(cluster, null);
     this.hintStrategies = config.getHintStrategyTable();
-    this.cluster = Objects.requireNonNull(cluster)
-        .withHintStrategies(this.hintStrategies);
+
+    cluster.setHintStrategies(this.hintStrategies);
+    this.cluster = Objects.requireNonNull(cluster);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/rules/AbstractMaterializedViewRule.java
Patch:
@@ -960,7 +960,9 @@ protected MaterializedViewAggregateRule(RelOptRuleOperand operand,
           Filter.class, relBuilderFactory, Aggregate.class);
       this.aggregateProjectPullUpConstantsRule = new AggregateProjectPullUpConstantsRule(
           Aggregate.class, Filter.class, relBuilderFactory, "AggFilterPullUpConstants");
-      this.projectMergeRule = new ProjectMergeRule(true, relBuilderFactory);
+      this.projectMergeRule =
+          new ProjectMergeRule(true, ProjectMergeRule.DEFAULT_BLOAT,
+              relBuilderFactory);
     }
 
     @Override protected boolean isValidPlan(Project topProject, RelNode node,

File: core/src/test/java/org/apache/calcite/rex/RexProgramTest.java
Patch:
@@ -738,7 +738,7 @@ private void checkExponentialCnf(int n) {
               rexBuilder.makeFieldAccess(range3, i * 2 + 1)));
     }
     final RexNode cnf = RexUtil.toCnf(rexBuilder, or(list));
-    final int nodeCount = nodeCount(cnf);
+    final int nodeCount = cnf.nodeCount();
     assertThat((n + 1) * (int) Math.pow(2, n) + 1, equalTo(nodeCount));
     if (n == 3) {
       assertThat(cnf.toStringRaw(),

File: core/src/test/java/org/apache/calcite/tools/PlannerTest.java
Patch:
@@ -1377,7 +1377,7 @@ public RelDataType deriveType(SqlValidator validator,
   @Test public void testMergeProjectForceMode() throws Exception {
     RuleSet ruleSet =
         RuleSets.ofList(
-            new ProjectMergeRule(true,
+            new ProjectMergeRule(true, ProjectMergeRule.DEFAULT_BLOAT,
                 RelBuilder.proto(RelFactories.DEFAULT_PROJECT_FACTORY)));
     Planner planner = getPlanner(null, Programs.of(ruleSet));
     planner.close();

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
Patch:
@@ -181,9 +181,7 @@ private String translateMatch(RexNode condition) {
      */
     private static String literalValue(RexLiteral literal) {
       Object value = literal.getValue2();
-      StringBuilder buf = new StringBuilder();
-      buf.append(value);
-      return buf.toString();
+      return String.valueOf(value);
     }
 
     /** Translate a conjunctive predicate to a CQL string.

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateCaseToFilterRule.java
Patch:
@@ -166,7 +166,7 @@ && isThreeArgCase(project.getProjects().get(singleArg))) {
 
     // Operand 1: Filter
     final SqlPostfixOperator op =
-        flip ? SqlStdOperatorTable.IS_FALSE : SqlStdOperatorTable.IS_TRUE;
+        flip ? SqlStdOperatorTable.IS_NOT_TRUE : SqlStdOperatorTable.IS_TRUE;
     final RexNode filterFromCase =
         rexBuilder.makeCall(op, caseCall.operands.get(0));
 

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -1117,6 +1117,8 @@ public boolean supportsImplicitTypeCoercion(RexCall call) {
     case UNKNOWN:
     case CALCITE:
       return SqlConformanceEnum.DEFAULT;
+    case BIG_QUERY:
+      return SqlConformanceEnum.BIG_QUERY;
     case MYSQL:
       return SqlConformanceEnum.MYSQL_5;
     case ORACLE:

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterStructsTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.calcite.sql.SqlCall;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.dialect.CalciteSqlDialect;
+import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.ImmutableBitSet;
 
@@ -180,8 +181,8 @@ public class RelToSqlConverterStructsTest {
 
   private RelToSqlConverterTest.Sql sql(String sql) {
     return new RelToSqlConverterTest.Sql(ROOT_SCHEMA, sql,
-        CalciteSqlDialect.DEFAULT, RelToSqlConverterTest.DEFAULT_REL_CONFIG,
-        ImmutableList.of());
+        CalciteSqlDialect.DEFAULT, SqlParser.Config.DEFAULT,
+        RelToSqlConverterTest.DEFAULT_REL_CONFIG, ImmutableList.of());
   }
 
   @Test public void testNestedSchemaSelectStar() {

File: cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterTest.java
Patch:
@@ -25,13 +25,13 @@
 
 import com.google.common.collect.ImmutableMap;
 
-import net.jcip.annotations.NotThreadSafe;
-
 import org.cassandraunit.CassandraCQLUnit;
 import org.cassandraunit.dataset.cql.ClassPathCQLDataSet;
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
 import org.junit.Test;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.rules.ExternalResource;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
@@ -55,7 +55,7 @@
 // force tests to run sequentially (maven surefire and failsafe are running them in parallel)
 // seems like some of our code is sharing static variables (like Hooks) which causes tests
 // to fail non-deterministically (flaky tests).
-@NotThreadSafe
+@Execution(ExecutionMode.SAME_THREAD)
 public class CassandraAdapterTest {
 
   @ClassRule

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -34,12 +34,12 @@
 
 import com.google.common.collect.ImmutableList;
 
-import net.jcip.annotations.NotThreadSafe;
-
 import org.hamcrest.CoreMatchers;
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -88,7 +88,7 @@
  * Technically speaking, the test is thread safe, however Caclite/Avatica have thread-safety issues
  * see https://issues.apache.org/jira/browse/CALCITE-2853.
  */
-@NotThreadSafe
+@Execution(ExecutionMode.SAME_THREAD)
 public class CalciteRemoteDriverTest {
   public static final String LJS = Factory2.class.getName();
 

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -3157,9 +3157,9 @@ private void checkReduceNullableToNotNull(ReduceExpressionsRule rule) {
         + "when 1 IS NOT NULL then 2\n"
         + "else null end as qx "
         + "from emp";
-    try (Hook.Closeable a = Hook.REL_BUILDER_SIMPLIFY.add(Hook.propertyJ(false))) {
-      sql(sql).with(program).check();
-    }
+    sql(sql)
+        .withProperty(Hook.REL_BUILDER_SIMPLIFY, false)
+        .with(program).check();
   }
 
   @Test public void testReduceCastsNullable() throws Exception {

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableRepeatUnionHierarchyTest.java
Patch:
@@ -26,8 +26,6 @@
 import org.apache.calcite.test.HierarchySchema;
 import org.apache.calcite.tools.RelBuilder;
 
-import net.jcip.annotations.NotThreadSafe;
-
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 
@@ -42,7 +40,6 @@
  * <a href="https://issues.apache.org/jira/browse/CALCITE-2812">[CALCITE-2812]
  * Add algebraic operators to allow expressing recursive queries</a>.
  */
-@NotThreadSafe
 public class EnumerableRepeatUnionHierarchyTest {
 
   // Tests for the following hierarchy:

File: redis/src/test/java/org/apache/calcite/adapter/redis/RedisCaseBase.java
Patch:
@@ -18,6 +18,8 @@
 
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 
 import java.io.IOException;
 import java.net.ServerSocket;
@@ -27,6 +29,7 @@
 /**
  * RedisITCaseBase.
  */
+@Execution(ExecutionMode.SAME_THREAD)
 public abstract class RedisCaseBase {
 
   public static final int PORT = getAvailablePort();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -397,6 +397,7 @@ public Boolean areColumnsUnique(RelSubset rel, RelMetadataQuery mq,
       if (rel2 instanceof Aggregate
           || rel2 instanceof Filter
           || rel2 instanceof Values
+          || rel2 instanceof Sort
           || rel2 instanceof TableScan
           || simplyProjects(rel2, columns)) {
         try {

File: core/src/main/java/org/apache/calcite/plan/RelOptTable.java
Patch:
@@ -162,7 +162,7 @@ interface ToRelContext extends ViewExpander {
   }
 
   /** Interface to customize the {@link ToRelContext}. **/
-  interface ToRelContextSupplier {
+  interface ToRelContextFactory {
     /**
      * Returns a {@link ToRelContext} instance.
      *
@@ -173,7 +173,7 @@ interface ToRelContextSupplier {
      *
      * @return A new {@link ToRelContext} instance.
      */
-    ToRelContext get(RelOptTable.ViewExpander viewExpander,
+    ToRelContext createToRelContext(RelOptTable.ViewExpander viewExpander,
         RelOptCluster cluster, List<RelHint> hints);
   }
 }

File: core/src/main/java/org/apache/calcite/rel/hint/package-info.java
Patch:
@@ -33,8 +33,8 @@
  *
  * <h2>Customize Hint Matching Rules</h2>
  * Calcite implements a framework to define and propagate the hints. In order to make the hints
- *  propagate efficiently, every hint referenced in the sql statement needs to
- *  register the propagation rules.
+ * propagate efficiently, every hint referenced in the sql statement needs to
+ * register the propagation rules.
  *
  * <p>We support two kinds of matching rules for rule registration:
  *

File: babel/src/test/java/org/apache/calcite/test/BabelQuidemTest.java
Patch:
@@ -23,7 +23,6 @@
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlWriter;
-import org.apache.calcite.sql.dialect.CalciteSqlDialect;
 import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.sql.parser.babel.SqlBabelParserImpl;
 import org.apache.calcite.sql.pretty.SqlPrettyWriter;
@@ -152,8 +151,7 @@ static class ExplainValidatedCommand extends AbstractCommand {
         final Planner planner = Frameworks.getPlanner(config.build());
         final SqlNode node = planner.parse(sqlCommand.sql);
         final SqlNode validateNode = planner.validate(node);
-        final SqlWriter sqlWriter =
-            new SqlPrettyWriter(CalciteSqlDialect.DEFAULT);
+        final SqlWriter sqlWriter = new SqlPrettyWriter();
         validateNode.unparse(sqlWriter, 0, 0);
         x.echo(ImmutableList.of(sqlWriter.toSqlString().getSql()));
       } else {

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -521,8 +521,7 @@ public Result visit(Values e) {
 
           // Wrap "SELECT 1 AS x"
           // as "SELECT * FROM (SELECT 1 AS x) AS t WHERE false"
-          query = new SqlSelect(POS, null,
-              new SqlNodeList(ImmutableList.of(SqlIdentifier.star(POS)), POS),
+          query = new SqlSelect(POS, null, SqlNodeList.SINGLETON_STAR,
               as(query, "t"), createAlwaysFalseCondition(), null, null,
               null, null, null, null, null);
         } else {

File: core/src/main/java/org/apache/calcite/sql/SqlAsOperator.java
Patch:
@@ -72,7 +72,7 @@ public void unparse(
     assert call.operandCount() >= 2;
     final SqlWriter.Frame frame =
         writer.startList(
-            SqlWriter.FrameTypeEnum.SIMPLE);
+            SqlWriter.FrameTypeEnum.AS);
     call.operand(0).unparse(writer, leftPrec, getLeftPrec());
     final boolean needsSpace = true;
     writer.setNeedWhitespace(needsSpace);

File: core/src/main/java/org/apache/calcite/sql/SqlWithinGroupOperator.java
Patch:
@@ -48,7 +48,7 @@ public SqlWithinGroupOperator() {
     final SqlWriter.Frame orderFrame =
         writer.startList(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, "(", ")");
     writer.keyword("ORDER BY");
-    ((SqlNodeList) call.operand(1)).commaList(writer);
+    ((SqlNodeList) call.operand(1)).unparse(writer, 0, 0);
     writer.endList(orderFrame);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -74,6 +74,7 @@
  * the standard operators and functions.
  */
 public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
+
   //~ Static fields/initializers ---------------------------------------------
 
   /**

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -36,7 +36,6 @@
 import org.apache.calcite.sql.SqlOperandCountRange;
 import org.apache.calcite.sql.SqlOperator;
 import org.apache.calcite.sql.dialect.AnsiSqlDialect;
-import org.apache.calcite.sql.dialect.CalciteSqlDialect;
 import org.apache.calcite.sql.fun.SqlLibrary;
 import org.apache.calcite.sql.fun.SqlLibraryOperatorTableFactory;
 import org.apache.calcite.sql.fun.SqlLibraryOperators;
@@ -9004,8 +9003,7 @@ protected void checkAggType(SqlTester tester, String expr, String type) {
           if (!typeChecker.checkOperandTypes(binding, false)) {
             continue;
           }
-          final SqlPrettyWriter writer =
-              new SqlPrettyWriter(CalciteSqlDialect.DEFAULT);
+          final SqlPrettyWriter writer = new SqlPrettyWriter();
           op.unparse(writer, call, 0, 0);
           final String s = writer.toSqlString().toString();
           if (s.startsWith("OVERLAY(")

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -306,7 +306,7 @@ public class JdbcAdapterTest {
             + "\"t0\".\"DNAME\", \"SALGRADE\".\"GRADE\"\n"
             + "FROM \"SCOTT\".\"SALGRADE\"\n"
             + "INNER JOIN ((SELECT \"EMPNO\", \"ENAME\", \"SAL\", \"DEPTNO\"\n"
-            + "FROM \"SCOTT\".\"EMP\") AS \"t\"\n"
+            + "FROM \"SCOTT\".\"EMP\") AS \"t\" "
             + "INNER JOIN (SELECT \"DEPTNO\", \"DNAME\"\n"
             + "FROM \"SCOTT\".\"DEPT\") AS \"t0\" ON \"t\".\"DEPTNO\" = \"t0\".\"DEPTNO\")"
             + " ON \"SALGRADE\".\"LOSAL\" < \"t\".\"SAL\" AND \"SALGRADE\".\"HISAL\" > \"t\".\"SAL\"");

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -711,7 +711,7 @@ public Result visit(TableModify modify) {
 
       final SqlInsert sqlInsert =
           new SqlInsert(POS, SqlNodeList.EMPTY, sqlTargetTable, sqlSource,
-              identifierList(modify.getInput().getRowType().getFieldNames()));
+              identifierList(modify.getTable().getRowType().getFieldNames()));
 
       return result(sqlInsert, ImmutableList.of(), modify, null);
     }

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -279,8 +279,8 @@ public static List<Pair<String, String>> getFoodmartQueries() {
           assertThat(resultSet.getString(1),
               isLinux(
                   "EnumerableTableModify(table=[[adhoc, MUTABLE_EMPLOYEES]], operation=[INSERT], flattened=[false])\n"
-                  + "  EnumerableCalc(expr#0..2=[{inputs}], expr#3=[CAST($t1):JavaType(int) NOT NULL], expr#4=[10], expr#5=[CAST($t0):JavaType(class java.lang.String)], expr#6=[CAST($t2):JavaType(float) NOT NULL], expr#7=[null:JavaType(class java.lang.Integer)], empid=[$t3], deptno=[$t4], name=[$t5], salary=[$t6], commission=[$t7])\n"
-                  + "    EnumerableValues(tuples=[[{ 'Fred', 56, 123.4 }]])\n"));
+                      + "  EnumerableCalc(expr#0=[{inputs}], expr#1=[56], expr#2=[10], expr#3=['Fred':JavaType(class java.lang.String)], expr#4=[CAST($t3):JavaType(class java.lang.String)], expr#5=[123.4:JavaType(float)], expr#6=[null:JavaType(class java.lang.Integer)], empid=[$t1], deptno=[$t2], name=[$t4], salary=[$t5], commission=[$t6])\n"
+                      + "    EnumerableValues(tuples=[[{ 0 }]])\n"));
 
           // With named columns
           resultSet =

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -1092,7 +1092,7 @@ protected final void check(
 
   @Test public void testUpdateExtendedColumnModifiableViewUnderlyingCollision() {
     sql("update EMP_MODIFIABLEVIEW3(extra BOOLEAN, comm INTEGER)"
-        + " set empno = 20, comm = true, extra = true"
+        + " set empno = 20, comm = 123, extra = true"
         + " where ename = 'Bob'").with(getExtendedTester()).ok();
   }
 

File: core/src/test/java/org/apache/calcite/tools/PlannerTest.java
Patch:
@@ -743,11 +743,11 @@ private void runDuplicateSortCheck(String sql, String plan) throws Exception {
     RelNode convert = planner.rel(validate).rel;
     RelDataType insertSourceType = convert.getInput(0).getRowType();
     String typeString = SqlTests.getTypeString(insertSourceType);
-    assertEquals("RecordType(INTEGER NOT NULL empid, INTEGER NOT NULL deptno, VARCHAR name, "
-            + "REAL NOT NULL salary, INTEGER commission) NOT NULL", typeString);
+    assertEquals("RecordType(INTEGER NOT NULL empid, INTEGER NOT NULL deptno, "
+        + "JavaType(class java.lang.String) name, REAL NOT NULL salary, "
+        + "INTEGER NOT NULL commission) NOT NULL", typeString);
   }
 
-
   /** Unit test that parses, validates, converts and plans. Planner is
    * provided with a list of RelTraitDefs to register. */
   @Test public void testPlanWithExplicitTraitDefs() throws Exception {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
Patch:
@@ -156,7 +156,7 @@ static Class[] toClassArray(Collection<Type> types) {
     return classes.toArray(new Class[0]);
   }
 
-  static Class[] toClassArray(Iterable<? extends Expression> arguments) {
+  public static Class[] toClassArray(Iterable<? extends Expression> arguments) {
     List<Class> classes = new ArrayList<>();
     for (Expression argument : arguments) {
       classes.add(toClass(argument.getType()));
@@ -255,7 +255,7 @@ public static PseudoField nthField(int ordinal, Type clazz) {
     return field(toClass(clazz).getFields()[ordinal]);
   }
 
-  static boolean allAssignable(boolean varArgs, Class[] parameterTypes,
+  public static boolean allAssignable(boolean varArgs, Class[] parameterTypes,
       Class[] argumentTypes) {
     if (varArgs) {
       if (argumentTypes.length < parameterTypes.length - 1) {

File: core/src/test/java/org/apache/calcite/test/MaterializationTest.java
Patch:
@@ -1661,7 +1661,7 @@ private void checkSatisfiable(RexNode e, String s) {
         HR_FKUK_MODEL,
         CalciteAssert.checkResultContains(
             "EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1], expr#3=[+($t1, $t2)],"
-                + " deptno=[$t0], $f1=[$t3])\n"
+                + " deptno=[$t0], S=[$t3])\n"
                 + "  EnumerableAggregate(group=[{1}], agg#0=[$SUM0($3)])\n"
                 + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[10], expr#5=[<($t4, $t1)], "
                 + "proj#0..3=[{exprs}], $condition=[$t5])\n"
@@ -1686,7 +1686,7 @@ private void checkSatisfiable(RexNode e, String s) {
         HR_FKUK_MODEL,
         CalciteAssert.checkResultContains(
             "EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1], expr#3=[+($t0, $t2)], "
-                + "expr#4=[+($t1, $t2)], $f0=[$t3], $f1=[$t4])\n"
+                + "expr#4=[+($t1, $t2)], EXPR$0=[$t3], S=[$t4])\n"
                 + "  EnumerableAggregate(group=[{1}], agg#0=[$SUM0($3)])\n"
                 + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[10], expr#5=[<($t4, $t1)], "
                 + "proj#0..3=[{exprs}], $condition=[$t5])\n"

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -2103,7 +2103,7 @@ protected void convertFrom(
       return;
 
     case SNAPSHOT:
-      snapshotTemporalTable(bb, (SqlCall) from);
+      convertTemporalTable(bb, (SqlCall) from);
       return;
 
     case JOIN:
@@ -2474,7 +2474,7 @@ protected void afterTableFunction(
       LogicalTableFunctionScan callRel) {
   }
 
-  private void snapshotTemporalTable(Blackboard bb, SqlCall call) {
+  private void convertTemporalTable(Blackboard bb, SqlCall call) {
     final SqlSnapshot snapshot = (SqlSnapshot) call;
     final RexNode period = bb.convertExpression(snapshot.getPeriod());
 

File: core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
Patch:
@@ -60,7 +60,7 @@ public static String extractValue(String input, String xpath) {
         return xpathExpression.evaluate(new InputSource(new StringReader(input)));
       }
     } catch (XPathExpressionException ex) {
-      throw RESOURCE.illegalBehaviorInExtractValueFunc(ex.toString(), input, xpath).ex();
+      throw RESOURCE.invalidInputForExtractValue(input, xpath).ex();
     }
   }
 }

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -5170,9 +5170,9 @@ private void checkNullOperand(SqlTester tester, String op) {
     mySqlTester.checkNull("ExtractValue(NULL, '//b')");
     mySqlTester.checkNull("ExtractValue('', NULL)");
     mySqlTester.checkFails("ExtractValue('<a><b/></a>', '#/a/b')",
-        "Illegal behavior '.*", true);
+        "Invalid input for EXTRACTVALUE: xml: '.*", true);
     mySqlTester.checkFails("ExtractValue('<a><b/></a></a>', '/b')",
-        "Illegal behavior '.*", true);
+        "Invalid input for EXTRACTVALUE: xml: '.*", true);
 
     mySqlTester.checkString("ExtractValue('<a>c</a>', '//a')",
         "c", "VARCHAR(2000)");

File: core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
Patch:
@@ -37,7 +37,7 @@
  * relational expressions.
  *
  * <p>A {@code HintStrategy} can be used independently or cascaded with other strategies
- * with method {@link HintStrategies#cascade}.
+ * with method {@link HintStrategies#and}.
  *
  * <p>The matching for hint name is case in-sensitive.
  *

File: core/src/main/java/org/apache/calcite/sql/SqlSelect.java
Patch:
@@ -92,7 +92,7 @@ public SqlOperator getOperator() {
 
   @Override public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(keywordList, selectList, from, where,
-        groupBy, having, windowDecls, orderBy, offset, fetch);
+        groupBy, having, windowDecls, orderBy, offset, fetch, hints);
   }
 
   @Override public void setOperand(int i, SqlNode operand) {

File: core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
Patch:
@@ -64,5 +64,3 @@ public static String extractValue(String input, String xpath) {
     }
   }
 }
-
-// End XmlFunctions.java

File: core/src/test/java/org/apache/calcite/test/SqlXmlFunctionsTest.java
Patch:
@@ -71,5 +71,3 @@ private void assertFailed(String invocationDesc, Supplier<?> supplier,
     }
   }
 }
-
-// End SqlXmlFunctionsTest.java

File: core/src/test/java/org/apache/calcite/test/SqlXmlFunctionsTest.java
Patch:
@@ -35,8 +35,7 @@
  */
 public class SqlXmlFunctionsTest {
 
-  @Test
-  public void testExtractValue() {
+  @Test public void testExtractValue() {
     assertExtractValue("<a>ccc<b>ddd</b></a>", "/a", is("ccc"));
 
     String input = "<a>ccc<b>ddd</b></a>";

File: core/src/test/java/org/apache/calcite/schemas/HrClusteredSchema.java
Patch:
@@ -49,7 +49,6 @@ public final class HrClusteredSchema extends AbstractSchema {
   private final ImmutableMap<String, Table> tables;
 
   public HrClusteredSchema() {
-    super();
     tables = ImmutableMap.<String, Table>builder()
         .put("emps",
             new PkClusteredTable(

File: core/src/test/java/org/apache/calcite/test/DiffRepository.java
Patch:
@@ -173,8 +173,6 @@ public class DiffRepository {
   private final File logFile;
   private final Filter filter;
 
-  //~ Constructors -----------------------------------------------------------
-
   /**
    * Creates a DiffRepository.
    *

File: core/src/test/java/org/apache/calcite/test/DiffTestCase.java
Patch:
@@ -83,8 +83,6 @@ public abstract class DiffTestCase {
    */
   private boolean verbose;
 
-  //~ Constructors -----------------------------------------------------------
-
   /**
    * Initializes a new DiffTestCase.
    *

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -7590,7 +7590,6 @@ public SalesFact(int cust_id, int prod_id) {
   public abstract static class AbstractModifiableTable
       extends AbstractTable implements ModifiableTable {
     protected AbstractModifiableTable(String tableName) {
-      super();
     }
 
     public TableModify toModificationRel(
@@ -7611,7 +7610,6 @@ public TableModify toModificationRel(
   public abstract static class AbstractModifiableView
       extends AbstractTable implements ModifiableView {
     protected AbstractModifiableView() {
-      super();
     }
   }
 
@@ -7696,7 +7694,6 @@ public static class AutoTempDriver
     private final List<Object> results;
 
     AutoTempDriver(List<Object> results) {
-      super();
       this.results = results;
     }
 

File: core/src/test/java/org/apache/calcite/test/TypeCoercionTest.java
Patch:
@@ -77,8 +77,6 @@ public class TypeCoercionTest extends SqlValidatorTestCase {
   private RelDataType varcharType;
   private RelDataType varchar20Type;
 
-  //~ Constructors -----------------------------------------------------------
-
   public TypeCoercionTest() {
     // tool tester impl.
     SqlTester tester1 = new SqlValidatorTester(SqlTestFactory.INSTANCE);

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommandScript.java
Patch:
@@ -81,7 +81,6 @@
  */
 public class ConcurrentTestCommandScript
     extends ConcurrentTestCommandGenerator {
-  //~ Static fields/initializers ---------------------------------------------
 
   private static final String PRE_SETUP_STATE = "pre-setup";
   private static final String SETUP_STATE = "setup";
@@ -261,8 +260,6 @@ public class ConcurrentTestCommandScript
   private final Map<Integer, ResultsReader> threadResultsReaders =
       new HashMap<>();
 
-  //~ Constructors -----------------------------------------------------------
-
   public ConcurrentTestCommandScript() throws IOException {
     super();
   }

File: core/src/test/java/org/apache/calcite/tools/TpchSchema.java
Patch:
@@ -31,7 +31,6 @@ public static class Part {
 
 
     public Part(int pPartkey) {
-      super();
       this.pPartkey = pPartkey;
     }
 
@@ -48,7 +47,6 @@ public static class PartSupp {
     public int psSupplyCost;
 
     public PartSupp(int psPartkey, int psSupplyCost) {
-      super();
       this.psPartkey = psPartkey;
       this.psSupplyCost = psSupplyCost;
     }

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.calcite.sql.validate.SqlMoniker;
 import org.apache.calcite.sql.validate.SqlMonikerType;
 import org.apache.calcite.test.SqlValidatorTestCase;
-import org.apache.calcite.test.WithLex;
+import org.apache.calcite.testlib.annotations.WithLex;
 
 import com.google.common.collect.ImmutableMap;
 

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTestCase.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.calcite.sql.validate.SqlMonotonicity;
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.test.catalog.MockCatalogReaderExtended;
+import org.apache.calcite.testlib.annotations.WithLex;
 
 import com.google.common.base.Preconditions;
 

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -2113,7 +2113,7 @@ private static List<Pair<String, String>> querify(String[] queries1) {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/CALCITE-2381">[CALCITE-2391]
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-2391">[CALCITE-2391]
    * Aggregate query with UNNEST or LATERAL fails with
    * ClassCastException</a>. */
   @Test public void testAggUnnestColumn() {

File: core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java
Patch:
@@ -853,7 +853,7 @@ private static boolean isNumeric(Class type) {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/CALCITE-281">[CALCITE-1919]
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-1919">[CALCITE-1919]
    * NPE when target in ReflectiveSchema belongs to the unnamed package</a>. */
   @Test public void testReflectiveSchemaInUnnamedPackage() throws Exception {
     final Driver driver = new Driver();

File: core/src/test/java/org/apache/calcite/test/ScannableTableTest.java
Patch:
@@ -319,7 +319,7 @@ private static Integer getFilter(boolean cooperative, List<RexNode> filters) {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/CALCITE-1031">[CALCITE-3405]
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-3405">[CALCITE-3405]
    * Prune columns for ProjectableFilterable when project is not simple mapping</a>. */
   @Test public void testPushNonSimpleMappingProject() throws Exception {
     final StringBuilder buf = new StringBuilder();
@@ -342,7 +342,7 @@ private static Integer getFilter(boolean cooperative, List<RexNode> filters) {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/CALCITE-1031">[CALCITE-3405]
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-3405">[CALCITE-3405]
    * Prune columns for ProjectableFilterable when project is not simple mapping</a>. */
   @Test public void testPushSimpleMappingProject() throws Exception {
     final StringBuilder buf = new StringBuilder();

File: core/src/test/java/org/apache/calcite/tools/PlannerTest.java
Patch:
@@ -1372,7 +1372,7 @@ public RelDataType deriveType(SqlValidator validator,
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/CALCITE-648">[CALCITE-649]
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-648">[CALCITE-648]
    * Update ProjectMergeRule description for new naming convention</a>. */
   @Test public void testMergeProjectForceMode() throws Exception {
     RuleSet ruleSet =

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java
Patch:
@@ -373,7 +373,7 @@ private static class CassandraLimitRule extends RelOptRule {
 
     private CassandraLimitRule() {
       super(operand(EnumerableLimit.class, operand(CassandraToEnumerableConverter.class, any())),
-        "CassandraLimitRule");
+          "CassandraLimitRule");
     }
 
     public RelNode convert(EnumerableLimit limit) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableFunctionScan.java
Patch:
@@ -46,7 +46,7 @@ public EnumerableTableFunctionScan(RelOptCluster cluster,
       RelDataType rowType, RexNode call,
       Set<RelColumnMapping> columnMappings) {
     super(cluster, traits, inputs, call, elementType, rowType,
-      columnMappings);
+        columnMappings);
   }
 
   @Override public EnumerableTableFunctionScan copy(

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1153,8 +1153,8 @@ private static class JoinOnLeftCalcToJoinUnifyRule extends AbstractUnifyRule {
 
     private JoinOnLeftCalcToJoinUnifyRule() {
       super(
-        operand(MutableJoin.class, operand(MutableCalc.class, query(0)), query(1)),
-        operand(MutableJoin.class, target(0), target(1)), 2);
+          operand(MutableJoin.class, operand(MutableCalc.class, query(0)), query(1)),
+          operand(MutableJoin.class, target(0), target(1)), 2);
     }
 
     @Override protected UnifyResult apply(UnifyRuleCall call) {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
Patch:
@@ -254,7 +254,7 @@ public static List<RelCollation> calc(RelMetadataQuery mq, RelNode input,
         program
             .getProjectList()
             .stream()
-            .map((p) -> program.expandLocalRef(p))
+            .map(program::expandLocalRef)
             .collect(Collectors.toList());
     return project(mq, input, projects);
   }

File: core/src/main/java/org/apache/calcite/rel/rules/FilterMultiJoinMergeRule.java
Patch:
@@ -60,9 +60,9 @@ public FilterMultiJoinMergeRule(RelBuilderFactory relBuilderFactory) {
   public FilterMultiJoinMergeRule(Class<? extends Filter> filterClass,
       RelBuilderFactory relBuilderFactory) {
     super(
-      operand(filterClass,
-        operand(MultiJoin.class, any())),
-      relBuilderFactory, null);
+        operand(filterClass,
+          operand(MultiJoin.class, any())),
+        relBuilderFactory, null);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectMultiJoinMergeRule.java
Patch:
@@ -59,8 +59,8 @@ public ProjectMultiJoinMergeRule(RelBuilderFactory relBuilderFactory) {
   public ProjectMultiJoinMergeRule(Class<? extends Project> projectClass,
       RelBuilderFactory relBuilderFactory) {
     super(
-      operand(projectClass,
-        operand(MultiJoin.class, any())), relBuilderFactory, null);
+        operand(projectClass,
+         operand(MultiJoin.class, any())), relBuilderFactory, null);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/util/NameSet.java
Patch:
@@ -43,7 +43,7 @@ public NameSet() {
 
   /** Creates a NameSet that is an immutable copy of a given collection. */
   public static NameSet immutableCopyOf(Set<String> names) {
-    return new NameSet(NameMap.immutableCopyOf(Maps.asMap(names, (k) -> DUMMY)));
+    return new NameSet(NameMap.immutableCopyOf(Maps.asMap(names, k -> DUMMY)));
   }
 
   @Override public String toString() {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -804,7 +804,7 @@ public DruidProjectFilterTransposeRule(
           operand(Project.class,
               operand(Filter.class,
                   operand(DruidQuery.class, none()))),
-              expr -> false,
+          expr -> false,
           relBuilderFactory);
     }
   }

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRules.java
Patch:
@@ -237,7 +237,7 @@ private static class ElasticsearchFilterRule extends ElasticsearchConverterRule
 
     private ElasticsearchFilterRule() {
       super(LogicalFilter.class, Convention.NONE, ElasticsearchRel.CONVENTION,
-        "ElasticsearchFilterRule");
+          "ElasticsearchFilterRule");
     }
 
     @Override public RelNode convert(RelNode relNode) {
@@ -288,7 +288,7 @@ private static class ElasticsearchProjectRule extends ElasticsearchConverterRule
 
     private ElasticsearchProjectRule() {
       super(LogicalProject.class, Convention.NONE, ElasticsearchRel.CONVENTION,
-        "ElasticsearchProjectRule");
+          "ElasticsearchProjectRule");
     }
 
     @Override public RelNode convert(RelNode relNode) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
Patch:
@@ -213,7 +213,8 @@ private JavaRowFormat format() {
     }
     if (fieldCount == 1 && (Object.class == elementType
           || Primitive.is(elementType)
-          || Number.class.isAssignableFrom(elementType))) {
+          || Number.class.isAssignableFrom(elementType)
+          || String.class == elementType)) {
       return JavaRowFormat.SCALAR;
     }
     return JavaRowFormat.CUSTOM;

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalJoin.java
Patch:
@@ -214,8 +214,8 @@ public List<RelDataTypeField> getSystemFieldList() {
     return systemFieldList;
   }
 
-  @Override public RelNode attachHints(List<RelHint> hintList) {
-    return new LogicalJoin(getCluster(), traitSet, mergeHints(hintList),
+  @Override public RelNode withHints(List<RelHint> hintList) {
+    return new LogicalJoin(getCluster(), traitSet, hintList,
         left, right, condition, variablesSet, joinType, semiJoinDone, systemFieldList);
   }
 }

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalProject.java
Patch:
@@ -141,8 +141,8 @@ public static LogicalProject create(final RelNode input,
     return shuttle.visit(this);
   }
 
-  @Override public RelNode attachHints(List<RelHint> hintList) {
-    return new LogicalProject(getCluster(), traitSet, mergeHints(hintList),
+  @Override public RelNode withHints(List<RelHint> hintList) {
+    return new LogicalProject(getCluster(), traitSet, hintList,
         input, getProjects(), rowType);
   }
 }

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalTableScan.java
Patch:
@@ -129,8 +129,8 @@ public static LogicalTableScan create(RelOptCluster cluster,
     return create(cluster, relOptTable, new ArrayList<>());
   }
 
-  @Override public RelNode attachHints(List<RelHint> hintList) {
-    return new LogicalTableScan(getCluster(), traitSet, mergeHints(hintList), table);
+  @Override public RelNode withHints(List<RelHint> hintList) {
+    return new LogicalTableScan(getCluster(), traitSet, hintList, table);
   }
 }
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/ReflectiveCallNotNullImplementor.java
Patch:
@@ -47,6 +47,8 @@ public Expression implement(RexToLixTranslator translator,
       RexCall call, List<Expression> translatedOperands) {
     translatedOperands =
         EnumUtils.fromInternal(method.getParameterTypes(), translatedOperands);
+    translatedOperands =
+        EnumUtils.convertAssignableTypes(method.getParameterTypes(), translatedOperands);
     final Expression callExpr;
     if ((method.getModifiers() & Modifier.STATIC) != 0) {
       callExpr = Expressions.call(method, translatedOperands);

File: core/src/main/java/org/apache/calcite/sql/type/JavaToSqlTypeConversionRules.java
Patch:
@@ -77,6 +77,7 @@ public class JavaToSqlTypeConversionRules {
           .put(ColumnList.class, SqlTypeName.COLUMN_LIST)
           .put(ArrayImpl.class, SqlTypeName.ARRAY)
           .put(List.class, SqlTypeName.ARRAY)
+          .put(Map.class, SqlTypeName.MAP)
           .put(Void.class, SqlTypeName.NULL)
           .build();
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
Patch:
@@ -192,6 +192,9 @@ private SqlTypeAssignmentRule(
     // ARRAY is assignable from ...
     rules.add(SqlTypeName.ARRAY, EnumSet.of(SqlTypeName.ARRAY));
 
+    // MAP is assignable from ...
+    rules.add(SqlTypeName.MAP, EnumSet.of(SqlTypeName.MAP));
+
     // ANY is assignable from ...
     rule.clear();
     rule.add(SqlTypeName.TINYINT);

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
Patch:
@@ -220,6 +220,8 @@ private void assertBasic(SqlTypeName typeName) {
         : "use createMultisetType() instead";
     assert typeName != SqlTypeName.ARRAY
         : "use createArrayType() instead";
+    assert typeName != SqlTypeName.MAP
+        : "use createMapType() instead";
     assert typeName != SqlTypeName.ROW
         : "use createStructType() instead";
     assert !SqlTypeName.INTERVAL_TYPES.contains(typeName)

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
Patch:
@@ -108,6 +108,9 @@ public Enumerable<Object> query(final GemFireCache clientCache,
         type = typeFactory.createMultisetType(
             typeFactory.createSqlType(SqlTypeName.ANY),
             -1);
+      } else if (typeName == SqlTypeName.MAP) {
+        RelDataType anyType = typeFactory.createSqlType(SqlTypeName.ANY);
+        type = typeFactory.createMapType(anyType, anyType);
       } else {
         type = typeFactory.createSqlType(typeName);
       }

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
Patch:
@@ -268,7 +268,7 @@ protected boolean needToCast(SqlValidatorScope scope, SqlNode node, RelDataType
     if (SqlTypeUtil.equalSansNullability(factory, fromType, toType)) {
       return false;
     }
-    // Should keep sync with rules in SqlTypeAssignmentRules.
+    // Should keep sync with rules in SqlTypeCoercionRule.
     assert SqlTypeUtil.canCastFrom(toType, fromType, true);
     return true;
   }

File: core/src/test/java/org/apache/calcite/sql/type/SqlTypeFixture.java
Patch:
@@ -48,6 +48,8 @@ class SqlTypeFixture {
       typeFactory.createSqlType(SqlTypeName.ANY), false);
   final RelDataType sqlFloat = typeFactory.createTypeWithNullability(
       typeFactory.createSqlType(SqlTypeName.FLOAT), false);
+  final RelDataType sqlTimestamp = typeFactory.createTypeWithNullability(
+      typeFactory.createSqlType(SqlTypeName.TIMESTAMP, 3), false);
   final RelDataType arrayFloat = typeFactory.createTypeWithNullability(
       typeFactory.createArrayType(sqlFloat, -1), false);
   final RelDataType arrayBigInt = typeFactory.createTypeWithNullability(

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -40,7 +40,7 @@
 import org.apache.calcite.sql.SqlSpecialOperator;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.type.ReturnTypes;
-import org.apache.calcite.sql.type.SqlTypeAssignmentRules;
+import org.apache.calcite.sql.type.SqlTypeAssignmentRule;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.DateString;
 import org.apache.calcite.util.ImmutableBitSet;
@@ -2148,8 +2148,8 @@ trueLiteral, literal(1),
 
     for (RelDataType fromType : types) {
       for (RelDataType toType : types) {
-        if (SqlTypeAssignmentRules.instance(false)
-            .canCastFrom(toType.getSqlTypeName(), fromType.getSqlTypeName())) {
+        if (SqlTypeAssignmentRule.instance()
+            .canApplyFrom(toType.getSqlTypeName(), fromType.getSqlTypeName())) {
           for (RexLiteral literal : map.get(fromType.getSqlTypeName())) {
             final RexNode cast = rexBuilder.makeCast(toType, literal);
             if (cast instanceof RexLiteral) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -1831,6 +1831,9 @@ public static <TSource, TInner, TResult> Enumerable<TResult> nestedLoopJoin(
               rightUnmatched.remove(right);
             }
             result.add(resultSelector.apply(left, right));
+            if (joinType == JoinType.SEMI) {
+              break;
+            }
           }
         }
       }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableCalc.java
Patch:
@@ -136,7 +136,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
                 Enumerator.class, inputJavaType),
             "inputEnumerator");
     Expression input =
-        RexToLixTranslator.convert(
+        EnumUtils.convert(
             Expressions.call(
                 inputEnumerator,
                 BuiltInMethod.ENUMERATOR_CURRENT.method),

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMatch.java
Patch:
@@ -176,7 +176,7 @@ private Expression implementEmitter(EnumerableRelImplementor implementor,
     // Add loop variable initialization
     builder2.add(
         Expressions.declare(0, row_,
-            RexToLixTranslator.convert(
+            EnumUtils.convert(
                 Expressions.call(rows_, BuiltInMethod.LIST_GET.method, i_),
                 inputPhysType.getJavaRowType())));
 
@@ -476,7 +476,7 @@ void setIndex(Expression index) {
       return Expressions.condition(
           Expressions.greaterThanOrEqual(this.index, Expressions.constant(0)),
           generator.apply(
-              RexToLixTranslator.convert(
+              EnumUtils.convert(
                   Expressions.call(this.passedRows,
                       BuiltInMethod.LIST_GET.method, this.index),
                   physType.getJavaRowType()))

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
Patch:
@@ -145,10 +145,10 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
                   right.getRowType().getFieldList().get(pair.right).getType()));
       final Type keyClass = typeFactory.getJavaClass(keyType);
       leftExpressions.add(
-          RexToLixTranslator.convert(
+          EnumUtils.convert(
               leftResult.physType.fieldReference(left_, pair.left), keyClass));
       rightExpressions.add(
-          RexToLixTranslator.convert(
+          EnumUtils.convert(
               rightResult.physType.fieldReference(right_, pair.right), keyClass));
     }
     final PhysType leftKeyPhysType =

File: core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java
Patch:
@@ -184,7 +184,7 @@ public Expression field(Expression expression, int field, Type fromType,
       if (fromType == null) {
         fromType = e.getType();
       }
-      return RexToLixTranslator.convert(e, fromType, fieldType);
+      return EnumUtils.convert(e, fromType, fieldType);
     }
   },
 
@@ -213,7 +213,7 @@ public Expression field(Expression expression, int field, Type fromType,
       if (fromType == null) {
         fromType = e.getType();
       }
-      return RexToLixTranslator.convert(e, fromType, fieldType);
+      return EnumUtils.convert(e, fromType, fieldType);
     }
   },
 
@@ -244,7 +244,7 @@ public Expression field(Expression expression, int field, Type fromType,
       if (fromType == null) {
         fromType = e.getType();
       }
-      return RexToLixTranslator.convert(e, fromType, fieldType);
+      return EnumUtils.convert(e, fromType, fieldType);
     }
   };
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
Patch:
@@ -54,7 +54,7 @@ protected final void accAdvance(AggAddContext add, Expression acc,
       Expression next) {
     add.currentBlock().add(
         Expressions.statement(
-            Expressions.assign(acc, RexToLixTranslator.convert(next, acc.type))));
+            Expressions.assign(acc, EnumUtils.convert(next, acc.type))));
   }
 
   public final List<Type> getStateType(AggContext info) {
@@ -166,7 +166,7 @@ protected abstract void implementNotNullAdd(AggContext info,
   public final Expression implementResult(AggContext info,
       final AggResultContext result) {
     if (!needTrackEmptySet) {
-      return RexToLixTranslator.convert(
+      return EnumUtils.convert(
           implementNotNullResult(info, result), info.returnType());
     }
     String tmpName = result.accumulator().isEmpty()
@@ -177,7 +177,7 @@ public final Expression implementResult(AggContext info,
 
     List<Expression> acc = result.accumulator();
     final BlockBuilder thenBlock = result.nestBlock();
-    Expression nonNull = RexToLixTranslator.convert(
+    Expression nonNull = EnumUtils.convert(
         implementNotNullResult(info, result), info.returnType());
     result.exitBlock();
     thenBlock.add(Expressions.statement(Expressions.assign(res, nonNull)));

File: core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
Patch:
@@ -17,7 +17,7 @@
 package org.apache.calcite.adapter.java;
 
 import org.apache.calcite.DataContext;
-import org.apache.calcite.adapter.enumerable.RexToLixTranslator;
+import org.apache.calcite.adapter.enumerable.EnumUtils;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.Enumerator;
 import org.apache.calcite.linq4j.Linq4j;
@@ -167,7 +167,7 @@ private Multimap<String, Function> createFunctionMap() {
   /** Returns an expression for the object wrapped by this schema (not the
    * schema itself). */
   Expression getTargetExpression(SchemaPlus parentSchema, String name) {
-    return RexToLixTranslator.convert(
+    return EnumUtils.convert(
         Expressions.call(
             Schemas.unwrap(
                 getExpression(parentSchema, name),

File: core/src/main/java/org/apache/calcite/rex/RexExecutorImpl.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.rex;
 
 import org.apache.calcite.DataContext;
+import org.apache.calcite.adapter.enumerable.EnumUtils;
 import org.apache.calcite.adapter.enumerable.RexToLixTranslator;
 import org.apache.calcite.adapter.enumerable.RexToLixTranslator.InputGetter;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
@@ -151,15 +152,15 @@ public Expression field(BlockBuilder list, int index, Type storageType) {
           BuiltInMethod.DATA_CONTEXT_GET.method,
           Expressions.constant("inputRecord"));
       Expression recFromCtxCasted =
-          RexToLixTranslator.convert(recFromCtx, Object[].class);
+          EnumUtils.convert(recFromCtx, Object[].class);
       IndexExpression recordAccess = Expressions.arrayIndex(recFromCtxCasted,
           Expressions.constant(index));
       if (storageType == null) {
         final RelDataType fieldType =
             rowType.getFieldList().get(index).getType();
         storageType = ((JavaTypeFactory) typeFactory).getJavaClass(fieldType);
       }
-      return RexToLixTranslator.convert(recordAccess, storageType);
+      return EnumUtils.convert(recordAccess, storageType);
     }
   }
 }

File: core/src/main/java/org/apache/calcite/schema/Schemas.java
Patch:
@@ -17,7 +17,7 @@
 package org.apache.calcite.schema;
 
 import org.apache.calcite.DataContext;
-import org.apache.calcite.adapter.enumerable.RexToLixTranslator;
+import org.apache.calcite.adapter.enumerable.EnumUtils;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.config.CalciteConnectionConfig;
 import org.apache.calcite.config.CalciteConnectionConfigImpl;
@@ -176,7 +176,7 @@ public static Expression tableExpression(SchemaPlus schema, Type elementType,
           Expressions.constant(elementType),
           Expressions.constant(tableName));
     }
-    return RexToLixTranslator.convert(expression, clazz);
+    return EnumUtils.convert(expression, clazz);
   }
 
   public static DataContext createDataContext(

File: core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.sql.validate;
 
-import org.apache.calcite.adapter.enumerable.RexToLixTranslator;
+import org.apache.calcite.adapter.enumerable.EnumUtils;
 import org.apache.calcite.linq4j.tree.BlockBuilder;
 import org.apache.calcite.linq4j.tree.Expression;
 import org.apache.calcite.linq4j.tree.Expressions;
@@ -186,7 +186,7 @@ private static Object coerce(Object o, RelDataType type) {
     // expressions.
     BlockBuilder bb = new BlockBuilder();
     final Expression expr =
-        RexToLixTranslator.convert(Expressions.constant(o), clazz);
+        EnumUtils.convert(Expressions.constant(o), clazz);
     bb.add(Expressions.return_(null, expr));
     final FunctionExpression convert =
         Expressions.lambda(bb.toBlock(), Collections.emptyList());

File: core/src/test/java/org/apache/calcite/test/FoodmartTest.java
Patch:
@@ -151,7 +151,7 @@ public FoodmartTest(int id) throws IOException {
     assert query.id == id : id + ":" + query.id;
   }
 
-  @Test(timeout = 60000)
+  @Test(timeout = 120000)
   public void test() {
     try {
       CalciteAssert.that()

File: plus/src/test/java/org/apache/calcite/adapter/tpcds/TpcdsTest.java
Patch:
@@ -219,7 +219,7 @@ protected void foo(CalciteAssert.AssertThat with, String tableName,
         .withHook(Hook.PROGRAM, handler(true, 2))
         .explainMatches("including all attributes ",
             CalciteAssert.checkMaskedResultContains(""
-                + "EnumerableCalc(expr#0..9=[{inputs}], expr#10=[/($t4, $t3)], expr#11=[CAST($t10):INTEGER NOT NULL], expr#12=[*($t4, $t4)], expr#13=[/($t12, $t3)], expr#14=[-($t5, $t13)], expr#15=[1], expr#16=[=($t3, $t15)], expr#17=[null], expr#18=[-($t3, $t15)], expr#19=[CASE($t16, $t17, $t18)], expr#20=[/($t14, $t19)], expr#21=[0.5], expr#22=[POWER($t20, $t21)], expr#23=[CAST($t22):INTEGER NOT NULL], expr#24=[/($t23, $t11)], expr#25=[/($t6, $t3)], expr#26=[CAST($t25):INTEGER NOT NULL], expr#27=[*($t6, $t6)], expr#28=[/($t27, $t3)], expr#29=[-($t7, $t28)], expr#30=[/($t29, $t19)], expr#31=[POWER($t30, $t21)], expr#32=[CAST($t31):INTEGER NOT NULL], expr#33=[/($t32, $t26)], expr#34=[/($t8, $t3)], expr#35=[CAST($t34):INTEGER NOT NULL], expr#36=[*($t8, $t8)], expr#37=[/($t36, $t3)], expr#38=[-($t9, $t37)], expr#39=[/($t38, $t19)], expr#40=[POWER($t39, $t21)], expr#41=[CAST($t40):INTEGER NOT NULL], expr#42=[/($t41, $t35)], proj#0..3=[{exprs}], STORE_SALES_QUANTITYAVE=[$t11], STORE_SALES_QUANTITYSTDEV=[$t23], STORE_SALES_QUANTITYCOV=[$t24], AS_STORE_RETURNS_QUANTITYCOUNT=[$t3], AS_STORE_RETURNS_QUANTITYAVE=[$t26], AS_STORE_RETURNS_QUANTITYSTDEV=[$t32], STORE_RETURNS_QUANTITYCOV=[$t33], CATALOG_SALES_QUANTITYCOUNT=[$t3], CATALOG_SALES_QUANTITYAVE=[$t35], CATALOG_SALES_QUANTITYSTDEV=[$t42], CATALOG_SALES_QUANTITYCOV=[$t42]): rowcount = 100.0, cumulative cost = {1.2435775409784036E28 rows, 2.555295485909236E30 cpu, 0.0 io}\n"
+                + "EnumerableCalc(expr#0..9=[{inputs}], expr#10=[/($t4, $t3)], expr#11=[CAST($t10):INTEGER NOT NULL], expr#12=[*($t4, $t4)], expr#13=[/($t12, $t3)], expr#14=[-($t5, $t13)], expr#15=[1], expr#16=[=($t3, $t15)], expr#17=[null:BIGINT], expr#18=[-($t3, $t15)], expr#19=[CASE($t16, $t17, $t18)], expr#20=[/($t14, $t19)], expr#21=[0.5:DECIMAL(2, 1)], expr#22=[POWER($t20, $t21)], expr#23=[CAST($t22):INTEGER NOT NULL], expr#24=[/($t23, $t11)], expr#25=[/($t6, $t3)], expr#26=[CAST($t25):INTEGER NOT NULL], expr#27=[*($t6, $t6)], expr#28=[/($t27, $t3)], expr#29=[-($t7, $t28)], expr#30=[/($t29, $t19)], expr#31=[POWER($t30, $t21)], expr#32=[CAST($t31):INTEGER NOT NULL], expr#33=[/($t32, $t26)], expr#34=[/($t8, $t3)], expr#35=[CAST($t34):INTEGER NOT NULL], expr#36=[*($t8, $t8)], expr#37=[/($t36, $t3)], expr#38=[-($t9, $t37)], expr#39=[/($t38, $t19)], expr#40=[POWER($t39, $t21)], expr#41=[CAST($t40):INTEGER NOT NULL], expr#42=[/($t41, $t35)], proj#0..3=[{exprs}], STORE_SALES_QUANTITYAVE=[$t11], STORE_SALES_QUANTITYSTDEV=[$t23], STORE_SALES_QUANTITYCOV=[$t24], AS_STORE_RETURNS_QUANTITYCOUNT=[$t3], AS_STORE_RETURNS_QUANTITYAVE=[$t26], AS_STORE_RETURNS_QUANTITYSTDEV=[$t32], STORE_RETURNS_QUANTITYCOV=[$t33], CATALOG_SALES_QUANTITYCOUNT=[$t3], CATALOG_SALES_QUANTITYAVE=[$t35], CATALOG_SALES_QUANTITYSTDEV=[$t42], CATALOG_SALES_QUANTITYCOV=[$t42]): rowcount = 100.0, cumulative cost = {1.2435775409784036E28 rows, 2.555295485909236E30 cpu, 0.0 io}\n"
                 + "  EnumerableLimit(fetch=[100]): rowcount = 100.0, cumulative cost = {1.2435775409784036E28 rows, 2.555295485909236E30 cpu, 0.0 io}\n"
                 + "    EnumerableSort(sort0=[$0], sort1=[$1], sort2=[$2], dir0=[ASC], dir1=[ASC], dir2=[ASC]): rowcount = 5.434029018852197E26, cumulative cost = {1.2435775409784036E28 rows, 2.555295485909236E30 cpu, 0.0 io}\n"
                 + "      EnumerableAggregate(group=[{0, 1, 2}], STORE_SALES_QUANTITYCOUNT=[COUNT()], agg#1=[$SUM0($3)], agg#2=[$SUM0($6)], agg#3=[$SUM0($4)], agg#4=[$SUM0($7)], agg#5=[$SUM0($5)], agg#6=[$SUM0($8)]): rowcount = 5.434029018852197E26, cumulative cost = {1.1892372507898816E28 rows, 1.2172225002228922E30 cpu, 0.0 io}\n"

File: core/src/main/java/org/apache/calcite/rel/hint/NodeTypeHintStrategy.java
Patch:
@@ -56,7 +56,7 @@ enum NodeType {
     /** Relational expression clazz that the hint can apply to. */
     private Class<?> relClazz;
 
-    NodeType(Class relClazz) {
+    NodeType(Class<?> relClazz) {
       this.relClazz = relClazz;
     }
   }

File: core/src/main/java/org/apache/calcite/sql/SqlHint.java
Patch:
@@ -82,7 +82,7 @@ public List<SqlNode> getOperandList() {
   }
 
   /**
-   * Returns the sql hint name
+   * Returns the sql hint name.
    */
   public String getName() {
     return name.getSimple();
@@ -95,7 +95,7 @@ public HintOptionFormat getOptionFormat() {
 
   /**
    * Returns a string list if the hint option is a list of
-   * simple SQL identifier, else an empty list
+   * simple SQL identifier, else an empty list.
    */
   public List<String> getOptionList() {
     if (optionFormat == HintOptionFormat.ID_LIST) {
@@ -111,7 +111,7 @@ public List<String> getOptionList() {
   /**
    * Returns a key value string map if the hint option is a list of
    * pair, each pair contains a simple SQL identifier and a string literal;
-   * else returns an empty map
+   * else returns an empty map.
    */
   public Map<String, String> getOptionKVPairs() {
     if (optionFormat == HintOptionFormat.KV_LIST) {

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -503,7 +503,9 @@ private RelDataType decimalOf2(RelDataType type) {
     assert typeName != null;
     switch (typeName) {
     case DECIMAL:
-      return type;
+      // Fix the precision when the type is JavaType.
+      return RelDataTypeFactoryImpl.isJavaType(type)
+          ? SqlTypeUtil.getMaxPrecisionScaleDecimal(this) : type;
     case TINYINT:
       return createSqlType(SqlTypeName.DECIMAL, 3, 0);
     case SMALLINT:

File: core/src/main/java/org/apache/calcite/config/CalciteSystemProperty.java
Patch:
@@ -195,7 +195,7 @@ public final class CalciteSystemProperty<T> {
    * Whether to run Druid tests.
    */
   public static final CalciteSystemProperty<Boolean> TEST_DRUID =
-      booleanProperty("calcite.test.druid", true);
+      booleanProperty("calcite.test.druid", false);
 
   /**
    * Whether to run Cassandra tests.

File: druid/src/test/java/org/apache/calcite/test/DruidChecker.java
Patch:
@@ -23,7 +23,7 @@
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 /**
  * A consumer that checks that a particular Druid query is generated to implement a query.

File: druid/src/test/java/org/apache/calcite/test/DruidDateRangeRulesTest.java
Patch:
@@ -29,14 +29,14 @@
 
 import org.hamcrest.Matcher;
 import org.joda.time.Interval;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import java.util.Calendar;
 import java.util.List;
 
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
 import static org.hamcrest.core.IsNull.notNullValue;
-import static org.junit.Assert.assertThat;
 
 /** Unit tests for {@link DateRangeRules} algorithms. */
 public class DruidDateRangeRulesTest {

File: core/src/test/java/org/apache/calcite/test/fuzzer/RexProgramFuzzyTest.java
Patch:
@@ -346,6 +346,7 @@ private static void trimStackTrace(Throwable t, int maxStackLines) {
     t.setStackTrace(stackTrace);
   }
 
+  @Ignore("Ignore for now: CALCITE-3457")
   @Test public void defaultFuzzTest() {
     try {
       runRexFuzzer(DEFAULT_FUZZ_TEST_SEED, DEFAULT_FUZZ_TEST_DURATION, 1,
@@ -361,6 +362,7 @@ private static void trimStackTrace(Throwable t, int maxStackLines) {
     }
   }
 
+  @Ignore("Ignore for now: CALCITE-3457")
   @Test public void testFuzzy() {
     runRexFuzzer(SEED, TEST_DURATION, MAX_FAILURES, TEST_ITERATIONS, TOPN_SLOWEST);
   }

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java
Patch:
@@ -147,7 +147,7 @@ SqlString generateSql() {
             SqlParserPos.ZERO);
     SqlSelect node =
         new SqlSelect(SqlParserPos.ZERO, SqlNodeList.EMPTY, selectList,
-            tableName(), null, null, null, null, null, null, null);
+            tableName(), null, null, null, null, null, null, null, null);
     final SqlPrettyWriter writer = new SqlPrettyWriter(jdbcSchema.dialect);
     node.unparse(writer, 0, 0);
     return writer.toSqlString();

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -99,7 +99,7 @@ void populate(Materialization materialization) {
 
     RelOptTable table =
         this.catalogReader.getTable(materialization.materializedTable.path());
-    materialization.tableRel = sqlToRelConverter2.toRel(table);
+    materialization.tableRel = sqlToRelConverter2.toRel(table, null);
   }
 
   /** Converts a relational expression to use a

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -985,7 +985,7 @@ private PreparedResult prepare_(Supplier<RelNode> fn,
               ? ((Sort) rel).collation
               : RelCollations.EMPTY;
       RelRoot root = new RelRoot(rel, resultType, SqlKind.SELECT, fields,
-          collation);
+          collation, new ArrayList<>());
 
       if (timingTracer != null) {
         timingTracer.traceTime("end sql2rel");

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -433,7 +433,7 @@ SqlSelect wrapSelect(SqlNode node) {
       node = as(node, "t");
     }
     return new SqlSelect(POS, SqlNodeList.EMPTY, null, node, null, null, null,
-        SqlNodeList.EMPTY, null, null, null);
+        SqlNodeList.EMPTY, null, null, null, null);
   }
 
   /** Returns whether we need to add an alias if this node is to be the FROM

File: core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
Patch:
@@ -56,6 +56,7 @@ public SqlNode rewriteCall(SqlValidator validator, SqlCall call) {
         null,
         null,
         null,
+        null,
         null);
   }
 }

File: core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
Patch:
@@ -143,7 +143,8 @@ public boolean supportsAliasedValues() {
     final SqlNode operand = ((SqlBasicCall) aggCall).operand(0);
     final SqlLiteral nullLiteral = SqlLiteral.createNull(SqlParserPos.ZERO);
     final SqlNode unionOperand = new SqlSelect(SqlParserPos.ZERO, SqlNodeList.EMPTY,
-        SqlNodeList.of(nullLiteral), null, null, null, null, SqlNodeList.EMPTY, null, null, null);
+        SqlNodeList.of(nullLiteral), null, null, null, null,
+        SqlNodeList.EMPTY, null, null, null, SqlNodeList.EMPTY);
     // For MySQL, generate
     //   CASE COUNT(*)
     //   WHEN 0 THEN NULL

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -1150,7 +1150,7 @@ public static Pair<SqlNode, RelDataType> validateExprWithRowType(
     final SqlSelect select0 = new SqlSelect(SqlParserPos.ZERO, null,
         new SqlNodeList(Collections.singletonList(expr), SqlParserPos.ZERO),
         new SqlIdentifier(tableName, SqlParserPos.ZERO),
-        null, null, null, null, null, null, null);
+        null, null, null, null, null, null, null, null);
     Prepare.CatalogReader catalogReader = createSingleTableCatalogReader(
         caseSensitive,
         tableName,

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -140,6 +140,7 @@
     SqlValidatorUtilTest.class,
     TypeFinderTest.class,
     RexShuttleTest.class,
+    SqlHintsConverterTest.class,
 
     // medium tests (above 0.1s)
     SqlParserTest.class,

File: core/src/test/java/org/apache/calcite/test/MockRelOptPlanner.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.function.BiFunction;
 
 /**
  * MockRelOptPlanner is a mock implementation of the {@link RelOptPlanner}
@@ -233,7 +234,8 @@ private class MockRuleCall extends RelOptRuleCall {
     }
 
     // implement RelOptRuleCall
-    public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv) {
+    public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv,
+        BiFunction<RelNode, RelNode, RelNode> handler) {
       transformationResult = rel;
     }
   }

File: core/src/test/java/org/apache/calcite/test/catalog/MockCatalogReader.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.calcite.linq4j.QueryProvider;
 import org.apache.calcite.linq4j.Queryable;
 import org.apache.calcite.linq4j.tree.Expression;
+import org.apache.calcite.linq4j.tree.Expressions;
 import org.apache.calcite.plan.RelOptSchema;
 import org.apache.calcite.plan.RelOptTable;
 import org.apache.calcite.prepare.CalciteCatalogReader;
@@ -551,7 +552,8 @@ public SqlAccessType getAllowedAccess() {
     }
 
     public Expression getExpression(Class clazz) {
-      throw new UnsupportedOperationException();
+      // Return a true constant just to pass the tests in EnumerableTableScanRule.
+      return Expressions.constant(true);
     }
 
     public void addColumn(String name, RelDataType type) {

File: server/src/main/java/org/apache/calcite/sql/ddl/SqlDdlNodes.java
Patch:
@@ -224,7 +224,7 @@ static SqlNode renameColumns(SqlNodeList columnList, SqlNode query) {
                 .addAll(columnList)
                 .build());
     return new SqlSelect(p, null, selectList, from, null, null, null, null,
-        null, null, null);
+        null, null, null, null);
   }
 
   /** Populates the table called {@code name} by executing {@code query}. */

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -612,7 +612,7 @@ private boolean rowTypesAreEquivalent(
       return litmus.fail("Mismatch for column count: [{}]", Pair.of(rel0, rel1));
     }
     for (Pair<RelDataTypeField, RelDataTypeField> pair
-        : Pair.zip(rel0.rowType.getFieldList(), rel0.rowType.getFieldList())) {
+        : Pair.zip(rel0.rowType.getFieldList(), rel1.rowType.getFieldList())) {
       if (!pair.left.getType().equals(pair.right.getType())) {
         return litmus.fail("Mismatch for column type: [{}]", Pair.of(rel0, rel1));
       }

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -1156,8 +1156,8 @@ public static BigDecimal mod(BigDecimal b0, int b1) {
   }
 
   // temporary
-  public static int mod(int b0, BigDecimal b1) {
-    return mod(b0, b1.intValue());
+  public static BigDecimal mod(int b0, BigDecimal b1) {
+    return mod(BigDecimal.valueOf(b0), b1);
   }
 
   public static BigDecimal mod(BigDecimal b0, BigDecimal b1) {

File: core/src/test/java/org/apache/calcite/sql/type/RelDataTypeSystemTest.java
Patch:
@@ -137,7 +137,7 @@ public void testDecimalModReturnTypeInference() {
 
     RelDataType dataType = SqlStdOperatorTable.MOD.inferReturnType(TYPE_FACTORY, Lists
             .newArrayList(operand1, operand2));
-    Assert.assertEquals(19, dataType.getPrecision());
+    Assert.assertEquals(11, dataType.getPrecision());
     Assert.assertEquals(2, dataType.getScale());
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -458,7 +458,8 @@ public static boolean validConstant(Object o, Litmus litmus) {
     if (o == null
         || o instanceof BigDecimal
         || o instanceof NlsString
-        || o instanceof ByteString) {
+        || o instanceof ByteString
+        || o instanceof Boolean) {
       return litmus.succeed();
     } else if (o instanceof List) {
       List list = (List) o;

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
Patch:
@@ -386,6 +386,8 @@ void propagateCostImprovements0(VolcanoPlanner planner, RelMetadataQuery mq,
           // removes parent cached metadata since its input was changed
           mq.clearCache(parent);
           final RelSubset parentSubset = planner.getSubset(parent);
+
+          // parent subset will clear its cache in propagateCostImprovements0 method itself
           for (RelSubset subset : parentSubset.set.subsets) {
             if (parent.getTraitSet().satisfies(subset.traitSet)) {
               propagationQueue.offer(Pair.of(subset, parent));

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -63,7 +63,7 @@ class CalciteMaterializer extends CalcitePrepareImpl.CalcitePreparingStmt {
   CalciteMaterializer(CalcitePrepareImpl prepare,
       CalcitePrepare.Context context,
       CatalogReader catalogReader, CalciteSchema schema,
-      SqlRexConvertletTable convertletTable, RelOptCluster cluster) {
+      RelOptCluster cluster, SqlRexConvertletTable convertletTable) {
     super(prepare, context, catalogReader, catalogReader.getTypeFactory(),
         schema, EnumerableRel.Prefer.ANY, BindableConvention.INSTANCE,
         convertletTable, cluster);

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -868,7 +868,7 @@ protected void populateMaterializations(Context context,
               context.config());
       final CalciteMaterializer materializer =
           new CalciteMaterializer(this, context, catalogReader, schema,
-              createConvertletTable(), cluster);
+              cluster, createConvertletTable());
       materializer.populate(materialization);
     } catch (Exception e) {
       throw new RuntimeException("While populating materialization "

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
Patch:
@@ -187,6 +187,8 @@ public Multimap<Class<? extends RelNode>, RelNode> getNodeTypes(RelNode rel) {
         return nodeTypesHandler.getNodeTypes(rel, this);
       } catch (JaninoRelMetadataProvider.NoHandler e) {
         nodeTypesHandler = revise(e.relClass, BuiltInMetadata.NodeTypes.DEF);
+      } catch (CyclicMetadataException e) {
+        return null;
       }
     }
   }

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -46,6 +46,7 @@
 import org.apache.calcite.rel.convert.ConverterRule;
 import org.apache.calcite.rel.externalize.RelWriterImpl;
 import org.apache.calcite.rel.metadata.JaninoRelMetadataProvider;
+import org.apache.calcite.rel.metadata.RelMdUtil;
 import org.apache.calcite.rel.metadata.RelMetadataProvider;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
@@ -1566,6 +1567,7 @@ private boolean fixUpInputs(RelNode rel) {
         }
       }
     }
+    RelMdUtil.clearCache(rel);
     return changeCount > 0;
   }
 

File: core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
Patch:
@@ -178,7 +178,7 @@ private static RelMetadataProvider reflectiveSource(
                   }
                   key1 = FlatLists.copyOf(args2);
                 }
-                if (mq.map.put(key1, NullSentinel.INSTANCE) != null) {
+                if (mq.map.put(rel, key1, NullSentinel.INSTANCE) != null) {
                   throw new CyclicMetadataException();
                 }
                 try {
@@ -188,7 +188,7 @@ private static RelMetadataProvider reflectiveSource(
                   Util.throwIfUnchecked(e.getCause());
                   throw new RuntimeException(e.getCause());
                 } finally {
-                  mq.map.remove(key1);
+                  mq.map.remove(rel, key1);
                 }
               });
       methodsMap.put(key, function);

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleCall.java
Patch:
@@ -194,10 +194,11 @@ public RelOptPlanner getPlanner() {
   }
 
   /**
-   * Returns the current RelMetadataQuery, to be used for instance by
+   * Returns the current RelMetadataQuery or its sub-class,
+   * to be used for instance by
    * {@link RelOptRule#onMatch(RelOptRuleCall)}.
    */
-  public RelMetadataQuery getMetadataQuery() {
+  public <M extends RelMetadataQuery> M getMetadataQuery() {
     return rel(0).getCluster().getMetadataQuery();
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/InitializerContext.java
Patch:
@@ -40,7 +40,7 @@ public interface InitializerContext {
    *   );
    * </pre>
    *
-   * You can use the string format expression "my_udf(a)" and "a + 1"
+   * <p>You can use the string format expression "my_udf(a)" and "a + 1"
    * as the initializer expression of column b and c.
    *
    * <p>Calcite doesn't really need this now because the DDL nodes

File: core/src/main/java/org/apache/calcite/util/XmlOutput.java
Patch:
@@ -372,11 +372,11 @@ public void cdata(String data, boolean quote) {
       out.print(data);
       out.println("]]>");
     } else if (!specials) {
-      out.print(data);
+      out.println(data);
     } else {
       stringEncodeXML(data, out);
+      out.println();
     }
-    out.println();
     out.flush();
     tagsWritten++;
   }

File: core/src/test/java/org/apache/calcite/test/catalog/Fixture.java
Patch:
@@ -163,4 +163,5 @@ abstract class AbstractFixture {
     this.typeFactory = typeFactory;
   }
 }
+
 // End Fixture.java

File: core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
Patch:
@@ -22,7 +22,6 @@
 import org.apache.calcite.linq4j.tree.Expressions;
 import org.apache.calcite.linq4j.tree.ParameterExpression;
 import org.apache.calcite.linq4j.tree.Primitive;
-import org.apache.calcite.linq4j.tree.Types;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 
@@ -55,7 +54,7 @@ protected final void accAdvance(AggAddContext add, Expression acc,
       Expression next) {
     add.currentBlock().add(
         Expressions.statement(
-            Expressions.assign(acc, Types.castIfNecessary(acc.type, next))));
+            Expressions.assign(acc, RexToLixTranslator.convert(next, acc.type))));
   }
 
   public final List<Type> getStateType(AggContext info) {

File: core/src/main/java/org/apache/calcite/schema/Schemas.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.schema;
 
 import org.apache.calcite.DataContext;
+import org.apache.calcite.adapter.enumerable.RexToLixTranslator;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.config.CalciteConnectionConfig;
 import org.apache.calcite.config.CalciteConnectionConfigImpl;
@@ -30,7 +31,6 @@
 import org.apache.calcite.linq4j.tree.Expression;
 import org.apache.calcite.linq4j.tree.Expressions;
 import org.apache.calcite.linq4j.tree.MethodCallExpression;
-import org.apache.calcite.linq4j.tree.Types;
 import org.apache.calcite.materialize.Lattice;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
@@ -176,7 +176,7 @@ public static Expression tableExpression(SchemaPlus schema, Type elementType,
           Expressions.constant(elementType),
           Expressions.constant(tableName));
     }
-    return Types.castIfNecessary(clazz, expression);
+    return RexToLixTranslator.convert(expression, clazz);
   }
 
   public static DataContext createDataContext(

File: core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java
Patch:
@@ -612,8 +612,8 @@ private void check(ResultSetMetaData metaData, String columnName,
             "final Long inp13_ = ((org.apache.calcite.test.ReflectiveSchemaTest.EveryType) inputEnumerator.current()).wrapperLong;")
         .planContains(
             "return inp13_ == null ? (Long) null "
-                + ": Long.valueOf(inp13_.longValue() / inp13_.longValue() "
-                + "+ inp13_.longValue() / inp13_.longValue());")
+                + ": Long.valueOf(Long.valueOf(inp13_.longValue() / inp13_.longValue()).longValue() "
+                + "+ Long.valueOf(inp13_.longValue() / inp13_.longValue()).longValue());")
         .returns("C=null\n");
   }
 

File: piglet/src/test/java/org/apache/calcite/test/PigRelOpTest.java
Patch:
@@ -49,7 +49,7 @@ public class PigRelOpTest extends PigRelTestBase {
    */
   private static class PigRelSqlDialect extends SqlDialect {
     static final SqlDialect DEFAULT =
-        new CalciteSqlDialect(emptyContext()
+        new CalciteSqlDialect(SqlDialect.EMPTY_CONTEXT
             .withDatabaseProduct(DatabaseProduct.CALCITE));
 
     private PigRelSqlDialect(Context context) {

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -152,7 +152,8 @@ public Result visit(Join e) {
       sqlCondition = convertConditionToSqlNode(e.getCondition(),
           leftContext,
           rightContext,
-          e.getLeft().getRowType().getFieldCount());
+          e.getLeft().getRowType().getFieldCount(),
+          dialect);
     }
     SqlNode join =
         new SqlJoin(POS,

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -235,9 +235,9 @@ private RexNode rewriteSome(RexSubQuery e, Set<CorrelationId> variablesSet,
       //   end as v
       // from emp as e
       // left outer join (
-      //   select max(deptno) as m, count(*) as c, count(deptno) as d,
+      //   select name, max(deptno) as m, count(*) as c, count(deptno) as d,
       //       "alwaysTrue" as indicator
-      //   group by name from emp) as q on e.name = q.name
+      //   from emp group by name) as q on e.name = q.name
       builder.push(e.rel)
           .aggregate(builder.groupKey(),
               builder.aggregateCall(minMax, builder.field(0)).as("m"),

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConstantExpression.java
Patch:
@@ -147,7 +147,7 @@ private static ExpressionWriter write(ExpressionWriter writer,
       try {
         final int scale = bigDecimal.scale();
         final long exact = bigDecimal.scaleByPowerOfTen(scale).longValueExact();
-        writer.append("new java.math.BigDecimal(").append(exact).append("L");
+        writer.append("java.math.BigDecimal.valueOf(").append(exact).append("L");
         if (scale != 0) {
           writer.append(", ").append(scale);
         }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -1202,7 +1202,7 @@ public static CalciteCatalogReader createSingleTableCatalogReader(
         false,
         false,
         "",
-        new ExplicitTablesSchema(tableMap));
+        new ExplicitTableSchema(tableMap));
 
     return new CalciteCatalogReader(
         schema,
@@ -1329,10 +1329,10 @@ private static class ExplicitRowTypeTable extends AbstractTable {
   /**
    * A {@link AbstractSchema} that can specify the table map explicitly.
    */
-  private static class ExplicitTablesSchema extends AbstractSchema {
+  private static class ExplicitTableSchema extends AbstractSchema {
     private final Map<String, Table> tableMap;
 
-    ExplicitTablesSchema(Map<String, Table> tableMap) {
+    ExplicitTableSchema(Map<String, Table> tableMap) {
       this.tableMap = Objects.requireNonNull(tableMap);
     }
 

File: server/src/test/java/org/apache/calcite/test/ServerTest.java
Patch:
@@ -428,7 +428,7 @@ static Connection connect() throws SQLException {
           + " h varchar(3) not null,\n"
           + " i varchar(3),\n"
           + " j int not null as (char_length(h)) virtual,\n"
-          + " k varchar(3) null as (trim(i)) virtual)";
+          + " k varchar(3) null as (rtrim(i)) virtual)";
       boolean b = s.execute(create);
       assertThat(b, is(false));
 
@@ -448,7 +448,8 @@ static Connection connect() throws SQLException {
 
       final String plan = ""
           + "EnumerableCalc(expr#0..1=[{inputs}], expr#2=[CHAR_LENGTH($t0)], "
-          + "expr#3=[FLAG(BOTH)], expr#4=[' '], expr#5=[TRIM($t3, $t4, $t1)], proj#0..2=[{exprs}], K=[$t5])\n"
+          + "expr#3=[FLAG(TRAILING)], expr#4=[' '], "
+          + "expr#5=[TRIM($t3, $t4, $t1)], proj#0..2=[{exprs}], K=[$t5])\n"
           + "  EnumerableTableScan(table=[[T1]])\n";
       try (ResultSet r = s.executeQuery("explain plan for " + select)) {
         assertThat(r.next(), is(true));

File: mongodb/src/test/java/org/apache/calcite/adapter/mongodb/MongoAdapterTest.java
Patch:
@@ -474,8 +474,7 @@ private CalciteAssert.AssertThat assertModel(URL url) {
                 "{$group: {_id: '$STATE', _1: {$sum: '$POP'}, _2: {$sum: {$cond: [ {$eq: ['POP', null]}, 0, 1]}}}}",
                 "{$project: {STATE: '$_id', _1: '$_1', _2: '$_2'}}",
                 "{$sort: {STATE: 1}}",
-                "{$project: {STATE: 1, A: {$divide: [{$cond:[{$eq: ['$_2', {$literal: 0}]},null,'$_1']}, '$_2']}, S: {$cond:[{$eq: ['$_2', {$literal: 0}]},null,'$_1']}, C: '$_2'}}"
-                ));
+                "{$project: {STATE: 1, A: {$divide: [{$cond:[{$eq: ['$_2', {$literal: 0}]},null,'$_1']}, '$_2']}, S: {$cond:[{$eq: ['$_2', {$literal: 0}]},null,'$_1']}, C: '$_2'}}"));
   }
 
   @Test public void testGroupByHaving() {

File: core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java
Patch:
@@ -273,9 +273,9 @@ private static <M extends Metadata> MetadataHandler<M> load3(
           .append("      if (v == ")
           .append(NullSentinel.class.getName())
           .append(".ACTIVE) {\n")
-          .append("        throw ")
+          .append("        throw new ")
           .append(CyclicMetadataException.class.getName())
-          .append(".INSTANCE;\n")
+          .append("();\n")
           .append("      }\n")
           .append("      if (v == ")
           .append(NullSentinel.class.getName())

File: core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
Patch:
@@ -179,7 +179,7 @@ private static RelMetadataProvider reflectiveSource(
                   key1 = FlatLists.copyOf(args2);
                 }
                 if (mq.map.put(key1, NullSentinel.INSTANCE) != null) {
-                  throw CyclicMetadataException.INSTANCE;
+                  throw new CyclicMetadataException();
                 }
                 try {
                   return handlerMethod.invoke(target, args1);

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfig.java
Patch:
@@ -76,6 +76,8 @@ public interface CalciteConnectionConfig extends ConnectionConfig {
   String locale();
   /** @see CalciteConnectionProperty#TYPE_COERCION */
   boolean typeCoercion();
+  /** @see CalciteConnectionProperty#LENIENT_OPERATOR_LOOKUP */
+  boolean lenientOperatorLookup();
 }
 
 // End CalciteConnectionConfig.java

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -328,7 +328,8 @@ protected SqlValidatorImpl(
     groupFinder = new AggFinder(opTab, false, false, true, null, nameMatcher);
     aggOrOverOrGroupFinder = new AggFinder(opTab, true, true, true, null,
         nameMatcher);
-    this.lenientOperatorLookup = false;
+    this.lenientOperatorLookup = catalogReader.getConfig() != null
+        && catalogReader.getConfig().lenientOperatorLookup();
     this.enableTypeCoercion = catalogReader.getConfig() == null
         || catalogReader.getConfig().typeCoercion();
     this.typeCoercion = TypeCoercions.getTypeCoercion(this, conformance);

File: core/src/main/java/org/apache/calcite/plan/RelTrait.java
Patch:
@@ -21,7 +21,7 @@
  * a trait definition. For example, a {@code CallingConvention.JAVA} is a trait
  * of the {@link ConventionTraitDef} trait definition.
  *
- * <h3><a id="EqualsHashCodeNote">Note about equals() and hashCode()</a></h3>
+ * <h2><a id="EqualsHashCodeNote">Note about equals() and hashCode()</a></h2>
  *
  * <p>If all instances of RelTrait for a particular RelTraitDef are defined in
  * an {@code enum} and no new RelTraits can be introduced at runtime, you need

File: core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
Patch:
@@ -41,7 +41,7 @@
  *
  * <p> Rewrite: (GB-Union All-GB)-GB-UDTF (on all attributes)
  *
- * <h3>Example</h3>
+ * <h2>Example</h2>
  *
  * <p>Query: <code>R1 Intersect All R2</code>
  *

File: core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
Patch:
@@ -48,7 +48,7 @@
  * {@link SqlValidatorNamespace} when resolving 'name', and
  * as a {@link SqlValidatorScope} when resolving 'gender'.</p>
  *
- * <h3>Scopes</h3>
+ * <h2>Scopes</h2>
  *
  * <p>In the query</p>
  *
@@ -72,7 +72,7 @@
  * defined in the SELECT clause</li>
  * </ul>
  *
- * <h3>Namespaces</h3>
+ * <h2>Namespaces</h2>
  *
  * <p>In the above query, there are 4 namespaces:</p>
  *

File: core/src/main/java/org/apache/calcite/util/Static.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Definitions of objects to be statically imported.
  *
- * <h3>Note to developers</h3>
+ * <h2>Note to developers</h2>
  *
  * <p>Please give careful consideration before including an object in this
  * class. Pros:

File: core/src/main/java/org/apache/calcite/util/trace/CalciteTrace.java
Patch:
@@ -31,7 +31,7 @@
  * Contains all of the {@link org.slf4j.Logger tracers} used within
  * org.apache.calcite class libraries.
  *
- * <h3>Note to developers</h3>
+ * <h2>Note to developers</h2>
  *
  * <p>Please ensure that every tracer used in org.apache.calcite is added to
  * this class as a <em>public static final</em> member called <code>

File: linq4j/src/main/java/org/apache/calcite/linq4j/Enumerator.java
Patch:
@@ -106,7 +106,7 @@ public interface Enumerator<T> extends AutoCloseable {
    * <p>This method is optional; it may throw
    * {@link UnsupportedOperationException}.
    *
-   * <h3>Notes to Implementers</h3>
+   * <p><b>Notes to Implementers</b>
    *
    * <p>All calls to Reset must result in the same state for the enumerator.
    * The preferred implementation is to move the enumerator to the beginning

File: linq4j/src/main/java/org/apache/calcite/linq4j/Extensions.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Contains what, in LINQ.NET, would be extension methods.
  *
- * <h3>Notes on mapping from LINQ.NET to Java</h3>
+ * <h2>Notes on mapping from LINQ.NET to Java</h2>
  *
  * <p>We have preserved most of the API. But we've changed a few things, so that
  * the API is more typical Java API:</p>

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcConvention.java
Patch:
@@ -39,7 +39,7 @@
  * (That would involve asking database B to open a database link to database
  * A.)</p>
  *
- * <p>As a result, converter rules from and two this convention need to be
+ * <p>As a result, converter rules from and to this convention need to be
  * instantiated, at the start of planning, for each JDBC database in play.</p>
  */
 public class JdbcConvention extends Convention.Impl {

File: core/src/main/java/org/apache/calcite/jdbc/Driver.java
Patch:
@@ -81,7 +81,7 @@ protected Function0<CalcitePrepare> createPrepareFactory() {
     }
   }
 
-  protected DriverVersion createDriverVersion() {
+  @Override protected DriverVersion createDriverVersion() {
     return DriverVersion.load(
         Driver.class,
         "org-apache-calcite-jdbc.properties",

File: core/src/main/java/org/apache/calcite/plan/ConventionTraitDef.java
Patch:
@@ -34,7 +34,7 @@
 import java.util.List;
 
 /**
- * Definition of the the convention trait.
+ * Definition of the convention trait.
  * A new set of conversion information is created for
  * each planner that registers at least one {@link ConverterRule} instance.
  *

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ClassDeclarationFinder.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.List;
 
 /**
- * Entry point for optimizers that factor ou deterministic expressions to
+ * Entry point for optimizers that factor out deterministic expressions to
  * final static fields.
  * Instances of this class should not be reused, so new visitor should be
  * created for optimizing a new expression tree.

File: core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
Patch:
@@ -329,7 +329,8 @@ protected void validateJoinFilters(List<RexNode> aboveFilters,
     final Iterator<RexNode> filterIter = joinFilters.iterator();
     while (filterIter.hasNext()) {
       RexNode exp = filterIter.next();
-      if (!predicate.apply(join, joinType, exp)) {
+      // Do not pull up filter conditions for semi/anti join.
+      if (!predicate.apply(join, joinType, exp) && joinType.projectsRight()) {
         aboveFilters.add(exp);
         filterIter.remove();
       }

File: core/src/main/java/org/apache/calcite/sql/SqlExplain.java
Patch:
@@ -172,7 +172,7 @@ public boolean isXml() {
    * Returns whether result is to be in JSON format.
    */
   public boolean isJson() {
-    return getFormat() == SqlExplainFormat.XML;
+    return getFormat() == SqlExplainFormat.JSON;
   }
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {

File: babel/src/test/java/org/apache/calcite/test/BabelParserTest.java
Patch:
@@ -150,9 +150,8 @@ public class BabelParserTest extends SqlParserTest {
    * Optimize global LOOKAHEAD for SQL parsers</a>
    */
   @Test public void testCaseExpressionBabel() {
-    checkFails(
-        "case x when 2, 4 then 3 ^when^ then 5 else 4 end",
-        "(?s)Encountered \"when then\" at .*");
+    sql("case x when 2, 4 then 3 ^when^ then 5 else 4 end")
+        .fails("(?s)Encountered \"when then\" at .*");
   }
 
   /** In Redshift, DATE is a function. It requires special treatment in the

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -81,6 +81,7 @@
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.function.Consumer;
+import java.util.function.UnaryOperator;
 import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
@@ -8984,7 +8985,7 @@ public static SqlTester tester() {
    */
   protected static class TesterImpl extends SqlRuntimeTester {
     public TesterImpl(SqlTestFactory testFactory) {
-      super(testFactory);
+      super(testFactory, UnaryOperator.identity());
     }
 
     @Override public void check(String query, TypeChecker typeChecker,

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -85,6 +85,7 @@ public final Sql sql(String sql) {
         SqlToRelConverter.Config.DEFAULT, tester.getConformance());
   }
 
+  @Deprecated // to be removed before 1.23
   protected final void check(
       String sql,
       String plan) {

File: core/src/test/java/org/apache/calcite/test/SqlValidatorDynamicTest.java
Patch:
@@ -94,7 +94,7 @@ public SqlValidatorDynamicTest() {
   }
 
   @Override public SqlTester getTester() {
-    // Dymamic schema should not be reused since it is mutable, so
+    // Dynamic schema should not be reused since it is mutable, so
     // we create new SqlTestFactory for each test
     return new SqlValidatorTester(SqlTestFactory.INSTANCE
         .withCatalogReader(MockCatalogReaderDynamic::new));

File: core/src/test/java/org/apache/calcite/test/SqlValidatorFeatureTest.java
Patch:
@@ -107,12 +107,12 @@ public SqlValidatorFeatureTest() {
 
   private void checkFeature(String sql, Feature feature) {
     // Test once with feature enabled:  should pass
-    check(sql);
+    sql(sql).ok();
 
     // Test once with feature disabled:  should fail
     try {
       disabledFeature = feature;
-      checkFails(sql, FEATURE_DISABLED);
+      sql(sql).fails(FEATURE_DISABLED);
     } finally {
       disabledFeature = null;
     }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorMatchTest.java
Patch:
@@ -190,7 +190,7 @@ public class SqlValidatorMatchTest extends SqlValidatorTestCase {
     sql(sql)
         .fails("Unknown pattern 'strt'");
     sql(sql)
-        .tester(tester.withCaseSensitive(false))
+        .withCaseSensitive(false)
         .sansCarets()
         .ok();
   }

File: core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercion.java
Patch:
@@ -118,6 +118,9 @@ boolean rowTypeCoercion(
   /** Coerce operand of binary arithmetic expressions to Numeric type.*/
   boolean binaryArithmeticCoercion(SqlCallBinding binding);
 
+  /** Coerce operands in binary comparison expressions. */
+  boolean binaryComparisonCoercion(SqlCallBinding binding);
+
   /**
    * Coerce CASE WHEN statement branches to one common type.
    *

File: core/src/main/java/org/apache/calcite/sql/SqlTypeNameSpec.java
Patch:
@@ -40,7 +40,7 @@ public abstract class SqlTypeNameSpec {
    * @param name Name of the type.
    * @param pos  Parser position, must not be null.
    */
-  SqlTypeNameSpec(SqlIdentifier name, SqlParserPos pos) {
+  public SqlTypeNameSpec(SqlIdentifier name, SqlParserPos pos) {
     this.typeName = name;
     this.pos = pos;
   }

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -749,6 +749,8 @@ public boolean supportsDataType(RelDataType type) {
     return true;
   }
 
+ /** Returns SqlNode for type in "cast(column as type)", which might be
+  * different between databases by type name, precision etc. */
   public SqlNode getCastSpec(RelDataType type) {
     if (type instanceof BasicSqlType) {
       int maxPrecision = -1;

File: core/src/test/java/org/apache/calcite/test/ScannableTableTest.java
Patch:
@@ -268,11 +268,11 @@ public class ScannableTableTest {
         + "group by \"k\"";
     final Table table = new BeatlesProjectableFilterableTable(buf, false);
     final String explain = "PLAN="
-        + "EnumerableAggregate(group=[{0}], C=[COUNT()])\n"
+        + "EnumerableAggregate(group=[{1}], C=[COUNT()])\n"
         + "  EnumerableAggregate(group=[{0, 1}])\n"
         + "    EnumerableInterpreter\n"
         + "      BindableTableScan(table=[[s, beatles]], "
-        + "filters=[[=($2, 1940)]], projects=[[2, 0]])";
+        + "filters=[[=($2, 1940)]], projects=[[0, 2]])";
     CalciteAssert.that()
         .with(newSchema("s", "beatles", table))
         .query(sql)

File: core/src/main/java/org/apache/calcite/sql/fun/SqlDotOperator.java
Patch:
@@ -143,6 +143,8 @@ public void validateCall(
     }
     final RelDataType operandType = callBinding.getOperandType(0);
     final SqlSingleOperandTypeChecker checker = getChecker(operandType);
+    // Actually operand0 always comes from parsing the SqlIdentifier, so there
+    // is no need to make implicit type coercion.
     return checker.checkSingleOperandType(callBinding, right, 0,
         throwOnFailure);
   }

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverterRule.java
Patch:
@@ -35,7 +35,7 @@ public JdbcToEnumerableConverterRule(JdbcConvention out,
       RelBuilderFactory relBuilderFactory) {
     super(RelNode.class, (Predicate<RelNode>) r -> true, out,
         EnumerableConvention.INSTANCE, relBuilderFactory,
-        "JdbcToEnumerableConverterRule:" + out);
+        "JdbcToEnumerableConverterRule");
   }
 
   @Override public RelNode convert(RelNode rel) {

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfig.java
Patch:
@@ -74,6 +74,8 @@ public interface CalciteConnectionConfig extends ConnectionConfig {
   @Override String timeZone();
   /** @see CalciteConnectionProperty#LOCALE */
   String locale();
+  /** @see CalciteConnectionProperty#TYPE_COERCION */
+  boolean typeCoercion();
 }
 
 // End CalciteConnectionConfig.java

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -213,6 +213,8 @@ public Type getJavaClass(RelDataType type) {
         return Enum.class;
       case ANY:
         return Object.class;
+      case NULL:
+        return Void.class;
       }
     }
     switch (type.getSqlTypeName()) {

File: core/src/main/java/org/apache/calcite/prepare/CalciteSqlValidator.java
Patch:
@@ -25,6 +25,7 @@
 
 /** Validator. */
 class CalciteSqlValidator extends SqlValidatorImpl {
+
   CalciteSqlValidator(SqlOperatorTable opTab,
       CalciteCatalogReader catalogReader, JavaTypeFactory typeFactory,
       SqlConformance conformance) {

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -507,10 +507,12 @@ public RelDataType deriveType(
     final List<RelDataType> argTypes = constructArgTypeList(validator, scope,
         call, args, false);
 
+    // Always disable type coercion for builtin operator operands,
+    // they are handled by the TypeCoercion specifically.
     final SqlOperator sqlOperator =
         SqlUtil.lookupRoutine(validator.getOperatorTable(), getNameAsId(),
             argTypes, null, null, getSyntax(), getKind(),
-            validator.getCatalogReader().nameMatcher());
+            validator.getCatalogReader().nameMatcher(), false);
 
     ((SqlBasicCall) call).setOperator(sqlOperator);
     RelDataType type = call.getOperator().validateOperands(validator, scope, call);

File: core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java
Patch:
@@ -77,6 +77,7 @@ public boolean checkOperandTypes(
               callBinding.getScope(),
               pair.right);
       if (!SqlTypeUtil.canAssignFrom(pair.left, argType)) {
+        // TODO: add in unresolved function type cast.
         if (throwOnFailure) {
           throw callBinding.newValidationSignatureError();
         } else {

File: core/src/main/java/org/apache/calcite/sql/type/JavaToSqlTypeConversionRules.java
Patch:
@@ -77,6 +77,7 @@ public class JavaToSqlTypeConversionRules {
           .put(ColumnList.class, SqlTypeName.COLUMN_LIST)
           .put(ArrayImpl.class, SqlTypeName.ARRAY)
           .put(List.class, SqlTypeName.ARRAY)
+          .put(Void.class, SqlTypeName.NULL)
           .build();
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
Patch:
@@ -113,7 +113,7 @@ protected boolean checkOperandTypesImpl(
    * interface, and cannot throw an error.
    */
   public boolean checkOperandTypes(
-      SqlOperatorBinding operatorBinding) {
+      SqlOperatorBinding operatorBinding, SqlCallBinding callBinding) {
     return checkOperandTypesImpl(operatorBinding, false, null);
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransforms.java
Patch:
@@ -137,6 +137,8 @@ private SqlTypeName toVar(RelDataType type) {
             return SqlTypeName.VARBINARY;
           case ANY:
             return SqlTypeName.ANY;
+          case NULL:
+            return SqlTypeName.NULL;
           default:
             throw Util.unexpected(sqlTypeName);
           }

File: core/src/test/java/org/apache/calcite/sql/test/SqlTester.java
Patch:
@@ -78,6 +78,9 @@ enum VmName {
    * version. */
   SqlTester withConformance(SqlConformance conformance);
 
+  /** Returns a tester that tests with implicit type coercion on/off. */
+  SqlTester enableTypeCoercion(boolean enabled);
+
   /** Returns a tester that gets connections from a given factory. */
   SqlTester withConnectionFactory(
       CalciteAssert.ConnectionFactory connectionFactory);

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -112,6 +112,8 @@
     SqlJsonFunctionsTest.class,
     SqlTypeNameTest.class,
     ModelTest.class,
+    TypeCoercionTest.class,
+    TypeCoercionConverterTest.class,
     SqlValidatorFeatureTest.class,
     VolcanoPlannerTraitTest.class,
     InterpreterTest.class,

File: core/src/test/java/org/apache/calcite/test/ExceptionMessageTest.java
Patch:
@@ -124,8 +124,8 @@ private void runQuery(String sql) throws SQLException {
 
   @Test public void testSemanticError() {
     try {
+      // implicit type coercion.
       runQuery("select \"name\" - \"id\" from \"entries\"");
-      fail("Query with semantic error should fail");
     } catch (SQLException e) {
       assertThat(e.getMessage(),
           containsString("Cannot apply '-' to arguments"));

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -5108,7 +5108,7 @@ private void transitiveInference(RelOptRule... extraRules) throws Exception {
   @Test public void testSortJoinTranspose4() {
     // Create a customized test with RelCollation trait in the test cluster.
     Tester tester = new TesterImpl(getDiffRepos(), true, true, false, false,
-        null, null) {
+        true, null, null) {
       @Override public RelOptPlanner createPlanner() {
         return new MockRelOptPlanner(Contexts.empty()) {
           @Override public List<RelTraitDef> getRelTraitDefs() {

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -1949,7 +1949,7 @@ public void testJoinUsingDynamicTable() {
     // Create a customized test with RelCollation trait in the test cluster.
     Tester tester = new TesterImpl(getDiffRepos(),
         false, true,
-        true, false,
+        true, false, true,
         null, null) {
       @Override public RelOptPlanner createPlanner() {
         return new MockRelOptPlanner(Contexts.empty()) {
@@ -3268,7 +3268,7 @@ private Tester getExtendedTester() {
         NullCollation.LOW.name());
     CalciteConnectionConfigImpl connectionConfig =
         new CalciteConnectionConfigImpl(properties);
-    TesterImpl tester = new TesterImpl(getDiffRepos(), false, false, true, false,
+    TesterImpl tester = new TesterImpl(getDiffRepos(), false, false, true, false, true,
         null, null, SqlToRelConverter.Config.DEFAULT,
         SqlConformanceEnum.DEFAULT, Contexts.of(connectionConfig));
     sql(sql).with(tester).ok();

File: geode/src/test/java/org/apache/calcite/adapter/geode/rel/GeodeZipsTest.java
Patch:
@@ -280,6 +280,7 @@ public void testSqlSingleStringWhereFilter() {
   }
 
   @Test
+  @Ignore("Currently fails")
   public void testWhereWithOrWithEmptyResult() {
     String expectedQuery = "SELECT state AS state FROM /zips "
         + "WHERE state IN SET('', true, false, 123, 13.892)";

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/BinaryExpression.java
Patch:
@@ -92,10 +92,10 @@ public Object evaluate(Evaluator evaluator) {
             .evaluate(evaluator);
       case DOUBLE:
         return (Double) expression0.evaluate(evaluator)
-               / (Double) expression1.evaluate(evaluator);
+            / (Double) expression1.evaluate(evaluator);
       case LONG:
         return (Long) expression0.evaluate(evaluator)
-               / (Long) expression1.evaluate(evaluator);
+            / (Long) expression1.evaluate(evaluator);
       default:
         throw cannotEvaluate();
       }

File: piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java
Patch:
@@ -95,7 +95,7 @@ private PigRelSqlUdfs() {
   static SqlUserDefinedFunction createPigTupleUDF(ImmutableList<RexNode> operands) {
     return new PigUserDefinedFunction("PIG_TUPLE",
         infer(PigRelSqlUdfs.PIG_TUPLE_FUNC),
-        OperandTypes.family(getFamilitTypes(operands)),
+        OperandTypes.family(getTypeFamilies(operands)),
         getRelDataTypes(operands),
         PigRelSqlUdfs.PIG_TUPLE_FUNC);
   }
@@ -110,7 +110,7 @@ static SqlUserDefinedFunction createPigBagUDF(ImmutableList<RexNode> operands) {
     return new PigUserDefinedFunction(
         "PIG_BAG",
         infer(PigRelSqlUdfs.PIG_BAG_FUNC),
-        OperandTypes.family(getFamilitTypes(operands)),
+        OperandTypes.family(getTypeFamilies(operands)),
         getRelDataTypes(operands),
         PigRelSqlUdfs.PIG_BAG_FUNC);
   }
@@ -223,7 +223,7 @@ public Consistency getConsistency() {
    * @param operands List of relational operands
    * @return List of SqlTypeFamilies
    */
-  private static List<SqlTypeFamily> getFamilitTypes(ImmutableList<RexNode> operands) {
+  private static List<SqlTypeFamily> getTypeFamilies(ImmutableList<RexNode> operands) {
     List<SqlTypeFamily> ret = new ArrayList<>();
     for (RexNode operand : operands) {
       SqlTypeFamily family = operand.getType().getSqlTypeName().getFamily();

File: core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
Patch:
@@ -40,7 +40,7 @@ public class RelOptCluster {
   //~ Instance fields --------------------------------------------------------
 
   private final RelDataTypeFactory typeFactory;
-  private final RelOptPlanner planner;
+  private RelOptPlanner planner;
   private final AtomicInteger nextCorrel;
   private final Map<String, RelNode> mapCorrelToRel;
   private RexNode originalExpression;

File: core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
Patch:
@@ -180,7 +180,7 @@ public String getCharSetName() {
 
     if (charSetName != null) {
       writer.keyword("CHARACTER SET");
-      writer.identifier(charSetName, false);
+      writer.identifier(charSetName, true);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -4163,8 +4163,8 @@ private void handleScalarSubQuery(
     final RelDataType type = deriveType(scope, selectItem);
     setValidatedNodeType(selectItem, type);
 
-    // we do not want to pass on the RelRecordType returned
-    // by the sub query.  Just the type of the single expression
+    // We do not want to pass on the RelRecordType returned
+    // by the sub-query.  Just the type of the single expression
     // in the sub-query select list.
     assert type instanceof RelRecordType;
     RelRecordType rec = (RelRecordType) type;

File: core/src/main/java/org/apache/calcite/plan/volcano/RuleQueue.java
Patch:
@@ -405,6 +405,7 @@ private void dump() {
       dump(pw);
       pw.flush();
       LOGGER.trace(sw.toString());
+      planner.getRoot().getCluster().invalidateMetadataQuery();
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -2337,7 +2337,7 @@ private void convertIdentifier(Blackboard bb, SqlIdentifier id,
       final SqlValidatorTable validatorTable =
           table.unwrap(SqlValidatorTable.class);
       final List<RelDataTypeField> extendedFields =
-          SqlValidatorUtil.getExtendedColumns(validator.getTypeFactory(), validatorTable,
+          SqlValidatorUtil.getExtendedColumns(validator, validatorTable,
               extendedColumns);
       table = table.extend(extendedFields);
     }

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -515,7 +515,7 @@ protected RexNode convertCast(
       return castToValidatedType(cx, call, cx.convertExpression(left));
     }
     SqlDataTypeSpec dataType = (SqlDataTypeSpec) right;
-    RelDataType type = dataType.deriveType(typeFactory);
+    RelDataType type = dataType.deriveType(cx.getValidator());
     if (type == null) {
       type = cx.getValidator().getValidatedNodeType(dataType.getTypeName());
     }

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -757,7 +757,8 @@ private UnifyResult matchRecurse(MutableRel target) {
 
   private UnifyResult apply(UnifyRule rule, MutableRel query,
       MutableRel target) {
-    final UnifyRuleCall call = new UnifyRuleCall(rule, query, target, null);
+    final UnifyRuleCall call =
+        new UnifyRuleCall(rule, query, target, ImmutableList.of());
     return rule.apply(call);
   }
 

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableTableFunctionScan.java
Patch:
@@ -69,7 +69,7 @@ public static MutableTableFunctionScan of(RelOptCluster cluster,
             ((MutableTableFunctionScan) obj).elementType)
         && Objects.equals(columnMappings,
             ((MutableTableFunctionScan) obj).columnMappings)
-        && inputs.equals(((MutableSetOp) obj).getInputs());
+        && inputs.equals(((MutableTableFunctionScan) obj).getInputs());
   }
 
   @Override public int hashCode() {

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcDataTypeName.java
Patch:
@@ -92,8 +92,7 @@ public SqlLiteral symbol(SqlParserPos pos) {
   public SqlNode createDataType(SqlParserPos pos) {
     if (typeName != null) {
       assert range == null;
-      final SqlIdentifier id = new SqlIdentifier(typeName.name(), pos);
-      return new SqlDataTypeSpec(id, -1, -1, null, null, pos);
+      return new SqlDataTypeSpec(new SqlBasicTypeNameSpec(typeName, pos), pos);
     } else {
       assert range != null;
       return new SqlIntervalQualifier(range.startUnit, range.endUnit, pos);

File: core/src/main/java/org/apache/calcite/rel/core/Match.java
Patch:
@@ -192,7 +192,7 @@ public RexNode getInterval() {
 
   @Override public RelWriter explainTerms(RelWriter pw) {
     return super.explainTerms(pw)
-        .item("partition", getPartitionKeys())
+        .item("partition", getPartitionKeys().asList())
         .item("order", getOrderKeys())
         .item("outputFields", getRowType().getFieldNames())
         .item("allRows", isAllRows())

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -90,8 +90,8 @@ public void onMatch(RelOptRuleCall call) {
       // the rule fires forever: A-F => A-F-A => A-A-F-A => A-A-A-F-A => ...
       return;
     }
-    boolean allColumnsInAggregate = aggregate.getGroupSet().
-        contains(filterColumns);
+    final boolean allColumnsInAggregate =
+        aggregate.getGroupSet().contains(filterColumns);
     final Aggregate newAggregate =
         aggregate.copy(aggregate.getTraitSet(), input,
             newGroupSet, null, aggregate.getAggCallList());

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -196,8 +196,8 @@ private RexNode rewriteSome(RexSubQuery e, Set<CorrelationId> variablesSet,
       // cross join (
       //   select max(deptno) as m, count(*) as c, count(deptno) as d
       //   from emp) as q
-      builder.push(e.rel).
-          aggregate(builder.groupKey(),
+      builder.push(e.rel)
+          .aggregate(builder.groupKey(),
               builder.aggregateCall(minMax, builder.field(0)).as("m"),
               builder.count(false, "c"),
               builder.count(false, "d", builder.field(0)))

File: core/src/test/java/org/apache/calcite/sql/parser/parserextensiontesting/ExtensionSqlParserTest.java
Patch:
@@ -17,7 +17,6 @@
 package org.apache.calcite.sql.parser.parserextensiontesting;
 
 import org.apache.calcite.sql.SqlNode;
-import org.apache.calcite.sql.parser.SqlParseException;
 import org.apache.calcite.sql.parser.SqlParserImplFactory;
 import org.apache.calcite.sql.parser.SqlParserTest;
 
@@ -36,12 +35,12 @@ public class ExtensionSqlParserTest extends SqlParserTest {
     return ExtensionSqlParserImpl.FACTORY;
   }
 
-  @Test public void testAlterSystemExtension() throws SqlParseException {
+  @Test public void testAlterSystemExtension() {
     check("alter system upload jar '/path/to/jar'",
         "ALTER SYSTEM UPLOAD JAR '/path/to/jar'");
   }
 
-  @Test public void testAlterSystemExtensionWithoutAlter() throws SqlParseException {
+  @Test public void testAlterSystemExtensionWithoutAlter() {
     // We need to include the scope for custom alter operations
     checkFails("^upload^ jar '/path/to/jar'",
         "(?s).*Encountered \"upload\" at .*");

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.calcite.rex.RexBuilderTest;
 import org.apache.calcite.rex.RexExecutorTest;
 import org.apache.calcite.rex.RexSqlStandardConvertletTableTest;
+import org.apache.calcite.runtime.AutomatonTest;
 import org.apache.calcite.runtime.BinarySearchTest;
 import org.apache.calcite.runtime.EnumerablesTest;
 import org.apache.calcite.sql.SqlSetOptionOperatorTest;
@@ -124,6 +125,7 @@
     RexProgramTest.class,
     SqlOperatorBindingTest.class,
     RexTransformerTest.class,
+    AutomatonTest.class,
     BinarySearchTest.class,
     EnumerablesTest.class,
     ExceptionMessageTest.class,

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -2625,7 +2625,7 @@ private RelNode buildRelWithDuplicateAggregates(RelBuilder builder,
             measuresBuilder.build(), after, subsets, false,
             partitionKeysBuilder.build(), orderKeysBuilder.build(), interval)
         .build();
-    final String expected = "LogicalMatch(partition=[{7}], order=[[0]], "
+    final String expected = "LogicalMatch(partition=[[7]], order=[[0]], "
         + "outputFields=[[$7, 'start_nw', 'bottom_nw']], allRows=[false], "
         + "after=[FLAG(SKIP TO NEXT ROW)], pattern=[(('STRT', "
         + "PATTERN_QUANTIFIER('DOWN', 1, -1, false)), "

File: file/src/test/java/org/apache/calcite/adapter/file/SqlTest.java
Patch:
@@ -389,7 +389,7 @@ Fluent returnsUnordered(String... expectedLines) {
   }
 
   /** Test returns the result of two json file joins. */
-  @Test public void testJsonJoinOnString() throws SQLException {
+  @Test public void testJsonJoinOnString() {
     final String sql = "select emps.EMPNO, emps.NAME, depts.deptno from emps\n"
         + "join depts on emps.deptno = depts.deptno";
     final String[] lines = {
@@ -401,7 +401,7 @@ Fluent returnsUnordered(String... expectedLines) {
   }
 
   /** The folder contains both JSON files and CSV files joins. */
-  @Test public void testJsonWithCsvJoin() throws SQLException {
+  @Test public void testJsonWithCsvJoin() {
     final String sql = "select emps.empno,\n"
         + " NAME,\n"
         + " \"DATE\".JOINEDAT\n"

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
Patch:
@@ -592,7 +592,7 @@ public static ConstantExpression constant(Object value, Type type) {
    * Creates a GotoExpression representing a continue statement.
    */
   public static GotoStatement continue_(LabelTarget labelTarget) {
-    throw Extensions.todo();
+    return new GotoStatement(GotoExpressionKind.Continue, null, null);
   }
 
   /**

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForEachStatement.java
Patch:
@@ -26,9 +26,7 @@ public class ForEachStatement extends Statement {
   public final Expression iterable;
   public final Statement body;
 
-  /**
-   * Cache the hash code for the expression
-   */
+  /** Cache the hash code for the expression */
   private int hash;
 
   public ForEachStatement(ParameterExpression parameter, Expression iterable,
@@ -52,6 +50,8 @@ public <R> R accept(Visitor<R> visitor) {
 
   @Override void accept0(ExpressionWriter writer) {
     writer.append("for (")
+        .append(parameter.type)
+        .append(" ")
         .append(parameter)
         .append(" : ")
         .append(iterable)

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
Patch:
@@ -103,7 +103,8 @@ public R visit(FunctionExpression functionExpression) {
   }
 
   public R visit(GotoStatement gotoStatement) {
-    return gotoStatement.expression.accept(this);
+    return gotoStatement.expression == null ? null
+        : gotoStatement.expression.accept(this);
   }
 
   public R visit(IndexExpression indexExpression) {

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -698,7 +698,8 @@ public enum SqlKind {
   COLUMN_LIST,
 
   /**
-   * The "CAST" operator.
+   * The "CAST" operator, and also the PostgreSQL-style infix cast operator
+   * "::".
    */
   CAST,
 

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -106,6 +106,7 @@ private StandardConvertletTable() {
 
     // Register convertlets for specific objects.
     registerOp(SqlStdOperatorTable.CAST, this::convertCast);
+    registerOp(SqlLibraryOperators.INFIX_CAST, this::convertCast);
     registerOp(SqlStdOperatorTable.IS_DISTINCT_FROM,
         (cx, call) -> convertIsDistinctFrom(cx, call, false));
     registerOp(SqlStdOperatorTable.IS_NOT_DISTINCT_FROM,

File: core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
Patch:
@@ -383,6 +383,9 @@ public RelDataType deriveType(RelDataTypeFactory typeFactory,
       case MULTISET:
         type = typeFactory.createMultisetType(type, -1);
         break;
+      case ARRAY:
+        type = typeFactory.createArrayType(type, -1);
+        break;
 
       default:
         throw Util.unexpected(collectionsSqlTypeName);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -824,8 +824,7 @@ private RelBuilder createSelectDistinct(RelBuilder relBuilder,
             rexBuilder.makeCall(SqlStdOperatorTable.CASE, filterRef,
                 argRef.left,
                 rexBuilder.ensureType(argRef.left.getType(),
-                    rexBuilder.makeCast(argRef.left.getType(),
-                        rexBuilder.constantNull()),
+                    rexBuilder.makeNullLiteral(argRef.left.getType()),
                     true));
         sourceOf.put(arg, projects.size());
         projects.add(Pair.of(condition, "i$" + argRef.right));

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateValuesRule.java
Patch:
@@ -89,8 +89,7 @@ public AggregateValuesRule(RelBuilderFactory relBuilderFactory) {
       case MIN:
       case MAX:
       case SUM:
-        literals.add((RexLiteral) rexBuilder.makeCast(
-            aggregateCall.getType(), rexBuilder.constantNull()));
+        literals.add(rexBuilder.makeNullLiteral(aggregateCall.getType()));
         break;
 
       default:

File: core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
Patch:
@@ -1651,8 +1651,7 @@ private LoptJoinTree createReplacementJoin(
           newType =
               typeFactory.createTypeWithNullability(newType, true);
         }
-        projExpr =
-            rexBuilder.makeCast(newType, rexBuilder.constantNull());
+        projExpr = rexBuilder.makeNullLiteral(newType);
       } else {
         RelDataTypeField mappedField = currFields.get(replacementKeys[i]);
         RexNode mappedInput =

File: core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java
Patch:
@@ -92,9 +92,7 @@ public RexNode convertLiteral(
       } else {
         type = validator.getValidatedNodeType(literal);
       }
-      return rexBuilder.makeCast(
-          type,
-          rexBuilder.constantNull());
+      return rexBuilder.makeNullLiteral(type);
     }
 
     BitString bitString;

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -360,7 +360,8 @@ private int inputOffset(int inputCount, int inputOrdinal) {
   public RexNode literal(Object value) {
     final RexBuilder rexBuilder = cluster.getRexBuilder();
     if (value == null) {
-      return rexBuilder.constantNull();
+      final RelDataType type = getTypeFactory().createSqlType(SqlTypeName.NULL);
+      return rexBuilder.makeNullLiteral(type);
     } else if (value instanceof Boolean) {
       return rexBuilder.makeLiteral((Boolean) value);
     } else if (value instanceof BigDecimal) {

File: core/src/test/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java
Patch:
@@ -56,7 +56,7 @@ class EmpInitializerExpressionFactory
       return rexBuilder.makeExactLiteral(new BigDecimal(555),
           typeFactory.createSqlType(SqlTypeName.INTEGER));
     default:
-      return rexBuilder.constantNull();
+      return super.newColumnDefaultValue(table, iColumn, context);
     }
   }
 }

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -1415,6 +1415,8 @@ public RexNode makeLiteral(Object value, RelDataType type,
     case INTERVAL_SECOND:
       return makeIntervalLiteral((BigDecimal) value,
           type.getIntervalQualifier());
+    case SYMBOL:
+      return makeFlag((Enum) value);
     case MAP:
       final MapSqlType mapType = (MapSqlType) type;
       @SuppressWarnings("unchecked")

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -373,6 +373,9 @@ public RexNode literal(Object value) {
           BigDecimal.valueOf(((Number) value).longValue()));
     } else if (value instanceof String) {
       return rexBuilder.makeLiteral((String) value);
+    } else if (value instanceof Enum) {
+      return rexBuilder.makeLiteral(value,
+          getTypeFactory().createSqlType(SqlTypeName.SYMBOL), false);
     } else {
       throw new IllegalArgumentException("cannot convert " + value
           + " (" + value.getClass() + ") to a constant");

File: core/src/test/java/org/apache/calcite/sql/type/RelDataTypeSystemTest.java
Patch:
@@ -199,4 +199,5 @@ public void testCustomDecimalModReturnTypeInference() {
     Assert.assertEquals(10, dataType.getScale());
   }
 }
+
 // End RelDataTypeSystemTest.java

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -5135,15 +5135,15 @@ private Sql checkSubQuery(String sql) {
 
   @Test public void testSelectAnyCorrelated() {
     final String sql = "select empno > ANY (\n"
-        + " select deptno from dept where emp.job = dept.name) \n"
+        + "  select deptno from dept where emp.job = dept.name)\n"
         + "from emp\n";
     checkSubQuery(sql).withLateDecorrelation(true).check();
   }
 
   @Test public void testWhereAnyCorrelatedInSelect() {
     final String sql =
         "select * from emp where empno > ANY (\n"
-            + " select deptno from dept where emp.job = dept.name) \n";
+            + "  select deptno from dept where emp.job = dept.name)\n";
     checkSubQuery(sql).withLateDecorrelation(true).check();
   }
 

File: core/src/test/java/org/apache/calcite/test/catalog/VirtualColumnsExpressionFactory.java
Patch:
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.calcite.test.catalog;
 
 import org.apache.calcite.plan.RelOptTable;

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -939,7 +939,8 @@ private RexNode expandTimes(RexCall call, List<RexNode> operands) {
       // a lower scale, then the number should be scaled down.
       int divisor = scaleA + scaleB - call.getType().getScale();
 
-      if (builder.getTypeFactory().useDoubleMultiplication(
+      if (builder.getTypeFactory().getTypeSystem().shouldUseDoubleMultiplication(
+          builder.getTypeFactory(),
           typeA,
           typeB)) {
         // Approximate implementation:

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -39,7 +39,6 @@
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.fun.SqlQuantifyOperator;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
-import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql2rel.RelDecorrelator;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
@@ -198,7 +197,7 @@ private RexNode rewriteSome(RexSubQuery e, Set<CorrelationId> variablesSet,
                   builder.field("q", "m"))), builder.literal(true), builder
               .call(SqlStdOperatorTable.GREATER_THAN, builder.field("q", "c"),
                   builder.field("q", "d")),
-          e.rel.getCluster().getRexBuilder().makeNullLiteral(SqlTypeName.BOOLEAN), builder
+          builder.getRexBuilder().constantNull(), builder
               .call(RelOptUtil.op(op.comparisonKind, null), e.operands.get(0),
                   builder.field("q", "m")));
     } else {
@@ -241,7 +240,7 @@ private RexNode rewriteSome(RexSubQuery e, Set<CorrelationId> variablesSet,
                   builder.field("q", "m"))), builder.literal(true), builder
               .call(SqlStdOperatorTable.GREATER_THAN, builder.field("q", "c"),
                   builder.field("q", "d")),
-          e.rel.getCluster().getRexBuilder().makeNullLiteral(SqlTypeName.BOOLEAN), builder
+          builder.getRexBuilder().constantNull(), builder
               .call(RelOptUtil.op(op.comparisonKind, null), e.operands.get(0),
                   builder.field("q", "m")));
     }

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -460,6 +460,7 @@ private List<RelDataTypeFieldImpl> fieldsOf(Class clazz) {
    * {@link RelDataTypeSystem#deriveDecimalMultiplyType(RelDataTypeFactory, RelDataType, RelDataType)}
    * to get the return type for the operation.
    */
+  @Deprecated
   public RelDataType createDecimalProduct(
       RelDataType type1,
       RelDataType type2) {
@@ -471,6 +472,7 @@ public RelDataType createDecimalProduct(
    * {@link RelDataTypeSystem#shouldUseDoubleMultiplication(RelDataTypeFactory, RelDataType, RelDataType)}
    * to get if double should be used for multiplication.
    */
+  @Deprecated
   public boolean useDoubleMultiplication(
       RelDataType type1,
       RelDataType type2) {
@@ -482,6 +484,7 @@ public boolean useDoubleMultiplication(
    * {@link RelDataTypeSystem#deriveDecimalDivideType(RelDataTypeFactory, RelDataType, RelDataType)}
    * to get the return type for the operation.
    */
+  @Deprecated
   public RelDataType createDecimalQuotient(
       RelDataType type1,
       RelDataType type2) {

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
Patch:
@@ -335,7 +335,7 @@ private void matchRecurse(int solve) {
           // but now check that it is the *correct* child.
           final RelSubset input =
               (RelSubset) rel.getInput(previousOperand.ordinalInParent);
-          List<RelNode> inputRels = input.set.getRelsFromAllSubsets();
+          List<RelNode> inputRels = input.getRelList();
           if (!inputRels.contains(previous)) {
             continue;
           }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -92,6 +92,7 @@
 import static org.apache.calcite.linq4j.tree.ExpressionType.OrElse;
 import static org.apache.calcite.linq4j.tree.ExpressionType.Subtract;
 import static org.apache.calcite.linq4j.tree.ExpressionType.UnaryPlus;
+import static org.apache.calcite.sql.fun.SqlLibraryOperators.CHR;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.DAYNAME;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.DIFFERENCE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.FROM_BASE64;
@@ -294,6 +295,7 @@ public class RexImpTable {
     defineMethod(RIGHT, BuiltInMethod.RIGHT.method, NullPolicy.ANY);
     defineMethod(REPLACE, BuiltInMethod.REPLACE.method, NullPolicy.STRICT);
     defineMethod(TRANSLATE3, BuiltInMethod.TRANSLATE3.method, NullPolicy.STRICT);
+    defineMethod(CHR, "chr", NullPolicy.STRICT);
     defineMethod(CHARACTER_LENGTH, BuiltInMethod.CHAR_LENGTH.method,
         NullPolicy.STRICT);
     defineMethod(CHAR_LENGTH, BuiltInMethod.CHAR_LENGTH.method,

File: core/src/main/java/org/apache/calcite/plan/RelOptRule.java
Patch:
@@ -100,7 +100,7 @@ public RelOptRule(RelOptRuleOperand operand,
     if (description == null) {
       description = guessDescription(getClass().getName());
     }
-    if (!description.matches("[A-Za-z][-A-Za-z0-9_.():]*")) {
+    if (!description.matches("[A-Za-z][-A-Za-z0-9_.(),\\[\\]\\s:]*")) {
       throw new RuntimeException("Rule description '" + description
           + "' is not valid");
     }
@@ -536,8 +536,8 @@ public RelTrait getOutTrait() {
    * Returns the description of this rule.
    *
    * <p>It must be unique (for rules that are not equal) and must consist of
-   * only the characters A-Z, a-z, 0-9, '_', '.', '(', ')'. It must start with
-   * a letter. */
+   * only the characters A-Z, a-z, 0-9, '_', '.', '(', ')', '-', ',', '[', ']', ':', ' '.
+   * It must start with a letter. */
   public final String toString() {
     return description;
   }

File: core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
Patch:
@@ -78,7 +78,7 @@ public <R extends RelNode> ConverterRule(Class<R> clazz,
     super(convertOperand(clazz, predicate, in),
         relBuilderFactory,
         description == null
-            ? "ConverterRule<in=" + in + ",out=" + out + ">"
+            ? "ConverterRule(in:" + in + ",out:" + out + ")"
             : description);
     this.inTrait = Objects.requireNonNull(in);
     this.outTrait = Objects.requireNonNull(out);

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
Patch:
@@ -285,7 +285,7 @@ RelDataType createDecimalProduct(
    * <p>Pre-condition: <code>createDecimalProduct(type1, type2) != null</code>
    *
    * @deprecated Use
-   * {@link RelDataTypeSystem#shouldUseDoubleMultiplication(RelDataType, RelDataType)}
+   * {@link RelDataTypeSystem#shouldUseDoubleMultiplication(RelDataTypeFactory, RelDataType, RelDataType)}
    */
   @Deprecated // to be removed before 2.0
   boolean useDoubleMultiplication(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1557,7 +1557,7 @@ public SqlOperandCountRange getOperandCountRange() {
       new SqlFunction(
           "MOD",
           SqlKind.MOD,
-          ReturnTypes.ARG1_NULLABLE,
+          ReturnTypes.NULLABLE_MOD,
           null,
           OperandTypes.EXACT_NUMERIC_EXACT_NUMERIC,
           SqlFunctionCategory.NUMERIC);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -205,11 +205,11 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
    * <p>Occurs in similar places to an aggregate
    * function ({@code SELECT}, {@code HAVING} clause, etc. of an aggregate
    * query), but not technically an aggregate function. */
-  public static final SqlGroupingFunction GROUPING =
+  public static final SqlAggFunction GROUPING =
       new SqlGroupingFunction("GROUPING");
 
   /** {@code GROUP_ID()} function. (Oracle-specific.) */
-  public static final SqlGroupIdFunction GROUP_ID =
+  public static final SqlAggFunction GROUP_ID =
       new SqlGroupIdFunction();
 
   /** {@code GROUPING_ID} function is a synonym for {@code GROUPING}.
@@ -222,7 +222,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
    * <p>The SQL standard has changed to allow {@code GROUPING} to have multiple
    * arguments. It is now equivalent to {@code GROUPING_ID}, so we made
    * {@code GROUPING_ID} a synonym for {@code GROUPING}. */
-  public static final SqlGroupingFunction GROUPING_ID =
+  public static final SqlAggFunction GROUPING_ID =
       new SqlGroupingFunction("GROUPING_ID");
 
   /** {@code EXTEND} operator. */

File: linq4j/src/main/java/org/apache/calcite/linq4j/Ord.java
Patch:
@@ -150,7 +150,7 @@ private static class OrdList<E> extends AbstractList<Ord<E>> {
     }
 
     public Ord<E> get(int index) {
-      return of(index, elements.get(index));
+      return Ord.of(index, elements.get(index));
     }
 
     public int size() {

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinFilterTransposeRule.java
Patch:
@@ -72,7 +72,8 @@ public void onMatch(RelOptRuleCall call) {
     final RelFactories.FilterFactory factory =
         RelFactories.DEFAULT_FILTER_FACTORY;
     RelNode newFilter =
-        factory.createFilter(newSemiJoin, filter.getCondition());
+        factory.createFilter(newSemiJoin, filter.getCondition(),
+            ImmutableSet.of());
 
     call.transformTo(newFilter);
   }

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -482,9 +482,9 @@ public TrimResult trimFields(
     RexNode newConditionExpr =
         conditionExpr.accept(shuttle);
 
-    // Use copy rather than relBuilder so that correlating variables get set.
-    relBuilder.push(
-        filter.copy(filter.getTraitSet(), newInput, newConditionExpr));
+    // Build new filter with trimmed input and condition.
+    relBuilder.push(newInput)
+        .filter(filter.getVariablesSet(), newConditionExpr);
 
     // The result has the same mapping as the input gave us. Sometimes we
     // return fields that the consumer didn't ask for, because the filter

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -989,7 +989,8 @@ private void convertWhere(
 
     final RelFactories.FilterFactory filterFactory =
         RelFactories.DEFAULT_FILTER_FACTORY;
-    final RelNode filter = filterFactory.createFilter(bb.root, convertedWhere2);
+    final RelNode filter =
+        filterFactory.createFilter(bb.root, convertedWhere2, ImmutableSet.of());
     final RelNode r;
     final CorrelationUse p = getCorrelationUse(bb, filter);
     if (p != null) {
@@ -2490,7 +2491,7 @@ protected RelNode createJoin(
         // Replace outer RexInputRef with RexFieldAccess,
         // and push lateral join predicate into inner child
         final RexNode newCond = joinCond.accept(shuttle);
-        innerRel = factory.createFilter(p.r, newCond);
+        innerRel = factory.createFilter(p.r, newCond, ImmutableSet.of());
         requiredCols = ImmutableBitSet
             .fromBitSet(shuttle.varCols)
             .union(p.requiredColumns);

File: geode/src/test/java/org/apache/calcite/adapter/geode/rel/GeodeAllDataTypesTest.java
Patch:
@@ -323,11 +323,11 @@ public void testSqlWhereWithMultipleOrForAllFields() {
         .queryContains(
             GeodeAssertions.query("SELECT stringValue AS stringValue "
                 + "FROM /allDataTypesRegion WHERE "
-                + "stringValue IN SET('abc', 'def') OR floatValue IN SET(1.5678, null) OR dateValue "
+                + "stringValue IN SET('abc', 'def') OR floatValue = 1.5678 OR dateValue "
                 + "IN SET(DATE '2018-02-05', DATE '2018-02-06') OR timeValue "
                 + "IN SET(TIME '03:22:23', TIME '07:22:23') OR timestampValue "
                 + "IN SET(TIMESTAMP '2018-02-05 04:22:33', TIMESTAMP '2017-02-05 04:22:33') "
-                + "OR booleanValue IN SET(true, false, null)"));
+                + "OR booleanValue = true OR booleanValue = false"));
   }
 }
 

File: core/src/main/java/org/apache/calcite/rel/RelNode.java
Patch:
@@ -434,7 +434,8 @@ RelNode copy(
 
   /**
    * Accepts a visit from a shuttle. If the shuttle updates expression, then
-   * a copy of the relation should be created.
+   * a copy of the relation should be created. This new relation might have
+   * a different row-type.
    *
    * @param shuttle Shuttle
    * @return A copy of this node incorporating changes made by the shuttle to

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -135,6 +135,7 @@
     SqlTypeUtilTest.class,
     SqlValidatorUtilTest.class,
     TypeFinderTest.class,
+    RexShuttleTest.class,
 
     // medium tests (above 0.1s)
     SqlParserTest.class,

File: mongodb/src/test/java/org/apache/calcite/adapter/mongodb/MongoAdapterTest.java
Patch:
@@ -94,7 +94,7 @@ public static void setUp() throws Exception {
     // Manually insert data for data-time test.
     MongoCollection<BsonDocument> datatypes =  database.getCollection("datatypes")
         .withDocumentClass(BsonDocument.class);
-    if (datatypes.count() > 0) {
+    if (datatypes.countDocuments() > 0) {
       datatypes.deleteMany(new BsonDocument());
     }
 
@@ -112,7 +112,7 @@ private static void populate(MongoCollection<Document> collection, URL resource)
       throws IOException {
     Objects.requireNonNull(collection, "collection");
 
-    if (collection.count() > 0) {
+    if (collection.countDocuments() > 0) {
       // delete any existing documents (run from a clean set)
       collection.deleteMany(new BsonDocument());
     }

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -99,6 +99,9 @@ public interface CalciteResource {
   @Property(name = "SQLSTATE", value = "2202H")
   ExInst<CalciteException> invalidSampleSize();
 
+  @BaseMessage("Literal ''{0}'' can not be parsed to type ''{1}''")
+  ExInst<CalciteException> invalidLiteral(String a0, String a1);
+
   @BaseMessage("Unknown character set ''{0}''")
   ExInst<CalciteException> unknownCharacterSet(String a0);
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableCorrelate.java
Patch:
@@ -130,7 +130,7 @@ public Result implement(EnumerableRelImplementor implementor,
 
     builder.append(
         Expressions.call(leftExpression, BuiltInMethod.CORRELATE_JOIN.method,
-            Expressions.constant(joinType.toLinq4jCorrelateJoinType()),
+            Expressions.constant(EnumUtils.toLinq4jJoinType(joinType)),
             Expressions.lambda(corrBlock.toBlock(), corrArg),
             selector));
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java
Patch:
@@ -151,7 +151,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
                     physType,
                     ImmutableList.of(leftResult.physType,
                         rightResult.physType)),
-                Expressions.constant(joinType.toLinq4jJoinType())))
+                Expressions.constant(EnumUtils.toLinq4jJoinType(joinType))))
             .toBlock());
   }
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -30,7 +30,6 @@
 import org.apache.calcite.interpreter.Row;
 import org.apache.calcite.interpreter.Scalar;
 import org.apache.calcite.linq4j.AbstractEnumerable;
-import org.apache.calcite.linq4j.CorrelateJoinType;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.EnumerableDefaults;
 import org.apache.calcite.linq4j.Enumerator;
@@ -171,7 +170,7 @@ public enum BuiltInMethod {
   NESTED_LOOP_JOIN(EnumerableDefaults.class, "nestedLoopJoin", Enumerable.class,
       Enumerable.class, Predicate2.class, Function2.class, JoinType.class),
   CORRELATE_JOIN(ExtendedEnumerable.class, "correlateJoin",
-      CorrelateJoinType.class, Function1.class, Function2.class),
+      JoinType.class, Function1.class, Function2.class),
   SELECT(ExtendedEnumerable.class, "select", Function1.class),
   SELECT2(ExtendedEnumerable.class, "select", Function2.class),
   SELECT_MANY(ExtendedEnumerable.class, "selectMany", Function1.class),

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
Patch:
@@ -138,7 +138,7 @@ public static MutableRel createProject(final MutableRel child,
     }
     return MutableProject.of(
         RelOptUtil.permute(child.cluster.getTypeFactory(), rowType,
-            Mappings.bijection(posList)),
+            Mappings.bijection(posList).inverse()),
         child,
         new AbstractList<RexNode>() {
           public int size() {

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -101,7 +101,6 @@
 
 import org.hamcrest.Matcher;
 import org.hsqldb.jdbcDriver;
-import org.junit.Assume;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -1973,7 +1972,6 @@ private static List<Pair<String, String>> querify(String[] queries1) {
   }
 
   @Test public void testMultisetQueryWithSingleColumn() {
-    Assume.assumeTrue("[CALCITE-2776]", Bug.CALCITE_2776_FIXED);
     CalciteAssert.hr()
         .query("select multiset(\n"
             + "  select \"deptno\" from \"hr\".\"emps\") as a\n"

File: core/src/test/java/org/apache/calcite/test/QuidemTest.java
Patch:
@@ -85,8 +85,6 @@ private static Object getEnv(String varName) {
           return Bug.CALCITE_1045_FIXED;
         case "calcite1048":
           return Bug.CALCITE_1048_FIXED;
-        case "calcite2776":
-          return Bug.CALCITE_2776_FIXED;
         }
         return null;
       };

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableRepeatUnionHierarchyTest.java
Patch:
@@ -25,6 +25,8 @@
 import org.apache.calcite.test.HierarchySchema;
 import org.apache.calcite.tools.RelBuilder;
 
+import net.jcip.annotations.NotThreadSafe;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -39,6 +41,7 @@
  * Add algebraic operators to allow expressing recursive queries</a>.
  */
 @RunWith(Parameterized.class)
+@NotThreadSafe
 public class EnumerableRepeatUnionHierarchyTest {
 
   // Tests for the following hierarchy:

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
Patch:
@@ -85,13 +85,13 @@ class EnumerableMergeJoinRule extends ConverterRule {
     final RelOptCluster cluster = join.getCluster();
     RelNode newRel;
     try {
-      RelTraitSet traits = join.getTraitSet()
+      RelTraitSet traitSet = join.getTraitSet()
           .replace(EnumerableConvention.INSTANCE);
       if (!collations.isEmpty()) {
-        traits = traits.replace(collations);
+        traitSet = traitSet.replace(collations);
       }
       newRel = new EnumerableMergeJoin(cluster,
-          traits,
+          traitSet,
           left,
           right,
           info.getEquiCondition(left, right, cluster.getRexBuilder()),

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRules.java
Patch:
@@ -44,7 +44,9 @@ private EnumerableRules() {
   public static final RelOptRule ENUMERABLE_MERGE_JOIN_RULE =
       new EnumerableMergeJoinRule();
 
-  @Deprecated // To be removed before 2.0, use ENUMERABLE_JOIN_RULE instead.
+  /** @deprecated To be removed along with {@link SemiJoin};
+   * use {@link #ENUMERABLE_JOIN_RULE} */
+  @Deprecated // to be removed before 1.21
   public static final RelOptRule ENUMERABLE_SEMI_JOIN_RULE =
       new EnumerableSemiJoinRule();
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -2613,9 +2613,9 @@ public Expression implement(
       if (op == CURRENT_USER
           || op == SESSION_USER
           || op == USER) {
-        return Expressions.constant("sa");
+        return Expressions.call(BuiltInMethod.USER.method, root);
       } else if (op == SYSTEM_USER) {
-        return Expressions.constant(System.getProperty("user.name"));
+        return Expressions.call(BuiltInMethod.SYSTEM_USER.method, root);
       } else if (op == CURRENT_PATH
           || op == CURRENT_ROLE
           || op == CURRENT_CATALOG) {

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -413,6 +413,8 @@ public enum BuiltInMethod {
   LOCAL_TIMESTAMP(SqlFunctions.class, "localTimestamp", DataContext.class),
   LOCAL_TIME(SqlFunctions.class, "localTime", DataContext.class),
   TIME_ZONE(SqlFunctions.class, "timeZone", DataContext.class),
+  USER(SqlFunctions.class, "user", DataContext.class),
+  SYSTEM_USER(SqlFunctions.class, "systemUser", DataContext.class),
   BOOLEAN_TO_STRING(SqlFunctions.class, "toString", boolean.class),
   JDBC_ARRAY_TO_LIST(SqlFunctions.class, "arrayToList", java.sql.Array.class),
   OBJECT_TO_STRING(Object.class, "toString"),

File: core/src/main/java/org/apache/calcite/sql/SqlUtil.java
Patch:
@@ -692,7 +692,7 @@ public static SqlNode getSelectListItem(SqlNode query, int i) {
     case SELECT:
       SqlSelect select = (SqlSelect) query;
       final SqlNode from = stripAs(select.getFrom());
-      if (from.getKind() == SqlKind.VALUES) {
+      if (from != null && from.getKind() == SqlKind.VALUES) {
         // They wrote "VALUES (x, y)", but the validator has
         // converted this into "SELECT * FROM VALUES (x, y)".
         return getSelectListItem(from, i);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
Patch:
@@ -37,7 +37,7 @@
  * {@link org.apache.calcite.rel.logical.LogicalJoin} relational expression
  * {@link EnumerableConvention enumerable calling convention}.
  *
- * @see org.apache.calcite.adapter.enumerable.EnumerableJoinRule
+ * @see EnumerableJoinRule
  */
 class EnumerableMergeJoinRule extends ConverterRule {
   EnumerableMergeJoinRule() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRules.java
Patch:
@@ -37,6 +37,7 @@ public class EnumerableRules {
   public static final RelOptRule ENUMERABLE_MERGE_JOIN_RULE =
       new EnumerableMergeJoinRule();
 
+  @Deprecated // To be removed before 2.0, use ENUMERABLE_JOIN_RULE instead.
   public static final RelOptRule ENUMERABLE_SEMI_JOIN_RULE =
       new EnumerableSemiJoinRule();
 

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -25,7 +25,6 @@
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.AggregateCall;
-import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.logical.LogicalJoin;
 import org.apache.calcite.rel.logical.LogicalProject;
@@ -176,8 +175,8 @@ private static boolean populate(List<RelNode> nodes, List<int[][]> tempLinks,
     }
     if (rel instanceof LogicalJoin) {
       LogicalJoin join = (LogicalJoin) rel;
-      if (join.getJoinType() != JoinRelType.INNER) {
-        throw new RuntimeException("only inner join allowed, but got "
+      if (join.getJoinType().isOuterJoin()) {
+        throw new RuntimeException("only non nulls-generating join allowed, but got "
             + join.getJoinType());
       }
       populate(nodes, tempLinks, join.getLeft());

File: core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.adapter.enumerable.EnumerableAggregate;
 import org.apache.calcite.adapter.enumerable.EnumerableFilter;
-import org.apache.calcite.adapter.enumerable.EnumerableJoin;
+import org.apache.calcite.adapter.enumerable.EnumerableHashJoin;
 import org.apache.calcite.adapter.enumerable.EnumerableProject;
 import org.apache.calcite.adapter.enumerable.EnumerableTableScan;
 import org.apache.calcite.config.CalciteSystemProperty;
@@ -142,7 +142,7 @@ public class JaninoRelMetadataProvider implements RelMetadataProvider {
             EnumerableAggregate.class,
             EnumerableFilter.class,
             EnumerableProject.class,
-            EnumerableJoin.class,
+            EnumerableHashJoin.class,
             EnumerableTableScan.class));
   }
 

File: core/src/main/java/org/apache/calcite/rel/rules/FilterCorrelateRule.java
Patch:
@@ -27,7 +27,6 @@
 import org.apache.calcite.rex.RexBuilder;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexUtil;
-import org.apache.calcite.sql.SemiJoinType;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 
@@ -88,7 +87,7 @@ public void onMatch(RelOptRuleCall call) {
         JoinRelType.INNER,
         false,
         true,
-        corr.getJoinType() == SemiJoinType.INNER,
+        corr.getJoinType() == JoinRelType.INNER,
         aboveFilters,
         leftFilters,
         rightFilters);

File: core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
Patch:
@@ -281,7 +281,7 @@ public void onMatch(RelOptRuleCall call) {
     int[] adjustments = new int[nJoinFields];
     for (int i = 0; i < nProjExprs; i++) {
       RexNode newExpr = mergedProgram.expandLocalRef(projList.get(i));
-      if (joinType != JoinRelType.INNER) {
+      if (joinType.isOuterJoin()) {
         newExpr =
             newExpr.accept(
                 new RelOptUtil.RexInputConverter(
@@ -299,7 +299,7 @@ public void onMatch(RelOptRuleCall call) {
     relBuilder.project(newProjExprs, joinRel.getRowType().getFieldNames());
     // if the join was outer, we might need a cast after the
     // projection to fix differences wrt nullability of fields
-    if (joinType != JoinRelType.INNER) {
+    if (joinType.isOuterJoin()) {
       relBuilder.convert(joinRel.getRowType(), false);
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
Patch:
@@ -268,7 +268,7 @@ public RexNode getPostJoinFilter() {
 
   boolean containsOuter() {
     for (JoinRelType joinType : joinTypes) {
-      if (joinType != JoinRelType.INNER) {
+      if (joinType.isOuterJoin()) {
         return true;
       }
     }

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinTransposeRule.java
Patch:
@@ -23,7 +23,6 @@
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.core.RelFactories;
-import org.apache.calcite.rel.core.SemiJoin;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rex.RexCall;
 import org.apache.calcite.rex.RexNode;
@@ -77,7 +76,7 @@ public void onMatch(RelOptRuleCall call) {
     Project origProj = call.rel(0);
     final Join join = call.rel(1);
 
-    if (join instanceof SemiJoin) {
+    if (join.isSemiJoin()) {
       return; // TODO: support SemiJoin
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -26,7 +26,6 @@
 import org.apache.calcite.rel.RelFieldCollation;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Calc;
-import org.apache.calcite.rel.core.EquiJoin;
 import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinInfo;
@@ -347,7 +346,7 @@ public JoinReduceExpressionsRule(Class<? extends Join> joinClass,
           matchNullability)) {
         return;
       }
-      if (join instanceof EquiJoin) {
+      if (RelOptUtil.forceEquiJoin(join)) {
         final JoinInfo joinInfo =
             JoinInfo.of(join.getLeft(), join.getRight(), expList.get(0));
         if (!joinInfo.isEqui()) {

File: core/src/main/java/org/apache/calcite/sql/SemiJoinType.java
Patch:
@@ -25,7 +25,10 @@
 /**
  * Enumeration representing different join types used in correlation
  * relations.
+ *
+ * @deprecated Use {@link JoinRelType} instead.
  */
+@Deprecated // To be removed before 2.0
 public enum SemiJoinType {
   /**
    * Inner join.

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -95,7 +95,6 @@
 import org.apache.calcite.schema.Wrapper;
 import org.apache.calcite.sql.JoinConditionType;
 import org.apache.calcite.sql.JoinType;
-import org.apache.calcite.sql.SemiJoinType;
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.SqlBasicCall;
 import org.apache.calcite.sql.SqlCall;
@@ -2498,7 +2497,7 @@ protected RelNode createJoin(
       }
 
       LogicalCorrelate corr = LogicalCorrelate.create(leftRel, innerRel,
-          p.id, requiredCols, SemiJoinType.of(joinType));
+          p.id, requiredCols, joinType);
       return corr;
     }
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -157,15 +157,15 @@ public enum BuiltInMethod {
       ResultSetEnumerable.PreparedStatementEnricher.class),
   CREATE_ENRICHER(ResultSetEnumerable.class, "createEnricher", Integer[].class,
       DataContext.class),
-  JOIN(ExtendedEnumerable.class, "join", Enumerable.class, Function1.class,
+  HASH_JOIN(ExtendedEnumerable.class, "hashJoin", Enumerable.class, Function1.class,
       Function1.class, Function2.class),
   MERGE_JOIN(EnumerableDefaults.class, "mergeJoin", Enumerable.class,
       Enumerable.class, Function1.class, Function1.class, Function2.class,
       boolean.class, boolean.class),
   SLICE0(Enumerables.class, "slice0", Enumerable.class),
   SEMI_JOIN(EnumerableDefaults.class, "semiJoin", Enumerable.class,
       Enumerable.class, Function1.class, Function1.class),
-  THETA_JOIN(EnumerableDefaults.class, "thetaJoin", Enumerable.class,
+  NESTED_LOOP_JOIN(EnumerableDefaults.class, "nestedLoopJoin", Enumerable.class,
       Enumerable.class, Predicate2.class, Function2.class, boolean.class,
       boolean.class),
   CORRELATE_JOIN(ExtendedEnumerable.class, "correlateJoin",

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -52,7 +52,7 @@ public class JdbcAdapterTest {
     final String sql = "select * from \"days\", (values 1, 2) as t(c)";
     final String explain = "PLAN="
         + "EnumerableCalc(expr#0..2=[{inputs}], day=[$t1], week_day=[$t2], C=[$t0])\n"
-        + "  EnumerableJoin(condition=[true], joinType=[inner])\n"
+        + "  EnumerableHashJoin(condition=[true], joinType=[inner])\n"
         + "    EnumerableValues(tuples=[[{ 1 }, { 2 }]])\n"
         + "    JdbcToEnumerableConverter\n"
         + "      JdbcTableScan(table=[[foodmart, days]])";
@@ -291,7 +291,7 @@ public class JdbcAdapterTest {
     CalciteAssert.model(JdbcTest.SCOTT_MODEL)
         .query("select empno, ename, d.deptno, dname \n"
             + "from scott.emp e,scott.dept d")
-        .explainContains("PLAN=EnumerableJoin(condition=[true], "
+        .explainContains("PLAN=EnumerableHashJoin(condition=[true], "
             + "joinType=[inner])\n"
             + "  JdbcToEnumerableConverter\n"
             + "    JdbcProject(EMPNO=[$0], ENAME=[$1])\n"

File: core/src/test/java/org/apache/calcite/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -124,7 +124,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
             + "  on s.\"customer_id\" - c.\"customer_id\" = 0)")
         .explainContains("EnumerableAggregate(group=[{}], EXPR$0=[COUNT()])\n"
             + "  EnumerableCalc(expr#0..1=[{inputs}], expr#2=[0], expr#3=[-($t0, $t1)], expr#4=[=($t3, $t2)], DUMMY=[$t2], $condition=[$t4])\n"
-            + "    EnumerableJoin(condition=[true], joinType=[inner])\n"
+            + "    EnumerableHashJoin(condition=[true], joinType=[inner])\n"
             + "      JdbcToEnumerableConverter\n"
             + "        JdbcProject(customer_id=[$2])\n"
             + "          JdbcTableScan(table=[[foodmart, sales_fact_1997]])\n"
@@ -270,7 +270,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
         .query(
             "select \"store\".\"store_country\" as \"c0\", sum(\"inventory_fact_1997\".\"supply_time\") as \"m0\" from \"store\" as \"store\", \"inventory_fact_1997\" as \"inventory_fact_1997\" where \"inventory_fact_1997\".\"store_id\" = \"store\".\"store_id\" group by \"store\".\"store_country\"")
         .planContains(
-            " left.join(right, new org.apache.calcite.linq4j.function.Function1() {\n");
+            " left.hashJoin(right, new org.apache.calcite.linq4j.function.Function1() {\n");
   }
 }
 

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -312,7 +312,7 @@ private static CalciteAssert.AssertThat modelWithLattices(
         "select 1 from \"foodmart\".\"sales_fact_1997\" as s\n"
         + "join \"foodmart\".\"product\" as p using (\"product_id\")\n"
         + "left join \"foodmart\".\"time_by_day\" as t on s.\"product_id\" = p.\"product_id\"")
-        .connectThrows("only inner join allowed, but got LEFT");
+        .connectThrows("only non nulls-generating join allowed, but got LEFT");
   }
 
   /** Each lattice table must have a parent. */

File: core/src/test/java/org/apache/calcite/test/MultiJdbcSchemaJoinTest.java
Patch:
@@ -145,7 +145,7 @@ private Connection setup() throws SQLException {
     return connection;
   }
 
-  @Test public void testJdbcWithEnumerableJoin() throws SQLException {
+  @Test public void testJdbcWithEnumerableHashJoin() throws SQLException {
     // This query works correctly
     String query = "select t.id, t.field1 "
         + "from db.table1 t join \"hr\".\"emps\" e on e.\"empid\" = t.id";
@@ -154,7 +154,7 @@ private Connection setup() throws SQLException {
   }
 
   @Test public void testEnumerableWithJdbcJoin() throws SQLException {
-    //  * compared to testJdbcWithEnumerableJoin, the join order is reversed
+    //  * compared to testJdbcWithEnumerableHashJoin, the join order is reversed
     //  * the query fails with a CannotPlanException
     String query = "select t.id, t.field1 "
         + "from \"hr\".\"emps\" e join db.table1 t on e.\"empid\" = t.id";

File: core/src/test/java/org/apache/calcite/test/MutableRelTest.java
Patch:
@@ -136,7 +136,7 @@ public class MutableRelTest {
         + "  where emp.deptno = dept.deptno\n"
         + "  and emp.sal > 100)";
     checkConvertMutableRel(
-        "SemiJoin",
+        "Join", // with join type as semi
         sql,
         true,
         ImmutableList.of(

File: core/src/test/java/org/apache/calcite/test/RelMdPercentageOriginalRowsTest.java
Patch:
@@ -38,7 +38,7 @@ public class RelMdPercentageOriginalRowsTest {
                             + " select e.deptno from emps e where exists (select 1 from depts d where d.deptno=e.deptno)\n"
                             + " union select e.deptno from emps e where e.salary > 10000) ")
             .explainMatches("including all attributes ",
-                    CalciteAssert.checkResultContains("EnumerableSemiJoin"));
+                    CalciteAssert.checkResultContains("EnumerableCorrelate"));
   }
 }
 

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -42,7 +42,6 @@
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rel.core.Minus;
 import org.apache.calcite.rel.core.Project;
-import org.apache.calcite.rel.core.SemiJoin;
 import org.apache.calcite.rel.core.Sort;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.core.Union;
@@ -1436,7 +1435,7 @@ private void checkPredicates(RelOptCluster cluster, RelOptTable empTable,
     relBuilder.semiJoin(
         relBuilder.equals(relBuilder.field(2, 0, "DEPTNO"),
             relBuilder.field(2, 1, "DEPTNO")));
-    final SemiJoin semiJoin = (SemiJoin) relBuilder.build();
+    final LogicalJoin semiJoin = (LogicalJoin) relBuilder.build();
 
     predicates = mq.getPulledUpPredicates(semiJoin);
     assertThat(predicates.pulledUpPredicates, sortsAs("[=($0, 1)]"));

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -129,7 +129,6 @@
 import org.apache.calcite.rex.RexCall;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.runtime.Hook;
-import org.apache.calcite.sql.SemiJoinType;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlOperator;
@@ -1283,7 +1282,7 @@ private void basePushFilterPastAggWithGroupingSets(boolean unchanged)
         .build();
     LogicalCorrelate correlate = new LogicalCorrelate(left.getCluster(),
         left.getTraitSet(), left, right, correlationId,
-        ImmutableBitSet.of(0), SemiJoinType.SEMI);
+        ImmutableBitSet.of(0), JoinRelType.SEMI);
 
     relBuilder.push(correlate);
     RelNode relNode = relBuilder.project(relBuilder.field(0))
@@ -1320,7 +1319,7 @@ private void basePushFilterPastAggWithGroupingSets(boolean unchanged)
             relBuilder.getRexBuilder().makeFieldAccess(rexCorrel, 0)).build();
     LogicalCorrelate correlate = new LogicalCorrelate(left.getCluster(),
         left.getTraitSet(), left, right, correlationId,
-        ImmutableBitSet.of(0), SemiJoinType.ANTI);
+        ImmutableBitSet.of(0), JoinRelType.ANTI);
 
     relBuilder.push(correlate);
     RelNode relNode = relBuilder.project(relBuilder.field(0))

File: core/src/test/java/org/apache/calcite/test/StreamTest.java
Patch:
@@ -284,7 +284,7 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz
             + "      LogicalTableScan(table=[[STREAM_JOINS, PRODUCTS]])\n")
         .explainContains(""
             + "EnumerableCalc(expr#0..6=[{inputs}], proj#0..1=[{exprs}], SUPPLIERID=[$t6])\n"
-            + "  EnumerableJoin(condition=[=($4, $5)], joinType=[inner])\n"
+            + "  EnumerableHashJoin(condition=[=($4, $5)], joinType=[inner])\n"
             + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) NOT NULL], proj#0..4=[{exprs}])\n"
             + "      EnumerableInterpreter\n"
             + "        BindableTableScan(table=[[STREAM_JOINS, ORDERS, (STREAM)]])\n"

File: geode/src/test/java/org/apache/calcite/adapter/geode/rel/GeodeZipsTest.java
Patch:
@@ -148,7 +148,7 @@ public void testJoin() {
         .returnsCount(1)
         .explainContains("PLAN=EnumerableCalc(expr#0..2=[{inputs}], _id1=[$t0])\n"
             + "  EnumerableLimit(fetch=[1])\n"
-            + "    EnumerableJoin(condition=[=($1, $2)], joinType=[inner])\n"
+            + "    EnumerableHashJoin(condition=[=($1, $2)], joinType=[inner])\n"
             + "      GeodeToEnumerableConverter\n"
             + "        GeodeProject(_id=[$0], _id0=[CAST($0):VARCHAR CHARACTER SET "
             + "\"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\"])\n"

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableQueryable.java
Patch:
@@ -335,7 +335,7 @@ public <TInner, TKey, TResult> Queryable<TResult> join(
       FunctionExpression<Function1<T, TKey>> outerKeySelector,
       FunctionExpression<Function1<TInner, TKey>> innerKeySelector,
       FunctionExpression<Function2<T, TInner, TResult>> resultSelector) {
-    return EnumerableDefaults.join(getThis(), inner,
+    return EnumerableDefaults.hashJoin(getThis(), inner,
         outerKeySelector.getFunction(), innerKeySelector.getFunction(),
         resultSelector.getFunction()).asQueryable();
   }
@@ -346,7 +346,7 @@ public <TInner, TKey, TResult> Queryable<TResult> join(
       FunctionExpression<Function1<TInner, TKey>> innerKeySelector,
       FunctionExpression<Function2<T, TInner, TResult>> resultSelector,
       EqualityComparer<TKey> comparer) {
-    return EnumerableDefaults.join(getThis(), inner,
+    return EnumerableDefaults.hashJoin(getThis(), inner,
         outerKeySelector.getFunction(), innerKeySelector.getFunction(),
         resultSelector.getFunction(), comparer).asQueryable();
   }

File: linq4j/src/main/java/org/apache/calcite/linq4j/ExtendedEnumerable.java
Patch:
@@ -494,7 +494,7 @@ Enumerable<TSource> intersect(Enumerable<TSource> enumerable1,
    * matching keys. The default equality comparer is used to compare
    * keys.
    */
-  <TInner, TKey, TResult> Enumerable<TResult> join(Enumerable<TInner> inner,
+  <TInner, TKey, TResult> Enumerable<TResult> hashJoin(Enumerable<TInner> inner,
       Function1<TSource, TKey> outerKeySelector,
       Function1<TInner, TKey> innerKeySelector,
       Function2<TSource, TInner, TResult> resultSelector);
@@ -504,7 +504,7 @@ <TInner, TKey, TResult> Enumerable<TResult> join(Enumerable<TInner> inner,
    * matching keys. A specified {@code EqualityComparer<TSource>} is used to
    * compare keys.
    */
-  <TInner, TKey, TResult> Enumerable<TResult> join(Enumerable<TInner> inner,
+  <TInner, TKey, TResult> Enumerable<TResult> hashJoin(Enumerable<TInner> inner,
       Function1<TSource, TKey> outerKeySelector,
       Function1<TInner, TKey> innerKeySelector,
       Function2<TSource, TInner, TResult> resultSelector,
@@ -530,7 +530,7 @@ <TInner, TKey, TResult> Enumerable<TResult> join(Enumerable<TInner> inner,
    *   <tr><td>FULL</td><td>true</td><td>true</td></tr>
    * </table>
    */
-  <TInner, TKey, TResult> Enumerable<TResult> join(Enumerable<TInner> inner,
+  <TInner, TKey, TResult> Enumerable<TResult> hashJoin(Enumerable<TInner> inner,
       Function1<TSource, TKey> outerKeySelector,
       Function1<TInner, TKey> innerKeySelector,
       Function2<TSource, TInner, TResult> resultSelector,

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigTableScan.java
Patch:
@@ -81,7 +81,7 @@ private String getConcatenatedFieldNameAndTypeForPigSchema(Implementor implement
     // Don't move Aggregates around, otherwise PigAggregate.implement() won't
     // know how to correctly procuce Pig Latin
     planner.removeRule(AggregateExpandDistinctAggregatesRule.INSTANCE);
-    // Make sure planner picks PigJoin over EnumerableJoin. Should there be
+    // Make sure planner picks PigJoin over EnumerableHashJoin. Should there be
     // a rule for this instead for removing ENUMERABLE_JOIN_RULE here?
     planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);
   }

File: spark/src/test/java/org/apache/calcite/test/SparkAdapterTest.java
Patch:
@@ -376,7 +376,7 @@ private CalciteAssert.AssertQuery sql(String sql) {
 
     final String plan = "PLAN="
         + "EnumerableCalc(expr#0..3=[{inputs}], Y=[$t3], Z=[$t1])\n"
-        + "  EnumerableJoin(condition=[=($0, $2)], joinType=[inner])\n"
+        + "  EnumerableHashJoin(condition=[=($0, $2)], joinType=[inner])\n"
         + "    EnumerableValues(tuples=[[{ 1, 'a' }, { 2, 'b' }]])\n"
         + "    EnumerableValues(tuples=[[{ 1, 'a' }, { 2, 'b' }, { 1, 'b' }, { 2, 'c' }, { 2, 'c' }]])\n\n";
 
@@ -399,7 +399,7 @@ private CalciteAssert.AssertQuery sql(String sql) {
 
     final String plan = "PLAN="
         + "EnumerableCalc(expr#0..3=[{inputs}], Z=[$t1])\n"
-        + "  EnumerableJoin(condition=[=($0, $2)], joinType=[inner])\n"
+        + "  EnumerableHashJoin(condition=[=($0, $2)], joinType=[inner])\n"
         + "    EnumerableValues(tuples=[[{ 1, 'a' }, { 2, 'b' }]])\n"
         + "    EnumerableValues(tuples=[[{ 1, 'a' }, { 2, 'b' }, { 1, 'b' }, { 2, 'c' }, { 2, 'c' }]])\n\n";
 

File: ubenchmark/src/main/java/org/apache/calcite/benchmarks/AbstractRelNodeGetRelTypeNameBenchmark.java
Patch:
@@ -76,9 +76,9 @@ public static class ClassNameState {
         "org.apache.calcite.adapter.enumerable.EnumerableProject",
         "org.apache.calcite.adapter.enumerable.EnumerableFilter",
         "org.apache.calcite.adapter.jdbc.JdbcToEnumerableConverter",
-        "org.apache.calcite.adapter.enumerable.EnumerableThetaJoin",
+        "org.apache.calcite.adapter.enumerable.EnumerableNestedLoopJoin",
         "org.apache.calcite.adapter.enumerable.EnumerableTableScan",
-        "org.apache.calcite.adapter.enumerable.EnumerableJoin",
+        "org.apache.calcite.adapter.enumerable.EnumerableHashJoin",
         "org.apache.calcite.adapter.enumerable.EnumerableTableModify",
         "org.apache.calcite.adapter.enumerable.EnumerableAggregate",
         "org.apache.calcite.adapter.enumerable.EnumerableCorrelate",

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
Patch:
@@ -68,7 +68,7 @@ private void unparseKeyword(SqlWriter writer, SqlCall call, String keyword) {
     writer.keyword(keyword);
   }
 
-  private static void unparseCube(SqlWriter writer, SqlCall call) {
+  private void unparseCube(SqlWriter writer, SqlCall call) {
     writer.keyword(call.getOperator().getName());
     final SqlWriter.Frame frame =
         writer.startList(SqlWriter.FrameTypeEnum.FUN_CALL, "(", ")");

File: core/src/main/java/org/apache/calcite/plan/RelOptNode.java
Patch:
@@ -34,8 +34,8 @@ public interface RelOptNode {
 
   /**
    * Returns a string which concisely describes the definition of this
-   * relational expression. Two relational expressions are equivalent if and
-   * only if their digests are the same.
+   * relational expression. Two relational expressions are equivalent if
+   * their digests and {@link #getRowType()} are the same.
    *
    * <p>The digest does not contain the relational expression's identity --
    * that would prevent similar relational expressions from ever comparing

File: core/src/main/java/org/apache/calcite/rel/rules/CalcMergeRule.java
Patch:
@@ -85,7 +85,8 @@ public void onMatch(RelOptRuleCall call) {
             bottomCalc.getInput(),
             mergedProgram);
 
-    if (newCalc.getDigest().equals(bottomCalc.getDigest())) {
+    if (newCalc.getDigest().equals(bottomCalc.getDigest())
+        && newCalc.getRowType().equals(bottomCalc.getRowType())) {
       // newCalc is equivalent to bottomCalc, which means that topCalc
       // must be trivial. Take it out of the game.
       call.getPlanner().setImportance(topCalc, 0.0);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -97,6 +97,7 @@
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.JSON_LENGTH;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.JSON_PRETTY;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.JSON_REMOVE;
+import static org.apache.calcite.sql.fun.SqlLibraryOperators.JSON_STORAGE_SIZE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.JSON_TYPE;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.REPEAT;
 import static org.apache.calcite.sql.fun.SqlLibraryOperators.REVERSE;
@@ -474,6 +475,7 @@ public Expression implement(RexToLixTranslator translator,
     defineMethod(JSON_PRETTY, BuiltInMethod.JSON_PRETTY.method, NullPolicy.ARG0);
     defineMethod(JSON_LENGTH, BuiltInMethod.JSON_LENGTH.method, NullPolicy.ARG0);
     defineMethod(JSON_REMOVE, BuiltInMethod.JSON_REMOVE.method, NullPolicy.ARG0);
+    defineMethod(JSON_STORAGE_SIZE, BuiltInMethod.JSON_STORAGE_SIZE.method, NullPolicy.ARG0);
     defineMethod(JSON_OBJECT, BuiltInMethod.JSON_OBJECT.method, NullPolicy.NONE);
     defineMethod(JSON_ARRAY, BuiltInMethod.JSON_ARRAY.method, NullPolicy.NONE);
     aggMap.put(JSON_OBJECTAGG.with(SqlJsonConstructorNullClause.ABSENT_ON_NULL),

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -885,6 +885,9 @@ ExInst<CalciteException> invalidTypesForComparison(String clazzName0, String op,
 
   @BaseMessage("Invalid input for JSON_REMOVE: document: ''{0}'', jsonpath expressions: ''{1}''")
   ExInst<CalciteException> invalidInputForJsonRemove(String value, String pathSpecs);
+
+  @BaseMessage("Not a valid input for JSON_STORAGE_SIZE: ''{0}''")
+  ExInst<CalciteException> invalidInputForJsonStorageSize(String value);
 }
 
 // End CalciteResource.java

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
Patch:
@@ -150,6 +150,9 @@ private SqlLibraryOperators() {
   @LibraryOperator(libraries = {MYSQL})
   public static final SqlFunction JSON_REMOVE = new SqlJsonRemoveFunction();
 
+  @LibraryOperator(libraries = {MYSQL})
+  public static final SqlFunction JSON_STORAGE_SIZE = new SqlJsonStorageSizeFunction();
+
   @LibraryOperator(libraries = {MYSQL, POSTGRESQL})
   public static final SqlFunction REPEAT =
       new SqlFunction(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1330,6 +1330,9 @@ public boolean argumentMustBeScalar(int ordinal) {
   @Deprecated // to be removed before 2.0
   public static final SqlFunction JSON_REMOVE = SqlLibraryOperators.JSON_REMOVE;
 
+  @Deprecated // to be removed before 2.0
+  public static final SqlFunction JSON_STORAGE_SIZE = SqlLibraryOperators.JSON_STORAGE_SIZE;
+
   public static final SqlJsonArrayAggAggFunction JSON_ARRAYAGG =
       new SqlJsonArrayAggAggFunction(SqlKind.JSON_ARRAYAGG,
           SqlJsonConstructorNullClause.ABSENT_ON_NULL);

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -297,6 +297,7 @@ public enum BuiltInMethod {
   JSON_PRETTY(JsonFunctions.class, "jsonPretty", String.class),
   JSON_LENGTH(JsonFunctions.class, "jsonLength", String.class),
   JSON_REMOVE(JsonFunctions.class, "jsonRemove", String.class),
+  JSON_STORAGE_SIZE(JsonFunctions.class, "jsonStorageSize", String.class),
   JSON_OBJECTAGG_ADD(JsonFunctions.class, "jsonObjectAggAdd", Map.class,
       String.class, Object.class, SqlJsonConstructorNullClause.class),
   JSON_ARRAY(JsonFunctions.class, "jsonArray",

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -5475,7 +5475,7 @@ private Sql checkSubQuery(String sql) {
   @Test public void testPushProjectWithIsNotDistinctFromPastJoin() {
     checkPlanning(ProjectJoinTransposeRule.INSTANCE,
         "select e.sal + b.comm from emp e inner join bonus b "
-            + "on e.ename IS NOT DISTINCT FROM b.ename and e.deptno = 10");
+            + "on (e.ename || e.job) IS NOT DISTINCT FROM (b.ename || b.job) and e.deptno = 10");
   }
 }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -257,8 +257,10 @@ public void onMatch(RelOptRuleCall call) {
               final int index = ((RexInputRef) singleton).getIndex();
               if (!belowAggregateKey.get(index)) {
                 projects.add(singleton);
+                side.split.put(aggCall.i, projects.size() - 1);
+              } else {
+                side.split.put(aggCall.i, index);
               }
-              side.split.put(aggCall.i, index);
             } else {
               projects.add(singleton);
               side.split.put(aggCall.i, projects.size() - 1);

File: core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
Patch:
@@ -231,7 +231,7 @@ public void unparse(
 
       if (charSetName != null) {
         writer.keyword("CHARACTER SET");
-        writer.identifier(charSetName);
+        writer.identifier(charSetName, false);
       }
 
       if (collectionsTypeName != null) {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -190,7 +190,7 @@ public void unparse(
       }
     }
     if (collation != null) {
-      collation.unparse(writer, 0, 0);
+      collation.unparse(writer);
     }
     writer.endList(frame);
   }

File: core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
Patch:
@@ -43,6 +43,9 @@ public class SqlParserPos implements Serializable {
    */
   public static final SqlParserPos ZERO = new SqlParserPos(0, 0);
 
+  /** Same as {@link #ZERO} but always quoted. **/
+  public static final SqlParserPos QUOTED_ZERO = new QuotedParserPos(0, 0, 0, 0);
+
   private static final long serialVersionUID = 1L;
 
   //~ Instance fields --------------------------------------------------------

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -1234,9 +1234,8 @@ public void _testLikeAndSimilarFails() {
           "(?s).*Encountered \"FROM\" at .*");
 
       // Without the "FROM" noise word, TRIM is parsed as a regular
-      // function, not as a built-in. So we can parse with and without
-      // quoting.
-      checkExpType("\"TRIM\"('b')", "VARCHAR(1) NOT NULL");
+      // function without quoting and built-in function with quoting.
+      checkExpType("\"TRIM\"('b', 'FROM', 'a')", "VARCHAR(1) NOT NULL");
       checkExpType("TRIM('b')", "VARCHAR(1) NOT NULL");
     }
   }

File: server/src/main/java/org/apache/calcite/sql/ddl/SqlAttributeDefinition.java
Patch:
@@ -67,7 +67,7 @@ public class SqlAttributeDefinition extends SqlCall {
     dataType.unparse(writer, 0, 0);
     if (collation != null) {
       writer.keyword("COLLATE");
-      collation.unparse(writer, 0, 0);
+      collation.unparse(writer);
     }
     if (dataType.getNullable() != null && !dataType.getNullable()) {
       writer.keyword("NOT NULL");

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -500,10 +500,10 @@ public SqlNode toSql(RexProgram program, RexNode rex) {
         case NUMERIC:
         case EXACT_NUMERIC:
           return SqlLiteral.createExactNumeric(
-              literal.getValueAs(BigDecimal.class).toString(), POS);
+              literal.getValueAs(BigDecimal.class).toPlainString(), POS);
         case APPROXIMATE_NUMERIC:
           return SqlLiteral.createApproxNumeric(
-              literal.getValueAs(BigDecimal.class).toString(), POS);
+              literal.getValueAs(BigDecimal.class).toPlainString(), POS);
         case BOOLEAN:
           return SqlLiteral.createBoolean(literal.getValueAs(Boolean.class),
               POS);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/NullPolicy.java
Patch:
@@ -31,6 +31,8 @@ public enum NullPolicy {
   SEMI_STRICT,
   /** If any of the arguments are null, return null. */
   ANY,
+  /** If the first argument is null, return null. */
+  ARG0,
   /** If any of the arguments are false, result is false; else if any
    * arguments are null, result is null; else true. */
   AND,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonKeysFunction.java
Patch:
@@ -22,14 +22,15 @@
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlTypeFamily;
+import org.apache.calcite.sql.type.SqlTypeTransforms;
 
 /**
  * The <code>JSON_KEYS</code> function.
  */
 public class SqlJsonKeysFunction extends SqlFunction {
   public SqlJsonKeysFunction() {
     super("JSON_KEYS", SqlKind.OTHER_FUNCTION,
-          ReturnTypes.VARCHAR_2000,
+          ReturnTypes.cascade(ReturnTypes.VARCHAR_2000, SqlTypeTransforms.FORCE_NULLABLE),
           null,
           OperandTypes.or(OperandTypes.ANY,
               OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.CHARACTER)),

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonPrettyFunction.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlOperandCountRanges;
 import org.apache.calcite.sql.type.SqlOperandTypeChecker;
+import org.apache.calcite.sql.type.SqlTypeTransforms;
 import org.apache.calcite.sql.validate.SqlValidator;
 
 /**
@@ -38,7 +39,7 @@ public class SqlJsonPrettyFunction extends SqlFunction {
   public SqlJsonPrettyFunction() {
     super("JSON_PRETTY",
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.VARCHAR_2000,
+        ReturnTypes.cascade(ReturnTypes.VARCHAR_2000, SqlTypeTransforms.FORCE_NULLABLE),
         null,
         OperandTypes.ANY,
         SqlFunctionCategory.SYSTEM);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1294,9 +1294,6 @@ public boolean argumentMustBeScalar(int ordinal) {
 
   public static final SqlThrowOperator THROW = new SqlThrowOperator();
 
-  public static final SqlJsonApiCommonSyntaxOperator JSON_API_COMMON_SYNTAX =
-      new SqlJsonApiCommonSyntaxOperator("JSON_API_COMMON_SYNTAX");
-
   public static final SqlFunction JSON_EXISTS = new SqlJsonExistsFunction();
 
   public static final SqlFunction JSON_VALUE =

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.apache.calcite.TestKtTest;
 import org.apache.calcite.adapter.clone.ArrayTableTest;
+import org.apache.calcite.adapter.enumerable.TypeFinderTest;
 import org.apache.calcite.jdbc.CalciteRemoteDriverTest;
 import org.apache.calcite.materialize.LatticeSuggesterTest;
 import org.apache.calcite.plan.RelOptPlanReaderTest;
@@ -131,6 +132,7 @@
     SqlTypeFactoryTest.class,
     SqlTypeUtilTest.class,
     SqlValidatorUtilTest.class,
+    TypeFinderTest.class,
 
     // medium tests (above 0.1s)
     SqlParserTest.class,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1845,7 +1845,7 @@ public SqlSyntax getSyntax() {
    */
   public static final SqlFunction IN_FENNEL =
       new SqlMonotonicUnaryFunction(
-          "IN_FENNEL",
+          "$IN_FENNEL",
           SqlKind.OTHER_FUNCTION,
           ReturnTypes.ARG0,
           null,

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -47,6 +47,7 @@
 import org.apache.calcite.sql.parser.SqlParserTest;
 import org.apache.calcite.sql.parser.SqlUnParserTest;
 import org.apache.calcite.sql.parser.parserextensiontesting.ExtensionSqlParserTest;
+import org.apache.calcite.sql.test.DocumentationTest;
 import org.apache.calcite.sql.test.SqlAdvisorTest;
 import org.apache.calcite.sql.test.SqlOperatorTest;
 import org.apache.calcite.sql.test.SqlPrettyWriterTest;
@@ -162,6 +163,7 @@
     MutableRelTest.class,
 
     // slow tests (above 1s)
+    DocumentationTest.class,
     UdfTest.class,
     UdtTest.class,
     TableFunctionTest.class,

File: core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
Patch:
@@ -536,7 +536,7 @@ public MinFloat() {
    */
   public static class MinDouble extends NumericComparison<Double> {
     public MinDouble() {
-      super(Double.MAX_VALUE, Math::max);
+      super(Double.MAX_VALUE, Math::min);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -836,7 +836,7 @@ private static ImmutableBitSet analyzeGroupExpr(SqlValidatorScope scope,
       SqlIdentifier expr = (SqlIdentifier) expandedGroupExpr;
 
       // column references should be fully qualified.
-      assert expr.names.size() == 2;
+      assert expr.names.size() >= 2;
       String originalRelName = expr.names.get(0);
       String originalFieldName = expr.names.get(1);
 

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectCorrelateTransposeRule.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.calcite.rex.RexCorrelVariable;
 import org.apache.calcite.rex.RexFieldAccess;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexOver;
 import org.apache.calcite.rex.RexShuttle;
 import org.apache.calcite.tools.RelBuilderFactory;
 import org.apache.calcite.util.BitSets;
@@ -43,10 +44,10 @@
 /**
  * Push Project under Correlate to apply on Correlate's left and right child
  */
-public class ProjectCorrelateTransposeRule  extends RelOptRule {
+public class ProjectCorrelateTransposeRule extends RelOptRule {
 
   public static final ProjectCorrelateTransposeRule INSTANCE =
-      new ProjectCorrelateTransposeRule(expr -> true,
+      new ProjectCorrelateTransposeRule(expr -> !(expr instanceof RexOver),
           RelFactories.LOGICAL_BUILDER);
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayFunction.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.calcite.sql.SqlOperandCountRange;
 import org.apache.calcite.sql.SqlWriter;
 import org.apache.calcite.sql.parser.SqlParserPos;
+import org.apache.calcite.sql.type.InferTypes;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlOperandCountRanges;
@@ -39,8 +40,8 @@
  */
 public class SqlJsonArrayFunction extends SqlFunction {
   public SqlJsonArrayFunction() {
-    super("JSON_ARRAY", SqlKind.OTHER_FUNCTION, ReturnTypes.VARCHAR_2000, null,
-        OperandTypes.VARIADIC, SqlFunctionCategory.SYSTEM);
+    super("JSON_ARRAY", SqlKind.OTHER_FUNCTION, ReturnTypes.VARCHAR_2000,
+        InferTypes.ANY_NULLABLE, OperandTypes.VARIADIC, SqlFunctionCategory.SYSTEM);
   }
 
   @Override public SqlOperandCountRange getOperandCountRange() {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonDepthFunction.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlOperandCountRanges;
 import org.apache.calcite.sql.type.SqlOperandTypeChecker;
+import org.apache.calcite.sql.type.SqlTypeTransforms;
 import org.apache.calcite.sql.validate.SqlValidator;
 
 /**
@@ -37,7 +38,8 @@ public class SqlJsonDepthFunction extends SqlFunction {
   public SqlJsonDepthFunction() {
     super("JSON_DEPTH",
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.INTEGER_NULLABLE,
+        ReturnTypes.cascade(ReturnTypes.INTEGER,
+            SqlTypeTransforms.FORCE_NULLABLE),
         null,
         OperandTypes.ANY,
         SqlFunctionCategory.SYSTEM);

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -292,6 +292,7 @@ public class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(BETWEEN)",
           "KEYWORD(CONTAINS)",
           "KEYWORD(EQUALS)",
+          "KEYWORD(FORMAT)",
           "KEYWORD(IMMEDIATELY)",
           "KEYWORD(IN)",
           "KEYWORD(IS)",

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -619,9 +619,9 @@ private void flattenProjection(RewriteRexShuttle shuttle,
         int n = fieldList.size();
         for (int j = 0; j < n; ++j) {
           final Ord<RelDataType> newField =
-              getNewFieldForOldInput(inputRef.getIndex());
+              getNewFieldForOldInput(inputRef.getIndex(), j);
           flattenedExps.add(
-              Pair.of(new RexInputRef(newField.i + j, newField.e),
+              Pair.of(new RexInputRef(newField.i, newField.e),
                   fieldName));
         }
       } else if (isConstructor(exp) || exp.isA(SqlKind.CAST)) {

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -8157,7 +8157,8 @@ public void _testGroupExpressionEquivalenceParams() {
     sql("SELECT * FROM customer.contact_peek as c")
         .type("RecordType(INTEGER NOT NULL CONTACTNO, VARCHAR(10) NOT NULL FNAME, "
             + "VARCHAR(10) NOT NULL LNAME, VARCHAR(20) NOT NULL EMAIL, INTEGER NOT NULL X, "
-            + "INTEGER NOT NULL Y, RecordType:peek_no_expand(INTEGER NOT NULL M, "
+            + "INTEGER NOT NULL Y, VARCHAR(20) NOT NULL unit, "
+            + "RecordType:peek_no_expand(INTEGER NOT NULL M, "
             + "RecordType:peek_no_expand(INTEGER NOT NULL A, INTEGER NOT NULL B) "
             + "NOT NULL SUB) NOT NULL COORD_NE) NOT NULL");
 

File: core/src/test/java/org/apache/calcite/test/catalog/Fixture.java
Patch:
@@ -75,6 +75,7 @@ final class Fixture {
         typeFactory.builder()
             .add("X", intType)
             .add("Y", intType)
+            .add("unit", varchar20Type)
             .kind(StructKind.PEEK_FIELDS)
             .build();
     rectilinearPeekNoExpandCoordType =

File: core/src/main/java/org/apache/calcite/rel/RelInput.java
Patch:
@@ -62,7 +62,7 @@ public interface RelInput {
   Object get(String tag);
 
   /**
-   * Returns a {@code float} value. Throws if wrong type.
+   * Returns a {@code string} value. Throws if wrong type.
    */
   String getString(String tag);
 

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleCall.java
Patch:
@@ -165,6 +165,8 @@ public <T extends RelNode> T rel(int ordinal) {
    * children, and hence where the matched children are not retrievable by any
    * other means.
    *
+   * <p>Warning: it produces wrong result for {@code unordered(...)} case.
+   *
    * @param rel Relational expression
    * @return Children of relational expression
    */

File: core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java
Patch:
@@ -155,7 +155,6 @@ public VolcanoPlannerTest() {
         equalTo(
             sort(
                 "NoneSingleRel:Subset#0.NONE",
-                "PhysSingleRel:Subset#0.NONE",
                 "PhysSingleRel:Subset#0.PHYS")));
   }
 

File: core/src/test/java/org/apache/calcite/rel/rules/SortRemoveRuleTest.java
Patch:
@@ -73,8 +73,7 @@ private RelNode transform(String sql, RuleSet prepareRules) throws Exception {
     RelRoot planRoot = planner.rel(validate);
     RelNode planBefore = planRoot.rel;
     RelTraitSet desiredTraits = planBefore.getTraitSet()
-        .replace(EnumerableConvention.INSTANCE)
-        .replace(planRoot.collation).simplify();
+        .replace(EnumerableConvention.INSTANCE);
     RelNode planAfter = planner.transform(0, desiredTraits, planBefore);
     return planner.transform(1, desiredTraits, planAfter);
   }

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -47,6 +47,7 @@
 import org.apache.calcite.sql.SqlUtil;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
+import org.apache.calcite.statistic.MapSqlStatisticProvider;
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Litmus;
 import org.apache.calcite.util.Pair;

File: core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
Patch:
@@ -178,8 +178,8 @@ public static AggregateCall create(SqlAggFunction aggFunction,
   public static AggregateCall create(SqlAggFunction aggFunction,
       boolean distinct, boolean approximate, List<Integer> argList,
       int filterArg, RelCollation collation, RelDataType type, String name) {
-    return new AggregateCall(aggFunction, distinct, approximate, false, argList,
-        filterArg, collation, type, name);
+    return create(aggFunction, distinct, approximate, false, argList, filterArg,
+        collation, type, name);
   }
 
   /** Creates an AggregateCall. */

File: core/src/main/java/org/apache/calcite/tools/Frameworks.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.config.CalciteConnectionProperty;
 import org.apache.calcite.jdbc.CalciteSchema;
-import org.apache.calcite.materialize.MapSqlStatisticProvider;
 import org.apache.calcite.materialize.SqlStatisticProvider;
 import org.apache.calcite.plan.Context;
 import org.apache.calcite.plan.RelOptCluster;
@@ -38,6 +37,7 @@
 import org.apache.calcite.sql2rel.SqlRexConvertletTable;
 import org.apache.calcite.sql2rel.SqlToRelConverter;
 import org.apache.calcite.sql2rel.StandardConvertletTable;
+import org.apache.calcite.statistic.QuerySqlStatisticProvider;
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
@@ -214,7 +214,7 @@ private ConfigBuilder() {
       sqlToRelConverterConfig = SqlToRelConverter.Config.DEFAULT;
       typeSystem = RelDataTypeSystem.DEFAULT;
       evolveLattice = false;
-      statisticProvider = MapSqlStatisticProvider.INSTANCE;
+      statisticProvider = QuerySqlStatisticProvider.SILENT_CACHING_INSTANCE;
     }
 
     /** Creates a ConfigBuilder, initializing from an existing config. */

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -175,6 +175,7 @@
     RexProgramFuzzyTest.class,
     SqlToRelConverterTest.class,
     ProfilerTest.class,
+    SqlStatisticProviderTest.class,
     SqlAdvisorJdbcTest.class,
     CoreQuidemTest.class,
     CalciteRemoteDriverTest.class,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -210,6 +210,9 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
       List<AggregateCall> aggregateCalls = group.getAggregateCalls(this);
       for (int aggIdx = 0; aggIdx < aggregateCalls.size(); aggIdx++) {
         AggregateCall call = aggregateCalls.get(aggIdx);
+        if (call.ignoreNulls()) {
+          throw new UnsupportedOperationException("IGNORE NULLS not supported");
+        }
         aggs.add(new AggImpState(aggIdx, call, true));
       }
 

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1294,6 +1294,7 @@ public static MutableRel unifyAggregates(MutableAggregate query,
         aggregateCalls.add(
             AggregateCall.create(getRollup(aggregateCall.getAggregation()),
                 aggregateCall.isDistinct(), aggregateCall.isApproximate(),
+                aggregateCall.ignoreNulls(),
                 ImmutableList.of(target.groupSet.cardinality() + i), -1,
                 aggregateCall.collation, aggregateCall.type,
                 aggregateCall.name));

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -466,8 +466,8 @@ RexNode toRex(RelInput relInput, Object o) {
           }
           final boolean distinct = (Boolean) map.get("distinct");
           return rexBuilder.makeOver(type, operator, rexOperands, partitionKeys,
-              ImmutableList.copyOf(orderKeys), lowerBound, upperBound, physical, true, false,
-              distinct);
+              ImmutableList.copyOf(orderKeys), lowerBound, upperBound, physical,
+              true, false, distinct, false);
         } else {
           final SqlOperator operator = toOp(relInput, op, map);
           final RelDataType type;

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
Patch:
@@ -283,7 +283,7 @@ private AggregateCall toAggCall(RelInput relInput, Map<String, Object> jsonAggCa
     final Integer filterOperand = (Integer) jsonAggCall.get("filter");
     final RelDataType type =
         relJson.toType(cluster.getTypeFactory(), jsonAggCall.get("type"));
-    return AggregateCall.create(aggregation, distinct, false, operands,
+    return AggregateCall.create(aggregation, distinct, false, false, operands,
         filterOperand == null ? -1 : filterOperand,
         RelCollations.EMPTY,
         type, null);

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
Patch:
@@ -155,7 +155,8 @@ public static RelNode create(RelOptCluster cluster,
                 over.getType(),
                 toInputRefs(over.operands),
                 aggMap.size(),
-                over.isDistinct());
+                over.isDistinct(),
+                over.ignoreNulls());
         aggCalls.add(aggCall);
         aggMap.put(over, aggCall);
       }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -144,8 +144,8 @@ public void onMatch(RelOptRuleCall call) {
         }
         topAggCallList.add(
             AggregateCall.create(rollup, aggregateCall.isDistinct(),
-                aggregateCall.isApproximate(), ImmutableList.of(i++), -1,
-                aggregateCall.collation,
+                aggregateCall.isApproximate(), aggregateCall.ignoreNulls(),
+                ImmutableList.of(i++), -1, aggregateCall.collation,
                 aggregateCall.type, aggregateCall.name));
       }
       final Aggregate topAggregate =

File: core/src/main/java/org/apache/calcite/rex/RexShuttle.java
Patch:
@@ -49,7 +49,8 @@ public RexNode visitOver(RexOver over) {
           over.getAggOperator(),
           clonedOperands,
           window,
-          over.isDistinct());
+          over.isDistinct(),
+          over.ignoreNulls());
     } else {
       return over;
     }

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -308,6 +308,9 @@ ExInst<SqlValidatorException> naturalOrUsingColumnNotCompatible(String a0,
   @BaseMessage("Window ''{0}'' not found")
   ExInst<SqlValidatorException> windowNotFound(String a0);
 
+  @BaseMessage("Cannot specify IGNORE NULLS or RESPECT NULLS following ''{0}''")
+  ExInst<SqlValidatorException> disallowsNullTreatment(String a0);
+
   @BaseMessage("Expression ''{0}'' is not being grouped")
   ExInst<SqlValidatorException> notGroupExpr(String a0);
 

File: core/src/main/java/org/apache/calcite/sql/SqlFilterOperator.java
Patch:
@@ -41,7 +41,7 @@ public class SqlFilterOperator extends SqlBinaryOperator {
   //~ Constructors -----------------------------------------------------------
 
   public SqlFilterOperator() {
-    super("FILTER", SqlKind.FILTER, 2, true, ReturnTypes.ARG0_FORCE_NULLABLE,
+    super("FILTER", SqlKind.FILTER, 20, true, ReturnTypes.ARG0_FORCE_NULLABLE,
         null, OperandTypes.ANY_ANY);
   }
 

File: core/src/test/java/org/apache/calcite/plan/volcano/TraitPropagationTest.java
Patch:
@@ -165,7 +165,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
 
       // aggregate on s, count
       AggregateCall aggCall = AggregateCall.create(SqlStdOperatorTable.COUNT,
-          false, false, Collections.singletonList(1), -1, RelCollations.EMPTY,
+          false, false, false, Collections.singletonList(1), -1, RelCollations.EMPTY,
           sqlBigInt, "cnt");
       RelNode agg = new LogicalAggregate(cluster,
           cluster.traitSetOf(Convention.NONE), project, false,

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1352,7 +1352,7 @@ private void checkAverageRowSize(RelOptCluster cluster, RelOptTable empTable,
             ImmutableList.of(),
             ImmutableList.of(
                 AggregateCall.create(SqlStdOperatorTable.COUNT,
-                    false, false, ImmutableIntList.of(),
+                    false, false, false, ImmutableIntList.of(),
                     -1, RelCollations.EMPTY, 2, join, null, null)));
     rowSize = mq.getAverageRowSize(aggregate);
     columnSizes = mq.getAverageColumnSizes(aggregate);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonApiCommonSyntaxOperator.java
Patch:
@@ -41,8 +41,7 @@ public SqlJsonApiCommonSyntaxOperator(String name, boolean hasPath) {
     super(name, SqlKind.JSON_API_COMMON_SYNTAX, 100, true,
         ReturnTypes.explicit(SqlTypeName.ANY), null,
         hasPath ? OperandTypes.family(SqlTypeFamily.ANY, SqlTypeFamily.STRING)
-            : OperandTypes.family(SqlTypeFamily.ANY)
-    );
+            : OperandTypes.family(SqlTypeFamily.ANY));
     this.hasPath = hasPath;
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/AuxiliaryConverter.java
Patch:
@@ -53,7 +53,7 @@ public RexNode convert(RexBuilder rexBuilder, RexNode groupCall,
       case TUMBLE_START:
       case HOP_START:
       case SESSION_START:
-      case SESSION_END: // TODO: ?
+      case SESSION_END:
         return e;
       case TUMBLE_END:
         return rexBuilder.makeCall(

File: core/src/main/java/org/apache/calcite/tools/Programs.java
Patch:
@@ -272,8 +272,8 @@ public static Program subQuery(RelMetadataProvider metadataProvider) {
   }
 
   public static Program getProgram() {
-    return (planner, rel, requiredOutputTraits, materializations, lattices)
-        -> null;
+    return (planner, rel, requiredOutputTraits, materializations, lattices) ->
+        null;
   }
 
   /** Returns the standard program used by Prepare. */

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchEnumerators.java
Patch:
@@ -53,7 +53,7 @@ private static Function1<ElasticsearchJson.SearchHit, Object> singletonGetter(
       final Object value;
       if (ElasticsearchConstants.ID.equals(key)
           || ElasticsearchConstants.ID.equals(mapping.getOrDefault(fieldName, fieldName))) {
-        // is the original projection on _id field ?
+        // is the original projection on _id field?
         value = hit.id();
       } else {
         value = hit.valueOrNull(key);
@@ -87,7 +87,7 @@ private static Function1<ElasticsearchJson.SearchHit, Object[]> listGetter(
         if (ElasticsearchConstants.ID.equals(key)
             || ElasticsearchConstants.ID.equals(mapping.get(field.getKey()))
             || ElasticsearchConstants.ID.equals(field.getKey())) {
-          // is the original projection on _id field ?
+          // is the original projection on _id field?
           value = hit.id();
         } else {
           value = hit.valueOrNull(key);

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
Patch:
@@ -95,9 +95,7 @@ private static class AutoClosingIterator implements Iterator<ElasticsearchJson.R
     private final Iterator<ElasticsearchJson.Result> delegate;
     private final Consumer<String> closer;
 
-    /**
-     * Was {@link #closer} consumer already called ?
-     */
+    /** Returns whether {@link #closer} consumer was already called. */
     private boolean closed;
 
     /**

File: core/src/main/java/org/apache/calcite/adapter/enumerable/PhysType.java
Patch:
@@ -200,12 +200,12 @@ Expression generateComparator(
   /** Converts an enumerable of this physical type to an enumerable that uses a
    * given physical type for its rows.
    *
-   * @deprecated As of 1.19, use {@link #convertTo(Expression, JavaRowFormat)}.
+   * @deprecated Use {@link #convertTo(Expression, JavaRowFormat)}.
    * The use of PhysType as a second parameter is misleading since only the row
    * format of the expression is affected by the conversion. Moreover it requires
    * to have at hand a PhysType object which is not really necessary for achieving
-   * the desired result.*/
-  @Deprecated
+   * the desired result. */
+  @Deprecated // to be removed before 2.0
   Expression convertTo(Expression expression, PhysType targetPhysType);
 
   /** Converts an enumerable of this physical type to an enumerable that uses

File: core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
Patch:
@@ -235,6 +235,7 @@ public PhysType makeNullable(boolean nullable) {
         Primitive.box(javaRowClass), format);
   }
 
+  @SuppressWarnings("deprecation")
   public Expression convertTo(Expression exp, PhysType targetPhysType) {
     return convertTo(exp, targetPhysType.getFormat());
   }

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -4256,7 +4256,7 @@ private void checkNullOperand(SqlTester tester, String op) {
     tester.checkScalarExact("ASCII('ABC')", "65");
     tester.checkScalarExact("ASCII(_UTF8'\u0082')", "130");
     tester.checkScalarExact("ASCII(_UTF8'\u5B57')", "23383");
-    tester.checkScalarExact("ASCII(_UTF8'Ω')", "937");
+    tester.checkScalarExact("ASCII(_UTF8'\u03a9')", "937"); // omega
     tester.checkNull("ASCII(cast(null as varchar(1)))");
   }
 

File: core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
Patch:
@@ -69,9 +69,7 @@
  * </ul>
  */
 public abstract class Aggregate extends SingleRel {
-  /**
-   * @see org.apache.calcite.util.Bug#CALCITE_461_FIXED
-   */
+
   public static boolean isSimple(Aggregate aggregate) {
     return aggregate.getGroupType() == Group.SIMPLE;
   }

File: spark/src/test/java/org/apache/calcite/test/SparkAdapterTest.java
Patch:
@@ -576,7 +576,7 @@ private CalciteAssert.AssertQuery sql(String sql) {
         + "where x is null";
 
     final String plan = "PLAN="
-        + "EnumerableCalc(expr#0..1=[{inputs}], expr#2=[false], proj#0..1=[{exprs}], $condition=[$t2])\n"
+        + "EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NULL($t0)], proj#0..1=[{exprs}], $condition=[$t2])\n"
         + "  EnumerableValues(tuples=[[{ 1, 'a' }, { 2, 'b' }, { 1, 'b' }, { 2, 'c' }, { 2, 'c' }]])\n\n";
 
     final String expectedResult = "";

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -596,8 +596,9 @@ private DruidQuery optimizeFilteredAggregations(RelOptRuleCall call,
       // Erase references to filters
       for (AggregateCall aggCall : aggregate.getAggCallList()) {
         if ((uniqueFilterRefs.size() == 1
-                && allHaveFilters) // filters get extracted
-            || project.getProjects().get(aggCall.filterArg).isAlwaysTrue()) {
+            && allHaveFilters) // filters get extracted
+            || aggCall.hasFilter()
+            && project.getProjects().get(aggCall.filterArg).isAlwaysTrue()) {
           aggCall = aggCall.copy(aggCall.getArgList(), -1, aggCall.collation);
         }
         newCalls.add(aggCall);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregate.java
Patch:
@@ -406,7 +406,7 @@ public RexToLixTranslator rowTranslator() {
           Expressions.return_(
               null,
               Expressions.call(
-                  inputPhysType.convertTo(childExp, physType),
+                  inputPhysType.convertTo(childExp, physType.getFormat()),
                   BuiltInMethod.DISTINCT.method,
                   Expressions.<Expression>list()
                       .appendIfNotNull(physType.comparer()))));

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -165,9 +165,6 @@ public Type getJavaClass(RelDataType type) {
       JavaType javaType = (JavaType) type;
       return javaType.getJavaClass();
     }
-    if (type.isStruct() && type.getFieldCount() == 1) {
-      return getJavaClass(type.getFieldList().get(0).getType());
-    }
     if (type instanceof BasicSqlType || type instanceof IntervalSqlType) {
       switch (type.getSqlTypeName()) {
       case VARCHAR:

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -101,6 +101,7 @@
 
 import org.hamcrest.Matcher;
 import org.hsqldb.jdbcDriver;
+import org.junit.Assume;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -1972,6 +1973,7 @@ private static List<Pair<String, String>> querify(String[] queries1) {
   }
 
   @Test public void testMultisetQueryWithSingleColumn() {
+    Assume.assumeTrue("[CALCITE-2776]", Bug.CALCITE_2776_FIXED);
     CalciteAssert.hr()
         .query("select multiset(\n"
             + "  select \"deptno\" from \"hr\".\"emps\") as a\n"

File: core/src/test/java/org/apache/calcite/test/QuidemTest.java
Patch:
@@ -85,6 +85,8 @@ private static Object getEnv(String varName) {
           return Bug.CALCITE_1045_FIXED;
         case "calcite1048":
           return Bug.CALCITE_1048_FIXED;
+        case "calcite2776":
+          return Bug.CALCITE_2776_FIXED;
         }
         return null;
       };

File: core/src/main/java/org/apache/calcite/sql/SqlUtil.java
Patch:
@@ -663,7 +663,7 @@ public static SqlNode getSelectListItem(SqlNode query, int i) {
   public static SqlCall makeCall(
       SqlOperatorTable opTab,
       SqlIdentifier id) {
-    if (id.names.size() == 1) {
+    if (id.names.size() == 1 && !id.isComponentQuoted(0)) {
       final List<SqlOperator> list = new ArrayList<>();
       opTab.lookupOperatorOverloads(id, null, SqlSyntax.FUNCTION, list);
       for (SqlOperator operator : list) {

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -54,6 +54,7 @@
 import org.apache.calcite.sql.type.SqlTypeFactoryTest;
 import org.apache.calcite.sql.type.SqlTypeUtilTest;
 import org.apache.calcite.sql.validate.LexCaseSensitiveTest;
+import org.apache.calcite.sql.validate.LexEscapeTest;
 import org.apache.calcite.sql.validate.SqlValidatorUtilTest;
 import org.apache.calcite.test.enumerable.EnumerableCorrelateTest;
 import org.apache.calcite.test.fuzzer.RexProgramFuzzyTest;
@@ -154,6 +155,7 @@
     EnumerableCorrelateTest.class,
     LookupOperatorOverloadsTest.class,
     LexCaseSensitiveTest.class,
+    LexEscapeTest.class,
     CollationConversionTest.class,
     TraitConversionTest.class,
     ComboRuleTest.class,

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvFieldType.java
Patch:
@@ -56,7 +56,7 @@ enum CsvFieldType {
   }
 
   CsvFieldType(Primitive primitive) {
-    this(primitive.boxClass, primitive.primitiveClass.getSimpleName());
+    this(primitive.boxClass, primitive.primitiveName);
   }
 
   CsvFieldType(Class clazz, String simpleName) {

File: file/src/main/java/org/apache/calcite/adapter/file/FileFieldType.java
Patch:
@@ -59,7 +59,7 @@ enum FileFieldType {
       builder.put(value.clazz.getSimpleName(), value);
 
       if (value.primitive != null) {
-        builder.put(value.primitive.primitiveClass.getSimpleName(), value);
+        builder.put(value.primitive.primitiveName, value);
       }
     }
     MAP = builder.build();

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConstantExpression.java
Patch:
@@ -132,7 +132,7 @@ private static ExpressionWriter write(ExpressionWriter writer,
     }
     final Primitive primitive2 = Primitive.ofBox(type);
     if (primitive2 != null) {
-      writer.append(primitive2.boxClass.getSimpleName() + ".valueOf(");
+      writer.append(primitive2.boxName + ".valueOf(");
       write(writer, value, primitive2.primitiveClass);
       return writer.append(")");
     }

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/FunctionExpression.java
Patch:
@@ -173,7 +173,7 @@ public F getFunction() {
     final String bridgeResultTypeName =
         isAbstractMethodPrimitive()
             ? Types.className(bridgeResultType)
-            : Types.boxClassName(bridgeResultType);
+            : Types.className(Types.box(bridgeResultType));
     if (!boxBridgeParams.equals(params)) {
       writer
           .append("public ")
@@ -204,7 +204,8 @@ public F getFunction() {
 
   private boolean isAbstractMethodPrimitive() {
     Method method = getAbstractMethod();
-    return method != null && Primitive.is(method.getReturnType());
+    assert method != null;
+    return Primitive.is(method.getReturnType());
   }
 
   private String getAbstractMethodName() {

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
Patch:
@@ -57,6 +57,7 @@ public enum Primitive {
   public final Class primitiveClass;
   public final Class boxClass;
   public final String primitiveName; // e.g. "int"
+  public final String boxName;
   private final int family;
 
   /** The default value of this primitive class. This is the value
@@ -105,6 +106,7 @@ public enum Primitive {
     this.primitiveName =
         primitiveClass != null ? primitiveClass.getSimpleName() : null;
     this.boxClass = boxClass;
+    this.boxName = boxClass != null ? boxClass.getSimpleName() : null;
     this.defaultValue = defaultValue;
     this.min = min;
     this.maxNegative = maxNegative;

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
Patch:
@@ -73,7 +73,7 @@ static void visitValueNodes(Aggregations aggregations, Consumer<Map<String, Obje
         rows.computeIfAbsent(r, ignore -> new ArrayList<>()).add(v);
     aggregations.forEach(a -> visitValueNodes(a, new ArrayList<>(), cons));
     rows.forEach((k, v) -> {
-      if (v.stream().anyMatch(val -> val instanceof GroupValue)) {
+      if (v.stream().allMatch(val -> val instanceof GroupValue)) {
         v.forEach(tuple -> {
           Map<String, Object> groupRow = new LinkedHashMap<>(k.keys);
           groupRow.put(tuple.getName(), tuple.value());

File: core/src/main/java/org/apache/calcite/plan/RelOptListener.java
Patch:
@@ -73,7 +73,7 @@ public interface RelOptListener extends EventListener {
   /**
    * Notifies this listener that a relational expression has been chosen as
    * part of the final implementation of the query plan. After the plan is
-   * copmlete, this is called one more time with null for the rel.
+   * complete, this is called one more time with null for the rel.
    *
    * @param event details about the event
    */
@@ -154,7 +154,7 @@ public RelOptRuleCall getRuleCall() {
     }
   }
 
-  /** Event indicating that a planner rule has been attemptedd. */
+  /** Event indicating that a planner rule has been attempted. */
   class RuleAttemptedEvent extends RuleEvent {
     private final boolean before;
 

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -73,7 +73,6 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Objects;
 import java.util.Queue;
 import java.util.Set;
 import java.util.TimeZone;
@@ -2487,7 +2486,7 @@ public static Boolean jsonExists(Object input,
             errorBehavior.toString()).ex();
       }
     } else {
-      return !Objects.isNull(context.pathReturned);
+      return context.pathReturned != null;
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1309,14 +1309,14 @@ public boolean argumentMustBeScalar(int ordinal) {
   public static final SqlFunction JSON_DEPTH = new SqlJsonDepthFunction();
 
   public static final SqlJsonObjectAggAggFunction JSON_OBJECTAGG =
-      new SqlJsonObjectAggAggFunction("JSON_OBJECTAGG",
+      new SqlJsonObjectAggAggFunction(SqlKind.JSON_OBJECTAGG,
           SqlJsonConstructorNullClause.NULL_ON_NULL);
 
   public static final SqlFunction JSON_ARRAY = new SqlJsonArrayFunction();
 
   public static final SqlJsonArrayAggAggFunction JSON_ARRAYAGG =
-      new SqlJsonArrayAggAggFunction("JSON_ARRAYAGG",
-          SqlJsonConstructorNullClause.NULL_ON_NULL);
+      new SqlJsonArrayAggAggFunction(SqlKind.JSON_ARRAYAGG,
+          SqlJsonConstructorNullClause.ABSENT_ON_NULL);
 
   public static final SqlBetweenOperator BETWEEN =
       new SqlBetweenOperator(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlBaseContextVariable.java
Patch:
@@ -26,8 +26,7 @@
 import org.apache.calcite.sql.validate.SqlMonotonicity;
 
 /**
- * Base class for functions such as "PI", "USER", "CURRENT_ROLE", and
- * "CURRENT_PATH".
+ * Base class for functions such as "USER", "CURRENT_ROLE", and "CURRENT_PATH".
  */
 public class SqlBaseContextVariable extends SqlFunction {
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -167,6 +167,7 @@
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_OBJECTAGG;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_QUERY;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_STRUCTURED_VALUE_EXPRESSION;
+import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_TYPE;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_VALUE_ANY;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.JSON_VALUE_EXPRESSION;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.LAG;
@@ -450,6 +451,7 @@ public Expression implement(RexToLixTranslator translator,
     defineMethod(JSON_VALUE_ANY, BuiltInMethod.JSON_VALUE_ANY.method, NullPolicy.NONE);
     defineMethod(JSON_QUERY, BuiltInMethod.JSON_QUERY.method, NullPolicy.NONE);
     defineMethod(JSON_OBJECT, BuiltInMethod.JSON_OBJECT.method, NullPolicy.NONE);
+    defineMethod(JSON_TYPE, BuiltInMethod.JSON_TYPE.method, NullPolicy.NONE);
     aggMap.put(JSON_OBJECTAGG,
         JsonObjectAggImplementor
             .supplierFor(BuiltInMethod.JSON_OBJECTAGG_ADD.method));

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -852,6 +852,9 @@ ExInst<CalciteException> invalidTypesForComparison(String clazzName0, String op,
 
   @BaseMessage("While executing SQL [{0}] on JDBC sub-schema")
   ExInst<RuntimeException> exceptionWhilePerformingQueryOnJdbcSubSchema(String sql);
+
+  @BaseMessage("Unknown JSON type in JSON_TYPE function, and the object is: ''{0}''")
+  ExInst<CalciteException> unknownObjectOfJsonType(String value);
 }
 
 // End CalciteResource.java

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1303,6 +1303,8 @@ public boolean argumentMustBeScalar(int ordinal) {
 
   public static final SqlFunction JSON_OBJECT = new SqlJsonObjectFunction();
 
+  public static final SqlFunction JSON_TYPE = new SqlJsonTypeFunction();
+
   public static final SqlJsonObjectAggAggFunction JSON_OBJECTAGG =
       new SqlJsonObjectAggAggFunction("JSON_OBJECTAGG",
           SqlJsonConstructorNullClause.NULL_ON_NULL);

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -282,6 +282,7 @@ public enum BuiltInMethod {
       SqlJsonQueryEmptyOrErrorBehavior.class),
   JSON_OBJECT(SqlFunctions.class, "jsonObject",
       SqlJsonConstructorNullClause.class),
+  JSON_TYPE(SqlFunctions.class, "jsonType", Object.class),
   JSON_OBJECTAGG_ADD(SqlFunctions.class, "jsonObjectAggAdd", Map.class,
       String.class, Object.class, SqlJsonConstructorNullClause.class),
   JSON_ARRAY(SqlFunctions.class, "jsonArray",

File: geode/src/test/java/org/apache/calcite/adapter/geode/rel/GeodeAllDataTypesTest.java
Patch:
@@ -160,8 +160,8 @@ public void testSqlWhereWithMultipleOrForLiteralFields() {
         .queryContains(
             GeodeAssertions.query("SELECT stringValue AS stringValue "
                 + "FROM /allDataTypesRegion WHERE "
-                + "stringValue IN SET('abc', 'def') OR floatValue IN SET(1.5678, null) "
-                + "OR booleanValue IN SET(true, false, null)"));
+                + "stringValue IN SET('abc', 'def') OR floatValue = 1.5678 "
+                + "OR booleanValue IN SET(true, false)"));
   }
 
   @Test

File: geode/src/test/java/org/apache/calcite/adapter/geode/rel/GeodeZipsTest.java
Patch:
@@ -282,7 +282,7 @@ public void testSqlSingleStringWhereFilter() {
   @Test
   public void testWhereWithOrWithEmptyResult() {
     String expectedQuery = "SELECT state AS state FROM /zips "
-        + "WHERE state IN SET('', null, true, false, 123, 13.892)";
+        + "WHERE state IN SET('', true, false, 123, 13.892)";
     calciteAssert()
         .query("SELECT state as state "
             + "FROM view WHERE state = '' OR state = null OR "

File: cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterTest.java
Patch:
@@ -154,7 +154,7 @@ public static void setUp() {
         .returns("tweet_id=f3cd759c-d05b-11e5-b58b-90e2ba530b12; "
             + "body=Lacus augue pede posuere.; username=JmuhsAaMdw\n")
         .explainContains("PLAN=CassandraToEnumerableConverter\n"
-           + "  CassandraFilter(condition=[=(CAST($0):CHAR(36) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\", 'f3cd759c-d05b-11e5-b58b-90e2ba530b12')])\n"
+           + "  CassandraFilter(condition=[=(CAST($0):CHAR(36), 'f3cd759c-d05b-11e5-b58b-90e2ba530b12')])\n"
            + "    CassandraTableScan(table=[[twissandra, tweets]]");
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
Patch:
@@ -80,9 +80,7 @@ protected RelDataType adjustType(
                 .createTypeWithCharsetAndCollation(
                     type,
                     type.getCharset(),
-                    new SqlCollation(
-                        collation.getCollationName(),
-                        collation.getCoercibility()));
+                    collation);
       }
     }
     return type;

File: core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
Patch:
@@ -81,9 +81,7 @@ protected RelDataType adjustType(
                 .createTypeWithCharsetAndCollation(
                     type,
                     type.getCharset(),
-                    new SqlCollation(
-                        collation.getCollationName(),
-                        collation.getCoercibility()));
+                    collation);
       }
     }
     return type;

File: core/src/test/java/org/apache/calcite/plan/RelOptUtilTest.java
Patch:
@@ -86,7 +86,7 @@ public RelOptUtilTest() {
     TestUtil.assertEqualsVerbose(
         TestUtil.fold(
             "f0 DECIMAL(5, 2) NOT NULL,",
-            "f1 VARCHAR(10) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL"),
+            "f1 VARCHAR(10) NOT NULL"),
         Util.toLinux(RelOptUtil.dumpType(t1) + "\n"));
 
     RelDataType t2 =
@@ -98,10 +98,10 @@ public RelOptUtilTest() {
         TestUtil.fold(
             "f0 RECORD (",
             "  f0 DECIMAL(5, 2) NOT NULL,",
-            "  f1 VARCHAR(10) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL) NOT NULL,",
+            "  f1 VARCHAR(10) NOT NULL) NOT NULL,",
             "f1 RECORD (",
             "  f0 DECIMAL(5, 2) NOT NULL,",
-            "  f1 VARCHAR(10) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL) NOT NULL MULTISET NOT NULL"),
+            "  f1 VARCHAR(10) NOT NULL) NOT NULL MULTISET NOT NULL"),
         Util.toLinux(RelOptUtil.dumpType(t2) + "\n"));
   }
 

File: core/src/test/java/org/apache/calcite/rex/RexBuilderTest.java
Patch:
@@ -250,7 +250,7 @@ private void checkTimestamp(RexNode node) {
   }
 
   private void checkTimestampWithLocalTimeZone(RexNode node) {
-    assertThat(node.toString(), is("1969-07-21 02:56:15"));
+    assertThat(node.toString(), is("1969-07-21 02:56:15:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"));
     RexLiteral literal = (RexLiteral) node;
     assertThat(literal.getValue() instanceof TimestampString, is(true));
     assertThat(literal.getValue2() instanceof Long, is(true));
@@ -514,6 +514,8 @@ private void checkDate(RexNode node) {
         "UTF8",
         SqlCollation.IMPLICIT);
     assertEquals("_UTF8'foobar'", literal.toString());
+    assertEquals("_UTF8'foobar':CHAR(6) CHARACTER SET \"UTF-8\"",
+        ((RexLiteral) literal).computeDigest(RexDigestIncludeType.ALWAYS));
     literal = builder.makePreciseStringLiteral(
         new ByteString("\u82f1\u56fd".getBytes(StandardCharsets.UTF_8)),
         "UTF8",

File: core/src/test/java/org/apache/calcite/test/StreamTest.java
Patch:
@@ -277,13 +277,13 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz
         .convertContains("LogicalDelta\n"
             + "  LogicalProject(ROWTIME=[$0], ORDERID=[$1], SUPPLIERID=[$6])\n"
             + "    LogicalJoin(condition=[=($4, $5)], joinType=[inner])\n"
-            + "      LogicalProject(ROWTIME=[$0], ID=[$1], PRODUCT=[$2], UNITS=[$3], PRODUCT0=[CAST($2):VARCHAR(32) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL])\n"
+            + "      LogicalProject(ROWTIME=[$0], ID=[$1], PRODUCT=[$2], UNITS=[$3], PRODUCT0=[CAST($2):VARCHAR(32) NOT NULL])\n"
             + "        LogicalTableScan(table=[[STREAM_JOINS, ORDERS]])\n"
             + "      LogicalTableScan(table=[[STREAM_JOINS, PRODUCTS]])\n")
         .explainContains(""
             + "EnumerableCalc(expr#0..6=[{inputs}], proj#0..1=[{exprs}], SUPPLIERID=[$t6])\n"
             + "  EnumerableJoin(condition=[=($4, $5)], joinType=[inner])\n"
-            + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL], proj#0..4=[{exprs}])\n"
+            + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) NOT NULL], proj#0..4=[{exprs}])\n"
             + "      EnumerableInterpreter\n"
             + "        BindableTableScan(table=[[STREAM_JOINS, ORDERS, (STREAM)]])\n"
             + "    EnumerableInterpreter\n"

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java
Patch:
@@ -98,7 +98,7 @@ public class DruidAdapterIT {
       Util.getBooleanProperty("calcite.test.druid", true);
 
   private static final String VARCHAR_TYPE =
-      "VARCHAR CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\"";
+      "VARCHAR";
 
   private static final String FOODMART_TABLE = "\"foodmart\"";
 
@@ -4313,7 +4313,7 @@ public void testTableauQuerySubStringHourMinutes() {
             + "SUM_T_OTHER_OK=[$3], HR_T_TIMESTAMP_OK2=[$2])\n"
             + "    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/"
             + "2992-01-10T00:00:00.000Z]], projects=[[CAST(SUBSTRING(CAST(CAST($0):TIMESTAMP(0) "
-            + "NOT NULL):VARCHAR CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" "
+            + "NOT NULL):VARCHAR "
             + "NOT NULL, 12, 2)):INTEGER NOT NULL, EXTRACT(FLAG(MINUTE), $0), "
             + "EXTRACT(FLAG(HOUR), $0), $90]], groups=[{0, 1, 2}], aggs=[[SUM($3)]], fetch=[1])")
         .queryContains(druidChecker("\"queryType\":\"groupBy\""));
@@ -4370,7 +4370,7 @@ public void testCastConcatOverPostAggregates() {
             + "2992-01-10T00:00:00.000Z]], projects=[[$90, $91]], groups=[{}], aggs=[[COUNT(), "
             + "SUM($0), SUM($1)]], post_projects=[[||(||(CAST(+($0, $1)):VARCHAR CHARACTER SET "
             + "\"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\", '_'), CAST($2):"
-            + "VARCHAR CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\")]])");
+            + "VARCHAR)]])");
   }
 
   @Test

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT2.java
Patch:
@@ -82,7 +82,7 @@ public class DruidAdapterIT2 {
       Util.getBooleanProperty("calcite.test.druid", true);
 
   private static final String VARCHAR_TYPE =
-      "VARCHAR CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\"";
+      "VARCHAR";
 
   private static final String FOODMART_TABLE = "\"foodmart\"";
 
@@ -3727,7 +3727,7 @@ public void testTableauQuerySubStringHourMinutes() {
             + "SUM_T_OTHER_OK=[$3], HR_T_TIMESTAMP_OK2=[$2])\n"
             + "    DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000Z/"
             + "2992-01-10T00:00:00.000Z]], projects=[[CAST(SUBSTRING(CAST($0):VARCHAR"
-            + " CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" "
+            + " "
             + "NOT NULL, 12, 2)):INTEGER NOT NULL, EXTRACT(FLAG(MINUTE), $0), "
             + "EXTRACT(FLAG(HOUR), $0), $90]], groups=[{0, 1, 2}], aggs=[[SUM($3)]], fetch=[1])")
         .queryContains(druidChecker("\"queryType\":\"groupBy\""));
@@ -3761,7 +3761,7 @@ public void testCastConcatOverPostAggregates() {
             + "2992-01-10T00:00:00.000Z]], projects=[[$90, $91]], groups=[{}], aggs=[[COUNT(), "
             + "SUM($0), SUM($1)]], post_projects=[[||(||(CAST(+($0, $1)):VARCHAR CHARACTER SET "
             + "\"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\", '_'), CAST($2):"
-            + "VARCHAR CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\")]])");
+            + "VARCHAR)]])");
   }
 
   @Test

File: example/csv/src/test/java/org/apache/calcite/test/CsvTest.java
Patch:
@@ -251,7 +251,7 @@ private static StringBuilder escapeString(StringBuilder buf, String s) {
         + "select max(empno) from EMPS where gender='F'";
     final String expected = "PLAN="
         + "EnumerableAggregate(group=[{}], EXPR$0=[MAX($0)])\n"
-        + "  EnumerableCalc(expr#0..1=[{inputs}], expr#2=['F'], "
+        + "  EnumerableCalc(expr#0..1=[{inputs}], expr#2=['F':VARCHAR], "
         + "expr#3=[=($t1, $t2)], proj#0..1=[{exprs}], $condition=[$t3])\n"
         + "    CsvTableScan(table=[[SALES, EMPS]], fields=[[0, 3]])\n";
     sql("smart", sql).returns(expected).ok();

File: geode/src/test/java/org/apache/calcite/adapter/geode/rel/GeodeBookstoreTest.java
Patch:
@@ -134,8 +134,7 @@ public void testWhereWithAndOr() {
         .explainContains("PLAN=GeodeToEnumerableConverter\n"
             + "  GeodeProject(author=[$4])\n"
             + "    GeodeFilter(condition=[OR(AND(>($0, 123), =(CAST($0):INTEGER, 789)), "
-            + "=(CAST($4):VARCHAR CHARACTER SET \"ISO-8859-1\" "
-            + "COLLATE \"ISO-8859-1$en_US$primary\", 'Daisy Mae West'))])\n"
+            + "=(CAST($4):VARCHAR, 'Daisy Mae West'))])\n"
             + "      GeodeTableScan(table=[[geode, BookMaster]])\n"
             + "\n")
         .queryContains(

File: spark/src/test/java/org/apache/calcite/test/SparkAdapterTest.java
Patch:
@@ -112,7 +112,7 @@ private CalciteAssert.AssertQuery sql(String sql) {
         + "group by x";
 
     final String plan = "PLAN="
-        + "EnumerableCalc(expr#0..5=[{inputs}], expr#6=[CAST($t1):INTEGER NOT NULL], expr#7=[CAST($t2):CHAR(1) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL], expr#8=[CAST($t3):CHAR(1) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL], expr#9=[CAST($t4):BIGINT NOT NULL], SUM_X=[$t6], MIN_Y=[$t7], MAX_Y=[$t8], CNT_Y=[$t9], CNT_DIST_Y=[$t5])\n"
+        + "EnumerableCalc(expr#0..5=[{inputs}], expr#6=[CAST($t1):INTEGER NOT NULL], expr#7=[CAST($t2):CHAR(1) NOT NULL], expr#8=[CAST($t3):CHAR(1) NOT NULL], expr#9=[CAST($t4):BIGINT NOT NULL], SUM_X=[$t6], MIN_Y=[$t7], MAX_Y=[$t8], CNT_Y=[$t9], CNT_DIST_Y=[$t5])\n"
         + "  EnumerableAggregate(group=[{0}], SUM_X=[MIN($2) FILTER $7], MIN_Y=[MIN($3) FILTER $7], MAX_Y=[MIN($4) FILTER $7], CNT_Y=[MIN($5) FILTER $7], CNT_DIST_Y=[COUNT($1) FILTER $6])\n"
         + "    EnumerableCalc(expr#0..6=[{inputs}], expr#7=[0], expr#8=[=($t6, $t7)], expr#9=[1], expr#10=[=($t6, $t9)], proj#0..5=[{exprs}], $g_0=[$t8], $g_1=[$t10])\n"
         + "      EnumerableAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}]], SUM_X=[$SUM0($0)], MIN_Y=[MIN($1)], MAX_Y=[MAX($1)], CNT_Y=[COUNT()], $g=[GROUPING($0, $1)])\n"
@@ -166,7 +166,7 @@ private CalciteAssert.AssertQuery sql(String sql) {
         + "order by x asc";
 
     final String plan = "PLAN="
-        + "EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t1):CHAR(1) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL], expr#6=[CAST($t2):CHAR(1) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL], expr#7=[CAST($t3):BIGINT NOT NULL], X=[$t0], MIN_Y=[$t5], MAX_Y=[$t6], CNT_Y=[$t7], CNT_DIST_Y=[$t4])\n"
+        + "EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t1):CHAR(1) NOT NULL], expr#6=[CAST($t2):CHAR(1) NOT NULL], expr#7=[CAST($t3):BIGINT NOT NULL], X=[$t0], MIN_Y=[$t5], MAX_Y=[$t6], CNT_Y=[$t7], CNT_DIST_Y=[$t4])\n"
         + "  EnumerableSort(sort0=[$0], dir0=[ASC])\n"
         + "    EnumerableAggregate(group=[{0}], MIN_Y=[MIN($2) FILTER $6], MAX_Y=[MIN($3) FILTER $6], CNT_Y=[MIN($4) FILTER $6], CNT_DIST_Y=[COUNT($1) FILTER $5])\n"
         + "      EnumerableCalc(expr#0..5=[{inputs}], expr#6=[0], expr#7=[=($t5, $t6)], expr#8=[1], expr#9=[=($t5, $t8)], proj#0..4=[{exprs}], $g_0=[$t7], $g_1=[$t9])\n"
@@ -188,7 +188,7 @@ private CalciteAssert.AssertQuery sql(String sql) {
         + "order by x desc";
 
     final String plan = "PLAN="
-        + "EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t1):CHAR(1) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL], expr#6=[CAST($t2):CHAR(1) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL], expr#7=[CAST($t3):BIGINT NOT NULL], X=[$t0], MIN_Y=[$t5], MAX_Y=[$t6], CNT_Y=[$t7], CNT_DIST_Y=[$t4])\n"
+        + "EnumerableCalc(expr#0..4=[{inputs}], expr#5=[CAST($t1):CHAR(1) NOT NULL], expr#6=[CAST($t2):CHAR(1) NOT NULL], expr#7=[CAST($t3):BIGINT NOT NULL], X=[$t0], MIN_Y=[$t5], MAX_Y=[$t6], CNT_Y=[$t7], CNT_DIST_Y=[$t4])\n"
         + "  EnumerableSort(sort0=[$0], dir0=[DESC])\n"
         + "    EnumerableAggregate(group=[{0}], MIN_Y=[MIN($2) FILTER $6], MAX_Y=[MIN($3) FILTER $6], CNT_Y=[MIN($4) FILTER $6], CNT_DIST_Y=[COUNT($1) FILTER $5])\n"
         + "      EnumerableCalc(expr#0..5=[{inputs}], expr#6=[0], expr#7=[=($t5, $t6)], expr#8=[1], expr#9=[=($t5, $t8)], proj#0..4=[{exprs}], $g_0=[$t7], $g_1=[$t9])\n"

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -847,6 +847,9 @@ ExInst<CalciteException> invalidTypesForComparison(String clazzName0, String op,
   @BaseMessage("Null key of JSON object is not allowed")
   ExInst<CalciteException> nullKeyOfJsonObjectNotAllowed();
 
+  @BaseMessage("Timeout of ''{0}'' ms for query execution is reached. Query execution started at ''{1}''")
+  ExInst<CalciteException> queryExecutionTimeoutReached(String timeout, String queryStart);
+
   @BaseMessage("While executing SQL [{0}] on JDBC sub-schema")
   ExInst<RuntimeException> exceptionWhilePerformingQueryOnJdbcSubSchema(String sql);
 }

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -146,6 +146,8 @@ public enum BuiltInMethod {
   JDBC_SCHEMA_DATA_SOURCE(JdbcSchema.class, "getDataSource"),
   ROW_VALUE(Row.class, "getObject", int.class),
   ROW_AS_COPY(Row.class, "asCopy", Object[].class),
+  RESULT_SET_ENUMERABLE_SET_TIMEOUT(ResultSetEnumerable.class, "setTimeout",
+      DataContext.class),
   RESULT_SET_ENUMERABLE_OF(ResultSetEnumerable.class, "of", DataSource.class,
       String.class, Function1.class),
   RESULT_SET_ENUMERABLE_OF_PREPARED(ResultSetEnumerable.class, "of",

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMethod.java
Patch:
@@ -22,6 +22,7 @@
 
 import java.lang.reflect.Method;
 import java.util.List;
+import java.util.Map;
 
 /**
  * Builtin methods in the Elasticsearch adapter.
@@ -35,7 +36,7 @@ enum ElasticsearchMethod {
       List.class, // sort
       List.class, // groupBy
       List.class, // aggregations
-      List.class, // expression mapping
+      Map.class, // item to expression mapping. Eg. _MAP['a.b.c'] and EXPR$1
       Long.class, // offset
       Long.class); // fetch
 

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRel.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.calcite.util.Pair;
 
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -72,7 +73,7 @@ class Implementor {
      *
      * @see SqlStdOperatorTable#ITEM
      */
-    final List<Map.Entry<String, String>> expressionItemMap = new ArrayList<>();
+    final Map<String, String> expressionItemMap = new LinkedHashMap<>();
 
     /**
      * Starting index (default {@code 0}). Equivalent to {@code start} in ES query.
@@ -112,7 +113,7 @@ void addAggregation(String field, String expression) {
     void addExpressionItemMapping(String expressionId, String item) {
       Objects.requireNonNull(expressionId, "expressionId");
       Objects.requireNonNull(item, "item");
-      expressionItemMap.add(new Pair<>(expressionId, item));
+      expressionItemMap.put(expressionId, item);
     }
 
     void offset(long offset) {

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
Patch:
@@ -122,7 +122,7 @@ private Enumerable<Object> find(List<String> ops,
       List<Map.Entry<String, RelFieldCollation.Direction>> sort,
       List<String> groupBy,
       List<Map.Entry<String, String>> aggregations,
-      List<Map.Entry<String, String>> mappings,
+      Map<String, String> mappings,
       Long offset, Long fetch) throws IOException {
 
     if (!aggregations.isEmpty() || !groupBy.isEmpty()) {
@@ -172,7 +172,7 @@ private Enumerable<Object> aggregate(List<String> ops,
       List<Map.Entry<String, RelFieldCollation.Direction>> sort,
       List<String> groupBy,
       List<Map.Entry<String, String>> aggregations,
-      List<Map.Entry<String, String>> mapping,
+      Map<String, String> mapping,
       Long offset, Long fetch) throws IOException {
 
     if (!groupBy.isEmpty() && offset != null) {
@@ -359,7 +359,7 @@ public Enumerable<Object> find(List<String> ops,
          List<Map.Entry<String, RelFieldCollation.Direction>> sort,
          List<String> groupBy,
          List<Map.Entry<String, String>> aggregations,
-         List<Map.Entry<String, String>> mappings,
+         Map<String, String> mappings,
          Long offset, Long fetch) {
       try {
         return getTable().find(ops, fields, sort, groupBy, aggregations, mappings, offset, fetch);

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchToEnumerableConverter.java
Patch:
@@ -82,15 +82,14 @@ public class ElasticsearchToEnumerableConverter extends ConverterImpl implements
     final Expression table = block.append("table",
         implementor.table
             .getExpression(ElasticsearchTable.ElasticsearchQueryable.class));
-    List<String> opList = implementor.list;
-    final Expression ops = block.append("ops", constantArrayList(opList, String.class));
+    final Expression ops = block.append("ops", Expressions.constant(implementor.list));
     final Expression sort = block.append("sort", constantArrayList(implementor.sort, Pair.class));
     final Expression groupBy = block.append("groupBy", Expressions.constant(implementor.groupBy));
     final Expression aggregations = block.append("aggregations",
         constantArrayList(implementor.aggregations, Pair.class));
 
     final Expression mappings = block.append("mappings",
-        constantArrayList(implementor.expressionItemMap, Pair.class));
+        Expressions.constant(implementor.expressionItemMap));
 
     final Expression offset = block.append("offset", Expressions.constant(implementor.offset));
     final Expression fetch = block.append("fetch", Expressions.constant(implementor.fetch));

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfig.java
Patch:
@@ -70,6 +70,8 @@ public interface CalciteConnectionConfig extends ConnectionConfig {
   <T> T typeSystem(Class<T> typeSystemClass, T defaultTypeSystem);
   /** @see CalciteConnectionProperty#CONFORMANCE */
   SqlConformance conformance();
+  /** @see CalciteConnectionProperty#TIME_ZONE */
+  @Override String timeZone();
 }
 
 // End CalciteConnectionConfig.java

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
Patch:
@@ -241,7 +241,7 @@ public RelDataTypeFamily getFamily() {
   /**
    * Generates a string representation of this type.
    *
-   * @param sb         StringBuffer into which to generate the string
+   * @param sb         StringBuilder into which to generate the string
    * @param withDetail when true, all detail information needed to compute a
    *                   unique digest (and return from getFullTypeString) should
    *                   be included;

File: core/src/main/java/org/apache/calcite/rex/RexProgram.java
Patch:
@@ -51,7 +51,7 @@
  * and optionally use a condition to filter rows.
  *
  * <p>Programs are immutable. It may help to use a {@link RexProgramBuilder},
- * which has the same relationship to {@link RexProgram} as {@link StringBuffer}
+ * which has the same relationship to {@link RexProgram} as {@link StringBuilder}
  * has to {@link String}.
  *
  * <p>A program can contain aggregate functions. If it does, the arguments to

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommandScript.java
Patch:
@@ -1391,7 +1391,6 @@ private String readLine(String line, BufferedReader in) throws IOException {
      */
     private String readSql(String startOfSql, BufferedReader in)
         throws IOException {
-      // REVIEW mb StringBuffer not always needed
       StringBuilder sql = new StringBuilder(startOfSql);
       sql.append('\n');
 

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -377,7 +377,7 @@ public static void verifyTypeEquivalence(
         + "set type is " + expectedRowType.getFullTypeString()
         + "\nexpression type is " + actualRowType.getFullTypeString()
         + "\nset is " + equivalenceClass.toString()
-        + "\nexpression is " + newRel.toString();
+        + "\nexpression is " + RelOptUtil.toString(newRel);
     throw new AssertionError(s);
   }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
Patch:
@@ -1100,6 +1100,7 @@ public boolean moveNext() {
                     }
                   }
                   inners = Linq4j.enumerator(list);
+                  outers.close();
                   outers = Linq4j.singletonNullEnumerator();
                   outers.moveNext();
                   unmatchedKeys = null; // don't do the 'leftovers' again

File: core/src/test/java/org/apache/calcite/test/QuidemTest.java
Patch:
@@ -55,6 +55,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.function.Function;
 
 import static org.junit.Assert.fail;
 
@@ -77,8 +78,8 @@ private static Object getEnv(String varName) {
     case "jdk18":
       return System.getProperty("java.version").startsWith("1.8");
     case "fixed":
-      // Quidem requires a Guava function
-      return (com.google.common.base.Function<String, Object>) v -> {
+      // Quidem requires a Java 8 function
+      return (Function<String, Object>) v -> {
         switch (v) {
         case "calcite1045":
           return Bug.CALCITE_1045_FIXED;

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.calcite.rel.RelDistributionTest;
 import org.apache.calcite.rel.rel2sql.RelToSqlConverterTest;
 import org.apache.calcite.rel.rules.DateRangeRulesTest;
+import org.apache.calcite.rel.rules.SortRemoveRuleTest;
 import org.apache.calcite.rex.RexBuilderTest;
 import org.apache.calcite.rex.RexExecutorTest;
 import org.apache.calcite.rex.RexSqlStandardConvertletTableTest;
@@ -182,6 +183,7 @@
     CoreQuidemTest.class,
     CalciteRemoteDriverTest.class,
     StreamTest.class,
+    SortRemoveRuleTest.class,
 
     // test cases
     TableInRootSchemaTest.class,

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/Linq4jSuite.java
Patch:
@@ -37,7 +37,8 @@
     BlockBuilderTest.class,
     FunctionTest.class,
     TypeTest.class,
-    CorrelateJoinTest.class
+    CorrelateJoinTest.class,
+    JoinPreserveOrderTest.class
     })
 public class Linq4jSuite {
 }

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.calcite.rel.rules.DateRangeRulesTest;
 import org.apache.calcite.rex.RexBuilderTest;
 import org.apache.calcite.rex.RexExecutorTest;
+import org.apache.calcite.rex.RexSqlStandardConvertletTableTest;
 import org.apache.calcite.runtime.BinarySearchTest;
 import org.apache.calcite.runtime.EnumerablesTest;
 import org.apache.calcite.sql.SqlSetOptionOperatorTest;
@@ -122,6 +123,7 @@
     InduceGroupingTypeTest.class,
     RelOptPlanReaderTest.class,
     RexBuilderTest.class,
+    RexSqlStandardConvertletTableTest.class,
     SqlTypeFactoryTest.class,
     SqlTypeUtilTest.class,
     SqlValidatorUtilTest.class,

File: core/src/main/java/org/apache/calcite/rel/rules/AbstractMaterializedViewRule.java
Patch:
@@ -301,8 +301,8 @@ protected void perform(RelOptRuleCall call, Project topProject, RelNode node) {
           // Extract view table references
           final Set<RelTableRef> viewTableRefs = mq.getTableReferences(viewNode);
           if (viewTableRefs == null) {
-            // Bail out
-            return;
+            // Skip it
+            continue;
           }
 
           // Extract view tables

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMethod.java
Patch:
@@ -35,6 +35,7 @@ enum ElasticsearchMethod {
       List.class, // sort
       List.class, // groupBy
       List.class, // aggregations
+      List.class, // expression mapping
       Long.class, // offset
       Long.class); // fetch
 

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -120,6 +120,7 @@ public class SqlDialect {
           .add(SqlStdOperatorTable.POWER)
           .add(SqlStdOperatorTable.RAND)
           .add(SqlStdOperatorTable.ROUND)
+          .add(SqlStdOperatorTable.ROW)
           .add(SqlStdOperatorTable.SIN)
           .add(SqlStdOperatorTable.SQRT)
           .add(SqlStdOperatorTable.SUBSTRING)
@@ -679,6 +680,7 @@ public boolean supportsFunction(SqlOperator operator, RelDataType type,
     case NVL:
     case OR:
     case PLUS:
+    case ROW:
     case TIMES:
       return true;
     default:

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -213,6 +213,8 @@ public Type getJavaClass(RelDataType type) {
         return ByteString.class;
       case GEOMETRY:
         return GeoFunctions.Geom.class;
+      case SYMBOL:
+        return Enum.class;
       case ANY:
         return Object.class;
       }

File: core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
Patch:
@@ -254,7 +254,7 @@ public AggregateCall rename(String name) {
   }
 
   public String toString() {
-    StringBuilder buf = new StringBuilder(aggFunction.getName());
+    StringBuilder buf = new StringBuilder(aggFunction.toString());
     buf.append("(");
     if (distinct) {
       buf.append((argList.size() == 0) ? "DISTINCT" : "DISTINCT ");

File: core/src/main/java/org/apache/calcite/sql/SqlJsonEmptyOrError.java
Patch:
@@ -23,10 +23,11 @@
  * EmptyOrErrorBehavior is invoked.
  */
 public enum SqlJsonEmptyOrError {
-  EMPTY, ERROR;
+  EMPTY,
+  ERROR;
 
   @Override public String toString() {
-    return String.format(Locale.ENGLISH, "SqlJsonEmptyOrError[%s]", name());
+    return String.format(Locale.ROOT, "SqlJsonEmptyOrError[%s]", name());
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/SqlJsonQueryEmptyOrErrorBehavior.java
Patch:
@@ -28,7 +28,7 @@ public enum SqlJsonQueryEmptyOrErrorBehavior {
   EMPTY_OBJECT;
 
   @Override public String toString() {
-    return String.format(Locale.ENGLISH,
+    return String.format(Locale.ROOT,
         "SqlJsonQueryEmptyOrErrorBehavior[%s]", name());
   }
 }

File: core/src/main/java/org/apache/calcite/sql/SqlJsonValueEmptyOrErrorBehavior.java
Patch:
@@ -27,7 +27,7 @@ public enum SqlJsonValueEmptyOrErrorBehavior {
   DEFAULT;
 
   @Override public String toString() {
-    return String.format(Locale.ENGLISH,
+    return String.format(Locale.ROOT,
         "SqlJsonValueEmptyOrErrorBehavior[%s]", name());
   }
 }

File: core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
Patch:
@@ -180,8 +180,8 @@ private void unparseFloor(SqlWriter writer, SqlCall call) {
 
   private void unparseSqlIntervalLiteralMssql(
       SqlWriter writer, SqlIntervalLiteral literal, int sign) {
-    SqlIntervalLiteral.IntervalValue interval
-        = (SqlIntervalLiteral.IntervalValue) literal.getValue();
+    final SqlIntervalLiteral.IntervalValue interval =
+        (SqlIntervalLiteral.IntervalValue) literal.getValue();
     unparseSqlIntervalQualifier(writer, interval.getIntervalQualifier(),
         RelDataTypeSystem.DEFAULT);
     writer.sep(",", true);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayFunction.java
Patch:
@@ -67,7 +67,7 @@ public SqlJsonArrayFunction() {
     final StringBuilder sb = new StringBuilder();
     sb.append("{0}(");
     for (int i = 1; i < operandsCount; i++) {
-      sb.append(String.format(Locale.ENGLISH, "{%d} ", i + 1));
+      sb.append(String.format(Locale.ROOT, "{%d} ", i + 1));
     }
     sb.append("{1})");
     return sb.toString();

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectFunction.java
Patch:
@@ -93,7 +93,7 @@ public SqlJsonObjectFunction() {
     StringBuilder sb = new StringBuilder();
     sb.append("{0}(");
     for (int i = 1; i < operandsCount; i++) {
-      sb.append(String.format(Locale.ENGLISH, "{%d} ", i + 1));
+      sb.append(String.format(Locale.ROOT, "{%d} ", i + 1));
     }
     sb.append("{1})");
     return sb.toString();

File: core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
Patch:
@@ -105,7 +105,8 @@ public MysqlSqlDialect(Context context) {
       return new SqlDataTypeSpec(new SqlIdentifier("CHAR", SqlParserPos.ZERO),
           type.getPrecision(), -1, null, null, SqlParserPos.ZERO);
     case INTEGER:
-      return new SqlDataTypeSpec(new SqlIdentifier("_UNSIGNED", SqlParserPos.ZERO),
+    case BIGINT:
+      return new SqlDataTypeSpec(new SqlIdentifier("_SIGNED", SqlParserPos.ZERO),
           type.getPrecision(), -1, null, null, SqlParserPos.ZERO);
     }
     return super.getCastSpec(type);

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -87,7 +87,6 @@
 import org.apache.calcite.tools.FrameworkConfig;
 import org.apache.calcite.tools.Frameworks;
 import org.apache.calcite.tools.RelBuilder;
-import org.apache.calcite.tools.RelBuilder.AggCall;
 import org.apache.calcite.util.BuiltInMethod;
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.ImmutableIntList;

File: core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
Patch:
@@ -168,7 +168,7 @@ private boolean implies2(RexNode first, RexNode second) {
     }
 
     // E.g. "x is null" implies "x is null".
-    if (RexUtil.eq(first, second)) {
+    if (first.equals(second)) {
       return true;
     }
 
@@ -184,7 +184,7 @@ private boolean implies2(RexNode first, RexNode second) {
       final RexNode operand = ((RexCall) second).getOperands().get(0);
       final Strong strong = new Strong() {
         @Override public boolean isNull(RexNode node) {
-          return RexUtil.eq(node, operand)
+          return node.equals(operand)
               || super.isNull(node);
         }
       };

File: core/src/main/java/org/apache/calcite/rel/core/Match.java
Patch:
@@ -277,7 +277,7 @@ private static class AggregateFinder extends RexVisitorImpl {
           }
           boolean update = true;
           for (RexMRAggCall rex : set) {
-            if (rex.toString().equals(aggCall.toString())) {
+            if (rex.equals(aggCall)) {
               update = false;
               break;
             }

File: core/src/main/java/org/apache/calcite/rel/mutable/MutableFilter.java
Patch:
@@ -43,13 +43,12 @@ public static MutableFilter of(MutableRel input, RexNode condition) {
   @Override public boolean equals(Object obj) {
     return obj == this
         || obj instanceof MutableFilter
-        && condition.toString().equals(
-            ((MutableFilter) obj).condition.toString())
+        && condition.equals(((MutableFilter) obj).condition)
         && input.equals(((MutableFilter) obj).input);
   }
 
   @Override public int hashCode() {
-    return Objects.hash(input, condition.toString());
+    return Objects.hash(input, condition);
   }
 
   @Override public StringBuilder digest(StringBuilder buf) {

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushExpressionsRule.java
Patch:
@@ -61,7 +61,7 @@ public JoinPushExpressionsRule(Class<? extends Join> clazz,
     // If the join is the same, we bail out
     if (newJoin instanceof Join) {
       final RexNode newCondition = ((Join) newJoin).getCondition();
-      if (join.getCondition().toString().equals(newCondition.toString())) {
+      if (join.getCondition().equals(newCondition)) {
         return;
       }
     }

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -547,7 +547,7 @@ protected static boolean reduceExpressions(RelNode rel, List<RexNode> expList,
     boolean simplified = false;
     for (int i = 0; i < expList.size(); i++) {
       RexNode expr2 = simplifier.apply(expList.get(i));
-      if (!expr2.toString().equals(expList.get(i).toString())) {
+      if (!expr2.equals(expList.get(i))) {
         expList.set(i, expr2);
         simplified = true;
       }

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -599,7 +599,7 @@ private static class ReplaceSubQueryShuttle extends RexShuttle {
     }
 
     @Override public RexNode visitSubQuery(RexSubQuery subQuery) {
-      return RexUtil.eq(subQuery, this.subQuery) ? replacement : subQuery;
+      return subQuery.equals(this.subQuery) ? replacement : subQuery;
     }
   }
 }

File: core/src/main/java/org/apache/calcite/rex/LogicVisitor.java
Patch:
@@ -115,7 +115,7 @@ public Logic visitCall(RexCall call, Logic logic) {
   }
 
   private Logic end(RexNode node, Logic arg) {
-    if (RexUtil.eq(node, seek)) {
+    if (node.equals(seek)) {
       logicCollection.add(arg);
     }
     return arg;

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -26,6 +26,7 @@
 
 import java.util.List;
 import java.util.Objects;
+import javax.annotation.Nonnull;
 
 /**
  * Call to an aggregate function over a window.
@@ -88,7 +89,7 @@ public boolean isDistinct() {
     return distinct;
   }
 
-  @Override protected String computeDigest(boolean withType) {
+  @Override protected @Nonnull String computeDigest(boolean withType) {
     final StringBuilder sb = new StringBuilder(op.getName());
     sb.append("(");
     if (distinct) {
@@ -98,8 +99,7 @@ public boolean isDistinct() {
       if (i > 0) {
         sb.append(", ");
       }
-      RexNode operand = operands.get(i);
-      sb.append(operand.toString());
+      sb.append(operands.get(i));
     }
     sb.append(")");
     if (withType) {

File: core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
Patch:
@@ -43,7 +43,7 @@ public class RexProgramBuilder {
   private final RexBuilder rexBuilder;
   private final RelDataType inputRowType;
   private final List<RexNode> exprList = new ArrayList<>();
-  private final Map<Pair<String, String>, RexLocalRef> exprMap =
+  private final Map<Pair<RexNode, String>, RexLocalRef> exprMap =
       new HashMap<>();
   private final List<RexLocalRef> localRefList = new ArrayList<>();
   private final List<RexLocalRef> projectRefList = new ArrayList<>();
@@ -329,7 +329,7 @@ private RexLocalRef registerInternal(RexNode expr, boolean force) {
     expr = simplify.simplifyPreservingType(expr);
 
     RexLocalRef ref;
-    final Pair<String, String> key;
+    final Pair<RexNode, String> key;
     if (expr instanceof RexLocalRef) {
       key = null;
       ref = (RexLocalRef) expr;

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRules.java
Patch:
@@ -149,8 +149,8 @@ static class RexToElasticsearchTranslator extends RexVisitorImpl<String> {
           return stripQuotes(strings.get(0)) + "[" + ((RexLiteral) op1).getValue2() + "]";
         }
       }
-      throw new IllegalArgumentException("Translation of " + call.toString()
-        + " is not supported by ElasticsearchProject");
+      throw new IllegalArgumentException("Translation of " + call
+          + " is not supported by ElasticsearchProject");
     }
 
     List<String> visitList(List<RexNode> list) {

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
Patch:
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.calcite.adapter.elasticsearch;
 
 import com.fasterxml.jackson.databind.node.ObjectNode;

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/ScrollingTest.java
Patch:
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.calcite.adapter.elasticsearch;
 
 import org.apache.calcite.jdbc.CalciteConnection;

File: core/src/main/java/org/apache/calcite/sql/type/AbstractSqlType.java
Patch:
@@ -24,6 +24,7 @@
 
 import java.io.Serializable;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Abstract base class for SQL implementations of {@link RelDataType}.
@@ -50,7 +51,7 @@ protected AbstractSqlType(
       boolean isNullable,
       List<? extends RelDataTypeField> fields) {
     super(fields);
-    this.typeName = typeName;
+    this.typeName = Objects.requireNonNull(typeName);
     this.isNullable = isNullable || (typeName == SqlTypeName.NULL);
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
Patch:
@@ -192,10 +192,9 @@ private RelDataType leastRestrictiveByCast(List<RelDataType> types) {
   @Override public RelDataType createTypeWithNullability(
       final RelDataType type,
       final boolean nullable) {
-    RelDataType newType;
+    final RelDataType newType;
     if (type instanceof BasicSqlType) {
-      BasicSqlType sqlType = (BasicSqlType) type;
-      newType = sqlType.createWithNullability(nullable);
+      newType = ((BasicSqlType) type).createWithNullability(nullable);
     } else if (type instanceof MapSqlType) {
       newType = copyMapType(type, nullable);
     } else if (type instanceof ArraySqlType) {

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -790,9 +790,6 @@ protected static class RexReplacer extends RexShuttle {
         return node;
       }
       node = super.visitCall(call);
-      if (node != call) {
-        node = simplify.simplifyUnknownAs(node, unknownAs);
-      }
       return node;
     }
 

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -943,7 +943,7 @@ private int getTypeOrdinal(RelDataType type) {
   }
 
   private static String getClassName(RelDataType type) {
-    return null;
+    return Object.class.getName(); // CALCITE-2613
   }
 
   private static int getScale(RelDataType type) {

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -846,6 +846,9 @@ ExInst<CalciteException> invalidTypesForComparison(String clazzName0, String op,
 
   @BaseMessage("Null key of JSON object is not allowed")
   ExInst<CalciteException> nullKeyOfJsonObjectNotAllowed();
+
+  @BaseMessage("While executing SQL [{0}] on JDBC sub-schema")
+  ExInst<RuntimeException> exceptionWhilePerformingQueryOnJdbcSubSchema(String sql);
 }
 
 // End CalciteResource.java

File: core/src/main/java/org/apache/calcite/sql/SqlDynamicParam.java
Patch:
@@ -61,8 +61,7 @@ public void unparse(
       SqlWriter writer,
       int leftPrec,
       int rightPrec) {
-    writer.print("?");
-    writer.setNeedWhitespace(true);
+    writer.dynamicParam(index);
   }
 
   public void validate(SqlValidator validator, SqlValidatorScope scope) {

File: core/src/main/java/org/apache/calcite/sql/SqlNode.java
Patch:
@@ -149,8 +149,7 @@ public SqlString toSqlString(SqlDialect dialect, boolean forceParens) {
     writer.setSelectListItemsOnSeparateLines(false);
     writer.setIndentation(0);
     unparse(writer, 0, 0);
-    final String sql = writer.toString();
-    return new SqlString(dialect, sql);
+    return writer.toSqlString();
   }
 
   public SqlString toSqlString(SqlDialect dialect) {

File: plus/src/main/java/org/apache/calcite/chinook/CalciteConnectionProvider.java
Patch:
@@ -32,13 +32,13 @@
  */
 public class CalciteConnectionProvider {
 
-  private static final String DRIVER_URL = "jdbc:calcite:";
+  public static final String DRIVER_URL = "jdbc:calcite:";
 
   public Connection connection() throws IOException, SQLException {
     return DriverManager.getConnection(DRIVER_URL, provideConnectionInfo());
   }
 
-  private Properties provideConnectionInfo() throws IOException {
+  public Properties provideConnectionInfo() throws IOException {
     Properties info = new Properties();
     info.setProperty("lex", "MYSQL");
     info.setProperty("model", "inline:" + provideSchema());

File: plus/src/main/java/org/apache/calcite/chinook/ConnectionFactory.java
Patch:
@@ -30,13 +30,13 @@ public class ConnectionFactory implements Quidem.ConnectionFactory {
   private static final CalciteConnectionProvider CALCITE = new CalciteConnectionProvider();
 
   public Connection connect(String db, boolean bln) throws Exception {
-    return DBWrapper.valueOf(db).connection();
+    return DatabaseWrapper.valueOf(db).connection();
   }
 
   /**
    * Wrapping with Fairy environmental decoration
    */
-  private enum DBWrapper {
+  public enum DatabaseWrapper {
     CALCITE_AS_ADMIN {
       @Override public Connection connection() throws Exception {
         EnvironmentFairy.login(EnvironmentFairy.User.ADMIN);

File: plus/src/test/java/org/apache/calcite/test/PlusSuite.java
Patch:
@@ -20,6 +20,7 @@
 import org.apache.calcite.adapter.tpcds.TpcdsTest;
 import org.apache.calcite.adapter.tpch.TpchTest;
 import org.apache.calcite.chinook.EndToEndTest;
+import org.apache.calcite.chinook.RemotePreparedStatementParametersTest;
 
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;
@@ -32,7 +33,8 @@
     OsAdapterTest.class,
     TpcdsTest.class,
     TpchTest.class,
-    EndToEndTest.class
+    EndToEndTest.class,
+    RemotePreparedStatementParametersTest.class
     })
 public class PlusSuite {
 }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.calcite.sql.SqlWriter;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
+import org.apache.calcite.util.Optionality;
 
 /**
  * The <code>JSON_OBJECTAGG</code> aggregation function.
@@ -44,7 +45,8 @@ public SqlJsonArrayAggAggFunction(String name, SqlJsonConstructorNullClause null
         OperandTypes.ANY,
         SqlFunctionCategory.SYSTEM,
         false,
-        false
+        false,
+        Optionality.FORBIDDEN
     );
     this.name = name;
     this.nullClause = nullClause;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlTypeFamily;
+import org.apache.calcite.util.Optionality;
 
 /**
  * The <code>JSON_OBJECTAGG</code> aggregation function.
@@ -45,7 +46,8 @@ public SqlJsonObjectAggAggFunction(String name, SqlJsonConstructorNullClause nul
         OperandTypes.family(SqlTypeFamily.CHARACTER, SqlTypeFamily.ANY),
         SqlFunctionCategory.SYSTEM,
         false,
-        false
+        false,
+        Optionality.FORBIDDEN
     );
     this.name = name;
     this.nullClause = nullClause;

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -39,7 +39,6 @@
 import org.apache.calcite.sql.parser.SqlParseException;
 import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.sql.validate.SqlConformance;
-import org.apache.calcite.sql.validate.SqlConformanceEnum;
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.sql2rel.RelDecorrelator;
 import org.apache.calcite.sql2rel.SqlRexConvertletTable;
@@ -202,7 +201,7 @@ private SqlConformance conformance() {
         return connectionConfig.conformance();
       }
     }
-    return SqlConformanceEnum.DEFAULT;
+    return config.getParserConfig().conformance();
   }
 
   public Pair<SqlNode, RelDataType> validateAndGetType(SqlNode sqlNode)

File: core/src/main/java/org/apache/calcite/model/ModelHandler.java
Patch:
@@ -527,8 +527,10 @@ public void visit(JsonFunction jsonFunction) {
   public void visit(JsonMeasure jsonMeasure) {
     checkRequiredAttributes(jsonMeasure, "agg");
     assert latticeBuilder != null;
+    final boolean distinct = false; // no distinct field in JsonMeasure.yet
     final Lattice.Measure measure =
-        latticeBuilder.resolveMeasure(jsonMeasure.agg, jsonMeasure.args);
+        latticeBuilder.resolveMeasure(jsonMeasure.agg, distinct,
+            jsonMeasure.args);
     if (tileBuilder != null) {
       tileBuilder.addMeasure(measure);
     } else if (latticeBuilder != null) {

File: core/src/main/java/org/apache/calcite/plan/RelOptLattice.java
Patch:
@@ -40,7 +40,7 @@ public RelOptLattice(Lattice lattice, RelOptTable starRelOptTable) {
   }
 
   public RelOptTable rootTable() {
-    return lattice.nodes.get(0).scan.getTable();
+    return lattice.rootNode.relOptTable();
   }
 
   /** Rewrites a relational expression to use a lattice.

File: core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
Patch:
@@ -89,7 +89,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
     if (this.fieldCounts == null) {
       this.fieldCounts = ImmutableIntList.copyOf(fieldCounts);
     }
-    return typeFactory.createStructType(typeList, lattice.uniqueColumnNames);
+    return typeFactory.createStructType(typeList, lattice.uniqueColumnNames());
   }
 
   public RelNode toRel(RelOptTable.ToRelContext context, RelOptTable table) {

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.TestKtTest;
 import org.apache.calcite.adapter.clone.ArrayTableTest;
 import org.apache.calcite.jdbc.CalciteRemoteDriverTest;
+import org.apache.calcite.materialize.LatticeSuggesterTest;
 import org.apache.calcite.plan.RelOptPlanReaderTest;
 import org.apache.calcite.plan.RelOptUtilTest;
 import org.apache.calcite.plan.RelTraitTest;
@@ -170,6 +171,7 @@
     CalciteSqlOperatorTest.class,
     RexProgramFuzzyTest.class,
     ProfilerTest.class,
+    LatticeSuggesterTest.class,
     LatticeTest.class,
     ReflectiveSchemaTest.class,
     SqlAdvisorJdbcTest.class,

File: core/src/test/java/org/apache/calcite/test/UdfTest.java
Patch:
@@ -594,7 +594,9 @@ private CalciteAssert.AssertThat withUdf() {
         .throws_("No match found for function signature MY_SUM3(<NUMERIC>, "
             + "<NUMERIC>, <APPROXIMATE_NUMERIC>)");
     with.query("select \"adhoc\".my_sum3(\"empid\",\"deptno\",\"name\") as p "
-        + "from \"adhoc\".EMPLOYEES\n");
+        + "from \"adhoc\".EMPLOYEES\n")
+        .throws_("No match found for function signature MY_SUM3(<NUMERIC>, "
+            + "<NUMERIC>, <CHARACTER>)");
     with.query("select \"adhoc\".my_sum2(\"commission\",250) as p "
         + "from \"adhoc\".EMPLOYEES\n")
         .returns("P=1500\n");

File: core/src/test/java/org/apache/calcite/test/RelOptTestBase.java
Patch:
@@ -219,7 +219,7 @@ protected void checkPlanning(Tester tester, HepProgram preProgram,
       diffRepos.assertEquals("planAfter", "${planAfter}", planAfter);
       if (planBefore.equals(planAfter)) {
         throw new AssertionError("Expected plan before and after is the same.\n"
-            + "You must use unchanged=true or call checkPlanUnchanged");
+            + "You must use unchanged=true or call checkUnchanged");
       }
     }
     SqlToRelTestBase.assertValid(r);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -201,6 +201,7 @@
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SIN;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SINGLE_VALUE;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SLICE;
+import static org.apache.calcite.sql.fun.SqlStdOperatorTable.STRUCT_ACCESS;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SUBMULTISET_OF;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SUBSTRING;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SUM;
@@ -369,6 +370,7 @@ public Expression implement(RexToLixTranslator translator,
         NullPolicy.STRICT);
     defineMethod(SLICE, BuiltInMethod.SLICE.method, NullPolicy.NONE);
     defineMethod(ELEMENT, BuiltInMethod.ELEMENT.method, NullPolicy.STRICT);
+    defineMethod(STRUCT_ACCESS, BuiltInMethod.STRUCT_ACCESS.method, NullPolicy.ANY);
     defineMethod(MEMBER_OF, BuiltInMethod.MEMBER_OF.method, NullPolicy.NONE);
     final MethodImplementor isEmptyImplementor =
         new MethodImplementor(BuiltInMethod.IS_EMPTY.method);

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -196,9 +196,9 @@ private StandardConvertletTable() {
 
     // "DOT"
     registerOp(SqlStdOperatorTable.DOT,
-        (cx, call) -> cx.getRexBuilder().makeCall(SqlStdOperatorTable.DOT,
+        (cx, call) -> cx.getRexBuilder().makeFieldAccess(
             cx.convertExpression(call.operand(0)),
-            cx.getRexBuilder().makeLiteral(call.operand(1).toString())));
+            call.operand(1).toString(), false));
     // "AS" has no effect, so expand "x AS id" into "x".
     registerOp(SqlStdOperatorTable.AS,
         (cx, call) -> cx.convertExpression(call.operand(0)));

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -432,7 +432,8 @@ public enum BuiltInMethod {
   CONTEXT_VALUES(Context.class, "values", true),
   CONTEXT_ROOT(Context.class, "root", true),
   DATA_CONTEXT_GET_QUERY_PROVIDER(DataContext.class, "getQueryProvider"),
-  METADATA_REL(Metadata.class, "rel");
+  METADATA_REL(Metadata.class, "rel"),
+  STRUCT_ACCESS(SqlFunctions.class, "structAccess", Object.class, int.class, String.class);
 
   public final Method method;
   public final Constructor constructor;

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -427,7 +427,7 @@ private void simplifyOrTerms(List<RexNode> terms) {
       final RexNode t2 = simplify.simplify(t, RexUnknownAs.UNKNOWN);
       terms.set(i, t2);
       final RexNode inverse =
-          simplify.simplify(rexBuilder.makeCall(SqlStdOperatorTable.NOT, t2),
+          simplify.simplify(rexBuilder.makeCall(SqlStdOperatorTable.IS_NOT_TRUE, t2),
               RexUnknownAs.UNKNOWN);
       final RelOptPredicateList newPredicates = simplify.predicates.union(rexBuilder,
           RelOptPredicateList.of(rexBuilder, ImmutableList.of(inverse)));

File: core/src/test/java/org/apache/calcite/test/fuzzer/RexProgramFuzzyTest.java
Patch:
@@ -119,7 +119,6 @@ private TopN(int n) {
   /**
    * Verifies {@code IS TRUE(IS NULL(null))} kind of expressions up to 4 level deep.
    */
-  @Ignore("[CALCITE-2556] RexSimplify: not(trueLiteral) could be simplified to false")
   @Test public void testNestedCalls() {
     nestedCalls(trueLiteral);
     nestedCalls(falseLiteral);

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -580,7 +580,7 @@ private RexNode simplifyCoalesce(RexCall call) {
     final RexSimplify simplify = withUnknownAsFalse(false);
     for (RexNode operand : call.getOperands()) {
       operand = simplify.simplify_(operand);
-      if (digests.add(operand.digest)) {
+      if (digests.add(operand.toString())) {
         operands.add(operand);
       }
       if (!operand.getType().isNullable()) {

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
Patch:
@@ -48,7 +48,7 @@ public class GeodeFilter extends Filter implements GeodeRel {
 
   private final String match;
 
-  public GeodeFilter(RelOptCluster cluster, RelTraitSet traitSet,
+  GeodeFilter(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode input, RexNode condition) {
 
     super(cluster, traitSet, input, condition);
@@ -70,7 +70,7 @@ public GeodeFilter(RelOptCluster cluster, RelTraitSet traitSet,
 
   @Override public void implement(GeodeImplementContext geodeImplementContext) {
     // first call the input down the tree.
-    ((GeodeRel) getInput()).implement(geodeImplementContext);
+    geodeImplementContext.visitChild(getInput());
     geodeImplementContext.addPredicates(Collections.singletonList(match));
   }
 

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeProject.java
Patch:
@@ -39,7 +39,7 @@
  */
 public class GeodeProject extends Project implements GeodeRel {
 
-  public GeodeProject(RelOptCluster cluster, RelTraitSet traitSet,
+  GeodeProject(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode input, List<? extends RexNode> projects, RelDataType rowType) {
     super(cluster, traitSet, input, projects, rowType);
     assert getConvention() == GeodeRel.CONVENTION;
@@ -56,8 +56,7 @@ public GeodeProject(RelOptCluster cluster, RelTraitSet traitSet,
   }
 
   @Override public void implement(GeodeImplementContext geodeImplementContext) {
-
-    ((GeodeRel) getInput()).implement(geodeImplementContext);
+    geodeImplementContext.visitChild(getInput());
 
     final RexToGeodeTranslator translator =
         new RexToGeodeTranslator(

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSchemaFactory.java
Patch:
@@ -24,6 +24,7 @@
 
 import com.google.common.collect.ImmutableList;
 
+import java.util.Arrays;
 import java.util.Map;
 
 /**
@@ -61,8 +62,8 @@ public synchronized Schema create(SchemaPlus parentSchema, String name,
           GeoFunctions.class.getName(), "*", true);
     }
 
-    return new GeodeSchema(locatorHost, locatorPort, regionNames,
-        pbxSerializablePackagePath, parentSchema);
+    return new GeodeSchema(locatorHost, locatorPort, Arrays.asList(regionNames),
+        pbxSerializablePackagePath);
   }
 }
 

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTableScan.java
Patch:
@@ -44,7 +44,7 @@ public class GeodeTableScan extends TableScan implements GeodeRel {
    * @param geodeTable     Geode table
    * @param projectRowType Fields and types to project; null to project raw row
    */
-  protected GeodeTableScan(RelOptCluster cluster, RelTraitSet traitSet,
+  GeodeTableScan(RelOptCluster cluster, RelTraitSet traitSet,
       RelOptTable table, GeodeTable geodeTable, RelDataType projectRowType) {
     super(cluster, traitSet, table);
     this.geodeTable = geodeTable;

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -577,8 +577,9 @@ private RexNode simplifyIsNull(RexNode a) {
   private RexNode simplifyCoalesce(RexCall call) {
     final Set<String> digests = new HashSet<>();
     final List<RexNode> operands = new ArrayList<>();
+    final RexSimplify simplify = withUnknownAsFalse(false);
     for (RexNode operand : call.getOperands()) {
-      operand = simplify_(operand);
+      operand = simplify.simplify_(operand);
       if (digests.add(operand.digest)) {
         operands.add(operand);
       }

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -1210,7 +1210,8 @@ private void checkExponentialCnf(int n) {
     checkSimplify(coalesce(iRef, literal1), "COALESCE(?0.i, 1)");
     checkSimplify(coalesce(iRef, plus(iRef, hRef), literal1, hRef),
         "COALESCE(?0.i, +(?0.i, ?0.h), 1)");
-
+    checkSimplify2(coalesce(gt(nullInt, nullInt), trueLiteral),
+        "COALESCE(null, true)", "COALESCE(null, true)");
     // "(not x) is null" to "x is null"
     checkSimplify(isNull(not(vBool())), "IS NULL(?0.bool0)");
     checkSimplify(isNull(not(vBoolNotNull())), "false");

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -705,11 +705,11 @@ private RexNode simplifyCase(RexCall call) {
           notTerms.add(pair.e.getKey());
         }
       }
-      final RexNode disjunction = RexUtil.composeDisjunction(rexBuilder, terms);
+      RexNode disjunction = RexUtil.composeDisjunction(rexBuilder, terms);
       if (!call.getType().equals(disjunction.getType())) {
-        return rexBuilder.makeCast(call.getType(), disjunction);
+        disjunction = rexBuilder.makeCast(call.getType(), disjunction);
       }
-      return disjunction;
+      return simplify_(disjunction);
     }
     if (newOperands.equals(operands)) {
       return call;

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -1872,7 +1872,9 @@ public static RexNode andNot(final RexBuilder rexBuilder, RexNode e,
                 RexCall call2 = (RexCall) e2;
                 if (call2.getOperands().get(0)
                     .equals(call.getOperands().get(0))
-                    && call2.getOperands().get(1) instanceof RexLiteral) {
+                    && call2.getOperands().get(1) instanceof RexLiteral
+                    && !call.getOperands().get(1)
+                          .equals(call2.getOperands().get(1))) {
                   return false;
                 }
               }

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -1250,6 +1250,9 @@ private RexNode simplifyCast(RexCall e) {
       return Objects.requireNonNull(
           Iterables.getOnlyElement(reducedValues));
     default:
+      if (operand.getType().equals(e.getType())) {
+        return simplify_(operand);
+      }
       return e;
     }
   }

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -2435,7 +2435,7 @@ private void checkReduceNullableToNotNull(ReduceExpressionsRule rule) {
         .build();
 
     // The resulting plan should have no cast expressions
-    checkPlanning(program,
+    checkPlanUnchanged(new HepPlanner(program),
         "select cast(d.name as varchar(128)), cast(e.empno as integer) "
             + "from dept as d inner join emp as e "
             + "on cast(d.deptno as integer) = cast(e.deptno as integer) "

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
Patch:
@@ -99,7 +99,7 @@ String translateMatch(RexNode condition) throws IOException,
       QueryBuilders.constantScoreQuery(PredicateAnalyzer.analyze(condition)).writeJson(generator);
       generator.flush();
       generator.close();
-      return "\"query\" : " + writer.toString();
+      return "{\"query\" : " + writer.toString() + "}";
     }
   }
 

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
Patch:
@@ -102,7 +102,7 @@ public class ElasticsearchProject extends Project implements ElasticsearchRel {
     }
 
     implementor.list.removeIf(l -> l.startsWith("\"_source\""));
-    implementor.add(query.toString());
+    implementor.add("{" + query.toString() + "}");
   }
 }
 

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -441,8 +441,6 @@ private RexNode simplifyIsPredicate(SqlKind kind, RexNode a) {
       }
       if (kind == pred.kind) {
         return rexBuilder.makeLiteral(true);
-      } else {
-        return rexBuilder.makeLiteral(false);
       }
     }
     return null;

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraProject.java
Patch:
@@ -61,7 +61,7 @@ public void implement(Implementor implementor) {
         new CassandraRules.RexToCassandraTranslator(
             (JavaTypeFactory) getCluster().getTypeFactory(),
             CassandraRules.cassandraFieldNames(getInput().getRowType()));
-    final Map<String, String> fields = new LinkedHashMap<String, String>();
+    final Map<String, String> fields = new LinkedHashMap<>();
     for (Pair<RexNode, String> pair : getNamedProjects()) {
       final String name = pair.right;
       final String originalName = pair.left.accept(translator);

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRel.java
Patch:
@@ -37,11 +37,11 @@ public interface CassandraRel extends RelNode {
   /** Callback for the implementation process that converts a tree of
    * {@link CassandraRel} nodes into a CQL query. */
   class Implementor {
-    final Map<String, String> selectFields = new LinkedHashMap<String, String>();
-    final List<String> whereClause = new ArrayList<String>();
+    final Map<String, String> selectFields = new LinkedHashMap<>();
+    final List<String> whereClause = new ArrayList<>();
     int offset = 0;
     int fetch = -1;
-    final List<String> order = new ArrayList<String>();
+    final List<String> order = new ArrayList<>();
 
     RelOptTable table;
     CassandraTable cassandraTable;

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraRules.java
Patch:
@@ -129,7 +129,7 @@ private CassandraFilterRule() {
       // Get field names from the scan operation
       CassandraTableScan scan = call.rel(1);
       Pair<List<String>, List<String>> keyFields = scan.cassandraTable.getKeyFields();
-      Set<String> partitionKeys = new HashSet<String>(keyFields.left);
+      Set<String> partitionKeys = new HashSet<>(keyFields.left);
       List<String> fieldNames = CassandraRules.cassandraFieldNames(filter.getInput().getRowType());
 
       List<RexNode> disjunctions = RelOptUtil.disjunctions(condition);

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSort.java
Patch:
@@ -63,7 +63,7 @@ public void implement(Implementor implementor) {
     implementor.visitChild(0, getInput());
 
     List<RelFieldCollation> sortCollations = collation.getFieldCollations();
-    List<String> fieldOrder = new ArrayList<String>();
+    List<String> fieldOrder = new ArrayList<>();
     if (!sortCollations.isEmpty()) {
       // Construct a series of order clauses from the desired collation
       final List<RelDataTypeField> fields = getRowType().getFieldList();

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java
Patch:
@@ -93,7 +93,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
                       }
                     }),
                 Pair.class));
-    List<Map.Entry<String, String>> selectList = new ArrayList<Map.Entry<String, String>>();
+    List<Map.Entry<String, String>> selectList = new ArrayList<>();
     for (Map.Entry<String, String> entry
             : Pair.zip(cassandraImplementor.selectFields.keySet(),
                 cassandraImplementor.selectFields.values())) {

File: core/src/main/java/org/apache/calcite/Demo.java
Patch:
@@ -26,7 +26,7 @@ private Demo() {
   }
 
   public static void main(String[] args) {
-    ArrayList<String> names = new ArrayList<String>();
+    ArrayList<String> names = new ArrayList<>();
     names.add("John");
     names.add("Paul");
     names.add("George");

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
Patch:
@@ -180,7 +180,7 @@ private ClassDeclaration classDecl(
             type.getName(),
             null,
             ImmutableList.of(Serializable.class),
-            new ArrayList<MemberDeclaration>());
+            new ArrayList<>());
 
     // For each field:
     //   public T0 f0;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableModify.java
Patch:
@@ -104,7 +104,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
       final JavaRowFormat format = EnumerableTableScan.deduceFormat(table);
       PhysType physType =
           PhysTypeImpl.of(typeFactory, table.getRowType(), format);
-      List<Expression> expressionList = new ArrayList<Expression>();
+      List<Expression> expressionList = new ArrayList<>();
       final PhysType childPhysType = result.physType;
       final ParameterExpression o_ =
           Expressions.parameter(childPhysType.getJavaRowType(), "o");

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java
Patch:
@@ -88,10 +88,10 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
             pref.preferCustom());
     final Type rowClass = physType.getJavaRowType();
 
-    final List<Expression> expressions = new ArrayList<Expression>();
+    final List<Expression> expressions = new ArrayList<>();
     final List<RelDataTypeField> fields = rowType.getFieldList();
     for (List<RexLiteral> tuple : tuples) {
-      final List<Expression> literals = new ArrayList<Expression>();
+      final List<Expression> literals = new ArrayList<>();
       for (Pair<RelDataTypeField, RexLiteral> pair
           : Pair.zip(fields, tuple)) {
         literals.add(

File: core/src/main/java/org/apache/calcite/adapter/enumerable/NestedBlockBuilderImpl.java
Patch:
@@ -32,9 +32,9 @@
  * @see org.apache.calcite.adapter.enumerable.StrictAggImplementor#implementAdd(AggContext, AggAddContext)
  */
 public class NestedBlockBuilderImpl implements NestedBlockBuilder {
-  private final List<BlockBuilder> blocks = new ArrayList<BlockBuilder>();
+  private final List<BlockBuilder> blocks = new ArrayList<>();
   private final List<Map<RexNode, Boolean>> nullables =
-      new ArrayList<Map<RexNode, Boolean>>();
+      new ArrayList<>();
 
   /**
    * Constructs nested block builders starting of a given code block.
@@ -83,7 +83,7 @@ public final void nestBlock(BlockBuilder block,
     if (nullables == null || nullables.isEmpty()) {
       next = prev;
     } else {
-      next = new HashMap<RexNode, Boolean>(nullables);
+      next = new HashMap<>(nullables);
       next.putAll(prev);
       next = Collections.unmodifiableMap(next);
     }

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -184,7 +184,7 @@ private void generateGet(EnumerableRelImplementor implementor,
     final Primitive primitive = Primitive.ofBoxOr(physType.fieldClass(i));
     final RelDataType fieldType =
         physType.getRowType().getFieldList().get(i).getType();
-    final List<Expression> dateTimeArgs = new ArrayList<Expression>();
+    final List<Expression> dateTimeArgs = new ArrayList<>();
     dateTimeArgs.add(Expressions.constant(i + 1));
     SqlTypeName sqlTypeName = fieldType.getSqlTypeName();
     boolean offset = false;

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -534,7 +534,7 @@ public Sink sink(RelNode rel) {
         nodeInfo = new NodeInfo(rel, null);
         nodes.put(rel, nodeInfo);
         for (Edge edge : edges2) {
-          nodeInfo.sinks.put(edge, new ListSink(new ArrayDeque<Row>()));
+          nodeInfo.sinks.put(edge, new ListSink(new ArrayDeque<>()));
         }
       }
       if (edges.size() == 1) {

File: core/src/main/java/org/apache/calcite/interpreter/JaninoRexCompiler.java
Patch:
@@ -147,9 +147,7 @@ static Scalar baz(ParameterExpression context_,
     }
     try {
       return getScalar(classDeclaration, s);
-    } catch (CompileException e) {
-      throw new RuntimeException(e);
-    } catch (IOException e) {
+    } catch (CompileException | IOException e) {
       throw new RuntimeException(e);
     }
   }

File: core/src/main/java/org/apache/calcite/plan/MulticastRelOptListener.java
Patch:
@@ -34,7 +34,7 @@ public class MulticastRelOptListener implements RelOptListener {
    * Creates a new empty multicast listener.
    */
   public MulticastRelOptListener() {
-    listeners = new ArrayList<RelOptListener>();
+    listeners = new ArrayList<>();
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
Patch:
@@ -56,14 +56,14 @@ static <T extends RelMultipleTrait> RelCompositeTrait<T> of(RelTraitDef def,
       List<T> traitList) {
     final RelCompositeTrait<T> compositeTrait;
     if (traitList.isEmpty()) {
-      compositeTrait = new EmptyCompositeTrait<T>(def);
+      compositeTrait = new EmptyCompositeTrait<>(def);
     } else {
       final RelMultipleTrait[] traits =
           traitList.toArray(new RelMultipleTrait[0]);
       for (int i = 0; i < traits.length; i++) {
         traits[i] = (T) def.canonize(traits[i]);
       }
-      compositeTrait = new RelCompositeTrait<T>(def, (T[]) traits);
+      compositeTrait = new RelCompositeTrait<>(def, (T[]) traits);
     }
     return def.canonizeComposite(compositeTrait);
   }
@@ -120,7 +120,7 @@ RelCompositeTrait<T> canonize(RelTraitDef<T> traitDef) {
     }
     assert false;
     // TODO: cache duplicate composites
-    return new RelCompositeTrait<T>(traitDef, newTraits);
+    return new RelCompositeTrait<>(traitDef, newTraits);
   }
 
   public T trait(int i) {

File: core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
Patch:
@@ -91,7 +91,7 @@ public class RelOptCluster {
   public static RelOptCluster create(RelOptPlanner planner,
       RexBuilder rexBuilder) {
     return new RelOptCluster(planner, rexBuilder.getTypeFactory(),
-        rexBuilder, new AtomicInteger(0), new HashMap<String, RelNode>());
+        rexBuilder, new AtomicInteger(0), new HashMap<>());
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/plan/RelOptCostImpl.java
Patch:
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.plan;
 
-import org.apache.calcite.runtime.Utilities;
-
 /**
  * RelOptCostImpl provides a default implementation for the {@link RelOptCost}
  * interface. It it defined in terms of a single scalar quantity; somewhat
@@ -70,7 +68,7 @@ public boolean isLt(RelOptCost other) {
   }
 
   @Override public int hashCode() {
-    return Utilities.hashCode(getRows());
+    return Double.hashCode(getRows());
   }
 
   // implement RelOptCost

File: core/src/main/java/org/apache/calcite/plan/RelOptQuery.java
Patch:
@@ -58,7 +58,7 @@ public class RelOptQuery {
    */
   @Deprecated // to be removed before 2.0
   public RelOptQuery(RelOptPlanner planner) {
-    this(planner, new AtomicInteger(0), new HashMap<String, RelNode>());
+    this(planner, new AtomicInteger(0), new HashMap<>());
   }
 
   /** For use by RelOptCluster only. */

File: core/src/main/java/org/apache/calcite/plan/RelTraitSet.java
Patch:
@@ -539,8 +539,7 @@ public RelTraitSet simplify() {
 
   /** Cache of trait sets. */
   private static class Cache {
-    final Map<List<RelTrait>, RelTraitSet> map =
-        new HashMap<List<RelTrait>, RelTraitSet>();
+    final Map<List<RelTrait>, RelTraitSet> map = new HashMap<>();
 
     Cache() {
     }

File: core/src/main/java/org/apache/calcite/plan/TableAccessMap.java
Patch:
@@ -84,7 +84,7 @@ public TableAccessMap(RelNode rel) {
     // input rel, because we use it for cached statements, and we don't
     // want to retain any rel references after preparation completes.
 
-    accessMap = new HashMap<List<String>, Mode>();
+    accessMap = new HashMap<>();
     RelOptUtil.go(
         new TableRelVisitor(),
         rel);
@@ -97,7 +97,7 @@ public TableAccessMap(RelNode rel) {
    * @param mode  access mode for the table
    */
   public TableAccessMap(List<String> table, Mode mode) {
-    accessMap = new HashMap<List<String>, Mode>();
+    accessMap = new HashMap<>();
     accessMap.put(table, mode);
   }
 

File: core/src/main/java/org/apache/calcite/plan/hep/HepInstruction.java
Patch:
@@ -186,7 +186,7 @@ void initialize(boolean clearCache) {
         return;
       }
 
-      ruleSet = new HashSet<RelOptRule>();
+      ruleSet = new HashSet<>();
       collecting = true;
     }
 

File: core/src/main/java/org/apache/calcite/plan/hep/HepProgramBuilder.java
Patch:
@@ -30,8 +30,7 @@
 public class HepProgramBuilder {
   //~ Instance fields --------------------------------------------------------
 
-  private final List<HepInstruction> instructions =
-      new ArrayList<HepInstruction>();
+  private final List<HepInstruction> instructions = new ArrayList<>();
 
   private HepInstruction.BeginGroup group;
 

File: core/src/main/java/org/apache/calcite/plan/hep/HepRuleCall.java
Patch:
@@ -46,7 +46,7 @@ public class HepRuleCall extends RelOptRuleCall {
       List<RelNode> parents) {
     super(planner, operand, rels, nodeChildren, parents);
 
-    results = new ArrayList<RelNode>();
+    results = new ArrayList<>();
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
Patch:
@@ -277,9 +277,9 @@ void add(RelNode rel) {
           "rowtype of set", getRowType(), Litmus.THROW);
     }
     set.addInternal(rel);
-    Set<CorrelationId> variablesSet = RelOptUtil.getVariablesSet(rel);
-    Set<CorrelationId> variablesStopped = rel.getVariablesSet();
     if (false) {
+      Set<CorrelationId> variablesSet = RelOptUtil.getVariablesSet(rel);
+      Set<CorrelationId> variablesStopped = rel.getVariablesSet();
       Set<CorrelationId> variablesPropagated =
           Util.minus(variablesSet, variablesStopped);
       assert set.variablesPropagated.containsAll(variablesPropagated);

File: core/src/main/java/org/apache/calcite/rel/core/JoinInfo.java
Patch:
@@ -53,9 +53,9 @@ protected JoinInfo(ImmutableIntList leftKeys, ImmutableIntList rightKeys) {
 
   /** Creates a {@code JoinInfo} by analyzing a condition. */
   public static JoinInfo of(RelNode left, RelNode right, RexNode condition) {
-    final List<Integer> leftKeys = new ArrayList<Integer>();
-    final List<Integer> rightKeys = new ArrayList<Integer>();
-    final List<Boolean> filterNulls = new ArrayList<Boolean>();
+    final List<Integer> leftKeys = new ArrayList<>();
+    final List<Integer> rightKeys = new ArrayList<>();
+    final List<Boolean> filterNulls = new ArrayList<>();
     RexNode remaining =
         RelOptUtil.splitJoinCondition(left, right, condition, leftKeys,
             rightKeys, filterNulls);

File: core/src/main/java/org/apache/calcite/rel/core/SetOp.java
Patch:
@@ -82,7 +82,7 @@ public abstract SetOp copy(
   }
 
   @Override public void replaceInput(int ordinalInParent, RelNode p) {
-    final List<RelNode> newInputs = new ArrayList<RelNode>(inputs);
+    final List<RelNode> newInputs = new ArrayList<>(inputs);
     newInputs.set(ordinalInParent, p);
     inputs = ImmutableList.copyOf(newInputs);
     recomputeDigest();

File: core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
Patch:
@@ -95,7 +95,7 @@ private void explainGeneric(
 
     xmlOutput.endBeginTag("RelNode");
 
-    final List<RelNode> inputs = new ArrayList<RelNode>();
+    final List<RelNode> inputs = new ArrayList<>();
     for (Pair<String, Object> pair : values) {
       if (pair.right instanceof RelNode) {
         inputs.add((RelNode) pair.right);

File: core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java
Patch:
@@ -370,7 +370,7 @@ private static <M extends Metadata> MetadataHandler<M> load3(
         buff.append(pair.getKey());
       }
     }
-    final List<Object> argList = new ArrayList<Object>(Pair.right(providerList));
+    final List<Object> argList = new ArrayList<>(Pair.right(providerList));
     argList.add(0, ImmutableList.copyOf(relClasses));
     try {
       return compile(name, buff.toString(), def, argList);

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java
Patch:
@@ -388,7 +388,7 @@ protected static Set<RexNode> createAllPossibleExpressions(RexBuilder rexBuilder
     }
 
     return createAllPossibleExpressions(rexBuilder, expr, predFieldsUsed, mapping,
-        new HashMap<RexInputRef, RexNode>());
+        new HashMap<>());
   }
 
   private static Set<RexNode> createAllPossibleExpressions(RexBuilder rexBuilder,

File: core/src/main/java/org/apache/calcite/rel/rules/AbstractMaterializedViewRule.java
Patch:
@@ -1252,7 +1252,7 @@ protected MaterializedViewAggregateRule(RelOptRuleOperand operand,
       if (topProject != null && !unionRewriting) {
         // We have a Project on top, gather only what is needed
         final RelOptUtil.InputFinder inputFinder =
-            new RelOptUtil.InputFinder(new LinkedHashSet<RelDataTypeField>());
+            new RelOptUtil.InputFinder(new LinkedHashSet<>());
         for (RexNode e : topProject.getChildExps()) {
           e.accept(inputFinder);
         }

File: core/src/main/java/org/apache/calcite/rel/rules/FilterTableFunctionTransposeRule.java
Patch:
@@ -87,7 +87,7 @@ public void onMatch(RelOptRuleCall call) {
         return;
       }
     }
-    final List<RelNode> newFuncInputs = new ArrayList<RelNode>();
+    final List<RelNode> newFuncInputs = new ArrayList<>();
     final RelOptCluster cluster = funcRel.getCluster();
     final RexNode condition = filter.getCondition();
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinUnionTransposeRule.java
Patch:
@@ -96,7 +96,7 @@ public void onMatch(RelOptRuleCall call) {
         return;
       }
     }
-    List<RelNode> newUnionInputs = new ArrayList<RelNode>();
+    List<RelNode> newUnionInputs = new ArrayList<>();
     for (RelNode input : unionRel.getInputs()) {
       RelNode joinLeft;
       RelNode joinRight;

File: core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
Patch:
@@ -503,7 +503,7 @@ public Project createProjectRefsAndExprs(
     }
     int refIdx = offset - 1;
     List<Pair<RexNode, String>> newProjects =
-        new ArrayList<Pair<RexNode, String>>();
+        new ArrayList<>();
     List<RelDataTypeField> destFields =
         projChild.getRowType().getFieldList();
 

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -127,8 +127,8 @@ public class DecimalShuttle extends RexShuttle {
     private final ExpanderMap expanderMap;
 
     public DecimalShuttle(RexBuilder rexBuilder) {
-      irreducible = new HashMap<Pair<String, String>, RexNode>();
-      results = new HashMap<Pair<String, String>, RexNode>();
+      irreducible = new HashMap<>();
+      results = new HashMap<>();
       expanderMap = new ExpanderMap(rexBuilder);
     }
 
@@ -224,7 +224,7 @@ private class ExpanderMap {
     private RexExpander defaultExpander;
 
     private ExpanderMap(RexBuilder rexBuilder) {
-      map = new HashMap<SqlOperator, RexExpander>();
+      map = new HashMap<>();
       registerExpanders(rexBuilder);
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -546,8 +546,7 @@ protected static boolean reduceExpressions(RelNode rel, List<RexNode> expList,
     for (int i = 0; i < expList.size(); i++) {
       RexNode expr2 = simplifier.apply(expList.get(i));
       if (!expr2.toString().equals(expList.get(i).toString())) {
-        expList.remove(i);
-        expList.add(i, expr2);
+        expList.set(i, expr2);
         simplified = true;
       }
     }

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinJoinTransposeRule.java
Patch:
@@ -80,7 +80,7 @@ public void onMatch(RelOptRuleCall call) {
     int nFieldsY = join.getRight().getRowType().getFieldList().size();
     int nFieldsZ = semiJoin.getRight().getRowType().getFieldList().size();
     int nTotalFields = nFieldsX + nFieldsY + nFieldsZ;
-    List<RelDataTypeField> fields = new ArrayList<RelDataTypeField>();
+    List<RelDataTypeField> fields = new ArrayList<>();
 
     // create a list of fields for the full join result; note that
     // we can't simply use the fields from the semi-join because the

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -993,7 +993,7 @@ public static boolean isNullLiteral(RexNode node) {
   }
 
   private static boolean equals(Object o1, Object o2) {
-    return (o1 == null) ? (o2 == null) : o1.equals(o2);
+    return Objects.equals(o1, o2);
   }
 
   public <R> R accept(RexVisitor<R> visitor) {

File: core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
Patch:
@@ -158,6 +158,7 @@ private RexProgramBuilder(
    */
   private static boolean assertionsAreEnabled() {
     boolean assertionsEnabled = false;
+    //noinspection AssertWithSideEffects
     assert assertionsEnabled = true;
     return assertionsEnabled;
   }

File: core/src/main/java/org/apache/calcite/rex/RexSqlReflectiveConvertletTable.java
Patch:
@@ -27,7 +27,7 @@
 public class RexSqlReflectiveConvertletTable implements RexSqlConvertletTable {
   //~ Instance fields --------------------------------------------------------
 
-  private final Map<Object, Object> map = new HashMap<Object, Object>();
+  private final Map<Object, Object> map = new HashMap<>();
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/rex/RexSqlStandardConvertletTable.java
Patch:
@@ -196,7 +196,7 @@ private void registerTypeAppendOp(final SqlOperator op) {
             return null;
           }
           List<SqlNode> operandList =
-              new ArrayList<SqlNode>(Arrays.asList(operands));
+              new ArrayList<>(Arrays.asList(operands));
           SqlDataTypeSpec typeSpec =
               SqlTypeUtil.convertTypeToSpec(call.getType());
           operandList.add(typeSpec);

File: core/src/main/java/org/apache/calcite/rex/RexTransformer.java
Patch:
@@ -39,8 +39,7 @@ public class RexTransformer {
   private RexNode root;
   private final RexBuilder rexBuilder;
   private int isParentsCount;
-  private final Set<SqlOperator> transformableOperators =
-      new HashSet<SqlOperator>();
+  private final Set<SqlOperator> transformableOperators = new HashSet<>();
 
   //~ Constructors -----------------------------------------------------------
 
@@ -159,7 +158,7 @@ private RexNode transformNullSemantics(RexNode node) {
       RexCall call = (RexCall) node;
 
       // Transform children (if any) before transforming node itself.
-      final ArrayList<RexNode> operands = new ArrayList<RexNode>();
+      final ArrayList<RexNode> operands = new ArrayList<>();
       for (RexNode operand : call.operands) {
         operands.add(transformNullSemantics(operand));
       }

File: core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java
Patch:
@@ -38,7 +38,7 @@ public void putMulti(K key, V value) {
       return;
     }
     if (list.size() == 1) {
-      list = new ArrayList<V>(list);
+      list = new ArrayList<>(list);
     }
     list.add(value);
     put(key, list);
@@ -71,7 +71,7 @@ public void remove() {
   public static <V> Iterator<V[]> singletonArrayIterator(
       Comparator<V> comparator, List<V> list) {
     final SortedMultiMap<Object, V> multiMap =
-        new SortedMultiMap<Object, V>();
+        new SortedMultiMap<>();
     multiMap.put("x", list);
     return multiMap.arrays(comparator);
   }

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -2137,9 +2137,9 @@ public static boolean memberOf(Object object, Collection collection) {
   /** Support the MULTISET INTERSECT DISTINCT function. */
   public static <E> Collection<E> multisetIntersectDistinct(Collection<E> c1,
       Collection<E> c2) {
-    final Set<E> result = new HashSet<E>(c1);
+    final Set<E> result = new HashSet<>(c1);
     result.retainAll(c2);
-    return new ArrayList<E>(result);
+    return new ArrayList<>(result);
   }
 
   /** Support the MULTISET INTERSECT ALL function. */

File: core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
Patch:
@@ -77,8 +77,8 @@ public static StarTable of(Lattice lattice, List<Table> tables) {
   }
 
   public RelDataType getRowType(RelDataTypeFactory typeFactory) {
-    final List<RelDataType> typeList = new ArrayList<RelDataType>();
-    final List<Integer> fieldCounts = new ArrayList<Integer>();
+    final List<RelDataType> typeList = new ArrayList<>();
+    final List<Integer> fieldCounts = new ArrayList<>();
     for (Table table : tables) {
       final RelDataType rowType = table.getRowType(typeFactory);
       typeList.addAll(RelOptUtil.getFieldTypeList(rowType));

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
Patch:
@@ -227,8 +227,8 @@ private RelDataType inferTypeFromValidator(
       SqlCallBinding callBinding) {
     SqlCase caseCall = (SqlCase) callBinding.getCall();
     SqlNodeList thenList = caseCall.getThenOperands();
-    ArrayList<SqlNode> nullList = new ArrayList<SqlNode>();
-    List<RelDataType> argTypes = new ArrayList<RelDataType>();
+    ArrayList<SqlNode> nullList = new ArrayList<>();
+    List<RelDataType> argTypes = new ArrayList<>();
     for (SqlNode node : thenList) {
       argTypes.add(
           callBinding.getValidator().deriveType(
@@ -263,7 +263,7 @@ private RelDataType inferTypeFromOperands(
     assert (argTypes.size() % 2) == 1 : "odd number of arguments expected: "
         + argTypes.size();
     assert argTypes.size() > 1 : argTypes.size();
-    List<RelDataType> thenTypes = new ArrayList<RelDataType>();
+    List<RelDataType> thenTypes = new ArrayList<>();
     for (int j = 1; j < (argTypes.size() - 1); j += 2) {
       thenTypes.add(argTypes.get(j));
     }

File: core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java
Patch:
@@ -123,7 +123,7 @@ public Collection<String> getExpectedTokenNames() {
     for (int[] expectedTokenSequence : expectedTokenSequences) {
       maxLength = Math.max(expectedTokenSequence.length, maxLength);
     }
-    final Set<String> set = new TreeSet<String>();
+    final Set<String> set = new TreeSet<>();
     for (int[] expectedTokenSequence : expectedTokenSequences) {
       if (expectedTokenSequence.length == maxLength) {
         set.add(

File: core/src/main/java/org/apache/calcite/sql/util/ListSqlOperatorTable.java
Patch:
@@ -38,7 +38,7 @@ public class ListSqlOperatorTable implements SqlOperatorTable {
   //~ Constructors -----------------------------------------------------------
 
   public ListSqlOperatorTable() {
-    this(new ArrayList<SqlOperator>());
+    this(new ArrayList<>());
   }
 
   public ListSqlOperatorTable(List<SqlOperator> operatorList) {

File: core/src/main/java/org/apache/calcite/sql/util/SqlShuttle.java
Patch:
@@ -71,7 +71,7 @@ public SqlNode visit(SqlNodeList nodeList) {
     boolean update = false;
     List<SqlNode> exprs = nodeList.getList();
     int exprCount = exprs.size();
-    List<SqlNode> newList = new ArrayList<SqlNode>(exprCount);
+    List<SqlNode> newList = new ArrayList<>(exprCount);
     for (SqlNode operand : exprs) {
       SqlNode clonedOperand;
       if (operand == null) {

File: core/src/main/java/org/apache/calcite/sql/validate/AliasNamespace.java
Patch:
@@ -64,7 +64,7 @@ protected AliasNamespace(
   //~ Methods ----------------------------------------------------------------
 
   protected RelDataType validateImpl(RelDataType targetRowType) {
-    final List<String> nameList = new ArrayList<String>();
+    final List<String> nameList = new ArrayList<>();
     final List<SqlNode> operands = call.getOperandList();
     final SqlValidatorNamespace childNs =
         validator.getNamespace(operands.get(0));
@@ -87,7 +87,7 @@ protected RelDataType validateImpl(RelDataType targetRowType) {
           RESOURCE.aliasListDegree(rowType.getFieldCount(), getString(rowType),
               nameList.size()));
     }
-    final List<RelDataType> typeList = new ArrayList<RelDataType>();
+    final List<RelDataType> typeList = new ArrayList<>();
     for (RelDataTypeField field : rowType.getFieldList()) {
       typeList.add(field.getType());
     }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
Patch:
@@ -134,7 +134,7 @@ public int frequency(Iterable<String> names, String name) {
 
     public Set<String> createSet() {
       return isCaseSensitive()
-          ? new LinkedHashSet<String>()
+          ? new LinkedHashSet<>()
           : new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
     }
   }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -4908,7 +4908,7 @@ public void validateWindow(
     if (orderBy != null) {
       for (SqlNode node : orderBy) {
         node.validate(this, scope);
-        SqlIdentifier identifier = null;
+        SqlIdentifier identifier;
         if (node instanceof SqlBasicCall) {
           identifier = (SqlIdentifier) ((SqlBasicCall) node).getOperands()[0];
         } else {

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -1121,6 +1121,7 @@ public Frame decorrelateRel(LogicalCorrelate rel) {
     int oldLeftFieldCount = oldLeft.getRowType().getFieldCount();
 
     int oldRightFieldCount = oldRight.getRowType().getFieldCount();
+    //noinspection AssertWithSideEffects
     assert rel.getRowType().getFieldCount()
         == oldLeftFieldCount + oldRightFieldCount;
 
@@ -1180,6 +1181,7 @@ public Frame decorrelateRel(LogicalJoin rel) {
     int newLeftFieldCount = leftFrame.r.getRowType().getFieldCount();
 
     int oldRightFieldCount = oldRight.getRowType().getFieldCount();
+    //noinspection AssertWithSideEffects
     assert rel.getRowType().getFieldCount()
         == oldLeftFieldCount + oldRightFieldCount;
 

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -2217,7 +2217,7 @@ protected void convertMatchRecognize(Blackboard bb, SqlCall call) {
       SqlIdentifier left = (SqlIdentifier) operands.get(0);
       patternVarsSet.add(left.getSimple());
       SqlNodeList rights = (SqlNodeList) operands.get(1);
-      final TreeSet<String> list = new TreeSet<String>();
+      final TreeSet<String> list = new TreeSet<>();
       for (SqlNode right : rights) {
         assert right instanceof SqlIdentifier;
         list.add(((SqlIdentifier) right).getSimple());
@@ -4986,7 +4986,7 @@ private void translateAgg(SqlCall call, SqlNode filter, SqlCall outerCall) {
       int filterArg = -1;
       final List<RelDataType> argTypes =
           call.getOperator() instanceof SqlCountAggFunction
-              ? new ArrayList<RelDataType>(call.getOperandList().size())
+              ? new ArrayList<>(call.getOperandList().size())
               : null;
       try {
         // switch out of agg mode

File: core/src/main/java/org/apache/calcite/util/Benchmark.java
Patch:
@@ -74,7 +74,7 @@ public void run() {
    */
   public static class Statistician {
     private final String desc;
-    private final List<Long> durations = new ArrayList<Long>();
+    private final List<Long> durations = new ArrayList<>();
 
     public Statistician(String desc) {
       super();

File: core/src/main/java/org/apache/calcite/util/CompositeList.java
Patch:
@@ -69,7 +69,7 @@ public static <T> CompositeList<T> of(List<? extends T>... lists) {
    */
   public static <T> CompositeList<T> ofCopy(Iterable<List<T>> lists) {
     final ImmutableList<List<T>> list = ImmutableList.copyOf(lists);
-    return new CompositeList<T>(list);
+    return new CompositeList<>(list);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/util/CompoundClosableAllocation.java
Patch:
@@ -36,7 +36,7 @@ public class CompoundClosableAllocation implements ClosableAllocationOwner {
   //~ Constructors -----------------------------------------------------------
 
   public CompoundClosableAllocation() {
-    allocations = new LinkedList<ClosableAllocation>();
+    allocations = new LinkedList<>();
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/util/DelegatingInvocationHandler.java
Patch:
@@ -62,9 +62,7 @@ public Object invoke(
           clazz.getMethod(
               method.getName(),
               method.getParameterTypes());
-    } catch (NoSuchMethodException e) {
-      matchingMethod = null;
-    } catch (SecurityException e) {
+    } catch (NoSuchMethodException | SecurityException e) {
       matchingMethod = null;
     }
     try {

File: core/src/main/java/org/apache/calcite/util/Holder.java
Patch:
@@ -48,7 +48,7 @@ public E get() {
 
   /** Creates a holder containing a given value. */
   public static <E> Holder<E> of(E e) {
-    return new Holder<E>(e);
+    return new Holder<>(e);
   }
 }
 

File: core/src/main/java/org/apache/calcite/util/JsonBuilder.java
Patch:
@@ -33,14 +33,14 @@ public class JsonBuilder {
    */
   public Map<String, Object> map() {
     // Use LinkedHashMap to preserve order.
-    return new LinkedHashMap<String, Object>();
+    return new LinkedHashMap<>();
   }
 
   /**
    * Creates a JSON object (represented by a {@link List}).
    */
   public List<Object> list() {
-    return new ArrayList<Object>();
+    return new ArrayList<>();
   }
 
   /**

File: core/src/main/java/org/apache/calcite/util/Permutation.java
Patch:
@@ -471,6 +471,7 @@ private boolean isValid(boolean fail) {
         assert !fail : "target " + target + " occurs more than once";
         return false;
       }
+      occurCount[target]++;
     }
     return true;
   }

File: core/src/main/java/org/apache/calcite/util/UnmodifiableArrayList.java
Patch:
@@ -43,7 +43,7 @@ private UnmodifiableArrayList(E[] elements) {
   }
 
   public static <E> UnmodifiableArrayList<E> of(E... elements) {
-    return new UnmodifiableArrayList<E>(elements);
+    return new UnmodifiableArrayList<>(elements);
   }
 
   @Override public E get(int index) {

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -1571,7 +1571,7 @@ public static Locale parseLocale(String localeString) {
    * @return A list whose members are of the desired type.
    */
   public static <E> List<E> cast(List<? super E> list, Class<E> clazz) {
-    return new CastingList<E>(list, clazz);
+    return new CastingList<>(list, clazz);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/util/XmlOutput.java
Patch:
@@ -547,7 +547,7 @@ static class StringEscaper implements Cloneable {
      * Identity transform
      */
     StringEscaper() {
-      translationVector = new ArrayList<String>();
+      translationVector = new ArrayList<>();
     }
 
     /**
@@ -597,7 +597,7 @@ public String escapeString(String s) {
         } else {
           if (sb == null) {
             sb = new StringBuilder(n * 2);
-            sb.append(s.substring(0, i));
+            sb.append(s, 0, i);
           }
           sb.append(escape);
         }
@@ -613,7 +613,7 @@ public String escapeString(String s) {
     protected StringEscaper clone() {
       StringEscaper clone = new StringEscaper();
       if (translationVector != null) {
-        clone.translationVector = new ArrayList<String>(translationVector);
+        clone.translationVector = new ArrayList<>(translationVector);
       }
       if (translationTable != null) {
         clone.translationTable = translationTable.clone();

File: core/src/main/java/org/apache/calcite/util/graph/CycleDetector.java
Patch:
@@ -32,7 +32,7 @@ public CycleDetector(DirectedGraph<V, E> graph) {
   }
 
   public Set<V> findCycles() {
-    return new TopologicalOrderIterator<V, E>(graph).findCycles();
+    return new TopologicalOrderIterator<>(graph).findCycles();
   }
 }
 

File: core/src/main/java/org/apache/calcite/util/graph/DepthFirstIterator.java
Patch:
@@ -57,7 +57,7 @@ public static <V, E extends DefaultEdge> Iterable<V> of(
   /** Populates a collection with the nodes reachable from a given node. */
   public static <V, E extends DefaultEdge> void reachable(Collection<V> list,
       final DirectedGraph<V, E> graph, final V start) {
-    buildListRecurse(list, new HashSet<V>(), graph, start);
+    buildListRecurse(list, new HashSet<>(), graph, start);
   }
 
   private static <V, E extends DefaultEdge> void buildListRecurse(

File: core/src/main/java/org/apache/calcite/util/graph/Graphs.java
Patch:
@@ -148,7 +148,7 @@ private void findPaths(V from, V to, List<List<V>> list) {
 //      }
       final List<V> prefix = new ArrayList<>();
       prefix.add(from);
-      findPathsExcluding(from, to, list, new HashSet<V>(), prefix);
+      findPathsExcluding(from, to, list, new HashSet<>(), prefix);
     }
 
     /**

File: core/src/main/java/org/apache/calcite/util/graph/TopologicalOrderIterator.java
Patch:
@@ -31,8 +31,8 @@
  */
 public class TopologicalOrderIterator<V, E extends DefaultEdge>
     implements Iterator<V> {
-  final Map<V, int[]> countMap = new HashMap<V, int[]>();
-  final List<V> empties = new ArrayList<V>();
+  final Map<V, int[]> countMap = new HashMap<>();
+  final List<V> empties = new ArrayList<>();
   private final DefaultDirectedGraph<V, E> graph;
 
   public TopologicalOrderIterator(DirectedGraph<V, E> graph) {
@@ -42,7 +42,7 @@ public TopologicalOrderIterator(DirectedGraph<V, E> graph) {
 
   public static <V, E extends DefaultEdge> Iterable<V> of(
       final DirectedGraph<V, E> graph) {
-    return () -> new TopologicalOrderIterator<V, E>(graph);
+    return () -> new TopologicalOrderIterator<>(graph);
   }
 
   private void populate(Map<V, int[]> countMap, List<V> empties) {

File: core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java
Patch:
@@ -45,7 +45,6 @@ public class JaninoCompiler implements JavaCompiler {
   //~ Constructors -----------------------------------------------------------
 
   public JaninoCompiler() {
-    args = new JaninoCompilerArgs();
   }
 
   //~ Methods ----------------------------------------------------------------
@@ -67,7 +66,7 @@ public void compile() {
       parentClassLoader = classLoader;
     }
 
-    Map<String, byte[]> sourceMap = new HashMap<String, byte[]>();
+    Map<String, byte[]> sourceMap = new HashMap<>();
     sourceMap.put(
         ClassFile.getSourceResourceName(args.fullClassName),
         args.source.getBytes(StandardCharsets.UTF_8));

File: core/src/main/java/org/apache/calcite/util/javac/JavaCompilerArgs.java
Patch:
@@ -32,8 +32,8 @@
 public class JavaCompilerArgs {
   //~ Instance fields --------------------------------------------------------
 
-  List<String> argsList = new ArrayList<String>();
-  List<String> fileNameList = new ArrayList<String>();
+  List<String> argsList = new ArrayList<>();
+  List<String> fileNameList = new ArrayList<>();
 
   ClassLoader classLoader;
 
@@ -56,7 +56,7 @@ public void clear() {
    * dir</i> -verbose [<i>file</i>...]"</code>
    */
   public void setString(String args) {
-    List<String> list = new ArrayList<String>();
+    List<String> list = new ArrayList<>();
     StringTokenizer tok = new StringTokenizer(args);
     while (tok.hasMoreTokens()) {
       list.add(tok.nextToken());

File: core/src/test/java/org/apache/calcite/util/UtilTest.java
Patch:
@@ -1571,6 +1571,7 @@ private void checkCompositeMap(String[] beatles, Map<String, Integer> map) {
     checkHash(Double.MIN_VALUE);
   }
 
+  @SuppressWarnings("deprecation")
   public void checkHash(double v) {
     assertThat(Double.valueOf(v).hashCode(), is(Utilities.hashCode(v)));
     final long long_ = (long) v;

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidSqlCastConverter.java
Patch:
@@ -171,7 +171,7 @@ public static String dateTimeFormatString(final SqlTypeName sqlTypeName) {
       return "yyyy-MM-dd";
     } else if (sqlTypeName == SqlTypeName.TIMESTAMP) {
       return "yyyy-MM-dd HH:mm:ss";
-    } else if (sqlTypeName == sqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE) {
+    } else if (sqlTypeName == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE) {
       return "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'";
     } else {
       return null;

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
Patch:
@@ -220,7 +220,7 @@ private boolean isSupportedPostAggOperation(SqlKind kind) {
   public List<ComplexMetric> getComplexMetricsFrom(String alias) {
     return complexMetrics.containsKey(alias)
             ? complexMetrics.get(alias)
-            : new ArrayList<ComplexMetric>();
+            : new ArrayList<>();
   }
 
   /**

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
Patch:
@@ -99,7 +99,7 @@ public Table create(SchemaPlus schema, String name, Map operand,
       // noinspection unchecked
       final List<String> complexMetricList = (List<String>) complexMetricsRaw;
       for (String metric : complexMetricList) {
-        complexMetrics.put(metric, new ArrayList<ComplexMetric>());
+        complexMetrics.put(metric, new ArrayList<>());
       }
     }
 

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
Patch:
@@ -123,7 +123,7 @@ private String translateMatch(RexNode condition) {
      * @return OQL string for the predicate
      */
     private String translateAnd(RexNode condition) {
-      List<String> predicates = new ArrayList<String>();
+      List<String> predicates = new ArrayList<>();
       for (RexNode node : RelOptUtil.conjunctions(condition)) {
         predicates.add(translateMatch2(node));
       }
@@ -132,7 +132,7 @@ private String translateAnd(RexNode condition) {
     }
 
     private String translateOr(List<RexNode> disjunctions) {
-      List<String> predicates = new ArrayList<String>();
+      List<String> predicates = new ArrayList<>();
       for (RexNode node : disjunctions) {
         if (RelOptUtil.conjunctions(node).size() > 1) {
           predicates.add("(" + translateMatch(node) + ")");

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSort.java
Patch:
@@ -76,7 +76,7 @@ public GeodeSort(RelOptCluster cluster, RelTraitSet traitSet,
 
     if (!sortCollations.isEmpty()) {
 
-      List<String> orderByFields = new ArrayList<String>();
+      List<String> orderByFields = new ArrayList<>();
 
       for (RelFieldCollation fieldCollation : sortCollations) {
         final String name = fieldName(fieldCollation.getFieldIndex());

File: linq4j/src/main/java/org/apache/calcite/linq4j/AbstractEnumerable2.java
Patch:
@@ -28,7 +28,7 @@
  */
 public abstract class AbstractEnumerable2<T> extends DefaultEnumerable<T> {
   public Enumerator<T> enumerator() {
-    return new Linq4j.IterableEnumerator<T>(this);
+    return new Linq4j.IterableEnumerator<>(this);
   }
 }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
Patch:
@@ -53,7 +53,7 @@ public Enumerator<Grouping<K, V>> enumerator() {
 
       public Grouping<K, V> current() {
         final Entry<K, List<V>> keyAndList = enumerator.current();
-        return new GroupingImpl<K, V>(keyAndList.getKey(),
+        return new GroupingImpl<>(keyAndList.getKey(),
             keyAndList.getValue());
       }
 
@@ -159,7 +159,7 @@ public boolean hasNext() {
 
           public Entry<K, Enumerable<V>> next() {
             final Entry<K, List<V>> entry = iterator.next();
-            return new AbstractMap.SimpleEntry<K, Enumerable<V>>(entry.getKey(),
+            return new AbstractMap.SimpleEntry<>(entry.getKey(),
                 Linq4j.asEnumerable(entry.getValue()));
           }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/QueryProviderImpl.java
Patch:
@@ -34,11 +34,11 @@ public QueryProviderImpl() {
   }
 
   public <T> Queryable<T> createQuery(Expression expression, Class<T> rowType) {
-    return new QueryableImpl<T>(this, rowType, expression);
+    return new QueryableImpl<>(this, rowType, expression);
   }
 
   public <T> Queryable<T> createQuery(Expression expression, Type rowType) {
-    return new QueryableImpl<T>(this, rowType, expression);
+    return new QueryableImpl<>(this, rowType, expression);
   }
 
   public <T> T execute(Expression expression, Class<T> type) {

File: linq4j/src/main/java/org/apache/calcite/linq4j/QueryableDefaults.java
Patch:
@@ -226,7 +226,7 @@ public static <T, T2> Queryable<T2> cast(final Queryable<T> source,
     return new BaseQueryable<T2>(source.getProvider(), clazz,
         source.getExpression()) {
       public Enumerator<T2> enumerator() {
-        return new EnumerableDefaults.CastingEnumerator<T2>(source.enumerator(),
+        return new EnumerableDefaults.CastingEnumerator<>(source.enumerator(),
             clazz);
       }
     };
@@ -911,7 +911,7 @@ public static <T> Queryable<T> skipWhileN(final Queryable<T> source,
     return new BaseQueryable<T>(source.getProvider(), source.getElementType(),
         source.getExpression()) {
       public Enumerator<T> enumerator() {
-        return new EnumerableDefaults.SkipWhileEnumerator<T>(
+        return new EnumerableDefaults.SkipWhileEnumerator<>(
             source.enumerator(), predicate.getFunction());
       }
     };
@@ -1046,7 +1046,7 @@ public static <T> Queryable<T> takeWhileN(final Queryable<T> source,
     return new BaseQueryable<T>(source.getProvider(), source.getElementType(),
         source.getExpression()) {
       public Enumerator<T> enumerator() {
-        return new EnumerableDefaults.TakeWhileEnumerator<T>(
+        return new EnumerableDefaults.TakeWhileEnumerator<>(
             source.enumerator(), predicate.getFunction());
       }
     };

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Evaluator.java
Patch:
@@ -23,9 +23,8 @@
  * Holds context for evaluating expressions.
  */
 class Evaluator {
-  final List<ParameterExpression> parameters =
-      new ArrayList<ParameterExpression>();
-  final List<Object> values = new ArrayList<Object>();
+  final List<ParameterExpression> parameters = new ArrayList<>();
+  final List<Object> values = new ArrayList<>();
 
   Evaluator() {
   }

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
Patch:
@@ -149,15 +149,15 @@ public static Class toClass(Type type) {
   }
 
   static Class[] toClassArray(Collection<Type> types) {
-    List<Class> classes = new ArrayList<Class>();
+    List<Class> classes = new ArrayList<>();
     for (Type type : types) {
       classes.add(toClass(type));
     }
     return classes.toArray(new Class[0]);
   }
 
   static Class[] toClassArray(Iterable<? extends Expression> arguments) {
-    List<Class> classes = new ArrayList<Class>();
+    List<Class> classes = new ArrayList<>();
     for (Expression argument : arguments) {
       classes.add(toClass(argument.getType()));
     }

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
Patch:
@@ -84,7 +84,7 @@ public MongoAggregate(
 
   public void implement(Implementor implementor) {
     implementor.visitChild(0, getInput());
-    List<String> list = new ArrayList<String>();
+    List<String> list = new ArrayList<>();
     final List<String> inNames =
         MongoRules.mongoFieldNames(getInput().getRowType());
     final List<String> outNames = MongoRules.mongoFieldNames(getRowType());
@@ -94,7 +94,7 @@ public void implement(Implementor implementor) {
       list.add("_id: " + MongoRules.maybeQuote("$" + inName));
       ++i;
     } else {
-      List<String> keys = new ArrayList<String>();
+      List<String> keys = new ArrayList<>();
       for (int group : groupSet) {
         final String inName = inNames.get(group);
         keys.add(inName + ": " + MongoRules.quote("$" + inName));
@@ -123,7 +123,7 @@ public void implement(Implementor implementor) {
         }
       };
     } else {
-      fixups = new ArrayList<String>();
+      fixups = new ArrayList<>();
       fixups.add("_id: 0");
       i = 0;
       for (int group : groupSet) {

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoFilter.java
Patch:
@@ -79,7 +79,7 @@ static class Translator {
     final Multimap<String, Pair<String, RexLiteral>> multimap =
         HashMultimap.create();
     final Map<String, RexLiteral> eqMap =
-        new LinkedHashMap<String, RexLiteral>();
+        new LinkedHashMap<>();
     private final List<String> fieldNames;
 
     Translator(List<String> fieldNames) {
@@ -93,7 +93,7 @@ private String translateMatch(RexNode condition) {
     }
 
     private Object translateOr(RexNode condition) {
-      List<Object> list = new ArrayList<Object>();
+      List<Object> list = new ArrayList<>();
       for (RexNode node : RelOptUtil.disjunctions(condition)) {
         list.add(translateAnd(node));
       }

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoProject.java
Patch:
@@ -69,7 +69,7 @@ public void implement(Implementor implementor) {
         new MongoRules.RexToMongoTranslator(
             (JavaTypeFactory) getCluster().getTypeFactory(),
             MongoRules.mongoFieldNames(getInput().getRowType()));
-    final List<String> items = new ArrayList<String>();
+    final List<String> items = new ArrayList<>();
     for (Pair<RexNode, String> pair : getNamedProjects()) {
       final String name = pair.right;
       final String expr = pair.left.accept(translator);

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRel.java
Patch:
@@ -36,8 +36,7 @@ public interface MongoRel extends RelNode {
   /** Callback for the implementation process that converts a tree of
    * {@link MongoRel} nodes into a MongoDB query. */
   class Implementor {
-    final List<Pair<String, String>> list =
-        new ArrayList<Pair<String, String>>();
+    final List<Pair<String, String>> list = new ArrayList<>();
 
     RelOptTable table;
     MongoTable mongoTable;

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -131,7 +131,7 @@ static class RexToMongoTranslator extends RexVisitorImpl<String> {
     private final List<String> inFields;
 
     private static final Map<SqlOperator, String> MONGO_OPERATORS =
-        new HashMap<SqlOperator, String>();
+        new HashMap<>();
 
     static {
       // Arithmetic
@@ -236,7 +236,7 @@ private String stripQuotes(String s) {
     }
 
     public List<String> visitList(List<RexNode> list) {
-      final List<String> strings = new ArrayList<String>();
+      final List<String> strings = new ArrayList<>();
       for (RexNode node : list) {
         strings.add(node.accept(this));
       }

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSort.java
Patch:
@@ -59,7 +59,7 @@ public MongoSort(RelOptCluster cluster, RelTraitSet traitSet,
   public void implement(Implementor implementor) {
     implementor.visitChild(0, getInput());
     if (!collation.getFieldCollations().isEmpty()) {
-      final List<String> keys = new ArrayList<String>();
+      final List<String> keys = new ArrayList<>();
       final List<RelDataTypeField> fields = getRowType().getFieldList();
       for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {
         final String name =

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java
Patch:
@@ -21,7 +21,6 @@
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
-import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rex.RexCall;
@@ -39,7 +38,7 @@ public class PigJoin extends Join implements PigRel {
   /** Creates a PigJoin. */
   public PigJoin(RelOptCluster cluster, RelTraitSet traitSet, RelNode left, RelNode right,
       RexNode condition, JoinRelType joinType) {
-    super(cluster, traitSet, left, right, condition, new HashSet<CorrelationId>(0), joinType);
+    super(cluster, traitSet, left, right, condition, new HashSet<>(0), joinType);
     assert getConvention() == PigRel.CONVENTION;
   }
 

File: plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
Patch:
@@ -90,7 +90,7 @@ private Object field(String field, String value) {
                       return 0;
                     }
                     if (value.endsWith(".")) {
-                      return Long.parseLong(value.substring(0, value.length()));
+                      return Long.parseLong(value);
                     }
                     return Long.parseLong(value);
                   }

File: spark/src/main/java/org/apache/calcite/adapter/spark/JdbcToSparkConverter.java
Patch:
@@ -82,7 +82,7 @@ public SparkRel.Result implementSpark(SparkRel.Implementor implementor) {
     }
     final Expression sqlLiteral =
         list.append("sql", Expressions.constant(sql));
-    final List<Primitive> primitives = new ArrayList<Primitive>();
+    final List<Primitive> primitives = new ArrayList<>();
     for (int i = 0; i < getRowType().getFieldCount(); i++) {
       final Primitive primitive = Primitive.ofBoxOr(physType.fieldClass(i));
       primitives.add(primitive != null ? primitive : Primitive.OTHER);

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkMethod.java
Patch:
@@ -44,8 +44,7 @@ public enum SparkMethod {
 
   public final Method method;
 
-  private static final HashMap<Method, SparkMethod> MAP =
-      new HashMap<Method, SparkMethod>();
+  private static final HashMap<Method, SparkMethod> MAP = new HashMap<>();
 
   static {
     for (SparkMethod method : SparkMethod.values()) {

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
Patch:
@@ -183,10 +183,10 @@ public Result implementSpark(Implementor implementor) {
               JavaRowFormat.CUSTOM);
       final Type rowClass = physType.getJavaRowType();
 
-      final List<Expression> expressions = new ArrayList<Expression>();
+      final List<Expression> expressions = new ArrayList<>();
       final List<RelDataTypeField> fields = rowType.getFieldList();
       for (List<RexLiteral> tuple : tuples) {
-        final List<Expression> literals = new ArrayList<Expression>();
+        final List<Expression> literals = new ArrayList<>();
         for (Pair<RelDataTypeField, RexLiteral> pair
             : Pair.zip(fields, tuple)) {
           literals.add(

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkQuery.java
Patch:
@@ -64,7 +64,7 @@ public Enumerator<T> enumerator() {
   }
 
   private Map<String, String> getArgs() {
-    Map<String, String> args = new HashMap<String, String>();
+    Map<String, String> args = new HashMap<>();
     if (fieldList != null) {
       String fields =
           StringUtils.encodeList(fieldList, ',').toString();

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkTable.java
Patch:
@@ -57,7 +57,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
 
   public <T> Queryable<T> asQueryable(QueryProvider queryProvider,
       SchemaPlus schema, String tableName) {
-    return new SplunkTableQueryable<T>(queryProvider, schema, this, tableName);
+    return new SplunkTableQueryable<>(queryProvider, schema, this, tableName);
   }
 
   public RelNode toRel(
@@ -93,7 +93,7 @@ public Enumerator<T> enumerator() {
     public SplunkQuery<T> createQuery(String search, String earliest,
         String latest, List<String> fieldList) {
       final SplunkSchema splunkSchema = schema.unwrap(SplunkSchema.class);
-      return new SplunkQuery<T>(splunkSchema.splunkConnection, search,
+      return new SplunkQuery<>(splunkSchema.splunkConnection, search,
           earliest, latest, fieldList);
     }
   }

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
Patch:
@@ -50,7 +50,7 @@ public static StringBuilder encodeList(
   }
 
   public static List<String> decodeList(CharSequence encoded, char delim) {
-    List<String> list = new LinkedList<String>();
+    List<String> list = new LinkedList<>();
     int len = encoded.length();
     int start = 0;
     int end = 0;
@@ -132,7 +132,7 @@ public static boolean parseBoolean(
 
 
   public static void main(String[] args) {
-    List<String> list = new LinkedList<String>();
+    List<String> list = new LinkedList<>();
     list.add("test");
     list.add("test,with,comma");
     list.add("");

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -544,6 +544,9 @@ private RexNode simplifyIsNull(RexNode a) {
     if (!a.getType().isNullable()) {
       return rexBuilder.makeLiteral(false);
     }
+    if (RexUtil.isNull(a)) {
+      return rexBuilder.makeLiteral(true);
+    }
     switch (Strong.policy(a.getKind())) {
     case NOT_NULL:
       return rexBuilder.makeLiteral(false);

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -1200,6 +1200,8 @@ private void checkExponentialCnf(int n) {
     checkSimplify(isNotNull(not(vBool())), "IS NOT NULL(?0.bool0)");
     checkSimplify(isNotNull(not(vBoolNotNull())), "true");
 
+    // "null is null" to "true"
+    checkSimplify(isNull(nullBool), "true");
     // "(x + y) is null" simplifies to "x is null or y is null"
     checkSimplify(isNull(plus(vInt(0), vInt(1))),
         "OR(IS NULL(?0.int0), IS NULL(?0.int1))");

File: core/src/main/java/org/apache/calcite/plan/Strong.java
Patch:
@@ -31,7 +31,6 @@
 import java.util.EnumMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 
 /** Utilities for strong predicates.
  *
@@ -87,7 +86,7 @@ public static boolean isNotTrue(RexNode node, ImmutableBitSet nullColumns) {
   /** Returns how to deduce whether a particular kind of expression is null,
    * given whether its arguments are null. */
   public static Policy policy(SqlKind kind) {
-    return Objects.requireNonNull(MAP.get(kind), kind.toString());
+    return MAP.getOrDefault(kind, Policy.AS_IS);
   }
 
   /** Returns whether an expression is definitely not true. */
@@ -106,7 +105,7 @@ public boolean isNotTrue(RexNode node) {
    * expressions, and you may override methods to test hypotheses such as
    * "if {@code x} is null, is {@code x + y} null? */
   public boolean isNull(RexNode node) {
-    final Policy policy = MAP.get(node.getKind());
+    final Policy policy = policy(node.getKind());
     switch (policy) {
     case NOT_NULL:
       return false;

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -1875,7 +1875,7 @@ public void testSkipReduceConstantsCaseEquals() throws Exception {
     // Rule should not fire, but there should be no NPE
     final String sql =
         "select * from (values (1,2)) where 1 + 2 > 3 + CAST(NULL AS INTEGER)";
-    checkPlanUnchanged(new HepPlanner(program), sql);
+    checkPlanning(new HepPlanner(program), sql);
   }
 
   @Test public void testAlreadyFalseEliminatesFilter() throws Exception {

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTableScan.java
Patch:
@@ -37,7 +37,7 @@
  * using the "find" method.</p>
  */
 public class ElasticsearchTableScan extends TableScan implements ElasticsearchRel {
-  private final AbstractElasticsearchTable elasticsearchTable;
+  private final ElasticsearchTable elasticsearchTable;
   private final RelDataType projectRowType;
 
   /**
@@ -50,10 +50,10 @@ public class ElasticsearchTableScan extends TableScan implements ElasticsearchRe
    * @param projectRowType Fields and types to project; null to project raw row
    */
   ElasticsearchTableScan(RelOptCluster cluster, RelTraitSet traitSet,
-       RelOptTable table, AbstractElasticsearchTable elasticsearchTable,
+       RelOptTable table, ElasticsearchTable elasticsearchTable,
        RelDataType projectRowType) {
     super(cluster, traitSet, table);
-    this.elasticsearchTable = Objects.requireNonNull(elasticsearchTable);
+    this.elasticsearchTable = Objects.requireNonNull(elasticsearchTable, "elasticsearchTable");
     this.projectRowType = projectRowType;
 
     assert getConvention() == ElasticsearchRel.CONVENTION;

File: elasticsearch/src/test/java/org/apache/calcite/adapter/elasticsearch/BooleanLogicTest.java
Patch:
@@ -128,6 +128,7 @@ public void expressions() {
     assertSingle("select * from view where num > 41");
     assertSingle("select * from view where num > 0");
     assertSingle("select * from view where (a = 'a' and b = 'b') or (num = 42 and c = 'c')");
+    assertSingle("select * from view where c = 'c' and (a in ('a', 'b') or num in (41, 42))");
     assertSingle("select * from view where (a = 'a' or b = 'b') or (num = 42 and c = 'c')");
     assertSingle("select * from view where a = 'a' and (b = '0' or (b = 'b' and "
             +  "(c = '0' or (c = 'c' and num = 42))))");

File: core/src/main/java/org/apache/calcite/rel/rules/AbstractMaterializedViewRule.java
Patch:
@@ -2541,8 +2541,9 @@ protected void addEquivalenceClass(RexTableInputRef p1, RexTableInputRef p2) {
         // Both present, we need to merge
         if (c1.size() < c2.size()) {
           // We swap them to merge
-          c1 = c2;
-          p1 = p2;
+          Set<RexTableInputRef> c2Temp = c2;
+          c2 = c1;
+          c1 = c2Temp;
         }
         for (RexTableInputRef newRef : c2) {
           c1.add(newRef);

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -371,7 +371,7 @@ private RexNode simplifyNot(RexCall call) {
     if (a.getKind() != negateKind) {
       return simplify_(
           rexBuilder.makeCall(RexUtil.op(negateKind),
-              ImmutableList.of(((RexCall) a).getOperands().get(0))));
+              ((RexCall) a).getOperands()));
     }
     final SqlKind negateKind2 = a.getKind().negateNullSafe();
     if (a.getKind() != negateKind2) {

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -2083,11 +2083,11 @@ private void assertTypeAndToString(
     assertThat(getString(map3), is("{1=?0.a, 2=?0.a}"));
   }
 
-  @Ignore("[CALCITE-2505] java.lang.AssertionError: wrong operand count 1 for IS DISTINCT FROM")
   @Test public void notDistinct() {
     checkSimplify2(
         isFalse(isNotDistinctFrom(vBool(0), vBool(1))),
-        "...", "...");
+        "IS DISTINCT FROM(?0.bool0, ?0.bool1)",
+        "IS DISTINCT FROM(?0.bool0, ?0.bool1)");
   }
 
   @Ignore("[CALCITE-2505] java.lang.AssertionError: result mismatch")

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -790,6 +790,8 @@ private void checkRelSelectivity(
    * JaninoRelMetadataProvider loading cache might cause
    * OutOfMemoryError</a>. */
   @Test public void testMetadataHandlerCacheLimit() {
+    Assume.assumeTrue("too slow to run every day, and it does not reproduce the issue",
+        CalciteAssert.ENABLE_SLOW);
     Assume.assumeTrue("If cache size is too large, this test may fail and the "
             + "test won't be to blame",
         SaffronProperties.INSTANCE.metadataHandlerCacheMaximumSize().get()

File: geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
Patch:
@@ -36,6 +36,7 @@
 import java.util.Collections;
 import java.util.List;
 
+import static org.apache.calcite.sql.type.SqlTypeName.BOOLEAN_TYPES;
 import static org.apache.calcite.sql.type.SqlTypeName.CHAR;
 import static org.apache.calcite.sql.type.SqlTypeName.NUMERIC_TYPES;
 
@@ -225,7 +226,7 @@ private String quoteCharLiteral(RexLiteral literal) {
     private String translateOp2(String op, String name, RexLiteral right) {
       String valueString = literalValue(right);
       SqlTypeName typeName = rowType.getField(name, true, false).getType().getSqlTypeName();
-      if (NUMERIC_TYPES.contains(typeName)) {
+      if (NUMERIC_TYPES.contains(typeName) || BOOLEAN_TYPES.contains(typeName)) {
         // leave the value as it is
       } else if (typeName != SqlTypeName.CHAR) {
         valueString = "'" + valueString + "'";

File: core/src/test/java/org/apache/calcite/util/UtilTest.java
Patch:
@@ -1656,6 +1656,8 @@ private void checkResourceMethodNames(Object resource) {
   }
 
   private NavigableSet<String> checkNav(NavigableSet<String> set, String s) {
+    // Note this does not support some unicode characters
+    // however it is fine for testing purposes
     return set.subSet(s.toUpperCase(Locale.ROOT), true,
         s.toLowerCase(Locale.ROOT), true);
   }

File: core/src/test/java/org/apache/calcite/test/ModelTest.java
Patch:
@@ -374,7 +374,7 @@ private ObjectMapper mapper() {
   @Test public void testYamlFileDetection() throws Exception {
     final URL inUrl = ModelTest.class.getResource("/empty-model.yaml");
     CalciteAssert.that()
-        .with(CalciteConnectionProperty.MODEL, inUrl.getFile())
+        .withModel(inUrl)
         .doWithConnection(calciteConnection -> null);
   }
 }

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.calcite.rel.metadata.RelMdDistribution;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.util.Litmus;
 
 import com.google.common.collect.ImmutableSet;
 
@@ -66,6 +67,7 @@ public LogicalFilter(
       ImmutableSet<CorrelationId> variablesSet) {
     super(cluster, traitSet, child, condition);
     this.variablesSet = Objects.requireNonNull(variablesSet);
+    assert isValid(Litmus.THROW, null);
   }
 
   @Deprecated // to be removed before 2.0

File: core/src/main/java/org/apache/calcite/runtime/Hook.java
Patch:
@@ -108,13 +108,13 @@ public enum Hook {
    *     }</pre>
    * </blockquote>
    */
-  public <T, R> Closeable add(final Consumer<T> handler) {
+  public <T> Closeable add(final Consumer<T> handler) {
     //noinspection unchecked
     handlers.add((Consumer<Object>) handler);
     return () -> remove(handler);
   }
 
-  /** @deprecated Use {@link #addThread(Consumer)}. */
+  /** @deprecated Use {@link #add(Consumer)}. */
   @SuppressWarnings("Guava")
   @Deprecated // to be removed in 2.0
   public <T, R> Closeable add(final Function<T, R> handler) {

File: core/src/test/java/org/apache/calcite/test/JdbcFrontLinqBackTest.java
Patch:
@@ -104,8 +104,8 @@ public class JdbcFrontLinqBackTest {
             + "from \"hr\".\"emps\" as e\n"
             + "order by \"deptno\", \"name\" desc")
         .explainContains(""
-            + "EnumerableCalc(expr#0..4=[{inputs}], expr#5=[UPPER($t2)], UN=[$t5], deptno=[$t1], name=[$t2])\n"
-            + "  EnumerableSort(sort0=[$1], sort1=[$2], dir0=[ASC], dir1=[DESC])\n"
+            + "EnumerableSort(sort0=[$1], sort1=[$2], dir0=[ASC], dir1=[DESC])\n"
+            + "  EnumerableCalc(expr#0..4=[{inputs}], expr#5=[UPPER($t2)], UN=[$t5], deptno=[$t1], name=[$t2])\n"
             + "    EnumerableTableScan(table=[[hr, emps]])")
         .returns("UN=THEODORE; deptno=10\n"
             + "UN=SEBASTIAN; deptno=10\n"

File: core/src/test/java/org/apache/calcite/test/MaterializationTest.java
Patch:
@@ -1743,7 +1743,7 @@ private void checkSatisfiable(RexNode e, String s) {
             + "join \"dependents\" on (\"depts\".\"name\" = \"dependents\".\"name\")",
         HR_FKUK_MODEL,
         CalciteAssert.checkResultContains(
-            "EnumerableCalc(expr#0..2=[{inputs}], empid0=[$t1])\n"
+            "EnumerableCalc(expr#0..2=[{inputs}], empid=[$t1])\n"
                 + "  EnumerableJoin(condition=[=($0, $2)], joinType=[inner])\n"
                 + "    EnumerableCalc(expr#0=[{inputs}], expr#1=[CAST($t0):VARCHAR CHARACTER SET \"ISO-8859-1\" "
                 + "COLLATE \"ISO-8859-1$en_US$primary\"], name=[$t1])\n"

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -2507,15 +2507,15 @@ public void testDynamicStarInTableJoin() throws Exception {
   }
 
   @Test public void testStarDynamicSchemaUnnest() {
-    final String sql3 = "select * \n"
+    final String sql3 = "select *\n"
         + "from SALES.CUSTOMER as t1,\n"
         + "lateral (select t2.\"$unnest\" as fake_col3\n"
         + "         from unnest(t1.fake_col) as t2) as t3";
     sql(sql3).with(getTesterWithDynamicTable()).ok();
   }
 
   @Test public void testStarDynamicSchemaUnnest2() {
-    final String sql3 = "select * \n"
+    final String sql3 = "select *\n"
         + "from SALES.CUSTOMER as t1,\n"
         + "unnest(t1.fake_col) as t2";
     sql(sql3).with(getTesterWithDynamicTable()).ok();

File: server/src/test/java/org/apache/calcite/test/ServerTest.java
Patch:
@@ -307,7 +307,7 @@ static Connection connect() throws SQLException {
       }
 
       final String plan = ""
-          + "EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1], expr#3=[+($t1, $t2)], proj#0..1=[{exprs}], $f2=[$t3])\n"
+          + "EnumerableCalc(expr#0..1=[{inputs}], expr#2=[1], expr#3=[+($t1, $t2)], proj#0..1=[{exprs}], J=[$t3])\n"
           + "  EnumerableTableScan(table=[[T]])\n";
       try (ResultSet r = s.executeQuery("explain plan for " + sql)) {
         assertThat(r.next(), is(true));

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
Patch:
@@ -72,7 +72,6 @@ public class EnumerableRelImplementor extends JavaRelImplementor {
       new HashMap<>();
   private final Map<Object, ParameterExpression> stashedParameters =
       new IdentityHashMap<>();
-  int windowCount = 0;
 
   protected final Function1<String, RexToLixTranslator.InputGetter> allCorrelateVariables =
       this::getCorrelVariableGetter;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -175,11 +175,10 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
 
     PhysType inputPhysType = result.physType;
 
-    final int w = implementor.windowCount++;
     ParameterExpression prevStart =
-        Expressions.parameter(int.class, builder.newName("prevStart" + w));
+        Expressions.parameter(int.class, builder.newName("prevStart"));
     ParameterExpression prevEnd =
-        Expressions.parameter(int.class, builder.newName("prevEnd" + w));
+        Expressions.parameter(int.class, builder.newName("prevEnd"));
 
     builder.add(Expressions.declare(0, prevStart, null));
     builder.add(Expressions.declare(0, prevEnd, null));

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
Patch:
@@ -2940,6 +2940,9 @@ public static DeclarationStatement declare(int modifiers,
    */
   public static DeclarationStatement declare(int modifiers, String name,
       Expression initializer) {
+    assert initializer != null
+        : "empty initializer for variable declaration with name '" + name + "', modifiers "
+        + modifiers + ". Please use declare(int, ParameterExpression, initializer) instead";
     return declare(modifiers, parameter(initializer.getType(), name),
         initializer);
   }

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/ExpressionTest.java
Patch:
@@ -995,7 +995,8 @@ public void checkBlockBuilder(boolean optimizing, String expected) {
             + "  final int _b = 1 + 2;\n"
             + "  final int _c = 1 + 3;\n"
             + "  final int _d = 1 + 4;\n"
-            + "  org.apache.calcite.linq4j.test.ExpressionTest.bar(1, _b, _c, _d, org.apache.calcite.linq4j.test.ExpressionTest.foo(_c));\n"
+            + "  final int _b0 = 1 + 3;\n"
+            + "  org.apache.calcite.linq4j.test.ExpressionTest.bar(1, _b, _c, _d, org.apache.calcite.linq4j.test.ExpressionTest.foo(_b0));\n"
             + "}\n",
         Expressions.toString(expression));
     expression.accept(new Shuttle());

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterStructsTest.java
Patch:
@@ -203,4 +203,5 @@ private RelToSqlConverterTest.Sql sql(String sql) {
     sql(query).ok(expected);
   }
 }
+
 // End RelToSqlConverterStructsTest.java

File: core/src/test/java/org/apache/calcite/test/HepPlannerTest.java
Patch:
@@ -42,7 +42,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
 
-
 /**
  * HepPlannerTest is a unit test for {@link HepPlanner}. See
  * {@link RelOptRulesTest} for an explanation of how to add tests; the tests in

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -2521,7 +2521,7 @@ public void testDynamicStarInTableJoin() throws Exception {
     sql(sql3).with(getTesterWithDynamicTable()).ok();
   }
 
-  @Test public void testStarDynamicSchemaUnnestNestedSubquery() {
+  @Test public void testStarDynamicSchemaUnnestNestedSubQuery() {
     String sql3 = "select t2.c1\n"
         + "from (select * from SALES.CUSTOMER) as t1,\n"
         + "unnest(t1.fake_col) as t2(c1)";

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -1179,13 +1179,12 @@ private PreparedResult prepare_(Supplier<RelNode> fn,
       final CatalogReader catalogReader =
           this.catalogReader.withSchemaPath(schemaPath);
       SqlValidator validator = createSqlValidator(catalogReader);
-      SqlNode sqlNode1 = validator.validate(sqlNode);
       final SqlToRelConverter.Config config = SqlToRelConverter.configBuilder()
               .withTrimUnusedFields(true).build();
       SqlToRelConverter sqlToRelConverter =
           getSqlToRelConverter(validator, catalogReader, config);
       RelRoot root =
-          sqlToRelConverter.convertQuery(sqlNode1, true, false);
+          sqlToRelConverter.convertQuery(sqlNode, true, false);
 
       --expansionDepth;
       return root;

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -262,7 +262,6 @@ public class ViewExpanderImpl implements ViewExpander {
           new CalciteSqlValidator(operatorTable, catalogReader, typeFactory,
               conformance);
       validator.setIdentifierExpansion(true);
-      final SqlNode validatedSqlNode = validator.validate(sqlNode);
 
       final RexBuilder rexBuilder = createRexBuilder();
       final RelOptCluster cluster = RelOptCluster.create(planner, rexBuilder);
@@ -276,7 +275,7 @@ public class ViewExpanderImpl implements ViewExpander {
           new SqlToRelConverter(new ViewExpanderImpl(), validator,
               catalogReader, cluster, convertletTable, config);
 
-      root = sqlToRelConverter.convertQuery(validatedSqlNode, true, false);
+      root = sqlToRelConverter.convertQuery(sqlNode, true, false);
       root = root.withRel(sqlToRelConverter.flattenTypes(root.rel, true));
       final RelBuilder relBuilder =
           config.getRelBuilderFactory().create(cluster, null);

File: core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
Patch:
@@ -232,7 +232,7 @@ void executeInstruction(
 
   void executeInstruction(
       HepInstruction.MatchOrder instruction) {
-    LOGGER.trace("Setting match limit to {}", instruction.order);
+    LOGGER.trace("Setting match order to {}", instruction.order);
     currentProgram.matchOrder = instruction.order;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -481,6 +481,8 @@ public static String stringValue(SqlNode node) {
   /**
    * Converts a chained string literals into regular literals; returns regular
    * literals unchanged.
+   * @throws IllegalArgumentException if {@code node} is not a string literal
+   * and cannot be unchained.
    */
   public static SqlLiteral unchain(SqlNode node) {
     if (node instanceof SqlLiteral) {
@@ -493,7 +495,7 @@ public static SqlLiteral unchain(SqlNode node) {
           new SqlIntervalLiteral.IntervalValue(q, 1, q.toString()),
           q.typeName(), q.pos);
     } else {
-      throw new AssertionError("invalid literal: " + node);
+      throw new IllegalArgumentException("invalid literal: " + node);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -241,8 +241,7 @@ private static boolean isSelectListItem(SqlNode root,
       final SqlParserPos pos) {
     List<SqlNode> nodes = SqlUtil.getAncestry(root,
         input -> input instanceof SqlIdentifier
-            && Util.last(((SqlIdentifier) input).names)
-                .equals(UPPER_HINT_TOKEN),
+            && ((SqlIdentifier) input).names.contains(UPPER_HINT_TOKEN),
         input -> Objects.requireNonNull(input).getParserPosition()
             .startsAt(pos));
     assert nodes.get(0) == root;

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -166,6 +166,7 @@ public SqlTypeName typeName() {
     case MILLISECOND:
     case EPOCH:
     case MICROSECOND:
+    case NANOSECOND:
       return SqlTypeName.INTERVAL_SECOND;
     default:
       throw new AssertionError(timeUnitRange);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlTimestampAddFunction.java
Patch:
@@ -39,8 +39,8 @@
  * </blockquote>
  *
  * <p>The interval time unit can one of the following literals:<ul>
- * <li>MICROSECOND (and synonyms SQL_TSI_MICROSECOND, FRAC_SECOND,
- *     SQL_TSI_FRAC_SECOND)
+ * <li>NANOSECOND (and synonym SQL_TSI_FRAC_SECOND)
+ * <li>MICROSECOND (and synonyms SQL_TSI_MICROSECOND, FRAC_SECOND)
  * <li>SECOND (and synonym SQL_TSI_SECOND)
  * <li>MINUTE (and synonym  SQL_TSI_MINUTE)
  * <li>HOUR (and synonym  SQL_TSI_HOUR)

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -6915,8 +6915,8 @@ public void subTestIntervalSecondFailsValidation() {
   @Test public void testTimestampAddAndDiff() {
     Map<String, List<String>> tsi = ImmutableMap.<String, List<String>>builder()
         .put("MICROSECOND",
-            Arrays.asList("FRAC_SECOND", "MICROSECOND",
-                "SQL_TSI_FRAC_SECOND", "SQL_TSI_MICROSECOND"))
+            Arrays.asList("FRAC_SECOND", "MICROSECOND", "SQL_TSI_MICROSECOND"))
+        .put("NANOSECOND", Arrays.asList("NANOSECOND", "SQL_TSI_FRAC_SECOND"))
         .put("SECOND", Arrays.asList("SECOND", "SQL_TSI_SECOND"))
         .put("MINUTE", Arrays.asList("MINUTE", "SQL_TSI_MINUTE"))
         .put("HOUR", Arrays.asList("HOUR", "SQL_TSI_HOUR"))

File: core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
Patch:
@@ -193,13 +193,13 @@ private void unparseFloor(SqlWriter writer, SqlCall call) {
       format = "%Y-%m-%d";
       break;
     case HOUR:
-      format = "%Y-%m-%d %k:00:00";
+      format = "%Y-%m-%d %H:00:00";
       break;
     case MINUTE:
-      format = "%Y-%m-%d %k:%i:00";
+      format = "%Y-%m-%d %H:%i:00";
       break;
     case SECOND:
-      format = "%Y-%m-%d %k:%i:%s";
+      format = "%Y-%m-%d %H:%i:%s";
       break;
     default:
       throw new AssertionError("MYSQL does not support FLOOR for time unit: "

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -754,6 +754,9 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
 
   @BaseMessage("Type ''{0}'' not found")
   ExInst<SqlValidatorException> typeNotFound(String name);
+
+  @BaseMessage("Dialect does not support feature: ''{0}''")
+  ExInst<SqlValidatorException> dialectDoesNotSupportFeature(String featureName);
 }
 
 // End CalciteResource.java

File: core/src/test/java/org/apache/calcite/test/JdbcFrontJdbcBackTest.java
Patch:
@@ -137,7 +137,6 @@ private void checkTablesByType(final String tableType,
   @Test public void testCase() {
     that()
         .with(CalciteAssert.Config.JDBC_FOODMART)
-        .withDefaultSchema("foodmart")
         .query("select\n"
             + "  case when \"sales_fact_1997\".\"promotion_id\" = 1 then 0\n"
             + "  else \"sales_fact_1997\".\"store_sales\" end as \"c0\"\n"

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverterRule.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /**
  * Rule to convert a relational expression from
@@ -40,7 +40,7 @@ public class CassandraToEnumerableConverterRule extends ConverterRule {
    */
   public CassandraToEnumerableConverterRule(
       RelBuilderFactory relBuilderFactory) {
-    super(RelNode.class, Predicates.<RelNode>alwaysTrue(),
+    super(RelNode.class, (Predicate<RelNode>) r -> true,
         CassandraRel.CONVENTION, EnumerableConvention.INSTANCE,
         relBuilderFactory, "CassandraToEnumerableConverterRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/clone/ListTable.java
Patch:
@@ -29,7 +29,6 @@
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.schema.Statistic;
 import org.apache.calcite.schema.Statistics;
-import org.apache.calcite.util.ImmutableBitSet;
 
 import com.google.common.collect.ImmutableList;
 
@@ -64,7 +63,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
   }
 
   public Statistic getStatistic() {
-    return Statistics.of(list.size(), ImmutableList.<ImmutableBitSet>of());
+    return Statistics.of(list.size(), ImmutableList.of());
   }
 
   public <T> Queryable<T> asQueryable(final QueryProvider queryProvider,

File: core/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
Patch:
@@ -42,7 +42,6 @@
 import java.util.List;
 import java.util.Map;
 
-
 /**
  * Implementation of a {@link org.apache.calcite.rel.core.Filter}
  * relational expression in Elasticsearch.

File: core/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTableScan.java
Patch:
@@ -27,9 +27,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 
-import com.google.common.base.Preconditions;
-
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Relational expression representing a scan of an Elasticsearch type.
@@ -54,7 +53,7 @@ protected ElasticsearchTableScan(RelOptCluster cluster, RelTraitSet traitSet,
        RelOptTable table, AbstractElasticsearchTable elasticsearchTable,
        RelDataType projectRowType) {
     super(cluster, traitSet, table);
-    this.elasticsearchTable = Preconditions.checkNotNull(elasticsearchTable);
+    this.elasticsearchTable = Objects.requireNonNull(elasticsearchTable);
     this.projectRowType = projectRowType;
 
     assert getConvention() == ElasticsearchRel.CONVENTION;

File: core/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchToEnumerableConverterRule.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /**
  * Rule to convert a relational expression from
@@ -40,7 +40,7 @@ public class ElasticsearchToEnumerableConverterRule extends ConverterRule {
    */
   public ElasticsearchToEnumerableConverterRule(
       RelBuilderFactory relBuilderFactory) {
-    super(RelNode.class, Predicates.<RelNode>alwaysTrue(),
+    super(RelNode.class, (Predicate<RelNode>) r -> true,
         ElasticsearchRel.CONVENTION, EnumerableConvention.INSTANCE,
         relBuilderFactory, "ElasticsearchToEnumerableConverterRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregate.java
Patch:
@@ -48,7 +48,6 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -368,7 +367,7 @@ public RexToLixTranslator rowTranslator() {
     }
     resultBlock.add(physType.record(results));
     if (getGroupType() != Group.SIMPLE) {
-      final List<Expression> list = Lists.newArrayList();
+      final List<Expression> list = new ArrayList<>();
       for (ImmutableBitSet set : groupSets) {
         list.add(
             inputPhysType.generateSelector(parameter, groupSet.asList(),

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableCorrelateRule.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.rel.logical.LogicalCorrelate;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /**
  * Implementation of nested loops over enumerable inputs.
@@ -35,7 +35,7 @@ public class EnumerableCorrelateRule extends ConverterRule {
    * @param relBuilderFactory Builder for relational expressions
    */
   public EnumerableCorrelateRule(RelBuilderFactory relBuilderFactory) {
-    super(LogicalCorrelate.class, Predicates.<RelNode>alwaysTrue(),
+    super(LogicalCorrelate.class, (Predicate<RelNode>) r -> true,
         Convention.NONE, EnumerableConvention.INSTANCE, relBuilderFactory,
         "EnumerableCorrelateRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpreterRule.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /**
  * Planner rule that converts {@link org.apache.calcite.interpreter.BindableRel}
@@ -39,7 +39,7 @@ public class EnumerableInterpreterRule extends ConverterRule {
    * @param relBuilderFactory Builder for relational expressions
    */
   public EnumerableInterpreterRule(RelBuilderFactory relBuilderFactory) {
-    super(RelNode.class, Predicates.<RelNode>alwaysTrue(),
+    super(RelNode.class, (Predicate<RelNode>) r -> true,
         BindableConvention.INSTANCE, EnumerableConvention.INSTANCE,
         relBuilderFactory, "EnumerableInterpreterRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
Patch:
@@ -96,7 +96,7 @@ public static EnumerableMergeJoin create(RelNode left, RelNode right,
       traitSet = traitSet.replace(collations);
     }
     return new EnumerableMergeJoin(cluster, traitSet, left, right, condition,
-        leftKeys, rightKeys, ImmutableSet.<CorrelationId>of(), joinType);
+        leftKeys, rightKeys, ImmutableSet.of(), joinType);
   }
 
   @Override public EnumerableMergeJoin copy(RelTraitSet traitSet,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableFunctionScanRule.java
Patch:
@@ -24,7 +24,7 @@
 import org.apache.calcite.rel.logical.LogicalTableFunctionScan;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /** Planner rule that converts a
  * {@link org.apache.calcite.rel.logical.LogicalTableFunctionScan}
@@ -42,7 +42,7 @@ public EnumerableTableFunctionScanRule() {
    * @param relBuilderFactory Builder for relational expressions
    */
   public EnumerableTableFunctionScanRule(RelBuilderFactory relBuilderFactory) {
-    super(LogicalTableFunctionScan.class, Predicates.<RelNode>alwaysTrue(),
+    super(LogicalTableFunctionScan.class, (Predicate<RelNode>) r -> true,
         Convention.NONE, EnumerableConvention.INSTANCE, relBuilderFactory,
         "EnumerableTableFunctionScanRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableModifyRule.java
Patch:
@@ -24,7 +24,7 @@
 import org.apache.calcite.schema.ModifiableTable;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /** Planner rule that converts a
  * {@link org.apache.calcite.rel.logical.LogicalTableModify}
@@ -37,7 +37,7 @@ public class EnumerableTableModifyRule extends ConverterRule {
    * @param relBuilderFactory Builder for relational expressions
    */
   public EnumerableTableModifyRule(RelBuilderFactory relBuilderFactory) {
-    super(LogicalTableModify.class, Predicates.<RelNode>alwaysTrue(),
+    super(LogicalTableModify.class, (Predicate<RelNode>) r -> true,
         Convention.NONE, EnumerableConvention.INSTANCE, relBuilderFactory,
         "EnumerableTableModificationRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScanRule.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /** Planner rule that converts a
  * {@link org.apache.calcite.rel.logical.LogicalTableFunctionScan}
@@ -45,7 +45,7 @@ public EnumerableTableScanRule() {
    * @param relBuilderFactory Builder for relational expressions
    */
   public EnumerableTableScanRule(RelBuilderFactory relBuilderFactory) {
-    super(LogicalTableScan.class, Predicates.<RelNode>alwaysTrue(),
+    super(LogicalTableScan.class, (Predicate<RelNode>) r -> true,
         Convention.NONE, EnumerableConvention.INSTANCE, relBuilderFactory,
         "EnumerableTableScanRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
Patch:
@@ -116,7 +116,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
             Expressions.constant(Ints.toArray(fieldCounts)),
             Expressions.constant(withOrdinality),
             Expressions.constant(
-                inputTypes.toArray(new FlatProductInputType[inputTypes.size()])));
+                inputTypes.toArray(new FlatProductInputType[0])));
     builder.add(
         Expressions.return_(null,
             Expressions.call(child_,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValuesRule.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.rel.logical.LogicalValues;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /** Planner rule that converts a
  * {@link org.apache.calcite.rel.logical.LogicalValues}
@@ -35,7 +35,7 @@ public class EnumerableValuesRule extends ConverterRule {
    * @param relBuilderFactory Builder for relational expressions
    */
   public EnumerableValuesRule(RelBuilderFactory relBuilderFactory) {
-    super(LogicalValues.class, Predicates.<RelNode>alwaysTrue(),
+    super(LogicalValues.class, (Predicate<RelNode>) r -> true,
         Convention.NONE, EnumerableConvention.INSTANCE, relBuilderFactory,
         "EnumerableValuesRule");
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/NestedBlockBuilderImpl.java
Patch:
@@ -52,7 +52,7 @@ public NestedBlockBuilderImpl(BlockBuilder block) {
    */
   public final BlockBuilder nestBlock() {
     BlockBuilder block = new BlockBuilder(true, currentBlock());
-    nestBlock(block, Collections.<RexNode, Boolean>emptyMap());
+    nestBlock(block, Collections.emptyMap());
     return block;
   }
 
@@ -63,7 +63,7 @@ public final BlockBuilder nestBlock() {
    * @see #exitBlock()
    */
   public final void nestBlock(BlockBuilder block) {
-    nestBlock(block, Collections.<RexNode, Boolean>emptyMap());
+    nestBlock(block, Collections.emptyMap());
   }
 
   /**
@@ -77,7 +77,7 @@ public final void nestBlock(BlockBuilder block,
       Map<RexNode, Boolean> nullables) {
     blocks.add(block);
     Map<RexNode, Boolean> prev = this.nullables.isEmpty()
-        ? Collections.<RexNode, Boolean>emptyMap()
+        ? Collections.emptyMap()
         : this.nullables.get(this.nullables.size() - 1);
     Map<RexNode, Boolean> next;
     if (nullables == null || nullables.isEmpty()) {

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -38,7 +38,6 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
@@ -52,6 +51,7 @@
 import java.util.Collection;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import javax.sql.DataSource;
 
@@ -89,8 +89,8 @@ private JdbcSchema(DataSource dataSource, SqlDialect dialect,
       JdbcConvention convention, String catalog, String schema,
       ImmutableMap<String, JdbcTable> tableMap) {
     super();
-    this.dataSource = Preconditions.checkNotNull(dataSource);
-    this.dialect = Preconditions.checkNotNull(dialect);
+    this.dataSource = Objects.requireNonNull(dataSource);
+    this.dialect = Objects.requireNonNull(dialect);
     this.convention = convention;
     this.catalog = catalog;
     this.schema = schema;

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverterRule.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.rel.convert.ConverterRule;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /**
  * Rule to convert a relational expression from
@@ -33,7 +33,7 @@ public class JdbcToEnumerableConverterRule extends ConverterRule {
   /** Creates a JdbcToEnumerableConverterRule. */
   public JdbcToEnumerableConverterRule(JdbcConvention out,
       RelBuilderFactory relBuilderFactory) {
-    super(RelNode.class, Predicates.<RelNode>alwaysTrue(), out,
+    super(RelNode.class, (Predicate<RelNode>) r -> true, out,
         EnumerableConvention.INSTANCE, relBuilderFactory,
         "JdbcToEnumerableConverterRule:" + out);
   }

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfigImpl.java
Patch:
@@ -99,7 +99,7 @@ public <T> T fun(Class<T> operatorTableClass, T defaultOperatorTable) {
     tables.add(SqlStdOperatorTable.instance());
     return operatorTableClass.cast(
         ChainedSqlOperatorTable.of(
-            tables.toArray(new SqlOperatorTable[tables.size()])));
+            tables.toArray(new SqlOperatorTable[0])));
   }
 
   private static void operatorTable(String s,

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -46,7 +46,6 @@
 import org.apache.calcite.util.ReflectiveVisitor;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -65,6 +64,7 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 
 /**
  * Interpreter.
@@ -81,7 +81,7 @@ public class Interpreter extends AbstractEnumerable<Object[]>
 
   /** Creates an Interpreter. */
   public Interpreter(DataContext dataContext, RelNode rootRel) {
-    this.dataContext = Preconditions.checkNotNull(dataContext);
+    this.dataContext = Objects.requireNonNull(dataContext);
     final RelNode rel = optimize(rootRel);
     final CompilerImpl compiler =
         new Nodes.CoreCompiler(this, rootRel.getCluster());
@@ -266,7 +266,7 @@ private static class EnumeratorSource implements Source {
     private final Enumerator<Row> enumerator;
 
     EnumeratorSource(final Enumerator<Row> enumerator) {
-      this.enumerator = Preconditions.checkNotNull(enumerator);
+      this.enumerator = Objects.requireNonNull(enumerator);
     }
 
     @Override public Row receive() {

File: core/src/main/java/org/apache/calcite/interpreter/JoinNode.java
Patch:
@@ -19,8 +19,8 @@
 import org.apache.calcite.rel.core.Join;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -56,7 +56,7 @@ public void run() throws InterruptedException {
     while ((left = leftSource.receive()) != null) {
       System.arraycopy(left.getValues(), 0, context.values, 0, leftCount);
       if (rightList == null) {
-        rightList = Lists.newArrayList();
+        rightList = new ArrayList<>();
         while ((right = rightSource.receive()) != null) {
           rightList.add(right);
         }

File: core/src/main/java/org/apache/calcite/interpreter/NoneToBindableConverterRule.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-import com.google.common.base.Predicates;
+import java.util.function.Predicate;
 
 /**
  * Rule to convert a relational expression from
@@ -40,7 +40,7 @@ public class NoneToBindableConverterRule extends ConverterRule {
    * @param relBuilderFactory Builder for relational expressions
    */
   public NoneToBindableConverterRule(RelBuilderFactory relBuilderFactory) {
-    super(RelNode.class, Predicates.<RelNode>alwaysTrue(), Convention.NONE,
+    super(RelNode.class, (Predicate<RelNode>) r -> true, Convention.NONE,
         BindableConvention.INSTANCE, relBuilderFactory,
         "NoneToBindableConverterRule");
   }

File: core/src/main/java/org/apache/calcite/interpreter/UnionNode.java
Patch:
@@ -19,8 +19,8 @@
 import org.apache.calcite.rel.core.Union;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Sets;
 
+import java.util.HashSet;
 import java.util.Set;
 
 /**
@@ -43,7 +43,7 @@ public UnionNode(Compiler compiler, Union rel) {
   }
 
   public void run() throws InterruptedException {
-    final Set<Row> rows = rel.all ? null : Sets.<Row>newHashSet();
+    final Set<Row> rows = rel.all ? null : new HashSet<>();
     for (Source source : sources) {
       Row row;
       while ((row = source.receive()) != null) {

File: core/src/main/java/org/apache/calcite/interpreter/ValuesNode.java
Patch:
@@ -21,8 +21,8 @@
 import org.apache.calcite.rex.RexNode;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -42,7 +42,7 @@ public ValuesNode(Compiler compiler, Values rel) {
 
   private ImmutableList<Row> createRows(Compiler compiler,
       ImmutableList<ImmutableList<RexLiteral>> tuples) {
-    final List<RexNode> nodes = Lists.newArrayList();
+    final List<RexNode> nodes = new ArrayList<>();
     for (ImmutableList<RexLiteral> tuple : tuples) {
       nodes.addAll(tuple);
     }

File: core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
Patch:
@@ -19,8 +19,6 @@
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rel.type.RelRecordType;
 
-import com.google.common.base.Preconditions;
-
 import java.util.List;
 import java.util.Objects;
 
@@ -36,7 +34,7 @@ public class JavaRecordType extends RelRecordType {
 
   public JavaRecordType(List<RelDataTypeField> fields, Class clazz) {
     super(fields);
-    this.clazz = Preconditions.checkNotNull(clazz);
+    this.clazz = Objects.requireNonNull(clazz);
   }
 
   @Override public boolean equals(Object obj) {

File: core/src/main/java/org/apache/calcite/materialize/LatticeStatisticProvider.java
Patch:
@@ -16,9 +16,8 @@
  */
 package org.apache.calcite.materialize;
 
-import com.google.common.base.Function;
-
 import java.util.List;
+import java.util.function.Function;
 
 /**
  * Estimates row counts for a lattice and its attributes.

File: core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
Patch:
@@ -16,12 +16,12 @@
  */
 package org.apache.calcite.plan;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Ordering;
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * A trait that consists of a list of traits, all of the same type.
@@ -40,7 +40,7 @@ class RelCompositeTrait<T extends RelMultipleTrait> implements RelTrait {
   // Must remain private. Does not copy the array.
   private RelCompositeTrait(RelTraitDef traitDef, T[] traits) {
     this.traitDef = traitDef;
-    this.traits = Preconditions.checkNotNull(traits);
+    this.traits = Objects.requireNonNull(traits);
     //noinspection unchecked
     assert Ordering.natural()
         .isStrictlyOrdered(Arrays.asList((Comparable[]) traits))
@@ -59,7 +59,7 @@ static <T extends RelMultipleTrait> RelCompositeTrait<T> of(RelTraitDef def,
       compositeTrait = new EmptyCompositeTrait<T>(def);
     } else {
       final RelMultipleTrait[] traits =
-          traitList.toArray(new RelMultipleTrait[traitList.size()]);
+          traitList.toArray(new RelMultipleTrait[0]);
       for (int i = 0; i < traits.length; i++) {
         traits[i] = (T) def.canonize(traits[i]);
       }

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleCall.java
Patch:
@@ -231,7 +231,7 @@ public List<RelNode> getParents() {
    *            expression of the rule call, {@code call.rels(0)}
    */
   public final void transformTo(RelNode rel) {
-    transformTo(rel, ImmutableMap.<RelNode, RelNode>of());
+    transformTo(rel, ImmutableMap.of());
   }
 
   /** Creates a {@link org.apache.calcite.tools.RelBuilder} to be used by

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleOperandChildren.java
Patch:
@@ -34,12 +34,12 @@ public class RelOptRuleOperandChildren {
   static final RelOptRuleOperandChildren ANY_CHILDREN =
       new RelOptRuleOperandChildren(
           RelOptRuleOperandChildPolicy.ANY,
-          ImmutableList.<RelOptRuleOperand>of());
+          ImmutableList.of());
 
   static final RelOptRuleOperandChildren LEAF_CHILDREN =
       new RelOptRuleOperandChildren(
           RelOptRuleOperandChildPolicy.LEAF,
-          ImmutableList.<RelOptRuleOperand>of());
+          ImmutableList.of());
 
   final RelOptRuleOperandChildPolicy policy;
   final ImmutableList<RelOptRuleOperand> operands;

File: core/src/main/java/org/apache/calcite/plan/RelTraitSet.java
Patch:
@@ -19,14 +19,14 @@
 import org.apache.calcite.runtime.FlatLists;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.base.Supplier;
 import com.google.common.collect.ImmutableList;
 
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.function.Supplier;
 
 /**
  * RelTraitSet represents an ordered set of {@link RelTrait}s.
@@ -551,7 +551,7 @@ RelTraitSet getOrAdd(List<RelTrait> traits) {
         return traitSet1;
       }
       final RelTraitSet traitSet =
-          new RelTraitSet(this, traits.toArray(new RelTrait[traits.size()]));
+          new RelTraitSet(this, traits.toArray(new RelTrait[0]));
       map.put(traits, traitSet);
       return traitSet;
     }

File: core/src/main/java/org/apache/calcite/plan/Strong.java
Patch:
@@ -24,14 +24,14 @@
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.util.ImmutableBitSet;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
 import java.util.ArrayList;
 import java.util.EnumMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 
 /** Utilities for strong predicates.
  *
@@ -87,7 +87,7 @@ public static boolean isNotTrue(RexNode node, ImmutableBitSet nullColumns) {
   /** Returns how to deduce whether a particular kind of expression is null,
    * given whether its arguments are null. */
   public static Policy policy(SqlKind kind) {
-    return Preconditions.checkNotNull(MAP.get(kind), kind);
+    return Objects.requireNonNull(MAP.get(kind), kind.toString());
   }
 
   /** Returns whether an expression is definitely not true. */

File: core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
Patch:
@@ -133,7 +133,7 @@ public HepPlanner(
     super(costFactory, context);
     this.mainProgram = program;
     this.onCopyHook =
-        Util.first(onCopyHook, Functions.<RelNode, RelNode, Void>ignore2());
+        Util.first(onCopyHook, Functions.ignore2());
     mapDigestToVertex = new HashMap<>();
     graph = DefaultDirectedGraph.create();
 
@@ -544,7 +544,7 @@ private HepRelVertex applyRule(
         new HepRuleCall(
             this,
             rule.getOperand(),
-            bindings.toArray(new RelNode[bindings.size()]),
+            bindings.toArray(new RelNode[0]),
             nodeChildren,
             parents);
 

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
Patch:
@@ -80,7 +80,7 @@ protected VolcanoRuleCall(
         planner,
         operand,
         new RelNode[operand.getRule().operands.size()],
-        ImmutableMap.<RelNode, List<RelNode>>of());
+        ImmutableMap.of());
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -50,8 +50,8 @@
 import org.apache.calcite.sql2rel.SqlToRelConverter;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -126,7 +126,7 @@ private Iterable<Callback> useStar(CalciteSchema schema, RelNode queryRel) {
       // Don't waste effort converting to leaf-join form.
       return ImmutableList.of();
     }
-    final List<Callback> list = Lists.newArrayList();
+    final List<Callback> list = new ArrayList<>();
     final RelNode rel2 =
         RelOptMaterialization.toLeafJoinForm(queryRel);
     for (CalciteSchema.TableEntry starTable : starTables) {

File: core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
Patch:
@@ -102,15 +102,15 @@ public RelNode translate(Expression expression) {
                 typeFactory.createJavaType(
                     Types.toClass(
                         Types.getElementType(call.targetExpression.getType()))),
-                ImmutableList.<String>of(),
+                ImmutableList.of(),
                 call.targetExpression));
 
       case SCHEMA_GET_TABLE:
         return LogicalTableScan.create(cluster,
             RelOptTableImpl.create(null,
                 typeFactory.createJavaType((Class)
                     ((ConstantExpression) call.expressions.get(1)).value),
-                ImmutableList.<String>of(),
+                ImmutableList.of(),
                 call.targetExpression));
 
       default:

File: core/src/main/java/org/apache/calcite/rel/RelDistributions.java
Patch:
@@ -24,7 +24,6 @@
 import org.apache.calcite.util.mapping.Mapping;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Ordering;
 
 import java.util.Collection;
@@ -89,7 +88,7 @@ private static class RelDistributionImpl implements RelDistribution {
     private final ImmutableIntList keys;
 
     private RelDistributionImpl(Type type, ImmutableIntList keys) {
-      this.type = Preconditions.checkNotNull(type);
+      this.type = Objects.requireNonNull(type);
       this.keys = ImmutableIntList.copyOf(keys);
       assert type != Type.HASH_DISTRIBUTED
           || keys.size() < 2

File: core/src/main/java/org/apache/calcite/rel/RelRoot.java
Patch:
@@ -25,11 +25,11 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Root of a tree of {@link RelNode}.
@@ -92,7 +92,7 @@ public RelRoot(RelNode rel, RelDataType validatedRowType, SqlKind kind,
     this.validatedRowType = validatedRowType;
     this.kind = kind;
     this.fields = ImmutableList.copyOf(fields);
-    this.collation = Preconditions.checkNotNull(collation);
+    this.collation = Objects.requireNonNull(collation);
   }
 
   /** Creates a simple RelRoot. */

File: core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
Patch:
@@ -24,7 +24,6 @@
 import org.apache.calcite.util.mapping.Mapping;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
@@ -89,9 +88,9 @@ private AggregateCall(
       int filterArg,
       RelDataType type,
       String name) {
-    this.type = Preconditions.checkNotNull(type);
+    this.type = Objects.requireNonNull(type);
     this.name = name;
-    this.aggFunction = Preconditions.checkNotNull(aggFunction);
+    this.aggFunction = Objects.requireNonNull(aggFunction);
     this.argList = ImmutableList.copyOf(argList);
     this.filterArg = filterArg;
     this.distinct = distinct;

File: core/src/main/java/org/apache/calcite/rel/core/Correlate.java
Patch:
@@ -27,7 +27,6 @@
 import org.apache.calcite.rel.RelWriter;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
-import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.sql.SemiJoinType;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 import org.apache.calcite.util.ImmutableBitSet;
@@ -144,7 +143,7 @@ public SemiJoinType getJoinType() {
       return SqlValidatorUtil.deriveJoinRowType(left.getRowType(),
           right.getRowType(), joinType.toJoinType(),
           getCluster().getTypeFactory(), null,
-          ImmutableList.<RelDataTypeField>of());
+          ImmutableList.of());
     case ANTI:
     case SEMI:
       return left.getRowType();

File: core/src/main/java/org/apache/calcite/rel/core/Exchange.java
Patch:
@@ -30,9 +30,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Relational expression that imposes a particular distribution on its input
@@ -58,7 +57,7 @@ public abstract class Exchange extends SingleRel {
   protected Exchange(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
       RelDistribution distribution) {
     super(cluster, traitSet, input);
-    this.distribution = Preconditions.checkNotNull(distribution);
+    this.distribution = Objects.requireNonNull(distribution);
 
     assert traitSet.containsIfApplicable(distribution)
         : "traits=" + traitSet + ", distribution" + distribution;

File: core/src/main/java/org/apache/calcite/rel/core/Join.java
Patch:
@@ -36,12 +36,12 @@
 import org.apache.calcite.util.Litmus;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 
 /**
@@ -101,9 +101,9 @@ protected Join(
       Set<CorrelationId> variablesSet,
       JoinRelType joinType) {
     super(cluster, traitSet, left, right);
-    this.condition = Preconditions.checkNotNull(condition);
+    this.condition = Objects.requireNonNull(condition);
     this.variablesSet = ImmutableSet.copyOf(variablesSet);
-    this.joinType = Preconditions.checkNotNull(joinType);
+    this.joinType = Objects.requireNonNull(joinType);
   }
 
   @Deprecated // to be removed before 2.0

File: core/src/main/java/org/apache/calcite/rel/core/RelFactories.java
Patch:
@@ -35,7 +35,6 @@
 import org.apache.calcite.rel.logical.LogicalUnion;
 import org.apache.calcite.rel.logical.LogicalValues;
 import org.apache.calcite.rel.type.RelDataType;
-import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.sql.SemiJoinType;
@@ -272,7 +271,7 @@ public RelNode createJoin(RelNode left, RelNode right,
         RexNode condition, Set<CorrelationId> variablesSet,
         JoinRelType joinType, boolean semiJoinDone) {
       return LogicalJoin.create(left, right, condition, variablesSet, joinType,
-          semiJoinDone, ImmutableList.<RelDataTypeField>of());
+          semiJoinDone, ImmutableList.of());
     }
 
     public RelNode createJoin(RelNode left, RelNode right, RexNode condition,

File: core/src/main/java/org/apache/calcite/rel/core/SemiJoin.java
Patch:
@@ -25,7 +25,6 @@
 import org.apache.calcite.rel.metadata.RelMdUtil;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
-import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 import org.apache.calcite.util.ImmutableIntList;
@@ -73,7 +72,7 @@ public SemiJoin(
         condition,
         leftKeys,
         rightKeys,
-        ImmutableSet.<CorrelationId>of(),
+        ImmutableSet.of(),
         JoinRelType.INNER);
   }
 
@@ -121,7 +120,7 @@ public static SemiJoin create(RelNode left, RelNode right, RexNode condition,
         JoinRelType.INNER,
         getCluster().getTypeFactory(),
         null,
-        ImmutableList.<RelDataTypeField>of());
+        ImmutableList.of());
   }
 }
 

File: core/src/main/java/org/apache/calcite/rel/core/SortExchange.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
 
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 
 /**
  * Relational expression that performs {@link Exchange} and {@link Sort}
@@ -57,7 +57,7 @@ public abstract class SortExchange extends Exchange {
   protected SortExchange(RelOptCluster cluster, RelTraitSet traitSet,
       RelNode input, RelDistribution distribution, RelCollation collation) {
     super(cluster, traitSet, input, distribution);
-    this.collation = Preconditions.checkNotNull(collation);
+    this.collation = Objects.requireNonNull(collation);
 
     assert traitSet.containsIfApplicable(collation)
         : "traits=" + traitSet + ", collation=" + collation;

File: core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
Patch:
@@ -95,7 +95,7 @@ protected TableFunctionScan(RelInput input) {
         input.getCluster(), input.getTraitSet(), input.getInputs(),
         input.getExpression("invocation"), (Type) input.get("elementType"),
         input.getRowType("rowType"),
-        ImmutableSet.<RelColumnMapping>of());
+        ImmutableSet.of());
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/core/TableModify.java
Patch:
@@ -36,6 +36,7 @@
 import com.google.common.base.Preconditions;
 
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Relational expression that modifies a table.
@@ -116,8 +117,8 @@ protected TableModify(
     this.updateColumnList = updateColumnList;
     this.sourceExpressionList = sourceExpressionList;
     if (operation == Operation.UPDATE) {
-      Preconditions.checkNotNull(updateColumnList);
-      Preconditions.checkNotNull(sourceExpressionList);
+      Objects.requireNonNull(updateColumnList);
+      Objects.requireNonNull(sourceExpressionList);
       Preconditions.checkArgument(sourceExpressionList.size()
           == updateColumnList.size());
     } else {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdSize.java
Patch:
@@ -43,8 +43,8 @@
 import org.apache.calcite.util.Pair;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -219,7 +219,7 @@ public List<Double> averageColumnSizes(Minus rel, RelMetadataQuery mq) {
 
   public List<Double> averageColumnSizes(Union rel, RelMetadataQuery mq) {
     final int fieldCount = rel.getRowType().getFieldCount();
-    List<List<Double>> inputColumnSizeList = Lists.newArrayList();
+    List<List<Double>> inputColumnSizeList = new ArrayList<>();
     for (RelNode input : rel.getInputs()) {
       final List<Double> inputSizes = mq.getAverageColumnSizes(input);
       if (inputSizes != null) {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdTableReferences.java
Patch:
@@ -32,8 +32,8 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
-import com.google.common.collect.Sets;
 
 import java.util.Collection;
 import java.util.HashMap;
@@ -88,7 +88,7 @@ public Set<RelTableRef> getTableReferences(RelSubset rel, RelMetadataQuery mq) {
    * TableScan table reference.
    */
   public Set<RelTableRef> getTableReferences(TableScan rel, RelMetadataQuery mq) {
-    return Sets.newHashSet(RelTableRef.of(rel.getTable(), 0));
+    return ImmutableSet.of(RelTableRef.of(rel.getTable(), 0));
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/metadata/UnboundMetadata.java
Patch:
@@ -24,6 +24,7 @@
  *
  * @param <M> Metadata type
  */
+@FunctionalInterface
 public interface UnboundMetadata<M extends Metadata> {
   M bind(RelNode rel, RelMetadataQuery mq);
 }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -308,7 +308,7 @@ private RelBuilder convertSingletonDistinct(RelBuilder relBuilder,
 
     // Add aggregate A (see the reference example above), the top aggregate
     // to handle the rest of the aggregation that the bottom aggregate hasn't handled
-    final List<AggregateCall> topAggregateCalls = Lists.newArrayList();
+    final List<AggregateCall> topAggregateCalls = new ArrayList<>();
     // Use the remapped arguments for the (non)distinct aggregate calls
     int nonDistinctAggCallProcessedSoFar = 0;
     for (AggregateCall aggCall : originalAggCalls) {
@@ -707,7 +707,7 @@ private void doRewrite(RelBuilder relBuilder, Aggregate aggregate, int n,
     // where {f0, f1, ...} are the GROUP BY fields.
     final List<RelDataTypeField> distinctFields =
         relBuilder.peek().getRowType().getFieldList();
-    final List<RexNode> conditions = Lists.newArrayList();
+    final List<RexNode> conditions = new ArrayList<>();
     for (i = 0; i < groupAndIndicatorCount; ++i) {
       // null values form its own group
       // use "is not distinct from" so that the join condition
@@ -845,7 +845,7 @@ private RelBuilder createSelectDistinct(RelBuilder relBuilder,
     relBuilder.push(
         aggregate.copy(aggregate.getTraitSet(), relBuilder.build(), false,
             ImmutableBitSet.range(projects.size()),
-            null, ImmutableList.<AggregateCall>of()));
+            null, ImmutableList.of()));
     return relBuilder;
   }
 }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectMergeRule.java
Patch:
@@ -31,8 +31,8 @@
 import org.apache.calcite.util.ImmutableBitSet;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -73,7 +73,7 @@ public void onMatch(RelOptRuleCall call) {
 
   public static RelNode apply(RelOptRuleCall call, Aggregate aggregate,
       Project project) {
-    final List<Integer> newKeys = Lists.newArrayList();
+    final List<Integer> newKeys = new ArrayList<>();
     final Map<Integer, Integer> map = new HashMap<>();
     for (int key : aggregate.getGroupSet()) {
       final RexNode rex = project.getProjects().get(key);
@@ -131,7 +131,7 @@ public static RelNode apply(RelOptRuleCall call, Aggregate aggregate,
     final RelBuilder relBuilder = call.builder();
     relBuilder.push(newAggregate);
     if (!newKeys.equals(newGroupSet.asList())) {
-      final List<Integer> posList = Lists.newArrayList();
+      final List<Integer> posList = new ArrayList<>();
       for (int newKey : newKeys) {
         posList.add(newGroupSet.indexOf(newKey));
       }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectPullUpConstantsRule.java
Patch:
@@ -87,7 +87,7 @@ public AggregateProjectPullUpConstantsRule(
       Class<? extends RelNode> inputClass,
       RelBuilderFactory relBuilderFactory, String description) {
     super(
-        operand(aggregateClass, null, Aggregate.IS_SIMPLE,
+        operandJ(aggregateClass, null, Aggregate::isSimple,
             operand(inputClass, any())),
         relBuilderFactory, description);
   }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionAggregateRule.java
Patch:
@@ -77,7 +77,7 @@ public AggregateUnionAggregateRule(Class<? extends Aggregate> aggregateClass,
       RelBuilderFactory relBuilderFactory,
       String desc) {
     super(
-        operand(aggregateClass, null, Aggregate.IS_SIMPLE,
+        operandJ(aggregateClass, null, Aggregate::isSimple,
             operand(unionClass,
                 operand(firstUnionInputClass, any()),
                 operand(secondUnionInputClass, any()))),

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -39,8 +39,8 @@
 import org.apache.calcite.tools.RelBuilderFactory;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
+import java.util.ArrayList;
 import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
@@ -147,7 +147,7 @@ public void onMatch(RelOptRuleCall call) {
 
   private List<AggregateCall> transformAggCalls(RelNode input, int groupCount,
       List<AggregateCall> origCalls) {
-    final List<AggregateCall> newCalls = Lists.newArrayList();
+    final List<AggregateCall> newCalls = new ArrayList<>();
     for (Ord<AggregateCall> ord : Ord.zip(origCalls)) {
       final AggregateCall origCall = ord.e;
       if (origCall.isDistinct()

File: core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
Patch:
@@ -126,7 +126,7 @@ RelNode execute() {
     // expressions to the left.
     assert program.isValid(Litmus.THROW, null);
     final List<RexNode> exprList = program.getExprList();
-    final RexNode[] exprs = exprList.toArray(new RexNode[exprList.size()]);
+    final RexNode[] exprs = exprList.toArray(new RexNode[0]);
     assert !RexUtil.containComplexExprs(exprList);
 
     // Figure out what level each expression belongs to.

File: core/src/main/java/org/apache/calcite/rel/rules/FilterAggregateTransposeRule.java
Patch:
@@ -34,8 +34,8 @@
 import org.apache.calcite.util.ImmutableBitSet;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -103,8 +103,8 @@ public void onMatch(RelOptRuleCall call) {
       adjustments[j] = i - j;
       j++;
     }
-    final List<RexNode> pushedConditions = Lists.newArrayList();
-    final List<RexNode> remainingConditions = Lists.newArrayList();
+    final List<RexNode> pushedConditions = new ArrayList<>();
+    final List<RexNode> remainingConditions = new ArrayList<>();
 
     for (RexNode condition : conditions) {
       ImmutableBitSet rCols = RelOptUtil.InputFinder.bits(condition);

File: core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
Patch:
@@ -187,7 +187,7 @@ public void onMatch(RelOptRuleCall call) {
             JoinRelType.INNER,
             joinRel.getCluster().getTypeFactory(),
             null,
-            Collections.<RelDataTypeField>emptyList());
+            Collections.emptyList());
 
     // Create projection expressions, combining the projection expressions
     // from the projects that feed into the join.  For the RHS projection

File: core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java
Patch:
@@ -34,7 +34,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 
 import java.util.ArrayList;
 import java.util.BitSet;
@@ -462,8 +461,8 @@ private ImmutableBitSet fieldBitmap(RexNode joinFilter) {
    * references
    */
   private void setJoinFilterRefs() {
-    fieldsRefByJoinFilter = Maps.newHashMap();
-    factorsRefByJoinFilter = Maps.newHashMap();
+    fieldsRefByJoinFilter = new HashMap<>();
+    factorsRefByJoinFilter = new HashMap<>();
     ListIterator<RexNode> filterIter = allJoinFilters.listIterator();
     while (filterIter.hasNext()) {
       RexNode joinFilter = filterIter.next();

File: core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
Patch:
@@ -74,7 +74,7 @@ protected void apply(RelOptRuleCall call, Filter filter, TableScan scan) {
     List<RelOptMaterialization> materializations =
         (planner instanceof VolcanoPlanner)
             ? ((VolcanoPlanner) planner).getMaterializations()
-            : ImmutableList.<RelOptMaterialization>of();
+            : ImmutableList.of();
     if (!materializations.isEmpty()) {
       RelNode root = filter.copy(filter.getTraitSet(),
           Collections.singletonList((RelNode) scan));

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectCorrelateTransposeRule.java
Patch:
@@ -46,8 +46,7 @@
 public class ProjectCorrelateTransposeRule  extends RelOptRule {
 
   public static final ProjectCorrelateTransposeRule INSTANCE =
-      new ProjectCorrelateTransposeRule(
-          PushProjector.ExprCondition.TRUE,
+      new ProjectCorrelateTransposeRule(expr -> true,
           RelFactories.LOGICAL_BUILDER);
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectFilterTransposeRule.java
Patch:
@@ -34,9 +34,9 @@
  * past a {@link org.apache.calcite.rel.core.Filter}.
  */
 public class ProjectFilterTransposeRule extends RelOptRule {
-  public static final ProjectFilterTransposeRule INSTANCE = new ProjectFilterTransposeRule(
-      LogicalProject.class, LogicalFilter.class, RelFactories.LOGICAL_BUILDER,
-      PushProjector.ExprCondition.FALSE);
+  public static final ProjectFilterTransposeRule INSTANCE =
+      new ProjectFilterTransposeRule(LogicalProject.class, LogicalFilter.class,
+          RelFactories.LOGICAL_BUILDER, expr -> false);
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinTransposeRule.java
Patch:
@@ -38,8 +38,7 @@
  */
 public class ProjectJoinTransposeRule extends RelOptRule {
   public static final ProjectJoinTransposeRule INSTANCE =
-      new ProjectJoinTransposeRule(
-          PushProjector.ExprCondition.TRUE,
+      new ProjectJoinTransposeRule(expr -> true,
           RelFactories.LOGICAL_BUILDER);
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectSetOpTransposeRule.java
Patch:
@@ -40,8 +40,8 @@
  */
 public class ProjectSetOpTransposeRule extends RelOptRule {
   public static final ProjectSetOpTransposeRule INSTANCE =
-      new ProjectSetOpTransposeRule(
-          PushProjector.ExprCondition.FALSE, RelFactories.LOGICAL_BUILDER);
+      new ProjectSetOpTransposeRule(expr -> false,
+          RelFactories.LOGICAL_BUILDER);
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/rel/rules/SortJoinTransposeRule.java
Patch:
@@ -34,7 +34,6 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.tools.RelBuilderFactory;
 
-
 /**
  * Planner rule that pushes a {@link org.apache.calcite.rel.core.Sort} past a
  * {@link org.apache.calcite.rel.core.Join}.

File: core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java
Patch:
@@ -140,7 +140,7 @@ public void onMatch(RelOptRuleCall call) {
     RelNode newProject =
         project.copy(
             sort.getTraitSet(),
-            ImmutableList.<RelNode>of(newSort));
+            ImmutableList.of(newSort));
     // Not only is newProject equivalent to sort;
     // newSort is equivalent to project's input
     // (but only if the sort is not also applying an offset/limit).

File: core/src/main/java/org/apache/calcite/rel/rules/UnionPullUpConstantsRule.java
Patch:
@@ -118,7 +118,7 @@ public UnionPullUpConstantsRule(Class<? extends Union> unionClass,
       List<Pair<RexNode, String>> newChildExprs = new ArrayList<>();
       for (int j : refsIndex) {
         newChildExprs.add(
-            Pair.<RexNode, String>of(rexBuilder.makeInputRef(input, j),
+            Pair.of(rexBuilder.makeInputRef(input, j),
                 input.getRowType().getFieldList().get(j).getName()));
       }
       if (newChildExprs.isEmpty()) {

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -75,7 +75,7 @@ public abstract class ValuesReduceRule extends RelOptRule {
   public static final ValuesReduceRule FILTER_INSTANCE =
       new ValuesReduceRule(
           operand(LogicalFilter.class,
-              operand(LogicalValues.class, null, Values.IS_NOT_EMPTY, none())),
+              operandJ(LogicalValues.class, null, Values::isNotEmpty, none())),
           RelFactories.LOGICAL_BUILDER,
           "ValuesReduceRule(Filter)") {
         public void onMatch(RelOptRuleCall call) {
@@ -92,7 +92,7 @@ public void onMatch(RelOptRuleCall call) {
   public static final ValuesReduceRule PROJECT_INSTANCE =
       new ValuesReduceRule(
           operand(LogicalProject.class,
-              operand(LogicalValues.class, null, Values.IS_NOT_EMPTY, none())),
+              operandJ(LogicalValues.class, null, Values::isNotEmpty, none())),
           RelFactories.LOGICAL_BUILDER,
           "ValuesReduceRule(Project)") {
         public void onMatch(RelOptRuleCall call) {
@@ -110,7 +110,7 @@ public void onMatch(RelOptRuleCall call) {
       new ValuesReduceRule(
           operand(LogicalProject.class,
               operand(LogicalFilter.class,
-                  operand(LogicalValues.class, null, Values.IS_NOT_EMPTY,
+                  operandJ(LogicalValues.class, null, Values::isNotEmpty,
                       none()))),
           RelFactories.LOGICAL_BUILDER,
           "ValuesReduceRule(Project-Filter)") {

File: core/src/main/java/org/apache/calcite/rel/type/DynamicRecordTypeImpl.java
Patch:
@@ -20,7 +20,8 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.Pair;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -69,7 +70,7 @@ public DynamicRecordTypeImpl(RelDataTypeFactory typeFactory) {
   }
 
   @Override public RelDataTypePrecedenceList getPrecedenceList() {
-    return new SqlTypeExplicitPrecedenceList(Collections.<SqlTypeName>emptyList());
+    return new SqlTypeExplicitPrecedenceList(ImmutableList.of());
   }
 
   protected void generateTypeString(StringBuilder sb, boolean withDetail) {

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
Patch:
@@ -23,12 +23,11 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 
-import com.google.common.base.Preconditions;
-
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 
 /**
  * RelDataTypeFactory is a factory for datatype descriptors. It defines methods
@@ -408,7 +407,7 @@ class Builder {
      * Creates a Builder with the given type factory.
      */
     public Builder(RelDataTypeFactory typeFactory) {
-      this.typeFactory = Preconditions.checkNotNull(typeFactory);
+      this.typeFactory = Objects.requireNonNull(typeFactory);
     }
 
     /**

File: core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
Patch:
@@ -19,10 +19,9 @@
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.sql.type.SqlTypeName;
 
-import com.google.common.base.Preconditions;
-
 import java.io.Serializable;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * RelRecordType represents a structured type having named fields.
@@ -39,7 +38,7 @@ public class RelRecordType extends RelDataTypeImpl implements Serializable {
    */
   public RelRecordType(StructKind kind, List<RelDataTypeField> fields) {
     super(fields);
-    this.kind = Preconditions.checkNotNull(kind);
+    this.kind = Objects.requireNonNull(kind);
     computeDigest();
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexCall.java
Patch:
@@ -22,10 +22,10 @@
 import org.apache.calcite.sql.SqlSyntax;
 import org.apache.calcite.util.Litmus;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
+import java.util.Objects;
 
 /**
  * An expression formed by a call to an operator with zero or more expressions
@@ -56,8 +56,8 @@ protected RexCall(
       RelDataType type,
       SqlOperator op,
       List<? extends RexNode> operands) {
-    this.type = Preconditions.checkNotNull(type);
-    this.op = Preconditions.checkNotNull(op);
+    this.type = Objects.requireNonNull(type);
+    this.op = Objects.requireNonNull(op);
     this.operands = ImmutableList.copyOf(operands);
     assert op.getKind() != null : op;
     assert op.validRexOperands(operands.size(), Litmus.THROW) : this;

File: core/src/main/java/org/apache/calcite/rex/RexCorrelVariable.java
Patch:
@@ -20,7 +20,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.sql.SqlKind;
 
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 
 /**
  * Reference to the current row of a correlating relational expression.
@@ -38,7 +38,7 @@ public class RexCorrelVariable extends RexVariable {
       CorrelationId id,
       RelDataType type) {
     super(id.getName(), type);
-    this.id = Preconditions.checkNotNull(id);
+    this.id = Objects.requireNonNull(id);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -211,8 +211,8 @@ public class RexLiteral extends RexNode {
       RelDataType type,
       SqlTypeName typeName) {
     this.value = value;
-    this.type = Preconditions.checkNotNull(type);
-    this.typeName = Preconditions.checkNotNull(typeName);
+    this.type = Objects.requireNonNull(type);
+    this.typeName = Objects.requireNonNull(typeName);
     Preconditions.checkArgument(valueMatchesType(value, typeName, true));
     Preconditions.checkArgument((value == null) == type.isNullable());
     Preconditions.checkArgument(typeName != SqlTypeName.ANY);

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -25,6 +25,7 @@
 import com.google.common.base.Preconditions;
 
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Call to an aggregate function over a window.
@@ -66,7 +67,7 @@ public class RexOver extends RexCall {
       boolean distinct) {
     super(type, op, operands);
     Preconditions.checkArgument(op.isAggregator());
-    this.window = Preconditions.checkNotNull(window);
+    this.window = Objects.requireNonNull(window);
     this.distinct = distinct;
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexPermuteInputsShuttle.java
Patch:
@@ -66,7 +66,7 @@ private RexPermuteInputsShuttle(
    * otherwise works OK. */
   public static RexPermuteInputsShuttle of(Mappings.TargetMapping mapping) {
     return new RexPermuteInputsShuttle(mapping,
-        ImmutableList.<RelDataTypeField>of());
+        ImmutableList.of());
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rex/RexProgram.java
Patch:
@@ -34,7 +34,6 @@
 import org.apache.calcite.util.Permutation;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 
 import java.io.PrintWriter;
@@ -514,7 +513,7 @@ public RexNode expandLocalRef(RexLocalRef ref) {
    * <p>Neither list is null.
    * The filters are evaluated first. */
   public Pair<ImmutableList<RexNode>, ImmutableList<RexNode>> split() {
-    final List<RexNode> filters = Lists.newArrayList();
+    final List<RexNode> filters = new ArrayList<>();
     if (condition != null) {
       RelOptUtil.decomposeConjunction(expandLocalRef(condition), filters);
     }
@@ -574,7 +573,7 @@ public static void deduceCollations(
       // to the output.
       outputCollations.add(RelCollations.of(fieldCollations));
     }
-    Collections.sort(outputCollations, Ordering.natural());
+    outputCollations.sort(Ordering.natural());
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rex/RexSubQuery.java
Patch:
@@ -86,7 +86,7 @@ public static RexSubQuery exists(RelNode rel) {
     final RelDataTypeFactory typeFactory = rel.getCluster().getTypeFactory();
     final RelDataType type = typeFactory.createSqlType(SqlTypeName.BOOLEAN);
     return new RexSubQuery(type, SqlStdOperatorTable.EXISTS,
-        ImmutableList.<RexNode>of(), rel);
+        ImmutableList.of(), rel);
   }
 
   /** Creates a scalar sub-query. */
@@ -97,7 +97,7 @@ public static RexSubQuery scalar(RelNode rel) {
     final RelDataType type =
         typeFactory.createTypeWithNullability(fieldList.get(0).getType(), true);
     return new RexSubQuery(type, SqlStdOperatorTable.SCALAR_QUERY,
-        ImmutableList.<RexNode>of(), rel);
+        ImmutableList.of(), rel);
   }
 
   public <R> R accept(RexVisitor<R> visitor) {

File: core/src/main/java/org/apache/calcite/runtime/PredicateImpl.java
Patch:
@@ -30,6 +30,9 @@
  * but still works on JDK 1.7.
  *
  * @param <T> the type of the input to the predicate
+ *
+ * @deprecated Now Calcite is Java 8 and higher, we recommend that you
+ * implement {@link java.util.function.Predicate} directly.
  */
 public abstract class PredicateImpl<T> implements Predicate<T> {
   public final boolean apply(@Nullable T input) {

File: core/src/main/java/org/apache/calcite/schema/Table.java
Patch:
@@ -77,9 +77,9 @@ public interface Table {
    * @param parent Parent node of {@code call} in the {@link SqlNode} tree
    * @param config Config settings. May be null
    * @return true iff the given aggregate call is valid
-   * */
-  boolean rolledUpColumnValidInsideAgg(String column, SqlCall call, SqlNode parent,
-                                       CalciteConnectionConfig config);
+   */
+  boolean rolledUpColumnValidInsideAgg(String column, SqlCall call,
+      SqlNode parent, CalciteConnectionConfig config);
 }
 
 // End Table.java

File: core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java
Patch:
@@ -25,12 +25,12 @@
 import org.apache.calcite.schema.ImplementableAggFunction;
 import org.apache.calcite.util.ReflectUtil;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.List;
+import java.util.Objects;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -70,8 +70,8 @@ private AggregateFunctionImpl(Class<?> declaringClass,
     this.parameters = params;
     this.accumulatorType = accumulatorType;
     this.resultType = resultType;
-    this.initMethod = Preconditions.checkNotNull(initMethod);
-    this.addMethod = Preconditions.checkNotNull(addMethod);
+    this.initMethod = Objects.requireNonNull(initMethod);
+    this.addMethod = Objects.requireNonNull(addMethod);
     this.mergeMethod = mergeMethod;
     this.resultMethod = resultMethod;
     this.isStatic = Modifier.isStatic(initMethod.getModifiers());

File: core/src/main/java/org/apache/calcite/schema/impl/MaterializedViewTable.java
Patch:
@@ -30,12 +30,11 @@
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.schema.TranslatableTable;
 
-import com.google.common.base.Preconditions;
-
 import java.lang.reflect.Type;
 import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Table that is a materialized view.
@@ -107,7 +106,7 @@ private MaterializedViewTableMacro(CalciteSchema schema, String viewSql,
       super(schema, viewSql,
           viewSchemaPath != null ? viewSchemaPath : schema.path(null), viewPath,
           Boolean.TRUE);
-      this.key = Preconditions.checkNotNull(
+      this.key = Objects.requireNonNull(
           MaterializationService.instance().defineMaterialization(
               schema, null, viewSql, schemaPath, suggestedTableName, true,
               existing));

File: core/src/main/java/org/apache/calcite/schema/impl/ModifiableViewTable.java
Patch:
@@ -39,10 +39,10 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -186,7 +186,7 @@ private class ModifiableViewTableInitializerExpressionFactory
 
     private ModifiableViewTableInitializerExpressionFactory() {
       super();
-      final Map<Integer, RexNode> projectMap = Maps.newHashMap();
+      final Map<Integer, RexNode> projectMap = new HashMap<>();
       final List<RexNode> filters = new ArrayList<>();
       RelOptUtil.inferViewPredicates(projectMap, filters, constraint);
       assert filters.isEmpty();

File: core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
Patch:
@@ -34,11 +34,11 @@
 import org.apache.calcite.util.ImmutableIntList;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * Virtual table that is composed of two or more tables joined together.
@@ -63,7 +63,7 @@ public class StarTable extends AbstractTable implements TranslatableTable {
 
   /** Creates a StarTable. */
   private StarTable(Lattice lattice, ImmutableList<Table> tables) {
-    this.lattice = Preconditions.checkNotNull(lattice);
+    this.lattice = Objects.requireNonNull(lattice);
     this.tables = tables;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -84,7 +84,7 @@ public int operandCount() {
   @Override public SqlNode clone(SqlParserPos pos) {
     final List<SqlNode> operandList = getOperandList();
     return getOperator().createCall(getFunctionQuantifier(), pos,
-        operandList.toArray(new SqlNode[operandList.size()]));
+        operandList.toArray(new SqlNode[0]));
   }
 
   public void unparse(

File: core/src/main/java/org/apache/calcite/sql/SqlDdl.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.sql.parser.SqlParserPos;
 
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 
 /** Base class for CREATE, DROP and other DDL statements. */
 public abstract class SqlDdl extends SqlCall {
@@ -31,7 +31,7 @@ public abstract class SqlDdl extends SqlCall {
   /** Creates a SqlDdl. */
   public SqlDdl(SqlOperator operator, SqlParserPos pos) {
     super(pos);
-    this.operator = Preconditions.checkNotNull(operator);
+    this.operator = Objects.requireNonNull(operator);
   }
 
   public SqlOperator getOperator() {

File: core/src/main/java/org/apache/calcite/sql/SqlDescribeSchema.java
Patch:
@@ -64,7 +64,7 @@ public SqlDescribeSchema(SqlParserPos pos, SqlIdentifier schema) {
   }
 
   @Override public List<SqlNode> getOperandList() {
-    return ImmutableNullableList.<SqlNode>of(schema);
+    return ImmutableNullableList.of(schema);
   }
 
   public SqlIdentifier getSchema() {

File: core/src/main/java/org/apache/calcite/sql/SqlDescribeTable.java
Patch:
@@ -75,7 +75,7 @@ public SqlDescribeTable(SqlParserPos pos,
   }
 
   @Override public List<SqlNode> getOperandList() {
-    return ImmutableNullableList.<SqlNode>of(table, column);
+    return ImmutableNullableList.of(table, column);
   }
 
   public SqlIdentifier getTable() {

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -29,9 +29,8 @@
 import org.apache.calcite.util.Litmus;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import java.math.BigDecimal;
+import java.util.Objects;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -109,7 +108,7 @@ public SqlIntervalQualifier(
       endUnit = null;
     }
     this.timeUnitRange =
-        TimeUnitRange.of(Preconditions.checkNotNull(startUnit), endUnit);
+        TimeUnitRange.of(Objects.requireNonNull(startUnit), endUnit);
     this.startPrecision = startPrecision;
     this.fractionalSecondPrecision = fractionalSecondPrecision;
   }

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
Patch:
@@ -25,10 +25,10 @@
 import org.apache.calcite.sql.validate.SqlValidatorImpl;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
 
 import java.util.Map;
+import java.util.Objects;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -601,7 +601,7 @@ private static class PermutingMakeCall extends SimpleMakeCall {
      */
     PermutingMakeCall(SqlOperator operator, int[] order) {
       super(operator);
-      this.order = Preconditions.checkNotNull(order);
+      this.order = Objects.requireNonNull(order);
     }
 
     @Override public SqlCall createCall(SqlParserPos pos,

File: core/src/main/java/org/apache/calcite/sql/SqlNode.java
Patch:
@@ -28,10 +28,9 @@
 import org.apache.calcite.util.Litmus;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import java.util.Collection;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 
 /**
@@ -58,7 +57,7 @@ public abstract class SqlNode implements Cloneable {
    * @param pos Parser position, must not be null.
    */
   SqlNode(SqlParserPos pos) {
-    this.pos = Preconditions.checkNotNull(pos);
+    this.pos = Objects.requireNonNull(pos);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlNodeList.java
Patch:
@@ -172,7 +172,7 @@ public boolean equalsDeep(SqlNode node, Litmus litmus) {
   }
 
   public SqlNode[] toArray() {
-    return list.toArray(new SqlNode[list.size()]);
+    return list.toArray(new SqlNode[0]);
   }
 
   public static boolean isEmptyList(final SqlNode node) {

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -296,7 +296,7 @@ public final SqlCall createCall(
     return createCall(
         null,
         pos,
-        operandList.toArray(new SqlNode[operandList.size()]));
+        operandList.toArray(new SqlNode[0]));
   }
 
   /**

File: core/src/main/java/org/apache/calcite/sql/SqlSetOption.java
Patch:
@@ -21,8 +21,7 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.ImmutableNullableList;
 
-import com.google.common.collect.Lists;
-
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -107,7 +106,7 @@ public SqlSetOption(SqlParserPos pos, String scope, SqlIdentifier name,
   }
 
   @Override public List<SqlNode> getOperandList() {
-    final List<SqlNode> operandList = Lists.newArrayList();
+    final List<SqlNode> operandList = new ArrayList<>();
     if (scope == null) {
       operandList.add(null);
     } else {

File: core/src/main/java/org/apache/calcite/sql/SqlSpecialOperator.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.util.PrecedenceClimbingParser;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Predicate;
+import java.util.function.Predicate;
 
 /**
  * Generic operator for nodes with special syntax.

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorHint.java
Patch:
@@ -43,7 +43,7 @@ public SqlAdvisorHint(SqlMoniker id) {
     final List<String> names = id.getFullyQualifiedNames();
     this.names = names == null
       ? null
-      : names.toArray(new String[names.size()]);
+      : names.toArray(new String[0]);
     type = id.getType().name();
   }
 }

File: core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
Patch:
@@ -33,8 +33,6 @@
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.type.ReturnTypes;
 
-
-
 /**
  * A <code>SqlDialect</code> implementation for the Microsoft SQL Server
  * database.

File: core/src/main/java/org/apache/calcite/sql/fun/SqlDatetimeSubtractionOperator.java
Patch:
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.sql.fun;
 
-
-
 import org.apache.calcite.sql.SqlCall;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlOperatorBinding;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlQuantifyOperator.java
Patch:
@@ -20,6 +20,8 @@
 
 import com.google.common.base.Preconditions;
 
+import java.util.Objects;
+
 /**
  * Definition of the SQL <code>ALL</code> and <code>SOME</code>operators.
  *
@@ -47,7 +49,7 @@ public class SqlQuantifyOperator extends SqlInOperator {
    */
   SqlQuantifyOperator(SqlKind kind, SqlKind comparisonKind) {
     super(comparisonKind.sql + " " + kind, kind);
-    this.comparisonKind = Preconditions.checkNotNull(comparisonKind);
+    this.comparisonKind = Objects.requireNonNull(comparisonKind);
     Preconditions.checkArgument(comparisonKind == SqlKind.EQUALS
         || comparisonKind == SqlKind.NOT_EQUALS
         || comparisonKind == SqlKind.LESS_THAN_OR_EQUAL

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -2242,7 +2242,7 @@ public static List<Pair<SqlNode, AuxiliaryConverter>> convertGroupToAuxiliaryCal
       for (final SqlGroupedWindowFunction f
           : ((SqlGroupedWindowFunction) op).getAuxiliaryFunctions()) {
         builder.add(
-            Pair.<SqlNode, AuxiliaryConverter>of(copy(call, f),
+            Pair.of(copy(call, f),
                 new AuxiliaryConverter.Impl(f)));
       }
       return builder.build();
@@ -2253,7 +2253,7 @@ public static List<Pair<SqlNode, AuxiliaryConverter>> convertGroupToAuxiliaryCal
   /** Creates a copy of a call with a new operator. */
   private static SqlCall copy(SqlCall call, SqlOperator operator) {
     final List<SqlNode> list = call.getOperandList();
-    return new SqlBasicCall(operator, list.toArray(new SqlNode[list.size()]),
+    return new SqlBasicCall(operator, list.toArray(new SqlNode[0]),
         call.getParserPosition());
   }
 

File: core/src/main/java/org/apache/calcite/sql/parser/SqlAbstractParserImpl.java
Patch:
@@ -32,12 +32,12 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
 
 import java.io.Reader;
 import java.io.StringReader;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -391,7 +391,7 @@ protected SqlCall createCall(
     // preserve the correct syntax (i.e. don't quote builtin function
     /// name when regenerating SQL).
     if (funName.isSimple()) {
-      final List<SqlOperator> list = Lists.newArrayList();
+      final List<SqlOperator> list = new ArrayList<>();
       opTab.lookupOperatorOverloads(funName, funcType, SqlSyntax.FUNCTION, list);
       if (list.size() == 1) {
         fun = list.get(0);

File: core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -1142,7 +1142,7 @@ public String[] getPropertyNames() {
       final Set<String> names = new HashSet<>();
       names.addAll(getterMethods.keySet());
       names.addAll(setterMethods.keySet());
-      return names.toArray(new String[names.size()]);
+      return names.toArray(new String[0]);
     }
   }
 }

File: core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
Patch:
@@ -20,7 +20,7 @@
 import org.apache.calcite.rel.type.RelDataTypeFamily;
 import org.apache.calcite.rel.type.RelDataTypePrecedenceList;
 
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 
 /**
  * SQL array type.
@@ -38,7 +38,7 @@ public class ArraySqlType extends AbstractSqlType {
    */
   public ArraySqlType(RelDataType elementType, boolean isNullable) {
     super(SqlTypeName.ARRAY, isNullable, null);
-    this.elementType = Preconditions.checkNotNull(elementType);
+    this.elementType = Objects.requireNonNull(elementType);
     computeDigest();
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/ComparableOperandTypeChecker.java
Patch:
@@ -21,7 +21,7 @@
 import org.apache.calcite.sql.SqlCallBinding;
 import org.apache.calcite.sql.SqlOperatorBinding;
 
-import com.google.common.base.Preconditions;
+import java.util.Objects;
 
 /**
  * Type checking strategy which verifies that types have the required attributes
@@ -45,7 +45,7 @@ public ComparableOperandTypeChecker(int nOperands,
       RelDataTypeComparability requiredComparability, Consistency consistency) {
     super(nOperands);
     this.requiredComparability = requiredComparability;
-    this.consistency = Preconditions.checkNotNull(consistency);
+    this.consistency = Objects.requireNonNull(consistency);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
Patch:
@@ -22,11 +22,11 @@
 import org.apache.calcite.sql.SqlOperator;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.AbstractList;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nullable;
 
 /**
@@ -93,8 +93,8 @@ public enum Composition {
       ImmutableList<? extends SqlOperandTypeChecker> allowedRules,
       @Nullable String allowedSignatures,
       @Nullable SqlOperandCountRange range) {
-    this.allowedRules = Preconditions.checkNotNull(allowedRules);
-    this.composition = Preconditions.checkNotNull(composition);
+    this.allowedRules = Objects.requireNonNull(allowedRules);
+    this.composition = Objects.requireNonNull(composition);
     this.allowedSignatures = allowedSignatures;
     this.range = range;
     assert (range != null) == (composition == Composition.REPEAT);

File: core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
Patch:
@@ -24,10 +24,10 @@
 import org.apache.calcite.sql.SqlOperator;
 import org.apache.calcite.sql.SqlUtil;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
+import java.util.function.Predicate;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -55,7 +55,7 @@ public class FamilyOperandTypeChecker implements SqlSingleOperandTypeChecker {
   //~ Methods ----------------------------------------------------------------
 
   public boolean isOptional(int i) {
-    return optional.apply(i);
+    return optional.test(i);
   }
 
   public boolean checkSingleOperandType(
@@ -120,7 +120,7 @@ public boolean checkOperandTypes(
   public SqlOperandCountRange getOperandCountRange() {
     final int max = families.size();
     int min = max;
-    while (min > 0 && optional.apply(min - 1)) {
+    while (min > 0 && optional.test(min - 1)) {
       --min;
     }
     return SqlOperandCountRanges.between(min, max);

File: core/src/main/java/org/apache/calcite/sql/util/SqlShuttle.java
Patch:
@@ -108,7 +108,7 @@ public CallCopyingArgHandler(SqlCall call, boolean alwaysCopy) {
       this.call = call;
       this.update = false;
       final List<SqlNode> operands = call.getOperandList();
-      this.clonedOperands = operands.toArray(new SqlNode[operands.size()]);
+      this.clonedOperands = operands.toArray(new SqlNode[0]);
       this.alwaysCopy = alwaysCopy;
     }
 

File: core/src/main/java/org/apache/calcite/sql/validate/AggChecker.java
Patch:
@@ -209,7 +209,7 @@ public Void visit(SqlCall call) {
 
     // Visit the operands (only expressions).
     call.getOperator()
-        .acceptCall(this, call, true, ArgHandlerImpl.<Void>instance());
+        .acceptCall(this, call, true, ArgHandlerImpl.instance());
 
     // Restore scope.
     scopes.pop();

File: core/src/main/java/org/apache/calcite/sql/validate/AggVisitor.java
Patch:
@@ -25,8 +25,7 @@
 import org.apache.calcite.sql.fun.SqlAbstractGroupFunction;
 import org.apache.calcite.sql.util.SqlBasicVisitor;
 
-import com.google.common.collect.Lists;
-
+import java.util.ArrayList;
 import java.util.List;
 
 /** Visitor that can find aggregate and windowed aggregate functions.
@@ -82,7 +81,7 @@ public Void visit(SqlCall call) {
     if (operator instanceof SqlFunction) {
       final SqlFunction sqlFunction = (SqlFunction) operator;
       if (sqlFunction.getFunctionType().isUserDefinedNotSpecificFunction()) {
-        final List<SqlOperator> list = Lists.newArrayList();
+        final List<SqlOperator> list = new ArrayList<>();
         opTab.lookupOperatorOverloads(sqlFunction.getSqlIdentifier(),
             sqlFunction.getFunctionType(), SqlSyntax.FUNCTION, list);
         for (SqlOperator operator2 : list) {

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
Patch:
@@ -462,7 +462,7 @@ private int worstKind(Path path) {
                 return kind;
               }
             };
-        Collections.sort(resolved.resolves, c);
+        resolved.resolves.sort(c);
         if (c.compare(resolved.resolves.get(0), resolved.resolves.get(1)) == 0) {
           throw validator.newValidationError(suffix,
               RESOURCE.columnAmbiguous(suffix.toString()));

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -25,12 +25,12 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nullable;
 
 import static org.apache.calcite.util.Static.RESOURCE;
@@ -74,7 +74,7 @@ public class IdentifierNamespace extends AbstractNamespace {
     super(validator, enclosingNode);
     this.id = id;
     this.extendList = extendList;
-    this.parentScope = Preconditions.checkNotNull(parentScope);
+    this.parentScope = Objects.requireNonNull(parentScope);
   }
 
   IdentifierNamespace(SqlValidatorImpl validator, SqlNode node,
@@ -174,7 +174,7 @@ private SqlValidatorNamespace resolveImpl(SqlIdentifier id) {
   }
 
   public RelDataType validateImpl(RelDataType targetRowType) {
-    resolvedNamespace = Preconditions.checkNotNull(resolveImpl(id));
+    resolvedNamespace = Objects.requireNonNull(resolveImpl(id));
     if (resolvedNamespace instanceof TableNamespace) {
       SqlValidatorTable table = resolvedNamespace.getTable();
       if (validator.shouldExpandIdentifiers()) {

File: core/src/main/java/org/apache/calcite/sql/validate/SchemaNamespace.java
Patch:
@@ -21,10 +21,10 @@
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
+import java.util.Objects;
 
 /** Namespace based on a schema.
  *
@@ -37,7 +37,7 @@ class SchemaNamespace extends AbstractNamespace {
   /** Creates a SchemaNamespace. */
   SchemaNamespace(SqlValidatorImpl validator, ImmutableList<String> names) {
     super(validator, null);
-    this.names = Preconditions.checkNotNull(names);
+    this.names = Objects.requireNonNull(names);
   }
 
   protected RelDataType validateImpl(RelDataType targetRowType) {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java
Patch:
@@ -18,9 +18,8 @@
 
 import org.apache.calcite.sql.SqlIdentifier;
 
-import com.google.common.base.Preconditions;
-
 import java.util.List;
+import java.util.Objects;
 
 /**
  * An implementation of {@link SqlMoniker} that encapsulates the normalized name
@@ -37,7 +36,7 @@ public class SqlIdentifierMoniker implements SqlMoniker {
    * Creates an SqlIdentifierMoniker.
    */
   public SqlIdentifierMoniker(SqlIdentifier id) {
-    this.id = Preconditions.checkNotNull(id);
+    this.id = Objects.requireNonNull(id);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -1956,7 +1956,7 @@ protected void convertFrom(
       call = (SqlCall) from;
       convertFrom(bb, call.operand(0));
       if (call.operandCount() > 2
-          && bb.root instanceof Values) {
+          && (bb.root instanceof Values || bb.root instanceof Uncollect)) {
         final List<String> fieldNames = new ArrayList<>();
         for (SqlNode node : Util.skip(call.getOperandList(), 2)) {
           fieldNames.add(((SqlIdentifier) node).getSimple());

File: core/src/test/java/org/apache/calcite/util/UtilTest.java
Patch:
@@ -843,6 +843,7 @@ private List<Integer> makeConsList(int start, int end) {
         Locale.getDefault(),
         Locale.US,
         Locale.TRADITIONAL_CHINESE,
+        Locale.ROOT,
     };
     for (Locale locale : locales) {
       assertEquals(locale, Util.parseLocale(locale.toString()));

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java
Patch:
@@ -71,8 +71,8 @@
  *   <li>push HAVING into "groupBy" query</li>
  * </ul>
  *
- * These tests use "timestamp with local time zone" type for the
- * Druid timestamp column, instead of "timestamp" type  as
+ * <p>These tests use TIMESTAMP WITH LOCAL TIME ZONE type for the
+ * Druid timestamp column, instead of TIMESTAMP type as
  * {@link DruidAdapterIT2}.
  */
 public class DruidAdapterIT {

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT2.java
Patch:
@@ -71,8 +71,8 @@
  *   <li>push HAVING into "groupBy" query</li>
  * </ul>
  *
- * These tests use "timestamp" type for the Druid timestamp column, instead
- * of "timestamp with local time zone" type as {@link DruidAdapterIT}.
+ * <p>These tests use TIMESTAMP type for the Druid timestamp column, instead
+ * of TIMESTAMP WITH LOCAL TIME ZONE type as {@link DruidAdapterIT}.
  */
 public class DruidAdapterIT2 {
   /** URL of the "druid-foodmart" model. */

File: elasticsearch2/src/main/java/org/apache/calcite/adapter/elasticsearch2/Elasticsearch2Enumerator.java
Patch:
@@ -115,7 +115,7 @@ public Object[] apply(SearchHit hit) {
             objects[i] = convert(hit.field(name).getValue(), field.getValue());
           } else {
             throw new IllegalStateException(
-                    String.format(Locale.getDefault(), "No result for %s", field));
+                String.format(Locale.ROOT, "No result for %s", field));
           }
         }
         return objects;

File: elasticsearch5/src/test/java/org/apache/calcite/adapter/elasticsearch5/EmbeddedElasticsearchNode.java
Patch:
@@ -118,7 +118,7 @@ TransportAddress httpAddress() {
   }
 
   /**
-   * Exposes elastic
+   * Exposes an Elasticsearch
    * <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html">transport client</a>
    * (use of HTTP client is preferred).
    *

File: mongodb/src/test/java/org/apache/calcite/test/MongoAdapterIT.java
Patch:
@@ -25,10 +25,10 @@
 /**
  * Used to trigger integration tests from maven (thus class name is suffixed with {@code IT}).
  *
- * If you want to run integration tests from IDE manually set
+ * <p>If you want to run integration tests from the, IDE manually set the
  * {@code -Dcalcite.integrationTest=true} system property.
- * <br>
- * For command line use:
+ *
+ * <p>For command line use:
  * <pre>
  *     $ mvn install -Pit
  * </pre>

File: core/src/test/java/org/apache/calcite/test/QuidemTest.java
Patch:
@@ -72,7 +72,8 @@ protected QuidemTest(String path) {
   private Method findMethod(String path) {
     // E.g. path "sql/agg.iq" gives method "testSqlAgg"
     String methodName =
-        AvaticaUtils.toCamelCase("test_" + path.replace('/', '_').replaceAll("\\.iq$", ""));
+        AvaticaUtils.toCamelCase(
+            "test_" + path.replace(File.separatorChar, '_').replaceAll("\\.iq$", ""));
     Method m;
     try {
       m = getClass().getMethod(methodName);

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -196,9 +196,7 @@ public void onMatch(RelOptRuleCall call) {
             .unwrap(CalciteConnectionConfig.class).timeZone();
         assert timeZone != null;
         intervals = DruidDateTimeUtils.createInterval(
-            RexUtil.composeConjunction(rexBuilder, triple.getLeft(), false),
-
-            query.getConnectionConfig().timeZone());
+            RexUtil.composeConjunction(rexBuilder, triple.getLeft(), false));
         if (intervals == null || intervals.isEmpty()) {
           // Case we have a filter with extract that can not be written as interval push down
           triple.getMiddle().addAll(triple.getLeft());

File: druid/src/test/java/org/apache/calcite/test/DruidDateRangeRulesTest.java
Patch:
@@ -143,7 +143,7 @@ private void checkDateRangeNoSimplify(Fixture f, RexNode e,
       Matcher<String> intervalMatcher) {
     e = DateRangeRules.replaceTimeUnits(f.rexBuilder, e, "UTC");
     final List<Interval> intervals =
-        DruidDateTimeUtils.createInterval(e, "UTC");
+        DruidDateTimeUtils.createInterval(e);
     assertThat(intervals, notNullValue());
     assertThat(intervals.toString(), intervalMatcher);
   }
@@ -152,7 +152,7 @@ private void checkDateRange(Fixture f, RexNode e, Matcher<String> intervalMatche
     e = DateRangeRules.replaceTimeUnits(f.rexBuilder, e, "UTC");
     final RexNode e2 = f.simplify.simplify(e);
     List<Interval> intervals =
-        DruidDateTimeUtils.createInterval(e2, "UTC");
+        DruidDateTimeUtils.createInterval(e2);
     if (intervals == null) {
       throw new AssertionError("null interval");
     }

File: mongodb/src/test/java/org/apache/calcite/test/MongoAdapterIT.java
Patch:
@@ -25,14 +25,13 @@
 /**
  * Used to trigger integration tests from maven (thus class name is suffixed with {@code IT}).
  *
- * <p>If you want to run integration tests from IDE manually set
+ * If you want to run integration tests from IDE manually set
  * {@code -Dcalcite.integrationTest=true} system property.
- *
+ * <br>
  * For command line use:
  * <pre>
  *     $ mvn install -Pit
  * </pre>
- * </p>
  */
 public class MongoAdapterIT extends MongoAdapterTest {
 

File: core/src/main/java/org/apache/calcite/plan/RelOptSamplingParameters.java
Patch:
@@ -84,7 +84,7 @@ public boolean isRepeatable() {
   }
 
   /**
-   * If {@link #isRepeatable()} returns <tt>true</tt>, this method returns a
+   * If {@link #isRepeatable()} returns <code>true</code>, this method returns a
    * user-specified seed value. Samples of the same, unmodified relation
    * should be identical if the sampling mode, sampling percentage and
    * repeatable seed are the same.

File: core/src/main/java/org/apache/calcite/plan/RelTrait.java
Patch:
@@ -21,7 +21,7 @@
  * a trait definition. For example, a {@code CallingConvention.JAVA} is a trait
  * of the {@link ConventionTraitDef} trait definition.
  *
- * <h3><a name="EqualsHashCodeNote">Note about equals() and hashCode()</a></h3>
+ * <h3><a id="EqualsHashCodeNote">Note about equals() and hashCode()</a></h3>
  *
  * <p>If all instances of RelTrait for a particular RelTraitDef are defined in
  * an {@code enum} and no new RelTraits can be introduced at runtime, you need

File: core/src/main/java/org/apache/calcite/plan/volcano/package-info.java
Patch:
@@ -262,7 +262,7 @@
  * </ol>
  * <h2>References</h2>
  *
- * <p>1. <a name="graefe93" href="http://citeseer.nj.nec.com/graefe93volcano.html">The
+ * <p>1. <a id="graefe93" href="http://citeseer.nj.nec.com/graefe93volcano.html">The
  *     Volcano Optimizer
  *     Generator: Extensibility and Efficient Search - Goetz Graefe, William J.
  *     McKenna

File: core/src/test/java/org/apache/calcite/test/concurrent/package-info.java
Patch:
@@ -247,7 +247,7 @@
  *
  * <p>The output from each thread is stored in a temporary file until
  * the test completes. At that point, the files are merged together
- * into a single <tt>.log</tt> file containing the results of each
+ * into a single <code>.log</code> file containing the results of each
  * thread, in the order the threads were defined. The output for the
  * example script looks like:
  *

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -194,7 +194,6 @@ public final RelDataType createStructType(
         });
   }
 
-  // implement RelDataTypeFactory
   public RelDataType leastRestrictive(List<RelDataType> types) {
     assert types != null;
     assert types.size() >= 1;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
Patch:
@@ -245,9 +245,7 @@ private RelDataType inferTypeFromValidator(
       nullList.add(elseOp);
     }
 
-    RelDataType ret =
-        callBinding.getTypeFactory().leastRestrictive(
-            argTypes);
+    RelDataType ret = callBinding.getTypeFactory().leastRestrictive(argTypes);
     if (null == ret) {
       throw callBinding.newValidationError(RESOURCE.illegalMixingOfTypes());
     }

File: core/src/main/java/org/apache/calcite/schema/Schemas.java
Patch:
@@ -538,7 +538,7 @@ public static Path path(CalciteSchema rootSchema, Iterable<String> names) {
       return PathImpl.EMPTY;
     }
     if (!rootSchema.name.isEmpty()) {
-      assert rootSchema.name.equals(iterator.next());
+      Preconditions.checkState(rootSchema.name.equals(iterator.next()));
     }
     for (;;) {
       final String name = iterator.next();

File: core/src/test/java/org/apache/calcite/util/ImmutableBitSetTest.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.Set;
 import java.util.SortedMap;
 
+import static org.hamcrest.CoreMatchers.anyOf;
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.sameInstance;
@@ -508,7 +509,7 @@ private List<ImmutableBitSet> getSortedList() {
       final ImmutableBitSet x = bitSet.shift(-5);
       fail("Expected error, got " + x);
     } catch (ArrayIndexOutOfBoundsException e) {
-      assertThat(e.getMessage(), is("-1"));
+      assertThat(e.getMessage(), anyOf(is("-1"), is("Index -1 out of bounds for length 0")));
     }
     final ImmutableBitSet empty = ImmutableBitSet.of();
     assertThat(empty.shift(-100), is(empty));

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -463,7 +463,7 @@ private String pad(String x) {
 
   @Test(expected = SQLException.class)
   public void testAvaticaConnectionException() throws Exception {
-    remoteConnection.isValid(0);
+    remoteConnection.isValid(-1);
   }
 
   @Test(expected = SQLException.class)

File: core/src/test/java/org/apache/calcite/test/MaterializationTest.java
Patch:
@@ -122,7 +122,7 @@ public class MaterializationTest {
   private final RexBuilder rexBuilder = new RexBuilder(typeFactory);
   private final RexSimplify simplify =
       new RexSimplify(rexBuilder, RelOptPredicateList.EMPTY, false,
-          RexUtil.EXECUTOR);
+          RexUtil.EXECUTOR).withParanoid(true);
 
   @Test public void testScan() {
     CalciteAssert.that()

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -46,6 +46,7 @@
 import org.apache.calcite.sql.test.SqlPrettyWriterTest;
 import org.apache.calcite.sql.test.SqlTypeNameTest;
 import org.apache.calcite.sql.type.SqlTypeFactoryTest;
+import org.apache.calcite.sql.type.SqlTypeUtilTest;
 import org.apache.calcite.sql.validate.LexCaseSensitiveTest;
 import org.apache.calcite.sql.validate.SqlValidatorUtilTest;
 import org.apache.calcite.test.enumerable.EnumerableCorrelateTest;
@@ -113,6 +114,7 @@
     RelOptPlanReaderTest.class,
     RexBuilderTest.class,
     SqlTypeFactoryTest.class,
+    SqlTypeUtilTest.class,
     SqlValidatorUtilTest.class,
 
     // medium tests (above 0.1s)

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -752,6 +752,9 @@ public Object getValue2() {
    * translator wants it.
    */
   public Object getValue3() {
+    if (value == null) {
+      return null;
+    }
     switch (typeName) {
     case DECIMAL:
       assert value instanceof BigDecimal;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCoalesceFunction.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
+import org.apache.calcite.sql.type.SqlTypeTransforms;
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.util.Util;
 
@@ -44,7 +45,8 @@ public SqlCoalesceFunction() {
     // strategies are used.
     super("COALESCE",
         SqlKind.COALESCE,
-        ReturnTypes.LEAST_RESTRICTIVE,
+        ReturnTypes.cascade(ReturnTypes.LEAST_RESTRICTIVE,
+            SqlTypeTransforms.LEAST_NULLABLE),
         null,
         OperandTypes.SAME_VARIADIC,
         SqlFunctionCategory.SYSTEM);

File: core/src/test/java/org/apache/calcite/profile/ProfilerTest.java
Patch:
@@ -112,7 +112,7 @@ public class ProfilerTest {
 
   @Test public void testProfileScott() throws Exception {
     final String sql = "select * from \"scott\".emp\n"
-        + "join \"scott\".dept using (deptno)";
+        + "join \"scott\".dept on emp.deptno = dept.deptno";
     sql(sql)
         .where(new PredicateImpl<Profiler.Statistic>() {
           public boolean test(Profiler.Statistic statistic) {
@@ -375,7 +375,7 @@ public boolean test(Profiler.Statistic statistic) {
 
   private Fluid scott() throws Exception {
     final String sql = "select * from \"scott\".emp\n"
-        + "join \"scott\".dept using (deptno)";
+        + "join \"scott\".dept on emp.deptno = dept.deptno";
     return sql(sql)
         .where(Fluid.STATISTIC_PREDICATE)
         .sort(Fluid.ORDERING.reverse())

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java
Patch:
@@ -541,8 +541,7 @@ Expression translateCast(
           }
           // If this is a widening cast, no need to pad.
           if (SqlTypeUtil.comparePrecision(sourcePrecision, targetPrecision)
-              >= 0
-              && targetPrecision != RelDataType.PRECISION_NOT_SPECIFIED) {
+              >= 0) {
             pad = false;
           }
           // fall through

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java
Patch:
@@ -82,7 +82,7 @@ public Double getDistinctRowCount(RelNode rel, RelMetadataQuery mq,
 
   public Double getDistinctRowCount(Union rel, RelMetadataQuery mq,
       ImmutableBitSet groupKey, RexNode predicate) {
-    Double rowCount = 0.0;
+    double rowCount = 0.0;
     int[] adjustments = new int[rel.getRowType().getFieldCount()];
     RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
     for (RelNode input : rel.getInputs()) {
@@ -215,10 +215,10 @@ public Double getDistinctRowCount(Values rel, RelMetadataQuery mq,
         return 1D;
       }
     }
-    Double selectivity = RelMdUtil.guessSelectivity(predicate);
+    double selectivity = RelMdUtil.guessSelectivity(predicate);
 
     // assume half the rows are duplicates
-    Double nRows = rel.estimateRowCount(mq) / 2;
+    double nRows = rel.estimateRowCount(mq) / 2;
     return RelMdUtil.numDistinctVals(nRows, nRows * selectivity);
   }
 

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPopulationSize.java
Patch:
@@ -69,7 +69,7 @@ public Double getPopulationSize(Exchange rel, RelMetadataQuery mq,
 
   public Double getPopulationSize(Union rel, RelMetadataQuery mq,
       ImmutableBitSet groupKey) {
-    Double population = 0.0;
+    double population = 0.0;
     for (RelNode input : rel.getInputs()) {
       Double subPop = mq.getPopulationSize(input, groupKey);
       if (subPop == null) {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdSize.java
Patch:
@@ -88,7 +88,7 @@ public Double averageRowSize(RelNode rel, RelMetadataQuery mq) {
     if (averageColumnSizes == null) {
       return null;
     }
-    Double d = 0d;
+    double d = 0d;
     final List<RelDataTypeField> fields = rel.getRowType().getFieldList();
     for (Pair<Double, RelDataTypeField> p
         : Pair.zip(averageColumnSizes, fields)) {
@@ -312,7 +312,7 @@ public Double averageTypeValueSize(RelDataType type) {
       // Even in large (say VARCHAR(2000)) columns most strings are small
       return Math.min((double) type.getPrecision() * BYTES_PER_CHARACTER, 100d);
     case ROW:
-      Double average = 0.0;
+      double average = 0.0;
       for (RelDataTypeField field : type.getFieldList()) {
         average += averageTypeValueSize(field.getType());
       }

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
Patch:
@@ -348,6 +348,8 @@ private void copyOuterJoinInfo(
     if (adjustmentAmount == 0) {
       destJoinSpecs.addAll(srcJoinSpecs);
     } else {
+      assert srcFields != null;
+      assert destFields != null;
       int nFields = srcFields.size();
       int[] adjustments = new int[nFields];
       for (int idx = 0; idx < nFields; idx++) {

File: core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
Patch:
@@ -671,7 +671,7 @@ private double computeScore(
       return 0;
     }
 
-    Double dimRows = dimCost.getRows();
+    double dimRows = dimCost.getRows();
     if (dimRows < 1.0) {
       dimRows = 1.0;
     }

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -801,8 +801,7 @@ public RexNode expand(RexCall call) {
         if (fromScale <= toScale) {
           scaled = ensureScale(value, fromScale, toScale);
         } else {
-          if ((toDigits == fromDigits)
-              && (toScale < fromScale)) {
+          if (toDigits == fromDigits) {
             // rounding away from zero may cause an overflow
             // for example: cast(9.99 as decimal(2,1))
             checkOverflow = true;

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -512,7 +512,7 @@ public static RelDataType deriveJoinRowType(
    *
    * @param typeFactory     Type factory
    * @param leftType        Type of left input to join
-   * @param rightType       Type of right input to join
+   * @param rightType       Type of right input to join, or null for semi-join
    * @param fieldNameList   If not null, overrides the original names of the
    *                        fields
    * @param systemFieldList List of system fields that will be prefixed to

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -4771,7 +4771,6 @@ protected class AggConverter implements SqlVisitor<Void> {
     /** Expressions to be evaluated as rows are being placed into the
      * aggregate's hash table. This is when group functions such as TUMBLE
      * cause rows to be expanded. */
-    private final List<RexNode> midExprs = new ArrayList<>();
 
     private final List<AggregateCall> aggCalls = new ArrayList<>();
     private final Map<SqlNode, RexNode> aggMapping = new HashMap<>();

File: core/src/main/java/org/apache/calcite/util/StackWriter.java
Patch:
@@ -154,7 +154,7 @@ private void pushQuote(Character quoteChar) throws IOException {
 
   private void popQuote(Character quoteChar) throws IOException {
     final Character pop = quoteStack.pop();
-    assert pop == quoteChar;
+    assert pop.equals(quoteChar);
     writeQuote(quoteChar);
   }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
Patch:
@@ -88,8 +88,7 @@ public boolean containsKey(Object key) {
   public boolean containsValue(Object value) {
     @SuppressWarnings("unchecked")
     List<V> list = (List<V>) value;
-    Enumerable<V> enumerable = Linq4j.asEnumerable(list);
-    return map.containsValue(enumerable);
+    return map.containsValue(list);
   }
 
   public Enumerable<V> get(Object key) {

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/Linq4jSuite.java
Patch:
@@ -22,7 +22,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;
 
-
 /**
  * Suite of all Linq4j tests.
  */
@@ -33,6 +32,7 @@
     ExpressionTest.class,
     OptimizerTest.class,
     InlinerTest.class,
+    LookupImplTest.class,
     DeterministicTest.class,
     BlockBuilderTest.class,
     FunctionTest.class,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java
Patch:
@@ -780,6 +780,8 @@ public static Expression translateLiteral(
       final BigDecimal bd = literal.getValueAs(BigDecimal.class);
       if (javaClass == float.class) {
         return Expressions.constant(bd, javaClass);
+      } else if (javaClass == double.class) {
+        return Expressions.constant(bd, javaClass);
       }
       assert javaClass == BigDecimal.class;
       return Expressions.new_(BigDecimal.class,

File: core/src/main/java/org/apache/calcite/model/JsonRoot.java
Patch:
@@ -31,6 +31,7 @@
  * <!-- CHECKSTYLE: OFF -->
  * <pre>{@code Root}
  *   {@link JsonSchema} (in collection {@link JsonRoot#schemas schemas})
+ *     {@link JsonType} (in collection {@link JsonMapSchema#types types})
  *     {@link JsonTable} (in collection {@link JsonMapSchema#tables tables})
  *       {@link JsonColumn} (in collection {@link JsonTable#columns columns})
  *       {@link JsonStream} (in field {@link JsonTable#stream stream})

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -751,6 +751,9 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
 
   @BaseMessage("View ''{0}'' not found")
   ExInst<SqlValidatorException> viewNotFound(String name);
+
+  @BaseMessage("Type ''{0}'' not found")
+  ExInst<SqlValidatorException> typeNotFound(String name);
 }
 
 // End CalciteResource.java

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1545,6 +1545,9 @@ public RelDataType getValidatedNodeTypeIfKnown(SqlNode node) {
     if (original != null && original != node) {
       return getValidatedNodeType(original);
     }
+    if (node instanceof SqlIdentifier) {
+      return getCatalogReader().getNamedType((SqlIdentifier) node);
+    }
     return null;
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -572,6 +572,9 @@ protected RexNode convertCast(
     }
     RexNode arg = cx.convertExpression(left);
     RelDataType type = dataType.deriveType(typeFactory);
+    if (type == null) {
+      type = cx.getValidator().getValidatedNodeType(dataType.getTypeName());
+    }
     if (arg.getType().isNullable()) {
       type = typeFactory.createTypeWithNullability(type, true);
     }

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -158,7 +158,6 @@ private Util() {}
               });
 
   //~ Methods ----------------------------------------------------------------
-
   /**
    * Does nothing with its argument. Returns whether it is ensured that
    * the call produces a single value

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -147,6 +147,7 @@
 
     // slow tests (above 1s)
     UdfTest.class,
+    UdtTest.class,
     TableFunctionTest.class,
     PlannerTest.class,
     RelBuilderTest.class,

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
Patch:
@@ -382,7 +382,7 @@ public JdbcProjectRule(final JdbcConvention out,
             public boolean test(@Nullable Project project) {
               assert project != null;
               return out.dialect.supportsWindowFunctions()
-                  && !RexOver.containsOver(project.getProjects(), null);
+                  || !RexOver.containsOver(project.getProjects(), null);
             }
           },
           Convention.NONE, out, relBuilderFactory, "JdbcProjectRule");

File: core/src/test/java/org/apache/calcite/test/MockCatalogReader.java
Patch:
@@ -247,6 +247,7 @@ public MockCatalogReader init() {
         MockTable.create(this, salesSchema, "DEPT_NESTED", false, 4);
     deptNestedTable.addColumn("DEPTNO", f.intType, true);
     deptNestedTable.addColumn("NAME", f.varchar10Type);
+    deptNestedTable.addColumn("SKILL", f.skillRecordType);
     deptNestedTable.addColumn("EMPLOYEES", f.empListType);
     registerTable(deptNestedTable);
 

File: core/src/main/java/org/apache/calcite/tools/Programs.java
Patch:
@@ -406,7 +406,9 @@ public RelNode run(RelOptPlanner planner, RelNode rel,
       final CalciteConnectionConfig config =
           planner.getContext().unwrap(CalciteConnectionConfig.class);
       if (config != null && config.forceDecorrelate()) {
-        return RelDecorrelator.decorrelateQuery(rel);
+        final RelBuilder relBuilder =
+            RelFactories.LOGICAL_BUILDER.create(rel.getCluster(), null);
+        return RelDecorrelator.decorrelateQuery(rel, relBuilder);
       }
       return rel;
     }

File: core/src/main/java/org/apache/calcite/interpreter/SortNode.java
Patch:
@@ -89,8 +89,8 @@ private Comparator<Row> comparator() {
     }
     return Ordering.compound(
         Iterables.transform(rel.getCollation().getFieldCollations(),
-            new Function<RelFieldCollation, Comparator<? super Row>>() {
-              public Comparator<? super Row> apply(RelFieldCollation input) {
+            new Function<RelFieldCollation, Comparator<Row>>() {
+              public Comparator<Row> apply(RelFieldCollation input) {
                 return comparator(input);
               }
             }));

File: core/src/main/java/org/apache/calcite/rel/core/Project.java
Patch:
@@ -279,7 +279,7 @@ public static Mappings.TargetMapping getMapping(int inputFieldCount,
     Mappings.TargetMapping mapping =
         Mappings.create(MappingType.INVERSE_SURJECTION,
             inputFieldCount, projects.size());
-    for (Ord<RexNode> exp : Ord.zip(projects)) {
+    for (Ord<RexNode> exp : Ord.<RexNode>zip(projects)) {
       if (!(exp.e instanceof RexInputRef)) {
         return null;
       }
@@ -306,7 +306,7 @@ public static Mappings.TargetMapping getPartialMapping(int inputFieldCount,
     Mappings.TargetMapping mapping =
         Mappings.create(MappingType.INVERSE_FUNCTION,
             inputFieldCount, projects.size());
-    for (Ord<RexNode> exp : Ord.zip(projects)) {
+    for (Ord<RexNode> exp : Ord.<RexNode>zip(projects)) {
       if (exp.e instanceof RexInputRef) {
         mapping.set(((RexInputRef) exp.e).getIndex(), exp.i);
       }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
Patch:
@@ -217,7 +217,7 @@ public static List<RelCollation> project(RelMetadataQuery mq,
     final Multimap<Integer, Integer> targets = LinkedListMultimap.create();
     final Map<Integer, SqlMonotonicity> targetsWithMonotonicity =
         new HashMap<>();
-    for (Ord<RexNode> project : Ord.zip(projects)) {
+    for (Ord<RexNode> project : Ord.<RexNode>zip(projects)) {
       if (project.e instanceof RexInputRef) {
         targets.put(((RexInputRef) project.e).getIndex(), project.i);
       } else if (project.e instanceof RexCall) {

File: core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
Patch:
@@ -105,6 +105,9 @@ public RelTraitDef getTraitDef() {
     return inTrait.getTraitDef();
   }
 
+  /** Converts a relational expression to the target trait(s) of this rule.
+   *
+   * <p>Returns null if conversion is not possible. */
   public abstract RelNode convert(RelNode rel);
 
   /**

File: plus/src/test/java/org/apache/calcite/test/PlusSuite.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.adapter.os.OsAdapterTest;
 import org.apache.calcite.adapter.tpcds.TpcdsTest;
 import org.apache.calcite.adapter.tpch.TpchTest;
+import org.apache.calcite.chinook.EndToEndTest;
 
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;
@@ -30,7 +31,8 @@
 @Suite.SuiteClasses({
     OsAdapterTest.class,
     TpcdsTest.class,
-    TpchTest.class
+    TpchTest.class,
+    EndToEndTest.class
     })
 public class PlusSuite {
 }

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -1188,8 +1188,8 @@ public RelBuilder aggregate(GroupKey groupKey, Iterable<AggCall> aggCalls) {
       if (registrar.extraNodes.size() == fields().size()) {
         final Boolean unique = mq.areColumnsUnique(peek(), groupSet);
         if (unique != null && unique) {
-          // Rel is already unique. Nothing to do.
-          return this;
+          // Rel is already unique.
+          return project(fields(groupSet.asList()));
         }
       }
       final Double maxRowCount = mq.getMaxRowCount(peek());

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -175,10 +175,11 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
 
     PhysType inputPhysType = result.physType;
 
+    final int w = implementor.windowCount++;
     ParameterExpression prevStart =
-        Expressions.parameter(int.class, builder.newName("prevStart"));
+        Expressions.parameter(int.class, builder.newName("prevStart" + w));
     ParameterExpression prevEnd =
-        Expressions.parameter(int.class, builder.newName("prevEnd"));
+        Expressions.parameter(int.class, builder.newName("prevEnd" + w));
 
     builder.add(Expressions.declare(0, prevStart, null));
     builder.add(Expressions.declare(0, prevEnd, null));

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -332,7 +332,8 @@ public Boolean areColumnsUnique(Values rel, RelMetadataQuery mq,
     final Set<List<Comparable>> set = new HashSet<>();
     final List<Comparable> values = new ArrayList<>();
     for (ImmutableList<RexLiteral> tuple : rel.tuples) {
-      for (RexLiteral literal : tuple) {
+      for (int column : columns) {
+        final RexLiteral literal = tuple.get(column);
         values.add(literal.isNull()
             ? NullSentinel.INSTANCE
             : literal.getValueAs(Comparable.class));

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -859,8 +859,8 @@ public static boolean canCastFrom(
     // where internally a cast across character repertoires is OK.  Should
     // probably clean that up.
 
-    SqlTypeAssignmentRules rules = SqlTypeAssignmentRules.instance();
-    return rules.canCastFrom(toTypeName, fromTypeName, coerce);
+    SqlTypeAssignmentRules rules = SqlTypeAssignmentRules.instance(coerce);
+    return rules.canCastFrom(toTypeName, fromTypeName);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -104,7 +104,8 @@ public static JdbcSchema create(
       DataSource dataSource,
       String catalog,
       String schema) {
-    return create(parentSchema, name, dataSource, new SqlDialectFactoryImpl(), catalog, schema);
+    return create(parentSchema, name, dataSource,
+        SqlDialectFactoryImpl.INSTANCE, catalog, schema);
   }
 
   public static JdbcSchema create(
@@ -174,7 +175,7 @@ public static JdbcSchema create(
    */
   @Deprecated // to be removed before 2.0
   public static SqlDialect createDialect(DataSource dataSource) {
-    return createDialect(new SqlDialectFactoryImpl(), dataSource);
+    return createDialect(SqlDialectFactoryImpl.INSTANCE, dataSource);
   }
 
   /** Returns a suitable SQL dialect for the given data source. */

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java
Patch:
@@ -74,7 +74,7 @@
  * The resulting queryable can then be converted to a SQL query, which can be
  * executed efficiently on the JDBC server.</p>
  */
-class JdbcTable extends AbstractQueryableTable
+public class JdbcTable extends AbstractQueryableTable
     implements TranslatableTable, ScannableTable, ModifiableTable {
   private RelProtoDataType protoRowType;
   private final JdbcSchema jdbcSchema;

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java
Patch:
@@ -30,7 +30,7 @@
  * Relational expression representing a scan of a table in a JDBC data source.
  */
 public class JdbcTableScan extends TableScan implements JdbcRel {
-  final JdbcTable jdbcTable;
+  protected final JdbcTable jdbcTable;
 
   protected JdbcTableScan(
       RelOptCluster cluster,

File: core/src/main/java/org/apache/calcite/sql/SqlDialectFactory.java
Patch:
@@ -20,7 +20,7 @@
 import java.sql.DatabaseMetaData;
 
 /**
- * <code>SqlDialectFactory</code> constructs a <code>SqlDialect</code> appropriate
+ * Creates a <code>SqlDialect</code> appropriate
  * for a given database metadata object.
  */
 public interface SqlDialectFactory {
@@ -34,6 +34,8 @@ public interface SqlDialectFactory {
    *
    * @param databaseMetaData used to determine which dialect of SQL to
    *                         generate
+   *
+   * @throws RuntimeException if there was an error creating the dialect
    */
   SqlDialect create(DatabaseMetaData databaseMetaData);
 

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkHandlerImpl.java
Patch:
@@ -50,7 +50,7 @@ public class SparkHandlerImpl implements CalcitePrepare.SparkHandler {
 
   private static SparkHandlerImpl instance;
   private static final File SRC_DIR = new File("/tmp");
-  private static final File CLASS_DIR = new File("spark/target/classes");
+  private static final File CLASS_DIR = new File("target/classes");
 
   /** Creates a SparkHandlerImpl. */
   private SparkHandlerImpl() {
@@ -85,8 +85,8 @@ public RelNode flattenTypes(RelOptPlanner planner, RelNode rootRel,
       boolean restructure) {
     RelNode root2 =
         planner.changeTraits(rootRel,
-            rootRel.getTraitSet().plus(SparkRel.CONVENTION));
-    return planner.changeTraits(root2, rootRel.getTraitSet());
+            rootRel.getTraitSet().plus(SparkRel.CONVENTION).simplify());
+    return planner.changeTraits(root2, rootRel.getTraitSet().simplify());
   }
 
   public void registerRules(RuleSetBuilder builder) {

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
Patch:
@@ -196,7 +196,7 @@ public RexNode apply(RexLocalRef a0) {
                         return program.expandLocalRef(a0);
                       }
                     }),
-              calc.getRowType().getFieldNames());
+                calc.getRowType().getFieldNames());
           }
           return relBuilder.build();
         }

File: piglet/src/main/java/org/apache/calcite/piglet/Ast.java
Patch:
@@ -570,7 +570,7 @@ public UnParser append(Node n) {
 
     public UnParser appendList(List<? extends Node> list) {
       append("[").in();
-      for (Ord<Node> n : Ord.zip(list)) {
+      for (Ord<Node> n : Ord.<Node>zip(list)) {
         newline().append(n.e);
         if (n.i < list.size() - 1) {
           append(",");

File: druid/src/test/java/org/apache/calcite/test/DruidDateRangeRulesTest.java
Patch:
@@ -128,11 +128,11 @@ public class DruidDateRangeRulesTest {
     c.set(2011, Calendar.JANUARY, 1);
     final TimestampString to = TimestampString.fromCalendarFields(c);
 
-    // dt >= 2010-01-01 AND dt < 2011-01-01
+    // d >= 2010-01-01 AND d < 2011-01-01
     checkDateRangeNoSimplify(f,
         f.and(
-            f.ge(f.dt, f.cast(f.timeStampDataType, f.timestampLiteral(from))),
-            f.lt(f.dt, f.cast(f.timeStampDataType, f.timestampLiteral(to)))),
+            f.ge(f.d, f.cast(f.timestampDataType, f.timestampLiteral(from))),
+            f.lt(f.d, f.cast(f.timestampDataType, f.timestampLiteral(to)))),
         is("[2010-01-01T00:00:00.000Z/2011-01-01T00:00:00.000Z]"));
   }
 

File: core/src/main/java/org/apache/calcite/plan/hep/HepProgram.java
Patch:
@@ -66,7 +66,7 @@ public static HepProgramBuilder builder() {
 
   void initialize(boolean clearCache) {
     matchLimit = MATCH_UNTIL_FIXPOINT;
-    matchOrder = HepMatchOrder.ARBITRARY;
+    matchOrder = HepMatchOrder.DEPTH_FIRST;
     group = null;
 
     for (HepInstruction instruction : instructions) {

File: mongodb/src/test/java/org/apache/calcite/test/MongoAdapterIT.java
Patch:
@@ -271,6 +271,7 @@ public Void apply(ResultSet resultSet) {
             + "CITY=FORT WORTH; LONGITUDE=null; LATITUDE=null; POP=20012; STATE=TX; ID=76104\n");
   }
 
+  @Ignore("broken; [CALCITE-2115] is logged to fix it")
   @Test public void testUnionPlan() {
     CalciteAssert.that()
         .enable(enabled())
@@ -614,6 +615,7 @@ public Void apply(ResultSet resultSet) {
                 "{$project: {C: 1, STATE: 1, CITY: 1}}"));
   }
 
+  @Ignore("broken; [CALCITE-2115] is logged to fix it")
   @Test public void testDistinctCount() {
     CalciteAssert.that()
         .enable(enabled())
@@ -668,6 +670,7 @@ public Void apply(ResultSet resultSet) {
                 "{$limit: 5}"));
   }
 
+  @Ignore("broken; [CALCITE-2115] is logged to fix it")
   @Test public void testProject() {
     CalciteAssert.that()
         .enable(enabled())

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java
Patch:
@@ -3089,8 +3089,8 @@ public void testCountWithNonNull() {
         + "group by \"B\"";
     String expectedSubExplain = "PLAN=EnumerableInterpreter\n"
         + "  DruidQuery(table=[[foodmart, foodmart]], "
-        + "intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], projects=[[$63, "
-        + "$89]], groups=[{0}], aggs=[[COUNT($1)]]";
+        + "intervals=[[1900-01-09T00:00:00.000Z/2992-01-10T00:00:00.000Z]], projects=[[$89, "
+        + "$63]], groups=[{1}], aggs=[[COUNT($0)]]";
 
     testCountWithApproxDistinct(true, sql, expectedSubExplain);
     testCountWithApproxDistinct(false, sql, expectedSubExplain);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java
Patch:
@@ -68,7 +68,7 @@ public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
 
   @Override public <T> T unwrap(Class<T> clazz) {
     if (clazz == SqlSplittableAggFunction.class) {
-      return clazz.cast(SqlSplittableAggFunction.SumSplitter.INSTANCE);
+      return clazz.cast(SqlSplittableAggFunction.Sum0Splitter.INSTANCE);
     }
     return super.unwrap(clazz);
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
Patch:
@@ -71,8 +71,7 @@ class EnumerableMergeJoinRule extends ConverterRule {
         final List<RelFieldCollation> fieldCollations = Lists.newArrayList();
         for (int key : info.keys().get(ord.i)) {
           fieldCollations.add(
-              new RelFieldCollation(key,
-                  RelFieldCollation.Direction.ASCENDING,
+              new RelFieldCollation(key, RelFieldCollation.Direction.ASCENDING,
                   RelFieldCollation.NullDirection.LAST));
         }
         final RelCollation collation = RelCollations.of(fieldCollations);

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -68,6 +68,7 @@ public class SqlAdvisorTest extends SqlValidatorTestCase {
   protected static final List<String> SALES_TABLES =
       Arrays.asList(
           "SCHEMA(CATALOG.SALES)",
+          "SCHEMA(CATALOG.SALES.NEST)",
           "TABLE(CATALOG.SALES.EMP)",
           "TABLE(CATALOG.SALES.EMPDEFAULTS)",
           "TABLE(CATALOG.SALES.EMPNULLABLES)",
@@ -92,7 +93,8 @@ public class SqlAdvisorTest extends SqlValidatorTestCase {
           "SCHEMA(CATALOG.DYNAMIC)",
           "SCHEMA(CATALOG.SALES)",
           "SCHEMA(CATALOG.STRUCT)",
-          "SCHEMA(CATALOG.CUSTOMER)");
+          "SCHEMA(CATALOG.CUSTOMER)",
+          "SCHEMA(CATALOG.SALES.NEST)");
 
   private static final List<String> AB_TABLES =
       Arrays.asList(

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -10405,6 +10405,9 @@ private void checkCustomColumnResolving(String table) {
 
     sql("select (((^slackingmin^))) from emp_r")
             .fails(error);
+
+    sql("select ^slackingmin^ from nest.emp_r")
+            .fails(error);
   }
 
   @Test public void testSelectAggregateOnRolledUpColumn() {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -345,10 +345,11 @@ public SqlNodeList expandStar(
     final List<Map.Entry<String, RelDataType>> types = new ArrayList<>();
     for (int i = 0; i < selectList.size(); i++) {
       final SqlNode selectItem = selectList.get(i);
+      final RelDataType originalType = getValidatedNodeTypeIfKnown(selectItem);
       expandSelectItem(
           selectItem,
           select,
-          unknownType,
+          Util.first(originalType, unknownType),
           list,
           catalogReader.nameMatcher().isCaseSensitive()
               ? new LinkedHashSet<String>()

File: core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.calcite.rel.logical.LogicalMinus;
 import org.apache.calcite.rel.logical.LogicalUnion;
 import org.apache.calcite.rel.logical.LogicalValues;
+import org.apache.calcite.rex.RexDynamicParam;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
@@ -247,6 +248,7 @@ private static boolean isEmpty(RelNode node) {
         @Override public void onMatch(RelOptRuleCall call) {
           Sort sort = call.rel(0);
           if (sort.fetch != null
+              && !(sort.fetch instanceof RexDynamicParam)
               && RexLiteral.intValue(sort.fetch) == 0) {
             call.transformTo(call.builder().push(sort).empty().build());
           }

File: core/src/main/java/org/apache/calcite/sql/SqlDynamicParam.java
Patch:
@@ -62,7 +62,7 @@ public void unparse(
       int leftPrec,
       int rightPrec) {
     writer.print("?");
-    writer.setNeedWhitespace(false);
+    writer.setNeedWhitespace(true);
   }
 
   public void validate(SqlValidator validator, SqlValidatorScope scope) {

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -799,7 +799,8 @@ protected void convertOrder(
         || select.getOrderList().getList().isEmpty()) {
       assert collation.getFieldCollations().isEmpty();
       if ((offset == null
-            || ((SqlLiteral) offset).bigDecimalValue().equals(BigDecimal.ZERO))
+            || (offset instanceof SqlLiteral
+                && ((SqlLiteral) offset).bigDecimalValue().equals(BigDecimal.ZERO)))
           && fetch == null) {
         return;
       }

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java
Patch:
@@ -592,7 +592,7 @@ private static MysqlSqlDialect mySqlDialect(NullCollation nullCollation) {
         + "AND ? >= \"shelf_width\"";
     final String expected = "SELECT *\n"
         + "FROM \"foodmart\".\"product\"\n"
-        + "WHERE \"product_id\" = ?"
+        + "WHERE \"product_id\" = ? "
         + "AND ? >= \"shelf_width\"";
     sql(query).ok(expected);
   }

File: core/src/main/java/org/apache/calcite/jdbc/CalciteResultSet.java
Patch:
@@ -83,7 +83,8 @@ public void toBeCompleted() {
         new CalcitePrepare.CalciteSignature<>(signature.sql,
             signature.parameters, signature.internalParameters,
             signature.rowType, columnMetaDataList, Meta.CursorFactory.ARRAY,
-            signature.rootSchema, ImmutableList.<RelCollation>of(), -1, null);
+            signature.rootSchema, ImmutableList.<RelCollation>of(), -1, null,
+            statement.getStatementType());
     ResultSetMetaData subResultSetMetaData =
         new AvaticaResultSetMetaData(statement, null, newSignature);
     final CalciteResultSet resultSet =

File: core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java
Patch:
@@ -46,7 +46,7 @@
 import java.util.Set;
 
 /**
- * <code>MaterializationOptUtil</code> defines static utility methods for using
+ * Utility methods for using
  * materialized views and lattices for queries.
  */
 public abstract class RelOptMaterializations {

File: core/src/main/java/org/apache/calcite/rel/type/RelDataType.java
Patch:
@@ -32,7 +32,7 @@
  * different type classes into one. Inelegant, but since our type system was
  * defined before the advent of Java generics, it avoids a lot of typecasting.
  */
-public interface RelDataType /*extends Type*/ {
+public interface RelDataType {
   int SCALE_NOT_SPECIFIED = Integer.MIN_VALUE;
   int PRECISION_NOT_SPECIFIED = -1;
 

File: core/src/main/java/org/apache/calcite/runtime/ConsList.java
Patch:
@@ -37,11 +37,12 @@ public class ConsList<E> extends AbstractImmutableList<E> {
   /** Creates a ConsList.
    * It consists of an element pre-pended to another list.
    * If the other list is mutable, creates an immutable copy. */
-  public static <E> List<E> of(E first, List<E> rest) {
+  public static <E> List<E> of(E first, List<? extends E> rest) {
     if (rest instanceof ConsList
         || rest instanceof ImmutableList
         && !rest.isEmpty()) {
-      return new ConsList<>(first, rest);
+      //noinspection unchecked
+      return new ConsList<>(first, (List<E>) rest);
     } else {
       return ImmutableList.<E>builder().add(first).addAll(rest).build();
     }

File: core/src/main/java/org/apache/calcite/sql/SqlExecutableStatement.java
Patch:
@@ -17,13 +17,15 @@
 package org.apache.calcite.sql;
 
 import org.apache.calcite.jdbc.CalcitePrepare;
+import org.apache.calcite.linq4j.function.Experimental;
 
 /**
  * Mix-in interface for {@link SqlNode} that allows DDL commands to be
  * executed directly.
  *
  * <p>NOTE: Subject to change without notice.
  */
+@Experimental
 public interface SqlExecutableStatement {
   void execute(CalcitePrepare.Context context);
 }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatcher.java
Patch:
@@ -49,7 +49,7 @@ <K extends List<String>, V> V get(Map<K, V> map, List<String> prefixNames,
    * throws {@link UnsupportedOperationException}. */
   String bestString();
 
-  /** Finds a field with a given name, using the currenct case-sensitivity,
+  /** Finds a field with a given name, using the current case-sensitivity,
    * returning null if not found.
    *
    * @param rowType    Row type

File: core/src/main/java/org/apache/calcite/util/graph/Graphs.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.util.graph;
 
-import org.apache.calcite.runtime.ConsList;
 import org.apache.calcite.util.Pair;
 
 import com.google.common.collect.ImmutableList;
@@ -29,6 +28,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static org.apache.calcite.util.Static.cons;
+
 /**
  * Miscellaneous graph utilities.
  */
@@ -80,7 +81,7 @@ public static <V, E extends DefaultEdge> FrozenGraph<V, E> makeImmutable(
             if ((bestPath == null)
                 || (bestPath.size() > (arc2Path.size() + 1))) {
               shortestPaths.put(key,
-                  ConsList.of(graph1.source(edge), arc2Path));
+                  cons(graph1.source(edge), arc2Path));
               changeCount++;
             }
           }

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -159,7 +159,7 @@
     LatticeTest.class,
     ReflectiveSchemaTest.class,
     JdbcTest.class,
-    QuidemTest.class,
+    CoreQuidemTest.class,
     CalciteRemoteDriverTest.class,
     StreamTest.class,
 

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -730,7 +730,7 @@ private void checkTableFunctionInModel(Class clazz) {
              driver.connect("jdbc:calcite:", new Properties());
         Statement statement = connection.createStatement()) {
       assertThat(driver.counter, is(0));
-      statement.executeQuery("COMMIT");
+      statement.executeUpdate("COMMIT");
       assertThat(driver.counter, is(1));
     }
   }

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -114,8 +114,6 @@
 
 import static org.junit.Assert.assertTrue;
 
-
-
 /**
  * Unit test for rules in {@code org.apache.calcite.rel} and subpackages.
  *

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoTable.java
Patch:
@@ -28,7 +28,6 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
-import org.apache.calcite.runtime.ConsList;
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.schema.TranslatableTable;
 import org.apache.calcite.schema.impl.AbstractTableQueryable;
@@ -51,6 +50,8 @@
 import java.util.List;
 import java.util.Map;
 
+import static org.apache.calcite.util.Static.cons;
+
 /**
  * Table based on a MongoDB collection.
  */
@@ -214,7 +215,7 @@ private static Integer parseIntString(String valueString) {
    */
   private AggregationOutput aggregateOldWay(DBCollection dbCollection,
        DBObject first, List<DBObject> rest) {
-    return dbCollection.aggregate(ConsList.of(first, rest));
+    return dbCollection.aggregate(cons(first, rest));
   }
 
   /** Implementation of {@link org.apache.calcite.linq4j.Queryable} based on

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -188,7 +188,8 @@ protected void apply(RelOptRuleCall call, LogicalProject project,
 
     // Compute the values they reduce to.
     final RelOptPredicateList predicates = RelOptPredicateList.EMPTY;
-    ReduceExpressionsRule.reduceExpressions(values, reducibleExps, predicates);
+    ReduceExpressionsRule.reduceExpressions(values, reducibleExps, predicates,
+        false, true);
 
     int changeCount = 0;
     final ImmutableList.Builder<ImmutableList<RexLiteral>> tuplesBuilder =

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -22,6 +22,7 @@
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Aggregate;
+import org.apache.calcite.rel.core.Aggregate.Group;
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rel.core.RelFactories;
@@ -158,7 +159,7 @@ public void onMatch(RelOptRuleCall call) {
     // arguments then we can use a more efficient form.
     if (nonDistinctAggCallCount == 0
         && argLists.size() == 1
-        && aggregate.getGroupSets().size() == 1) {
+        && aggregate.getGroupType() == Group.SIMPLE) {
       final Pair<List<Integer>, Integer> pair =
           Iterables.getOnlyElement(argLists);
       final RelBuilder relBuilder = call.builder();

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.calcite.plan.SubstitutionVisitor;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Aggregate;
+import org.apache.calcite.rel.core.Aggregate.Group;
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.core.RelFactories;
@@ -107,7 +108,7 @@ public Integer apply(Integer a0) {
         RexUtil.apply(mapping, filter.getCondition());
     final Filter newFilter = filter.copy(filter.getTraitSet(),
         newAggregate, newCondition);
-    if (allColumnsInAggregate && aggregate.getGroupSets().size() == 1) {
+    if (allColumnsInAggregate && aggregate.getGroupType() == Group.SIMPLE) {
       // Everything needed by the filter is returned by the aggregate.
       assert newGroupSet.equals(aggregate.getGroupSet());
       call.transformTo(newFilter);
@@ -120,7 +121,7 @@ public Integer apply(Integer a0) {
         topGroupSet.set(newGroupSet.indexOf(c));
       }
       ImmutableList<ImmutableBitSet> newGroupingSets = null;
-      if (aggregate.groupSets.size() > 1) {
+      if (aggregate.getGroupType() != Group.SIMPLE) {
         ImmutableList.Builder<ImmutableBitSet> newGroupingSetsBuilder =
                 ImmutableList.builder();
         for (ImmutableBitSet groupingSet : aggregate.getGroupSets()) {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectMergeRule.java
Patch:
@@ -20,6 +20,7 @@
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Aggregate;
+import org.apache.calcite.rel.core.Aggregate.Group;
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.core.RelFactories;
@@ -88,7 +89,7 @@ public static RelNode apply(RelOptRuleCall call, Aggregate aggregate,
 
     final ImmutableBitSet newGroupSet = aggregate.getGroupSet().permute(map);
     ImmutableList<ImmutableBitSet> newGroupingSets = null;
-    if (aggregate.getGroupSets().size() > 1) {
+    if (aggregate.getGroupType() != Group.SIMPLE) {
       newGroupingSets =
           ImmutableBitSet.ORDERING.immutableSortedCopy(
               ImmutableBitSet.permute(aggregate.getGroupSets(), map));

File: core/src/main/java/org/apache/calcite/rel/rules/FilterAggregateTransposeRule.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Aggregate;
+import org.apache.calcite.rel.core.Aggregate.Group;
 import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.rel.type.RelDataTypeField;
@@ -137,7 +138,7 @@ private boolean canPush(Aggregate aggregate, ImmutableBitSet rCols) {
       return false;
     }
 
-    if (aggregate.getGroupSets().size() > 1) {
+    if (aggregate.getGroupType() != Group.SIMPLE) {
       // If grouping sets are used, the filter can be pushed if
       // the columns referenced in the predicate are present in
       // all the grouping sets.

File: core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
Patch:
@@ -186,9 +186,8 @@ public RelDataType deriveType(
       final SqlMonotonicity mono0 = call.getOperandMonotonicity(0);
       final SqlMonotonicity mono1 = call.getOperandMonotonicity(1);
       if (mono1 == SqlMonotonicity.CONSTANT) {
-        final Object o = call.getOperandLiteralValue(1);
-        if (o instanceof BigDecimal) {
-          switch (((BigDecimal) o).compareTo(BigDecimal.ZERO)) {
+        if (call.isOperandLiteral(1, false)) {
+          switch (call.getOperandLiteralValue(1, BigDecimal.class).signum()) {
           case -1:
 
             // mono / -ve constant --> reverse mono, unstrict

File: core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
Patch:
@@ -152,7 +152,7 @@ private boolean hasAssignment() {
 
   /** Returns the operands to a call permuted into the same order as the
    * formal parameters of the function. */
-  public List<SqlNode> permutedOperands(final SqlCall call) {
+  private List<SqlNode> permutedOperands(final SqlCall call) {
     final SqlFunction operator = (SqlFunction) call.getOperator();
     return Lists.transform(operator.getParamNames(),
         new Function<String, SqlNode>() {
@@ -215,10 +215,10 @@ public SqlMonotonicity getOperandMonotonicity(int ordinal) {
     throw new AssertionError();
   }
 
-  @Override public Comparable getOperandLiteralValue(int ordinal) {
+  @Override public <T> T getOperandLiteralValue(int ordinal, Class<T> clazz) {
     try {
       final SqlNode node = call.operand(ordinal);
-      return SqlLiteral.value(node);
+      return SqlLiteral.unchain(node).getValueAs(clazz);
     } catch (IllegalArgumentException e) {
       return null;
     }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlAbstractTimeFunction.java
Patch:
@@ -65,7 +65,7 @@ public RelDataType inferReturnType(
     if (opBinding.getOperandCount() == 1) {
       RelDataType type = opBinding.getOperandType(0);
       if (SqlTypeUtil.isNumeric(type)) {
-        precision = ((Number) opBinding.getOperandLiteralValue(0)).intValue();
+        precision = opBinding.getOperandLiteralValue(0, Integer.class);
       }
     }
     assert precision >= 0;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlExtractFunction.java
Patch:
@@ -65,7 +65,7 @@ public void unparse(
   }
 
   @Override public SqlMonotonicity getMonotonicity(SqlOperatorBinding call) {
-    switch ((TimeUnitRange) call.getOperandLiteralValue(0)) {
+    switch (call.getOperandLiteralValue(0, TimeUnitRange.class)) {
     case YEAR:
       return call.getOperandMonotonicity(1).unstrict();
     default:

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSubstringFunction.java
Patch:
@@ -195,8 +195,8 @@ public void unparse(
       final SqlMonotonicity mono0 = call.getOperandMonotonicity(0);
       if ((mono0 != SqlMonotonicity.NOT_MONOTONIC)
           && call.getOperandMonotonicity(1) == SqlMonotonicity.CONSTANT
-          && call.getOperandLiteralValue(1) instanceof BigDecimal
-          && call.getOperandLiteralValue(1).equals(BigDecimal.ZERO)
+          && call.getOperandLiteralValue(1, BigDecimal.class)
+              .equals(BigDecimal.ZERO)
           && call.getOperandMonotonicity(2) == SqlMonotonicity.CONSTANT) {
         return mono0.unstrict();
       }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlTimestampAddFunction.java
Patch:
@@ -60,8 +60,7 @@ class SqlTimestampAddFunction extends SqlFunction {
       new SqlReturnTypeInference() {
         public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
           final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();
-          final TimeUnit unit = (TimeUnit) opBinding.getOperandLiteralValue(0);
-          switch (unit) {
+          switch (opBinding.getOperandLiteralValue(0, TimeUnit.class)) {
           case HOUR:
           case MINUTE:
           case SECOND:

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -2297,7 +2297,8 @@ protected void convertCollectionTable(
       SqlCall call) {
     final SqlOperator operator = call.getOperator();
     if (operator == SqlStdOperatorTable.TABLESAMPLE) {
-      final String sampleName = (String) SqlLiteral.value(call.operand(0));
+      final String sampleName =
+          SqlLiteral.unchain(call.operand(0)).getValueAs(String.class);
       datasetStack.push(sampleName);
       SqlCall cursorCall = call.operand(1);
       SqlNode query = cursorCall.operand(0);

File: core/src/main/java/org/apache/calcite/rel/core/Project.java
Patch:
@@ -273,6 +273,9 @@ public Mappings.TargetMapping getMapping() {
    */
   public static Mappings.TargetMapping getMapping(int inputFieldCount,
       List<? extends RexNode> projects) {
+    if (inputFieldCount < projects.size()) {
+      return null; // surjection is not possible
+    }
     Mappings.TargetMapping mapping =
         Mappings.create(MappingType.INVERSE_SURJECTION,
             inputFieldCount, projects.size());

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
Patch:
@@ -174,7 +174,7 @@ private String translateMatch(RexNode condition) {
       }
     }
 
-    /** Conver the value of a literal to a string.
+    /** Convert the value of a literal to a string.
      *
      * @param literal Literal to translate
      * @return String representation of the literal

File: core/src/main/java/org/apache/calcite/rel/type/RelDataType.java
Patch:
@@ -71,8 +71,8 @@ public interface RelDataType /*extends Type*/ {
   /**
    * Returns the number of fields in a struct type.
    *
-   * <p>This method is equivalent to <code>{@link #getFieldList}
-   * ().size()</code>.
+   * <p>This method is equivalent to
+   * <code>{@link #getFieldList}.size()</code>.
    */
   int getFieldCount();
 

File: core/src/main/java/org/apache/calcite/schema/ProjectableFilterableTable.java
Patch:
@@ -48,7 +48,7 @@ public interface ProjectableFilterableTable extends Table {
    * <p>The projects are zero-based.</p>
    *
    * @param root Execution context
-   * @param filters Mutable list of filters. The method should remove from the
+   * @param filters Mutable list of filters. The method should keep in the
    *                list any filters that it cannot apply.
    * @param projects List of projects. Each is the 0-based ordinal of the column
    *                 to project.

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -457,8 +457,9 @@ public Result visit(Match e) {
       for (RelFieldCollation fc : e.getOrderKeys().getFieldCollations()) {
         if (fc.nullDirection != RelFieldCollation.NullDirection.UNSPECIFIED) {
           boolean first = fc.nullDirection == RelFieldCollation.NullDirection.FIRST;
-          SqlNode nullDirectionNode = dialect.emulateNullDirection(
-              context.field(fc.getFieldIndex()), first);
+          SqlNode nullDirectionNode =
+              dialect.emulateNullDirection(context.field(fc.getFieldIndex()),
+                  first, fc.direction.isDescending());
           if (nullDirectionNode != null) {
             orderBySqlList.add(nullDirectionNode);
             fc = new RelFieldCollation(fc.getFieldIndex(), fc.getDirection(),

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -1122,8 +1122,9 @@ public void addOrderItem(List<SqlNode> orderByList,
         RelFieldCollation field) {
       if (field.nullDirection != RelFieldCollation.NullDirection.UNSPECIFIED) {
         boolean first = field.nullDirection == RelFieldCollation.NullDirection.FIRST;
-        SqlNode nullDirectionNode = dialect.emulateNullDirection(
-            context.field(field.getFieldIndex()), first);
+        SqlNode nullDirectionNode =
+            dialect.emulateNullDirection(context.field(field.getFieldIndex()),
+                first, field.direction.isDescending());
         if (nullDirectionNode != null) {
           orderByList.add(nullDirectionNode);
           field = new RelFieldCollation(field.getFieldIndex(),

File: core/src/main/java/org/apache/calcite/sql/fun/SqlTrimFunction.java
Patch:
@@ -119,7 +119,7 @@ public void unparse(
   public String getSignatureTemplate(final int operandsCount) {
     switch (operandsCount) {
     case 3:
-      return "{0}([BOTH|LEADING|TRAILING} {1} FROM {2})";
+      return "{0}([BOTH|LEADING|TRAILING] {1} FROM {2})";
     default:
       throw new AssertionError();
     }

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -1187,7 +1187,7 @@ private JsonFilter translateFilter(RexNode e) {
           // normal selector
           if (numeric && extractionFunction == null) {
             String constantValue = tr(e, posConstant);
-            return new JsonBound(dimName, constantValue, true, constantValue, true,
+            return new JsonBound(dimName, constantValue, false, constantValue, false,
                 numeric, extractionFunction);
           }
           return new JsonSelector(dimName, tr(e, posConstant), extractionFunction);
@@ -1198,9 +1198,9 @@ private JsonFilter translateFilter(RexNode e) {
           if (numeric && extractionFunction == null) {
             String constantValue = tr(e, posConstant);
             return new JsonCompositeFilter(JsonFilter.Type.OR,
-                new JsonBound(dimName, constantValue, false, null, false,
+                new JsonBound(dimName, constantValue, true, null, false,
                     numeric, extractionFunction),
-                new JsonBound(dimName, null, false, constantValue, false,
+                new JsonBound(dimName, null, false, constantValue, true,
                     numeric, extractionFunction));
           }
           return new JsonCompositeFilter(JsonFilter.Type.NOT,

File: file/src/main/java/org/apache/calcite/adapter/file/FileSchemaFactory.java
Patch:
@@ -29,7 +29,7 @@
  * Factory that creates a {@link FileSchema}.
  *
  * <p>Allows a custom schema to be included in a model.json file.
- * See <a href="http://calcite.apache.org/docs/file.html">File adapter</a>.
+ * See <a href="http://calcite.apache.org/docs/file_adapter.html">File adapter</a>.
  */
 @SuppressWarnings("UnusedDeclaration")
 public class FileSchemaFactory implements SchemaFactory {

File: core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
Patch:
@@ -356,7 +356,7 @@ public void end(Sink sink) throws InterruptedException {
   /**
    * A list of accumulators used during grouping.
    */
-  private class AccumulatorList extends ArrayList<Accumulator> {
+  private static class AccumulatorList extends ArrayList<Accumulator> {
     public void send(Row row) {
       for (Accumulator a : this) {
         a.send(row);

File: core/src/main/java/org/apache/calcite/sql/SqlBinaryStringLiteral.java
Patch:
@@ -56,7 +56,7 @@ public BitString getBitString() {
     return (BitString) value;
   }
 
-  public SqlNode clone(SqlParserPos pos) {
+  @Override public SqlBinaryStringLiteral clone(SqlParserPos pos) {
     return new SqlBinaryStringLiteral((BitString) value, pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlCharStringLiteral.java
Patch:
@@ -63,7 +63,7 @@ public SqlCollation getCollation() {
     return getNlsString().getCollation();
   }
 
-  public SqlNode clone(SqlParserPos pos) {
+  @Override public SqlCharStringLiteral clone(SqlParserPos pos) {
     return new SqlCharStringLiteral((NlsString) value, pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlDateLiteral.java
Patch:
@@ -42,7 +42,7 @@ protected DateString getDate() {
     return (DateString) value;
   }
 
-  public SqlNode clone(SqlParserPos pos) {
+  @Override public SqlDateLiteral clone(SqlParserPos pos) {
     return new SqlDateLiteral((DateString) value, pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -234,7 +234,7 @@ public static boolean valueMatchesType(
     }
   }
 
-  public SqlNode clone(SqlParserPos pos) {
+  public SqlLiteral clone(SqlParserPos pos) {
     return new SqlLiteral(value, typeName, pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlTimeLiteral.java
Patch:
@@ -44,7 +44,7 @@ protected TimeString getTime() {
     return (TimeString) value;
   }
 
-  public SqlNode clone(SqlParserPos pos) {
+  @Override public SqlTimeLiteral clone(SqlParserPos pos) {
     return new SqlTimeLiteral((TimeString) value, precision, hasTimeZone, pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java
Patch:
@@ -39,7 +39,7 @@ public class SqlTimestampLiteral extends SqlAbstractDateTimeLiteral {
 
   //~ Methods ----------------------------------------------------------------
 
-  public SqlNode clone(SqlParserPos pos) {
+  @Override public SqlTimestampLiteral clone(SqlParserPos pos) {
     return new SqlTimestampLiteral((TimestampString) value, precision,
         hasTimeZone, pos);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlNullifFunction.java
Patch:
@@ -67,9 +67,8 @@ public SqlNode rewriteCall(SqlValidator validator, SqlCall call) {
     SqlNodeList thenList = new SqlNodeList(pos);
     whenList.add(operands.get(1));
     thenList.add(SqlLiteral.createNull(SqlParserPos.ZERO));
-    return SqlCase.createSwitched(
-        pos, operands.get(0), whenList, thenList, operands.get(0).clone(
-        operands.get(0).getParserPosition()));
+    return SqlCase.createSwitched(pos, operands.get(0), whenList, thenList,
+        SqlNode.clone(operands.get(0)));
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeFamily.java
Patch:
@@ -99,9 +99,9 @@ public enum SqlTypeFamily implements RelDataTypeFamily {
 
           .put(Types.DATE, DATE)
           .put(Types.TIME, TIME)
-          .put(Types.TIME_WITH_TIMEZONE, TIME)
+          .put(ExtraSqlTypes.TIME_WITH_TIMEZONE, TIME)
           .put(Types.TIMESTAMP, TIMESTAMP)
-          .put(Types.TIMESTAMP_WITH_TIMEZONE, TIMESTAMP)
+          .put(ExtraSqlTypes.TIMESTAMP_WITH_TIMEZONE, TIMESTAMP)
           .put(Types.BOOLEAN, BOOLEAN)
 
           .put(ExtraSqlTypes.REF_CURSOR, CURSOR)

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -125,7 +125,7 @@ private static class DummyTestDataContext implements DataContext {
       this.map =
           ImmutableMap.<String, Object>of(
               Variable.TIME_ZONE.camelName, TimeZone.getTimeZone("America/Los_Angeles"),
-              Variable.CURRENT_TIMESTAMP.camelName, new Long(1311120000000L));
+              Variable.CURRENT_TIMESTAMP.camelName, 1311120000000L);
     }
 
     public SchemaPlus getRootSchema() {

File: linq4j/src/main/java/org/apache/calcite/linq4j/function/Experimental.java
Patch:
@@ -20,6 +20,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+import static java.lang.annotation.ElementType.CONSTRUCTOR;
 import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PACKAGE;
@@ -33,7 +34,7 @@
  * <p>And yes, it is flagged experimental. We may move it elsewhere in future,
  * when we re-think the maturity model.
  */
-@Target({PACKAGE, TYPE, FIELD, METHOD })
+@Target({PACKAGE, TYPE, FIELD, METHOD, CONSTRUCTOR })
 @Retention(RetentionPolicy.SOURCE)
 @Experimental
 public @interface Experimental {

File: core/src/test/java/org/apache/calcite/rex/RexBuilderTest.java
Patch:
@@ -179,7 +179,7 @@ private void checkTimestamp(RexNode node) {
   }
 
   /** Tests
-   * {@link RexBuilder#makeTimestampWithLocalTimeZoneLiteral(TimestampWithTimeZoneString, int)}. */
+   * {@link RexBuilder#makeTimestampWithLocalTimeZoneLiteral(TimestampString, int)}. */
   @Test public void testTimestampWithLocalTimeZoneLiteral() {
     final RelDataTypeFactory typeFactory =
         new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -176,12 +176,14 @@ public Type getJavaClass(RelDataType type) {
         return String.class;
       case DATE:
       case TIME:
+      case TIME_WITH_LOCAL_TIME_ZONE:
       case INTEGER:
       case INTERVAL_YEAR:
       case INTERVAL_YEAR_MONTH:
       case INTERVAL_MONTH:
         return type.isNullable() ? Integer.class : int.class;
       case TIMESTAMP:
+      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
       case BIGINT:
       case INTERVAL_DAY:
       case INTERVAL_DAY_HOUR:

File: core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.rel.RelCollation;
 import org.apache.calcite.rel.RelCollationTraitDef;
+import org.apache.calcite.rel.RelCollations;
 import org.apache.calcite.rel.RelFieldCollation;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Project;
@@ -102,7 +103,7 @@ public void onMatch(RelOptRuleCall call) {
         final RexCall cast = (RexCall) node;
         final RexCallBinding binding =
             RexCallBinding.create(cluster.getTypeFactory(), cast,
-                ImmutableList.of(RexUtil.apply(map, sort.getCollation())));
+                ImmutableList.of(RelCollations.of(RexUtil.apply(map, fc))));
         if (cast.getOperator().getMonotonicity(binding) == SqlMonotonicity.NOT_MONOTONIC) {
           return;
         }

File: core/src/main/java/org/apache/calcite/rex/RexSimplify.java
Patch:
@@ -811,6 +811,7 @@ private RexNode simplifyCast(RexCall e) {
         case TIMESTAMP:
           return e;
         }
+        break;
       }
       final List<RexNode> reducedValues = new ArrayList<>();
       executor.reduce(rexBuilder, ImmutableList.<RexNode>of(e), reducedValues);

File: core/src/main/java/org/apache/calcite/schema/Schemas.java
Patch:
@@ -54,7 +54,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.TimeZone;
 
 /**
  * Utility functions for schemas.
@@ -564,8 +563,7 @@ private static class DummyDataContext implements DataContext {
     DummyDataContext(CalciteConnection connection, SchemaPlus rootSchema) {
       this.connection = connection;
       this.rootSchema = rootSchema;
-      this.map =
-          ImmutableMap.<String, Object>of("timeZone", TimeZone.getDefault());
+      this.map = ImmutableMap.<String, Object>of();
     }
 
     public SchemaPlus getRootSchema() {

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcDataTypeName.java
Patch:
@@ -34,7 +34,9 @@ public enum SqlJdbcDataTypeName {
   SQL_VARCHAR(SqlTypeName.VARCHAR),
   SQL_DATE(SqlTypeName.DATE),
   SQL_TIME(SqlTypeName.TIME),
+  SQL_TIME_WITH_LOCAL_TIME_ZONE(SqlTypeName.TIME_WITH_LOCAL_TIME_ZONE),
   SQL_TIMESTAMP(SqlTypeName.TIMESTAMP),
+  SQL_TIMESTAMP_WITH_LOCAL_TIME_ZONE(SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE),
   SQL_DECIMAL(SqlTypeName.DECIMAL),
   SQL_NUMERIC(SqlTypeName.DECIMAL),
   SQL_BOOLEAN(SqlTypeName.BOOLEAN),

File: core/src/main/java/org/apache/calcite/util/DateString.java
Patch:
@@ -42,7 +42,7 @@ public DateString(String v) {
 
   /** Creates a DateString for year, month, day values. */
   public DateString(int year, int month, int day) {
-    this(TimestampString.ymd(new StringBuilder(), year, month, day).toString());
+    this(DateTimeStringUtils.ymd(new StringBuilder(), year, month, day).toString());
   }
 
   @Override public String toString() {

File: core/src/main/java/org/apache/calcite/util/TimeString.java
Patch:
@@ -44,7 +44,7 @@ public TimeString(String v) {
 
   /** Creates a TimeString for hour, minute, second and millisecond values. */
   public TimeString(int h, int m, int s) {
-    this(TimestampString.hms(new StringBuilder(), h, m, s).toString());
+    this(DateTimeStringUtils.hms(new StringBuilder(), h, m, s).toString());
   }
 
   /** Sets the fraction field of a {@code TimeString} to a given number
@@ -55,7 +55,7 @@ public TimeString(int h, int m, int s) {
    * yields {@code TIME '1970-01-01 02:03:04.056'}. */
   public TimeString withMillis(int millis) {
     Preconditions.checkArgument(millis >= 0 && millis < 1000);
-    return withFraction(TimestampString.pad(3, millis));
+    return withFraction(DateTimeStringUtils.pad(3, millis));
   }
 
   /** Sets the fraction field of a {@code TimeString} to a given number
@@ -66,7 +66,7 @@ public TimeString withMillis(int millis) {
    * yields {@code TIME '1970-01-01 02:03:04.000056789'}. */
   public TimeString withNanos(int nanos) {
     Preconditions.checkArgument(nanos >= 0 && nanos < 1000000000);
-    return withFraction(TimestampString.pad(9, nanos));
+    return withFraction(DateTimeStringUtils.pad(9, nanos));
   }
 
   /** Sets the fraction field of a {@code TimeString}.

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -274,7 +274,7 @@ public AvaticaJsonHandler createHandler(Service service) {
   @Test public void testRemoteTypeInfo() throws Exception {
     CalciteAssert.hr().with(REMOTE_CONNECTION_FACTORY)
         .metaData(GET_TYPEINFO)
-        .returns(CalciteAssert.checkResultCount(is(43)));
+        .returns(CalciteAssert.checkResultCount(is(45)));
   }
 
   @Test public void testRemoteTableTypes() throws Exception {

File: core/src/test/java/org/apache/calcite/test/CalciteAssert.java
Patch:
@@ -548,6 +548,9 @@ static void assertQuery(
         calciteConnection.getProperties().setProperty(
             CalciteConnectionProperty.CREATE_MATERIALIZATIONS.camelName(),
             Boolean.toString(materializationsEnabled));
+        calciteConnection.getProperties().setProperty(
+            CalciteConnectionProperty.TIME_ZONE.camelName(),
+            DateTimeUtils.UTC_ZONE.getID());
       }
       for (Pair<Hook, Function> hook : hooks) {
         closer.add(hook.left.addThread(hook.right));

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
Patch:
@@ -512,7 +512,7 @@ void metadata(String dataSourceName, String timestampColumnName,
               JsonSegmentMetadata.class);
       final List<JsonSegmentMetadata> list = mapper.readValue(in, listType);
       in.close();
-      fieldBuilder.put(timestampColumnName, SqlTypeName.TIMESTAMP);
+      fieldBuilder.put(timestampColumnName, SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE);
       for (JsonSegmentMetadata o : list) {
         for (Map.Entry<String, JsonColumn> entry : o.columns.entrySet()) {
           if (entry.getKey().equals(DruidTable.DEFAULT_TIMESTAMP_COLUMN)) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -230,8 +230,8 @@ public void onMatch(RelOptRuleCall call) {
       List<LocalInterval> intervals = null;
       if (!triple.getLeft().isEmpty()) {
         intervals = DruidDateTimeUtils.createInterval(
-            query.getRowType().getFieldList().get(timestampFieldIdx).getType(),
-            RexUtil.composeConjunction(rexBuilder, triple.getLeft(), false));
+            RexUtil.composeConjunction(rexBuilder, triple.getLeft(), false),
+            cluster.getPlanner().getContext().unwrap(CalciteConnectionConfig.class).timeZone());
         if (intervals == null || intervals.isEmpty()) {
           // Case we have an filter with extract that can not be written as interval push down
           triple.getMiddle().addAll(triple.getLeft());
@@ -579,7 +579,7 @@ public boolean checkPostAggregatorExist(RexNode rexNode) {
         case MINUS:
         case DIVIDE:
         case TIMES:
-        case CAST:
+        //case CAST:
           return true;
         default:
           return false;

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
Patch:
@@ -59,7 +59,7 @@ public Table create(SchemaPlus schema, String name, Map operand,
     } else {
       timestampColumnName = DruidTable.DEFAULT_TIMESTAMP_COLUMN;
     }
-    fieldBuilder.put(timestampColumnName, SqlTypeName.TIMESTAMP);
+    fieldBuilder.put(timestampColumnName, SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE);
     final Object dimensionsRaw = operand.get("dimensions");
     if (dimensionsRaw instanceof List) {
       // noinspection unchecked

File: druid/src/test/java/org/apache/calcite/adapter/druid/DruidQueryFilterTest.java
Patch:
@@ -121,7 +121,7 @@ static class Fixture {
         .add("dimensionName", varcharType)
         .build();
     final DruidQuery.Translator translatorStringKind =
-        new DruidQuery.Translator(druidTable, varcharRowType);
+        new DruidQuery.Translator(druidTable, varcharRowType, "UTC");
   }
 }
 

File: druid/src/test/java/org/apache/calcite/test/DruidDateRangeRulesTest.java
Patch:
@@ -158,7 +158,7 @@ private void checkDateRangeNoSimplify(Fixture f, RexNode e,
               operandRanges));
     }
     final List<LocalInterval> intervals =
-        DruidDateTimeUtils.createInterval(f.timeStampDataType, e);
+        DruidDateTimeUtils.createInterval(e, "UTC");
     assertThat(intervals, notNullValue());
     assertThat(intervals.toString(), intervalMatcher);
   }
@@ -178,7 +178,7 @@ private void checkDateRange(Fixture f, RexNode e, Matcher<String> intervalMatche
     }
     final RexNode e2 = f.simplify.simplify(e);
     List<LocalInterval> intervals =
-        DruidDateTimeUtils.createInterval(f.timeStampDataType, e2);
+        DruidDateTimeUtils.createInterval(e2, "UTC");
     if (intervals == null) {
       throw new AssertionError("null interval");
     }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/AggAddContextImpl.java
Patch:
@@ -29,7 +29,7 @@
 public abstract class AggAddContextImpl extends AggResultContextImpl
     implements AggAddContext {
   public AggAddContextImpl(BlockBuilder block, List<Expression> accumulator) {
-    super(block, accumulator);
+    super(block, null, accumulator, null, null);
   }
 
   public final List<Expression> arguments() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggResultContextImpl.java
Patch:
@@ -45,7 +45,7 @@ public abstract class WinAggResultContextImpl extends AggResultContextImpl
   public WinAggResultContextImpl(BlockBuilder block,
       List<Expression> accumulator,
       Function<BlockBuilder, WinAggFrameResultContext> frameContextBuilder) {
-    super(block, accumulator);
+    super(block, null, accumulator, null, null);
     this.frame = frameContextBuilder;
   }
 

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1204,8 +1204,7 @@ public static MutableAggregate permute(MutableAggregate aggregate,
         Mappings.apply2(mapping, aggregate.groupSets);
     List<AggregateCall> aggregateCalls =
         apply(mapping, aggregate.aggCalls);
-    return MutableAggregate.of(input, aggregate.indicator, groupSet, groupSets,
-        aggregateCalls);
+    return MutableAggregate.of(input, groupSet, groupSets, aggregateCalls);
   }
 
   private static List<AggregateCall> apply(final Mapping mapping,
@@ -1267,7 +1266,7 @@ public static MutableRel unifyAggregates(MutableAggregate query,
                 ImmutableList.of(target.groupSet.cardinality() + i), -1,
                 aggregateCall.type, aggregateCall.name));
       }
-      result = MutableAggregate.of(target, false, groupSet.build(), null,
+      result = MutableAggregate.of(target, groupSet.build(), null,
           aggregateCalls);
     }
     return MutableRels.createCastRel(result, query.rowType, true);

File: core/src/main/java/org/apache/calcite/rel/core/RelFactories.java
Patch:
@@ -206,6 +206,7 @@ RelNode createAggregate(RelNode input, boolean indicator,
    * that returns a vanilla {@link LogicalAggregate}.
    */
   private static class AggregateFactoryImpl implements AggregateFactory {
+    @SuppressWarnings("deprecation")
     public RelNode createAggregate(RelNode input, boolean indicator,
         ImmutableBitSet groupSet, ImmutableList<ImmutableBitSet> groupSets,
         List<AggregateCall> aggCalls) {

File: core/src/main/java/org/apache/calcite/rel/rules/AbstractMaterializedViewRule.java
Patch:
@@ -1053,7 +1053,7 @@ protected MaterializedViewAggregateRule(RelOptRuleOperand operand,
                         relBuilder.peek(), aggregate.getGroupCount() + i))));
       }
       RelNode result = relBuilder
-          .aggregate(relBuilder.groupKey(groupSet, false, null), aggregateCalls)
+          .aggregate(relBuilder.groupKey(groupSet, null), aggregateCalls)
           .build();
       if (topProject != null) {
         // Top project
@@ -1274,7 +1274,7 @@ protected MaterializedViewAggregateRule(RelOptRuleOperand operand,
         }
         result = relBuilder
             .push(result)
-            .aggregate(relBuilder.groupKey(groupSet, false, null), aggregateCalls)
+            .aggregate(relBuilder.groupKey(groupSet, null), aggregateCalls)
             .build();
         // We introduce a project on top, as group by columns order is lost
         List<RexNode> projects = new ArrayList<>();

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -106,7 +106,7 @@ public Integer apply(Integer a0) {
         RexUtil.apply(mapping, filter.getCondition());
     final Filter newFilter = filter.copy(filter.getTraitSet(),
         newAggregate, newCondition);
-    if (allColumnsInAggregate && !aggregate.indicator) {
+    if (allColumnsInAggregate && aggregate.getGroupSets().size() == 1) {
       // Everything needed by the filter is returned by the aggregate.
       assert newGroupSet.equals(aggregate.getGroupSet());
       call.transformTo(newFilter);
@@ -119,7 +119,7 @@ public Integer apply(Integer a0) {
         topGroupSet.set(newGroupSet.indexOf(c));
       }
       ImmutableList<ImmutableBitSet> newGroupingSets = null;
-      if (aggregate.indicator) {
+      if (aggregate.groupSets.size() > 1) {
         ImmutableList.Builder<ImmutableBitSet> newGroupingSetsBuilder =
                 ImmutableList.builder();
         for (ImmutableBitSet groupingSet : aggregate.getGroupSets()) {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -253,7 +253,7 @@ public void onMatch(RelOptRuleCall call) {
           }
         }
         side.newInput = relBuilder.push(joinInput)
-            .aggregate(relBuilder.groupKey(belowAggregateKey, false, null),
+            .aggregate(relBuilder.groupKey(belowAggregateKey, null),
                 belowAggCalls)
             .build();
       }
@@ -336,7 +336,7 @@ public Integer apply(Integer a0) {
     if (!aggConvertedToProjects) {
       relBuilder.aggregate(
           relBuilder.groupKey(Mappings.apply(mapping, aggregate.getGroupSet()),
-              aggregate.indicator, Mappings.apply2(mapping, aggregate.getGroupSets())),
+              Mappings.apply2(mapping, aggregate.getGroupSets())),
           newAggCalls);
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectMergeRule.java
Patch:
@@ -88,7 +88,7 @@ public static RelNode apply(RelOptRuleCall call, Aggregate aggregate,
 
     final ImmutableBitSet newGroupSet = aggregate.getGroupSet().permute(map);
     ImmutableList<ImmutableBitSet> newGroupingSets = null;
-    if (aggregate.indicator) {
+    if (aggregate.getGroupSets().size() > 1) {
       newGroupingSets =
           ImmutableBitSet.ORDERING.immutableSortedCopy(
               ImmutableBitSet.permute(aggregate.getGroupSets(), map));

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectPullUpConstantsRule.java
Patch:
@@ -153,9 +153,7 @@ public void onMatch(RelOptRuleCall call) {
           aggCall.adaptTo(input, aggCall.getArgList(), aggCall.filterArg,
               groupCount, newGroupCount));
     }
-    relBuilder.aggregate(
-        relBuilder.groupKey(newGroupSet, false, null),
-        newAggCalls);
+    relBuilder.aggregate(relBuilder.groupKey(newGroupSet, null), newAggCalls);
 
     // Create a projection back again.
     List<Pair<RexNode, String>> projects = new ArrayList<>();

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -560,7 +560,6 @@ protected void newAggregateRel(RelBuilder relBuilder,
       List<AggregateCall> newCalls) {
     relBuilder.aggregate(
         relBuilder.groupKey(oldAggregate.getGroupSet(),
-            oldAggregate.indicator,
             oldAggregate.getGroupSets()),
         newCalls);
   }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionAggregateRule.java
Patch:
@@ -104,7 +104,7 @@ public void onMatch(RelOptRuleCall call) {
     }
 
     relBuilder.union(true);
-    relBuilder.aggregate(relBuilder.groupKey(topAggRel.getGroupSet(), false, null),
+    relBuilder.aggregate(relBuilder.groupKey(topAggRel.getGroupSet(), null),
         topAggRel.getAggCallList());
     call.transformTo(relBuilder.build());
   }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -125,7 +125,7 @@ public void onMatch(RelOptRuleCall call) {
       relBuilder.push(input);
       if (!alreadyUnique) {
         ++transformCount;
-        relBuilder.aggregate(relBuilder.groupKey(aggRel.getGroupSet(), false, null),
+        relBuilder.aggregate(relBuilder.groupKey(aggRel.getGroupSet(), null),
             aggRel.getAggCallList());
       }
     }
@@ -140,7 +140,7 @@ public void onMatch(RelOptRuleCall call) {
     // create a new union whose children are the aggregates created above
     relBuilder.union(true, union.getInputs().size());
     relBuilder.aggregate(
-        relBuilder.groupKey(aggRel.getGroupSet(), aggRel.indicator, aggRel.getGroupSets()),
+        relBuilder.groupKey(aggRel.getGroupSet(), aggRel.getGroupSets()),
         transformedAggCalls);
     call.transformTo(relBuilder.build());
   }

File: core/src/main/java/org/apache/calcite/rel/rules/FilterAggregateTransposeRule.java
Patch:
@@ -137,7 +137,7 @@ private boolean canPush(Aggregate aggregate, ImmutableBitSet rCols) {
       return false;
     }
 
-    if (aggregate.indicator) {
+    if (aggregate.getGroupSets().size() > 1) {
       // If grouping sets are used, the filter can be pushed if
       // the columns referenced in the predicate are present in
       // all the grouping sets.

File: core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
Patch:
@@ -107,7 +107,7 @@ public void onMatch(RelOptRuleCall call) {
 
     final ImmutableBitSet groupSet =
         ImmutableBitSet.range(fieldCount - 1);
-    relBuilder.aggregate(relBuilder.groupKey(groupSet, false, null),
+    relBuilder.aggregate(relBuilder.groupKey(groupSet, null),
         relBuilder.countStar(null));
 
     // add a filter count(c) = #branches

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -320,9 +320,6 @@ ExInst<SqlValidatorException> naturalOrUsingColumnNotCompatible(String a0,
   @BaseMessage("Windowed aggregate expression is illegal in {0} clause")
   ExInst<SqlValidatorException> windowedAggregateIllegalInClause(String a0);
 
-  @BaseMessage("Aggregate expression is illegal in GROUP BY clause")
-  ExInst<SqlValidatorException> aggregateIllegalInGroupBy();
-
   @BaseMessage("Aggregate expressions cannot be nested")
   ExInst<SqlValidatorException> nestedAggIllegal();
 

File: core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
Patch:
@@ -248,7 +248,6 @@ public class Resolved {
     public final ImmutableList<SqlNode> groupExprList;
     public final ImmutableBitSet groupSet;
     public final ImmutableList<ImmutableBitSet> groupSets;
-    public final boolean indicator;
     public final Map<Integer, Integer> groupExprProjection;
 
     Resolved(List<SqlNode> extraExprList, List<SqlNode> groupExprList,
@@ -258,7 +257,6 @@ public class Resolved {
       this.groupExprList = ImmutableList.copyOf(groupExprList);
       this.groupSet = ImmutableBitSet.range(groupExprList.size());
       this.groupSets = ImmutableList.copyOf(groupSets);
-      this.indicator = !this.groupSets.equals(ImmutableList.of(groupSet));
       this.groupExprProjection = ImmutableMap.copyOf(groupExprProjection);
     }
 

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -873,8 +873,8 @@ public ImmutableBitSet apply(ImmutableBitSet input) {
       ++j;
     }
 
-    final RelBuilder.GroupKey groupKey = relBuilder.groupKey(newGroupSet,
-        aggregate.indicator, newGroupSets);
+    final RelBuilder.GroupKey groupKey =
+        relBuilder.groupKey(newGroupSet, newGroupSets);
     relBuilder.aggregate(groupKey, newAggCallList);
 
     return result(relBuilder.build(), mapping);

File: core/src/test/java/org/apache/calcite/plan/RelWriterTest.java
Patch:
@@ -138,8 +138,7 @@ public String apply(RelOptCluster cluster,
                 final RelDataType bigIntType =
                     cluster.getTypeFactory().createSqlType(SqlTypeName.BIGINT);
                 LogicalAggregate aggregate =
-                    LogicalAggregate.create(filter, false,
-                        ImmutableBitSet.of(0), null,
+                    LogicalAggregate.create(filter, ImmutableBitSet.of(0), null,
                         ImmutableList.of(
                             AggregateCall.create(SqlStdOperatorTable.COUNT,
                                 true, ImmutableList.of(1), -1, bigIntType,

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1280,7 +1280,7 @@ private void checkAverageRowSize(RelOptCluster cluster, RelOptTable empTable,
 
     // Aggregate
     final LogicalAggregate aggregate =
-        LogicalAggregate.create(join, false, ImmutableBitSet.of(2, 0),
+        LogicalAggregate.create(join, ImmutableBitSet.of(2, 0),
             ImmutableList.<ImmutableBitSet>of(),
             ImmutableList.of(
                 AggregateCall.create(
@@ -2162,7 +2162,7 @@ private void checkNodeTypeCount(String sql, Map<Class<? extends RelNode>, Intege
         + "group by grouping sets ((deptno), (ename, deptno))";
     final Map<Class<? extends RelNode>, Integer> expected = new HashMap<>();
     expected.put(TableScan.class, 1);
-    expected.put(Project.class, 3);
+    expected.put(Project.class, 2);
     expected.put(Aggregate.class, 1);
     checkNodeTypeCount(sql, expected);
   }

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.rel.type.RelDataTypeFieldImpl;
 import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.rel.type.RelRecordType;
+import org.apache.calcite.runtime.GeoFunctions;
 import org.apache.calcite.runtime.Unit;
 import org.apache.calcite.sql.type.BasicSqlType;
 import org.apache.calcite.sql.type.IntervalSqlType;
@@ -209,6 +210,8 @@ public Type getJavaClass(RelDataType type) {
       case BINARY:
       case VARBINARY:
         return ByteString.class;
+      case GEOMETRY:
+        return GeoFunctions.Geom.class;
       case ANY:
         return Object.class;
       }

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -55,6 +55,9 @@ public interface CalciteResource {
   @BaseMessage("BETWEEN operator has no terminating AND")
   ExInst<SqlValidatorException> betweenWithoutAnd();
 
+  @BaseMessage("Geo-spatial extensions and the GEOMETRY data type are not enabled")
+  ExInst<SqlValidatorException> geometryDisabled();
+
   @BaseMessage("Illegal INTERVAL literal {0}; at {1}")
   @Property(name = "SQLSTATE", value = "42000")
   ExInst<CalciteException> illegalIntervalLiteral(String a0, String a1);

File: core/src/main/java/org/apache/calcite/sql/type/ExtraSqlTypes.java
Patch:
@@ -42,6 +42,9 @@ public interface ExtraSqlTypes {
   int REF_CURSOR = 2012;
   int TIME_WITH_TIMEZONE = 2013;
   int TIMESTAMP_WITH_TIMEZONE = 2014;
+
+  // From OpenGIS
+  int GEOMETRY = 2015; // TODO: confirm
 }
 
 // End ExtraSqlTypes.java

File: core/src/main/java/org/apache/calcite/sql/type/JavaToSqlTypeConversionRules.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.sql.type;
 
 import org.apache.calcite.avatica.util.ArrayImpl;
+import org.apache.calcite.runtime.GeoFunctions;
 
 import com.google.common.collect.ImmutableMap;
 
@@ -70,6 +71,8 @@ public class JavaToSqlTypeConversionRules {
           .put(Time.class, SqlTypeName.TIME)
           .put(BigDecimal.class, SqlTypeName.DECIMAL)
 
+          .put(GeoFunctions.Geom.class, SqlTypeName.GEOMETRY)
+
           .put(ResultSet.class, SqlTypeName.CURSOR)
           .put(ColumnList.class, SqlTypeName.COLUMN_LIST)
           .put(ArrayImpl.class, SqlTypeName.ARRAY)

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRules.java
Patch:
@@ -161,6 +161,9 @@ private SqlTypeAssignmentRules() {
     // Timestamp is assignable from ...
     rules.put(SqlTypeName.TIMESTAMP, EnumSet.of(SqlTypeName.TIMESTAMP));
 
+    // Geometry is assignable from ...
+    rules.put(SqlTypeName.GEOMETRY, EnumSet.of(SqlTypeName.GEOMETRY));
+
     // Array is assignable from ...
     rules.put(SqlTypeName.ARRAY, EnumSet.of(SqlTypeName.ARRAY));
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -115,7 +115,8 @@ public enum SqlTypeName {
   COLUMN_LIST(PrecScale.NO_NO, false, Types.OTHER + 2,
       SqlTypeFamily.COLUMN_LIST),
   DYNAMIC_STAR(PrecScale.NO_NO | PrecScale.YES_NO | PrecScale.YES_YES, true,
-      Types.JAVA_OBJECT, SqlTypeFamily.ANY);
+      Types.JAVA_OBJECT, SqlTypeFamily.ANY),
+  GEOMETRY(PrecScale.NO_NO, true, ExtraSqlTypes.GEOMETRY, SqlTypeFamily.GEO);
 
   public static final int MAX_DATETIME_PRECISION = 3;
 

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -274,7 +274,7 @@ public AvaticaJsonHandler createHandler(Service service) {
   @Test public void testRemoteTypeInfo() throws Exception {
     CalciteAssert.hr().with(REMOTE_CONNECTION_FACTORY)
         .metaData(GET_TYPEINFO)
-        .returns(CalciteAssert.checkResultCount(is(42)));
+        .returns(CalciteAssert.checkResultCount(is(43)));
   }
 
   @Test public void testRemoteTableTypes() throws Exception {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java
Patch:
@@ -43,7 +43,7 @@ public SqlCovarAggFunction(SqlKind kind) {
     super(kind.name(),
         null,
         kind,
-        ReturnTypes.ARG0_NULLABLE_IF_EMPTY,
+        ReturnTypes.COVAR_FUNCTION,
         null,
         OperandTypes.NUMERIC_NUMERIC,
         SqlFunctionCategory.NUMERIC,

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraEnumerator.java
Patch:
@@ -42,7 +42,7 @@ class CassandraEnumerator implements Enumerator<Object> {
    * @param results Cassandra result set ({@link com.datastax.driver.core.ResultSet})
    * @param protoRowType The type of resulting rows
    */
-  public CassandraEnumerator(ResultSet results, RelProtoDataType protoRowType) {
+  CassandraEnumerator(ResultSet results, RelProtoDataType protoRowType) {
     this.iterator = results.iterator();
     this.current = null;
 

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java
Patch:
@@ -51,8 +51,8 @@
  * Relational expression representing a scan of a table in a Cassandra data source.
  */
 public class CassandraToEnumerableConverter
-  extends ConverterImpl
-  implements EnumerableRel {
+    extends ConverterImpl
+    implements EnumerableRel {
   protected CassandraToEnumerableConverter(
       RelOptCluster cluster,
       RelTraitSet traits,

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverterRule.java
Patch:
@@ -27,7 +27,7 @@
  */
 public class CassandraToEnumerableConverterRule extends ConverterRule {
   public static final ConverterRule INSTANCE =
-    new CassandraToEnumerableConverterRule();
+      new CassandraToEnumerableConverterRule();
 
   private CassandraToEnumerableConverterRule() {
     super(RelNode.class, CassandraRel.CONVENTION, EnumerableConvention.INSTANCE,

File: cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterIT.java
Patch:
@@ -47,7 +47,7 @@ public class CassandraAdapterIT {
    * included if "it" profile is activated ({@code -Pit}). To disable,
    * specify {@code -Dcalcite.test.cassandra=false} on the Java command line. */
   public static final boolean ENABLED =
-     Util.getBooleanProperty("calcite.test.cassandra", true);
+      Util.getBooleanProperty("calcite.test.cassandra", true);
 
   /** Whether to run this test. */
   protected boolean enabled() {

File: core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
Patch:
@@ -50,7 +50,7 @@ class ColumnLoader<T> {
   static final int[] INT_B = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};
   static final int[] INT_S = {1, 2, 4, 8, 16};
   static final long[] LONG_B = {
-    0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000, 0xFFFFFFFF00000000L};
+      0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000, 0xFFFFFFFF00000000L};
   static final int[] LONG_S = {1, 2, 4, 8, 16, 32};
 
   private static final Function<Timestamp, Long> TIMESTAMP_TO_LONG =
@@ -461,7 +461,7 @@ private static class Kev implements Comparable<Kev> {
     private final int source;
     private final Comparable key;
 
-    public Kev(int source, Comparable key) {
+    Kev(int source, Comparable key) {
       this.source = source;
       this.key = key;
     }

File: core/src/main/java/org/apache/calcite/adapter/clone/ListTable.java
Patch:
@@ -48,7 +48,7 @@ class ListTable extends AbstractQueryableTable {
   private final List list;
 
   /** Creates a ListTable. */
-  public ListTable(
+  ListTable(
       Type elementType,
       RelProtoDataType protoRowType,
       Expression expression,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java
Patch:
@@ -186,7 +186,7 @@ private static class EnumerableNode implements Node {
     private final Enumerable<Object[]> enumerable;
     private final Sink sink;
 
-    public EnumerableNode(Enumerable<Object[]> enumerable,
+    EnumerableNode(Enumerable<Object[]> enumerable,
         Interpreter interpreter, EnumerableInterpretable rel) {
       this.enumerable = enumerable;
       this.sink = interpreter.sink(rel);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -276,7 +276,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
 
       final List<Expression> outputRow = new ArrayList<Expression>();
       int fieldCountWithAggResults =
-        inputPhysType.getRowType().getFieldCount();
+          inputPhysType.getRowType().getFieldCount();
       for (int i = 0; i < fieldCountWithAggResults; i++) {
         outputRow.add(
             inputPhysType.fieldReference(
@@ -520,7 +520,7 @@ public List<RexNode> apply(AggImpState agg) {
   }
 
   private Function<BlockBuilder, WinAggFrameResultContext>
-  getBlockBuilderWinAggFrameResultContextFunction(
+      getBlockBuilderWinAggFrameResultContextFunction(
       final JavaTypeFactory typeFactory, final Result result,
       final List<Expression> translatedConstants,
       final Expression comparator_,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/WinAggImplementor.java
Patch:
@@ -35,7 +35,7 @@ public interface WinAggImplementor extends AggImplementor {
    * Allows to access rows in window partition relative to first/last and
    * current row.
    */
-  public enum SeekType {
+  enum SeekType {
     /**
      * Start of window.
      * @see WinAggFrameContext#startIndex()

File: core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
Patch:
@@ -358,7 +358,9 @@ public TranslatableTable apply(final List<Object> arguments) {
     }
   }
 
-  /** Table based on a Java field. */
+  /** Table based on a Java field.
+   *
+   * @param <T> element type */
   private static class FieldTable<T> extends ReflectiveTable {
     private final Field field;
     private Statistic statistic;

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
Patch:
@@ -128,7 +128,7 @@ public static List<RelOptRule> rules(JdbcConvention out) {
   abstract static class JdbcConverterRule extends ConverterRule {
     protected final JdbcConvention out;
 
-    public JdbcConverterRule(Class<? extends RelNode> clazz, RelTrait in,
+    JdbcConverterRule(Class<? extends RelNode> clazz, RelTrait in,
         JdbcConvention out, String description) {
       super(clazz, in, out, description);
       this.out = out;

File: core/src/main/java/org/apache/calcite/interpreter/AbstractSingleNode.java
Patch:
@@ -28,7 +28,7 @@ abstract class AbstractSingleNode<T extends SingleRel> implements Node {
   protected final Sink sink;
   protected final T rel;
 
-  public AbstractSingleNode(Interpreter interpreter, T rel) {
+  AbstractSingleNode(Interpreter interpreter, T rel) {
     this.rel = rel;
     this.source = interpreter.source(rel, 0);
     this.sink = interpreter.sink(rel);

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -322,7 +322,7 @@ private static class NodeInfo {
     final Enumerable<Row> rowEnumerable;
     Node node;
 
-    public NodeInfo(RelNode rel, Sink sink, Enumerable<Row> rowEnumerable) {
+    NodeInfo(RelNode rel, Sink sink, Enumerable<Row> rowEnumerable) {
       this.rel = rel;
       this.sink = sink;
       this.rowEnumerable = rowEnumerable;
@@ -337,7 +337,7 @@ public NodeInfo(RelNode rel, Sink sink, Enumerable<Row> rowEnumerable) {
   private static class EnumeratorSource implements Source {
     private final Enumerator<Row> enumerator;
 
-    public EnumeratorSource(final Enumerator<Row> enumerator) {
+    EnumeratorSource(final Enumerator<Row> enumerator) {
       this.enumerator = Preconditions.checkNotNull(enumerator);
     }
 
@@ -386,7 +386,7 @@ public void end() throws InterruptedException {
   private static class ListSource implements Source {
     private final ArrayDeque<Row> list;
 
-    public ListSource(ListSink sink) {
+    ListSource(ListSink sink) {
       this.list = sink.list;
     }
 

File: core/src/main/java/org/apache/calcite/jdbc/CachingCalciteSchema.java
Patch:
@@ -242,7 +242,9 @@ private interface Cached<T> {
   }
 
   /** Implementation of {@link CachingCalciteSchema.Cached}
-   * that drives from {@link CachingCalciteSchema#cache}. */
+   * that drives from {@link CachingCalciteSchema#cache}.
+   *
+   * @param <T> element type */
   private abstract class AbstractCached<T> implements Cached<T> {
     T t;
     long checked = Long.MIN_VALUE;

File: core/src/main/java/org/apache/calcite/jdbc/CalciteJdbc41Factory.java
Patch:
@@ -117,7 +117,7 @@ private static class CalciteJdbc41Connection extends CalciteConnectionImpl {
 
   /** Implementation of statement for JDBC 4.1. */
   private static class CalciteJdbc41Statement extends CalciteStatement {
-    public CalciteJdbc41Statement(CalciteConnectionImpl connection,
+    CalciteJdbc41Statement(CalciteConnectionImpl connection,
         Meta.StatementHandle h, int resultSetType, int resultSetConcurrency,
         int resultSetHoldability) {
       super(connection, h, resultSetType, resultSetConcurrency,

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -60,7 +60,7 @@ public class JavaTypeFactoryImpl
     extends SqlTypeFactoryImpl
     implements JavaTypeFactory {
   private final Map<List<Pair<Type, Boolean>>, SyntheticRecordType>
-  syntheticTypes = new HashMap<>();
+      syntheticTypes = new HashMap<>();
 
   public JavaTypeFactoryImpl() {
     this(RelDataTypeSystem.DEFAULT);
@@ -356,7 +356,7 @@ private static class RecordFieldImpl implements Types.RecordField {
     private final boolean nullable;
     private final int modifiers;
 
-    public RecordFieldImpl(
+    RecordFieldImpl(
         SyntheticRecordType syntheticType,
         String name,
         Type type,

File: core/src/main/java/org/apache/calcite/materialize/CachingLatticeStatisticProvider.java
Patch:
@@ -34,7 +34,7 @@ class CachingLatticeStatisticProvider implements LatticeStatisticProvider {
   private final LoadingCache<Pair<Lattice, Lattice.Column>, Integer> cache;
 
   /** Creates a CachingStatisticProvider. */
-  public CachingLatticeStatisticProvider(
+  CachingLatticeStatisticProvider(
       final LatticeStatisticProvider provider) {
     cache = CacheBuilder.<Pair<Lattice, Lattice.Column>>newBuilder()
         .build(

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -445,7 +445,7 @@ public Edge createEdge(RelNode source, RelNode target) {
 
     final List<IntPair> pairs = Lists.newArrayList();
 
-    public Edge(RelNode source, RelNode target) {
+    Edge(RelNode source, RelNode target) {
       super(source, target);
     }
 

File: core/src/main/java/org/apache/calcite/materialize/TileSuggester.java
Patch:
@@ -99,7 +99,7 @@ private static class SchemaImpl implements Schema {
     private final TableImpl table;
     private final ImmutableList<AttributeImpl> attributes;
 
-    public SchemaImpl(Lattice lattice, StatisticsProvider statisticsProvider) {
+    SchemaImpl(Lattice lattice, StatisticsProvider statisticsProvider) {
       this.statisticsProvider = statisticsProvider;
       this.table = new TableImpl();
       final ImmutableList.Builder<AttributeImpl> attributeBuilder =
@@ -197,7 +197,7 @@ public List<Attribute> getAncestorAttributes() {
   private static class StatisticsProviderImpl implements StatisticsProvider {
     private final Lattice lattice;
 
-    public StatisticsProviderImpl(Lattice lattice) {
+    StatisticsProviderImpl(Lattice lattice) {
       this.lattice = lattice;
     }
 

File: core/src/main/java/org/apache/calcite/plan/ConventionTraitDef.java
Patch:
@@ -221,8 +221,7 @@ private static final class ConversionData {
      * conversion rules. Maps {@link DefaultEdge} to a
      * collection of {@link ConverterRule} objects.
      */
-    final Multimap<Pair<Convention, Convention>, ConverterRule>
-    mapArcToConverterRule =
+    final Multimap<Pair<Convention, Convention>, ConverterRule> mapArcToConverterRule =
         HashMultimap.create();
 
     private Graphs.FrozenGraph<Convention, DefaultEdge> pathMap;

File: core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
Patch:
@@ -131,7 +131,9 @@ public int size() {
     return traits.length;
   }
 
-  /** Composite trait with 0 elements. */
+  /** Composite trait with 0 elements.
+   *
+   * @param <T> trait type */
   private static class EmptyCompositeTrait<T extends RelMultipleTrait>
       extends RelCompositeTrait<T> {
     private EmptyCompositeTrait(RelTraitDef traitDef) {

File: core/src/main/java/org/apache/calcite/plan/RelOptRule.java
Patch:
@@ -225,7 +225,7 @@ public static <R extends RelNode> RelOptRuleOperand operand(
    * @param predicate Predicate to apply to relational expression
    */
   protected static <R extends RelNode> ConverterRelOptRuleOperand
-  convertOperand(Class<R> clazz, Predicate<? super R> predicate,
+      convertOperand(Class<R> clazz, Predicate<? super R> predicate,
       RelTrait trait) {
     return new ConverterRelOptRuleOperand(clazz, trait, predicate);
   }

File: core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
Patch:
@@ -523,7 +523,9 @@ private InputRefUsage<SqlOperator, RexNode> getUsageMap(RexInputRef rex) {
 
   /**
    * Usage of a {@link RexInputRef} in an expression.
-   */
+   *
+   * @param <T1> left type
+   * @param <T2> right type */
   private static class InputRefUsage<T1, T2> {
     private final List<Pair<T1, T2>> usageList = new ArrayList<>();
     private int usageCount = 0;

File: core/src/main/java/org/apache/calcite/plan/TableAccessMap.java
Patch:
@@ -38,7 +38,7 @@ public class TableAccessMap {
   //~ Enums ------------------------------------------------------------------
 
   /** Access mode. */
-  public static enum Mode {
+  public enum Mode {
     /**
      * Table is not accessed at all.
      */

File: core/src/main/java/org/apache/calcite/plan/hep/HepInstruction.java
Patch:
@@ -38,7 +38,9 @@ void initialize(boolean clearCache) {
 
   //~ Inner Classes ----------------------------------------------------------
 
-  /** Instruction that executes all rules of a given class. */
+  /** Instruction that executes all rules of a given class.
+   *
+   * @param <R> rule type */
   static class RuleClass<R extends RelOptRule> extends HepInstruction {
     Class<R> ruleClass;
 

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -139,7 +139,7 @@ public class VolcanoPlanner extends AbstractRelOptPlanner {
    * operands based on the class of the RelNode.</p>
    */
   private final Multimap<Class<? extends RelNode>, RelOptRuleOperand>
-  classOperands = LinkedListMultimap.create();
+      classOperands = LinkedListMultimap.create();
 
   /**
    * List of all sets. Used only for debugging.
@@ -282,7 +282,7 @@ public VolcanoPlanner(RelOptCostFactory costFactory, //
   //~ Methods ----------------------------------------------------------------
 
   protected VolcanoPlannerPhaseRuleMappingInitializer
-  getPhaseRuleMappingInitializer() {
+      getPhaseRuleMappingInitializer() {
     return new VolcanoPlannerPhaseRuleMappingInitializer() {
       public void initialize(
           Map<VolcanoPlannerPhase, Set<String>> phaseRuleMap) {

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -58,7 +58,7 @@
  * Context for populating a {@link Prepare.Materialization}.
  */
 class CalciteMaterializer extends CalcitePrepareImpl.CalcitePreparingStmt {
-  public CalciteMaterializer(CalcitePrepareImpl prepare,
+  CalciteMaterializer(CalcitePrepareImpl prepare,
       CalcitePrepare.Context context,
       CatalogReader catalogReader, CalciteSchema schema,
       RelOptPlanner planner, SqlRexConvertletTable convertletTable) {

File: core/src/main/java/org/apache/calcite/prepare/CalciteSqlValidator.java
Patch:
@@ -25,7 +25,7 @@
 
 /** Validator. */
 class CalciteSqlValidator extends SqlValidatorImpl {
-  public CalciteSqlValidator(SqlOperatorTable opTab,
+  CalciteSqlValidator(SqlOperatorTable opTab,
       CalciteCatalogReader catalogReader, JavaTypeFactory typeFactory,
       SqlConformance conformance) {
     super(opTab, catalogReader, typeFactory, conformance);

File: core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
Patch:
@@ -54,7 +54,7 @@ class LixToRelTranslator implements RelOptTable.ToRelContext {
   private final Prepare preparingStmt;
   final JavaTypeFactory typeFactory;
 
-  public LixToRelTranslator(RelOptCluster cluster, Prepare preparingStmt) {
+  LixToRelTranslator(RelOptCluster cluster, Prepare preparingStmt) {
     this.cluster = cluster;
     this.preparingStmt = preparingStmt;
     this.typeFactory = (JavaTypeFactory) cluster.getTypeFactory();

File: core/src/main/java/org/apache/calcite/prepare/QueryableRelBuilder.java
Patch:
@@ -78,7 +78,7 @@ class QueryableRelBuilder<T> implements QueryableFactory<T> {
   private final LixToRelTranslator translator;
   private RelNode rel;
 
-  public QueryableRelBuilder(LixToRelTranslator translator) {
+  QueryableRelBuilder(LixToRelTranslator translator) {
     this.translator = translator;
   }
 

File: core/src/main/java/org/apache/calcite/prepare/RelOptTableImpl.java
Patch:
@@ -337,7 +337,7 @@ private static class MySchemaPlus implements SchemaPlus {
     private final String name;
     private final Schema schema;
 
-    public MySchemaPlus(SchemaPlus parent, String name, Schema schema) {
+    MySchemaPlus(SchemaPlus parent, String name, Schema schema) {
       this.parent = parent;
       this.name = name;
       this.schema = schema;

File: core/src/main/java/org/apache/calcite/rel/core/Match.java
Patch:
@@ -132,8 +132,8 @@ protected Match(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,
 
   /** Creates an immutable map of a map of sorted sets. */
   private static <K extends Comparable<K>, V>
-  ImmutableSortedMap<K, SortedSet<V>> copyMap(
-      Map<K, ? extends SortedSet<V>> map) {
+      ImmutableSortedMap<K, SortedSet<V>>
+      copyMap(Map<K, ? extends SortedSet<V>> map) {
     final ImmutableSortedMap.Builder<K, SortedSet<V>> b =
         ImmutableSortedMap.naturalOrder();
     for (Map.Entry<K, ? extends SortedSet<V>> e : map.entrySet()) {

File: core/src/main/java/org/apache/calcite/rel/core/RelFactories.java
Patch:
@@ -71,10 +71,10 @@ public class RelFactories {
       new SemiJoinFactoryImpl();
 
   public static final SortFactory DEFAULT_SORT_FACTORY =
-    new SortFactoryImpl();
+      new SortFactoryImpl();
 
   public static final AggregateFactory DEFAULT_AGGREGATE_FACTORY =
-    new AggregateFactoryImpl();
+      new AggregateFactoryImpl();
 
   public static final MatchFactory DEFAULT_MATCH_FACTORY =
       new MatchFactoryImpl();

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -405,7 +405,7 @@ private boolean simplyProjects(RelNode rel, ImmutableBitSet columns) {
 
   /** Splits a column set between left and right sets. */
   private static Pair<ImmutableBitSet, ImmutableBitSet>
-  splitLeftAndRightColumns(int leftCount, final ImmutableBitSet columns) {
+      splitLeftAndRightColumns(int leftCount, final ImmutableBitSet columns) {
     ImmutableBitSet.Builder leftBuilder = ImmutableBitSet.builder();
     ImmutableBitSet.Builder rightBuilder = ImmutableBitSet.builder();
     for (int bit : columns) {

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
Patch:
@@ -500,7 +500,7 @@ static class JoinConditionBasedPredicateInference {
     final RexNode leftChildPredicates;
     final RexNode rightChildPredicates;
 
-    public JoinConditionBasedPredicateInference(Join joinRel,
+    JoinConditionBasedPredicateInference(Join joinRel,
             RexNode lPreds, RexNode rPreds) {
       this(joinRel, joinRel instanceof SemiJoin, lPreds, rPreds);
     }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
Patch:
@@ -757,7 +757,7 @@ private static class CardOfProjExpr extends RexVisitorImpl<Double> {
     private final RelMetadataQuery mq;
     private Project rel;
 
-    public CardOfProjExpr(RelMetadataQuery mq, Project rel) {
+    CardOfProjExpr(RelMetadataQuery mq, Project rel) {
       super(true);
       this.mq = mq;
       this.rel = rel;

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
Patch:
@@ -199,7 +199,7 @@ private RelMetadataQuery(boolean dummy) {
   /** Re-generates the handler for a given kind of metadata, adding support for
    * {@code class_} if it is not already present. */
   protected <M extends Metadata, H extends MetadataHandler<M>> H
-  revise(Class<? extends RelNode> class_, MetadataDef<M> def) {
+      revise(Class<? extends RelNode> class_, MetadataDef<M> def) {
     return metadataProvider.revise(class_, def);
   }
 

File: core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
Patch:
@@ -310,7 +310,7 @@ public Result visit(TableModify modify) {
 
     // Target Table Name
     final SqlIdentifier sqlTargetTable =
-      new SqlIdentifier(modify.getTable().getQualifiedName(), POS);
+        new SqlIdentifier(modify.getTable().getQualifiedName(), POS);
 
     switch (modify.getOperation()) {
     case INSERT: {

File: core/src/main/java/org/apache/calcite/rel/rules/AbstractMaterializedViewRule.java
Patch:
@@ -2186,7 +2186,7 @@ public Edge createEdge(RelTableRef source, RelTableRef target) {
     final Multimap<RexTableInputRef, RexTableInputRef> equiColumns =
         ArrayListMultimap.create();
 
-    public Edge(RelTableRef source, RelTableRef target) {
+    Edge(RelTableRef source, RelTableRef target) {
       super(source, target);
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateJoinTransposeRule.java
Patch:
@@ -391,8 +391,8 @@ private static void populateEquivalence(Map<Integer, BitSet> equivalence,
 
   /** Creates a {@link org.apache.calcite.sql.SqlSplittableAggFunction.Registry}
    * that is a view of a list. */
-  private static <E> SqlSplittableAggFunction.Registry<E>
-  registry(final List<E> list) {
+  private static <E> SqlSplittableAggFunction.Registry<E> registry(
+      final List<E> list) {
     return new SqlSplittableAggFunction.Registry<E>() {
       public int register(E e) {
         int i = list.indexOf(e);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -56,7 +56,7 @@ public class AggregateUnionTransposeRule extends RelOptRule {
           LogicalUnion.class, RelFactories.LOGICAL_BUILDER);
 
   private static final Map<Class<? extends SqlAggFunction>, Boolean>
-  SUPPORTED_AGGREGATES = new IdentityHashMap<>();
+      SUPPORTED_AGGREGATES = new IdentityHashMap<>();
 
   static {
     SUPPORTED_AGGREGATES.put(SqlMinMaxAggFunction.class, true);

File: core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
Patch:
@@ -823,7 +823,7 @@ public boolean canImplement(RexProgram program) {
   private static class ImplementTester extends RexVisitorImpl<Void> {
     private final RelType relType;
 
-    public ImplementTester(RelType relType) {
+    ImplementTester(RelType relType) {
       super(false);
       this.relType = relType;
     }
@@ -876,7 +876,7 @@ private static class InputToCommonExprConverter extends RexShuttle {
     private final int[] inputExprOrdinals;
     private final RexNode[] allExprs;
 
-    public InputToCommonExprConverter(
+    InputToCommonExprConverter(
         int[] exprInverseOrdinals,
         int[] exprLevels,
         int level,
@@ -959,7 +959,7 @@ private static class HighestUsageFinder extends RexVisitorImpl<Void> {
     private final int[] maxUsingLevelOrdinals;
     private int currentLevel;
 
-    public HighestUsageFinder(RexNode[] exprs, int[] exprLevels) {
+    HighestUsageFinder(RexNode[] exprs, int[] exprLevels) {
       super(true);
       this.maxUsingLevelOrdinals = new int[exprs.length];
       Arrays.fill(maxUsingLevelOrdinals, -1);

File: core/src/main/java/org/apache/calcite/rel/rules/FilterRemoveIsNotDistinctFromRule.java
Patch:
@@ -87,7 +87,7 @@ public void onMatch(RelOptRuleCall call) {
   private class RemoveIsNotDistinctFromRexShuttle extends RexShuttle {
     RexBuilder rexBuilder;
 
-    public RemoveIsNotDistinctFromRexShuttle(
+    RemoveIsNotDistinctFromRexShuttle(
         RexBuilder rexBuilder) {
       this.rexBuilder = rexBuilder;
     }

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
Patch:
@@ -544,7 +544,7 @@ private List<RexNode> combinePostJoinFilters(
   private class InputReferenceCounter extends RexVisitorImpl<Void> {
     private final int[] refCounts;
 
-    public InputReferenceCounter(int[] refCounts) {
+    InputReferenceCounter(int[] refCounts) {
       super(true);
       this.refCounts = refCounts;
     }

File: core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
Patch:
@@ -824,7 +824,7 @@ private static class LcsTableScan {
 
   /** Dummy class to allow code to compile. */
   private static class LcsIndexOptimizer {
-    public LcsIndexOptimizer(LcsTableScan rel) {}
+    LcsIndexOptimizer(LcsTableScan rel) {}
 
     public FemLocalIndex findSemiJoinIndexByCost(RelNode dimRel,
         List<Integer> actualLeftKeys, List<Integer> rightKeys,

File: core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
Patch:
@@ -621,7 +621,7 @@ private class InputSpecialOpFinder extends RexVisitorImpl<Void> {
     private final List<RexNode> preserveRight;
     private final Strong strong;
 
-    public InputSpecialOpFinder(
+    InputSpecialOpFinder(
         BitSet rexRefs,
         ImmutableBitSet leftFields,
         ImmutableBitSet rightFields,
@@ -716,7 +716,7 @@ private class RefAndExprConverter extends RelOptUtil.RexInputConverter {
     private final List<RexNode> preserveRight;
     private final int firstRightRef;
 
-    public RefAndExprConverter(
+    RefAndExprConverter(
         RexBuilder rexBuilder,
         List<RelDataTypeField> srcFields,
         List<RelDataTypeField> destFields,
@@ -850,7 +850,7 @@ class OperatorExprCondition extends ExprConditionImpl {
      *
      * @param operatorSet Set of operators
      */
-    public OperatorExprCondition(Iterable<? extends SqlOperator> operatorSet) {
+    OperatorExprCondition(Iterable<? extends SqlOperator> operatorSet) {
       this.operatorSet = ImmutableSet.copyOf(operatorSet);
     }
 

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -402,7 +402,7 @@ private static class ReplaceSubQueryShuttle extends RexShuttle {
     private final RexSubQuery subQuery;
     private final RexNode replacement;
 
-    public ReplaceSubQueryShuttle(RexSubQuery subQuery, RexNode replacement) {
+    ReplaceSubQueryShuttle(RexSubQuery subQuery, RexNode replacement) {
       this.subQuery = subQuery;
       this.replacement = replacement;
     }

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystemImpl.java
Patch:
@@ -201,7 +201,7 @@ public int getMaxScale(SqlTypeName typeName) {
 
   @Override public int getNumTypeRadix(SqlTypeName typeName) {
     if (typeName.getFamily() == SqlTypeFamily.NUMERIC
-      && getDefaultPrecision(typeName) != -1) {
+        && getDefaultPrecision(typeName) != -1) {
       return 10;
     }
     return 0;

File: core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
Patch:
@@ -138,7 +138,7 @@ public CalciteException newError(
   private static class RexCastCallBinding extends RexCallBinding {
     private final RelDataType type;
 
-    public RexCastCallBinding(
+    RexCastCallBinding(
         RelDataTypeFactory typeFactory,
         SqlOperator sqlOperator, List<? extends RexNode> operands,
         RelDataType type,

File: core/src/main/java/org/apache/calcite/rex/RexExecutorImpl.java
Patch:
@@ -138,7 +138,7 @@ private static class DataContextInputGetter implements InputGetter {
     private final RelDataTypeFactory typeFactory;
     private final RelDataType rowType;
 
-    public DataContextInputGetter(RelDataType rowType,
+    DataContextInputGetter(RelDataType rowType,
         RelDataTypeFactory typeFactory) {
       this.rowType = rowType;
       this.typeFactory = typeFactory;

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -177,7 +177,7 @@ private static class OverFound extends ControlFlowException {
    * and it can be re-used for multiple visits.
    */
   private static class Finder extends RexVisitorImpl<Void> {
-    public Finder() {
+    Finder() {
       super(true);
     }
 

File: core/src/main/java/org/apache/calcite/rex/RexProgram.java
Patch:
@@ -807,7 +807,7 @@ static class Checker extends RexChecker {
      *                             or null
      * @param litmus               Whether to fail
      */
-    public Checker(RelDataType inputRowType,
+    Checker(RelDataType inputRowType,
         List<RelDataType> internalExprTypeList, RelNode.Context context,
         Litmus litmus) {
       super(inputRowType, context, litmus);
@@ -841,7 +841,7 @@ public Checker(RelDataType inputRowType,
   static class ExpansionShuttle extends RexShuttle {
     private final List<RexNode> exprs;
 
-    public ExpansionShuttle(List<RexNode> exprs) {
+    ExpansionShuttle(List<RexNode> exprs) {
       this.exprs = exprs;
     }
 

File: core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
Patch:
@@ -1013,7 +1013,7 @@ public RexNode visitLocalRef(RexLocalRef local) {
   private class RegisterOutputShuttle extends RegisterShuttle {
     private final List<RexNode> localExprList;
 
-    public RegisterOutputShuttle(List<RexNode> localExprList) {
+    RegisterOutputShuttle(List<RexNode> localExprList) {
       super();
       this.localExprList = localExprList;
     }

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -564,8 +564,7 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
 
   @BaseMessage("Execution of a new autocommit statement while a cursor is still open on same connection is not supported")
   @Property(name = "FeatureDefinition", value = "Eigenbase-defined")
-  ExInst<CalciteException>
-  sQLConformance_MultipleActiveAutocommitStatements();
+  ExInst<CalciteException> sQLConformance_MultipleActiveAutocommitStatements();
 
   @BaseMessage("Descending sort (ORDER BY DESC) not supported")
   @Property(name = "FeatureDefinition", value = "Eigenbase-defined")

File: core/src/main/java/org/apache/calcite/runtime/Enumerables.java
Patch:
@@ -61,8 +61,8 @@ public static Enumerable<Row> toRow(final Enumerable<Object[]> enumerable) {
 
   /** Converts a supplier of an {@link Enumerable} over object arrays into a
    * supplier of an {@link Enumerable} over {@link Row} objects. */
-  public static Supplier<Enumerable<Row>>
-  toRow(final Supplier<Enumerable<Object[]>> supplier) {
+  public static Supplier<Enumerable<Row>> toRow(
+      final Supplier<Enumerable<Object[]>> supplier) {
     return new Supplier<Enumerable<Row>>() {
       public Enumerable<Row> get() {
         return toRow(supplier.get());

File: core/src/main/java/org/apache/calcite/schema/Schemas.java
Patch:
@@ -461,8 +461,8 @@ public RelDataType apply(RelDataTypeFactory typeFactory) {
   /** Returns the star tables defined in a schema.
    *
    * @param schema Schema */
-  public static List<CalciteSchema.TableEntry>
-  getStarTables(CalciteSchema schema) {
+  public static List<CalciteSchema.TableEntry> getStarTables(
+      CalciteSchema schema) {
     final List<CalciteSchema.LatticeEntry> list = getLatticeEntries(schema);
     return Lists.transform(list, TO_TABLE_ENTRY);
   }

File: core/src/main/java/org/apache/calcite/schema/TableFunction.java
Patch:
@@ -40,7 +40,7 @@ public interface TableFunction extends Function {
    * @return row type of the table
    */
   RelDataType getRowType(RelDataTypeFactory typeFactory,
-    List<Object> arguments);
+      List<Object> arguments);
 
   /**
    * Returns the row type of the table yielded by this function when

File: core/src/main/java/org/apache/calcite/sql/SqlDescribeSchema.java
Patch:
@@ -67,7 +67,9 @@ public SqlDescribeSchema(SqlParserPos pos, SqlIdentifier schema) {
     return ImmutableNullableList.<SqlNode>of(schema);
   }
 
-  public SqlIdentifier getSchema() { return schema; }
+  public SqlIdentifier getSchema() {
+    return schema;
+  }
 }
 
 // End SqlDescribeSchema.java

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -408,8 +408,8 @@ public void quoteStringLiteralUnicode(StringBuilder buf, String val) {
   }
 
   private static final char[] HEXITS = {
-    '0', '1', '2', '3', '4', '5', '6', '7',
-    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
+      '0', '1', '2', '3', '4', '5', '6', '7',
+      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
   };
 
   /**

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -413,7 +413,7 @@ private void checkLeadFieldInRange(RelDataTypeSystem typeSystem, int sign,
   }
 
   private static final BigDecimal[] POWERS10 = {
-    ZERO,
+      ZERO,
     BigDecimal.valueOf(10),
     BigDecimal.valueOf(100),
     BigDecimal.valueOf(1000),

File: core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java
Patch:
@@ -336,7 +336,7 @@ private SqlMatchRecognizeOperator() {
         writer.newlineAndIndent();
         writer.sep("ORDER BY");
         final SqlWriter.Frame orderFrame =
-          writer.startList(SqlWriter.FrameTypeEnum.ORDER_BY_LIST);
+            writer.startList(SqlWriter.FrameTypeEnum.ORDER_BY_LIST);
         unparseListClause(writer, pattern.orderList);
         writer.endList(orderFrame);
       }

File: core/src/main/java/org/apache/calcite/sql/SqlSplittableAggFunction.java
Patch:
@@ -95,7 +95,9 @@ RexNode singleton(RexBuilder rexBuilder, RelDataType inputRowType,
       AggregateCall aggregateCall);
 
   /** Collection in which one can register an element. Registering may return
-   * a reference to an existing element. */
+   * a reference to an existing element.
+   *
+   * @param <E> element type */
   interface Registry<E> {
     int register(E e);
   }

File: core/src/main/java/org/apache/calcite/sql/SqlUtil.java
Patch:
@@ -383,9 +383,8 @@ public static SqlOperator lookupRoutine(SqlOperatorTable opTab,
     return null;
   }
 
-  private static Iterator<SqlOperator>
-  filterOperatorRoutinesByKind(Iterator<SqlOperator> routines,
-      final SqlKind sqlKind) {
+  private static Iterator<SqlOperator> filterOperatorRoutinesByKind(
+      Iterator<SqlOperator> routines, final SqlKind sqlKind) {
     return Iterators.filter(routines,
         new PredicateImpl<SqlOperator>() {
           public boolean test(SqlOperator input) {

File: core/src/main/java/org/apache/calcite/sql/SqlWithItem.java
Patch:
@@ -76,7 +76,7 @@ private static class SqlWithItemOperator extends SqlSpecialOperator {
     private static final SqlWithItemOperator INSTANCE =
         new SqlWithItemOperator();
 
-    public SqlWithItemOperator() {
+    SqlWithItemOperator() {
       super("WITH_ITEM", SqlKind.WITH_ITEM, 0);
     }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlArgumentAssignmentOperator.java
Patch:
@@ -35,7 +35,7 @@
  * consistent with AS, we reverse the arguments.
  */
 class SqlArgumentAssignmentOperator extends SqlAsOperator {
-  public SqlArgumentAssignmentOperator() {
+  SqlArgumentAssignmentOperator() {
     super("=>", SqlKind.ARGUMENT_ASSIGNMENT, 20, true, ReturnTypes.ARG0,
         InferTypes.RETURN_TYPE, OperandTypes.ANY_ANY);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlDefaultOperator.java
Patch:
@@ -33,7 +33,7 @@
  * has chance to resolve arguments.
  */
 class SqlDefaultOperator extends SqlSpecialOperator {
-  public SqlDefaultOperator() {
+  SqlDefaultOperator() {
     super("DEFAULT", SqlKind.DEFAULT, 100, true,
         ReturnTypes.explicit(SqlTypeName.ANY), InferTypes.RETURN_TYPE,
         OperandTypes.NILADIC);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlExtendOperator.java
Patch:
@@ -34,7 +34,7 @@
  * achieve schema-on-query against other adapters.
  */
 class SqlExtendOperator extends SqlInternalOperator {
-  public SqlExtendOperator() {
+  SqlExtendOperator() {
     super("EXTEND", SqlKind.EXTEND, MDX_PRECEDENCE);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlGroupIdFunction.java
Patch:
@@ -30,7 +30,7 @@
  * <p>Some examples are in {@code agg.iq}.
  */
 class SqlGroupIdFunction extends SqlAbstractGroupFunction {
-  public SqlGroupIdFunction() {
+  SqlGroupIdFunction() {
     super("GROUP_ID", SqlKind.GROUP_ID, ReturnTypes.BIGINT, null,
         OperandTypes.NILADIC, SqlFunctionCategory.SYSTEM);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlGroupingFunction.java
Patch:
@@ -30,7 +30,7 @@
  * <p>Some examples are in {@code agg.iq}.
  */
 class SqlGroupingFunction extends SqlAbstractGroupFunction {
-  public SqlGroupingFunction(String name) {
+  SqlGroupingFunction(String name) {
     super(name, SqlKind.GROUPING, ReturnTypes.BIGINT, null,
         OperandTypes.ONE_OR_MORE, SqlFunctionCategory.SYSTEM);
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlGroupingIdFunction.java
Patch:
@@ -34,7 +34,7 @@
  */
 @Deprecated // to be removed before 2.0
 class SqlGroupingIdFunction extends SqlAbstractGroupFunction {
-  public SqlGroupingIdFunction() {
+  SqlGroupingIdFunction() {
     //noinspection deprecation
     super("GROUPING_ID", SqlKind.GROUPING_ID, ReturnTypes.BIGINT, null,
         OperandTypes.ONE_OR_MORE, SqlFunctionCategory.SYSTEM);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlItemOperator.java
Patch:
@@ -47,7 +47,7 @@ class SqlItemOperator extends SqlSpecialOperator {
           OperandTypes.family(SqlTypeFamily.MAP),
           OperandTypes.family(SqlTypeFamily.ANY));
 
-  public SqlItemOperator() {
+  SqlItemOperator() {
     super("ITEM", SqlKind.OTHER_FUNCTION, 100, true, null, null, null);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
Patch:
@@ -28,7 +28,7 @@
  * {@code ROLLUP}, {@code GROUPING SETS}.
  */
 class SqlRollupOperator extends SqlInternalOperator {
-  public SqlRollupOperator(String name, SqlKind kind) {
+  SqlRollupOperator(String name, SqlKind kind) {
     super(name, kind, 4);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -2204,8 +2204,8 @@ public static SqlCall convertAuxiliaryToGroupCall(SqlCall call) {
    *
    * <p>For example, converts {@code TUMBLE_START(rowtime, INTERVAL '1' HOUR))}
    * to {@code TUMBLE(rowtime, INTERVAL '1' HOUR))}. */
-  public static List<Pair<SqlNode, AuxiliaryConverter>>
-  convertGroupToAuxiliaryCalls(SqlCall call) {
+  public static List<Pair<SqlNode, AuxiliaryConverter>> convertGroupToAuxiliaryCalls(
+      SqlCall call) {
     final SqlOperator op = call.getOperator();
     if (op instanceof SqlGroupFunction
         && op.isGroup()) {

File: core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java
Patch:
@@ -180,7 +180,7 @@ protected void generateTypeString(StringBuilder sb, boolean withDetail) {
     if (withDetail) {
       // -1 means there is no default value for precision
       if (typeName.allowsPrec()
-        && typeSystem.getDefaultPrecision(typeName) > -1) {
+          && typeSystem.getDefaultPrecision(typeName) > -1) {
         printPrecision = true;
       }
       if (typeName.getDefaultScale() > -1) {

File: core/src/main/java/org/apache/calcite/sql/type/SqlOperandCountRanges.java
Patch:
@@ -45,7 +45,7 @@ private static class RangeImpl implements SqlOperandCountRange {
     private final int min;
     private final int max;
 
-    public RangeImpl(int min, int max) {
+    RangeImpl(int min, int max) {
       this.min = min;
       this.max = max;
       Preconditions.checkArgument(min <= max || max == -1);

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeExplicitPrecedenceList.java
Patch:
@@ -69,7 +69,7 @@ public class SqlTypeExplicitPrecedenceList
    * @see Glossary#SQL2003 SQL:2003 Part 2 Section 9.5
    */
   private static final Map<SqlTypeName, SqlTypeExplicitPrecedenceList>
-  TYPE_NAME_TO_PRECEDENCE_LIST =
+      TYPE_NAME_TO_PRECEDENCE_LIST =
       ImmutableMap.<SqlTypeName, SqlTypeExplicitPrecedenceList>builder()
           .put(SqlTypeName.BOOLEAN, list(SqlTypeName.BOOLEAN))
           .put(SqlTypeName.TINYINT, numeric(SqlTypeName.TINYINT))

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
Patch:
@@ -174,8 +174,8 @@ public void findAliases(Collection<SqlMoniker> result) {
   }
 
   @SuppressWarnings("deprecation")
-  public Pair<String, SqlValidatorNamespace>
-  findQualifyingTableName(String columnName, SqlNode ctx) {
+  public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
+      String columnName, SqlNode ctx) {
     //noinspection deprecation
     return parent.findQualifyingTableName(columnName, ctx);
   }

File: core/src/main/java/org/apache/calcite/sql/validate/EmptyScope.java
Patch:
@@ -198,8 +198,8 @@ public void validateExpr(SqlNode expr) {
   }
 
   @SuppressWarnings("deprecation")
-  public Pair<String, SqlValidatorNamespace>
-  findQualifyingTableName(String columnName, SqlNode ctx) {
+  public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
+      String columnName, SqlNode ctx) {
     throw validator.newValidationError(ctx,
         RESOURCE.columnNotFound(columnName));
   }

File: core/src/main/java/org/apache/calcite/sql/validate/ParameterNamespace.java
Patch:
@@ -31,7 +31,7 @@ class ParameterNamespace extends AbstractNamespace {
 
   //~ Constructors -----------------------------------------------------------
 
-  public ParameterNamespace(SqlValidatorImpl validator, RelDataType type) {
+  ParameterNamespace(SqlValidatorImpl validator, RelDataType type) {
     super(validator, null);
     this.type = type;
   }

File: core/src/main/java/org/apache/calcite/sql/validate/TableNamespace.java
Patch:
@@ -52,7 +52,7 @@ private TableNamespace(SqlValidatorImpl validator, SqlValidatorTable table,
     this.extendedFields = ImmutableList.copyOf(fields);
   }
 
-  public TableNamespace(SqlValidatorImpl validator, SqlValidatorTable table) {
+  TableNamespace(SqlValidatorImpl validator, SqlValidatorTable table) {
     this(validator, table, ImmutableList.<RelDataTypeField>of());
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -1264,7 +1264,7 @@ public static RexNode castToValidatedType(SqlNode node, RexNode e,
   private static class AvgVarianceConvertlet implements SqlRexConvertlet {
     private final SqlKind kind;
 
-    public AvgVarianceConvertlet(SqlKind kind) {
+    AvgVarianceConvertlet(SqlKind kind) {
       this.kind = kind;
     }
 
@@ -1377,7 +1377,7 @@ private SqlNode expandVariance(
   private static class TrimConvertlet implements SqlRexConvertlet {
     private final SqlTrimFunction.Flag flag;
 
-    public TrimConvertlet(SqlTrimFunction.Flag flag) {
+    TrimConvertlet(SqlTrimFunction.Flag flag) {
       this.flag = flag;
     }
 

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -1482,8 +1482,8 @@ public RelBuilder values(RelDataType rowType) {
 
   /** Converts an iterable of lists into an immutable list of immutable lists
    * with the same contents. Returns the same object if possible. */
-  private static <E> ImmutableList<ImmutableList<E>>
-  copy(Iterable<? extends List<E>> tupleList) {
+  private static <E> ImmutableList<ImmutableList<E>> copy(
+      Iterable<? extends List<E>> tupleList) {
     final ImmutableList.Builder<ImmutableList<E>> builder =
         ImmutableList.builder();
     int changeCount = 0;
@@ -1793,7 +1793,7 @@ List<RelDataTypeField> fields() {
   /** A field that belongs to a stack {@link Frame}. */
   private static class Field
       extends Pair<ImmutableSet<String>, RelDataTypeField> {
-    public Field(ImmutableSet<String> left, RelDataTypeField right) {
+    Field(ImmutableSet<String> left, RelDataTypeField right) {
       super(left, right);
     }
   }

File: core/src/main/java/org/apache/calcite/tools/RuleSets.java
Patch:
@@ -45,7 +45,7 @@ public static RuleSet ofList(Iterable<? extends RelOptRule> rules) {
   private static class ListRuleSet implements RuleSet {
     private final ImmutableList<RelOptRule> rules;
 
-    public ListRuleSet(ImmutableList<RelOptRule> rules) {
+    ListRuleSet(ImmutableList<RelOptRule> rules) {
       this.rules = rules;
     }
 

File: core/src/main/java/org/apache/calcite/util/BitSets.java
Patch:
@@ -327,7 +327,7 @@ private static class Closure {
     private SortedMap<Integer, BitSet> equivalence;
     private final SortedMap<Integer, BitSet> closure = new TreeMap<>();
 
-    public Closure(SortedMap<Integer, BitSet> equivalence) {
+    Closure(SortedMap<Integer, BitSet> equivalence) {
       this.equivalence = equivalence;
       final ImmutableIntList keys =
           ImmutableIntList.copyOf(equivalence.keySet());

File: core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
Patch:
@@ -914,7 +914,7 @@ private static class Closure {
     private final SortedMap<Integer, ImmutableBitSet> closure =
         Maps.newTreeMap();
 
-    public Closure(SortedMap<Integer, ImmutableBitSet> equivalence) {
+    Closure(SortedMap<Integer, ImmutableBitSet> equivalence) {
       this.equivalence = equivalence;
       final ImmutableIntList keys =
           ImmutableIntList.copyOf(equivalence.keySet());

File: core/src/main/java/org/apache/calcite/util/ImmutableIntList.java
Patch:
@@ -287,7 +287,9 @@ private static class EmptyImmutableIntList extends ImmutableIntList {
   }
 
   /** Extension to {@link com.google.common.collect.UnmodifiableListIterator}
-   * that operates by index. */
+   * that operates by index.
+   *
+   * @param <E> element type */
   private abstract static class AbstractIndexedListIterator<E>
       extends UnmodifiableListIterator<E> {
     private final int size;

File: core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java
Patch:
@@ -200,6 +200,8 @@ public static <E> Builder<E> builder() {
 
   /**
    * A builder for creating immutable nullable list instances.
+   *
+   * @param <E> element type
    */
   public static final class Builder<E> {
     private final List<E> contents = Lists.newArrayList();

File: core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
Patch:
@@ -670,7 +670,7 @@ private static class Node<E> {
     final List<Node<E>> childList = new ArrayList<>();
     final E e;
 
-    public Node(E e) {
+    Node(E e) {
       this.e = e;
     }
 
@@ -688,7 +688,7 @@ public Node(E e) {
   private static class TopBottomNode<E> extends Node<E> {
     private final String description;
 
-    public TopBottomNode(boolean top) {
+    TopBottomNode(boolean top) {
       super(null);
       this.description = top ? "top" : "bottom";
     }
@@ -734,7 +734,7 @@ public interface Ordering<E> {
   private static class StripList<E> extends AbstractList<E> {
     private final List<Node<E>> list;
 
-    public StripList(List<Node<E>> list) {
+    StripList(List<Node<E>> list) {
       this.list = list;
     }
 

File: core/src/main/java/org/apache/calcite/util/ReflectUtil.java
Patch:
@@ -410,8 +410,7 @@ private static Method lookupVisitMethod(
    * @param visiteeBaseClazz Visitee base class
    * @return cache of methods
    */
-  public static <R extends ReflectiveVisitor, E>
-  ReflectiveVisitDispatcher<R, E> createDispatcher(
+  public static <R extends ReflectiveVisitor, E> ReflectiveVisitDispatcher<R, E> createDispatcher(
       final Class<R> visitorBaseClazz,
       final Class<E> visiteeBaseClazz) {
     assert ReflectiveVisitor.class.isAssignableFrom(visitorBaseClazz);

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -2240,8 +2240,8 @@ public static boolean getBooleanProperty(String property,
 
   /** Returns a copy of a list of lists, making the component lists immutable if
    * they are not already. */
-  public static <E> List<List<E>>
-  immutableCopy(Iterable<? extends Iterable<E>> lists) {
+  public static <E> List<List<E>> immutableCopy(
+      Iterable<? extends Iterable<E>> lists) {
     int n = 0;
     for (Iterable<E> list : lists) {
       if (!(list instanceof ImmutableList)) {

File: core/src/main/java/org/apache/calcite/util/XmlOutput.java
Patch:
@@ -540,7 +540,7 @@ static class StringEscaper implements Cloneable {
     /**
      * Identity transform
      */
-    public StringEscaper() {
+    StringEscaper() {
       translationVector = new ArrayList<String>();
     }
 

File: core/src/main/java/org/apache/calcite/util/graph/Graphs.java
Patch:
@@ -36,8 +36,8 @@ public class Graphs {
   private Graphs() {
   }
 
-  public static <V, E extends DefaultEdge> List<V>
-  predecessorListOf(DirectedGraph<V, E> graph, V vertex) {
+  public static <V, E extends DefaultEdge> List<V> predecessorListOf(
+      DirectedGraph<V, E> graph, V vertex) {
     final List<E> edges = graph.getInwardEdges(vertex);
     return new AbstractList<V>() {
       public V get(int index) {

File: core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java
Patch:
@@ -139,7 +139,7 @@ private static class AccountingClassLoader extends JavaSourceClassLoader {
     private final File destDir;
     private int nBytes;
 
-    public AccountingClassLoader(
+    AccountingClassLoader(
         ClassLoader parentClassLoader,
         ResourceFinder sourceFinder,
         String optionalCharacterEncoding,

File: core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
Patch:
@@ -118,7 +118,7 @@ public enum MappingType {
 
   private final int inverseOrdinal;
 
-  private MappingType() {
+  MappingType() {
     this.inverseOrdinal = ((ordinal() & 3) << 2)
         | ((ordinal() & 12) >> 2);
   }

File: core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
Patch:
@@ -1549,7 +1549,7 @@ private static class PartialFunctionImpl extends AbstractMapping
     private final MappingType mappingType;
     private final int[] targets;
 
-    public PartialFunctionImpl(
+    PartialFunctionImpl(
         int sourceCount,
         int targetCount,
         MappingType mappingType) {

File: core/src/main/java/org/apache/calcite/util/trace/CalciteTrace.java
Patch:
@@ -55,8 +55,7 @@ public abstract class CalciteTrace {
    */
   public static final Logger PARSER_LOGGER = getParserTracer();
 
-  private static final ThreadLocal<Function2<Void, File, String>>
-  DYNAMIC_HANDLER =
+  private static final ThreadLocal<Function2<Void, File, String>> DYNAMIC_HANDLER =
       new ThreadLocal<Function2<Void, File, String>>() {
         @Override protected Function2<Void, File, String> initialValue() {
           return Functions.ignore2();

File: core/src/test/java/RootHr.java
Patch:
@@ -20,9 +20,9 @@
  * belongs to the unnamed (root) package. */
 public class RootHr {
   public final RootEmployee[] emps = {
-    new RootEmployee(100, "Bill"),
-    new RootEmployee(200, "Eric"),
-    new RootEmployee(150, "Sebastian"),
+      new RootEmployee(100, "Bill"),
+      new RootEmployee(200, "Eric"),
+      new RootEmployee(150, "Sebastian"),
   };
 }
 

File: core/src/test/java/org/apache/calcite/adapter/clone/ArrayTableTest.java
Patch:
@@ -44,7 +44,7 @@ public class ArrayTableTest {
     assertEquals(0xF0F, values[0]);
 
     values = new long[]{
-      0x1213141516171819L, 0x232425262728292AL, 0x3435363738393A3BL};
+        0x1213141516171819L, 0x232425262728292AL, 0x3435363738393A3BL};
     assertEquals(
         0x324, ArrayTable.BitSlicedPrimitiveArray.getLong(12, values, 9));
     assertEquals(

File: core/src/test/java/org/apache/calcite/plan/volcano/VolcanoPlannerTest.java
Patch:
@@ -461,7 +461,7 @@ private void checkEvent(
 
   /** Converter from PHYS to ENUMERABLE convention. */
   class PhysToIteratorConverter extends ConverterImpl {
-    public PhysToIteratorConverter(
+    PhysToIteratorConverter(
         RelOptCluster cluster,
         RelNode child) {
       super(

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -1020,8 +1020,8 @@ private static SortedSet<String> keywords(String dialect) {
 
   @Test public void testOverlaps() {
     final String[] ops = {
-      "overlaps", "equals", "precedes", "succeeds",
-      "immediately precedes", "immediately succeeds"
+        "overlaps", "equals", "precedes", "succeeds",
+        "immediately precedes", "immediately succeeds"
     };
     final String[] periods = {"period ", ""};
     for (String period : periods) {
@@ -7269,7 +7269,7 @@ public void subTestIntervalSecondFailsValidation() {
 
 
     check("alter system set \"a\".\"number\" = 1",
-      "ALTER SYSTEM SET `a`.`number` = 1");
+        "ALTER SYSTEM SET `a`.`number` = 1");
     sql("set approx = -12.3450")
         .ok("SET `APPROX` = -12.3450")
         .node(isDdl());

File: core/src/test/java/org/apache/calcite/sql/parser/parserextensiontesting/ExtensionSqlParserTest.java
Patch:
@@ -36,13 +36,13 @@ public class ExtensionSqlParserTest extends SqlParserTest {
 
   @Test public void testAlterSystemExtension() throws SqlParseException {
     check("alter system upload jar '/path/to/jar'",
-      "ALTER SYSTEM UPLOAD JAR '/path/to/jar'");
+        "ALTER SYSTEM UPLOAD JAR '/path/to/jar'");
   }
 
   @Test public void testAlterSystemExtensionWithoutAlter() throws SqlParseException {
     // We need to include the scope for custom alter operations
     checkFails("^upload^ jar '/path/to/jar'",
-      "(?s).*Encountered \"upload\" at .*");
+        "(?s).*Encountered \"upload\" at .*");
   }
 
   @Test public void testCreateTable() {

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -1234,7 +1234,7 @@ sql, EXPR_KEYWORDS, getSelectKeywords(), xyColumns, tTable, SETOPS,
 
   /** Factory that creates testers. */
   private static class AdvisorTesterFactory extends DelegatingSqlTestFactory {
-    public AdvisorTesterFactory() {
+    AdvisorTesterFactory() {
       super(DefaultSqlTestFactory.INSTANCE);
     }
 

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -175,7 +175,7 @@
     // system tests and benchmarks (very slow, but usually only run if
     // '-Dcalcite.test.slow' is specified)
     FoodmartTest.class
-})
+    })
 public class CalciteSuite {
 }
 

File: core/src/test/java/org/apache/calcite/test/ExceptionMessageTest.java
Patch:
@@ -47,8 +47,8 @@ public class ExceptionMessageTest {
   @SuppressWarnings("UnusedDeclaration")
   public static class TestSchema {
     public Entry[] entries = {
-      new Entry(1, "name1"),
-      new Entry(2, "name2")
+        new Entry(1, "name1"),
+        new Entry(2, "name2")
     };
 
     public Iterable<Entry> badEntries = new Iterable<Entry>() {

File: core/src/test/java/org/apache/calcite/test/InterpreterTest.java
Patch:
@@ -54,7 +54,7 @@ public class InterpreterTest {
   private class MyDataContext implements DataContext {
     private final Planner planner;
 
-    public MyDataContext(Planner planner) {
+    MyDataContext(Planner planner) {
       this.planner = planner;
     }
 

File: core/src/test/java/org/apache/calcite/test/MockCatalogReader.java
Patch:
@@ -1167,7 +1167,7 @@ private class ModifiableView extends JdbcTest.AbstractModifiableView
      * CustomColumnResolvingTable.
      */
     private class ModifiableViewWithCustomColumnResolving
-      extends ModifiableView implements CustomColumnResolvingTable, Wrapper {
+        extends ModifiableView implements CustomColumnResolvingTable, Wrapper {
 
       @Override public List<Pair<RelDataTypeField, List<String>>> resolveColumn(
           RelDataType rowType, RelDataTypeFactory typeFactory, List<String> names) {

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -2335,7 +2335,7 @@ public static class BrokenColTypeImpl extends PartialColTypeImpl {
   private static class MyRelMetadataQuery extends RelMetadataQuery {
     private ColType.Handler colTypeHandler;
 
-    public MyRelMetadataQuery() {
+    MyRelMetadataQuery() {
       super(THREAD_PROVIDERS.get(), EMPTY);
       colTypeHandler = initialHandler(ColType.Handler.class);
     }

File: core/src/test/java/org/apache/calcite/test/SqlValidatorFeatureTest.java
Patch:
@@ -127,7 +127,7 @@ private void checkFeature(String sql, Feature feature) {
 
   /** Factory for tester objects. */
   private class FeatureTesterFactory extends DelegatingSqlTestFactory {
-    public FeatureTesterFactory() {
+    FeatureTesterFactory() {
       super(DefaultSqlTestFactory.INSTANCE);
     }
 

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -7083,8 +7083,8 @@ public void _testGroupExpressionEquivalenceParams() {
 
     // Other operators with similar syntax
     String[] ops = {
-      "overlaps", "contains", "equals", "precedes", "succeeds",
-      "immediately precedes", "immediately succeeds"
+        "overlaps", "contains", "equals", "precedes", "succeeds",
+        "immediately precedes", "immediately succeeds"
     };
     for (String op : ops) {
       checkExpType("period (date '1-2-3', date '1-2-3')\n"

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommand.java
Patch:
@@ -78,7 +78,7 @@ ConcurrentTestCommand markToFail(
    * Indicates that a command should have failed, but instead succeeded, which
    * is a test error
    */
-  public static class ShouldHaveFailedException extends RuntimeException {
+  class ShouldHaveFailedException extends RuntimeException {
     private final String description;
 
     public ShouldHaveFailedException(String description) {

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommandExecutor.java
Patch:
@@ -281,7 +281,7 @@ public static class Sync {
     private int numThreads;
     private int numWaiting;
 
-    public Sync(int numThreads) {
+    Sync(int numThreads) {
       assert numThreads > 0;
       this.numThreads = numThreads;
       this.numWaiting = 0;

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestCommandGenerator.java
Patch:
@@ -78,8 +78,7 @@ public class ConcurrentTestCommandGenerator {
    * Maps Integer thread IDs to a TreeMap. The TreeMap vaules map an Integer
    * execution order to a {@link ConcurrentTestCommand}.
    */
-  private TreeMap<Integer, TreeMap<Integer, ConcurrentTestCommand>>
-  threadMap;
+  private TreeMap<Integer, TreeMap<Integer, ConcurrentTestCommand>> threadMap;
 
   /**
    * Maps Integer thread IDs to thread names.

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestTimedCommandGenerator.java
Patch:
@@ -104,6 +104,8 @@ void printCommands(
   /**
    * TimedIterator is an Iterator that repeats a given collection's elements
    * until <code>System.currentTimeMillis() &ge; endTimeMillis</code>.
+   *
+   * @param <E> element type
    */
   private class TimedIterator<E> implements Iterator<E> {
     private final List<E> commands;

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
Patch:
@@ -595,7 +595,9 @@ private interface RunnableQueueSink extends Sink, Runnable {
   }
 
   /** An {@link Enumerator} that gets its rows from a {@link BlockingQueue}.
-   * There are other fields to signal errors and end-of-data. */
+   * There are other fields to signal errors and end-of-data.
+   *
+   * @param <E> element type */
   private static class BlockingQueueEnumerator<E> implements Enumerator<E> {
     final BlockingQueue<E> queue = new ArrayBlockingQueue<>(1000);
     final AtomicBoolean done = new AtomicBoolean(false);

File: druid/src/main/java/org/apache/calcite/adapter/druid/QueryType.java
Patch:
@@ -25,7 +25,7 @@ public enum QueryType {
 
   private final String queryName;
 
-  private QueryType(String queryName) {
+  QueryType(String queryName) {
     this.queryName = queryName;
   }
 

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
Patch:
@@ -87,8 +87,9 @@ public class ElasticsearchSchema extends AbstractSchema {
     final ImmutableMap.Builder<String, Table> builder = ImmutableMap.builder();
 
     try {
-      GetMappingsResponse response = client.admin().indices().getMappings(
-        new GetMappingsRequest().indices(index)).get();
+      GetMappingsResponse response = client.admin().indices()
+          .getMappings(new GetMappingsRequest().indices(index))
+          .get();
       ImmutableOpenMap<String, MappingMetaData> mapping = response.getMappings().get(index);
       for (ObjectObjectCursor<String, MappingMetaData> c: mapping) {
         builder.put(c.key, new ElasticsearchTable(client, index, c.key));

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
Patch:
@@ -116,6 +116,8 @@ public Enumerator<Object> enumerator() {
   /**
    * Implementation of {@link org.apache.calcite.linq4j.Queryable} based on
    * a {@link org.apache.calcite.adapter.elasticsearch.ElasticsearchTable}.
+   *
+   * @param <T> element type
    */
   public static class ElasticsearchQueryable<T> extends AbstractTableQueryable<T> {
     public ElasticsearchQueryable(QueryProvider queryProvider, SchemaPlus schema,

File: elasticsearch/src/test/java/org/apache/calcite/test/ElasticsearchAdapterIT.java
Patch:
@@ -192,10 +192,10 @@ private static Function<List, Void> elasticsearchChecker(final String... strings
 
   @Test public void testInPlan() {
     final String[] searches = {
-      "\"query\" : {\"constant_score\":{\"filter\":{\"bool\":{\"should\":"
+        "\"query\" : {\"constant_score\":{\"filter\":{\"bool\":{\"should\":"
           + "[{\"bool\":{\"must\":[{\"term\":{\"pop\":20012}}]}},{\"bool\":{\"must\":[{\"term\":"
           + "{\"pop\":15590}}]}}]}}}}",
-      "\"fields\" : [\"city\", \"pop\", \"state\", \"id\"], \"script_fields\": {\"longitude\":{\"script\":\"_source.loc[0]\"}, \"latitude\":{\"script\":\"_source.loc[1]\"}}"
+        "\"fields\" : [\"city\", \"pop\", \"state\", \"id\"], \"script_fields\": {\"longitude\":{\"script\":\"_source.loc[0]\"}, \"latitude\":{\"script\":\"_source.loc[1]\"}}"
     };
     CalciteAssert.that()
         .enable(enabled())

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvFieldType.java
Patch:
@@ -47,8 +47,7 @@ enum CsvFieldType {
   private final Class clazz;
   private final String simpleName;
 
-  private static final Map<String, CsvFieldType> MAP =
-    new HashMap<String, CsvFieldType>();
+  private static final Map<String, CsvFieldType> MAP = new HashMap<>();
 
   static {
     for (CsvFieldType value : values()) {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/JsonEnumerator.java
Patch:
@@ -30,7 +30,7 @@
 class JsonEnumerator implements Enumerator<Object[]> {
   private final Enumerator<Object> enumerator;
 
-  public JsonEnumerator(Source source) {
+  JsonEnumerator(Source source) {
     try {
       final ObjectMapper mapper = new ObjectMapper();
       mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);

File: example/function/src/main/java/org/apache/calcite/example/maze/Maze.java
Patch:
@@ -39,7 +39,7 @@ class Maze {
   private final boolean horizontal = false;
   private final boolean spiral = false;
 
-  public Maze(int width, int height) {
+  Maze(int width, int height) {
     this.width = width;
     this.height = height;
     this.regions = new int[width * height];

File: linq4j/src/main/java/org/apache/calcite/linq4j/QueryProviderImpl.java
Patch:
@@ -51,6 +51,8 @@ public <T> T execute(Expression expression, Type type) {
 
   /**
    * Binds an expression to this query provider.
+   *
+   * @param <T> element type
    */
   public static class QueryableImpl<T> extends BaseQueryable<T> {
     public QueryableImpl(QueryProviderImpl provider, Type elementType,

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
Patch:
@@ -497,7 +497,7 @@ private static class SubstituteVariableVisitor extends Shuttle {
     private final Map<ParameterExpression, Boolean> actives =
         new IdentityHashMap<>();
 
-    public SubstituteVariableVisitor(Map<ParameterExpression, Expression> map) {
+    SubstituteVariableVisitor(Map<ParameterExpression, Expression> map) {
       this.map = map;
     }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ExpressionWriter.java
Patch:
@@ -33,11 +33,11 @@ class ExpressionWriter {
   private boolean indentPending;
   private final boolean generics;
 
-  public ExpressionWriter() {
+  ExpressionWriter() {
     this(true);
   }
 
-  public ExpressionWriter(boolean generics) {
+  ExpressionWriter(boolean generics) {
     this.generics = generics;
   }
 
@@ -197,7 +197,7 @@ public void backUp() {
 
   /** Helps generate strings of spaces, to indent text. */
   private static class Indent extends ArrayList<String> {
-    public Indent(int initialCapacity) {
+    Indent(int initialCapacity) {
       super(initialCapacity);
       ensureSize(initialCapacity);
     }

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/DeterministicTest.java
Patch:
@@ -80,7 +80,7 @@ public static int nonDeterministic(int a) {
   private boolean isAtomic(Expression e) {
     /** Subclass to make a protected method public. */
     class MyDeterministicCodeOptimizer extends DeterministicCodeOptimizer {
-      public MyDeterministicCodeOptimizer() {
+      MyDeterministicCodeOptimizer() {
         super(ClassDeclarationFinder.create());
       }
 

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/Linq4jSuite.java
Patch:
@@ -38,7 +38,7 @@
     FunctionTest.class,
     TypeTest.class,
     CorrelateJoinTest.class
-})
+    })
 public class Linq4jSuite {
 }
 

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoEnumerator.java
Patch:
@@ -40,7 +40,7 @@ class MongoEnumerator implements Enumerator<Object> {
    * @param cursor Mongo iterator (usually a {@link com.mongodb.DBCursor})
    * @param getter Converts an object into a list of fields
    */
-  public MongoEnumerator(Iterator<DBObject> cursor,
+  MongoEnumerator(Iterator<DBObject> cursor,
       Function1<DBObject, Object> getter) {
     this.cursor = cursor;
     this.getter = getter;

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoTable.java
Patch:
@@ -218,7 +218,9 @@ private AggregationOutput aggregateOldWay(DBCollection dbCollection,
   }
 
   /** Implementation of {@link org.apache.calcite.linq4j.Queryable} based on
-   * a {@link org.apache.calcite.adapter.mongodb.MongoTable}. */
+   * a {@link org.apache.calcite.adapter.mongodb.MongoTable}.
+   *
+   * @param <T> element type */
   public static class MongoQueryable<T> extends AbstractTableQueryable<T> {
     MongoQueryable(QueryProvider queryProvider, SchemaPlus schema,
         MongoTable table, String tableName) {

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigAggFunction.java
Patch:
@@ -29,11 +29,11 @@ public enum PigAggFunction {
   private final SqlKind calciteFunc;
   private final boolean star; // as in COUNT(*)
 
-  private PigAggFunction(SqlKind calciteFunc) {
+  PigAggFunction(SqlKind calciteFunc) {
     this(calciteFunc, false);
   }
 
-  private PigAggFunction(SqlKind calciteFunc, boolean star) {
+  PigAggFunction(SqlKind calciteFunc, boolean star) {
     this.calciteFunc = calciteFunc;
     this.star = star;
   }

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigDataType.java
Patch:
@@ -32,7 +32,7 @@ public enum PigDataType {
   private byte pigType; // Pig defines types using bytes
   private SqlTypeName sqlType;
 
-  private PigDataType(byte pigType, SqlTypeName sqlType) {
+  PigDataType(byte pigType, SqlTypeName sqlType) {
     this.pigType = pigType;
     this.sqlType = sqlType;
   }

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigTableScan.java
Patch:
@@ -48,9 +48,9 @@ public PigTableScan(RelOptCluster cluster, RelTraitSet traitSet, RelOptTable tab
     final PigTable pigTable = getPigTable(implementor.getTableName(this));
     final String alias = implementor.getPigRelationAlias(this);
     final String schema = '(' + getSchemaForPigStatement(implementor)
-      + ')';
+        + ')';
     final String statement = alias + " = LOAD '" + pigTable.getFilePath()
-      + "' USING PigStorage() AS " + schema + ';';
+        + "' USING PigStorage() AS " + schema + ';';
     implementor.addStatement(statement);
   }
 

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigToEnumerableConverterRule.java
Patch:
@@ -27,7 +27,7 @@
  */
 public class PigToEnumerableConverterRule extends ConverterRule {
   public static final ConverterRule INSTANCE =
-    new PigToEnumerableConverterRule();
+      new PigToEnumerableConverterRule();
 
   private PigToEnumerableConverterRule() {
     super(RelNode.class, PigRel.CONVENTION, EnumerableConvention.INSTANCE,

File: piglet/src/main/java/org/apache/calcite/piglet/Handler.java
Patch:
@@ -178,8 +178,8 @@ public Handler handle(Ast.Node node) {
   protected void dump(RelNode rel) {
   }
 
-  private ImmutableList<ImmutableList<RexLiteral>>
-  tuples(Ast.ValuesStmt valuesStmt, RelDataType rowType) {
+  private ImmutableList<ImmutableList<RexLiteral>> tuples(
+      Ast.ValuesStmt valuesStmt, RelDataType rowType) {
     final ImmutableList.Builder<ImmutableList<RexLiteral>> listBuilder =
         ImmutableList.builder();
     for (List<Ast.Node> nodeList : valuesStmt.tupleList) {

File: piglet/src/test/java/org/apache/calcite/test/CalciteHandler.java
Patch:
@@ -36,7 +36,7 @@
 class CalciteHandler extends Handler {
   private final PrintWriter writer;
 
-  public CalciteHandler(PigRelBuilder builder, Writer writer) {
+  CalciteHandler(PigRelBuilder builder, Writer writer) {
     super(builder);
     this.writer = new PrintWriter(writer);
   }

File: piglet/src/test/java/org/apache/calcite/test/Fluent.java
Patch:
@@ -40,7 +40,7 @@
 class Fluent {
   private final String pig;
 
-  public Fluent(String pig) {
+  Fluent(String pig) {
     this.pig = pig;
   }
 

File: plus/src/main/java/org/apache/calcite/adapter/os/Processes.java
Patch:
@@ -184,7 +184,7 @@ public void close() {
   private static class ProcessFactory implements Supplier<Process> {
     private final String[] args;
 
-    public ProcessFactory(String... args) {
+    ProcessFactory(String... args) {
       this.args = args;
     }
 

File: plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
Patch:
@@ -99,7 +99,9 @@ public TpcdsSchema(double scaleFactor, int part, int partCount) {
     return tableMap;
   }
 
-  /** Definition of a table in the TPC-DS schema. */
+  /** Definition of a table in the TPC-DS schema.
+   *
+   * @param <E> entity type */
   private class TpcdsQueryableTable<E extends TpcdsEntity>
       extends AbstractQueryableTable {
     private final TpcdsTable<E> tpcdsTable;

File: plus/src/main/java/org/apache/calcite/adapter/tpch/TpchSchema.java
Patch:
@@ -79,7 +79,9 @@ public TpchSchema(double scaleFactor, int part, int partCount,
     return tableMap;
   }
 
-  /** Definition of a table in the TPC-H schema. */
+  /** Definition of a table in the TPC-H schema.
+   *
+   * @param <E> entity type */
   private class TpchQueryableTable<E extends TpchEntity>
       extends AbstractQueryableTable {
     private final TpchTable<E> tpchTable;

File: plus/src/test/java/org/apache/calcite/adapter/tpcds/TpcdsTest.java
Patch:
@@ -51,9 +51,8 @@
  * command-line.
  * (See {@link org.apache.calcite.test.CalciteAssert#ENABLE_SLOW}.)</p> */
 public class TpcdsTest {
-  private static
-  Function<Pair<List<Prepare.Materialization>, Holder<Program>>, Void>
-  handler(final boolean bushy, final int minJoinCount) {
+  private static Function<Pair<List<Prepare.Materialization>, Holder<Program>>, Void> handler(
+      final boolean bushy, final int minJoinCount) {
     return new Function<Pair<List<Prepare.Materialization>, Holder<Program>>,
         Void>() {
       public Void apply(

File: plus/src/test/java/org/apache/calcite/test/PlusSuite.java
Patch:
@@ -31,7 +31,7 @@
     OsAdapterTest.class,
     TpcdsTest.class,
     TpchTest.class
-})
+    })
 public class PlusSuite {
 }
 

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkRel.java
Patch:
@@ -34,7 +34,7 @@ public interface SparkRel extends RelNode {
 
   /** Extension to {@link JavaRelImplementor} that can handle Spark relational
    * expressions. */
-  public abstract class Implementor extends JavaRelImplementor {
+  abstract class Implementor extends JavaRelImplementor {
     public Implementor(RexBuilder rexBuilder) {
       super(rexBuilder);
     }
@@ -46,7 +46,7 @@ public Implementor(RexBuilder rexBuilder) {
 
   /** Result of generating Java code to implement a Spark relational
    * expression. */
-  public class Result {
+  class Result {
     public final BlockStatement block;
     public final PhysType physType;
 

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkToEnumerableConverter.java
Patch:
@@ -95,7 +95,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
   private static class SparkImplementorImpl extends SparkRel.Implementor {
     private final EnumerableRelImplementor implementor;
 
-    public SparkImplementorImpl(EnumerableRelImplementor implementor) {
+    SparkImplementorImpl(EnumerableRelImplementor implementor) {
       super(implementor.getRexBuilder());
       this.implementor = implementor;
     }

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
Patch:
@@ -106,7 +106,7 @@ public void getSearchResults(String search, Map<String, String> otherArgs,
   private static class WrappingSplunkConnection implements SplunkConnection {
     private final SplunkConnection connection;
 
-    public WrappingSplunkConnection(SplunkConnection connection) {
+    WrappingSplunkConnection(SplunkConnection connection) {
       this.connection = connection;
     }
 

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -6763,7 +6763,7 @@ public void _testGroupExpressionEquivalenceParams() {
         + " from emp group by deptno\n"
         + " window w1 as (partition by ^empno^ ROWS 2 PRECEDING),\n"
         + " w2 as (order by deptno ROWS 2 PRECEDING)")
-        .fails("Expression 'EMP.EMPNO' is not being grouped");
+        .fails("Expression 'EMPNO' is not being grouped");
     sql("select avg(count(empno)) over w\n"
         + "from emp group by deptno\n"
         + "window w as (partition by deptno order by ^empno^)")

File: core/src/main/java/org/apache/calcite/schema/Table.java
Patch:
@@ -74,7 +74,7 @@ public interface Table {
    *
    * @param column The column name for which {@code isRolledUp} is true
    * @param call The aggregate call
-   * @param parent Parent node of {@param call} in the {@link SqlNode} tree
+   * @param parent Parent node of {@code call} in the {@link SqlNode} tree
    * @param config Config settings. May be null
    * @return true iff the given aggregate call is valid
    * */

File: core/src/main/java/org/apache/calcite/sql/fun/SqlNtileAggFunction.java
Patch:
@@ -32,7 +32,7 @@ public SqlNtileAggFunction() {
         "NTILE",
         null,
         SqlKind.NTILE,
-        ReturnTypes.INTEGER,
+        ReturnTypes.RANK,
         null,
         OperandTypes.POSITIVE_INTEGER_LITERAL,
         SqlFunctionCategory.NUMERIC,

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
Patch:
@@ -134,7 +134,7 @@ RelProtoDataType getRelDataType(String columnFamily, boolean view) {
     // proto-type will be copied into a real type factory.
     final RelDataTypeFactory typeFactory =
         new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
-    final RelDataTypeFactory.FieldInfoBuilder fieldInfo = typeFactory.builder();
+    final RelDataTypeFactory.Builder fieldInfo = typeFactory.builder();
     for (ColumnMetadata column : columns) {
       final String columnName = column.getName();
       final DataType type = column.getType();

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java
Patch:
@@ -115,7 +115,7 @@ public Enumerable<Object> query(final Session session, List<Map.Entry<String, Cl
     // Build the type of the resulting row based on the provided fields
     final RelDataTypeFactory typeFactory =
         new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
-    final RelDataTypeFactory.FieldInfoBuilder fieldInfo = typeFactory.builder();
+    final RelDataTypeFactory.Builder fieldInfo = typeFactory.builder();
     final RelDataType rowType = getRowType(typeFactory);
 
     Function1<String, Void> addField = new Function1<String, Void>() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -212,8 +212,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
       }
 
       // The output from this stage is the input plus the aggregate functions.
-      final RelDataTypeFactory.FieldInfoBuilder typeBuilder =
-          typeFactory.builder();
+      final RelDataTypeFactory.Builder typeBuilder = typeFactory.builder();
       typeBuilder.addAll(inputPhysType.getRowType().getFieldList());
       for (AggImpState agg : aggs) {
         typeBuilder.add(agg.call.name, agg.call.type);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
Patch:
@@ -98,7 +98,7 @@ public static PhysType of(
   static PhysType of(
       final JavaTypeFactory typeFactory,
       Type javaRowClass) {
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     if (javaRowClass instanceof Types.RecordType) {
       final Types.RecordType recordType = (Types.RecordType) javaRowClass;
       for (Types.RecordField field : recordType.getRecordFields()) {
@@ -121,7 +121,7 @@ public PhysType project(List<Integer> integers, JavaRowFormat format) {
 
   public PhysType project(List<Integer> integers, boolean indicator,
       JavaRowFormat format) {
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     for (int index : integers) {
       builder.add(rowType.getFieldList().get(index));
     }

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -277,7 +277,7 @@ RelProtoDataType getRelDataType(DatabaseMetaData metaData, String catalogName,
     // proto-type will be copied into a real type factory.
     final RelDataTypeFactory typeFactory =
         new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
-    final RelDataTypeFactory.FieldInfoBuilder fieldInfo = typeFactory.builder();
+    final RelDataTypeFactory.Builder fieldInfo = typeFactory.builder();
     while (resultSet.next()) {
       final String columnName = resultSet.getString(4);
       final int dataType = resultSet.getInt(5);

File: core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
Patch:
@@ -153,7 +153,7 @@ public Accumulator get() {
       final PhysType inputPhysType =
           PhysTypeImpl.of(typeFactory, rel.getInput().getRowType(),
               JavaRowFormat.ARRAY);
-      final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+      final RelDataTypeFactory.Builder builder = typeFactory.builder();
       for (Expression expression : agg.state) {
         builder.add("a",
             typeFactory.createJavaType((Class) expression.getType()));

File: core/src/main/java/org/apache/calcite/interpreter/Bindables.java
Patch:
@@ -198,7 +198,7 @@ public List<RelCollation> get() {
     }
 
     @Override public RelDataType deriveRowType() {
-      final RelDataTypeFactory.FieldInfoBuilder builder =
+      final RelDataTypeFactory.Builder builder =
           getCluster().getTypeFactory().builder();
       final List<RelDataTypeField> fieldList =
           table.getRowType().getFieldList();

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -133,7 +133,7 @@ public Scalar compile(List<RexNode> nodes, RelDataType inputRowType) {
   }
 
   RelDataType combinedRowType(List<RelNode> inputs) {
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         dataContext.getTypeFactory().builder();
     for (RelNode input : inputs) {
       builder.addAll(input.getRowType().getFieldList());

File: core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
Patch:
@@ -257,7 +257,7 @@ private static TableScanNode createEnumerable(
         final Mapping mapping = Mappings.target(acceptedProjects,
             rel.getTable().getRowType().getFieldCount());
         filter2 = RexUtil.apply(mapping, filter);
-        final RelDataTypeFactory.FieldInfoBuilder builder =
+        final RelDataTypeFactory.Builder builder =
             rel.getCluster().getTypeFactory().builder();
         final List<RelDataTypeField> fieldList =
             rel.getTable().getRowType().getFieldList();

File: core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
Patch:
@@ -339,7 +339,7 @@ public static RelDataType deriveRowType(RelDataTypeFactory typeFactory,
       final List<AggregateCall> aggCalls) {
     final List<Integer> groupList = groupSet.asList();
     assert groupList.size() == groupSet.cardinality();
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     final List<RelDataTypeField> fieldList = inputRowType.getFieldList();
     final Set<String> containedNames = Sets.newHashSet();
     for (int groupKey : groupList) {

File: core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
Patch:
@@ -123,7 +123,7 @@ public static RelDataType deriveUncollectRowType(RelNode rel,
     RelDataType inputType = rel.getRowType();
     assert inputType.isStruct() : inputType + " is not a struct";
     final List<RelDataTypeField> fields = inputType.getFieldList();
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         rel.getCluster().getTypeFactory().builder();
     for (RelDataTypeField field : fields) {
       if (field.getType() instanceof MapSqlType) {

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -192,7 +192,7 @@ public RelDataType toType(RelDataTypeFactory typeFactory, Object o) {
     if (o instanceof List) {
       @SuppressWarnings("unchecked")
       final List<Map<String, Object>> jsonList = (List<Map<String, Object>>) o;
-      final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+      final RelDataTypeFactory.Builder builder = typeFactory.builder();
       for (Map<String, Object> jsonMap : jsonList) {
         builder.add((String) jsonMap.get("name"), toType(typeFactory, jsonMap));
       }

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectWindowTransposeRule.java
Patch:
@@ -75,7 +75,7 @@ private ProjectWindowTransposeRule() {
 
     // Put a DrillProjectRel below LogicalWindow
     final List<RexNode> exps = new ArrayList<>();
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         cluster.getTypeFactory().builder();
 
     // Keep only the fields which are referred
@@ -123,7 +123,7 @@ private ProjectWindowTransposeRule() {
     };
 
     int aggCallIndex = windowInputColumn;
-    final RelDataTypeFactory.FieldInfoBuilder outputBuilder =
+    final RelDataTypeFactory.Builder outputBuilder =
         cluster.getTypeFactory().builder();
     outputBuilder.addAll(projectBelowWindow.getRowType().getFieldList());
     for (Window.Group group : window.groups) {

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -221,7 +221,7 @@ protected RelDataType leastRestrictiveStructuredType(
     }
 
     // recursively compute column-wise least restrictive
-    final FieldInfoBuilder builder = builder();
+    final Builder builder = builder();
     for (int j = 0; j < fieldCount; ++j) {
       // REVIEW jvs 22-Jan-2004:  Always use the field name from the
       // first type?
@@ -567,6 +567,7 @@ public Charset getDefaultCharset() {
     return Util.getDefaultCharset();
   }
 
+  @SuppressWarnings("deprecation")
   public FieldInfoBuilder builder() {
     return new FieldInfoBuilder(this);
   }

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -926,8 +926,7 @@ public static RelDataType createStructType(
       names = SqlValidatorUtil.uniquify(names, suggester,
           typeFactory.getTypeSystem().isSchemaCaseSensitive());
     }
-    final RelDataTypeFactory.FieldInfoBuilder builder =
-        typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     for (int i = 0; i < exprs.size(); i++) {
       String name;
       if (names == null || (name = names.get(i)) == null) {

File: core/src/main/java/org/apache/calcite/schema/impl/ModifiableViewTable.java
Patch:
@@ -113,7 +113,7 @@ public final ModifiableViewTable extend(
     final ExtensibleTable underlying = unwrap(ExtensibleTable.class);
     assert underlying != null;
 
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     final RelDataType rowType = getRowType(typeFactory);
     for (RelDataTypeField column : rowType.getFieldList()) {
       builder.add(column);

File: core/src/main/java/org/apache/calcite/sql/SqlUnnestOperator.java
Patch:
@@ -61,7 +61,7 @@ public SqlUnnestOperator(boolean withOrdinality) {
   //~ Methods ----------------------------------------------------------------
 
   @Override public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         opBinding.getTypeFactory().builder();
     for (Integer operand : Util.range(opBinding.getOperandCount())) {
       RelDataType type = opBinding.getOperandType(operand);

File: core/src/main/java/org/apache/calcite/sql/validate/SchemaNamespace.java
Patch:
@@ -41,7 +41,7 @@ class SchemaNamespace extends AbstractNamespace {
   }
 
   protected RelDataType validateImpl(RelDataType targetRowType) {
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         validator.getTypeFactory().builder();
     for (SqlMoniker moniker
         : validator.catalogReader.getAllSchemaObjectNames(names)) {

File: core/src/main/java/org/apache/calcite/sql/validate/TableNamespace.java
Patch:
@@ -60,7 +60,7 @@ protected RelDataType validateImpl(RelDataType targetRowType) {
     if (extendedFields.isEmpty()) {
       return table.getRowType();
     }
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         validator.getTypeFactory().builder();
     builder.addAll(table.getRowType().getFieldList());
     builder.addAll(extendedFields);

File: core/src/main/java/org/apache/calcite/sql/validate/WithItemNamespace.java
Patch:
@@ -41,7 +41,7 @@ class WithItemNamespace extends AbstractNamespace {
     if (withItem.columnList == null) {
       return rowType;
     }
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         validator.getTypeFactory().builder();
     for (Pair<SqlNode, RelDataTypeField> pair
         : Pair.zip(withItem.columnList, rowType.getFieldList())) {

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -302,7 +302,7 @@ protected RexNode handle(RexFieldAccess fieldAccess) {
                   && v.getType().getFieldCount() == mapping.getSourceCount()) {
                 final int old = fieldAccess.getField().getIndex();
                 final int new_ = mapping.getTarget(old);
-                final RelDataTypeFactory.FieldInfoBuilder typeBuilder =
+                final RelDataTypeFactory.Builder typeBuilder =
                     relBuilder.getTypeFactory().builder();
                 for (int target : Util.range(mapping.getTargetCount())) {
                   typeBuilder.add(

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -4209,8 +4209,7 @@ Pair<RexNode, Map<String, Integer>> lookupExp(SqlQualified qualified) {
         if (resolve.path.steps().get(0).i < 0) {
           return Pair.of(rexBuilder.makeCorrel(rowType, correlId), null);
         } else {
-          final RelDataTypeFactory.FieldInfoBuilder builder =
-              typeFactory.builder();
+          final RelDataTypeFactory.Builder builder = typeFactory.builder();
           final ListScope ancestorScope1 = (ListScope) resolve.scope;
           final ImmutableMap.Builder<String, Integer> fields =
               ImmutableMap.builder();

File: core/src/test/java/org/apache/calcite/sql/parser/parserextensiontesting/SqlCreateTable.java
Patch:
@@ -113,7 +113,7 @@ public void execute(CalcitePrepare.Context context) {
       schema = schema.getSubSchema(p, true);
     }
     final JavaTypeFactory typeFactory = new JavaTypeFactoryImpl();
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     for (Pair<SqlIdentifier, SqlDataTypeSpec> pair : nameTypes()) {
       builder.add(pair.left.getSimple(),
           pair.right.deriveType(typeFactory, true));

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -942,7 +942,7 @@ private RexProgramBuilder createProg(int variant) {
   private void checkExponentialCnf(int n) {
     final RelDataType booleanType =
         typeFactory.createSqlType(SqlTypeName.BOOLEAN);
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     for (int i = 0; i < n; i++) {
       builder.add("x" + i, booleanType)
           .add("y" + i, booleanType);

File: core/src/test/java/org/apache/calcite/util/Smalls.java
Patch:
@@ -187,8 +187,7 @@ public static QueryableTable multiplicationTable(final int ncol,
     final int offs = offset == null ? 0 : offset;
     return new AbstractQueryableTable(Object[].class) {
       public RelDataType getRowType(RelDataTypeFactory typeFactory) {
-        final RelDataTypeFactory.FieldInfoBuilder builder =
-            typeFactory.builder();
+        final RelDataTypeFactory.Builder builder = typeFactory.builder();
         builder.add("row_name", typeFactory.createJavaType(String.class));
         final RelDataType int_ = typeFactory.createJavaType(int.class);
         for (int i = 1; i <= ncol; i++) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
Patch:
@@ -136,7 +136,7 @@ private static class MapRelProtoDataType implements RelProtoDataType {
     }
 
     public RelDataType apply(RelDataTypeFactory typeFactory) {
-      final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+      final RelDataTypeFactory.Builder builder = typeFactory.builder();
       for (Map.Entry<String, SqlTypeName> field : fields.entrySet()) {
         builder.add(field.getKey(), field.getValue()).nullable(true);
       }

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvTableScan.java
Patch:
@@ -67,7 +67,7 @@ protected CsvTableScan(RelOptCluster cluster, RelOptTable table,
 
   @Override public RelDataType deriveRowType() {
     final List<RelDataTypeField> fieldList = table.getRowType().getFieldList();
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         getCluster().getTypeFactory().builder();
     for (int field : fields) {
       builder.add(fieldList.get(field));

File: file/src/main/java/org/apache/calcite/adapter/file/FileTableScan.java
Patch:
@@ -68,7 +68,7 @@ protected FileTableScan(RelOptCluster cluster, RelOptTable table,
 
   @Override public RelDataType deriveRowType() {
     final List<RelDataTypeField> fieldList = table.getRowType().getFieldList();
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         getCluster().getTypeFactory().builder();
     for (int field : fields) {
       builder.add(fieldList.get(field));

File: pig/src/main/java/org/apache/calcite/adapter/pig/PigTable.java
Patch:
@@ -50,7 +50,7 @@ public PigTable(String filePath, String[] fieldNames) {
   }
 
   @Override public RelDataType getRowType(RelDataTypeFactory typeFactory) {
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     for (String fieldName : fieldNames) {
       // only supports CHARARRAY types for now
       final RelDataType relDataType = typeFactory

File: piglet/src/main/java/org/apache/calcite/piglet/Handler.java
Patch:
@@ -232,7 +232,7 @@ private RexLiteral item(Ast.Node node, RelDataType type) {
 
 
   private RelDataType toType(Ast.Schema schema) {
-    final RelDataTypeFactory.FieldInfoBuilder typeBuilder =
+    final RelDataTypeFactory.Builder typeBuilder =
         builder.getTypeFactory().builder();
     for (Ast.FieldSchema fieldSchema : schema.fieldSchemaList) {
       typeBuilder.add(fieldSchema.id.value, toType(fieldSchema.type));
@@ -284,7 +284,7 @@ private RelDataType toType(Ast.MapType type) {
 
   private RelDataType toType(Ast.TupleType type) {
     final RelDataTypeFactory typeFactory = builder.getTypeFactory();
-    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+    final RelDataTypeFactory.Builder builder = typeFactory.builder();
     for (Ast.FieldSchema fieldSchema : type.fieldSchemaList) {
       builder.add(fieldSchema.id.value, toType(fieldSchema.type));
     }

File: plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
Patch:
@@ -21,7 +21,6 @@
 import org.apache.calcite.linq4j.function.Function1;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
-import org.apache.calcite.rel.type.RelDataTypeFactory.FieldInfoBuilder;
 import org.apache.calcite.schema.ScannableTable;
 import org.apache.calcite.schema.Schema;
 import org.apache.calcite.schema.Statistic;
@@ -96,7 +95,7 @@ private Object field(String field, String value) {
 
       public RelDataType getRowType(RelDataTypeFactory typeFactory) {
         final String osName = System.getProperty("os.name");
-        final FieldInfoBuilder builder = typeFactory.builder();
+        final RelDataTypeFactory.Builder builder = typeFactory.builder();
         switch (osName) {
         case "Mac OS X":
           return builder

File: plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
Patch:
@@ -165,7 +165,7 @@ public void close() {
     }
 
     public RelDataType getRowType(RelDataTypeFactory typeFactory) {
-      final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+      final RelDataTypeFactory.Builder builder = typeFactory.builder();
       for (TpcdsColumn<E> column : tpcdsTable.getColumns()) {
         builder.add(column.getColumnName().toUpperCase(Locale.ROOT),
             typeFactory.createJavaType(realType(column)));

File: plus/src/main/java/org/apache/calcite/adapter/tpch/TpchSchema.java
Patch:
@@ -138,7 +138,7 @@ public void close() {
     }
 
     public RelDataType getRowType(RelDataTypeFactory typeFactory) {
-      final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
+      final RelDataTypeFactory.Builder builder = typeFactory.builder();
       String prefix = "";
       if (columnPrefix) {
         final String t = tpchTable.getTableName().toUpperCase(Locale.ROOT);

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkTableScan.java
Patch:
@@ -100,7 +100,7 @@ protected SplunkTableScan(
   }
 
   @Override public RelDataType deriveRowType() {
-    final RelDataTypeFactory.FieldInfoBuilder builder =
+    final RelDataTypeFactory.Builder builder =
         getCluster().getTypeFactory().builder();
     for (String field : fieldList) {
       // REVIEW: is case-sensitive match what we want here?

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -144,6 +144,7 @@
 
     // slow tests (above 1s)
     UdfTest.class,
+    TableFunctionTest.class,
     PlannerTest.class,
     RelBuilderTest.class,
     PigRelBuilderTest.class,

File: core/src/test/java/org/apache/calcite/test/UdfTest.java
Patch:
@@ -57,8 +57,9 @@
 import static org.junit.Assert.assertThat;
 
 /**
- * Tests for user-defined functions (including user-defined table functions
- * and user-defined aggregate functions).
+ * Tests for user-defined functions;
+ * includes user-defined aggregate functions
+ * but user-defined table functions are in {@link TableFunctionTest}.
  *
  * @see Smalls
  */

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -636,6 +636,9 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
   @BaseMessage("Cannot stream VALUES")
   ExInst<SqlValidatorException> cannotStreamValues();
 
+  @BaseMessage("Cannot resolve ''{0}''; it references view ''{1}'', whose definition is cyclic")
+  ExInst<SqlValidatorException> cyclicDefinition(String id, String view);
+
   @BaseMessage("Modifiable view must be based on a single table")
   ExInst<SqlValidatorException> modifiableViewMustBeBasedOnSingleTable();
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
Patch:
@@ -98,8 +98,8 @@ public LocalInterval apply(Range<TimestampString> range) {
             return LocalInterval.create(start, end);
           }
         });
-    if (LOGGER.isInfoEnabled()) {
-      LOGGER.info("Converted time ranges " + ranges + " to interval " + intervals);
+    if (LOGGER.isDebugEnabled()) {
+      LOGGER.debug("Converted time ranges " + ranges + " to interval " + intervals);
     }
     return intervals;
   }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -5415,7 +5415,7 @@ public SqlNode visit(SqlLiteral literal) {
 
             // SQL ordinals are 1-based, but Sort's are 0-based
             int ordinal = intValue - 1;
-            return select.getSelectList().get(ordinal);
+            return SqlUtil.stripAs(select.getSelectList().get(ordinal));
           }
           break;
         }

File: core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
Patch:
@@ -329,7 +329,7 @@ public boolean test(Integer input) {
     } else if (function instanceof AggregateFunction) {
       return new SqlUserDefinedAggFunction(name,
           infer((AggregateFunction) function), InferTypes.explicit(argTypes),
-          typeChecker, (AggregateFunction) function, false, false);
+          typeChecker, (AggregateFunction) function, false, false, typeFactory);
     } else if (function instanceof TableMacro) {
       return new SqlUserDefinedTableMacro(name, ReturnTypes.CURSOR,
           InferTypes.explicit(argTypes), typeChecker, paramTypes,

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraEnumerator.java
Patch:
@@ -83,8 +83,10 @@ private Object currentRowField(int index, SqlTypeName typeName) {
       return current.getInt(index);
     } else if (type == DataType.bigint()) {
       return current.getLong(index);
-    } else if (type == DataType.cdouble() || type == DataType.cfloat()) {
+    } else if (type == DataType.cdouble()) {
       return current.getDouble(index);
+    } else if (type == DataType.cfloat()) {
+      return current.getFloat(index);
     } else if (type == DataType.uuid() || type == DataType.timeuuid()) {
       return current.getUUID(index).toString();
     } else {

File: core/src/main/java/org/apache/calcite/rel/rules/UnionMergeRule.java
Patch:
@@ -115,7 +115,8 @@ public void onMatch(RelOptRuleCall call) {
     // Combine the inputs from the bottom set-op with the other inputs from
     // the top set-op.
     final RelBuilder relBuilder = call.builder();
-    if (setOpClass.isInstance(call.rel(2))) {
+    if (setOpClass.isInstance(call.rel(2))
+        && !Minus.class.isAssignableFrom(setOpClass)) {
       relBuilder.push(topOp.getInput(0));
       relBuilder.pushAll(bottomOp.getInputs());
       // topOp.getInputs().size() may be more than 2

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -122,6 +122,7 @@ public boolean test(Aggregate aggregate) {
           for (AggregateCall aggregateCall : aggregate.getAggCallList()) {
             switch (aggregateCall.getAggregation().getKind()) {
             case COUNT:
+              return !aggregateCall.getArgList().isEmpty();
             case SUM:
             case SUM0:
             case MIN:

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraTable.java
Patch:
@@ -116,7 +116,7 @@ public Enumerable<Object> query(final Session session, List<Map.Entry<String, Cl
     final RelDataTypeFactory typeFactory =
         new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     final RelDataTypeFactory.FieldInfoBuilder fieldInfo = typeFactory.builder();
-    final RelDataType rowType = protoRowType.apply(typeFactory);
+    final RelDataType rowType = getRowType(typeFactory);
 
     Function1<String, Void> addField = new Function1<String, Void>() {
       public Void apply(String fieldName) {

File: file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java
Patch:
@@ -77,6 +77,7 @@ public static String file(String s) {
   }
 
   /** Tests {@link FileReader} URL fetch. */
+  @Ignore("[CALCITE-1789] Wikipedia format change breaks file adapter test")
   @Test public void testFileReaderUrlFetch() throws FileReaderException {
     Assume.assumeTrue(FileSuite.hazNetwork());
     FileReader t =

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.calcite.sql.SqlOperatorBinding;
 import org.apache.calcite.sql.SqlSpecialOperator;
 import org.apache.calcite.sql.SqlWriter;
+import org.apache.calcite.sql.type.InferTypes;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlTypeUtil;
@@ -54,7 +55,7 @@ protected SqlMultisetValueConstructor(String name, SqlKind kind) {
         kind, MDX_PRECEDENCE,
         false,
         ReturnTypes.ARG0,
-        null,
+        InferTypes.FIRST_KNOWN,
         OperandTypes.VARIADIC);
   }
 

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -216,7 +216,7 @@ public static boolean valueMatchesType(
     case TIME:
     case TIMESTAMP:
       return value instanceof Calendar
-          && ((Calendar) value).getTimeZone().equals(DateTimeUtils.GMT_ZONE);
+          && ((Calendar) value).getTimeZone().equals(DateTimeUtils.UTC_ZONE);
     case INTERVAL_YEAR:
     case INTERVAL_YEAR_MONTH:
     case INTERVAL_MONTH:
@@ -520,7 +520,7 @@ public static RexLiteral fromJdbcString(
     case TIME:
     case TIMESTAMP:
       String format = getCalendarFormat(typeName);
-      TimeZone tz = DateTimeUtils.GMT_ZONE;
+      TimeZone tz = DateTimeUtils.UTC_ZONE;
       Calendar cal = null;
       if (typeName == SqlTypeName.DATE) {
         cal =

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -463,7 +463,7 @@ public boolean hasImplicitTableAlias() {
    * <blockquote><code>quoteTimestampLiteral(new Timestamp(0));</code>
    * </blockquote>
    *
-   * returns {@code TIMESTAMP '1970-01-01 00:00:00'}, regardless of the JVM's
+   * <p>returns {@code TIMESTAMP '1970-01-01 00:00:00'}, regardless of the JVM's
    * time zone.
    *
    * @param timestamp Timestamp
@@ -474,7 +474,7 @@ public String quoteTimestampLiteral(Timestamp timestamp) {
         new SimpleDateFormat(
             "'TIMESTAMP' ''yyyy-MM-DD HH:mm:SS''",
             Locale.ROOT);
-    format.setTimeZone(DateTimeUtils.GMT_ZONE);
+    format.setTimeZone(DateTimeUtils.UTC_ZONE);
     return format.format(timestamp);
   }
 

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -2417,7 +2417,7 @@ public static BufferedReader reader(File file) throws FileNotFoundException {
   /** Creates a {@link Calendar} in the GMT time zone and root locale.
    * Does not use the time zone or locale. */
   public static Calendar calendar() {
-    return Calendar.getInstance(DateTimeUtils.GMT_ZONE, Locale.ROOT);
+    return Calendar.getInstance(DateTimeUtils.UTC_ZONE, Locale.ROOT);
   }
 
   //~ Inner Classes ----------------------------------------------------------

File: core/src/test/java/org/apache/calcite/test/CalciteAssert.java
Patch:
@@ -131,7 +131,7 @@ private CalciteAssert() {}
   private static final DateFormat UTC_TIME_FORMAT;
   private static final DateFormat UTC_TIMESTAMP_FORMAT;
   static {
-    final TimeZone utc = DateTimeUtils.GMT_ZONE;
+    final TimeZone utc = DateTimeUtils.UTC_ZONE;
     UTC_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd", Locale.ROOT);
     UTC_DATE_FORMAT.setTimeZone(utc);
     UTC_TIME_FORMAT = new SimpleDateFormat("HH:mm:ss", Locale.ROOT);

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -5017,7 +5017,7 @@ public Object apply(CalciteConnection connection) {
                     fail("expected error, got " + resultSet);
                   } catch (SQLException e) {
                     assertThat(e.getMessage(),
-                        equalTo(
+                        containsString(
                             "exception while executing query: unbound parameter"));
                   }
 

File: core/src/test/java/org/apache/calcite/test/SqlLimitsTest.java
Patch:
@@ -195,7 +195,7 @@ private void printLimit(
     } else if (o instanceof Calendar) {
       Calendar calendar = (Calendar) o;
       DateFormat dateFormat = getDateFormat(type.getSqlTypeName());
-      dateFormat.setTimeZone(DateTimeUtils.GMT_ZONE);
+      dateFormat.setTimeZone(DateTimeUtils.UTC_ZONE);
       s = dateFormat.format(calendar.getTime());
     } else {
       s = o.toString();

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
Patch:
@@ -72,7 +72,7 @@ class DruidConnectionImpl implements DruidConnection {
   private static final SimpleDateFormat UTC_TIMESTAMP_FORMAT;
 
   static {
-    final TimeZone utc = DateTimeUtils.GMT_ZONE;
+    final TimeZone utc = DateTimeUtils.UTC_ZONE;
     UTC_TIMESTAMP_FORMAT =
         new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.ROOT);
     UTC_TIMESTAMP_FORMAT.setTimeZone(utc);

File: file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
Patch:
@@ -324,7 +324,7 @@ FileFieldType getType() {
     }
 
     private java.util.Date parseDate(String string) {
-      Parser parser = new Parser(DateTimeUtils.GMT_ZONE);
+      Parser parser = new Parser(DateTimeUtils.UTC_ZONE);
       List<DateGroup> groups = parser.parse(string);
       DateGroup group = groups.get(0);
       return group.getDates().get(0);

File: file/src/test/java/org/apache/calcite/adapter/file/FileReaderTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.jsoup.select.Elements;
 
 import org.junit.Assume;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.hamcrest.CoreMatchers.instanceOf;
@@ -66,6 +67,7 @@ public static String file(String s) {
   }
 
   /** Tests {@link FileReader} URL instantiation - with path. */
+  @Ignore("[CALCITE-1789] Wikipedia format change breaks file adapter test")
   @Test public void testFileReaderUrlWithPath() throws FileReaderException {
     Assume.assumeTrue(FileSuite.hazNetwork());
     FileReader t =

File: file/src/test/java/org/apache/calcite/adapter/file/SqlTest.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.junit.Assert;
 import org.junit.Assume;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.sql.Connection;
@@ -193,6 +194,7 @@ private void close(Connection connection, Statement statement) {
   }
 
   /** Reads from a URL and checks the result. */
+  @Ignore("[CALCITE-1789] Wikipedia format change breaks file adapter test")
   @Test public void testUrlSelect() throws SQLException {
     Assume.assumeTrue(FileSuite.hazNetwork());
     final String sql = "select \"State\", \"Statehood\" from \"States_as_of\"\n"

File: core/src/main/java/org/apache/calcite/sql/validate/TableNamespace.java
Patch:
@@ -20,6 +20,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rel.type.RelDataTypeField;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.schema.ExtensibleTable;
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.schema.impl.ModifiableViewTable;
@@ -150,8 +151,8 @@ private void checkExtendedColumnTypes(SqlNodeList extendList) {
 
         if (!extType.equals(baseType)) {
           // Get the extended column node that failed validation.
-          final Predicate<SqlNode> nameMatches = new Predicate<SqlNode>() {
-            @Override public boolean apply(SqlNode sqlNode) {
+          final Predicate<SqlNode> nameMatches = new PredicateImpl<SqlNode>() {
+            @Override public boolean test(SqlNode sqlNode) {
               if (sqlNode instanceof SqlIdentifier) {
                 final SqlIdentifier identifier = (SqlIdentifier) sqlNode;
                 return Util.last(identifier.names).equals(extendedField.getName());

File: core/src/test/java/org/apache/calcite/sql/test/SqlPrettyWriterTest.java
Patch:
@@ -275,7 +275,7 @@ protected void checkSimple(
     assertExprPrintsTo(
         true,
         "(x,xx) overlaps (y,yy) or x is not null",
-        "(`X`, `XX`) OVERLAPS (`Y`, `YY`) OR `X` IS NOT NULL");
+        "PERIOD (`X`, `XX`) OVERLAPS PERIOD (`Y`, `YY`) OR `X` IS NOT NULL");
   }
 
   @Test public void testUnion() {

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -845,7 +845,7 @@ public static boolean analyzeSimpleEquiJoin(
    * <blockquote><code>L.A = R.X AND L.B = L.C AND (L.D = 5 OR L.E =
    * R.Y)</code></blockquote>
    *
-   * returns
+   * <p>returns
    *
    * <ul>
    * <li>leftKeys = {A}

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdAllPredicates.java
Patch:
@@ -48,14 +48,14 @@
  * Utility to extract Predicates that are present in the (sub)plan
  * starting at this node.
  *
- * This should be used to infer whether same filters are applied on
+ * <p>This should be used to infer whether same filters are applied on
  * a given plan by materialized view rewriting rules.
  *
- * The output predicates might contain references to columns produced
+ * <p>The output predicates might contain references to columns produced
  * by TableScan operators ({@link RexTableInputRef}). In turn, each TableScan
  * operator is identified uniquely by its qualified name and an identifier.
  *
- * If the provider cannot infer the lineage for any of the expressions
+ * <p>If the provider cannot infer the lineage for any of the expressions
  * contain in any of the predicates, it will return null. Observe that
  * this is different from the empty list of predicates, which means that
  * there are not predicates in the (sub)plan.

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdNodeTypes.java
Patch:
@@ -54,7 +54,7 @@ public MetadataDef<BuiltInMetadata.NodeTypes> getDef() {
   }
 
   /** Catch-all implementation for
-   * {@link BuiltInMetadata.NodeTypeCount#getNodeTypes()},
+   * {@link BuiltInMetadata.NodeTypes#getNodeTypes()},
    * invoked using reflection.
    *
    * @see org.apache.calcite.rel.metadata.RelMetadataQuery#getNodeTypes(RelNode)

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
Patch:
@@ -205,7 +205,7 @@ private RelMetadataQuery(boolean dummy) {
 
   /**
    * Returns the
-   * {@link BuiltInMetadata.NodeTypeCount#getNodeTypeCount()}
+   * {@link BuiltInMetadata.NodeTypes#getNodeTypes()}
    * statistic.
    *
    * @param rel the relational expression

File: core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
Patch:
@@ -25,9 +25,9 @@
 /**
  * Variable which references a column of a table occurrence in a relational plan.
  *
- * <p>This object is used by:
- * - {@link {@link org.apache.calcite.rel.metadata.BuiltInMetadata.ExpressionLineage}, and
- * - {@link {@link org.apache.calcite.rel.metadata.BuiltInMetadata.AllPredicates}.
+ * <p>This object is used by
+ * {@link org.apache.calcite.rel.metadata.BuiltInMetadata.ExpressionLineage}
+ * and {@link org.apache.calcite.rel.metadata.BuiltInMetadata.AllPredicates}.
  *
  * <p>Given a relational expression, its purpose is to be able to reference uniquely
  * the provenance of a given expression. For that, it uses a unique table reference

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -6255,7 +6255,7 @@ public void subTestIntervalSecondFailsValidation() {
    * </li>
    * </ul>
    *
-   * A substantially identical set of tests exists in SqlValidatorTest, and
+   * <p>A substantially identical set of tests exists in SqlValidatorTest, and
    * any changes here should be synchronized there.
    */
   @Test public void testIntervalLiterals() {

File: core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
Patch:
@@ -37,6 +37,7 @@
  * optimization of a query.
  */
 public class RelOptCluster {
+
   //~ Instance fields --------------------------------------------------------
 
   private final RelDataTypeFactory typeFactory;

File: core/src/main/java/org/apache/calcite/rel/metadata/DefaultRelMetadataProvider.java
Patch:
@@ -43,6 +43,8 @@ protected DefaultRelMetadataProvider() {
         ImmutableList.of(
             RelMdPercentageOriginalRows.SOURCE,
             RelMdColumnOrigins.SOURCE,
+            RelMdExpressionLineage.SOURCE,
+            RelMdNodeTypes.SOURCE,
             RelMdRowCount.SOURCE,
             RelMdMaxRowCount.SOURCE,
             RelMdMinRowCount.SOURCE,
@@ -57,6 +59,7 @@ protected DefaultRelMetadataProvider() {
             RelMdSelectivity.SOURCE,
             RelMdExplainVisibility.SOURCE,
             RelMdPredicates.SOURCE,
+            RelMdAllPredicates.SOURCE,
             RelMdCollation.SOURCE));
   }
 }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
Patch:
@@ -843,6 +843,7 @@ public static boolean checkInputForCollationAndLimit(RelMetadataQuery mq,
     }
     return alreadySorted && alreadySmaller;
   }
+
 }
 
 // End RelMdUtil.java

File: core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java
Patch:
@@ -48,6 +48,8 @@ public interface RexBiVisitor<R, P> {
 
   R visitSubQuery(RexSubQuery subQuery, P arg);
 
+  R visitTableInputRef(RexTableInputRef ref, P arg);
+
   R visitPatternFieldRef(RexPatternFieldRef ref, P arg);
 }
 

File: core/src/main/java/org/apache/calcite/rex/RexVisitor.java
Patch:
@@ -48,6 +48,8 @@ public interface RexVisitor<R> {
 
   R visitSubQuery(RexSubQuery subQuery);
 
+  R visitTableInputRef(RexTableInputRef fieldRef);
+
   R visitPatternFieldRef(RexPatternFieldRef fieldRef);
 }
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -1081,10 +1081,9 @@ private static boolean containsLimit(QuerySpec querySpec) {
     }
 
     private ColumnMetaData.Rep getPrimitive(RelDataTypeField field) {
-      if (field.getName().equals(query.druidTable.timestampFieldName)) {
-        return ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP;
-      }
       switch (field.getType().getSqlTypeName()) {
+      case TIMESTAMP:
+        return ColumnMetaData.Rep.JAVA_SQL_TIMESTAMP;
       case BIGINT:
         return ColumnMetaData.Rep.LONG;
       case INTEGER:

File: druid/src/test/java/org/apache/calcite/adapter/druid/DruidQueryFilterTest.java
Patch:
@@ -103,7 +103,7 @@ public class DruidQueryFilterTest {
     Assert.assertThat(sw.toString(),
         is("{\"type\":\"bound\",\"dimension\":\"dimensionName\",\"lower\":\"lower-bound\","
             + "\"lowerStrict\":false,\"upper\":\"upper-bound\",\"upperStrict\":false,"
-            + "\"alphaNumeric\":false}"));
+            + "\"ordering\":\"lexicographic\"}"));
   }
 
   /** Everything a test needs for a healthy, active life. */

File: cassandra/src/test/java/org/apache/calcite/test/CassandraAdapterIT.java
Patch:
@@ -71,7 +71,7 @@ protected boolean enabled() {
         .returns("username=!PUBLIC!; time=e8754000-80b8-1fe9-8e73-e3698c967ddd; "
             + "tweet_id=f3c329de-d05b-11e5-b58b-90e2ba530b12\n")
         .explainContains("PLAN=CassandraToEnumerableConverter\n"
-           + "  CassandraFilter(condition=[=(CAST($0):VARCHAR(8) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\", '!PUBLIC!')])\n"
+           + "  CassandraFilter(condition=[=($0, '!PUBLIC!')])\n"
            + "    CassandraTableScan(table=[[twissandra, userline]]");
   }
 
@@ -96,7 +96,7 @@ protected boolean enabled() {
         .returnsCount(146)
         .explainContains("PLAN=CassandraToEnumerableConverter\n"
             + "  CassandraSort(sort0=[$1], dir0=[DESC])\n"
-            + "    CassandraFilter(condition=[=(CAST($0):VARCHAR(8) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\", '!PUBLIC!')])\n");
+            + "    CassandraFilter(condition=[=($0, '!PUBLIC!')])\n");
   }
 
   @Test public void testProject() {
@@ -109,7 +109,7 @@ protected boolean enabled() {
         .explainContains("PLAN=CassandraToEnumerableConverter\n"
                 + "  CassandraLimit(fetch=[2])\n"
                 + "    CassandraProject(tweet_id=[$2])\n"
-                + "      CassandraFilter(condition=[=(CAST($0):VARCHAR(8) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\", '!PUBLIC!')])\n");
+                + "      CassandraFilter(condition=[=($0, '!PUBLIC!')])\n");
   }
 
   @Test public void testProjectAlias() {

File: avatica/standalone-server/src/main/java/org/apache/calcite/avatica/standalone/StandaloneServer.java
Patch:
@@ -14,11 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.avatica.server;
+package org.apache.calcite.avatica.standalone;
 
 import org.apache.calcite.avatica.jdbc.JdbcMeta;
 import org.apache.calcite.avatica.remote.Driver.Serialization;
 import org.apache.calcite.avatica.remote.LocalService;
+import org.apache.calcite.avatica.server.HttpServer;
 import org.apache.calcite.avatica.util.Unsafe;
 
 import com.beust.jcommander.IStringConverter;

File: avatica/standalone-server/src/main/java/org/apache/calcite/avatica/standalone/package-info.java
Patch:
@@ -19,7 +19,7 @@
  * Avatica Server without any authentication for any JDBC driver.
  */
 @PackageMarker
-package org.apache.calcite.avatica.server;
+package org.apache.calcite.avatica.standalone;
 
 import org.apache.calcite.avatica.util.PackageMarker;
 

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -155,7 +155,7 @@ public FilterDateRangeRule(RelBuilderFactory relBuilderFactory) {
       final RelBuilder relBuilder =
           relBuilderFactory.create(filter.getCluster(), null);
       relBuilder.push(filter.getInput())
-          .filter(RexUtil.simplify(rexBuilder, condition, true));
+          .filter(condition);
       call.transformTo(relBuilder.build());
     }
   }
@@ -316,7 +316,7 @@ RexNode foo(SqlKind comparison, RexNode operand, RexLiteral literal) {
       for (Range<Calendar> r : s2.asRanges()) {
         nodes.add(toRex(operand, r));
       }
-      return RexUtil.composeDisjunction(rexBuilder, nodes, false);
+      return RexUtil.composeDisjunction(rexBuilder, nodes);
     }
 
     private boolean next(Calendar c, TimeUnitRange timeUnit, int v,

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
Patch:
@@ -199,7 +199,7 @@ protected boolean canImplement(RexCall call) {
         protected RelNode makeRel(RelOptCluster cluster, RelTraitSet traitSet,
             RelBuilder relBuilder, RelNode input, RexProgram program) {
           assert !program.containsAggs();
-          program = program.normalize(cluster.getRexBuilder(), false);
+          program = program.normalize(cluster.getRexBuilder(), null);
           return super.makeRel(cluster, traitSet, relBuilder, input, program);
         }
       },

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -1445,7 +1445,7 @@ public RexNode convertCall(SqlRexContext cx, SqlCall call) {
       for (RexNode expr : exprs) {
         orList.add(rexBuilder.makeCall(SqlStdOperatorTable.IS_NULL, expr));
       }
-      list.add(RexUtil.composeDisjunction(rexBuilder, orList, false));
+      list.add(RexUtil.composeDisjunction(rexBuilder, orList));
       list.add(rexBuilder.makeNullLiteral(type));
       for (int i = 0; i < exprs.size() - 1; i++) {
         RexNode expr = exprs.get(i);

File: core/src/test/java/org/apache/calcite/rel/rules/DateRangeRulesTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.avatica.util.TimeUnitRange;
 import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.test.RexImplicationCheckerTest.Fixture;
 
@@ -204,7 +203,7 @@ private void checkDateRange(Fixture f, RexNode e, Matcher<String> matcher,
               operandRanges));
     }
     assertThat(e.toString(), matcher);
-    final RexNode e2 = RexUtil.simplify(f.rexBuilder, e);
+    final RexNode e2 = f.simplify.simplify(e);
     assertThat(e2.toString(), simplifyMatcher);
   }
 

File: core/src/test/java/org/apache/calcite/test/RexImplicationCheckerTest.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.calcite.rex.RexInputRef;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexSimplify;
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.schema.Schemas;
 import org.apache.calcite.server.CalciteServerStatement;
@@ -357,6 +358,7 @@ public static class Fixture {
     public final RexImplicationChecker checker;
     public final RelDataType rowType;
     public final RexExecutorImpl executor;
+    public final RexSimplify simplify;
 
     public Fixture() {
       typeFactory = new JavaTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
@@ -417,6 +419,7 @@ public Void apply(RelOptCluster cluster,
           });
 
       executor = holder.get();
+      simplify = new RexSimplify(rexBuilder, false, executor);
       checker = new RexImplicationChecker(rexBuilder, executor, rowType);
     }
 

File: druid/src/test/java/org/apache/calcite/test/DruidDateRangeRulesTest.java
Patch:
@@ -21,7 +21,6 @@
 import org.apache.calcite.avatica.util.TimeUnitRange;
 import org.apache.calcite.rel.rules.DateRangeRules;
 import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.test.RexImplicationCheckerTest.Fixture;
 
@@ -130,7 +129,7 @@ private void checkDateRange(Fixture f, RexNode e, Matcher<String> intervalMatche
           new DateRangeRules.ExtractShuttle(f.rexBuilder, timeUnit,
               operandRanges));
     }
-    final RexNode e2 = RexUtil.simplify(f.rexBuilder, e);
+    final RexNode e2 = f.simplify.simplify(e);
     List<LocalInterval> intervals =
         DruidDateTimeUtils.createInterval(f.timeStampDataType, e2);
     if (intervals == null) {

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystemImpl.java
Patch:
@@ -61,9 +61,10 @@ public int getMaxScale(SqlTypeName typeName) {
     switch (typeName) {
     case CHAR:
     case BINARY:
+      return 1;
     case VARCHAR:
     case VARBINARY:
-      return 1;
+      return RelDataType.PRECISION_NOT_SPECIFIED;
     case DECIMAL:
       return getMaxNumericPrecision();
     case INTERVAL_YEAR:

File: pig/src/test/java/org/apache/calcite/test/PigAdapterTest.java
Patch:
@@ -52,13 +52,13 @@ public void testScanAndFilter() throws Exception {
   }
 
   @Test
-  public void testImplWithMltipleFilters() {
+  public void testImplWithMultipleFilters() {
     CalciteAssert.that()
       .with(MODEL)
       .query("select * from \"t\" where \"tc0\" > 'abc' and \"tc1\" = '3'")
       .explainContains(
           "PigToEnumerableConverter\n"
-            + "  PigFilter(condition=[AND(>($0, 'abc'), =($1, '3'))])\n"
+            + "  PigFilter(condition=[AND(>($0, 'abc'), =($1, CAST('3'):VARCHAR CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL))])\n"
             + "    PigTableScan(table=[[PIG, t]])")
       .runs()
       .queryContains(

File: pig/src/test/java/org/apache/calcite/test/PigRelBuilderStyleTest.java
Patch:
@@ -69,7 +69,7 @@ public void testScanAndFilter() throws Exception {
   }
 
   @Test
-  public void testImplWithMltipleFilters() {
+  public void testImplWithMultipleFilters() {
     final SchemaPlus schema = createTestSchema();
     final RelBuilder builder = createRelBuilder(schema);
     final RelNode node = builder.scan("t")

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaPreparedStatement.java
Patch:
@@ -39,6 +39,7 @@
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * Implementation of {@link java.sql.PreparedStatement}
@@ -115,7 +116,7 @@ protected List<TypedValue> copyParameterValues() {
    */
   protected synchronized Calendar getCalendar() {
     if (calendar == null) {
-      calendar = Calendar.getInstance(connection.getTimeZone());
+      calendar = Calendar.getInstance(connection.getTimeZone(), Locale.ROOT);
     }
     return calendar;
   }

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaResultSet.java
Patch:
@@ -40,6 +40,7 @@
 import java.sql.Timestamp;
 import java.util.Calendar;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 
@@ -87,7 +88,7 @@ public AvaticaResultSet(AvaticaStatement statement,
     this.fetchSize = statement.getFetchSize();
     this.fetchDirection = statement.getFetchDirection();
     this.resultSetMetaData = resultSetMetaData;
-    this.localCalendar = Calendar.getInstance(timeZone);
+    this.localCalendar = Calendar.getInstance(timeZone, Locale.ROOT);
   }
 
   private int findColumn0(String columnLabel) throws SQLException {

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaSite.java
Patch:
@@ -24,6 +24,7 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.URL;
+import java.nio.charset.StandardCharsets;
 import java.sql.Array;
 import java.sql.Blob;
 import java.sql.Clob;
@@ -477,7 +478,7 @@ private static byte[] toBytes(Object x) {
       return (byte[]) x;
     }
     if (x instanceof String) {
-      return ((String) x).getBytes();
+      return ((String) x).getBytes(StandardCharsets.UTF_8);
     }
     throw unsupportedCast(x.getClass(), byte[].class);
   }

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaUtils.java
Patch:
@@ -37,6 +37,7 @@
 
 /** Avatica utilities. */
 public class AvaticaUtils {
+
   private static final Map<Class, Class> BOX;
 
   private static final MethodHandle SET_LARGE_MAX_ROWS =

File: avatica/core/src/main/java/org/apache/calcite/avatica/BuiltInConnectionProperty.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
@@ -90,7 +91,7 @@ public enum BuiltInConnectionProperty implements ConnectionProperty {
   static {
     NAME_TO_PROPS = new HashMap<>();
     for (BuiltInConnectionProperty p : BuiltInConnectionProperty.values()) {
-      NAME_TO_PROPS.put(p.camelName.toUpperCase(), p);
+      NAME_TO_PROPS.put(p.camelName.toUpperCase(Locale.ROOT), p);
       NAME_TO_PROPS.put(p.name(), p);
     }
 

File: avatica/core/src/main/java/org/apache/calcite/avatica/ConnectionConfigImpl.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.File;
 import java.math.BigDecimal;
 import java.util.LinkedHashMap;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
 
@@ -121,7 +122,7 @@ public static Map<ConnectionProperty, String> parse(Properties properties,
         new LinkedHashMap<ConnectionProperty, String>();
     for (String name : properties.stringPropertyNames()) {
       final ConnectionProperty connectionProperty =
-          nameToProps.get(name.toUpperCase());
+          nameToProps.get(name.toUpperCase(Locale.ROOT));
       if (connectionProperty == null) {
         // For now, don't throw. It messes up sub-projects.
         //throw new RuntimeException("Unknown property '" + name + "'");

File: avatica/core/src/main/java/org/apache/calcite/avatica/remote/AvaticaRemoteConnectionProperty.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.avatica.ConnectionProperty;
 
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
 
@@ -42,7 +43,7 @@ public enum AvaticaRemoteConnectionProperty implements ConnectionProperty {
     NAME_TO_PROPS = new HashMap<>();
     for (AvaticaRemoteConnectionProperty p
         : AvaticaRemoteConnectionProperty.values()) {
-      NAME_TO_PROPS.put(p.camelName.toUpperCase(), p);
+      NAME_TO_PROPS.put(p.camelName.toUpperCase(Locale.ROOT), p);
       NAME_TO_PROPS.put(p.name(), p);
     }
   }

File: avatica/core/src/main/java/org/apache/calcite/avatica/remote/Driver.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 import java.util.Properties;
 
 /**
@@ -184,7 +185,8 @@ Serialization getSerialization(ConnectionConfig config) {
     Serialization serializationType = Serialization.JSON;
     if (null != serializationStr) {
       try {
-        serializationType = Serialization.valueOf(serializationStr.toUpperCase());
+        serializationType =
+            Serialization.valueOf(serializationStr.toUpperCase(Locale.ROOT));
       } catch (Exception e) {
         // Log a warning instead of failing harshly? Intentionally no loggers available?
         throw new RuntimeException(e);

File: avatica/core/src/main/java/org/apache/calcite/avatica/remote/RemoteProtobufService.java
Patch:
@@ -20,6 +20,7 @@
 import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 
 
 /**
@@ -51,7 +52,8 @@ public RemoteProtobufService(AvaticaHttpClient client, ProtobufTranslation trans
     try {
       resp = translation.parseResponse(response);
     } catch (IOException e) {
-      LOG.debug("Failed to deserialize reponse to {}. '{}'", request, new String(response));
+      LOG.debug("Failed to deserialize reponse to {}. '{}'", request,
+          new String(response, StandardCharsets.UTF_8));
       // Not a protobuf that we could parse.
       throw new RuntimeException(e);
     }

File: avatica/core/src/main/java/org/apache/calcite/avatica/util/AbstractCursor.java
Patch:
@@ -792,7 +792,7 @@ public BinaryAccessor(Getter getter) {
       if (obj instanceof ByteString) {
         return ((ByteString) obj).getBytes();
       } else if (obj instanceof String) {
-        return ((String) obj).getBytes();
+        return ((String) obj).getBytes(StandardCharsets.UTF_8);
       } else if (obj instanceof byte[]) {
         return (byte[]) obj;
       } else {

File: avatica/core/src/test/java/org/apache/calcite/avatica/AvaticaResultSetConversionsTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.apache.calcite.avatica.ColumnMetaData.AvaticaType;
 import org.apache.calcite.avatica.remote.TypedValue;
+import org.apache.calcite.avatica.util.DateTimeUtils;
 
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -43,7 +44,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
-import java.util.TimeZone;
 
 import static org.hamcrest.CoreMatchers.isA;
 import static org.junit.Assert.assertEquals;
@@ -913,8 +913,7 @@ private StringAccessorTestHelper(int ordinal) {
     }
   }
 
-  private static final Calendar DEFAULT_CALENDAR = Calendar
-      .getInstance(TimeZone.getTimeZone("GMT"));
+  private static final Calendar DEFAULT_CALENDAR = DateTimeUtils.calendar();
 
   private static Connection connection = null;
   private static ResultSet resultSet = null;

File: avatica/core/src/test/java/org/apache/calcite/avatica/remote/KerberosConnectionTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.mockito.Mockito;
 
 import java.io.File;
+import java.util.Locale;
 import java.util.Map.Entry;
 
 import javax.security.auth.Subject;
@@ -135,7 +136,8 @@ public class KerberosConnectionTest {
     end = start + 1000 * 60 * 60 * 24;
     // Ten minutes prior to expiration
     now = end - 1000 * 60 * 10;
-    assertTrue(String.format("start=%d, end=%d, now=%d", start, end, now),
+    assertTrue(
+        String.format(Locale.ROOT, "start=%d, end=%d, now=%d", start, end, now),
         renewal.shouldRenew(start, end, now));
   }
 }

File: avatica/core/src/test/java/org/apache/calcite/avatica/test/AvaticaUtilsTest.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
+import java.util.Locale;
 import java.util.Properties;
 import java.util.Set;
 
@@ -292,11 +293,11 @@ private static class ConnectionPropertyImpl implements ConnectionProperty {
     }
 
     public String name() {
-      return name.toUpperCase();
+      return name.toUpperCase(Locale.ROOT);
     }
 
     public String camelName() {
-      return name.toLowerCase();
+      return name.toLowerCase(Locale.ROOT);
     }
 
     public Object defaultValue() {

File: avatica/server/src/main/java/org/apache/calcite/avatica/jdbc/JdbcMeta.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.calcite.avatica.proto.Requests;
 import org.apache.calcite.avatica.remote.ProtobufMeta;
 import org.apache.calcite.avatica.remote.TypedValue;
+import org.apache.calcite.avatica.util.Unsafe;
 
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -85,7 +86,7 @@ public class JdbcMeta implements ProtobufMeta {
 
   // End of constants, start of member variables
 
-  final Calendar calendar = Calendar.getInstance();
+  final Calendar calendar = Unsafe.localCalendar();
 
   /** Generates ids for statements. The ids are unique across all connections
    * created by this JdbcMeta. */

File: avatica/server/src/main/java/org/apache/calcite/avatica/jdbc/JdbcResultSet.java
Patch:
@@ -77,7 +77,7 @@ public static JdbcResultSet create(String connectionId, int statementId,
   public static JdbcResultSet create(String connectionId, int statementId,
       ResultSet resultSet, int maxRowCount, Meta.Signature signature) {
     try {
-      final Calendar calendar = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+      final Calendar calendar = DateTimeUtils.calendar();
       final int fetchRowCount;
       if (maxRowCount == JdbcMeta.UNLIMITED_COUNT) {
         fetchRowCount = -1;

File: avatica/server/src/test/java/org/apache/calcite/avatica/SslDriverTest.java
Patch:
@@ -20,6 +20,7 @@
 import org.apache.calcite.avatica.remote.Driver;
 import org.apache.calcite.avatica.remote.LocalService;
 import org.apache.calcite.avatica.server.HttpServer;
+import org.apache.calcite.avatica.util.DateTimeUtils;
 
 import org.bouncycastle.asn1.x500.X500Name;
 import org.bouncycastle.asn1.x500.style.IETFUtils;
@@ -195,8 +196,8 @@ private X509CertificateObject generateCert(String keyName, KeyPair kp, boolean i
         PublicKey signerPublicKey, PrivateKey signerPrivateKey) throws IOException,
         CertIOException, OperatorCreationException, CertificateException,
         NoSuchAlgorithmException {
-      Calendar startDate = Calendar.getInstance();
-      Calendar endDate = Calendar.getInstance();
+      Calendar startDate = DateTimeUtils.calendar();
+      Calendar endDate = DateTimeUtils.calendar();
       endDate.add(Calendar.YEAR, 100);
 
       BigInteger serialNumber = BigInteger.valueOf(startDate.getTimeInMillis());

File: avatica/server/src/test/java/org/apache/calcite/avatica/server/AbstractAvaticaHandlerTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.junit.Test;
 
 import java.net.HttpURLConnection;
+import java.nio.charset.StandardCharsets;
 
 import javax.servlet.ServletOutputStream;
 import javax.servlet.http.HttpServletRequest;
@@ -72,7 +73,7 @@ public class AbstractAvaticaHandlerTest {
       }
 
       @Override public boolean matches(Object item) {
-        String msg = new String((byte[]) item);
+        String msg = new String((byte[]) item, StandardCharsets.UTF_8);
         return msg.contains("User is not authenticated");
       }
 

File: avatica/server/src/test/java/org/apache/calcite/avatica/server/HttpServerSpnegoWithJaasTest.java
Patch:
@@ -38,6 +38,7 @@
 import java.io.File;
 import java.net.HttpURLConnection;
 import java.net.URL;
+import java.nio.charset.StandardCharsets;
 import java.security.Principal;
 import java.security.PrivilegedExceptionAction;
 import java.util.Set;
@@ -220,7 +221,8 @@ private static void setupUsers(File keytabDir) throws KrbException {
 
     // We should get a response which is "OK" with our client's name
     assertNotNull(response);
-    assertEquals("OK " + SpnegoTestUtil.CLIENT_PRINCIPAL, new String(response));
+    assertEquals("OK " + SpnegoTestUtil.CLIENT_PRINCIPAL,
+        new String(response, StandardCharsets.UTF_8));
   }
 }
 

File: avatica/server/src/test/java/org/apache/calcite/avatica/server/HttpServerSpnegoWithoutJaasTest.java
Patch:
@@ -38,6 +38,7 @@
 import java.io.File;
 import java.net.HttpURLConnection;
 import java.net.URL;
+import java.nio.charset.StandardCharsets;
 import java.security.Principal;
 import java.security.PrivilegedExceptionAction;
 import java.util.Set;
@@ -211,7 +212,8 @@ private static void setupUsers(File keytabDir) throws KrbException {
 
     // We should get a response which is "OK" with our client's name
     assertNotNull(response);
-    assertEquals("OK " + SpnegoTestUtil.CLIENT_PRINCIPAL, new String(response));
+    assertEquals("OK " + SpnegoTestUtil.CLIENT_PRINCIPAL,
+        new String(response, StandardCharsets.UTF_8));
   }
 }
 

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -46,6 +46,7 @@
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.Collection;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import javax.sql.DataSource;
@@ -210,7 +211,7 @@ private ImmutableMap<String, JdbcTable> computeTables() {
         final String tableTypeName2 =
             tableTypeName == null
             ? null
-            : tableTypeName.toUpperCase().replace(' ', '_');
+            : tableTypeName.toUpperCase(Locale.ROOT).replace(' ', '_');
         final TableType tableType =
             Util.enumVal(TableType.OTHER, tableTypeName2);
         if (tableType == TableType.OTHER  && tableTypeName2 != null) {

File: core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
Patch:
@@ -49,6 +49,7 @@
 import java.math.BigDecimal;
 import java.util.ArrayDeque;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.NoSuchElementException;
 
@@ -211,7 +212,7 @@ public Object execute(Context context) {
                 if (s0 == null) {
                   return null;
                 }
-                return s0.toUpperCase();
+                return s0.toUpperCase(Locale.ROOT);
               }
               if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {
                 argScalar.execute(context, args);

File: core/src/main/java/org/apache/calcite/materialize/TileSuggester.java
Patch:
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.materialize;
 
+import org.apache.calcite.util.Util;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -59,7 +61,7 @@ public TileSuggester(Lattice lattice) {
 
   public Iterable<? extends Lattice.Tile> tiles() {
     final Algorithm algorithm = new MonteCarloAlgorithm();
-    final PrintWriter pw = new PrintWriter(System.out);
+    final PrintWriter pw = Util.printWriter(System.out);
     final Progress progress = new ArgumentUtils.TextProgress(pw);
     final StatisticsProvider statisticsProvider =
         new StatisticsProviderImpl(lattice);

File: core/src/main/java/org/apache/calcite/rel/core/Correlate.java
Patch:
@@ -156,7 +156,7 @@ public SemiJoinType getJoinType() {
   @Override public RelWriter explainTerms(RelWriter pw) {
     return super.explainTerms(pw)
         .item("correlation", correlationId)
-        .item("joinType", joinType.name().toLowerCase())
+        .item("joinType", joinType.lowerName)
         .item("requiredColumns", requiredColumns.toString());
   }
 

File: core/src/main/java/org/apache/calcite/rel/core/Join.java
Patch:
@@ -204,7 +204,7 @@ public static double estimateJoinedRows(
   @Override public RelWriter explainTerms(RelWriter pw) {
     return super.explainTerms(pw)
         .item("condition", condition)
-        .item("joinType", joinType.name().toLowerCase())
+        .item("joinType", joinType.lowerName)
         .itemIf(
             "systemFields",
             getSystemFieldList(),

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
Patch:
@@ -46,6 +46,7 @@
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 /**
@@ -188,7 +189,8 @@ public boolean getBoolean(String tag, boolean default_) {
       }
 
       public <E extends Enum<E>> E getEnum(String tag, Class<E> enumClass) {
-        return Util.enumVal(enumClass, getString(tag).toUpperCase());
+        return Util.enumVal(enumClass,
+            getString(tag).toUpperCase(Locale.ROOT));
       }
 
       public List<RexNode> getExpressionList(String tag) {

File: core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
Patch:
@@ -84,6 +84,7 @@
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
@@ -831,7 +832,7 @@ public SqlNode field(int ordinal) {
         if (ordinal < fields.size()) {
           RelDataTypeField field = fields.get(ordinal);
           final SqlNode mappedSqlNode =
-              ordinalMap.get(field.getName().toLowerCase());
+              ordinalMap.get(field.getName().toLowerCase(Locale.ROOT));
           if (mappedSqlNode != null) {
             return mappedSqlNode;
           }

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.rel.rules;
 
-import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.avatica.util.TimeUnitRange;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
@@ -36,6 +35,7 @@
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 import org.apache.calcite.util.Bug;
+import org.apache.calcite.util.Util;
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.BoundType;
@@ -290,7 +290,7 @@ RexNode foo(SqlKind comparison, RexNode operand, RexLiteral literal) {
         final Calendar c;
         switch (timeUnit) {
         case YEAR:
-          c = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+          c = Util.calendar();
           c.clear();
           c.set(v, Calendar.JANUARY, 1);
           s2.add(baz(timeUnit, comparison, c));

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
Patch:
@@ -69,8 +69,9 @@ public class MultiJoinOptimizeBushyRule extends RelOptRule {
   public static final MultiJoinOptimizeBushyRule INSTANCE =
       new MultiJoinOptimizeBushyRule(RelFactories.LOGICAL_BUILDER);
 
-  private final PrintWriter pw =
-      CalcitePrepareImpl.DEBUG ? new PrintWriter(System.out, true) : null;
+  private final PrintWriter pw = CalcitePrepareImpl.DEBUG
+      ? Util.printWriter(System.out)
+      : null;
 
   /** Creates an MultiJoinOptimizeBushyRule. */
   public MultiJoinOptimizeBushyRule(RelBuilderFactory relBuilderFactory) {

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -1402,22 +1402,22 @@ private static Object clean(Object o, RelDataType type) {
       if (o instanceof Calendar) {
         return o;
       }
-      calendar = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+      calendar = Util.calendar();
       calendar.setTimeInMillis((Integer) o);
       return calendar;
     case DATE:
       if (o instanceof Calendar) {
         return o;
       }
-      calendar = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+      calendar = Util.calendar();
       calendar.setTimeInMillis(0);
       calendar.add(Calendar.DAY_OF_YEAR, (Integer) o);
       return calendar;
     case TIMESTAMP:
       if (o instanceof Calendar) {
         return o;
       }
-      calendar = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+      calendar = Util.calendar();
       calendar.setTimeInMillis((Long) o);
       return calendar;
     default:

File: core/src/main/java/org/apache/calcite/sql/SqlAccessType.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.sql;
 
 import java.util.EnumSet;
+import java.util.Locale;
 
 /**
  * SqlAccessType is represented by a set of allowed access types
@@ -54,10 +55,9 @@ public String toString() {
   public static SqlAccessType create(String[] accessNames) {
     assert accessNames != null;
     EnumSet<SqlAccessEnum> enumSet = EnumSet.noneOf(SqlAccessEnum.class);
-    for (int i = 0; i < accessNames.length; i++) {
+    for (String accessName : accessNames) {
       enumSet.add(
-          SqlAccessEnum.valueOf(
-              accessNames[i].trim().toUpperCase()));
+          SqlAccessEnum.valueOf(accessName.trim().toUpperCase(Locale.ROOT)));
     }
     return new SqlAccessType(enumSet);
   }

File: core/src/main/java/org/apache/calcite/sql/SqlCollation.java
Patch:
@@ -88,7 +88,8 @@ public SqlCollation(
     this.wrappedCharset = SerializableCharset.forCharset(charset);
     locale = parseValues.getLocale();
     strength = parseValues.getStrength();
-    String c = charset.name().toUpperCase() + "$" + locale.toString();
+    String c =
+        charset.name().toUpperCase(Locale.ROOT) + "$" + locale.toString();
     if ((strength != null) && (strength.length() > 0)) {
       c += "$" + strength;
     }

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -44,6 +44,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * An assistant which offers hints and corrections to a partially-formed SQL
@@ -54,7 +55,8 @@ public class SqlAdvisor {
 
   public static final Logger LOGGER = CalciteTrace.PARSER_LOGGER;
   private static final String HINT_TOKEN = "_suggest_";
-  private static final String UPPER_HINT_TOKEN = HINT_TOKEN.toUpperCase();
+  private static final String UPPER_HINT_TOKEN =
+      HINT_TOKEN.toUpperCase(Locale.ROOT);
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/sql/advise/SqlSimpleParser.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Locale;
 import java.util.Map;
 
 /**
@@ -379,7 +380,7 @@ public Token nextToken() {
               }
             }
             String name = sql.substring(start, pos);
-            TokenType tokenType = map.get(name.toUpperCase());
+            TokenType tokenType = map.get(name.toUpperCase(Locale.ROOT));
             if (tokenType == null) {
               return new IdToken(TokenType.ID, name);
             } else {

File: core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
Patch:
@@ -135,7 +135,7 @@ public static java.sql.Timestamp parseTimestamp(String s) {
    * @param pattern {@link SimpleDateFormat}  pattern
    */
   public static void checkDateFormat(String pattern) {
-    SimpleDateFormat df = new SimpleDateFormat(pattern);
+    SimpleDateFormat df = new SimpleDateFormat(pattern, Locale.ROOT);
     Util.discard(df);
   }
 
@@ -279,9 +279,9 @@ public static String strip(String s, String startQuote, String endQuote,
     }
     switch (casing) {
     case TO_UPPER:
-      return s.toUpperCase();
+      return s.toUpperCase(Locale.ROOT);
     case TO_LOWER:
-      return s.toLowerCase();
+      return s.toLowerCase(Locale.ROOT);
     default:
       return s;
     }

File: core/src/main/java/org/apache/calcite/sql/util/ReflectiveSqlOperatorTable.java
Patch:
@@ -32,6 +32,7 @@
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * ReflectiveSqlOperatorTable implements the {@link SqlOperatorTable} interface
@@ -145,7 +146,7 @@ public List<SqlOperator> getOperatorList() {
    * store case-insensitively, even in a case-sensitive session. */
   private static class Key extends Pair<String, SqlSyntax> {
     Key(String name, SqlSyntax syntax) {
-      super(name.toUpperCase(), normalize(syntax));
+      super(name.toUpperCase(Locale.ROOT), normalize(syntax));
     }
 
     private static SqlSyntax normalize(SqlSyntax syntax) {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -111,6 +111,7 @@
 import java.util.IdentityHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
@@ -3073,7 +3074,7 @@ protected void validateSelect(
       names = Lists.transform(names,
           new Function<String, String>() {
             public String apply(String s) {
-              return s.toUpperCase();
+              return s.toUpperCase(Locale.ROOT);
             }
           });
     }

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -87,6 +87,7 @@
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Objects;
 import java.util.Set;
 import java.util.SortedSet;
@@ -431,7 +432,7 @@ public RexNode field(int inputCount, String alias, String fieldName) {
           return field(inputCount, inputCount - 1 - inputOrdinal, p.i);
         }
         fields.add(
-            String.format("{aliases=%s,fieldName=%s}", p.e.left,
+            String.format(Locale.ROOT, "{aliases=%s,fieldName=%s}", p.e.left,
                 p.e.right.getName()));
       }
     }

File: core/src/main/java/org/apache/calcite/util/NameMap.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.common.collect.ImmutableSortedMap;
 
+import java.util.Locale;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.TreeMap;
@@ -62,7 +63,8 @@ public NavigableMap<String, V> range(String name, boolean caseSensitive) {
         return ImmutableSortedMap.of();
       }
     } else {
-      return map.subMap(name.toUpperCase(), true, name.toLowerCase(), true);
+      return map.subMap(name.toUpperCase(Locale.ROOT), true,
+          name.toLowerCase(Locale.ROOT), true);
     }
   }
 

File: core/src/main/java/org/apache/calcite/util/NameMultimap.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.TreeMap;
@@ -75,7 +76,8 @@ public Collection<Map.Entry<String, V>> range(String name,
       final ImmutableList.Builder<Map.Entry<String, V>> builder =
           ImmutableList.builder();
       NavigableMap<String, List<V>> m =
-          map.subMap(name.toUpperCase(), true, name.toLowerCase(), true);
+          map.subMap(name.toUpperCase(Locale.ROOT), true,
+              name.toLowerCase(Locale.ROOT), true);
       for (Map.Entry<String, List<V>> entry : m.entrySet()) {
         for (V v : entry.getValue()) {
           builder.add(Pair.of(entry.getKey(), v));

File: core/src/main/java/org/apache/calcite/util/NlsString.java
Patch:
@@ -27,6 +27,7 @@
 import java.nio.charset.IllegalCharsetNameException;
 import java.nio.charset.UnsupportedCharsetException;
 import java.util.List;
+import java.util.Locale;
 import java.util.Objects;
 
 import static org.apache.calcite.util.Static.RESOURCE;
@@ -63,7 +64,7 @@ public NlsString(
       SqlCollation collation) {
     assert value != null;
     if (null != charsetName) {
-      charsetName = charsetName.toUpperCase();
+      charsetName = charsetName.toUpperCase(Locale.ROOT);
       this.charsetName = charsetName;
       String javaCharsetName =
           SqlUtil.translateCharacterSetName(charsetName);

File: core/src/main/java/org/apache/calcite/util/ZonelessDatetime.java
Patch:
@@ -21,6 +21,7 @@
 import java.io.Serializable;
 import java.text.DateFormat;
 import java.util.Calendar;
+import java.util.Locale;
 import java.util.TimeZone;
 
 /**
@@ -171,7 +172,7 @@ public long getJdbcTimestamp(TimeZone zone) {
    */
   protected Calendar getCalendar(TimeZone zone) {
     if (tempCal == null) {
-      tempCal = Calendar.getInstance(zone);
+      tempCal = Calendar.getInstance(zone, Locale.ROOT);
     } else {
       tempCal.setTimeZone(zone);
     }

File: core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java
Patch:
@@ -24,6 +24,7 @@
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -67,7 +68,7 @@ public void compile() {
     Map<String, byte[]> sourceMap = new HashMap<String, byte[]>();
     sourceMap.put(
         ClassFile.getSourceResourceName(args.fullClassName),
-        args.source.getBytes());
+        args.source.getBytes(StandardCharsets.UTF_8));
     MapResourceFinder sourceFinder = new MapResourceFinder(sourceMap);
 
     classLoader =

File: core/src/main/java/org/apache/calcite/util/trace/CalciteTimingTracer.java
Patch:
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.util.trace;
 
+import org.apache.calcite.util.NumberUtil;
+
 import org.slf4j.Logger;
 
 import java.text.DecimalFormat;
@@ -28,7 +30,7 @@ public class CalciteTimingTracer {
   //~ Static fields/initializers ---------------------------------------------
 
   private static final DecimalFormat DECIMAL_FORMAT =
-      new DecimalFormat("###,###,###,###,###");
+      NumberUtil.decimalFormat("###,###,###,###,###");
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/test/java/org/apache/calcite/rex/RexExecutorTest.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.DataContext;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.avatica.util.ByteString;
-import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.linq4j.QueryProvider;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelOptSchema;
@@ -38,6 +37,7 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.tools.Frameworks;
 import org.apache.calcite.util.NlsString;
+import org.apache.calcite.util.Util;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableList;
@@ -159,7 +159,7 @@ public RexNode apply(RexBuilder rexBuilder) {
     checkConstant(true,
         new Function<RexBuilder, RexNode>() {
           public RexNode apply(RexBuilder rexBuilder) {
-            Calendar calendar = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+            Calendar calendar = Util.calendar();
             return rexBuilder.makeCall(SqlStdOperatorTable.LESS_THAN_OR_EQUAL,
                 rexBuilder.makeDateLiteral(calendar),
                 rexBuilder.makeDateLiteral(calendar));
@@ -169,7 +169,7 @@ public RexNode apply(RexBuilder rexBuilder) {
     checkConstant(false,
         new Function<RexBuilder, RexNode>() {
           public RexNode apply(RexBuilder rexBuilder) {
-            Calendar calendar = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+            Calendar calendar = Util.calendar();
             return rexBuilder.makeCall(SqlStdOperatorTable.LESS_THAN,
                 rexBuilder.makeDateLiteral(calendar),
                 rexBuilder.makeDateLiteral(calendar));

File: core/src/test/java/org/apache/calcite/test/DiffRepository.java
Patch:
@@ -34,7 +34,6 @@
 import org.xml.sax.SAXException;
 
 import java.io.File;
-import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.net.URL;
@@ -526,7 +525,7 @@ private void flushDoc() {
     try {
       boolean b = logFile.getParentFile().mkdirs();
       Util.discard(b);
-      try (FileWriter w = new FileWriter(logFile)) {
+      try (Writer w = Util.printWriter(logFile)) {
         write(doc, w, indent);
       }
     } catch (IOException e) {

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.avatica.util.ByteString;
-import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.jdbc.JavaTypeFactoryImpl;
 import org.apache.calcite.plan.Strong;
 import org.apache.calcite.rel.type.RelDataType;
@@ -1310,7 +1309,7 @@ private void checkExponentialCnf(int n) {
   }
 
   private Calendar cal(int y, int m, int d, int h, int mm, int s) {
-    final Calendar c = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
+    final Calendar c = Util.calendar();
     c.set(Calendar.YEAR, y);
     c.set(Calendar.MONTH, m);
     c.set(Calendar.DAY_OF_MONTH, d);

File: core/src/test/java/org/apache/calcite/test/SqlFunctionsTest.java
Patch:
@@ -88,11 +88,11 @@ public class SqlFunctionsTest {
   }
 
   @Test public void testLower() {
-    assertEquals("a bcd", lower("A bCd"));
+    assertEquals("a bcd iijk", lower("A bCd Iijk"));
   }
 
   @Test public void testUpper() {
-    assertEquals("A BCD", upper("A bCd"));
+    assertEquals("A BCD IIJK", upper("A bCd iIjk"));
   }
 
   @Test public void testInitcap() {

File: core/src/test/java/org/apache/calcite/test/SqlLimitsTest.java
Patch:
@@ -211,11 +211,11 @@ private void printLimit(
   private DateFormat getDateFormat(SqlTypeName typeName) {
     switch (typeName) {
     case DATE:
-      return new SimpleDateFormat("MMM d, yyyy");
+      return new SimpleDateFormat("MMM d, yyyy", Locale.ROOT);
     case TIME:
-      return new SimpleDateFormat("hh:mm:ss a");
+      return new SimpleDateFormat("hh:mm:ss a", Locale.ROOT);
     default:
-      return new SimpleDateFormat("MMM d, yyyy hh:mm:ss a");
+      return new SimpleDateFormat("MMM d, yyyy hh:mm:ss a", Locale.ROOT);
     }
   }
 }

File: core/src/test/java/org/apache/calcite/test/SqlTestGen.java
Patch:
@@ -24,9 +24,9 @@
 import org.apache.calcite.sql.test.SqlTesterImpl;
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.util.BarfingInvocationHandler;
+import org.apache.calcite.util.Util;
 
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.lang.reflect.InvocationTargetException;
@@ -51,8 +51,7 @@ public static void main(String[] args) {
 
   private void genValidatorTest() {
     final File file = new File("validatorTest.sql");
-    try (FileOutputStream fos = new FileOutputStream(file);
-         PrintWriter pw = new PrintWriter(fos)) {
+    try (PrintWriter pw = Util.printWriter(file)) {
       Method[] methods = getJunitMethods(SqlValidatorSpooler.class);
       for (Method method : methods) {
         final SqlValidatorSpooler test = new SqlValidatorSpooler(pw);

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -3637,7 +3637,7 @@ public void subTestIntervalSecondNegative() {
 
     for (String interval : tsi) {
       for (String function : functions) {
-        checkExp(String.format(function, interval));
+        checkExp(String.format(Locale.ROOT, function, interval));
       }
     }
 
@@ -7844,7 +7844,7 @@ public void _testValuesWithAggFuncs() {
       case INTERNAL:
         break;
       default:
-        assertThat(name.toUpperCase(), equalTo(name));
+        assertThat(name.toUpperCase(Locale.ROOT), equalTo(name));
         break;
       }
     }

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -962,7 +962,7 @@ String translate(RexNode e, boolean set) {
       case OR:
       case NOT:
         call = (RexCall) e;
-        return new JsonCompositeFilter(e.getKind().toString().toLowerCase(),
+        return new JsonCompositeFilter(e.getKind().lowerName,
             translateFilters(call.getOperands()));
       }
       throw new AssertionError("cannot translate filter: " + e);

File: druid/src/main/java/org/apache/calcite/adapter/druid/Granularity.java
Patch:
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.adapter.druid;
 
+import java.util.Locale;
+
 /** Granularity of a Druid query. */
 public enum Granularity {
   ALL,
@@ -30,7 +32,7 @@ public enum Granularity {
   NONE;
 
   /** JSON attribute value in a Druid query. */
-  public final String value = name().toLowerCase();
+  public final String value = name().toLowerCase(Locale.ROOT);
 }
 
 // End Granularity.java

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
Patch:
@@ -39,6 +39,7 @@
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 
@@ -93,7 +94,8 @@ private String translateMatch(RexNode condition) {
       final Map<String, Object> map = builder.map();
       map.put("constant_score", filterMap);
 
-      return "\"query\" : " + builder.toJsonString(map).replaceAll("\\s+", "").toLowerCase();
+      return "\"query\" : " + builder.toJsonString(map).replaceAll("\\s+", "")
+          .toLowerCase(Locale.ROOT);
     }
 
     private Object translateOr(RexNode condition) {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvSchemaFactory.java
Patch:
@@ -22,6 +22,7 @@
 import org.apache.calcite.schema.SchemaPlus;
 
 import java.io.File;
+import java.util.Locale;
 import java.util.Map;
 
 /**
@@ -56,7 +57,7 @@ public Schema create(SchemaPlus parentSchema, String name,
     if (flavorName == null) {
       flavor = CsvTable.Flavor.SCANNABLE;
     } else {
-      flavor = CsvTable.Flavor.valueOf(flavorName.toUpperCase());
+      flavor = CsvTable.Flavor.valueOf(flavorName.toUpperCase(Locale.ROOT));
     }
     return new CsvSchema(directoryFile, flavor);
   }

File: example/csv/src/test/java/org/apache/calcite/test/CsvTest.java
Patch:
@@ -31,7 +31,6 @@
 import org.junit.Test;
 
 import java.io.File;
-import java.io.FileWriter;
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import java.net.URL;
@@ -582,7 +581,7 @@ private String range(int first, int count) {
 
     try (final Connection connection =
              DriverManager.getConnection("jdbc:calcite:model=inline:" + model);
-         final PrintWriter pw = new PrintWriter(new FileWriter(file));
+         final PrintWriter pw = Util.printWriter(file);
          final Worker<Void> worker = new Worker<>()) {
       final Thread thread = new Thread(worker);
       thread.start();

File: example/function/src/main/java/org/apache/calcite/example/maze/MazeTable.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.schema.ScannableTable;
 import org.apache.calcite.schema.impl.AbstractTable;
 import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.calcite.util.Util;
 
 import java.io.PrintWriter;
 import java.util.Random;
@@ -88,7 +89,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
   public Enumerable<Object[]> scan(DataContext root) {
     final Random random = seed >= 0 ? new Random(seed) : new Random();
     final Maze maze = new Maze(width, height);
-    final PrintWriter pw = new PrintWriter(System.out);
+    final PrintWriter pw = Util.printWriter(System.out);
     maze.layout(random, pw);
     if (Maze.DEBUG) {
       maze.print(pw, true);

File: plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
Patch:
@@ -41,6 +41,7 @@
 import java.sql.Date;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 
 /** Schema that provides TPC-DS tables, populated according to a
@@ -88,7 +89,7 @@ public TpcdsSchema(double scaleFactor, int part, int partCount) {
     final ImmutableMap.Builder<String, Table> builder = ImmutableMap.builder();
     for (TpcdsTable<?> tpcdsTable : TpcdsTable.getTables()) {
       //noinspection unchecked
-      builder.put(tpcdsTable.getTableName().toUpperCase(),
+      builder.put(tpcdsTable.getTableName().toUpperCase(Locale.ROOT),
           new TpcdsQueryableTable(tpcdsTable));
     }
     this.tableMap = builder.build();
@@ -166,7 +167,7 @@ public void close() {
     public RelDataType getRowType(RelDataTypeFactory typeFactory) {
       final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
       for (TpcdsColumn<E> column : tpcdsTable.getColumns()) {
-        builder.add(column.getColumnName().toUpperCase(),
+        builder.add(column.getColumnName().toUpperCase(Locale.ROOT),
             typeFactory.createJavaType(realType(column)));
       }
       return builder.build();

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
Patch:
@@ -72,6 +72,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 import java.util.Random;
 
 /**
@@ -445,7 +446,7 @@ public List<Pair<String, Integer>> call(String x) {
                   return Collections.emptyList();
                 }
                 return Collections.singletonList(
-                    Pair.of(x.toUpperCase(), x.length()));
+                    Pair.of(x.toUpperCase(Locale.ROOT), x.length()));
               }
             })
             .take(5)

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java
Patch:
@@ -1334,11 +1334,11 @@ public Void apply(ResultSet resultSet) {
         + "and extract(month from \"timestamp\") in (4, 6)\n";
     final String explain = "EnumerableInterpreter\n"
         + "  BindableAggregate(group=[{}], C=[COUNT()])\n"
-        + "    BindableFilter(condition=[AND(>=(/INT(Reinterpret($0), 86400000), 1997-01-01), <(/INT(Reinterpret($0), 86400000), 1998-01-01), >=(/INT(Reinterpret($0), 86400000), 1997-04-01), <(/INT(Reinterpret($0), 86400000), 1997-05-01))])\n"
+        + "    BindableFilter(condition=[AND(>=(/INT(Reinterpret($0), 86400000), 1997-01-01), <(/INT(Reinterpret($0), 86400000), 1998-01-01), OR(AND(>=(/INT(Reinterpret($0), 86400000), 1997-04-01), <(/INT(Reinterpret($0), 86400000), 1997-05-01)), AND(>=(/INT(Reinterpret($0), 86400000), 1997-06-01), <(/INT(Reinterpret($0), 86400000), 1997-07-01))))])\n"
         + "      DruidQuery(table=[[foodmart, foodmart]], intervals=[[1900-01-09T00:00:00.000/2992-01-10T00:00:00.000]])";
     sql(sql)
         .explainContains(explain)
-        .returnsUnordered("C=6588");
+        .returnsUnordered("C=13500");
   }
 
   @Test public void testFilterSwapped() {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -3808,9 +3808,9 @@ private void checkFieldCount(
       if (!field.getType().isNullable()) {
         final RelDataTypeField targetField =
             logicalTargetRowType.getField(field.getName(), true, false);
-        final boolean haveDefaultValue =
-            table.columnHasDefaultValue(table.getRowType(), field.getIndex());
-        if (targetField == null && !haveDefaultValue) {
+        if (targetField == null
+            && !table.columnHasDefaultValue(table.getRowType(),
+                field.getIndex())) {
           throw newValidationError(node,
               RESOURCE.columnNotNullable(field.getName()));
         }

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -1449,6 +1449,9 @@ public static <E> boolean all(
    * Shifts every {@link RexInputRef} in an expression by {@code offset}.
    */
   public static RexNode shift(RexNode node, final int offset) {
+    if (offset == 0) {
+      return node;
+    }
     return node.accept(new RexShiftShuttle(offset));
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -1243,7 +1243,7 @@ private RexNode translateIn(RelOptUtil.Logic logic, RelNode root,
       final RexLiteral trueLiteral = rexBuilder.makeLiteral(true);
       final RexLiteral falseLiteral = rexBuilder.makeLiteral(false);
       final RexNode unknownLiteral =
-          rexBuilder.makeNullLiteral(SqlTypeName.BOOLEAN);
+          rexBuilder.makeNullLiteral(trueLiteral.getType());
 
       final ImmutableList.Builder<RexNode> args = ImmutableList.builder();
       args.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, cRef, zero),
@@ -2984,7 +2984,7 @@ private RelNode createSource(RelOptTable targetTable, RelNode source,
     for (RelDataTypeField field : delegateRowType.getFieldList()) {
       RexNode node = projectMap.get(field.getIndex());
       if (node == null) {
-        node = rexBuilder.makeNullLiteral(field.getType().getSqlTypeName());
+        node = rexBuilder.makeNullLiteral(field.getType());
       }
       projects.add(
           Pair.of(rexBuilder.ensureType(field.getType(), node, false),

File: core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
Patch:
@@ -202,7 +202,7 @@ public RexNode convertCall(SqlRexContext cx, SqlCall call) {
             if (operands.size() % 2 == 0) {
               exprs.add(Util.last(operands));
             } else {
-              exprs.add(rexBuilder.makeNullLiteral(type.getSqlTypeName()));
+              exprs.add(rexBuilder.makeNullLiteral(type));
             }
             return rexBuilder.makeCall(type, SqlStdOperatorTable.CASE, exprs);
           }
@@ -1447,7 +1447,7 @@ public RexNode convertCall(SqlRexContext cx, SqlCall call) {
         orList.add(rexBuilder.makeCall(SqlStdOperatorTable.IS_NULL, expr));
       }
       list.add(RexUtil.composeDisjunction(rexBuilder, orList, false));
-      list.add(rexBuilder.makeNullLiteral(type.getSqlTypeName()));
+      list.add(rexBuilder.makeNullLiteral(type));
       for (int i = 0; i < exprs.size() - 1; i++) {
         RexNode expr = exprs.get(i);
         final List<RexNode> andList = new ArrayList<>();

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1111,10 +1111,12 @@ private void checkCollation(RelOptCluster cluster, RelOptTable empTable,
   private void addRow(ImmutableList.Builder<ImmutableList<RexLiteral>> builder,
       RexBuilder rexBuilder, Object... values) {
     ImmutableList.Builder<RexLiteral> b = ImmutableList.builder();
+    final RelDataType varcharType =
+        rexBuilder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR);
     for (Object value : values) {
       final RexLiteral literal;
       if (value == null) {
-        literal = (RexLiteral) rexBuilder.makeNullLiteral(SqlTypeName.VARCHAR);
+        literal = rexBuilder.makeNullLiteral(varcharType);
       } else if (value instanceof Integer) {
         literal = rexBuilder.makeExactLiteral(
             BigDecimal.valueOf((Integer) value));

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -906,7 +906,9 @@ private RelBuilder createSelectDistinct(RelBuilder relBuilder,
             rexBuilder.makeCall(SqlStdOperatorTable.CASE, filterRef,
                 argRef.left,
                 rexBuilder.ensureType(argRef.left.getType(),
-                    rexBuilder.constantNull(), true));
+                    rexBuilder.makeCast(argRef.left.getType(),
+                        rexBuilder.constantNull()),
+                    true));
         sourceOf.put(arg, projects.size());
         projects.add(Pair.of(condition, "i$" + argRef.right));
         continue;

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -351,7 +351,7 @@ private RexNode reduceSum(
     return rexBuilder.makeCall(SqlStdOperatorTable.CASE,
         rexBuilder.makeCall(SqlStdOperatorTable.EQUALS,
             countRef, rexBuilder.makeExactLiteral(BigDecimal.ZERO)),
-        rexBuilder.constantNull(),
+        rexBuilder.makeCast(sumZeroRef.getType(), rexBuilder.constantNull()),
         sumZeroRef);
   }
 
@@ -469,7 +469,7 @@ private RexNode reduceStddev(
       final RexLiteral one =
           rexBuilder.makeExactLiteral(BigDecimal.ONE);
       final RexNode nul =
-          rexBuilder.makeNullLiteral(countArg.getType().getSqlTypeName());
+          rexBuilder.makeCast(countArg.getType(), rexBuilder.constantNull());
       final RexNode countMinusOne =
           rexBuilder.makeCall(
               SqlStdOperatorTable.MINUS, countArg, one);

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateValuesRule.java
Patch:
@@ -79,7 +79,8 @@ private AggregateValuesRule() {
       case MIN:
       case MAX:
       case SUM:
-        literals.add(rexBuilder.constantNull());
+        literals.add((RexLiteral) rexBuilder.makeCast(
+            aggregateCall.getType(), rexBuilder.constantNull()));
         break;
 
       default:

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -981,7 +981,7 @@ public RelBuilder aggregate(GroupKey groupKey, Iterable<AggCall> aggCalls) {
     final ImmutableBitSet groupSet =
         ImmutableBitSet.of(registerExpressions(extraNodes, groupKey_.nodes));
   label:
-    if (Iterables.isEmpty(aggCalls)) {
+    if (Iterables.isEmpty(aggCalls) && !groupKey_.indicator) {
       final RelMetadataQuery mq = RelMetadataQuery.instance();
       if (groupSet.isEmpty()) {
         final Double minRowCount = mq.getMinRowCount(peek());

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -4679,7 +4679,7 @@ private CalciteAssert.AssertQuery predicate(String foo) {
   @Test public void testNotExistsCorrelated() {
     final String plan = "PLAN="
         + "EnumerableCalc(expr#0..5=[{inputs}], expr#6=[IS NULL($t5)], proj#0..4=[{exprs}], $condition=[$t6])\n"
-        + "  EnumerableCorrelate(correlation=[$cor0], joinType=[LEFT], requiredColumns=[{1}])\n"
+        + "  EnumerableCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{1}])\n"
         + "    EnumerableTableScan(table=[[hr, emps]])\n"
         + "    EnumerableAggregate(group=[{0}])\n"
         + "      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[true], expr#5=[$cor0], expr#6=[$t5.deptno], expr#7=[=($t6, $t0)], i=[$t4], $condition=[$t7])\n"

File: core/src/test/java/org/apache/calcite/test/RelBuilderTest.java
Patch:
@@ -1032,7 +1032,7 @@ private String str(RelNode r) {
     // Note that the join filter gets pushed to the right-hand input of
     // LogicalCorrelate
     final String expected = ""
-        + "LogicalCorrelate(correlation=[$cor0], joinType=[LEFT], requiredColumns=[{7}])\n"
+        + "LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{7}])\n"
         + "  LogicalTableScan(table=[[scott, EMP]])\n"
         + "  LogicalFilter(condition=[=($cor0.SAL, 1000)])\n"
         + "    LogicalFilter(condition=[=($0, $cor0.DEPTNO)])\n"

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCorrelateTest.java
Patch:
@@ -53,7 +53,7 @@ public class EnumerableCorrelateTest {
             "select empid, name from emps e where exists (select 1 from depts d where d.deptno=e.deptno)")
         .explainContains(""
             + "EnumerableCalc(expr#0..3=[{inputs}], empid=[$t0], name=[$t2])\n"
-            + "  EnumerableCorrelate(correlation=[$cor0], joinType=[INNER], requiredColumns=[{1}])\n"
+            + "  EnumerableCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{1}])\n"
             + "    EnumerableCalc(expr#0..4=[{inputs}], proj#0..2=[{exprs}])\n"
             + "      EnumerableTableScan(table=[[s, emps]])\n"
             + "    EnumerableAggregate(group=[{0}])\n"

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -3984,7 +3984,8 @@ Pair<RexNode, Map<String, Integer>> lookupExp(SqlQualified qualified) {
             builder.addAll(c.getRowType().getFieldList());
             if (i == resolve.path.steps().get(0).i) {
               for (RelDataTypeField field : c.getRowType().getFieldList()) {
-                fields.put(field.getName(), field.getIndex() + offset);
+                fields.put(c.translate(field.getName()),
+                    field.getIndex() + offset);
               }
             }
             ++i;

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinRule.java
Patch:
@@ -60,8 +60,8 @@ public boolean test(Join input) {
 
   /* Tests if an Aggregate always produces 1 row and 0 columns. */
   private static final Predicate<Aggregate> IS_EMPTY_AGGREGATE =
-      new Predicate<Aggregate>() {
-        public boolean apply(Aggregate input) {
+      new PredicateImpl<Aggregate>() {
+        public boolean test(Aggregate input) {
           return input.getRowType().getFieldCount() == 0;
         }
       };

File: avatica/core/src/main/java/org/apache/calcite/avatica/Meta.java
Patch:
@@ -909,7 +909,7 @@ public Frame(long offset, boolean done, Iterable<Object> rows) {
     }
 
     @JsonCreator
-    public static Frame create(@JsonProperty("offset") int offset,
+    public static Frame create(@JsonProperty("offset") long offset,
         @JsonProperty("done") boolean done,
         @JsonProperty("rows") List<Object> rows) {
       if (offset == 0 && done && rows.isEmpty()) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
Patch:
@@ -191,7 +191,8 @@ && getRowType().getFieldCount() == 1
 
   private Expression fieldExpression(ParameterExpression row_, int i,
       PhysType physType, JavaRowFormat format) {
-    final Expression e = format.field(row_, i, physType.getJavaFieldType(i));
+    final Expression e =
+        format.field(row_, i, null, physType.getJavaFieldType(i));
     final RelDataType relFieldType =
         physType.getRowType().getFieldList().get(i).getType();
     switch (relFieldType.getSqlTypeName()) {

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -1537,6 +1537,7 @@ public static int toInt(Object o) {
     return o instanceof Integer ? (Integer) o
         : o instanceof Number ? toInt((Number) o)
         : o instanceof String ? toInt((String) o)
+        : o instanceof java.util.Date ? toInt((java.util.Date) o)
         : (Integer) cannotConvert(o, int.class);
   }
 

File: core/src/main/java/org/apache/calcite/jdbc/CalciteConnectionImpl.java
Patch:
@@ -61,7 +61,6 @@
 import org.apache.calcite.util.Holder;
 
 import com.google.common.base.Preconditions;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
@@ -163,7 +162,7 @@ public PreparedStatement prepare(RelNode rel) {
                     ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
                     getHoldability());
               } catch (SQLException e) {
-                throw Throwables.propagate(e);
+                throw new RuntimeException(e);
               }
             }
           });
@@ -288,7 +287,7 @@ public <T> Enumerable<T> enumerable(Meta.StatementHandle handle,
     try {
       cancelFlag = getCancelFlag(handle);
     } catch (NoSuchStatementException e) {
-      throw Throwables.propagate(e);
+      throw new RuntimeException(e);
     }
     map.put(DataContext.Variable.CANCEL_FLAG.camelName, cancelFlag);
     final DataContext dataContext = createDataContext(map);

File: core/src/main/java/org/apache/calcite/materialize/CachingLatticeStatisticProvider.java
Patch:
@@ -17,8 +17,8 @@
 package org.apache.calcite.materialize;
 
 import org.apache.calcite.util.Pair;
+import org.apache.calcite.util.Util;
 
-import com.google.common.base.Throwables;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
@@ -50,7 +50,8 @@ public int cardinality(Lattice lattice, Lattice.Column column) {
     try {
       return cache.get(Pair.of(lattice, column));
     } catch (UncheckedExecutionException | ExecutionException e) {
-      throw Throwables.propagate(e.getCause());
+      Util.throwIfUnchecked(e.getCause());
+      throw new RuntimeException(e.getCause());
     }
   }
 }

File: core/src/main/java/org/apache/calcite/plan/ConventionTraitDef.java
Patch:
@@ -20,7 +20,6 @@
 import org.apache.calcite.rel.convert.ConverterRule;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.util.Pair;
-import org.apache.calcite.util.Util;
 import org.apache.calcite.util.graph.DefaultDirectedGraph;
 import org.apache.calcite.util.graph.DefaultEdge;
 import org.apache.calcite.util.graph.DirectedGraph;
@@ -159,8 +158,7 @@ public RelNode convert(
                   converted, previous, arc,
                   conversionData.mapArcToConverterRule);
           if (converted == null) {
-            throw Util.newInternal("Converter from " + previous
-                + " to " + arc
+            throw new AssertionError("Converter from " + previous + " to " + arc
                 + " guaranteed that it could convert any relexp");
           }
         }

File: core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
Patch:
@@ -924,9 +924,8 @@ private void assertNoCycles() {
       return;
     }
 
-    throw Util.newInternal(
-        "Query graph cycle detected in HepPlanner:  "
-            + cyclicVertices);
+    throw new AssertionError("Query graph cycle detected in HepPlanner: "
+        + cyclicVertices);
   }
 
   private void dumpGraph() {

File: core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
Patch:
@@ -361,7 +361,7 @@ public String recomputeDigest() {
   public void replaceInput(
       int ordinalInParent,
       RelNode p) {
-    throw Util.newInternal("replaceInput called on " + this);
+    throw new UnsupportedOperationException("replaceInput called on " + this);
   }
 
   public String toString() {

File: core/src/main/java/org/apache/calcite/rel/BiRel.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.runtime.FlatLists;
-import org.apache.calcite.util.Util;
 
 import java.util.List;
 
@@ -70,7 +69,7 @@ public void replaceInput(
       this.right = p;
       break;
     default:
-      throw Util.newInternal();
+      throw new IndexOutOfBoundsException("Input " + ordinalInParent);
     }
     recomputeDigest();
   }

File: core/src/main/java/org/apache/calcite/rel/metadata/CachingRelMetadataProvider.java
Patch:
@@ -20,7 +20,6 @@
 import org.apache.calcite.rel.RelNode;
 
 import com.google.common.base.Preconditions;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Multimap;
 
@@ -141,8 +140,7 @@ public Object invoke(Object proxy, Method method, Object[] args)
         }
         return result;
       } catch (InvocationTargetException e) {
-        Throwables.propagateIfPossible(e.getCause());
-        throw e;
+        throw e.getCause();
       }
     }
   }

File: core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java
Patch:
@@ -17,8 +17,8 @@
 package org.apache.calcite.rel.metadata;
 
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.util.Util;
 
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Lists;
@@ -140,8 +140,8 @@ public Object invoke(Object proxy, Method method, Object[] args)
           if (e.getCause() instanceof CyclicMetadataException) {
             continue;
           }
-          Throwables.propagateIfPossible(e.getCause());
-          throw e;
+          Util.throwIfUnchecked(e.getCause());
+          throw new RuntimeException(e.getCause());
         }
       }
       return null;

File: core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
Patch:
@@ -26,7 +26,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Preconditions;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
@@ -197,8 +196,8 @@ public Object invoke(Object proxy, Method method,
                         return handlerMethod.invoke(target, args1);
                       } catch (InvocationTargetException
                           | UndeclaredThrowableException e) {
-                        Throwables.propagateIfPossible(e.getCause());
-                        throw e;
+                        Util.throwIfUnchecked(e.getCause());
+                        throw new RuntimeException(e.getCause());
                       } finally {
                         mq.map.remove(key);
                       }

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
Patch:
@@ -41,13 +41,13 @@
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.util.ImmutableIntList;
 import org.apache.calcite.util.Pair;
-import org.apache.calcite.util.Util;
 import org.apache.calcite.util.graph.DefaultDirectedGraph;
 import org.apache.calcite.util.graph.DefaultEdge;
 import org.apache.calcite.util.graph.DirectedGraph;
 import org.apache.calcite.util.graph.TopologicalOrderIterator;
 
 import com.google.common.base.Function;
+import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
@@ -226,7 +226,7 @@ protected boolean supportsCondition() {
 
         protected RelNode makeRel(RelOptCluster cluster, RelTraitSet traitSet,
             RelBuilder relBuilder, RelNode input, RexProgram program) {
-          Util.permAssert(program.getCondition() == null,
+          Preconditions.checkArgument(program.getCondition() == null,
               "WindowedAggregateRel cannot accept a condition");
           return LogicalWindow.create(cluster, traitSet, relBuilder, input,
               program);

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -868,8 +868,7 @@ public RexNode expand(RexCall call) {
       } else if (call.getOperator() == SqlStdOperatorTable.MOD) {
         return expandMod(call, operands);
       } else {
-        throw Util.newInternal(
-            "ReduceDecimalsRule could not expand "
+        throw new AssertionError("ReduceDecimalsRule could not expand "
             + call.getOperator());
       }
     }

File: core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
Patch:
@@ -29,7 +29,6 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 import org.apache.calcite.util.NlsString;
-import org.apache.calcite.util.Util;
 
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
@@ -211,7 +210,7 @@ public SqlMonotonicity getOperandMonotonicity(int ordinal) {
             RESOURCE.numberLiteralOutOfRange(bd.toString()));
       }
     }
-    throw Util.newInternal("should never come here");
+    throw new AssertionError();
   }
 
   @Override public Comparable getOperandLiteralValue(int ordinal) {

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -371,9 +371,10 @@ public static String stringValue(SqlNode node) {
       return literal.toValue();
     } else if (node instanceof SqlCall
         && ((SqlCall) node).getOperator() == SqlStdOperatorTable.CAST) {
+      //noinspection deprecation
       return stringValue(((SqlCall) node).operand(0));
     } else {
-      throw Util.newInternal("invalid string literal: " + node);
+      throw new AssertionError("invalid string literal: " + node);
     }
   }
 
@@ -387,7 +388,7 @@ public static SqlLiteral unchain(SqlNode node) {
     } else if (SqlUtil.isLiteralChain(node)) {
       return SqlLiteralChainOperator.concatenateOperands((SqlCall) node);
     } else {
-      throw Util.newInternal("invalid literal: " + node);
+      throw new AssertionError("invalid literal: " + node);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
Patch:
@@ -69,8 +69,7 @@ protected RelDataType adjustType(
       RelDataType operandType =
           validator.getValidatedNodeType(call.operand(0));
       if (null == operandType) {
-        throw Util.newInternal(
-            "operand's type should have been derived");
+        throw new AssertionError("operand's type should have been derived");
       }
       if (SqlTypeUtil.inCharFamily(operandType)) {
         SqlCollation collation = operandType.getCollation();

File: core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
Patch:
@@ -70,8 +70,7 @@ protected RelDataType adjustType(
       RelDataType operandType =
           validator.getValidatedNodeType(call.operand(0));
       if (null == operandType) {
-        throw Util.newInternal(
-            "operand's type should have been derived");
+        throw new AssertionError("operand's type should have been derived");
       }
       if (SqlTypeUtil.inCharFamily(operandType)) {
         SqlCollation collation = operandType.getCollation();

File: core/src/main/java/org/apache/calcite/sql/SqlSyntax.java
Patch:
@@ -141,8 +141,8 @@ public void unparse(
         SqlCall call,
         int leftPrec,
         int rightPrec) {
-      throw Util.newInternal("Internal operator '" + operator
-          + "' cannot be un-parsed");
+      throw new UnsupportedOperationException("Internal operator '"
+          + operator + "' " + "cannot be un-parsed");
     }
   };
 

File: core/src/main/java/org/apache/calcite/sql/SqlWindow.java
Patch:
@@ -698,7 +698,7 @@ private void validateFrameBoundary(
       }
       break;
     default:
-      throw Util.newInternal("Unexpected node type");
+      throw new AssertionError("Unexpected node type");
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.sql.type.SqlOperandCountRanges;
 import org.apache.calcite.sql.type.SqlTypeUtil;
-import org.apache.calcite.util.Util;
 
 /**
  * An operator describing the <code>LIKE</code> and <code>SIMILAR</code>
@@ -119,8 +118,8 @@ public boolean checkOperandTypes(
       // enforce the escape character length to be 1
       break;
     default:
-      throw Util.newInternal(
-          "unexpected number of args to " + callBinding.getCall());
+      throw new AssertionError("unexpected number of args to "
+          + callBinding.getCall() + ": " + callBinding.getOperandCount());
     }
 
     return SqlTypeUtil.isCharTypeComparable(

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMinMaxAggFunction.java
Patch:
@@ -24,7 +24,6 @@
 import org.apache.calcite.sql.SqlSplittableAggFunction;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
-import org.apache.calcite.util.Util;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
@@ -113,7 +112,7 @@ public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     case MINMAX_COMPARATOR:
       return argTypes.subList(1, 2);
     default:
-      throw Util.newInternal("bad kind: " + minMaxKind);
+      throw new AssertionError("bad kind: " + minMaxKind);
     }
   }
 
@@ -125,7 +124,7 @@ public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     case MINMAX_COMPARATOR:
       return argTypes.get(1);
     default:
-      throw Util.newInternal("bad kind: " + minMaxKind);
+      throw new AssertionError("bad kind: " + minMaxKind);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.sql.SqlCollation;
 import org.apache.calcite.util.SerializableCharset;
-import org.apache.calcite.util.Util;
 
 import com.google.common.base.Preconditions;
 
@@ -104,7 +103,7 @@ BasicSqlType createWithNullability(boolean nullable) {
     try {
       ret = (BasicSqlType) this.clone();
     } catch (CloneNotSupportedException e) {
-      throw Util.newInternal(e);
+      throw new AssertionError(e);
     }
     ret.isNullable = nullable;
     ret.computeDigest();
@@ -124,7 +123,7 @@ BasicSqlType createWithCharsetAndCollation(
     try {
       ret = (BasicSqlType) this.clone();
     } catch (CloneNotSupportedException e) {
-      throw Util.newInternal(e);
+      throw new AssertionError(e);
     }
     ret.wrappedCharset = SerializableCharset.forCharset(charset);
     ret.collation = collation;

File: core/src/main/java/org/apache/calcite/sql/validate/SetopNamespace.java
Patch:
@@ -20,7 +20,6 @@
 import org.apache.calcite.sql.SqlCall;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlNode;
-import org.apache.calcite.util.Util;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -107,7 +106,7 @@ public RelDataType validateImpl(RelDataType targetRowType) {
           scope,
           call);
     default:
-      throw Util.newInternal("Not a query: " + call.getKind());
+      throw new AssertionError("Not a query: " + call.getKind());
     }
   }
 }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java
Patch:
@@ -17,7 +17,8 @@
 package org.apache.calcite.sql.validate;
 
 import org.apache.calcite.sql.SqlIdentifier;
-import org.apache.calcite.util.Util;
+
+import com.google.common.base.Preconditions;
 
 import java.util.List;
 
@@ -36,8 +37,7 @@ public class SqlIdentifierMoniker implements SqlMoniker {
    * Creates an SqlIdentifierMoniker.
    */
   public SqlIdentifierMoniker(SqlIdentifier id) {
-    Util.pre(id != null, "id != null");
-    this.id = id;
+    this.id = Preconditions.checkNotNull(id);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -909,7 +909,7 @@ public TrimResult trimFields(
     if (!inputMapping.isIdentity()) {
       // We asked for all fields. Can't believe that the child decided
       // to permute them!
-      throw Util.newInternal(
+      throw new AssertionError(
           "Expected identity mapping, got " + inputMapping);
     }
 

File: core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java
Patch:
@@ -34,6 +34,8 @@
 import org.apache.calcite.util.NlsString;
 import org.apache.calcite.util.Util;
 
+import com.google.common.base.Preconditions;
+
 import java.math.BigDecimal;
 import java.util.Calendar;
 
@@ -117,8 +119,7 @@ public RexNode convertLiteral(
       return rexBuilder.makeLiteral(((Boolean) value).booleanValue());
     case BINARY:
       bitString = (BitString) value;
-      Util.permAssert(
-          (bitString.getBitCount() % 8) == 0,
+      Preconditions.checkArgument((bitString.getBitCount() % 8) == 0,
           "incomplete octet");
 
       // An even number of hexits (e.g. X'ABCD') makes whole number

File: core/src/main/java/org/apache/calcite/tools/RelRunners.java
Patch:
@@ -18,8 +18,6 @@
 
 import org.apache.calcite.rel.RelNode;
 
-import com.google.common.base.Throwables;
-
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.PreparedStatement;
@@ -35,7 +33,7 @@ public static PreparedStatement run(RelNode rel) {
       final RelRunner runner = connection.unwrap(RelRunner.class);
       return runner.prepare(rel);
     } catch (SQLException e) {
-      throw Throwables.propagate(e);
+      throw new RuntimeException(e);
     }
   }
 }

File: core/src/main/java/org/apache/calcite/util/Closer.java
Patch:
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.util;
 
-import com.google.common.base.Throwables;
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
@@ -40,8 +38,10 @@ public void close() {
     for (AutoCloseable closeable : list) {
       try {
         closeable.close();
+      } catch (RuntimeException e) {
+        throw e;
       } catch (Exception e) {
-        throw Throwables.propagate(e);
+        throw new RuntimeException(e);
       }
     }
   }

File: core/src/main/java/org/apache/calcite/util/SaffronProperties.java
Patch:
@@ -116,7 +116,7 @@ static SaffronProperties instance() {
           try {
             properties.load(new FileInputStream(file));
           } catch (IOException e) {
-            throw Util.newInternal(e, "while reading from " + file);
+            throw new RuntimeException("while reading from " + file, e);
           }
         }
       } catch (AccessControlException e) {

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -33,7 +33,6 @@
 import org.apache.calcite.util.TestUtil;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSortedSet;
@@ -7193,7 +7192,7 @@ public void checkNode(String sql, Matcher<SqlNode> matcher) {
         final SqlNode sqlNode = getSqlParser(sap.sql).parseStmt();
         assertThat(sqlNode, matcher);
       } catch (SqlParseException e) {
-        throw Throwables.propagate(e);
+        throw new RuntimeException(e);
       }
     }
 

File: core/src/test/java/org/apache/calcite/test/JdbcFrontLinqBackTest.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.calcite.schema.impl.AbstractTableQueryable;
 
 import com.google.common.base.Function;
-import com.google.common.base.Throwables;
 
 import org.junit.Ignore;
 import org.junit.Test;
@@ -262,7 +261,7 @@ public Object apply(CalciteConnection c) {
               }
               return null;
             } catch (SQLException e) {
-              throw Throwables.propagate(e);
+              throw new RuntimeException(e);
             }
           }
         });

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -98,7 +98,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Function;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.LinkedListMultimap;
 import com.google.common.collect.Multimap;
@@ -315,7 +314,7 @@ public static List<Pair<String, String>> getFoodmartQueries() {
                 statement.close();
                 return null;
               } catch (SQLException e) {
-                throw Throwables.propagate(e);
+                throw new RuntimeException(e);
               }
             }
           });
@@ -6597,7 +6596,7 @@ public Void apply(ResultSet input) {
                   }
                   return null;
                 } catch (SQLException e) {
-                  throw Throwables.propagate(e);
+                  throw new RuntimeException(e);
                 }
               }
             });

File: core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java
Patch:
@@ -37,7 +37,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Function;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 
 import org.junit.Assert;
@@ -347,7 +346,7 @@ public Void apply(ResultSet input) {
                       ++n;
                     }
                   } catch (SQLException e) {
-                    throw Throwables.propagate(e);
+                    throw new RuntimeException(e);
                   }
                   assertThat(n, equalTo(1));
                   return null;
@@ -580,7 +579,7 @@ public Void apply(ResultSet input) {
                     buf.append(input.getInt(2)).append("\n");
                   }
                 } catch (SQLException e) {
-                  throw Throwables.propagate(e);
+                  throw new RuntimeException(e);
                 }
                 assertThat(buf.toString(), equalTo("0\n2147483647\n"));
                 return null;

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -75,7 +75,6 @@
 import org.apache.calcite.util.ImmutableIntList;
 
 import com.google.common.base.Function;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -1074,7 +1073,7 @@ private void checkCollation(RelOptCluster cluster, RelOptTable empTable,
       join = EnumerableMergeJoin.create(project, deptSort,
           rexBuilder.makeLiteral(true), leftKeys, rightKeys, JoinRelType.INNER);
     } catch (InvalidRelException e) {
-      throw Throwables.propagate(e);
+      throw new RuntimeException(e);
     }
     collations =
         RelMdCollation.mergeJoin(mq, project, deptSort, leftKeys,

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -419,7 +419,7 @@ private RexProgramBuilder createProg(int variant) {
                   t1));
       break;
     default:
-      throw Util.newInternal("unexpected variant " + variant);
+      throw new AssertionError("unexpected variant " + variant);
     }
     // $t6 = $t4 + $t2 (i.e. (x + y) + (x + 1))
     RexLocalRef t6 =

File: core/src/test/java/org/apache/calcite/test/StreamTest.java
Patch:
@@ -37,7 +37,6 @@
 import org.apache.calcite.util.ImmutableBitSet;
 
 import com.google.common.base.Function;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
@@ -348,7 +347,7 @@ public Void apply(ResultSet input) {
           }
           return null;
         } catch (SQLException e) {
-          throw Throwables.propagate(e);
+          throw new RuntimeException(e);
         }
       }
     };

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -64,7 +64,6 @@
 import com.fasterxml.jackson.core.JsonGenerator;
 
 import com.google.common.base.Preconditions;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
@@ -746,7 +745,7 @@ static String metadataQuery(String dataSourceName, List<Interval> intervals) {
       generator.writeEndObject();
       generator.close();
     } catch (IOException e) {
-      throw Throwables.propagate(e);
+      throw new RuntimeException(e);
     }
     return sw.toString();
   }

File: elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
Patch:
@@ -21,7 +21,6 @@
 
 import com.carrotsearch.hppc.cursors.ObjectObjectCursor;
 
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
@@ -94,8 +93,10 @@ public class ElasticsearchSchema extends AbstractSchema {
       for (ObjectObjectCursor<String, MappingMetaData> c: mapping) {
         builder.put(c.key, new ElasticsearchTable(client, index, c.key));
       }
+    } catch (RuntimeException e) {
+      throw e;
     } catch (Exception e) {
-      throw Throwables.propagate(e);
+      throw new RuntimeException(e);
     }
     return builder.build();
   }

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvEnumerator.java
Patch:
@@ -26,8 +26,6 @@
 
 import au.com.bytecode.opencsv.CSVReader;
 
-import com.google.common.base.Throwables;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileReader;
@@ -201,7 +199,7 @@ public boolean moveNext() {
             try {
               Thread.sleep(CsvStreamReader.DEFAULT_MONITOR_DELAY);
             } catch (InterruptedException e) {
-              throw Throwables.propagate(e);
+              throw new RuntimeException(e);
             }
             continue;
           }

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/CsvStreamReader.java
Patch:
@@ -23,8 +23,6 @@
 import au.com.bytecode.opencsv.CSVParser;
 import au.com.bytecode.opencsv.CSVReader;
 
-import com.google.common.base.Throwables;
-
 import java.io.Closeable;
 import java.io.File;
 import java.io.IOException;
@@ -88,7 +86,7 @@ private CsvStreamReader(File csvFile, char separator, char quoteChar,
       // wait for tailer to capture data
       Thread.sleep(DEFAULT_MONITOR_DELAY);
     } catch (InterruptedException e) {
-      throw Throwables.propagate(e);
+      throw new RuntimeException(e);
     }
   }
 

File: example/csv/src/test/java/org/apache/calcite/test/CsvTest.java
Patch:
@@ -24,7 +24,6 @@
 import org.apache.calcite.sql2rel.SqlToRelConverter;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
 
 import org.junit.Assert;
@@ -198,7 +197,7 @@ public Void apply(ResultSet resultSet) {
           assertThat(resultSet.next(), is(false));
           return null;
         } catch (SQLException e) {
-          throw Throwables.propagate(e);
+          throw new RuntimeException(e);
         }
       }
     });

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -98,7 +98,8 @@ static List<String> mongoFieldNames(final RelDataType rowType) {
           @Override public int size() {
             return rowType.getFieldCount();
           }
-        });
+        },
+        SqlValidatorUtil.EXPR_SUGGESTER, true);
   }
 
   static String maybeQuote(String s) {

File: mongodb/src/test/java/org/apache/calcite/test/MongoAdapterIT.java
Patch:
@@ -22,7 +22,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Function;
-import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
@@ -833,7 +832,7 @@ public Void apply(ResultSet input) {
                   assertThat(input.getInt(1), CoreMatchers.is(29353));
                   return null;
                 } catch (SQLException e) {
-                  throw Throwables.propagate(e);
+                  throw new RuntimeException(e);
                 }
               }
             });

File: piglet/src/test/java/org/apache/calcite/test/CalciteHandler.java
Patch:
@@ -21,8 +21,6 @@
 import org.apache.calcite.tools.PigRelBuilder;
 import org.apache.calcite.tools.RelRunners;
 
-import com.google.common.base.Throwables;
-
 import java.io.PrintWriter;
 import java.io.Writer;
 import java.sql.Array;
@@ -48,7 +46,7 @@ public CalciteHandler(PigRelBuilder builder, Writer writer) {
       final ResultSet resultSet = preparedStatement.executeQuery();
       dump(resultSet, true);
     } catch (SQLException e) {
-      throw Throwables.propagate(e);
+      throw new RuntimeException(e);
     }
   }
 

File: core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
Patch:
@@ -20,9 +20,9 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.metadata.RelMetadataProvider;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.util.CancelFlag;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
@@ -415,8 +415,8 @@ protected MulticastRelOptListener getListener() {
   public Iterable<Class<? extends RelNode>> subClasses(
       final Class<? extends RelNode> clazz) {
     return Iterables.filter(classes,
-        new Predicate<Class<? extends RelNode>>() {
-          public boolean apply(Class<? extends RelNode> input) {
+        new PredicateImpl<Class<? extends RelNode>>() {
+          public boolean test(Class<? extends RelNode> input) {
             return clazz.isAssignableFrom(input);
           }
         });

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -48,6 +48,7 @@
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexShuttle;
 import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
@@ -2392,8 +2393,8 @@ void visit(Operand operand) {
    */
   public static class FilterOnProjectRule extends RelOptRule {
     private static final Predicate<LogicalFilter> PREDICATE =
-        new Predicate<LogicalFilter>() {
-          public boolean apply(LogicalFilter input) {
+        new PredicateImpl<LogicalFilter>() {
+          public boolean test(LogicalFilter input) {
             return input.getCondition() instanceof RexInputRef;
           }
         };

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
Patch:
@@ -34,12 +34,12 @@
 import org.apache.calcite.rex.RexShuttle;
 import org.apache.calcite.rex.RexWindow;
 import org.apache.calcite.rex.RexWindowBound;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Litmus;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedListMultimap;
 import com.google.common.collect.Lists;
@@ -348,8 +348,8 @@ private static void addWindows(
     RelCollation orderKeys = getCollation(
       Lists.newArrayList(
         Iterables.filter(aggWindow.orderKeys,
-          new Predicate<RexFieldCollation>() {
-            public boolean apply(RexFieldCollation rexFieldCollation) {
+          new PredicateImpl<RexFieldCollation>() {
+            public boolean test(RexFieldCollation rexFieldCollation) {
               // If ORDER BY references constant (i.e. RexInputRef),
               // then we can ignore such ORDER BY key.
               return rexFieldCollation.left instanceof RexLocalRef;

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -40,6 +40,7 @@
 import org.apache.calcite.rex.RexInputRef;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.util.BuiltInMethod;
 import org.apache.calcite.util.ImmutableBitSet;
@@ -65,8 +66,8 @@ public class RelMdColumnUniqueness
 
   /** Aggregate and Calc are "safe" children of a RelSubset to delve into. */
   private static final Predicate<RelNode> SAFE_REL =
-      new Predicate<RelNode>() {
-        public boolean apply(RelNode r) {
+      new PredicateImpl<RelNode>() {
+        public boolean test(RelNode r) {
           return r instanceof Aggregate || r instanceof Project;
         }
       };

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.calcite.rex.RexShuttle;
 import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.rex.RexVisitorImpl;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.sql.SqlBinaryOperator;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
@@ -77,8 +78,8 @@ public abstract class DateRangeRules {
   private DateRangeRules() {}
 
   private static final Predicate<Filter> FILTER_PREDICATE =
-      new Predicate<Filter>() {
-        @Override public boolean apply(Filter filter) {
+      new PredicateImpl<Filter>() {
+        @Override public boolean test(Filter filter) {
           final ExtractFinder finder = ExtractFinder.THREAD_INSTANCES.get();
           assert finder.timeUnits.isEmpty() : "previous user did not clean up";
           try {

File: core/src/main/java/org/apache/calcite/rel/rules/FilterTableScanRule.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.schema.FilterableTable;
 import org.apache.calcite.schema.ProjectableFilterableTable;
 import org.apache.calcite.util.ImmutableIntList;
@@ -50,8 +51,8 @@
  */
 public abstract class FilterTableScanRule extends RelOptRule {
   public static final Predicate<TableScan> PREDICATE =
-      new Predicate<TableScan>() {
-        public boolean apply(TableScan scan) {
+      new PredicateImpl<TableScan>() {
+        public boolean test(TableScan scan) {
           // We can only push filters into a FilterableTable or
           // ProjectableFilterableTable.
           final RelOptTable table = scan.getTable();

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectRemoveRule.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.runtime.PredicateImpl;
 
 import com.google.common.base.Predicate;
 
@@ -42,8 +43,8 @@
 public class ProjectRemoveRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
   private static final Predicate<Project> PREDICATE =
-      new Predicate<Project>() {
-        public boolean apply(Project input) {
+      new PredicateImpl<Project>() {
+        public boolean test(Project input) {
           return isTrivial(input);
         }
       };

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectTableScanRule.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.schema.ProjectableFilterableTable;
 import org.apache.calcite.util.ImmutableIntList;
 import org.apache.calcite.util.mapping.Mapping;
@@ -48,8 +49,8 @@
  */
 public abstract class ProjectTableScanRule extends RelOptRule {
   public static final Predicate<TableScan> PREDICATE =
-      new Predicate<TableScan>() {
-        public boolean apply(TableScan scan) {
+      new PredicateImpl<TableScan>() {
+        public boolean test(TableScan scan) {
           // We can only push projects into a ProjectableFilterableTable.
           final RelOptTable table = scan.getTable();
           return table.unwrap(ProjectableFilterableTable.class) != null;

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinRule.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.rex.RexBuilder;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 import org.apache.calcite.util.ImmutableBitSet;
@@ -45,8 +46,8 @@
  */
 public class SemiJoinRule extends RelOptRule {
   private static final Predicate<Join> IS_LEFT_OR_INNER =
-      new Predicate<Join>() {
-        public boolean apply(Join input) {
+      new PredicateImpl<Join>() {
+        public boolean test(Join input) {
           switch (input.getJoinType()) {
           case LEFT:
           case INNER:

File: core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.avatica.util.Casing;
 import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.runtime.CalciteContextException;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.sql.SqlBinaryOperator;
 import org.apache.calcite.sql.SqlIntervalLiteral;
 import org.apache.calcite.sql.SqlIntervalQualifier;
@@ -585,8 +586,8 @@ public static SqlNode toTree(List<Object> list) {
   public static SqlNode toTreeEx(SqlSpecialOperator.TokenSequence list,
       int start, final int minPrec, final SqlKind stopperKind) {
     final Predicate<PrecedenceClimbingParser.Token> predicate =
-        new Predicate<PrecedenceClimbingParser.Token>() {
-          public boolean apply(PrecedenceClimbingParser.Token t) {
+        new PredicateImpl<PrecedenceClimbingParser.Token>() {
+          public boolean test(PrecedenceClimbingParser.Token t) {
             if (t instanceof PrecedenceClimbingParser.Op) {
               final SqlOperator op = ((ToTreeListItem) t.o).op;
               return stopperKind != SqlKind.OTHER

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexShuttle;
 import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.runtime.PredicateImpl;
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
@@ -75,8 +76,8 @@ private DruidRules() {}
 
   /** Predicate that returns whether Druid can not handle an aggregate. */
   private static final Predicate<AggregateCall> BAD_AGG =
-      new Predicate<AggregateCall>() {
-        public boolean apply(AggregateCall aggregateCall) {
+      new PredicateImpl<AggregateCall>() {
+        public boolean test(AggregateCall aggregateCall) {
           switch (aggregateCall.getAggregation().getKind()) {
           case COUNT:
           case SUM:

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -1661,8 +1661,9 @@ public Expression implement(
       assert translatedOperands.size() == 1;
       ConstantExpression x = (ConstantExpression) translatedOperands.get(0);
       List<String> names = Util.stringToList((String) x.value);
-      RelOptTable table =
-          Prepare.CatalogReader.THREAD_LOCAL.get().getTable(names);
+      final Prepare.CatalogReader catalogReader =
+          Prepare.CatalogReader.THREAD_LOCAL.get();
+      RelOptTable table = catalogReader.getTable(names);
       System.out.println("Now, do something with table " + table);
       return super.implement(translator, call, translatedOperands);
     }

File: core/src/main/java/org/apache/calcite/prepare/Prepare.java
Patch:
@@ -388,7 +388,7 @@ public interface CatalogReader
      * different schema path. */
     CatalogReader withSchemaPath(List<String> schemaPath);
 
-    PreparingTable getTable(List<String> names);
+    @Override PreparingTable getTable(List<String> names);
 
     ThreadLocal<CatalogReader> THREAD_LOCAL = new ThreadLocal<>();
   }

File: core/src/main/java/org/apache/calcite/prepare/RelOptTableImpl.java
Patch:
@@ -326,11 +326,11 @@ public SqlAccessType getAllowedAccess() {
     return SqlAccessType.ALL;
   }
 
-  /** Im0plementation of {@link SchemaPlus} that wraps a regular schema and knows
+  /** Implementation of {@link SchemaPlus} that wraps a regular schema and knows
    * its name and parent.
    *
    * <p>It is read-only, and functionality is limited in other ways, it but
-   * allows table expressions to be genenerated. */
+   * allows table expressions to be generated. */
   private static class MySchemaPlus implements SchemaPlus {
     private final SchemaPlus parent;
     private final String name;

File: core/src/main/java/org/apache/calcite/sql/validate/AbstractNamespace.java
Patch:
@@ -149,7 +149,7 @@ public SqlValidatorNamespace lookupChild(String name) {
 
   public boolean fieldExists(String name) {
     final RelDataType rowType = getRowType();
-    return validator.catalogReader.field(rowType, name) != null;
+    return validator.catalogReader.nameMatcher().field(rowType, name) != null;
   }
 
   public List<Pair<SqlNode, SqlMonotonicity>> getMonotonicExprs() {

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingSqlValidatorCatalogReader.java
Patch:
@@ -52,8 +52,8 @@ public List<SqlMoniker> getAllSchemaObjectNames(List<String> names) {
     return catalogReader.getAllSchemaObjectNames(names);
   }
 
-  public List<String> getSchemaName() {
-    return catalogReader.getSchemaName();
+  public List<List<String>> getSchemaPaths() {
+    return catalogReader.getSchemaPaths();
   }
 }
 

File: core/src/test/java/org/apache/calcite/prepare/LookupOperatorOverloadsTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.calcite.sql.validate.SqlUserDefinedTableFunction;
 import org.apache.calcite.util.Smalls;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 
 import org.junit.Test;
@@ -141,8 +142,8 @@ private static void check(List<SqlFunctionCategory> actuals,
           statement.createPrepareContext();
       final JavaTypeFactory typeFactory = prepareContext.getTypeFactory();
       CalciteCatalogReader reader =
-          new CalciteCatalogReader(prepareContext.getRootSchema(), false, null,
-              typeFactory);
+          new CalciteCatalogReader(prepareContext.getRootSchema(), false,
+              ImmutableList.<String>of(), typeFactory);
 
       final List<SqlOperator> operatorList = new ArrayList<>();
       SqlIdentifier myFuncIdentifier =

File: core/src/test/java/org/apache/calcite/test/CollectionTypeTest.java
Patch:
@@ -387,6 +387,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
           .build();
     }
 
+
     public Statistic getStatistic() {
       return Statistics.UNKNOWN;
     }

File: core/src/test/java/org/apache/calcite/test/ExceptionMessageTest.java
Patch:
@@ -141,7 +141,7 @@ private void runQuery(String sql) throws SQLException {
       fail("Query should fail");
     } catch (SQLException e) {
       assertThat(e.getMessage(),
-          containsString("Table 'nonexistentTable' not found"));
+          containsString("Object 'nonexistentTable' not found"));
     }
   }
 }

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -172,7 +172,7 @@ private CalciteAssert.AssertThat modelWithLattices(String... lattices) {
   @Test public void testLatticeInvalidSqlFails() {
     modelWithLattice("star", "select foo from nonexistent")
         .connectThrows("Error instantiating JsonLattice(name=star, ")
-        .connectThrows("Table 'NONEXISTENT' not found");
+        .connectThrows("Object 'NONEXISTENT' not found");
   }
 
   /** Tests a lattice whose SQL is invalid because it contains a GROUP BY. */

File: core/src/test/java/org/apache/calcite/test/MultiJdbcSchemaJoinTest.java
Patch:
@@ -196,7 +196,7 @@ private Set<Integer> runQuery(Connection calciteConnection, String query)
       fail("expected error, got " + rs);
     } catch (SQLException e) {
       assertThat(e.getCause().getCause().getMessage(),
-          equalTo("Table 'DB.TABLE2' not found"));
+          equalTo("Object 'TABLE2' not found within 'DB'"));
     }
 
     stmt1.execute("create table table2(id varchar(10) not null primary key, "
@@ -209,7 +209,7 @@ private Set<Integer> runQuery(Connection calciteConnection, String query)
       fail("expected error, got " + rs);
     } catch (SQLException e) {
       assertThat(e.getCause().getCause().getMessage(),
-          equalTo("Table 'DB.TABLE2' not found"));
+          equalTo("Object 'TABLE2' not found within 'DB'"));
     }
 
     // disable caching and table becomes visible

File: core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java
Patch:
@@ -621,7 +621,7 @@ private static boolean isNumeric(Class type) {
     // BitSet is not a valid relation type. It's as if "bitSet" field does
     // not exist.
     with.query("select * from \"s\".\"bitSet\"")
-        .throws_("Table 's.bitSet' not found");
+        .throws_("Object 'bitSet' not found within 's'");
     // Enumerable field returns 3 records with 0 fields
     with.query("select * from \"s\".\"enumerable\"")
         .returns("\n"

File: core/src/test/java/org/apache/calcite/test/SqlToRelTestBase.java
Patch:
@@ -254,7 +254,8 @@ public MockRelOptSchema(
     }
 
     public RelOptTable getTableForMember(List<String> names) {
-      final SqlValidatorTable table = catalogReader.getTable(names);
+      final SqlValidatorTable table =
+          catalogReader.getTable(names);
       final RelDataType rowType = table.getRowType();
       final List<RelCollation> collationList = deduceMonotonicity(table);
       if (names.size() < 3) {

File: core/src/test/java/org/apache/calcite/test/UdfTest.java
Patch:
@@ -26,6 +26,7 @@
 
 import com.google.common.collect.ImmutableList;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.sql.Connection;
@@ -149,6 +150,7 @@ private CalciteAssert.AssertThat withUdf() {
 
   /** Tests a user-defined function that is defined in terms of a class with
    * non-static methods. */
+  @Ignore("[CALCITE-1561] Intermittent test failures")
   @Test public void testUserDefinedFunction() throws Exception {
     final String sql = "select \"adhoc\".my_plus(\"deptno\", 100) as p\n"
         + "from \"adhoc\".EMPLOYEES";

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -451,7 +451,6 @@ public Frame decorrelateRel(LogicalAggregate rel) {
       // If input has not been rewritten, do not rewrite this rel.
       return null;
     }
-    assert !frame.corVarOutputPos.isEmpty();
     final RelNode newInput = frame.r;
 
     // map from newInput

File: core/src/main/java/org/apache/calcite/rel/core/Join.java
Patch:
@@ -141,15 +141,14 @@ public JoinRelType getJoinType() {
     return joinType;
   }
 
-  // TODO: enable
-  public boolean isValid_(Litmus litmus, Context context) {
+  @Override public boolean isValid(Litmus litmus, Context context) {
     if (!super.isValid(litmus, context)) {
       return false;
     }
     if (getRowType().getFieldCount()
         != getSystemFieldList().size()
         + left.getRowType().getFieldCount()
-        + right.getRowType().getFieldCount()) {
+        + (this instanceof SemiJoin ? 0 : right.getRowType().getFieldCount())) {
       return litmus.fail("field count mismatch");
     }
     if (condition != null) {

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingNamespace.java
Patch:
@@ -98,7 +98,6 @@ public SqlMonotonicity getMonotonicity(String columnName) {
   }
 
   public void makeNullable() {
-    namespace.makeNullable();
   }
 
   public String translate(String name) {

File: core/src/main/java/org/apache/calcite/sql/validate/EmptyScope.java
Patch:
@@ -105,7 +105,8 @@ public void validateExpr(SqlNode expr) {
         RESOURCE.columnNotFound(columnName));
   }
 
-  public void addChild(SqlValidatorNamespace ns, String alias) {
+  public void addChild(SqlValidatorNamespace ns, String alias,
+      boolean nullable) {
     // cannot add to the empty scope
     throw new UnsupportedOperationException();
   }

File: core/src/main/java/org/apache/calcite/sql/validate/OverScope.java
Patch:
@@ -75,7 +75,7 @@ public SqlMonotonicity getMonotonicity(SqlNode expr) {
     }
 
     if (children.size() == 1) {
-      final SqlValidatorNamespace child = children.get(0).right;
+      final SqlValidatorNamespace child = children.get(0).namespace;
       final List<Pair<SqlNode, SqlMonotonicity>> monotonicExprs =
           child.getMonotonicExprs();
       for (Pair<SqlNode, SqlMonotonicity> pair : monotonicExprs) {

File: core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
Patch:
@@ -181,7 +181,7 @@ public SqlNodeList getOrderList() {
       // Compute on demand first call.
       orderList = new SqlNodeList(SqlParserPos.ZERO);
       if (children.size() == 1) {
-        final SqlValidatorNamespace child = children.get(0).right;
+        final SqlValidatorNamespace child = children.get(0).namespace;
         final List<Pair<SqlNode, SqlMonotonicity>> monotonicExprs =
             child.getMonotonicExprs();
         if (monotonicExprs.size() > 0) {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
Patch:
@@ -695,7 +695,7 @@ private static ImmutableBitSet analyzeGroupExpr(SqlValidatorScope scope,
 
       assert resolved.count() == 1;
       final SqlValidatorScope.Resolve resolve = resolved.only();
-      final SqlValidatorNamespace foundNs = resolve.namespace;
+      final RelDataType rowType = resolve.rowType();
       final int childNamespaceIndex = resolve.path.steps().get(0).i;
 
       int namespaceOffset = 0;
@@ -715,7 +715,7 @@ private static ImmutableBitSet analyzeGroupExpr(SqlValidatorScope scope,
       }
 
       RelDataTypeField field =
-          scope.getValidator().getCatalogReader().field(foundNs.getRowType(),
+          scope.getValidator().getCatalogReader().field(rowType,
               originalFieldName);
       int origPos = namespaceOffset + field.getIndex();
 

File: core/src/main/java/org/apache/calcite/sql/validate/TableScope.java
Patch:
@@ -49,9 +49,10 @@ class TableScope extends ListScope {
   //~ Methods ----------------------------------------------------------------
 
 
-  @Override public void addChild(SqlValidatorNamespace ns, String alias) {
+  @Override public void addChild(SqlValidatorNamespace ns, String alias,
+      boolean nullable) {
     if (beforeLateral) {
-      super.addChild(ns, alias);
+      super.addChild(ns, alias, nullable);
     }
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/WithScope.java
Patch:
@@ -54,13 +54,14 @@ public SqlNode getNode() {
     return super.getTableNamespace(names);
   }
 
-  @Override public void resolve(List<String> names, boolean deep, Resolved resolved) {
+  @Override public void resolve(List<String> names, boolean deep,
+      Resolved resolved) {
     if (names.size() == 1
         && names.equals(withItem.name.names)) {
       final SqlValidatorNamespace ns = validator.getNamespace(withItem);
       final Step path = resolved.emptyPath()
           .add(ns.getRowType(), 0, StructKind.FULLY_QUALIFIED);
-      resolved.found(ns, null, path);
+      resolved.found(ns, false, null, path);
       return;
     }
     super.resolve(names, deep, resolved);

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -2873,13 +2873,15 @@ private Sql checkSubQuery(String sql) {
     checkSubQuery(sql).check();
   }
 
+  @Ignore("[CALCITE-1045]")
   @Test public void testExpandJoinIn() throws Exception {
     final String sql = "select empno\n"
         + "from sales.emp left join sales.dept\n"
         + "on emp.deptno in (select deptno from sales.emp where empno < 20)";
     checkSubQuery(sql).check();
   }
 
+  @Ignore("[CALCITE-1045]")
   @Test public void testExpandJoinInComposite() throws Exception {
     final String sql = "select empno\n"
         + "from sales.emp left join sales.dept\n"

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -2234,11 +2234,11 @@ public static JoinRelType simplifyJoin(RelNode joinRel,
 
     for (RexNode filter : aboveFilters) {
       if (joinType.generatesNullsOnLeft()
-          && Strong.isNull(filter, leftBitmap)) {
+          && Strong.isNotTrue(filter, leftBitmap)) {
         joinType = joinType.cancelNullsOnLeft();
       }
       if (joinType.generatesNullsOnRight()
-          && Strong.isNull(filter, rightBitmap)) {
+          && Strong.isNotTrue(filter, rightBitmap)) {
         joinType = joinType.cancelNullsOnRight();
       }
       if (joinType == JoinRelType.INNER) {

File: core/src/main/java/org/apache/calcite/prepare/Prepare.java
Patch:
@@ -268,7 +268,7 @@ public PreparedResult prepareSql(
     root = root.withRel(flattenTypes(root.rel, true));
 
     if (this.context.config().forceDecorrelate()) {
-      // Subquery decorrelation.
+      // Sub-query decorrelation.
       root = root.withRel(decorrelate(sqlToRelConverter, sqlQuery, root.rel));
     }
 

File: core/src/main/java/org/apache/calcite/rel/core/Sample.java
Patch:
@@ -31,7 +31,7 @@
  * Relational expression that returns a sample of the rows from its input.
  *
  * <p>In SQL, a sample is expressed using the {@code TABLESAMPLE BERNOULLI} or
- * {@code SYSTEM} keyword applied to a table, view or subquery.
+ * {@code SYSTEM} keyword applied to a table, view or sub-query.
  */
 public class Sample extends SingleRel {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -413,8 +413,8 @@ ExInst<SqlValidatorException> intervalFieldExceedsPrecision(Number a0,
   @BaseMessage("The {0} function does not support the {1} data type.")
   ExInst<SqlValidatorException> minMaxBadType(String a0, String a1);
 
-  @BaseMessage("Only scalar subqueries allowed in select list.")
-  ExInst<SqlValidatorException> onlyScalarSubqueryAllowed();
+  @BaseMessage("Only scalar sub-queries allowed in select list.")
+  ExInst<SqlValidatorException> onlyScalarSubQueryAllowed();
 
   @BaseMessage("Ordinal out of range")
   ExInst<SqlValidatorException> orderByOrdinalOutOfRange();

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -419,7 +419,7 @@ public enum SqlKind {
   EXPLICIT_TABLE,
 
   /**
-   * Scalar query; that is, a subquery used in an expression context, and
+   * Scalar query; that is, a sub-query used in an expression context, and
    * returning one row and one column.
    */
   SCALAR_QUERY,

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -900,7 +900,7 @@ public boolean requiresDecimalExpansion() {
    * be scalar (as opposed to a query).
    *
    * <p>If true (the default), the validator will attempt to convert the
-   * argument into a scalar subquery, which must have one column and return at
+   * argument into a scalar sub-query, which must have one column and return at
    * most one row.
    *
    * <p>Operators such as <code>SELECT</code> and <code>EXISTS</code> override

File: core/src/main/java/org/apache/calcite/sql/SqlSelect.java
Patch:
@@ -208,11 +208,11 @@ public void validate(SqlValidator validator, SqlValidatorScope scope) {
     validator.validateQuery(this, scope, validator.getUnknownType());
   }
 
-  // Override SqlCall, to introduce a subquery frame.
+  // Override SqlCall, to introduce a sub-query frame.
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
     if (!writer.inQuery()) {
-      // If this SELECT is the topmost item in a subquery, introduce a new
-      // frame. (The topmost item in the subquery might be a UNION or
+      // If this SELECT is the topmost item in a sub-query, introduce a new
+      // frame. (The topmost item in the sub-query might be a UNION or
       // ORDER. In this case, we don't need a wrapper frame.)
       final SqlWriter.Frame frame =
           writer.startList(SqlWriter.FrameTypeEnum.SUB_QUERY, "(", ")");

File: core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
Patch:
@@ -45,7 +45,7 @@
 
 /**
  * Definition of the SQL <code>IN</code> operator, which tests for a value's
- * membership in a subquery or a list of values.
+ * membership in a sub-query or a list of values.
  */
 public class SqlInOperator extends SqlBinaryOperator {
   //~ Instance fields --------------------------------------------------------
@@ -183,7 +183,7 @@ private static boolean anyNullable(List<RelDataTypeField> fieldList) {
   public boolean argumentMustBeScalar(int ordinal) {
     // Argument #0 must be scalar, argument #1 can be a list (1, 2) or
     // a query (select deptno from emp). So, only coerce argument #0 into
-    // a scalar subquery. For example, in
+    // a scalar sub-query. For example, in
     //  select * from emp
     //  where (select count(*) from dept) in (select deptno from dept)
     // we should coerce the LHS to a scalar.

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -342,13 +342,13 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
           OperandTypes.COMPARABLE_ORDERED_COMPARABLE_ORDERED);
 
   /**
-   * <code>IN</code> operator tests for a value's membership in a subquery or
+   * <code>IN</code> operator tests for a value's membership in a sub-query or
    * a list of values.
    */
   public static final SqlBinaryOperator IN = new SqlInOperator(false);
 
   /**
-   * <code>NOT IN</code> operator tests for a value's membership in a subquery
+   * <code>NOT IN</code> operator tests for a value's membership in a sub-query
    * or a list of values.
    */
   public static final SqlBinaryOperator NOT_IN =

File: core/src/main/java/org/apache/calcite/sql/validate/SelectNamespace.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.type.SqlTypeUtil;
 
 /**
- * Namespace offered by a subquery.
+ * Namespace offered by a sub-query.
  *
  * @see SelectScope
  * @see SetopNamespace

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorNamespace.java
Patch:
@@ -30,8 +30,8 @@
  * and DEPT, and a row type consisting of the combined columns of those tables.
  *
  * <p>Other examples of namespaces include a table in the from list (the
- * namespace contains the constituent columns) and a subquery (the namespace
- * contains the columns in the SELECT clause of the subquery).
+ * namespace contains the constituent columns) and a sub-query (the namespace
+ * contains the columns in the SELECT clause of the sub-query).
  *
  * <p>These various kinds of namespace are implemented by classes
  * {@link IdentifierNamespace} for table names, {@link SelectNamespace} for

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -1834,8 +1834,8 @@ protected static Calendar getCalendarNotTooNear(int timeUnit) {
         "1",
         0);
 
-    // Check return type on scalar subquery in select list.  Note return
-    // type is always nullable even if subquery select value is NOT NULL.
+    // Check return type on scalar sub-query in select list.  Note return
+    // type is always nullable even if sub-query select value is NOT NULL.
     // Bug FRG-189 causes this test to fail only in SqlOperatorTest; not
     // in subtypes.
     if (Bug.FRG189_FIXED

File: core/src/test/java/org/apache/calcite/sql/test/SqlPrettyWriterTest.java
Patch:
@@ -207,12 +207,12 @@ protected void checkSimple(
     checkSimple(prettyWriter, "${desc}", "${formatted}");
   }
 
-  @Test public void testDamiansSubqueryStyle() throws Exception {
+  @Test public void testDamiansSubQueryStyle() throws Exception {
     // Note that ( is at the indent, SELECT is on the same line, and ) is
     // below it.
     final SqlPrettyWriter prettyWriter =
         new SqlPrettyWriter(SqlDialect.DUMMY);
-    prettyWriter.setSubqueryStyle(SqlWriter.SubqueryStyle.BLACK);
+    prettyWriter.setSubQueryStyle(SqlWriter.SubQueryStyle.BLACK);
     checkSimple(prettyWriter, "${desc}", "${formatted}");
   }
 

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -539,7 +539,8 @@ public class JdbcAdapterTest {
     final String expected;
     switch (CalciteAssert.DB) {
     case MYSQL:
-      expected = "Subquery returns more than 1 row";
+      expected = "Sub"
+          + "query returns more than 1 row";
       break;
     default:
       expected = "more than one value in agg SINGLE_VALUE";
@@ -581,7 +582,7 @@ public Void apply(CalciteConnection connection) {
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-666">[CALCITE-666]
    * Anti-semi-joins against JDBC adapter give wrong results</a>. */
-  @Test public void testScalarSubquery() {
+  @Test public void testScalarSubQuery() {
     CalciteAssert.model(JdbcTest.SCOTT_MODEL)
         .query("SELECT COUNT(empno) AS cEmpNo FROM \"SCOTT\".\"EMP\" "
             + "WHERE DEPTNO <> (SELECT * FROM (VALUES 1))")

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -4723,7 +4723,7 @@ private CalciteAssert.AssertQuery predicate(String foo) {
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-313">[CALCITE-313]
    * Query decorrelation fails</a>. */
-  @Test public void testJoinInCorrelatedSubquery() {
+  @Test public void testJoinInCorrelatedSubQuery() {
     CalciteAssert.hr()
         .query("select *\n"
             + "from \"hr\".\"depts\" as d\n"
@@ -4762,8 +4762,8 @@ public Void apply(RelNode relNode) {
 
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-559">[CALCITE-559]
-   * Correlated scalar subquery in WHERE gives error</a>. */
-  @Test public void testJoinCorrelatedScalarSubquery() throws SQLException {
+   * Correlated scalar sub-query in WHERE gives error</a>. */
+  @Test public void testJoinCorrelatedScalarSubQuery() throws SQLException {
     final String sql = "select e.employee_id, d.department_id "
         + " from employee e, department d "
         + " where e.department_id = d.department_id "

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -179,7 +179,8 @@ protected DiffRepository getDiffRepos() {
 
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-1479">[CALCITE-1479]
-   * AssertionError in ReduceExpressionsRule on multi-column IN subquery</a>. */
+   * AssertionError in ReduceExpressionsRule on multi-column IN
+   * sub-query</a>. */
   @Test public void testReduceCompositeInSubQuery() {
     final HepProgram hepProgram = new HepProgramBuilder()
         .addRuleInstance(ReduceExpressionsRule.FILTER_INSTANCE)

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -1927,11 +1927,12 @@ public void testSelStarOrderBy() throws Exception {
     // No conversion to join since less than IN-list size threshold 10
     SqlToRelConverter.Config noConvertConfig = SqlToRelConverter.configBuilder().
 
-        withInSubqueryThreshold(10).build();
+
+        withInSubQueryThreshold(10).build();
     sql(sql).withConfig(noConvertConfig).convertsTo("${planNotConverted}");
     // Conversion to join since greater than IN-list size threshold 2
     SqlToRelConverter.Config convertConfig = SqlToRelConverter.configBuilder().
-        withInSubqueryThreshold(2).build();
+        withInSubQueryThreshold(2).build();
     sql(sql).withConfig(convertConfig).convertsTo("${planConverted}");
   }
 

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -430,7 +430,7 @@ public SqlString implement(MongoImplementor implementor) {
       }
       implementor.newline(buf)
           .append("FROM ");
-      implementor.subquery(buf, 0, getChild(), "t");
+      implementor.subQuery(buf, 0, getChild(), "t");
       if (program.getCondition() != null) {
         implementor.newline(buf);
         buf.append("WHERE ");

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -2749,13 +2749,12 @@ private Sql checkSubQuery(String sql) {
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-1493">[CALCITE-1493]
    * Wrong plan for NOT IN correlated queries</a>. */
-  @Ignore("[CALCITE-1493] is not fixed yet")
   @Test public void testWhereNotInCorrelated() {
     final String sql = "select sal from emp\n"
         + "where empno NOT IN (\n"
         + "  select deptno from dept\n"
         + "  where emp.job = dept.name)";
-    checkSubQuery(sql).withLateDecorrelation(false).check();
+    checkSubQuery(sql).withLateDecorrelation(true).check();
   }
 
   @Test public void testExpandProjectIn() throws Exception {

File: core/src/test/java/org/apache/calcite/test/RexTransformerTest.java
Patch:
@@ -398,6 +398,8 @@ private RexNode isTrue(RexNode node) {
     assertThat(deduceLogic(and(x, not(y)), x, Logic.TRUE), is(Logic.TRUE));
     assertThat(deduceLogic(and(x, not(y)), y, Logic.TRUE),
         is(Logic.UNKNOWN_AS_TRUE));
+    assertThat(deduceLogic(and(x, not(not(y))), y, Logic.TRUE),
+        is(Logic.TRUE_FALSE));
     assertThat(deduceLogic(and(x, not(and(y, z))), z, Logic.TRUE),
         is(Logic.UNKNOWN_AS_TRUE));
     assertThat(deduceLogic(or(x, y), x, Logic.TRUE), is(Logic.TRUE_FALSE));

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableModifyRule.java
Patch:
@@ -50,6 +50,7 @@ public class EnumerableTableModifyRule extends ConverterRule {
         convert(modify.getInput(), traitSet),
         modify.getOperation(),
         modify.getUpdateColumnList(),
+        modify.getSourceExpressionList(),
         modify.isFlattened());
   }
 }

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -297,7 +297,7 @@ private String generateSql(SqlDialect dialect) {
             (JavaTypeFactory) getCluster().getTypeFactory());
     final JdbcImplementor.Result result =
         jdbcImplementor.visitChild(0, getInput());
-    return result.asQuery().toSqlString(dialect).getSql();
+    return result.asStatement().toSqlString(dialect).getSql();
   }
 
   /** Whether this JDBC driver needs you to pass a Calendar object to methods

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -1752,6 +1752,7 @@ public static RelDataType createDmlRowType(
     switch (kind) {
     case INSERT:
     case DELETE:
+    case UPDATE:
       return typeFactory.createStructType(
           ImmutableList.of(
               Pair.of(AvaticaConnection.ROWCOUNT_COLUMN_NAME,

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -660,6 +660,7 @@ private Meta.StatementType getStatementType(SqlKind kind) {
     switch (kind) {
     case INSERT:
     case DELETE:
+    case UPDATE:
       return Meta.StatementType.IS_DML;
     default:
       return Meta.StatementType.SELECT;
@@ -750,6 +751,7 @@ public Enumerable<T> bind(DataContext dataContext) {
       switch (sqlNode.getKind()) {
       case INSERT:
       case DELETE:
+      case UPDATE:
       case EXPLAIN:
         // FIXME: getValidatedNodeType is wrong for DML
         x = RelOptUtil.createDmlRowType(sqlNode.getKind(), typeFactory);

File: core/src/main/java/org/apache/calcite/schema/ModifiableTable.java
Patch:
@@ -21,6 +21,7 @@
 import org.apache.calcite.prepare.Prepare;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.TableModify;
+import org.apache.calcite.rex.RexNode;
 
 import java.util.Collection;
 import java.util.List;
@@ -46,6 +47,7 @@ TableModify toModificationRel(
       RelNode child,
       TableModify.Operation operation,
       List<String> updateColumnList,
+      List<RexNode> sourceExpressionList,
       boolean flattened);
 }
 

File: core/src/main/java/org/apache/calcite/sql/SqlInsert.java
Patch:
@@ -141,7 +141,7 @@ public final SqlNode getModifierNode(SqlInsertKeyword modifier) {
       columnList.unparse(writer, opLeft, opRight);
     }
     writer.newlineAndIndent();
-    source.unparse(writer, opLeft, opRight);
+    source.unparse(writer, 0, 0);
   }
 
   public void validate(SqlValidator validator, SqlValidatorScope scope) {

File: core/src/main/java/org/apache/calcite/sql/SqlValuesOperator.java
Patch:
@@ -33,7 +33,8 @@ public void unparse(
       SqlCall call,
       int leftPrec,
       int rightPrec) {
-    final SqlWriter.Frame frame = writer.startList("VALUES", "");
+    final SqlWriter.Frame frame =
+        writer.startList(SqlWriter.FrameTypeEnum.VALUES, "VALUES", "");
     for (SqlNode operand : call.getOperandList()) {
       writer.sep(",");
       operand.unparse(writer, 0, 0);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlRowOperator.java
Patch:
@@ -40,14 +40,14 @@
 public class SqlRowOperator extends SqlSpecialOperator {
   //~ Constructors -----------------------------------------------------------
 
-  public SqlRowOperator() {
-    super(
-        "ROW",
+  public SqlRowOperator(String name) {
+    super(name,
         SqlKind.ROW, MDX_PRECEDENCE,
         false,
         null,
         InferTypes.RETURN_TYPE,
         OperandTypes.VARIADIC);
+    assert name.equals("ROW") || name.equals(" ");
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -921,7 +921,7 @@ public boolean argumentMustBeScalar(int ordinal) {
   //-------------------------------------------------------------
   //                   SPECIAL OPERATORS
   //-------------------------------------------------------------
-  public static final SqlRowOperator ROW = new SqlRowOperator();
+  public static final SqlRowOperator ROW = new SqlRowOperator("ROW");
 
   /**
    * A special operator for the subtraction of two DATETIMEs. The format of

File: core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -454,6 +454,7 @@ protected FrameImpl createListFrame(
 
       switch (frameTypeEnum) {
       case WINDOW_DECL_LIST:
+      case VALUES:
         return new FrameImpl(
             frameType,
             keyword,

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -352,6 +352,7 @@ public void rewriteRel(LogicalTableModify rel) {
             getNewForOldRel(rel.getInput()),
             rel.getOperation(),
             rel.getUpdateColumnList(),
+            rel.getSourceExpressionList(),
             true);
     setNewForOldRel(rel, newRel);
   }

File: core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java
Patch:
@@ -1478,6 +1478,7 @@ protected final void check(
     sql(sql).ok();
   }
 
+  @Ignore("CALCITE-1527")
   @Test public void testUpdateSubQuery() {
     final String sql = "update emp\n"
         + "set empno = (\n"

File: spark/src/main/java/org/apache/calcite/adapter/spark/JdbcToSparkConverter.java
Patch:
@@ -114,7 +114,7 @@ private String generateSql(SqlDialect dialect) {
             (JavaTypeFactory) getCluster().getTypeFactory());
     final JdbcImplementor.Result result =
         jdbcImplementor.visitChild(0, getInput());
-    return result.asQuery().toSqlString(dialect).getSql();
+    return result.asStatement().toSqlString(dialect).getSql();
   }
 }
 

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -403,7 +403,7 @@ public RexNode field(String alias, String fieldName) {
       aliases.add(pair.left);
       offset += pair.right.getFieldCount();
     }
-    throw new IllegalArgumentException("no relation wtih alias '" + alias
+    throw new IllegalArgumentException("no relation with alias '" + alias
         + "'; aliases are: " + aliases);
   }
 

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.calcite.sql.SqlSetOptionOperatorTest;
 import org.apache.calcite.sql.parser.SqlParserTest;
 import org.apache.calcite.sql.parser.SqlUnParserTest;
+import org.apache.calcite.sql.parser.parserextensiontesting.ExtensionSqlParserTest;
 import org.apache.calcite.sql.test.SqlAdvisorTest;
 import org.apache.calcite.sql.test.SqlOperatorTest;
 import org.apache.calcite.sql.test.SqlPrettyWriterTest;
@@ -112,6 +113,7 @@
     // medium tests (above 0.1s)
     SqlParserTest.class,
     SqlUnParserTest.class,
+    ExtensionSqlParserTest.class,
     SqlSetOptionOperatorTest.class,
     SqlPrettyWriterTest.class,
     SqlValidatorTest.class,

File: core/src/main/java/org/apache/calcite/prepare/RelOptTableImpl.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rel.type.RelRecordType;
+import org.apache.calcite.runtime.Hook;
 import org.apache.calcite.schema.ExtensibleTable;
 import org.apache.calcite.schema.FilterableTable;
 import org.apache.calcite.schema.ModifiableTable;
@@ -251,7 +252,7 @@ public RelNode toRel(ToRelContext context) {
       return ((TranslatableTable) table).toRel(context, this);
     }
     final RelOptCluster cluster = context.getCluster();
-    if (CalcitePrepareImpl.ENABLE_BINDABLE) {
+    if (Hook.ENABLE_BINDABLE.get(false)) {
       return LogicalTableScan.create(cluster, this);
     }
     if (CalcitePrepareImpl.ENABLE_ENUMERABLE

File: core/src/main/java/org/apache/calcite/util/Closer.java
Patch:
@@ -25,8 +25,8 @@
 /** Helper that holds onto {@link AutoCloseable} resources and releases them
  * when its {@code #close} method is called.
  *
- * <p>Similar to {@link com.google.common.io.Closer} but can deal with
- * {@link AutoCloseable} and doesn't throw {@link IOException}. */
+ * <p>Similar to {@code com.google.common.io.Closer} but can deal with
+ * {@link AutoCloseable}, and doesn't throw {@link IOException}. */
 public final class Closer implements AutoCloseable {
   private final List<AutoCloseable> list = new ArrayList<>();
 

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
Patch:
@@ -69,7 +69,6 @@ public class DruidTable extends AbstractTable implements TranslatableTable {
    * @param metricFieldNames Names of fields that are metrics
    * @param intervals Default interval if query does not constrain the time, or null
    * @param timestampFieldName Name of the column that contains the time
-   * @param intervals Intervals for the given table
    */
   public DruidTable(DruidSchema schema, String dataSource,
       RelProtoDataType protoRowType, Set<String> metricFieldNames,

File: core/src/main/java/org/apache/calcite/model/JsonSchema.java
Patch:
@@ -106,7 +106,6 @@ public void visitChildren(ModelHandler modelHandler) {
 
   /** Built-in schema types. */
   public enum Type {
-    NONE,
     MAP,
     JDBC,
     CUSTOM

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -622,8 +622,6 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
   @BaseMessage("SELECT must have a FROM clause")
   ExInst<SqlValidatorException> selectMissingFrom();
 
-  @BaseMessage("Statement canceled")
-  Inst statementCanceled();
 }
 
 // End CalciteResource.java

File: core/src/test/java/org/apache/calcite/test/SqlFunctionsTest.java
Patch:
@@ -767,7 +767,7 @@ private void thereAndBack(byte[] bytes) {
       fail("'ge' on non-numeric different type is not possible");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage(),
-          is("Invalid types for arithmetic: class java.lang.String >= "
+          is("Invalid types for comparison: class java.lang.String >= "
               + "class java.lang.Long"));
     }
   }

File: core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
Patch:
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
-import org.apache.calcite.runtime.SqlFunctions;
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql.type.SqlTypeUtil;
@@ -162,7 +161,7 @@ public TimeZone getTimeZone() {
   /** Returns a copy of this data type specification with a given
    * nullability. */
   public SqlDataTypeSpec withNullable(Boolean nullable) {
-    if (SqlFunctions.eq(nullable, this.nullable)) {
+    if (Objects.equals(nullable, this.nullable)) {
       return this;
     }
     return new SqlDataTypeSpec(collectionsTypeName, typeName, precision, scale,

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1350,8 +1350,7 @@ private void checkPredicates(RelOptCluster cluster, RelOptTable empTable,
     final RelMetadataQuery mq = RelMetadataQuery.instance();
     RelOptPredicateList list = mq.getPulledUpPredicates(rel);
     assertThat(list.pulledUpPredicates,
-        sortsAs("[<($0, 10), =($3, 'y'), =($4, CAST('1'):INTEGER NOT NULL), "
-            + "IS NULL($1), IS NULL($2)]"));
+        sortsAs("[<($0, 10), =($3, 'y'), =($4, 1), IS NULL($1), IS NULL($2)]"));
   }
 
   @Test public void testPullUpPredicatesOnNullableConstant() {

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -248,7 +248,7 @@ public int getFractionalSecondPrecisionPreservingDefault() {
     if (useDefaultFractionalSecondPrecision()) {
       return RelDataType.PRECISION_NOT_SPECIFIED;
     } else {
-      return startPrecision;
+      return fractionalSecondPrecision;
     }
   }
 

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -527,6 +527,9 @@ private static String cannotStreamResultsForNonStreamingInputs(String inputs) {
     checkExpType(
         "CASE 1 WHEN 1 THEN cast(null as integer) WHEN 2 THEN cast(cast(null as tinyint) as integer) END",
         "INTEGER");
+    checkExpType(
+        "CASE 1 WHEN 1 THEN INTERVAL '12 3:4:5.6' DAY TO SECOND(6) WHEN 2 THEN INTERVAL '12 3:4:5.6' DAY TO SECOND(9) END",
+        "INTERVAL DAY TO SECOND(9)");
   }
 
   @Test public void testCaseExpressionFails() {

File: core/src/main/java/org/apache/calcite/rex/RexLiteral.java
Patch:
@@ -587,8 +587,6 @@ public Object getValue2() {
       return null;
     }
     switch (typeName) {
-    case BINARY:
-      return ((ByteBuffer) value).array();
     case CHAR:
       return ((NlsString) value).getValue();
     case DECIMAL:

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
Patch:
@@ -674,7 +674,7 @@ private JdbcToInternalLookupTable() {
               assert 1 == operands.length;
               return super.createCall(pos,
                   SqlTrimFunction.Flag.LEADING.symbol(SqlParserPos.ZERO),
-                  SqlLiteral.createCharString(" ", null),
+                  SqlLiteral.createCharString(" ", SqlParserPos.ZERO),
                   operands[0]);
             }
           });
@@ -686,7 +686,7 @@ private JdbcToInternalLookupTable() {
               assert 1 == operands.length;
               return super.createCall(pos,
                   SqlTrimFunction.Flag.TRAILING.symbol(SqlParserPos.ZERO),
-                  SqlLiteral.createCharString(" ", null),
+                  SqlLiteral.createCharString(" ", SqlParserPos.ZERO),
                   operands[0]);
             }
           });

File: core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
Patch:
@@ -72,7 +72,7 @@ protected List<Integer> getOperandList(int operandCount) {
         : Util.range(0, nOperands);
   }
 
-  private boolean checkOperandTypesImpl(
+  protected boolean checkOperandTypesImpl(
       SqlOperatorBinding operatorBinding,
       boolean throwOnFailure,
       SqlCallBinding callBinding) {

File: avatica/core/src/test/java/org/apache/calcite/avatica/util/NumberAccessorTest.java
Patch:
@@ -23,6 +23,7 @@
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.sql.SQLException;
 
 import static org.junit.Assert.assertEquals;
 
@@ -32,7 +33,7 @@
 public class NumberAccessorTest {
 
   @Test
-  public void testBigDecimalZeroScale() {
+  public void testBigDecimalZeroScale() throws SQLException {
     final BigDecimal orig = new BigDecimal(BigInteger.valueOf(137L), 1);
     NumberAccessor accessor = new AbstractCursor.NumberAccessor(
         new Getter() {

File: avatica/core/src/test/java/org/apache/calcite/avatica/remote/ProtobufTranslationImplTest.java
Patch:
@@ -285,8 +285,8 @@ private static List<Response> getResponses() {
     ScalarType arrayComponentType = ColumnMetaData.scalar(Types.INTEGER, "integer", Rep.INTEGER);
     ColumnMetaData arrayColumnMetaData = getArrayColumnMetaData(arrayComponentType, 2, "counts");
     List<ColumnMetaData> columns =
-        Arrays.asList(MetaImpl.columnMetaData("str", 0, String.class),
-            MetaImpl.columnMetaData("count", 1, Integer.class),
+        Arrays.asList(MetaImpl.columnMetaData("str", 0, String.class, true),
+            MetaImpl.columnMetaData("count", 1, Integer.class, true),
             arrayColumnMetaData);
     List<AvaticaParameter> params =
         Arrays.asList(

File: avatica/server/src/test/java/org/apache/calcite/avatica/RemoteDriverMockTest.java
Patch:
@@ -107,8 +107,8 @@ private Connection getMockConnection() {
     assertFalse(resultSet.next());
     final ResultSetMetaData metaData = resultSet.getMetaData();
     assertTrue(metaData.getColumnCount() >= 2);
-    assertEquals("TABLE_CATALOG", metaData.getColumnName(1));
-    assertEquals("TABLE_SCHEM", metaData.getColumnName(2));
+    assertEquals("TABLE_SCHEM", metaData.getColumnName(1));
+    assertEquals("TABLE_CATALOG", metaData.getColumnName(2));
     resultSet.close();
     connection.close();
   }

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
Patch:
@@ -70,9 +70,10 @@ public DruidSchema(String url, String coordinatorUrl,
               public Table load(@Nonnull String tableName) throws Exception {
                 final Map<String, SqlTypeName> fieldMap = new LinkedHashMap<>();
                 final Set<String> metricNameSet = new LinkedHashSet<>();
-                connection.metadata(tableName, null, fieldMap, metricNameSet);
+                connection.metadata(tableName, DruidTable.DEFAULT_TIMESTAMP_COLUMN,
+                    null, fieldMap, metricNameSet);
                 return DruidTable.create(DruidSchema.this, tableName, null,
-                    fieldMap, metricNameSet, null, connection);
+                    fieldMap, metricNameSet, DruidTable.DEFAULT_TIMESTAMP_COLUMN, connection);
               }
             }));
   }

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -238,9 +238,9 @@ public enum BuiltInMethod {
       Object.class, int.class, int.class, Function1.class, Comparator.class),
   BINARY_SEARCH6_UPPER(BinarySearch.class, "upperBound", Object[].class,
       Object.class, int.class, int.class, Function1.class, Comparator.class),
-  ARRAY_ITEM(SqlFunctions.class, "arrayItem", List.class, int.class),
-  MAP_ITEM(SqlFunctions.class, "mapItem", Map.class, Object.class),
-  ANY_ITEM(SqlFunctions.class, "item", Object.class, Object.class),
+  ARRAY_ITEM(SqlFunctions.class, "arrayItemOptional", List.class, int.class),
+  MAP_ITEM(SqlFunctions.class, "mapItemOptional", Map.class, Object.class),
+  ANY_ITEM(SqlFunctions.class, "itemOptional", Object.class, Object.class),
   UPPER(SqlFunctions.class, "upper", String.class),
   LOWER(SqlFunctions.class, "lower", String.class),
   INITCAP(SqlFunctions.class, "initcap", String.class),

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -159,6 +159,7 @@
     RelMdColumnOriginsTest.class,
     MultiJdbcSchemaJoinTest.class,
     SqlLineTest.class,
+    CollectionTypeTest.class,
 
     // slow tests that don't break often
     SqlToRelConverterExtendedTest.class,

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/JsonTable.java
Patch:
@@ -48,7 +48,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
         typeFactory.createMapType(
             typeFactory.createSqlType(SqlTypeName.VARCHAR),
             typeFactory.createTypeWithNullability(
-                typeFactory.createSqlType(SqlTypeName.ANY), true))).build();
+                typeFactory.createSqlType(SqlTypeName.VARCHAR), true))).build();
   }
 
   public Enumerable<Object[]> scan(DataContext root) {

File: example/csv/src/test/java/org/apache/calcite/test/CsvTest.java
Patch:
@@ -258,7 +258,7 @@ public Void apply(ResultSet resultSet) {
     checkSql("bug", "select _MAP['id'] as id,\n"
             + " _MAP['title'] as title,\n"
             + " CHAR_LENGTH(CAST(_MAP['title'] AS VARCHAR(30))) as len\n"
-            + " from \"archers\"",
+            + " from \"archers\"\n",
         "ID=19990101; TITLE=Tractor trouble.; LEN=16",
         "ID=19990103; TITLE=Charlie's surprise.; LEN=19");
   }

File: core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
Patch:
@@ -42,7 +42,7 @@ public SqlPrefixOperator(
     super(
         name,
         kind,
-        leftPrec(0, true),
+        leftPrec(prec, true),
         rightPrec(prec, true),
         returnTypeInference,
         operandTypeInference,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
Patch:
@@ -66,7 +66,7 @@ public class SqlInOperator extends SqlBinaryOperator {
     super(
         isNotIn ? "NOT IN" : "IN",
         SqlKind.IN,
-        30,
+        32,
         true,
         ReturnTypes.BOOLEAN_NULLABLE,
         InferTypes.FIRST_KNOWN,

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -2044,7 +2044,7 @@ public static <E> List<E> skip(List<E> list) {
 
   /** Returns all but the first {@code n} elements of a list. */
   public static <E> List<E> skip(List<E> list, int fromIndex) {
-    return list.subList(fromIndex, list.size());
+    return fromIndex == 0 ? list : list.subList(fromIndex, list.size());
   }
 
   public static List<Integer> range(final int end) {

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -53,6 +53,7 @@
 import org.apache.calcite.util.ImmutableBitSetTest;
 import org.apache.calcite.util.PartiallyOrderedSetTest;
 import org.apache.calcite.util.PermutationTestCase;
+import org.apache.calcite.util.PrecedenceClimbingParserTest;
 import org.apache.calcite.util.ReflectVisitorTest;
 import org.apache.calcite.util.UtilTest;
 import org.apache.calcite.util.graph.DirectedGraphTest;
@@ -81,6 +82,7 @@
     RelOptUtilTest.class,
     RelCollationTest.class,
     UtilTest.class,
+    PrecedenceClimbingParserTest.class,
     MappingTest.class,
     CalciteResourceTest.class,
     FilteratorTest.class,

File: core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
Patch:
@@ -452,7 +452,7 @@ public boolean apply(MetaTable v1) {
 
   private ImmutableList<MetaTypeInfo> getAllDefaultType() {
     final ImmutableList.Builder<MetaTypeInfo> allTypeList =
-        new ImmutableList.Builder<>();
+        ImmutableList.builder();
     final CalciteConnectionImpl conn = (CalciteConnectionImpl) connection;
     final RelDataTypeSystem typeSystem = conn.typeFactory.getTypeSystem();
     for (SqlTypeName sqlTypeName : SqlTypeName.values()) {

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
Patch:
@@ -264,9 +264,7 @@ private static Pair<List<RexNode>, List<RexNode>> splitProjects(final RexBuilder
                 final int index = positions.indexOf(ref.getIndex());
                 return rexBuilder.makeInputRef(belowTypes.get(index), index);
               }
-            }
-          )
-        );
+            }));
       }
       return Pair.of(aboveNodes, belowNodes);
     }

File: core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
Patch:
@@ -53,6 +53,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.TimeZone;
 
 /**
  * Collection of planner rules that convert
@@ -253,7 +254,7 @@ RexNode foo(SqlKind comparison, RexNode operand, RexLiteral literal) {
         final Calendar c;
         switch (timeUnit) {
         case YEAR:
-          c = Calendar.getInstance();
+          c = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
           c.clear();
           c.set(v, Calendar.JANUARY, 1);
           s2.add(baz(timeUnit, comparison, c));

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaSite.java
Patch:
@@ -194,7 +194,7 @@ public void setTime(Time x, Calendar calendar) {
     slots[index] = wrap(ColumnMetaData.Rep.JAVA_SQL_TIME, x, calendar);
   }
 
-  public void setDate(Date x, Calendar cal) {
+  public void setDate(Date x, Calendar calendar) {
     slots[index] = wrap(ColumnMetaData.Rep.JAVA_SQL_DATE, x, calendar);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -916,7 +916,8 @@ public enum SqlKind {
           CREATE_TABLE, ALTER_TABLE, DROP_TABLE,
           CREATE_VIEW, ALTER_VIEW, DROP_VIEW,
           CREATE_SEQUENCE, ALTER_SEQUENCE, DROP_SEQUENCE,
-          CREATE_INDEX, ALTER_INDEX, DROP_INDEX);
+          CREATE_INDEX, ALTER_INDEX, DROP_INDEX,
+          SET_OPTION, OTHER_DDL);
 
   /**
    * Category consisting of query node types.

File: avatica/server/src/test/java/org/apache/calcite/avatica/AvaticaSpnegoTest.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.kerby.kerberos.kerb.server.SimpleKdcServer;
 
 import org.junit.AfterClass;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -55,6 +56,7 @@
  * End to end test case for SPNEGO with Avatica.
  */
 @RunWith(Parameterized.class)
+@Ignore("Disabled due to [CALCITE-1183] intermittent HTTP 404 failures")
 public class AvaticaSpnegoTest {
   private static final Logger LOG = LoggerFactory.getLogger(AvaticaSpnegoTest.class);
 

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
Patch:
@@ -358,7 +358,7 @@ public RelOptPredicateList getPredicates(Union union, RelMetadataQuery mq) {
     }
 
     List<RexNode> preds = new ArrayList<>(finalPreds.values());
-    RexNode disjPred = RexUtil.composeDisjunction(rB, finalResidualPreds, false);
+    RexNode disjPred = RexUtil.simplifyOrs(rB, finalResidualPreds);
     if (!disjPred.isAlwaysTrue()) {
       preds.add(disjPred);
     }

File: core/src/test/java/org/apache/calcite/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -270,7 +270,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
         .query(
             "select \"store\".\"store_country\" as \"c0\", sum(\"inventory_fact_1997\".\"supply_time\") as \"m0\" from \"store\" as \"store\", \"inventory_fact_1997\" as \"inventory_fact_1997\" where \"inventory_fact_1997\".\"store_id\" = \"store\".\"store_id\" group by \"store\".\"store_country\"")
         .planContains(
-            "  return left.join(right, new org.apache.calcite.linq4j.function.Function1() {\n");
+            " left.join(right, new org.apache.calcite.linq4j.function.Function1() {\n");
   }
 }
 

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -4614,7 +4614,7 @@ private CalciteAssert.AssertQuery predicate(String foo) {
 
   @Test public void testNotExistsCorrelated() {
     final String plan = "PLAN="
-        + "EnumerableCalc(expr#0..5=[{inputs}], expr#6=[IS NOT NULL($t5)], expr#7=[true], expr#8=[false], expr#9=[CASE($t6, $t7, $t8)], expr#10=[NOT($t9)], proj#0..4=[{exprs}], $condition=[$t10])\n"
+        + "EnumerableCalc(expr#0..5=[{inputs}], expr#6=[IS NULL($t5)], proj#0..4=[{exprs}], $condition=[$t6])\n"
         + "  EnumerableCorrelate(correlation=[$cor0], joinType=[LEFT], requiredColumns=[{1}])\n"
         + "    EnumerableTableScan(table=[[hr, emps]])\n"
         + "    EnumerableAggregate(group=[{0}])\n"

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
Patch:
@@ -352,7 +352,7 @@ public RelOptPredicateList getPredicates(Union union, RelMetadataQuery mq) {
 
     List<RexNode> preds = new ArrayList<>(finalPreds.values());
     RexNode disjPred = RexUtil.composeDisjunction(rB, finalResidualPreds, false);
-    if (!disjPred.isAlwaysFalse()) {
+    if (!disjPred.isAlwaysTrue()) {
       preds.add(disjPred);
     }
     return RelOptPredicateList.of(preds);

File: druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
Patch:
@@ -531,6 +531,7 @@ static String metadataQuery(String dataSourceName, List<String> intervals) {
       generator.writeStringField("queryType", "segmentMetadata");
       generator.writeStringField("dataSource", dataSourceName);
       generator.writeBooleanField("merge", true);
+      generator.writeBooleanField("lenientAggregatorMerge", true);
       generator.writeArrayFieldStart("analysisTypes");
       generator.writeString("aggregators");
       generator.writeEndArray();

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -4544,9 +4544,6 @@ public Void visit(SqlCall call) {
       // Ignore window aggregates and ranking functions (associated with OVER
       // operator). However, do not ignore nested window aggregates.
       if (call.getOperator().getKind() == SqlKind.OVER) {
-        if (call.operand(0).getKind() == SqlKind.RANK) {
-          return null;
-        }
         // Track aggregate nesting levels only within an OVER operator.
         inOver = true;
       }

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcImplementor.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.SqlDialect;
 import org.apache.calcite.util.Util;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
 
 /**
  * State for generating a SQL statement.
@@ -36,7 +36,7 @@ public JdbcImplementor(SqlDialect dialect, JavaTypeFactory typeFactory) {
   /** @see #dispatch */
   public Result visit(JdbcTableScan scan) {
     return result(scan.jdbcTable.tableName(),
-        Collections.singletonList(Clause.FROM), scan);
+        ImmutableList.of(Clause.FROM), scan, null);
   }
 
   public Result implement(RelNode node) {

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java
Patch:
@@ -22,7 +22,8 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.TableScan;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -49,7 +50,7 @@ protected JdbcTableScan(
 
   public JdbcImplementor.Result implement(JdbcImplementor implementor) {
     return implementor.result(jdbcTable.tableName(),
-        Collections.singletonList(JdbcImplementor.Clause.FROM), this);
+        ImmutableList.of(JdbcImplementor.Clause.FROM), this, null);
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/SqlDialect.java
Patch:
@@ -460,12 +460,13 @@ public DatabaseProduct getDatabaseProduct() {
    */
   public boolean supportsCharSet() {
     switch (databaseProduct) {
-    case MYSQL:
+    case DB2:
     case H2:
     case HSQLDB:
+    case MYSQL:
+    case ORACLE:
     case PHOENIX:
     case POSTGRESQL:
-    case ORACLE:
       return false;
     default:
       return true;

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -1650,7 +1650,7 @@ private static int lastDay(int y, int m) {
 
   /** Finds the number of months between two dates, each represented as the
    * number of days since the epoch. */
-  public static long subtractMonths(int date0, int date1) {
+  public static int subtractMonths(int date0, int date1) {
     if (date0 < date1) {
       return -subtractMonths(date1, date0);
     }
@@ -1679,7 +1679,7 @@ public static int subtractMonths(long t0, long t1) {
         DateTimeUtils.floorMod(t1, DateTimeUtils.MILLIS_PER_DAY);
     final int d1 = (int) DateTimeUtils.floorDiv(t1 - millis1,
         DateTimeUtils.MILLIS_PER_DAY);
-    int x = (int) subtractMonths(d0, d1);
+    int x = subtractMonths(d0, d1);
     final long d2 = addMonths(d1, x);
     if (d2 == d0 && millis0 < millis1) {
       --x;

File: core/src/test/java/org/apache/calcite/test/SqlFunctionsTest.java
Patch:
@@ -381,11 +381,11 @@ private void checkAddMonths(int y0, int m0, int d0, int y1, int m1, int d1,
     assertThat((int) date, is(date1));
 
     assertThat(subtractMonths(date1, date0),
-        anyOf(is((long) months), is((long) months + 1)));
+        anyOf(is(months), is(months + 1)));
     assertThat(subtractMonths(date1 + 1, date0),
-        anyOf(is((long) months), is((long) months + 1)));
+        anyOf(is(months), is(months + 1)));
     assertThat(subtractMonths(date1, date0 + 1),
-        anyOf(is((long) months), is((long) months - 1)));
+        anyOf(is(months), is(months - 1)));
     assertThat(subtractMonths(d2ts(date1, 1), d2ts(date0, 0)),
         anyOf(is(months), is(months + 1)));
     assertThat(subtractMonths(d2ts(date1, 0), d2ts(date0, 1)),

File: core/src/main/java/org/apache/calcite/plan/ConventionTraitDef.java
Patch:
@@ -195,8 +195,8 @@ public boolean canConvert(
       Convention fromConvention,
       Convention toConvention) {
     ConversionData conversionData = getConversionData(planner);
-    return conversionData.getShortestPath(fromConvention, toConvention)
-        != null;
+    return fromConvention.canConvertConvention(toConvention)
+        || conversionData.getShortestPath(fromConvention, toConvention) != null;
   }
 
   private ConversionData getConversionData(RelOptPlanner planner) {

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -1941,6 +1941,7 @@ public Void apply(ResultSet a0) {
     //   12    36
     //   13   116 - OOM did not complete
     checkJoinNWay(1);
+    checkJoinNWay(3);
     checkJoinNWay(6);
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
Patch:
@@ -208,9 +208,7 @@ private void assertBasic(SqlTypeName typeName) {
     assert typeName != null;
     assert typeName != SqlTypeName.MULTISET
         : "use createMultisetType() instead";
-    assert typeName != SqlTypeName.INTERVAL_DAY_TIME
-        : "use createSqlIntervalType() instead";
-    assert typeName != SqlTypeName.INTERVAL_YEAR_MONTH
+    assert !SqlTypeName.INTERVAL_TYPES.contains(typeName)
         : "use createSqlIntervalType() instead";
   }
 

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
Patch:
@@ -42,6 +42,7 @@
 import java.nio.charset.Charset;
 import java.util.AbstractList;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import static org.apache.calcite.util.Static.RESOURCE;
@@ -267,7 +268,7 @@ public static boolean isOfSameTypeName(
    * @see #isOfSameTypeName(SqlTypeName, RelDataType)
    */
   public static boolean isOfSameTypeName(
-      List<SqlTypeName> typeNames,
+      Collection<SqlTypeName> typeNames,
       RelDataType type) {
     for (SqlTypeName typeName : typeNames) {
       if (isOfSameTypeName(typeName, type)) {

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -1877,8 +1877,7 @@ public static <T extends Enum<T>> Map<String, T> enumConstants(
       Class<T> clazz) {
     final T[] ts = clazz.getEnumConstants();
     if (ts == null) {
-      // not an enum type
-      return null;
+      throw new AssertionError("not an enum type");
     }
     ImmutableMap.Builder<String, T> builder = ImmutableMap.builder();
     for (T t : ts) {

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -272,7 +272,7 @@ public AvaticaJsonHandler createHandler(Service service) {
   @Test public void testRemoteTypeInfo() throws Exception {
     CalciteAssert.hr().with(REMOTE_CONNECTION_FACTORY)
         .metaData(GET_TYPEINFO)
-        .returns(CalciteAssert.checkResultCount(31));
+        .returns(CalciteAssert.checkResultCount(is(42)));
   }
 
   @Test public void testRemoteTableTypes() throws Exception {

File: avatica/core/src/main/java/org/apache/calcite/avatica/ConnectionConfig.java
Patch:
@@ -41,7 +41,9 @@ public interface ConnectionConfig {
   String avaticaUser();
   /** @see BuiltInConnectionProperty#AVATICA_PASSWORD */
   String avaticaPassword();
+  /** @see BuiltInConnectionProperty#HTTP_CLIENT_FACTORY */
   AvaticaHttpClientFactory httpClientFactory();
+  /** @see BuiltInConnectionProperty#HTTP_CLIENT_IMPL */
   String httpClientClass();
   /** @see BuiltInConnectionProperty#PRINCIPAL */
   String kerberosPrincipal();

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRel.java
Patch:
@@ -48,9 +48,7 @@ public RelNode createProject(RelNode child,
           final RelOptCluster cluster = child.getCluster();
           final RelDataType rowType =
               RexUtil.createStructType(cluster.getTypeFactory(), projects,
-                  fieldNames == null ? null
-                      : SqlValidatorUtil.uniquify(fieldNames,
-                          SqlValidatorUtil.F_SUGGESTER));
+                  fieldNames, SqlValidatorUtil.F_SUGGESTER);
           return EnumerableProject.create(child, projects, rowType);
         }
       };

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -143,7 +143,7 @@ private Lattice(CalciteSchema rootSchema, ImmutableList<Node> nodes,
     }
     uniqueColumnNames =
         ImmutableList.copyOf(
-            SqlValidatorUtil.uniquify(Lists.transform(columns, GET_ALIAS)));
+            SqlValidatorUtil.uniquify(Lists.transform(columns, GET_ALIAS), true));
     if (rowCountEstimate == null) {
       // We could improve this when we fix
       // [CALCITE-429] Add statistics SPI for lattice optimization algorithm

File: core/src/main/java/org/apache/calcite/rel/core/SemiJoin.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.sql.validate.SqlValidatorUtil;
 import org.apache.calcite.util.ImmutableIntList;
 import org.apache.calcite.util.Util;
 
@@ -114,7 +115,7 @@ public static SemiJoin create(RelNode left, RelNode right, RexNode condition,
    * input only.
    */
   @Override public RelDataType deriveRowType() {
-    return deriveJoinRowType(
+    return SqlValidatorUtil.deriveJoinRowType(
         left.getRowType(),
         null,
         JoinRelType.INNER,

File: core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexProgram;
 import org.apache.calcite.rex.RexProgramBuilder;
+import org.apache.calcite.sql.validate.SqlValidatorUtil;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 import org.apache.calcite.util.Pair;
@@ -180,7 +181,7 @@ public void onMatch(RelOptRuleCall call) {
     // into the bottom RexProgram.  Note that the join type is an inner
     // join because the inputs haven't actually been joined yet.
     RelDataType joinChildrenRowType =
-        Join.deriveJoinRowType(
+        SqlValidatorUtil.deriveJoinRowType(
             leftJoinChild.getRowType(),
             rightJoinChild.getRowType(),
             JoinRelType.INNER,

File: core/src/main/java/org/apache/calcite/rel/rules/SemiJoinProjectTransposeRule.java
Patch:
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.rel.RelNode;
-import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.rel.core.SemiJoin;
@@ -32,6 +31,7 @@
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexProgram;
 import org.apache.calcite.rex.RexProgramBuilder;
+import org.apache.calcite.sql.validate.SqlValidatorUtil;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 import org.apache.calcite.util.ImmutableIntList;
@@ -125,7 +125,7 @@ private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) {
     // for the bottom RexProgram, the input is a concatenation of the
     // child of the project and the RHS of the semijoin
     RelDataType bottomInputRowType =
-        Join.deriveJoinRowType(
+        SqlValidatorUtil.deriveJoinRowType(
             project.getInput().getRowType(),
             rightChild.getRowType(),
             JoinRelType.INNER,
@@ -156,7 +156,7 @@ private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) {
     // input rowtype into the top program is the concatenation of the
     // project and the RHS of the semijoin
     RelDataType topInputRowType =
-        Join.deriveJoinRowType(
+        SqlValidatorUtil.deriveJoinRowType(
             project.getRowType(),
             rightChild.getRowType(),
             JoinRelType.INNER,

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -145,8 +145,9 @@ public boolean equalsDeep(SqlNode node, Litmus litmus) {
     SqlCall that = (SqlCall) node;
 
     // Compare operators by name, not identity, because they may not
-    // have been resolved yet.
-    if (!this.getOperator().getName().equals(that.getOperator().getName())) {
+    // have been resolved yet. Use case insensitive comparison since
+    // this may be a case insensitive system.
+    if (!this.getOperator().getName().equalsIgnoreCase(that.getOperator().getName())) {
       return litmus.fail("{} != {}", this, node);
     }
     return equalDeep(this.getOperandList(), that.getOperandList(), litmus);

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorCatalogReader.java
Patch:
@@ -92,6 +92,8 @@ public interface SqlValidatorCatalogReader {
 
   RelDataType createTypeFromProjection(RelDataType type,
       List<String> columnNameList);
+
+  boolean isCaseSensitive();
 }
 
 // End SqlValidatorCatalogReader.java

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -454,7 +454,8 @@ private void checkConvertedType(SqlNode query, RelNode result) {
     final RelDataType validatedRowType =
         validator.getTypeFactory().createStructType(
             Pair.right(validatedFields),
-            SqlValidatorUtil.uniquify(Pair.left(validatedFields)));
+            SqlValidatorUtil.uniquify(Pair.left(validatedFields),
+                catalogReader.isCaseSensitive()));
 
     final List<RelDataTypeField> convertedFields =
         result.getRowType().getFieldList().subList(0, validatedFields.size());
@@ -3520,7 +3521,7 @@ private void convertSelectList(
       fieldNames.add(deriveAlias(expr, aliases, i));
     }
 
-    fieldNames = SqlValidatorUtil.uniquify(fieldNames);
+    fieldNames = SqlValidatorUtil.uniquify(fieldNames, catalogReader.isCaseSensitive());
 
     bb.setRoot(
         RelOptUtil.createProject(bb.root, exprs, fieldNames),

File: core/src/main/java/org/apache/calcite/sql/SqlUtil.java
Patch:
@@ -263,8 +263,7 @@ public static void unparseFunctionSyntax(
     if (operator instanceof SqlFunction) {
       SqlFunction function = (SqlFunction) operator;
 
-      switch (function.getFunctionType()) {
-      case USER_DEFINED_SPECIFIC_FUNCTION:
+      if (function.getFunctionType().isSpecific()) {
         writer.keyword("SPECIFIC");
       }
       SqlIdentifier id = function.getSqlIdentifier();

File: core/src/main/java/org/apache/calcite/sql/parser/SqlAbstractParserImpl.java
Patch:
@@ -363,7 +363,7 @@ protected SqlCall createCall(
     /// name when regenerating SQL).
     if (funName.isSimple()) {
       final List<SqlOperator> list = Lists.newArrayList();
-      opTab.lookupOperatorOverloads(funName, null, SqlSyntax.FUNCTION, list);
+      opTab.lookupOperatorOverloads(funName, funcType, SqlSyntax.FUNCTION, list);
       if (list.size() == 1) {
         fun = list.get(0);
       }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableFunction.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.schema.TableFunction;
+import org.apache.calcite.sql.SqlFunctionCategory;
 import org.apache.calcite.sql.SqlIdentifier;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.type.SqlOperandTypeChecker;
@@ -42,7 +43,7 @@ public SqlUserDefinedTableFunction(SqlIdentifier opName,
       List<RelDataType> paramTypes,
       TableFunction function) {
     super(opName, returnTypeInference, operandTypeInference, operandTypeChecker,
-        paramTypes, function);
+        paramTypes, function, SqlFunctionCategory.USER_DEFINED_TABLE_FUNCTION);
   }
 
   /**

File: core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
Patch:
@@ -70,7 +70,7 @@ public SqlUserDefinedTableMacro(SqlIdentifier opName,
     super(Util.last(opName.names), opName, SqlKind.OTHER_FUNCTION,
         returnTypeInference, operandTypeInference, operandTypeChecker,
         Preconditions.checkNotNull(paramTypes),
-        SqlFunctionCategory.USER_DEFINED_FUNCTION);
+        SqlFunctionCategory.USER_DEFINED_TABLE_FUNCTION);
     this.tableMacro = tableMacro;
   }
 

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.calcite.plan.volcano.TraitPropagationTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTraitTest;
+import org.apache.calcite.prepare.LookupOperatorOverloadsTest;
 import org.apache.calcite.rel.RelCollationTest;
 import org.apache.calcite.rel.rel2sql.RelToSqlConverterTest;
 import org.apache.calcite.rex.RexBuilderTest;
@@ -119,6 +120,7 @@
     ChunkListTest.class,
     FrameworksTest.class,
     EnumerableCorrelateTest.class,
+    LookupOperatorOverloadsTest.class,
 
     // slow tests (above 1s)
     UdfTest.class,

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.calcite.rex.RexExecutorTest;
 import org.apache.calcite.runtime.BinarySearchTest;
 import org.apache.calcite.runtime.EnumerablesTest;
+import org.apache.calcite.sql.SqlSetOptionOperatorTest;
 import org.apache.calcite.sql.parser.SqlParserTest;
 import org.apache.calcite.sql.parser.SqlUnParserTest;
 import org.apache.calcite.sql.test.SqlAdvisorTest;
@@ -97,6 +98,7 @@
     // medium tests (above 0.1s)
     SqlParserTest.class,
     SqlUnParserTest.class,
+    SqlSetOptionOperatorTest.class,
     SqlPrettyWriterTest.class,
     SqlValidatorTest.class,
     SqlAdvisorTest.class,

File: core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
Patch:
@@ -529,6 +529,9 @@ public Consistency getConsistency() {
   public static final SqlSingleOperandTypeChecker SCALAR_OR_RECORD_COLLECTION =
       OperandTypes.or(COLLECTION, RECORD_COLLECTION);
 
+  public static final SqlSingleOperandTypeChecker SCALAR_OR_RECORD_COLLECTION_OR_MAP =
+      OperandTypes.or(COLLECTION_OR_MAP, RECORD_COLLECTION);
+
   public static final SqlOperandTypeChecker MULTISET_MULTISET =
       new MultisetOperandTypeChecker();
 

File: core/src/main/java/org/apache/calcite/sql/SqlSelect.java
Patch:
@@ -205,7 +205,7 @@ public void setFetch(SqlNode fetch) {
   }
 
   public void validate(SqlValidator validator, SqlValidatorScope scope) {
-    validator.validateQuery(this, scope);
+    validator.validateQuery(this, scope, validator.getUnknownType());
   }
 
   // Override SqlCall, to introduce a subquery frame.

File: core/src/main/java/org/apache/calcite/sql/SqlSetOperator.java
Patch:
@@ -87,7 +87,7 @@ public void validateCall(
       SqlValidator validator,
       SqlValidatorScope scope,
       SqlValidatorScope operandScope) {
-    validator.validateQuery(call, operandScope);
+    validator.validateQuery(call, operandScope, validator.getUnknownType());
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/SqlUpdate.java
Patch:
@@ -71,13 +71,14 @@ public SqlOperator getOperator() {
 
   public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(targetTable, targetColumnList,
-        sourceExpressionList, condition, sourceSelect, alias);
+        sourceExpressionList, condition, alias);
   }
 
   @Override public void setOperand(int i, SqlNode operand) {
     switch (i) {
     case 0:
-      targetTable = (SqlIdentifier) operand;
+      assert operand instanceof SqlIdentifier;
+      targetTable = operand;
       break;
     case 1:
       targetColumnList = (SqlNodeList) operand;

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorValidator.java
Patch:
@@ -185,11 +185,12 @@ protected void validateOver(SqlCall call, SqlValidatorScope scope) {
     }
   }
 
-  protected void validateNamespace(final SqlValidatorNamespace namespace) {
+  protected void validateNamespace(final SqlValidatorNamespace namespace,
+      RelDataType targetRowType) {
     // Only attempt to validate each namespace once. Otherwise if
     // validation fails, we may end up cycling.
     if (activeNamespaces.add(namespace)) {
-      super.validateNamespace(namespace);
+      super.validateNamespace(namespace, targetRowType);
     } else {
       namespace.setType(emptyStructType);
     }

File: core/src/main/java/org/apache/calcite/sql/validate/AliasNamespace.java
Patch:
@@ -63,7 +63,7 @@ protected AliasNamespace(
 
   //~ Methods ----------------------------------------------------------------
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     final List<String> nameList = new ArrayList<String>();
     final List<SqlNode> operands = call.getOperandList();
     final SqlValidatorNamespace childNs =

File: core/src/main/java/org/apache/calcite/sql/validate/CollectNamespace.java
Patch:
@@ -64,7 +64,7 @@ public class CollectNamespace extends AbstractNamespace {
 
   //~ Methods ----------------------------------------------------------------
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     return child.getOperator().deriveType(validator, scope, child);
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/DelegatingNamespace.java
Patch:
@@ -68,8 +68,8 @@ public RelDataType getType() {
     return namespace.getType();
   }
 
-  public void validate() {
-    namespace.validate();
+  public void validate(RelDataType targetRowType) {
+    namespace.validate(targetRowType);
   }
 
   public SqlNode getNode() {

File: core/src/main/java/org/apache/calcite/sql/validate/FieldNamespace.java
Patch:
@@ -49,7 +49,7 @@ public void setType(RelDataType type) {
     throw new UnsupportedOperationException();
   }
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     return rowType;
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
Patch:
@@ -100,7 +100,7 @@ protected static Pair<SqlIdentifier, SqlNodeList> split(SqlNode node) {
     }
   }
 
-  public RelDataType validateImpl() {
+  public RelDataType validateImpl(RelDataType targetRowType) {
     resolvedNamespace = parentScope.getTableNamespace(id.names);
     if (resolvedNamespace == null) {
       throw validator.newValidationError(id,

File: core/src/main/java/org/apache/calcite/sql/validate/JoinNamespace.java
Patch:
@@ -38,7 +38,7 @@ class JoinNamespace extends AbstractNamespace {
 
   //~ Methods ----------------------------------------------------------------
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     RelDataType leftType =
         validator.getNamespace(join.getLeft()).getRowType();
     RelDataType rightType =

File: core/src/main/java/org/apache/calcite/sql/validate/ParameterNamespace.java
Patch:
@@ -42,7 +42,7 @@ public SqlNode getNode() {
     return null;
   }
 
-  public RelDataType validateImpl() {
+  public RelDataType validateImpl(RelDataType targetRowType) {
     return type;
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java
Patch:
@@ -48,7 +48,7 @@ public class ProcedureNamespace extends AbstractNamespace {
 
   //~ Methods ----------------------------------------------------------------
 
-  public RelDataType validateImpl() {
+  public RelDataType validateImpl(RelDataType targetRowType) {
     validator.inferUnknownTypes(validator.unknownType, scope, call);
     final RelDataType type = validator.deriveTypeImpl(scope, call);
     final SqlOperator operator = call.getOperator();

File: core/src/main/java/org/apache/calcite/sql/validate/SchemaNamespace.java
Patch:
@@ -40,7 +40,7 @@ class SchemaNamespace extends AbstractNamespace {
     this.names = Preconditions.checkNotNull(names);
   }
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     final RelDataTypeFactory.FieldInfoBuilder builder =
         validator.getTypeFactory().builder();
     for (SqlMoniker moniker

File: core/src/main/java/org/apache/calcite/sql/validate/SelectNamespace.java
Patch:
@@ -56,8 +56,8 @@ public SelectNamespace(
     return select;
   }
 
-  public RelDataType validateImpl() {
-    validator.validateSelect(select, validator.unknownType);
+  public RelDataType validateImpl(RelDataType targetRowType) {
+    validator.validateSelect(select, targetRowType);
     return rowType;
   }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SetopNamespace.java
Patch:
@@ -89,7 +89,7 @@ private SqlMonotonicity combine(SqlMonotonicity m0, SqlMonotonicity m1) {
     return SqlMonotonicity.NOT_MONOTONIC;
   }
 
-  public RelDataType validateImpl() {
+  public RelDataType validateImpl(RelDataType targetRowType) {
     switch (call.getKind()) {
     case UNION:
     case INTERSECT:
@@ -100,7 +100,7 @@ public RelDataType validateImpl() {
           throw validator.newValidationError(operand,
               RESOURCE.needQueryOp(operand.toString()));
         }
-        validator.validateQuery(operand, scope);
+        validator.validateQuery(operand, scope, targetRowType);
       }
       return call.getOperator().deriveType(
           validator,

File: core/src/main/java/org/apache/calcite/sql/validate/TableNamespace.java
Patch:
@@ -44,7 +44,7 @@ public TableNamespace(SqlValidatorImpl validator, SqlValidatorTable table) {
     this(validator, table, ImmutableList.<RelDataTypeField>of());
   }
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     if (extendedFields.isEmpty()) {
       return table.getRowType();
     }

File: core/src/main/java/org/apache/calcite/sql/validate/UnnestNamespace.java
Patch:
@@ -47,7 +47,7 @@ class UnnestNamespace extends AbstractNamespace {
 
   //~ Methods ----------------------------------------------------------------
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     // Validate the call and its arguments, and infer the return type.
     validator.validateCall(unnest, scope);
     RelDataType type =

File: core/src/main/java/org/apache/calcite/sql/validate/WithItemNamespace.java
Patch:
@@ -34,7 +34,7 @@ class WithItemNamespace extends AbstractNamespace {
     this.withItem = withItem;
   }
 
-  @Override protected RelDataType validateImpl() {
+  @Override protected RelDataType validateImpl(RelDataType targetRowType) {
     final SqlValidatorNamespace childNs =
         validator.getNamespace(withItem.query);
     final RelDataType rowType = childNs.getRowTypeSansSystemColumns();

File: core/src/main/java/org/apache/calcite/sql/validate/WithNamespace.java
Patch:
@@ -48,13 +48,13 @@ public class WithNamespace extends AbstractNamespace {
 
   //~ Methods ----------------------------------------------------------------
 
-  protected RelDataType validateImpl() {
+  protected RelDataType validateImpl(RelDataType targetRowType) {
     for (SqlNode withItem : with.withList) {
       validator.validateWithItem((SqlWithItem) withItem);
     }
     final SqlValidatorScope scope2 =
         validator.getWithScope(Util.last(with.withList.getList()));
-    validator.validateQuery(with.body, scope2);
+    validator.validateQuery(with.body, scope2, targetRowType);
     final RelDataType rowType = validator.getValidatedNodeType(with.body);
     validator.setValidatedNodeType(with, rowType);
     return rowType;

File: avatica/server/src/main/java/org/apache/calcite/avatica/jdbc/JdbcResultSet.java
Patch:
@@ -65,7 +65,7 @@ public static JdbcResultSet create(String connectionId, int statementId,
    * negative value (typically -1) returns an unlimited number of rows
    * in frames of the default frame size. */
   public static JdbcResultSet create(String connectionId, int statementId,
-      ResultSet resultSet, long maxRowCount) {
+      ResultSet resultSet, int maxRowCount) {
     try {
       Meta.Signature sig = JdbcMeta.signature(resultSet.getMetaData());
       return create(connectionId, statementId, resultSet, maxRowCount, sig);
@@ -75,7 +75,7 @@ public static JdbcResultSet create(String connectionId, int statementId,
   }
 
   public static JdbcResultSet create(String connectionId, int statementId,
-      ResultSet resultSet, long maxRowCount, Meta.Signature signature) {
+      ResultSet resultSet, int maxRowCount, Meta.Signature signature) {
     try {
       final Calendar calendar = Calendar.getInstance(DateTimeUtils.GMT_ZONE);
       final int fetchRowCount;
@@ -86,7 +86,7 @@ public static JdbcResultSet create(String connectionId, int statementId,
       } else if (maxRowCount > AvaticaStatement.DEFAULT_FETCH_SIZE) {
         fetchRowCount = AvaticaStatement.DEFAULT_FETCH_SIZE;
       } else {
-        fetchRowCount = (int) maxRowCount;
+        fetchRowCount = maxRowCount;
       }
       final Meta.Frame firstFrame = frame(null, resultSet, 0, fetchRowCount, calendar);
       if (firstFrame.done) {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlItemOperator.java
Patch:
@@ -104,6 +104,7 @@ private SqlSingleOperandTypeChecker getChecker(RelDataType operandType) {
       return OperandTypes.family(
           operandType.getKeyType().getSqlTypeName().getFamily());
     case ANY:
+    case DYNAMIC_STAR:
       return OperandTypes.or(
           OperandTypes.family(SqlTypeFamily.INTEGER),
           OperandTypes.family(SqlTypeFamily.CHARACTER));
@@ -128,6 +129,7 @@ private SqlSingleOperandTypeChecker getChecker(RelDataType operandType) {
       return typeFactory.createTypeWithNullability(operandType.getValueType(),
           true);
     case ANY:
+    case DYNAMIC_STAR:
       return typeFactory.createTypeWithNullability(
           typeFactory.createSqlType(SqlTypeName.ANY), true);
     default:

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -85,7 +85,9 @@ public enum SqlTypeName {
   CURSOR(PrecScale.NO_NO, false, ExtraSqlTypes.REF_CURSOR,
       SqlTypeFamily.CURSOR),
   COLUMN_LIST(PrecScale.NO_NO, false, Types.OTHER + 2,
-      SqlTypeFamily.COLUMN_LIST);
+      SqlTypeFamily.COLUMN_LIST),
+  DYNAMIC_STAR(PrecScale.NO_NO | PrecScale.YES_NO | PrecScale.YES_YES, true,
+      Types.JAVA_OBJECT, SqlTypeFamily.ANY);
 
   public static final int MAX_DATETIME_PRECISION = 3;
 

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -271,7 +271,7 @@ public AvaticaJsonHandler createHandler(Service service) {
   @Test public void testRemoteTypeInfo() throws Exception {
     CalciteAssert.hr().with(REMOTE_CONNECTION_FACTORY)
         .metaData(GET_TYPEINFO)
-        .returns(CalciteAssert.checkResultCount(30));
+        .returns(CalciteAssert.checkResultCount(31));
   }
 
   @Test public void testRemoteTableTypes() throws Exception {

File: core/src/test/java/org/apache/calcite/test/SqlToRelTestBase.java
Patch:
@@ -575,7 +575,7 @@ public SqlValidator createValidator(
         RelDataTypeFactory typeFactory) {
       return new FarragoTestValidator(
           getOperatorTable(),
-          createCatalogReader(typeFactory),
+          catalogReader,
           typeFactory,
           getConformance());
     }

File: avatica/server/src/main/java/org/apache/calcite/avatica/server/AvaticaJsonHandler.java
Patch:
@@ -129,6 +129,7 @@ public void handle(String target, Request baseRequest,
             jsonResponse = jsonHandler.apply(jsonRequest);
           }
         } catch (Exception e) {
+          LOG.debug("Error invoking request from {}", baseRequest.getRemoteAddr(), e);
           jsonResponse = jsonHandler.convertToErrorResponse(e);
         }
 

File: avatica/server/src/main/java/org/apache/calcite/avatica/server/AvaticaProtobufHandler.java
Patch:
@@ -124,6 +124,7 @@ public void handle(String target, Request baseRequest,
             handlerResponse = pbHandler.apply(requestBytes);
           }
         } catch (Exception e) {
+          LOG.debug("Error invoking request from {}", baseRequest.getRemoteAddr(), e);
           // Catch at the highest level of exceptions
           handlerResponse = pbHandler.convertToErrorResponse(e);
         }

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfig.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.avatica.ConnectionConfig;
 import org.apache.calcite.avatica.util.Casing;
 import org.apache.calcite.avatica.util.Quoting;
+import org.apache.calcite.sql.validate.SqlConformance;
 
 /** Interface for reading connection properties within Calcite code. There is
  * a method for every property. At some point there will be similar config
@@ -52,8 +53,8 @@ public interface CalciteConnectionConfig extends ConnectionConfig {
   boolean forceDecorrelate();
   /** @see CalciteConnectionProperty#TYPE_SYSTEM */
   <T> T typeSystem(Class<T> typeSystemClass, T defaultTypeSystem);
-  /** @see CalciteConnectionProperty#FROM_REQUIRED */
-  boolean fromRequired();
+  /** @see CalciteConnectionProperty#CONFORMANCE */
+  SqlConformance conformance();
 }
 
 // End CalciteConnectionConfig.java

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionProperty.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.config;
 
 import org.apache.calcite.avatica.ConnectionProperty;
+import org.apache.calcite.sql.validate.SqlConformance;
 import org.apache.calcite.util.Bug;
 
 import java.util.HashMap;
@@ -96,8 +97,8 @@ public enum CalciteConnectionProperty implements ConnectionProperty {
    * default constructor or an {@code INSTANCE} constant. */
   TYPE_SYSTEM("typeSystem", Type.PLUGIN, null, false),
 
-  /** Whether to support SELECT without FROM, e.g. SELECT 2+2. */
-  FROM_REQUIRED("fromRequired", Type.BOOLEAN, false, false);
+  /** SQL conformance level. */
+  CONFORMANCE("conformance", Type.ENUM, SqlConformance.DEFAULT, false);
 
   private final String camelName;
   private final Type type;

File: core/src/test/java/org/apache/calcite/sql/test/DefaultSqlTestFactory.java
Patch:
@@ -86,11 +86,13 @@ public SqlParser createParser(SqlTestFactory factory, String sql) {
   public SqlValidator getValidator(SqlTestFactory factory) {
     final SqlOperatorTable operatorTable = factory.createOperatorTable(factory);
     final boolean caseSensitive = (Boolean) factory.get("caseSensitive");
+    final SqlConformance conformance =
+        (SqlConformance) factory.get("conformance");
     final RelDataTypeFactory typeFactory =
         new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     return SqlValidatorUtil.newValidator(operatorTable,
         new MockCatalogReader(typeFactory, caseSensitive).init(),
-        typeFactory);
+        typeFactory, conformance);
   }
 
   public SqlAdvisor createAdvisor(SqlValidatorWithHints validator) {

File: avatica/core/src/main/java/org/apache/calcite/avatica/remote/AbstractHandler.java
Patch:
@@ -106,7 +106,7 @@ public HandlerResponse<T> apply(T serializedRequest) {
    * @param e The exception to convert.
    * @return A HandlerResponse instance.
    */
-  private HandlerResponse<T> convertToErrorResponse(Exception e) {
+  public HandlerResponse<T> convertToErrorResponse(Exception e) {
     ErrorResponse errorResp = unwrapException(e);
 
     try {

File: avatica/core/src/test/java/org/apache/calcite/avatica/remote/AbstractHandlerTest.java
Patch:
@@ -107,6 +107,7 @@ private String exceptionToString(Exception e) {
     Mockito.when(request.accept(Mockito.any(Service.class))).thenReturn(response);
     // Throw an IOException when serializing the Response.
     Mockito.when(handler.encode(response)).thenThrow(exception);
+    Mockito.when(handler.convertToErrorResponse(exception)).thenCallRealMethod();
     // Convert the IOException into an ErrorResponse
     Mockito.when(handler.unwrapException(exception)).thenReturn(errorResponse);
     Mockito.when(handler.encode(errorResponse)).thenReturn(serializedErrorResponse);
@@ -155,6 +156,7 @@ private String exceptionToString(Exception e) {
     Mockito.when(handler.apply(Mockito.anyString())).thenCallRealMethod();
     // Throw an Exception trying to convert it back into a POJO
     Mockito.when(handler.decode(Mockito.anyString())).thenThrow(exception);
+    Mockito.when(handler.convertToErrorResponse(exception)).thenCallRealMethod();
     Mockito.when(handler.unwrapException(exception)).thenReturn(errorResponse);
     Mockito.when(handler.encode(errorResponse)).thenReturn(serializedErrorResponse);
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -253,6 +253,7 @@ public enum BuiltInMethod {
       int.class),
   POSITION(SqlFunctions.class, "position", String.class, String.class),
   TRUNCATE(SqlFunctions.class, "truncate", String.class, int.class),
+  TRUNCATE_OR_PAD(SqlFunctions.class, "truncateOrPad", String.class, int.class),
   TRIM(SqlFunctions.class, "trim", boolean.class, boolean.class, String.class,
       String.class),
   TRANSLATE3(SqlFunctions.class, "translate3", String.class, String.class, String.class),

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -755,7 +755,7 @@ private void adviseSql(String sql, Function<ResultSet, Void> checker)
     // The call to "View('(10), (2)')" expands to 'values (1), (3), (10), (20)'.
     assertThat(CalciteAssert.toString(resultSet),
         equalTo("N={'a'=1, 'baz'=2}\n"
-            + "N=[3, 4, null]\n"));
+            + "N=[3, 4, null]    \n"));
     connection.close();
   }
 

File: druid/src/test/java/org/apache/calcite/test/DruidAdapterIT.java
Patch:
@@ -45,8 +45,8 @@
  * <p>Before calling this test, you need to populate Druid, as follows:
  *
  * <blockquote><code>
- * git clone https://github.com/vlsi/test-dataset
- * cd test-dataset
+ * git clone https://github.com/vlsi/calcite-test-dataset<br>
+ * cd calcite-test-dataset<br>
  * mvn install
  * </code></blockquote>
  *

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -86,6 +86,7 @@
     TraitPropagationTest.class,
     RelWriterTest.class,
     RexProgramTest.class,
+    SqlOperatorBindingTest.class,
     RexTransformerTest.class,
     BinarySearchTest.class,
     EnumerablesTest.class,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -87,6 +87,7 @@
 import static org.apache.calcite.linq4j.tree.ExpressionType.OrElse;
 import static org.apache.calcite.linq4j.tree.ExpressionType.Subtract;
 import static org.apache.calcite.linq4j.tree.ExpressionType.UnaryPlus;
+import static org.apache.calcite.sql.fun.OracleSqlOperatorTable.TRANSLATE3;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.ABS;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.AND;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.ARRAY_VALUE_CONSTRUCTOR;
@@ -168,7 +169,6 @@
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SUM;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SUM0;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SYSTEM_USER;
-import static org.apache.calcite.sql.fun.SqlStdOperatorTable.TRANSLATE3;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.TRIM;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.UNARY_MINUS;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.UNARY_PLUS;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java
Patch:
@@ -64,10 +64,10 @@
 import java.util.List;
 import java.util.Map;
 
+import static org.apache.calcite.sql.fun.OracleSqlOperatorTable.TRANSLATE3;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.CHARACTER_LENGTH;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.CHAR_LENGTH;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SUBSTRING;
-import static org.apache.calcite.sql.fun.SqlStdOperatorTable.TRANSLATE3;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.UPPER;
 
 /**

File: core/src/main/java/org/apache/calcite/rex/RexSqlStandardConvertletTable.java
Patch:
@@ -22,6 +22,7 @@
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlNodeList;
 import org.apache.calcite.sql.SqlOperator;
+import org.apache.calcite.sql.fun.OracleSqlOperatorTable;
 import org.apache.calcite.sql.fun.SqlCaseOperator;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.parser.SqlParserPos;
@@ -99,7 +100,7 @@ public RexSqlStandardConvertletTable() {
     registerEquivOp(SqlStdOperatorTable.TRANSLATE);
     registerEquivOp(SqlStdOperatorTable.OVERLAY);
     registerEquivOp(SqlStdOperatorTable.TRIM);
-    registerEquivOp(SqlStdOperatorTable.TRANSLATE3);
+    registerEquivOp(OracleSqlOperatorTable.TRANSLATE3);
     registerEquivOp(SqlStdOperatorTable.POSITION);
     registerEquivOp(SqlStdOperatorTable.CHAR_LENGTH);
     registerEquivOp(SqlStdOperatorTable.CHARACTER_LENGTH);

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTestCase.java
Patch:
@@ -60,7 +60,7 @@ public class SqlValidatorTestCase {
 
   //~ Instance fields --------------------------------------------------------
 
-  protected final SqlTester tester;
+  protected SqlTester tester;
 
   //~ Constructors -----------------------------------------------------------
 

File: cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraMethod.java
Patch:
@@ -28,7 +28,7 @@
  */
 public enum CassandraMethod {
   CASSANDRA_QUERYABLE_QUERY(CassandraTable.CassandraQueryable.class, "query",
-      List.class, List.class, List.class, String.class);
+      List.class, List.class, List.class, List.class, String.class);
 
   public final Method method;
 

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaConnection.java
Patch:
@@ -81,7 +81,7 @@ public abstract class AvaticaConnection implements Connection {
   final String url;
   protected final Properties info;
   protected final Meta meta;
-  protected final AvaticaDatabaseMetaData metaData;
+  protected final AvaticaSpecificDatabaseMetaData metaData;
   public final Helper helper = Helper.INSTANCE;
   public final Map<InternalProperty, Object> properties = new HashMap<>();
   public final Map<Integer, AvaticaStatement> statementMap =

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaFactory.java
Patch:
@@ -67,7 +67,7 @@ AvaticaResultSet newResultSet(AvaticaStatement statement, QueryState state,
    *
    * @return Database meta data
    */
-  AvaticaDatabaseMetaData newDatabaseMetaData(AvaticaConnection connection);
+  AvaticaSpecificDatabaseMetaData newDatabaseMetaData(AvaticaConnection connection);
 
   /**
    * Creates meta data for a result set.

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaJdbc41Factory.java
Patch:
@@ -62,7 +62,7 @@ public AvaticaConnection newConnection(
     return new AvaticaJdbc41Connection(driver, factory, url, info);
   }
 
-  public AvaticaDatabaseMetaData newDatabaseMetaData(
+  public AvaticaSpecificDatabaseMetaData newDatabaseMetaData(
       AvaticaConnection connection) {
     return new AvaticaJdbc41DatabaseMetaData(connection);
   }
@@ -246,7 +246,7 @@ public void setNClob(
 
   /** Implementation of DatabaseMetaData for JDBC 4.1. */
   private static class AvaticaJdbc41DatabaseMetaData
-      extends AvaticaDatabaseMetaDataImpl {
+      extends AvaticaDatabaseMetaData {
     AvaticaJdbc41DatabaseMetaData(AvaticaConnection connection) {
       super(connection);
     }

File: avatica/core/src/main/java/org/apache/calcite/avatica/InternalProperty.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Definitions of properties that drive the behavior of
- * {@link org.apache.calcite.avatica.AvaticaDatabaseMetaDataImpl}.
+ * {@link org.apache.calcite.avatica.AvaticaDatabaseMetaData}.
  */
 public enum InternalProperty {
   /** Whether identifiers are matched case-sensitively. */

File: avatica/server/src/test/java/org/apache/calcite/avatica/RemoteDriverTest.java
Patch:
@@ -1431,7 +1431,7 @@ private void executeBatchInsertWithDates(Connection conn) throws Exception {
     ConnectionSpec.getDatabaseLock().lock();
     try (Connection conn = getLocalConnection()) {
       DatabaseMetaData metadata = conn.getMetaData();
-      assertTrue(metadata.isWrapperFor(AvaticaDatabaseMetaData.class));
+      assertTrue(metadata.isWrapperFor(AvaticaSpecificDatabaseMetaData.class));
       assertTrue(metadata.isWrapperFor(Properties.class));
       Properties props = metadata.unwrap(Properties.class);
       assertNotNull(props);

File: avatica/server/src/test/java/org/apache/calcite/avatica/remote/RemoteMetaTest.java
Patch:
@@ -17,7 +17,7 @@
 package org.apache.calcite.avatica.remote;
 
 import org.apache.calcite.avatica.AvaticaConnection;
-import org.apache.calcite.avatica.AvaticaDatabaseMetaData;
+import org.apache.calcite.avatica.AvaticaSpecificDatabaseMetaData;
 import org.apache.calcite.avatica.AvaticaSqlException;
 import org.apache.calcite.avatica.AvaticaStatement;
 import org.apache.calcite.avatica.AvaticaUtils;
@@ -629,8 +629,8 @@ private int getSales(Connection conn, String salesTable, int productId) throws E
     try (final Connection conn = DriverManager.getConnection(url)) {
       DatabaseMetaData metadata = conn.getMetaData();
       assertTrue("DatabaseMetaData is not an instance of AvaticaDatabaseMetaData",
-          metadata instanceof AvaticaDatabaseMetaData);
-      AvaticaDatabaseMetaData avaticaMetadata = (AvaticaDatabaseMetaData) metadata;
+          metadata instanceof AvaticaSpecificDatabaseMetaData);
+      AvaticaSpecificDatabaseMetaData avaticaMetadata = (AvaticaSpecificDatabaseMetaData) metadata;
       // We should get the same version back from the server
       assertEquals(FilteredConstants.VERSION, avaticaMetadata.getAvaticaServerVersion());
 

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
Patch:
@@ -89,8 +89,7 @@ protected VolcanoRuleCall(
   // implement RelOptRuleCall
   public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv) {
     if (LOGGER.isDebugEnabled()) {
-      LOGGER.debug(
-          "Transform to: rel#{}" + rel.getId() + " via {}{}", rel.getId(), getRule(),
+      LOGGER.debug("Transform to: rel#{} via {}{}", rel.getId(), getRule(),
           equiv.isEmpty() ? "" : " with equivalences " + equiv);
       if (generatedRelList != null) {
         generatedRelList.add(rel);

File: avatica/core/src/main/java/org/apache/calcite/avatica/ConnectionProperty.java
Patch:
@@ -49,13 +49,16 @@ public interface ConnectionProperty {
   enum Type {
     BOOLEAN,
     STRING,
+    NUMBER,
     ENUM,
     PLUGIN;
 
     public boolean valid(Object defaultValue) {
       switch (this) {
       case BOOLEAN:
         return defaultValue instanceof Boolean;
+      case NUMBER:
+        return defaultValue instanceof Number;
       case STRING:
       case PLUGIN:
         return defaultValue instanceof String;

File: avatica/core/src/main/java/org/apache/calcite/avatica/Meta.java
Patch:
@@ -1036,7 +1036,7 @@ static Object deserializeScalarValue(Common.TypedValue protoElement) {
       if (Common.Rep.BYTE_STRING == protoElement.getType()) {
         // Protobuf is sending native bytes (not b64) across the wire. B64 bytes is only for
         // TypedValue's benefit
-        return protoElement.getBytesValues().toByteArray();
+        return protoElement.getBytesValue().toByteArray();
       }
       // Again, let TypedValue deserialize things for us.
       return TypedValue.fromProto(protoElement).value;

File: avatica/core/src/test/java/org/apache/calcite/avatica/remote/TypedValueTest.java
Patch:
@@ -112,7 +112,7 @@ private void serializeAndEqualityCheck(TypedValue value) {
   @Test public void testBase64() {
     byte[] bytes = "qwertyasdf".getBytes(UTF_8);
     // Plain bytes get put into protobuf for simplicitly
-    Common.TypedValue proto = Common.TypedValue.newBuilder().setBytesValues(
+    Common.TypedValue proto = Common.TypedValue.newBuilder().setBytesValue(
         com.google.protobuf.ByteString.copyFrom(bytes))
         .setType(Common.Rep.BYTE_STRING).build();
 

File: avatica/core/src/main/java/org/apache/calcite/avatica/remote/TypedValue.java
Patch:
@@ -35,6 +35,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /** Value and type.
  *
  * <p>There are 3 representations:
@@ -385,7 +387,7 @@ private static void writeToProtoWithType(Common.TypedValue.Builder builder, Obje
       builder.setBytesValues(HBaseZeroCopyByteString.wrap(bytes));
       return;
     case STRING:
-      builder.setStringValueBytes(HBaseZeroCopyByteString.wrap(((String) o).getBytes()));
+      builder.setStringValueBytes(HBaseZeroCopyByteString.wrap(((String) o).getBytes(UTF_8)));
       return;
     case PRIMITIVE_CHAR:
     case CHARACTER:

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaStatement.java
Patch:
@@ -386,7 +386,7 @@ public void addBatch(String sql) throws SQLException {
   }
 
   public void clearBatch() throws SQLException {
-    throw connection.helper.unsupported();
+    this.batchedSql.clear();
   }
 
   public int[] executeBatch() throws SQLException {

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaDatabaseMetaData.java
Patch:
@@ -31,7 +31,7 @@
  *
  * <p>Some properties defined in {@link org.apache.calcite.avatica.Meta.DatabaseProperty} do not
  * correspond to a typical JDBC method/property. Those are enumerated here:
- * <table>
+ * <table summary="Avatica-Specific Properties">
  *   <tr><th>Property</th><th>Method</th></tr>
  *   <tr><td>AVATICA_VERSION</td><td>getAvaticaServerVersion()</td></tr>
  * </table>

File: avatica/core/src/main/java/org/apache/calcite/avatica/AvaticaJdbc41Factory.java
Patch:
@@ -246,7 +246,7 @@ public void setNClob(
 
   /** Implementation of DatabaseMetaData for JDBC 4.1. */
   private static class AvaticaJdbc41DatabaseMetaData
-      extends AvaticaDatabaseMetaData {
+      extends AvaticaDatabaseMetaDataImpl {
     AvaticaJdbc41DatabaseMetaData(AvaticaConnection connection) {
       super(connection);
     }

File: avatica/core/src/main/java/org/apache/calcite/avatica/InternalProperty.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Definitions of properties that drive the behavior of
- * {@link org.apache.calcite.avatica.AvaticaDatabaseMetaData}.
+ * {@link org.apache.calcite.avatica.AvaticaDatabaseMetaDataImpl}.
  */
 public enum InternalProperty {
   /** Whether identifiers are matched case-sensitively. */

File: core/src/test/java/org/apache/calcite/examples/RelBuilderExample.java
Patch:
@@ -118,7 +118,7 @@ private RelBuilder example2(RelBuilder builder) {
    * SELECT deptno, count(*) AS c, sum(sal) AS s
    * FROM emp
    * GROUP BY deptno
-   * HAVING count(*) > 10</pre>
+   * HAVING count(*) &gt; 10</pre>
    */
   private RelBuilder example3(RelBuilder builder) {
     return builder

File: core/src/test/java/org/apache/calcite/test/RexProgramTest.java
Patch:
@@ -284,10 +284,10 @@ private RexNode gt(RexNode n1, RexNode n2) {
    * <li><code>select (x + y) + (x + 1) as a, (x + (x + 1)) as b
    * from t(x, y)</code>
    * <li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)
-   * where ((x + y) > 1) and ((x + y) > 1)</code>
+   * where ((x + y) &gt; 1) and ((x + y) &gt; 1)</code>
    * <li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)
    * where not case
-   *           when x + 1 > 5 then true
+   *           when x + 1 &gt; 5 then true
    *           when y is null then null
    *           else false
    *           end</code>

File: core/src/test/java/org/apache/calcite/test/concurrent/ConcurrentTestTimedCommandGenerator.java
Patch:
@@ -103,7 +103,7 @@ void printCommands(
 
   /**
    * TimedIterator is an Iterator that repeats a given collection's elements
-   * until <code>System.currentTimeMillis() >= endTimeMillis</code>.
+   * until <code>System.currentTimeMillis() &ge; endTimeMillis</code>.
    */
   private class TimedIterator<E> implements Iterator<E> {
     private final List<E> commands;

File: core/src/main/java/org/apache/calcite/materialize/CachingLatticeStatisticProvider.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
+import com.google.common.util.concurrent.UncheckedExecutionException;
 
 import java.util.concurrent.ExecutionException;
 
@@ -48,8 +49,8 @@ public Integer load(Pair<Lattice, Lattice.Column> key)
   public int cardinality(Lattice lattice, Lattice.Column column) {
     try {
       return cache.get(Pair.of(lattice, column));
-    } catch (ExecutionException e) {
-      throw Throwables.propagate(e);
+    } catch (UncheckedExecutionException | ExecutionException e) {
+      throw Throwables.propagate(e.getCause());
     }
   }
 }

File: core/src/main/java/org/apache/calcite/rel/metadata/CachingRelMetadataProvider.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Multimap;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
@@ -77,7 +78,7 @@ public M bind(RelNode rel, RelMetadataQuery mq) {
     };
   }
 
-  public <M extends Metadata> Map<Method, MetadataHandler<M>>
+  public <M extends Metadata> Multimap<Method, MetadataHandler<M>>
   handlers(MetadataDef<M> def) {
     return underlyingProvider.handlers(def);
   }

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataProvider.java
Patch:
@@ -18,8 +18,9 @@
 
 import org.apache.calcite.rel.RelNode;
 
+import com.google.common.collect.Multimap;
+
 import java.lang.reflect.Method;
-import java.util.Map;
 
 /**
  * RelMetadataProvider defines an interface for obtaining metadata about
@@ -65,7 +66,7 @@ public interface RelMetadataProvider {
   apply(Class<? extends RelNode> relClass,
       Class<? extends M> metadataClass);
 
-  <M extends Metadata> Map<Method, MetadataHandler<M>>
+  <M extends Metadata> Multimap<Method, MetadataHandler<M>>
   handlers(MetadataDef<M> def);
 }
 

File: core/src/test/java/org/apache/calcite/test/CalciteAssert.java
Patch:
@@ -48,6 +48,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultiset;
 import com.google.common.collect.Lists;
+import com.google.common.util.concurrent.UncheckedExecutionException;
 
 import net.hydromatic.foodmart.data.hsqldb.FoodmartHsqldb;
 import net.hydromatic.scott.data.hsqldb.ScottHsqldb;
@@ -1072,9 +1073,9 @@ public PoolingConnectionFactory(final ConnectionFactory factory) {
     public Connection createConnection() throws SQLException {
       try {
         return Pool.POOL.get(factory);
-      } catch (ExecutionException e) {
+      } catch (UncheckedExecutionException | ExecutionException e) {
         throw new SQLException(
-            "Unable to get pooled connection for " + factory, e);
+            "Unable to get pooled connection for " + factory, e.getCause());
       }
     }
   }

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -2036,7 +2036,7 @@ public void transitiveInference(RelOptRule... extraRules) throws Exception {
    * Wrong collation trait in SortJoinTransposeRule for right joins</a>. */
   @Test public void testSortJoinTranspose4() {
     // Create a customized test with RelCollation trait in the test cluster.
-    Tester tester = new TesterImpl(getDiffRepos(), true, true, false, null) {
+    Tester tester = new TesterImpl(getDiffRepos(), true, true, false, null, null) {
       @Override public RelOptPlanner createPlanner() {
         return new MockRelOptPlanner() {
           @Override public List<RelTraitDef> getRelTraitDefs() {

File: avatica/src/main/java/org/apache/calcite/avatica/ConnectionConfig.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.avatica;
 
+import org.apache.calcite.avatica.remote.AvaticaHttpClientFactory;
 import org.apache.calcite.avatica.remote.Service;
 
 /**
@@ -32,6 +33,8 @@ public interface ConnectionConfig {
   String url();
   /** @see BuiltInConnectionProperty#SERIALIZATION */
   String serialization();
+  AvaticaHttpClientFactory httpClientFactory();
+  String httpClientClass();
 }
 
 // End ConnectionConfig.java

File: avatica/src/main/java/org/apache/calcite/avatica/remote/Driver.java
Patch:
@@ -135,7 +135,9 @@ AvaticaHttpClient getHttpClient(AvaticaConnection connection, ConnectionConfig c
       throw new RuntimeException(e);
     }
 
-    return new AvaticaHttpClientImpl(url);
+    AvaticaHttpClientFactory httpClientFactory = config.httpClientFactory();
+
+    return httpClientFactory.getClient(url, config);
   }
 
   @Override public Connection connect(String url, Properties info)

File: core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
Patch:
@@ -382,7 +382,8 @@ public static RelDataType deriveRowType(RelDataTypeFactory typeFactory,
 
   public boolean isValid(Litmus litmus) {
     return super.isValid(litmus)
-        && litmus.check(Util.isDistinct(getRowType().getFieldNames()), getRowType());
+        && litmus.check(Util.isDistinct(getRowType().getFieldNames()),
+            "distinct field names: {}", getRowType());
   }
 
   /**

File: core/src/main/java/org/apache/calcite/rel/core/Join.java
Patch:
@@ -155,8 +155,8 @@ public boolean isValid_(Litmus litmus) {
     }
     if (condition != null) {
       if (condition.getType().getSqlTypeName() != SqlTypeName.BOOLEAN) {
-        return litmus.fail("condition must be boolean: "
-            + condition.getType());
+        return litmus.fail("condition must be boolean: {}",
+            condition.getType());
       }
       // The input to the condition is a row type consisting of system
       // fields, left fields, and right fields. Very similar to the

File: core/src/main/java/org/apache/calcite/rex/RexChecker.java
Patch:
@@ -111,8 +111,8 @@ public Boolean visitInputRef(RexInputRef ref) {
     final int index = ref.getIndex();
     if ((index < 0) || (index >= inputTypeList.size())) {
       ++failCount;
-      return litmus.fail("RexInputRef index " + index
-          + " out of range 0.." + (inputTypeList.size() - 1));
+      return litmus.fail("RexInputRef index {} out of range 0..{}",
+          index, inputTypeList.size() - 1);
     }
     if (!ref.getType().isStruct()
         && !RelOptUtil.eq("ref", ref.getType(), "input",

File: core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
Patch:
@@ -217,7 +217,7 @@ public RelDataType deriveType(
           && count > 2) {
         return true;
       }
-      return litmus.fail("wrong operand count " + count + " for " + this);
+      return litmus.fail("wrong operand count {} for {}", count, this);
     }
     return litmus.succeed();
   }

File: core/src/main/java/org/apache/calcite/sql/SqlCall.java
Patch:
@@ -140,14 +140,14 @@ public boolean equalsDeep(SqlNode node, Litmus litmus) {
       return true;
     }
     if (!(node instanceof SqlCall)) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     SqlCall that = (SqlCall) node;
 
     // Compare operators by name, not identity, because they may not
     // have been resolved yet.
     if (!this.getOperator().getName().equals(that.getOperator().getName())) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     return equalDeep(this.getOperandList(), that.getOperandList(), litmus);
   }

File: core/src/main/java/org/apache/calcite/sql/SqlDynamicParam.java
Patch:
@@ -79,11 +79,11 @@ public <R> R accept(SqlVisitor<R> visitor) {
 
   public boolean equalsDeep(SqlNode node, Litmus litmus) {
     if (!(node instanceof SqlDynamicParam)) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     SqlDynamicParam that = (SqlDynamicParam) node;
     if (this.index != that.index) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     return litmus.succeed();
   }

File: core/src/main/java/org/apache/calcite/sql/SqlIdentifier.java
Patch:
@@ -289,15 +289,15 @@ public void validateExpr(SqlValidator validator, SqlValidatorScope scope) {
 
   public boolean equalsDeep(SqlNode node, Litmus litmus) {
     if (!(node instanceof SqlIdentifier)) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     SqlIdentifier that = (SqlIdentifier) node;
     if (this.names.size() != that.names.size()) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     for (int i = 0; i < names.size(); i++) {
       if (!this.names.get(i).equals(that.names.get(i))) {
-        return litmus.fail(this + "!=" + node);
+        return litmus.fail("{} != {}", this, node);
       }
     }
     return litmus.succeed();

File: core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
Patch:
@@ -147,7 +147,7 @@ public boolean equalsDeep(SqlNode node, Litmus litmus) {
     final String thisString = this.toString();
     final String thatString = node.toString();
     if (!thisString.equals(thatString)) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     return litmus.succeed();
   }

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -407,11 +407,11 @@ public <R> R accept(SqlVisitor<R> visitor) {
 
   public boolean equalsDeep(SqlNode node, Litmus litmus) {
     if (!(node instanceof SqlLiteral)) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     SqlLiteral that = (SqlLiteral) node;
     if (!this.equals(that)) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     return litmus.succeed();
   }

File: core/src/main/java/org/apache/calcite/sql/SqlNodeList.java
Patch:
@@ -155,11 +155,11 @@ public <R> R accept(SqlVisitor<R> visitor) {
 
   public boolean equalsDeep(SqlNode node, Litmus litmus) {
     if (!(node instanceof SqlNodeList)) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     SqlNodeList that = (SqlNodeList) node;
     if (this.size() != that.size()) {
-      return litmus.fail(this + "!=" + node);
+      return litmus.fail("{} != {}", this, node);
     }
     for (int i = 0; i < list.size(); i++) {
       SqlNode thisChild = list.get(i);

File: core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
Patch:
@@ -91,7 +91,7 @@ protected RelDataType adjustType(
 
   @Override public boolean validRexOperands(int count, Litmus litmus) {
     if (count != 1) {
-      return litmus.fail("wrong operand count " + count + " for " + this);
+      return litmus.fail("wrong operand count {} for {}", count, this);
     }
     return litmus.succeed();
   }

File: core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
Patch:
@@ -100,7 +100,7 @@ protected RelDataType adjustType(
 
   @Override public boolean validRexOperands(int count, Litmus litmus) {
     if (count != 1) {
-      return litmus.fail("wrong operand count " + count + " for " + this);
+      return litmus.fail("wrong operand count {} for {}", count, this);
     }
     return litmus.succeed();
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
Patch:
@@ -87,7 +87,7 @@ public boolean isNotIn() {
 
   @Override public boolean validRexOperands(int count, Litmus litmus) {
     if (count == 0) {
-      return litmus.fail("wrong operand count " + count + " for " + this);
+      return litmus.fail("wrong operand count {} for {}", count, this);
     }
     return litmus.succeed();
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -617,7 +617,7 @@ public boolean argumentMustBeScalar(int ordinal) {
 
         @Override public boolean validRexOperands(int count, Litmus litmus) {
           if (count != 0) {
-            return litmus.fail("wrong operand count " + count + " for " + this);
+            return litmus.fail("wrong operand count {} for {}", count, this);
           }
           return litmus.succeed();
         }

File: core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
Patch:
@@ -1323,7 +1323,7 @@ static boolean allLessThan(Collection<Integer> integers, int limit,
       Litmus ret) {
     for (int value : integers) {
       if (value >= limit) {
-        return ret.fail("out of range; value: " + value + ", limit: " + limit);
+        return ret.fail("out of range; value: {}, limit: {}", value, limit);
       }
     }
     return ret.succeed();

File: core/src/main/java/org/apache/calcite/util/Pair.java
Patch:
@@ -85,7 +85,8 @@ public boolean equals(Object obj) {
 
   /** {@inheritDoc}
    *
-   * <p>Computes hash code consistent with {@link Map.Entry#hashCode()}. */
+   * <p>Computes hash code consistent with
+   * {@link java.util.Map.Entry#hashCode()}. */
   @Override public int hashCode() {
     int keyHash = left == null ? 0 : left.hashCode();
     int valueHash = right == null ? 0 : right.hashCode();

File: linq4j/src/main/java/org/apache/calcite/linq4j/GroupingImpl.java
Patch:
@@ -43,7 +43,8 @@ class GroupingImpl<K, V> extends AbstractEnumerable<V>
 
   /** {@inheritDoc}
    *
-   * <p>Computes hash code consistent with {@link Map.Entry#hashCode()}. */
+   * <p>Computes hash code consistent with
+   * {@link java.util.Map.Entry#hashCode()}. */
   @Override public int hashCode() {
     return key.hashCode() ^ values.hashCode();
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregateRule.java
Patch:
@@ -47,7 +47,7 @@ public RelNode convert(RelNode rel) {
           agg.getGroupSets(),
           agg.getAggCallList());
     } catch (InvalidRelException e) {
-      EnumerableRules.LOGGER.fine(e.toString());
+      EnumerableRules.LOGGER.debug(e.toString());
       return null;
     }
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableJoinRule.java
Patch:
@@ -67,7 +67,7 @@ class EnumerableJoinRule extends ConverterRule {
         return new EnumerableThetaJoin(cluster, traitSet, left, right,
             join.getCondition(), join.getVariablesSet(), join.getJoinType());
       } catch (InvalidRelException e) {
-        EnumerableRules.LOGGER.fine(e.toString());
+        EnumerableRules.LOGGER.debug(e.toString());
         return null;
       }
     }
@@ -84,7 +84,7 @@ class EnumerableJoinRule extends ConverterRule {
           join.getVariablesSet(),
           join.getJoinType());
     } catch (InvalidRelException e) {
-      EnumerableRules.LOGGER.fine(e.toString());
+      EnumerableRules.LOGGER.debug(e.toString());
       return null;
     }
     if (!info.isEqui()) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
Patch:
@@ -102,7 +102,7 @@ class EnumerableMergeJoinRule extends ConverterRule {
           join.getVariablesSet(),
           join.getJoinType());
     } catch (InvalidRelException e) {
-      EnumerableRules.LOGGER.fine(e.toString());
+      EnumerableRules.LOGGER.debug(e.toString());
       return null;
     }
     if (!info.isEqui()) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRules.java
Patch:
@@ -19,7 +19,7 @@
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.util.trace.CalciteTrace;
 
-import java.util.logging.Logger;
+import org.slf4j.Logger;
 
 /**
  * Rules and relational operators for the

File: core/src/main/java/org/apache/calcite/interpreter/Bindables.java
Patch:
@@ -621,7 +621,7 @@ public RelNode convert(RelNode rel) {
             convert(agg.getInput(), traitSet), agg.indicator, agg.getGroupSet(),
             agg.getGroupSets(), agg.getAggCallList());
       } catch (InvalidRelException e) {
-        RelOptPlanner.LOGGER.fine(e.toString());
+        RelOptPlanner.LOGGER.debug(e.toString());
         return null;
       }
     }

File: core/src/main/java/org/apache/calcite/plan/RelOptPlanner.java
Patch:
@@ -25,8 +25,9 @@
 import org.apache.calcite.util.CancelFlag;
 import org.apache.calcite.util.trace.CalciteTrace;
 
+import org.slf4j.Logger;
+
 import java.util.List;
-import java.util.logging.Logger;
 import java.util.regex.Pattern;
 
 /**

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleCall.java
Patch:
@@ -24,10 +24,11 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
+import org.slf4j.Logger;
+
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.logging.Logger;
 
 /**
  * A <code>RelOptRuleCall</code> is an invocation of a {@link RelOptRule} with a

File: core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
Patch:
@@ -28,11 +28,12 @@
 
 import com.google.common.collect.ImmutableList;
 
+import org.slf4j.Logger;
+
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.logging.Logger;
 
 /**
  * A <code>RelSet</code> is an equivalence-set of expressions; that is, a set of
@@ -232,7 +233,7 @@ void mergeWith(
     assert this != otherSet;
     assert this.equivalentSet == null;
     assert otherSet.equivalentSet == null;
-    LOGGER.finer("Merge set#" + otherSet.id + " into set#" + id);
+    LOGGER.trace("Merge set#{} into set#{}", otherSet.id, id);
     otherSet.equivalentSet = this;
 
     // remove from table

File: core/src/main/java/org/apache/calcite/rel/InvalidRelException.java
Patch:
@@ -36,7 +36,7 @@
  *
  * <p>The caller that receives an {@code InvalidRelException} (typically a rule
  * attempting to create a relational expression) should log it at
- * {@link java.util.logging.Level#FINE} level.</p>
+ * the DEBUG level.</p>
  */
 public class InvalidRelException extends Exception {
   /**

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -36,9 +36,10 @@
 
 import com.google.common.collect.ImmutableList;
 
+import org.slf4j.Logger;
+
 import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Logger;
 
 /**
  * Planner rule that folds projections and filters into an underlying

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -37,12 +37,13 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 
+import org.slf4j.Logger;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
-import java.util.logging.Logger;
 
 /**
  * An assistant which offers hints and corrections to a partially-formed SQL

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -73,7 +73,6 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.logging.Level;
 
 /**
  * Transformer that walks over a tree of relational expressions, replacing each
@@ -162,8 +161,8 @@ public RelNode trim(RelNode root) {
     if (!trimResult.right.isIdentity()) {
       throw new IllegalArgumentException();
     }
-    if (SqlToRelConverter.SQL2REL_LOGGER.isLoggable(Level.FINE)) {
-      SqlToRelConverter.SQL2REL_LOGGER.fine(
+    if (SqlToRelConverter.SQL2REL_LOGGER.isDebugEnabled()) {
+      SqlToRelConverter.SQL2REL_LOGGER.debug(
           RelOptUtil.dumpPlan("Plan after trimming unused fields",
               trimResult.left, false, SqlExplainLevel.EXPPLAN_ATTRIBUTES));
     }

File: core/src/main/java/org/apache/calcite/util/Util.java
Patch:
@@ -37,6 +37,8 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
+import org.slf4j.Logger;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.BufferedReader;
@@ -80,8 +82,6 @@
 import java.util.Set;
 import java.util.TimeZone;
 import java.util.jar.JarFile;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
@@ -235,7 +235,7 @@ public static void swallow(
       Throwable e,
       Logger logger) {
     if (logger != null) {
-      logger.log(Level.FINER, "Discarding exception", e);
+      logger.debug("Discarding exception", e);
     }
   }
 

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -46,12 +46,13 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.trace.CalciteTrace;
 
+import org.slf4j.Logger;
+
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.logging.Logger;
 
 /**
  * Rules and relational operators for
@@ -518,7 +519,7 @@ public RelNode convert(RelNode rel) {
             agg.getGroupSets(),
             agg.getAggCallList());
       } catch (InvalidRelException e) {
-        LOGGER.warning(e.toString());
+        LOGGER.warn(e.toString());
         return null;
       }
     }

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -1650,7 +1650,7 @@ private RexLiteral convertLiteralInValuesList(
 
     Comparable value = literal.getValue();
 
-    if (SqlTypeUtil.isExactNumeric(type)) {
+    if (SqlTypeUtil.isExactNumeric(type) && SqlTypeUtil.hasScale(type)) {
       BigDecimal roundedValue =
           NumberUtil.rescaleBigDecimal(
               (BigDecimal) value,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableProject.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.metadata.RelMdCollation;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.util.Util;
@@ -68,12 +69,13 @@ public EnumerableProject(RelOptCluster cluster, RelTraitSet traitSet,
   public static EnumerableProject create(final RelNode input,
       final List<? extends RexNode> projects, RelDataType rowType) {
     final RelOptCluster cluster = input.getCluster();
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
     final RelTraitSet traitSet =
         cluster.traitSet().replace(EnumerableConvention.INSTANCE)
             .replaceIfs(RelCollationTraitDef.INSTANCE,
                 new Supplier<List<RelCollation>>() {
                   public List<RelCollation> get() {
-                    return RelMdCollation.project(input, projects);
+                    return RelMdCollation.project(mq, input, projects);
                   }
                 });
     return new EnumerableProject(cluster, traitSet, input, projects, rowType);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.calcite.rel.core.Values;
 import org.apache.calcite.rel.metadata.RelMdCollation;
 import org.apache.calcite.rel.metadata.RelMdDistribution;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rex.RexLiteral;
@@ -57,12 +58,13 @@ private EnumerableValues(RelOptCluster cluster, RelDataType rowType,
   public static EnumerableValues create(RelOptCluster cluster,
       final RelDataType rowType,
       final ImmutableList<ImmutableList<RexLiteral>> tuples) {
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
     final RelTraitSet traitSet =
         cluster.traitSetOf(EnumerableConvention.INSTANCE)
             .replaceIfs(RelCollationTraitDef.INSTANCE,
                 new Supplier<List<RelCollation>>() {
                   public List<RelCollation> get() {
-                    return RelMdCollation.values(rowType, tuples);
+                    return RelMdCollation.values(mq, rowType, tuples);
                   }
                 })
             .replaceIf(RelDistributionTraitDef.INSTANCE,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.rel.core.Window;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rex.RexInputRef;
@@ -74,8 +75,8 @@ public class EnumerableWindow extends Window implements EnumerableRel {
         constants, rowType, groups);
   }
 
-  public RelOptCost computeSelfCost(RelOptPlanner planner) {
-    return super.computeSelfCost(planner)
+  public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
+    return super.computeSelfCost(planner, mq)
         .multiplyBy(EnumerableConvention.COST_MULTIPLIER);
   }
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java
Patch:
@@ -148,7 +148,7 @@ public Expression record(
                 null,
                 BuiltInMethod.LIST_N.method,
                 Expressions.newArrayInit(
-                    Object.class,
+                    Comparable.class,
                     expressions)),
             List.class);
       }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
Patch:
@@ -599,7 +599,7 @@ public Expression generateAccessor(
                 null,
                 BuiltInMethod.LIST_N.method,
                 Expressions.newArrayInit(
-                    Object.class,
+                    Comparable.class,
                     list)),
             v1);
       }

File: core/src/main/java/org/apache/calcite/plan/ConventionTraitDef.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.convert.ConverterRule;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.graph.DefaultDirectedGraph;
@@ -124,6 +125,7 @@ public RelNode convert(
       RelNode rel,
       Convention toConvention,
       boolean allowInfiniteCostConverters) {
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
     final ConversionData conversionData = getConversionData(planner);
 
     final Convention fromConvention = rel.getConvention();
@@ -139,7 +141,7 @@ public RelNode convert(
       RelNode converted = rel;
       Convention previous = null;
       for (Convention arc : conversionPath) {
-        if (planner.getCost(converted).isInfinite()
+        if (planner.getCost(converted, mq).isInfinite()
             && !allowInfiniteCostConverters) {
           continue loop;
         }

File: core/src/main/java/org/apache/calcite/plan/RelOptCost.java
Patch:
@@ -32,7 +32,7 @@ public interface RelOptCost {
   /**
    * @return number of rows processed; this should not be confused with the
    * row count produced by a relational expression
-   * ({@link org.apache.calcite.rel.RelNode#getRows})
+   * ({@link org.apache.calcite.rel.RelNode#estimateRowCount})
    */
   double getRows();
 

File: core/src/main/java/org/apache/calcite/plan/volcano/AbstractConverter.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
 import org.apache.calcite.rel.convert.ConverterImpl;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 
 import java.util.List;
 
@@ -66,7 +67,7 @@ public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
         traitSet);
   }
 
-  public RelOptCost computeSelfCost(RelOptPlanner planner) {
+  public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
     return planner.getCostFactory().makeInfiniteCost();
   }
 

File: core/src/main/java/org/apache/calcite/rel/SingleRel.java
Patch:
@@ -63,9 +63,9 @@ public RelNode getInput() {
     return ImmutableList.of(input);
   }
 
-  @Override public double getRows() {
+  @Override public double estimateRowCount(RelMetadataQuery mq) {
     // Not necessarily correct, but a better default than AbstractRelNode's 1.0
-    return RelMetadataQuery.getRowCount(input);
+    return mq.getRowCount(input);
   }
 
   @Override public void childrenAccept(RelVisitor visitor) {

File: core/src/main/java/org/apache/calcite/rel/convert/ConverterImpl.java
Patch:
@@ -58,9 +58,9 @@ protected ConverterImpl(
 
   //~ Methods ----------------------------------------------------------------
 
-  // implement RelNode
-  public RelOptCost computeSelfCost(RelOptPlanner planner) {
-    double dRows = RelMetadataQuery.getRowCount(getInput());
+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,
+      RelMetadataQuery mq) {
+    double dRows = mq.getRowCount(getInput());
     double dCpu = dRows;
     double dIo = 0;
     return planner.getCostFactory().makeCost(dRows, dCpu, dIo);

File: core/src/main/java/org/apache/calcite/rel/core/Exchange.java
Patch:
@@ -89,10 +89,11 @@ public RelDistribution getDistribution() {
     return distribution;
   }
 
-  @Override public RelOptCost computeSelfCost(RelOptPlanner planner) {
+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,
+      RelMetadataQuery mq) {
     // Higher cost if rows are wider discourages pushing a project through an
     // exchange.
-    double rowCount = RelMetadataQuery.getRowCount(this);
+    double rowCount = mq.getRowCount(this);
     double bytesPerRow = getRowType().getFieldCount() * 4;
     return planner.getCostFactory().makeCost(
         Util.nLogN(rowCount) * bytesPerRow, rowCount, 0);

File: core/src/main/java/org/apache/calcite/rel/core/Intersect.java
Patch:
@@ -51,12 +51,11 @@ protected Intersect(RelInput input) {
     super(input);
   }
 
-  @Override public double getRows() {
+  @Override public double estimateRowCount(RelMetadataQuery mq) {
     // REVIEW jvs 30-May-2005:  I just pulled this out of a hat.
     double dRows = Double.MAX_VALUE;
     for (RelNode input : inputs) {
-      dRows = Math.min(
-          dRows, RelMetadataQuery.getRowCount(input));
+      dRows = Math.min(dRows, mq.getRowCount(input));
     }
     dRows *= 0.25;
     return dRows;

File: core/src/main/java/org/apache/calcite/rel/core/Minus.java
Patch:
@@ -21,6 +21,7 @@
 import org.apache.calcite.rel.RelInput;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.metadata.RelMdUtil;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.sql.SqlKind;
 
 import java.util.List;
@@ -48,8 +49,8 @@ protected Minus(RelInput input) {
     super(input);
   }
 
-  @Override public double getRows() {
-    return RelMdUtil.getMinusRowCount(this);
+  @Override public double estimateRowCount(RelMetadataQuery mq) {
+    return RelMdUtil.getMinusRowCount(mq, this);
   }
 }
 

File: core/src/main/java/org/apache/calcite/rel/core/Project.java
Patch:
@@ -210,8 +210,9 @@ public Object apply(RexNode a0) {
     return litmus.succeed();
   }
 
-  public RelOptCost computeSelfCost(RelOptPlanner planner) {
-    double dRows = RelMetadataQuery.getRowCount(getInput());
+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,
+      RelMetadataQuery mq) {
+    double dRows = mq.getRowCount(getInput());
     double dCpu = dRows * exps.size();
     double dIo = 0;
     return planner.getCostFactory().makeCost(dRows, dCpu, dIo);

File: core/src/main/java/org/apache/calcite/rel/core/Sort.java
Patch:
@@ -129,10 +129,11 @@ public final Sort copy(RelTraitSet traitSet, RelNode newInput,
   public abstract Sort copy(RelTraitSet traitSet, RelNode newInput,
       RelCollation newCollation, RexNode offset, RexNode fetch);
 
-  @Override public RelOptCost computeSelfCost(RelOptPlanner planner) {
+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,
+      RelMetadataQuery mq) {
     // Higher cost if rows are wider discourages pushing a project through a
     // sort.
-    double rowCount = RelMetadataQuery.getRowCount(this);
+    double rowCount = mq.getRowCount(this);
     double bytesPerRow = getRowType().getFieldCount() * 4;
     return planner.getCostFactory().makeCost(
         Util.nLogN(rowCount) * bytesPerRow, rowCount, 0);

File: core/src/main/java/org/apache/calcite/rel/core/Window.java
Patch:
@@ -170,14 +170,15 @@ public List<RexLiteral> getConstants() {
     return constants;
   }
 
-  public RelOptCost computeSelfCost(RelOptPlanner planner) {
+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner,
+      RelMetadataQuery mq) {
     // Cost is proportional to the number of rows and the number of
     // components (groups and aggregate functions). There is
     // no I/O cost.
     //
     // TODO #1. Add memory cost.
     // TODO #2. MIN and MAX have higher CPU cost than SUM and COUNT.
-    final double rowsIn = RelMetadataQuery.getRowCount(getInput());
+    final double rowsIn = mq.getRowCount(getInput());
     int count = groups.size();
     for (Group group : groups) {
       count += group.aggCalls.size();

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalProject.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.rel.RelShuttle;
 import org.apache.calcite.rel.core.Project;
 import org.apache.calcite.rel.metadata.RelMdCollation;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexUtil;
@@ -111,13 +112,14 @@ public static LogicalProject create(final RelNode input,
   public static LogicalProject create(final RelNode input,
       final List<? extends RexNode> projects, RelDataType rowType) {
     final RelOptCluster cluster = input.getCluster();
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
     final RelTraitSet traitSet =
         cluster.traitSet().replace(Convention.NONE)
             .replaceIfs(
                 RelCollationTraitDef.INSTANCE,
                 new Supplier<List<RelCollation>>() {
                   public List<RelCollation> get() {
-                    return RelMdCollation.project(input, projects);
+                    return RelMdCollation.project(mq, input, projects);
                   }
                 });
     return new LogicalProject(cluster, traitSet, input, projects, rowType);

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.TableFunctionScan;
 import org.apache.calcite.rel.metadata.RelColumnMapping;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 
@@ -111,7 +112,7 @@ public static LogicalTableFunctionScan create(
         columnMappings);
   }
 
-  public RelOptCost computeSelfCost(RelOptPlanner planner) {
+  public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
     // REVIEW jvs 8-Jan-2006:  what is supposed to be here
     // for an abstract rel?
     return planner.getCostFactory().makeHugeCost();

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.calcite.rel.RelShuttle;
 import org.apache.calcite.rel.core.Values;
 import org.apache.calcite.rel.metadata.RelMdCollation;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.sql.type.SqlTypeName;
@@ -81,11 +82,12 @@ public LogicalValues(RelInput input) {
   public static LogicalValues create(RelOptCluster cluster,
       final RelDataType rowType,
       final ImmutableList<ImmutableList<RexLiteral>> tuples) {
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
     final RelTraitSet traitSet = cluster.traitSetOf(Convention.NONE)
         .replaceIfs(
             RelCollationTraitDef.INSTANCE, new Supplier<List<RelCollation>>() {
               public List<RelCollation> get() {
-                return RelMdCollation.values(rowType, tuples);
+                return RelMdCollation.values(mq, rowType, tuples);
               }
             });
     return new LogicalValues(cluster, traitSet, rowType, tuples);

File: core/src/main/java/org/apache/calcite/rel/metadata/Metadata.java
Patch:
@@ -26,7 +26,7 @@
  * kinds of metadata for particular sub-classes of {@link RelNode}.
  *
  * <p>User code (typically in a planner rule or an implementation of
- * {@link RelNode#computeSelfCost(org.apache.calcite.plan.RelOptPlanner)})
+ * {@link RelNode#computeSelfCost(org.apache.calcite.plan.RelOptPlanner, RelMetadataQuery)})
  * acquires a {@code Metadata} instance by calling {@link RelNode#metadata}.
  *
  * <p>A {@code Metadata} instance already knows which particular {@code RelNode}

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -72,8 +72,8 @@ public void onMatch(RelOptRuleCall call) {
     final ImmutableBitSet newGroupSet =
         aggregate.getGroupSet().union(filterColumns);
     final RelNode input = filter.getInput();
-    final Boolean unique =
-        RelMetadataQuery.areColumnsUnique(input, newGroupSet);
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
+    final Boolean unique = mq.areColumnsUnique(input, newGroupSet);
     if (unique != null && unique) {
       // The input is already unique on the grouping columns, so there's little
       // advantage of aggregating again. More important, without this check,

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectPullUpConstantsRule.java
Patch:
@@ -109,8 +109,9 @@ public void onMatch(RelOptRuleCall call) {
     }
 
     final RexBuilder rexBuilder = aggregate.getCluster().getRexBuilder();
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
     final RelOptPredicateList predicates =
-        RelMetadataQuery.getPulledUpPredicates(aggregate.getInput());
+        mq.getPulledUpPredicates(aggregate.getInput());
     if (predicates == null) {
       return;
     }

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.calcite.rel.core.Aggregate;
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.rel.core.Project;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.schema.impl.StarTable;
@@ -115,7 +116,8 @@ protected void apply(RelOptRuleCall call, Project postProject,
     final RelBuilder relBuilder = call.builder();
     final CalciteSchema.TableEntry tableEntry = pair.left;
     final TileKey tileKey = pair.right;
-    final double rowCount = aggregate.getRows();
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
+    final double rowCount = aggregate.estimateRowCount(mq);
     final Table aggregateTable = tableEntry.getTable();
     final RelDataType aggregateTableRowType =
         aggregateTable.getRowType(cluster.getTypeFactory());

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.rel.logical.LogicalAggregate;
 import org.apache.calcite.rel.logical.LogicalUnion;
 import org.apache.calcite.rel.metadata.RelMdUtil;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.fun.SqlCountAggFunction;
@@ -115,10 +116,10 @@ public void onMatch(RelOptRuleCall call) {
     // create corresponding aggregates on top of each union child
     final RelBuilder relBuilder = call.builder();
     int transformCount = 0;
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
     for (RelNode input : union.getInputs()) {
       boolean alreadyUnique =
-          RelMdUtil.areColumnsDefinitelyUnique(
-              input,
+          RelMdUtil.areColumnsDefinitelyUnique(mq, input,
               aggRel.getGroupSet());
 
       relBuilder.push(input);

File: core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
Patch:
@@ -59,7 +59,8 @@ public JoinPushTransitivePredicatesRule(Class<? extends Join> clazz,
 
   @Override public void onMatch(RelOptRuleCall call) {
     Join join = call.rel(0);
-    RelOptPredicateList preds = RelMetadataQuery.getPulledUpPredicates(join);
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
+    RelOptPredicateList preds = mq.getPulledUpPredicates(join);
 
     if (preds.leftInferredPredicates.isEmpty()
         && preds.rightInferredPredicates.isEmpty()) {

File: core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
Patch:
@@ -87,14 +87,15 @@ public MultiJoinOptimizeBushyRule(RelFactories.JoinFactory joinFactory,
     final MultiJoin multiJoinRel = call.rel(0);
     final RexBuilder rexBuilder = multiJoinRel.getCluster().getRexBuilder();
     final RelBuilder relBuilder = call.builder();
+    final RelMetadataQuery mq = RelMetadataQuery.instance();
 
     final LoptMultiJoin multiJoin = new LoptMultiJoin(multiJoinRel);
 
     final List<Vertex> vertexes = Lists.newArrayList();
     int x = 0;
     for (int i = 0; i < multiJoin.getNumJoinFactors(); i++) {
       final RelNode rel = multiJoin.getJoinFactor(i);
-      double cost = RelMetadataQuery.getRowCount(rel);
+      double cost = mq.getRowCount(rel);
       vertexes.add(new LeafVertex(i, rel, cost, x));
       x += rel.getRowType().getFieldCount();
     }

File: core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
Patch:
@@ -148,7 +148,8 @@ protected RexNode apply(RexSubQuery e, Set<CorrelationId> variablesSet,
     switch (e.getKind()) {
     case SCALAR_QUERY:
       builder.push(e.rel);
-      final Boolean unique = RelMetadataQuery.areColumnsUnique(builder.peek(),
+      final RelMetadataQuery mq = RelMetadataQuery.instance();
+      final Boolean unique = mq.areColumnsUnique(builder.peek(),
           ImmutableBitSet.of());
       if (unique == null || !unique) {
         builder.aggregate(builder.groupKey(),

File: core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.TableScan;
+import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.schema.Schema;
@@ -129,7 +130,8 @@ public StarTableScan(RelOptCluster cluster, RelOptTable relOptTable) {
       super(cluster, cluster.traitSetOf(Convention.NONE), relOptTable);
     }
 
-    @Override public RelOptCost computeSelfCost(RelOptPlanner planner) {
+    @Override public RelOptCost computeSelfCost(RelOptPlanner planner,
+        RelMetadataQuery mq) {
       return planner.getCostFactory().makeInfiniteCost();
     }
   }

File: core/src/main/java/org/apache/calcite/util/Bug.java
Patch:
@@ -171,9 +171,9 @@ public abstract class Bug {
   public static final boolean CALCITE_673_FIXED = false;
 
   /** Whether
-   * <a href="https://issues.apache.org/jira/browse/CALCITE-794">[CALCITE-794]
-   * Detect cycles when computing statistics</a> is fixed. */
-  public static final boolean CALCITE_794_FIXED = false;
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-1048">[CALCITE-1048]
+   * Make metadata more robust</a> is fixed. */
+  public static final boolean CALCITE_1048_FIXED = false;
 
   /** Whether
    * <a href="https://issues.apache.org/jira/browse/CALCITE-1045">[CALCITE-1045]

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -176,7 +176,7 @@ public enum BuiltInMethod {
   FUNCTION1_APPLY(Function1.class, "apply", Object.class),
   ARRAYS_AS_LIST(Arrays.class, "asList", Object[].class),
   ARRAY(SqlFunctions.class, "array", Object[].class),
-  LIST_N(FlatLists.class, "of", Object[].class),
+  LIST_N(FlatLists.class, "copyOf", Comparable[].class),
   LIST2(FlatLists.class, "of", Object.class, Object.class),
   LIST3(FlatLists.class, "of", Object.class, Object.class, Object.class),
   COMPARABLE_EMPTY_LIST(FlatLists.class, "COMPARABLE_EMPTY_LIST", true),
@@ -346,14 +346,14 @@ public enum BuiltInMethod {
   COLUMN_ORIGIN(ColumnOrigin.class, "getColumnOrigins", int.class),
   CUMULATIVE_COST(CumulativeCost.class, "getCumulativeCost"),
   NON_CUMULATIVE_COST(NonCumulativeCost.class, "getNonCumulativeCost"),
+  PREDICATES(Predicates.class, "getPredicates"),
   EXPLAIN_VISIBILITY(ExplainVisibility.class, "isVisibleInExplain",
       SqlExplainLevel.class),
   SCALAR_EXECUTE1(Scalar.class, "execute", Context.class),
   SCALAR_EXECUTE2(Scalar.class, "execute", Context.class, Object[].class),
   CONTEXT_VALUES(Context.class, "values", true),
   CONTEXT_ROOT(Context.class, "root", true),
   DATA_CONTEXT_GET_QUERY_PROVIDER(DataContext.class, "getQueryProvider"),
-  PREDICATES(Predicates.class, "getPredicates"),
   METADATA_REL(Metadata.class, "rel");
 
   public final Method method;
@@ -373,7 +373,7 @@ public enum BuiltInMethod {
     MAP = builder.build();
   }
 
-  private BuiltInMethod(Method method, Constructor constructor, Field field) {
+  BuiltInMethod(Method method, Constructor constructor, Field field) {
     this.method = method;
     this.constructor = constructor;
     this.field = field;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -138,7 +138,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
           SqlKind.AND,
           28,
           true,
-          ReturnTypes.BOOLEAN_NULLABLE,
+          ReturnTypes.ARG0_NULLABLE, // more efficient than BOOLEAN_NULLABLE
           InferTypes.BOOLEAN,
           OperandTypes.BOOLEAN_BOOLEAN);
 
@@ -427,7 +427,7 @@ public class SqlStdOperatorTable extends ReflectiveSqlOperatorTable {
           SqlKind.OR,
           26,
           true,
-          ReturnTypes.BOOLEAN_NULLABLE,
+          ReturnTypes.ARG0_NULLABLE, // more efficient than BOOLEAN_NULLABLE
           InferTypes.BOOLEAN,
           OperandTypes.BOOLEAN_BOOLEAN);
 
@@ -628,7 +628,7 @@ public boolean argumentMustBeScalar(int ordinal) {
           "NOT",
           SqlKind.NOT,
           30,
-          ReturnTypes.BOOLEAN_NULLABLE,
+          ReturnTypes.ARG0,
           InferTypes.BOOLEAN,
           OperandTypes.BOOLEAN);
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
Patch:
@@ -99,8 +99,8 @@ class EnumerableMergeJoinRule extends ConverterRule {
           info.getEquiCondition(left, right, cluster.getRexBuilder()),
           info.leftKeys,
           info.rightKeys,
-          join.getJoinType(),
-          join.getVariablesStopped());
+          join.getVariablesSet(),
+          join.getJoinType());
     } catch (InvalidRelException e) {
       EnumerableRules.LOGGER.fine(e.toString());
       return null;

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -44,7 +44,6 @@
 import org.apache.calcite.sql.SqlUtil;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
-import org.apache.calcite.util.BitSets;
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.graph.DefaultDirectedGraph;
 import org.apache.calcite.util.graph.DefaultEdge;
@@ -260,7 +259,7 @@ public String sql(ImmutableBitSet groupSet, List<Measure> aggCallList) {
     final StringBuilder groupBuf = new StringBuilder("\nGROUP BY ");
     int k = 0;
     final Set<String> columnNames = Sets.newHashSet();
-    for (int i : BitSets.toIter(groupSet)) {
+    for (int i : groupSet) {
       if (k++ > 0) {
         buf.append(", ");
         groupBuf.append(", ");

File: core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.plan;
 
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.metadata.DefaultRelMetadataProvider;
 import org.apache.calcite.rel.metadata.MetadataFactory;
 import org.apache.calcite.rel.metadata.MetadataFactoryImpl;
@@ -143,8 +144,8 @@ public MetadataFactory getMetadataFactory() {
    * Constructs a new id for a correlating variable. It is unique within the
    * whole query.
    */
-  public int createCorrel() {
-    return nextCorrel.getAndIncrement();
+  public CorrelationId createCorrel() {
+    return new CorrelationId(nextCorrel.getAndIncrement());
   }
 
   /** Returns the default trait set for this cluster. */

File: core/src/main/java/org/apache/calcite/plan/RelOptQuery.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.plan;
 
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rex.RexBuilder;
 
@@ -35,7 +36,7 @@ public class RelOptQuery {
   /**
    * Prefix to the name of correlating variables.
    */
-  public static final String CORREL_PREFIX = "$cor";
+  public static final String CORREL_PREFIX = CorrelationId.CORREL_PREFIX;
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -1759,7 +1759,7 @@ private RelSubset registerImpl(
           nextSetId++,
           Util.minus(
               RelOptUtil.getVariablesSet(rel),
-              rel.getVariablesStopped()),
+              rel.getVariablesSet()),
           RelOptUtil.getVariablesUsed(rel));
       this.allSets.add(set);
     }

File: core/src/main/java/org/apache/calcite/rel/core/SemiJoin.java
Patch:
@@ -71,8 +71,8 @@ public SemiJoin(
         condition,
         leftKeys,
         rightKeys,
-        JoinRelType.INNER,
-        ImmutableSet.<String>of());
+        ImmutableSet.<CorrelationId>of(),
+        JoinRelType.INNER);
   }
 
   /** Creates a SemiJoin. */

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -397,7 +397,7 @@ RexNode toRex(RelInput relInput, Object o) {
       if (correl != null) {
         final Object jsonType = map.get("type");
         RelDataType type = toType(cluster.getTypeFactory(), jsonType);
-        return rexBuilder.makeCorrel(type, correl);
+        return rexBuilder.makeCorrel(type, new CorrelationId(correl));
       }
       if (map.containsKey("literal")) {
         final Object literal = map.get("literal");

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.calcite.rel.RelDistributionTraitDef;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Calc;
+import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.metadata.RelMdCollation;
 import org.apache.calcite.rel.metadata.RelMdDistribution;
 import org.apache.calcite.rel.rules.FilterToCalcRule;
@@ -113,9 +114,9 @@ public RelDistribution get() {
     return new LogicalCalc(getCluster(), traitSet, child, program);
   }
 
-  @Override public void collectVariablesUsed(Set<String> variableSet) {
+  @Override public void collectVariablesUsed(Set<CorrelationId> variableSet) {
     final RelOptUtil.VariableUsedVisitor vuv =
-        new RelOptUtil.VariableUsedVisitor();
+        new RelOptUtil.VariableUsedVisitor(null);
     for (RexNode expr : program.getExprList()) {
       expr.accept(vuv);
     }

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalCorrelate.java
Patch:
@@ -19,13 +19,15 @@
 import org.apache.calcite.plan.Convention;
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelTraitSet;
+import org.apache.calcite.prepare.CalcitePrepareImpl;
 import org.apache.calcite.rel.RelInput;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelShuttle;
 import org.apache.calcite.rel.core.Correlate;
 import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.sql.SemiJoinType;
 import org.apache.calcite.util.ImmutableBitSet;
+import org.apache.calcite.util.Litmus;
 
 /**
  * A relational operator that performs nested-loop joins.
@@ -69,6 +71,7 @@ public LogicalCorrelate(
         correlationId,
         requiredColumns,
         joinType);
+    assert !CalcitePrepareImpl.DEBUG || isValid(Litmus.THROW);
   }
 
   @Deprecated // to be removed before 2.0

File: core/src/main/java/org/apache/calcite/rel/rules/EquiJoin.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.util.ImmutableIntList;
@@ -38,7 +39,7 @@ public EquiJoin(RelOptCluster cluster, RelTraitSet traits, RelNode left,
       ImmutableIntList rightKeys, JoinRelType joinType,
       Set<String> variablesStopped) {
     super(cluster, traits, left, right, condition, leftKeys, rightKeys,
-        joinType, variablesStopped);
+        CorrelationId.setOf(variablesStopped), joinType);
   }
 }
 

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToCorrelateRule.java
Patch:
@@ -102,10 +102,9 @@ public void onMatch(RelOptRuleCall call) {
     final RelOptCluster cluster = join.getCluster();
     final RexBuilder rexBuilder = cluster.getRexBuilder();
     final RelBuilder relBuilder = call.builder();
-    final int dynInId = cluster.createCorrel();
-    final CorrelationId correlationId = new CorrelationId(dynInId);
+    final CorrelationId correlationId = cluster.createCorrel();
     final RexNode corrVar =
-        rexBuilder.makeCorrel(left.getRowType(), correlationId.getName());
+        rexBuilder.makeCorrel(left.getRowType(), correlationId);
     final ImmutableBitSet.Builder requiredColumns = ImmutableBitSet.builder();
 
     // Replace all references of left input with FieldAccess(corrVar, field)

File: core/src/main/java/org/apache/calcite/rel/rules/JoinUnionTransposeRule.java
Patch:
@@ -70,7 +70,7 @@ public void onMatch(RelOptRuleCall call) {
     if (!unionRel.all) {
       return;
     }
-    if (!join.getVariablesStopped().isEmpty()) {
+    if (!join.getVariablesSet().isEmpty()) {
       return;
     }
     // The UNION ALL cannot be on the null generating side

File: core/src/main/java/org/apache/calcite/rex/RexVisitor.java
Patch:
@@ -45,6 +45,8 @@ public interface RexVisitor<R> {
   R visitRangeRef(RexRangeRef rangeRef);
 
   R visitFieldAccess(RexFieldAccess fieldAccess);
+
+  R visitSubQuery(RexSubQuery subQuery);
 }
 
 // End RexVisitor.java

File: core/src/main/java/org/apache/calcite/schema/SchemaPlus.java
Patch:
@@ -26,7 +26,7 @@
  * <p>Given a user-defined schema that implements the {@link Schema} interface,
  * Calcite creates a wrapper that implements the {@code SchemaPlus} interface.
  * This provides extra functionality, such as access to tables that have been
- * added explicitly.</p>
+ * added explicitly.
  *
  * <p>A user-defined schema does not need to implement this interface, but by
  * the time a schema is passed to a method in a user-defined schema or

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1927,6 +1927,7 @@ private SqlNode registerFrom(
       if (newRight != right) {
         join.setRight(newRight);
       }
+      registerSubqueries(joinScope, join.getCondition());
       final JoinNamespace joinNamespace = new JoinNamespace(this, join);
       registerNamespace(null, null, joinNamespace, forceNullable);
       return join;

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.calcite.rel.RelRoot;
 import org.apache.calcite.rel.core.Aggregate;
 import org.apache.calcite.rel.core.AggregateCall;
+import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rel.core.Project;
@@ -1160,7 +1161,7 @@ private void checkAverageRowSize(RelOptCluster cluster, RelOptTable empTable,
     // Join
     final LogicalJoin join =
         LogicalJoin.create(empScan, deptProject, rexBuilder.makeLiteral(true),
-            JoinRelType.INNER, ImmutableSet.<String>of());
+            ImmutableSet.<CorrelationId>of(), JoinRelType.INNER);
     rowSize = RelMetadataQuery.getAverageRowSize(join);
     columnSizes = RelMetadataQuery.getAverageColumnSizes(join);
     assertThat(columnSizes.size(), equalTo(13));

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectMergeRule.java
Patch:
@@ -24,9 +24,9 @@
 import org.apache.calcite.rel.core.RelFactories;
 import org.apache.calcite.rel.core.RelFactories.ProjectFactory;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
-import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.util.Permutation;
 
 import java.util.List;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlArrayQueryConstructor.java
Patch:
@@ -26,7 +26,7 @@ public class SqlArrayQueryConstructor extends SqlMultisetQueryConstructor {
   //~ Constructors -----------------------------------------------------------
 
   public SqlArrayQueryConstructor() {
-    super("ARRAY", SqlKind.MAP_QUERY_CONSTRUCTOR);
+    super("ARRAY", SqlKind.ARRAY_QUERY_CONSTRUCTOR);
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlArrayValueConstructor.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.type.SqlTypeUtil;
 
 /**
- * Definition of the SQL:2003 standard ARRAY constructor, <code>MULTISET
+ * Definition of the SQL:2003 standard ARRAY constructor, <code>ARRAY
  * [&lt;expr&gt;, ...]</code>.
  */
 public class SqlArrayValueConstructor extends SqlMultisetValueConstructor {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
Patch:
@@ -122,7 +122,7 @@ public void unparse(
       SqlCall call,
       int leftPrec,
       int rightPrec) {
-    writer.keyword("MULTISET");
+    writer.keyword(getName());
     final SqlWriter.Frame frame = writer.startList("(", ")");
     assert call.operandCount() == 1;
     call.operand(0).unparse(writer, leftPrec, rightPrec);

File: core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.calcite.tools.Frameworks;
 import org.apache.calcite.tools.Planner;
 import org.apache.calcite.tools.Program;
+import org.apache.calcite.util.Util;
 
 import org.junit.Test;
 
@@ -51,7 +52,7 @@ private void checkRel2Sql(Planner planner, String query, String expectedQuery,
       final RelToSqlConverter converter =
           new RelToSqlConverter(dialect);
       final SqlNode sqlNode = converter.visitChild(0, rel).asQuery();
-      assertThat(sqlNode.toSqlString(dialect).getSql(),
+      assertThat(Util.toLinux(sqlNode.toSqlString(dialect).getSql()),
           is(expectedQuery));
     } catch (Exception e) {
       assertTrue("Parsing failed throwing error: " + e.getMessage(), false);

File: core/src/main/java/org/apache/calcite/runtime/Utilities.java
Patch:
@@ -29,6 +29,8 @@ public class Utilities {
   protected Utilities() {
   }
 
+  /** @deprecated Use {@link java.util.Objects#equals}. */
+  @Deprecated // to be removed before 2.0
   public static boolean equal(Object o0, Object o1) {
     // Same as java.lang.Objects.equals (JDK 1.7 and later)
     // and com.google.common.base.Objects.equal

File: core/src/main/java/org/apache/calcite/sql/SqlUtil.java
Patch:
@@ -493,7 +493,7 @@ public RelDataType apply(Integer a0) {
         final RelDataType argType = p.right;
         final RelDataType paramType = p.left;
         if (argType != null
-            && !SqlTypeUtil.canAssignFrom(paramType, argType)) {
+            && !SqlTypeUtil.canCastFrom(paramType, argType, false)) {
           iter.remove();
           continue loop;
         }

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeExplicitPrecedenceList.java
Patch:
@@ -71,6 +71,7 @@ public class SqlTypeExplicitPrecedenceList
       ImmutableMap.<SqlTypeName, SqlTypeExplicitPrecedenceList>builder()
           .put(SqlTypeName.BOOLEAN, list(SqlTypeName.BOOLEAN))
           .put(SqlTypeName.TINYINT, numeric(SqlTypeName.TINYINT))
+          .put(SqlTypeName.SMALLINT, numeric(SqlTypeName.SMALLINT))
           .put(SqlTypeName.INTEGER, numeric(SqlTypeName.INTEGER))
           .put(SqlTypeName.BIGINT, numeric(SqlTypeName.BIGINT))
           .put(SqlTypeName.DECIMAL, numeric(SqlTypeName.DECIMAL))

File: core/src/test/java/org/apache/calcite/test/CalciteAssert.java
Patch:
@@ -275,7 +275,8 @@ public Void apply(ResultSet resultSet) {
             throw new AssertionError("expected 1 column");
           }
           final String resultString = resultSet.getString(1);
-          assertEquals(expected, Util.toLinux(resultString));
+          assertEquals(expected,
+              resultString == null ? null : Util.toLinux(resultString));
           return null;
         } catch (SQLException e) {
           throw new RuntimeException(e);

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCountAggFunction.java
Patch:
@@ -48,7 +48,7 @@ public SqlCountAggFunction() {
     super(
         "COUNT",
         null,
-        SqlKind.OTHER_FUNCTION,
+        SqlKind.COUNT,
         ReturnTypes.BIGINT,
         null,
         SqlValidator.STRICT

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSingleValueAggFunction.java
Patch:
@@ -35,6 +35,7 @@
 public class SqlSingleValueAggFunction extends SqlAggFunction {
   //~ Instance fields --------------------------------------------------------
 
+  @Deprecated // to be removed before 2.0
   private final RelDataType type;
 
   //~ Constructors -----------------------------------------------------------
@@ -44,7 +45,7 @@ public SqlSingleValueAggFunction(
     super(
         "SINGLE_VALUE",
         null,
-        SqlKind.OTHER_FUNCTION,
+        SqlKind.SINGLE_VALUE,
         ReturnTypes.ARG0,
         null,
         OperandTypes.ANY,
@@ -64,6 +65,7 @@ public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     return type;
   }
 
+  @Deprecated // to be removed before 2.0
   public RelDataType getType() {
     return type;
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSumAggFunction.java
Patch:
@@ -39,6 +39,7 @@ public class SqlSumAggFunction extends SqlAggFunction {
 
   //~ Instance fields --------------------------------------------------------
 
+  @Deprecated // to be removed before 2.0
   private final RelDataType type;
 
   //~ Constructors -----------------------------------------------------------
@@ -47,7 +48,7 @@ public SqlSumAggFunction(RelDataType type) {
     super(
         "SUM",
         null,
-        SqlKind.OTHER_FUNCTION,
+        SqlKind.SUM,
         ReturnTypes.AGG_SUM,
         null,
         OperandTypes.NUMERIC,
@@ -63,6 +64,7 @@ public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     return ImmutableList.of(type);
   }
 
+  @Deprecated // to be removed before 2.0
   public RelDataType getType() {
     return type;
   }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java
Patch:
@@ -42,7 +42,7 @@ public class SqlSumEmptyIsZeroAggFunction extends SqlAggFunction {
   SqlSumEmptyIsZeroAggFunction() {
     super("$SUM0",
         null,
-        SqlKind.OTHER_FUNCTION,
+        SqlKind.SUM0,
         ReturnTypes.AGG_SUM_EMPTY_IS_ZERO,
         null,
         OperandTypes.NUMERIC,

File: core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
Patch:
@@ -268,7 +268,7 @@ protected void perform(RelOptRuleCall call, Filter filter,
     // create a FilterRel on top of the join if needed
     relBuilder.filter(
         RexUtil.fixUp(rexBuilder, aboveFilters,
-            RelOptUtil.getFieldTypeList(newJoinRel.getRowType())));
+            RelOptUtil.getFieldTypeList(relBuilder.peek().getRowType())));
 
     call.transformTo(relBuilder.build());
   }

File: core/src/main/java/org/apache/calcite/materialize/Lattice.java
Patch:
@@ -327,7 +327,8 @@ public String sql(ImmutableBitSet groupSet, List<Measure> aggCallList) {
       }
     }
     if (CalcitePrepareImpl.DEBUG) {
-      System.out.println("Lattice SQL:\n" + buf);
+      System.out.println("Lattice SQL:\n"
+          + buf);
     }
     buf.append(groupBuf);
     return buf.toString();

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -502,7 +502,8 @@ public RelNode get() {
         RelNode rel2 = lattice.rewrite(leafJoinRoot.get());
         if (rel2 != null) {
           if (CalcitePrepareImpl.DEBUG) {
-            System.out.println("use lattice:\n" + RelOptUtil.toString(rel2));
+            System.out.println("use lattice:\n"
+                + RelOptUtil.toString(rel2));
           }
           latticeUses.add(Pair.of(lattice, rel2));
         }

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -4806,7 +4806,8 @@ public RelDataType getRowType(
     new Quidem(bufferedReader, writer, env, connectionFactory).execute();
     final String diff = DiffTestCase.diff(inFile, outFile);
     if (!diff.isEmpty()) {
-      fail("Files differ: " + outFile + " " + inFile + "\n" + diff);
+      fail("Files differ: " + outFile + " " + inFile + "\n"
+          + diff);
     }
   }
 

File: avatica-server/src/main/java/org/apache/calcite/avatica/server/DelegatingAvaticaHandler.java
Patch:
@@ -36,7 +36,7 @@
  * An AvaticaHandler implementation that delegates to a provided Jetty Handler instance.
  *
  * <p>This implementation provides a no-op implementation for
- * {@link #setServerRpcMetadata(RpcMetadataResponse)}.
+ * {@link #setServerRpcMetadata(org.apache.calcite.avatica.remote.Service.RpcMetadataResponse)}.
  */
 public class DelegatingAvaticaHandler implements AvaticaHandler {
   private static final Log LOG = LogFactory.getLog(DelegatingAvaticaHandler.class);

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaConnection.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.avatica;
 
-import org.apache.calcite.avatica.AvaticaConnection.CallableWithoutException;
 import org.apache.calcite.avatica.Meta.MetaResultSet;
 import org.apache.calcite.avatica.remote.Service.ErrorResponse;
 import org.apache.calcite.avatica.remote.Service.OpenConnectionRequest;
@@ -116,7 +115,8 @@ protected AvaticaConnection(UnregisteredDriver driver,
   }
 
   /** Computes the number of retries
-   * {@link #executeInternal(String)} should retry before failing. */
+   * {@link #executeQueryInternal(AvaticaStatement, Meta.Signature, Meta.Frame, QueryState)}
+   * should retry before failing. */
   long getNumStatementRetries(Properties props) {
     return Long.valueOf(Objects.requireNonNull(props)
         .getProperty(NUM_EXECUTE_RETRIES_KEY, NUM_EXECUTE_RETRIES_DEFAULT));

File: avatica/src/main/java/org/apache/calcite/avatica/ConnectStringParser.java
Patch:
@@ -142,7 +142,7 @@ Properties parseInternal(Properties props)
   }
 
   /**
-   * Reads "name=value;" or "name=value<EOF>".
+   * Reads "name=value;" or "name=value&lt;EOF&gt;".
    *
    * @throws SQLException error parsing value
    */
@@ -198,7 +198,7 @@ String parseName() {
   }
 
   /**
-   * Reads "value;" or "value<EOF>"
+   * Reads "value;" or "value&lt;EOF&gt;"
    *
    * @throws SQLException if find an unterminated quoted value
    */

File: avatica/src/main/java/org/apache/calcite/avatica/MetaImpl.java
Patch:
@@ -830,7 +830,7 @@ public Object next() {
   }
 
   /** Iterable that yields an iterator over rows coming from a sequence of
-   * {@link Frame}s. */
+   * {@link Meta.Frame}s. */
   private class FetchIterable implements Iterable<Object> {
     private final AvaticaStatement stmt;
     private final QueryState state;
@@ -850,7 +850,7 @@ public Iterator<Object> iterator() {
     }
   }
 
-  /** Iterator over rows coming from a sequence of {@link Frame}s. */
+  /** Iterator over rows coming from a sequence of {@link Meta.Frame}s. */
   private class FetchIterator implements Iterator<Object> {
     private final AvaticaStatement stmt;
     private final QueryState state;

File: avatica/src/main/java/org/apache/calcite/avatica/util/AbstractCursor.java
Patch:
@@ -270,7 +270,7 @@ static Timestamp longToTimestamp(long v, Calendar calendar) {
     return new Timestamp(v);
   }
 
-  /** Implementation of {@link Accessor}. */
+  /** Implementation of {@link Cursor.Accessor}. */
   static class AccessorImpl implements Accessor {
     protected final Getter getter;
 

File: avatica/src/main/java/org/apache/calcite/avatica/util/DateTimeUtils.java
Patch:
@@ -104,13 +104,12 @@ private DateTimeUtils() {}
    * less than 31, etc.
    *
    * @param s       string to be parsed
-   * @param pattern {@link SimpleDateFormat}  pattern
+   * @param pattern {@link SimpleDateFormat} pattern (not null)
    * @param tz      time zone in which to interpret string. Defaults to the Java
    *                default time zone
    * @param pp      position to start parsing from
    * @return a Calendar initialized with the parsed value, or null if parsing
    * failed. If returned, the Calendar is configured to the GMT time zone.
-   * @pre pattern != null
    */
   private static Calendar parseDateFormat(
       String s,

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -568,7 +568,7 @@ private List<List<Replacement>> go(MutableRel replacement) {
   }
 
   /**
-   * Represents a replacement action: before => after.
+   * Represents a replacement action: before &rarr; after.
    */
   private static class Replacement {
     final MutableRel before;

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -53,7 +53,7 @@
 import java.util.List;
 
 /**
- * Context for populating a {@link Materialization}.
+ * Context for populating a {@link Prepare.Materialization}.
  */
 class CalciteMaterializer extends CalcitePrepareImpl.CalcitePreparingStmt {
   public CalciteMaterializer(CalcitePrepareImpl prepare,

File: core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
Patch:
@@ -1231,7 +1231,7 @@ private LoptJoinTree addToTop(
    *
    * @param multiJoin join factors being optimized
    * @param leftTree left subtree of the join tree
-   * @param leftIdx if >=0, only consider filters that reference leftIdx in
+   * @param leftIdx if &ge; 0, only consider filters that reference leftIdx in
    * leftTree; otherwise, consider all filters that reference any factor in
    * leftTree
    * @param rightTree right subtree of the join tree
@@ -1577,7 +1577,7 @@ private LoptJoinTree createReplacementSemiJoin(
    * @param multiJoin join factors being optimized
    * @param semiJoinOpt optimal semijoins for each factor
    * @param currJoinTree current join tree being added to
-   * @param leftIdx if >=0, when creating the replacement join, only consider
+   * @param leftIdx if &ge; 0, when creating the replacement join, only consider
    * filters that reference leftIdx in currJoinTree; otherwise, consider all
    * filters that reference any factor in currJoinTree
    * @param factorToAdd new factor whose join can be removed

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
Patch:
@@ -580,8 +580,8 @@ private MakeCall(
      * @param operator Operator
      * @param order    Order
      * @pre order != null
-     * @pre order[i] < order.length
-     * @pre order.length > 0
+     * @pre order[i] &lt; order.length
+     * @pre order.length &gt; 0
      * @pre argCounts == order.length
      */
     MakeCall(SqlOperator operator, int argCount, int[] order) {

File: core/src/main/java/org/apache/calcite/util/BitSets.java
Patch:
@@ -313,7 +313,7 @@ public static void populate(BitSet bitSet, ImmutableIntList list) {
   }
 
   /**
-   * Setup equivalence Sets for each position. If i & j are equivalent then
+   * Setup equivalence Sets for each position. If i and j are equivalent then
    * they will have the same equivalence Set. The algorithm computes the
    * closure relation at each position for the position wrt to positions
    * greater than it. Once a closure is computed for a position, the closure

File: core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
Patch:
@@ -870,7 +870,7 @@ public ImmutableBitSet shift(int offset) {
   }
 
   /**
-   * Setup equivalence Sets for each position. If i & j are equivalent then
+   * Setup equivalence Sets for each position. If i and j are equivalent then
    * they will have the same equivalence Set. The algorithm computes the
    * closure relation at each position for the position wrt to positions
    * greater than it. Once a closure is computed for a position, the closure

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.calcite.plan.volcano.VolcanoPlannerTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTraitTest;
 import org.apache.calcite.rel.RelCollationTest;
+import org.apache.calcite.rel.rel2sql.RelToSqlConverterTest;
 import org.apache.calcite.rex.RexExecutorTest;
 import org.apache.calcite.runtime.BinarySearchTest;
 import org.apache.calcite.runtime.EnumerablesTest;
@@ -106,6 +107,7 @@
     JdbcFrontLinqBackTest.class,
     JdbcFrontJdbcBackTest.class,
     SqlToRelConverterTest.class,
+    RelToSqlConverterTest.class,
     SqlOperatorTest.class,
     ChunkListTest.class,
     FrameworksTest.class,

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -604,7 +604,7 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
   @BaseMessage("Table ''{0}'' not found")
   ExInst<CalciteException> tableNotFound(String tableName);
 
-  @BaseMessage("Cannot stream results of a query with no streaming inputs: ''{0}''. At least one input should be convertable to a stream.")
+  @BaseMessage("Cannot stream results of a query with no streaming inputs: ''{0}''. At least one input should be convertible to a stream")
   ExInst<SqlValidatorException> cannotStreamResultsForNonStreamingInputs(String inputs);
 }
 

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
Patch:
@@ -3032,14 +3032,14 @@ public boolean validateModality(SqlSelect select, SqlModality modality,
           }
         }
       } else {
-        boolean atLeastOneSupportsModality = false;
+        int supportsModalityCount = 0;
         for (Pair<String, SqlValidatorNamespace> namespace : scope.children) {
           if (namespace.right.supportsModality(modality)) {
-            atLeastOneSupportsModality = true;
+            ++supportsModalityCount;
           }
         }
 
-        if (!atLeastOneSupportsModality) {
+        if (supportsModalityCount == 0) {
           if (fail) {
             List<String> inputList = new ArrayList<String>();
             for (Pair<String, SqlValidatorNamespace> namespace : scope.children) {

File: core/src/test/java/org/apache/calcite/test/MockCatalogReader.java
Patch:
@@ -252,15 +252,15 @@ public MockCatalogReader init() {
 
     // Register "PRODUCTS" table.
     MockTable productsTable = MockTable.create(this, salesSchema, "PRODUCTS",
-        false);
+        false, 200D);
     productsTable.addColumn("PRODUCTID", intType);
     productsTable.addColumn("NAME", varchar20Type);
     productsTable.addColumn("SUPPLIERID", intType);
     registerTable(productsTable);
 
     // Register "SUPPLIERS" table.
     MockTable suppliersTable = MockTable.create(this, salesSchema, "SUPPLIERS",
-        false);
+        false, 10D);
     suppliersTable.addColumn("SUPPLIERID", intType);
     suppliersTable.addColumn("NAME", varchar20Type);
     suppliersTable.addColumn("CITY", intType);

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -135,7 +135,7 @@ private static String cannotConvertToRelation(String table) {
   private static String cannotStreamResultsForNonStreamingInputs(String inputs) {
     return "Cannot stream results of a query with no streaming inputs: '"
         + inputs
-        + "'. At least one input should be convertable to a stream.";
+        + "'. At least one input should be convertible to a stream";
   }
 
   @Test public void testMultipleSameAsPass() {

File: core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
Patch:
@@ -72,7 +72,8 @@ public abstract class PruneEmptyRules {
         public void onMatch(RelOptRuleCall call) {
           LogicalUnion union = call.rel(0);
           final List<RelNode> childRels = call.getChildRels(union);
-          final List<RelNode> newChildRels = new ArrayList<RelNode>();
+          assert childRels != null;
+          final List<RelNode> newChildRels = new ArrayList<>();
           for (RelNode childRel : childRels) {
             if (!isEmpty(childRel)) {
               newChildRels.add(childRel);

File: core/src/main/java/org/apache/calcite/runtime/CalciteResource.java
Patch:
@@ -603,6 +603,9 @@ ExInst<CalciteException> illegalArgumentForTableFunctionCall(String a0,
 
   @BaseMessage("Table ''{0}'' not found")
   ExInst<CalciteException> tableNotFound(String tableName);
+
+  @BaseMessage("Cannot stream results of a query with no streaming inputs: ''{0}''. At least one input should be convertable to a stream.")
+  ExInst<SqlValidatorException> cannotStreamResultsForNonStreamingInputs(String inputs);
 }
 
 // End CalciteResource.java

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -72,7 +72,9 @@ public class SqlAdvisorTest extends SqlValidatorTestCase {
           "TABLE(CATALOG.SALES.BONUS)",
           "TABLE(CATALOG.SALES.ORDERS)",
           "TABLE(CATALOG.SALES.SALGRADE)",
-          "TABLE(CATALOG.SALES.SHIPMENTS)");
+          "TABLE(CATALOG.SALES.SHIPMENTS)",
+          "TABLE(CATALOG.SALES.PRODUCTS)",
+          "TABLE(CATALOG.SALES.SUPPLIERS)");
 
   private static final List<String> SCHEMAS =
       Arrays.asList(

File: avatica-server/src/main/java/org/apache/calcite/avatica/server/HandlerFactory.java
Patch:
@@ -35,7 +35,7 @@ public class HandlerFactory {
   public Handler getHandler(Service service, Driver.Serialization serialization) {
     switch (serialization) {
     case JSON:
-      return new AvaticaHandler(service);
+      return new AvaticaJsonHandler(service);
     case PROTOBUF:
       return new AvaticaProtobufHandler(service);
     default:

File: avatica-server/src/main/java/org/apache/calcite/avatica/server/Main.java
Patch:
@@ -46,7 +46,7 @@ public interface HandlerFactory {
 
   private static final HandlerFactory JSON_HANDLER_FACTORY = new HandlerFactory() {
     public AbstractHandler createHandler(Service service) {
-      return new AvaticaHandler(service);
+      return new AvaticaJsonHandler(service);
     }
   };
 

File: avatica-server/src/test/java/org/apache/calcite/avatica/remote/AlternatingRemoteMetaTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.calcite.avatica.ConnectionSpec;
 import org.apache.calcite.avatica.Meta;
 import org.apache.calcite.avatica.jdbc.JdbcMeta;
-import org.apache.calcite.avatica.server.AvaticaHandler;
+import org.apache.calcite.avatica.server.AvaticaJsonHandler;
 import org.apache.calcite.avatica.server.HttpServer;
 import org.apache.calcite.avatica.server.Main;
 import org.apache.calcite.avatica.server.Main.HandlerFactory;
@@ -193,7 +193,7 @@ public static void beforeClass() throws Exception {
       }
       HttpServer jsonServer = Main.start(mainArgs, 0, new HandlerFactory() {
         @Override public AbstractHandler createHandler(Service service) {
-          return new AvaticaHandler(service);
+          return new AvaticaJsonHandler(service);
         }
       });
       ACTIVE_SERVERS.add(jsonServer);

File: avatica-server/src/test/java/org/apache/calcite/avatica/server/HandlerFactoryTest.java
Patch:
@@ -44,7 +44,7 @@ public void setup() {
   public void testJson() {
     Handler handler = factory.getHandler(service, Serialization.JSON);
     assertTrue("Expected an implementation of the AvaticaHandler, "
-        + "but got " + handler.getClass(), handler instanceof AvaticaHandler);
+        + "but got " + handler.getClass(), handler instanceof AvaticaJsonHandler);
   }
 
   @Test

File: avatica/src/test/java/org/apache/calcite/avatica/remote/ProtobufHandlerTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.calcite.avatica.remote.Handler.HandlerResponse;
 import org.apache.calcite.avatica.remote.Service.FetchRequest;
 import org.apache.calcite.avatica.remote.Service.FetchResponse;
+import org.apache.calcite.avatica.remote.Service.RpcMetadataResponse;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -84,7 +85,8 @@ public void testFetch() throws Exception {
     frameRows.add(new Object[] {true, "my_string"});
 
     Meta.Frame frame = Frame.create(0, true, frameRows);
-    FetchResponse response = new FetchResponse(frame, false, false);
+    RpcMetadataResponse metadata = new RpcMetadataResponse("localhost:8765");
+    FetchResponse response = new FetchResponse(frame, false, false, metadata);
 
     when(translation.parseRequest(serializedRequest)).thenReturn(request);
     when(service.apply(request)).thenReturn(response);

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -1983,7 +1983,8 @@ protected void onMatch() {
           new VolcanoRuleMatch(
               volcanoPlanner,
               getOperand0(),
-              rels);
+              rels,
+              nodeInputs);
       volcanoPlanner.ruleQueue.addMatch(match);
     }
   }

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -598,6 +598,7 @@ public RelSet getSet(RelNode rel) {
     this.mapRel2Subset.clear();
     this.relImportances.clear();
     this.ruleQueue.clear();
+    this.ruleNames.clear();
   }
 
   public boolean addRule(RelOptRule rule) {

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -1150,9 +1150,9 @@ protected MutableRel invert(MutableRel model, MutableRel input,
       for (Ord<RexNode> expr : Ord.zip(project.getProjects())) {
         if (expr.e instanceof RexInputRef) {
           final int target = ((RexInputRef) expr.e).getIndex();
-          exprList.set(expr.i,
+          exprList.set(target,
               rexBuilder.ensureType(expr.e.getType(),
-                  RexInputRef.of(target, input.rowType),
+                  RexInputRef.of(expr.i, input.rowType),
                   false));
         } else {
           throw MatchFailed.INSTANCE;

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfig.java
Patch:
@@ -30,6 +30,8 @@ public interface CalciteConnectionConfig extends ConnectionConfig {
   boolean materializationsEnabled();
   /** @see CalciteConnectionProperty#CREATE_MATERIALIZATIONS */
   boolean createMaterializations();
+  /** @see CalciteConnectionProperty#DEFAULT_NULL_COLLATION */
+  NullCollation defaultNullCollation();
   /** @see CalciteConnectionProperty#MODEL */
   String model();
   /** @see CalciteConnectionProperty#LEX */

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -714,6 +714,7 @@ public Enumerable<T> bind(DataContext dataContext) {
       final SqlValidator validator =
           createSqlValidator(catalogReader, typeFactory);
       validator.setIdentifierExpansion(true);
+      validator.setDefaultNullCollation(config.defaultNullCollation());
 
       final List<Prepare.Materialization> materializations =
           config.materializationsEnabled()

File: core/src/main/java/org/apache/calcite/rel/RelCollationImpl.java
Patch:
@@ -132,7 +132,7 @@ public String toString() {
       RelFieldCollation e = it.next();
       sb.append(e.getFieldIndex());
       if (e.direction != RelFieldCollation.Direction.ASCENDING
-          || e.nullDirection != RelFieldCollation.NullDirection.UNSPECIFIED) {
+          || e.nullDirection != e.direction.defaultNullDirection()) {
         sb.append(' ').append(e.shortString());
       }
       if (!it.hasNext()) {

File: core/src/main/java/org/apache/calcite/rex/RexFieldCollation.java
Patch:
@@ -63,7 +63,7 @@ public RelFieldCollation.NullDirection getNullDirection() {
         ? RelFieldCollation.NullDirection.LAST
         : right.contains(SqlKind.NULLS_FIRST)
             ? RelFieldCollation.NullDirection.FIRST
-            : RelFieldCollation.NullDirection.UNSPECIFIED;
+            : getDirection().defaultNullDirection();
   }
 }
 

File: core/src/test/java/org/apache/calcite/test/MockCatalogReader.java
Patch:
@@ -519,8 +519,7 @@ private static List<RelCollation> deduceMonotonicity(
                 : RelFieldCollation.Direction.ASCENDING;
         collationList.add(
             RelCollations.of(
-                new RelFieldCollation(i, direction,
-                    RelFieldCollation.NullDirection.UNSPECIFIED)));
+                new RelFieldCollation(i, direction)));
       }
     }
     return collationList;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSumAggFunction.java
Patch:
@@ -48,7 +48,7 @@ public SqlSumAggFunction(RelDataType type) {
         "SUM",
         null,
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.ARG0_NULLABLE_IF_EMPTY,
+        ReturnTypes.AGG_SUM,
         null,
         OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC,

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java
Patch:
@@ -43,7 +43,7 @@ public class SqlSumEmptyIsZeroAggFunction extends SqlAggFunction {
     super("$SUM0",
         null,
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.ARG0,
+        ReturnTypes.AGG_SUM_EMPTY_IS_ZERO,
         null,
         OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC,

File: core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
Patch:
@@ -113,7 +113,7 @@ public CallImplementor getImplementor() {
 
   private static CallImplementor createImplementor(final Method method) {
     return RexImpTable.createImplementor(
-        new ReflectiveCallNotNullImplementor(method), NullPolicy.ANY, false);
+        new ReflectiveCallNotNullImplementor(method), NullPolicy.NONE, false);
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCastFunction.java
Patch:
@@ -113,7 +113,7 @@ public RelDataType inferReturnType(
             firstType.isNullable());
     if (opBinding instanceof SqlCallBinding) {
       SqlCallBinding callBinding = (SqlCallBinding) opBinding;
-      SqlNode operand0 = callBinding.getCall().operand(0);
+      SqlNode operand0 = callBinding.operand(0);
 
       // dynamic parameters and null constants need their types assigned
       // to them using the type they are casted to.
@@ -145,8 +145,8 @@ public SqlOperandCountRange getOperandCountRange() {
   public boolean checkOperandTypes(
       SqlCallBinding callBinding,
       boolean throwOnFailure) {
-    final SqlNode left = callBinding.getCall().operand(0);
-    final SqlNode right = callBinding.getCall().operand(1);
+    final SqlNode left = callBinding.operand(0);
+    final SqlNode right = callBinding.operand(1);
     if (SqlUtil.isNullLiteral(left, false)
         || left instanceof SqlDynamicParam) {
       return true;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlItemOperator.java
Patch:
@@ -84,8 +84,8 @@ public SqlItemOperator() {
   @Override public boolean checkOperandTypes(
       SqlCallBinding callBinding,
       boolean throwOnFailure) {
-    final SqlNode left = callBinding.getCall().operand(0);
-    final SqlNode right = callBinding.getCall().operand(1);
+    final SqlNode left = callBinding.operand(0);
+    final SqlNode right = callBinding.operand(1);
     if (!ARRAY_OR_MAP.checkSingleOperandType(callBinding, left, 0,
         throwOnFailure)) {
       return false;

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
Patch:
@@ -127,7 +127,7 @@ public boolean checkOperandTypes(
 
     return SqlTypeUtil.isCharTypeComparable(
         callBinding,
-        callBinding.getCall().getOperandList(),
+        callBinding.operands(),
         throwOnFailure);
   }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -79,9 +79,8 @@ private boolean argTypesValid(SqlCallBinding callBinding) {
     if (callBinding.getOperandCount() < 2) {
       return true; // nothing to compare
     }
-    final List<SqlNode> operandList = callBinding.getCall().getOperandList();
     RelDataType firstType = null;
-    for (Ord<SqlNode> operand : Ord.zip(operandList)) {
+    for (Ord<SqlNode> operand : Ord.zip(callBinding.operands())) {
       RelDataType type =
           callBinding.getValidator().deriveType(
               callBinding.getScope(),

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
Patch:
@@ -61,7 +61,7 @@ public boolean checkOperandTypes(
         SqlTypeUtil.deriveAndCollectTypes(
             callBinding.getValidator(),
             callBinding.getScope(),
-            callBinding.getCall().getOperandList());
+            callBinding.operands());
     if (argTypes.size() == 0) {
       throw callBinding.newValidationError(RESOURCE.mapRequiresTwoOrMoreArgs());
     }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetMemberOfOperator.java
Patch:
@@ -56,7 +56,7 @@ public boolean checkOperandTypes(
       boolean throwOnFailure) {
     if (!OperandTypes.MULTISET.checkSingleOperandType(
         callBinding,
-        callBinding.getCall().operand(1),
+        callBinding.operand(1),
         0,
         throwOnFailure)) {
       return false;
@@ -65,12 +65,12 @@ public boolean checkOperandTypes(
     MultisetSqlType mt =
         (MultisetSqlType) callBinding.getValidator().deriveType(
             callBinding.getScope(),
-            callBinding.getCall().operand(1));
+            callBinding.operand(1));
 
     RelDataType t0 =
         callBinding.getValidator().deriveType(
             callBinding.getScope(),
-            callBinding.getCall().operand(0));
+            callBinding.operand(0));
     RelDataType t1 = mt.getComponentType();
 
     if (t0.getFamily() != t1.getFamily()) {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
Patch:
@@ -89,7 +89,7 @@ public boolean checkOperandTypes(
         SqlTypeUtil.deriveAndCollectTypes(
             callBinding.getValidator(),
             callBinding.getScope(),
-            callBinding.getCall().getOperandList());
+            callBinding.operands());
     final RelDataType componentType =
         getComponentType(
             callBinding.getTypeFactory(),

File: core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
Patch:
@@ -88,7 +88,7 @@ public boolean checkOperandTypes(
         SqlTypeUtil.deriveAndCollectTypes(
             callBinding.getValidator(),
             callBinding.getScope(),
-            callBinding.getCall().getOperandList());
+            callBinding.operands());
     if (argTypes.size() == 0) {
       throw callBinding.newValidationError(RESOURCE.requireAtLeastOneArg());
     }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlQuarterFunction.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.sql.fun;
 
-import org.apache.calcite.sql.SqlCall;
 import org.apache.calcite.sql.SqlCallBinding;
 import org.apache.calcite.sql.SqlFunction;
 import org.apache.calcite.sql.SqlFunctionCategory;
@@ -56,9 +55,8 @@ public String getSignatureTemplate(int operandsCount) {
 
   public boolean checkOperandTypes(SqlCallBinding callBinding,
       boolean throwOnFailure) {
-    SqlCall call = callBinding.getCall();
     return OperandTypes.DATETIME.checkSingleOperandType(callBinding,
-        call.operand(0), 0, throwOnFailure);
+        callBinding.operand(0), 0, throwOnFailure);
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlSubstringFunction.java
Patch:
@@ -95,11 +95,10 @@ public String getAllowedSignatures(String opName) {
   public boolean checkOperandTypes(
       SqlCallBinding callBinding,
       boolean throwOnFailure) {
-    SqlCall call = callBinding.getCall();
     SqlValidator validator = callBinding.getValidator();
     SqlValidatorScope scope = callBinding.getScope();
 
-    final List<SqlNode> operands = call.getOperandList();
+    final List<SqlNode> operands = callBinding.operands();
     int n = operands.size();
     assert (3 == n) || (2 == n);
     if (!OperandTypes.STRING.checkSingleOperandType(

File: core/src/main/java/org/apache/calcite/sql/type/InferTypes.java
Patch:
@@ -47,7 +47,7 @@ public void inferOperandTypes(
           final RelDataType unknownType =
               callBinding.getValidator().getUnknownType();
           RelDataType knownType = unknownType;
-          for (SqlNode operand : callBinding.getCall().getOperandList()) {
+          for (SqlNode operand : callBinding.operands()) {
             knownType = callBinding.getValidator().deriveType(
                 callBinding.getScope(), operand);
             if (!knownType.equals(unknownType)) {

File: core/src/main/java/org/apache/calcite/sql/type/SqlOperandTypeChecker.java
Patch:
@@ -59,6 +59,9 @@ boolean checkOperandTypes(
   /** Returns the strategy for making the arguments have consistency types. */
   Consistency getConsistency();
 
+  /** Returns whether the {@code i}th operand is optional. */
+  boolean isOptional(int i);
+
   /** Strategy used to make arguments consistent. */
   enum Consistency {
     /** Do not try to make arguments consistent. */

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -88,6 +88,7 @@
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.SqlBasicCall;
 import org.apache.calcite.sql.SqlCall;
+import org.apache.calcite.sql.SqlCallBinding;
 import org.apache.calcite.sql.SqlDataTypeSpec;
 import org.apache.calcite.sql.SqlDelete;
 import org.apache.calcite.sql.SqlDynamicParam;
@@ -4173,7 +4174,8 @@ public RexNode visit(SqlCall call) {
           return agg.lookupAggregates(call);
         }
       }
-      return exprConverter.convertCall(this, call);
+      return exprConverter.convertCall(this,
+          new SqlCallBinding(validator, scope, call).permutedCall());
     }
 
     // implement SqlVisitor

File: avatica-server/src/main/java/org/apache/calcite/avatica/jdbc/JdbcMeta.java
Patch:
@@ -533,8 +533,8 @@ public StatementHandle createStatement(ConnectionHandle ch) {
     }
   }
 
-  @Override
-  public void openConnection(ConnectionHandle ch, Map<String, String> info) {
+  @Override public void openConnection(ConnectionHandle ch,
+      Map<String, String> info) {
     Properties fullInfo = new Properties();
     fullInfo.putAll(this.info);
     if (info != null) {

File: avatica/src/main/java/org/apache/calcite/avatica/Meta.java
Patch:
@@ -42,6 +42,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Properties;
 
 /**
  * Command handler for getting various metadata. Should be implemented by each

File: avatica/src/main/java/org/apache/calcite/avatica/remote/ProtobufService.java
Patch:
@@ -74,8 +74,7 @@ public abstract class ProtobufService extends AbstractService {
     return (CloseStatementResponse) _apply(request);
   }
 
-  @Override
-  public OpenConnectionResponse apply(OpenConnectionRequest request) {
+  @Override public OpenConnectionResponse apply(OpenConnectionRequest request) {
     return (OpenConnectionResponse) _apply(request);
   }
 

File: core/src/test/java/org/apache/calcite/test/ExceptionMessageTest.java
Patch:
@@ -109,7 +109,7 @@ private void runQuery(String sql) throws SQLException {
       fail("Query badEntries should result in an exception");
     } catch (SQLException e) {
       assertThat(e.getMessage(),
-          equalTo("error while executing SQL \"select * from \"badEntries\"\": "
+          equalTo("Error while executing SQL \"select * from \"badEntries\"\": "
               + "Can't iterate over badEntries"));
     }
   }
@@ -120,7 +120,7 @@ private void runQuery(String sql) throws SQLException {
       fail("Query should fail");
     } catch (SQLException e) {
       assertThat(e.getMessage(),
-          equalTo("error while executing SQL \"invalid sql\": parse failed: "
+          equalTo("Error while executing SQL \"invalid sql\": parse failed: "
               + "Non-query expression encountered in illegal context"));
     }
   }

File: avatica-server/src/test/java/org/apache/calcite/avatica/RemoteDriverMockTest.java
Patch:
@@ -94,8 +94,7 @@ private Connection getMockConnection() {
   }
 
   @Test public void testRegister() throws Exception {
-    final Connection connection =
-        DriverManager.getConnection("jdbc:avatica:remote:");
+    final Connection connection = getMockConnection();
     assertThat(connection.isClosed(), is(false));
     connection.close();
     assertThat(connection.isClosed(), is(true));

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaConnection.java
Patch:
@@ -284,8 +284,7 @@ public PreparedStatement prepareStatement(
       int resultSetConcurrency,
       int resultSetHoldability) throws SQLException {
     try {
-      final Meta.ConnectionHandle ch = new Meta.ConnectionHandle(id);
-      final Meta.StatementHandle h = meta.prepare(ch, sql, -1);
+      final Meta.StatementHandle h = meta.prepare(handle, sql, -1);
       return factory.newPreparedStatement(this, h, h.signature, resultSetType,
           resultSetConcurrency, resultSetHoldability);
     } catch (RuntimeException e) {

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -824,7 +824,7 @@ public ImmutableBitSet apply(ImmutableBitSet input) {
         RelBuilder.AggCall newAggCall =
             relBuilder.aggregateCall(aggCall.getAggregation(),
                 aggCall.isDistinct(), filterArg, aggCall.name, args);
-        mapping.set(groupCount + indicatorCount + newAggCallList.size(), j);
+        mapping.set(j, groupCount + indicatorCount + newAggCallList.size());
         newAggCallList.add(newAggCall);
       }
       ++j;

File: core/src/main/java/org/apache/calcite/model/JsonRoot.java
Patch:
@@ -44,7 +44,7 @@
  * </pre>
  * <!-- CHECKSTYLE: ON -->
  *
- * <p>See the <a href="http://calcite.incubator.apache.org/docs/model.html">JSON
+ * <p>See the <a href="http://calcite.apache.org/docs/model.html">JSON
  * model reference</a>.
  */
 public class JsonRoot {

File: core/src/main/java/org/apache/calcite/model/package-info.java
Patch:
@@ -31,7 +31,7 @@
  * interfaces and including a custom schema in the model.</p>
  *
  * <p>There are several examples of schemas in the
- * <a href="https://github.com/apache/incubator-calcite/blob/master/doc/tutorial.md">tutorial</a>.
+ * <a href="https://github.com/apache/calcite/blob/master/doc/tutorial.md">tutorial</a>.
  */
 @PackageMarker
 package org.apache.calcite.model;

File: avatica/src/main/java/org/apache/calcite/avatica/remote/AbstractService.java
Patch:
@@ -98,6 +98,9 @@ ResultSetResponse finagle(ResultSetResponse r) {
       assert r.signature == null;
       return r;
     }
+    if (r.signature == null) {
+      return r;
+    }
     final Meta.Signature signature = finagle(r.signature);
     if (signature == r.signature) {
       return r;

File: avatica/src/main/java/org/apache/calcite/avatica/remote/AbstractService.java
Patch:
@@ -43,7 +43,7 @@ Meta.Signature finagle(Meta.Signature signature) {
     }
     return new Meta.Signature(columns, signature.sql,
         signature.parameters, signature.internalParameters,
-        signature.cursorFactory);
+        signature.cursorFactory, signature.statementType);
   }
 
   ColumnMetaData finagle(ColumnMetaData column) {

File: avatica/src/main/java/org/apache/calcite/avatica/remote/MockProtobufService.java
Patch:
@@ -61,7 +61,7 @@ public class MockProtobufService extends ProtobufService {
                 Arrays.<ColumnMetaData>asList(
                     MetaImpl.columnMetaData("C1", 0, Integer.class),
                     MetaImpl.columnMetaData("C2", 1, String.class)),
-                null, null, Meta.CursorFactory.ARRAY),
+                null, null, Meta.CursorFactory.ARRAY, Meta.StatementType.SELECT),
             Meta.Frame.create(0, true,
                 Arrays.<Object>asList(new Object[] {1, "a"},
                     new Object[] {null, "b"}, new Object[] {3, "c"})), -1));
@@ -76,7 +76,7 @@ public class MockProtobufService extends ProtobufService {
                     MetaImpl.columnMetaData("C1", 0, Integer.class),
                     MetaImpl.columnMetaData("C2", 1, String.class)),
                 null, Collections.<AvaticaParameter>emptyList(),
-                Meta.CursorFactory.ARRAY),
+                Meta.CursorFactory.ARRAY, Meta.StatementType.SELECT),
             null, -1));
 
     MAPPING = Collections.unmodifiableMap(mappings);

File: avatica/src/main/java/org/apache/calcite/avatica/remote/ProtobufTranslationImpl.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.calcite.avatica.proto.Requests.ConnectionSyncRequest;
 import org.apache.calcite.avatica.proto.Requests.CreateStatementRequest;
 import org.apache.calcite.avatica.proto.Requests.DatabasePropertyRequest;
+import org.apache.calcite.avatica.proto.Requests.ExecuteRequest;
 import org.apache.calcite.avatica.proto.Requests.FetchRequest;
 import org.apache.calcite.avatica.proto.Requests.PrepareAndExecuteRequest;
 import org.apache.calcite.avatica.proto.Requests.PrepareRequest;
@@ -96,6 +97,8 @@ public class ProtobufTranslationImpl implements ProtobufTranslation {
         new RequestTranslator(TableTypesRequest.PARSER, new Service.TableTypesRequest()));
     reqParsers.put(TypeInfoRequest.class.getName(),
         new RequestTranslator(TypeInfoRequest.PARSER, new Service.TypeInfoRequest()));
+    reqParsers.put(ExecuteRequest.class.getName(),
+        new RequestTranslator(ExecuteRequest.PARSER, new Service.ExecuteRequest()));
 
     REQUEST_PARSERS = Collections.unmodifiableMap(reqParsers);
 

File: avatica/src/test/java/org/apache/calcite/avatica/remote/ProtobufHandlerTest.java
Patch:
@@ -74,7 +74,7 @@ public void testFetch() throws Exception {
     Requests.FetchRequest protoRequest = Requests.FetchRequest.newBuilder()
         .setConnectionId(connectionId).setStatementId(statementId)
         .setOffset(offset).setFetchMaxRowCount(fetchMaxRowCount)
-        .addAllParameterValues(values).build();
+        .build();
     byte[] serializedRequest = protoRequest.toByteArray();
 
     FetchRequest request = new FetchRequest().deserialize(protoRequest);

File: avatica/src/test/java/org/apache/calcite/avatica/remote/ProtobufTranslationImplTest.java
Patch:
@@ -175,7 +175,7 @@ private static List<Request> getRequests() {
     List<TypedValue> paramValues =
         Arrays.asList(TypedValue.create(Rep.BOOLEAN.name(), Boolean.TRUE),
             TypedValue.create(Rep.STRING.name(), "string"));
-    FetchRequest fetchRequest = new FetchRequest("connectionId", Integer.MAX_VALUE, paramValues,
+    FetchRequest fetchRequest = new FetchRequest("connectionId", Integer.MAX_VALUE,
         Long.MAX_VALUE, Integer.MAX_VALUE);
     requests.add(fetchRequest);
 
@@ -231,7 +231,8 @@ private static List<Response> getResponses() {
     rows.add(new Object[] {"str_value", 50});
 
     // Create the signature and frame using the metadata and values
-    Signature signature = Signature.create(columns, "sql", params, cursorFactory);
+    Signature signature = Signature.create(columns, "sql", params, cursorFactory,
+        Meta.StatementType.SELECT);
     Frame frame = Frame.create(Integer.MAX_VALUE, true, rows);
 
     // And then create a ResultSetResponse

File: avatica/src/main/java/org/apache/calcite/avatica/remote/Service.java
Patch:
@@ -106,7 +106,8 @@ abstract class Request {
       @JsonSubTypes.Type(value = CloseConnectionResponse.class,
           name = "closeConnection"),
       @JsonSubTypes.Type(value = ConnectionSyncResponse.class, name = "connectionSync"),
-      @JsonSubTypes.Type(value = DatabasePropertyResponse.class, name = "databaseProperties") })
+      @JsonSubTypes.Type(value = DatabasePropertyResponse.class, name = "databaseProperties"),
+      @JsonSubTypes.Type(value = ExecuteResponse.class, name = "executeResults") })
   abstract class Response {
     abstract Response deserialize(Message genericMsg);
     abstract Message serialize();

File: avatica-server/src/main/java/org/apache/calcite/avatica/jdbc/JdbcMeta.java
Patch:
@@ -805,7 +805,7 @@ public Frame fetch(StatementHandle h, List<TypedValue> parameterValues,
 
   private static String[] toArray(List<String> typeList) {
     if (typeList == null) {
-      return new String[0];
+      return null;
     }
     return typeList.toArray(new String[typeList.size()]);
   }

File: avatica/src/main/java/org/apache/calcite/avatica/proto/Common.java
Patch:
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 // Generated by the protocol buffer compiler.  DO NOT EDIT!
 // source: common.proto
 

File: avatica/src/main/java/org/apache/calcite/avatica/proto/Responses.java
Patch:
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 // Generated by the protocol buffer compiler.  DO NOT EDIT!
 // source: responses.proto
 

File: piglet/src/test/java/org/apache/calcite/test/PigletTest.java
Patch:
@@ -135,12 +135,12 @@ private static Fluent pig(String pig) {
     final String s = "A = LOAD 'EMP';\n"
         + "B = GROUP A BY DEPTNO;";
     final String expected = ""
-        + "LogicalAggregate(group=[{7}], A=[COLLECT($0, $1, $2, $3, $4, $5, $6, $7)])\n"
-        + "  LogicalTableScan(table=[[scott, EMP]])\n";
+        + "LogicalAggregate(group=[{7}], A=[COLLECT($8)])\n"
+        + "  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], $f8=[ROW($0, $1, $2, $3, $4, $5, $6, $7)])\n"
+        + "    LogicalTableScan(table=[[scott, EMP]])\n";
     pig(s).explainContains(expected);
   }
 
-  @Ignore("only collect first column, should collect a struct")
   @Test public void testGroupExample() throws ParseException {
     final String pre = "A = VALUES ('John',18,4.0F),\n"
         + "('Mary',19,3.8F),\n"

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableCollect.java
Patch:
@@ -43,12 +43,12 @@ public EnumerableCollect(RelOptCluster cluster, RelTraitSet traitSet,
   public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
     final BlockBuilder builder = new BlockBuilder();
     final EnumerableRel child = (EnumerableRel) getInput();
-    final Result result = implementor.visitChild(this, 0, child, pref);
+    final Result result = implementor.visitChild(this, 0, child, Prefer.ARRAY);
     final PhysType physType =
         PhysTypeImpl.of(
             implementor.getTypeFactory(),
             getRowType(),
-            result.format);
+            JavaRowFormat.LIST);
 
     // final Enumerable<Employee> child = <<child adapter>>;
     // final List<Employee> list = child.toList();

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
Patch:
@@ -50,7 +50,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
         PhysTypeImpl.of(
             implementor.getTypeFactory(),
             getRowType(),
-            result.format);
+            JavaRowFormat.LIST);
 
     final JavaTypeFactory typeFactory = implementor.getTypeFactory();
     RelDataType inputRowType = child.getRowType();

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -156,6 +156,7 @@
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.POWER;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.RANK;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.REINTERPRET;
+import static org.apache.calcite.sql.fun.SqlStdOperatorTable.ROW;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.ROW_NUMBER;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SESSION_USER;
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.SIMILAR_TO;
@@ -194,6 +195,7 @@ public class RexImpTable {
   winAggMap = Maps.newHashMap();
 
   RexImpTable() {
+    defineMethod(ROW, BuiltInMethod.ARRAY.method, NullPolicy.ANY);
     defineMethod(UPPER, BuiltInMethod.UPPER.method, NullPolicy.STRICT);
     defineMethod(LOWER, BuiltInMethod.LOWER.method, NullPolicy.STRICT);
     defineMethod(INITCAP,  BuiltInMethod.INITCAP.method, NullPolicy.STRICT);

File: core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
Patch:
@@ -19,6 +19,8 @@
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rel.type.RelRecordType;
 
+import com.google.common.base.Preconditions;
+
 import java.util.List;
 
 /**
@@ -33,8 +35,7 @@ public class JavaRecordType extends RelRecordType {
 
   public JavaRecordType(List<RelDataTypeField> fields, Class clazz) {
     super(fields);
-    this.clazz = clazz;
-    assert clazz != null;
+    this.clazz = Preconditions.checkNotNull(clazz);
   }
 
   @Override public boolean equals(Object obj) {

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
Patch:
@@ -307,7 +307,9 @@ public RelDataType createTypeWithNullability(
       final boolean nullable) {
     Preconditions.checkNotNull(type);
     RelDataType newType;
-    if (type instanceof RelRecordType) {
+    if (type.isNullable() == nullable) {
+      newType = type;
+    } else if (type instanceof RelRecordType) {
       // REVIEW: angel 18-Aug-2005 dtbug 336 workaround
       // Changed to ignore nullable parameter if nullable is false since
       // copyRecordType implementation is doubtful

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -1370,6 +1370,9 @@ public static <E> Function1<List<E>, Enumerable<E>> listToEnumerable() {
     return (Function1<List<E>, Enumerable<E>>) (Function1) LIST_AS_ENUMERABLE;
   }
 
+  public static Object[] array(Object... args) {
+    return args;
+  }
 }
 
 // End SqlFunctions.java

File: core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
Patch:
@@ -19,6 +19,8 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFamily;
 
+import com.google.common.base.Preconditions;
+
 /**
  * SQL array type.
  */
@@ -35,8 +37,7 @@ public class ArraySqlType extends AbstractSqlType {
    */
   public ArraySqlType(RelDataType elementType, boolean isNullable) {
     super(SqlTypeName.ARRAY, isNullable, null);
-    assert elementType != null;
-    this.elementType = elementType;
+    this.elementType = Preconditions.checkNotNull(elementType);
     computeDigest();
   }
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -172,6 +172,7 @@ public enum BuiltInMethod {
   FUNCTION0_APPLY(Function0.class, "apply"),
   FUNCTION1_APPLY(Function1.class, "apply", Object.class),
   ARRAYS_AS_LIST(Arrays.class, "asList", Object[].class),
+  ARRAY(SqlFunctions.class, "array", Object[].class),
   LIST_N(FlatLists.class, "of", Object[].class),
   LIST2(FlatLists.class, "of", Object.class, Object.class),
   LIST3(FlatLists.class, "of", Object.class, Object.class, Object.class),

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleCall.java
Patch:
@@ -214,10 +214,10 @@ public final void transformTo(RelNode rel) {
   }
 
   /** Creates a {@link org.apache.calcite.tools.RelBuilder} to be used by
-   * code within the call. The {@code protoBuilder} argument contains policies
+   * code within the call. The {@link RelOptRule#relBuilderFactory} argument contains policies
    * such as what implementation of {@link Filter} to create. */
-  public RelBuilder builder(RelBuilder.ProtoRelBuilder protoBuilder) {
-    return protoBuilder.create(rel(0).getCluster(), null);
+  public RelBuilder builder() {
+    return rule.relBuilderFactory.create(rel(0).getCluster(), null);
   }
 }
 

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -206,7 +206,7 @@ public class JdbcAdapterTest {
             + "FROM \"SCOTT\".\"EMP\") AS \"t0\" ON \"t\".\"MGR\" = \"t0\".\"EMPNO\" AND (\"t\".\"SAL\" > \"t0\".\"SAL\" OR \"t\".\"HIREDATE\" < \"t0\".\"HIREDATE\")");
   }
 
-  @Test public void tesJoin3TablesPlan() {
+  @Test public void testJoin3TablesPlan() {
     CalciteAssert.model(JdbcTest.SCOTT_MODEL)
         .query("select  empno, ename, dname, grade \n"
             + "from scott.emp e inner join scott.dept d \n"

File: mongodb/src/test/java/org/apache/calcite/test/MongoAdapterIT.java
Patch:
@@ -658,9 +658,9 @@ public Void apply(ResultSet resultSet) {
             + "STATE=CA; CDC=1072\n")
         .queryContains(
             mongoChecker(
-                "{$project: {STATE: '$state', CITY: '$city'}}",
-                "{$group: {_id: {STATE: '$STATE', CITY: '$CITY'}}}",
-                "{$project: {_id: 0, STATE: '$_id.STATE', CITY: '$_id.CITY'}}",
+                "{$project: {CITY: '$city', STATE: '$state'}}",
+                "{$group: {_id: {CITY: '$CITY', STATE: '$STATE'}}}",
+                "{$project: {_id: 0, CITY: '$_id.CITY', STATE: '$_id.STATE'}}",
                 "{$group: {_id: '$STATE', CDC: {$sum: {$cond: [ {$eq: ['CITY', null]}, 0, 1]}}}}",
                 "{$project: {STATE: '$_id', CDC: '$CDC'}}",
                 "{$sort: {CDC: -1}}",

File: core/src/main/java/org/apache/calcite/prepare/QueryableRelBuilder.java
Patch:
@@ -315,11 +315,11 @@ public <TKey, TElement> Queryable<Grouping<TKey, TElement>> groupBy(
     throw new UnsupportedOperationException();
   }
 
-  public <TKey, TResult> Queryable<Grouping<TKey, TResult>> groupByK(
+  public <TKey, TResult> Queryable<TResult> groupByK(
       Queryable<T> source,
       FunctionExpression<Function1<T, TKey>> keySelector,
       FunctionExpression<Function2<TKey, Enumerable<T>, TResult>>
-          elementSelector) {
+          resultSelector) {
     throw new UnsupportedOperationException();
   }
 

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -86,6 +86,7 @@
 import org.apache.calcite.rel.rules.ProjectFilterTransposeRule;
 import org.apache.calcite.rel.rules.ProjectMergeRule;
 import org.apache.calcite.rel.rules.ProjectTableScanRule;
+import org.apache.calcite.rel.rules.ProjectWindowTransposeRule;
 import org.apache.calcite.rel.rules.ReduceExpressionsRule;
 import org.apache.calcite.rel.rules.SortProjectTransposeRule;
 import org.apache.calcite.rel.rules.TableScanRule;
@@ -222,6 +223,7 @@ public class CalcitePrepareImpl implements CalcitePrepare {
           AggregateExpandDistinctAggregatesRule.INSTANCE,
           AggregateReduceFunctionsRule.INSTANCE,
           FilterAggregateTransposeRule.INSTANCE,
+          ProjectWindowTransposeRule.INSTANCE,
           JoinCommuteRule.INSTANCE,
           JoinPushThroughJoinRule.RIGHT,
           JoinPushThroughJoinRule.LEFT,

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTable.java
Patch:
@@ -47,6 +47,7 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Function;
+import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 
 import java.sql.SQLException;
@@ -80,7 +81,7 @@ public JdbcTable(JdbcSchema jdbcSchema, String jdbcCatalogName,
     this.jdbcCatalogName = jdbcCatalogName;
     this.jdbcSchemaName = jdbcSchemaName;
     this.jdbcTableName = tableName;
-    this.jdbcTableType = jdbcTableType;
+    this.jdbcTableType = Preconditions.checkNotNull(jdbcTableType);
   }
 
   public String toString() {

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
Patch:
@@ -287,7 +287,9 @@ RelProtoDataType getRelDataType(DatabaseMetaData metaData, String catalogName,
 
   private RelDataType sqlType(RelDataTypeFactory typeFactory, int dataType,
       int precision, int scale, String typeString) {
-    SqlTypeName sqlTypeName = SqlTypeName.getNameForJdbcType(dataType);
+    // Fall back to ANY if type is unknown
+    final SqlTypeName sqlTypeName =
+        Util.first(SqlTypeName.getNameForJdbcType(dataType), SqlTypeName.ANY);
     switch (sqlTypeName) {
     case ARRAY:
       RelDataType component = null;

File: core/src/main/java/org/apache/calcite/sql/type/SqlTypeName.java
Patch:
@@ -326,7 +326,7 @@ public SqlTypeFamily getFamily() {
    * Gets the SqlTypeName corresponding to a JDBC type.
    *
    * @param jdbcType the JDBC type of interest
-   * @return corresponding SqlTypeName
+   * @return corresponding SqlTypeName, or null if the type is not known
    */
   public static SqlTypeName getNameForJdbcType(int jdbcType) {
     return JDBC_TYPE_TO_NAME.get(jdbcType);

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -3414,7 +3414,6 @@ public SqlNode getNode() {
     return ret;
   }
 
-
   private void convertSelectList(
       Blackboard bb,
       SqlSelect select,
@@ -4160,7 +4159,8 @@ public RexNode visit(SqlLiteral literal) {
     public RexNode visit(SqlCall call) {
       if (agg != null) {
         final SqlOperator op = call.getOperator();
-        if (op.isAggregator() || op.getKind() == SqlKind.FILTER) {
+        if (window == null
+            && (op.isAggregator() || op.getKind() == SqlKind.FILTER)) {
           return agg.lookupAggregates(call);
         }
       }
@@ -4195,6 +4195,7 @@ public RexNode visit(SqlIntervalQualifier intervalQualifier) {
     public List<SqlMonotonicity> getColumnMonotonicities() {
       return columnMonotonicities;
     }
+
   }
 
   /** Deferred lookup. */

File: core/src/main/java/org/apache/calcite/interpreter/Sink.java
Patch:
@@ -28,6 +28,8 @@ public interface Sink {
 
   void end() throws InterruptedException;
 
+  /** This method is temporary. It will be removed without notice. */
+  @Deprecated
   void setSourceEnumerable(Enumerable<Row> enumerable) throws InterruptedException;
 }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/DelegatingEnumerator.java
Patch:
@@ -17,12 +17,12 @@
 package org.apache.calcite.linq4j;
 
 /**
- * Simple enumerator that just delegates all calls to the passed enumerator
+ * Simple enumerator that just delegates all calls to the passed enumerator.
+ *
  * @param <T> type of value to return, as passed from the delegate enumerator
  */
 public class DelegatingEnumerator<T> implements Enumerator<T> {
-
-  private Enumerator<T> delegate;
+  protected final Enumerator<T> delegate;
 
   public DelegatingEnumerator(Enumerator<T> delegate) {
     this.delegate = delegate;

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
Patch:
@@ -35,7 +35,6 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.common.collect.ImmutableList;
@@ -77,8 +76,6 @@ public RelJsonReader(RelOptCluster cluster, RelOptSchema relOptSchema,
   public RelNode read(String s) throws IOException {
     lastRel = null;
     final ObjectMapper mapper = new ObjectMapper();
-    mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
-    mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
     Map<String, Object> o = mapper.readValue(s, TYPE_REF);
     readRels((List<Map<String, Object>>) o.get("rels"));
     System.out.println(lastRel);

File: core/src/main/java/org/apache/calcite/util/JsonBuilder.java
Patch:
@@ -113,7 +113,7 @@ private void appendMap(
         buf.append(",");
         newline(buf, indent + 1);
       }
-      buf.append(entry.getKey());
+      append(buf, 0, entry.getKey());
       buf.append(": ");
       append(buf, indent + 1, entry.getValue());
     }

File: avatica-server/src/main/java/org/apache/calcite/avatica/server/Main.java
Patch:
@@ -40,9 +40,10 @@ public static void main(String[] args)
    *
    * <p>Arguments are as follows:
    * <ul>
-   *   <li>args[0]: the {@link Meta.Factory} class name
+   *   <li>args[0]: the {@link org.apache.calcite.avatica.Meta.Factory} class
+   *       name
    *   <li>args[1+]: arguments passed along to
-   *   {@link Meta.Factory#create(java.util.List)}
+   *   {@link org.apache.calcite.avatica.Meta.Factory#create(java.util.List)}
    * </ul>
    *
    * @param args Command-line arguments

File: core/src/test/java/org/apache/calcite/test/RelMetadataTest.java
Patch:
@@ -1074,7 +1074,7 @@ private void checkPredicates(RelOptCluster cluster, RelOptTable empTable,
 
     predicates = RelMetadataQuery.getPulledUpPredicates(semiJoin);
     assertThat(predicates.pulledUpPredicates.toString(), is("[=($0, 1)]"));
-    assertThat(predicates.leftInferredPredicates.toString(), is("[=($0, 1)]"));
+    assertThat(predicates.leftInferredPredicates.toString(), is("[]"));
     assertThat(predicates.rightInferredPredicates.isEmpty(), is(true));
   }
 

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -1111,9 +1111,7 @@ private static void splitJoinCondition(
 
         boolean foundInput = false;
         for (int i = 0; i < inputs.size() && !foundInput; i++) {
-          final int lowerLimit = inputsRange[i].nextSetBit(0);
-          final int upperLimit = inputsRange[i].length();
-          if (projRefs.nextSetBit(lowerLimit) < upperLimit) {
+          if (inputsRange[i].contains(projRefs)) {
             leftInput = i;
             leftFields = inputs.get(leftInput).getRowType().getFieldList();
 

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -436,7 +436,7 @@ private void checkTileAlgorithm(String statisticProvider,
                 + "GROUP BY \"s\".\"unit_sales\", \"p\".\"recyclable_package\", \"t\".\"the_day\", \"t\".\"the_year\", \"t\".\"quarter\", \"pc\".\"product_family\"")
         .explainContains(
             "JdbcToEnumerableConverter\n"
-                + "  JdbcAggregate(group=[{7, 16, 25, 27, 31, 37}], m0=[COUNT()], m1=[$SUM0($5)], m2=[$SUM0($7)])\n"
+                + "  JdbcAggregate(group=[{7, 16, 25, 27, 31, 37}], m0=[COUNT()], m1=[SUM($5)], m2=[SUM($7)])\n"
                 + "    JdbcJoin(condition=[=($8, $33)], joinType=[inner])\n"
                 + "      JdbcJoin(condition=[=($1, $23)], joinType=[inner])\n"
                 + "        JdbcJoin(condition=[=($0, $9)], joinType=[inner])\n"

File: core/src/main/java/org/apache/calcite/tools/Frameworks.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.sql2rel.SqlRexConvertletTable;
 import org.apache.calcite.sql2rel.StandardConvertletTable;
+import org.apache.calcite.util.Util;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
@@ -107,7 +108,8 @@ public static <R> R withPlanner(final PlannerAction<R> action, //
           public R apply(RelOptCluster cluster, RelOptSchema relOptSchema,
               SchemaPlus rootSchema, CalciteServerStatement statement) {
             final CalciteSchema schema =
-                CalciteSchema.from(config.getDefaultSchema());
+                CalciteSchema.from(
+                    Util.first(config.getDefaultSchema(), rootSchema));
             return action.apply(cluster, relOptSchema, schema.root().plus());
           }
         });

File: core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
Patch:
@@ -86,10 +86,10 @@ public void onMatch(RelOptRuleCall call) {
       return;
     }
 
-    if (filter.hasCorrelation()) {
+    if (RexUtil.containsCorrelation(filter.getCondition())) {
       // If there is a correlation condition anywhere in the filter, don't
       // push this filter past project since in some cases it can prevent a
-      // Correlate from being decorrelated
+      // Correlate from being de-correlated.
       return;
     }
 

File: core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
Patch:
@@ -21,6 +21,7 @@
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.type.SqlTypeUtil;
+import org.apache.calcite.util.mapping.Mapping;
 import org.apache.calcite.util.mapping.Mappings;
 
 import com.google.common.base.Objects;
@@ -286,8 +287,8 @@ public AggregateCall adaptTo(RelNode input, List<Integer> argList,
   /** Creates a copy of this aggregate call, applying a mapping to its
    * arguments. */
   public AggregateCall transform(Mappings.TargetMapping mapping) {
-    return copy(Mappings.permute(argList, mapping),
-        Mappings.apply(mapping, filterArg));
+    return copy(Mappings.apply2((Mapping) mapping, argList),
+        filterArg < 0 ? -1 : Mappings.apply(mapping, filterArg));
   }
 }
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregateRule.java
Patch:
@@ -41,7 +41,7 @@ public RelNode convert(RelNode rel) {
       return new EnumerableAggregate(
           rel.getCluster(),
           traitSet,
-          convert(agg.getInput(), traitSet),
+          convert(agg.getInput(), EnumerableConvention.INSTANCE),
           agg.indicator,
           agg.getGroupSet(),
           agg.getGroupSets(),

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
Patch:
@@ -680,7 +680,7 @@ public RelNode convert(RelNode rel) {
           agg.getTraitSet().replace(out);
       try {
         return new JdbcAggregate(rel.getCluster(), traitSet,
-            convert(agg.getInput(), traitSet), agg.indicator, agg.getGroupSet(),
+            convert(agg.getInput(), out), agg.indicator, agg.getGroupSet(),
             agg.getGroupSets(), agg.getAggCallList());
       } catch (InvalidRelException e) {
         LOGGER.fine(e.toString());

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
Patch:
@@ -340,7 +340,7 @@ private RexNode reduceSum(
             argType, argType.isNullable());
     final AggregateCall sumZeroCall =
         AggregateCall.create(SqlStdOperatorTable.SUM0, oldCall.isDistinct(),
-            oldCall.getArgList(), oldCall.filterArg, sumType, null);
+            oldCall.getArgList(), oldCall.filterArg, sumType, oldCall.name);
     final AggregateCall countCall =
         AggregateCall.create(
             SqlStdOperatorTable.COUNT,

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateRemoveRule.java
Patch:
@@ -63,7 +63,7 @@ public void onMatch(RelOptRuleCall call) {
     // Distinct is "GROUP BY c1, c2" (where c1, c2 are a set of columns on
     // which the input is unique, i.e. contain a key) and has no aggregate
     // functions. It can be removed.
-    final RelNode newInput = convert(input, aggregate.getTraitSet());
+    final RelNode newInput = convert(input, aggregate.getTraitSet().simplify());
 
     // If aggregate was projecting a subset of columns, add a project for the
     // same effect.

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -200,7 +200,7 @@ protected TrimResult trimChild(
       fieldsUsed = ImmutableBitSet.range(input.getRowType().getFieldCount());
     }
     final ImmutableList<RelCollation> collations =
-        RelMetadataQuery.collations(rel);
+        RelMetadataQuery.collations(input);
     for (RelCollation collation : collations) {
       for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {
         fieldsUsed = fieldsUsed.set(fieldCollation.getFieldIndex());

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -3332,7 +3332,7 @@ private void checkNullableTimestamp(CalciteAssert.Config config) {
             + "where \"deptno\" < 0")
         .explainContains(""
             + "PLAN=EnumerableCalc(expr#0..1=[{inputs}], expr#2=[0], expr#3=[=($t0, $t2)], expr#4=[null], expr#5=[CASE($t3, $t4, $t1)], expr#6=[/($t5, $t0)], expr#7=[CAST($t6):JavaType(class java.lang.Integer)], CS=[$t0], C=[$t0], S=[$t5], A=[$t7])\n"
-            + "  EnumerableAggregate(group=[{}], CS=[COUNT()], agg#1=[$SUM0($1)])\n"
+            + "  EnumerableAggregate(group=[{}], CS=[COUNT()], S=[$SUM0($1)])\n"
             + "    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[0], expr#6=[<($t1, $t5)], proj#0..4=[{exprs}], $condition=[$t6])\n"
             + "      EnumerableTableScan(table=[[hr, emps]])\n")
         .returns("CS=0; C=0; S=null; A=null\n");

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -436,7 +436,7 @@ private void checkTileAlgorithm(String statisticProvider,
                 + "GROUP BY \"s\".\"unit_sales\", \"p\".\"recyclable_package\", \"t\".\"the_day\", \"t\".\"the_year\", \"t\".\"quarter\", \"pc\".\"product_family\"")
         .explainContains(
             "JdbcToEnumerableConverter\n"
-                + "  JdbcAggregate(group=[{7, 16, 25, 27, 31, 37}], m0=[COUNT()], m1=[SUM($5)], m2=[SUM($7)])\n"
+                + "  JdbcAggregate(group=[{7, 16, 25, 27, 31, 37}], m0=[COUNT()], m1=[$SUM0($5)], m2=[$SUM0($7)])\n"
                 + "    JdbcJoin(condition=[=($8, $33)], joinType=[inner])\n"
                 + "      JdbcJoin(condition=[=($1, $23)], joinType=[inner])\n"
                 + "        JdbcJoin(condition=[=($0, $9)], joinType=[inner])\n"

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -512,7 +512,7 @@ public RelNode convert(RelNode rel) {
         return new MongoAggregate(
             rel.getCluster(),
             traitSet,
-            convert(agg.getInput(), traitSet),
+            convert(agg.getInput(), traitSet.simplify()),
             agg.indicator,
             agg.getGroupSet(),
             agg.getGroupSets(),

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
Patch:
@@ -746,7 +746,7 @@ private void declareAndResetState(final JavaTypeFactory typeFactory,
       BlockBuilder builder, final Result result, int windowIdx,
       List<AggImpState> aggs, PhysType outputPhysType,
       List<Expression> outputRow) {
-    for (final AggImpState agg: aggs) {
+    for (final AggImpState agg : aggs) {
       agg.context =
           new WinAggContext() {
             public SqlAggFunction aggregation() {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateFilterTransposeRule.java
Patch:
@@ -113,7 +113,7 @@ public Integer apply(Integer a0) {
       if (aggregate.indicator) {
         ImmutableList.Builder<ImmutableBitSet> newGroupingSetsBuilder =
                 ImmutableList.builder();
-        for (ImmutableBitSet groupingSet: aggregate.getGroupSets()) {
+        for (ImmutableBitSet groupingSet : aggregate.getGroupSets()) {
           final ImmutableBitSet.Builder newGroupingSet =
                   ImmutableBitSet.builder();
           for (int c : groupingSet) {

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateUnionTransposeRule.java
Patch:
@@ -156,7 +156,7 @@ public void onMatch(RelOptRuleCall call) {
   private List<AggregateCall> transformAggCalls(RelNode input, int groupCount,
       List<AggregateCall> origCalls) {
     final List<AggregateCall> newCalls = Lists.newArrayList();
-    for (Ord<AggregateCall> ord: Ord.zip(origCalls)) {
+    for (Ord<AggregateCall> ord : Ord.zip(origCalls)) {
       final AggregateCall origCall = ord.e;
       if (origCall.isDistinct()
           || !SUPPORTED_AGGREGATES.containsKey(origCall.getAggregation()

File: core/src/main/java/org/apache/calcite/rel/rules/FilterAggregateTransposeRule.java
Patch:
@@ -131,7 +131,7 @@ private boolean canPush(Aggregate aggregate, ImmutableBitSet rCols) {
       // If grouping sets are used, the filter can be pushed if
       // the columns referenced in the predicate are present in
       // all the grouping sets.
-      for (ImmutableBitSet groupingSet: aggregate.getGroupSets()) {
+      for (ImmutableBitSet groupingSet : aggregate.getGroupSets()) {
         if (!groupingSet.contains(rCols)) {
           return false;
         }

File: core/src/test/java/org/apache/calcite/test/DiffRepository.java
Patch:
@@ -435,7 +435,6 @@ public void assertEquals(String tag, String expected, String actual) {
             tag,
             expected2Canonical,
             actualCanonical);
-        amend(expected, actual);
       } catch (ComparisonFailure e) {
         amend(expected, actual);
         throw e;

File: core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java
Patch:
@@ -44,7 +44,6 @@ public RelCrossType(
       List<RelDataTypeField> fields) {
     super(fields);
     this.types = ImmutableList.copyOf(types);
-    assert types != null;
     assert types.size() >= 1;
     for (RelDataType type : types) {
       assert !(type instanceof RelCrossType);

File: core/src/main/java/org/apache/calcite/runtime/FlatLists.java
Patch:
@@ -219,7 +219,7 @@ public boolean remove(Object o) {
    *
    * <p>The list is created via {@link FlatLists#of}.
    *
-   * @param <T>
+   * @param <T> Element type
    */
   protected static class Flat2List<T>
       extends AbstractFlatList<T>
@@ -346,7 +346,7 @@ public int compareTo(List o) {
    *
    * <p>The list is created via {@link FlatLists#of(java.util.List)}.
    *
-   * @param <T>
+   * @param <T> Element type
    */
   protected static class Flat3List<T>
       extends AbstractFlatList<T>

File: core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
Patch:
@@ -544,7 +544,9 @@ public static Long divide(Integer b0, Long b1) {
 
   /** SQL <code>/</code> operator applied to BigDecimal values. */
   public static BigDecimal divide(BigDecimal b0, BigDecimal b1) {
-    return (b0 == null || b1 == null) ? null : b0.divide(b1);
+    return (b0 == null || b1 == null)
+        ? null
+        : b0.divide(b1, MathContext.DECIMAL64);
   }
 
   // *

File: avatica-server/src/main/java/org/apache/calcite/avatica/server/AvaticaHandler.java
Patch:
@@ -45,7 +45,7 @@ public AvaticaHandler(Service service) {
   public void handle(String target, Request baseRequest,
       HttpServletRequest request, HttpServletResponse response)
       throws IOException, ServletException {
-    response.setContentType("text/html;charset=utf-8");
+    response.setContentType("application/json;charset=utf-8");
     response.setStatus(HttpServletResponse.SC_OK);
     if (request.getMethod().equals("POST")) {
       final String jsonRequest =

File: core/src/main/java/org/apache/calcite/tools/RelBuilder.java
Patch:
@@ -864,14 +864,15 @@ public RelBuilder sortLimit(int offset, int fetch,
     }
     final RexNode offsetNode = offset <= 0 ? null : literal(offset);
     final RexNode fetchNode = fetch < 0 ? null : literal(fetch);
-    if (extraNodes.size() > inputRowType.getFieldCount()) {
+    final boolean addedFields = extraNodes.size() > originalExtraNodes.size();
+    if (addedFields) {
       project(extraNodes);
     }
     final RelNode sort =
         sortFactory.createSort(build(), RelCollations.of(fieldCollations),
             offsetNode, fetchNode);
     push(sort);
-    if (extraNodes.size() > inputRowType.getFieldCount()) {
+    if (addedFields) {
       project(originalExtraNodes);
     }
     return this;

File: core/src/main/java/org/apache/calcite/sql/validate/SelectNamespace.java
Patch:
@@ -52,7 +52,7 @@ public SelectNamespace(
   //~ Methods ----------------------------------------------------------------
 
   // implement SqlValidatorNamespace, overriding return type
-  public SqlSelect getNode() {
+  @Override public SqlSelect getNode() {
     return select;
   }
 

File: core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
Patch:
@@ -3483,6 +3483,7 @@ public SqlNode getNode() {
     for (int i = 0; i < joinList.size(); i++) {
       Object o = joinList.get(i);
       if (o instanceof List) {
+        @SuppressWarnings("unchecked")
         List<SqlNode> projectList = (List<SqlNode>) o;
         final List<RexNode> selectList = new ArrayList<>();
         final List<String> fieldNameList = new ArrayList<>();

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -4262,7 +4262,6 @@ public void _testWinPartClause() {
   /** Test case for
    * <a href="https://issues.apache.org/jira/browse/CALCITE-754">[CALCITE-754]
    * Validator error when resolving OVER clause of JOIN query</a>. */
-  @Ignore
   @Test public void testPartitionByColumnInJoinAlias() {
     sql("select sum(1) over(partition by t1.ename) \n"
             + "from emp t1, emp t2")

File: core/src/test/java/org/apache/calcite/test/CalciteAssert.java
Patch:
@@ -277,7 +277,7 @@ public Void apply(ResultSet resultSet) {
     };
   }
 
-  static Function<ResultSet, Void> checkResultCount(final int expected) {
+  public static Function<ResultSet, Void> checkResultCount(final int expected) {
     return new Function<ResultSet, Void>() {
       public Void apply(ResultSet resultSet) {
         try {

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidator.java
Patch:
@@ -346,6 +346,7 @@ CalciteContextException newValidationError(
    * @param selectNode Expression in SELECT clause
    * @return whether expression is an aggregate function
    */
+  @Deprecated // to be removed before 2.0
   boolean isAggregate(SqlNode selectNode);
 
   /**

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaResultSet.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.avatica;
 
+import org.apache.calcite.avatica.remote.TypedValue;
 import org.apache.calcite.avatica.util.ArrayImpl;
 import org.apache.calcite.avatica.util.Cursor;
 
@@ -179,7 +180,7 @@ protected void cancel() {
    * @throws SQLException if execute fails for some reason.
    */
   protected AvaticaResultSet execute() throws SQLException {
-    final List<Object> parameterValues = statement.getBoundParameterValues();
+    final List<TypedValue> parameterValues = statement.getBoundParameterValues();
     final Iterable<Object> iterable1 =
         statement.connection.meta.createIterable(statement.handle, signature,
             parameterValues, firstFrame);
@@ -377,7 +378,7 @@ public ResultSetMetaData getMetaData() throws SQLException {
   public Object getObject(int columnIndex) throws SQLException {
     final Cursor.Accessor accessor = getAccessor(columnIndex);
     final ColumnMetaData metaData = columnMetaDataList.get(columnIndex - 1);
-    return AvaticaParameter.get(accessor, metaData.type.id, localCalendar);
+    return AvaticaSite.get(accessor, metaData.type.id, localCalendar);
   }
 
   public Object getObject(String columnLabel) throws SQLException {

File: avatica/src/main/java/org/apache/calcite/avatica/ColumnMetaData.java
Patch:
@@ -246,7 +246,7 @@ protected AvaticaType(int id, String name, Rep rep) {
     }
 
     public String columnClassName() {
-      return SqlType.valueOf(id).clazz.getName();
+      return SqlType.valueOf(id).boxedClass().getName();
     }
 
     public AvaticaType setRep(Rep rep) {

File: avatica/src/main/java/org/apache/calcite/avatica/remote/LocalService.java
Patch:
@@ -81,8 +81,9 @@ public ResultSetResponse toResponse(Meta.MetaResultSet resultSet) {
   private List<List<Object>> list2(Meta.MetaResultSet resultSet) {
     final Meta.StatementHandle h = new Meta.StatementHandle(
         resultSet.connectionId, resultSet.statementId, null);
+    final List<TypedValue> parameterValues = Collections.emptyList();
     final Iterable<Object> iterable = meta.createIterable(h,
-        resultSet.signature, Collections.emptyList(), resultSet.firstFrame);
+        resultSet.signature, parameterValues, resultSet.firstFrame);
     final List<List<Object>> list = new ArrayList<>();
     return MetaImpl.collect(resultSet.signature.cursorFactory, iterable, list);
   }
@@ -161,7 +162,7 @@ public FetchResponse apply(FetchRequest request) {
         request.connectionId, request.statementId, null);
     final Meta.Frame frame =
         meta.fetch(h,
-            TypedValue.values(request.parameterValues),
+            request.parameterValues,
             request.offset,
             request.fetchMaxRowCount);
     return new FetchResponse(frame);

File: avatica/src/main/java/org/apache/calcite/avatica/util/AbstractCursor.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.avatica.util;
 
-import org.apache.calcite.avatica.AvaticaParameter;
+import org.apache.calcite.avatica.AvaticaSite;
 import org.apache.calcite.avatica.AvaticaUtils;
 import org.apache.calcite.avatica.ColumnMetaData;
 
@@ -666,7 +666,7 @@ public BigDecimal getBigDecimal(int scale) {
       if (n == null) {
         return null;
       }
-      return AvaticaParameter.toBigDecimal(n)
+      return AvaticaSite.toBigDecimal(n)
           .setScale(scale, BigDecimal.ROUND_UNNECESSARY);
     }
 

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -285,7 +285,7 @@ public ResultSet apply(Connection input) {
       }
       int param = map.get(sqlType);
       Class clazz = entry.getKey();
-      for (Object sampleValue : values(sqlType.clazz)) {
+      for (Object sampleValue : values(sqlType.boxedClass())) {
         switch (sqlType) {
         case DATE:
         case TIME:

File: avatica/src/main/java/org/apache/calcite/avatica/ColumnMetaData.java
Patch:
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.avatica;
 
+import org.apache.calcite.avatica.util.ByteString;
+
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonSubTypes;
@@ -190,6 +192,7 @@ public enum Rep {
     JAVA_SQL_TIMESTAMP(Timestamp.class),
     JAVA_SQL_DATE(java.sql.Date.class),
     JAVA_UTIL_DATE(java.util.Date.class),
+    BYTE_STRING(ByteString.class),
     STRING(String.class),
     OBJECT(Object.class);
 

File: avatica/src/main/java/org/apache/calcite/avatica/remote/LocalService.java
Patch:
@@ -161,7 +161,7 @@ public FetchResponse apply(FetchRequest request) {
         request.connectionId, request.statementId, null);
     final Meta.Frame frame =
         meta.fetch(h,
-            request.parameterValues,
+            TypedValue.values(request.parameterValues),
             request.offset,
             request.fetchMaxRowCount);
     return new FetchResponse(frame);

File: avatica/src/main/java/org/apache/calcite/avatica/remote/RemoteMeta.java
Patch:
@@ -175,9 +175,10 @@ private MetaResultSet toResultSet(Class clazz,
 
   @Override public Frame fetch(StatementHandle h, List<Object> parameterValues,
       int offset, int fetchMaxRowCount) {
+    final List<TypedValue> typedValues = TypedValue.list(parameterValues);
     final Service.FetchResponse response =
         service.apply(
-            new Service.FetchRequest(h.connectionId, h.id, parameterValues,
+            new Service.FetchRequest(h.connectionId, h.id, typedValues,
                 offset, fetchMaxRowCount));
     return response.frame;
   }

File: avatica/src/main/java/org/apache/calcite/avatica/remote/Service.java
Patch:
@@ -294,13 +294,13 @@ class FetchRequest extends Request {
     public final int fetchMaxRowCount;
     /** A list of parameter values, if statement is to be executed; otherwise
      * null. */
-    public final List<Object> parameterValues;
+    public final List<TypedValue> parameterValues;
 
     @JsonCreator
     public FetchRequest(
         @JsonProperty("connectionId") String connectionId,
         @JsonProperty("statementId") int statementId,
-        @JsonProperty("parameterValues") List<Object> parameterValues,
+        @JsonProperty("parameterValues") List<TypedValue> parameterValues,
         @JsonProperty("offset") int offset,
         @JsonProperty("fetchMaxRowCount") int fetchMaxRowCount) {
       this.connectionId = connectionId;

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -51,6 +51,7 @@
 import org.apache.calcite.rel.metadata.RelMetadataProvider;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rel.rules.AggregateJoinTransposeRule;
+import org.apache.calcite.rel.rules.AggregateProjectMergeRule;
 import org.apache.calcite.rel.rules.AggregateRemoveRule;
 import org.apache.calcite.rel.rules.CalcRemoveRule;
 import org.apache.calcite.rel.rules.FilterJoinRule;
@@ -1070,6 +1071,7 @@ public void registerAbstractRelationalRules() {
     addRule(UnionToDistinctRule.INSTANCE);
     addRule(ProjectRemoveRule.INSTANCE);
     addRule(AggregateJoinTransposeRule.INSTANCE);
+    addRule(AggregateProjectMergeRule.INSTANCE);
     addRule(CalcRemoveRule.INSTANCE);
     addRule(SortRemoveRule.INSTANCE);
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectMergeRule.java
Patch:
@@ -114,8 +114,7 @@ public static RelNode apply(Aggregate aggregate,
     // Add a project if the group set is not in the same order or
     // contains duplicates.
     RelNode rel = newAggregate;
-    //noinspection EqualsBetweenInconvertibleTypes
-    if (!newGroupSet.toList().equals(newKeys)) {
+    if (!newKeys.equals(newGroupSet.asList())) {
       final List<Integer> posList = Lists.newArrayList();
       for (int newKey : newKeys) {
         posList.add(newGroupSet.indexOf(newKey));

File: core/src/test/java/org/apache/calcite/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -270,7 +270,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
         .query(
             "select \"store\".\"store_country\" as \"c0\", sum(\"inventory_fact_1997\".\"supply_time\") as \"m0\" from \"store\" as \"store\", \"inventory_fact_1997\" as \"inventory_fact_1997\" where \"inventory_fact_1997\".\"store_id\" = \"store\".\"store_id\" group by \"store\".\"store_country\"")
         .planContains(
-            "  final org.apache.calcite.linq4j.Enumerable _inputEnumerable1 = left.join(right, new org.apache.calcite.linq4j.function.Function1() {\n");
+            "  return left.join(right, new org.apache.calcite.linq4j.function.Function1() {\n");
   }
 }
 

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -111,11 +111,11 @@ public RelDataType createType(Type type) {
           createType(clazz.getComponentType()), -1);
     } else if (List.class.isAssignableFrom(clazz)) {
       return createArrayType(
-          createSqlType(SqlTypeName.ANY), -1);
+          createTypeWithNullability(createSqlType(SqlTypeName.ANY), true), -1);
     } else if (Map.class.isAssignableFrom(clazz)) {
       return createMapType(
-          createSqlType(SqlTypeName.ANY),
-          createSqlType(SqlTypeName.ANY));
+          createTypeWithNullability(createSqlType(SqlTypeName.ANY), true),
+          createTypeWithNullability(createSqlType(SqlTypeName.ANY), true));
     } else {
       return createStructType(clazz);
     }

File: core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
Patch:
@@ -287,7 +287,8 @@ public RelDataType apply(RelDataType input) {
             if (input instanceof RelDataTypeFactoryImpl.JavaType
                 && ((RelDataTypeFactoryImpl.JavaType) input).getJavaClass()
                 == Object.class) {
-              return typeFactory.createSqlType(SqlTypeName.ANY);
+              return typeFactory.createTypeWithNullability(
+                  typeFactory.createSqlType(SqlTypeName.ANY), true);
             }
             return typeFactory.toSql(input);
           }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlCountAggFunction.java
Patch:
@@ -62,7 +62,9 @@ public SqlCountAggFunction() {
   }
 
   public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
-    return ImmutableList.of(typeFactory.createSqlType(SqlTypeName.ANY));
+    return ImmutableList.of(
+        typeFactory.createTypeWithNullability(
+            typeFactory.createSqlType(SqlTypeName.ANY), true));
   }
 
   public RelDataType getReturnType(RelDataTypeFactory typeFactory) {

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/JsonTable.java
Patch:
@@ -47,7 +47,8 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
     return typeFactory.builder().add("_MAP",
         typeFactory.createMapType(
             typeFactory.createSqlType(SqlTypeName.VARCHAR),
-            typeFactory.createSqlType(SqlTypeName.ANY))).build();
+            typeFactory.createTypeWithNullability(
+                typeFactory.createSqlType(SqlTypeName.ANY), true))).build();
   }
 
   public Enumerable<Object[]> scan(DataContext root) {

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoTable.java
Patch:
@@ -69,7 +69,8 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
     final RelDataType mapType =
         typeFactory.createMapType(
             typeFactory.createSqlType(SqlTypeName.VARCHAR),
-            typeFactory.createSqlType(SqlTypeName.ANY));
+            typeFactory.createTypeWithNullability(
+                typeFactory.createSqlType(SqlTypeName.ANY), true));
     return typeFactory.builder().add("_MAP", mapType).build();
   }
 

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -239,7 +239,7 @@ public RelNode convert(RelNode rel) {
       return new MongoFilter(
           rel.getCluster(),
           traitSet,
-          convert(filter.getInput(), traitSet),
+          convert(filter.getInput(), out),
           filter.getCondition());
     }
   }
@@ -260,7 +260,7 @@ public RelNode convert(RelNode rel) {
       final LogicalProject project = (LogicalProject) rel;
       final RelTraitSet traitSet = project.getTraitSet().replace(out);
       return new MongoProject(project.getCluster(), traitSet,
-          convert(project.getInput(), traitSet), project.getProjects(),
+          convert(project.getInput(), out), project.getProjects(),
           project.getRowType());
     }
   }

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -50,6 +50,7 @@
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.metadata.RelMetadataProvider;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
+import org.apache.calcite.rel.rules.AggregateJoinTransposeRule;
 import org.apache.calcite.rel.rules.AggregateRemoveRule;
 import org.apache.calcite.rel.rules.CalcRemoveRule;
 import org.apache.calcite.rel.rules.FilterJoinRule;
@@ -1068,6 +1069,7 @@ public void registerAbstractRelationalRules() {
     addRule(AggregateRemoveRule.INSTANCE);
     addRule(UnionToDistinctRule.INSTANCE);
     addRule(ProjectRemoveRule.INSTANCE);
+    addRule(AggregateJoinTransposeRule.INSTANCE);
     addRule(CalcRemoveRule.INSTANCE);
     addRule(SortRemoveRule.INSTANCE);
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -234,6 +234,8 @@ public enum BuiltInMethod {
       int.class),
   CHAR_LENGTH(SqlFunctions.class, "charLength", String.class),
   STRING_CONCAT(SqlFunctions.class, "concat", String.class, String.class),
+  FLOOR_DIV(SqlFunctions.class, "floorDiv", long.class, long.class),
+  FLOOR_MOD(SqlFunctions.class, "floorMod", long.class, long.class),
   FLOOR(SqlFunctions.class, "floor", int.class, int.class),
   CEIL(SqlFunctions.class, "ceil", int.class, int.class),
   OVERLAY(SqlFunctions.class, "overlay", String.class, String.class, int.class),

File: core/src/main/java/org/apache/calcite/sql/fun/SqlBetweenOperator.java
Patch:
@@ -83,9 +83,8 @@ public class SqlBetweenOperator extends SqlInfixOperator {
    * Custom operand-type checking strategy.
    */
   private static final SqlOperandTypeChecker OTC_CUSTOM =
-      new ComparableOperandTypeChecker(
-          3,
-          RelDataTypeComparability.ALL);
+      new ComparableOperandTypeChecker(3, RelDataTypeComparability.ALL,
+          SqlOperandTypeChecker.Consistency.COMPARE);
   private static final SqlWriter.FrameType FRAME_TYPE =
       SqlWriter.FrameTypeEnum.create("BETWEEN");
 

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -684,15 +684,15 @@ public boolean canConvert(RelTraitSet fromTraits, RelTraitSet toTraits) {
   }
 
   public RelNode changeTraits(final RelNode rel, RelTraitSet toTraits) {
-    assert !rel.getTraitSet().equals(toTraits)
-        : "pre: !rel.getTraits().equals(toTraits)";
+    assert !rel.getTraitSet().equals(toTraits);
+    assert toTraits.allSimple();
 
     RelSubset rel2 = ensureRegistered(rel, null);
     if (rel2.getTraitSet().equals(toTraits)) {
       return rel2;
     }
 
-    return rel2.set.getOrCreateSubset(rel.getCluster(), toTraits);
+    return rel2.set.getOrCreateSubset(rel.getCluster(), toTraits.simplify());
   }
 
   public RelOptPlanner chooseDelegate() {

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -20,6 +20,7 @@
 import org.apache.calcite.jdbc.CalciteRemoteDriverTest;
 import org.apache.calcite.plan.RelOptUtilTest;
 import org.apache.calcite.plan.RelWriterTest;
+import org.apache.calcite.plan.volcano.TraitPropagationTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTraitTest;
 import org.apache.calcite.rel.RelCollationTest;
@@ -79,6 +80,7 @@
     InterpreterTest.class,
     VolcanoPlannerTest.class,
     HepPlannerTest.class,
+    TraitPropagationTest.class,
     RelWriterTest.class,
     RexProgramTest.class,
     RexTransformerTest.class,

File: avatica/src/main/java/org/apache/calcite/avatica/remote/Service.java
Patch:
@@ -171,7 +171,7 @@ ResultSetResponse accept(Service service) {
    * <p>Several types of request, including
    * {@link org.apache.calcite.avatica.Meta#getCatalogs()} and
    * {@link org.apache.calcite.avatica.Meta#getSchemas(String, org.apache.calcite.avatica.Meta.Pat)}
-   * {@link Meta#getTables(String, org.apache.calcite.avatica.Meta.Pat, org.apache.calcite.avatica.Meta.Pat, List<String>)}
+   * {@link Meta#getTables(String, Meta.Pat, Meta.Pat, List)}
    * {@link Meta#getTableTypes()}
    * return this response. */
   class ResultSetResponse extends Response {

File: avatica/src/main/java/org/apache/calcite/avatica/util/AbstractCursor.java
Patch:
@@ -88,9 +88,9 @@ protected Accessor createAccessor(ColumnMetaData columnMetaData, int ordinal,
       return new LongAccessor(getter);
     case Types.BOOLEAN:
       return new BooleanAccessor(getter);
-    case Types.FLOAT:
     case Types.REAL:
       return new FloatAccessor(getter);
+    case Types.FLOAT:
     case Types.DOUBLE:
       return new DoubleAccessor(getter);
     case Types.NUMERIC:

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -152,9 +152,9 @@ public Type getJavaClass(RelDataType type) {
       case BOOLEAN:
         return type.isNullable() ? Boolean.class : boolean.class;
       case DOUBLE:
+      case FLOAT: // sic
         return type.isNullable() ? Double.class : double.class;
       case REAL:
-      case FLOAT:
         return type.isNullable() ? Float.class : float.class;
       case BINARY:
       case VARBINARY:

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdSize.java
Patch:
@@ -265,13 +265,13 @@ public Double averageTypeValueSize(RelDataType type) {
     case SMALLINT:
       return 2d;
     case INTEGER:
-    case FLOAT:
     case REAL:
     case DATE:
     case TIME:
       return 4d;
     case BIGINT:
     case DOUBLE:
+    case FLOAT: // sic
     case TIMESTAMP:
     case INTERVAL_DAY_TIME:
     case INTERVAL_YEAR_MONTH:

File: core/src/test/java/org/apache/calcite/sql/test/SqlTests.java
Patch:
@@ -187,7 +187,7 @@ private static ColumnMetaData.Rep rep(int columnType) {
       return ColumnMetaData.Rep.INTEGER;
     case Types.BIGINT:
       return ColumnMetaData.Rep.LONG;
-    case Types.FLOAT:
+    case Types.REAL:
       return ColumnMetaData.Rep.FLOAT;
     case Types.DOUBLE:
       return ColumnMetaData.Rep.DOUBLE;

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaJdbc41Factory.java
Patch:
@@ -84,11 +84,11 @@ public AvaticaPreparedStatement newPreparedStatement(
   }
 
   public AvaticaResultSet newResultSet(AvaticaStatement statement,
-      Meta.Signature signature, TimeZone timeZone, Iterable<Object> iterable) {
+      Meta.Signature signature, TimeZone timeZone, Meta.Frame firstFrame) {
     final ResultSetMetaData metaData =
         newResultSetMetaData(statement, signature);
     return new AvaticaResultSet(statement, signature, metaData, timeZone,
-        iterable);
+        firstFrame);
   }
 
   public AvaticaResultSetMetaData newResultSetMetaData(

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaResultSetMetaData.java
Patch:
@@ -104,11 +104,11 @@ public String getCatalogName(int column) throws SQLException {
   }
 
   public int getColumnType(int column) throws SQLException {
-    return getColumnMetaData(column).type.type;
+    return getColumnMetaData(column).type.id;
   }
 
   public String getColumnTypeName(int column) throws SQLException {
-    return getColumnMetaData(column).type.typeName;
+    return getColumnMetaData(column).type.name;
   }
 
   public boolean isReadOnly(int column) throws SQLException {

File: avatica/src/main/java/org/apache/calcite/avatica/UnregisteredDriver.java
Patch:
@@ -43,7 +43,7 @@
  * <p>The provider must implement:</p>
  * <ul>
  *   <li>{@link Meta#prepare(org.apache.calcite.avatica.Meta.StatementHandle, String, int)}
- *   <li>{@link Meta#createIterable(org.apache.calcite.avatica.Meta.StatementHandle, org.apache.calcite.avatica.Meta.Signature, Iterable)}
+ *   <li>{@link Meta#createIterable(org.apache.calcite.avatica.Meta.StatementHandle, org.apache.calcite.avatica.Meta.Signature, java.util.List, Meta.Frame)}
  * </ul>
  */
 public abstract class UnregisteredDriver implements java.sql.Driver {

File: core/src/main/java/org/apache/calcite/jdbc/CalciteJdbc41Factory.java
Patch:
@@ -91,13 +91,13 @@ public AvaticaPreparedStatement newPreparedStatement(
   }
 
   public CalciteResultSet newResultSet(AvaticaStatement statement,
-      Meta.Signature signature, TimeZone timeZone, Iterable<Object> iterable) {
+      Meta.Signature signature, TimeZone timeZone, Meta.Frame firstFrame) {
     final ResultSetMetaData metaData =
         newResultSetMetaData(statement, signature);
     final CalcitePrepare.CalciteSignature calciteSignature =
         (CalcitePrepare.CalciteSignature) signature;
     return new CalciteResultSet(statement, calciteSignature, metaData, timeZone,
-        iterable);
+        firstFrame);
   }
 
   public ResultSetMetaData newResultSetMetaData(AvaticaStatement statement,

File: core/src/main/java/org/apache/calcite/materialize/MaterializationService.java
Patch:
@@ -126,7 +126,7 @@ public MaterializationKey defineMaterialization(final CalciteSchema schema,
               Functions.adapt(calciteSignature.columns,
                   new Function1<ColumnMetaData, ColumnMetaData.Rep>() {
                     public ColumnMetaData.Rep apply(ColumnMetaData column) {
-                      return column.type.representation;
+                      return column.type.rep;
                     }
                   }),
               new AbstractQueryable<Object>() {

File: core/src/test/java/org/apache/calcite/test/JdbcAdapterTest.java
Patch:
@@ -32,7 +32,7 @@ public class JdbcAdapterTest {
             + "    JdbcTableScan(table=[[foodmart, sales_fact_1997]])\n"
             + "    JdbcTableScan(table=[[foodmart, sales_fact_1998]])")
         .runs()
-        .enable(CalciteAssert.CONNECTION_SPEC.url.startsWith("jdbc:hsqldb:"))
+        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)
         .planHasSql("SELECT *\n"
             + "FROM \"foodmart\".\"sales_fact_1997\"\n"
             + "UNION ALL\n"
@@ -48,7 +48,7 @@ public class JdbcAdapterTest {
             + "  select * from \"sales_fact_1998\")\n"
             + "where \"product_id\" = 1")
         .runs()
-        .enable(CalciteAssert.CONNECTION_SPEC.url.startsWith("jdbc:hsqldb:"))
+        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)
         .planHasSql("SELECT *\n"
             + "FROM \"foodmart\".\"sales_fact_1997\"\n"
             + "WHERE \"product_id\" = 1\n"
@@ -63,7 +63,7 @@ public class JdbcAdapterTest {
         .query("select \"store_id\", \"store_name\" from \"store\"\n"
             + "where \"store_name\" in ('Store 1', 'Store 10', 'Store 11', 'Store 15', 'Store 16', 'Store 24', 'Store 3', 'Store 7')")
         .runs()
-        .enable(CalciteAssert.CONNECTION_SPEC.url.startsWith("jdbc:hsqldb:"))
+        .enable(CalciteAssert.DB == CalciteAssert.DatabaseInstance.HSQLDB)
         .planHasSql(
             "SELECT \"store_id\", \"store_name\"\n"
             + "FROM \"foodmart\".\"store\"\n"

File: core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
Patch:
@@ -129,7 +129,9 @@ private static Object getValue(SqlNode right) throws NonLiteralException {
           ImmutableMap.builder();
       final List<SqlNode> operands = ((SqlCall) right).getOperandList();
       for (int i = 0; i < operands.size(); i += 2) {
-        builder2.put(operands.get(i), operands.get(i + 1));
+        final SqlNode key = operands.get(i);
+        final SqlNode value = operands.get(i + 1);
+        builder2.put(getValue(key), getValue(value));
       }
       return builder2.build();
     default:

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.calcite.schema.ProjectableFilterableTable;
 import org.apache.calcite.schema.QueryableTable;
 import org.apache.calcite.schema.ScannableTable;
+import org.apache.calcite.schema.StreamableTable;
 import org.apache.calcite.schema.Table;
 import org.apache.calcite.util.BuiltInMethod;
 
@@ -104,7 +105,8 @@ public static Class deduceElementType(Table table) {
       }
     } else if (table instanceof ScannableTable
         || table instanceof FilterableTable
-        || table instanceof ProjectableFilterableTable) {
+        || table instanceof ProjectableFilterableTable
+        || table instanceof StreamableTable) {
       return Object[].class;
     } else {
       return Object.class;

File: core/src/main/java/org/apache/calcite/model/JsonRoot.java
Patch:
@@ -32,6 +32,7 @@
  *   {@link JsonSchema} (in collection {@link JsonRoot#schemas schemas})
  *     {@link JsonTable} (in collection {@link JsonMapSchema#tables tables})
  *       {@link JsonColumn} (in collection {@link JsonTable#columns columns}
+ *       {@link JsonStream} (in field {@link JsonTable#stream stream}
  *     {@link JsonView}
  *     {@link JsonFunction} (in collection {@link JsonMapSchema#functions functions})
  *     {@link JsonLattice} (in collection {@link JsonSchema#lattices lattices})

File: core/src/main/java/org/apache/calcite/rel/core/Sort.java
Patch:
@@ -45,7 +45,7 @@
 public abstract class Sort extends SingleRel {
   //~ Instance fields --------------------------------------------------------
 
-  protected final RelCollation collation;
+  public final RelCollation collation;
   protected final ImmutableList<RexNode> fieldExps;
   public final RexNode offset;
   public final RexNode fetch;

File: core/src/main/java/org/apache/calcite/schema/Schema.java
Patch:
@@ -181,6 +181,9 @@ enum TableType {
      * <p>Used by Apache Phoenix, and others. Must have a single BIGINT column
      * called "$seq". */
     SEQUENCE,
+
+    /** Stream. */
+    STREAM,
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/SqlSelectKeyword.java
Patch:
@@ -23,7 +23,8 @@
  */
 public enum SqlSelectKeyword implements SqlLiteral.SqlSymbol {
   DISTINCT,
-  ALL;
+  ALL,
+  STREAM;
 
   /**
    * Creates a parse-tree node representing an occurrence of this keyword

File: core/src/main/java/org/apache/calcite/sql/fun/SqlExtractFunction.java
Patch:
@@ -59,9 +59,9 @@ public void unparse(
       int leftPrec,
       int rightPrec) {
     final SqlWriter.Frame frame = writer.startFunCall(getName());
-    call.operand(0).unparse(writer, leftPrec, rightPrec);
+    call.operand(0).unparse(writer, 0, 0);
     writer.sep("FROM");
-    call.operand(1).unparse(writer, leftPrec, rightPrec);
+    call.operand(1).unparse(writer, 0, 0);
     writer.endFunCall(frame);
   }
 }

File: core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorTable.java
Patch:
@@ -42,6 +42,8 @@ public interface SqlValidatorTable {
    * Returns the access type of the table
    */
   SqlAccessType getAllowedAccess();
+
+  boolean supportsModality(SqlModality modality);
 }
 
 // End SqlValidatorTable.java

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -116,6 +116,7 @@
     ReflectiveSchemaTest.class,
     JdbcTest.class,
     CalciteRemoteDriverTest.class,
+    StreamTest.class,
 
     // test cases
     TableInRootSchemaTest.class,

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -793,7 +793,7 @@ public Prepare.CatalogReader apply(RelDataTypeFactory typeFactory) {
                     typeFactory.createSqlType(SqlTypeName.INTEGER);
                 for (int i = 0; i < 10; i++) {
                   String t = String.valueOf((char) ('A' + i));
-                  MockTable table = MockTable.create(this, schema, t);
+                  MockTable table = MockTable.create(this, schema, t, false);
                   table.addColumn(t, intType);
                   registerTable(table);
                 }

File: core/src/test/java/org/apache/calcite/sql/parser/SqlParserTest.java
Patch:
@@ -825,7 +825,8 @@ protected void checkExpFails(
   @Test public void testGroupByRollup() {
     sql("select deptno from emp\n"
         + "group by rollup (deptno, deptno + 1, gender)")
-        .ok("SELECT `DEPTNO`\n" + "FROM `EMP`\n"
+        .ok("SELECT `DEPTNO`\n"
+            + "FROM `EMP`\n"
             + "GROUP BY (ROLLUP(`DEPTNO`, (`DEPTNO` + 1), `GENDER`))");
 
     // Nested rollup not ok

File: core/src/test/java/org/apache/calcite/test/SqlValidatorTest.java
Patch:
@@ -5333,7 +5333,8 @@ public void _testJoinUsing() {
 
     // self-reference is not ok, even in table not used
     checkFails("with emp2 as (select * from emp),\n"
-            + " emp3 as (select * from ^emp3^)\n" + "values (1)",
+            + " emp3 as (select * from ^emp3^)\n"
+            + "values (1)",
         "Table 'EMP3' not found");
 
     // self-reference not ok

File: core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
Patch:
@@ -168,6 +168,7 @@ public SqlNode validate(SqlNode sqlNode) throws ValidationException {
     this.validator =
         new CalciteSqlValidator(
             operatorTable, createCatalogReader(), typeFactory);
+    this.validator.setIdentifierExpansion(true);
     try {
       validatedSqlNode = validator.validate(sqlNode);
     } catch (RuntimeException e) {
@@ -210,6 +211,7 @@ public RelNode expandView(RelDataType rowType, String queryString,
           createCatalogReader().withSchemaPath(schemaPath);
       final SqlValidator validator = new CalciteSqlValidator(operatorTable,
           catalogReader, typeFactory);
+      validator.setIdentifierExpansion(true);
       final SqlNode validatedSqlNode = validator.validate(sqlNode);
 
       final SqlToRelConverter sqlToRelConverter = new SqlToRelConverter(

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -1843,6 +1843,7 @@ protected static Calendar getCalendarNotTooNear(int timeUnit) {
         "fedf",
         "BINARY(2) NOT NULL");
     tester.checkNull("x'ff' || cast(null as varbinary)");
+    tester.checkNull(" cast(null as ANY) || cast(null as ANY) ");
   }
 
   @Test public void testDivideOperator() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableConvention.java
Patch:
@@ -49,7 +49,7 @@ public RelTraitDef getTraitDef() {
     return ConventionTraitDef.INSTANCE;
   }
 
-  public boolean subsumes(RelTrait trait) {
+  public boolean satisfies(RelTrait trait) {
     return this == trait;
   }
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRules.java
Patch:
@@ -33,6 +33,9 @@ public class EnumerableRules {
   public static final RelOptRule ENUMERABLE_JOIN_RULE =
       new EnumerableJoinRule();
 
+  public static final RelOptRule ENUMERABLE_MERGE_JOIN_RULE =
+      new EnumerableMergeJoinRule();
+
   public static final RelOptRule ENUMERABLE_SEMI_JOIN_RULE =
       new EnumerableSemiJoinRule();
 

File: core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
Patch:
@@ -517,8 +517,7 @@ public Expression generateAccessor(
           Function1.class,
           Expressions.field(
               null,
-              Collections.class,
-              "EMPTY_LIST"),
+              BuiltInMethod.COMPARABLE_EMPTY_LIST.field),
           v1);
     case 1:
       int field0 = fields.get(0);

File: core/src/main/java/org/apache/calcite/interpreter/BindableConvention.java
Patch:
@@ -54,7 +54,7 @@ public RelTraitDef getTraitDef() {
     return ConventionTraitDef.INSTANCE;
   }
 
-  public boolean subsumes(RelTrait trait) {
+  public boolean satisfies(RelTrait trait) {
     return this == trait;
   }
 

File: core/src/main/java/org/apache/calcite/interpreter/InterpretableConvention.java
Patch:
@@ -48,7 +48,7 @@ public RelTraitDef getTraitDef() {
     return ConventionTraitDef.INSTANCE;
   }
 
-  public boolean subsumes(RelTrait trait) {
+  public boolean satisfies(RelTrait trait) {
     return this == trait;
   }
 

File: core/src/main/java/org/apache/calcite/plan/Convention.java
Patch:
@@ -55,7 +55,7 @@ public Impl(String name, Class<? extends RelNode> relClass) {
 
     public void register(RelOptPlanner planner) {}
 
-    public boolean subsumes(RelTrait trait) {
+    public boolean satisfies(RelTrait trait) {
       return this == trait;
     }
 

File: core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
Patch:
@@ -89,7 +89,7 @@ public boolean isKey(ImmutableBitSet columns) {
   }
 
   public RelNode toRel(ToRelContext context) {
-    return new LogicalTableScan(context.getCluster(), this);
+    return LogicalTableScan.create(context.getCluster(), this);
   }
 
   public Expression getExpression(Class clazz) {

File: core/src/main/java/org/apache/calcite/plan/RelOptMaterialization.java
Patch:
@@ -149,7 +149,7 @@ private void match(ProjectFilterTable left, ProjectFilterTable right,
                           Mappings.offsetSource(rightMapping, offset),
                           leftMapping.getTargetCount()));
               final RelNode project = RelOptUtil.createProject(
-                  new LogicalTableScan(cluster, leftRelOptTable),
+                  LogicalTableScan.create(cluster, leftRelOptTable),
                   Mappings.asList(mapping.inverse()));
               final List<RexNode> conditions = Lists.newArrayList();
               if (left.condition != null) {
@@ -173,7 +173,7 @@ private void match(ProjectFilterTable left, ProjectFilterTable right,
                       Mappings.offsetSource(leftMapping, offset),
                       Mappings.offsetTarget(rightMapping, leftCount));
               final RelNode project = RelOptUtil.createProject(
-                  new LogicalTableScan(cluster, rightRelOptTable),
+                  LogicalTableScan.create(cluster, rightRelOptTable),
                   Mappings.asList(mapping.inverse()));
               final List<RexNode> conditions = Lists.newArrayList();
               if (left.condition != null) {

File: core/src/main/java/org/apache/calcite/plan/volcano/AbstractConverter.java
Patch:
@@ -52,6 +52,7 @@ public AbstractConverter(
       RelTraitDef traitDef,
       RelTraitSet traits) {
     super(cluster, traitDef, traits, rel);
+    assert traits.allSimple();
   }
 
   //~ Methods ----------------------------------------------------------------
@@ -83,7 +84,7 @@ public RelWriter explainTerms(RelWriter pw) {
    * Rule which converts an {@link AbstractConverter} into a chain of
    * converters from the source relation to the target traits.
    *
-   * <p>The chain produced is mimimal: we have previously built the transitive
+   * <p>The chain produced is minimal: we have previously built the transitive
    * closure of the graph of conversions, so we choose the shortest chain.</p>
    *
    * <p>Unlike the {@link AbstractConverter} they are replacing, these

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -165,6 +165,7 @@ public class CalcitePrepareImpl implements CalcitePrepare {
   private static final List<RelOptRule> ENUMERABLE_RULES =
       ImmutableList.of(
           EnumerableRules.ENUMERABLE_JOIN_RULE,
+          EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE,
           EnumerableRules.ENUMERABLE_SEMI_JOIN_RULE,
           EnumerableRules.ENUMERABLE_CORRELATE_RULE,
           EnumerableRules.ENUMERABLE_PROJECT_RULE,
@@ -781,7 +782,7 @@ public PreparedResult prepareQueryable(
 
       final List<Materialization> materializations = ImmutableList.of();
       final List<CalciteSchema.LatticeEntry> lattices = ImmutableList.of();
-      rootRel = optimize(resultType, rootRel, materializations, lattices);
+      rootRel = optimize(rootRel, materializations, lattices);
 
       if (timingTracer != null) {
         timingTracer.traceTime("end optimization");

File: core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
Patch:
@@ -200,6 +200,8 @@ public boolean isValid(boolean fail) {
     return true;
   }
 
+  /** @deprecated Use {@link RelMetadataQuery#collations(RelNode)} */
+  @Deprecated // to be removed before 2.0
   public List<RelCollation> getCollationList() {
     return ImmutableList.of();
   }

File: core/src/main/java/org/apache/calcite/rel/RelCollation.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.rel;
 
-import org.apache.calcite.plan.RelTrait;
+import org.apache.calcite.plan.RelMultipleTrait;
 
 import java.util.List;
 
@@ -26,7 +26,7 @@
  * <p>An ordering consists of a list of one or more column ordinals and the
  * direction of the ordering.
  */
-public interface RelCollation extends RelTrait {
+public interface RelCollation extends RelMultipleTrait {
   //~ Methods ----------------------------------------------------------------
 
   /**

File: core/src/main/java/org/apache/calcite/rel/RelNode.java
Patch:
@@ -90,7 +90,7 @@ public interface RelNode extends RelOptNode, Cloneable {
    * @return List of this relational expression's child expressions
    * @see #accept(org.apache.calcite.rex.RexShuttle)
    */
-  @Deprecated
+  @Deprecated // to be removed before 2.0
   List<RexNode> getChildExps();
 
   /**

File: core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
Patch:
@@ -276,7 +276,9 @@ public RelWriter explainTerms(RelWriter pw) {
     // REVIEW jvs 24-Aug-2008:  This is bogus, but no more bogus
     // than what's currently in Join.
     double rowCount = RelMetadataQuery.getRowCount(this);
-    return planner.getCostFactory().makeCost(rowCount, 0, 0);
+    // Aggregates with more aggregate functions cost a bit more
+    final float multiplier = 1f + (float) aggCalls.size() * 0.125f;
+    return planner.getCostFactory().makeCost(rowCount * multiplier, 0, 0);
   }
 
   protected RelDataType deriveRowType() {

File: core/src/main/java/org/apache/calcite/rel/core/Window.java
Patch:
@@ -22,7 +22,7 @@
 import org.apache.calcite.plan.RelOptPlanner;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelCollation;
-import org.apache.calcite.rel.RelCollationImpl;
+import org.apache.calcite.rel.RelCollations;
 import org.apache.calcite.rel.RelFieldCollation;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
@@ -146,7 +146,7 @@ public int size() {
 
   public static RelCollation getCollation(
       final List<RexFieldCollation> collations) {
-    return RelCollationImpl.of(
+    return RelCollations.of(
         new AbstractList<RelFieldCollation>() {
           public RelFieldCollation get(int index) {
             final RexFieldCollation collation = collations.get(index);

File: core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
Patch:
@@ -19,6 +19,7 @@
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.rel.RelCollation;
 import org.apache.calcite.rel.RelCollationImpl;
+import org.apache.calcite.rel.RelCollations;
 import org.apache.calcite.rel.RelFieldCollation;
 import org.apache.calcite.rel.RelInput;
 import org.apache.calcite.rel.RelNode;
@@ -166,7 +167,7 @@ public RelCollation toCollation(
     for (Map<String, Object> map : jsonFieldCollations) {
       fieldCollations.add(toFieldCollation(map));
     }
-    return RelCollationImpl.of(fieldCollations);
+    return RelCollations.of(fieldCollations);
   }
 
   public RelFieldCollation toFieldCollation(Map<String, Object> map) {

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java
Patch:
@@ -20,6 +20,7 @@
 import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelCollation;
+import org.apache.calcite.rel.RelCollationTraitDef;
 import org.apache.calcite.rel.RelInput;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelShuttle;
@@ -56,6 +57,7 @@ public LogicalSort(RelInput input) {
   public static LogicalSort create(RelNode input, RelCollation collation,
       RexNode offset, RexNode fetch) {
     RelOptCluster cluster = input.getCluster();
+    collation = RelCollationTraitDef.INSTANCE.canonize(collation);
     RelTraitSet traitSet =
         input.getTraitSet().replace(Convention.NONE).replace(collation);
     return new LogicalSort(cluster, traitSet, input, collation, offset, fetch);

File: core/src/main/java/org/apache/calcite/rel/metadata/DefaultRelMetadataProvider.java
Patch:
@@ -44,7 +44,8 @@ public DefaultRelMetadataProvider() {
             RelMdDistinctRowCount.SOURCE,
             RelMdSelectivity.SOURCE,
             RelMdExplainVisibility.SOURCE,
-            RelMdPredicates.SOURCE));
+            RelMdPredicates.SOURCE,
+            RelMdCollation.SOURCE));
   }
 }
 

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
Patch:
@@ -154,9 +154,8 @@ public void onMatch(RelOptRuleCall call) {
       rel = null;
     } else {
       rel =
-          new LogicalAggregate(aggregate.getCluster(), aggregate.getInput(),
-              aggregate.indicator, groupSet, aggregate.getGroupSets(),
-              newAggCallList);
+          LogicalAggregate.create(aggregate.getInput(), aggregate.indicator,
+              groupSet, aggregate.getGroupSets(), newAggCallList);
     }
 
     // For each set of operands, find and rewrite all calls which have that

File: core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
Patch:
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.rel.rules;
 
-import org.apache.calcite.plan.Convention;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.plan.RelOptRuleOperand;
@@ -228,7 +227,7 @@ protected void perform(RelOptRuleCall call, Filter filter,
 
     RelNode newJoinRel =
         join.copy(
-            join.getCluster().traitSetOf(Convention.NONE),
+            join.getTraitSet(),
             joinFilter,
             leftRel,
             rightRel,

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToCorrelateRule.java
Patch:
@@ -123,9 +123,7 @@ public void onMatch(RelOptRuleCall call) {
     final RelNode filteredRight =
         RelOptUtil.createFilter(right, joinCondition, filterFactory);
     RelNode newRel =
-        new LogicalCorrelate(
-            join.getCluster(),
-            left,
+        LogicalCorrelate.create(left,
             filteredRight,
             correlationId,
             requiredColumns.build(),

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -221,7 +221,7 @@ protected void apply(RelOptRuleCall call, LogicalProject project,
         rowType = values.getRowType();
       }
       final RelNode newRel =
-          new LogicalValues(values.getCluster(), rowType,
+          LogicalValues.create(values.getCluster(), rowType,
               tuplesBuilder.build());
       call.transformTo(newRel);
     } else {

File: core/src/main/java/org/apache/calcite/rex/RexNode.java
Patch:
@@ -86,7 +86,7 @@ public String toString() {
    * Accepts a visitor, dispatching to the right overloaded
    * {@link RexVisitor#visitInputRef visitXxx} method.
    *
-   * <p>Also see {@link RexProgram#apply(RexVisitor, java.util.List, RexNode)},
+   * <p>Also see {@link RexUtil#apply(RexVisitor, java.util.List, RexNode)},
    * which applies a visitor to several expressions simultaneously.
    */
   public abstract <R> R accept(RexVisitor<R> visitor);

File: core/src/main/java/org/apache/calcite/rex/RexOver.java
Patch:
@@ -107,7 +107,7 @@ public static boolean containsOver(RexNode expr) {
    */
   public static boolean containsOver(RexProgram program) {
     try {
-      RexProgram.apply(FINDER, program.getExprList(), null);
+      RexUtil.apply(FINDER, program.getExprList(), null);
       return false;
     } catch (OverFound e) {
       Util.swallow(e, null);
@@ -120,7 +120,7 @@ public static boolean containsOver(RexProgram program) {
    */
   public static boolean containsOver(List<RexNode> exprs, RexNode condition) {
     try {
-      RexProgram.apply(FINDER, exprs, condition);
+      RexUtil.apply(FINDER, exprs, condition);
       return false;
     } catch (OverFound e) {
       Util.swallow(e, null);

File: core/src/main/java/org/apache/calcite/sql/SqlWindow.java
Patch:
@@ -836,8 +836,7 @@ public <R> void acceptCall(
         boolean onlyExpressions,
         SqlBasicVisitor.ArgHandler<R> argHandler) {
       if (onlyExpressions) {
-        final List<SqlNode> operandList = call.getOperandList();
-        for (Ord<SqlNode> operand : Ord.zip(operandList)) {
+        for (Ord<SqlNode> operand : Ord.zip(call.getOperandList())) {
           // if the second param is an Identifier then it's supposed to
           // be a name from a window clause and isn't part of the
           // group by check

File: core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
Patch:
@@ -422,7 +422,7 @@ public List<String> getReservedAndKeyWords() {
    * <p>To use a different parser (recognizing a different dialect of SQL),
    * derived class should override.
    *
-   * @return a {@link SqlAbstractParserImpl.Metadata} instance.
+   * @return metadata
    */
   protected SqlAbstractParserImpl.Metadata getParserMetadata() {
     SqlParser parser = SqlParser.create("");

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -159,8 +159,7 @@ public void unparse(
       int rightPrec) {
     final SqlWriter.Frame frame = writer.startList("", "");
     SqlCollation collation = null;
-    final List<SqlNode> rands = call.getOperandList();
-    for (Ord<SqlNode> operand : Ord.zip(rands)) {
+    for (Ord<SqlNode> operand : Ord.zip(call.getOperandList())) {
       SqlLiteral rand = (SqlLiteral) operand.e;
       if (operand.i > 0) {
         // SQL:2003 says there must be a newline between string

File: core/src/main/java/org/apache/calcite/sql/util/SqlShuttle.java
Patch:
@@ -94,8 +94,9 @@ public SqlNode visit(SqlNodeList nodeList) {
   //~ Inner Classes ----------------------------------------------------------
 
   /**
-   * Implementation of {@link ArgHandler} which deep-copies {@link SqlCall}s
-   * and their operands.
+   * Implementation of
+   * {@link org.apache.calcite.sql.util.SqlBasicVisitor.ArgHandler}
+   * that deep-copies {@link SqlCall}s and their operands.
    */
   protected class CallCopyingArgHandler implements ArgHandler<SqlNode> {
     boolean update;

File: core/src/main/java/org/apache/calcite/util/ImmutableIntList.java
Patch:
@@ -131,7 +131,7 @@ public <T> T[] toArray(T[] a) {
           : (T[]) Array.newInstance(
               a.getClass().getComponentType(), size);
     }
-    if (a.getClass() == Integer[].class) {
+    if ((Class) a.getClass() == Integer[].class) {
       final Integer[] integers = (Integer[]) a;
       for (int i = 0; i < integers.length; i++) {
         integers[i] = ints[i];

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -22,6 +22,7 @@
 import org.apache.calcite.plan.RelWriterTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTraitTest;
+import org.apache.calcite.rel.RelCollationTest;
 import org.apache.calcite.rex.RexExecutorTest;
 import org.apache.calcite.runtime.BinarySearchTest;
 import org.apache.calcite.runtime.EnumerablesTest;
@@ -64,6 +65,7 @@
     DirectedGraphTest.class,
     ReflectVisitorTest.class,
     RelOptUtilTest.class,
+    RelCollationTest.class,
     UtilTest.class,
     MappingTest.class,
     CalciteResourceTest.class,

File: core/src/test/java/org/apache/calcite/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -64,7 +64,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
 
   @Test public void testCase() {
     that()
-        .with(CalciteAssert.Config.JDBC_FOODMART)
+        .with(CalciteAssert.Config.FOODMART_CLONE)
         .query("select \"day\",\n"
             + " \"week_day\",\n"
             + " case when \"day\" < 3 then upper(\"week_day\")\n"

File: core/src/test/java/org/apache/calcite/tools/FrameworksTest.java
Patch:
@@ -93,13 +93,13 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
                         rexBuilder.makeRangeReference(tableRel), "i", true),
                     rexBuilder.makeExactLiteral(BigDecimal.ONE));
             final LogicalFilter filter =
-                new LogicalFilter(cluster, tableRel, condition);
+                LogicalFilter.create(tableRel, condition);
 
             // Specify that the result should be in Enumerable convention.
             final RelNode rootRel = filter;
             final RelOptPlanner planner = cluster.getPlanner();
-            RelTraitSet desiredTraits = rootRel.getTraitSet().replace(
-                EnumerableConvention.INSTANCE);
+            RelTraitSet desiredTraits =
+                cluster.traitSet().replace(EnumerableConvention.INSTANCE);
             final RelNode rootRel2 = planner.changeTraits(rootRel,
                 desiredTraits);
             planner.setRoot(rootRel2);

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -24,7 +24,7 @@
 import org.apache.calcite.plan.RelTrait;
 import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.InvalidRelException;
-import org.apache.calcite.rel.RelCollationImpl;
+import org.apache.calcite.rel.RelCollations;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.convert.ConverterRule;
 import org.apache.calcite.rel.core.Sort;
@@ -216,7 +216,7 @@ public RelNode convert(RelNode rel) {
           sort.getTraitSet().replace(out)
               .replace(sort.getCollation());
       return new MongoSort(rel.getCluster(), traitSet,
-          convert(sort.getInput(), traitSet.replace(RelCollationImpl.EMPTY)),
+          convert(sort.getInput(), traitSet.replace(RelCollations.EMPTY)),
           sort.getCollation(), sort.offset, sort.fetch);
     }
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * Represents internal state when implementing aggregate functions.
  */
-class AggImpState {
+public class AggImpState {
   public final int aggIdx;
   public final AggregateCall call;
   public final AggImplementor implementor;

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
Patch:
@@ -56,8 +56,6 @@ private EnumUtils() {}
 
   public static final String[] LEFT_RIGHT = {"left", "right"};
 
-  static final boolean B = false;
-
   /** Declares a method that overrides another method. */
   public static MethodDeclaration overridingMethodDecl(Method method,
       Iterable<ParameterExpression> parameters,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableCalc.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.adapter.enumerable;
 
+import org.apache.calcite.DataContext;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.linq4j.Enumerator;
 import org.apache.calcite.linq4j.tree.BlockBuilder;
@@ -144,6 +145,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
             typeFactory,
             builder3,
             physType,
+            DataContext.ROOT,
             new RexToLixTranslator.InputGetterImpl(
                 Collections.singletonList(
                     Pair.of(input, result.physType))),

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
Patch:
@@ -142,7 +142,7 @@ public Statement apply(ParameterExpression input) {
             Expressions.list(root0_),
             block));
     memberDeclarations.add(
-        Expressions.methodDecl(Modifier.PUBLIC, Type.class,
+        Expressions.methodDecl(Modifier.PUBLIC, Class.class,
             BuiltInMethod.TYPED_GET_ELEMENT_TYPE.method.getName(),
             Collections.<ParameterExpression>emptyList(),
             Blocks.toFunctionBlock(

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSort.java
Patch:
@@ -71,8 +71,8 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
                 BuiltInMethod.ORDER_BY.method,
                 Expressions.list(
                     builder.append("keySelector", pair.left))
-                    .appendIfNotNull(builder.appendIfNotNull("comparator",
-                        pair.right)))));
+                    .appendIfNotNull(
+                        builder.appendIfNotNull("comparator", pair.right)))));
     return implementor.result(physType, builder.toBlock());
   }
 }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindowRule.java
Patch:
@@ -23,8 +23,8 @@
 import org.apache.calcite.rel.logical.LogicalWindow;
 
 /**
- * Rule to convert a {@link org.apache.calcite.rel.logical.LogicalAggregate} to
- * an {@link org.apache.calcite.adapter.enumerable.EnumerableAggregate}.
+ * Rule to convert a {@link org.apache.calcite.rel.logical.LogicalWindow} to
+ * an {@link org.apache.calcite.adapter.enumerable.EnumerableWindow}.
  */
 class EnumerableWindowRule extends ConverterRule {
   EnumerableWindowRule() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java
Patch:
@@ -199,7 +199,6 @@ public Expression record(
     Type javaRowClass(
         JavaTypeFactory typeFactory,
         RelDataType type) {
-      assert type.getFieldCount() > 1;
       return Object[].class;
     }
 

File: core/src/main/java/org/apache/calcite/interpreter/Scalar.java
Patch:
@@ -21,6 +21,7 @@
  */
 public interface Scalar {
   Object execute(Context context);
+  void execute(Context context, Object[] results);
 }
 
 // End Scalar.java

File: core/src/main/java/org/apache/calcite/jdbc/CalcitePrepare.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.calcite.runtime.ArrayBindable;
 import org.apache.calcite.runtime.Bindable;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.validate.SqlValidator;
@@ -104,7 +105,7 @@ RelNode flattenTypes(RelOptPlanner planner, RelNode rootRel,
 
     boolean enabled();
 
-    Bindable compile(ClassDeclaration expr, String s);
+    ArrayBindable compile(ClassDeclaration expr, String s);
 
     Object sparkContext();
 
@@ -177,7 +178,7 @@ public boolean enabled() {
         return false;
       }
 
-      public Bindable compile(ClassDeclaration expr, String s) {
+      public ArrayBindable compile(ClassDeclaration expr, String s) {
         throw new UnsupportedOperationException();
       }
 

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -16,8 +16,8 @@
  */
 package org.apache.calcite.prepare;
 
-import org.apache.calcite.adapter.enumerable.EnumerableConvention;
 import org.apache.calcite.adapter.enumerable.EnumerableRel;
+import org.apache.calcite.interpreter.BindableConvention;
 import org.apache.calcite.jdbc.CalcitePrepare;
 import org.apache.calcite.jdbc.CalciteSchema;
 import org.apache.calcite.plan.RelOptMaterialization;
@@ -59,7 +59,7 @@ public CalciteMaterializer(CalcitePrepare.Context context,
       CatalogReader catalogReader, CalciteSchema schema,
       RelOptPlanner planner) {
     super(context, catalogReader, catalogReader.getTypeFactory(), schema,
-        EnumerableRel.Prefer.ANY, planner, EnumerableConvention.INSTANCE);
+        EnumerableRel.Prefer.ANY, planner, BindableConvention.INSTANCE);
   }
 
   /** Populates a materialization record, converting a table path

File: core/src/main/java/org/apache/calcite/rex/RexExecutorImpl.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.util.BuiltInMethod;
+import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
 
@@ -78,7 +79,7 @@ private String compile(RexBuilder rexBuilder, List<RexNode> constExps,
             Expressions.convert_(root0_, DataContext.class)));
     final List<Expression> expressions =
         RexToLixTranslator.translateProjects(programBuilder.getProgram(),
-        javaTypeFactory, blockBuilder, null, getter, null);
+        javaTypeFactory, blockBuilder, null, root_, getter, null);
     blockBuilder.add(
         Expressions.return_(null,
             Expressions.newArrayInit(Object[].class, expressions)));
@@ -88,7 +89,7 @@ private String compile(RexBuilder rexBuilder, List<RexNode> constExps,
             ImmutableList.of(root0_), blockBuilder.toBlock());
     String code = Expressions.toString(methodDecl);
     if (CalcitePrepareImpl.DEBUG) {
-      System.out.println(code);
+      Util.debugCode(System.out, code);
     }
     return code;
   }

File: core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java
Patch:
@@ -80,7 +80,7 @@ private AggregateFunctionImpl(Class<?> declaringClass,
   }
 
   /** Creates an aggregate function, or returns null. */
-  public static AggregateFunction create(Class<?> clazz) {
+  public static AggregateFunctionImpl create(Class<?> clazz) {
     final Method initMethod = ReflectiveFunctionBase.findMethod(clazz, "init");
     final Method addMethod = ReflectiveFunctionBase.findMethod(clazz, "add");
     final Method mergeMethod = null; // TODO:

File: core/src/main/java/org/apache/calcite/sql/SqlKind.java
Patch:
@@ -94,8 +94,8 @@ public enum SqlKind {
    * JOIN operator or compound FROM clause.
    *
    * <p>A FROM clause with more than one table is represented as if it were a
-   * join. For example, "FROM x, y, z" is represented as "JOIN(x, JOIN(x,
-   * y))".</p>
+   * join. For example, "FROM x, y, z" is represented as
+   * "JOIN(x, JOIN(x, y))".</p>
    */
   JOIN,
 

File: core/src/main/java/org/apache/calcite/tools/Programs.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.tools;
 
 import org.apache.calcite.adapter.enumerable.EnumerableRules;
+import org.apache.calcite.interpreter.NoneToBindableConverterRule;
 import org.apache.calcite.plan.RelOptCostImpl;
 import org.apache.calcite.plan.RelOptPlanner;
 import org.apache.calcite.plan.RelOptRule;
@@ -76,6 +77,7 @@ public Program apply(RuleSet ruleSet) {
 
   public static final ImmutableList<RelOptRule> CALC_RULES =
       ImmutableList.of(
+          NoneToBindableConverterRule.INSTANCE,
           EnumerableRules.ENUMERABLE_CALC_RULE,
           EnumerableRules.ENUMERABLE_FILTER_TO_CALC_RULE,
           EnumerableRules.ENUMERABLE_PROJECT_TO_CALC_RULE,

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -2129,6 +2129,7 @@ private CalciteAssert.AssertQuery withFoodMartQuery(int id)
 
   /** Tests that a relatively complex query on the foodmart schema creates
    * an in-memory aggregate table and then uses it. */
+  @Ignore // DO NOT CHECK IN
   @Test public void testFoodmartLattice() throws IOException {
     // 8: select ... from customer, sales, time ... group by ...
     final FoodmartTest.FoodmartQuery query =

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -299,7 +299,7 @@ public Void apply(String materializationName) {
       .enableMaterializations(true)
       .explainContains(""
           + "EnumerableCalc(expr#0..3=[{inputs}], expr#4=[10], expr#5=[*($t3, $t4)], proj#0..2=[{exprs}], US=[$t5])\n"
-          + "  EnumerableAggregate(group=[{0}], C=[$SUM0($2)], Q=[MIN($1)], agg#2=[SUM($4)])\n"
+          + "  EnumerableAggregate(group=[{0}], C=[$SUM0($2)], Q=[MIN($1)], agg#2=[$SUM0($4)])\n"
           + "    EnumerableTableScan(table=[[adhoc, m{27, 31}")
       .returnsUnordered("the_year=1997; C=86837; Q=Q1; US=2667730.0000")
       .sameResultWithMaterializationsDisabled();

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConditionalExpression.java
Patch:
@@ -48,8 +48,9 @@ public ConditionalExpression(List<Node> expressionList, Type type) {
           .append(Blocks.toBlock(expressionList.get(i + 1)));
     }
     if (expressionList.size() % 2 == 1) {
-      writer.append(" else ").append(Blocks.toBlock(expressionList.get(
-          expressionList.size() - 1)));
+      writer.append(" else ")
+          .append(
+              Blocks.toBlock(expressionList.get(expressionList.size() - 1)));
     }
   }
 

File: core/src/test/java/org/apache/calcite/jdbc/CalciteRemoteDriverTest.java
Patch:
@@ -55,8 +55,8 @@ public class CalciteRemoteDriverTest {
 
   private static final CalciteAssert.ConnectionFactory
   REMOTE_CONNECTION_FACTORY =
-      new CalciteAssert.AbstractConnectionFactory() {
-        public Connection createConnection() throws Exception {
+      new CalciteAssert.ConnectionFactory() {
+        public Connection createConnection() throws SQLException {
           return remoteConnection;
         }
       };

File: core/src/test/java/org/apache/calcite/test/FoodmartTest.java
Patch:
@@ -177,7 +177,7 @@ public void testWithLattice() {
       CalciteAssert.that()
           .with(CalciteAssert.Config.JDBC_FOODMART_WITH_LATTICE)
           .pooled()
-          .withSchema("foodmart")
+          .withDefaultSchema("foodmart")
           .query(query.sql)
           .enableMaterializations(true)
           .runs();

File: core/src/test/java/org/apache/calcite/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -229,7 +229,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
   @Test public void testPlan2() {
     that()
         .with(CalciteAssert.Config.JDBC_FOODMART)
-        .withSchema("foodmart")
+        .withDefaultSchema("foodmart")
         .query("select \"customer\".\"state_province\" as \"c0\",\n"
             + " \"customer\".\"country\" as \"c1\"\n"
             + "from \"customer\" as \"customer\"\n"

File: core/src/test/java/org/apache/calcite/test/JdbcFrontJdbcBackTest.java
Patch:
@@ -151,7 +151,7 @@ public Object apply(CalciteConnection a0) {
   @Test public void testCase() {
     that()
         .with(CalciteAssert.Config.JDBC_FOODMART)
-        .withSchema("foodmart")
+        .withDefaultSchema("foodmart")
         .query("select\n"
             + "  case when \"sales_fact_1997\".\"promotion_id\" = 1 then 0\n"
             + "  else \"sales_fact_1997\".\"store_sales\" end as \"c0\"\n"

File: core/src/test/java/org/apache/calcite/test/LatticeTest.java
Patch:
@@ -86,7 +86,7 @@ private CalciteAssert.AssertThat modelWithLattices(String... lattices) {
         + Arrays.toString(lattices)
         + "     }\n"
         + "   ]\n"
-        + "}").withSchema("adhoc");
+        + "}").withDefaultSchema("adhoc");
   }
 
   /** Tests that it's OK for a lattice to have the same name as a table in the
@@ -472,7 +472,7 @@ private void check(int n) throws IOException {
       return;
     }
     foodmartModelWithOneTile()
-        .withSchema("foodmart")
+        .withDefaultSchema("foodmart")
         .query(query.sql)
       .sameResultWithMaterializationsDisabled();
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableModify.java
Patch:
@@ -107,8 +107,8 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
       final int fieldCount =
           childPhysType.getRowType().getFieldCount();
       for (int i = 0; i < fieldCount; i++) {
-        expressionList.add(childPhysType.fieldReference(o_, i,
-            physType.getJavaFieldType(i)));
+        expressionList.add(
+            childPhysType.fieldReference(o_, i, physType.getJavaFieldType(i)));
       }
       convertedChildExp =
           builder.append(

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggAddContextImpl.java
Patch:
@@ -40,8 +40,9 @@ public WinAggAddContextImpl(BlockBuilder block, List<Expression> accumulator,
   }
 
   public final RexToLixTranslator rowTranslator() {
-    return rowTranslator(computeIndex(Expressions.constant(0),
-        WinAggImplementor.SeekType.AGG_INDEX));
+    return rowTranslator(
+        computeIndex(Expressions.constant(0),
+            WinAggImplementor.SeekType.AGG_INDEX));
   }
 
   public final List<Expression> arguments() {

File: core/src/main/java/org/apache/calcite/prepare/Prepare.java
Patch:
@@ -450,8 +450,8 @@ public LogicalTableModify.Operation getTableModOp() {
     }
 
     public List<List<String>> getFieldOrigins() {
-      return Collections.singletonList(Collections.<String>nCopies(
-          4, null));
+      return Collections.singletonList(
+          Collections.<String>nCopies(4, null));
     }
 
     public RelNode getRel() {

File: core/src/main/java/org/apache/calcite/rex/RexBuilder.java
Patch:
@@ -244,8 +244,8 @@ public RexNode makeCall(
   /**
    * Creates a call with a list of arguments.
    *
-   * <p>Equivalent to <code>makeCall(op, exprList.toArray(new
-   * RexNode[exprList.size()]))</code>.
+   * <p>Equivalent to
+   * <code>makeCall(op, exprList.toArray(new RexNode[exprList.size()]))</code>.
    */
   public final RexNode makeCall(
       SqlOperator op,

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -1357,8 +1357,8 @@ private RexNode pull(RexNode rex) {
         for (RexNode operand : operands) {
           list.add(removeFactor(factors, operand));
         }
-        return and(Iterables.concat(factors.values(),
-            ImmutableList.of(or(list))));
+        return and(
+            Iterables.concat(factors.values(), ImmutableList.of(or(list))));
       default:
         return rex;
       }

File: core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
Patch:
@@ -112,8 +112,8 @@ public CallImplementor getImplementor() {
   }
 
   private static CallImplementor createImplementor(final Method method) {
-    return RexImpTable.createImplementor(new ReflectiveCallNotNullImplementor(
-        method), NullPolicy.ANY, false);
+    return RexImpTable.createImplementor(
+        new ReflectiveCallNotNullImplementor(method), NullPolicy.ANY, false);
   }
 }
 

File: core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
Patch:
@@ -46,8 +46,9 @@
  * <p>In its full glory, we will have to support complex type expressions
  * like:</p>
  *
- * <blockquote><code>ROW( NUMBER(5,2) NOT NULL AS foo, ROW( BOOLEAN AS b, MyUDT
- * NOT NULL AS i ) AS rec )</code></blockquote>
+ * <blockquote><code>ROW(<br>
+ *   NUMBER(5, 2) NOT NULL AS foo,<br>
+ *   ROW(BOOLEAN AS b, MyUDT NOT NULL AS i) AS rec)</code></blockquote>
  *
  * <p>Currently it only supports simple datatypes like CHAR, VARCHAR and DOUBLE,
  * with optional precision and scale.</p>

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -652,8 +652,9 @@ private void flattenNullLiteral(
             null);
     for (RelDataTypeField field : flattenedType.getFieldList()) {
       flattenedExps.add(
-          Pair.of(rexBuilder.makeCast(field.getType(),
-                  rexBuilder.constantNull()), field.getName()));
+          Pair.of(
+              rexBuilder.makeCast(field.getType(), rexBuilder.constantNull()),
+              field.getName()));
     }
   }
 

File: core/src/test/java/org/apache/calcite/plan/RelWriterTest.java
Patch:
@@ -179,8 +179,9 @@ public String apply(RelOptCluster cluster,
               }
             });
 
-    assertThat(Util.toLinux(s), is(
-        "LogicalAggregate(group=[{0}], agg#0=[COUNT(DISTINCT $1)], agg#1=[COUNT()])\n"
+    assertThat(Util.toLinux(s),
+        is(
+            "LogicalAggregate(group=[{0}], agg#0=[COUNT(DISTINCT $1)], agg#1=[COUNT()])\n"
             + "  LogicalFilter(condition=[=($1, 10)])\n"
             + "    LogicalTableScan(table=[[hr, emps]])\n"));
   }

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/Blocks.java
Patch:
@@ -59,8 +59,8 @@ public static BlockStatement toBlock(Node body) {
    */
   public static BlockStatement create(Statement statement,
       BlockStatement block) {
-    return Expressions.block(Expressions.list(statement).appendAll(
-        block.statements));
+    return Expressions.block(
+        Expressions.list(statement).appendAll(block.statements));
   }
 
   /**

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -4248,7 +4248,6 @@ public Void apply(RelNode relNode) {
             "deptno=10; deptno=10",
             "deptno=10; deptno=10",
             "deptno=20; deptno=null",
-            "deptno=null; deptno=null",
             "deptno=null; deptno=30",
             "deptno=null; deptno=40");
   }

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/Linq4jTest.java
Patch:
@@ -973,8 +973,7 @@ public String apply(Employee v1, Department v2) {
             + "Eric works in Sales, "
             + "Fred works in Sales, "
             + "Janet works in Sales, "
-            + "null works in HR, "
-            + "null works in null]",
+            + "null works in HR]",
         s);
   }
 

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -274,6 +274,9 @@ public enum BuiltInMethod {
       Timestamp.class),
   TIMESTAMP_TO_LONG_OPTIONAL_OFFSET(SqlFunctions.class, "toLongOptional",
       Timestamp.class, TimeZone.class),
+  SEQUENCE_CURRENT_VALUE(SqlFunctions.class, "sequenceCurrentValue",
+      String.class),
+  SEQUENCE_NEXT_VALUE(SqlFunctions.class, "sequenceNextValue", String.class),
   SLICE(SqlFunctions.class, "slice", List.class),
   ELEMENT(SqlFunctions.class, "element", List.class),
   SELECTIVITY(Selectivity.class, "getSelectivity", RexNode.class),

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -115,6 +115,7 @@ public class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(COVAR_POP)",
           "KEYWORD(COVAR_SAMP)",
           "KEYWORD(CUME_DIST)",
+          "KEYWORD(CURRENT)",
           "KEYWORD(CURRENT_CATALOG)",
           "KEYWORD(CURRENT_DATE)",
           "KEYWORD(CURRENT_DEFAULT_TRANSFORM_GROUP)",
@@ -147,6 +148,7 @@ public class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(MOD)",
           "KEYWORD(MULTISET)",
           "KEYWORD(NEW)",
+          "KEYWORD(NEXT)",
           "KEYWORD(NOT)",
           "KEYWORD(NULL)",
           "KEYWORD(NULLIF)",

File: core/src/main/java/org/apache/calcite/rex/RexUtil.java
Patch:
@@ -583,7 +583,7 @@ public static Pair<String, String> makeKey(RexNode expr) {
    * underlying datatype.
    */
   public static boolean containIdentity(
-      List<RexNode> exprs,
+      List<? extends RexNode> exprs,
       RelDataType rowType,
       boolean fail) {
     final List<RelDataTypeField> fields = rowType.getFieldList();

File: core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
Patch:
@@ -380,7 +380,6 @@ public TrimResult trimFields(
     final RelNode newProject;
     if (ProjectRemoveRule.isIdentity(
         newProjectExprList,
-        newRowType,
         newInput.getRowType())) {
       // The new project would be the identity. It is equivalent to return
       // its child.

File: avatica-server/src/main/java/org/apache/calcite/avatica/server/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Avatica server that listens for HTTP requests.
  */
+@PackageMarker
 package org.apache.calcite.avatica.server;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: avatica/src/main/java/org/apache/calcite/avatica/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Avatica JDBC framework.
  */
+@PackageMarker
 package org.apache.calcite.avatica;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: avatica/src/main/java/org/apache/calcite/avatica/remote/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * JDBC driver that uses remote procedure calls.
  */
+@PackageMarker
 package org.apache.calcite.avatica.remote;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: avatica/src/main/java/org/apache/calcite/avatica/util/package-info.java
Patch:
@@ -18,6 +18,7 @@
 /**
  * Avatica utilities.
  */
+@PackageMarker
 package org.apache.calcite.avatica.util;
 
 // End package-info.java

File: avatica/src/test/java/org/apache/calcite/avatica/test/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Avatica tests.
  */
+@PackageMarker
 package org.apache.calcite.avatica.test;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/clone/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Provides utility classes.
  */
+@PackageMarker
 package org.apache.calcite.adapter.clone;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Calcite-specific classes for implementation of regular and window aggregates.
  */
+@PackageMarker
 package org.apache.calcite.adapter.enumerable.impl;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/enumerable/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Query optimizer rules for Java calling convention.
  */
+@PackageMarker
 package org.apache.calcite.adapter.enumerable;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/java/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Query provider based on Java in-memory data
  * structures.
  */
+@PackageMarker
 package org.apache.calcite.adapter.java;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/jdbc/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Query provider based on a JDBC data source.
  */
+@PackageMarker
 package org.apache.calcite.adapter.jdbc;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/package-info.java
Patch:
@@ -37,6 +37,9 @@
  * </pre>
  * </blockquote>
  */
+@PackageMarker
 package org.apache.calcite.adapter;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/config/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Configuration.
  */
+@PackageMarker
 package org.apache.calcite.config;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/interpreter/package-info.java
Patch:
@@ -22,6 +22,9 @@
  * preparation time is less, and so the total prepare + execute time is
  * competitive for queries over small data sets.
  */
+@PackageMarker
 package org.apache.calcite.interpreter;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/jdbc/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * JDBC driver for Calcite.
  */
+@PackageMarker
 package org.apache.calcite.jdbc;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/materialize/package-info.java
Patch:
@@ -32,6 +32,9 @@
  * instantiating materializations from the intermediate results of queries, and
  * recognize what materializations would be useful based on actual query load.
  */
+@PackageMarker
 package org.apache.calcite.materialize;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/model/package-info.java
Patch:
@@ -34,6 +34,9 @@
  * <a href="https://github.com/julianhyde/blog/master/optiq-csv/TUTORIAL.md">optiq-csv
  * tutorial</a>.
  */
+@PackageMarker
 package org.apache.calcite.model;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Main package for Calcite, the dynamic data management platform.
  */
+@PackageMarker
 package org.apache.calcite;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/plan/hep/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Provides a heuristic planner implementation for the interfaces in
  * {@link org.apache.calcite.plan}.
  */
+@PackageMarker
 package org.apache.calcite.plan.hep;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/plan/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Defines interfaces for constructing rule-based optimizers of
  * relational expressions.
  */
+@PackageMarker
 package org.apache.calcite.plan;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/plan/volcano/package-info.java
Patch:
@@ -268,6 +268,9 @@
  *     McKenna
  *     (1993)</a>.</p>
  */
+@PackageMarker
 package org.apache.calcite.plan.volcano;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/prepare/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Preparation of queries (parsing, planning and implementation).
  */
+@PackageMarker
 package org.apache.calcite.prepare;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/convert/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Defines relational expressions and rules for converting between calling
  * conventions.
  */
+@PackageMarker
 package org.apache.calcite.rel.convert;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/core/package-info.java
Patch:
@@ -31,6 +31,9 @@
  *
  * </ul>
  */
+@PackageMarker
 package org.apache.calcite.rel.core;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/externalize/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Facilities to externalize {@link org.apache.calcite.rel.RelNode}s to and from
  * XML and JSON format.
  */
+@PackageMarker
 package org.apache.calcite.rel.externalize;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/jdbc/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Contains query transformation rules relating to generating SQL for
  * foreign JDBC databases.
  */
+@PackageMarker
 package org.apache.calcite.rel.jdbc;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/logical/package-info.java
Patch:
@@ -31,6 +31,9 @@
  *
  * </ul>
  */
+@PackageMarker
 package org.apache.calcite.rel.logical;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/metadata/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Defines metadata interfaces and utilities for relational
  * expressions.
  */
+@PackageMarker
 package org.apache.calcite.rel.metadata;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/package-info.java
Patch:
@@ -35,6 +35,9 @@
  *
  * </ul>
  */
+@PackageMarker
 package org.apache.calcite.rel;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/rules/package-info.java
Patch:
@@ -47,6 +47,9 @@
  *        provides an optimizer interface.</li>
  * </ul>
  */
+@PackageMarker
 package org.apache.calcite.rel.rules;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/type/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Defines a type system for relational expressions.
  */
+@PackageMarker
 package org.apache.calcite.rel.type;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rex/package-info.java
Patch:
@@ -79,6 +79,9 @@
  *
  * </ul>
  */
+@PackageMarker
 package org.apache.calcite.rex;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/runtime/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Utilities required at runtime.
  */
+@PackageMarker
 package org.apache.calcite.runtime;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/schema/impl/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Utilities to help implement Calcite's SPIs.
  */
+@PackageMarker
 package org.apache.calcite.schema.impl;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/schema/package-info.java
Patch:
@@ -22,6 +22,9 @@
  * SQL validator to validate SQL abstract syntax trees and resolve
  * identifiers to objects.
  */
+@PackageMarker
 package org.apache.calcite.schema;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/server/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Provides a server for hosting Calcite connections.
  */
+@PackageMarker
 package org.apache.calcite.server;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/advise/package-info.java
Patch:
@@ -24,6 +24,9 @@
  * <p>The advisor uses the validation and parser framework set up in
  * <code>org.apache.calcite.sql.validate</code> package.
 */
+@PackageMarker
 package org.apache.calcite.sql.advise;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/fun/package-info.java
Patch:
@@ -27,6 +27,9 @@
  * which are not row-level (e.g. select and join) should be defined in package
  * {@link org.apache.calcite.sql} instead.</p>
  */
+@PackageMarker
 package org.apache.calcite.sql.fun;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/package-info.java
Patch:
@@ -92,6 +92,9 @@
  * {@link org.apache.calcite.sql.SqlNode}s into a SQL string. A
  * {@link org.apache.calcite.sql.SqlDialect} defines how this happens.</p>
  */
+@PackageMarker
 package org.apache.calcite.sql;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/parser/impl/package-info.java
Patch:
@@ -19,6 +19,9 @@
  * Contains generated code for the
  * {@link org.apache.calcite.sql.parser Calcite SQL parser}.
  */
+@PackageMarker
 package org.apache.calcite.sql.parser.impl;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/parser/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Provides a SQL parser.
  */
+@PackageMarker
 package org.apache.calcite.sql.parser;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/pretty/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Provides a pretty-printer for SQL statements.
  */
+@PackageMarker
 package org.apache.calcite.sql.pretty;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/type/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * SQL type system.
  */
+@PackageMarker
 package org.apache.calcite.sql.type;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/util/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Utility classes for the SQL object model, parsing, and validation.
  */
+@PackageMarker
 package org.apache.calcite.sql.util;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql/validate/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * SQL validation.
  */
+@PackageMarker
 package org.apache.calcite.sql.validate;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/sql2rel/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Translates a SQL parse tree to relational expression.
  */
+@PackageMarker
 package org.apache.calcite.sql2rel;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/tools/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Provides utility classes.
  */
+@PackageMarker
 package org.apache.calcite.tools;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/util/graph/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Graph-theoretic algorithms and data structures.
  */
+@PackageMarker
 package org.apache.calcite.util.graph;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/util/javac/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Provides compilers for Java code.
  */
+@PackageMarker
 package org.apache.calcite.util.javac;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/util/mapping/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Support for algebraic maps.
  */
+@PackageMarker
 package org.apache.calcite.util.mapping;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/util/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Provides utility classes.
  */
+@PackageMarker
 package org.apache.calcite.util;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/main/java/org/apache/calcite/util/trace/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Tracing services.
  */
+@PackageMarker
 package org.apache.calcite.util.trace;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/test/java/org/apache/calcite/sql/test/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Regression tests for the SQL model.
  */
+@PackageMarker
 package org.apache.calcite.sql.test;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/test/java/org/apache/calcite/test/concurrent/package-info.java
Patch:
@@ -314,6 +314,9 @@
  *         </ul>
  *
  */
+@PackageMarker
 package org.apache.calcite.test.concurrent;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/test/java/org/apache/calcite/test/enumerable/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Tests for Enumerable convention runtime.
  */
+@PackageMarker
 package org.apache.calcite.test.enumerable;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/test/java/org/apache/calcite/test/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Tests for Calcite.
  */
+@PackageMarker
 package org.apache.calcite.test;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: example/csv/src/main/java/org/apache/calcite/adapter/csv/package-info.java
Patch:
@@ -22,6 +22,9 @@
  * directory appears as a table.  Full SQL operations are available on
  * those tables.</p>
  */
+@PackageMarker
 package org.apache.calcite.adapter.csv;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: linq4j/src/main/java/org/apache/calcite/linq4j/function/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Contains definitions of functions and predicates.
  */
+@PackageMarker
 package org.apache.calcite.linq4j.function;
 
+import org.apache.calcite.linq4j.PackageMarker;
+
 // End package-info.java

File: linq4j/src/main/java/org/apache/calcite/linq4j/package-info.java
Patch:
@@ -18,6 +18,7 @@
 /**
  * Language-integrated query for Java (linq4j) main package.
  */
+@PackageMarker
 package org.apache.calcite.linq4j;
 
 // End package-info.java

File: linq4j/src/main/java/org/apache/calcite/linq4j/tree/package-info.java
Patch:
@@ -25,6 +25,9 @@
  * efficiency; for example, it may attempt to push down filters to the
  * source SQL system.</p>
  */
+@PackageMarker
 package org.apache.calcite.linq4j.tree;
 
+import org.apache.calcite.linq4j.PackageMarker;
+
 // End package-info.java

File: linq4j/src/test/java/com/example/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Examples of using linq4j.
  */
+@PackageMarker
 package com.example;
 
+import org.apache.calcite.linq4j.PackageMarker;
+
 // End package-info.java

File: linq4j/src/test/java/org/apache/calcite/linq4j/function/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Tests for functions.
  */
+@PackageMarker
 package org.apache.calcite.linq4j.function;
 
+import org.apache.calcite.linq4j.PackageMarker;
+
 // End package-info.java

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Core linq4j tests.
  */
+@PackageMarker
 package org.apache.calcite.linq4j.test;
 
+import org.apache.calcite.linq4j.PackageMarker;
+
 // End package-info.java

File: linq4j/src/test/java/org/apache/calcite/linq4j/tree/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Tests for expressions.
  */
+@PackageMarker
 package org.apache.calcite.linq4j.tree;
 
+import org.apache.calcite.linq4j.PackageMarker;
+
 // End package-info.java

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Query provider based on a MongoDB database.
  */
+@PackageMarker
 package org.apache.calcite.adapter.mongodb;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: plus/src/main/java/org/apache/calcite/adapter/tpcds/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * TPC-DS schema.
  */
+@PackageMarker
 package org.apache.calcite.adapter.tpcds;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: plus/src/main/java/org/apache/calcite/adapter/tpch/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * TPC-H schema.
  */
+@PackageMarker
 package org.apache.calcite.adapter.tpch;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: spark/src/main/java/org/apache/calcite/adapter/spark/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Adapter based on the Apache Spark data management system.
  */
+@PackageMarker
 package org.apache.calcite.adapter.spark;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/package-info.java
Patch:
@@ -22,6 +22,9 @@
  * "host", "index", "source", "sourcetype". It has a variable type, so other
  * fields are held in a map field called "_others".</p>
  */
+@PackageMarker
 package org.apache.calcite.adapter.splunk;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/search/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Executes queries via Splunk's REST API.
  */
+@PackageMarker
 package org.apache.calcite.adapter.splunk.search;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/util/package-info.java
Patch:
@@ -18,6 +18,9 @@
 /**
  * Utilities for RPC to Splunk.
  */
+@PackageMarker
 package org.apache.calcite.adapter.splunk.util;
 
+import org.apache.calcite.avatica.util.PackageMarker;
+
 // End package-info.java

File: core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCorrelateTest.java
Patch:
@@ -41,7 +41,7 @@ public class EnumerableCorrelateTest {
             "EnumerableCalc(expr#0..4=[{inputs}], empid=[$t0], name=[$t2])\n"
             + "  EnumerableSemiJoin(condition=[=($1, $5)], joinType=[inner])\n"
             + "    EnumerableTableScan(table=[[s, emps]])\n"
-            + "    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[true], $f01=[$t0], $f0=[$t4])\n"
+            + "    EnumerableCalc(expr#0..4=[{inputs}], expr#5=[true], $f01=[$t0], $f0=[$t5])\n"
             + "      EnumerableJoin(condition=[=($0, $1)], joinType=[inner])\n"
             + "        EnumerableAggregate(group=[{0}])\n"
             + "          EnumerableCalc(expr#0..4=[{inputs}], $f0=[$t1])\n"
@@ -63,7 +63,7 @@ public class EnumerableCorrelateTest {
             + "  EnumerableCorrelate(correlation=[$cor0], joinType=[LEFT], requiredColumns=[{1}])\n"
             + "    EnumerableTableScan(table=[[s, emps]])\n"
             + "    EnumerableAggregate(group=[{}], agg#0=[MIN($0)])\n"
-            + "      EnumerableCalc(expr#0..2=[{inputs}], expr#3=[true], expr#4=[$cor0], expr#5=[$t4.deptno], expr#6=[=($t0, $t5)], $f0=[$t3], $condition=[$t6])\n"
+            + "      EnumerableCalc(expr#0..3=[{inputs}], expr#4=[true], expr#5=[$cor0], expr#6=[$t5.deptno], expr#7=[=($t0, $t6)], $f0=[$t4], $condition=[$t7])\n"
             + "        EnumerableTableScan(table=[[s, depts]])")
         .returnsUnordered(
             "empid=100; name=Bill",

File: splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkTableScan.java
Patch:
@@ -104,7 +104,7 @@ protected SplunkTableScan(
         getCluster().getTypeFactory().builder();
     for (String field : fieldList) {
       // REVIEW: is case-sensitive match what we want here?
-      builder.add(table.getRowType().getField(field, true));
+      builder.add(table.getRowType().getField(field, true, false));
     }
     return builder.build();
   }

File: core/src/test/java/org/apache/calcite/runtime/EnumerablesTest.java
Patch:
@@ -218,8 +218,9 @@ public T apply(T v0, T v1) {
   @Test public void testThetaFullJoinLeftEmpty() {
     assertThat(
         Enumerables.thetaJoin(EMPS.take(0), DEPTS, EQUAL_DEPTNO,
-            EMP_DEPT_TO_STRING, true, true).toList().toString(),
-        equalTo("[{null, null, 20, Sales}, {null, null, 15, Marketing}]"));
+            EMP_DEPT_TO_STRING, true, true)
+            .orderBy(Functions.<String>identitySelector()).toList().toString(),
+        equalTo("[{null, null, 15, Marketing}, {null, null, 20, Sales}]"));
   }
 
   @Test public void testThetaFullJoinRightEmpty() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexToLixTranslator.java
Patch:
@@ -743,7 +743,7 @@ public static Expression convert(Expression operand, Type toType) {
         return Expressions.convert_(
             operand, toPrimitive.primitiveClass);
       }
-      if (fromNumber) {
+      if (fromNumber || fromBox == Primitive.CHAR) {
         // Generate "x.shortValue()".
         return Expressions.unbox(operand, toPrimitive);
       } else {

File: core/src/main/java/org/apache/calcite/rel/rules/ValuesReduceRule.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.rel.rules;
 
+import org.apache.calcite.plan.RelOptPredicateList;
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.plan.RelOptRuleOperand;
@@ -172,7 +173,8 @@ protected void apply(RelOptRuleCall call, LogicalProject project,
     assert reducibleExps.size() == (values.getTuples().size() * fieldsPerRow);
 
     // Compute the values they reduce to.
-    ReduceExpressionsRule.reduceExpressions(values, reducibleExps);
+    final RelOptPredicateList predicates = RelOptPredicateList.EMPTY;
+    ReduceExpressionsRule.reduceExpressions(values, reducibleExps, predicates);
 
     int changeCount = 0;
     final ImmutableList.Builder<ImmutableList<RexLiteral>> tuplesBuilder =

File: core/src/main/java/org/apache/calcite/rex/RexExecutorImpl.java
Patch:
@@ -57,6 +57,7 @@ private String compile(RexBuilder rexBuilder, List<RexNode> constExps,
     final RelDataType emptyRowType = typeFactory.builder().build();
     return compile(rexBuilder, constExps, getter, emptyRowType);
   }
+
   private String compile(RexBuilder rexBuilder, List<RexNode> constExps,
       RexToLixTranslator.InputGetter getter, RelDataType rowType) {
     final RexProgramBuilder programBuilder =

File: core/src/main/java/org/apache/calcite/rel/BiRel.java
Patch:
@@ -75,8 +75,7 @@ public void replaceInput(
     recomputeDigest();
   }
 
-  @Override
-  public RelWriter explainTerms(RelWriter pw) {
+  @Override public RelWriter explainTerms(RelWriter pw) {
     return super.explainTerms(pw)
         .input("left", left)
         .input("right", right);

File: core/src/main/java/org/apache/calcite/rel/core/CorrelationId.java
Patch:
@@ -88,4 +88,4 @@ public int compareTo(CorrelationId other) {
   }
 }
 
-// End Correlation.java
+// End CorrelationId.java

File: core/src/main/java/org/apache/calcite/rel/rules/JoinToCorrelateRule.java
Patch:
@@ -108,8 +108,7 @@ public void onMatch(RelOptRuleCall call) {
 
     // Replace all references of left input with FieldAccess(corrVar, field)
     joinCondition = joinCondition.accept(new RexShuttle() {
-      @Override
-      public RexNode visitInputRef(RexInputRef input) {
+      @Override public RexNode visitInputRef(RexInputRef input) {
         int field = input.getIndex();
         if (field >= leftFieldCount) {
           return rexBuilder.makeInputRef(input.getType(),

File: core/src/main/java/org/apache/calcite/sql2rel/DeduplicateCorrelateVariables.java
Patch:
@@ -47,8 +47,7 @@ public DeduplicateCorrelateVariablesShuttle(RexBuilder builder,
       this.altNames = altNames;
     }
 
-    @Override
-    public RexNode visitCorrelVariable(RexCorrelVariable variable) {
+    @Override public RexNode visitCorrelVariable(RexCorrelVariable variable) {
       if (!altNames.contains(variable.getName())) {
         return variable;
       }

File: core/src/main/java/org/apache/calcite/sql/fun/SqlItemOperator.java
Patch:
@@ -128,7 +128,8 @@ private SqlSingleOperandTypeChecker getChecker(RelDataType operandType) {
       return typeFactory.createTypeWithNullability(operandType.getValueType(),
           true);
     case ANY:
-      return typeFactory.createSqlType(SqlTypeName.ANY);
+      return typeFactory.createTypeWithNullability(
+          typeFactory.createSqlType(SqlTypeName.ANY), true);
     default:
       throw new AssertionError();
     }

File: core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -4296,6 +4296,9 @@ public Void apply(Holder<Long> o) {
         "map['foo', CAST(NULL AS INTEGER), 'bar', 7]['baz']",
         "INTEGER",
         null);
+    tester.checkColumnType(
+        "select cast(null as any)['x'] from (values(1))",
+        "ANY");
   }
 
   @Test public void testMapValueConstructor() {

File: avatica/src/main/java/org/apache/calcite/avatica/MetaImpl.java
Patch:
@@ -187,7 +187,8 @@ protected static ColumnMetaData columnMetaData(String name, int index,
             ? DatabaseMetaData.columnNullable
             : DatabaseMetaData.columnNoNulls,
         true, -1, name, name, null,
-        0, 0, null, null, scalarType, true, false, false, null);
+        0, 0, null, null, scalarType, true, false, false,
+        scalarType.columnClassName());
   }
 
   protected static ColumnMetaData.StructType fieldMetaData(Class clazz) {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableCalcRule.java
Patch:
@@ -52,7 +52,6 @@ public RelNode convert(RelNode rel) {
             calc.getInput(),
             calc.getInput().getTraitSet()
                 .replace(EnumerableConvention.INSTANCE)),
-        calc.getRowType(),
         program,
         calc.getCollationList());
   }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableFilterToCalcRule.java
Patch:
@@ -52,7 +52,6 @@ public void onMatch(RelOptRuleCall call) {
             filter.getCluster(),
             filter.getTraitSet(),
             rel,
-            inputRowType,
             program,
             ImmutableList.<RelCollation>of());
     call.transformTo(calc);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableProjectToCalcRule.java
Patch:
@@ -20,7 +20,6 @@
 import org.apache.calcite.plan.RelOptRuleCall;
 import org.apache.calcite.rel.RelCollation;
 import org.apache.calcite.rel.RelNode;
-import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexProgram;
 
 import com.google.common.collect.ImmutableList;
@@ -35,7 +34,6 @@ public class EnumerableProjectToCalcRule extends RelOptRule {
   public void onMatch(RelOptRuleCall call) {
     final EnumerableProject project = call.rel(0);
     final RelNode child = project.getInput();
-    final RelDataType rowType = project.getRowType();
     final RexProgram program =
         RexProgram.create(child.getRowType(),
             project.getProjects(),
@@ -47,7 +45,6 @@ public void onMatch(RelOptRuleCall call) {
             project.getCluster(),
             project.getTraitSet(),
             child,
-            rowType,
             program,
             ImmutableList.<RelCollation>of());
     call.transformTo(calc);

File: core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
Patch:
@@ -2834,7 +2834,6 @@ public static RelNode permute(
         rel.getCluster(),
         rel.getTraitSet(),
         rel,
-        program.getOutputRowType(),
         program,
         ImmutableList.<RelCollation>of());
   }

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
Patch:
@@ -82,8 +82,8 @@ public static RelNode create(
       RelOptCluster cluster,
       RelTraitSet traitSet,
       RelNode child,
-      final RexProgram program,
-      RelDataType outRowType) {
+      final RexProgram program) {
+    final RelDataType outRowType = program.getOutputRowType();
     // Build a list of distinct groups, partitions and aggregate
     // functions.
     final Multimap<WindowKey, RexOver> windowMap =

File: core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
Patch:
@@ -224,7 +224,6 @@ RelNode execute() {
           relType.makeRel(
               cluster,
               traits,
-              program1.getOutputRowType(),
               rel,
               program1);
 
@@ -773,14 +772,12 @@ protected boolean supportsCondition() {
     protected RelNode makeRel(
         RelOptCluster cluster,
         RelTraitSet traits,
-        RelDataType rowType,
         RelNode child,
         RexProgram program) {
       return new LogicalCalc(
           cluster,
           traits,
           child,
-          rowType,
           program,
           Collections.<RelCollation>emptyList());
     }

File: core/src/main/java/org/apache/calcite/rel/rules/FilterCalcMergeRule.java
Patch:
@@ -87,7 +87,6 @@ public void onMatch(RelOptRuleCall call) {
             calc.getCluster(),
             calc.getTraitSet(),
             calc.getInput(),
-            filter.getRowType(),
             mergedProgram,
             Collections.<RelCollation>emptyList());
     call.transformTo(newCalc);

File: core/src/main/java/org/apache/calcite/rel/rules/FilterToCalcRule.java
Patch:
@@ -74,7 +74,6 @@ public void onMatch(RelOptRuleCall call) {
             filter.getCluster(),
             filter.getTraitSet(),
             rel,
-            inputRowType,
             program,
             ImmutableList.<RelCollation>of());
     call.transformTo(calc);

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectCalcMergeRule.java
Patch:
@@ -83,7 +83,6 @@ public void onMatch(RelOptRuleCall call) {
               cluster,
               project.getTraitSet(),
               calc,
-              project.getRowType(),
               program,
               Collections.<RelCollation>emptyList());
       call.transformTo(projectAsCalc);
@@ -113,7 +112,6 @@ public void onMatch(RelOptRuleCall call) {
             cluster,
             project.getTraitSet(),
             calc.getInput(),
-            project.getRowType(),
             mergedProgram,
             Collections.<RelCollation>emptyList());
     call.transformTo(newCalc);

File: core/src/main/java/org/apache/calcite/rel/rules/ProjectToCalcRule.java
Patch:
@@ -22,7 +22,6 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.logical.LogicalCalc;
 import org.apache.calcite.rel.logical.LogicalProject;
-import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexProgram;
 
 import com.google.common.collect.ImmutableList;
@@ -57,7 +56,6 @@ private ProjectToCalcRule() {
   public void onMatch(RelOptRuleCall call) {
     final LogicalProject project = call.rel(0);
     final RelNode child = project.getInput();
-    final RelDataType rowType = project.getRowType();
     final RexProgram program =
         RexProgram.create(
             child.getRowType(),
@@ -70,7 +68,6 @@ public void onMatch(RelOptRuleCall call) {
             project.getCluster(),
             project.getTraitSet(),
             child,
-            rowType,
             program,
             ImmutableList.<RelCollation>of());
     call.transformTo(calc);

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
Patch:
@@ -115,7 +115,6 @@ public void onMatch(RelOptRuleCall call) {
             calc.getCluster(),
             calc.getTraitSet(),
             calc.getInput(),
-            newProgram.getOutputRowType(),
             newProgram,
             Collections.<RelCollation>emptyList());
     call.transformTo(newCalc);

File: core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -277,7 +277,6 @@ public RexNode visitLocalRef(RexLocalRef localRef) {
                     calc.getCluster(),
                     calc.getTraitSet(),
                     calc.getInput(),
-                    calc.getRowType(),
                     builder.getProgram(),
                     calc.getCollationList()));
 

File: core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -548,7 +548,6 @@ public void rewriteRel(LogicalCalc rel) {
             cluster,
             rel.getTraitSet(),
             newChild,
-            newProgram.getOutputRowType(),
             newProgram,
             Collections.<RelCollation>emptyList());
     setNewForOldRel(rel, newRel);

File: core/src/main/java/org/apache/calcite/adapter/enumerable/AggAddContext.java
Patch:
@@ -50,6 +50,8 @@ public interface AggAddContext extends AggResultContext {
    * Returns a
    * {@link org.apache.calcite.adapter.enumerable.RexToLixTranslator}
    * suitable to transform the arguments.
+   *
+   * @return {@link RexToLixTranslator} suitable to transform the arguments
    */
   RexToLixTranslator rowTranslator();
 }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRel.java
Patch:
@@ -66,6 +66,7 @@ public RelNode createProject(RelNode child,
    *
    * @param implementor Implementor
    * @param pref Preferred representation for rows in result expression
+   * @return Plan for this expression according to a calling convention
    */
   Result implement(EnumerableRelImplementor implementor, Prefer pref);
 

File: core/src/main/java/org/apache/calcite/plan/RelTrait.java
Patch:
@@ -62,6 +62,9 @@ public interface RelTrait {
    *
    * <p>Many traits cannot be substituted, in which case, this method should
    * return {@code equals(trait)}.</p>
+   *
+   * @param trait Given trait
+   * @return Whether this trait subsumes a given trait
    */
   boolean subsumes(RelTrait trait);
 

File: core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
Patch:
@@ -285,6 +285,7 @@ public void explain(RelWriter pw) {
    * methods for each input and attribute.
    *
    * @param pw Plan writer
+   * @return Plan writer for fluent-explain pattern
    */
   public RelWriter explainTerms(RelWriter pw) {
     return pw;
@@ -351,6 +352,8 @@ public RelOptTable getTable() {
 
   /**
    * Computes the digest. Does not modify this object.
+   *
+   * @return Digest
    */
   protected String computeDigest() {
     StringWriter sw = new StringWriter();

File: core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
Patch:
@@ -92,6 +92,9 @@ public RelTraitDef getTraitDef() {
    *
    * <p>The union-to-java converter, for example, is not guaranteed, because
    * it only works on unions.</p>
+   *
+   * @return {@code true} if this rule can convert <em>any</em> relational
+   *   expression
    */
   public boolean isGuaranteed() {
     return false;

File: core/src/main/java/org/apache/calcite/rel/core/SetOp.java
Patch:
@@ -125,6 +125,8 @@ public abstract SetOp copy(
    *
    * @param compareNames Whether column names are important in the
    *                     homogeneity comparison
+   * @return Whether all the inputs of this set operator have the same row
+   *   type as its output row
    */
   public boolean isHomogeneous(boolean compareNames) {
     RelDataType unionType = getRowType();

File: core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
Patch:
@@ -43,6 +43,8 @@ public interface RelDataTypeFactory {
 
   /**
    * Returns the type system.
+   *
+   * @return Type system
    */
   RelDataTypeSystem getTypeSystem();
 

File: core/src/main/java/org/apache/calcite/schema/SchemaFactory.java
Patch:
@@ -66,6 +66,7 @@ public interface SchemaFactory {
    * @param parentSchema Parent schema
    * @param name Name of this schema
    * @param operand The "operand" JSON property
+   * @return Created schema
    */
   Schema create(
       SchemaPlus parentSchema,

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRules.java
Patch:
@@ -36,6 +36,9 @@ public class EnumerableRules {
   public static final RelOptRule ENUMERABLE_SEMI_JOIN_RULE =
       new EnumerableSemiJoinRule();
 
+  public static final RelOptRule ENUMERABLE_CORRELATE_RULE =
+      new EnumerableCorrelateRule();
+
   private EnumerableRules() {
   }
 

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfig.java
Patch:
@@ -44,6 +44,8 @@ public interface CalciteConnectionConfig extends ConnectionConfig {
   boolean caseSensitive();
   /** @see CalciteConnectionProperty#SPARK */
   boolean spark();
+  /** @see CalciteConnectionProperty#FORCE_DECORRELATE */
+  boolean forceDecorrelate();
   /** @see CalciteConnectionProperty#TYPE_SYSTEM */
   <T> T typeSystem(Class<T> typeSystemClass, T defaultTypeSystem);
 }

File: core/src/main/java/org/apache/calcite/prepare/CalciteMaterializer.java
Patch:
@@ -26,11 +26,11 @@
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelShuttle;
-import org.apache.calcite.rel.core.Correlator;
 import org.apache.calcite.rel.core.Sort;
 import org.apache.calcite.rel.core.TableFunctionScan;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.logical.LogicalAggregate;
+import org.apache.calcite.rel.logical.LogicalCorrelate;
 import org.apache.calcite.rel.logical.LogicalFilter;
 import org.apache.calcite.rel.logical.LogicalIntersect;
 import org.apache.calcite.rel.logical.LogicalJoin;
@@ -159,8 +159,8 @@ public RelNode visit(LogicalProject project) {
     public RelNode visit(LogicalJoin join) {
       return join;
     }
-    public RelNode visit(Correlator correlator) {
-      return correlator;
+    public RelNode visit(LogicalCorrelate correlate) {
+      return correlate;
     }
     public RelNode visit(LogicalUnion union) {
       return union;

File: core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
Patch:
@@ -168,6 +168,7 @@ public class CalcitePrepareImpl implements CalcitePrepare {
       ImmutableList.of(
           EnumerableRules.ENUMERABLE_JOIN_RULE,
           EnumerableRules.ENUMERABLE_SEMI_JOIN_RULE,
+          EnumerableRules.ENUMERABLE_CORRELATE_RULE,
           EnumerableRules.ENUMERABLE_PROJECT_RULE,
           EnumerableRules.ENUMERABLE_FILTER_RULE,
           EnumerableRules.ENUMERABLE_AGGREGATE_RULE,

File: core/src/main/java/org/apache/calcite/rel/RelShuttle.java
Patch:
@@ -16,11 +16,11 @@
  */
 package org.apache.calcite.rel;
 
-import org.apache.calcite.rel.core.Correlator;
 import org.apache.calcite.rel.core.Sort;
 import org.apache.calcite.rel.core.TableFunctionScan;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.logical.LogicalAggregate;
+import org.apache.calcite.rel.logical.LogicalCorrelate;
 import org.apache.calcite.rel.logical.LogicalFilter;
 import org.apache.calcite.rel.logical.LogicalIntersect;
 import org.apache.calcite.rel.logical.LogicalJoin;
@@ -45,7 +45,7 @@ public interface RelShuttle {
 
   RelNode visit(LogicalJoin join);
 
-  RelNode visit(Correlator correlator);
+  RelNode visit(LogicalCorrelate correlate);
 
   RelNode visit(LogicalUnion union);
 

File: core/src/main/java/org/apache/calcite/rel/RelShuttleImpl.java
Patch:
@@ -17,11 +17,11 @@
 package org.apache.calcite.rel;
 
 import org.apache.calcite.linq4j.Ord;
-import org.apache.calcite.rel.core.Correlator;
 import org.apache.calcite.rel.core.Sort;
 import org.apache.calcite.rel.core.TableFunctionScan;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.logical.LogicalAggregate;
+import org.apache.calcite.rel.logical.LogicalCorrelate;
 import org.apache.calcite.rel.logical.LogicalFilter;
 import org.apache.calcite.rel.logical.LogicalIntersect;
 import org.apache.calcite.rel.logical.LogicalJoin;
@@ -97,8 +97,8 @@ public RelNode visit(LogicalJoin join) {
     return visitChildren(join);
   }
 
-  public RelNode visit(Correlator correlator) {
-    return visitChildren(correlator);
+  public RelNode visit(LogicalCorrelate correlate) {
+    return visitChildren(correlate);
   }
 
   public RelNode visit(LogicalUnion union) {

File: core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
Patch:
@@ -33,7 +33,8 @@
  * relation.
  *
  * <p>Like its inverse operation {@link Collect}, Uncollect is generally
- * invoked in a nested loop, driven by {@link Correlator} or similar.
+ * invoked in a nested loop, driven by
+ * {@link org.apache.calcite.rel.logical.LogicalCorrelate} or similar.
  */
 public class Uncollect extends SingleRel {
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Aggregate;
-import org.apache.calcite.rel.core.Correlator;
+import org.apache.calcite.rel.core.Correlate;
 import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinInfo;
@@ -72,7 +72,7 @@ public Boolean areColumnsUnique(
   }
 
   public Boolean areColumnsUnique(
-      Correlator rel,
+      Correlate rel,
       ImmutableBitSet columns,
       boolean ignoreNulls) {
     return RelMetadataQuery.areColumnsUnique(

File: core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
Patch:
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Aggregate;
-import org.apache.calcite.rel.core.Correlator;
+import org.apache.calcite.rel.core.Correlate;
 import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.core.Join;
 import org.apache.calcite.rel.core.JoinInfo;
@@ -62,7 +62,7 @@ public Set<ImmutableBitSet> getUniqueKeys(Sort rel, boolean ignoreNulls) {
     return RelMetadataQuery.getUniqueKeys(rel.getInput(), ignoreNulls);
   }
 
-  public Set<ImmutableBitSet> getUniqueKeys(Correlator rel,
+  public Set<ImmutableBitSet> getUniqueKeys(Correlate rel,
       boolean ignoreNulls) {
     return RelMetadataQuery.getUniqueKeys(rel.getLeft(), ignoreNulls);
   }

File: core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
Patch:
@@ -20,6 +20,7 @@
 import org.apache.calcite.plan.RelOptUtil;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.Join;
+import org.apache.calcite.rel.core.SemiJoin;
 import org.apache.calcite.rel.core.SetOp;
 import org.apache.calcite.rel.logical.LogicalProject;
 import org.apache.calcite.rel.type.RelDataTypeField;
@@ -213,7 +214,7 @@ public PushProjector(
       List<RelDataTypeField> rightFields =
           joinRel.getRight().getRowType().getFieldList();
       nFields = leftFields.size();
-      nFieldsRight = rightFields.size();
+      nFieldsRight = childRel instanceof SemiJoin ? 0 : rightFields.size();
       nSysFields = joinRel.getSystemFieldList().size();
       childBitmap =
           ImmutableBitSet.range(nSysFields, nFields + nSysFields);

File: core/src/main/java/org/apache/calcite/rex/RexExecutorImpl.java
Patch:
@@ -77,7 +77,7 @@ private String compile(RexBuilder rexBuilder, List<RexNode> constExps,
             Expressions.convert_(root0_, DataContext.class)));
     final List<Expression> expressions =
         RexToLixTranslator.translateProjects(programBuilder.getProgram(),
-        javaTypeFactory, blockBuilder, null, getter);
+        javaTypeFactory, blockBuilder, null, getter, null);
     blockBuilder.add(
         Expressions.return_(null,
             Expressions.newArrayInit(Object[].class, expressions)));

File: core/src/main/java/org/apache/calcite/tools/Programs.java
Patch:
@@ -100,6 +100,7 @@ public Program apply(RuleSet ruleSet) {
       ImmutableSet.of(
           EnumerableRules.ENUMERABLE_JOIN_RULE,
           EnumerableRules.ENUMERABLE_SEMI_JOIN_RULE,
+          EnumerableRules.ENUMERABLE_CORRELATE_RULE,
           EnumerableRules.ENUMERABLE_PROJECT_RULE,
           EnumerableRules.ENUMERABLE_FILTER_RULE,
           EnumerableRules.ENUMERABLE_AGGREGATE_RULE,

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.calcite.avatica.util.TimeUnitRange;
 import org.apache.calcite.interpreter.Row;
 import org.apache.calcite.linq4j.AbstractEnumerable;
+import org.apache.calcite.linq4j.CorrelateJoinType;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.EnumerableDefaults;
 import org.apache.calcite.linq4j.Enumerator;
@@ -123,6 +124,8 @@ public enum BuiltInMethod {
   SLICE0(Enumerables.class, "slice0", Enumerable.class),
   SEMI_JOIN(Enumerables.class, "semiJoin", Enumerable.class, Enumerable.class,
       Function1.class, Function1.class),
+  CORRELATE_JOIN(ExtendedEnumerable.class, "correlateJoin",
+      CorrelateJoinType.class, Function1.class, Function2.class),
   SELECT(ExtendedEnumerable.class, "select", Function1.class),
   SELECT2(ExtendedEnumerable.class, "select", Function2.class),
   SELECT_MANY(ExtendedEnumerable.class, "selectMany", Function1.class),

File: core/src/main/java/org/apache/calcite/util/trace/CalciteTrace.java
Patch:
@@ -18,9 +18,9 @@
 
 import org.apache.calcite.linq4j.function.Function2;
 import org.apache.calcite.linq4j.function.Functions;
+import org.apache.calcite.plan.RelImplementor;
 import org.apache.calcite.plan.RelOptPlanner;
 import org.apache.calcite.prepare.Prepare;
-import org.apache.calcite.rel.RelImplementorImpl;
 
 import java.io.File;
 import java.util.logging.Level;
@@ -96,7 +96,7 @@ public static Logger getStatementTracer() {
    * expressions are bound to variables ({@link Level#FINE})
    */
   public static Logger getRelImplementorTracer() {
-    return Logger.getLogger(RelImplementorImpl.class.getName());
+    return Logger.getLogger(RelImplementor.class.getName());
   }
 
   /**

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.calcite.sql.test.SqlOperatorTest;
 import org.apache.calcite.sql.test.SqlPrettyWriterTest;
 import org.apache.calcite.sql.test.SqlTypeNameTest;
+import org.apache.calcite.test.enumerable.EnumerableCorrelateTest;
 import org.apache.calcite.tools.FrameworksTest;
 import org.apache.calcite.tools.PlannerTest;
 import org.apache.calcite.util.BitSetsTest;
@@ -99,6 +100,7 @@
     SqlOperatorTest.class,
     ChunkListTest.class,
     FrameworksTest.class,
+    EnumerableCorrelateTest.class,
 
     // slow tests (above 1s)
     PlannerTest.class,

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -4176,7 +4176,7 @@ private CalciteAssert.AssertQuery predicate(String foo) {
             new Function<RelNode, Void>() {
               public Void apply(RelNode relNode) {
                 String s = RelOptUtil.toString(relNode);
-                assertThat(s, not(containsString("Correlator")));
+                assertThat(s, not(containsString("Correlate")));
                 return null;
               }
             });

File: linq4j/src/test/java/org/apache/calcite/linq4j/test/Linq4jSuite.java
Patch:
@@ -36,7 +36,8 @@
     DeterministicTest.class,
     BlockBuilderTest.class,
     FunctionTest.class,
-    TypeTest.class
+    TypeTest.class,
+    CorrelateJoinTest.class
 })
 public class Linq4jSuite {
 }

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
Patch:
@@ -343,7 +343,7 @@ public Result implementSpark(Implementor implementor) {
                 builder2,
                 new RexToLixTranslator.InputGetterImpl(
                     Collections.singletonList(
-                        Pair.of((Expression) e_, result.physType))));
+                        Pair.of((Expression) e_, result.physType))), null);
         builder2.add(
             Expressions.ifThen(
                 Expressions.not(condition),
@@ -360,7 +360,7 @@ public Result implementSpark(Implementor implementor) {
               null,
               new RexToLixTranslator.InputGetterImpl(
                   Collections.singletonList(
-                      Pair.of((Expression) e_, result.physType))));
+                      Pair.of((Expression) e_, result.physType))), null);
       builder2.add(
           Expressions.return_(null,
               Expressions.convert_(

File: spark/src/main/java/org/apache/calcite/adapter/spark/SparkToEnumerableConverter.java
Patch:
@@ -107,7 +107,6 @@ SparkRel.Result visitInput(SparkRel parent, int ordinal, SparkRel input) {
       if (parent != null) {
         assert input == parent.getInputs().get(ordinal);
       }
-      createFrame(parent, ordinal, input);
       return input.implementSpark(this);
     }
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
Patch:
@@ -50,7 +50,7 @@
  *
  * <p><b>NOTE</b> If the <code>NOT</code> clause is present the
  * {@link org.apache.calcite.sql.parser.SqlParser parser} will generate a
- * eqvivalent to <code>NOT (src LIKE pattern ...)</code>
+ * equivalent to <code>NOT (src LIKE pattern ...)</code>
  */
 public class SqlLikeOperator extends SqlSpecialOperator {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
Patch:
@@ -722,6 +722,9 @@ private JdbcToInternalLookupTable() {
                   pos);
             }
           });
+      map.put(
+          "QUARTER",
+          new MakeCall(SqlStdOperatorTable.QUARTER, 1));
       map.put(
           "RTRIM",
           new MakeCall(SqlStdOperatorTable.TRIM, 1) {

File: core/src/main/java/org/apache/calcite/sql/SqlInsert.java
Patch:
@@ -32,15 +32,15 @@ public class SqlInsert extends SqlCall {
       new SqlSpecialOperator("INSERT", SqlKind.INSERT);
 
   SqlNodeList keywords;
-  SqlIdentifier targetTable;
+  SqlNode targetTable;
   SqlNode source;
   SqlNodeList columnList;
 
   //~ Constructors -----------------------------------------------------------
 
   public SqlInsert(SqlParserPos pos,
       SqlNodeList keywords,
-      SqlIdentifier targetTable,
+      SqlNode targetTable,
       SqlNode source,
       SqlNodeList columnList) {
     super(pos);
@@ -87,7 +87,7 @@ public List<SqlNode> getOperandList() {
   /**
    * @return the identifier for the target table of the insertion
    */
-  public SqlIdentifier getTargetTable() {
+  public SqlNode getTargetTable() {
     return targetTable;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlMerge.java
Patch:
@@ -34,7 +34,7 @@ public class SqlMerge extends SqlCall {
   public static final SqlSpecialOperator OPERATOR =
       new SqlSpecialOperator("MERGE", SqlKind.MERGE);
 
-  SqlIdentifier targetTable;
+  SqlNode targetTable;
   SqlNode condition;
   SqlNode source;
   SqlUpdate updateCall;
@@ -45,7 +45,7 @@ public class SqlMerge extends SqlCall {
   //~ Constructors -----------------------------------------------------------
 
   public SqlMerge(SqlParserPos pos,
-      SqlIdentifier targetTable,
+      SqlNode targetTable,
       SqlNode condition,
       SqlNode source,
       SqlUpdate updateCall,
@@ -108,7 +108,7 @@ public List<SqlNode> getOperandList() {
   /**
    * @return the identifier for the target table of the merge
    */
-  public SqlIdentifier getTargetTable() {
+  public SqlNode getTargetTable() {
     return targetTable;
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlUpdate.java
Patch:
@@ -33,7 +33,7 @@ public class SqlUpdate extends SqlCall {
   public static final SqlSpecialOperator OPERATOR =
       new SqlSpecialOperator("UPDATE", SqlKind.UPDATE);
 
-  SqlIdentifier targetTable;
+  SqlNode targetTable;
   SqlNodeList targetColumnList;
   SqlNodeList sourceExpressionList;
   SqlNode condition;
@@ -43,7 +43,7 @@ public class SqlUpdate extends SqlCall {
   //~ Constructors -----------------------------------------------------------
 
   public SqlUpdate(SqlParserPos pos,
-      SqlIdentifier targetTable,
+      SqlNode targetTable,
       SqlNodeList targetColumnList,
       SqlNodeList sourceExpressionList,
       SqlNode condition,
@@ -102,7 +102,7 @@ public List<SqlNode> getOperandList() {
   /**
    * @return the identifier for the target table of the update
    */
-  public SqlIdentifier getTargetTable() {
+  public SqlNode getTargetTable() {
     return targetTable;
   }
 

File: core/src/test/java/org/apache/calcite/sql/test/SqlAdvisorTest.java
Patch:
@@ -271,6 +271,8 @@ public class SqlAdvisorTest extends SqlValidatorTestCase {
           "KEYWORD(UNION)",
           "KEYWORD(FULL)",
           "KEYWORD(ORDER)",
+          "KEYWORD(()",
+          "KEYWORD(EXTEND)",
           "KEYWORD(AS)",
           "KEYWORD(USING)",
           "KEYWORD(RIGHT)",

File: core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java
Patch:
@@ -607,7 +607,7 @@ public Prepare.CatalogReader apply(RelDataTypeFactory typeFactory) {
                     typeFactory.createSqlType(SqlTypeName.INTEGER);
                 for (int i = 0; i < 10; i++) {
                   String t = String.valueOf((char) ('A' + i));
-                  MockTable table = new MockTable(this, schema, t);
+                  MockTable table = MockTable.create(this, schema, t);
                   table.addColumn(t, intType);
                   registerTable(table);
                 }

File: core/src/main/java/org/apache/calcite/rel/logical/LogicalAggregate.java
Patch:
@@ -82,7 +82,7 @@ public LogicalAggregate(RelInput input) {
       boolean indicator, ImmutableBitSet groupSet,
       List<ImmutableBitSet> groupSets, List<AggregateCall> aggCalls) {
     assert traitSet.containsIfApplicable(Convention.NONE);
-    return new LogicalAggregate(getCluster(), input, this.indicator, groupSet,
+    return new LogicalAggregate(getCluster(), input, indicator, groupSet,
         groupSets, aggCalls);
   }
 

File: avatica/src/main/java/org/apache/calcite/avatica/ConnectionProperty.java
Patch:
@@ -42,6 +42,9 @@ public interface ConnectionProperty {
    * obtained when needed. */
   ConnectionConfigImpl.PropEnv wrap(Properties properties);
 
+  /** Whether the property is mandatory. */
+  boolean required();
+
   /** Data type of property. */
   enum Type {
     BOOLEAN,

File: avatica/src/main/java/org/apache/calcite/avatica/InternalProperty.java
Patch:
@@ -17,6 +17,8 @@
 package org.apache.calcite.avatica;
 
 import org.apache.calcite.avatica.ConnectionProperty.Type;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 
 import java.util.Map;
 

File: avatica/src/main/java/org/apache/calcite/avatica/util/ByteString.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.avatica;
+package org.apache.calcite.avatica.util;
 
 import java.io.Serializable;
 import java.util.Arrays;

File: avatica/src/main/java/org/apache/calcite/avatica/util/Casing.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.avatica;
+package org.apache.calcite.avatica.util;
 
 /** Policy for converting case of identifiers before storing them.
  *

File: avatica/src/main/java/org/apache/calcite/avatica/util/Cursor.java
Patch:
@@ -14,7 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.avatica;
+package org.apache.calcite.avatica.util;
+
+import org.apache.calcite.avatica.ColumnMetaData;
 
 import java.io.Closeable;
 import java.io.InputStream;

File: avatica/src/main/java/org/apache/calcite/avatica/util/Quoting.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.avatica;
+package org.apache.calcite.avatica.util;
 
 /** Syntax for quoting identifiers in SQL statements. */
 public enum Quoting {

File: avatica/src/main/java/org/apache/calcite/avatica/util/Spacer.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.runtime;
+package org.apache.calcite.avatica.util;
 
 /**
  * Efficiently writes strings of spaces.

File: avatica/src/main/java/org/apache/calcite/avatica/util/Spaces.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.calcite.runtime;
+package org.apache.calcite.avatica.util;
 
 import java.io.IOException;
 import java.io.PrintWriter;

File: avatica/src/test/java/org/apache/calcite/avatica/test/AvaticaSuite.java
Patch:
@@ -24,7 +24,8 @@
  */
 @RunWith(Suite.class)
 @Suite.SuiteClasses({
-    ConnectStringParserTest.class
+    ConnectStringParserTest.class,
+    RemoteDriverTest.class
 })
 public class AvaticaSuite {
 }

File: core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
Patch:
@@ -18,6 +18,7 @@
 
 import org.apache.calcite.adapter.java.JavaTypeFactory;
 import org.apache.calcite.avatica.ColumnMetaData;
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.linq4j.function.Function1;
@@ -26,7 +27,6 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.rel.type.RelProtoDataType;
-import org.apache.calcite.util.DateTimeUtil;
 
 import java.lang.reflect.Type;
 import java.sql.Date;
@@ -64,7 +64,7 @@ public Long apply(Timestamp a0) {
         public Integer apply(Time a0) {
           return a0 == null
               ? null
-              : (int) (a0.getTime() % DateTimeUtil.MILLIS_PER_DAY);
+              : (int) (a0.getTime() % DateTimeUtils.MILLIS_PER_DAY);
         }
       };
 
@@ -73,7 +73,7 @@ public Integer apply(Time a0) {
         public Integer apply(Date a0) {
           return a0 == null
               ? null
-              : (int) (a0.getTime() / DateTimeUtil.MILLIS_PER_DAY);
+              : (int) (a0.getTime() / DateTimeUtils.MILLIS_PER_DAY);
         }
       };
 

File: core/src/main/java/org/apache/calcite/adapter/clone/ListTable.java
Patch:
@@ -83,7 +83,8 @@ public QueryProvider getProvider() {
       }
 
       public Iterator<T> iterator() {
-        return Linq4j.enumeratorIterator(enumerator());
+        //noinspection unchecked
+        return list.iterator();
       }
 
       public Enumerator<T> enumerator() {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.adapter.enumerable;
 
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.linq4j.tree.BlockBuilder;
 import org.apache.calcite.linq4j.tree.BlockStatement;
@@ -49,7 +50,6 @@
 import org.apache.calcite.sql.validate.SqlUserDefinedAggFunction;
 import org.apache.calcite.sql.validate.SqlUserDefinedFunction;
 import org.apache.calcite.util.BuiltInMethod;
-import org.apache.calcite.util.DateTimeUtil;
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Supplier;
@@ -1756,7 +1756,7 @@ public Expression implement(RexToLixTranslator translator, RexCall call,
         trop1 =
             Expressions.convert_(
                 Expressions.divide(trop1,
-                    Expressions.constant(DateTimeUtil.MILLIS_PER_DAY)),
+                    Expressions.constant(DateTimeUtils.MILLIS_PER_DAY)),
                 int.class);
         break;
       case TIME:

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcUtils.java
Patch:
@@ -16,11 +16,11 @@
  */
 package org.apache.calcite.adapter.jdbc;
 
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.linq4j.function.Function0;
 import org.apache.calcite.linq4j.function.Function1;
 import org.apache.calcite.linq4j.tree.Primitive;
 import org.apache.calcite.sql.SqlDialect;
-import org.apache.calcite.util.DateTimeUtil;
 import org.apache.calcite.util.ImmutableNullableList;
 import org.apache.calcite.util.IntList;
 import org.apache.calcite.util.Pair;
@@ -185,7 +185,7 @@ private static Time shift(Time v) {
       }
       long time = v.getTime();
       int offset = TimeZone.getDefault().getOffset(time);
-      return new Time((time + offset) % DateTimeUtil.MILLIS_PER_DAY);
+      return new Time((time + offset) % DateTimeUtils.MILLIS_PER_DAY);
     }
 
     private static Date shift(Date v) {

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfig.java
Patch:
@@ -16,9 +16,9 @@
  */
 package org.apache.calcite.config;
 
-import org.apache.calcite.avatica.Casing;
 import org.apache.calcite.avatica.ConnectionConfig;
-import org.apache.calcite.avatica.Quoting;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 
 /** Interface for reading connection properties within Calcite code. There is
  * a method for every property. At some point there will be similar config

File: core/src/main/java/org/apache/calcite/config/CalciteConnectionConfigImpl.java
Patch:
@@ -16,9 +16,9 @@
  */
 package org.apache.calcite.config;
 
-import org.apache.calcite.avatica.Casing;
 import org.apache.calcite.avatica.ConnectionConfigImpl;
-import org.apache.calcite.avatica.Quoting;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 
 import java.util.Properties;
 

File: core/src/main/java/org/apache/calcite/config/Lex.java
Patch:
@@ -16,8 +16,8 @@
  */
 package org.apache.calcite.config;
 
-import org.apache.calcite.avatica.Casing;
-import org.apache.calcite.avatica.Quoting;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 
 /** Named, built-in lexical policy. A lexical policy describes how
  * identifiers are quoted, whether they are converted to upper- or

File: core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -17,7 +17,7 @@
 package org.apache.calcite.jdbc;
 
 import org.apache.calcite.adapter.java.JavaTypeFactory;
-import org.apache.calcite.avatica.ByteString;
+import org.apache.calcite.avatica.util.ByteString;
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.linq4j.tree.Primitive;
 import org.apache.calcite.linq4j.tree.Types;

File: core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.plan;
 
+import org.apache.calcite.avatica.util.Spaces;
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.prepare.CalcitePrepareImpl;
 import org.apache.calcite.rel.RelCollation;
@@ -43,7 +44,6 @@
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.rex.RexShuttle;
 import org.apache.calcite.rex.RexUtil;
-import org.apache.calcite.runtime.Spaces;
 import org.apache.calcite.sql.SqlAggFunction;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;

File: core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.plan.volcano;
 
+import org.apache.calcite.avatica.util.Spaces;
 import org.apache.calcite.config.CalciteConnectionConfig;
 import org.apache.calcite.linq4j.tree.Expressions;
 import org.apache.calcite.plan.AbstractRelOptPlanner;
@@ -61,7 +62,6 @@
 import org.apache.calcite.rel.rules.UnionToDistinctRule;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.runtime.Hook;
-import org.apache.calcite.runtime.Spaces;
 import org.apache.calcite.sql.SqlExplainLevel;
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.SaffronProperties;

File: core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
Patch:
@@ -16,12 +16,12 @@
  */
 package org.apache.calcite.rel.externalize;
 
+import org.apache.calcite.avatica.util.Spacer;
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.runtime.Spacer;
 import org.apache.calcite.sql.SqlExplainLevel;
 import org.apache.calcite.util.Pair;
 

File: core/src/main/java/org/apache/calcite/schema/Schemas.java
Patch:
@@ -291,7 +291,7 @@ public static CalcitePrepare.ConvertResult convert(
   }
 
   /** Prepares a SQL query for execution. For use within Calcite only. */
-  public static CalcitePrepare.PrepareResult<Object> prepare(
+  public static CalcitePrepare.CalciteSignature<Object> prepare(
       final CalciteConnection connection, final CalciteSchema schema,
       final List<String> schemaPath, final String sql,
       final ImmutableMap<CalciteConnectionProperty, String> map) {

File: core/src/main/java/org/apache/calcite/sql/SqlDateLiteral.java
Patch:
@@ -16,11 +16,11 @@
  */
 package org.apache.calcite.sql;
 
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.SqlTypeName;
-import org.apache.calcite.util.DateTimeUtil;
 
 import java.util.Calendar;
 
@@ -34,7 +34,7 @@ public class SqlDateLiteral extends SqlAbstractDateTimeLiteral {
   //~ Constructors -----------------------------------------------------------
 
   SqlDateLiteral(Calendar d, SqlParserPos pos) {
-    super(d, false, SqlTypeName.DATE, 0, DateTimeUtil.DATE_FORMAT_STRING, pos);
+    super(d, false, SqlTypeName.DATE, 0, DateTimeUtils.DATE_FORMAT_STRING, pos);
   }
 
   SqlDateLiteral(Calendar d, String format, SqlParserPos pos) {

File: core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
Patch:
@@ -16,6 +16,7 @@
  */
 package org.apache.calcite.sql;
 
+import org.apache.calcite.avatica.util.TimeUnitRange;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.sql.fun.SqlLiteralChainOperator;
@@ -200,11 +201,10 @@ public static boolean valueMatchesType(
       return value instanceof BitString;
     case CHAR:
       return value instanceof NlsString;
-
     case SYMBOL:
-
       return (value instanceof SqlSymbol)
-          || (value instanceof SqlSampleSpec);
+          || (value instanceof SqlSampleSpec)
+          || (value instanceof TimeUnitRange);
     case MULTISET:
       return true;
     case INTEGER: // not allowed -- use Decimal

File: core/src/main/java/org/apache/calcite/sql/SqlTimeLiteral.java
Patch:
@@ -16,9 +16,9 @@
  */
 package org.apache.calcite.sql;
 
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.SqlTypeName;
-import org.apache.calcite.util.DateTimeUtil;
 
 import java.util.Calendar;
 
@@ -40,7 +40,7 @@ public class SqlTimeLiteral extends SqlAbstractDateTimeLiteral {
         t,
         hasTZ,
         SqlTypeName.TIME,
-        precision, DateTimeUtil.TIME_FORMAT_STRING,
+        precision, DateTimeUtils.TIME_FORMAT_STRING,
         pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java
Patch:
@@ -16,9 +16,9 @@
  */
 package org.apache.calcite.sql;
 
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.SqlTypeName;
-import org.apache.calcite.util.DateTimeUtil;
 
 import java.util.Calendar;
 
@@ -40,7 +40,7 @@ public SqlTimestampLiteral(
         cal,
         hasTimeZone,
         SqlTypeName.TIMESTAMP,
-        precision, DateTimeUtil.TIMESTAMP_FORMAT_STRING,
+        precision, DateTimeUtils.TIMESTAMP_FORMAT_STRING,
         pos);
   }
 

File: core/src/main/java/org/apache/calcite/sql/parser/SqlAbstractParserImpl.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.sql.parser;
 
-import org.apache.calcite.avatica.Casing;
+import org.apache.calcite.avatica.util.Casing;
 import org.apache.calcite.sql.SqlCall;
 import org.apache.calcite.sql.SqlFunctionCategory;
 import org.apache.calcite.sql.SqlIdentifier;

File: core/src/main/java/org/apache/calcite/sql/parser/SqlParser.java
Patch:
@@ -16,8 +16,8 @@
  */
 package org.apache.calcite.sql.parser;
 
-import org.apache.calcite.avatica.Casing;
-import org.apache.calcite.avatica.Quoting;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 import org.apache.calcite.config.Lex;
 import org.apache.calcite.runtime.CalciteContextException;
 import org.apache.calcite.sql.SqlNode;

File: core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.sql.parser;
 
-import org.apache.calcite.avatica.Casing;
+import org.apache.calcite.avatica.util.Casing;
 import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.runtime.CalciteContextException;
 import org.apache.calcite.sql.SqlBinaryOperator;

File: core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.sql.pretty;
 
-import org.apache.calcite.runtime.Spaces;
+import org.apache.calcite.avatica.util.Spaces;
 import org.apache.calcite.sql.SqlDialect;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlWriter;

File: core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.sql2rel;
 
-import org.apache.calcite.avatica.ByteString;
+import org.apache.calcite.avatica.util.ByteString;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rex.RexBuilder;

File: core/src/main/java/org/apache/calcite/util/JsonBuilder.java
Patch:
@@ -16,7 +16,7 @@
  */
 package org.apache.calcite.util;
 
-import org.apache.calcite.runtime.Spaces;
+import org.apache.calcite.avatica.util.Spaces;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;

File: core/src/test/java/org/apache/calcite/sql/test/DefaultSqlTestFactory.java
Patch:
@@ -16,8 +16,8 @@
  */
 package org.apache.calcite.sql.test;
 
-import org.apache.calcite.avatica.Casing;
-import org.apache.calcite.avatica.Quoting;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rel.type.RelDataTypeSystem;
 import org.apache.calcite.sql.SqlOperatorTable;

File: core/src/test/java/org/apache/calcite/sql/test/SqlTester.java
Patch:
@@ -16,8 +16,8 @@
  */
 package org.apache.calcite.sql.test;
 
-import org.apache.calcite.avatica.Casing;
-import org.apache.calcite.avatica.Quoting;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 import org.apache.calcite.config.Lex;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.sql.SqlOperator;

File: core/src/test/java/org/apache/calcite/sql/test/SqlTesterImpl.java
Patch:
@@ -16,8 +16,8 @@
  */
 package org.apache.calcite.sql.test;
 
-import org.apache.calcite.avatica.Casing;
-import org.apache.calcite.avatica.Quoting;
+import org.apache.calcite.avatica.util.Casing;
+import org.apache.calcite.avatica.util.Quoting;
 import org.apache.calcite.config.Lex;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeField;

File: core/src/test/java/org/apache/calcite/test/CalciteSuite.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.test;
 
 import org.apache.calcite.adapter.clone.ArrayTableTest;
+import org.apache.calcite.jdbc.CalciteRemoteDriverTest;
 import org.apache.calcite.plan.RelOptUtilTest;
 import org.apache.calcite.plan.RelWriterTest;
 import org.apache.calcite.plan.volcano.VolcanoPlannerTest;
@@ -109,6 +110,7 @@
     LatticeTest.class,
     ReflectiveSchemaTest.class,
     JdbcTest.class,
+    CalciteRemoteDriverTest.class,
 
     // test cases
     TableInRootSchemaTest.class,

File: core/src/test/java/org/apache/calcite/test/ExceptionMessageTest.java
Patch:
@@ -109,8 +109,8 @@ private void runQuery(String sql) throws SQLException {
       fail("Query badEntries should result in an exception");
     } catch (SQLException e) {
       assertThat(e.getMessage(),
-          equalTo(
-              "exception while executing query: Can't iterate over badEntries"));
+          equalTo("error while executing SQL \"select * from \"badEntries\"\": "
+              + "Can't iterate over badEntries"));
     }
   }
 

File: core/src/test/java/org/apache/calcite/test/ReflectiveSchemaTest.java
Patch:
@@ -17,6 +17,7 @@
 package org.apache.calcite.test;
 
 import org.apache.calcite.adapter.java.ReflectiveSchema;
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.jdbc.CalciteConnection;
 import org.apache.calcite.linq4j.Enumerable;
 import org.apache.calcite.linq4j.Linq4j;
@@ -32,7 +33,6 @@
 import org.apache.calcite.schema.impl.AbstractSchema;
 import org.apache.calcite.schema.impl.TableMacroImpl;
 import org.apache.calcite.schema.impl.ViewTable;
-import org.apache.calcite.util.DateTimeUtil;
 
 import org.junit.Ignore;
 import org.junit.Test;
@@ -723,7 +723,7 @@ public static class DateColumnSchema {
           10, 20, "fred", 0f, null, new java.sql.Date(0)), // 1970-1-1
       new EmployeeWithHireDate(
             10, 20, "bill", 0f, null,
-            new java.sql.Date(100 * DateTimeUtil.MILLIS_PER_DAY)) // 1970-04-11
+            new java.sql.Date(100 * DateTimeUtils.MILLIS_PER_DAY)) // 1970-04-11
     };
   }
 }

File: linq4j/src/main/java/org/apache/calcite/linq4j/AbstractEnumerable2.java
Patch:
@@ -28,7 +28,7 @@
  */
 public abstract class AbstractEnumerable2<T> extends DefaultEnumerable<T> {
   public Enumerator<T> enumerator() {
-    return Linq4j.iterableEnumerator(this);
+    return new Linq4j.IterableEnumerator<T>(this);
   }
 }
 

File: linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableQueryable.java
Patch:
@@ -73,7 +73,7 @@ protected Queryable<T> queryable() {
   }
 
   public Iterator<T> iterator() {
-    return Linq4j.enumeratorIterator(enumerator());
+    return enumerable.iterator();
   }
 
   public Enumerator<T> enumerator() {

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoEnumerator.java
Patch:
@@ -16,9 +16,9 @@
  */
 package org.apache.calcite.adapter.mongodb;
 
+import org.apache.calcite.avatica.util.DateTimeUtils;
 import org.apache.calcite.linq4j.Enumerator;
 import org.apache.calcite.linq4j.function.Function1;
-import org.apache.calcite.util.DateTimeUtil;
 
 import com.mongodb.DBCursor;
 import com.mongodb.DBObject;
@@ -127,7 +127,7 @@ private static Object convert(Object o, Class clazz) {
     }
     if (clazz == int.class || clazz == Integer.class) {
       if (o instanceof Date) {
-        return (int) (((Date) o).getTime() / DateTimeUtil.MILLIS_PER_DAY);
+        return (int) (((Date) o).getTime() / DateTimeUtils.MILLIS_PER_DAY);
       }
     }
     return o;

File: core/src/test/java/org/apache/calcite/test/JdbcTest.java
Patch:
@@ -677,7 +677,8 @@ public Integer apply(Object[] v0, IntString v1) {
       resultSet.next();
       fail("resultSet.next() should throw SQLException when closed");
     } catch (SQLException e) {
-      assertThat(e.getMessage(), containsString("next() called on closed cursor"));
+      assertThat(e.getMessage(),
+          containsString("next() called on closed cursor"));
     }
     assertEquals(0, closeCount[0]);
     assertEquals(0, statementCloseCount[0]);

File: core/src/main/java/org/apache/calcite/util/Glossary.java
Patch:
@@ -489,7 +489,7 @@ public interface Glossary {
   Glossary TEMPLATE_METHOD_PATTERN = null;
 
   /**
-   * Represent an operation to be performed on the elments of an object
+   * Represent an operation to be performed on the elements of an object
    * structure. Lets you define a new operation without changing the classes
    * of the elements on which it operates. (See <a
    * href="http://c2.com/cgi/wiki?VisitorPattern">GoF</a>.)

File: core/src/test/java/org/apache/calcite/test/InterpreterTest.java
Patch:
@@ -18,12 +18,12 @@
 
 import org.apache.calcite.DataContext;
 import org.apache.calcite.adapter.java.JavaTypeFactory;
-import org.apache.calcite.config.Lex;
 import org.apache.calcite.interpreter.Interpreter;
 import org.apache.calcite.linq4j.QueryProvider;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.sql.SqlNode;
+import org.apache.calcite.sql.parser.SqlParser;
 import org.apache.calcite.tools.FrameworkConfig;
 import org.apache.calcite.tools.Frameworks;
 import org.apache.calcite.tools.Planner;
@@ -76,7 +76,7 @@ public Object get(String name) {
   @Before public void setUp() {
     rootSchema = Frameworks.createRootSchema(true);
     final FrameworkConfig config = Frameworks.newConfigBuilder()
-        .lex(Lex.ORACLE)
+        .parserConfig(SqlParser.Config.DEFAULT)
         .defaultSchema(
             CalciteAssert.addSchema(rootSchema, CalciteAssert.SchemaSpec.HR))
         .build();

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregate.java
Patch:
@@ -185,6 +185,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
         inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,
             JavaRowFormat.LIST);
     final int keyArity = groupSet.cardinality();
+    final int indicatorArity = indicator ? keyArity : 0;
 
     final List<AggImpState> aggs =
         new ArrayList<AggImpState>(aggCalls.size());
@@ -349,7 +350,7 @@ public RexToLixTranslator rowTranslator() {
     } else {
       final Type keyType = keyPhysType.getJavaRowType();
       key_ = Expressions.parameter(keyType, "key");
-      for (int j = 0; j < keyArity; j++) {
+      for (int j = 0; j < keyArity + indicatorArity; j++) {
         results.add(
             keyPhysType.fieldReference(key_, j));
       }

File: core/src/main/java/org/apache/calcite/adapter/enumerable/JavaRowFormat.java
Patch:
@@ -148,7 +148,7 @@ public Expression record(
             Expressions.call(
                 List.class,
                 null,
-                BuiltInMethod.ARRAYS_AS_LIST.method,
+                BuiltInMethod.LIST_N.method,
                 Expressions.newArrayInit(
                     Object.class,
                     expressions)),

File: core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
Patch:
@@ -564,7 +564,7 @@ public Expression generateAccessor(
             Expressions.call(
                 List.class,
                 null,
-                BuiltInMethod.ARRAYS_AS_LIST.method,
+                BuiltInMethod.LIST_N.method,
                 Expressions.newArrayInit(
                     Object.class,
                     list)),

File: core/src/main/java/org/apache/calcite/sql/validate/AggChecker.java
Patch:
@@ -24,7 +24,6 @@
 import org.apache.calcite.sql.util.SqlBasicVisitor;
 import org.apache.calcite.util.Stacks;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 
 import java.util.List;
@@ -39,7 +38,7 @@ class AggChecker extends SqlBasicVisitor<Void> {
   //~ Instance fields --------------------------------------------------------
 
   private final List<SqlValidatorScope> scopes = Lists.newArrayList();
-  private final ImmutableList<SqlNode> groupExprs;
+  private final List<SqlNode> groupExprs;
   private boolean distinct;
   private SqlValidatorImpl validator;
 
@@ -61,7 +60,7 @@ class AggChecker extends SqlBasicVisitor<Void> {
       List<SqlNode> groupExprs,
       boolean distinct) {
     this.validator = validator;
-    this.groupExprs = ImmutableList.copyOf(groupExprs);
+    this.groupExprs = groupExprs;
     this.distinct = distinct;
     Stacks.push(this.scopes, scope);
   }

File: core/src/main/java/org/apache/calcite/util/BuiltInMethod.java
Patch:
@@ -64,6 +64,7 @@
 import java.sql.ResultSet;
 import java.sql.Time;
 import java.sql.Timestamp;
+import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Collections;
@@ -148,7 +149,8 @@ public enum BuiltInMethod {
   ARRAY_COMPARER(Functions.class, "arrayComparer"),
   FUNCTION0_APPLY(Function0.class, "apply"),
   FUNCTION1_APPLY(Function1.class, "apply", Object.class),
-  ARRAYS_AS_LIST(FlatLists.class, "of", Object[].class),
+  ARRAYS_AS_LIST(Arrays.class, "asList", Object[].class),
+  LIST_N(FlatLists.class, "of", Object[].class),
   LIST2(FlatLists.class, "of", Object.class, Object.class),
   LIST3(FlatLists.class, "of", Object.class, Object.class, Object.class),
   IDENTITY_COMPARER(Functions.class, "identityComparer"),

File: core/src/main/java/org/apache/calcite/interpreter/package-info.java
Patch:
@@ -22,6 +22,6 @@
  * preparation time is less, and so the total prepare + execute time is
  * competitive for queries over small data sets.
  */
-package org.apache.calcite.adapter.interpreter;
+package org.apache.calcite.interpreter;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableAggregateRule.java
Patch:
@@ -42,7 +42,9 @@ public RelNode convert(RelNode rel) {
           rel.getCluster(),
           traitSet,
           convert(agg.getInput(), traitSet),
+          agg.indicator,
           agg.getGroupSet(),
+          agg.getGroupSets(),
           agg.getAggCallList());
     } catch (InvalidRelException e) {
       EnumerableRules.LOGGER.fine(e.toString());

File: core/src/main/java/org/apache/calcite/rel/RelInput.java
Patch:
@@ -53,6 +53,8 @@ public interface RelInput {
 
   ImmutableBitSet getBitSet(String tag);
 
+  List<ImmutableBitSet> getBitSetList(String tag);
+
   List<AggregateCall> getAggregateCalls(String tag);
 
   Object get(String tag);
@@ -82,7 +84,7 @@ public interface RelInput {
 
   List<List<RexLiteral>> getTuples(String tag);
 
-  boolean getBoolean(String tag);
+  boolean getBoolean(String tag, boolean default_);
 }
 
 // End RelInput.java

File: core/src/main/java/org/apache/calcite/rel/core/SetOp.java
Patch:
@@ -67,7 +67,7 @@ protected SetOp(RelOptCluster cluster, RelTraitSet traits,
    */
   protected SetOp(RelInput input) {
     this(input.getCluster(), input.getTraitSet(), input.getInputs(),
-        SqlKind.UNION, input.getBoolean("all"));
+        SqlKind.UNION, input.getBoolean("all", false));
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/apache/calcite/rel/rules/AggregateProjectMergeRule.java
Patch:
@@ -51,7 +51,7 @@ public class AggregateProjectMergeRule extends RelOptRule {
   /** Private constructor. */
   private AggregateProjectMergeRule() {
     super(
-        operand(Aggregate.class,
+        operand(Aggregate.class, null, Aggregate.IS_SIMPLE,
             operand(Project.class, any())));
   }
 
@@ -95,8 +95,8 @@ public static RelNode apply(Aggregate aggregate,
 
     final ImmutableBitSet newGroupSet = ImmutableBitSet.of(newKeys);
     final Aggregate newAggregate =
-        aggregate.copy(aggregate.getTraitSet(), project.getInput(), newGroupSet,
-            aggCalls.build());
+        aggregate.copy(aggregate.getTraitSet(), project.getInput(), false,
+            newGroupSet, null, aggCalls.build());
 
     // Add a project if the group set is not in the same order or
     // contains duplicates.

File: core/src/main/java/org/apache/calcite/sql/SqlOperator.java
Patch:
@@ -65,7 +65,7 @@ public abstract class SqlOperator {
   /**
    * Maximum precedence.
    */
-  protected static final int MDX_PRECEDENCE = 200;
+  public static final int MDX_PRECEDENCE = 200;
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -22,11 +22,11 @@
 import org.apache.calcite.sql.SqlCallBinding;
 import org.apache.calcite.sql.SqlCharStringLiteral;
 import org.apache.calcite.sql.SqlCollation;
-import org.apache.calcite.sql.SqlInternalOperator;
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlLiteral;
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlOperatorBinding;
+import org.apache.calcite.sql.SqlSpecialOperator;
 import org.apache.calcite.sql.SqlUtil;
 import org.apache.calcite.sql.SqlWriter;
 import org.apache.calcite.sql.parser.SqlParserPos;
@@ -56,7 +56,7 @@
  * objects, a {@link SqlCollation} object is attached only to the head of the
  * chain.
  */
-public class SqlLiteralChainOperator extends SqlInternalOperator {
+public class SqlLiteralChainOperator extends SqlSpecialOperator {
   //~ Constructors -----------------------------------------------------------
 
   SqlLiteralChainOperator() {

File: core/src/main/java/org/apache/calcite/sql/fun/SqlThrowOperator.java
Patch:
@@ -17,8 +17,8 @@
 package org.apache.calcite.sql.fun;
 
 import org.apache.calcite.sql.SqlCall;
-import org.apache.calcite.sql.SqlInternalOperator;
 import org.apache.calcite.sql.SqlKind;
+import org.apache.calcite.sql.SqlSpecialOperator;
 import org.apache.calcite.sql.SqlWriter;
 import org.apache.calcite.sql.type.OperandTypes;
 import org.apache.calcite.sql.type.ReturnTypes;
@@ -37,7 +37,7 @@
  * ELSE throw("what's wrong with you man?")<br>
  * END</code></blockquote>
  */
-public class SqlThrowOperator extends SqlInternalOperator {
+public class SqlThrowOperator extends SqlSpecialOperator {
   //~ Constructors -----------------------------------------------------------
 
   public SqlThrowOperator() {

File: core/src/test/java/org/apache/calcite/plan/RelWriterTest.java
Patch:
@@ -133,12 +133,11 @@ public String apply(RelOptCluster cluster,
                                 "deptno", true),
                             rexBuilder.makeExactLiteral(BigDecimal.TEN)));
                 final RelJsonWriter writer = new RelJsonWriter();
-                final RelDataType intType =
-                    cluster.getTypeFactory().createSqlType(SqlTypeName.INTEGER);
                 final RelDataType bigIntType =
                     cluster.getTypeFactory().createSqlType(SqlTypeName.BIGINT);
                 LogicalAggregate aggregate =
-                    new LogicalAggregate(cluster, filter, ImmutableBitSet.of(0),
+                    new LogicalAggregate(cluster, filter, false,
+                        ImmutableBitSet.of(0), null,
                         ImmutableList.of(
                             new AggregateCall(SqlStdOperatorTable.COUNT,
                                 true, ImmutableList.of(1), bigIntType, "c"),

File: mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
Patch:
@@ -455,7 +455,9 @@ public RelNode convert(RelNode rel) {
             rel.getCluster(),
             traitSet,
             convert(agg.getInput(), traitSet),
+            agg.indicator,
             agg.getGroupSet(),
+            agg.getGroupSets(),
             agg.getAggCallList());
       } catch (InvalidRelException e) {
         LOGGER.warning(e.toString());

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaFactory.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.sql.ResultSetMetaData;
 import java.sql.SQLException;

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaJdbc40Factory.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 /**
  * Implementation of {@link AvaticaFactory}

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaPrepareResult.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.util.List;
 import java.util.Map;

File: avatica/src/main/java/org/apache/calcite/avatica/AvaticaResultSetMetaData.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.sql.ResultSetMetaData;
 import java.sql.SQLException;

File: avatica/src/main/java/org/apache/calcite/avatica/BuiltInConnectionProperty.java
Patch:
@@ -14,13 +14,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Properties;
 
-import static net.hydromatic.avatica.ConnectionConfigImpl.*;
+import static org.apache.calcite.avatica.ConnectionConfigImpl.PropEnv;
+import static org.apache.calcite.avatica.ConnectionConfigImpl.parse;
 
 /**
  * Enumeration of Avatica's built-in connection properties.

File: avatica/src/main/java/org/apache/calcite/avatica/Casing.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 /** Policy for converting case of identifiers before storing them.
  *

File: avatica/src/main/java/org/apache/calcite/avatica/ConnectionConfig.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 /**
  * Connection configuration.

File: avatica/src/main/java/org/apache/calcite/avatica/ConnectionConfigImpl.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.lang.reflect.Field;
 import java.util.LinkedHashMap;
@@ -39,7 +39,7 @@ public String timeZone() {
 
   /** Converts a {@link Properties} object containing (name, value)
    * pairs into a map whose keys are
-   * {@link net.hydromatic.avatica.InternalProperty} objects.
+   * {@link org.apache.calcite.avatica.InternalProperty} objects.
    *
    * <p>Matching is case-insensitive. Throws if a property is not known.
    * If a property occurs more than once, takes the last occurrence.</p>

File: avatica/src/main/java/org/apache/calcite/avatica/ConnectionProperty.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.util.Properties;
 

File: avatica/src/main/java/org/apache/calcite/avatica/DriverVersion.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.io.IOException;
 import java.io.InputStream;

File: avatica/src/main/java/org/apache/calcite/avatica/Handler.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.sql.SQLException;
 

File: avatica/src/main/java/org/apache/calcite/avatica/HandlerImpl.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.sql.SQLException;
 

File: avatica/src/main/java/org/apache/calcite/avatica/Helper.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.sql.SQLException;
 

File: avatica/src/main/java/org/apache/calcite/avatica/Meta.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 import java.sql.ResultSet;
 import java.util.List;

File: avatica/src/main/java/org/apache/calcite/avatica/Quoting.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 /** Syntax for quoting identifiers in SQL statements. */
 public enum Quoting {

File: avatica/src/main/java/org/apache/calcite/avatica/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Avatica JDBC framework.
  */
-package net.hydromatic.avatica;
+package org.apache.calcite.avatica;
 
 // End package-info.java

File: avatica/src/test/java/org/apache/calcite/avatica/test/AvaticaSuite.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.avatica.test;
+package org.apache.calcite.avatica.test;
 
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;

File: avatica/src/test/java/org/apache/calcite/avatica/test/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Avatica tests.
  */
-package net.hydromatic.avatica.test;
+package org.apache.calcite.avatica.test;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/Demo.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq;
+package org.apache.calcite;
 
 import java.util.ArrayList;
 

File: core/src/main/java/org/apache/calcite/adapter/clone/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Provides utility classes.
  */
-package net.hydromatic.optiq.impl.clone;
+package org.apache.calcite.adapter.clone;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/enumerable/NullPolicy.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.rules.java;
+package org.apache.calcite.adapter.enumerable;
 
 /**
  * Describes when a function/operator will return null.
@@ -40,3 +40,5 @@ public enum NullPolicy {
   NOT,
   NONE
 }
+
+// End NullPolicy.java

File: core/src/main/java/org/apache/calcite/adapter/enumerable/WinAggContext.java
Patch:
@@ -14,11 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.rules.java;
+package org.apache.calcite.adapter.enumerable;
 
 /**
  * Marker interface to allow
- * {@link net.hydromatic.optiq.rules.java.AggImplementor}
+ * {@link org.apache.calcite.adapter.enumerable.AggImplementor}
  * to tell if it is used in regular or windowed context.
  */
 public interface WinAggContext extends AggContext {

File: core/src/main/java/org/apache/calcite/adapter/enumerable/WinAggFrameResultContext.java
Patch:
@@ -14,9 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.rules.java;
+package org.apache.calcite.adapter.enumerable;
 
-import net.hydromatic.linq4j.expressions.Expression;
+import org.apache.calcite.linq4j.tree.Expression;
 
 /**
  * Provides information on the current window when computing the result of

File: core/src/main/java/org/apache/calcite/adapter/enumerable/impl/package-info.java
Patch:
@@ -16,8 +16,8 @@
  */
 
 /**
- * Optiq-specific classes for implementation of regular and window aggregates.
+ * Calcite-specific classes for implementation of regular and window aggregates.
  */
-package net.hydromatic.optiq.rules.java.impl;
+package org.apache.calcite.adapter.enumerable.impl;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/enumerable/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Query optimizer rules for Java calling convention.
  */
-package net.hydromatic.optiq.rules.java;
+package org.apache.calcite.adapter.enumerable;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/java/JavaTypeFactory.java
Patch:
@@ -14,10 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.java;
+package org.apache.calcite.adapter.java;
 
-import org.eigenbase.reltype.RelDataType;
-import org.eigenbase.reltype.RelDataTypeFactory;
+import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rel.type.RelDataTypeFactory;
 
 import java.lang.reflect.Type;
 import java.util.List;

File: core/src/main/java/org/apache/calcite/adapter/java/package-info.java
Patch:
@@ -19,6 +19,6 @@
  * Query provider based on Java in-memory data
  * structures.
  */
-package net.hydromatic.optiq.impl.java;
+package org.apache.calcite.adapter.java;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRel.java
Patch:
@@ -14,9 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.jdbc;
+package org.apache.calcite.adapter.jdbc;
 
-import org.eigenbase.rel.RelNode;
+import org.apache.calcite.rel.RelNode;
 
 /**
  * Relational expression that uses JDBC calling convention.

File: core/src/main/java/org/apache/calcite/adapter/jdbc/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Query provider based on a JDBC data source.
  */
-package net.hydromatic.optiq.impl.jdbc;
+package org.apache.calcite.adapter.jdbc;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/config/Lex.java
Patch:
@@ -14,10 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.config;
+package org.apache.calcite.config;
 
-import net.hydromatic.avatica.Casing;
-import net.hydromatic.avatica.Quoting;
+import org.apache.calcite.avatica.Casing;
+import org.apache.calcite.avatica.Quoting;
 
 /** Named, built-in lexical policy. A lexical policy describes how
  * identifiers are quoted, whether they are converted to upper- or

File: core/src/main/java/org/apache/calcite/config/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Configuration.
  */
-package net.hydromatic.optiq.config;
+package org.apache.calcite.config;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/interpreter/Context.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.interpreter;
+package org.apache.calcite.interpreter;
 
 /**
  * Context for executing a scalar expression in an interpreter.

File: core/src/main/java/org/apache/calcite/interpreter/Node.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.interpreter;
+package org.apache.calcite.interpreter;
 
 /**
  * Relational expression that can be executed using an interpreter.

File: core/src/main/java/org/apache/calcite/interpreter/Row.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.interpreter;
+package org.apache.calcite.interpreter;
 
 import java.util.Arrays;
 

File: core/src/main/java/org/apache/calcite/interpreter/Scalar.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.interpreter;
+package org.apache.calcite.interpreter;
 
 /**
  * Compiled scalar expression.

File: core/src/main/java/org/apache/calcite/interpreter/Sink.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.interpreter;
+package org.apache.calcite.interpreter;
 
 /**
  * Sink to which to send rows.

File: core/src/main/java/org/apache/calcite/interpreter/Source.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.impl.interpreter;
+package org.apache.calcite.interpreter;
 
 /**
  * Source of rows.

File: core/src/main/java/org/apache/calcite/interpreter/package-info.java
Patch:
@@ -22,6 +22,6 @@
  * preparation time is less, and so the total prepare + execute time is
  * competitive for queries over small data sets.
  */
-package net.hydromatic.optiq.impl.interpreter;
+package org.apache.calcite.adapter.interpreter;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
Patch:
@@ -14,10 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.jdbc;
+package org.apache.calcite.jdbc;
 
-import org.eigenbase.reltype.RelDataTypeField;
-import org.eigenbase.reltype.RelRecordType;
+import org.apache.calcite.rel.type.RelDataTypeField;
+import org.apache.calcite.rel.type.RelRecordType;
 
 import java.util.List;
 

File: core/src/main/java/org/apache/calcite/jdbc/SqlTimeoutException.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.jdbc;
+package org.apache.calcite.jdbc;
 
 import java.sql.SQLException;
 

File: core/src/main/java/org/apache/calcite/jdbc/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * JDBC driver for Calcite.
  */
-package net.hydromatic.optiq.jdbc;
+package org.apache.calcite.jdbc;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/materialize/TileSuggester.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.materialize;
+package org.apache.calcite.materialize;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableList;

File: core/src/main/java/org/apache/calcite/materialize/package-info.java
Patch:
@@ -18,10 +18,10 @@
 /**
  * Management of materialized query results.
  *
- * <p>An actor ({@link net.hydromatic.optiq.materialize.MaterializationActor})
+ * <p>An actor ({@link org.apache.calcite.materialize.MaterializationActor})
  * maintains the state of all
  * materializations in the system and is wrapped in a service
- * ({@link net.hydromatic.optiq.materialize.MaterializationService})
+ * ({@link org.apache.calcite.materialize.MaterializationService})
  * for access from other parts of the system.</p>
  *
  * <p>Optimizer rules allow Calcite to rewrite queries using materializations,
@@ -32,6 +32,6 @@
  * instantiating materializations from the intermediate results of queries, and
  * recognize what materializations would be useful based on actual query load.
  */
-package net.hydromatic.optiq.materialize;
+package org.apache.calcite.materialize;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/model/JsonColumn.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 /**
  * JSON object representing a column.

File: core/src/main/java/org/apache/calcite/model/JsonCustomTable.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 import java.util.Map;
 
@@ -25,7 +25,7 @@
  */
 public class JsonCustomTable extends JsonTable {
   /** Name of the factory class for this table. Must implement interface
-   * {@link net.hydromatic.optiq.TableFactory} and have a public default
+   * {@link org.apache.calcite.schema.TableFactory} and have a public default
    * constructor. */
   public String factory;
 

File: core/src/main/java/org/apache/calcite/model/JsonFunction.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 import java.util.List;
 

File: core/src/main/java/org/apache/calcite/model/JsonJdbcSchema.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 /**
  * JSON object representing a schema that maps to a JDBC database.
@@ -29,8 +29,7 @@ public class JsonJdbcSchema extends JsonSchema {
   public String jdbcCatalog;
   public String jdbcSchema;
 
-  @Override
-  public void accept(ModelHandler handler) {
+  @Override public void accept(ModelHandler handler) {
     handler.visit(this);
   }
 }

File: core/src/main/java/org/apache/calcite/model/JsonLattice.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 import com.google.common.collect.Lists;
 

File: core/src/main/java/org/apache/calcite/model/JsonMaterialization.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 /**
  * Element that describes how a table is a materialization of a query.
@@ -30,8 +30,7 @@ public void accept(ModelHandler handler) {
     handler.visit(this);
   }
 
-  @Override
-  public String toString() {
+  @Override public String toString() {
     return "JsonMaterialization(table=" + table + ", view=" + view + ")";
   }
 

File: core/src/main/java/org/apache/calcite/model/JsonMeasure.java
Patch:
@@ -14,14 +14,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 /**
  * An aggregate function applied to a column (or columns) of a lattice.
  *
- * <p>Occurs in a {@link net.hydromatic.optiq.model.JsonTile},
+ * <p>Occurs in a {@link org.apache.calcite.model.JsonTile},
  * and there is a default list in
- * {@link net.hydromatic.optiq.model.JsonLattice}.
+ * {@link org.apache.calcite.model.JsonLattice}.
  *
  * @see JsonRoot Description of schema elements
  */

File: core/src/main/java/org/apache/calcite/model/JsonRoot.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -33,7 +33,7 @@
  *     {@link JsonTable} (in collection {@link JsonMapSchema#tables tables})
  *       {@link JsonColumn} (in collection {@link JsonTable#columns columns}
  *     {@link JsonView}
- *     {@link JsonFunction}  (in collection {@link JsonMapSchema#functions functions})
+ *     {@link JsonFunction} (in collection {@link JsonMapSchema#functions functions})
  *     {@link JsonLattice} (in collection {@link JsonSchema#lattices lattices})
  *       {@link JsonMeasure} (in collection {@link JsonLattice#defaultMeasures defaultMeasures})
  *       {@link JsonTile} (in collection {@link JsonLattice#tiles tiles})

File: core/src/main/java/org/apache/calcite/model/JsonTable.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 import com.fasterxml.jackson.annotation.JsonSubTypes;
 import com.fasterxml.jackson.annotation.JsonTypeInfo;

File: core/src/main/java/org/apache/calcite/model/JsonTile.java
Patch:
@@ -14,14 +14,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 import com.google.common.collect.Lists;
 
 import java.util.List;
 
 /**
- * Materialized view within a {@link net.hydromatic.optiq.model.JsonLattice}.
+ * Materialized view within a {@link org.apache.calcite.model.JsonLattice}.
  *
  * <p>A tile is defined in terms of its dimensionality (the grouping columns,
  * drawn from the lattice) and measures (aggregate functions applied to

File: core/src/main/java/org/apache/calcite/model/JsonView.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package net.hydromatic.optiq.model;
+package org.apache.calcite.model;
 
 import java.util.List;
 
@@ -35,8 +35,7 @@ public void accept(ModelHandler handler) {
     handler.visit(this);
   }
 
-  @Override
-  public String toString() {
+  @Override public String toString() {
     return "JsonView(name=" + name + ")";
   }
 

File: core/src/main/java/org/apache/calcite/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Main package for Calcite, the dynamic data management platform.
  */
-package net.hydromatic.optiq;
+package org.apache.calcite;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/plan/CommonRelSubExprRule.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 
 /**

File: core/src/main/java/org/apache/calcite/plan/Context.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 /**
  * Provides library users a way to store data within the planner session and
@@ -31,3 +31,5 @@ public interface Context {
   <T> T unwrap(Class<T> clazz);
 
 }
+
+// End Context.java

File: core/src/main/java/org/apache/calcite/plan/Convention.java
Patch:
@@ -14,9 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
-import org.eigenbase.rel.RelNode;
+import org.apache.calcite.rel.RelNode;
 
 /**
  * Calling convention trait.

File: core/src/main/java/org/apache/calcite/plan/MulticastRelOptListener.java
Patch:
@@ -14,9 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
  * MulticastRelOptListener implements the {@link RelOptListener} interface by

File: core/src/main/java/org/apache/calcite/plan/RelOptConnection.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 /**
  * The planner's view of a connection to a database.

File: core/src/main/java/org/apache/calcite/plan/RelOptCost.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 /**
  * RelOptCost defines an interface for optimizer cost in terms of number of rows
@@ -31,8 +31,8 @@ public interface RelOptCost {
 
   /**
    * @return number of rows processed; this should not be confused with the
-   * row count produced by a relational expression ({@link
-   * org.eigenbase.rel.RelNode#getRows})
+   * row count produced by a relational expression
+   * ({@link org.apache.calcite.rel.RelNode#getRows})
    */
   double getRows();
 

File: core/src/main/java/org/apache/calcite/plan/RelOptCostFactory.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 /**
  * Cost model for query planning.

File: core/src/main/java/org/apache/calcite/plan/RelOptNode.java
Patch:
@@ -14,11 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
-import java.util.List;
+import org.apache.calcite.rel.type.RelDataType;
 
-import org.eigenbase.reltype.RelDataType;
+import java.util.List;
 
 /**
  * Node in a planner.

File: core/src/main/java/org/apache/calcite/plan/RelOptPredicateList.java
Patch:
@@ -14,9 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
-import org.eigenbase.rex.RexNode;
+import org.apache.calcite.rex.RexNode;
 
 import com.google.common.collect.ImmutableList;
 
@@ -71,4 +71,4 @@ public static RelOptPredicateList of(Iterable<RexNode> pulledUpPredicates,
   }
 }
 
-// End RelOptPulledUpPredicates.java
+// End RelOptPredicateList.java

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleOperandChildPolicy.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 /**
  * Policy by which operands will be matched by relational expressions with

File: core/src/main/java/org/apache/calcite/plan/RelOptRuleOperandChildren.java
Patch:
@@ -14,13 +14,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 import com.google.common.collect.ImmutableList;
 
 /**
- * Children of a {@link org.eigenbase.relopt.RelOptRuleOperand} and the policy
- * for matching them.
+ * Children of a {@link org.apache.calcite.plan.RelOptRuleOperand} and the
+ * policy for matching them.
  *
  * <p>Often created by calling one of the following methods:
  * {@link RelOptRule#some},

File: core/src/main/java/org/apache/calcite/plan/RelOptSamplingParameters.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 /**
  * RelOptSamplingParameters represents the parameters necessary to produce a
@@ -74,8 +74,8 @@ public float getSamplingPercentage() {
    * Indicates whether the sample results should be repeatable. Sample results
    * are only required to repeat if no changes have been made to the
    * relation's content or structure. If the sample is configured to be
-   * repeatable, then a user-specified seed value can be obtained via {@link
-   * #getRepeatableSeed()}.
+   * repeatable, then a user-specified seed value can be obtained via
+   * {@link #getRepeatableSeed()}.
    *
    * @return true if the sample results should be repeatable
    */

File: core/src/main/java/org/apache/calcite/plan/RelOptSchema.java
Patch:
@@ -14,11 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
-import java.util.List;
+import org.apache.calcite.rel.type.RelDataTypeFactory;
 
-import org.eigenbase.reltype.*;
+import java.util.List;
 
 /**
  * A <code>RelOptSchema</code> is a set of {@link RelOptTable} objects.

File: core/src/main/java/org/apache/calcite/plan/RelOptSchemaWithSampling.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 import java.util.List;
 

File: core/src/main/java/org/apache/calcite/plan/hep/HepMatchOrder.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.relopt.hep;
+package org.apache.calcite.plan.hep;
 
 /**
  * HepMatchOrder specifies the order of graph traversal when looking for rule

File: core/src/main/java/org/apache/calcite/plan/hep/package-info.java
Patch:
@@ -17,8 +17,8 @@
 
 /**
  * Provides a heuristic planner implementation for the interfaces in
- * {@link org.eigenbase.relopt}.
+ * {@link org.apache.calcite.plan}.
  */
-package org.eigenbase.relopt.hep;
+package org.apache.calcite.plan.hep;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/plan/package-info.java
Patch:
@@ -19,6 +19,6 @@
  * Defines interfaces for constructing rule-based optimizers of
  * relational expressions.
  */
-package org.eigenbase.relopt;
+package org.apache.calcite.plan;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/prepare/package-info.java
Patch:
@@ -18,6 +18,6 @@
 /**
  * Preparation of queries (parsing, planning and implementation).
  */
-package net.hydromatic.optiq.prepare;
+package org.apache.calcite.prepare;
 
 // End package-info.java

File: core/src/main/java/org/apache/calcite/rel/InvalidRelException.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.rel;
+package org.apache.calcite.rel;
 
 /**
  * Exception that indicates that a relational expression would be invalid

File: core/src/main/java/org/apache/calcite/rel/RelCollation.java
Patch:
@@ -14,11 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.rel;
+package org.apache.calcite.rel;
 
-import java.util.*;
+import org.apache.calcite.plan.RelTrait;
 
-import org.eigenbase.relopt.RelTrait;
+import java.util.List;
 
 /**
  * Description of the physical ordering of a relational expression.

File: core/src/main/java/org/apache/calcite/rel/RelFieldCollation.java
Patch:
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.eigenbase.rel;
+package org.apache.calcite.rel;
 
 /**
  * Definition of the ordering of one field of a {@link RelNode} whose

File: example/csv/src/main/java/net/hydromatic/optiq/impl/csv/CsvEnumerator.java
Patch:
@@ -102,6 +102,7 @@ static int[] identityList(int n) {
     return integers;
   }
 
+  /** Row converter. */
   private abstract static class RowConverter {
     abstract Object convertRow(String[] rows);
 
@@ -182,6 +183,7 @@ protected Object convert(CsvFieldType fieldType, String string) {
     }
   }
 
+  /** Array row converter. */
   private static class ArrayRowConverter extends RowConverter {
     private final CsvFieldType[] fieldTypes;
     private final int[] fields;
@@ -201,6 +203,7 @@ public Object convertRow(String[] strings) {
     }
   }
 
+  /** Single column row converter. */
   private static class SingleColumnRowConverter extends RowConverter {
     private final CsvFieldType fieldType;
     private final int fieldIndex;

File: example/csv/src/main/java/net/hydromatic/optiq/impl/csv/CsvFieldType.java
Patch:
@@ -16,10 +16,10 @@
  */
 package net.hydromatic.optiq.impl.csv;
 
-import net.hydromatic.optiq.impl.java.JavaTypeFactory;
-
 import net.hydromatic.linq4j.expressions.Primitive;
 
+import net.hydromatic.optiq.impl.java.JavaTypeFactory;
+
 import org.eigenbase.reltype.RelDataType;
 
 import java.util.HashMap;

File: example/csv/src/main/java/net/hydromatic/optiq/impl/csv/CsvTable.java
Patch:
@@ -16,15 +16,15 @@
  */
 package net.hydromatic.optiq.impl.csv;
 
+import net.hydromatic.linq4j.*;
+
 import net.hydromatic.optiq.*;
 import net.hydromatic.optiq.impl.AbstractTableQueryable;
 import net.hydromatic.optiq.impl.java.AbstractQueryableTable;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 import net.hydromatic.optiq.rules.java.EnumerableConvention;
 import net.hydromatic.optiq.rules.java.JavaRules;
 
-import net.hydromatic.linq4j.*;
-
 import org.eigenbase.rel.RelNode;
 import org.eigenbase.relopt.RelOptTable;
 import org.eigenbase.reltype.*;

File: example/csv/src/main/java/net/hydromatic/optiq/impl/csv/CsvTableScan.java
Patch:
@@ -16,10 +16,10 @@
  */
 package net.hydromatic.optiq.impl.csv;
 
-import net.hydromatic.optiq.rules.java.*;
-
 import net.hydromatic.linq4j.expressions.*;
 
+import net.hydromatic.optiq.rules.java.*;
+
 import org.eigenbase.rel.*;
 import org.eigenbase.relopt.*;
 import org.eigenbase.reltype.*;

File: example/csv/src/main/java/net/hydromatic/optiq/impl/csv/JsonTable.java
Patch:
@@ -16,14 +16,14 @@
  */
 package net.hydromatic.optiq.impl.csv;
 
+import net.hydromatic.linq4j.*;
+
 import net.hydromatic.optiq.*;
 import net.hydromatic.optiq.impl.AbstractTableQueryable;
 import net.hydromatic.optiq.impl.java.AbstractQueryableTable;
 import net.hydromatic.optiq.rules.java.EnumerableConvention;
 import net.hydromatic.optiq.rules.java.JavaRules;
 
-import net.hydromatic.linq4j.*;
-
 import org.eigenbase.rel.RelNode;
 import org.eigenbase.relopt.RelOptTable;
 import org.eigenbase.reltype.*;

File: linq4j/src/main/java/net/hydromatic/linq4j/OrderedEnumerable.java
Patch:
@@ -19,6 +19,8 @@
 /**
  * Represents the result of applying a sorting operation to an
  * {@link net.hydromatic.linq4j.Enumerable}.
+ *
+ * @param <T> element type
  */
 public interface OrderedEnumerable<T>
     extends Enumerable<T>, ExtendedOrderedEnumerable<T> {

File: linq4j/src/main/java/net/hydromatic/linq4j/QueryableDefaults.java
Patch:
@@ -1125,10 +1125,12 @@ public static <T0, T1, TResult> Queryable<TResult> zip(Queryable<T0> source0,
     throw Extensions.todo();
   }
 
+  /** Replayable. */
   public interface Replayable<T> extends Queryable<T> {
     void replay(QueryableFactory<T> factory);
   }
 
+  /** Replayable queryable. */
   public abstract static class ReplayableQueryable<T>
       extends DefaultQueryable<T> implements Replayable<T> {
     public void replay(QueryableFactory<T> factory) {
@@ -1162,6 +1164,7 @@ public <U> Queryable<U> castQueryable() {
     }
   }
 
+  /** Non-leaf replayable queryable. */
   public abstract static class NonLeafReplayableQueryable<T>
       extends ReplayableQueryable<T> {
     private final Queryable<T> original;

File: linq4j/src/main/java/net/hydromatic/linq4j/expressions/BlockBuilder.java
Patch:
@@ -477,6 +477,7 @@ public BlockBuilder append(Expression expression) {
     return this;
   }
 
+  /** Substitute Variable Visitor. */
   private static class SubstituteVariableVisitor extends Visitor {
     private final Map<ParameterExpression, Expression> map;
     private final Map<ParameterExpression, Boolean> actives =
@@ -538,6 +539,7 @@ public Expression visit(UnaryExpression unaryExpression, Expression
     }
   }
 
+  /** Use counter. */
   private static class UseCounter extends Visitor {
     private final Map<ParameterExpression, Slot> map =
         new IdentityHashMap<ParameterExpression, Slot>();

File: linq4j/src/main/java/net/hydromatic/linq4j/expressions/FunctionExpression.java
Patch:
@@ -91,7 +91,7 @@ public F getFunction() {
           new Class[]{Types.toClass(type)},
           new InvocationHandler() {
             public Object invoke(Object proxy, Method method, Object[] args)
-              throws Throwable {
+                throws Throwable {
               return x.dynamicInvoke(args);
             }
           });

File: linq4j/src/main/java/net/hydromatic/linq4j/expressions/Primitive.java
Patch:
@@ -635,7 +635,7 @@ private static void sortBooleanArray(boolean[] booleans, int fromIndex,
    * Sends a field value to a sink.
    */
   public void send(Field field, Object o, Sink sink)
-    throws IllegalAccessException {
+      throws IllegalAccessException {
     switch (this) {
     case BOOLEAN:
       sink.set(field.getBoolean(o));

File: linq4j/src/test/java/net/hydromatic/linq4j/test/ExpressionTest.java
Patch:
@@ -1177,6 +1177,7 @@ public void checkBlockBuilder(boolean optimizing, String expected) {
         Expressions.toString(builder.toBlock()));
   }
 
+  /** An enum. */
   enum MyEnum {
     X,
     Y {
@@ -1194,6 +1195,7 @@ public static int bar(int v, int w, int x, int y, int z) {
     return 0;
   }
 
+  /** A class with a field for each type of interest. */
   public static class AllType {
     public final boolean b;
     public final byte y;

File: avatica/src/main/java/net/hydromatic/avatica/ColumnMetaData.java
Patch:
@@ -175,7 +175,7 @@ public enum Rep {
     STRING(String.class),
     OBJECT(Object.class);
 
-    private final Class clazz;
+    public final Class clazz;
 
     public static final Map<Class, Rep> VALUE_MAP;
 

File: core/src/main/java/net/hydromatic/optiq/impl/MaterializedViewTable.java
Patch:
@@ -102,11 +102,11 @@ public static class MaterializedViewTableMacro
     private final MaterializationKey key;
 
     private MaterializedViewTableMacro(OptiqSchema schema, String viewSql,
-        List<String> viewSchemaPath, String tableName) {
+        List<String> viewSchemaPath, String suggestedTableName) {
       super(schema, viewSql, viewSchemaPath);
       this.key = Preconditions.checkNotNull(
           MaterializationService.instance().defineMaterialization(
-              schema, null, viewSql, schemaPath, tableName, true));
+              schema, null, viewSql, schemaPath, suggestedTableName, true));
     }
 
     @Override

File: core/src/main/java/net/hydromatic/optiq/impl/StarTable.java
Patch:
@@ -72,12 +72,10 @@ public static StarTable of(Lattice lattice, List<Table> tables) {
 
   public RelDataType getRowType(RelDataTypeFactory typeFactory) {
     final List<RelDataType> typeList = new ArrayList<RelDataType>();
-    final List<String> nameList = new ArrayList<String>();
     final List<Integer> fieldCounts = new ArrayList<Integer>();
     for (Table table : tables) {
       final RelDataType rowType = table.getRowType(typeFactory);
       typeList.addAll(RelOptUtil.getFieldTypeList(rowType));
-      nameList.addAll(rowType.getFieldNames());
       fieldCounts.add(rowType.getFieldCount());
     }
     // Compute fieldCounts the first time this method is called. Safe to assume

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -122,7 +122,7 @@ void init() {
       final Lattice lattice = e.getLattice();
       for (Lattice.Tile tile : lattice.computeTiles()) {
         service.defineTile(lattice, tile.bitSet(), tile.measures, e.schema,
-            true);
+            true, true);
       }
     }
   }

File: core/src/main/java/net/hydromatic/optiq/runtime/Utilities.java
Patch:
@@ -30,6 +30,8 @@ protected Utilities() {
   }
 
   public static boolean equal(Object o0, Object o1) {
+    // Same as java.lang.Objects.equals (JDK 1.7 and later)
+    // and com.google.common.base.Objects.equal
     return o0 == o1 || o0 != null && o0.equals(o1);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -775,7 +775,7 @@ public boolean argumentMustBeScalar(int ordinal) {
    * <code>SUM0</code> aggregate function.
    */
   public static final SqlAggFunction SUM0 =
-      new SqlSumEmptyIsZeroAggFunction(null);
+      new SqlSumEmptyIsZeroAggFunction();
 
   //-------------------------------------------------------------
   // WINDOW Rank Functions

File: core/src/test/java/net/hydromatic/optiq/test/MaterializationTest.java
Patch:
@@ -247,7 +247,7 @@ private void checkNoMaterialize(String materialize, String query,
         JdbcTest.HR_MODEL,
         OptiqAssert.checkResultContains(
             "EnumerableCalcRel(expr#0..1=[{inputs}], expr#2=[1], expr#3=[+($t1, $t2)], C=[$t3], deptno=[$t0])\n"
-            + "  EnumerableAggregateRel(group=[{1}], agg#0=[SUM($2)])\n"
+            + "  EnumerableAggregateRel(group=[{1}], agg#0=[$SUM0($2)])\n"
             + "    EnumerableTableAccessRel(table=[[hr, m0]])"));
   }
 

File: core/src/main/java/net/hydromatic/optiq/materialize/Lattice.java
Patch:
@@ -121,7 +121,7 @@ private Lattice(ImmutableList<Node> nodes, boolean auto, boolean algorithm,
             SqlValidatorUtil.uniquify(Lists.transform(columns, GET_ALIAS)));
     if (rowCountEstimate == null) {
       // We could improve this when we fix
-      // [OPTIQ-429] Add statistics SPI for lattice optimization algorithm
+      // [CALCITE-429] Add statistics SPI for lattice optimization algorithm
       rowCountEstimate = 1000d;
     }
     Preconditions.checkArgument(rowCountEstimate > 0d);

File: core/src/main/java/org/eigenbase/rel/metadata/RelMdPredicates.java
Patch:
@@ -193,8 +193,8 @@ public RelOptPredicateList getPredicates(FilterRelBase filter) {
 
   /** Infers predicates for a {@link SemiJoinRel}. */
   public RelOptPredicateList getPredicates(SemiJoinRel semiJoin) {
-    // Workaround, pending
-    // [OPTIQ-390] Transitive Inference(RelMdPredicate) doesn't handle SemiJoin
+    // Workaround, pending [CALCITE-390] "Transitive inference (RelMdPredicate)
+    // doesn't handle semi-join"
     return RelOptPredicateList.EMPTY;
   }
 

File: core/src/test/java/net/hydromatic/optiq/test/FoodmartTest.java
Patch:
@@ -89,7 +89,7 @@ public class FoodmartTest {
     5900, 5901, 5902, 6080, 6091,
 
     // bugs
-    6597, // OPTIQ-403
+    6597, // CALCITE-403
   };
 
   // Interesting tests. (We need to fix and remove from the disabled list.)

File: core/src/test/java/net/hydromatic/optiq/test/JdbcFrontLinqBackTest.java
Patch:
@@ -193,7 +193,7 @@ public class JdbcFrontLinqBackTest {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-9">OPTIQ-9</a>,
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-9">CALCITE-9</a>,
    * "RexToLixTranslator not incrementing local variable name counter". */
   @Test public void testWhereOr() {
     that()

File: core/src/test/java/net/hydromatic/optiq/test/LatticeTest.java
Patch:
@@ -343,7 +343,7 @@ public Void apply(String materializationName) {
    * tiles.
    *
    * <p>Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-428">OPTIQ-428,
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-428">CALCITE-428,
    * "Use optimization algorithm to suggest which tiles of a lattice to
    * materialize"</a>. */
   @Test public void testTileAlgorithm() {

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -314,12 +314,12 @@ private void checkAgg(OptiqAssert.AssertThat with, String fn) {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-119">OPTIQ-119</a>,
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-119">CALCITE-119</a>,
    * "Comparing a Java type long with a SQL type INTEGER gives wrong answer". */
   @Test public void testCompareJavaAndSqlTypes() throws Exception {
     final OptiqAssert.AssertThat with =
         OptiqAssert.that().with("s", new CatchallSchema());
-    // With OPTIQ-119, returned 0 rows. The problem was that when comparing
+    // With CALCITE-119, returned 0 rows. The problem was that when comparing
     // a Java type (long) and a SQL type (INTEGER), the SQL type was deemed
     // "less restrictive". So, the long value got truncated to an int value.
     with.query(

File: core/src/test/java/net/hydromatic/optiq/tools/FrameworksTest.java
Patch:
@@ -121,7 +121,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
    * that allows a larger maximum precision for decimals.
    *
    * <p>Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-413">OPTIQ-413</a>,
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-413">CALCITE-413</a>,
    * "Add RelDataTypeSystem plugin, allowing different max precision of a
    * DECIMAL".
    *

File: core/src/test/java/net/hydromatic/optiq/tools/PlannerTest.java
Patch:
@@ -454,7 +454,7 @@ private void checkJoinNWay(int n) throws Exception {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-435">OPTIQ-435</a>,
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-435">CALCITE-435</a>,
    * "LoptOptimizeJoinRule incorrectly re-orders outer joins".
    *
    * <p>Checks the {@link org.eigenbase.rel.rules.LoptOptimizeJoinRule} on a

File: core/src/test/java/org/eigenbase/test/RelOptRulesTest.java
Patch:
@@ -174,7 +174,7 @@ protected DiffRepository getDiffRepos() {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-434">[OPTIQ-434],
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-434">[CALCITE-434],
    * FilterAggregateTransposeRule loses conditions that cannot be pushed</a>. */
   @Test public void testPushFilterPastAggTwo() {
     checkPlanning(FilterAggregateTransposeRule.INSTANCE,
@@ -204,7 +204,7 @@ protected DiffRepository getDiffRepos() {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-438">[OPTIQ-438],
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-438">[CALCITE-438],
    * Push predicates through SemiJoinRel</a>. */
   @Test public void testPushFilterThroughSemiJoin() {
     final HepProgram preProgram =

File: core/src/test/java/org/eigenbase/test/RexProgramTest.java
Patch:
@@ -439,7 +439,7 @@ static boolean strongIf(RexNode e, BitSet b) {
   }
 
   /** Unit test for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-394">OPTIQ-394,
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-394">CALCITE-394,
    * "Add RexUtil.toCnf, to convert expressions to conjunctive normal form
    * (CNF)"</a>. */
   @Test public void testCnf2() {

File: core/src/test/java/org/eigenbase/test/SqlValidatorTest.java
Patch:
@@ -6486,7 +6486,7 @@ public void _testValuesWithAggFuncs() {
   }
 
   /** Test case for
-   * <a href="https://issues.apache.org/jira/browse/OPTIQ-145">OPTIQ-145,
+   * <a href="https://issues.apache.org/jira/browse/CALCITE-145">CALCITE-145,
    * "Unexpected upper-casing of keywords when using java lexer"</a>. */
   @Test public void testLexJavaKeyword() {
     final SqlTester tester1 = tester.withLex(Lex.JAVA);
@@ -6564,7 +6564,7 @@ public void _testValuesWithAggFuncs() {
     // mysql> select `D`.day from DAYS as `d`, DAYS as `D`;
     // ERROR 1066 (42000): Not unique table/alias: 'D'
     tester2.checkQuery("select count(*) from dept as [D], dept as [d]");
-    if (!Bug.OPTIQ_319_FIXED) {
+    if (!Bug.CALCITE_319_FIXED) {
       return;
     }
     tester1.checkQueryFails("select count(*) from dept as [D], dept as [d]",

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoRules.java
Patch:
@@ -145,7 +145,7 @@ protected RexToMongoTranslator(JavaTypeFactory typeFactory,
         final RexNode op1 = call.operands.get(1);
         if (op1 instanceof RexLiteral
             && op1.getType().getSqlTypeName() == SqlTypeName.INTEGER) {
-          if (!Bug.OPTIQ_194_FIXED) {
+          if (!Bug.CALCITE_194_FIXED) {
             return "'" + stripQuotes(strings.get(0)) + "["
                 + ((RexLiteral) op1).getValue2() + "]'";
           }

File: plus/src/test/java/net/hydromatic/optiq/impl/tpcds/TpcdsTest.java
Patch:
@@ -181,7 +181,7 @@ private OptiqAssert.AssertQuery checkQuery(int i) {
       }
       break;
     case 72:
-      // Work around OPTIQ-304: Support '<DATE> + <INTEGER>'.
+      // Work around CALCITE-304: Support '<DATE> + <INTEGER>'.
       sql = sql.replace("+ 5", "+ interval '5' day");
       break;
     case 95:

File: core/src/main/java/net/hydromatic/optiq/tools/Programs.java
Patch:
@@ -174,13 +174,13 @@ public RelNode run(RelOptPlanner planner, RelNode rel,
    * {@link org.eigenbase.rel.rules.LoptOptimizeJoinRule})
    * if there are 6 or more joins (7 or more relations). */
   public static Program heuristicJoinOrder(final Collection<RelOptRule> rules,
-      final boolean bushy) {
+      final boolean bushy, final int minJoinCount) {
     return new Program() {
       public RelNode run(RelOptPlanner planner, RelNode rel,
           RelTraitSet requiredOutputTraits) {
         final int joinCount = RelOptUtil.countJoins(rel);
         final Program program;
-        if (joinCount < (bushy ? 2 : 6)) {
+        if (joinCount < minJoinCount) {
           program = ofRules(rules);
         } else {
           // Create a program that gathers together joins as a MultiJoinRel.

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -120,7 +120,7 @@ void init() {
     final MaterializationService service = MaterializationService.instance();
     for (OptiqSchema.LatticeEntry e : Schemas.getLatticeEntries(rootSchema)) {
       final Lattice lattice = e.getLattice();
-      for (Lattice.Tile tile : lattice.tiles) {
+      for (Lattice.Tile tile : lattice.computeTiles()) {
         service.defineTile(lattice, tile.bitSet(), tile.measures, e.schema,
             true);
       }

File: core/src/main/java/org/eigenbase/rel/AggregateRelBase.java
Patch:
@@ -68,6 +68,7 @@ protected AggregateRelBase(
     assert groupSet.isEmpty() == (groupSet.cardinality() == 0)
         : "See https://bugs.openjdk.java.net/browse/JDK-6222207, "
         + "BitSet internal invariants may be violated";
+    assert groupSet.length() <= child.getRowType().getFieldCount();
     for (AggregateCall aggCall : aggCalls) {
       assert typeMatchesInferred(aggCall, true);
     }

File: core/src/test/java/net/hydromatic/optiq/test/MaterializationTest.java
Patch:
@@ -238,15 +238,16 @@ private void checkNoMaterialize(String materialize, String query,
   }
 
   /** Aggregation query at coarser level of aggregation than aggregation
-   * materialization. Requires an additional AggregateRel to roll up. */
+   * materialization. Requires an additional AggregateRel to roll up. Note that
+   * COUNT is rolled up using SUM. */
   @Test public void testAggregateRollUp() {
     checkMaterialize(
         "select \"empid\", \"deptno\", count(*) as c, sum(\"empid\") as s from \"emps\" group by \"empid\", \"deptno\"",
         "select count(*) + 1 as c, \"deptno\" from \"emps\" group by \"deptno\"",
         JdbcTest.HR_MODEL,
         OptiqAssert.checkResultContains(
             "EnumerableCalcRel(expr#0..1=[{inputs}], expr#2=[1], expr#3=[+($t1, $t2)], C=[$t3], deptno=[$t0])\n"
-            + "  EnumerableAggregateRel(group=[{1}], agg#0=[COUNT($1)])\n"
+            + "  EnumerableAggregateRel(group=[{1}], agg#0=[SUM($2)])\n"
             + "    EnumerableTableAccessRel(table=[[hr, m0]])"));
   }
 

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeSystemImpl.java
Patch:
@@ -25,8 +25,9 @@
  * values as needed.
  *
  * <table border='1'>
- *   <tr><td>Parameter</td>        <td>Value</td></tr>
- *   <tr><td>MAX_NUMERIC_SCALE</td><td>19</td></tr>
+ *   <caption>Parameter values</caption>
+ *   <tr><th>Parameter</th>         <th>Value</th></tr>
+ *   <tr><td>MAX_NUMERIC_SCALE</td> <td>19</td></tr>
  * </table>
  */
 public abstract class RelDataTypeSystemImpl implements RelDataTypeSystem {

File: avatica/src/main/java/net/hydromatic/avatica/ConnectionProperty.java
Patch:
@@ -46,13 +46,15 @@ public interface ConnectionProperty {
   enum Type {
     BOOLEAN,
     STRING,
-    ENUM;
+    ENUM,
+    PLUGIN;
 
     public boolean valid(Object defaultValue) {
       switch (this) {
       case BOOLEAN:
         return defaultValue instanceof Boolean;
       case STRING:
+      case PLUGIN:
         return defaultValue instanceof String;
       default:
         return defaultValue instanceof Enum;

File: core/src/main/java/net/hydromatic/optiq/config/OptiqConnectionConfig.java
Patch:
@@ -44,6 +44,8 @@ public interface OptiqConnectionConfig extends ConnectionConfig {
   boolean caseSensitive();
   /** @see net.hydromatic.optiq.config.OptiqConnectionProperty#SPARK */
   boolean spark();
+  /** @see net.hydromatic.optiq.config.OptiqConnectionProperty#TYPE_SYSTEM */
+  <T> T typeSystem(Class<T> typeSystemClass, T defaultTypeSystem);
 }
 
 // End OptiqConnectionConfig.java

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcSchema.java
Patch:
@@ -240,7 +240,8 @@ RelProtoDataType getRelDataType(DatabaseMetaData metaData, String catalogName,
     // Temporary type factory, just for the duration of this method. Allowable
     // because we're creating a proto-type, not a type; before being used, the
     // proto-type will be copied into a real type factory.
-    final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
+    final RelDataTypeFactory typeFactory =
+        new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     final RelDataTypeFactory.FieldInfoBuilder fieldInfo = typeFactory.builder();
     while (resultSet.next()) {
       final String columnName = resultSet.getString(4);

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexToLixTranslator.java
Patch:
@@ -251,7 +251,9 @@ Expression translateCast(
                 BuiltinMethod.INTERVAL_DAY_TIME_TO_STRING.method,
                 operand,
                 Expressions.constant(interval.foo()),
-                Expressions.constant(interval.getFractionalSecondPrecision())));
+                Expressions.constant(
+                    interval.getFractionalSecondPrecision(
+                        typeFactory.getTypeSystem()))));
         break;
       case BOOLEAN:
         convert = RexImpTable.optimize2(

File: core/src/main/java/org/eigenbase/rex/RexExecutorImpl.java
Patch:
@@ -61,7 +61,8 @@ private String compile(RexBuilder rexBuilder, List<RexNode> constExps,
       programBuilder.addProject(
           node, "c" + programBuilder.getProjectList().size());
     }
-    final JavaTypeFactoryImpl javaTypeFactory = new JavaTypeFactoryImpl();
+    final JavaTypeFactoryImpl javaTypeFactory =
+        new JavaTypeFactoryImpl(rexBuilder.getTypeFactory().getTypeSystem());
     final BlockBuilder blockBuilder = new BlockBuilder();
     final ParameterExpression root0_ =
         Expressions.parameter(Object.class, "root0");

File: core/src/main/java/org/eigenbase/sql/parser/SqlParserUtil.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.*;
 import java.util.logging.*;
 
+import org.eigenbase.reltype.RelDataTypeSystem;
 import org.eigenbase.sql.*;
 import org.eigenbase.trace.*;
 import org.eigenbase.util.*;
@@ -135,7 +136,7 @@ public static long intervalToMillis(
     int[] ret;
     try {
       ret = intervalQualifier.evaluateIntervalLiteral(literal,
-          intervalQualifier.getParserPosition());
+          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);
       assert ret != null;
     } catch (EigenbaseContextException e) {
       throw Util.newInternal(
@@ -177,7 +178,7 @@ public static long intervalToMonths(
     int[] ret;
     try {
       ret = intervalQualifier.evaluateIntervalLiteral(literal,
-          intervalQualifier.getParserPosition());
+          intervalQualifier.getParserPosition(), RelDataTypeSystem.DEFAULT);
       assert ret != null;
     } catch (EigenbaseContextException e) {
       throw Util.newInternal(

File: core/src/test/java/net/hydromatic/optiq/test/MaterializationTest.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.eigenbase.relopt.SubstitutionVisitor;
 import org.eigenbase.reltype.RelDataType;
+import org.eigenbase.reltype.RelDataTypeSystem;
 import org.eigenbase.rex.*;
 import org.eigenbase.sql.fun.SqlStdOperatorTable;
 
@@ -46,7 +47,8 @@ public class MaterializationTest {
       OptiqAssert.checkResultContains(
           "EnumerableTableAccessRel(table=[[hr, m0]])");
 
-  final JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl();
+  final JavaTypeFactoryImpl typeFactory =
+      new JavaTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
   final RexBuilder rexBuilder = new RexBuilder(typeFactory);
 
   @Test public void testFilter() {

File: core/src/test/java/org/eigenbase/relopt/RelOptUtilTest.java
Patch:
@@ -36,7 +36,8 @@ public RelOptUtilTest() {
   //~ Methods ----------------------------------------------------------------
 
   @Test public void testTypeDump() {
-    RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
+    RelDataTypeFactory typeFactory =
+        new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     RelDataType t1 =
         typeFactory.builder()
             .add("f0", SqlTypeName.DECIMAL, 5, 2)

File: core/src/test/java/org/eigenbase/relopt/volcano/VolcanoPlannerTest.java
Patch:
@@ -60,7 +60,8 @@ public VolcanoPlannerTest() {
 
   static RelOptCluster newCluster(VolcanoPlanner planner) {
     RelOptQuery query = new RelOptQuery(planner);
-    RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
+    RelDataTypeFactory typeFactory =
+        new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     return query.createCluster(
         typeFactory,
         new RexBuilder(typeFactory));

File: core/src/test/java/org/eigenbase/sql/test/DefaultSqlTestFactory.java
Patch:
@@ -17,6 +17,7 @@
 package org.eigenbase.sql.test;
 
 import org.eigenbase.reltype.RelDataTypeFactory;
+import org.eigenbase.reltype.RelDataTypeSystem;
 import org.eigenbase.sql.SqlOperatorTable;
 import org.eigenbase.sql.advise.SqlAdvisor;
 import org.eigenbase.sql.fun.SqlStdOperatorTable;
@@ -74,7 +75,8 @@ public SqlParser createParser(SqlTestFactory factory, String sql) {
   public SqlValidator getValidator(SqlTestFactory factory) {
     final SqlOperatorTable operatorTable = factory.createOperatorTable();
     final boolean caseSensitive = (Boolean) factory.get("caseSensitive");
-    final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
+    final RelDataTypeFactory typeFactory =
+        new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     return SqlValidatorUtil.newValidator(operatorTable,
         new MockCatalogReader(typeFactory, caseSensitive).init(),
         typeFactory);

File: core/src/test/java/org/eigenbase/sql/test/SqlAdvisorTest.java
Patch:
@@ -1176,9 +1176,9 @@ public AdvisorTesterFactory() {
     }
 
     @Override
-    public SqlValidator getValidator(
-        SqlTestFactory factory) {
-      final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
+    public SqlValidator getValidator(SqlTestFactory factory) {
+      final RelDataTypeFactory typeFactory =
+          new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
       final SqlConformance conformance = (SqlConformance) get("conformance");
       final boolean caseSensitive = (Boolean) factory.get("caseSensitive");
       return new SqlAdvisorValidator(

File: core/src/test/java/org/eigenbase/test/RexProgramTest.java
Patch:
@@ -61,7 +61,7 @@ public RexProgramTest() {
 
   @Before
   public void setUp() {
-    typeFactory = new JavaTypeFactoryImpl();
+    typeFactory = new JavaTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     rexBuilder = new RexBuilder(typeFactory);
   }
 

File: core/src/test/java/org/eigenbase/test/RexTransformerTest.java
Patch:
@@ -47,7 +47,7 @@ public class RexTransformerTest {
 
   @Before
   public void setUp() {
-    typeFactory = new JavaTypeFactoryImpl();
+    typeFactory = new JavaTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     rexBuilder = new RexBuilder(typeFactory);
     boolRelDataType = typeFactory.createSqlType(SqlTypeName.BOOLEAN);
 

File: core/src/test/java/org/eigenbase/test/SargTest.java
Patch:
@@ -76,7 +76,8 @@ public SargTest() {
   public void setUp() {
     // create some reusable fixtures
 
-    RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
+    RelDataTypeFactory typeFactory =
+        new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     intType = typeFactory.createSqlType(SqlTypeName.INTEGER);
     intType = typeFactory.createTypeWithNullability(intType, true);
     stringType = typeFactory.createSqlType(SqlTypeName.VARCHAR, 20);

File: core/src/test/java/org/eigenbase/test/SqlToRelTestBase.java
Patch:
@@ -480,7 +480,7 @@ protected final RelDataTypeFactory getTypeFactory() {
     }
 
     protected RelDataTypeFactory createTypeFactory() {
-      return new SqlTypeFactoryImpl();
+      return new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
     }
 
     protected final RelOptPlanner getPlanner() {

File: core/src/test/java/org/eigenbase/test/SqlValidatorFeatureTest.java
Patch:
@@ -124,7 +124,8 @@ public FeatureTesterFactory() {
 
     @Override
     public SqlValidator getValidator(SqlTestFactory factory) {
-      final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
+      final RelDataTypeFactory typeFactory =
+          new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
       SqlConformance conformance = (SqlConformance) get("conformance");
       final boolean caseSensitive = (Boolean) get("caseSensitive");
       return new FeatureValidator(

File: avatica/src/test/java/net/hydromatic/avatica/test/package-info.java
Patch:
@@ -16,8 +16,8 @@
  */
 
 /**
- * Provides utility classes.
+ * Avatica tests.
  */
-package org.eigenbase.util;
+package net.hydromatic.avatica.test;
 
 // End package-info.java

File: core/src/main/java/net/hydromatic/optiq/impl/clone/ArrayTable.java
Patch:
@@ -576,7 +576,7 @@ public Object permute(Object dataSet, int[] sources) {
 
     public Object getObject(Object dataSet, int ordinal) {
       Pair<Object, Integer> pair = (Pair<Object, Integer>) dataSet;
-      return pair.getValue();
+      return pair.left;
     }
 
     public int getInt(Object dataSet, int ordinal) {

File: core/src/main/java/org/eigenbase/rel/rules/AggregateStarTableRule.java
Patch:
@@ -98,7 +98,6 @@ protected void apply(RelOptRuleCall call, ProjectRelBase postProject,
     if (aggregateTable == null) {
       return;
     }
-    System.out.println(aggregateTable);
     final double rowCount = aggregate.getRows();
     final RelOptTable aggregateRelOptTable =
         RelOptTableImpl.create(table.getRelOptSchema(),

File: core/src/main/java/org/eigenbase/relopt/volcano/VolcanoPlanner.java
Patch:
@@ -403,6 +403,9 @@ public RelNode get() {
       if (queryTableNames.contains(lattice.rootTable().getQualifiedName())) {
         RelNode rel2 = lattice.rewrite(leafJoinRoot.get());
         if (rel2 != null) {
+          if (OptiqPrepareImpl.DEBUG) {
+            System.out.println("use lattice:\n" + RelOptUtil.toString(rel2));
+          }
           latticeUses.add(Pair.of(lattice, rel2));
         }
       }

File: core/src/main/java/org/eigenbase/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -28,8 +28,7 @@
 import org.eigenbase.util.*;
 import org.eigenbase.util.mapping.Mappings;
 
-import net.hydromatic.linq4j.function.Function1;
-
+import com.google.common.base.Function;
 import com.google.common.collect.*;
 
 // TODO jvs 10-Feb-2005:  factor out generic rewrite helper, with the
@@ -256,7 +255,7 @@ protected int getNewForOldInput(int oldOrdinal) {
   private Mappings.TargetMapping getNewForOldInputMapping(RelNode oldRel) {
     final RelNode newRel = getNewForOldRel(oldRel);
     return Mappings.target(
-        new Function1<Integer, Integer>() {
+        new Function<Integer, Integer>() {
           public Integer apply(Integer oldInput) {
             return getNewForOldInput(oldInput);
           }

File: core/src/test/java/net/hydromatic/optiq/test/FoodmartTest.java
Patch:
@@ -184,7 +184,7 @@ private FoodMartQuerySet() throws IOException {
     /** Returns the singleton instance of the query set. It is backed by a
      * soft reference, so it may be freed if memory is short and no one is
      * using it. */
-    public static FoodMartQuerySet instance() throws IOException {
+    public static synchronized FoodMartQuerySet instance() throws IOException {
       final SoftReference<FoodMartQuerySet> refLocal = ref;
       if (refLocal != null) {
         final FoodMartQuerySet set = refLocal.get();

File: core/src/test/java/net/hydromatic/optiq/test/LinqFrontJdbcBackTest.java
Patch:
@@ -37,7 +37,7 @@ public class LinqFrontJdbcBackTest {
   @Test public void testTableWhere() throws SQLException,
       ClassNotFoundException {
     final OptiqConnection connection =
-        OptiqAssert.getConnection(false);
+        OptiqAssert.getConnection(OptiqAssert.SchemaSpec.JDBC_FOODMART);
     final SchemaPlus schema =
         connection.getRootSchema().getSubSchema("foodmart");
     ParameterExpression c =

File: core/src/test/java/net/hydromatic/optiq/test/LatticeTest.java
Patch:
@@ -194,7 +194,7 @@ private OptiqAssert.AssertThat modelWithLattices(String... lattices) {
             new Function<RelNode, Void>() {
               public Void apply(RelNode relNode) {
                 counter.incrementAndGet();
-                String s = RelOptUtil.toString(relNode);
+                String s = Util.toLinux(RelOptUtil.toString(relNode));
                 assertThat(s,
                     anyOf(
                         containsString(

File: core/src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -161,7 +161,7 @@ public Void apply(RelNode relNode) {
         if (counter != null) {
           counter.incrementAndGet();
         }
-        String s = RelOptUtil.toString(relNode);
+        String s = Util.toLinux(RelOptUtil.toString(relNode));
         assertThat(s, containsString(expected));
         return null;
       }

File: core/src/test/java/net/hydromatic/optiq/tools/SqlRunTest.java
Patch:
@@ -18,6 +18,8 @@
 
 import net.hydromatic.optiq.test.OptiqAssert;
 
+import org.eigenbase.util.Util;
+
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.Matcher;
 
@@ -241,7 +243,7 @@ public Connection connect(String name) throws Exception {
           }
         });
     writer.flush();
-    String out = writer.toString();
+    String out = Util.toLinux(writer.toString());
     Assert.assertThat(out, matcher);
   }
 }

File: core/src/main/java/org/eigenbase/relopt/RelOptMaterialization.java
Patch:
@@ -157,8 +157,6 @@ private void match(RelNode left, Mappings.TargetMapping leftMapping,
             final Table rightTable = rightRelOptTable.unwrap(Table.class);
             if (leftTable instanceof StarTable
                 && ((StarTable) leftTable).tables.contains(rightTable)) {
-              System.out.println("left: " + leftMapping);
-              System.out.println("right: " + rightMapping);
               Mappings.TargetMapping mapping =
                   Mappings.merge(leftMapping,
                       Mappings.offset(rightMapping,

File: core/src/main/java/org/eigenbase/rel/rules/OptimizeBushyJoinRule.java
Patch:
@@ -242,7 +242,7 @@ private double rowCountDiff(LoptMultiJoin.Edge edge) {
             RexUtil.composeConjunction(rexBuilder, joinVertex.conditions,
                 false);
         relNodes.add(
-            Pair.of(
+            Pair.of((RelNode)
                 joinFactory.createJoin(left, right, condition.accept(shuttle),
                     JoinRelType.INNER, ImmutableSet.<String>of(), false),
                 mapping));

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaConnection.java
Patch:
@@ -371,6 +371,7 @@ public TimeZone getTimeZone() {
   /**
    * Executes a parsed query, closing any previously open result set.
    *
+   * @param statement     Statement
    * @param prepareResult Parsed query
    * @return Result set
    * @throws java.sql.SQLException if a database error occurs

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaFactory.java
Patch:
@@ -57,6 +57,7 @@ AvaticaPreparedStatement newPreparedStatement(
    *
    * @param statement Statement
    * @param prepareResult Prepared statement
+   * @param timeZone Time zone
    * @return Result set
    */
   AvaticaResultSet newResultSet(

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaPreparedStatement.java
Patch:
@@ -43,6 +43,9 @@ public abstract class AvaticaPreparedStatement
    *
    * @param connection Connection
    * @param prepareResult Result of preparing statement
+   * @param resultSetType Result set type
+   * @param resultSetConcurrency Result set concurrency
+   * @param resultSetHoldability Result set holdability
    * @throws SQLException If fails due to underlying implementation reasons.
    */
   protected AvaticaPreparedStatement(

File: avatica/src/test/java/net/hydromatic/avatica/test/ConnectStringParserTest.java
Patch:
@@ -138,8 +138,6 @@ public class ConnectStringParserTest {
    * href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/oledb/htm/oledbconnectionstringsyntax.asp">
    * OLE DB spec</a>. Omitted are cases for Window handles, returning multiple
    * values, and special handling of "Provider" keyword.
-   *
-   * @throws Throwable
    */
   @Test public void testOleDbExamples() throws Throwable {
     // test the parser with examples from OLE DB documentation

File: core/src/test/java/org/eigenbase/test/DiffRepository.java
Patch:
@@ -686,7 +686,8 @@ public interface Filter {
      * @param testCaseName   Test case name
      * @param tag            Tag being expanded
      * @param text           Text being expanded
-     * @param expanded       Expanded text @return Expanded text after filtering
+     * @param expanded       Expanded text
+     * @return Expanded text after filtering
      */
     String filter(
         DiffRepository diffRepository,

File: core/src/test/java/org/eigenbase/test/SqlToRelTestBase.java
Patch:
@@ -147,6 +147,7 @@ void assertConvertsTo(
      *
      * @param sql  SQL query
      * @param plan Expected plan
+     * @param trim Whether to trim columns that are not needed
      */
     void assertConvertsTo(
         String sql,

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/search/package-info.java
Patch:
@@ -16,8 +16,8 @@
 */
 
 /**
- * Provides utility classes.
+ * Executes queries via Splunk's REST API.
  */
-package org.eigenbase.util;
+package net.hydromatic.optiq.impl.splunk.search;
 
 // End package-info.java

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/util/package-info.java
Patch:
@@ -16,8 +16,8 @@
 */
 
 /**
- * Provides utility classes.
+ * Utilities for RPC to Splunk.
  */
-package org.eigenbase.util;
+package net.hydromatic.optiq.impl.splunk.util;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -4084,7 +4084,7 @@ && isConvertedSubq(rex)) {
         if (needTruthTest) {
           fieldAccess =
               rexBuilder.makeCall(
-                  SqlStdOperatorTable.IS_TRUE,
+                  SqlStdOperatorTable.IS_NOT_NULL,
                   fieldAccess);
         }
         return fieldAccess;

File: core/src/main/java/org/eigenbase/rel/rules/OptimizeBushyJoinRule.java
Patch:
@@ -124,7 +124,8 @@ private double rowCountDiff(LoptMultiJoin.Edge edge) {
       if (edgeOrdinal == -1) {
         // No more edges. Are there any un-joined vertexes?
         final Vertex lastVertex = Util.last(vertexes);
-        final int z = lastVertex.factors.previousClearBit(lastVertex.id - 1);
+        final int z =
+            BitSets.previousClearBit(lastVertex.factors, lastVertex.id - 1);
         if (z < 0) {
           break;
         }

File: core/src/main/java/net/hydromatic/optiq/tools/Programs.java
Patch:
@@ -137,6 +137,7 @@ public RelNode run(RelOptPlanner planner, RelNode rel,
           final List<RelOptRule> list = new ArrayList<RelOptRule>(rules);
           list.removeAll(
               ImmutableList.of(SwapJoinRule.INSTANCE,
+                  CommutativeJoinRule.INSTANCE,
                   PushJoinThroughJoinRule.LEFT,
                   PushJoinThroughJoinRule.RIGHT));
           list.add(LoptOptimizeJoinRule.INSTANCE);

File: core/src/main/java/org/eigenbase/rel/rules/LoptOptimizeJoinRule.java
Patch:
@@ -643,9 +643,8 @@ private LoptJoinTree createOrdering(
       int firstFactor) {
     LoptJoinTree joinTree = null;
     int nJoinFactors = multiJoin.getNumJoinFactors();
-    BitSet factorsToAdd = new BitSet(nJoinFactors);
+    BitSet factorsToAdd = BitSets.range(0, nJoinFactors);
     BitSet factorsAdded = new BitSet(nJoinFactors);
-    factorsToAdd.flip(0, nJoinFactors);
     List<RexNode> filtersToAdd =
         new ArrayList<RexNode>(multiJoin.getJoinFilters());
 

File: core/src/test/java/net/hydromatic/optiq/test/MaterializationTest.java
Patch:
@@ -104,7 +104,7 @@ private void checkMaterialize(String materialize, String query, String model,
           .withMaterializations(model, "m0", materialize)
           .query(query)
           .enableMaterializations(true)
-          .explainMatches(explainChecker)
+          .explainMatches("", explainChecker)
           .sameResultWithMaterializationsDisabled();
     } finally {
       Prepare.THREAD_TRIM.set(false);

File: core/src/main/java/org/eigenbase/sql2rel/RelDecorrelator.java
Patch:
@@ -24,6 +24,7 @@
 import org.eigenbase.rel.*;
 import org.eigenbase.rel.CorrelatorRel.Correlation;
 import org.eigenbase.rel.metadata.*;
+import org.eigenbase.rel.rules.PushFilterPastJoinRule;
 import org.eigenbase.relopt.*;
 import org.eigenbase.relopt.hep.*;
 import org.eigenbase.reltype.*;
@@ -119,6 +120,7 @@ public RelNode decorrelate(RelNode root) {
     HepProgram program = HepProgram.builder()
         .addRuleInstance(new AdjustProjectForCountAggregateRule(false))
         .addRuleInstance(new AdjustProjectForCountAggregateRule(true))
+        .addRuleInstance(PushFilterPastJoinRule.FILTER_ON_JOIN)
         .build();
 
     HepPlanner planner = createPlanner(program);

File: core/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -2130,9 +2130,7 @@ private RexNode pushDownJoinConditions(
         final int left3 = leftCount + extraLeftExprs.size();
         final int right3 = rightCount + extraRightExprs.size();
         fix(remainingOperands, left2, left3);
-        fix(remainingOperands, left3 + right2, left3 + right3);
         fix(list, left2, left3);
-        fix(list, left3 + right2, left3 + right3);
         list.add(e);
       }
       if (!list.equals(call.getOperands())) {
@@ -2147,6 +2145,7 @@ private RexNode pushDownJoinConditions(
       final int mid = leftCount + extraLeftExprs.size();
       switch (Side.of(bits, mid)) {
       case LEFT:
+        fix(extraRightExprs, mid, mid + 1);
         extraLeftExprs.add(node);
         return new RexInputRef(mid, node.getType());
       case RIGHT:

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeExplicitPrecedenceList.java
Patch:
@@ -97,7 +97,8 @@ public class SqlTypeExplicitPrecedenceList
   //~ Constructors -----------------------------------------------------------
 
   public SqlTypeExplicitPrecedenceList(List<SqlTypeName> typeNames) {
-    this.typeNames = ImmutableList.copyOf(typeNames);
+    this.typeNames = new ArrayList();
+    this.typeNames.addAll(typeNames);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/net/hydromatic/optiq/ImplementableAggFunction.java
Patch:
@@ -21,7 +21,7 @@
 
 /**
  * Function that can be translated to java code.
- * <p>
+ *
  * @see net.hydromatic.optiq.rules.java.AggImplementor
  * @see net.hydromatic.optiq.rules.java.WinAggImplementor
  * @see net.hydromatic.optiq.rules.java.StrictAggImplementor
@@ -30,6 +30,7 @@
 public interface ImplementableAggFunction extends AggregateFunction {
   /**
    * Returns implementor that translates the function to linq4j expression.
+   *
    * @param windowContext true when aggregate is used in window context
    * @return implementor that translates the function to linq4j expression.
    */

File: core/src/main/java/org/eigenbase/sql/SqlOperator.java
Patch:
@@ -631,7 +631,7 @@ public boolean isAggregator() {
    * Returns whether this is a window function that requires ordering.
    *
    * <p>Per SQL:2011, 2, 6.10: "If &lt;ntile function&gt;, &lt;lead or lag
-   * function&gt, RANK or DENSE_RANK is specified, then the window ordering
+   * function&gt;, RANK or DENSE_RANK is specified, then the window ordering
    * clause shall be present."</p>
    *
    * @see #isAggregator()

File: core/src/test/java/net/hydromatic/optiq/test/JdbcFrontLinqBackTest.java
Patch:
@@ -193,7 +193,9 @@ public class JdbcFrontLinqBackTest {
         .throws_("Column 'EMPID' not found in any table");
   }
 
-  /** Test case for https://github.com/julianhyde/optiq/issues/9. */
+  /** Test case for
+   * <a href="https://issues.apache.org/jira/browse/OPTIQ-9">OPTIQ-9</a>,
+   * "RexToLixTranslator not incrementing local variable name counter". */
   @Test public void testWhereOr() {
     that()
         .query(

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -315,8 +315,8 @@ private void checkAgg(OptiqAssert.AssertThat with, String fn) {
   }
 
   /** Test case for
-   * <a href="https://github.com/julianhyde/optiq/issues/119">optiq-119</a>.
-   * Comparing a Java type with a SQL type. */
+   * <a href="https://issues.apache.org/jira/browse/OPTIQ-119">OPTIQ-119</a>,
+   * "Comparing a Java type long with a SQL type INTEGER gives wrong answer". */
   @Test public void testCompareJavaAndSqlTypes() throws Exception {
     final OptiqAssert.AssertThat with =
         OptiqAssert.that().with("s", new CatchallSchema());

File: core/src/test/java/org/eigenbase/test/SqlValidatorTest.java
Patch:
@@ -6469,7 +6469,7 @@ public void _testValuesWithAggFuncs() {
   }
 
   /** Test case for
-   * <a href="https://github.com/julianhyde/optiq/issues/145">optiq-145,
+   * <a href="https://issues.apache.org/jira/browse/OPTIQ-145">OPTIQ-145,
    * "Unexpected upper-casing of keywords when using java lexer"</a>. */
   @Test public void testLexJavaKeyword() {
     final SqlTester tester1 = tester.withLex(Lex.JAVA);

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeName.java
Patch:
@@ -72,7 +72,8 @@ public enum SqlTypeName {
   VARBINARY(PrecScale.NO_NO | PrecScale.YES_NO, false, Types.VARBINARY,
       SqlTypeFamily.BINARY),
   NULL(PrecScale.NO_NO, true, Types.NULL, SqlTypeFamily.NULL),
-  ANY(PrecScale.NO_NO, true, Types.JAVA_OBJECT, SqlTypeFamily.ANY),
+  ANY(PrecScale.NO_NO | PrecScale.YES_NO | PrecScale.YES_YES, true,
+      Types.JAVA_OBJECT, SqlTypeFamily.ANY),
   SYMBOL(PrecScale.NO_NO, true, Types.OTHER, null),
   MULTISET(PrecScale.NO_NO, false, Types.ARRAY, SqlTypeFamily.MULTISET),
   ARRAY(PrecScale.NO_NO, false, Types.ARRAY, SqlTypeFamily.ARRAY),

File: core/src/test/java/net/hydromatic/optiq/test/OptiqSuite.java
Patch:
@@ -21,6 +21,7 @@
 import net.hydromatic.optiq.runtime.BinarySearchTest;
 import net.hydromatic.optiq.tools.FrameworksTest;
 import net.hydromatic.optiq.tools.PlannerTest;
+import net.hydromatic.optiq.tools.SqlRunTest;
 import net.hydromatic.optiq.util.PartiallyOrderedSetTest;
 import net.hydromatic.optiq.util.graph.DirectedGraphTest;
 
@@ -106,6 +107,7 @@
 
     // slow tests that don't break often
     SqlToRelConverterExtendedTest.class,
+    SqlRunTest.class,
     PartiallyOrderedSetTest.class
 })
 public class OptiqSuite {

File: core/src/main/java/net/hydromatic/optiq/rules/java/JavaRules.java
Patch:
@@ -1180,8 +1180,7 @@ public RexToLixTranslator rowTranslator() {
                     childExp,
                     BuiltinMethod.DISTINCT.method,
                     Expressions.<Expression>list()
-                        .appendIfNotNull(
-                            keyPhysType.comparer()))));
+                        .appendIfNotNull(physType.comparer()))));
       } else {
         final Expression resultSelector =
             builder.append(

File: core/src/main/java/net/hydromatic/optiq/prepare/Prepare.java
Patch:
@@ -255,6 +255,8 @@ public PreparedResult prepareSql(
     // Trim unused fields.
     rootRel = trimUnusedFields(rootRel);
 
+    Hook.TRIMMED.run(rootRel);
+
     // Display physical plan after decorrelation.
     if (sqlExplain != null) {
       SqlExplain.Depth explainDepth = sqlExplain.getDepth();

File: core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -3688,9 +3688,10 @@ private void startOfGroupStep3(String startOfGroup) {
             + "from \"hr\".\"emps\"\n"
             + "where \"empid\" > 10")
           .convertContains(
-              "ProjectRel(name=[$2], EXPR$1=[+(CAST(COUNT($4) OVER (PARTITION BY $1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)):BIGINT, 1)])\n"
+              "ProjectRel(name=[$2], EXPR$1=[+(CAST(COUNT($3) OVER (PARTITION BY $1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)):BIGINT, 1)])\n"
               + "  FilterRel(condition=[>($0, 10)])\n"
-              + "    EnumerableTableAccessRel(table=[[hr, emps]])\n");
+              + "    ProjectRel(empid=[$0], deptno=[$1], name=[$2], commission=[$4])\n"
+              + "      EnumerableTableAccessRel(table=[[hr, emps]])\n");
     } finally {
       Prepare.trim = false;
     }

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1812,6 +1812,9 @@ private SqlNode registerFrom(
     case WITH:
     case UNNEST:
     case OTHER_FUNCTION:
+      if (alias == null) {
+        alias = deriveAlias(node, nextGeneratedId++);
+      }
       registerQuery(
           parentScope,
           usingScope,

File: core/src/main/java/org/eigenbase/sql/fun/SqlFirstLastValueAggFunction.java
Patch:
@@ -37,7 +37,7 @@ public SqlFirstLastValueAggFunction(boolean firstFlag) {
     super(
         firstFlag ? "FIRST_VALUE" : "LAST_VALUE",
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.ARG0,
+        ReturnTypes.ARG0_NULLABLE_IF_EMPTY,
         null,
         OperandTypes.ANY,
         SqlFunctionCategory.NUMERIC);

File: core/src/main/java/org/eigenbase/rel/rules/PullConstantsThroughAggregatesRule.java
Patch:
@@ -139,8 +139,7 @@ public void onMatch(RelOptRuleCall call) {
 
       // Ensure that the first positions in the mapping are for the new
       // group columns.
-      for (
-          int i = 0, groupOrdinal = 0, constOrdinal = newGroupCount;
+      for (int i = 0, groupOrdinal = 0, constOrdinal = newGroupCount;
           i < groupCount;
           ++i) {
         if (i >= groupCount) {

File: core/src/main/java/org/eigenbase/rel/rules/PushSemiJoinPastJoinRule.java
Patch:
@@ -205,8 +205,7 @@ private void setJoinAdjustments(
     for (int i = nFieldsX; i < (nFieldsX + nFieldsY); i++) {
       adjustments[i] = adjustY;
     }
-    for (
-        int i = nFieldsX + nFieldsY;
+    for (int i = nFieldsX + nFieldsY;
         i < (nFieldsX + nFieldsY + nFieldsZ);
         i++) {
       adjustments[i] = adjustZ;

File: core/src/main/java/org/eigenbase/rex/RexProgram.java
Patch:
@@ -559,9 +559,7 @@ public static void deduceCollations(
     for (RelCollation collation : inputCollations) {
       final ArrayList<RelFieldCollation> fieldCollations =
           new ArrayList<RelFieldCollation>(0);
-      for (
-          RelFieldCollation fieldCollation
-          : collation.getFieldCollations()) {
+      for (RelFieldCollation fieldCollation : collation.getFieldCollations()) {
         final int source = fieldCollation.getFieldIndex();
         final int target = targets[source];
         if (target < 0) {

File: core/src/main/java/org/eigenbase/sql2rel/RelDecorrelator.java
Patch:
@@ -1070,8 +1070,7 @@ public void decorrelateRel(JoinRel rel) {
       SortedMap<CorrelatorRel.Correlation, Integer>
           rightChildMapCorVarToOutputPos =
           mapNewRelToMapCorVarToOutputPos.get(newRightRel);
-      for (
-          CorrelatorRel.Correlation corVar
+      for (CorrelatorRel.Correlation corVar
           : rightChildMapCorVarToOutputPos.keySet()) {
         oldRightPos = rightChildMapCorVarToOutputPos.get(corVar);
         mapCorVarToOutputPos.put(

File: core/src/main/java/org/eigenbase/util/RhBase64.java
Patch:
@@ -1098,9 +1098,8 @@ public int read() throws IOException {
             int b = 0;
             do {
               b = in.read();
-            } while (
-                (b >= 0)
-                    && (DECODABET[b & 0x7f] <= WHITE_SPACE_ENC));
+            } while ((b >= 0)
+                && (DECODABET[b & 0x7f] <= WHITE_SPACE_ENC));
 
             if (b < 0) {
               break; // Reads a -1 if end of stream

File: core/src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -179,6 +179,8 @@ public enum BuiltinMethod {
   BOOLEAN_TO_STRING(SqlFunctions.class, "toString", boolean.class),
   JDBC_ARRAY_TO_LIST(SqlFunctions.class, "arrayToList", java.sql.Array.class),
   OBJECT_TO_STRING(Object.class, "toString"),
+  OBJECTS_EQUAL(com.google.common.base.Objects.class, "equal", Object.class,
+      Object.class),
   ROUND_LONG(SqlFunctions.class, "round", long.class, long.class),
   ROUND_INT(SqlFunctions.class, "round", int.class, int.class),
   DATE_TO_INT(SqlFunctions.class, "toInt", java.util.Date.class),

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -105,7 +105,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
     if (fieldCount == 1) {
       final ParameterExpression value_ =
           Expressions.parameter(Object.class, builder.newName("value"));
-      builder.add(Expressions.declare(0, value_, null));
+      builder.add(Expressions.declare(Modifier.FINAL, value_, null));
       generateGet(implementor, physType, builder, resultSet_, 0, value_,
           calendar_, calendarPolicy);
       builder.add(Expressions.return_(null, value_));

File: core/src/main/java/net/hydromatic/optiq/rules/java/EnumerableRelImplementor.java
Patch:
@@ -267,9 +267,9 @@ private ClassDeclaration classDecl(
     final BlockBuilder blockBuilder4 = new BlockBuilder();
     final ParameterExpression cParameter =
         Expressions.parameter(int.class, "c");
+    final int mod = type.getRecordFields().size() == 1 ? Modifier.FINAL : 0;
     blockBuilder4.add(
-        Expressions.declare(
-            0, cParameter, null));
+        Expressions.declare(mod, cParameter, null));
     final ConditionalStatement conditionalStatement =
         Expressions.ifThen(
             Expressions.notEqual(cParameter, constantZero),

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexToLixTranslator.java
Patch:
@@ -32,8 +32,7 @@
 import org.eigenbase.sql.*;
 import org.eigenbase.util.*;
 
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
+import java.lang.reflect.*;
 import java.math.BigDecimal;
 import java.util.*;
 
@@ -352,7 +351,7 @@ private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs,
       }
       ParameterExpression unboxed = Expressions.parameter(nullHandled.getType(),
           list.newName(unboxVarName));
-      list.add(Expressions.declare(0, unboxed, nullHandled));
+      list.add(Expressions.declare(Modifier.FINAL, unboxed, nullHandled));
 
       return unboxed;
     case LOCAL_REF:

File: core/src/main/java/org/eigenbase/sql/type/ReturnTypes.java
Patch:
@@ -62,7 +62,7 @@ public static ExplicitReturnTypeInference explicit(RelDataType type) {
    * such as {@code DATE}.
    */
   public static ExplicitReturnTypeInference explicit(SqlTypeName typeName) {
-    return explicit(RelDataTypeImpl.proto(typeName));
+    return explicit(RelDataTypeImpl.proto(typeName, false));
   }
 
   /**
@@ -71,7 +71,7 @@ public static ExplicitReturnTypeInference explicit(SqlTypeName typeName) {
    */
   public static ExplicitReturnTypeInference explicit(SqlTypeName typeName,
       int precision) {
-    return explicit(RelDataTypeImpl.proto(typeName, precision));
+    return explicit(RelDataTypeImpl.proto(typeName, precision, false));
   }
 
   /**

File: core/src/test/java/org/eigenbase/test/DiffTestCase.java
Patch:
@@ -386,7 +386,7 @@ private static boolean inIde() {
    * Returns a string containing the difference between the contents of two
    * files. The string has a similar format to the UNIX 'diff' utility.
    */
-  private static String diff(File file1, File file2) {
+  public static String diff(File file1, File file2) {
     List<String> lines1 = fileLines(file1);
     List<String> lines2 = fileLines(file2);
     return diffLines(lines1, lines2);

File: src/main/java/net/hydromatic/linq4j/Linq4j.java
Patch:
@@ -34,7 +34,7 @@ private Linq4j() {}
   private static final Method AUTO_CLOSEABLE_CLOSE_METHOD =
       getMethod("java.lang.AutoCloseable", "close");
 
-  private static Method getMethod(String className, String methodName,
+  public static Method getMethod(String className, String methodName,
       Class... parameterTypes) {
     try {
       return Class.forName(className).getMethod(methodName, parameterTypes);

File: core/src/main/java/org/eigenbase/rex/RexWindow.java
Patch:
@@ -62,9 +62,6 @@ public class RexWindow {
     this.upperBound = upperBound;
     this.isRows = isRows;
     this.digest = computeDigest();
-    if (!isRows) {
-      assert orderKeys.size() > 0 : "logical window requires sort key";
-    }
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlFunction.java
Patch:
@@ -113,6 +113,7 @@ protected SqlFunction(
     this.category = category;
     this.paramTypes =
         paramTypes == null ? null : ImmutableList.copyOf(paramTypes);
+    assert category != null;
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlFunctionalOperator.java
Patch:
@@ -51,7 +51,7 @@ public void unparse(
       SqlCall call,
       int leftPrec,
       int rightPrec) {
-    SqlUtil.unparseFunctionSyntax(this, writer, call, true, null);
+    SqlUtil.unparseFunctionSyntax(this, writer, call);
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/SqlJdbcFunctionCall.java
Patch:
@@ -399,7 +399,7 @@ public SqlJdbcFunctionCall(String name) {
         null,
         null,
         OperandTypes.VARIADIC,
-        null);
+        SqlFunctionCategory.SYSTEM);
     jdbcName = name;
     lookupMakeCallObj = JdbcToInternalLookupTable.INSTANCE.lookup(name);
     lookupCall = null;

File: core/src/main/java/org/eigenbase/sql/fun/SqlRowOperator.java
Patch:
@@ -76,7 +76,7 @@ public void unparse(
       SqlCall call,
       int leftPrec,
       int rightPrec) {
-    SqlUtil.unparseFunctionSyntax(this, writer, call, true, null);
+    SqlUtil.unparseFunctionSyntax(this, writer, call);
   }
 
   // override SqlOperator

File: core/src/main/java/org/eigenbase/sql/validate/SqlUserDefinedAggFunction.java
Patch:
@@ -44,7 +44,8 @@ public SqlUserDefinedAggFunction(SqlIdentifier opName,
       SqlOperandTypeInference operandTypeInference,
       SqlOperandTypeChecker operandTypeChecker, AggregateFunction function) {
     super(Util.last(opName.names), opName, SqlKind.OTHER_FUNCTION,
-        returnTypeInference, operandTypeInference, operandTypeChecker, null);
+        returnTypeInference, operandTypeInference, operandTypeChecker,
+        SqlFunctionCategory.USER_DEFINED_FUNCTION);
     this.function = function;
   }
 

File: core/src/main/java/org/eigenbase/sql/validate/SqlUserDefinedFunction.java
Patch:
@@ -39,7 +39,7 @@ public SqlUserDefinedFunction(SqlIdentifier opName,
       Function function) {
     super(Util.last(opName.names), opName, SqlKind.OTHER_FUNCTION,
         returnTypeInference, operandTypeInference, operandTypeChecker,
-        null, null);
+        null, SqlFunctionCategory.USER_DEFINED_FUNCTION);
     this.function = function;
   }
 

File: core/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -1585,9 +1585,6 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
         throw new AssertionError(
             "Relation should have sort key for implicit ORDER BY");
       }
-      if (orderList.size() <= 0) {
-        throw new AssertionError("sort key must not be empty");
-      }
     }
     final ImmutableList.Builder<RexFieldCollation> orderKeys =
         ImmutableList.builder();

File: core/src/main/java/org/eigenbase/sql/advise/SqlAdvisorGetHintsFunction.java
Patch:
@@ -107,7 +107,7 @@ public static Enumerable<SqlAdvisorHint> getCompletionHints(
     for (SqlMoniker hint : hints) {
       res.add(new SqlAdvisorHint(hint));
     }
-    return Linq4j.asEnumerable(res).<SqlAdvisorHint>asQueryable();
+    return Linq4j.asEnumerable(res).asQueryable();
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/SqlWithItem.java
Patch:
@@ -94,7 +94,7 @@ public void unparse(
       if (withItem.columnList != null) {
         withItem.columnList.unparse(writer, getLeftPrec(), getRightPrec());
       }
-      writer.sep("AS");
+      writer.keyword("AS");
       withItem.query.unparse(writer, getLeftPrec(), getRightPrec());
     }
 

File: core/src/main/java/org/eigenbase/sql/validate/WithScope.java
Patch:
@@ -50,7 +50,7 @@ public SqlNode getNode() {
   @Override
   public SqlValidatorNamespace getTableNamespace(List<String> names) {
     if (names.size() == 1 && names.get(0).equals(withItem.name.getSimple())) {
-      return getValidator().getNamespace(withItem.query);
+      return validator.getNamespace(withItem);
     }
     return super.getTableNamespace(names);
   }
@@ -60,7 +60,7 @@ public SqlValidatorNamespace resolve(String name,
       SqlValidatorScope[] ancestorOut,
       int[] offsetOut) {
     if (name.equals(withItem.name.getSimple())) {
-      return getValidator().getNamespace(withItem.query);
+      return validator.getNamespace(withItem);
     }
     return super.resolve(name, ancestorOut, offsetOut);
   }

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqSchema.java
Patch:
@@ -686,7 +686,7 @@ private static class SubSchemaCache {
     private SubSchemaCache(final OptiqSchema optiqSchema,
         ImmutableSortedSet<String> names) {
       this.names = names;
-      this.cache = CacheBuilder.<String, OptiqSchema>newBuilder().build(
+      this.cache = CacheBuilder.newBuilder().build(
           new CacheLoader<String, OptiqSchema>() {
             @SuppressWarnings("NullableProblems")
             @Override public OptiqSchema load(String schemaName) {

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaResultSetMetaData.java
Patch:
@@ -106,11 +106,11 @@ public String getCatalogName(int column) throws SQLException {
   }
 
   public int getColumnType(int column) throws SQLException {
-    return getColumnMetaData(column).type;
+    return getColumnMetaData(column).type.type;
   }
 
   public String getColumnTypeName(int column) throws SQLException {
-    return getColumnMetaData(column).typeName;
+    return getColumnMetaData(column).type.typeName;
   }
 
   public boolean isReadOnly(int column) throws SQLException {

File: avatica/src/main/java/net/hydromatic/avatica/Cursor.java
Patch:
@@ -36,10 +36,11 @@ public interface Cursor extends Closeable {
    *
    * @param types List of column types, per {@link java.sql.Types}.
    * @param localCalendar Calendar in local timezone
+   * @param factory Factory that creates sub-ResultSets when needed
    * @return List of column accessors
    */
   List<Accessor> createAccessors(List<ColumnMetaData> types,
-      Calendar localCalendar);
+      Calendar localCalendar, ArrayImpl.Factory factory);
 
   /**
    * Moves to the next row.

File: core/src/main/java/net/hydromatic/optiq/materialize/MaterializationService.java
Patch:
@@ -79,10 +79,10 @@ public MaterializationKey defineMaterialization(final OptiqSchema schema,
         materializedTable =
             CloneSchema.createCloneTable(typeFactory,
                 RelDataTypeImpl.proto(prepareResult.rowType),
-                Functions.adapt(prepareResult.columnList,
+                Functions.adapt(prepareResult.structType.columns,
                     new Function1<ColumnMetaData, ColumnMetaData.Rep>() {
                       public ColumnMetaData.Rep apply(ColumnMetaData column) {
-                        return column.representation;
+                        return column.type.representation;
                       }
                     }),
                 new AbstractQueryable<Object>() {

File: core/src/main/java/net/hydromatic/optiq/jdbc/MetaImpl.java
Patch:
@@ -149,7 +149,7 @@ static ColumnMetaData columnMetaData(String name, int index, Class<?> type) {
             : DatabaseMetaData.columnNoNulls,
         true, -1, name, name, null,
         0, 0, null, null, pair.left, pair.right, true,
-        false, false, null, rep);
+        false, false, null, null, rep);
   }
 
   static List<ColumnMetaData> fieldMetaData(Class clazz) {

File: mongodb/src/test/java/net/hydromatic/optiq/test/MongoAdapterTest.java
Patch:
@@ -503,6 +503,7 @@ public Void apply(ResultSet resultSet) {
                 + "}"));
   }
 
+  @Ignore("https://github.com/julianhyde/optiq/issues/270")
   @Test public void testGroupByHaving2() {
     OptiqAssert.that()
         .enable(enabled())

File: core/src/main/java/net/hydromatic/optiq/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -159,6 +159,7 @@ public Type getJavaClass(RelDataType type) {
     case MAP:
       return Map.class;
     case ARRAY:
+    case MULTISET:
       return List.class;
     }
     return null;

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -159,6 +159,8 @@ protected RelOptPlanner createPlanner(Context context) {
     planner.addRule(JavaRules.ENUMERABLE_AGGREGATE_RULE);
     planner.addRule(JavaRules.ENUMERABLE_SORT_RULE);
     planner.addRule(JavaRules.ENUMERABLE_LIMIT_RULE);
+    planner.addRule(JavaRules.ENUMERABLE_COLLECT_RULE);
+    planner.addRule(JavaRules.ENUMERABLE_UNCOLLECT_RULE);
     planner.addRule(JavaRules.ENUMERABLE_UNION_RULE);
     planner.addRule(JavaRules.ENUMERABLE_INTERSECT_RULE);
     planner.addRule(JavaRules.ENUMERABLE_MINUS_RULE);

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexImpTable.java
Patch:
@@ -167,6 +167,8 @@ public Expression implement(RexToLixTranslator translator,
     // Multisets & arrays
     defineMethod(CARDINALITY, BuiltinMethod.COLLECTION_SIZE.method,
         NullPolicy.STRICT);
+    defineMethod(SLICE, BuiltinMethod.SLICE.method, NullPolicy.NONE);
+    defineMethod(ELEMENT, BuiltinMethod.ELEMENT.method, NullPolicy.STRICT);
 
     map.put(CASE, new CaseImplementor());
 

File: core/src/main/java/org/eigenbase/sql/SqlUnnestOperator.java
Patch:
@@ -34,7 +34,7 @@ public SqlUnnestOperator() {
         true,
         null,
         null,
-        OperandTypes.MULTISET_OR_RECORD_MULTISET);
+        OperandTypes.SCALAR_OR_RECORD_COLLECTION);
   }
 
   //~ Methods ----------------------------------------------------------------
@@ -45,8 +45,8 @@ public RelDataType inferReturnType(
     if (type.isStruct()) {
       type = type.getFieldList().get(0).getType();
     }
-    MultisetSqlType t = (MultisetSqlType) type;
-    return t.getComponentType();
+    assert type instanceof ArraySqlType || type instanceof MultisetSqlType;
+    return type.getComponentType();
   }
 
   public boolean argumentMustBeScalar(int ordinal) {

File: core/src/main/java/org/eigenbase/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -1247,7 +1247,7 @@ public SqlOperandCountRange getOperandCountRange() {
           SqlKind.OTHER_FUNCTION,
           ReturnTypes.MULTISET_ELEMENT_NULLABLE,
           null,
-          OperandTypes.MULTISET,
+          OperandTypes.COLLECTION,
           SqlFunctionCategory.SYSTEM);
 
   /**
@@ -1299,7 +1299,7 @@ public SqlOperandCountRange getOperandCountRange() {
           false,
           ReturnTypes.MULTISET_PROJECT0,
           null,
-          OperandTypes.RECORD_MULTISET) {
+          OperandTypes.RECORD_COLLECTION) {
       };
 
   /**
@@ -1378,7 +1378,7 @@ public boolean argumentMustBeScalar(int ordinal) {
           SqlKind.OTHER_FUNCTION,
           ReturnTypes.INTEGER_NULLABLE,
           null,
-          OperandTypes.COLLECTION,
+          OperandTypes.COLLECTION_OR_MAP,
           SqlFunctionCategory.SYSTEM);
 
   /**

File: core/src/main/java/org/eigenbase/rel/rules/PushProjector.java
Patch:
@@ -556,7 +556,8 @@ public ProjectRel createNewProject(RelNode projChild, int[] adjustments) {
     return (ProjectRel) CalcRel.createProject(
         projChild,
         Pair.left(projects),
-        Pair.right(projects));
+        Pair.right(projects),
+        true /* optimize to avoid trivial projections, as per javadoc */);
   }
 
   //~ Inner Classes ----------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlMinMaxAggFunction.java
Patch:
@@ -66,7 +66,7 @@ public SqlMinMaxAggFunction(
     super(
         isMin ? "MIN" : "MAX",
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.ARG0,
+        ReturnTypes.ARG0_NULLABLE_IF_EMPTY,
         null,
         OperandTypes.COMPARABLE_ORDERED,
         SqlFunctionCategory.SYSTEM);

File: core/src/test/java/org/eigenbase/test/DiffRepository.java
Patch:
@@ -406,6 +406,7 @@ public void assertEquals(String tag, String expected, String actual) {
         String actualCanonical =
             actual.replace(Util.LINE_SEPARATOR, "\n");
         Assert.assertEquals(
+            tag,
             expected2Canonical,
             actualCanonical);
       } catch (ComparisonFailure e) {

File: core/src/test/java/org/eigenbase/test/MockCatalogReader.java
Patch:
@@ -102,6 +102,8 @@ protected MockCatalogReader(RelDataTypeFactory typeFactory,
   protected void init() {
     final RelDataType intType =
         typeFactory.createSqlType(SqlTypeName.INTEGER);
+    final RelDataType intTypeNull =
+        typeFactory.createTypeWithNullability(intType, true);
     final RelDataType varchar10Type =
         typeFactory.createSqlType(SqlTypeName.VARCHAR, 10);
     final RelDataType varchar20Type =
@@ -136,7 +138,7 @@ protected void init() {
     empTable.addColumn("EMPNO", intType);
     empTable.addColumn("ENAME", varchar20Type);
     empTable.addColumn("JOB", varchar10Type);
-    empTable.addColumn("MGR", intType);
+    empTable.addColumn("MGR", intTypeNull);
     empTable.addColumn("HIREDATE", timestampType);
     empTable.addColumn("SAL", intType);
     empTable.addColumn("COMM", intType);

File: src/main/java/net/hydromatic/linq4j/ExtendedEnumerable.java
Patch:
@@ -496,6 +496,7 @@ <TInner, TKey, TResult> Enumerable<TResult> join(Enumerable<TInner> inner,
    * <p>A left join generates nulls on right, and vice versa:</p>
    *
    * <table>
+   *   <caption>Join types</caption>
    *   <tr>
    *     <td>Join type</td>
    *     <td>generateNullsOnLeft</td>

File: src/main/java/net/hydromatic/linq4j/expressions/ParameterExpression.java
Patch:
@@ -37,6 +37,9 @@ public ParameterExpression(Type type) {
   public ParameterExpression(int modifier, Type type, String name) {
     super(ExpressionType.Parameter, type);
     assert name != null : "name should not be null";
+    assert Character.isJavaIdentifierStart(name.charAt(0))
+      : "parameter name should be valid java identifier: "
+        + name + ". The first character is invalid.";
     this.modifier = modifier;
     this.name = name;
   }

File: src/main/java/net/hydromatic/lambda/functions/Predicates.java
Patch:
@@ -218,7 +218,7 @@ public static <T> Predicate<T> xor(Predicate<? super T>... predicates) {
     return xor(Arrays.asList(predicates));
   }
 
-  abstract static class AbstractPredicate<T> implements Predicate<T> {
+  public abstract static class AbstractPredicate<T> implements Predicate<T> {
     public Predicate<T> and(Predicate<? super T> p) {
       //noinspection unchecked
       return Predicates.and((Predicate) this, p);

File: src/main/java/net/hydromatic/linq4j/expressions/BinaryExpression.java
Patch:
@@ -39,6 +39,7 @@ public class BinaryExpression extends Expression {
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression expression0 = this.expression0.accept(visitor);
     Expression expression1 = this.expression1.accept(visitor);
     return visitor.visit(this, expression0, expression1);

File: src/main/java/net/hydromatic/linq4j/expressions/BlockStatement.java
Patch:
@@ -56,6 +56,7 @@ private boolean distinctVariables(boolean fail) {
 
   @Override
   public BlockStatement accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     List<Statement> newStatements = Expressions.acceptStatements(statements,
         visitor);
     return visitor.visit(this, newStatements);

File: src/main/java/net/hydromatic/linq4j/expressions/ClassDeclaration.java
Patch:
@@ -29,8 +29,8 @@ public class ClassDeclaration extends MemberDeclaration {
   public final String classClass = "class";
   public final String name;
   public final List<MemberDeclaration> memberDeclarations;
-  private final Type extended;
-  private final List<Type> implemented;
+  public final Type extended;
+  public final List<Type> implemented;
 
   public ClassDeclaration(int modifier, String name, Type extended,
       List<Type> implemented, List<MemberDeclaration> memberDeclarations) {
@@ -60,6 +60,7 @@ public void accept(ExpressionWriter writer) {
   }
 
   public ClassDeclaration accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     final List<MemberDeclaration> members1 =
         Expressions.acceptMemberDeclarations(memberDeclarations, visitor);
     return visitor.visit(this, members1);

File: src/main/java/net/hydromatic/linq4j/expressions/ConditionalStatement.java
Patch:
@@ -42,6 +42,7 @@ public ConditionalStatement(List<Node> expressionList) {
 
   @Override
   public Statement accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     List<Node> list = Expressions.acceptNodes(expressionList, visitor);
     return visitor.visit(this, list);
   }

File: src/main/java/net/hydromatic/linq4j/expressions/ConstructorDeclaration.java
Patch:
@@ -50,9 +50,10 @@ public ConstructorDeclaration(int modifier, Type declaredAgainst,
 
   @Override
   public MemberDeclaration accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     // do not visit parameters
     final BlockStatement body = this.body.accept(visitor);
-    return visitor.visit(this, parameters, body);
+    return visitor.visit(this, body);
   }
 
   public void accept(ExpressionWriter writer) {

File: src/main/java/net/hydromatic/linq4j/expressions/DeclarationStatement.java
Patch:
@@ -38,11 +38,12 @@ public DeclarationStatement(int modifiers, ParameterExpression parameter,
 
   @Override
   public DeclarationStatement accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     // do not visit parameter - visit may not return a ParameterExpression
     Expression initializer = this.initializer != null
         ? this.initializer.accept(visitor)
         : null;
-    return visitor.visit(this, parameter, initializer);
+    return visitor.visit(this, initializer);
   }
 
   @Override

File: src/main/java/net/hydromatic/linq4j/expressions/FieldDeclaration.java
Patch:
@@ -37,10 +37,11 @@ public FieldDeclaration(int modifier, ParameterExpression parameter,
 
   @Override
   public MemberDeclaration accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     // do not visit parameter - visit may not return a ParameterExpression
     final Expression initializer =
         this.initializer == null ? null : this.initializer.accept(visitor);
-    return visitor.visit(this, parameter, initializer);
+    return visitor.visit(this, initializer);
   }
 
   public void accept(ExpressionWriter writer) {

File: src/main/java/net/hydromatic/linq4j/expressions/ForStatement.java
Patch:
@@ -47,6 +47,7 @@ public ForStatement(List<DeclarationStatement> declarations,
 
   @Override
   public ForStatement accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     List<DeclarationStatement> decls1 =
         Expressions.acceptDeclarations(declarations, visitor);
     final Expression condition1 =

File: src/main/java/net/hydromatic/linq4j/expressions/FunctionExpression.java
Patch:
@@ -63,8 +63,9 @@ public FunctionExpression(Class<F> type, BlockStatement body,
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     BlockStatement body = this.body.accept(visitor);
-    return visitor.visit(this, body, parameterList);
+    return visitor.visit(this, body);
   }
 
   public Invokable compile() {

File: src/main/java/net/hydromatic/linq4j/expressions/GotoStatement.java
Patch:
@@ -55,6 +55,7 @@ public class GotoStatement extends Statement {
 
   @Override
   public Statement accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression expression1 =
         expression == null ? null : expression.accept(visitor);
     return visitor.visit(this, expression1);

File: src/main/java/net/hydromatic/linq4j/expressions/IndexExpression.java
Patch:
@@ -37,6 +37,7 @@ public IndexExpression(Expression array, List<Expression> indexExpressions) {
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression array = this.array.accept(visitor);
     List<Expression> indexExpressions = Expressions.acceptExpressions(
         this.indexExpressions, visitor);

File: src/main/java/net/hydromatic/linq4j/expressions/MemberExpression.java
Patch:
@@ -42,6 +42,7 @@ public MemberExpression(Expression expression, PseudoField field) {
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression expression1 = expression == null
         ? null
         : expression.accept(visitor);

File: src/main/java/net/hydromatic/linq4j/expressions/MethodCallExpression.java
Patch:
@@ -55,6 +55,7 @@ public class MethodCallExpression extends Expression {
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression targetExpression = Expressions.accept(this.targetExpression,
         visitor);
     List<Expression> expressions = Expressions.acceptExpressions(

File: src/main/java/net/hydromatic/linq4j/expressions/MethodDeclaration.java
Patch:
@@ -49,9 +49,10 @@ public MethodDeclaration(int modifier, String name, Type resultType,
 
   @Override
   public MemberDeclaration accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     // do not visit parameters
     final BlockStatement body = this.body.accept(visitor);
-    return visitor.visit(this, parameters, body);
+    return visitor.visit(this, body);
   }
 
   public void accept(ExpressionWriter writer) {

File: src/main/java/net/hydromatic/linq4j/expressions/NewArrayExpression.java
Patch:
@@ -43,6 +43,7 @@ public NewArrayExpression(Type type, int dimension, Expression bound,
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     List<Expression> expressions =
         this.expressions == null
             ? null

File: src/main/java/net/hydromatic/linq4j/expressions/NewExpression.java
Patch:
@@ -45,6 +45,7 @@ public NewExpression(Type type, List<Expression> arguments,
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     final List<Expression> arguments = Expressions.acceptExpressions(
         this.arguments, visitor);
     final List<MemberDeclaration> memberDeclarations =

File: src/main/java/net/hydromatic/linq4j/expressions/TernaryExpression.java
Patch:
@@ -40,6 +40,7 @@ public class TernaryExpression extends Expression {
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression expression0 = this.expression0.accept(visitor);
     Expression expression1 = this.expression1.accept(visitor);
     Expression expression2 = this.expression2.accept(visitor);

File: src/main/java/net/hydromatic/linq4j/expressions/ThrowStatement.java
Patch:
@@ -30,6 +30,7 @@ public ThrowStatement(Expression expression) {
 
   @Override
   public Statement accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression expression = this.expression.accept(visitor);
     return visitor.visit(this, expression);
   }

File: src/main/java/net/hydromatic/linq4j/expressions/TypeBinaryExpression.java
Patch:
@@ -23,8 +23,8 @@
  * Represents an operation between an expression and a type.
  */
 public class TypeBinaryExpression extends Expression {
-  private final Expression expression;
-  private final Type type;
+  public final Expression expression;
+  public final Type type;
 
   public TypeBinaryExpression(ExpressionType nodeType, Expression expression,
       Type type) {
@@ -36,6 +36,7 @@ public TypeBinaryExpression(ExpressionType nodeType, Expression expression,
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression expression = this.expression.accept(visitor);
     return visitor.visit(this, expression);
   }

File: src/main/java/net/hydromatic/linq4j/expressions/UnaryExpression.java
Patch:
@@ -33,6 +33,7 @@ public class UnaryExpression extends Expression {
 
   @Override
   public Expression accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     Expression expression = this.expression.accept(visitor);
     return visitor.visit(this, expression);
   }

File: src/main/java/net/hydromatic/linq4j/expressions/WhileStatement.java
Patch:
@@ -34,6 +34,7 @@ public WhileStatement(Expression condition, Statement body) {
 
   @Override
   public Statement accept(Visitor visitor) {
+    visitor = visitor.preVisit(this);
     final Expression condition1 = condition.accept(visitor);
     final Statement body1 = body.accept(visitor);
     return visitor.visit(this, condition1, body1);

File: src/test/java/net/hydromatic/linq4j/test/Linq4jSuite.java
Patch:
@@ -34,6 +34,7 @@
     ExpressionTest.class,
     OptimizerTest.class,
     InlinerTest.class,
+    DeterministicTest.class,
     BlockBuilderTest.class,
     FunctionTest.class,
     TypeTest.class

File: core/src/main/java/net/hydromatic/optiq/materialize/MaterializationService.java
Patch:
@@ -32,6 +32,7 @@
 
 import org.eigenbase.reltype.RelDataType;
 import org.eigenbase.reltype.RelDataTypeImpl;
+import org.eigenbase.util.Pair;
 
 import java.lang.reflect.Type;
 import java.util.*;
@@ -68,7 +69,8 @@ public MaterializationKey defineMaterialization(final OptiqSchema schema,
     RelDataType rowType = null;
     OptiqSchema.TableEntry tableEntry;
     if (tableName != null) {
-      materializedTable = schema.getTable(tableName, true);
+      final Pair<String, Table> pair = schema.getTable(tableName, true);
+      materializedTable = pair == null ? null : pair.right;
       if (materializedTable == null) {
         final OptiqPrepare.PrepareResult<Object> prepareResult =
             Schemas.prepare(connection, schema, viewSchemaPath, viewSql);

File: core/src/main/java/net/hydromatic/optiq/model/ModelHandler.java
Patch:
@@ -166,6 +166,8 @@ private static ImmutableList<String> stringList(Object s) {
   }
 
   private void populateSchema(JsonSchema jsonSchema, SchemaPlus schema) {
+    boolean cache = jsonSchema.cache == null || jsonSchema.cache;
+    schema.setCacheEnabled(cache);
     final Pair<String, SchemaPlus> pair = Pair.of(jsonSchema.name, schema);
     push(schemaStack, pair);
     jsonSchema.visitChildren(this);

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -602,7 +602,7 @@ protected SqlToRelConverter getSqlToRelConverter(
           new SqlToRelConverter(
               this, validator, catalogReader, planner, rexBuilder,
               StandardConvertletTable.INSTANCE);
-      sqlToRelConverter.setTrimUnusedFields(false);
+      sqlToRelConverter.setTrimUnusedFields(true);
       return sqlToRelConverter;
     }
 

File: core/src/main/java/org/eigenbase/sql2rel/RelFieldTrimmer.java
Patch:
@@ -193,6 +193,7 @@ protected final TrimResult dispatchTrimFields(
         : "source: " + mapping.getSourceCount() + " != " + fieldCount;
     final int newFieldCount = newRel.getRowType().getFieldCount();
     assert mapping.getTargetCount() + extraFields.size() == newFieldCount
+        || Bug.TODO_FIXED
         : "target: " + mapping.getTargetCount()
         + " + " + extraFields.size()
         + " != " + newFieldCount;
@@ -520,7 +521,7 @@ public TrimResult trimFields(
       // individually. For now, we assume that just one input has
       // on-demand fields.
       Set<RelDataTypeField> inputExtraFields =
-          RelDataTypeImpl.extra(rowType) == null
+          RelDataTypeImpl.extra(inputRowType) == null
               ? Collections.<RelDataTypeField>emptySet()
               : combinedInputExtraFields;
       inputExtraFieldCounts.add(inputExtraFields.size());

File: src/main/java/net/hydromatic/linq4j/expressions/ThrowStatement.java
Patch:
@@ -30,7 +30,8 @@ public ThrowStatement(Expression expression) {
 
   @Override
   public Statement accept(Visitor visitor) {
-    return visitor.visit(this);
+    Expression expression = this.expression.accept(visitor);
+    return visitor.visit(this, expression);
   }
 
   @Override

File: src/test/java/net/hydromatic/linq4j/test/Linq4jSuite.java
Patch:
@@ -32,6 +32,9 @@
     PrimitiveTest.class,
     Linq4jTest.class,
     ExpressionTest.class,
+    OptimizerTest.class,
+    InlinerTest.class,
+    BlockBuilderTest.class,
     FunctionTest.class,
     TypeTest.class
 })

File: src/main/java/net/hydromatic/linq4j/Enumerable.java
Patch:
@@ -32,7 +32,7 @@ public interface Enumerable<T>
   /**
    * Converts this Enumerable to a Queryable.
    *
-   * @see EnumerableDefaults#asQueryable(Enumerable
+   * @see EnumerableDefaults#asQueryable(Enumerable)
    */
   Queryable<T> asQueryable();
 

File: src/main/java/net/hydromatic/linq4j/expressions/Expressions.java
Patch:
@@ -710,16 +710,16 @@ public static DynamicExpression dynamic(CallSiteBinder binder, Type type,
   }
 
   /**
-   * Creates a DynamicExpression that represents a dynamic
-   * operation bound by the provided CallSiteBinder, using varargs.
+   * Creates a {@code DynamicExpression} that represents a dynamic
+   * operation bound by the provided {@code CallSiteBinder}, using varargs.
    */
   public static DynamicExpression dynamic(CallSiteBinder binder, Type type,
       Expression... expression) {
     throw Extensions.todo();
   }
 
   /**
-   * Creates an ElementInit, given an Iterable<T> as the second
+   * Creates an {@code ElementInit}, given an {@code Iterable<T>} as the second
    * argument.
    */
   public static ElementInit elementInit(Method method,

File: core/src/main/java/org/eigenbase/rel/CollectRel.java
Patch:
@@ -71,7 +71,7 @@ public CollectRel(RelInput input) {
 
   @Override
   public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-    assert traitSet.comprises(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     return new CollectRel(
         getCluster(),
         sole(inputs),

File: core/src/main/java/org/eigenbase/rel/OneRowRel.java
Patch:
@@ -49,7 +49,7 @@ public OneRowRel(RelInput input) {
 
   @Override
   public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-    assert traitSet.comprises(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     assert inputs.isEmpty();
     return this;
   }

File: core/src/main/java/org/eigenbase/rel/SamplingRel.java
Patch:
@@ -65,7 +65,7 @@ private static RelOptSamplingParameters getSamplingParameters(
   }
 
   public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-    assert traitSet.comprises(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     return new SamplingRel(
         getCluster(),
         sole(inputs),

File: core/src/main/java/org/eigenbase/rel/TableAccessRel.java
Patch:
@@ -73,7 +73,7 @@ public TableAccessRel(RelInput input) {
 
   @Override
   public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-    assert traitSet.comprises(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     assert inputs.isEmpty();
     return this;
   }

File: core/src/main/java/org/eigenbase/rel/TableFunctionRel.java
Patch:
@@ -68,7 +68,7 @@ public TableFunctionRel(RelInput input) {
 
   @Override
   public TableFunctionRel copy(RelTraitSet traitSet, List<RelNode> inputs) {
-    assert traitSet.comprises(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     return new TableFunctionRel(
         getCluster(),
         inputs,

File: core/src/main/java/org/eigenbase/rel/UncollectRel.java
Patch:
@@ -62,7 +62,7 @@ public UncollectRel(RelInput input) {
   //~ Methods ----------------------------------------------------------------
 
   public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-    assert traitSet.comprises(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     return new UncollectRel(
         getCluster(),
         sole(inputs));

File: core/src/main/java/org/eigenbase/rel/ValuesRel.java
Patch:
@@ -60,7 +60,7 @@ public ValuesRel(RelInput input) {
   }
 
   public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-    assert traitSet.comprises(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     assert inputs.isEmpty();
     return new ValuesRel(
         getCluster(),

File: core/src/main/java/org/eigenbase/sql2rel/RelDecorrelator.java
Patch:
@@ -310,7 +310,9 @@ public void decorrelateRel(SortRel rel) {
             rel.getCluster(),
             rel.getCluster().traitSetOf(Convention.NONE).plus(newCollation),
             newChildRel,
-            newCollation);
+            newCollation,
+            rel.offset,
+            rel.fetch);
 
     mapOldToNewRel.put(rel, newRel);
 

File: core/src/main/java/org/eigenbase/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -348,7 +348,9 @@ public void rewriteRel(SortRel rel) {
             rel.getCluster(),
             rel.getCluster().traitSetOf(Convention.NONE).plus(newCollation),
             newChild,
-            newCollation);
+            newCollation,
+            rel.offset,
+            rel.fetch);
     setNewForOldRel(rel, newRel);
   }
 

File: core/src/test/java/net/hydromatic/optiq/examples/foodmart/java/JdbcExample.java
Patch:
@@ -40,9 +40,8 @@ public void run() throws ClassNotFoundException, SQLException {
     OptiqConnection optiqConnection =
         connection.unwrap(OptiqConnection.class);
     SchemaPlus rootSchema = optiqConnection.getRootSchema();
-    rootSchema.add("hr", new ReflectiveSchema("hr", new Hr()));
-    rootSchema.add("foodmart",
-        new ReflectiveSchema("foodmart", new Foodmart()));
+    rootSchema.add("hr", new ReflectiveSchema(new Hr()));
+    rootSchema.add("foodmart", new ReflectiveSchema(new Foodmart()));
     Statement statement = connection.createStatement();
     ResultSet resultSet =
         statement.executeQuery(

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -148,7 +148,7 @@ public class ReflectiveSchemaTest {
         TableMacroImpl.create(JdbcTest.GENERATE_STRINGS_METHOD));
     schema.add("StringUnion",
         TableMacroImpl.create(JdbcTest.STRING_UNION_METHOD));
-    rootSchema.add("hr", new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
+    rootSchema.add("hr", new ReflectiveSchema(new JdbcTest.HrSchema()));
     ResultSet resultSet = connection.createStatement().executeQuery(
         "select *\n"
         + "from table(s.StringUnion(\n"
@@ -173,7 +173,7 @@ public class ReflectiveSchemaTest {
         ViewTable.viewMacro(schema,
             "select * from \"hr\".\"emps\" where \"deptno\" = 10",
             null));
-    rootSchema.add("hr", new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
+    rootSchema.add("hr", new ReflectiveSchema(new JdbcTest.HrSchema()));
     ResultSet resultSet = connection.createStatement().executeQuery(
         "select *\n"
         + "from \"s\".\"emps_view\"\n"
@@ -210,7 +210,7 @@ public class ReflectiveSchemaTest {
             Collections.singletonList("s")));
     schema.add("null_emps",
         ViewTable.viewMacro(schema, "select * from \"emps\"", null));
-    rootSchema.add("hr", new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
+    rootSchema.add("hr", new ReflectiveSchema(new JdbcTest.HrSchema()));
     final Statement statement = connection.createStatement();
     ResultSet resultSet;
     resultSet = statement.executeQuery(

File: core/src/test/java/net/hydromatic/optiq/tools/PlannerTest.java
Patch:
@@ -151,8 +151,8 @@ private String toString(RelNode rel) {
   }
 
   private SchemaPlus createHrSchema() {
-    return Frameworks.createRootSchema()
-        .add("hr", new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
+    return Frameworks.createRootSchema().add("hr",
+        new ReflectiveSchema(new JdbcTest.HrSchema()));
   }
 
   private Planner getPlanner(List<RelTraitDef> traitDefs, RuleSet... ruleSets) {
@@ -506,7 +506,7 @@ public Iterator<RelOptRule> iterator() {
   public String checkTpchQuery(String tpchTestQuery) throws Exception {
     final SchemaPlus schema =
         Frameworks.createRootSchema().add("tpch",
-        new ReflectiveSchema("tpch", new TpchSchema()));
+            new ReflectiveSchema(new TpchSchema()));
 
     Planner p = Frameworks.getPlanner(Lex.MYSQL, schema,
         SqlStdOperatorTable.instance(), RULE_SETS);

File: core/src/test/java/org/eigenbase/relopt/RelWriterTest.java
Patch:
@@ -115,7 +115,7 @@ public class RelWriterTest {
               public String apply(RelOptCluster cluster,
                   RelOptSchema relOptSchema, SchemaPlus rootSchema) {
                 rootSchema.add("hr",
-                    new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
+                    new ReflectiveSchema(new JdbcTest.HrSchema()));
                 TableAccessRel table =
                     new TableAccessRel(cluster,
                         relOptSchema.getTableForMember(
@@ -158,7 +158,7 @@ public String apply(RelOptCluster cluster,
                   RelOptSchema relOptSchema, SchemaPlus rootSchema) {
                 SchemaPlus schema =
                     rootSchema.add("hr",
-                        new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
+                        new ReflectiveSchema(new JdbcTest.HrSchema()));
                 final RelJsonReader reader =
                     new RelJsonReader(cluster, relOptSchema, schema);
                 RelNode node;

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -182,7 +182,8 @@ private void generateGet(EnumerableRelImplementor implementor,
       dateTimeArgs.add(calendar_);
       break;
     case NULL:
-      dateTimeArgs.add(Expressions.constant(null));
+      // We don't specify a calendar at all, so we don't add an argument and
+      // instead use the version of the getXXX that doesn't take a Calendar
       break;
     case DIRECT:
       sqlTypeName = SqlTypeName.ANY;

File: core/src/main/java/net/hydromatic/optiq/impl/TableMacroImpl.java
Patch:
@@ -86,8 +86,7 @@ public String getName() {
             public RelDataType getType(RelDataTypeFactory typeFactory) {
               return ((JavaTypeFactory) typeFactory).createType(parameterType);
             }
-          }
-      );
+          });
     }
     return new TableMacroImpl(parameters, method);
   }

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -140,8 +140,7 @@ protected List<Function1<Context, RelOptPlanner>> createPlannerFactories() {
           public RelOptPlanner apply(Context context) {
             return createPlanner(context);
           }
-        }
-    );
+        });
   }
 
   /** Creates a query planner and initializes it with a default set of

File: core/src/main/java/org/eigenbase/rel/rules/CalcRelSplitter.java
Patch:
@@ -419,8 +419,7 @@ public Void visitLocalRef(RexLocalRef localRef) {
               }
               return null;
             }
-          }
-      );
+          });
     }
     TopologicalOrderIterator<Integer, DefaultEdge> iter =
         new TopologicalOrderIterator<Integer, DefaultEdge>(graph);

File: core/src/main/java/org/eigenbase/relopt/RelOptPlanner.java
Patch:
@@ -279,6 +279,9 @@ RelNode register(
 
   Executor getExecutor();
 
+  /** Called when a relational expression is copied to a similar expression. */
+  void onCopy(RelNode rel, RelNode newRel);
+
   /** Can reduce expressions, writing a literal for each into a list. */
   interface Executor {
     /**

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeFactoryImpl.java
Patch:
@@ -158,8 +158,7 @@ public RelDataType get(int index) {
           public int size() {
             return fieldInfo.getFieldCount();
           }
-        }
-    );
+        });
   }
 
   // implement RelDataTypeFactory

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -3488,8 +3488,7 @@ public RelDataType get(int row) {
                   public int size() {
                     return rowCount;
                   }
-                }
-          );
+                });
 
         if (null == type) {
           throw newValidationError(node,

File: core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -183,8 +183,7 @@ public static List<Pair<String, String>> getFoodmartQueries() {
     assertThat(OptiqAssert.toString(resultSet),
         equalTo("N=1\n"
             + "N=3\n"
-            + "N=10\n")
-    );
+            + "N=10\n"));
   }
 
   /** Tests a JDBC connection that provides a model that contains a table

File: core/src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -540,8 +540,7 @@ public OptiqConnection createConnection() throws Exception {
               return (OptiqConnection) DriverManager.getConnection(
                   "jdbc:optiq:", info);
             }
-          }
-      );
+          });
     }
 
     /** Sets the default schema to a reflective schema based on a given

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeTransforms.java
Patch:
@@ -127,6 +127,8 @@ private SqlTypeName toVar(RelDataType type) {
             return SqlTypeName.VARCHAR;
           case BINARY:
             return SqlTypeName.VARBINARY;
+          case ANY:
+            return SqlTypeName.ANY;
           default:
             throw Util.unexpected(sqlTypeName);
           }

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoRules.java
Patch:
@@ -119,6 +119,9 @@ protected RexToMongoTranslator(JavaTypeFactory typeFactory,
     }
 
     @Override public String visitLiteral(RexLiteral literal) {
+      if (literal.getValue() == null) {
+        return "null";
+      }
       return "{$ifNull: [null, "
           + RexToLixTranslator.translateLiteral(literal, literal.getType(),
               typeFactory, RexImpTable.NullAs.NOT_POSSIBLE)

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexImpTable.java
Patch:
@@ -193,7 +193,6 @@ public Expression implement(RexToLixTranslator translator,
     map.put(LOCALTIMESTAMP, systemFunctionImplementor);
 
     aggMap.put(COUNT, new CountImplementor());
-    aggMap.put(SUM, new SumImplementor());
     aggMap.put(SUM0, new SumImplementor());
     final MinMaxImplementor minMax =
         new MinMaxImplementor();

File: core/src/main/java/org/eigenbase/sql/fun/SqlAvgAggFunction.java
Patch:
@@ -51,7 +51,7 @@ public SqlAvgAggFunction(
     super(
         subtype.name(),
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.ARG0,
+        ReturnTypes.ARG0_NULLABLE_IF_EMPTY,
         null,
         OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC);

File: core/src/main/java/org/eigenbase/sql/fun/SqlSumAggFunction.java
Patch:
@@ -42,7 +42,7 @@ public SqlSumAggFunction(RelDataType type) {
     super(
         "SUM",
         SqlKind.OTHER_FUNCTION,
-        ReturnTypes.ARG0,
+        ReturnTypes.ARG0_NULLABLE_IF_EMPTY,
         null,
         OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC);

File: core/src/main/java/org/eigenbase/rel/AggregateRelBase.java
Patch:
@@ -169,7 +169,6 @@ public RelOptCost computeSelfCost(RelOptPlanner planner) {
   }
 
   protected RelDataType deriveRowType() {
-    //noinspection unchecked
     return getCluster().getTypeFactory().createStructType(
         CompositeList.of(
             // fields derived from grouping columns

File: core/src/main/java/org/eigenbase/sql/parser/SqlAbstractParserImpl.java
Patch:
@@ -359,7 +359,8 @@ protected SqlCall createCall(
     // Otherwise, just create a placeholder function.  Later, during
     // validation, it will be resolved into a real function reference.
     if (fun == null) {
-      fun = new SqlFunction(funName, null, null, null, null, funcType);
+      fun = new SqlUnresolvedFunction(funName, null, null, null, null,
+          funcType);
     }
 
     return fun.createCall(functionQualifier, pos, operands);

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexImpTable.java
Patch:
@@ -610,7 +610,9 @@ private static Expression implementCall(
         }
       }
     }
-    return implementor.implement(translator, call, translatedOperands);
+    Expression result;
+    result = implementor.implement(translator, call, translatedOperands);
+    return nullAs.handle(result);
   }
 
   /** Strategy what an operator should return if one of its

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -322,6 +322,7 @@ <T> PrepareResult<T> prepare2_(
               ImmutableList.of(SqlStdOperatorTable.instance(), catalogReader));
       final SqlValidator validator =
           new OptiqSqlValidator(opTab, catalogReader, typeFactory);
+      validator.setIdentifierExpansion(true);
 
       final List<Prepare.Materialization> materializations =
           config.materializationsEnabled()

File: core/src/main/java/org/eigenbase/sql/SqlOperator.java
Patch:
@@ -612,7 +612,7 @@ public SqlOperandTypeInference getOperandTypeInference() {
    * @return whether this operator is an aggregator
    */
   public boolean isAggregator() {
-    return this instanceof SqlAggFunction;
+    return false;
   }
 
   /**

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -23,7 +23,6 @@
 import net.hydromatic.linq4j.function.*;
 
 import net.hydromatic.optiq.SchemaPlus;
-import net.hydromatic.optiq.Schemas;
 import net.hydromatic.optiq.impl.*;
 import net.hydromatic.optiq.impl.java.*;
 import net.hydromatic.optiq.jdbc.OptiqConnection;
@@ -146,9 +145,9 @@ public class ReflectiveSchemaTest {
     SchemaPlus rootSchema = optiqConnection.getRootSchema();
     SchemaPlus schema = rootSchema.add("s", new AbstractSchema());
     schema.add("GenerateStrings",
-        Schemas.methodMember(JdbcTest.GENERATE_STRINGS_METHOD));
+        TableMacroImpl.create(JdbcTest.GENERATE_STRINGS_METHOD));
     schema.add("StringUnion",
-        Schemas.methodMember(JdbcTest.STRING_UNION_METHOD));
+        TableMacroImpl.create(JdbcTest.STRING_UNION_METHOD));
     rootSchema.add("hr", new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
     ResultSet resultSet = connection.createStatement().executeQuery(
         "select *\n"

File: core/src/main/java/net/hydromatic/optiq/Schema.java
Patch:
@@ -94,8 +94,8 @@ public interface Schema {
    * Returns the expression by which this schema can be referenced in generated
    * code.
    *
-   * @param parentSchema
-   * @param name
+   * @param parentSchema Parent schema
+   * @param name Name of this schema
    */
   Expression getExpression(SchemaPlus parentSchema, String name);
 

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -319,8 +319,7 @@ <T> PrepareResult<T> prepare2_(
       final OptiqSchema rootSchema = context.getRootSchema();
       final ChainedSqlOperatorTable opTab =
           new ChainedSqlOperatorTable(
-              ImmutableList.<SqlOperatorTable>of(
-                  SqlStdOperatorTable.instance(), catalogReader));
+              ImmutableList.of(SqlStdOperatorTable.instance(), catalogReader));
       final SqlValidator validator =
           new OptiqSqlValidator(opTab, catalogReader, typeFactory);
 

File: core/src/main/java/net/hydromatic/optiq/rules/java/EnumerableConvention.java
Patch:
@@ -31,7 +31,6 @@ public String toString() {
     return getName();
   }
 
-
   public Class getInterface() {
     return EnumerableRel.class;
   }
@@ -47,6 +46,8 @@ public RelTraitDef getTraitDef() {
   public boolean subsumes(RelTrait trait) {
     return this == trait;
   }
+
+  public void register(RelOptPlanner planner) {}
 }
 
 // End EnumerableConvention.java

File: core/src/main/java/org/eigenbase/relopt/Convention.java
Patch:
@@ -50,11 +50,12 @@ public Impl(String name, Class<? extends RelNode> relClass) {
       this.relClass = relClass;
     }
 
-    @Override
-    public String toString() {
+    @Override public String toString() {
       return getName();
     }
 
+    public void register(RelOptPlanner planner) {}
+
     public boolean subsumes(RelTrait trait) {
       return this == trait;
     }

File: core/src/test/java/net/hydromatic/optiq/test/OptiqSuite.java
Patch:
@@ -100,6 +100,7 @@
 
     // test cases
     TableInRootSchemaTest.class,
+    MultiJdbcSchemaJoinTest.class,
 
     // slow tests that don't break often
     SqlToRelConverterExtendedTest.class,

File: core/src/test/java/org/eigenbase/relopt/volcano/VolcanoPlannerTraitTest.java
Patch:
@@ -218,6 +218,8 @@ private AltTrait(AltTraitDef traitDef, String description) {
       this.ordinal = altTraitOrdinal++;
     }
 
+    public void register(RelOptPlanner planner) {}
+
     public RelTraitDef getTraitDef() {
       return traitDef;
     }
@@ -238,7 +240,7 @@ public int hashCode() {
     }
 
     public boolean subsumes(RelTrait trait) {
-      return equals(true);
+      return equals(trait);
     }
 
     public String toString() {

File: core/src/test/java/net/hydromatic/optiq/tools/PlannerTest.java
Patch:
@@ -216,7 +216,7 @@ private Planner getPlanner(List<RelTraitDef> traitDefs, RuleSet... ruleSets) {
             + "order by \"emps\".\"deptno\"");
     SqlNode validate = planner.validate(parse);
     RelNode convert = planner.convert(validate);
-    RelTraitSet traitSet = planner.getEmptyTraitSet()
+    RelTraitSet traitSet = convert.getTraitSet()
         .replace(EnumerableConvention.INSTANCE);
     RelNode transform = planner.transform(0, traitSet, convert);
     assertThat(toString(transform), equalTo(
@@ -304,7 +304,7 @@ private Planner getPlanner(List<RelTraitDef> traitDefs, RuleSet... ruleSets) {
     RelNode transform = planner.transform(0, traitSet, convert);
     assertThat(toString(transform), equalTo(
         "EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
-            + "  EnumerableTableAccessRel(table=[[hr, emps]])\n"));
+        + "  EnumerableTableAccessRel(table=[[hr, emps]])\n"));
   }
 
   /** Unit test that calls {@link Planner#transform} twice. */

File: core/src/main/java/org/eigenbase/sql/fun/SqlExtractFunction.java
Patch:
@@ -38,7 +38,7 @@ public SqlExtractFunction() {
         SqlKind.OTHER_FUNCTION,
         ReturnTypes.BIGINT_NULLABLE,
         null,
-        OperandTypes.INTERVAL_SAME_SAME,
+        OperandTypes.INTERVALINTERVAL_INTERVALDATETIME,
         SqlFunctionCategory.SYSTEM);
   }
 

File: core/src/test/java/org/eigenbase/test/SqlValidatorTest.java
Patch:
@@ -5800,6 +5800,7 @@ public void _testGroupExpressionEquivalenceParams() {
         "extract(year from interval '1-2' year to month)",
         "BIGINT NOT NULL");
     checkExp("extract(minute from interval '1.1' second)");
+    checkExp("extract(year from DATE '2008-2-2')");
 
     checkWholeExpFails(
         "extract(minute from interval '11' month)",

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqMaterializer.java
Patch:
@@ -90,9 +90,9 @@ private void useStar(OptiqSchema schema, Materialization materialization) {
     for (OptiqSchema.TableEntry starTable : starTables) {
       final Table table = starTable.getTable();
       assert table instanceof StarTable;
-      OptiqPrepareImpl.RelOptTableImpl starRelOptTable =
-          new OptiqPrepareImpl.RelOptTableImpl(catalogReader,
-              table.getRowType(typeFactory), starTable);
+      RelOptTableImpl starRelOptTable =
+          RelOptTableImpl.create(catalogReader, table.getRowType(typeFactory),
+              starTable);
       final RelNode rel3 =
           RelOptMaterialization.tryUseStar(rel2, starRelOptTable);
       if (rel3 != null) {

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -143,13 +143,12 @@ public class ReflectiveSchemaTest {
         DriverManager.getConnection("jdbc:optiq:");
     OptiqConnection optiqConnection =
         connection.unwrap(OptiqConnection.class);
-    JavaTypeFactory typeFactory = optiqConnection.getTypeFactory();
     SchemaPlus rootSchema = optiqConnection.getRootSchema();
     SchemaPlus schema = rootSchema.add("s", new AbstractSchema());
     schema.add("GenerateStrings",
-        Schemas.methodMember(JdbcTest.GENERATE_STRINGS_METHOD, typeFactory));
+        Schemas.methodMember(JdbcTest.GENERATE_STRINGS_METHOD));
     schema.add("StringUnion",
-        Schemas.methodMember(JdbcTest.STRING_UNION_METHOD, typeFactory));
+        Schemas.methodMember(JdbcTest.STRING_UNION_METHOD));
     rootSchema.add("hr", new ReflectiveSchema("hr", new JdbcTest.HrSchema()));
     ResultSet resultSet = connection.createStatement().executeQuery(
         "select *\n"

File: core/src/main/java/org/eigenbase/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -324,7 +324,7 @@ static boolean reduceExpressions(RelNode rel, List<RexNode> expList) {
     RelOptPlanner.Executor executor =
         rel.getCluster().getPlanner().getExecutor();
     List<RexNode> reducedValues = new ArrayList<RexNode>();
-    executor.execute(rexBuilder, constExps, reducedValues);
+    executor.reduce(rexBuilder, constExps, reducedValues);
 
     // For ProjectRel, we have to be sure to preserve the result
     // types, so always cast regardless of the expression type.

File: core/src/main/java/org/eigenbase/relopt/RelOptPlanner.java
Patch:
@@ -284,7 +284,7 @@ interface Executor {
     /**
      * Reduces expressions, and writes their results into {@code reducedValues}.
      */
-    void execute(RexBuilder rexBuilder, List<RexNode> constExps,
+    void reduce(RexBuilder rexBuilder, List<RexNode> constExps,
         List<RexNode> reducedValues);
   }
 

File: core/src/test/java/org/eigenbase/test/SqlValidatorTest.java
Patch:
@@ -5668,10 +5668,9 @@ public void _testGroupExpressionEquivalenceParams() {
         ERR_AGG_IN_GROUP_BY);
   }
 
-  @Ignore("https://github.com/julianhyde/optiq/issues/217")
   @Test public void testAggregateInNonGroupBy() {
-    checkFails("select count(1), empno from emp",
-        "xxx");
+    checkFails("select count(1), ^empno^ from emp",
+        "Expression 'EMPNO' is not being grouped");
   }
 
   @Test public void testAggregateInOrderByFails() {

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqSchema.java
Patch:
@@ -205,7 +205,6 @@ public String getName() {
   }
 
   public SchemaPlus plus() {
-//    System.out.println("plus: " + n++);
     return new SchemaPlusImpl();
   }
 

File: core/src/main/java/org/eigenbase/sql/util/ListSqlOperatorTable.java
Patch:
@@ -65,7 +65,8 @@ public List<SqlOperator> lookupOperatorOverloads(
       } else {
         functionCategory = SqlFunctionCategory.SYSTEM;
       }
-      if (category != functionCategory) {
+      if (category != functionCategory
+          && category != SqlFunctionCategory.USER_DEFINED_FUNCTION) {
         continue;
       }
       list.add(operator);

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -413,8 +413,8 @@ private boolean expandSelectItem(
     selectItems.add(expanded);
     aliases.add(alias);
 
-    final RelDataType type = deriveType(scope, selectItem);
-    setValidatedNodeTypeImpl(selectItem, type);
+    final RelDataType type = deriveType(scope, expanded);
+    setValidatedNodeTypeImpl(expanded, type);
     types.add(Pair.of(alias, type));
     return false;
   }

File: core/src/main/java/net/hydromatic/optiq/impl/MaterializedViewTable.java
Patch:
@@ -115,7 +115,7 @@ public Table apply(List<Object> arguments) {
           Schemas.parse(MATERIALIZATION_CONNECTION, schema, schemaPath,
               viewSql);
       final List<String> schemaPath1 =
-          schemaPath != null ? schemaPath : Schemas.path(schema.schema, null);
+          schemaPath != null ? schemaPath : schema.path(null);
       final JavaTypeFactory typeFactory =
           MATERIALIZATION_CONNECTION.getTypeFactory();
       return new MaterializedViewTable(typeFactory.getJavaClass(parsed.rowType),

File: core/src/main/java/net/hydromatic/optiq/impl/ViewTable.java
Patch:
@@ -128,7 +128,7 @@ public Table apply(List<Object> arguments) {
           Schemas.parse(MATERIALIZATION_CONNECTION, schema, schemaPath,
               viewSql);
       final List<String> schemaPath1 =
-          schemaPath != null ? schemaPath : Schemas.path(schema.schema, null);
+          schemaPath != null ? schemaPath : schema.path(null);
       final JavaTypeFactory typeFactory = (JavaTypeFactory) parsed.typeFactory;
       return new ViewTable(typeFactory.getJavaClass(parsed.rowType),
           RelDataTypeImpl.proto(parsed.rowType), viewSql, schemaPath1);

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqRootSchema.java
Patch:
@@ -25,8 +25,7 @@
 public class OptiqRootSchema extends OptiqSchema {
   /** Creates a root schema. */
   OptiqRootSchema(Schema schema) {
-    super(null, schema);
-    assert schema.getParentSchema() == null;
+    super(null, schema, "");
   }
 }
 

File: core/src/test/java/net/hydromatic/optiq/examples/foodmart/java/JdbcExample.java
Patch:
@@ -40,9 +40,9 @@ public void run() throws ClassNotFoundException, SQLException {
     OptiqConnection optiqConnection =
         connection.unwrap(OptiqConnection.class);
     SchemaPlus rootSchema = optiqConnection.getRootSchema();
-    rootSchema.add(new ReflectiveSchema(rootSchema, "hr", new Hr()));
-    rootSchema.add(
-        new ReflectiveSchema(rootSchema, "foodmart", new Foodmart()));
+    rootSchema.add("hr", new ReflectiveSchema("hr", new Hr()));
+    rootSchema.add("foodmart",
+        new ReflectiveSchema("foodmart", new Foodmart()));
     Statement statement = connection.createStatement();
     ResultSet resultSet =
         statement.executeQuery(

File: core/src/test/java/net/hydromatic/optiq/test/JdbcFrontLinqBackTest.java
Patch:
@@ -256,7 +256,7 @@ public OptiqConnection createConnection() throws Exception {
                 SchemaPlus rootSchema =
                     optiqConnection.getRootSchema();
                 SchemaPlus mapSchema =
-                    rootSchema.add(new AbstractSchema(rootSchema, "foo"));
+                    rootSchema.add("foo", new AbstractSchema());
                 final String tableName = "bar";
                 final JdbcTest.AbstractModifiableTable table =
                     new JdbcTest.AbstractModifiableTable(tableName) {

File: core/src/test/java/net/hydromatic/optiq/tools/PlannerTest.java
Patch:
@@ -113,8 +113,7 @@ private Planner getPlanner(List<RelTraitDef> traitDefs, RuleSet... ruleSets) {
         SqlParserImpl.FACTORY,
         new Function1<SchemaPlus, Schema>() {
           public Schema apply(SchemaPlus parentSchema) {
-            return new ReflectiveSchema(parentSchema, "hr",
-                new JdbcTest.HrSchema());
+            return new ReflectiveSchema("hr", new JdbcTest.HrSchema());
           }
         }, SqlStdOperatorTable.instance(), traitDefs, ruleSets);
   }
@@ -229,7 +228,7 @@ public Schema apply(SchemaPlus parentSchema) {
             JavaRules.ENUMERABLE_FILTER_RULE,
             JavaRules.ENUMERABLE_PROJECT_RULE);
 
-    JdbcConvention out = new JdbcConvention(null, "myjdbc");
+    JdbcConvention out = new JdbcConvention(null, null, "myjdbc");
     RuleSet ruleSet1 = RuleSets.ofList(new MockJdbcProjectRule(out),
         new MockJdbcTableRule(out));
 

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoSchemaFactory.java
Patch:
@@ -37,7 +37,7 @@ public Schema create(SchemaPlus parentSchema, String name,
     Map map = (Map) operand;
     String host = (String) map.get("host");
     String database = (String) map.get("database");
-    return new MongoSchema(parentSchema, name, host, database);
+    return new MongoSchema(host, database);
   }
 }
 

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/JdbcToSparkConverter.java
Patch:
@@ -67,7 +67,7 @@ public SparkRel.Result implementSpark(SparkRel.Implementor implementor) {
             JavaRowFormat.CUSTOM);
     final JdbcConvention jdbcConvention =
         (JdbcConvention) child.getConvention();
-    String sql = generateSql(jdbcConvention.jdbcSchema.dialect);
+    String sql = generateSql(jdbcConvention.dialect);
     if (OptiqPrepareImpl.DEBUG) {
       System.out.println("[" + sql + "]");
     }
@@ -89,7 +89,7 @@ public SparkRel.Result implementSpark(SparkRel.Implementor implementor) {
                 BuiltinMethod.RESULT_SET_ENUMERABLE_OF.method,
                 Expressions.call(
                     Expressions.convert_(
-                        jdbcConvention.jdbcSchema.getExpression(),
+                        jdbcConvention.expression,
                         JdbcSchema.class),
                     BuiltinMethod.JDBC_SCHEMA_DATA_SOURCE.method),
                 sqlLiteral,

File: core/src/main/java/net/hydromatic/optiq/Member.java
Patch:
@@ -59,7 +59,7 @@ public interface Member {
    *
    * @return Parameters; never null
    */
-  List<Parameter> getParameters();
+  List<FunctionParameter> getParameters();
 
   /**
    * Returns the type of this function's result.

File: core/src/main/java/net/hydromatic/optiq/SchemaPlus.java
Patch:
@@ -40,8 +40,8 @@ public interface SchemaPlus extends Schema {
   /** Adds a table to this schema. */
   void add(String name, Table table);
 
-  /** Adds a table function to this schema. */
-  void add(String name, TableFunction table);
+  /** Adds a function to this schema. */
+  void add(String name, Function function);
 
   boolean isMutable();
 

File: core/src/main/java/net/hydromatic/optiq/Table.java
Patch:
@@ -35,7 +35,7 @@
  * <a href="http://en.wikipedia.org/wiki/Inode">i-node</a> concept in the UNIX
  * filesystem.)</p>
  *
- * @see TableFunction
+ * @see TableMacro
  */
 public interface Table {
   /** Returns this table's row type.

File: core/src/main/java/net/hydromatic/optiq/model/ModelHandler.java
Patch:
@@ -182,7 +182,7 @@ public void visit(JsonView jsonView) {
       final SchemaPlus schema = currentMutableSchema("view");
       final List<String> path = Util.first(jsonView.path, currentSchemaPath());
       schema.add(jsonView.name,
-          ViewTable.viewFunction(schema, jsonView.sql, path));
+          ViewTable.viewMacro(schema, jsonView.sql, path));
     } catch (Exception e) {
       throw new RuntimeException("Error instantiating " + jsonView, e);
     }

File: core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -130,7 +130,7 @@ public static List<Pair<String, String>> getFoodmartQueries() {
    * The function returns a {@link Queryable}.
    */
   @Ignore
-  @Test public void testTableFunction()
+  @Test public void testTableMacro()
     throws SQLException, ClassNotFoundException {
     Class.forName("net.hydromatic.optiq.jdbc.Driver");
     Connection connection =
@@ -140,9 +140,9 @@ public static List<Pair<String, String>> getFoodmartQueries() {
     JavaTypeFactory typeFactory = optiqConnection.getTypeFactory();
     SchemaPlus rootSchema = optiqConnection.getRootSchema();
     SchemaPlus schema = rootSchema.add(new AbstractSchema(rootSchema, "s"));
-    final TableFunction tableFunction =
+    final TableMacro tableMacro =
         Schemas.methodMember(GENERATE_STRINGS_METHOD, typeFactory);
-    schema.add("GenerateStrings", tableFunction);
+    schema.add("GenerateStrings", tableMacro);
     ResultSet resultSet = connection.createStatement().executeQuery(
         "select *\n"
         + "from table(\"s\".\"GenerateStrings\"(5)) as t(n, c)\n"

File: avatica/src/main/java/net/hydromatic/avatica/ConnectStringParser.java
Patch:
@@ -370,10 +370,10 @@ public static String getParamString(Properties props) {
    *
    * <blockquote>
    * <code>
-   * Properties properties;<br/>
+   * Properties properties;<br>
    * for (Map.Entry&lt;String, String&gt; entry =
-   * Util.toMap(properties).entrySet()) {<br/>
-   *   println("key=" + entry.getKey() + ", value=" + entry.getValue());<br/>
+   * Util.toMap(properties).entrySet()) {<br>
+   *   println("key=" + entry.getKey() + ", value=" + entry.getValue());<br>
    * }
    * </code>
    * </blockquote>

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcQueryProvider.java
Patch:
@@ -17,9 +17,7 @@
 */
 package net.hydromatic.optiq.impl.jdbc;
 
-import net.hydromatic.linq4j.Enumerator;
-import net.hydromatic.linq4j.QueryProviderImpl;
-import net.hydromatic.linq4j.Queryable;
+import net.hydromatic.linq4j.*;
 
 /**
  * Implementation of {@link QueryProvider} that talks to JDBC databases.

File: core/src/main/java/net/hydromatic/optiq/runtime/SqlFunctions.java
Patch:
@@ -1444,12 +1444,12 @@ public static Object item(Object object, Object index) {
     return null;
   }
 
-  /** NULL -> FALSE, FALSE -> FALSE, TRUE -> TRUE. */
+  /** NULL &rarr; FALSE, FALSE &rarr; FALSE, TRUE &rarr; TRUE. */
   public static boolean isTrue(Boolean b) {
     return b != null && b;
   }
 
-  /** NULL -> TRUE, FALSE -> FALSE, TRUE -> TRUE. */
+  /** NULL &rarr; TRUE, FALSE &rarr; FALSE, TRUE &rarr; TRUE. */
   public static boolean isNotFalse(Boolean b) {
     return b == null || b;
   }

File: core/src/main/java/org/eigenbase/rel/AggregateRel.java
Patch:
@@ -41,9 +41,8 @@ public final class AggregateRel extends AggregateRelBase {
    *
    * @param cluster  Cluster that this relational expression belongs to
    * @param child    input relational expression
-   * @param groupSet Bitset of grouping fields
-   * @param aggCalls Array of aggregates to compute
-   * @pre aggCalls != null
+   * @param groupSet Bit set of grouping fields
+   * @param aggCalls Array of aggregates to compute, not null
    */
   public AggregateRel(
       RelOptCluster cluster,

File: core/src/main/java/org/eigenbase/rel/AggregateRelBase.java
Patch:
@@ -52,7 +52,7 @@ public abstract class AggregateRelBase extends SingleRel {
    * @param cluster  Cluster
    * @param traits   Traits
    * @param child    Child
-   * @param groupSet Bitset of grouping fields
+   * @param groupSet Bit set of grouping fields
    * @param aggCalls Collection of calls to aggregate functions
    */
   protected AggregateRelBase(
@@ -62,7 +62,7 @@ protected AggregateRelBase(
       BitSet groupSet,
       List<AggregateCall> aggCalls) {
     super(cluster, traits, child);
-    Util.pre(aggCalls != null, "aggCalls != null");
+    assert aggCalls != null;
     this.aggCalls = ImmutableList.copyOf(aggCalls);
     this.groupSet = groupSet;
     assert groupSet != null;

File: core/src/main/java/org/eigenbase/rel/JoinRelBase.java
Patch:
@@ -287,9 +287,6 @@ public static RelDataType deriveJoinRowType(
    *                        output row type; typically empty but must not be
    *                        null
    * @return type of row which results when two relations are joined
-   * @pre fieldNameList == null
-   * || fieldNameList.size() == systemFieldList.size()
-   * + leftType.getFieldCount() + rightType.getFieldCount()
    */
   public static RelDataType createJoinType(
       RelDataTypeFactory typeFactory,

File: core/src/main/java/org/eigenbase/rel/RelNode.java
Patch:
@@ -290,9 +290,7 @@ void replaceInput(
 
   /**
    * Returns a description of the physical ordering (or orderings) of this
-   * relational expression.
-   *
-   * @post return != null
+   * relational expression. Never null.
    */
   List<RelCollation> getCollationList();
 

File: core/src/main/java/org/eigenbase/rel/TableAccessRel.java
Patch:
@@ -30,20 +30,20 @@
  * possible to read all of the rows unless some narrowing constraint is applied.
  *
  * <p>In the example of the <code>net.sf.saffron.ext.ReflectSchema</code>
- * schema,
+ * schema,</p>
  *
  * <blockquote>
  * <pre>select from fields</pre>
  * </blockquote>
  *
- * cannot be implemented, but
+ * <p>cannot be implemented, but</p>
  *
  * <blockquote>
  * <pre>select from fields as f
  * where f.getClass().getName().equals("java.lang.String")</pre>
  * </blockquote>
  *
- * can. It is the optimizer's responsibility to find these ways, by applying
+ * <p>can. It is the optimizer's responsibility to find these ways, by applying
  * transformation rules.</p>
  */
 public final class TableAccessRel extends TableAccessRelBase {

File: core/src/main/java/org/eigenbase/rel/convert/ConverterRule.java
Patch:
@@ -39,8 +39,6 @@ public abstract class ConverterRule extends RelOptRule {
    * @param in          Trait of relational expression to consider converting
    * @param out         Trait which is converted to
    * @param description Description of rule
-   * @pre in != null
-   * @pre out != null
    */
   public ConverterRule(
       Class<? extends RelNode> clazz,

File: core/src/main/java/org/eigenbase/rel/rules/AddRedundantSemiJoinRule.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Rule to add a semijoin into a joinrel. Transformation is as follows:
  *
- * <p>JoinRel(X, Y) -> JoinRel(SemiJoinRel(X, Y), Y)
+ * <p>JoinRel(X, Y) &rarr; JoinRel(SemiJoinRel(X, Y), Y)
  */
 public class AddRedundantSemiJoinRule extends RelOptRule {
   public static final AddRedundantSemiJoinRule INSTANCE =

File: core/src/main/java/org/eigenbase/rel/rules/PullConstantsThroughAggregatesRule.java
Patch:
@@ -32,7 +32,7 @@
  * PullConstantsThroughAggregatesRule removes constant expressions from the
  * group list of an {@link AggregateRel}.
  *
- * <h4>Effect of the rule</h4>
+ * <p><b>Effect of the rule</b></p>
  *
  * <p>Since the transformed relational expression has to match the original
  * relational expression, the constants are placed in a projection above the

File: core/src/main/java/org/eigenbase/rel/rules/PushSemiJoinPastFilterRule.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * PushSemiJoinPastFilterRule implements the rule for pushing semijoins down in
  * a tree past a filter in order to trigger other rules that will convert
- * semijoins. SemiJoinRel(FilterRel(X), Y) --> FilterRel(SemiJoinRel(X, Y))
+ * semijoins. SemiJoinRel(FilterRel(X), Y) &rarr; FilterRel(SemiJoinRel(X, Y))
  */
 public class PushSemiJoinPastFilterRule extends RelOptRule {
   public static final PushSemiJoinPastFilterRule INSTANCE =

File: core/src/main/java/org/eigenbase/rel/rules/PushSemiJoinPastProjectRule.java
Patch:
@@ -30,7 +30,7 @@
  * a tree past a project in order to trigger other rules that will convert
  * semijoins.
  *
- * <p>SemiJoinRel(ProjectRel(X), Y) --> ProjectRel(SemiJoinRel(X, Y))
+ * <p>SemiJoinRel(ProjectRel(X), Y) &rarr; ProjectRel(SemiJoinRel(X, Y))
  */
 public class PushSemiJoinPastProjectRule extends RelOptRule {
   public static final PushSemiJoinPastProjectRule INSTANCE =

File: core/src/main/java/org/eigenbase/relopt/AbstractRelOptPlanner.java
Patch:
@@ -233,7 +233,6 @@ public Executor getExecutor() {
    * Fires a rule, taking care of tracing and listener notification.
    *
    * @param ruleCall description of rule call
-   * @pre ruleCall.getRule().matches(ruleCall)
    */
   protected void fireRule(
       RelOptRuleCall ruleCall) {

File: core/src/main/java/org/eigenbase/relopt/RelOptTable.java
Patch:
@@ -70,7 +70,6 @@ public interface RelOptTable {
    * Returns a description of the physical ordering (or orderings) of the rows
    * returned from this table.
    *
-   * @post return != null
    * @see RelNode#getCollationList()
    */
   List<RelCollation> getCollationList();

File: core/src/main/java/org/eigenbase/relopt/RelOptUtil.java
Patch:
@@ -240,8 +240,6 @@ public static Mappings.TargetMapping permutation(
    * net.sf.farrago.fennel.rel. The last two arguments do not apply to
    * those invocations and can be removed from the method.
    *
-   *
-   *
    * @param cluster    Cluster
    * @param seekRel    A query rel, for example the resulting rel from 'select *
    *                   from emp' or 'values (1,2,3)' or '('Foo', 34)'.
@@ -250,14 +248,14 @@ public static Mappings.TargetMapping permutation(
    * @param extraName  Name of expression to add.
    * @return relational expression which outer joins a boolean condition
    * column
-   * @pre extraExpr == null || extraName != null
    */
   public static RelNode createExistsPlan(
       RelOptCluster cluster,
       RelNode seekRel,
       List<RexNode> conditions,
       RexLiteral extraExpr,
       String extraName) {
+    assert extraExpr == null || extraName != null;
     RelNode ret = seekRel;
 
     if ((conditions != null) && (conditions.size() > 0)) {

File: core/src/main/java/org/eigenbase/relopt/volcano/VolcanoRuleCall.java
Patch:
@@ -146,8 +146,6 @@ public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv) {
 
   /**
    * Called when all operands have matched.
-   *
-   * @pre getRule().matches(this)
    */
   protected void onMatch() {
     assert getRule().matches(this);

File: core/src/main/java/org/eigenbase/reltype/RelDataType.java
Patch:
@@ -56,7 +56,6 @@ public interface RelDataType /*extends Type*/ {
    * the returned list.
    *
    * @return read-only list of fields
-   * @pre this.isStruct()
    */
   List<RelDataTypeField> getFieldList();
 
@@ -91,7 +90,6 @@ public interface RelDataType /*extends Type*/ {
    * @param fieldName name of field to find
    * @param caseSensitive Whether case-sensitive
    * @return named field, or null if not found
-   * @pre this.isStruct()
    */
   RelDataTypeField getField(String fieldName, boolean caseSensitive);
 

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeFieldImpl.java
Patch:
@@ -32,8 +32,7 @@ public class RelDataTypeFieldImpl implements RelDataTypeField, Serializable {
   //~ Constructors -----------------------------------------------------------
 
   /**
-   * @pre name != null
-   * @pre type != null
+   * Creates a RelDataTypeFieldImpl.
    */
   public RelDataTypeFieldImpl(
       String name,

File: core/src/main/java/org/eigenbase/reltype/RelDataTypePrecedenceList.java
Patch:
@@ -37,11 +37,12 @@ public interface RelDataTypePrecedenceList {
   /**
    * Compares the precedence of two types.
    *
+   * <p>The list must contain both types.</p>
+   *
    * @param type1 first type to compare
    * @param type2 second type to compare
    * @return positive if type1 has higher precedence; negative if type2 has
    * higher precedence; 0 if types have equal precedence
-   * @pre containsType(type1) && containsType(type2)
    */
   int compareTypePrecedence(RelDataType type1, RelDataType type2);
 }

File: core/src/main/java/org/eigenbase/rex/RexProgramBuilder.java
Patch:
@@ -793,8 +793,6 @@ public void clearCondition() {
    * Adds a project item for every input field.
    *
    * <p>You cannot call this method if there are other project items.
-   *
-   * @pre projectRefList.isEmpty()
    */
   public void addIdentity() {
     assert projectRefList.isEmpty();

File: core/src/main/java/org/eigenbase/rex/RexUtil.java
Patch:
@@ -169,9 +169,9 @@ public static boolean isNullLiteral(
 
   /**
    * Returns whether a node represents the NULL value or a series of nested
-   * CAST(NULL as <TYPE>) calls<br>
-   * For Example:<br>
-   * isNull(CAST(CAST(NULL as INTEGER) AS VARCHAR(1))) returns true
+   * {@code CAST(NULL AS type)} calls. For example:
+   * <code>isNull(CAST(CAST(NULL as INTEGER) AS VARCHAR(1)))</code>
+   * returns {@code true}.
    */
   public static boolean isNull(RexNode expr) {
     switch (expr.getKind()) {

File: core/src/main/java/org/eigenbase/sarg/SargSetOperator.java
Patch:
@@ -23,13 +23,13 @@
  */
 public enum SargSetOperator {
   /**
-   * Set intersection over any number of children (no children => universal
+   * Set intersection over any number of children (no children &rarr; universal
    * set).
    */
   INTERSECTION,
 
   /**
-   * Set union over any number of children (no children => empty set).
+   * Set union over any number of children (no children &rarr; empty set).
    */
   UNION,
 

File: core/src/main/java/org/eigenbase/sql/SqlCollation.java
Patch:
@@ -129,6 +129,7 @@ public int hashCode() {
    * @param col2 second operand for the dyadic operation
    * @return the resulting collation sequence. The "no collating sequence"
    * result is returned as null.
+   *
    * @sql.99 Part 2 Section 4.2.3 Table 2
    */
   public static SqlCollation getCoercibilityDyadicOperator(
@@ -147,6 +148,7 @@ public static SqlCollation getCoercibilityDyadicOperator(
    * @throws EigenbaseException {@link EigenbaseNewResource#invalidCompare} or
    *                            {@link EigenbaseNewResource#differentCollations}
    *                            if no collating sequence can be deduced
+   *
    * @sql.99 Part 2 Section 4.2.3 Table 2
    */
   public static SqlCollation getCoercibilityDyadicOperatorThrows(
@@ -171,6 +173,7 @@ public static SqlCollation getCoercibilityDyadicOperatorThrows(
    * @param col2 second operand for the dyadic operation
    * @return the resulting collation sequence. If no collating sequence could
    * be deduced a {@link EigenbaseNewResource#invalidCompare} is thrown
+   *
    * @sql.99 Part 2 Section 4.2.3 Table 3
    */
   public static String getCoercibilityDyadicComparison(

File: core/src/main/java/org/eigenbase/sql/SqlKind.java
Patch:
@@ -46,7 +46,7 @@
  * <pre>exp.{@link org.eigenbase.sql.SqlNode#isA isA}({@link #COMPARISON SqlKind.Comparison})</pre>
  * </blockquote>
  *
- * To quickly choose between a number of options, use a switch statement:
+ * <p>To quickly choose between a number of options, use a switch statement:</p>
  *
  * <blockquote>
  * <pre>switch (exp.getKind()) {
@@ -58,7 +58,6 @@
  *     throw {@link org.eigenbase.util.Util#unexpected Util.unexpected}(exp.getKind());
  * }</pre>
  * </blockquote>
- * </p>
  */
 public enum SqlKind {
   //~ Static fields/initializers ---------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlOperatorBinding.java
Patch:
@@ -163,10 +163,8 @@ public String getColumnListParamInfo(
   /**
    * Wraps a validation error with context appropriate to this operator call.
    *
-   * @param e Validation error
+   * @param e Validation error, not null
    * @return Error wrapped, if possible, with positional information
-   * @pre node != null
-   * @post return != null
    */
   public abstract EigenbaseException newError(
       Resources.ExInst<SqlValidatorException> e);

File: core/src/main/java/org/eigenbase/sql/SqlOverOperator.java
Patch:
@@ -29,14 +29,13 @@
 /**
  * An operator describing a window function specification.
  *
- * <p>Operands are as follows:
+ * <p>Operands are as follows:</p>
  *
  * <ul>
  * <li>0: name of window function ({@link org.eigenbase.sql.SqlCall})</li>
  * <li>1: window name ({@link org.eigenbase.sql.SqlLiteral}) or window in-line
  * specification ({@link SqlWindow})</li>
  * </ul>
- * </p>
  */
 public class SqlOverOperator extends SqlBinaryOperator {
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlSampleSpec.java
Patch:
@@ -20,14 +20,14 @@
 /**
  * Specification of a SQL sample.
  *
- * <p>For example, the query
+ * <p>For example, the query</p>
  *
  * <blockquote>
  * <pre>SELECT *
  * FROM emp TABLESAMPLE SUBSTITUTE('medium')</pre>
  * </blockquote>
  *
- * declares a sample which is created using {@link #createNamed}.</p>
+ * <p>declares a sample which is created using {@link #createNamed}.</p>
  *
  * <p>A sample is not a {@link SqlNode}. To include it in a parse tree, wrap it
  * as a literal, viz: {@link SqlLiteral#createSample(SqlSampleSpec,

File: core/src/main/java/org/eigenbase/sql/SqlSelectOperator.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * An operator describing a query. (Not a query itself.)
  *
- * <p>Operands are:
+ * <p>Operands are:</p>
  *
  * <ul>
  * <li>0: distinct ({@link SqlLiteral})</li>
@@ -38,7 +38,6 @@
  * <li>6: windowClause ({@link SqlNodeList})</li>
  * <li>7: orderClause ({@link SqlNode})</li>
  * </ul>
- * </p>
  */
 public class SqlSelectOperator extends SqlOperator {
   public static final SqlSelectOperator INSTANCE =

File: core/src/main/java/org/eigenbase/sql/SqlWindow.java
Patch:
@@ -37,7 +37,7 @@
 /**
  * SQL window specification.
  *
- * <p>For example, the query
+ * <p>For example, the query</p>
  *
  * <blockquote>
  * <pre>SELECT sum(a) OVER (w ROWS 3 PRECEDING)
@@ -46,7 +46,7 @@
  *     w1 AS (w ROWS 5 PRECEDING UNBOUNDED FOLLOWING)</pre>
  * </blockquote>
  *
- * declares windows w and w1, and uses a window in an OVER clause. It thus
+ * <p>declares windows w and w1, and uses a window in an OVER clause. It thus
  * contains 3 {@link SqlWindow} objects.</p>
  */
 public class SqlWindow extends SqlCall {

File: core/src/main/java/org/eigenbase/sql/parser/SqlParseException.java
Patch:
@@ -97,7 +97,7 @@ public SqlParserPos getPos() {
    * {"IN"}
    * {"BETWEEN"}
    * {"LIKE"}
-   * {"=", "&lt;IDENTIFIER>"}
+   * {"=", "&lt;IDENTIFIER&gt;"}
    * {"=", "USER"}
    * </pre>
    * </blockquote>
@@ -106,7 +106,7 @@ public SqlParserPos getPos() {
    *
    * <blockquote>
    * <pre>
-   * "&lt;IDENTIFIER>"
+   * "&lt;IDENTIFIER&gt;"
    * "USER"
    * </pre>
    * </blockquote>

File: core/src/main/java/org/eigenbase/sql/parser/SqlParserUtil.java
Patch:
@@ -525,10 +525,9 @@ public static <T> void replaceSublist(
   /**
    * Converts a list of {expression, operator, expression, ...} into a tree,
    * taking operator precedence and associativity into account.
-   *
-   * @pre list.size() % 2 == 1
    */
   public static SqlNode toTree(List<Object> list) {
+    assert list.size() % 2 == 1;
     if (LOGGER.isLoggable(Level.FINER)) {
       LOGGER.finer("Attempting to reduce " + list);
     }

File: core/src/main/java/org/eigenbase/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -35,6 +35,7 @@
  * <p>There are several options to control the format.
  *
  * <table>
+ * <caption>Formatting options</caption>
  * <tr>
  * <th>Option</th>
  * <th>Description</th>

File: core/src/main/java/org/eigenbase/sql/type/MultisetSqlType.java
Patch:
@@ -33,12 +33,10 @@ public class MultisetSqlType extends AbstractSqlType {
   /**
    * Constructs a new MultisetSqlType. This constructor should only be called
    * from a factory method.
-   *
-   * @pre null!=elementType
    */
   public MultisetSqlType(RelDataType elementType, boolean isNullable) {
     super(SqlTypeName.MULTISET, isNullable, null);
-    Util.pre(null != elementType, "null!=elementType");
+    assert elementType != null;
     this.elementType = elementType;
     computeDigest();
   }

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeName.java
Patch:
@@ -367,6 +367,7 @@ public static SqlTypeName getNameForJdbcType(int jdbcType) {
    * Returns the limit of this datatype. For example,
    *
    * <table border="1">
+   * <caption>Datatype limits</caption>
    * <tr>
    * <th>Datatype</th>
    * <th>sign</th>

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -2701,7 +2701,6 @@ private RelDataType validateUsingCol(SqlIdentifier id, SqlNode leftOrRight) {
    * @param select        Select statement
    * @param targetRowType Desired row type, must not be null, may be the data
    *                      type 'unknown'.
-   * @pre targetRowType != null
    */
   protected void validateSelect(
       SqlSelect select,

File: core/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -1623,7 +1623,6 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
    *             <li>a query ("(SELECT * FROM EMP WHERE GENDER = 'F')"),
    *             <li>or any combination of the above.
    *             </ul>
-   * @post return != null
    */
   protected void convertFrom(
       Blackboard bb,
@@ -2582,7 +2581,6 @@ public RexDynamicParam convertDynamicParam(
    * @param extraOrderExprs Sort expressions which are not in the select
    *                        clause (output)
    * @param collationList   List of collations (output)
-   * @pre bb.root != null
    */
   protected void gatherOrderExprs(
       Blackboard bb,

File: core/src/main/java/org/eigenbase/util/DelegatingInvocationHandler.java
Patch:
@@ -28,7 +28,7 @@
  * <p>It is useful in creating a wrapper class around an interface which may
  * change over time.</p>
  *
- * <p>Example:
+ * <p>Example:</p>
  *
  * <blockquote>
  * <pre>import java.sql.Connection;
@@ -46,7 +46,6 @@
  *         }
  *     });</pre>
  * </blockquote>
- * </p>
  */
 public abstract class DelegatingInvocationHandler implements InvocationHandler {
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/util/MainApp.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * Abstract base class for a Java application invoked from the command-line.
  *
- * <p>Example usage:
+ * <p>Example usage:</p>
  *
  * <blockquote>
  * <pre>public class MyClass extends MainApp {
@@ -32,7 +32,6 @@
  *     }
  * }</pre>
  * </blockquote>
- * </p>
  */
 public abstract class MainApp {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/util/NlsString.java
Patch:
@@ -52,13 +52,12 @@ public class NlsString implements Comparable<NlsString> {
    *     is available in this instance of the Java virtual machine
    * @throws RuntimeException If the given value cannot be represented in the
    *     given charset
-   * @pre theString != null
    */
   public NlsString(
       String value,
       String charsetName,
       SqlCollation collation) {
-    Util.pre(value != null, "theString != null");
+    assert value != null;
     if (null != charsetName) {
       charsetName = charsetName.toUpperCase();
       this.charsetName = charsetName;

File: core/src/main/java/org/eigenbase/util/Permutation.java
Patch:
@@ -117,6 +117,7 @@ public void clear() {
    * <p>For example, the mapping
    *
    * <table>
+   * <caption>Example mapping</caption>
    * <tr>
    * <th>source</th>
    * <th>target</th>
@@ -261,6 +262,7 @@ public void set(int source, int target, boolean allowResize) {
    * <p>For example, consider the permutation</p>
    *
    * <table border="1">
+   * <caption>Example permutation</caption>
    * <tr>
    * <td>source</td>
    * <td>0</td>
@@ -283,6 +285,7 @@ public void set(int source, int target, boolean allowResize) {
    * shifted up one.</p>
    *
    * <table border="1">
+   * <caption>Mapping after applying insertTarget(2)</caption>
    * <tr>
    * <td>source</td>
    * <td>0</td>

File: core/src/main/java/org/eigenbase/util/ReflectUtil.java
Patch:
@@ -494,7 +494,7 @@ public boolean invokeVisitor(
    *
    * could be used to call the methods
    *
-   * <blockquote>String foo(Car, int, List)<br/>
+   * <blockquote>String foo(Car, int, List)<br>
    * String foo(Bus, int, List)</blockquote>
    *
    * (because Car and Bus are subclasses of Vehicle, and they occur in the

File: core/src/main/java/org/eigenbase/util/StackWriter.java
Patch:
@@ -37,7 +37,7 @@
  *    pw.write(StackWriter.OPEN_SQL_STRING_LITERAL);
  *    pw.println();
  *    pw.write(StackWriter.INDENT);
- *    pw.println("select * from t where c > 'alabama'");
+ *    pw.println("select * from t where c &gt; 'alabama'");
  *    pw.write(StackWriter.OUTDENT);
  *    pw.write(StackWriter.CLOSE_SQL_STRING_LITERAL);
  *    pw.println(");");
@@ -50,7 +50,7 @@
  *
  * <pre><code>
  *      execute remote(link_name,'
- *          select * from t where c > ''alabama''
+ *          select * from t where c &gt; ''alabama''
  *      ');
  * </code></pre>
  */

File: core/src/main/java/org/eigenbase/util14/DateTimeUtil.java
Patch:
@@ -139,7 +139,6 @@ private static Calendar parseDateFormat(
    *                default time zone
    * @return a Calendar initialized with the parsed value, or null if parsing
    * failed. If returned, the Calendar is configured to the GMT time zone.
-   * @pre pattern != null
    */
   public static Calendar parseDateFormat(
       String s,
@@ -169,12 +168,12 @@ public static Calendar parseDateFormat(
    * @return a {@link DateTimeUtil.PrecisionTime PrecisionTime} initialized
    * with the parsed value, or null if parsing failed. The PrecisionTime
    * contains a GMT Calendar and a precision.
-   * @pre pattern != null
    */
   public static PrecisionTime parsePrecisionDateTimeLiteral(
       String s,
       String pattern,
       TimeZone tz) {
+    assert pattern != null;
     ParsePosition pp = new ParsePosition(0);
     Calendar cal = parseDateFormat(s, pattern, tz, pp);
     if (cal == null) {

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -464,7 +464,7 @@ private static boolean isNumeric(Class type) {
   }
 
   /** If a method returns a
-   * {@link net.hydromatic.optiq.impl.ViewTable.ViewTableFunction}, then it
+   * {@link ViewTable}.{@code ViewTableFunction}, then it
    * should be expanded. */
   @Ignore
   @Test public void testTableFunctionIsView() throws Exception {

File: core/src/test/java/org/eigenbase/sql/test/SqlTests.java
Patch:
@@ -212,9 +212,9 @@ public static void compareResultList(
    * reference lists, taking order into account.
    *
    * @param resultSet Result set
-   * @param refLists  vararg of List<String>. The first list is compared to the
-   *                  first column, the second list to the second column and so
-   *                  on
+   * @param refLists  vararg of List&lt;String&gt;. The first list is compared
+   *                  to the first column, the second list to the second column
+   *                  and so on
    */
   public static void compareResultLists(
       ResultSet resultSet,

File: core/src/test/java/org/eigenbase/test/concurrent/package-info.java
Patch:
@@ -114,7 +114,7 @@
  * <h4>Basic Commands (allowed in any section):</h4>
  *
  * <p><pre>
- * &lt;SQL statement&gt;&semi;
+ * &lt;SQL statement&gt;:
  *     An SQL statement terminated by a semicolon. The statement can span lines.
  * </pre>
  * <p><pre>

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoTableScan.java
Patch:
@@ -41,7 +41,7 @@ public class MongoTableScan extends TableAccessRelBase implements MongoRel {
    * @param traitSet       Traits
    * @param table          Table
    * @param mongoTable     MongoDB table
-   * @param projectRowType Fields & types to project; null to project raw row
+   * @param projectRowType Fields and types to project; null to project raw row
    * @param ops            List of operators to apply
    */
   protected MongoTableScan(RelOptCluster cluster, RelTraitSet traitSet,

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/SplunkTableAccessRel.java
Patch:
@@ -41,7 +41,7 @@
  * <p>Splunk does not have tables, but it's easiest to imagine that a Splunk
  * instance is one large table. This "table" does not have a fixed set of
  * columns (Splunk calls them "fields") but each query specifies the fields that
- * it wants. It also specifies a search expression, and optionally earliest &
+ * it wants. It also specifies a search expression, and optionally earliest and
  * latest dates.</p>
  */
 public class SplunkTableAccessRel

File: core/src/main/java/org/eigenbase/sql/validate/CollectNamespace.java
Patch:
@@ -82,9 +82,9 @@ protected RelDataType validateImpl() {
         return type;
       } else {
         final RelDataType structType =
-            typeFactory.createStructType(
-                new RelDataType[]{type},
-                new String[]{validator.deriveAlias(child, 0)});
+            typeFactory.builder()
+                .add(validator.deriveAlias(child, 0), type)
+                .build();
         final RelDataType multisetType =
             typeFactory.createMultisetType(structType, -1);
         return typeFactory.createTypeWithNullability(

File: core/src/main/java/org/eigenbase/sql/validate/UnnestNamespace.java
Patch:
@@ -56,9 +56,9 @@ protected RelDataType validateImpl() {
     if (type.isStruct()) {
       return type;
     }
-    return validator.getTypeFactory().createStructType(
-        new RelDataType[]{type},
-        new String[]{validator.deriveAlias(unnest, 0)});
+    return validator.getTypeFactory().builder()
+        .add(validator.deriveAlias(unnest, 0), type)
+        .build();
   }
 
   /**

File: core/src/test/java/org/eigenbase/sql/test/SqlTesterImpl.java
Patch:
@@ -437,7 +437,7 @@ public void checkRewrite(
     SqlNode rewrittenNode = parseAndValidate(validator, query);
     String actualRewrite =
         rewrittenNode.toSqlString(SqlDialect.DUMMY, false).getSql();
-    TestUtil.assertEqualsVerbose(expectedRewrite, actualRewrite);
+    TestUtil.assertEqualsVerbose(expectedRewrite, Util.toLinux(actualRewrite));
   }
 
   public void checkFails(

File: core/src/test/java/org/eigenbase/test/DiffRepository.java
Patch:
@@ -525,7 +525,7 @@ private static void writeNode(Node node, XmlOutput out) {
     final NodeList childNodes;
     switch (node.getNodeType()) {
     case Node.DOCUMENT_NODE:
-      out.print("<?xml version=\"1.0\" ?>" + TestUtil.NL);
+      out.print("<?xml version=\"1.0\" ?>\n");
       childNodes = node.getChildNodes();
       for (int i = 0; i < childNodes.getLength(); i++) {
         Node child = childNodes.item(i);
@@ -586,7 +586,7 @@ private static void writeNode(Node node, XmlOutput out) {
 
     case Node.COMMENT_NODE:
       Comment comment = (Comment) node;
-      out.print("<!--" + comment.getNodeValue() + "-->" + TestUtil.NL);
+      out.print("<!--" + comment.getNodeValue() + "-->\n");
       break;
 
     default:

File: core/src/test/java/org/eigenbase/test/MockCatalogReader.java
Patch:
@@ -111,9 +111,7 @@ protected void init() {
     final RelDataType booleanType =
         typeFactory.createSqlType(SqlTypeName.BOOLEAN);
     final RelDataType rectilinearCoordType =
-        typeFactory.createStructType(
-            new RelDataType[]{intType, intType},
-            new String[]{"X", "Y"});
+        typeFactory.builder().add("X", intType).add("Y", intType).build();
 
     // TODO jvs 12-Feb-2005: register this canonical instance with type
     // factory

File: core/src/test/java/org/eigenbase/util/UtilTest.java
Patch:
@@ -395,9 +395,8 @@ private String toString(byte[] bytes) {
         DiffTestCase.diffLines(
             Arrays.asList(before),
             Arrays.asList(after));
-    assertEquals(
-        diff,
-        TestUtil.fold(
+    assertThat(Util.toLinux(diff),
+        equalTo(
             "1a2\n"
             + "> (they call her \"Polythene Pam\")\n"
             + "3c4,5\n"

File: core/src/main/java/org/eigenbase/relopt/AbstractRelOptPlanner.java
Patch:
@@ -214,6 +214,9 @@ public boolean addRelTraitDef(RelTraitDef relTraitDef) {
     return false;
   }
 
+  // implement RelOptPlanner
+  public void clearRelTraitDefs() {}
+
   public List<RelTraitDef> getRelTraitDefs() {
     return Collections.emptyList();
   }

File: core/src/main/java/net/hydromatic/optiq/prepare/PlannerImpl.java
Patch:
@@ -190,6 +190,7 @@ public RelNode transform(int ruleSetIndex, RelTraitSet requiredOutputTraits,
     ensure(State.STATE_5_CONVERTED);
     RuleSet ruleSet = ruleSets.get(ruleSetIndex);
     planner.clearRules();
+    planner.clear();
     for (RelOptRule rule : ruleSet) {
       planner.addRule(rule);
     }

File: core/src/main/java/org/eigenbase/relopt/AbstractRelOptPlanner.java
Patch:
@@ -73,6 +73,8 @@ protected AbstractRelOptPlanner(RelOptCostFactory costFactory) {
 
   //~ Methods ----------------------------------------------------------------
 
+  public void clear() {}
+
   public RelOptCostFactory getCostFactory() {
     return costFactory;
   }

File: core/src/main/java/net/hydromatic/optiq/Schemas.java
Patch:
@@ -21,6 +21,7 @@
 import net.hydromatic.linq4j.Queryable;
 import net.hydromatic.linq4j.expressions.*;
 
+import net.hydromatic.optiq.config.OptiqConnectionConfig;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 import net.hydromatic.optiq.jdbc.*;
 
@@ -275,7 +276,7 @@ private static OptiqPrepare.Context makeContext(
   }
 
   private static OptiqPrepare.Context makeContext(
-      final ConnectionConfig connectionConfig,
+      final OptiqConnectionConfig connectionConfig,
       final JavaTypeFactory typeFactory,
       final DataContext dataContext,
       final OptiqSchema schema,
@@ -298,7 +299,7 @@ public List<String> getDefaultSchemaPath() {
         return schemaPath;
       }
 
-      public ConnectionConfig config() {
+      public OptiqConnectionConfig config() {
         return connectionConfig;
       }
 

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqPrepare.java
Patch:
@@ -24,6 +24,7 @@
 import net.hydromatic.linq4j.function.Function0;
 
 import net.hydromatic.optiq.*;
+import net.hydromatic.optiq.config.OptiqConnectionConfig;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 import net.hydromatic.optiq.prepare.OptiqPrepareImpl;
 import net.hydromatic.optiq.runtime.*;
@@ -82,7 +83,7 @@ interface Context {
 
     List<String> getDefaultSchemaPath();
 
-    ConnectionConfig config();
+    OptiqConnectionConfig config();
 
     /** Returns the spark handler. Never null. */
     SparkHandler spark();

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -27,8 +27,8 @@
 
 import net.hydromatic.optiq.*;
 import net.hydromatic.optiq.Table;
+import net.hydromatic.optiq.config.OptiqConnectionConfig;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
-import net.hydromatic.optiq.jdbc.ConnectionConfig;
 import net.hydromatic.optiq.jdbc.OptiqPrepare;
 import net.hydromatic.optiq.jdbc.OptiqSchema;
 import net.hydromatic.optiq.materialize.MaterializationService;
@@ -304,7 +304,7 @@ <T> PrepareResult<T> prepare2_(
     final Prepare.PreparedResult preparedResult;
     if (sql != null) {
       assert queryable == null;
-      final ConnectionConfig config = context.config();
+      final OptiqConnectionConfig config = context.config();
       SqlParser parser = new SqlParser(sql, config.quoting(),
           config.unquotedCasing(), config.quotedCasing());
       SqlNode sqlNode;

File: core/src/main/java/net/hydromatic/optiq/prepare/PlannerImpl.java
Patch:
@@ -22,8 +22,8 @@
 import net.hydromatic.optiq.Schema;
 import net.hydromatic.optiq.SchemaPlus;
 import net.hydromatic.optiq.Schemas;
+import net.hydromatic.optiq.config.Lex;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
-import net.hydromatic.optiq.jdbc.ConnectionConfig;
 import net.hydromatic.optiq.jdbc.OptiqSchema;
 import net.hydromatic.optiq.tools.*;
 
@@ -43,7 +43,7 @@ public class PlannerImpl implements Planner {
   private final Function1<SchemaPlus, Schema> schemaFactory;
   private final SqlOperatorTable operatorTable;
   private final ImmutableList<RuleSet> ruleSets;
-  private final ConnectionConfig.Lex lex;
+  private final Lex lex;
 
   // Options. TODO: allow client to set these. Maybe use a ConnectionConfig.
   private boolean caseSensitive = true;
@@ -67,7 +67,7 @@ public class PlannerImpl implements Planner {
   private SqlToRelConverter sqlToRelConverter;
   private RelNode rel;
 
-  public PlannerImpl(ConnectionConfig.Lex lex,
+  public PlannerImpl(Lex lex,
       Function1<SchemaPlus, Schema> schemaFactory,
       SqlOperatorTable operatorTable, ImmutableList<RuleSet> ruleSets) {
     this.schemaFactory = schemaFactory;

File: core/src/main/java/net/hydromatic/optiq/tools/Frameworks.java
Patch:
@@ -21,7 +21,7 @@
 
 import net.hydromatic.optiq.Schema;
 import net.hydromatic.optiq.SchemaPlus;
-import net.hydromatic.optiq.jdbc.ConnectionConfig;
+import net.hydromatic.optiq.config.Lex;
 import net.hydromatic.optiq.jdbc.OptiqConnection;
 import net.hydromatic.optiq.prepare.OptiqPrepareImpl;
 import net.hydromatic.optiq.prepare.PlannerImpl;
@@ -65,7 +65,7 @@ private Frameworks() {
    * @return The Planner object.
    */
   public static Planner getPlanner(
-      ConnectionConfig.Lex lex,
+      Lex lex,
       Function1<SchemaPlus, Schema> schemaFactory,
       SqlStdOperatorTable operatorTable, RuleSet... ruleSets) {
     return new PlannerImpl(lex, schemaFactory, operatorTable,

File: core/src/test/java/net/hydromatic/optiq/tools/PlannerTest.java
Patch:
@@ -21,8 +21,8 @@
 
 import net.hydromatic.optiq.Schema;
 import net.hydromatic.optiq.SchemaPlus;
+import net.hydromatic.optiq.config.Lex;
 import net.hydromatic.optiq.impl.java.ReflectiveSchema;
-import net.hydromatic.optiq.jdbc.ConnectionConfig;
 import net.hydromatic.optiq.rules.java.EnumerableConvention;
 import net.hydromatic.optiq.rules.java.JavaRules;
 import net.hydromatic.optiq.test.JdbcTest;
@@ -102,7 +102,7 @@ private String toString(RelNode rel) {
 
   private Planner getPlanner(RuleSet... ruleSets) {
     return Frameworks.getPlanner(
-        ConnectionConfig.Lex.ORACLE,
+        Lex.ORACLE,
         new Function1<SchemaPlus, Schema>() {
           public Schema apply(SchemaPlus parentSchema) {
             return new ReflectiveSchema(parentSchema, "hr",

File: core/src/test/java/org/eigenbase/sql/test/SqlTester.java
Patch:
@@ -28,7 +28,7 @@
 import net.hydromatic.avatica.Casing;
 import net.hydromatic.avatica.Quoting;
 
-import net.hydromatic.optiq.jdbc.ConnectionConfig;
+import net.hydromatic.optiq.config.Lex;
 
 /**
  * SqlTester defines a callback for testing SQL queries and expressions.
@@ -73,7 +73,7 @@ public enum VmName {
   SqlTester withCaseSensitive(boolean sensitive);
 
   /** Returns a tester that follows a lex policy. */
-  SqlTester withLex(ConnectionConfig.Lex lex);
+  SqlTester withLex(Lex lex);
 
   /** Returns a tester that tests conformance to a particular SQL language
    * version. */

File: core/src/test/java/org/eigenbase/sql/test/SqlTesterImpl.java
Patch:
@@ -34,7 +34,7 @@
 import net.hydromatic.avatica.Casing;
 import net.hydromatic.avatica.Quoting;
 
-import net.hydromatic.optiq.jdbc.ConnectionConfig;
+import net.hydromatic.optiq.config.Lex;
 import net.hydromatic.optiq.runtime.Utilities;
 
 import com.google.common.collect.ImmutableList;
@@ -268,7 +268,7 @@ public SqlTester withCaseSensitive(boolean sensitive) {
     return with("caseSensitive", sensitive);
   }
 
-  public SqlTester withLex(ConnectionConfig.Lex lex) {
+  public SqlTester withLex(Lex lex) {
     return withQuoting(lex.quoting)
         .withCaseSensitive(lex.caseSensitive)
         .withQuotedCasing(lex.quotedCasing)

File: core/src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -170,6 +170,7 @@ public enum BuiltinMethod {
   LOCAL_TIMESTAMP(SqlFunctions.class, "localTimestamp", DataContext.class),
   LOCAL_TIME(SqlFunctions.class, "localTime", DataContext.class),
   BOOLEAN_TO_STRING(SqlFunctions.class, "toString", boolean.class),
+  OBJECT_TO_STRING(Object.class, "toString"),
   ROUND_LONG(SqlFunctions.class, "round", long.class, long.class),
   ROUND_INT(SqlFunctions.class, "round", int.class, int.class),
   DATE_TO_INT(SqlFunctions.class, "toInt", java.util.Date.class),

File: core/src/main/java/org/eigenbase/rel/AggregateRelBase.java
Patch:
@@ -22,6 +22,7 @@
 import org.eigenbase.rel.metadata.*;
 import org.eigenbase.relopt.*;
 import org.eigenbase.reltype.*;
+import org.eigenbase.resource.Resources;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.parser.*;
 import org.eigenbase.sql.validate.*;
@@ -279,7 +280,7 @@ public RelDataType getOperandType(int ordinal) {
     }
 
     public EigenbaseException newError(
-        SqlValidatorException e) {
+        Resources.ExInst<SqlValidatorException> e) {
       return SqlUtil.newContextException(SqlParserPos.ZERO, e);
     }
   }

File: core/src/main/java/org/eigenbase/rex/RexCallBinding.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.List;
 
 import org.eigenbase.reltype.*;
+import org.eigenbase.resource.Resources;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.parser.*;
 import org.eigenbase.sql.validate.*;
@@ -74,7 +75,7 @@ public RelDataType getOperandType(int ordinal) {
   }
 
   public EigenbaseException newError(
-      SqlValidatorException e) {
+      Resources.ExInst<SqlValidatorException> e) {
     return SqlUtil.newContextException(SqlParserPos.ZERO, e);
   }
 }

File: core/src/main/java/org/eigenbase/sql/ExplicitOperatorBinding.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.List;
 
 import org.eigenbase.reltype.*;
+import org.eigenbase.resource.Resources;
 import org.eigenbase.sql.parser.*;
 import org.eigenbase.sql.validate.*;
 import org.eigenbase.util.*;
@@ -76,7 +77,7 @@ public RelDataType getOperandType(int ordinal) {
   }
 
   public EigenbaseException newError(
-      SqlValidatorException e) {
+      Resources.ExInst<SqlValidatorException> e) {
     if (delegate != null) {
       return delegate.newError(e);
     } else {

File: core/src/main/java/org/eigenbase/sql/SqlOperatorBinding.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.*;
 
 import org.eigenbase.reltype.*;
+import org.eigenbase.resource.Resources;
 import org.eigenbase.sql.validate.*;
 import org.eigenbase.util.*;
 
@@ -168,7 +169,7 @@ public String getColumnListParamInfo(
    * @post return != null
    */
   public abstract EigenbaseException newError(
-      SqlValidatorException e);
+      Resources.ExInst<SqlValidatorException> e);
 }
 
 // End SqlOperatorBinding.java

File: core/src/main/java/org/eigenbase/sql/fun/SqlMultisetQueryConstructor.java
Patch:
@@ -20,11 +20,12 @@
 import java.util.List;
 
 import org.eigenbase.reltype.*;
-import org.eigenbase.resource.*;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.type.*;
 import org.eigenbase.sql.validate.*;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * Definition of the SQL:2003 standard MULTISET query constructor, <code>
  * MULTISET (&lt;query&gt;)</code>.
@@ -85,8 +86,7 @@ public boolean checkOperandTypes(
             argTypes);
     if (null == componentType) {
       if (throwOnFailure) {
-        throw callBinding.newValidationError(
-            EigenbaseResource.instance().NeedSameTypeParameter.ex());
+        throw callBinding.newValidationError(RESOURCE.needSameTypeParameter());
       }
       return false;
     }

File: core/src/main/java/org/eigenbase/sql/type/MultisetOperandTypeChecker.java
Patch:
@@ -20,9 +20,10 @@
 import java.util.Arrays;
 
 import org.eigenbase.reltype.*;
-import org.eigenbase.resource.*;
 import org.eigenbase.sql.*;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * Parameter type-checking strategy types must be [nullable] Multiset,
  * [nullable] Multiset and the two types must have the same element type
@@ -68,7 +69,7 @@ public boolean checkOperandTypes(
     if (null == biggest) {
       if (throwOnFailure) {
         throw callBinding.newError(
-            EigenbaseResource.instance().TypeNotComparable.ex(
+            RESOURCE.typeNotComparable(
                 op0.getParserPosition().toString(),
                 op1.getParserPosition().toString()));
       }

File: core/src/main/java/org/eigenbase/sql/type/OperandTypes.java
Patch:
@@ -20,11 +20,12 @@
 import java.util.*;
 
 import org.eigenbase.reltype.*;
-import org.eigenbase.resource.*;
 import org.eigenbase.sql.*;
 
 import com.google.common.collect.ImmutableList;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * Strategies for checking operand types.
  *
@@ -208,7 +209,7 @@ public boolean checkSingleOperandType(
           if (value < 0) {
             if (throwOnFailure) {
               throw callBinding.newError(
-                  EigenbaseResource.instance().ArgumentMustBePositiveInteger.ex(
+                  RESOURCE.argumentMustBePositiveInteger(
                       callBinding.getOperator().getName()));
             }
             return false;

File: core/src/main/java/org/eigenbase/sql/type/ReturnTypes.java
Patch:
@@ -21,10 +21,11 @@
 import java.util.List;
 
 import org.eigenbase.reltype.*;
-import org.eigenbase.resource.EigenbaseResource;
 import org.eigenbase.sql.*;
 import org.eigenbase.util.Util;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * A collection of return-type inference strategies.
  */
@@ -524,7 +525,7 @@ public RelDataType inferReturnType(
             if (!SqlTypeUtil.isCharTypeComparable(
                 opBinding.collectOperandTypes().subList(0, 2))) {
               throw opBinding.newError(
-                  EigenbaseResource.instance().TypeNotComparable.ex(
+                  RESOURCE.typeNotComparable(
                       argType0.getFullTypeString(),
                       argType1.getFullTypeString()));
             }

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeUtil.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.*;
 
 import org.eigenbase.reltype.*;
-import org.eigenbase.resource.*;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.parser.*;
 import org.eigenbase.sql.validate.*;
@@ -30,6 +29,8 @@
 
 import com.google.common.base.Preconditions;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * Contains utility methods used during SQL validation or type derivation.
  */
@@ -108,8 +109,7 @@ public static boolean isCharTypeComparable(
           }
           msg += operands.get(i).toString();
         }
-        throw binding.newError(
-            EigenbaseResource.instance().OperandNotComparable.ex(msg));
+        throw binding.newError(RESOURCE.operandNotComparable(msg));
       }
       return false;
     }

File: core/src/main/java/org/eigenbase/sql/type/TableFunctionReturnTypeInference.java
Patch:
@@ -21,9 +21,10 @@
 
 import org.eigenbase.rel.metadata.*;
 import org.eigenbase.reltype.*;
-import org.eigenbase.resource.*;
 import org.eigenbase.sql.*;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * TableFunctionReturnTypeInference implements rules for deriving table function
  * output row types by expanding references to cursor parameters.
@@ -192,8 +193,7 @@ private void addOutputColumn(
     for (String fieldName : expandedFieldNames) {
       if (fieldName.equals(cursorField.getName())) {
         throw opBinding.newError(
-            EigenbaseResource.instance().DuplicateColumnName.ex(
-                cursorField.getName()));
+            RESOURCE.duplicateColumnName(cursorField.getName()));
       }
     }
     expandedOutputTypes.add(nullableType);

File: core/src/main/java/org/eigenbase/sql/validate/TableConstructorNamespace.java
Patch:
@@ -20,6 +20,8 @@
 import org.eigenbase.reltype.*;
 import org.eigenbase.sql.*;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * Namespace for a table constructor <code>VALUES (expr, expr, ...)</code>.
  */
@@ -65,9 +67,7 @@ protected RelDataType validateImpl() {
     final RelDataType tableConstructorRowType =
         validator.getTableConstructorRowType(values, scope);
     if (tableConstructorRowType == null) {
-      throw validator.newValidationError(
-          values,
-          new SqlValidatorException("Incompatible types", null));
+      throw validator.newValidationError(values, RESOURCE.incompatibleTypes());
     }
     return tableConstructorRowType;
   }

File: core/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -25,7 +25,6 @@
 import org.eigenbase.rel.metadata.*;
 import org.eigenbase.relopt.*;
 import org.eigenbase.reltype.*;
-import org.eigenbase.resource.*;
 import org.eigenbase.rex.*;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.fun.*;
@@ -48,6 +47,8 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
+import static org.eigenbase.util.Static.RESOURCE;
+
 /**
  * Converts a SQL parse tree (consisting of {@link org.eigenbase.sql.SqlNode}
  * objects) into a relational algebra expression (consisting of {@link
@@ -2927,8 +2928,7 @@ protected RelNode convertColumnList(
       fieldNames.set(i, fieldName);
       if (sourceExps.get(i) != null) {
         if (defaultValueFactory.isGeneratedAlways(targetTable, i)) {
-          throw EigenbaseResource.instance().InsertIntoAlwaysGenerated
-              .ex(fieldName);
+          throw RESOURCE.insertIntoAlwaysGenerated(fieldName).ex();
         }
         continue;
       }

File: core/src/test/java/net/hydromatic/optiq/test/OptiqSuite.java
Patch:
@@ -58,6 +58,7 @@
     EigenbaseResourceTest.class,
     FilteratorTest.class,
     OptionsListTest.class,
+    ResourceTest.class,
     PermutationTestCase.class,
     SqlFunctionsTest.class,
     SqlTypeNameTest.class,

File: core/src/main/java/net/hydromatic/optiq/rules/java/JavaRules.java
Patch:
@@ -494,8 +494,9 @@ public EnumerableProjectRel(
       assert getConvention() instanceof EnumerableConvention;
     }
 
-    @Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-      return new EnumerableProjectRel(getCluster(), traitSet, sole(inputs),
+    public EnumerableProjectRel copy(RelTraitSet traitSet, RelNode input,
+        List<RexNode> exps, RelDataType rowType) {
+      return new EnumerableProjectRel(getCluster(), traitSet, input,
           exps, rowType, flags);
     }
 

File: core/src/main/java/org/eigenbase/resource/EigenbaseResource_en_US.java
Patch:
@@ -5,8 +5,6 @@
 
 import java.io.IOException;
 
-import org.eigenbase.resgen.*;
-
 /**
  * This class was generated
  * by class org.eigenbase.resgen.ResourceGen

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.logging.*;
 
 import org.eigenbase.reltype.*;
-import org.eigenbase.resgen.*;
 import org.eigenbase.resource.*;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.fun.*;

File: core/src/test/java/org/eigenbase/test/SqlValidatorFeatureTest.java
Patch:
@@ -18,7 +18,6 @@
 package org.eigenbase.test;
 
 import org.eigenbase.reltype.*;
-import org.eigenbase.resgen.*;
 import org.eigenbase.resource.*;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.parser.*;

File: core/src/main/java/net/hydromatic/optiq/materialize/MaterializationService.java
Patch:
@@ -68,7 +68,7 @@ public MaterializationKey defineMaterialization(final OptiqSchema schema,
     RelDataType rowType = null;
     OptiqSchema.TableEntry tableEntry;
     if (tableName != null) {
-      materializedTable = schema.compositeTableMap.get(tableName);
+      materializedTable = schema.getTable(tableName, true);
       if (materializedTable == null) {
         final OptiqPrepare.PrepareResult<Object> prepareResult =
             Schemas.prepare(connection, schema, viewSchemaPath, viewSql);

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqCatalogReader.java
Patch:
@@ -86,7 +86,7 @@ private OptiqPrepareImpl.RelOptTableImpl getTableFrom(
       return null;
     }
     final String name = Util.last(names);
-    final Table table = schema.compositeTableMap.get(name);
+    final Table table = schema.getTable(name, caseSensitive);
     if (table != null) {
       return new OptiqPrepareImpl.RelOptTableImpl(
           this,
@@ -111,7 +111,7 @@ private Collection<TableFunction> getTableFunctionsFrom(
   private OptiqSchema getSchema(Iterable<String> schemaNames) {
     OptiqSchema schema = rootSchema;
     for (String schemaName : schemaNames) {
-      schema = schema.getSubSchema(schemaName);
+      schema = schema.getSubSchema(schemaName, caseSensitive);
       if (schema == null) {
         return null;
       }

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqMaterializer.java
Patch:
@@ -115,7 +115,7 @@ private List<OptiqSchema.TableEntry> getStarTables(OptiqSchema schema) {
     // TODO: Assumes that star tables are all defined in a schema called
     // "mat". Instead, we should look for star tables that use a given set of
     // tables, regardless of schema.
-    final OptiqSchema matSchema = schema.root().getSubSchema("mat");
+    final OptiqSchema matSchema = schema.root().getSubSchema("mat", true);
     if (matSchema != null) {
       for (OptiqSchema.TableEntry tis : matSchema.tableMap.values()) {
         if (tis.getTable().getJdbcTableType() == Schema.TableType.STAR) {

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaDatabaseMetaData.java
Patch:
@@ -145,11 +145,11 @@ public boolean storesLowerCaseIdentifiers() throws SQLException {
   }
 
   public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {
-    return caseSensitive() && quotedCasing() == Casing.UNCHANGED;
+    return !caseSensitive() && quotedCasing() == Casing.UNCHANGED;
   }
 
   public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {
-    return !caseSensitive() && quotedCasing() == Casing.UNCHANGED;
+    return caseSensitive() && quotedCasing() == Casing.UNCHANGED;
   }
 
   public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {

File: core/src/main/java/net/hydromatic/optiq/impl/java/ReflectiveSchema.java
Patch:
@@ -208,7 +208,7 @@ public Enumerator<T> enumerator() {
    *     {
    *       name: "foodmart",
    *       type: "custom",
-   *       factory: "net.hydromatic.optiq.impl.java.ReflectiveSchema.Factory",
+   *       factory: "net.hydromatic.optiq.impl.java.ReflectiveSchema$Factory",
    *       operand: {
    *         class: "com.acme.FoodMart",
    *         staticMethod: "instance"

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcRules.java
Patch:
@@ -158,7 +158,7 @@ public RelNode convert(RelNode rel) {
             join.getJoinType(),
             join.getVariablesStopped());
       } catch (InvalidRelException e) {
-        LOGGER.warning(e.toString());
+        LOGGER.fine(e.toString());
         return null;
       }
     }
@@ -507,7 +507,7 @@ public RelNode convert(RelNode rel) {
             convert(agg.getChild(), traitSet), agg.getGroupSet(),
             agg.getAggCallList());
       } catch (InvalidRelException e) {
-        LOGGER.warning(e.toString());
+        LOGGER.fine(e.toString());
         return null;
       }
     }

File: core/src/main/java/net/hydromatic/optiq/rules/java/JavaRules.java
Patch:
@@ -102,7 +102,7 @@ public RelNode convert(RelNode rel) {
             join.getJoinType(),
             join.getVariablesStopped());
       } catch (InvalidRelException e) {
-        LOGGER.warning(e.toString());
+        LOGGER.fine(e.toString());
         return null;
       }
     }
@@ -812,7 +812,7 @@ public RelNode convert(RelNode rel) {
             agg.getGroupSet(),
             agg.getAggCallList());
       } catch (InvalidRelException e) {
-        LOGGER.warning(e.toString());
+        LOGGER.fine(e.toString());
         return null;
       }
     }

File: core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -46,6 +46,7 @@
 import org.eigenbase.sql.type.SqlTypeName;
 import org.eigenbase.util.Bug;
 import org.eigenbase.util.Pair;
+import org.eigenbase.util.Util;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -2932,7 +2933,7 @@ public Object apply(Object a0) {
           .returns("C=0\n");
       switch (OptiqAssert.CONNECTION_SPEC) {
       case HSQLDB:
-        assertThat(sqls[0], equalTo(
+        assertThat(Util.toLinux(sqls[0]), equalTo(
             "SELECT COUNT(*) AS \"C\"\n"
             + "FROM (SELECT 0 AS \"DUMMY\"\n"
             + "FROM \"foodmart\".\"employee\"\n"

File: core/src/test/java/net/hydromatic/optiq/tools/PlannerTest.java
Patch:
@@ -85,7 +85,7 @@ private String toString(RelNode rel) {
     Planner planner = getPlanner();
     SqlNode parse =
         planner.parse("select * from \"emps\" where \"Xname\" like '%e%'");
-    assertThat(parse.toString(), equalTo(
+    assertThat(Util.toLinux(parse.toString()), equalTo(
         "SELECT *\n"
         + "FROM `emps`\n"
         + "WHERE `Xname` LIKE '%e%'"));

File: core/src/test/java/net/hydromatic/optiq/tools/FrameworksTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.eigenbase.rex.RexNode;
 import org.eigenbase.sql.SqlExplainLevel;
 import org.eigenbase.sql.fun.SqlStdOperatorTable;
+import org.eigenbase.util.Util;
 
 import org.junit.Test;
 
@@ -100,7 +101,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
         });
     String s =
         RelOptUtil.dumpPlan("", x, false, SqlExplainLevel.DIGEST_ATTRIBUTES);
-    assertThat(s, equalTo(
+    assertThat(Util.toLinux(s), equalTo(
         "EnumerableFilterRel(condition=[>($1, 1)])\n"
         + "  EnumerableTableAccessRel(table=[[myTable]])\n"));
   }

File: core/src/test/java/org/eigenbase/relopt/RelWriterTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.eigenbase.sql.SqlExplainLevel;
 import org.eigenbase.sql.fun.SqlStdOperatorTable;
 import org.eigenbase.sql.type.SqlTypeName;
+import org.eigenbase.util.Util;
 
 import net.hydromatic.optiq.SchemaPlus;
 import net.hydromatic.optiq.impl.java.ReflectiveSchema;
@@ -176,7 +177,7 @@ public String apply(RelOptCluster cluster,
               }
             });
 
-    assertThat(s, is(
+    assertThat(Util.toLinux(s), is(
         "AggregateRel(group=[{0}], agg#0=[COUNT(DISTINCT $1)], agg#1=[COUNT()])\n"
         + "  FilterRel(condition=[=($1, 10)])\n"
         + "    TableAccessRel(table=[[hr, emps]])\n"));

File: core/src/test/java/org/eigenbase/sql/test/SqlAdvisorTest.java
Patch:
@@ -323,7 +323,7 @@ private void assertTokenizesTo(String sql, String expected) {
       if (token == null) {
         break;
       }
-      buf.append(token).append(TestUtil.NL);
+      buf.append(token).append("\n");
     }
     Assert.assertEquals(expected, buf.toString());
   }
@@ -456,7 +456,7 @@ private String convertCompletionHints(List<SqlMoniker> hints) {
   private static <T> String toString(List<T> list) {
     StringBuilder buf = new StringBuilder();
     for (T t : list) {
-      buf.append(t).append(TestUtil.NL);
+      buf.append(t).append("\n");
     }
     return buf.toString();
   }

File: core/src/test/java/org/eigenbase/test/SqlValidatorTestCase.java
Patch:
@@ -339,6 +339,9 @@ public static void checkEx(
                 + sqlWithCarets);
           }
         }
+        if (actualMessage != null) {
+          actualMessage = Util.toLinux(actualMessage);
+        }
         if ((actualMessage == null)
             || !actualMessage.matches(expectedMsgPattern)) {
           actualException.printStackTrace();

File: core/src/test/java/org/eigenbase/util/OptionsListTest.java
Patch:
@@ -355,9 +355,8 @@ private void checkIt(
       optionsList.add(option);
     }
     optionsList.parse(args);
-    assertEquals(
-        expected,
-        handler.toString());
+    assertEquals(expected,
+        Util.toLinux(handler.toString()));
   }
 
   //~ Inner Classes ----------------------------------------------------------

File: core/src/main/java/org/eigenbase/util/Util.java
Patch:
@@ -95,7 +95,7 @@ private Util() {}
    * classes are not prevented from being unloaded.
    */
   private static final LoadingCache<Class, Map<String, Enum>> ENUM_CONSTANTS =
-      CacheBuilder.<Class, Map<String, Enum>>newBuilder()
+      CacheBuilder.newBuilder()
           .weakKeys()
           .build(
               new CacheLoader<Class, Map<String, Enum>>() {

File: core/src/main/java/net/hydromatic/optiq/prepare/LixToRelTranslator.java
Patch:
@@ -136,7 +136,7 @@ private List<RexNode> toRex(
     RexBuilder rexBuilder = cluster.getRexBuilder();
     List<RexNode> list =
         Collections.singletonList(
-            rexBuilder.makeRangeReference(child.getRowType()));
+            rexBuilder.makeRangeReference(child));
     OptiqPrepareImpl.ScalarTranslator translator =
         OptiqPrepareImpl.EmptyScalarTranslator
             .empty(rexBuilder)
@@ -165,7 +165,7 @@ List<RexNode> toRexList(
     List<RexNode> list = new ArrayList<RexNode>();
     RexBuilder rexBuilder = cluster.getRexBuilder();
     for (RelNode input : inputs) {
-      list.add(rexBuilder.makeRangeReference(input.getRowType()));
+      list.add(rexBuilder.makeRangeReference(input));
     }
     return OptiqPrepareImpl.EmptyScalarTranslator.empty(rexBuilder)
         .bind(expression.parameterList, list)
@@ -178,7 +178,7 @@ RexNode toRex(
     List<RexNode> list = new ArrayList<RexNode>();
     RexBuilder rexBuilder = cluster.getRexBuilder();
     for (RelNode input : inputs) {
-      list.add(rexBuilder.makeRangeReference(input.getRowType()));
+      list.add(rexBuilder.makeRangeReference(input));
     }
     return OptiqPrepareImpl.EmptyScalarTranslator.empty(rexBuilder)
         .bind(expression.parameterList, list)

File: core/src/main/java/org/eigenbase/rel/RelFactories.java
Patch:
@@ -85,8 +85,7 @@ public int size() {
 
       public RexNode get(int index) {
         final int pos = posList.get(index);
-        return child.getCluster().getRexBuilder().makeInputRef(
-            child.getRowType().getFieldList().get(pos).getType(), pos);
+        return child.getCluster().getRexBuilder().makeInputRef(child, pos);
       }
     }, null);
   }

File: core/src/main/java/org/eigenbase/rel/SortRel.java
Patch:
@@ -91,9 +91,7 @@ public SortRel(
     ImmutableList.Builder<RexNode> builder = ImmutableList.builder();
     for (RelFieldCollation field : collation.getFieldCollations()) {
       int index = field.getFieldIndex();
-      builder.add(
-          cluster.getRexBuilder().makeInputRef(
-              getRowType().getFieldList().get(index).getType(), index));
+      builder.add(cluster.getRexBuilder().makeInputRef(child, index));
     }
     fieldExps = builder.build();
   }

File: core/src/main/java/org/eigenbase/rel/TableAccessRelBase.java
Patch:
@@ -125,9 +125,7 @@ public RelNode project(
     // Project the subset of fields.
     for (int i : BitSets.toIter(fieldsUsed)) {
       RelDataTypeField field = fields.get(i);
-      exprList.add(
-          rexBuilder.makeInputRef(
-              field.getType(), i));
+      exprList.add(rexBuilder.makeInputRef(this, i));
       nameList.add(field.getName());
     }
 

File: core/src/test/java/net/hydromatic/optiq/tools/FrameworksTest.java
Patch:
@@ -80,8 +80,7 @@ public RelDataType getRowType(RelDataTypeFactory typeFactory) {
             final RexNode condition =
                 rexBuilder.makeCall(SqlStdOperatorTable.GREATER_THAN,
                     rexBuilder.makeFieldAccess(
-                        rexBuilder.makeRangeReference(
-                            table.getRowType(typeFactory)), "i", true),
+                        rexBuilder.makeRangeReference(tableRel), "i", true),
                     rexBuilder.makeExactLiteral(BigDecimal.ONE));
             final FilterRel filterRel =
                 new FilterRel(cluster, tableRel, condition);

File: core/src/test/java/org/eigenbase/relopt/RelWriterTest.java
Patch:
@@ -126,8 +126,7 @@ public String apply(RelOptCluster cluster,
                         rexBuilder.makeCall(
                             SqlStdOperatorTable.EQUALS,
                             rexBuilder.makeFieldAccess(
-                                rexBuilder.makeRangeReference(
-                                    table.getRowType()),
+                                rexBuilder.makeRangeReference(table),
                                 "deptno", true),
                             rexBuilder.makeExactLiteral(BigDecimal.TEN)));
                 final RelJsonWriter writer = new RelJsonWriter();

File: core/src/main/java/net/hydromatic/optiq/Schemas.java
Patch:
@@ -307,7 +307,8 @@ public DataContext getDataContext() {
       }
 
       public OptiqPrepare.SparkHandler spark() {
-        return OptiqPrepare.Dummy.getSparkHandler();
+        final boolean enable = config().spark();
+        return OptiqPrepare.Dummy.getSparkHandler(enable);
       }
     };
   }

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -392,7 +392,8 @@ public DataContext getDataContext() {
     }
 
     public OptiqPrepare.SparkHandler spark() {
-      return OptiqPrepare.Dummy.getSparkHandler();
+      final boolean enable = config().spark();
+      return OptiqPrepare.Dummy.getSparkHandler(enable);
     }
   }
 

File: core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -1806,6 +1806,7 @@ private static ImmutableMultimap<Class, Integer> x() {
         .query("select distinct \"empid\" > 140 as c, \"deptno\"\n"
             + "from \"hr\".\"emps\"\n")
         .returnsUnordered(
+            "C=false; deptno=10",
             "C=false; deptno=10",
             "C=true; deptno=10",
             "C=true; deptno=20")

File: core/src/main/java/org/eigenbase/sql/fun/SqlStdOperatorTable.java
Patch:
@@ -920,8 +920,7 @@ public boolean argumentMustBeScalar(int ordinal) {
   public static final SqlSpecialOperator EXPLAIN =
       new SqlSpecialOperator("EXPLAIN", SqlKind.EXPLAIN);
 
-  public static final SqlOrderByOperator ORDER_BY =
-      new SqlOrderByOperator();
+  public static final SqlSpecialOperator ORDER_BY = SqlOrderBy.OPERATOR;
 
   public static final SqlOperator PROCEDURE_CALL =
       new SqlProcedureCallOperator();

File: core/src/main/java/net/hydromatic/optiq/model/ModelHandler.java
Patch:
@@ -53,6 +53,7 @@ public ModelHandler(OptiqConnection connection, String uri)
     final ObjectMapper mapper = new ObjectMapper();
     mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
     mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
+    mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
     JsonRoot root;
     if (uri.startsWith("inline:")) {
       root = mapper.readValue(

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcRules.java
Patch:
@@ -257,14 +257,13 @@ public JdbcImplementor.Result implement(JdbcImplementor implementor) {
         }
       }
       SqlNode join =
-          SqlStdOperatorTable.JOIN.createCall(
+          new SqlJoin(POS,
               leftResult.asFrom(),
               SqlLiteral.createBoolean(false, POS),
               joinType(joinType).symbol(POS),
               rightResult.asFrom(),
               SqlJoinOperator.ConditionType.ON.symbol(POS),
-              sqlCondition,
-              POS);
+              sqlCondition);
       return implementor.result(join, leftResult, rightResult);
     }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlCoalesceFunction.java
Patch:
@@ -75,8 +75,8 @@ public SqlNode rewriteCall(SqlValidator validator, SqlCall call) {
     }
     SqlNode elseExpr = Util.last(operands);
     assert call.getFunctionQuantifier() == null;
-    return SqlStdOperatorTable.CASE.createSwitchedCall(pos, null, whenList,
-        thenList, elseExpr);
+    return SqlCase.createSwitched(
+        pos, null, whenList, thenList, elseExpr);
   }
 }
 

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcRules.java
Patch:
@@ -917,9 +917,9 @@ implementor.new AliasContext(
                   new SqlIdentifier(literal.right, POS)));
         }
         selects.add(
-            SqlStdOperatorTable.SELECT.createCall(SqlNodeList.EMPTY,
+            new SqlSelect(POS, SqlNodeList.EMPTY,
                 new SqlNodeList(selectList, POS), null, null, null,
-                null, null, null, null, null, POS));
+                null, null, null, null, null));
       }
       SqlNode query = null;
       for (SqlSelect select : selects) {

File: core/src/main/java/net/hydromatic/optiq/rules/java/JavaRules.java
Patch:
@@ -34,7 +34,7 @@
 import org.eigenbase.relopt.*;
 import org.eigenbase.reltype.*;
 import org.eigenbase.rex.*;
-import org.eigenbase.sql.SqlWindowOperator;
+import org.eigenbase.sql.SqlWindow;
 import org.eigenbase.sql.fun.SqlStdOperatorTable;
 import org.eigenbase.trace.EigenbaseTrace;
 import org.eigenbase.util.*;
@@ -2315,8 +2315,8 @@ private void generateWindowLoop(BlockBuilder builder, Window window,
       final Expression max_ =
           Expressions.subtract(Expressions.field(rows_, "length"),
               Expressions.constant(1));
-      final SqlWindowOperator.OffsetRange offsetAndRange =
-          SqlWindowOperator.getOffsetAndRange(
+      final SqlWindow.OffsetRange offsetAndRange =
+          SqlWindow.getOffsetAndRange(
               window.lowerBound, window.upperBound, window.isRows);
       final Expression start_ =
           builder.append("start",

File: core/src/main/java/org/eigenbase/sql/SqlDelete.java
Patch:
@@ -24,7 +24,7 @@
  * A <code>SqlDelete</code> is a node of a parse tree which represents a DELETE
  * statement.
  */
-public class SqlDelete extends SqlCall {
+public class SqlDelete extends SqlBasicCall {
   //~ Static fields/initializers ---------------------------------------------
 
   // constants representing operand positions

File: core/src/main/java/org/eigenbase/sql/SqlExplain.java
Patch:
@@ -23,7 +23,7 @@
  * A <code>SqlExplain</code> is a node of a parse tree which represents an
  * EXPLAIN PLAN statement.
  */
-public class SqlExplain extends SqlCall {
+public class SqlExplain extends SqlBasicCall {
   //~ Static fields/initializers ---------------------------------------------
 
   // constants representing operand positions

File: core/src/main/java/org/eigenbase/sql/SqlFunctionalOperator.java
Patch:
@@ -48,10 +48,10 @@ public SqlFunctionalOperator(
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
-    SqlUtil.unparseFunctionSyntax(this, writer, operands, true, null);
+    SqlUtil.unparseFunctionSyntax(this, writer, call, true, null);
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/SqlInternalOperator.java
Patch:
@@ -64,7 +64,7 @@ public SqlSyntax getSyntax() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     throw new UnsupportedOperationException(

File: core/src/main/java/org/eigenbase/sql/SqlJdbcFunctionCall.java
Patch:
@@ -449,7 +449,7 @@ public RelDataType deriveType(
     // REVIEW: jhyde, 2006/4/18: Should SqlJdbcFunctionCall even be a
     // subclass of SqlFunction?
 
-    for (SqlNode operand : call.operands) {
+    for (SqlNode operand : call.getOperandList()) {
       RelDataType nodeType = validator.deriveType(scope, operand);
       validator.setValidatedNodeType(operand, nodeType);
     }
@@ -505,13 +505,13 @@ private String getArgCountMismatchMsg() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     writer.print("{fn ");
     writer.print(jdbcName);
     final SqlWriter.Frame frame = writer.startList("(", ")");
-    for (SqlNode operand : operands) {
+    for (SqlNode operand : call.getOperandList()) {
       writer.sep(",");
       operand.unparse(writer, leftPrec, rightPrec);
     }

File: core/src/main/java/org/eigenbase/sql/SqlJoin.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * Parse tree node representing a {@code JOIN} clause.
  */
-public class SqlJoin extends SqlCall {
+public class SqlJoin extends SqlBasicCall {
   //~ Static fields/initializers ---------------------------------------------
 
   public static final int LEFT_OPERAND = 0;

File: core/src/main/java/org/eigenbase/sql/SqlMerge.java
Patch:
@@ -26,7 +26,7 @@
  * A <code>SqlMerge</code> is a node of a parse tree which represents a MERGE
  * statement.
  */
-public class SqlMerge extends SqlCall {
+public class SqlMerge extends SqlBasicCall {
   //~ Static fields/initializers ---------------------------------------------
 
   // constants representing operand positions

File: core/src/main/java/org/eigenbase/sql/SqlPostfixOperator.java
Patch:
@@ -64,7 +64,7 @@ protected RelDataType adjustType(
       // Determine coercibility and resulting collation name of
       // unary operator if needed.
       RelDataType operandType =
-          validator.getValidatedNodeType(call.operands[0]);
+          validator.getValidatedNodeType(call.operand(0));
       if (null == operandType) {
         throw Util.newInternal(
             "operand's type should have been derived");

File: core/src/main/java/org/eigenbase/sql/SqlPrefixOperator.java
Patch:
@@ -64,7 +64,7 @@ protected RelDataType adjustType(
       // Determine coercibility and resulting collation name of
       // unary operator if needed.
       RelDataType operandType =
-          validator.getValidatedNodeType(call.operands[0]);
+          validator.getValidatedNodeType(call.operand(0));
       if (null == operandType) {
         throw Util.newInternal(
             "operand's type should have been derived");
@@ -90,7 +90,7 @@ public SqlMonotonicity getMonotonicity(
       SqlCall call,
       SqlValidatorScope scope) {
     if (getName().equals("-")) {
-      return scope.getMonotonicity(call.getOperands()[0]).reverse();
+      return scope.getMonotonicity(call.operand(0)).reverse();
     }
 
     return super.getMonotonicity(call, scope);

File: core/src/main/java/org/eigenbase/sql/SqlSpecialOperator.java
Patch:
@@ -67,7 +67,7 @@ public SqlSyntax getSyntax() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     throw new UnsupportedOperationException(

File: core/src/main/java/org/eigenbase/sql/SqlUpdate.java
Patch:
@@ -26,7 +26,7 @@
  * A <code>SqlUpdate</code> is a node of a parse tree which represents an UPDATE
  * statement.
  */
-public class SqlUpdate extends SqlCall {
+public class SqlUpdate extends SqlBasicCall {
   //~ Static fields/initializers ---------------------------------------------
 
   // constants representing operand positions

File: core/src/main/java/org/eigenbase/sql/SqlValuesOperator.java
Patch:
@@ -31,13 +31,12 @@ public SqlValuesOperator() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     final SqlWriter.Frame frame = writer.startList("VALUES", "");
-    for (int i = 0; i < operands.length; i++) {
+    for (SqlNode operand : call.getOperandList()) {
       writer.sep(",");
-      SqlNode operand = operands[i];
       operand.unparse(writer, 0, 0);
     }
     writer.endList(frame);

File: core/src/main/java/org/eigenbase/sql/advise/SqlAdvisorValidator.java
Patch:
@@ -161,9 +161,9 @@ protected void validateHavingClause(SqlSelect select) {
   protected void validateOver(SqlCall call, SqlValidatorScope scope) {
     try {
       final OverScope overScope = (OverScope) getOverScope(call);
-      final SqlNode relation = call.operands[0];
+      final SqlNode relation = call.operand(0);
       validateFrom(relation, unknownType, scope);
-      final SqlNode window = call.operands[1];
+      final SqlNode window = call.operand(1);
       SqlValidatorScope opScope = scopes.get(relation);
       if (opScope == null) {
         opScope = overScope;

File: core/src/main/java/org/eigenbase/sql/fun/SqlCase.java
Patch:
@@ -25,7 +25,7 @@
  * statement. It warrants its own node type just because we have a lot of
  * methods to put somewhere.
  */
-public class SqlCase extends SqlCall {
+public class SqlCase extends SqlBasicCall {
   //~ Static fields/initializers ---------------------------------------------
 
   /**
@@ -65,8 +65,7 @@ public class SqlCase extends SqlCall {
    * <p>See {@link #VALUE_OPERAND}, {@link #WHEN_OPERANDS},
    * {@link #THEN_OPERANDS}, {@link #ELSE_OPERAND}.
    */
-  SqlCase(
-      SqlCaseOperator operator,
+  SqlCase(SqlCaseOperator operator,
       SqlNode[] operands,
       SqlParserPos pos) {
     super(operator, operands, pos);

File: core/src/main/java/org/eigenbase/sql/fun/SqlColumnListConstructor.java
Patch:
@@ -41,14 +41,14 @@ public SqlColumnListConstructor() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     writer.keyword("ROW");
     final SqlWriter.Frame frame = writer.startList("(", ")");
-    for (int i = 0; i < operands.length; i++) {
+    for (SqlNode operand : call.getOperandList()) {
       writer.sep(",");
-      operands[0].unparse(writer, leftPrec, rightPrec);
+      operand.unparse(writer, leftPrec, rightPrec);
     }
     writer.endList(frame);
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlConvertFunction.java
Patch:
@@ -40,13 +40,13 @@ protected SqlConvertFunction(String name) {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     final SqlWriter.Frame frame = writer.startFunCall(getName());
-    operands[0].unparse(writer, leftPrec, rightPrec);
+    call.operand(0).unparse(writer, leftPrec, rightPrec);
     writer.sep("USING");
-    operands[1].unparse(writer, leftPrec, rightPrec);
+    call.operand(1).unparse(writer, leftPrec, rightPrec);
     writer.endFunCall(frame);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlExtractFunction.java
Patch:
@@ -51,13 +51,13 @@ public String getSignatureTemplate(int operandsCount) {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     final SqlWriter.Frame frame = writer.startFunCall(getName());
-    operands[0].unparse(writer, leftPrec, rightPrec);
+    call.operand(0).unparse(writer, leftPrec, rightPrec);
     writer.sep("FROM");
-    operands[1].unparse(writer, leftPrec, rightPrec);
+    call.operand(1).unparse(writer, leftPrec, rightPrec);
     writer.endFunCall(frame);
   }
 }

File: core/src/main/java/org/eigenbase/sql/fun/SqlFloorFunction.java
Patch:
@@ -43,8 +43,7 @@ public SqlMonotonicity getMonotonicity(
       SqlCall call,
       SqlValidatorScope scope) {
     // Monotonic iff its first argument is, but not strict.
-    SqlNode node = (SqlNode) call.operands[0];
-    return scope.getMonotonicity(node).unstrict();
+    return scope.getMonotonicity(call.operand(0)).unstrict();
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlMapValueConstructor.java
Patch:
@@ -61,7 +61,7 @@ public boolean checkOperandTypes(
         SqlTypeUtil.deriveAndCollectTypes(
             callBinding.getValidator(),
             callBinding.getScope(),
-            callBinding.getCall().operands);
+            callBinding.getCall().getOperandList());
     if (argTypes.size() == 0) {
       throw callBinding.newValidationError(
           new SqlValidatorException(

File: core/src/main/java/org/eigenbase/sql/fun/SqlMonotonicUnaryFunction.java
Patch:
@@ -49,8 +49,7 @@ protected SqlMonotonicUnaryFunction(
   public SqlMonotonicity getMonotonicity(
       SqlCall call,
       SqlValidatorScope scope) {
-    SqlNode node = (SqlNode) call.operands[0];
-    return scope.getMonotonicity(node).unstrict();
+    return scope.getMonotonicity(call.operand(0)).unstrict();
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlMultisetMemberOfOperator.java
Patch:
@@ -50,7 +50,7 @@ public boolean checkOperandTypes(
       boolean throwOnFailure) {
     if (!OperandTypes.MULTISET.checkSingleOperandType(
         callBinding,
-        callBinding.getCall().operands[1],
+        callBinding.getCall().operand(1),
         0,
         throwOnFailure)) {
       return false;
@@ -59,12 +59,12 @@ public boolean checkOperandTypes(
     MultisetSqlType mt =
         (MultisetSqlType) callBinding.getValidator().deriveType(
             callBinding.getScope(),
-            callBinding.getCall().operands[1]);
+            callBinding.getCall().operand(1));
 
     RelDataType t0 =
         callBinding.getValidator().deriveType(
             callBinding.getScope(),
-            callBinding.getCall().operands[0]);
+            callBinding.getCall().operand(0));
     RelDataType t1 = mt.getComponentType();
 
     if (t0.getFamily() != t1.getFamily()) {

File: core/src/main/java/org/eigenbase/sql/fun/SqlMultisetValueConstructor.java
Patch:
@@ -80,7 +80,7 @@ public boolean checkOperandTypes(
         SqlTypeUtil.deriveAndCollectTypes(
             callBinding.getValidator(),
             callBinding.getScope(),
-            callBinding.getCall().operands);
+            callBinding.getCall().getOperandList());
     if (argTypes.size() == 0) {
       throw callBinding.newValidationError(
           new SqlValidatorException(
@@ -102,12 +102,12 @@ public boolean checkOperandTypes(
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     writer.keyword(getName()); // "MULTISET" or "ARRAY"
     final SqlWriter.Frame frame = writer.startList("[", "]");
-    for (SqlNode operand : operands) {
+    for (SqlNode operand : call.getOperandList()) {
       writer.sep(",");
       operand.unparse(writer, leftPrec, rightPrec);
     }

File: core/src/main/java/org/eigenbase/sql/fun/SqlNewOperator.java
Patch:
@@ -40,7 +40,7 @@ public SqlNewOperator() {
   public SqlNode rewriteCall(SqlValidator validator, SqlCall call) {
     // New specification is purely syntactic, so we rewrite it as a
     // direct call to the constructor method.
-    return call.getOperands()[0];
+    return call.operand(0);
   }
 
   // override SqlOperator

File: core/src/main/java/org/eigenbase/sql/fun/SqlPositionFunction.java
Patch:
@@ -44,13 +44,13 @@ public SqlPositionFunction() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     final SqlWriter.Frame frame = writer.startFunCall(getName());
-    operands[0].unparse(writer, leftPrec, rightPrec);
+    call.operand(0).unparse(writer, leftPrec, rightPrec);
     writer.sep("IN");
-    operands[1].unparse(writer, leftPrec, rightPrec);
+    call.operand(1).unparse(writer, leftPrec, rightPrec);
     writer.endFunCall(frame);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlRowOperator.java
Patch:
@@ -73,10 +73,10 @@ public int size() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
-    SqlUtil.unparseFunctionSyntax(this, writer, operands, true, null);
+    SqlUtil.unparseFunctionSyntax(this, writer, call, true, null);
   }
 
   // override SqlOperator

File: core/src/main/java/org/eigenbase/sql/fun/SqlThrowOperator.java
Patch:
@@ -24,7 +24,7 @@
  * An internal operator that throws an exception.
  *
  * <p>The exception is thrown with a (localized) error message which is the only
- * input paramter to the operator.</p>
+ * input parameter to the operator.</p>
  *
  * <p>The return type is defined as a <code>BOOLEAN</code> to facilitate the use
  * of it in constructs such as the following:</p>
@@ -52,11 +52,11 @@ public SqlThrowOperator() {
 
   public void unparse(
       SqlWriter writer,
-      SqlNode[] operands,
+      SqlCall call,
       int leftPrec,
       int rightPrec) {
     final SqlWriter.Frame frame = writer.startFunCall(getName());
-    operands[0].unparse(writer, 0, 0);
+    call.operand(0).unparse(writer, 0, 0);
     writer.endFunCall(frame);
   }
 }

File: core/src/main/java/org/eigenbase/sql/type/CompositeOperandTypeChecker.java
Patch:
@@ -285,7 +285,7 @@ public boolean checkOperandTypes(
         }
         if (!rule.checkSingleOperandType(
             callBinding,
-            callBinding.getCall().operands[ord.i],
+            callBinding.getCall().operand(ord.i),
             0,
             false)) {
           typeErrorCount++;

File: core/src/main/java/org/eigenbase/sql/type/InferTypes.java
Patch:
@@ -41,11 +41,10 @@ public void inferOperandTypes(
             SqlCallBinding callBinding,
             RelDataType returnType,
             RelDataType[] operandTypes) {
-          SqlNode[] operands = callBinding.getCall().getOperands();
           final RelDataType unknownType =
               callBinding.getValidator().getUnknownType();
           RelDataType knownType = unknownType;
-          for (SqlNode operand : operands) {
+          for (SqlNode operand : callBinding.getCall().getOperandList()) {
             knownType = callBinding.getValidator().deriveType(
                 callBinding.getScope(), operand);
             if (!knownType.equals(unknownType)) {

File: core/src/main/java/org/eigenbase/sql/type/LiteralOperandTypeChecker.java
Patch:
@@ -75,7 +75,7 @@ public boolean checkOperandTypes(
       boolean throwOnFailure) {
     return checkSingleOperandType(
         callBinding,
-        callBinding.getCall().operands[0],
+        callBinding.getCall().operand(0),
         0,
         throwOnFailure);
   }

File: core/src/main/java/org/eigenbase/sql/type/OperandTypes.java
Patch:
@@ -387,7 +387,7 @@ public boolean checkOperandTypes(
             boolean throwOnFailure) {
           return checkSingleOperandType(
               callBinding,
-              callBinding.getCall().operands[0],
+              callBinding.getCall().operand(0),
               0,
               throwOnFailure);
         }
@@ -444,7 +444,7 @@ public boolean checkOperandTypes(
             boolean throwOnFailure) {
           return checkSingleOperandType(
               callBinding,
-              callBinding.getCall().operands[0],
+              callBinding.getCall().operand(0),
               0,
               throwOnFailure);
         }

File: core/src/main/java/org/eigenbase/sql/type/SameOperandTypeChecker.java
Patch:
@@ -75,7 +75,7 @@ private boolean checkOperandTypesImpl(
       if (operatorBinding.isOperandNull(i, false)) {
         if (throwOnFailure) {
           throw callBinding.getValidator().newValidationError(
-              callBinding.getCall().operands[i],
+              callBinding.getCall().operand(i),
               EigenbaseResource.instance().NullIllegal.ex());
         } else {
           return false;

File: core/src/main/java/org/eigenbase/sql/util/SqlShuttle.java
Patch:
@@ -99,7 +99,8 @@ protected class CallCopyingArgHandler implements ArgHandler<SqlNode> {
     public CallCopyingArgHandler(SqlCall call, boolean alwaysCopy) {
       this.call = call;
       this.update = false;
-      this.clonedOperands = call.operands.clone();
+      final List<SqlNode> operands = call.getOperandList();
+      this.clonedOperands = operands.toArray(new SqlNode[operands.size()]);
       this.alwaysCopy = alwaysCopy;
     }
 

File: core/src/main/java/org/eigenbase/sql/validate/SelectScope.java
Patch:
@@ -160,7 +160,7 @@ public SqlMonotonicity getMonotonicity(SqlNode expr) {
           && (((SqlCall) order0).getOperator()
           == SqlStdOperatorTable.DESC)) {
         monotonicity = monotonicity.reverse();
-        order0 = ((SqlCall) order0).getOperands()[0];
+        order0 = ((SqlCall) order0).operand(0);
       }
       if (expr.equalsDeep(order0, false)) {
         return monotonicity;
@@ -199,7 +199,7 @@ public boolean existingWindowName(String winName) {
 
     // if the name wasn't found then check the parent(s)
     SqlValidatorScope walker = parent;
-    while ((null != walker) && !(walker instanceof EmptyScope)) {
+    while (!(walker instanceof EmptyScope)) {
       if (walker instanceof SelectScope) {
         final SelectScope parentScope = (SelectScope) walker;
         return parentScope.existingWindowName(winName);

File: core/src/main/java/org/eigenbase/sql/validate/SetopNamespace.java
Patch:
@@ -59,7 +59,7 @@ public RelDataType validateImpl() {
     case INTERSECT:
     case EXCEPT:
       final SqlValidatorScope scope = validator.scopes.get(call);
-      for (SqlNode operand : call.operands) {
+      for (SqlNode operand : call.getOperandList()) {
         if (!(operand.isA(SqlKind.QUERY))) {
           throw validator.newValidationError(
               operand,

File: core/src/main/java/org/eigenbase/sql/validate/SqlScopedShuttle.java
Patch:
@@ -26,7 +26,7 @@
  * Refinement to {@link SqlShuttle} which maintains a stack of scopes.
  *
  * <p>Derived class should override {@link #visitScoped(SqlCall)} rather than
- * {@link #visit(SqlCall)}.
+ * {@link SqlVisitor#visit(SqlCall)}.
  */
 public abstract class SqlScopedShuttle extends SqlShuttle {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorUtil.java
Patch:
@@ -153,11 +153,11 @@ public static String getAlias(SqlNode node, int ordinal) {
     switch (node.getKind()) {
     case AS:
       // E.g. "1 + 2 as foo" --> "foo"
-      return ((SqlCall) node).getOperands()[1].toString();
+      return ((SqlCall) node).operand(1).toString();
 
     case OVER:
       // E.g. "bids over w" --> "bids"
-      return getAlias(((SqlCall) node).getOperands()[0], ordinal);
+      return getAlias(((SqlCall) node).operand(0), ordinal);
 
     case IDENTIFIER:
       // E.g. "foo.bar" --> "bar"

File: core/src/main/java/org/eigenbase/sql/validate/UnnestNamespace.java
Patch:
@@ -65,7 +65,7 @@ protected RelDataType validateImpl() {
    * Returns the type of the argument to UNNEST.
    */
   private RelDataType inferReturnType() {
-    final SqlNode operand = unnest.getOperands()[0];
+    final SqlNode operand = unnest.operand(0);
     RelDataType type = validator.getValidatedNodeType(operand);
 
     // If sub-query, pick out first column.

File: core/src/test/java/org/eigenbase/sql/test/SqlPrettyWriterTest.java
Patch:
@@ -93,8 +93,8 @@ protected void assertExprPrintsTo(
       final String sql,
       String expected) {
     final SqlCall valuesCall = (SqlCall) parseQuery("VALUES (" + sql + ")");
-    final SqlCall rowCall = (SqlCall) valuesCall.getOperands()[0];
-    final SqlNode node = rowCall.getOperands()[0];
+    final SqlCall rowCall = valuesCall.operand(0);
+    final SqlNode node = rowCall.operand(0);
     final SqlPrettyWriter prettyWriter =
         new SqlPrettyWriter(SqlDialect.DUMMY);
     prettyWriter.setAlwaysUseParentheses(false);

File: core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -1662,7 +1662,7 @@ private static ImmutableMultimap<Class, Integer> x() {
             + "order by 1 fetch first 5 rows only")
         .explainContains(
             "PLAN=EnumerableLimitRel(fetch=[5])\n"
-            + "  EnumerableSortRel(sort0=[$0], dir0=[Ascending])\n"
+            + "  EnumerableSortRel(sort0=[$0], dir0=[ASC])\n"
             + "    EnumerableCalcRel(expr#0..23=[{inputs}], expr#24=[10], expr#25=[<($t0, $t24)], store_id=[$t0], grocery_sqft=[$t16], $condition=[$t25])\n"
             + "      EnumerableTableAccessRel(table=[[foodmart2, store]])\n")
         .returns(
@@ -1834,7 +1834,7 @@ private static ImmutableMultimap<Class, Integer> x() {
             "select * from \"time_by_day\"\n"
             + "order by \"time_id\"")
         .explainContains(
-            "PLAN=EnumerableSortRel(sort0=[$0], dir0=[Ascending])\n"
+            "PLAN=EnumerableSortRel(sort0=[$0], dir0=[ASC])\n"
             + "  EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])\n\n");
   }
 
@@ -1886,7 +1886,7 @@ private static ImmutableMultimap<Class, Integer> x() {
             "[S REAL, FIVE INTEGER NOT NULL, M REAL, C BIGINT, deptno INTEGER NOT NULL, empid INTEGER NOT NULL]")
         .explainContains(
             "EnumerableCalcRel(expr#0..7=[{inputs}], expr#8=[0], expr#9=[>($t4, $t8)], expr#10=[null], expr#11=[CASE($t9, $t5, $t10)], expr#12=[CAST($t11):JavaType(class java.lang.Float)], expr#13=[5], expr#14=[CAST($t6):JavaType(class java.lang.Float)], expr#15=[CAST($t7):BIGINT], S=[$t12], FIVE=[$t13], M=[$t14], C=[$t15], deptno=[$t1], empid=[$t0])\n"
-            + "  EnumerableWindowRel(window#0=[window(partition {1} order by [0 Ascending] rows between 1 PRECEDING and CURRENT ROW aggs [COUNT($3), $SUM0($3), MIN($2), COUNT()])])\n"
+            + "  EnumerableWindowRel(window#0=[window(partition {1} order by [0] rows between 1 PRECEDING and CURRENT ROW aggs [COUNT($3), $SUM0($3), MIN($2), COUNT()])])\n"
             + "    EnumerableCalcRel(expr#0..4=[{inputs}], expr#5=[+($t3, $t0)], proj#0..1=[{exprs}], salary=[$t3], $3=[$t5])\n"
             + "      EnumerableTableAccessRel(table=[[hr, emps]])\n")
         .returns(

File: core/src/main/java/org/eigenbase/sql/SqlIdentifier.java
Patch:
@@ -260,7 +260,7 @@ public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     final SqlIdentifier fqId = scope.fullyQualify(this);
     final SqlValidatorNamespace ns =
         SqlValidatorUtil.lookup(scope, Util.skipLast(fqId.names));
-    return ns.getMonotonicity(Util.last(fqId.names));
+    return ns.resolve().getMonotonicity(Util.last(fqId.names));
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/parser/SqlParserPos.java
Patch:
@@ -178,7 +178,7 @@ public static SqlParserPos sum(
    * Combines the parser positions of a list of nodes to create a position
    * which spans from the beginning of the first to the end of the last.
    */
-  public static SqlParserPos sum(List<SqlNode> nodes) {
+  public static SqlParserPos sum(List<? extends SqlNode> nodes) {
     return sum(nodes.toArray(new SqlNode[nodes.size()]));
   }
 

File: core/src/main/java/org/eigenbase/sql/parser/SqlParserUtil.java
Patch:
@@ -532,7 +532,7 @@ public static <T> void replaceSublist(
    *
    * @pre list.size() % 2 == 1
    */
-  public static SqlNode toTree(List list) {
+  public static SqlNode toTree(List<Object> list) {
     if (LOGGER.isLoggable(Level.FINER)) {
       LOGGER.finer("Attempting to reduce " + list);
     }

File: core/src/main/java/org/eigenbase/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -208,6 +208,7 @@ public boolean isAlwaysUseParentheses() {
   public boolean inQuery() {
     return (frame == null)
         || (frame.frameType == FrameTypeEnum.OrderBy)
+        || (frame.frameType == FrameTypeEnum.With)
         || (frame.frameType == FrameTypeEnum.Setop);
   }
 

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqSchema.java
Patch:
@@ -23,6 +23,7 @@
 import net.hydromatic.optiq.*;
 import net.hydromatic.optiq.Table;
 import net.hydromatic.optiq.impl.MaterializedViewTable;
+import net.hydromatic.optiq.util.Compatible;
 import net.hydromatic.optiq.util.CompositeMap;
 
 import org.eigenbase.util.Util;
@@ -82,7 +83,7 @@ public Table apply(Collection<TableFunctionEntry> input) {
                 return entry.getTableFunction().apply(ImmutableList.of());
               }
             }),
-        Maps.asMap(
+        Compatible.INSTANCE.asMap(
             schema.getTableNames(),
             new Function<String, Table>() {
               public Table apply(String input) {
@@ -100,7 +101,7 @@ public TableFunction apply(TableFunctionEntry input) {
     this.compositeSubSchemaMap =
         CompositeMap.of(
             subSchemaMap,
-            Maps.<String, OptiqSchema>asMap(
+            Compatible.INSTANCE.<String, OptiqSchema>asMap(
                 schema.getSubSchemaNames(),
                 new Function<String, OptiqSchema>() {
                   public OptiqSchema apply(String input) {

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvTable.java
Patch:
@@ -85,9 +85,9 @@ public Enumerator<T> enumerator() {
   }
 
   /** Returns an enumerable over a given projection of the fields. */
-  public Enumerable<Object[]> project(final int[] fields) {
-    return new AbstractEnumerable<Object[]>() {
-      public Enumerator<Object[]> enumerator() {
+  public Enumerable<Object> project(final int[] fields) {
+    return new AbstractEnumerable<Object>() {
+      public Enumerator<Object> enumerator() {
         return new CsvEnumerator(file,
             fieldTypes.toArray(new CsvFieldType[fieldTypes.size()]), fields);
       }

File: core/src/main/java/org/eigenbase/rel/metadata/RelMdDistinctRowCount.java
Patch:
@@ -115,7 +115,8 @@ public Double getDistinctRowCount(
         rel,
         rel.getJoinType(),
         groupKey,
-        predicate);
+        predicate,
+        false);
   }
 
   public Double getDistinctRowCount(

File: core/src/main/java/org/eigenbase/rel/rules/MergeProjectRule.java
Patch:
@@ -25,7 +25,7 @@
 import org.eigenbase.rex.*;
 
 /**
- * MergeProjectRule merges a {@link ProjectRel} into another {@link ProjectRel},
+ * MergeProjectRule merges a {@link ProjectRelBase} into another {@link ProjectRelBase},
  * provided the projects aren't projecting identical sets of input references.
  */
 public class MergeProjectRule extends RelOptRule {

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -309,6 +309,9 @@ <T> PrepareResult<T> prepare2_(
       } catch (SqlParseException e) {
         throw new RuntimeException("parse failed", e);
       }
+
+      Hook.PARSE_TREE.run(new Object[] {sql, sqlNode});
+
       final OptiqSchema rootSchema = context.getRootSchema();
       final ChainedSqlOperatorTable opTab =
           new ChainedSqlOperatorTable(

File: core/src/main/java/net/hydromatic/optiq/runtime/Hook.java
Patch:
@@ -30,6 +30,9 @@
  * <p>For testing and debugging rather than for end-users.</p>
  */
 public enum Hook {
+  /** Called with the SQL string and parse tree, in an array. */
+  PARSE_TREE,
+
   /** Called with the generated Java plan, just before it is compiled by
    * Janino. */
   JAVA_PLAN,

File: core/src/main/java/org/eigenbase/sql/SqlDataTypeSpec.java
Patch:
@@ -99,7 +99,7 @@ public SqlDataTypeSpec(
   //~ Methods ----------------------------------------------------------------
 
   public SqlNode clone(SqlParserPos pos) {
-    return (collectionsTypeName == null)
+    return (collectionsTypeName != null)
         ? new SqlDataTypeSpec(collectionsTypeName, typeName, precision, scale,
             charSetName, pos)
         : new SqlDataTypeSpec(typeName, precision, scale, charSetName, timeZone,

File: core/src/main/java/net/hydromatic/optiq/Schema.java
Patch:
@@ -117,6 +117,7 @@ public interface Schema {
    * stores the defined objects in a wrapper object. */
   boolean isMutable();
 
+  /** Table type. */
   enum TableType {
     /** A regular table. */
     TABLE,

File: core/src/main/java/net/hydromatic/optiq/TableFactory.java
Patch:
@@ -72,6 +72,8 @@
  *
  * <p>A class that implements TableFactory specified in a schema must have a
  * public default constructor.</p>
+ *
+ * @param <T> Sub-type of table created by this factory
  */
 public interface TableFactory<T extends Table> {
   /** Creates a Table.

File: core/src/main/java/net/hydromatic/optiq/impl/AbstractTableQueryable.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Abstract implementation of {@link net.hydromatic.linq4j.Queryable} for
- * {@link Table}.
+ * {@link QueryableTable}.
  *
  * <p>Not to be confused with
  * {@link net.hydromatic.optiq.impl.java.AbstractQueryableTable}.</p>

File: core/src/main/java/net/hydromatic/optiq/impl/clone/ColumnLoader.java
Patch:
@@ -40,6 +40,8 @@
 
 /**
  * Column loader.
+ *
+ * @param <T> Element type of source table
  */
 class ColumnLoader<T> {
   static final int[] INT_B = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqJdbc41Factory.java
Patch:
@@ -96,6 +96,7 @@ public ResultSetMetaData newResultSetMetaData(
         statement, null, columnMetaDataList);
   }
 
+  /** Implementation of connection for JDBC 4.1. */
   private static class OptiqJdbc41Connection extends OptiqConnectionImpl {
     OptiqJdbc41Connection(Driver driver, AvaticaFactory factory, String url,
         Properties info, OptiqRootSchema rootSchema,

File: core/src/main/java/net/hydromatic/optiq/materialize/MaterializationActor.java
Patch:
@@ -34,6 +34,8 @@ class MaterializationActor {
   final Map<MaterializationKey, Materialization> keyMap =
       new HashMap<MaterializationKey, Materialization>();
 
+  /** A query materialized in a table, so that reading from the table gives the
+   * same results as executing the query. */
   static class Materialization {
     final MaterializationKey key;
     final OptiqRootSchema rootSchema;

File: core/src/main/java/net/hydromatic/optiq/prepare/PlannerImpl.java
Patch:
@@ -200,6 +200,7 @@ public RelNode transform(int ruleSetIndex, RelTraitSet requiredOutputTraits,
     return planner.findBestExp();
   }
 
+  /** Stage of a statement in the query-preparation lifecycle. */
   private enum State {
     STATE_0_CLOSED {
       @Override

File: core/src/main/java/net/hydromatic/optiq/prepare/Prepare.java
Patch:
@@ -347,6 +347,7 @@ private boolean shouldTrim(RelNode rootRel) {
 
   /** Returns the number of {@link JoinRelBase} nodes in a tree. */
   private static int countJoins(RelNode rootRel) {
+    /** Visitor that counts join nodes. */
     class JoinCounter extends RelVisitor {
       int joinCount;
 
@@ -386,6 +387,7 @@ public RelNode expandView(
 
   protected abstract SqlValidator getSqlValidator();
 
+  /** Interface by which validator and planner can read table metadata. */
   public interface CatalogReader
       extends RelOptSchema, SqlValidatorCatalogReader {
     PreparingTable getTableForMember(List<String> names);
@@ -397,6 +399,7 @@ public interface CatalogReader
     PreparingTable getTable(List<String> names);
   }
 
+  /** Definition of a table, for the purposes of the validator and planner. */
   public interface PreparingTable
       extends RelOptTable, SqlValidatorTable {
   }

File: core/src/main/java/net/hydromatic/optiq/prepare/QueryableRelBuilder.java
Patch:
@@ -52,6 +52,8 @@
  *
  * <p>NOTE: Many methods currently throw {@link UnsupportedOperationException}.
  * These method need to be implemented.</p>
+ *
+ * @param <T> Element type
  */
 class QueryableRelBuilder<T> implements QueryableFactory<T> {
   private final LixToRelTranslator translator;

File: core/src/main/java/net/hydromatic/optiq/rules/java/EnumerableRel.java
Patch:
@@ -82,6 +82,8 @@ public Prefer of(JavaRowFormat format) {
     }
   }
 
+  /** Result of implementing an enumerable relational expression by generating
+   * Java code. */
   class Result {
     public final BlockStatement block;
 

File: core/src/main/java/net/hydromatic/optiq/rules/java/EnumerableRelImplementor.java
Patch:
@@ -352,6 +352,7 @@ public EnumerableRel.Result result(PhysType physType, BlockStatement block) {
         block, physType, ((PhysTypeImpl) physType).format);
   }
 
+  /** Visitor that finds types in an {@link Expression} tree. */
   private static class TypeFinder extends Visitor {
     private final LinkedHashSet<Type> types;
 

File: core/src/main/java/net/hydromatic/optiq/runtime/AbstractCursor.java
Patch:
@@ -204,6 +204,7 @@ static Timestamp longToTimestamp(long v, Calendar calendar) {
     return new Timestamp(v);
   }
 
+  /** Implementation of {@link Accessor}. */
   static class AccessorImpl implements Accessor {
     protected final Getter getter;
 

File: core/src/main/java/net/hydromatic/optiq/runtime/ArrayComparator.java
Patch:
@@ -17,6 +17,8 @@
 */
 package net.hydromatic.optiq.runtime;
 
+import com.google.common.collect.Ordering;
+
 import java.util.Collections;
 import java.util.Comparator;
 
@@ -41,7 +43,7 @@ private static Comparator[] comparators(boolean[] descendings) {
       comparators[i] =
           descending
               ? Collections.reverseOrder()
-              : ComparableComparator.instance();
+              : Ordering.natural();
     }
     return comparators;
   }

File: core/src/main/java/net/hydromatic/optiq/runtime/ArrayEnumeratorCursor.java
Patch:
@@ -48,6 +48,8 @@ public void close() {
     enumerator.close();
   }
 
+  /** Implementation of {@link Getter} that reads from records that are
+   * arrays. */
   class ArrayEnumeratorGetter extends AbstractGetter {
     protected final int field;
 

File: core/src/main/java/net/hydromatic/optiq/runtime/Bindable.java
Patch:
@@ -23,6 +23,8 @@
 
 /**
  * Statement that can be bound to a {@link DataContext} and then executed.
+ *
+ * @param <T> Element type of the resulting enumerable
  */
 public interface Bindable<T> {
   /**

File: core/src/main/java/net/hydromatic/optiq/runtime/ObjectEnumeratorCursor.java
Patch:
@@ -48,6 +48,9 @@ public void close() {
     enumerator.close();
   }
 
+  /** Implementation of {@link Getter} for records that consist of a single
+   * field. Each record is represented as an object, and the value of the sole
+   * field is that object. */
   class ObjectEnumeratorGetter extends AbstractGetter {
     public ObjectEnumeratorGetter(int field) {
       assert field == 0;

File: core/src/main/java/net/hydromatic/optiq/runtime/RecordEnumeratorCursor.java
Patch:
@@ -26,6 +26,8 @@
  * {@link net.hydromatic.linq4j.Enumerator} that
  * returns a record for each row. The record is a synthetic class whose fields
  * are all public.
+ *
+ * @param <E> Element type
  */
 public class RecordEnumeratorCursor<E> extends AbstractCursor {
   private final Enumerator<E> enumerator;
@@ -56,6 +58,7 @@ public void close() {
     enumerator.close();
   }
 
+  /** Implementation of {@link Getter} that reads fields via reflection. */
   class RecordEnumeratorGetter extends AbstractGetter {
     protected final Field field;
 

File: core/src/main/java/net/hydromatic/optiq/runtime/SortedMultiMap.java
Patch:
@@ -22,6 +22,9 @@
 /**
  * Map that allows you to partition values into lists according to a common
  * key, and then convert those lists into an iterator of sorted arrays.
+ *
+ * @param <K> Key type
+ * @param <V> Value type
  */
 public class SortedMultiMap<K, V> extends HashMap<K, List<V>> {
   public void putMulti(K key, V value) {

File: core/src/main/java/net/hydromatic/optiq/runtime/SqlFunctions.java
Patch:
@@ -1454,6 +1454,9 @@ public static boolean isNotFalse(Boolean b) {
     return b == null || b;
   }
 
+  /** A range of time units. The first is more significant than the
+   * other (e.g. year-to-day) or the same as the other
+   * (e.g. month). */
   public enum TimeUnitRange {
     YEAR,
     YEAR_TO_MONTH,

File: core/src/main/java/net/hydromatic/optiq/util/graph/BreadthFirstIterator.java
Patch:
@@ -26,6 +26,9 @@
 
 /**
  * Iterates over the vertices in a directed graph in breadth-first order.
+ *
+ * @param <V> Vertex type
+ * @param <E> Edge type
  */
 public class BreadthFirstIterator<V, E extends DefaultEdge>
     implements Iterator<V> {

File: core/src/main/java/net/hydromatic/optiq/util/graph/CycleDetector.java
Patch:
@@ -21,6 +21,9 @@
 
 /**
  * Detects cycles in directed graphs.
+ *
+ * @param <V> Vertex type
+ * @param <E> Edge type
  */
 public class CycleDetector<V, E extends DefaultEdge> {
   private final DirectedGraph<V, E> graph;

File: core/src/main/java/net/hydromatic/optiq/util/graph/DepthFirstIterator.java
Patch:
@@ -21,6 +21,9 @@
 
 /**
  * Iterates over the vertices in a directed graph in depth-first order.
+ *
+ * @param <V> Vertex type
+ * @param <E> Edge type
  */
 public class DepthFirstIterator<V, E extends DefaultEdge>
     implements Iterator<V> {

File: core/src/main/java/net/hydromatic/optiq/util/graph/TopologicalOrderIterator.java
Patch:
@@ -21,6 +21,9 @@
 
 /**
  * Iterates over the edges of a graph in topological order.
+ *
+ * @param <V> Vertex type
+ * @param <E> Edge type
  */
 public class TopologicalOrderIterator<V, E extends DefaultEdge>
     implements Iterator<V> {

File: core/src/main/java/org/eigenbase/javac/JaninoCompiler.java
Patch:
@@ -101,6 +101,9 @@ public int getTotalByteCodeSize() {
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /**
+   * Arguments to an invocation of the Janino compiler.
+   */
   private static class JaninoCompilerArgs extends JavaCompilerArgs {
     String destdir;
     String fullClassName;

File: core/src/main/java/org/eigenbase/rel/ProjectRelBase.java
Patch:
@@ -226,6 +226,7 @@ public RelWriter explainTerms(RelWriter pw) {
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /** A collection of integer constants that describe the kind of project. */
   public static class Flags {
     public static final int ANON_FIELDS = 2;
 

File: core/src/main/java/org/eigenbase/rel/WindowRel.java
Patch:
@@ -240,6 +240,9 @@ public RexNode get(int index) {
     };
   }
 
+  /** Window specification. All windowed aggregates over the same window
+   * (regardless of how it is specified, in terms of a named window or specified
+   * attribute by attribute) will end up with the same window key. */
   private static class WindowKey {
     private final BitSet groupSet;
     private final RelCollation orderKeys;

File: core/src/main/java/org/eigenbase/rel/convert/ConverterRule.java
Patch:
@@ -105,6 +105,9 @@ public void onMatch(RelOptRuleCall call) {
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /**
+   * Operand to an instance of the converter rule.
+   */
   private static class ConverterRelOptRuleOperand extends RelOptRuleOperand {
     public ConverterRelOptRuleOperand(
         Class<? extends RelNode> clazz, RelTrait in) {

File: core/src/main/java/org/eigenbase/rel/metadata/RelMdUtil.java
Patch:
@@ -693,6 +693,8 @@ public static Double getJoinDistinctRowCount(
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /** Visitor that walks over a scalar expression and computes the
+   * cardinality of its result. */
   private static class CardOfProjExpr extends RexVisitorImpl<Double> {
     private ProjectRelBase rel;
 

File: core/src/main/java/org/eigenbase/rel/rules/CalcRelSplitter.java
Patch:
@@ -713,6 +713,8 @@ protected List<Set<Integer>> getCohorts() {
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /** Type of relational expression. Determines which kinds of
+   * expressions it can handle. */
   public abstract static class RelType {
     private final String name;
 

File: core/src/main/java/org/eigenbase/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -432,6 +432,8 @@ public RexNode visitCall(final RexCall call) {
    * literals or contain redundant casts.
    */
   private static class ReducibleExprLocator extends RexVisitorImpl<Void> {
+    /** Whether an expression is constant, and if so, whether it can be
+     * reduced to a simpler constant. */
     enum Constancy {
       NON_CONSTANT, REDUCIBLE_CONSTANT, IRREDUCIBLE_CONSTANT
     }

File: core/src/main/java/org/eigenbase/rel/rules/ReduceValuesRule.java
Patch:
@@ -231,6 +231,7 @@ protected void apply(RelOptRuleCall call, ProjectRel project,
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /** Shuttle that converts inputs to literals. */
   private static class MyRexShuttle extends RexShuttle {
     private List<RexLiteral> literalList;
 

File: core/src/main/java/org/eigenbase/rel/rules/RemoveEmptyRules.java
Patch:
@@ -224,6 +224,8 @@ private static EmptyRel empty(RelNode node) {
     return new EmptyRel(node.getCluster(), node.getRowType());
   }
 
+  /** Planner rule that converts a single-rel (e.g. project, sort, aggregate or
+   * filter) on top of the empty relational expression into empty. */
   private static class RemoveEmptySingleRule extends RelOptRule {
     public RemoveEmptySingleRule(Class<? extends SingleRel> clazz,
         String description) {

File: core/src/main/java/org/eigenbase/rel/rules/RemoveIsNotDistinctFromRule.java
Patch:
@@ -70,6 +70,9 @@ public void onMatch(RelOptRuleCall call) {
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /** Shuttle that removes 'x IS NOT DISTINCT FROM y' and converts it
+   * to 'CASE WHEN x IS NULL THEN y IS NULL WHEN y IS NULL THEN x IS
+   * NULL ELSE x = y END'. */
   private class RemoveIsNotDistinctFromRexShuttle extends RexShuttle {
     RexBuilder rexBuilder;
 

File: core/src/main/java/org/eigenbase/relopt/ConventionTraitDef.java
Patch:
@@ -208,6 +208,7 @@ private ConversionData getConversionData(RelOptPlanner planner) {
 
   //~ Inner Classes ----------------------------------------------------------
 
+  /** Workspace for converting from one convention to another. */
   private static final class ConversionData {
     final DirectedGraph<Convention, DefaultEdge> conversionGraph =
         DefaultDirectedGraph.create();

File: core/src/main/java/org/eigenbase/relopt/RelOptCostImpl.java
Patch:
@@ -114,6 +114,8 @@ public String toString() {
     }
   }
 
+  /** Implementation of {@link RelOptCostFactory} that creates
+   * {@link RelOptCostImpl}s. */
   private static class Factory implements RelOptCostFactory {
     // implement RelOptPlanner
     public RelOptCost makeCost(

File: core/src/main/java/org/eigenbase/relopt/RelOptPlanner.java
Patch:
@@ -276,6 +276,7 @@ RelNode register(
 
   Executor getExecutor();
 
+  /** Can reduce expressions, writing a literal for each into a list. */
   interface Executor {
     /**
      * Reduces expressions, and writes their results into {@code reducedValues}.

File: core/src/main/java/org/eigenbase/relopt/RelOptTable.java
Patch:
@@ -96,13 +96,16 @@ public interface RelOptTable {
    */
   Expression getExpression(Class clazz);
 
+  /** Can expand a view into relational expressions. */
   interface ViewExpander {
     RelNode expandView(
         RelDataType rowType,
         String queryString,
         List<String> schemaPath);
   }
 
+  /** Contains the context needed to convert a a table into a relational
+   * expression. */
   interface ToRelContext extends ViewExpander {
     RelOptCluster getCluster();
   }

File: core/src/main/java/org/eigenbase/relopt/RelTraitDef.java
Patch:
@@ -47,6 +47,8 @@
  *
  * <p>Otherwise, a new instance of RelTraitDef must be constructed and
  * registered with each new planner instantiated.</p>
+ *
+ * @param <T> Trait that this trait definition is based upon
  */
 public abstract class RelTraitDef<T extends RelTrait> {
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/relopt/RelTraitSet.java
Patch:
@@ -353,6 +353,7 @@ public RelTraitSet merge(RelTraitSet additionalTraits) {
     return plusAll(additionalTraits.traits);
   }
 
+  /** Cache of trait sets. */
   private static class Cache {
     final Map<RelTraitSet, RelTraitSet> map =
         new HashMap<RelTraitSet, RelTraitSet>();

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoRel.java
Patch:
@@ -34,6 +34,8 @@ public interface MongoRel extends RelNode {
   /** Calling convention for relational operations that occur in MongoDB. */
   Convention CONVENTION = new Convention.Impl("MONGO", MongoRel.class);
 
+  /** Callback for the implementation process that converts a tree of
+   * {@link MongoRel} nodes into a MongoDB query. */
   class Implementor {
     final List<Pair<String, String>> list =
         new ArrayList<Pair<String, String>>();

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/SplunkQuery.java
Patch:
@@ -26,6 +26,8 @@
 
 /**
  * Query against Splunk.
+ *
+ * @param <T> Element type
  */
 public class SplunkQuery<T> extends AbstractEnumerable<T> {
   private final SplunkConnection splunkConnection;
@@ -60,7 +62,7 @@ public Iterator<T> iterator() {
 
   public Enumerator<T> enumerator() {
     //noinspection unchecked
-    return (Enumerator<T>) splunkConnection.getSearchResultIterator(
+    return (Enumerator<T>) splunkConnection.getSearchResultEnumerator(
         search, getArgs(), fieldList);
   }
 

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/util/StringUtils.java
Patch:
@@ -21,6 +21,9 @@
 import java.util.List;
 import java.util.logging.Logger;
 
+/**
+ * Utility methods for encoding and decoding strings for Splunk REST calls.
+ */
 public class StringUtils {
   private StringUtils() {}
 

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/util/TrustAllSslSocketFactory.java
Patch:
@@ -107,6 +107,8 @@ public static SSLSocketFactory createSSLSocketFactory() {
     return sslsocketfactory;
   }
 
+  /** Implementation of {@link X509TrustManager} that trusts all
+   * certificates. */
   private static class DummyTrustManager implements X509TrustManager {
     public X509Certificate[] getAcceptedIssuers() {
       return null;

File: core/src/main/java/org/eigenbase/rel/metadata/ReflectiveRelMetadataProvider.java
Patch:
@@ -92,7 +92,8 @@ public static RelMetadataProvider reflectiveSource(Method method,
     final Class<?> metadataClass0 = method.getDeclaringClass();
     assert Metadata.class.isAssignableFrom(metadataClass0);
     final Map<Class<RelNode>, Function<RelNode, Metadata>> treeMap =
-        Maps.newTreeMap(SUPERCLASS_COMPARATOR);
+        Maps.<Class<RelNode>, Class<RelNode>, Function<RelNode, Metadata>>
+            newTreeMap(SUPERCLASS_COMPARATOR);
     for (final Method method1 : target.getClass().getMethods()) {
       if (method1.getName().equals(method.getName())
           && (method1.getModifiers() & Modifier.STATIC) == 0

File: core/src/main/java/org/eigenbase/relopt/AbstractRelOptPlanner.java
Patch:
@@ -206,7 +206,7 @@ public void addListener(RelOptListener newListener) {
   }
 
   // implement RelOptPlanner
-  public void registerMetadataProviders(ChainedRelMetadataProvider chain) {
+  public void registerMetadataProviders(List<RelMetadataProvider> list) {
   }
 
   // implement RelOptPlanner

File: core/src/main/java/org/eigenbase/relopt/hep/HepPlanner.java
Patch:
@@ -941,8 +941,8 @@ private void dumpGraph() {
   }
 
   // implement RelOptPlanner
-  public void registerMetadataProviders(ChainedRelMetadataProvider chain) {
-    chain.addProvider(new HepRelMetadataProvider());
+  public void registerMetadataProviders(List<RelMetadataProvider> list) {
+    list.add(0, new HepRelMetadataProvider());
   }
 
   // implement RelOptPlanner

File: core/src/main/java/org/eigenbase/relopt/volcano/VolcanoPlanner.java
Patch:
@@ -1593,8 +1593,8 @@ public void addListener(RelOptListener newListener) {
   }
 
   // implement RelOptPlanner
-  public void registerMetadataProviders(ChainedRelMetadataProvider chain) {
-    chain.addProvider(new VolcanoRelMetadataProvider());
+  public void registerMetadataProviders(List<RelMetadataProvider> list) {
+    list.add(0, new VolcanoRelMetadataProvider());
   }
 
   // implement RelOptPlanner

File: core/src/main/java/org/eigenbase/stat/RelStatSource.java
Patch:
@@ -17,7 +17,6 @@
 */
 package org.eigenbase.stat;
 
-import org.eigenbase.rel.*;
 import org.eigenbase.sarg.*;
 
 /**

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvTable.java
Patch:
@@ -85,9 +85,9 @@ public Enumerator<T> enumerator() {
   }
 
   /** Returns an enumerable over a given projection of the fields. */
-  public Enumerable<Object[]> project(final int[] fields) {
-    return new AbstractEnumerable<Object[]>() {
-      public Enumerator<Object[]> enumerator() {
+  public Enumerable<Object> project(final int[] fields) {
+    return new AbstractEnumerable<Object>() {
+      public Enumerator<Object> enumerator() {
         return new CsvEnumerator(file,
             fieldTypes.toArray(new CsvFieldType[fieldTypes.size()]), fields);
       }

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvFieldType.java
Patch:
@@ -17,9 +17,10 @@
 */
 package net.hydromatic.optiq.impl.csv;
 
-import net.hydromatic.linq4j.expressions.Primitive;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 
+import net.hydromatic.linq4j.expressions.Primitive;
+
 import org.eigenbase.reltype.RelDataType;
 
 import java.util.HashMap;

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvTable.java
Patch:
@@ -17,15 +17,15 @@
 */
 package net.hydromatic.optiq.impl.csv;
 
-import net.hydromatic.linq4j.*;
-
 import net.hydromatic.optiq.*;
 import net.hydromatic.optiq.impl.AbstractTableQueryable;
 import net.hydromatic.optiq.impl.java.AbstractQueryableTable;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 import net.hydromatic.optiq.rules.java.EnumerableConvention;
 import net.hydromatic.optiq.rules.java.JavaRules;
 
+import net.hydromatic.linq4j.*;
+
 import org.eigenbase.rel.RelNode;
 import org.eigenbase.relopt.RelOptTable;
 import org.eigenbase.reltype.*;

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvTableScan.java
Patch:
@@ -17,7 +17,6 @@
 */
 package net.hydromatic.optiq.impl.csv;
 
-import net.hydromatic.linq4j.Queryable;
 import net.hydromatic.optiq.rules.java.*;
 
 import net.hydromatic.linq4j.expressions.*;

File: src/test/java/net/hydromatic/optiq/test/CsvTest.java
Patch:
@@ -151,7 +151,7 @@ public Void apply(ResultSet resultSet) {
   }
 
   private void checkSql(String model, String sql, final String expected)
-      throws SQLException {
+    throws SQLException {
     checkSql(sql, model, new Function1<ResultSet, Void>() {
       public Void apply(ResultSet resultSet) {
         try {
@@ -166,7 +166,7 @@ public Void apply(ResultSet resultSet) {
   }
 
   private void checkSql(String sql, String model, Function1<ResultSet, Void> fn)
-      throws SQLException {
+    throws SQLException {
     Connection connection = null;
     Statement statement = null;
     try {
@@ -201,7 +201,7 @@ private static String toString(ResultSet resultSet) throws SQLException {
   }
 
   private void output(ResultSet resultSet, PrintStream out)
-      throws SQLException {
+    throws SQLException {
     final ResultSetMetaData metaData = resultSet.getMetaData();
     final int columnCount = metaData.getColumnCount();
     while (resultSet.next()) {

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcRules.java
Patch:
@@ -34,7 +34,7 @@
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.fun.SqlStdOperatorTable;
 import org.eigenbase.sql.parser.SqlParserPos;
-import org.eigenbase.sql.type.SqlTypeStrategies;
+import org.eigenbase.sql.type.*;
 import org.eigenbase.sql.validate.SqlValidatorUtil;
 import org.eigenbase.trace.EigenbaseTrace;
 import org.eigenbase.util.*;
@@ -635,8 +635,8 @@ public JdbcImplementor.Result implement(JdbcImplementor implementor) {
   /** MySQL specific function. */
   private static final SqlFunction ISNULL_FUNCTION =
       new SqlFunction("ISNULL", SqlKind.OTHER_FUNCTION,
-          SqlTypeStrategies.rtiBoolean, SqlTypeStrategies.otiFirstKnown,
-          SqlTypeStrategies.otcAny, SqlFunctionCategory.SYSTEM);
+          ReturnTypes.BOOLEAN, InferTypes.FIRST_KNOWN,
+          OperandTypes.ANY, SqlFunctionCategory.SYSTEM);
 
   /**
    * Rule to convert an {@link org.eigenbase.rel.UnionRel} to a

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqPrepare.java
Patch:
@@ -118,7 +118,7 @@ private static SparkHandler createHandler() {
       try {
         final Class<?> clazz =
             Class.forName("net.hydromatic.optiq.impl.spark.SparkHandlerImpl");
-        Method method = clazz.getMethod("INSTANCE");
+        Method method = clazz.getMethod("instance");
         return (OptiqPrepare.SparkHandler) method.invoke(null);
       } catch (ClassNotFoundException e) {
         return new TrivialSparkHandler();

File: core/src/main/java/org/eigenbase/rel/metadata/RelMdUtil.java
Patch:
@@ -42,9 +42,9 @@ public class RelMdUtil {
   public static final SqlFunction ARTIFICIAL_SELECTIVITY_FUNC =
       new SqlFunction("ARTIFICIAL_SELECTIVITY",
           SqlKind.OTHER_FUNCTION,
-          SqlTypeStrategies.rtiBoolean, // returns boolean since we'll AND it
+          ReturnTypes.BOOLEAN, // returns boolean since we'll AND it
           null,
-          SqlTypeStrategies.otcNumeric, // takes a numeric param
+          OperandTypes.NUMERIC, // takes a numeric param
           SqlFunctionCategory.SYSTEM);
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlAsOperator.java
Patch:
@@ -38,9 +38,9 @@ public SqlAsOperator() {
         SqlKind.AS,
         20,
         true,
-        SqlTypeStrategies.rtiFirstArgType,
-        SqlTypeStrategies.otiReturnType,
-        SqlTypeStrategies.otcAnyX2);
+        ReturnTypes.ARG0,
+        InferTypes.RETURN_TYPE,
+        OperandTypes.ANY_ANY);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlCall.java
Patch:
@@ -199,8 +199,7 @@ protected String getCallSignature(
       SqlValidator validator,
       SqlValidatorScope scope) {
     List<String> signatureList = new ArrayList<String>();
-    for (int i = 0; i < operands.length; i++) {
-      final SqlNode operand = operands[i];
+    for (final SqlNode operand : operands) {
       final RelDataType argType = validator.deriveType(scope, operand);
       if (null == argType) {
         continue;

File: core/src/main/java/org/eigenbase/sql/SqlJdbcFunctionCall.java
Patch:
@@ -396,7 +396,7 @@ public SqlJdbcFunctionCall(String name) {
         SqlKind.JDBC_FN,
         null,
         null,
-        SqlTypeStrategies.otcVariadic,
+        OperandTypes.VARIADIC,
         null);
     jdbcName = name;
     lookupMakeCallObj = JdbcToInternalLookupTable.INSTANCE.lookup(name);

File: core/src/main/java/org/eigenbase/sql/SqlOverOperator.java
Patch:
@@ -44,9 +44,9 @@ public SqlOverOperator() {
         SqlKind.OVER,
         20,
         true,
-        SqlTypeStrategies.rtiFirstArgTypeForceNullable,
+        ReturnTypes.ARG0_FORCE_NULLABLE,
         null,
-        SqlTypeStrategies.otcAnyX2);
+        OperandTypes.ANY_ANY);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlRankFunction.java
Patch:
@@ -41,9 +41,9 @@ public SqlRankFunction(String name) {
     super(
         name,
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiInteger,
+        ReturnTypes.INTEGER,
         null,
-        SqlTypeStrategies.otcNiladic,
+        OperandTypes.NILADIC,
         SqlFunctionCategory.NUMERIC);
   }
 

File: core/src/main/java/org/eigenbase/sql/SqlSelectOperator.java
Patch:
@@ -50,7 +50,7 @@ public SqlSelectOperator() {
         SqlKind.SELECT,
         2,
         true,
-        SqlTypeStrategies.rtiScope,
+        ReturnTypes.SCOPE,
         null,
         null);
   }

File: core/src/main/java/org/eigenbase/sql/SqlSetOperator.java
Patch:
@@ -43,9 +43,9 @@ public SqlSetOperator(
         kind,
         prec,
         true,
-        SqlTypeStrategies.rtiLeastRestrictive,
+        ReturnTypes.LEAST_RESTRICTIVE,
         null,
-        SqlTypeStrategies.otcSetop);
+        OperandTypes.SET_OP);
     this.all = all;
   }
 

File: core/src/main/java/org/eigenbase/sql/SqlUnnestOperator.java
Patch:
@@ -34,7 +34,7 @@ public SqlUnnestOperator() {
         true,
         null,
         null,
-        SqlTypeStrategies.otcMultisetOrRecordTypeMultiset);
+        OperandTypes.MULTISET_OR_RECORD_MULTISET);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlAbstractTimeFunction.java
Patch:
@@ -30,9 +30,8 @@ public class SqlAbstractTimeFunction extends SqlFunction {
   //~ Static fields/initializers ---------------------------------------------
 
   private static final SqlOperandTypeChecker OTC_CUSTOM =
-      SqlTypeStrategies.or(
-          SqlTypeStrategies.otcPositiveIntLit,
-          SqlTypeStrategies.otcNiladic);
+      OperandTypes.or(
+          OperandTypes.POSITIVE_INTEGER_LITERAL, OperandTypes.NILADIC);
 
   //~ Instance fields --------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlAvgAggFunction.java
Patch:
@@ -51,9 +51,9 @@ public SqlAvgAggFunction(
     super(
         subtype.name(),
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcNumeric,
+        OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC);
     this.type = type;
     this.subtype = subtype;

File: core/src/main/java/org/eigenbase/sql/fun/SqlBetweenOperator.java
Patch:
@@ -134,7 +134,7 @@ public RelDataType inferReturnType(
                 callBinding.getValidator(),
                 callBinding.getScope(),
                 callBinding.getCall()));
-    return SqlTypeStrategies.rtiNullableBoolean.inferReturnType(
+    return ReturnTypes.BOOLEAN_NULLABLE.inferReturnType(
         newOpBinding);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlCaseOperator.java
Patch:
@@ -129,7 +129,7 @@ public SqlCaseOperator() {
         SqlKind.CASE, MDX_PRECEDENCE,
         true,
         null,
-        SqlTypeStrategies.otiReturnType,
+        InferTypes.RETURN_TYPE,
         null);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlCastFunction.java
Patch:
@@ -44,7 +44,7 @@ public SqlCastFunction() {
         "CAST",
         SqlKind.CAST,
         null,
-        SqlTypeStrategies.otiFirstKnown,
+        InferTypes.FIRST_KNOWN,
         null,
         SqlFunctionCategory.SYSTEM);
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlCeilFunction.java
Patch:
@@ -31,9 +31,9 @@ public SqlCeilFunction() {
     super(
         "CEIL",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcNumeric,
+        OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlCoalesceFunction.java
Patch:
@@ -37,9 +37,9 @@ public SqlCoalesceFunction() {
     super(
         "COALESCE",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiLeastRestrictive,
+        ReturnTypes.LEAST_RESTRICTIVE,
         null,
-        SqlTypeStrategies.otcSameVariadic,
+        OperandTypes.SAME_VARIADIC,
         SqlFunctionCategory.SYSTEM);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlCollectionTableOperator.java
Patch:
@@ -46,9 +46,9 @@ public SqlCollectionTableOperator(String name, int modality) {
         SqlKind.COLLECTION_TABLE,
         200,
         true,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcAny);
+        OperandTypes.ANY);
 
     this.modality = modality;
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlColumnListConstructor.java
Patch:
@@ -32,9 +32,9 @@ public SqlColumnListConstructor() {
         "COLUMN_LIST",
         SqlKind.COLUMN_LIST, MDX_PRECEDENCE,
         false,
-        SqlTypeStrategies.rtiColumnList,
+        ReturnTypes.COLUMN_LIST,
         null,
-        SqlTypeStrategies.otcAny);
+        OperandTypes.ANY);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlCountAggFunction.java
Patch:
@@ -40,9 +40,9 @@ public SqlCountAggFunction() {
     super(
         "COUNT",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiBigint,
+        ReturnTypes.BIGINT,
         null,
-        SqlTypeStrategies.otcAny,
+        OperandTypes.ANY,
         SqlFunctionCategory.NUMERIC);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlCurrentDateFunction.java
Patch:
@@ -31,9 +31,9 @@ public SqlCurrentDateFunction() {
     super(
         "CURRENT_DATE",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiDate,
+        ReturnTypes.DATE,
         null,
-        SqlTypeStrategies.otcNiladic,
+        OperandTypes.NILADIC,
         SqlFunctionCategory.TIMEDATE);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlCursorConstructor.java
Patch:
@@ -34,9 +34,9 @@ public SqlCursorConstructor() {
         "CURSOR",
         SqlKind.CURSOR, MDX_PRECEDENCE,
         false,
-        SqlTypeStrategies.rtiCursor,
+        ReturnTypes.CURSOR,
         null,
-        SqlTypeStrategies.otcAny);
+        OperandTypes.ANY);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlDatetimeSubtractionOperator.java
Patch:
@@ -38,9 +38,9 @@ public SqlDatetimeSubtractionOperator() {
         SqlKind.MINUS,
         40,
         true,
-        SqlTypeStrategies.rtiNullableThirdArgType,
-        SqlTypeStrategies.otiFirstKnown,
-        SqlTypeStrategies.otcMinusDateOperator);
+        ReturnTypes.ARG2_NULLABLE,
+        InferTypes.FIRST_KNOWN,
+        OperandTypes.MINUS_DATE_OPERATOR);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlExtractFunction.java
Patch:
@@ -36,9 +36,9 @@ public SqlExtractFunction() {
     super(
         "EXTRACT",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiNullableBigint,
+        ReturnTypes.BIGINT_NULLABLE,
         null,
-        SqlTypeStrategies.otcIntervalSameX2,
+        OperandTypes.INTERVAL_SAME_SAME,
         SqlFunctionCategory.SYSTEM);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlFirstLastValueAggFunction.java
Patch:
@@ -37,9 +37,9 @@ public SqlFirstLastValueAggFunction(boolean firstFlag) {
     super(
         firstFlag ? "FIRST_VALUE" : "LAST_VALUE",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcAny,
+        OperandTypes.ANY,
         SqlFunctionCategory.NUMERIC);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlFloorFunction.java
Patch:
@@ -31,9 +31,9 @@ public SqlFloorFunction() {
     super(
         "FLOOR",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcNumeric,
+        OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlHistogramAggFunction.java
Patch:
@@ -43,9 +43,9 @@ public SqlHistogramAggFunction(RelDataType type) {
     super(
         "$HISTOGRAM",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiHistogram,
+        ReturnTypes.HISTOGRAM,
         null,
-        SqlTypeStrategies.otcNumericOrString,
+        OperandTypes.NUMERIC_OR_STRING,
         SqlFunctionCategory.NUMERIC);
     this.type = type;
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlInOperator.java
Patch:
@@ -50,8 +50,8 @@ public class SqlInOperator extends SqlBinaryOperator {
         SqlKind.IN,
         30,
         true,
-        SqlTypeStrategies.rtiNullableBoolean,
-        SqlTypeStrategies.otiFirstKnown,
+        ReturnTypes.BOOLEAN_NULLABLE,
+        InferTypes.FIRST_KNOWN,
         null);
     this.isNotIn = isNotIn;
   }
@@ -125,7 +125,7 @@ public RelDataType deriveType(
 
     final ComparableOperandTypeChecker checker =
         (ComparableOperandTypeChecker)
-            SqlTypeStrategies.otcComparableUnorderedX2;
+            OperandTypes.COMPARABLE_UNORDERED_COMPARABLE_UNORDERED;
     if (!checker.checkOperandTypes(
         new ExplicitOperatorBinding(
             new SqlCallBinding(

File: core/src/main/java/org/eigenbase/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -48,9 +48,9 @@ public class SqlLiteralChainOperator extends SqlInternalOperator {
         true,
 
         // precedence tighter than the * and || operators
-        SqlTypeStrategies.rtiFirstArgType,
-        SqlTypeStrategies.otiFirstKnown,
-        SqlTypeStrategies.otcVariadic);
+        ReturnTypes.ARG0,
+        InferTypes.FIRST_KNOWN,
+        OperandTypes.VARIADIC);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlMinMaxAggFunction.java
Patch:
@@ -66,9 +66,9 @@ public SqlMinMaxAggFunction(
     super(
         isMin ? "MIN" : "MAX",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcComparableOrdered,
+        OperandTypes.COMPARABLE_ORDERED,
         SqlFunctionCategory.SYSTEM);
     this.argTypes = argTypes;
     this.isMin = isMin;

File: core/src/main/java/org/eigenbase/sql/fun/SqlMultisetMemberOfOperator.java
Patch:
@@ -38,7 +38,7 @@ public SqlMultisetMemberOfOperator() {
         SqlKind.OTHER,
         30,
         true,
-        SqlTypeStrategies.rtiNullableBoolean,
+        ReturnTypes.BOOLEAN_NULLABLE,
         null,
         null);
   }
@@ -48,7 +48,7 @@ public SqlMultisetMemberOfOperator() {
   public boolean checkOperandTypes(
       SqlCallBinding callBinding,
       boolean throwOnFailure) {
-    if (!SqlTypeStrategies.otcMultiset.checkSingleOperandType(
+    if (!OperandTypes.MULTISET.checkSingleOperandType(
         callBinding,
         callBinding.getCall().operands[1],
         0,

File: core/src/main/java/org/eigenbase/sql/fun/SqlMultisetQueryConstructor.java
Patch:
@@ -43,9 +43,9 @@ protected SqlMultisetQueryConstructor(String name, SqlKind kind) {
         name,
         kind, MDX_PRECEDENCE,
         false,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcVariadic);
+        OperandTypes.VARIADIC);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlMultisetSetOperator.java
Patch:
@@ -43,9 +43,9 @@ public SqlMultisetSetOperator(String name, int prec, boolean all) {
         SqlKind.OTHER,
         prec,
         true,
-        SqlTypeStrategies.rtiNullableMultiset,
-        SqlTypeStrategies.otiFirstKnown,
-        SqlTypeStrategies.otcMultisetX2);
+        ReturnTypes.MULTISET_NULLABLE,
+        InferTypes.FIRST_KNOWN,
+        OperandTypes.MULTISET_MULTISET);
     this.all = all;
   }
 }

File: core/src/main/java/org/eigenbase/sql/fun/SqlMultisetValueConstructor.java
Patch:
@@ -45,9 +45,9 @@ protected SqlMultisetValueConstructor(String name, SqlKind kind) {
         name,
         kind, MDX_PRECEDENCE,
         false,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcVariadic);
+        OperandTypes.VARIADIC);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlNullifFunction.java
Patch:
@@ -37,9 +37,9 @@ public SqlNullifFunction() {
     super(
         "NULLIF",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgTypeForceNullable,
+        ReturnTypes.ARG0_FORCE_NULLABLE,
         null,
-        SqlTypeStrategies.otcComparableUnorderedX2,
+        OperandTypes.COMPARABLE_UNORDERED_COMPARABLE_UNORDERED,
         SqlFunctionCategory.SYSTEM);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlPositionFunction.java
Patch:
@@ -34,9 +34,9 @@ public SqlPositionFunction() {
     super(
         "POSITION",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiNullableInteger,
+        ReturnTypes.INTEGER_NULLABLE,
         null,
-        SqlTypeStrategies.otcStringSameX2,
+        OperandTypes.STRING_SAME_SAME,
         SqlFunctionCategory.NUMERIC);
   }
 
@@ -63,7 +63,7 @@ public boolean checkOperandTypes(
       SqlCallBinding callBinding,
       boolean throwOnFailure) {
     // check that the two operands are of same type.
-    return SqlTypeStrategies.otcSameX2.checkOperandTypes(
+    return OperandTypes.SAME_SAME.checkOperandTypes(
         callBinding, throwOnFailure)
         && super.checkOperandTypes(callBinding, throwOnFailure);
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlRowOperator.java
Patch:
@@ -40,8 +40,8 @@ public SqlRowOperator() {
         SqlKind.ROW, MDX_PRECEDENCE,
         false,
         null,
-        SqlTypeStrategies.otiReturnType,
-        SqlTypeStrategies.otcVariadic);
+        InferTypes.RETURN_TYPE,
+        OperandTypes.VARIADIC);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/fun/SqlSingleValueAggFunction.java
Patch:
@@ -41,9 +41,9 @@ public SqlSingleValueAggFunction(
     super(
         "SINGLE_VALUE",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcAny,
+        OperandTypes.ANY,
         SqlFunctionCategory.SYSTEM);
     this.type = type;
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlStringContextVariable.java
Patch:
@@ -31,9 +31,9 @@ protected SqlStringContextVariable(String name) {
     super(
         name,
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiVarchar2000,
+        ReturnTypes.VARCHAR_2000,
         null,
-        SqlTypeStrategies.otcNiladic,
+        OperandTypes.NILADIC,
         SqlFunctionCategory.SYSTEM);
   }
 

File: core/src/main/java/org/eigenbase/sql/fun/SqlSumAggFunction.java
Patch:
@@ -42,9 +42,9 @@ public SqlSumAggFunction(RelDataType type) {
     super(
         "SUM",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcNumeric,
+        OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC);
     this.type = type;
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlSumEmptyIsZeroAggFunction.java
Patch:
@@ -42,9 +42,9 @@ public SqlSumEmptyIsZeroAggFunction(RelDataType type) {
     super(
         "$SUM0",
         SqlKind.OTHER_FUNCTION,
-        SqlTypeStrategies.rtiFirstArgType,
+        ReturnTypes.ARG0,
         null,
-        SqlTypeStrategies.otcNumeric,
+        OperandTypes.NUMERIC,
         SqlFunctionCategory.NUMERIC);
     this.type = type;
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlThrowOperator.java
Patch:
@@ -43,9 +43,9 @@ public SqlThrowOperator() {
         SqlKind.OTHER,
         2,
         true,
-        SqlTypeStrategies.rtiBoolean,
+        ReturnTypes.BOOLEAN,
         null,
-        SqlTypeStrategies.otcCharString);
+        OperandTypes.CHARACTER);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/type/ComparableOperandTypeChecker.java
Patch:
@@ -105,9 +105,7 @@ public boolean checkOperandTypes(
 
   // implement SqlOperandTypeChecker
   public String getAllowedSignatures(SqlOperator op, String opName) {
-    return SqlUtil.getAliasedSignature(
-        op,
-        opName,
+    return SqlUtil.getAliasedSignature(op, opName,
         Collections.nCopies(nOperands, "COMPARABLE_TYPE"));
   }
 }

File: core/src/main/java/org/eigenbase/sql/type/CompositeOperandTypeChecker.java
Patch:
@@ -89,8 +89,8 @@ public enum Composition {
   //~ Constructors -----------------------------------------------------------
 
   /**
-   * Package private. Use {@link SqlTypeStrategies#and},
-   * {@link SqlTypeStrategies#or}.
+   * Package private. Use {@link OperandTypes#and},
+   * {@link OperandTypes#or}.
    */
   CompositeOperandTypeChecker(
       Composition composition,

File: core/src/main/java/org/eigenbase/sql/type/FamilyOperandTypeChecker.java
Patch:
@@ -37,7 +37,7 @@ public class FamilyOperandTypeChecker implements SqlSingleOperandTypeChecker {
   //~ Constructors -----------------------------------------------------------
 
   /**
-   * Package private. Create using {@link SqlTypeStrategies#family}.
+   * Package private. Create using {@link OperandTypes#family}.
    */
   FamilyOperandTypeChecker(List<SqlTypeFamily> families) {
     this.families = ImmutableList.copyOf(families);

File: core/src/main/java/org/eigenbase/sql/type/MultisetOperandTypeChecker.java
Patch:
@@ -37,7 +37,7 @@ public boolean checkOperandTypes(
       boolean throwOnFailure) {
     SqlCall call = callBinding.getCall();
     SqlNode op0 = call.operands[0];
-    if (!SqlTypeStrategies.otcMultiset.checkSingleOperandType(
+    if (!OperandTypes.MULTISET.checkSingleOperandType(
         callBinding,
         op0,
         0,
@@ -46,7 +46,7 @@ public boolean checkOperandTypes(
     }
 
     SqlNode op1 = call.operands[1];
-    if (!SqlTypeStrategies.otcMultiset.checkSingleOperandType(
+    if (!OperandTypes.MULTISET.checkSingleOperandType(
         callBinding,
         op1,
         0,

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1485,7 +1485,7 @@ public RelDataType deriveConstructorType(
         call.setOperator(
             new SqlFunction(
                 type.getSqlIdentifier(),
-                ExplicitReturnTypeInference.of(type),
+                ReturnTypes.explicit(type),
                 null,
                 null,
                 null,

File: core/src/main/java/org/eigenbase/sql2rel/StandardConvertletTable.java
Patch:
@@ -641,7 +641,7 @@ public RexNode convertCall(
     final RexBuilder rexBuilder = cx.getRexBuilder();
     final List<RexNode> exprs = convertExpressionList(cx, operands);
     if (op.getOperandTypeChecker()
-        == SqlTypeStrategies.otcComparableUnorderedX2) {
+        == OperandTypes.COMPARABLE_UNORDERED_COMPARABLE_UNORDERED) {
       ensureSameType(cx, exprs);
     }
     return rexBuilder.makeFlatCall(op, exprs);

File: core/src/test/java/org/eigenbase/test/MockSqlOperatorTable.java
Patch:
@@ -63,7 +63,7 @@ public RampFunction() {
           SqlKind.OTHER_FUNCTION,
           null,
           null,
-          SqlTypeStrategies.otcNumeric,
+          OperandTypes.NUMERIC,
           SqlFunctionCategory.USER_DEFINED_FUNCTION);
     }
 
@@ -83,7 +83,7 @@ public DedupFunction() {
           SqlKind.OTHER_FUNCTION,
           null,
           null,
-          SqlTypeStrategies.otcVariadic,
+          OperandTypes.VARIADIC,
           SqlFunctionCategory.USER_DEFINED_FUNCTION);
     }
 

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/EnumerableToSparkConverter.java
Patch:
@@ -39,7 +39,7 @@ public class EnumerableToSparkConverter
     implements SparkRel {
   protected EnumerableToSparkConverter(RelOptCluster cluster,
       RelTraitSet traits, RelNode input) {
-    super(cluster, ConventionTraitDef.instance, traits, input);
+    super(cluster, ConventionTraitDef.INSTANCE, traits, input);
   }
 
   @Override

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/JdbcToSparkConverter.java
Patch:
@@ -38,11 +38,10 @@
  */
 public class JdbcToSparkConverter
     extends ConverterRelImpl
-    implements SparkRel
-{
+    implements SparkRel {
   protected JdbcToSparkConverter(RelOptCluster cluster, RelTraitSet traits,
       RelNode input) {
-    super(cluster, ConventionTraitDef.instance, traits, input);
+    super(cluster, ConventionTraitDef.INSTANCE, traits, input);
   }
 
   @Override

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/SparkRel.java
Patch:
@@ -32,7 +32,7 @@ public interface SparkRel extends RelNode {
   Result implementSpark(Implementor implementor);
 
   /** Calling convention for relational operations that occur in Spark. */
-  final Convention CONVENTION = new Convention.Impl("SPARK", SparkRel.class);
+  Convention CONVENTION = new Convention.Impl("SPARK", SparkRel.class);
 
   public abstract class Implementor extends JavaRelImplementor {
     public Implementor(RexBuilder rexBuilder) {

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/SparkToEnumerableConverter.java
Patch:
@@ -41,12 +41,11 @@
  */
 public class SparkToEnumerableConverter
     extends ConverterRelImpl
-    implements EnumerableRel
-{
+    implements EnumerableRel {
   protected SparkToEnumerableConverter(RelOptCluster cluster,
       RelTraitSet traits,
       RelNode input) {
-    super(cluster, ConventionTraitDef.instance, traits, input);
+    super(cluster, ConventionTraitDef.INSTANCE, traits, input);
   }
 
   @Override

File: core/src/main/java/org/eigenbase/relopt/RelOptCostImpl.java
Patch:
@@ -70,7 +70,7 @@ public boolean isLt(RelOptCost other) {
 
   @Override
   public int hashCode() {
-    return Double.hashCode(getRows());
+    return Double.valueOf(getRows()).hashCode();
   }
 
   // implement RelOptCost

File: core/src/main/java/org/eigenbase/relopt/volcano/VolcanoCost.java
Patch:
@@ -117,9 +117,9 @@ public double getRows() {
 
   @Override
   public int hashCode() {
-    return Double.hashCode(dRows)
-        + Double.hashCode(dCpu)
-        + Double.hashCode(dIo);
+    return Double.valueOf(dRows).hashCode()
+        + Double.valueOf(dCpu).hashCode()
+        + Double.valueOf(dIo).hashCode();
   }
 
   public boolean equals(RelOptCost other) {

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaConnection.java
Patch:
@@ -295,7 +295,7 @@ public void setClientInfo(
   }
 
   public void setClientInfo(Properties properties)
-      throws SQLClientInfoException {
+    throws SQLClientInfoException {
     throw new UnsupportedOperationException();
   }
 

File: avatica/src/main/java/net/hydromatic/avatica/HandlerImpl.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class HandlerImpl implements Handler {
   public void onConnectionInit(AvaticaConnection connection)
-      throws SQLException {
+    throws SQLException {
     // nothing
   }
 

File: core/src/main/java/net/hydromatic/optiq/Schemas.java
Patch:
@@ -175,6 +175,7 @@ public static Expression subSchemaExpression(Schema schema,
         Expressions.call(schema.getExpression(),
             BuiltinMethod.SCHEMA_GET_SUB_SCHEMA.method,
             Expressions.constant(name));
+    //checkstyle: ignore 2
     //noinspection unchecked
     if (false && type != null && !type.isAssignableFrom(Schema.class)) {
       return unwrap(call, type);

File: core/src/main/java/net/hydromatic/optiq/Statistics.java
Patch:
@@ -25,6 +25,9 @@
  * Utility functions regarding {@link Statistic}.
  */
 public class Statistics {
+  private Statistics() {
+  }
+
   /** Returns a {@link Statistic} that knows nothing about a table. */
   public static final Statistic UNKNOWN =
       new Statistic() {

File: core/src/main/java/net/hydromatic/optiq/impl/MaterializedViewTable.java
Patch:
@@ -95,6 +95,7 @@ public RelNode toRel(RelOptTable.ToRelContext context,
     return super.toRel(context, relOptTable);
   }
 
+  /** Table function that returns the table that materializes a view. */
   public static class MaterializedViewTableFunction
       extends ViewTableFunction {
     private final MaterializationKey key;

File: core/src/main/java/net/hydromatic/optiq/impl/ViewTable.java
Patch:
@@ -46,8 +46,7 @@
  */
 public class ViewTable
     extends AbstractQueryableTable
-    implements TranslatableTable
-{
+    implements TranslatableTable {
   private final String viewSql;
   private final List<String> schemaPath;
   private final RelProtoDataType protoRowType;
@@ -104,6 +103,8 @@ private RelNode expandView(
     }
   }
 
+  /** Table function that implements a view. It returns the operator
+   * tree of the view's SQL query. */
   static class ViewTableFunction implements TableFunction {
     protected final String viewSql;
     protected final OptiqSchema schema;

File: core/src/main/java/net/hydromatic/optiq/impl/clone/ArrayTable.java
Patch:
@@ -191,6 +191,7 @@ enum RepresentationType {
     BYTE_STRING_DICTIONARY,
   }
 
+  /** Column definition and value set. */
   public static class Column {
     final Representation representation;
     final Object dataSet;

File: core/src/main/java/net/hydromatic/optiq/impl/clone/ColumnLoader.java
Patch:
@@ -45,7 +45,7 @@ class ColumnLoader<T> {
   static final int[] INT_B = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};
   static final int[] INT_S = {1, 2, 4, 8, 16};
   static final long[] LONG_B = {
-      0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000, 0xFFFFFFFF00000000L};
+    0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000, 0xFFFFFFFF00000000L};
   static final int[] LONG_S = {1, 2, 4, 8, 16, 32};
 
   private static final Function1<Timestamp, Long> TIMESTAMP_TO_LONG =
@@ -368,7 +368,7 @@ private long toLong(Object o) {
       // We treat Boolean and Character as if they were subclasses of
       // Number but actually they are not.
       if (o instanceof Boolean) {
-        return ((Boolean) o ? 1 : 0);
+        return (Boolean) o ? 1 : 0;
       } else if (o instanceof Character) {
         return (long) (Character) o;
       } else {
@@ -453,6 +453,7 @@ private static long abs2(long v) {
     }
   }
 
+  /** Key-value pair. */
   private static class Kev implements Comparable<Kev> {
     private final int source;
     private final Comparable key;

File: core/src/main/java/net/hydromatic/optiq/impl/java/ReflectiveSchema.java
Patch:
@@ -163,6 +163,7 @@ private static Enumerable toEnumerable(final Object o) {
         "Cannot convert " + o.getClass() + " into a Enumerable");
   }
 
+  /** Table that is implemented by reading from a Java object. */
   private static class ReflectiveTable
       extends AbstractQueryableTable
       implements Table {
@@ -261,6 +262,7 @@ public Schema create(SchemaPlus parentSchema, String name,
     }
   }
 
+  /** Table function based on a Java method. */
   private static class MethodTableFunction implements TableFunction {
     private final ReflectiveSchema schema;
     private final Method method;
@@ -334,6 +336,7 @@ public Expression getExpression(SchemaPlus schema, String tableName,
     }
   }
 
+  /** Table based on a Java field. */
   private static class FieldTable<T> extends ReflectiveTable {
     private final Field field;
 

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcImplementor.java
Patch:
@@ -318,6 +318,7 @@ public SqlNode field(int ordinal) {
     }
   }
 
+  /** Result of implementing a node. */
   public class Result {
     final SqlNode node;
     private final String neededAlias;
@@ -445,6 +446,7 @@ public Context qualifiedContext() {
     }
   }
 
+  /** Builder. */
   public class Builder {
     private final JdbcRel rel;
     private final List<Clause> clauses;

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcQueryProvider.java
Patch:
@@ -18,7 +18,6 @@
 package net.hydromatic.optiq.impl.jdbc;
 
 import net.hydromatic.linq4j.Enumerator;
-import net.hydromatic.linq4j.QueryProvider;
 import net.hydromatic.linq4j.QueryProviderImpl;
 import net.hydromatic.linq4j.Queryable;
 

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcRel.java
Patch:
@@ -18,7 +18,6 @@
 package net.hydromatic.optiq.impl.jdbc;
 
 import org.eigenbase.rel.RelNode;
-import org.eigenbase.sql.SqlNode;
 
 /**
  * Relational expression that uses JDBC calling convention.

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcTableScan.java
Patch:
@@ -55,8 +55,8 @@ public void register(RelOptPlanner planner) {
     for (RelOptRule rule : JdbcRules.rules(out)) {
       planner.addRule(rule);
     }
-    planner.addRule(PushFilterPastSetOpRule.instance);
-    planner.addRule(RemoveTrivialProjectRule.instance);
+    planner.addRule(PushFilterPastSetOpRule.INSTANCE);
+    planner.addRule(RemoveTrivialProjectRule.INSTANCE);
   }
 
   public JdbcImplementor.Result implement(JdbcImplementor implementor) {

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcUtils.java
Patch:
@@ -38,6 +38,7 @@ private JdbcUtils() {
     throw new AssertionError("no instances!");
   }
 
+  /** Pool of dialects. */
   public static class DialectPool {
     final Map<List, SqlDialect> map = new HashMap<List, SqlDialect>();
 
@@ -90,7 +91,7 @@ public static class ObjectArrayRowBuilder implements Function0<Object[]> {
 
     public ObjectArrayRowBuilder(
         ResultSet resultSet, Primitive[] primitives, int[] types)
-        throws SQLException {
+      throws SQLException {
       this.resultSet = resultSet;
       this.primitives = primitives;
       this.types = types;

File: core/src/main/java/net/hydromatic/optiq/jdbc/Driver.java
Patch:
@@ -82,7 +82,7 @@ protected Handler createHandler() {
     return new HandlerImpl() {
       @Override
       public void onConnectionInit(AvaticaConnection connection_)
-          throws SQLException {
+        throws SQLException {
         final OptiqConnectionImpl connection =
             (OptiqConnectionImpl) connection_;
         super.onConnectionInit(connection);

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqJdbc41Factory.java
Patch:
@@ -104,6 +104,7 @@ private static class OptiqJdbc41Connection extends OptiqConnectionImpl {
     }
   }
 
+  /** Implementation of statement for JDBC 4.1. */
   private static class OptiqJdbc41Statement extends OptiqStatement {
     public OptiqJdbc41Statement(
         OptiqConnectionImpl connection,
@@ -115,6 +116,7 @@ public OptiqJdbc41Statement(
     }
   }
 
+  /** Implementation of prepared statement for JDBC 4.1. */
   private static class OptiqJdbc41PreparedStatement
       extends OptiqPreparedStatement {
     OptiqJdbc41PreparedStatement(
@@ -236,6 +238,7 @@ public void setNClob(
     }
   }
 
+  /** Implementation of database metadata for JDBC 4.1. */
   private static class OptiqJdbc41DatabaseMetaData
       extends AvaticaDatabaseMetaData {
     OptiqJdbc41DatabaseMetaData(OptiqConnectionImpl connection) {

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqPreparedStatement.java
Patch:
@@ -33,8 +33,7 @@
  */
 abstract class OptiqPreparedStatement
     extends AvaticaPreparedStatement
-    implements OptiqServerStatement
-{
+    implements OptiqServerStatement {
   /**
    * Creates an OptiqPreparedStatement.
    *
@@ -49,7 +48,7 @@ protected OptiqPreparedStatement(
       int resultSetType,
       int resultSetConcurrency,
       int resultSetHoldability)
-      throws SQLException {
+    throws SQLException {
     super(
         connection, prepareResult, resultSetType, resultSetConcurrency,
         resultSetHoldability);

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqStatement.java
Patch:
@@ -29,8 +29,7 @@
  */
 public abstract class OptiqStatement
     extends AvaticaStatement
-    implements OptiqServerStatement
-{
+    implements OptiqServerStatement {
   OptiqStatement(
       OptiqConnectionImpl connection,
       int resultSetType,

File: core/src/main/java/net/hydromatic/optiq/jdbc/SqlTimeoutException.java
Patch:
@@ -24,8 +24,7 @@
  * retry the operation.
  */
 public class SqlTimeoutException
-    extends SQLException
-{
+    extends SQLException {
   SqlTimeoutException() {
     // SQLException(reason, SQLState, vendorCode)
     // REVIEW mb 19-Jul-05 Is there a standard SQLState?

File: core/src/main/java/net/hydromatic/optiq/model/JsonRoot.java
Patch:
@@ -17,7 +17,6 @@
 */
 package net.hydromatic.optiq.model;
 
-import java.lang.String;
 import java.util.ArrayList;
 import java.util.List;
 

File: core/src/main/java/net/hydromatic/optiq/model/JsonSchema.java
Patch:
@@ -35,7 +35,7 @@
 @JsonSubTypes({
     @JsonSubTypes.Type(value = JsonMapSchema.class, name = "map"),
     @JsonSubTypes.Type(value = JsonJdbcSchema.class, name = "jdbc"),
-    @JsonSubTypes.Type(value = JsonCustomSchema.class, name = "custom")})
+    @JsonSubTypes.Type(value = JsonCustomSchema.class, name = "custom") })
 public abstract class JsonSchema {
   public String name;
 

File: core/src/main/java/net/hydromatic/optiq/model/JsonTable.java
Patch:
@@ -34,7 +34,7 @@
     defaultImpl = JsonCustomTable.class)
 @JsonSubTypes({
     @JsonSubTypes.Type(value = JsonCustomTable.class, name = "custom"),
-    @JsonSubTypes.Type(value = JsonView.class, name = "view")})
+    @JsonSubTypes.Type(value = JsonView.class, name = "view") })
 public abstract class JsonTable {
   public String name;
   public final List<JsonColumn> columns = new ArrayList<JsonColumn>();

File: core/src/main/java/net/hydromatic/optiq/model/JsonView.java
Patch:
@@ -17,7 +17,6 @@
 */
 package net.hydromatic.optiq.model;
 
-import java.util.ArrayList;
 import java.util.List;
 
 /**

File: core/src/main/java/net/hydromatic/optiq/model/ModelHandler.java
Patch:
@@ -47,7 +47,7 @@ public class ModelHandler {
       new ArrayList<Pair<String, SchemaPlus>>();
 
   public ModelHandler(OptiqConnection connection, String uri)
-      throws IOException {
+    throws IOException {
     super();
     this.connection = connection;
     final ObjectMapper mapper = new ObjectMapper();
@@ -91,7 +91,7 @@ public void visit(JsonMapSchema jsonSchema) {
       // Inject by hand a Star Table. Later we'll add a JSON model element.
       final List<Table> tables = new ArrayList<Table>();
       final String[] tableNames = {
-          "sales_fact_1997", "time_by_day", "product", "product_class"
+        "sales_fact_1997", "time_by_day", "product", "product_class"
       };
       final SchemaPlus schema2 = parentSchema.getSubSchema("foodmart");
       for (String tableName : tableNames) {

File: core/src/main/java/net/hydromatic/optiq/prepare/LixToRelTranslator.java
Patch:
@@ -87,7 +87,7 @@ public RelNode translate(Expression expression) {
                 child,
                 (FunctionExpression) call.expressions.get(0)),
             null,
-            ProjectRel.Flags.Boxed);
+            ProjectRel.Flags.BOXED);
 
       case WHERE:
         child = translate(call.targetExpression);

File: core/src/main/java/net/hydromatic/optiq/prepare/QueryableRelBuilder.java
Patch:
@@ -497,7 +497,7 @@ public <TResult> Queryable<TResult> select(
             child,
             nodes,
             null,
-            ProjectRelBase.Flags.Boxed));
+            ProjectRelBase.Flags.BOXED));
     return null;
   }
 

File: core/src/main/java/net/hydromatic/optiq/rules/java/EnumerableConvention.java
Patch:
@@ -41,7 +41,7 @@ public String getName() {
   }
 
   public RelTraitDef getTraitDef() {
-    return ConventionTraitDef.instance;
+    return ConventionTraitDef.INSTANCE;
   }
 
   public boolean subsumes(RelTrait trait) {

File: core/src/main/java/net/hydromatic/optiq/rules/java/EnumerableRel.java
Patch:
@@ -27,8 +27,7 @@
  * conventions.
  */
 public interface EnumerableRel
-    extends RelNode
-{
+    extends RelNode {
   //~ Methods ----------------------------------------------------------------
 
   /**
@@ -52,7 +51,7 @@ enum Prefer {
      * accommodate records represented as arrays. */
     CUSTOM_NICE,
     /** Consumer has no preferred representation. */
-    ANY,;
+    ANY;
 
     public JavaRowFormat preferCustom() {
       return prefer(JavaRowFormat.CUSTOM);

File: core/src/main/java/net/hydromatic/optiq/rules/java/JavaRowFormat.java
Patch:
@@ -108,7 +108,7 @@ public Expression record(
         Type javaRowClass, List<Expression> expressions) {
       switch (expressions.size()) {
       case 0:
-      return Expressions.field(
+        return Expressions.field(
           null,
           Collections.class,
           "EMPTY_LIST");

File: core/src/main/java/net/hydromatic/optiq/rules/java/PhysTypeImpl.java
Patch:
@@ -101,8 +101,7 @@ public Map.Entry<String, RelDataType> get(int index) {
               public int size() {
                 return integers.size();
               }
-            }
-        );
+            });
     return of(typeFactory, projectedRowType, format.optimize(projectedRowType));
   }
 

File: core/src/main/java/net/hydromatic/optiq/runtime/AbstractCursor.java
Patch:
@@ -558,7 +558,7 @@ public float getFloat() {
 
     public long getLong() {
       Number number = getNumber();
-      return number == null ? 0l : number.longValue();
+      return number == null ? 0L : number.longValue();
     }
 
     public int getInt() {

File: core/src/main/java/net/hydromatic/optiq/runtime/ArrayEnumeratorCursor.java
Patch:
@@ -57,7 +57,7 @@ public ArrayEnumeratorGetter(int field) {
 
     public Object getObject() {
       Object o = enumerator.current()[field];
-      wasNull[0] = (o == null);
+      wasNull[0] = o == null;
       return o;
     }
   }

File: core/src/main/java/net/hydromatic/optiq/runtime/Bindable.java
Patch:
@@ -18,7 +18,7 @@
 package net.hydromatic.optiq.runtime;
 
 import net.hydromatic.linq4j.Enumerable;
-import net.hydromatic.linq4j.RawEnumerable;
+
 import net.hydromatic.optiq.DataContext;
 
 /**

File: core/src/main/java/net/hydromatic/optiq/runtime/ComparableComparator.java
Patch:
@@ -23,8 +23,7 @@
  * Comparator that uses the natural ordering of [@link Comparable} values.
  */
 public final class ComparableComparator<T extends Comparable>
-    implements Comparator<T>
-{
+    implements Comparator<T> {
   private static final ComparableComparator INSTANCE =
       new ComparableComparator();
 

File: core/src/main/java/net/hydromatic/optiq/runtime/ObjectEnumeratorCursor.java
Patch:
@@ -55,7 +55,7 @@ public ObjectEnumeratorGetter(int field) {
 
     public Object getObject() {
       Object o = enumerator.current();
-      wasNull[0] = (o == null);
+      wasNull[0] = o == null;
       return o;
     }
   }

File: core/src/main/java/net/hydromatic/optiq/runtime/RecordEnumeratorCursor.java
Patch:
@@ -70,7 +70,7 @@ public Object getObject() {
       } catch (IllegalAccessException e) {
         throw new RuntimeException(e);
       }
-      wasNull[0] = (o == null);
+      wasNull[0] = o == null;
       return o;
     }
   }

File: core/src/main/java/net/hydromatic/optiq/runtime/ResultSetEnumerable.java
Patch:
@@ -38,7 +38,7 @@ public class ResultSetEnumerable<T> extends AbstractEnumerable<T> {
   private final Function1<ResultSet, Function0<T>> rowBuilderFactory;
 
   private static final Function1<ResultSet, Function0<Object>>
-      AUTO_ROW_BUILDER_FACTORY =
+  AUTO_ROW_BUILDER_FACTORY =
       new Function1<ResultSet, Function0<Object>>() {
         public Function0<Object> apply(final ResultSet resultSet) {
           final ResultSetMetaData metaData;
@@ -67,14 +67,14 @@ public Object[] apply() {
                   final List<Object> list = new ArrayList<Object>();
                   for (int i = 0; i < columnCount; i++) {
                     if (metaData.getColumnType(i + 1) == Types.TIMESTAMP) {
-                     long v = resultSet.getLong(i + 1);
+                      long v = resultSet.getLong(i + 1);
                       if (v == 0 && resultSet.wasNull()) {
                         list.add(null);
                       } else {
                         list.add(v);
                       }
                     } else {
-                    list.add(resultSet.getObject(i + 1));
+                      list.add(resultSet.getObject(i + 1));
                     }
                   }
                   return list.toArray();

File: core/src/main/java/net/hydromatic/optiq/tools/Frameworks.java
Patch:
@@ -40,6 +40,9 @@
  * server first.
  */
 public class Frameworks {
+  private Frameworks() {
+  }
+
   /**
    * Creates an instance of {@code Planner}.
    *

File: core/src/main/java/net/hydromatic/optiq/tools/Planner.java
Patch:
@@ -79,7 +79,7 @@ public interface Planner {
    */
   RelNode transform(int ruleSetIndex,
       RelTraitSet requiredOutputTraits, RelNode rel)
-      throws RelConversionException;
+    throws RelConversionException;
 
   /**
    * Resets this {@code Planner} to be used with a new query. This

File: core/src/main/java/net/hydromatic/optiq/util/graph/Graphs.java
Patch:
@@ -27,6 +27,9 @@
  * Miscellaneous graph utilities.
  */
 public class Graphs {
+  private Graphs() {
+  }
+
   public static <V, E extends DefaultEdge> List<V>
   predecessorListOf(DirectedGraph<V, E> graph, V vertex) {
     final List<E> edges = graph.getInwardEdges(vertex);

File: core/src/main/java/org/eigenbase/javac/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.javac;
 
 /**
  * Provides compilers for Java code.
  */
+package org.eigenbase.javac;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/jdbc4/package-info.java
Patch:
@@ -15,12 +15,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.jdbc4;
 
 /**
  * Provides source compatibility gunk when building a JDBC 4.0 driver
  * implementation against JDK 1.5. For more information, see
  * <a href="http://pub.eigenbase.org/wiki/Jdbc4Transition">Eigenpedia</a>.
  */
+package org.eigenbase.jdbc4;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/rel/AggregateRel.java
Patch:
@@ -31,6 +31,7 @@
  * <li>{@link org.eigenbase.rel.rules.PullConstantsThroughAggregatesRule}
  * <li>{@link org.eigenbase.rel.rules.RemoveDistinctAggregateRule}
  * <li>{@link org.eigenbase.rel.rules.ReduceAggregatesRule}.
+ * </ul>
  */
 public final class AggregateRel extends AggregateRelBase {
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/AggregateRelBase.java
Patch:
@@ -143,7 +143,7 @@ public double getRows() {
       return 1;
     } else {
       double rowCount = super.getRows();
-      rowCount *= (1.0 - Math.pow(.5, groupCount));
+      rowCount *= 1.0 - Math.pow(.5, groupCount);
       return rowCount;
     }
   }
@@ -189,8 +189,7 @@ public RelDataTypeField get(int index) {
                 return new RelDataTypeFieldImpl(
                     name, index, aggCall.type);
               }
-            }
-        ));
+            }));
   }
 
   /**

File: core/src/main/java/org/eigenbase/rel/CollectRel.java
Patch:
@@ -110,7 +110,7 @@ public static RelDataType deriveCollectRowType(
       SingleRel rel,
       String fieldName) {
     RelDataType childType = rel.getChild().getRowType();
-    assert (childType.isStruct());
+    assert childType.isStruct();
     RelDataType ret =
         SqlTypeUtil.createMultisetType(
             rel.getCluster().getTypeFactory(),

File: core/src/main/java/org/eigenbase/rel/CorrelatorRel.java
Patch:
@@ -102,7 +102,7 @@ public CorrelatorRel(
   public CorrelatorRel(RelInput input) {
     this(
         input.getCluster(), input.getInputs().get(0),
-        input.getInputs().get((1)), getCorrelations(input),
+        input.getInputs().get(1), getCorrelations(input),
         input.getEnum("joinType", JoinRelType.class));
   }
 
@@ -196,7 +196,7 @@ public String toString() {
     }
 
     public int compareTo(Correlation other) {
-      return (id - other.id);
+      return id - other.id;
     }
   }
 }

File: core/src/main/java/org/eigenbase/rel/JoinRelBase.java
Patch:
@@ -110,7 +110,7 @@ public RelNode getRight() {
   }
 
   // TODO: enable
-  public boolean _isValid(boolean fail) {
+  public boolean isValid_(boolean fail) {
     if (!super.isValid(fail)) {
       return false;
     }
@@ -334,7 +334,7 @@ private static void addFields(
       // Ensure that name is unique from all previous field names
       if (uniqueNameList.contains(name)) {
         String nameBase = name;
-        for (int j = 0; ; j++) {
+        for (int j = 0;; j++) {
           name = nameBase + j;
           if (!uniqueNameList.contains(name)) {
             break;

File: core/src/main/java/org/eigenbase/rel/RelImplementorImpl.java
Patch:
@@ -33,7 +33,7 @@
  * Implementation of {@link RelImplementor}.
  */
 public class RelImplementorImpl implements RelImplementor {
-  protected static final Logger tracer =
+  protected static final Logger LOGGER =
       EigenbaseTrace.getRelImplementorTracer();
 
   /**

File: core/src/main/java/org/eigenbase/rel/SingleRel.java
Patch:
@@ -78,7 +78,7 @@ public RelWriter explainTerms(RelWriter pw) {
   public void replaceInput(
       int ordinalInParent,
       RelNode rel) {
-    assert (ordinalInParent == 0);
+    assert ordinalInParent == 0;
     this.child = rel;
   }
 

File: core/src/main/java/org/eigenbase/rel/TableAccessRel.java
Patch:
@@ -18,7 +18,6 @@
 package org.eigenbase.rel;
 
 import java.util.List;
-import java.util.Map;
 
 import org.eigenbase.relopt.*;
 

File: core/src/main/java/org/eigenbase/rel/TableAccessRelBase.java
Patch:
@@ -147,7 +147,7 @@ public RelNode project(
         this,
         exprList,
         nameList,
-        ProjectRel.Flags.Boxed);
+        ProjectRel.Flags.BOXED);
   }
 
   @Override

File: core/src/main/java/org/eigenbase/rel/TableFunctionRel.java
Patch:
@@ -25,8 +25,6 @@
 import org.eigenbase.reltype.*;
 import org.eigenbase.rex.*;
 
-import com.google.common.collect.ImmutableSet;
-
 /**
  * <code>TableFunctionRel</code> represents a call to a function which returns a
  * result set. Currently, it can only appear as a leaf in a query tree, but

File: core/src/main/java/org/eigenbase/rel/TableModificationRelBase.java
Patch:
@@ -125,7 +125,7 @@ public RelDataType deriveRowType() {
 
   // override RelNode
   public RelDataType getExpectedInputRowType(int ordinalInParent) {
-    assert (ordinalInParent == 0);
+    assert ordinalInParent == 0;
 
     if (inputRowType != null) {
       return inputRowType;

File: core/src/main/java/org/eigenbase/rel/UncollectRel.java
Patch:
@@ -22,9 +22,6 @@
 import org.eigenbase.relopt.*;
 import org.eigenbase.reltype.*;
 import org.eigenbase.sql.*;
-import org.eigenbase.util.Pair;
-
-import com.google.common.collect.ImmutableList;
 
 /**
  * A relational expression which unnests its input's sole column into a

File: core/src/main/java/org/eigenbase/rel/ValuesRelBase.java
Patch:
@@ -73,7 +73,7 @@ protected ValuesRelBase(
     super(cluster, traits);
     this.rowType = rowType;
     this.tuples = tuples;
-    assert (assertRowType());
+    assert assertRowType();
   }
 
   /**

File: core/src/main/java/org/eigenbase/rel/convert/ConverterRule.java
Patch:
@@ -52,8 +52,8 @@ public ConverterRule(
         description == null
             ? "ConverterRule<in=" + in + ",out=" + out + ">"
             : description);
-    assert (in != null);
-    assert (out != null);
+    assert in != null;
+    assert out != null;
 
     // Source and target traits must have same type
     assert in.getTraitDef() == out.getTraitDef();

File: core/src/main/java/org/eigenbase/rel/convert/NoneConverterRel.java
Patch:
@@ -35,7 +35,7 @@ public NoneConverterRel(
       RelNode child) {
     super(
         cluster,
-        ConventionTraitDef.instance,
+        ConventionTraitDef.INSTANCE,
         cluster.traitSetOf(Convention.NONE),
         child);
   }

File: core/src/main/java/org/eigenbase/rel/convert/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.rel.convert;
 
 /**
  * Defines relational expressions and rules for converting between calling
  * conventions.
  */
+package org.eigenbase.rel.convert;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/rel/jdbc/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.rel.jdbc;
 
 /**
  * Contains query transformation rules relating to generating SQL for
  * foreign JDBC databases.
  */
+package org.eigenbase.rel.jdbc;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/rel/metadata/RelMdColumnUniqueness.java
Patch:
@@ -179,7 +179,7 @@ public Boolean areColumnsUnique(
       if ((leftUnique == null) || (rightUnique == null)) {
         return null;
       } else {
-        return (leftUnique && rightUnique);
+        return leftUnique && rightUnique;
       }
     }
 
@@ -210,7 +210,7 @@ public Boolean areColumnsUnique(
       if ((rightJoinColsUnique == null) || (leftUnique == null)) {
         return null;
       }
-      return (rightJoinColsUnique && leftUnique);
+      return rightJoinColsUnique && leftUnique;
     } else if (rightColumns.cardinality() > 0) {
       if (rel.getJoinType().generatesNullsOnRight()) {
         return false;
@@ -223,7 +223,7 @@ public Boolean areColumnsUnique(
       if ((leftJoinColsUnique == null) || (rightUnique == null)) {
         return null;
       }
-      return (leftJoinColsUnique && rightUnique);
+      return leftJoinColsUnique && rightUnique;
     }
 
     throw new AssertionError();

File: core/src/main/java/org/eigenbase/rel/metadata/RelMdPercentageOriginalRows.java
Patch:
@@ -57,7 +57,7 @@ public Double getPercentageOriginalRows(UnionRelBase rel) {
       double percentage =
           RelMetadataQuery.getPercentageOriginalRows(input);
       if (percentage != 0.0) {
-        denominator += (rowCount / percentage);
+        denominator += rowCount / percentage;
         numerator += rowCount;
       }
     }

File: core/src/main/java/org/eigenbase/rel/metadata/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.rel.metadata;
 
 /**
  * Defines metadata interfaces and utilities for relational
  * expressions.
  */
+package org.eigenbase.rel.metadata;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/rel/package-info.java
Patch:
@@ -15,7 +15,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.rel;
 
 /**
  * Defines relational expressions.
@@ -36,5 +35,6 @@
  *     </li>
  * </ul>
  */
+package org.eigenbase.rel;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/rel/rules/AddRedundantSemiJoinRule.java
Patch:
@@ -28,7 +28,7 @@
  * <p>JoinRel(X, Y) -> JoinRel(SemiJoinRel(X, Y), Y)
  */
 public class AddRedundantSemiJoinRule extends RelOptRule {
-  public static final AddRedundantSemiJoinRule instance =
+  public static final AddRedundantSemiJoinRule INSTANCE =
       new AddRedundantSemiJoinRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/CombineUnionsRule.java
Patch:
@@ -25,11 +25,11 @@
 import org.eigenbase.util.Util;
 
 /**
- * CombineUnionsRule implements the rule for combining two non-distinct {@link
- * UnionRel}s into a single {@link UnionRel}.
+ * CombineUnionsRule implements the rule for combining two non-distinct
+ * {@link UnionRel}s into a single {@link UnionRel}.
  */
 public class CombineUnionsRule extends RelOptRule {
-  public static final CombineUnionsRule instance =
+  public static final CombineUnionsRule INSTANCE =
       new CombineUnionsRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/FilterToCalcRule.java
Patch:
@@ -36,7 +36,7 @@
 public class FilterToCalcRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final FilterToCalcRule instance = new FilterToCalcRule();
+  public static final FilterToCalcRule INSTANCE = new FilterToCalcRule();
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/rel/rules/MergeCalcRule.java
Patch:
@@ -29,7 +29,7 @@
 public class MergeCalcRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final MergeCalcRule instance = new MergeCalcRule();
+  public static final MergeCalcRule INSTANCE = new MergeCalcRule();
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/rel/rules/MergeFilterOntoCalcRule.java
Patch:
@@ -33,7 +33,7 @@
 public class MergeFilterOntoCalcRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final MergeFilterOntoCalcRule instance =
+  public static final MergeFilterOntoCalcRule INSTANCE =
       new MergeFilterOntoCalcRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/MergeFilterRule.java
Patch:
@@ -25,7 +25,7 @@
  * MergeFilterRule implements the rule for combining two {@link FilterRel}s
  */
 public class MergeFilterRule extends RelOptRule {
-  public static final MergeFilterRule instance = new MergeFilterRule();
+  public static final MergeFilterRule INSTANCE = new MergeFilterRule();
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/rel/rules/MergeProjectOntoCalcRule.java
Patch:
@@ -34,7 +34,7 @@
 public class MergeProjectOntoCalcRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final MergeProjectOntoCalcRule instance =
+  public static final MergeProjectOntoCalcRule INSTANCE =
       new MergeProjectOntoCalcRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/MergeProjectRule.java
Patch:
@@ -28,7 +28,7 @@
  * provided the projects aren't projecting identical sets of input references.
  */
 public class MergeProjectRule extends RelOptRule {
-  public static final MergeProjectRule instance =
+  public static final MergeProjectRule INSTANCE =
       new MergeProjectRule();
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/ProjectToCalcRule.java
Patch:
@@ -36,7 +36,7 @@
 public class ProjectToCalcRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final ProjectToCalcRule instance = new ProjectToCalcRule();
+  public static final ProjectToCalcRule INSTANCE = new ProjectToCalcRule();
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/rel/rules/PullUpAggregateAboveUnionRule.java
Patch:
@@ -34,7 +34,7 @@
  * two inputs.
  */
 public class PullUpAggregateAboveUnionRule extends RelOptRule {
-  public static final PullUpAggregateAboveUnionRule instance =
+  public static final PullUpAggregateAboveUnionRule INSTANCE =
       new PullUpAggregateAboveUnionRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushAggregateThroughUnionRule.java
Patch:
@@ -30,7 +30,7 @@
  * {@link AggregateRel} past a non-distinct {@link UnionRel}.
  */
 public class PushAggregateThroughUnionRule extends RelOptRule {
-  public static final PushAggregateThroughUnionRule instance =
+  public static final PushAggregateThroughUnionRule INSTANCE =
       new PushAggregateThroughUnionRule();
 
   /**

File: core/src/main/java/org/eigenbase/rel/rules/PushFilterIntoMultiJoinRule.java
Patch:
@@ -25,7 +25,7 @@
  * FilterRel} into a {@link MultiJoinRel}.
  */
 public class PushFilterIntoMultiJoinRule extends RelOptRule {
-  public static final PushFilterIntoMultiJoinRule instance =
+  public static final PushFilterIntoMultiJoinRule INSTANCE =
       new PushFilterIntoMultiJoinRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushFilterPastJoinRule.java
Patch:
@@ -111,7 +111,7 @@ protected void perform(RelOptRuleCall call, FilterRel filter, JoinRel join) {
     if (RelOptUtil.classifyFilters(
         join,
         aboveFilters,
-        (join.getJoinType() == JoinRelType.INNER),
+        join.getJoinType() == JoinRelType.INNER,
         !join.getJoinType().generatesNullsOnLeft(),
         !join.getJoinType().generatesNullsOnRight(),
         joinFilters,

File: core/src/main/java/org/eigenbase/rel/rules/PushFilterPastProjectRule.java
Patch:
@@ -26,7 +26,7 @@
  * past a {@link ProjectRel}.
  */
 public class PushFilterPastProjectRule extends RelOptRule {
-  public static final PushFilterPastProjectRule instance =
+  public static final PushFilterPastProjectRule INSTANCE =
       new PushFilterPastProjectRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushFilterPastSetOpRule.java
Patch:
@@ -30,7 +30,7 @@
  * past a {@link SetOpRel}.
  */
 public class PushFilterPastSetOpRule extends RelOptRule {
-  public static final PushFilterPastSetOpRule instance =
+  public static final PushFilterPastSetOpRule INSTANCE =
       new PushFilterPastSetOpRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushFilterPastTableFunctionRule.java
Patch:
@@ -30,7 +30,7 @@
  * {@link FilterRel} past a {@link TableFunctionRel}.
  */
 public class PushFilterPastTableFunctionRule extends RelOptRule {
-  public static final PushFilterPastTableFunctionRule instance =
+  public static final PushFilterPastTableFunctionRule INSTANCE =
       new PushFilterPastTableFunctionRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushProjectIntoMultiJoinRule.java
Patch:
@@ -26,7 +26,7 @@
  * input into the {@link ProjectRel}.
  */
 public class PushProjectIntoMultiJoinRule extends RelOptRule {
-  public static final PushProjectIntoMultiJoinRule instance =
+  public static final PushProjectIntoMultiJoinRule INSTANCE =
       new PushProjectIntoMultiJoinRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushProjectPastFilterRule.java
Patch:
@@ -26,7 +26,7 @@
  * filter.
  */
 public class PushProjectPastFilterRule extends RelOptRule {
-  public static final PushProjectPastFilterRule instance =
+  public static final PushProjectPastFilterRule INSTANCE =
       new PushProjectPastFilterRule(PushProjector.ExprCondition.FALSE);
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushProjectPastJoinRule.java
Patch:
@@ -30,7 +30,7 @@
  * the join.
  */
 public class PushProjectPastJoinRule extends RelOptRule {
-  public static final PushProjectPastJoinRule instance =
+  public static final PushProjectPastJoinRule INSTANCE =
       new PushProjectPastJoinRule(PushProjector.ExprCondition.FALSE);
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushProjectPastSetOpRule.java
Patch:
@@ -29,7 +29,7 @@
  * only the {@link RexInputRef}s referenced in the original {@link ProjectRel}.
  */
 public class PushProjectPastSetOpRule extends RelOptRule {
-  public static final PushProjectPastSetOpRule instance =
+  public static final PushProjectPastSetOpRule INSTANCE =
       new PushProjectPastSetOpRule(PushProjector.ExprCondition.FALSE);
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushSemiJoinPastFilterRule.java
Patch:
@@ -26,7 +26,7 @@
  * semijoins. SemiJoinRel(FilterRel(X), Y) --> FilterRel(SemiJoinRel(X, Y))
  */
 public class PushSemiJoinPastFilterRule extends RelOptRule {
-  public static final PushSemiJoinPastFilterRule instance =
+  public static final PushSemiJoinPastFilterRule INSTANCE =
       new PushSemiJoinPastFilterRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/PushSemiJoinPastJoinRule.java
Patch:
@@ -33,7 +33,7 @@
  * participate in the semijoin.
  */
 public class PushSemiJoinPastJoinRule extends RelOptRule {
-  public static final PushSemiJoinPastJoinRule instance =
+  public static final PushSemiJoinPastJoinRule INSTANCE =
       new PushSemiJoinPastJoinRule();
 
   //~ Constructors -----------------------------------------------------------
@@ -90,7 +90,7 @@ public void onMatch(RelOptRuleCall call) {
 
     // the keys must all originate from either the left or right;
     // otherwise, a semijoin wouldn't have been created
-    assert ((nKeysFromX == 0) || (nKeysFromX == leftKeys.size()));
+    assert (nKeysFromX == 0) || (nKeysFromX == leftKeys.size());
 
     // need to convert the semijoin condition and possibly the keys
     RexNode newSemiJoinFilter;

File: core/src/main/java/org/eigenbase/rel/rules/PushSemiJoinPastProjectRule.java
Patch:
@@ -33,7 +33,7 @@
  * <p>SemiJoinRel(ProjectRel(X), Y) --> ProjectRel(SemiJoinRel(X, Y))
  */
 public class PushSemiJoinPastProjectRule extends RelOptRule {
-  public static final PushSemiJoinPastProjectRule instance =
+  public static final PushSemiJoinPastProjectRule INSTANCE =
       new PushSemiJoinPastProjectRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/ReduceAggregatesRule.java
Patch:
@@ -38,7 +38,7 @@ public class ReduceAggregatesRule extends RelOptRule {
   /**
    * The singleton.
    */
-  public static final ReduceAggregatesRule instance =
+  public static final ReduceAggregatesRule INSTANCE =
       new ReduceAggregatesRule(operand(AggregateRel.class, any()));
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/ReduceExpressionsRule.java
Patch:
@@ -95,8 +95,8 @@ public void onMatch(RelOptRuleCall call) {
             if (newConditionExp instanceof RexCall) {
               RexCall rexCall = (RexCall) newConditionExp;
               boolean reverse =
-                  (rexCall.getOperator()
-                      == SqlStdOperatorTable.notOperator);
+                  rexCall.getOperator()
+                      == SqlStdOperatorTable.notOperator;
               if (reverse) {
                 rexCall = (RexCall) rexCall.getOperands().get(0);
               }
@@ -162,7 +162,7 @@ public void onMatch(RelOptRuleCall call) {
                     project.getChild(),
                     expList,
                     project.getRowType(),
-                    ProjectRel.Flags.Boxed));
+                    ProjectRel.Flags.BOXED));
 
             // New plan is absolutely better than old plan.
             call.getPlanner().setImportance(project, 0.0);

File: core/src/main/java/org/eigenbase/rel/rules/ReduceValuesRule.java
Patch:
@@ -43,7 +43,7 @@
 public abstract class ReduceValuesRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  private static final Logger tracer = EigenbaseTrace.getPlannerTracer();
+  private static final Logger LOGGER = EigenbaseTrace.getPlannerTracer();
 
   /**
    * Instance of this rule that applies to the pattern
@@ -104,7 +104,7 @@ public void onMatch(RelOptRuleCall call) {
    */
   private ReduceValuesRule(RelOptRuleOperand operand, String desc) {
     super(operand, desc);
-    Util.discard(tracer);
+    Util.discard(LOGGER);
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/RemoveDistinctRule.java
Patch:
@@ -25,7 +25,7 @@
  * underlying relational expression is already distinct.
  */
 public class RemoveDistinctRule extends RelOptRule {
-  public static final RemoveDistinctRule instance =
+  public static final RemoveDistinctRule INSTANCE =
       new RemoveDistinctRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/RemoveSemiJoinRule.java
Patch:
@@ -27,7 +27,7 @@
  * after attempts have been made to convert SemiJoinRels.
  */
 public class RemoveSemiJoinRule extends RelOptRule {
-  public static final RemoveSemiJoinRule instance =
+  public static final RemoveSemiJoinRule INSTANCE =
       new RemoveSemiJoinRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/RemoveTrivialCalcRule.java
Patch:
@@ -32,7 +32,7 @@
 public class RemoveTrivialCalcRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final RemoveTrivialCalcRule instance =
+  public static final RemoveTrivialCalcRule INSTANCE =
       new RemoveTrivialCalcRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/TableAccessRule.java
Patch:
@@ -23,16 +23,14 @@
 import org.eigenbase.relopt.*;
 import org.eigenbase.reltype.RelDataType;
 
-import net.hydromatic.optiq.prepare.Prepare;
-
 /**
  * TableAccessRule converts a TableAccessRel to the result of calling {@link
  * RelOptTable#toRel}.
  */
 public class TableAccessRule extends RelOptRule {
   //~ Static fields/initializers ---------------------------------------------
 
-  public static final TableAccessRule instance = new TableAccessRule();
+  public static final TableAccessRule INSTANCE = new TableAccessRule();
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/rel/rules/UnionEliminatorRule.java
Patch:
@@ -26,7 +26,7 @@
  * consists of only one input.
  */
 public class UnionEliminatorRule extends RelOptRule {
-  public static final UnionEliminatorRule instance =
+  public static final UnionEliminatorRule INSTANCE =
       new UnionEliminatorRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/rel/rules/UnionToDistinctRule.java
Patch:
@@ -26,7 +26,7 @@
  * of a non-distinct {@link UnionRel} (<code>all</code> = <code>true</code>).
  */
 public class UnionToDistinctRule extends RelOptRule {
-  public static final UnionToDistinctRule instance =
+  public static final UnionToDistinctRule INSTANCE =
       new UnionToDistinctRule();
 
   //~ Constructors -----------------------------------------------------------

File: core/src/main/java/org/eigenbase/relopt/Convention.java
Patch:
@@ -68,7 +68,7 @@ public String getName() {
     }
 
     public RelTraitDef getTraitDef() {
-      return ConventionTraitDef.instance;
+      return ConventionTraitDef.INSTANCE;
     }
   }
 }

File: core/src/main/java/org/eigenbase/relopt/RelOptCost.java
Patch:
@@ -131,7 +131,7 @@ public interface RelOptCost {
    * Forces implementations to override {@link Object#toString} and provide a
    * good cost rendering to use during tracing.
    */
-   String toString();
+  String toString();
 }
 
 // End RelOptCost.java

File: core/src/main/java/org/eigenbase/relopt/RelOptMaterialization.java
Patch:
@@ -184,8 +184,8 @@ private void match(RelNode left, Mappings.TargetMapping leftMapping,
    */
   public static RelNode toLeafJoinForm(RelNode rel) {
     HepProgram program = HepProgram.builder()
-        .addRuleInstance(PullUpProjectsAboveJoinRule.instanceRightProjectChild)
-        .addRuleInstance(PullUpProjectsAboveJoinRule.instanceLeftProjectChild)
+        .addRuleInstance(PullUpProjectsAboveJoinRule.RIGHT_PROJECT)
+        .addRuleInstance(PullUpProjectsAboveJoinRule.LEFT_PROJECT)
         .build();
     final HepPlanner planner =
         new HepPlanner(program);

File: core/src/main/java/org/eigenbase/relopt/RelOptPlanner.java
Patch:
@@ -36,7 +36,7 @@
 public interface RelOptPlanner {
   //~ Static fields/initializers ---------------------------------------------
 
-  Logger tracer = EigenbaseTrace.getPlannerTracer();
+  Logger LOGGER = EigenbaseTrace.getPlannerTracer();
 
   //~ Methods ----------------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/relopt/RelOptRuleCall.java
Patch:
@@ -33,12 +33,12 @@
 public abstract class RelOptRuleCall {
   //~ Static fields/initializers ---------------------------------------------
 
-  protected static final Logger tracer = EigenbaseTrace.getPlannerTracer();
+  protected static final Logger LOGGER = EigenbaseTrace.getPlannerTracer();
 
   /**
    * Generator for {@link #id} values.
    */
-  static int nextId = 0;
+  private static int NEXT_ID = 0;
 
   //~ Instance fields --------------------------------------------------------
 
@@ -72,7 +72,7 @@ protected RelOptRuleCall(
       RelNode[] rels,
       Map<RelNode, List<RelNode>> nodeChildren,
       List<RelNode> parents) {
-    this.id = nextId++;
+    this.id = NEXT_ID++;
     this.planner = planner;
     this.operand0 = operand;
     this.nodeChildren = nodeChildren;

File: core/src/main/java/org/eigenbase/relopt/RelOptSchema.java
Patch:
@@ -51,8 +51,7 @@ public interface RelOptSchema {
    * Registers all of the rules supported by this schema. Only called by
    * {@link RelOptPlanner#registerSchema}.
    */
-  void registerRules(RelOptPlanner planner)
-      throws Exception;
+  void registerRules(RelOptPlanner planner) throws Exception;
 }
 
 // End RelOptSchema.java

File: core/src/main/java/org/eigenbase/relopt/SubstitutionVisitor.java
Patch:
@@ -141,6 +141,7 @@ public void visit(RelNode node, int ordinal, RelNode parent) {
           super.visit(node, ordinal, parent);
         }
       }.go(ancestor);
+      // CHECKSTYLE: IGNORE -1
       return false;
     } catch (FoundRel e) {
       return true;

File: core/src/main/java/org/eigenbase/relopt/hep/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.relopt.hep;
 
 /**
  * Provides a heuristic planner implementation for the interfaces in
  * {@link org.eigenbase.relopt}.
  */
+package org.eigenbase.relopt.hep;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/relopt/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.relopt;
 
 /**
  * Defines interfaces for constructing rule-based optimizers of
  * relational expressions.
  */
+package org.eigenbase.relopt;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/relopt/volcano/AbstractConverter.java
Patch:
@@ -90,7 +90,7 @@ public RelWriter explainTerms(RelWriter pw) {
    * than infinite cost).</p>
    */
   public static class ExpandConversionRule extends RelOptRule {
-    public static final ExpandConversionRule instance =
+    public static final ExpandConversionRule INSTANCE =
         new ExpandConversionRule();
 
     /**

File: core/src/main/java/org/eigenbase/relopt/volcano/VolcanoRuleMatch.java
Patch:
@@ -50,7 +50,7 @@ class VolcanoRuleMatch extends VolcanoRuleCall {
     super(volcanoPlanner, operand0, rels.clone());
     this.volcanoPlanner = volcanoPlanner;
     for (int i = 0; i < rels.length; i++) {
-      assert (rels[i] != null);
+      assert rels[i] != null;
     }
 
     // Try to deduce which subset the result will belong to. Assume --

File: core/src/main/java/org/eigenbase/relopt/volcano/package-info.java
Patch:
@@ -15,7 +15,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.relopt.volcano;
 
 /**
  * Optimizes relational expressions.<p>&nbsp;</p>
@@ -271,5 +270,6 @@
  *     McKenna
  *     (1993)</a>.</p>
  */
+package org.eigenbase.relopt.volcano;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeField.java
Patch:
@@ -19,8 +19,6 @@
 
 import java.util.Map;
 
-import net.hydromatic.linq4j.expressions.Types;
-
 /**
  * RelDataTypeField represents the definition of a field in a structured {@link
  * RelDataType}.

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeFieldImpl.java
Patch:
@@ -39,8 +39,8 @@ public RelDataTypeFieldImpl(
       String name,
       int index,
       RelDataType type) {
-    assert (name != null);
-    assert (type != null);
+    assert name != null;
+    assert type != null;
     this.name = name;
     this.index = index;
     this.type = type;

File: core/src/main/java/org/eigenbase/reltype/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.reltype;
 
 /**
  * Defines a type system for relational expressions.
  */
+package org.eigenbase.reltype;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/resource/EigenbaseResource_en_US.java
Patch:
@@ -4,8 +4,6 @@
 package org.eigenbase.resource;
 
 import java.io.IOException;
-import java.util.Locale;
-import java.util.ResourceBundle;
 
 import org.eigenbase.resgen.*;
 

File: core/src/main/java/org/eigenbase/resource/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.resource;
 
 /**
  * Defines resources used for Eigenbase internationalization.
  */
+package org.eigenbase.resource;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/rex/RexChecker.java
Patch:
@@ -36,6 +36,7 @@
  * assert new RexChecker(rowType, true).isValid(node);</code></blockquote>
  *
  * This mode requires that assertions are enabled.</li>
+ *
  * <li>Use <code>fail=false</code> to test for validity without throwing an
  * error.
  *
@@ -45,8 +46,9 @@
  * node.accept(checker);<br/>
  * if (!checker.valid) {<br/>
  * &nbsp;&nbsp;&nbsp;...<br/>
- * }</br></code></blockquote>
+ * }</code></blockquote>
  * </li>
+ * </ul>
  *
  * @see RexNode
  */

File: core/src/main/java/org/eigenbase/rex/RexLiteral.java
Patch:
@@ -311,7 +311,7 @@ private static void printAsJava(
     case BINARY:
       assert value instanceof ByteString;
       pw.print("X'");
-      pw.print((((ByteString) value).toString(16)));
+      pw.print(((ByteString) value).toString(16));
       pw.print("'");
       break;
     case NULL:
@@ -352,7 +352,7 @@ private static void printDatetime(
       PrintWriter pw,
       ZonelessDatetime datetime,
       Comparable value) {
-    assert (value instanceof Calendar);
+    assert value instanceof Calendar;
     datetime.setZonelessTime(
         ((Calendar) value).getTimeInMillis());
     pw.print(datetime);

File: core/src/main/java/org/eigenbase/rex/RexOver.java
Patch:
@@ -135,7 +135,7 @@ public RexCall clone(RelDataType type, List<RexNode> operands) {
   //~ Inner Classes ----------------------------------------------------------
 
   private static class OverFound extends RuntimeException {
-    public static final OverFound instance = new OverFound();
+    public static final OverFound INSTANCE = new OverFound();
   }
 
   /**
@@ -151,7 +151,7 @@ public Finder() {
     }
 
     public Void visitOver(RexOver over) {
-      throw OverFound.instance;
+      throw OverFound.INSTANCE;
     }
   }
 }

File: core/src/main/java/org/eigenbase/rex/RexProgram.java
Patch:
@@ -555,7 +555,7 @@ public static void deduceCollations(
         targets[source] = i;
       }
     }
-    loop:
+  loop:
     for (RelCollation collation : inputCollations) {
       final ArrayList<RelFieldCollation> fieldCollations =
           new ArrayList<RelFieldCollation>(0);

File: core/src/main/java/org/eigenbase/rex/RexProgramBuilder.java
Patch:
@@ -405,7 +405,8 @@ private RelDataType computeOutputRowType() {
   }
 
   private void generateMissingNames() {
-    int i = -1, j = 0;
+    int i = -1;
+    int j = 0;
     for (String projectName : projectNameList) {
       ++i;
       if (projectName == null) {

File: core/src/main/java/org/eigenbase/rex/RexSqlStandardConvertletTable.java
Patch:
@@ -232,7 +232,7 @@ private void registerCaseOp(final SqlOperator op) {
           public SqlNode convertCall(
               RexToSqlNodeConverter converter,
               RexCall call) {
-            assert (op instanceof SqlCaseOperator);
+            assert op instanceof SqlCaseOperator;
             SqlNode[] operands =
                 convertExpressionList(converter, call.operands);
             if (operands == null) {

File: core/src/main/java/org/eigenbase/rex/RexUtil.java
Patch:
@@ -144,7 +144,7 @@ public static boolean isNullLiteral(
     if (node instanceof RexLiteral) {
       RexLiteral literal = (RexLiteral) node;
       if (literal.getTypeName() == SqlTypeName.NULL) {
-        assert (null == literal.getValue());
+        assert null == literal.getValue();
         return true;
       } else {
         // We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as

File: core/src/main/java/org/eigenbase/rex/package-info.java
Patch:
@@ -15,7 +15,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.rex;
 
 /**
  * Provides a language for representing row-expressions.
@@ -85,5 +84,6 @@
  *     </li>
  * </ul>
  */
+package org.eigenbase.rex;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/runtime/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.runtime;
 
 /**
  * Defines classes used by generated Eigenbase classes at runtime.
  */
+package org.eigenbase.runtime;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sarg/SargInterval.java
Patch:
@@ -62,13 +62,13 @@ public class SargInterval extends SargIntervalBase {
   //~ Methods ----------------------------------------------------------------
 
   void copyFrom(SargIntervalBase other) {
-    assert (getDataType() == other.getDataType());
+    assert getDataType() == other.getDataType();
     lowerBound.copyFrom(other.getLowerBound());
     upperBound.copyFrom(other.getUpperBound());
   }
 
   boolean contains(SargInterval other) {
-    assert (getDataType() == other.getDataType());
+    assert getDataType() == other.getDataType();
     if (getLowerBound().compareTo(other.getLowerBound()) > 0) {
       return false;
     }

File: core/src/main/java/org/eigenbase/sarg/SargIntervalBase.java
Patch:
@@ -86,7 +86,7 @@ public boolean isEmpty() {
    * @return whether this represents a (non-empty, non-point) range interval
    */
   public boolean isRange() {
-    return (!isPoint() && !isEmpty());
+    return !isPoint() && !isEmpty();
   }
 
   /**

File: core/src/main/java/org/eigenbase/sarg/SargIntervalExpr.java
Patch:
@@ -207,7 +207,7 @@ public SargIntervalSequence evaluateComplemented() {
       return seq;
     }
 
-    assert (originalSeq.getList().size() == 1);
+    assert originalSeq.getList().size() == 1;
     SargInterval originalInterval = originalSeq.getList().get(0);
 
     // Complement of universal set is empty set.
@@ -264,7 +264,7 @@ public SargIntervalSequence evaluateComplemented() {
       }
     } else {
       // Mirror image of previous case.
-      assert (originalInterval.getUpperBound().isFinite());
+      assert originalInterval.getUpperBound().isFinite();
       interval.setLower(
           originalInterval.getUpperBound().getCoordinate(),
           originalInterval.getUpperBound().getStrictnessComplement());

File: core/src/main/java/org/eigenbase/sarg/package-info.java
Patch:
@@ -15,12 +15,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sarg;
 
 /**
  * Provides a class library for representing arguments to index searches,
  * also known as <em>sargs</em>. Unit tests for this package are in
  * {@code org.eigenbase.test.SargTest}.
  */
+package org.eigenbase.sarg;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/SqlCollation.java
Patch:
@@ -84,7 +84,7 @@ public SqlCollation(
     strength = parseValues.getStrength();
     String c = charset.name().toUpperCase() + "$" + locale.toString();
     if ((strength != null) && (strength.length() > 0)) {
-      c += ("$" + strength);
+      c += "$" + strength;
     }
     collationName = c;
   }
@@ -174,8 +174,8 @@ public static String getCoercibilityDyadicComparison(
   protected static SqlCollation getCoercibilityDyadic(
       SqlCollation col1,
       SqlCollation col2) {
-    assert (null != col1);
-    assert (null != col2);
+    assert null != col1;
+    assert null != col2;
     final Coercibility coercibility1 = col1.getCoercibility();
     final Coercibility coercibility2 = col2.getCoercibility();
     switch (coercibility1) {

File: core/src/main/java/org/eigenbase/sql/SqlDataTypeSpec.java
Patch:
@@ -277,13 +277,13 @@ public RelDataType deriveType(RelDataTypeFactory typeFactory) {
     // to be assertions rather than user-level exceptions.
     RelDataType type;
     if ((precision >= 0) && (scale >= 0)) {
-      assert (sqlTypeName.allowsPrecScale(true, true));
+      assert sqlTypeName.allowsPrecScale(true, true);
       type = typeFactory.createSqlType(sqlTypeName, precision, scale);
     } else if (precision >= 0) {
-      assert (sqlTypeName.allowsPrecNoScale());
+      assert sqlTypeName.allowsPrecNoScale();
       type = typeFactory.createSqlType(sqlTypeName, precision);
     } else {
-      assert (sqlTypeName.allowsNoPrecNoScale());
+      assert sqlTypeName.allowsNoPrecNoScale();
       type = typeFactory.createSqlType(sqlTypeName);
     }
 

File: core/src/main/java/org/eigenbase/sql/SqlDialect.java
Patch:
@@ -322,8 +322,8 @@ public void quoteStringLiteralUnicode(StringBuilder buf, String val) {
   }
 
   private static final char[] hex = {
-      '0', '1', '2', '3', '4', '5', '6', '7',
-      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
+    '0', '1', '2', '3', '4', '5', '6', '7',
+    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
   };
 
   /**

File: core/src/main/java/org/eigenbase/sql/SqlJoinOperator.java
Patch:
@@ -127,10 +127,10 @@ public SqlCall createCall(
       SqlParserPos pos,
       SqlNode... operands) {
     assert functionQualifier == null;
-    assert (operands[SqlJoin.IS_NATURAL_OPERAND] instanceof SqlLiteral);
+    assert operands[SqlJoin.IS_NATURAL_OPERAND] instanceof SqlLiteral;
     final SqlLiteral isNatural =
         (SqlLiteral) operands[SqlJoin.IS_NATURAL_OPERAND];
-    assert (isNatural.getTypeName() == SqlTypeName.BOOLEAN);
+    assert isNatural.getTypeName() == SqlTypeName.BOOLEAN;
     assert operands[SqlJoin.CONDITION_TYPE_OPERAND] != null
         : "precondition: operands[CONDITION_TYPE_OPERAND] != null";
     assert (operands[SqlJoin.CONDITION_TYPE_OPERAND] instanceof SqlLiteral)

File: core/src/main/java/org/eigenbase/sql/SqlLiteral.java
Patch:
@@ -760,7 +760,7 @@ public SqlLiteral unescapeUnicode(char unicodeEscapeChar) {
     if (unicodeEscapeChar == 0) {
       return this;
     }
-    assert (SqlTypeUtil.inCharFamily(getTypeName()));
+    assert SqlTypeUtil.inCharFamily(getTypeName());
     NlsString ns = (NlsString) value;
     String s = ns.getValue();
     StringBuilder sb = new StringBuilder();

File: core/src/main/java/org/eigenbase/sql/SqlNumericLiteral.java
Patch:
@@ -117,7 +117,7 @@ public RelDataType createSqlType(RelDataTypeFactory typeFactory) {
   }
 
   public boolean isInteger() {
-    return (0 == scale.intValue());
+    return 0 == scale.intValue();
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/SqlOperator.java
Patch:
@@ -619,7 +619,7 @@ public SqlOperandTypeInference getOperandTypeInference() {
    * @return whether this operator is an aggregator
    */
   public boolean isAggregator() {
-    return (this instanceof SqlAggFunction);
+    return this instanceof SqlAggFunction;
   }
 
   /**

File: core/src/main/java/org/eigenbase/sql/SqlSelect.java
Patch:
@@ -152,7 +152,7 @@ public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
 
   public boolean hasOrderBy() {
     SqlNodeList orderList = getOrderList();
-    return ((null != orderList) && (0 != orderList.size()));
+    return (null != orderList) && (0 != orderList.size());
   }
 
   public boolean hasWhere() {

File: core/src/main/java/org/eigenbase/sql/SqlSyntax.java
Patch:
@@ -71,7 +71,7 @@ public void unparse(
         SqlNode[] operands,
         int leftPrec,
         int rightPrec) {
-      assert (operands.length == 1);
+      assert operands.length == 1;
       writer.keyword(operator.getName());
       operands[0].unparse(
           writer,
@@ -90,7 +90,7 @@ public void unparse(
         SqlNode[] operands,
         int leftPrec,
         int rightPrec) {
-      assert (operands.length == 1);
+      assert operands.length == 1;
       operands[0].unparse(
           writer,
           operator.getLeftPrec(),

File: core/src/main/java/org/eigenbase/sql/SqlTimeLiteral.java
Patch:
@@ -76,7 +76,7 @@ public String toFormattedString() {
     String result = getTime().toString(formatString);
     final Calendar cal = getCal();
     if (precision > 0) {
-      assert (precision <= 3);
+      assert precision <= 3;
 
       // get the millisecond count.  millisecond => at most 3 digits.
       String digits = Long.toString(cal.getTimeInMillis());
@@ -85,7 +85,7 @@ public String toFormattedString() {
           + digits.substring(digits.length() - 3,
               digits.length() - 3 + precision);
     } else {
-      assert (0 == cal.get(Calendar.MILLISECOND));
+      assert 0 == cal.get(Calendar.MILLISECOND);
     }
     return result;
   }

File: core/src/main/java/org/eigenbase/sql/SqlTimestampLiteral.java
Patch:
@@ -98,7 +98,7 @@ public String toFormattedString() {
     String result = getTimestamp().toString(formatString);
     final Calendar cal = getCal();
     if (precision > 0) {
-      assert (precision <= 3);
+      assert precision <= 3;
 
       // get the millisecond count.  millisecond => at most 3 digits.
       String digits = Long.toString(cal.getTimeInMillis());
@@ -107,7 +107,7 @@ public String toFormattedString() {
           + digits.substring(digits.length() - 3,
               digits.length() - 3 + precision);
     } else {
-      assert (0 == cal.get(Calendar.MILLISECOND));
+      assert 0 == cal.get(Calendar.MILLISECOND);
     }
     return result;
   }

File: core/src/main/java/org/eigenbase/sql/SqlUpdate.java
Patch:
@@ -57,7 +57,7 @@ public SqlUpdate(
     operands[TARGET_COLUMN_LIST_OPERAND] = targetColumnList;
     operands[CONDITION_OPERAND] = condition;
     operands[ALIAS_OPERAND] = alias;
-    assert (sourceExpressionList.size() == targetColumnList.size());
+    assert sourceExpressionList.size() == targetColumnList.size();
   }
 
   //~ Methods ----------------------------------------------------------------

File: core/src/main/java/org/eigenbase/sql/SqlWindowOperator.java
Patch:
@@ -409,7 +409,7 @@ private void validateFrameBoundary(
     case OTHER:
     case FOLLOWING:
     case PRECEDING:
-      assert (bound instanceof SqlCall);
+      assert bound instanceof SqlCall;
       final SqlNode boundVal = ((SqlCall) bound).getOperands()[0];
 
       // Boundries must be a constant

File: core/src/main/java/org/eigenbase/sql/advise/SqlSimpleParser.java
Patch:
@@ -190,7 +190,7 @@ private void consumeSelect(ListIterator<Token> iter, List<Token> outList) {
     boolean isQuery = false;
     int start = outList.size();
     List<Token> subqueryList = new ArrayList<Token>();
-    loop:
+  loop:
     while (iter.hasNext()) {
       Token token = iter.next();
       subqueryList.add(token);

File: core/src/main/java/org/eigenbase/sql/advise/package-info.java
Patch:
@@ -15,7 +15,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.advise;
 
 /**
  * Provides hints and corrections for editing SQL statements.
@@ -26,5 +25,6 @@
  * <p>The advisor uses the validation and parser framework set up in
  * <code>org.eigenbase.sql.validate</code> package.
 */
+package org.eigenbase.sql.advise;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/fun/SqlAbstractTimeFunction.java
Patch:
@@ -67,7 +67,7 @@ public RelDataType inferReturnType(
         precision = opBinding.getIntLiteralOperand(0);
       }
     }
-    assert (precision >= 0);
+    assert precision >= 0;
     if (precision > SqlTypeName.MAX_DATETIME_PRECISION) {
       throw opBinding.newError(
           EigenbaseResource.instance().ArgumentMustBeValidPrecision.ex(

File: core/src/main/java/org/eigenbase/sql/fun/SqlCaseOperator.java
Patch:
@@ -171,7 +171,7 @@ public boolean checkOperandTypes(
     SqlCase caseCall = (SqlCase) callBinding.getCall();
     SqlNodeList whenList = caseCall.getWhenOperands();
     SqlNodeList thenList = caseCall.getThenOperands();
-    assert (whenList.size() == thenList.size());
+    assert whenList.size() == thenList.size();
 
     // checking that search conditions are ok...
     for (SqlNode node : whenList) {

File: core/src/main/java/org/eigenbase/sql/fun/SqlCastFunction.java
Patch:
@@ -116,7 +116,7 @@ private boolean isMonotonicPreservingCast(
 
   public RelDataType inferReturnType(
       SqlOperatorBinding opBinding) {
-    assert (opBinding.getOperandCount() == 2);
+    assert opBinding.getOperandCount() == 2;
     RelDataType ret = opBinding.getOperandType(1);
     RelDataType firstType = opBinding.getOperandType(0);
     ret =

File: core/src/main/java/org/eigenbase/sql/fun/SqlConvertFunction.java
Patch:
@@ -55,7 +55,7 @@ public String getSignatureTemplate(final int operandsCount) {
     case 2:
       return "{0}({1} USING {2})";
     }
-    assert (false);
+    assert false;
     return null;
   }
 }

File: core/src/main/java/org/eigenbase/sql/fun/SqlFirstLastValueAggFunction.java
Patch:
@@ -39,7 +39,7 @@ public class SqlFirstLastValueAggFunction extends SqlAggFunction {
 
   public SqlFirstLastValueAggFunction(boolean firstFlag) {
     super(
-        (firstFlag) ? "FIRST_VALUE" : "LAST_VALUE",
+        firstFlag ? "FIRST_VALUE" : "LAST_VALUE",
         SqlKind.OTHER_FUNCTION,
         SqlTypeStrategies.rtiFirstArgType,
         null,

File: core/src/main/java/org/eigenbase/sql/fun/SqlInOperator.java
Patch:
@@ -72,7 +72,7 @@ public RelDataType deriveType(
       SqlValidatorScope scope,
       SqlCall call) {
     final SqlNode[] operands = call.getOperands();
-    assert (operands.length == 2);
+    assert operands.length == 2;
 
     final RelDataTypeFactory typeFactory = validator.getTypeFactory();
     RelDataType leftType = validator.deriveType(scope, operands[0]);

File: core/src/main/java/org/eigenbase/sql/fun/SqlLiteralChainOperator.java
Patch:
@@ -107,7 +107,7 @@ public RelDataType inferReturnType(
     int size = 0;
     for (RelDataType type : opBinding.collectOperandTypes()) {
       size += type.getPrecision();
-      assert (type.getSqlTypeName().equals(typeName));
+      assert type.getSqlTypeName().equals(typeName);
     }
     return opBinding.getTypeFactory().createSqlType(typeName, size);
   }

File: core/src/main/java/org/eigenbase/sql/fun/SqlNullifFunction.java
Patch:
@@ -54,7 +54,7 @@ public SqlNode rewriteCall(SqlValidator validator, SqlCall call) {
         validator,
         getOperandTypeChecker(),
         call);
-    assert (operands.length == 2);
+    assert operands.length == 2;
 
     SqlNodeList whenList = new SqlNodeList(pos);
     SqlNodeList thenList = new SqlNodeList(pos);

File: core/src/main/java/org/eigenbase/sql/fun/SqlOverlayFunction.java
Patch:
@@ -70,7 +70,7 @@ public String getSignatureTemplate(final int operandsCount) {
     case 4:
       return "{0}({1} PLACING {2} FROM {3} FOR {4})";
     }
-    assert (false);
+    assert false;
     return null;
   }
 }

File: core/src/main/java/org/eigenbase/sql/fun/SqlSubstringFunction.java
Patch:
@@ -84,7 +84,7 @@ public boolean checkOperandTypes(
     SqlValidatorScope scope = callBinding.getScope();
 
     int n = call.operands.length;
-    assert ((3 == n) || (2 == n));
+    assert (3 == n) || (2 == n);
     if (!SqlTypeStrategies.otcString.checkSingleOperandType(
         callBinding,
         call.operands[0],

File: core/src/main/java/org/eigenbase/sql/fun/SqlTrimFunction.java
Patch:
@@ -116,9 +116,9 @@ public SqlCall createCall(
       // This variant occurs when someone writes TRIM(string)
       // as opposed to the sugared syntax TRIM(string FROM string).
       operands = new SqlNode[]{
-          SqlLiteral.createSymbol(Flag.BOTH, SqlParserPos.ZERO),
-          SqlLiteral.createCharString(" ", pos),
-          operands[0]
+        SqlLiteral.createSymbol(Flag.BOTH, SqlParserPos.ZERO),
+        SqlLiteral.createCharString(" ", pos),
+        operands[0]
       };
       break;
     case 3:

File: core/src/main/java/org/eigenbase/sql/fun/package-info.java
Patch:
@@ -15,7 +15,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.fun;
 
 /**
  * Defines the set of standard SQL row-level functions and
@@ -29,5 +28,6 @@
  * which are not row-level (e.g. select and join) should be defined in package
  * {@link org.eigenbase.sql} instead.</p>
  */
+package org.eigenbase.sql.fun;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/package-info.java
Patch:
@@ -15,7 +15,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql;
 
 /**
  * Provides an SQL parser and object model. This package, and the dependent
@@ -98,5 +97,6 @@
  *     happens.</p>
  *
  */
+package org.eigenbase.sql;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/parser/SqlAbstractParserImpl.java
Patch:
@@ -550,8 +550,7 @@ private void initList(
      */
     private Object virtualCall(
         SqlAbstractParserImpl parserImpl,
-        String name)
-        throws Throwable {
+        String name) throws Throwable {
       Class<?> clazz = parserImpl.getClass();
       try {
         final Method method = clazz.getMethod(name, (Class[]) null);

File: core/src/main/java/org/eigenbase/sql/parser/impl/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.parser.impl;
 
 /**
  * Contains generated code for the
  * {@link org.eigenbase.sql.parser Eigenbase SQL parser}.
  */
+package org.eigenbase.sql.parser.impl;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/parser/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.parser;
 
 /**
  * Provides a SQL parser.
  */
+package org.eigenbase.sql.parser;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/pretty/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.pretty;
 
 /**
  * Provides a pretty-printer for SQL statements.
  */
+package org.eigenbase.sql.pretty;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/type/ArraySqlType.java
Patch:
@@ -19,7 +19,6 @@
 
 import org.eigenbase.reltype.RelDataType;
 import org.eigenbase.reltype.RelDataTypeFamily;
-import org.eigenbase.util.Util;
 
 /**
  * SQL array type.

File: core/src/main/java/org/eigenbase/sql/type/CompositeOperandTypeChecker.java
Patch:
@@ -242,7 +242,7 @@ public boolean checkSingleOperandType(
       ret = typeErrorCount == 0;
       break;
     case OR:
-      ret = (typeErrorCount < allowedRules.size());
+      ret = typeErrorCount < allowedRules.size();
       break;
     default:
       // should never come here
@@ -274,7 +274,7 @@ public boolean checkOperandTypes(
       boolean throwOnFailure) {
     int typeErrorCount = 0;
 
-    label:
+  label:
     for (Ord<SqlSingleOperandTypeChecker> ord : Ord.zip(allowedRules)) {
       SqlSingleOperandTypeChecker rule = ord.e;
 
@@ -306,7 +306,7 @@ public boolean checkOperandTypes(
       failed = typeErrorCount > 0;
       break;
     case OR:
-      failed = (typeErrorCount == allowedRules.size());
+      failed = typeErrorCount == allowedRules.size();
       break;
     default:
       throw new AssertionError();

File: core/src/main/java/org/eigenbase/sql/type/JavaToSqlTypeConversionRules.java
Patch:
@@ -31,7 +31,7 @@
 public class JavaToSqlTypeConversionRules {
   //~ Static fields/initializers ---------------------------------------------
 
-  private static final JavaToSqlTypeConversionRules instance =
+  private static final JavaToSqlTypeConversionRules INSTANCE =
       new JavaToSqlTypeConversionRules();
 
   //~ Instance fields --------------------------------------------------------
@@ -77,7 +77,7 @@ public class JavaToSqlTypeConversionRules {
    * singleton} instance.
    */
   public static JavaToSqlTypeConversionRules instance() {
-    return instance;
+    return INSTANCE;
   }
 
   /**

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeUtil.java
Patch:
@@ -405,7 +405,7 @@ public static boolean isExactNumeric(RelDataType type) {
    * Returns the maximum value of an integral type, as a long value
    */
   public static long maxValue(RelDataType type) {
-    assert (SqlTypeUtil.isIntType(type));
+    assert SqlTypeUtil.isIntType(type);
     switch (type.getSqlTypeName()) {
     case TINYINT:
       return Byte.MAX_VALUE;
@@ -858,7 +858,7 @@ public static boolean needsNullIndicator(RelDataType recordType) {
     // no null indicator is required for structured type columns declared
     // as NOT NULL.  However, the uniformity of always having a null
     // indicator makes things cleaner in many places.
-    return (recordType.getSqlTypeName() == SqlTypeName.STRUCTURED);
+    return recordType.getSqlTypeName() == SqlTypeName.STRUCTURED;
   }
 
   private static boolean flattenFields(
@@ -934,7 +934,7 @@ public static SqlDataTypeSpec convertTypeToSpec(RelDataType type) {
 
     // TODO jvs 28-Dec-2004:  support row types, user-defined types,
     // interval types, multiset types, etc
-    assert (typeName != null);
+    assert typeName != null;
     SqlIdentifier typeIdentifier =
         new SqlIdentifier(
             typeName.name(),

File: core/src/main/java/org/eigenbase/sql/type/TableFunctionReturnTypeInference.java
Patch:
@@ -86,7 +86,7 @@ public RelDataType inferReturnType(
           ++iCursor;
         }
       }
-      assert (paramOrdinal != -1);
+      assert paramOrdinal != -1;
 
       // Translate to actual argument type.
       boolean isRowOp = false;
@@ -99,7 +99,7 @@ public RelDataType inferReturnType(
                 paramOrdinal,
                 fieldName,
                 columnNames);
-        assert (parentCursorName != null);
+        assert parentCursorName != null;
         paramOrdinal = -1;
         iCursor = 0;
         for (int i = 0; i < paramNames.size(); ++i) {
@@ -113,7 +113,7 @@ public RelDataType inferReturnType(
           }
         }
         cursorType = opBinding.getCursorOperand(paramOrdinal);
-        assert (cursorType != null);
+        assert cursorType != null;
       }
 
       // And expand. Function output is always nullable... except system

File: core/src/main/java/org/eigenbase/sql/type/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.type;
 
 /**
  * SQL type system.
  */
+package org.eigenbase.sql.type;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/util/SqlBasicVisitor.java
Patch:
@@ -88,7 +88,7 @@ public static class ArgHandlerImpl<R> implements ArgHandler<R> {
     // REVIEW jvs 16-June-2006:  This doesn't actually work, because it
     // is type-erased, and if you try to add <R>, you get the error
     // "non-static class R cannot be referenced from a static context."
-    public static final ArgHandler instance = new ArgHandlerImpl();
+    public static final ArgHandler INSTANCE = new ArgHandlerImpl();
 
     public R result() {
       return null;

File: core/src/main/java/org/eigenbase/sql/util/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.util;
 
 /**
  * Utility classes for the SQL object model, parsing, and validation.
  */
+package org.eigenbase.sql.util;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql/validate/AggChecker.java
Patch:
@@ -143,7 +143,7 @@ public Void visit(SqlCall call) {
         this,
         call,
         true,
-        ArgHandlerImpl.instance);
+        ArgHandlerImpl.INSTANCE);
 
     // Restore scope.
     scopes.pop();

File: core/src/main/java/org/eigenbase/sql/validate/SelectScope.java
Patch:
@@ -153,7 +153,7 @@ public SqlMonotonicity getMonotonicity(SqlNode expr) {
 
     // TODO: compare fully qualified names
     final SqlNodeList orderList = getOrderList();
-    if ((orderList.size() > 0)) {
+    if (orderList.size() > 0) {
       SqlNode order0 = orderList.get(0);
       monotonicity = SqlMonotonicity.Increasing;
       if ((order0 instanceof SqlCall)

File: core/src/main/java/org/eigenbase/sql/validate/SqlMonikerComparator.java
Patch:
@@ -32,7 +32,7 @@ public int compare(SqlMoniker m1, SqlMoniker m2) {
     } else if (m1.getType().ordinal() < m2.getType().ordinal()) {
       return -1;
     } else {
-      return (m1.toString().compareTo(m2.toString()));
+      return m1.toString().compareTo(m2.toString());
     }
   }
 }

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorException.java
Patch:
@@ -36,7 +36,7 @@ public class SqlValidatorException extends Exception
     implements EigenbaseValidatorException {
   //~ Static fields/initializers ---------------------------------------------
 
-  private static Logger tracer =
+  private static final Logger LOGGER =
       Logger.getLogger("org.eigenbase.util.EigenbaseException");
 
   static final long serialVersionUID = -831683113957131387L;
@@ -55,8 +55,8 @@ public SqlValidatorException(
     super(message, cause);
 
     // TODO: see note in EigenbaseException constructor
-    tracer.throwing("SqlValidatorException", "constructor", this);
-    tracer.severe(toString());
+    LOGGER.throwing("SqlValidatorException", "constructor", this);
+    LOGGER.severe(toString());
   }
 }
 

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorUtil.java
Patch:
@@ -105,8 +105,8 @@ public static void checkCharsetAndCollateConsistentIfCharType(
     if (SqlTypeUtil.inCharFamily(type)) {
       Charset strCharset = type.getCharset();
       Charset colCharset = type.getCollation().getCharset();
-      assert (null != strCharset);
-      assert (null != colCharset);
+      assert null != strCharset;
+      assert null != colCharset;
       if (!strCharset.equals(colCharset)) {
         if (false) {
           // todo: enable this checking when we have a charset to

File: core/src/main/java/org/eigenbase/sql/validate/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql.validate;
 
 /**
  * SQL validation.
  */
+package org.eigenbase.sql.validate;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/sql2rel/RelFieldTrimmer.java
Patch:
@@ -536,8 +536,8 @@ public TrimResult trimFields(
 
       // Move offset to point to start of next input.
       offset += inputFieldCount;
-      newFieldCount
-          += inputMapping.getTargetCount() + inputExtraFields.size();
+      newFieldCount +=
+          inputMapping.getTargetCount() + inputExtraFields.size();
     }
 
     Mapping mapping =

File: core/src/main/java/org/eigenbase/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -113,7 +113,7 @@ public void updateRelInMap(
       CorrelatorRel oldRel = mapCorVarToCorRel.get(corVar);
       if (oldToNewRelMap.containsKey(oldRel)) {
         RelNode newRel = oldToNewRelMap.get(oldRel);
-        assert (newRel instanceof CorrelatorRel);
+        assert newRel instanceof CorrelatorRel;
         mapCorVarToCorRel.put(corVar, (CorrelatorRel) newRel);
       }
     }
@@ -225,7 +225,7 @@ protected RelNode getNewForOldRel(RelNode oldRel) {
    * @return Post-flattening ordinal
    */
   protected int getNewForOldInput(int oldOrdinal) {
-    assert (currentRel != null);
+    assert currentRel != null;
     int newOrdinal = 0;
 
     // determine which input rel oldOrdinal references, and adjust
@@ -242,7 +242,7 @@ protected int getNewForOldInput(int oldOrdinal) {
       newOrdinal += newInput.getRowType().getFieldCount();
       oldOrdinal -= n;
     }
-    assert (oldInput != null);
+    assert oldInput != null;
 
     RelDataType oldInputType = oldInput.getRowType();
     newOrdinal += calculateFlattenedOffset(oldInputType, oldOrdinal);

File: core/src/main/java/org/eigenbase/sql2rel/StandardConvertletTable.java
Patch:
@@ -240,7 +240,7 @@ public RexNode convertCase(
       SqlCase call) {
     SqlNodeList whenList = call.getWhenOperands();
     SqlNodeList thenList = call.getThenOperands();
-    assert (whenList.size() == thenList.size());
+    assert whenList.size() == thenList.size();
 
     final List<RexNode> exprList = new ArrayList<RexNode>();
     for (int i = 0; i < whenList.size(); i++) {
@@ -354,7 +354,7 @@ protected RexNode convertCast(
         RexLiteral sourceInterval =
             (RexLiteral) cx.convertExpression(node);
         BigDecimal sourceValue =
-            ((BigDecimal) sourceInterval.getValue());
+            (BigDecimal) sourceInterval.getValue();
         RexLiteral castedInterval =
             cx.getRexBuilder().makeIntervalLiteral(
                 sourceValue.multiply(

File: core/src/main/java/org/eigenbase/sql2rel/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.sql2rel;
 
 /**
  * Translates a SQL parse tree to relational expression.
  */
+package org.eigenbase.sql2rel;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/stat/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.stat;
 
 /**
  * Defines interfaces related to statistics about data sets produced by
  * relational expressions.
  */
+package org.eigenbase.stat;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/trace/EigenbaseLogger.java
Patch:
@@ -41,7 +41,7 @@ public class EigenbaseLogger {
   //~ Constructors -----------------------------------------------------------
 
   public EigenbaseLogger(Logger logger) {
-    assert (logger != null);
+    assert logger != null;
     this.logger = logger;
   }
 

File: core/src/main/java/org/eigenbase/trace/EigenbaseTrace.java
Patch:
@@ -60,7 +60,7 @@ public abstract class EigenbaseTrace {
   public static final Logger parserTracer = getParserTracer();
 
   private static final ThreadLocal<Function2<Void, File, String>>
-      DYNAMIC_HANDLER =
+  DYNAMIC_HANDLER =
       new ThreadLocal<Function2<Void, File, String>>() {
         @Override
         protected Function2<Void, File, String> initialValue() {

File: core/src/main/java/org/eigenbase/trace/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.trace;
 
 /**
  * Tracing services.
  */
+package org.eigenbase.trace;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/util/ArrayQueue.java
Patch:
@@ -299,7 +299,7 @@ public boolean equals(Object o) {
    *                   #size()}.
    */
   private void copyQueueToArray(E[] otherQueue) {
-    assert (otherQueue.length >= size());
+    assert otherQueue.length >= size();
 
     if (end < start) {
       System.arraycopy(queue, start, otherQueue, 0, capacity - start);

File: core/src/main/java/org/eigenbase/util/BarfingInvocationHandler.java
Patch:
@@ -41,8 +41,7 @@ protected BarfingInvocationHandler() {
   public Object invoke(
       Object proxy,
       Method method,
-      Object[] args)
-      throws Throwable {
+      Object[] args) throws Throwable {
     Class clazz = getClass();
     Method matchingMethod = null;
     try {

File: core/src/main/java/org/eigenbase/util/BitString.java
Patch:
@@ -44,8 +44,8 @@ public class BitString {
   //~ Static fields/initializers ---------------------------------------------
 
   private static final char[] Hexits = {
-      '0', '1', '2', '3', '4', '5', '6', '7',
-      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
+    '0', '1', '2', '3', '4', '5', '6', '7',
+    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
   };
 
   //~ Instance fields --------------------------------------------------------

File: core/src/main/java/org/eigenbase/util/ChunkList.java
Patch:
@@ -218,7 +218,7 @@ public E next() {
           chunk = first;
         } else {
           chunk = ChunkList.next(chunk);
-          startIndex += (end - HEADER_SIZE);
+          startIndex += end - HEADER_SIZE;
         }
         if (chunk == null) {
           throw new NoSuchElementException();
@@ -294,7 +294,7 @@ public void remove() {
       if (offset == end) {
         final Object[] next = ChunkList.next(chunk);
         if (next != null) {
-          startIndex += (end - HEADER_SIZE);
+          startIndex += end - HEADER_SIZE;
           chunk = next;
           offset = HEADER_SIZE - 1;
           end = HEADER_SIZE + occupied(next);

File: core/src/main/java/org/eigenbase/util/DelegatingInvocationHandler.java
Patch:
@@ -54,8 +54,7 @@ public abstract class DelegatingInvocationHandler implements InvocationHandler {
   public Object invoke(
       Object proxy,
       Method method,
-      Object[] args)
-      throws Throwable {
+      Object[] args) throws Throwable {
     Class clazz = getClass();
     Method matchingMethod;
     try {

File: core/src/main/java/org/eigenbase/util/EigenbaseContextException.java
Patch:
@@ -78,7 +78,7 @@ public EigenbaseContextException(
       int endPosLine,
       int endPosColumn) {
     super(message, cause);
-    assert (cause != null);
+    assert cause != null;
     setPosition(posLine, posColumn, endPosLine, endPosColumn);
   }
 

File: core/src/main/java/org/eigenbase/util/EigenbaseException.java
Patch:
@@ -39,7 +39,7 @@ public class EigenbaseException extends RuntimeException {
    */
   private static final long serialVersionUID = -1314522633397794178L;
 
-  private static Logger tracer =
+  private static final Logger LOGGER =
       Logger.getLogger(EigenbaseException.class.getName());
 
   //~ Constructors -----------------------------------------------------------
@@ -57,8 +57,8 @@ public EigenbaseException(
 
     // TODO: Force the caller to pass in a Logger as a trace argument for
     // better context.  Need to extend ResGen for this.
-    tracer.throwing("EigenbaseException", "constructor", this);
-    tracer.severe(toString());
+    LOGGER.throwing("EigenbaseException", "constructor", this);
+    LOGGER.severe(toString());
   }
 }
 

File: core/src/main/java/org/eigenbase/util/MainApp.java
Patch:
@@ -55,8 +55,7 @@ protected MainApp(String[] args) {
    * method; they can throw any exception they like, and {@link #run} will
    * clean up after them.
    */
-  public abstract void mainImpl()
-      throws Exception;
+  public abstract void mainImpl() throws Exception;
 
   /**
    * Does the work of the application, handles any errors, then calls {@link

File: core/src/main/java/org/eigenbase/util/NlsString.java
Patch:
@@ -57,7 +57,7 @@ public NlsString(
       String value,
       String charsetName,
       SqlCollation collation)
-      throws IllegalCharsetNameException, UnsupportedCharsetException {
+    throws IllegalCharsetNameException, UnsupportedCharsetException {
     Util.pre(value != null, "theString != null");
     if (null != charsetName) {
       charsetName = charsetName.toUpperCase();

File: core/src/main/java/org/eigenbase/util/ReflectUtil.java
Patch:
@@ -94,7 +94,7 @@ public abstract class ReflectUtil {
    * @return corresponding method
    */
   public static Method getByteBufferReadMethod(Class clazz) {
-    assert (clazz.isPrimitive());
+    assert clazz.isPrimitive();
     return primitiveToByteBufferReadMethod.get(clazz);
   }
 
@@ -106,7 +106,7 @@ public static Method getByteBufferReadMethod(Class clazz) {
    * @return corresponding method
    */
   public static Method getByteBufferWriteMethod(Class clazz) {
-    assert (clazz.isPrimitive());
+    assert clazz.isPrimitive();
     return primitiveToByteBufferWriteMethod.get(clazz);
   }
 
@@ -118,7 +118,7 @@ public static Method getByteBufferWriteMethod(Class clazz) {
    * @return corresponding boxing Class (e.g. java.lang.Integer)
    */
   public static Class getBoxingClass(Class primitiveClass) {
-    assert (primitiveClass.isPrimitive());
+    assert primitiveClass.isPrimitive();
     return primitiveToBoxingMap.get(primitiveClass);
   }
 

File: core/src/main/java/org/eigenbase/util/SerializableCharset.java
Patch:
@@ -55,16 +55,15 @@ private SerializableCharset(Charset charset) {
   /**
    * Per {@link Serializable}.
    */
-  private void writeObject(ObjectOutputStream out)
-      throws IOException {
+  private void writeObject(ObjectOutputStream out) throws IOException {
     out.writeObject(charset.name());
   }
 
   /**
    * Per {@link Serializable}.
    */
   private void readObject(ObjectInputStream in)
-      throws IOException, ClassNotFoundException {
+    throws IOException, ClassNotFoundException {
     charsetName = (String) in.readObject();
     charset = Charset.availableCharsets().get(this.charsetName);
   }

File: core/src/main/java/org/eigenbase/util/mapping/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.util.mapping;
 
 /**
  * Support for algebraic maps.
  */
+package org.eigenbase.util.mapping;
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/util/package-info.java
Patch:
@@ -15,10 +15,10 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.util;
-
 /**
  * Provides utility classes.
  */
+package org.eigenbase.util;
+
 
 // End package-info.java

File: core/src/main/java/org/eigenbase/util14/DateTimeUtil.java
Patch:
@@ -119,7 +119,7 @@ private static Calendar parseDateFormat(
       String pattern,
       TimeZone tz,
       ParsePosition pp) {
-    assert (pattern != null);
+    assert pattern != null;
     SimpleDateFormat df = new SimpleDateFormat(pattern);
     if (tz == null) {
       tz = defaultZone;
@@ -153,7 +153,7 @@ public static Calendar parseDateFormat(
       String s,
       String pattern,
       TimeZone tz) {
-    assert (pattern != null);
+    assert pattern != null;
     ParsePosition pp = new ParsePosition(0);
     Calendar ret = parseDateFormat(s, pattern, tz, pp);
     if (pp.getIndex() != s.length()) {
@@ -230,7 +230,7 @@ public static PrecisionTime parsePrecisionDateTimeLiteral(
       }
     }
 
-    assert (pp.getIndex() == s.length());
+    assert pp.getIndex() == s.length();
     PrecisionTime ret = new PrecisionTime(cal, p);
     return ret;
   }

File: core/src/main/java/org/eigenbase/util14/NumberUtil.java
Patch:
@@ -138,7 +138,7 @@ public static boolean isValidDecimal(BigDecimal bd) {
   }
 
   public static NumberFormat getApproxFormatter(boolean isFloat) {
-    return (isFloat) ? floatFormatter : doubleFormatter;
+    return isFloat ? floatFormatter : doubleFormatter;
   }
 
   public static long round(double d) {

File: core/src/main/java/org/eigenbase/util14/package-info.java
Patch:
@@ -15,11 +15,11 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 */
-package org.eigenbase.util14;
 
 /**
  * Provides utility classes for use from code which must remain
  * source-compatible with JDK 1.4.
  */
+package org.eigenbase.util14;
 
 // End package-info.java

File: core/src/test/java/net/hydromatic/optiq/impl/clone/ArrayTableTest.java
Patch:
@@ -23,8 +23,6 @@
 import net.hydromatic.optiq.jdbc.JavaTypeFactoryImpl;
 
 import org.eigenbase.reltype.RelDataType;
-import org.eigenbase.reltype.RelDataTypeFactory;
-
 import org.eigenbase.reltype.RelDataTypeImpl;
 
 import org.junit.Test;
@@ -45,7 +43,7 @@ public class ArrayTableTest {
     assertEquals(0xF0F, values[0]);
 
     values = new long[]{
-        0x1213141516171819L, 0x232425262728292AL, 0x3435363738393A3BL};
+      0x1213141516171819L, 0x232425262728292AL, 0x3435363738393A3BL};
     assertEquals(
         0x324, ArrayTable.BitSlicedPrimitiveArray.getLong(12, values, 9));
     assertEquals(

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeImpl.java
Patch:
@@ -25,6 +25,7 @@
 import org.eigenbase.sql.parser.*;
 import org.eigenbase.sql.type.*;
 import org.eigenbase.util.Pair;
+import org.eigenbase.util.Util;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
@@ -76,7 +77,7 @@ protected RelDataTypeImpl() {
   // implement RelDataType
   public RelDataTypeField getField(String fieldName, boolean caseSensitive) {
     for (RelDataTypeField field : fieldList) {
-      if (field.getName().equals(fieldName)) {
+      if (Util.match(caseSensitive, field.getName(), fieldName)) {
         return field;
       }
     }

File: core/src/test/java/org/eigenbase/test/SqlValidatorTest.java
Patch:
@@ -5718,10 +5718,10 @@ public void _testGroupExpressionEquivalenceParams() {
 
     checkWholeExpFails(
         "(timestamp '1-2-3 4:5:6', timestamp '1-2-3 4:5:6' ) overlaps (time '4:5:6', interval '1 2:3:4.5' day to second)",
-        "(?s).*Cannot apply 'OVERLAPS' to arguments of type '.<TIMESTAMP>, <TIMESTAMP>. OVERLAPS .<TIME.0.>, <INTERVAL DAY TO SECOND>.*");
+        "(?s).*Cannot apply 'OVERLAPS' to arguments of type '.<TIMESTAMP.0.>, <TIMESTAMP.0.>. OVERLAPS .<TIME.0.>, <INTERVAL DAY TO SECOND>.*");
     checkWholeExpFails(
         "(time '4:5:6', timestamp '1-2-3 4:5:6' ) overlaps (time '4:5:6', interval '1 2:3:4.5' day to second)",
-        "(?s).*Cannot apply 'OVERLAPS' to arguments of type '.<TIME.0.>, <TIMESTAMP>. OVERLAPS .<TIME.0.>, <INTERVAL DAY TO SECOND>.'.*");
+        "(?s).*Cannot apply 'OVERLAPS' to arguments of type '.<TIME.0.>, <TIMESTAMP.0.>. OVERLAPS .<TIME.0.>, <INTERVAL DAY TO SECOND>.'.*");
     checkWholeExpFails(
         "(time '4:5:6', time '4:5:6' ) overlaps (time '4:5:6', date '1-2-3')",
         "(?s).*Cannot apply 'OVERLAPS' to arguments of type '.<TIME.0.>, <TIME.0.>. OVERLAPS .<TIME.0.>, <DATE>.'.*");

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaConnection.java
Patch:
@@ -44,6 +44,8 @@ public abstract class AvaticaConnection implements Connection {
   private String schema;
   protected final AvaticaDatabaseMetaData metaData;
   public final Helper helper = Helper.INSTANCE;
+  public final Map<InternalProperty, Object> properties =
+      new HashMap<InternalProperty, Object>();
 
   /**
    * Creates an AvaticaConnection.

File: core/src/main/java/org/eigenbase/rel/RelJson.java
Patch:
@@ -367,7 +367,7 @@ RexNode toRex(RelInput relInput, Object o) {
       if (field != null) {
         final Object jsonExpr = map.get("expr");
         final RexNode expr = toRex(relInput, jsonExpr);
-        return rexBuilder.makeFieldAccess(expr, field);
+        return rexBuilder.makeFieldAccess(expr, field, true);
       }
       final String correl = (String) map.get("correl");
       if (correl != null) {

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeFactory.java
Patch:
@@ -56,7 +56,7 @@ public interface RelDataTypeFactory {
    * @pre types != null
    * @pre types.length >= 1
    */
-  public RelDataType createJoinType(RelDataType[] types);
+  public RelDataType createJoinType(RelDataType... types);
 
   /**
    * Creates a type which represents a structured collection of fields.

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeFactoryImpl.java
Patch:
@@ -109,7 +109,7 @@ public RelDataType createJavaType(Class clazz) {
   }
 
   // implement RelDataTypeFactory
-  public RelDataType createJoinType(RelDataType[] types) {
+  public RelDataType createJoinType(RelDataType... types) {
     final List<RelDataType> flattenedTypes =
         getTypeArray(ImmutableList.copyOf(types));
     return canonize(

File: core/src/main/java/org/eigenbase/sql/validate/AbstractNamespace.java
Patch:
@@ -145,9 +145,7 @@ public SqlValidatorNamespace lookupChild(String name) {
 
   public boolean fieldExists(String name) {
     final RelDataType rowType = getRowType();
-    final RelDataType dataType =
-        SqlValidatorUtil.lookupFieldType(rowType, name);
-    return dataType != null;
+    return validator.catalogReader.field(rowType, name) != null;
   }
 
   public List<Pair<SqlNode, SqlMonotonicity>> getMonotonicExprs() {

File: core/src/main/java/org/eigenbase/sql/validate/DelegatingScope.java
Patch:
@@ -161,9 +161,9 @@ public SqlIdentifier fullyQualify(SqlIdentifier identifier) {
       }
       columnName = identifier.names.get(1);
       final RelDataType fromRowType = fromNs.getRowType();
-      final RelDataType type =
-          SqlValidatorUtil.lookupFieldType(fromRowType, columnName);
-      if (type != null) {
+      final RelDataTypeField field =
+          validator.catalogReader.field(fromRowType, columnName);
+      if (field != null) {
         return identifier; // it was fine already
       } else {
         throw validator.newValidationError(

File: core/src/main/java/org/eigenbase/sql2rel/RelFieldTrimmer.java
Patch:
@@ -520,7 +520,7 @@ public TrimResult trimFields(
       // individually. For now, we assume that just one input has
       // on-demand fields.
       Set<RelDataTypeField> inputExtraFields =
-          input.getRowType().getField("_extra") == null
+          RelDataTypeImpl.extra(rowType) == null
               ? Collections.<RelDataTypeField>emptySet()
               : combinedInputExtraFields;
       inputExtraFieldCounts.add(inputExtraFields.size());

File: core/src/main/java/org/eigenbase/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -735,9 +735,7 @@ public RexNode visitFieldAccess(RexFieldAccess fieldAccess) {
 
       for (;;) {
         RexNode refExp = fieldAccess.getReferenceExpr();
-        int ordinal =
-            refExp.getType().getFieldOrdinal(
-                fieldAccess.getField().getName());
+        int ordinal = fieldAccess.getField().getIndex();
         iInput +=
             calculateFlattenedOffset(
                 refExp.getType(),

File: core/src/test/java/org/eigenbase/relopt/RelWriterTest.java
Patch:
@@ -128,7 +128,7 @@ public String apply(RelOptCluster cluster,
                             rexBuilder.makeFieldAccess(
                                 rexBuilder.makeRangeReference(
                                     table.getRowType()),
-                                "deptno"),
+                                "deptno", true),
                             rexBuilder.makeExactLiteral(BigDecimal.TEN)));
                 final RelJsonWriter writer = new RelJsonWriter();
                 final RelDataType intType =

File: core/src/test/java/org/eigenbase/sql/test/SqlAdvisorTest.java
Patch:
@@ -1186,11 +1186,11 @@ public AdvisorTesterFactory() {
     public SqlValidator getValidator(
         SqlTestFactory factory) {
       final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
-      final SqlConformance conformance =
-          (SqlConformance) get("conformance");
+      final SqlConformance conformance = (SqlConformance) get("conformance");
+      final boolean caseSensitive = (Boolean) factory.get("caseSensitive");
       return new SqlAdvisorValidator(
           SqlStdOperatorTable.instance(),
-          new MockCatalogReader(typeFactory),
+          new MockCatalogReader(typeFactory, caseSensitive),
           typeFactory,
           conformance);
     }

File: core/src/test/java/org/eigenbase/test/SqlValidatorFeatureTest.java
Patch:
@@ -126,9 +126,10 @@ public FeatureTesterFactory() {
     public SqlValidator getValidator(SqlTestFactory factory) {
       final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
       SqlConformance conformance = (SqlConformance) get("conformance");
+      final boolean caseSensitive = (Boolean) get("caseSensitive");
       return new FeatureValidator(
           factory.createOperatorTable(),
-          new MockCatalogReader(typeFactory),
+          new MockCatalogReader(typeFactory, caseSensitive),
           typeFactory,
           conformance);
     }

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/SplunkTableAccessRel.java
Patch:
@@ -97,7 +97,8 @@ public RelDataType deriveRowType() {
     final RelDataTypeFactory.FieldInfoBuilder builder =
         getCluster().getTypeFactory().builder();
     for (String field : fieldList) {
-      builder.add(table.getRowType().getField(field));
+      // REVIEW: is case-sensitive match what we want here?
+      builder.add(table.getRowType().getField(field, true));
     }
     return builder.build();
   }

File: core/src/test/java/org/eigenbase/sql/parser/SqlParserTest.java
Patch:
@@ -781,8 +781,8 @@ public void _testEmbeddedFunction() {
     checkExpFails("^\"^x`y`z\"", "(?s).*Encountered.*");
     checkExpFails("^`^x``y``z`", "(?s).*Encountered.*");
 
-    checkExp("[anything [but brackets]] are].[ok]",
-        "`anything [but brackets]] are`.`ok`");
+    checkExp("[anything [even brackets]] is].[ok]",
+        "`anything [even brackets] is`.`ok`");
 
     // What would be a call to the 'item' function in DOUBLE_QUOTE and BACK_TICK
     // is a table alias.

File: core/src/main/java/net/hydromatic/optiq/jdbc/ConnectionConfig.java
Patch:
@@ -17,6 +17,8 @@
 */
 package net.hydromatic.optiq.jdbc;
 
+import org.eigenbase.sql.parser.SqlParser;
+
 /** Interface for reading connection properties within Optiq code. There is
  * a method for every property. At some point there will be similar config
  * classes for system and statement properties. */
@@ -25,6 +27,7 @@ public interface ConnectionConfig {
   boolean materializationsEnabled();
   String model();
   String schema();
+  SqlParser.Quoting quoting();
   boolean spark();
 }
 

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -297,7 +297,7 @@ <T> PrepareResult<T> prepare2_(
     final Prepare.PreparedResult preparedResult;
     if (sql != null) {
       assert queryable == null;
-      SqlParser parser = new SqlParser(sql);
+      SqlParser parser = new SqlParser(sql, context.config().quoting());
       SqlNode sqlNode;
       try {
         sqlNode = parser.parseStmt();

File: core/src/main/java/org/eigenbase/sql/advise/SqlAdvisor.java
Patch:
@@ -381,7 +381,7 @@ public List<String> getReservedAndKeyWords() {
    * @return a {@link SqlAbstractParserImpl} instance
    */
   protected SqlAbstractParserImpl getParserImpl() {
-    SqlParser parser = new SqlParser(new StringReader(""));
+    SqlParser parser = new SqlParser("");
     return parser.getParserImpl();
   }
 

File: core/src/main/java/org/eigenbase/sql/util/ChainedSqlOperatorTable.java
Patch:
@@ -60,8 +60,7 @@ public List<SqlOperator> lookupOperatorOverloads(
       SqlFunctionCategory category,
       SqlSyntax syntax) {
     List<SqlOperator> list = new ArrayList<SqlOperator>();
-    for (int i = 0; i < tableList.size(); ++i) {
-      SqlOperatorTable table = tableList.get(i);
+    for (SqlOperatorTable table : tableList) {
       list.addAll(
           table.lookupOperatorOverloads(opName, category, syntax));
     }

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1487,12 +1487,10 @@ public RelDataType deriveConstructorType(
         call.setOperator(resolvedConstructor);
       } else {
         // fake a fully-qualified call to the default constructor
-        SqlReturnTypeInference returnTypeInference =
-            new ExplicitReturnTypeInference(type);
         call.setOperator(
             new SqlFunction(
                 type.getSqlIdentifier(),
-                returnTypeInference,
+                ExplicitReturnTypeInference.of(type),
                 null,
                 null,
                 null,

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -164,6 +164,7 @@ protected RelOptPlanner createPlanner(Context context) {
     planner.addRule(JavaRules.ENUMERABLE_VALUES_RULE);
     planner.addRule(JavaRules.ENUMERABLE_WINDOW_RULE);
     planner.addRule(JavaRules.ENUMERABLE_ONE_ROW_RULE);
+    planner.addRule(JavaRules.ENUMERABLE_EMPTY_RULE);
     planner.addRule(TableAccessRule.instance);
     planner.addRule(MergeProjectRule.instance);
     planner.addRule(PushFilterPastProjectRule.instance);

File: core/src/main/java/org/eigenbase/rel/EmptyRel.java
Patch:
@@ -33,7 +33,7 @@
  *
  * <ul>
  * <li>Created by {@code net.sf.farrago.query.FarragoReduceValuesRule}</li>
- * <li>Triggers {@link org.eigenbase.rel.rules.RemoveEmptyRule}</li>
+ * <li>Triggers {@link org.eigenbase.rel.rules.RemoveEmptyRules}</li>
  * </ul>
  *
  * @see org.eigenbase.rel.ValuesRel

File: core/src/main/java/org/eigenbase/rel/SortRel.java
Patch:
@@ -129,7 +129,7 @@ public SortRel copy(
       RelCollation newCollation,
       RexNode offset,
       RexNode fetch) {
-    assert traitSet.contains(Convention.NONE);
+    assert traitSet.containsIfApplicable(Convention.NONE);
     return new SortRel(
         getCluster(),
         traitSet,

File: core/src/main/java/org/eigenbase/reltype/RelDataTypeFactoryImpl.java
Patch:
@@ -69,7 +69,9 @@ public RelDataType load(Object key) {
 
   private static final Map<Class, RelDataTypeFamily> CLASS_FAMILIES =
       ImmutableMap.<Class, RelDataTypeFamily>of(
-          String.class, SqlTypeFamily.CHARACTER);
+          String.class, SqlTypeFamily.CHARACTER,
+          boolean.class, SqlTypeFamily.BOOLEAN,
+          Boolean.class, SqlTypeFamily.BOOLEAN);
 
   //~ Constructors -----------------------------------------------------------
 

File: core/src/main/java/org/eigenbase/rel/rules/MultiJoinRel.java
Patch:
@@ -106,7 +106,7 @@ public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
     return new MultiJoinRel(
         getCluster(),
         inputs,
-        joinFilter.clone(),
+        joinFilter,
         rowType,
         isFullOuterJoin,
         outerJoinConditions,

File: core/src/main/java/org/eigenbase/rel/rules/SwapJoinRule.java
Patch:
@@ -89,7 +89,7 @@ public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) {
     final RelDataType rightRowType = join.getRight().getRowType();
     final VariableReplacer variableReplacer =
         new VariableReplacer(rexBuilder, leftRowType, rightRowType);
-    final RexNode oldCondition = join.getCondition().clone();
+    final RexNode oldCondition = join.getCondition();
     RexNode condition = variableReplacer.go(oldCondition);
 
     // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the

File: core/src/main/java/org/eigenbase/rex/RexBuilder.java
Patch:
@@ -717,9 +717,7 @@ public RexInputRef makeInputRef(
   /**
    * Creates a literal representing a flag.
    *
-   * @param flag Flag value; must be either a {@link
-   *             org.eigenbase.util14.Enum14.Value} or a {@link Enum}, and hence a {@link
-   *             Comparable}.
+   * @param flag Flag value
    */
   public RexLiteral makeFlag(Enum flag) {
     assert flag != null;

File: core/src/main/java/org/eigenbase/rex/RexCorrelVariable.java
Patch:
@@ -39,7 +39,8 @@ public class RexCorrelVariable extends RexVariable {
   //~ Methods ----------------------------------------------------------------
 
   public RexCorrelVariable clone() {
-    return new RexCorrelVariable(name, type);
+    // All fields are immutable, so there's no point in creating a copy.
+    return this;
   }
 
   public <R> R accept(RexVisitor<R> visitor) {

File: core/src/main/java/org/eigenbase/rex/RexDynamicParam.java
Patch:
@@ -46,7 +46,8 @@ public RexDynamicParam(
   //~ Methods ----------------------------------------------------------------
 
   public RexDynamicParam clone() {
-    return new RexDynamicParam(type, index);
+    // All fields are immutable, so there's no point in creating a copy.
+    return this;
   }
 
   public SqlKind getKind() {

File: core/src/main/java/org/eigenbase/rex/RexRangeRef.java
Patch:
@@ -68,7 +68,8 @@ public int getOffset() {
   }
 
   public RexRangeRef clone() {
-    return new RexRangeRef(type, offset);
+    // All fields are immutable, so there's no point in creating a copy.
+    return this;
   }
 
   public <R> R accept(RexVisitor<R> visitor) {

File: core/src/main/java/org/eigenbase/rex/RexUtil.java
Patch:
@@ -73,6 +73,8 @@ public static double getSelectivity(RexNode exp) {
 
   /**
    * Returns a copy of an array of row-expressions.
+   *
+   * @deprecated Will be removed before optiq-0.4.19.
    */
   public static RexNode[] clone(RexNode[] exps) {
     if (null == exps) {

File: core/src/test/java/net/hydromatic/optiq/test/JdbcAdapterTest.java
Patch:
@@ -20,7 +20,7 @@
 import org.junit.Test;
 
 /**
- * Tests for the {@link net.hydromatic.optiq.impl.jdbc} package.
+ * Tests for the {@code net.hydromatic.optiq.impl.jdbc} package.
  */
 public class JdbcAdapterTest {
   @Test public void testUnionPlan() {

File: core/src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -248,7 +248,7 @@ public void onStatementClose(AvaticaStatement statement) {
     HandlerDriver.HANDLERS.remove();
   }
 
-  /** Tests {@link java.sql.Statement#closeOnCompletion()}. */
+  /** Tests {@link java.sql.Statement}.{@code closeOnCompletion()}. */
   @Test public void testStatementCloseOnCompletion() throws Exception {
     String javaVersion = System.getProperty("java.version");
     if (javaVersion.compareTo("1.7") < 0) {

File: core/src/test/java/org/eigenbase/test/SargTest.java
Patch:
@@ -31,7 +31,7 @@
 import static org.junit.Assert.*;
 
 /**
- * Tests for the {@link org.eigenbase.sarg} class library.
+ * Tests for the {@code org.eigenbase.sarg} class library.
  *
  * <p>NOTE: This class lives in org.eigenbase.test rather than
  * org.eigenbase.sarg by design: we want to make sure we're only testing via the

File: mongodb/src/test/java/net/hydromatic/optiq/test/MongoAdapterTest.java
Patch:
@@ -34,7 +34,7 @@
 import java.util.Properties;
 
 /**
- * Tests for the {@link net.hydromatic.optiq.impl.mongodb} package.
+ * Tests for the {@code net.hydromatic.optiq.impl.mongodb} package.
  *
  * <p>Before calling this test, you need to populate MongoDB with the "zips"
  * data set (as described in HOWTO.md)

File: core/src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -82,6 +82,7 @@ public enum BuiltinMethod {
       boolean.class),
   ARRAY_COMPARER(Functions.class, "arrayComparer"),
   FUNCTION0_APPLY(Function0.class, "apply"),
+  FUNCTION1_APPLY(Function1.class, "apply", Object.class),
   ARRAYS_AS_LIST(FlatLists.class, "of", Object[].class),
   LIST2(FlatLists.class, "of", Object.class, Object.class),
   LIST3(FlatLists.class, "of", Object.class, Object.class, Object.class),

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqPrepare.java
Patch:
@@ -87,6 +87,8 @@ interface Context {
 
     /** Returns the spark handler. Never null. */
     SparkHandler spark();
+
+    DataContext getDataContext();
   }
 
   /** Callback to register Spark as the main engine. */

File: core/src/main/java/org/eigenbase/rel/ValuesRelBase.java
Patch:
@@ -113,9 +113,8 @@ private boolean assertRowType() {
         // overflow, rounding, and padding/truncation must already have
         // been dealt with.
         if (!RexLiteral.isNullLiteral(literal)) {
-          assert (SqlTypeUtil.canAssignFrom(
-              fieldType,
-              literal.getType()));
+          assert SqlTypeUtil.canAssignFrom(fieldType, literal.getType())
+              : "to " + fieldType + " from " + literal;
         }
       }
     }

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeUtil.java
Patch:
@@ -692,7 +692,8 @@ public static boolean canAssignFrom(
       return false;
     }
 
-    return toType.getFamily() == fromType.getFamily();
+    return toType.getFamily() == SqlTypeFamily.ANY
+        || toType.getFamily() == fromType.getFamily();
   }
 
   /**

File: core/src/main/java/net/hydromatic/optiq/util/CompositeMap.java
Patch:
@@ -33,7 +33,7 @@ public CompositeMap(ImmutableList<Map<K, V>> maps) {
   }
 
   /** Creates a CompositeMap. */
-  @SafeVarargs
+  // Would like to use '@SafeVarargs' but JDK 1.6 doesn't support it.
   @SuppressWarnings("varargs")
   public static <K, V> CompositeMap<K, V> of(Map<K, V> map0,
       Map<K, V>... maps) {

File: avatica/src/main/java/net/hydromatic/avatica/UnregisteredDriver.java
Patch:
@@ -43,7 +43,7 @@
  */
 public abstract class UnregisteredDriver implements java.sql.Driver {
   final DriverVersion version;
-  final AvaticaFactory factory;
+  protected final AvaticaFactory factory;
   public final Handler handler;
 
   protected UnregisteredDriver() {

File: core/src/main/java/net/hydromatic/optiq/ModifiableTable.java
Patch:
@@ -32,7 +32,7 @@
  * <p>NOTE: The current API is inefficient and experimental. It will change
  * without notice.</p>
  */
-public interface ModifiableTable<E> extends Table<E> {
+public interface ModifiableTable extends QueryableTable {
   /** Returns the modifiable collection.
    * Modifying the collection will change the table's contents. */
   Collection getModifiableCollection();

File: core/src/main/java/net/hydromatic/optiq/TableFactory.java
Patch:
@@ -82,7 +82,7 @@ public interface TableFactory<T extends Table> {
    * @param rowType Row type. Specified if the "columns" JSON property.
    */
   T create(
-      Schema schema,
+      SchemaPlus schema,
       String name,
       Map<String, Object> operand,
       RelDataType rowType);

File: core/src/main/java/net/hydromatic/optiq/TranslatableTable.java
Patch:
@@ -20,7 +20,6 @@
 import org.eigenbase.rel.RelNode;
 import org.eigenbase.relopt.RelOptTable;
 
-
 /**
  * Extension to {@link Table} that specifies how it is to be translated to
  * a {@link org.eigenbase.rel.RelNode planner node}.
@@ -31,7 +30,7 @@
  * create a particular subclass of RelNode, and also register rules that act
  * on that particular subclass of RelNode.</p>
  */
-public interface TranslatableTable<T> extends Table<T> {
+public interface TranslatableTable extends Table {
   /** Converts this table into a {@link RelNode relational expression}. */
   RelNode toRel(
       RelOptTable.ToRelContext context,

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcRules.java
Patch:
@@ -18,6 +18,7 @@
 package net.hydromatic.optiq.impl.jdbc;
 
 import net.hydromatic.linq4j.Ord;
+import net.hydromatic.linq4j.Queryable;
 import net.hydromatic.linq4j.expressions.*;
 
 import net.hydromatic.optiq.ModifiableTable;
@@ -791,7 +792,7 @@ public RelNode convert(RelNode rel) {
       final ModifiableTable modifiableTable =
           modify.getTable().unwrap(ModifiableTable.class);
       if (modifiableTable == null
-          || modifiableTable.getExpression() == null) {
+          /* || modifiableTable.getExpression(tableInSchema) == null */) {
         return null;
       }
       final RelTraitSet traitSet =
@@ -831,7 +832,7 @@ public JdbcTableModificationRel(
       if (modifiableTable == null) {
         throw new AssertionError(); // TODO: user error in validator
       }
-      this.expression = modifiableTable.getExpression();
+      this.expression = table.getExpression(Queryable.class);
       if (expression == null) {
         throw new AssertionError(); // TODO: user error in validator
       }

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -20,6 +20,7 @@
 import net.hydromatic.linq4j.expressions.*;
 
 import net.hydromatic.optiq.BuiltinMethod;
+import net.hydromatic.optiq.Schemas;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 import net.hydromatic.optiq.prepare.OptiqPrepareImpl;
 import net.hydromatic.optiq.rules.java.*;
@@ -147,8 +148,7 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
             Expressions.call(
                 BuiltinMethod.RESULT_SET_ENUMERABLE_OF.method,
                 Expressions.call(
-                    Expressions.convert_(
-                        jdbcConvention.jdbcSchema.getExpression(),
+                    Schemas.unwrap(jdbcConvention.jdbcSchema.getExpression(),
                         JdbcSchema.class),
                     BuiltinMethod.JDBC_SCHEMA_DATA_SOURCE.method),
                 sql_,

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqConnection.java
Patch:
@@ -17,7 +17,7 @@
 */
 package net.hydromatic.optiq.jdbc;
 
-import net.hydromatic.optiq.MutableSchema;
+import net.hydromatic.optiq.SchemaPlus;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 
 import net.hydromatic.linq4j.QueryProvider;
@@ -47,7 +47,7 @@ public interface OptiqConnection extends Connection, QueryProvider {
    *
    * @return Root schema
    */
-  MutableSchema getRootSchema();
+  SchemaPlus getRootSchema();
 
   /**
    * Returns the type factory.

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqJdbc40Factory.java
Patch:
@@ -22,7 +22,7 @@
  * for Optiq and JDBC 4.0 (corresponds to JDK 1.6).
  */
 public class OptiqJdbc40Factory extends OptiqJdbc41Factory {
-  /** Creates a JDBC factory. */
+  /** Creates a factory for JDBC version 4.1. */
   public OptiqJdbc40Factory() {
     super(4, 0);
   }

File: core/src/main/java/net/hydromatic/optiq/prepare/LixToRelTranslator.java
Patch:
@@ -17,7 +17,7 @@
 */
 package net.hydromatic.optiq.prepare;
 
-import net.hydromatic.optiq.BuiltinMethod;
+import net.hydromatic.optiq.*;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 
 import net.hydromatic.linq4j.Queryable;
@@ -70,8 +70,8 @@ public <T> RelNode translate(Queryable<T> queryable) {
 
   public RelNode translate(Expression expression) {
     if (expression instanceof MethodCallExpression) {
-      MethodCallExpression call = (MethodCallExpression) expression;
-      BuiltinMethod method = BuiltinMethod.lookup(call.method);
+      final MethodCallExpression call = (MethodCallExpression) expression;
+      BuiltinMethod method = BuiltinMethod.MAP.get(call.method);
       if (method == null) {
         throw new UnsupportedOperationException(
             "unknown method " + call.method);

File: core/src/main/java/net/hydromatic/optiq/prepare/Prepare.java
Patch:
@@ -18,8 +18,8 @@
 package net.hydromatic.optiq.prepare;
 
 import net.hydromatic.linq4j.function.Functions;
-import net.hydromatic.optiq.Schema;
 import net.hydromatic.optiq.impl.StarTable;
+import net.hydromatic.optiq.jdbc.OptiqSchema;
 import net.hydromatic.optiq.rules.java.JavaRules;
 import net.hydromatic.optiq.runtime.Bindable;
 import net.hydromatic.optiq.runtime.Typed;
@@ -556,7 +556,7 @@ public RelNode getRootRel() {
    * process. */
   public static class Materialization {
     /** The table that holds the materialized data. */
-    final Schema.TableInSchema materializedTable;
+    final OptiqSchema.TableEntry materializedTable;
     /** The query that derives the data. */
     final String sql;
     /** Relational expression for the table. Usually a
@@ -567,7 +567,7 @@ public static class Materialization {
     /** Star table identified. */
     private RelOptTable starRelOptTable;
 
-    public Materialization(Schema.TableInSchema materializedTable,
+    public Materialization(OptiqSchema.TableEntry materializedTable,
         String sql) {
       assert materializedTable != null;
       assert sql != null;

File: core/src/main/java/net/hydromatic/optiq/rules/java/EnumerableRelImplementor.java
Patch:
@@ -22,6 +22,7 @@
 import net.hydromatic.linq4j.expressions.*;
 
 import net.hydromatic.optiq.BuiltinMethod;
+import net.hydromatic.optiq.DataContext;
 import net.hydromatic.optiq.jdbc.JavaTypeFactoryImpl;
 import net.hydromatic.optiq.runtime.Bindable;
 import net.hydromatic.optiq.runtime.Utilities;
@@ -73,7 +74,7 @@ public ClassDeclaration implementRoot(EnumerableRel rootRel,
             Modifier.PUBLIC,
             Enumerable.class,
             BuiltinMethod.BINDABLE_BIND.method.getName(),
-            Expressions.list(root),
+            Expressions.list(DataContext.ROOT),
             result.block));
     memberDeclarations.add(
         Expressions.methodDecl(

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexToLixTranslator.java
Patch:
@@ -327,7 +327,7 @@ private Expression translateParameter(RexDynamicParam expr,
     return nullAs.handle(
         convert(
             Expressions.call(
-                Expressions.variable(DataContext.class, "root"),
+                DataContext.ROOT,
                 BuiltinMethod.DATA_CONTEXT_GET.method,
                 Expressions.constant("?" + expr.getIndex())),
             typeFactory.getJavaClass(expr.getType())));

File: core/src/main/java/org/eigenbase/relopt/RelOptMaterialization.java
Patch:
@@ -70,8 +70,8 @@ public RelNode visit(TableAccessRelBase scan) {
             if (table.equals(starTable.tables.get(0))) {
               Mappings.TargetMapping mapping =
                   Mappings.createShiftMapping(
-                      starTable.getRowType().getFieldCount(),
-                      0, 0, table.getRowType().getFieldCount());
+                      starRelOptTable.getRowType().getFieldCount(),
+                      0, 0, relOptTable.getRowType().getFieldCount());
 
               return CalcRel.createProject(
                   new TableAccessRel(scan.getCluster(), starRelOptTable),
@@ -152,7 +152,7 @@ private void match(RelNode left, Mappings.TargetMapping leftMapping,
                   Mappings.merge(leftMapping,
                       Mappings.offset(rightMapping,
                           ((StarTable) leftTable).columnOffset(rightTable),
-                          leftTable.getRowType().getFieldCount()));
+                          leftRelOptTable.getRowType().getFieldCount()));
               throw new Util.FoundOne(
                   CalcRel.createProject(
                       new TableAccessRel(cluster, leftRelOptTable),

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoRel.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.eigenbase.rel.RelNode;
 import org.eigenbase.relopt.Convention;
+import org.eigenbase.relopt.RelOptTable;
 import org.eigenbase.util.Pair;
 
 import java.util.ArrayList;
@@ -37,7 +38,8 @@ class Implementor {
     final List<Pair<String, String>> list =
         new ArrayList<Pair<String, String>>();
 
-    MongoTable table;
+    RelOptTable table;
+    MongoTable mongoTable;
 
     public void add(String findOp, String aggOp) {
       list.add(Pair.of(findOp, aggOp));

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoTableScan.java
Patch:
@@ -93,7 +93,8 @@ public void register(RelOptPlanner planner) {
   }
 
   public void implement(Implementor implementor) {
-    implementor.table = mongoTable;
+    implementor.mongoTable = mongoTable;
+    implementor.table = table;
     for (Pair<String, String> op : ops) {
       implementor.add(op.left, op.right);
     }

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/EnumerableToSparkConverter.java
Patch:
@@ -36,8 +36,7 @@
  */
 public class EnumerableToSparkConverter
     extends ConverterRelImpl
-    implements SparkRel
-{
+    implements SparkRel {
   protected EnumerableToSparkConverter(RelOptCluster cluster,
       RelTraitSet traits, RelNode input) {
     super(cluster, ConventionTraitDef.instance, traits, input);
@@ -68,7 +67,7 @@ public Result implementSpark(Implementor implementor) {
     final Expression sparkContext =
         Expressions.call(
             SparkMethod.GET_SPARK_CONTEXT.method,
-            implementor.root);
+            implementor.getRootExpression());
     final Expression rdd =
         list.append(
             "rdd",

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/JdbcToSparkConverterRule.java
Patch:
@@ -18,7 +18,6 @@
 package net.hydromatic.optiq.impl.spark;
 
 import net.hydromatic.optiq.impl.jdbc.JdbcConvention;
-import net.hydromatic.optiq.impl.jdbc.JdbcToEnumerableConverter;
 
 import org.eigenbase.rel.RelNode;
 import org.eigenbase.rel.convert.ConverterRule;
@@ -40,8 +39,7 @@ public class JdbcToSparkConverterRule extends ConverterRule {
   @Override
   public RelNode convert(RelNode rel) {
     RelTraitSet newTraitSet = rel.getTraitSet().replace(getOutTrait());
-    return new JdbcToSparkConverter(
-        rel.getCluster(), newTraitSet, rel);
+    return new JdbcToSparkConverter(rel.getCluster(), newTraitSet, rel);
   }
 }
 

File: spark/src/test/java/net/hydromatic/optiq/test/SparkAdapterTest.java
Patch:
@@ -17,7 +17,6 @@
 */
 package net.hydromatic.optiq.test;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.sql.*;
@@ -32,7 +31,7 @@ public class SparkAdapterTest {
    * There are no data sources.
    */
   @Test public void testValues() throws SQLException {
-    OptiqAssert.assertThat()
+    OptiqAssert.that()
         .with(OptiqAssert.Config.SPARK)
         .query(
             "select *\n"
@@ -47,7 +46,7 @@ public class SparkAdapterTest {
 
   /** Tests values followed by filter, evaluated by Spark. */
   @Test public void testValuesFilter() throws SQLException {
-    OptiqAssert.assertThat()
+    OptiqAssert.that()
         .with(OptiqAssert.Config.SPARK)
         .query(
             "select *\n"

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqMaterializer.java
Patch:
@@ -72,8 +72,7 @@ void populate(Materialization materialization) {
 
     RelOptTable table =
         this.catalogReader.getTable(materialization.materializedTable.path());
-    materialization.tableRel =
-        table.toRel(sqlToRelConverter2.makeToRelContext());
+    materialization.tableRel = sqlToRelConverter2.toRel(table);
   }
 
   /** Converts a relational expression to use a

File: core/src/main/java/org/eigenbase/rel/UncollectRel.java
Patch:
@@ -99,9 +99,9 @@ public static RelDataType deriveUncollectRowType(RelNode rel)
             // Element type is not a record. It may be a scalar type, say
             // "INTEGER". Wrap it in a struct type.
             ret =
-                rel.getCluster().getTypeFactory().createStructType(
-                    ImmutableList.of(
-                        Pair.of(SqlUtil.deriveAliasFromOrdinal(0), ret)));
+                rel.getCluster().getTypeFactory().builder()
+                    .add(SqlUtil.deriveAliasFromOrdinal(0), ret)
+                    .build();
         }
         return ret;
     }

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -475,8 +475,7 @@ private static RelDataType makeStruct(
     if (type.isStruct()) {
       return type;
     }
-    return typeFactory.createStructType(
-        RelDataTypeFactory.FieldInfoBuilder.of("$0", type));
+    return typeFactory.builder().add("$0", type).build();
   }
 
   /** Executes an optimize action. */

File: core/src/main/java/net/hydromatic/optiq/rules/java/PhysTypeImpl.java
Patch:
@@ -71,15 +71,14 @@ public static PhysType of(
   static PhysType of(
       final JavaTypeFactory typeFactory,
       Type javaRowClass) {
-    final RelDataTypeFactory.FieldInfoBuilder builder =
-        new RelDataTypeFactory.FieldInfoBuilder();
+    final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
     if (javaRowClass instanceof Types.RecordType) {
       final Types.RecordType recordType = (Types.RecordType) javaRowClass;
       for (Types.RecordField field : recordType.getRecordFields()) {
         builder.add(field.getName(), typeFactory.createType(field.getType()));
       }
     }
-    RelDataType rowType = typeFactory.createStructType(builder);
+    RelDataType rowType = builder.build();
     // Do not optimize if there are 0 or 1 fields.
     return new PhysTypeImpl(
         typeFactory, rowType, javaRowClass, JavaRowFormat.CUSTOM);

File: core/src/main/java/org/eigenbase/rel/RelJson.java
Patch:
@@ -161,12 +161,11 @@ public RelDataType toType(RelDataTypeFactory typeFactory, Object o) {
     if (o instanceof List) {
       @SuppressWarnings("unchecked")
       final List<Map<String, Object>> jsonList = (List<Map<String, Object>>) o;
-      final RelDataTypeFactory.FieldInfoBuilder builder =
-          new RelDataTypeFactory.FieldInfoBuilder();
+      final RelDataTypeFactory.FieldInfoBuilder builder = typeFactory.builder();
       for (Map<String, Object> jsonMap : jsonList) {
         builder.add((String) jsonMap.get("name"), toType(typeFactory, jsonMap));
       }
-      return typeFactory.createStructType(builder);
+      return builder.build();
     } else {
       final Map<String, Object> map = (Map<String, Object>) o;
       final SqlTypeName sqlTypeName =

File: mongodb/src/main/java/net/hydromatic/optiq/impl/mongodb/MongoSchema.java
Patch:
@@ -24,7 +24,6 @@
 import net.hydromatic.optiq.impl.java.MapSchema;
 
 import org.eigenbase.reltype.RelDataType;
-import org.eigenbase.reltype.RelDataTypeFactory;
 import org.eigenbase.sql.type.SqlTypeName;
 
 import com.mongodb.DB;
@@ -70,8 +69,7 @@ protected Collection<TableInSchema> initialTables() {
             typeFactory.createSqlType(SqlTypeName.VARCHAR),
             typeFactory.createSqlType(SqlTypeName.ANY));
     final RelDataType rowType =
-        typeFactory.createStructType(
-            new RelDataTypeFactory.FieldInfoBuilder().add("_MAP", mapType));
+        typeFactory.builder().add("_MAP", mapType).build();
     for (String collection : mongoDb.getCollectionNames()) {
       final MongoTable table = new MongoTable(this, collection, rowType);
       list.add(

File: splunk/src/main/java/net/hydromatic/optiq/impl/splunk/SplunkTableAccessRel.java
Patch:
@@ -95,11 +95,11 @@ public void register(RelOptPlanner planner) {
   @Override
   public RelDataType deriveRowType() {
     final RelDataTypeFactory.FieldInfoBuilder builder =
-        new RelDataTypeFactory.FieldInfoBuilder();
+        getCluster().getTypeFactory().builder();
     for (String field : fieldList) {
       builder.add(table.getRowType().getField(field));
     }
-    return getCluster().getTypeFactory().createStructType(builder);
+    return builder.build();
   }
 
   private static final Constructor CONSTRUCTOR =

File: core/src/main/java/org/eigenbase/rel/rules/RemoveTrivialProjectRule.java
Patch:
@@ -73,7 +73,7 @@ public void onMatch(RelOptRuleCall call)
     /** Returns the child of a project if the project is trivial, otherwise
      * the project itself. */
     public static RelNode strip(ProjectRel project) {
-        return isTrivial(project) ? project : project.getChild();
+        return isTrivial(project) ? project.getChild() : project;
     }
 
     public static boolean isTrivial(ProjectRelBase project) {

File: core/src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -585,12 +585,10 @@ public AssertThat withMaterializations(
       } else {
         throw new AssertionError("do not know where to splice");
       }
-      System.out.println(model2);
       return withModel(model2);
     }
 
     public AssertQuery query(String sql) {
-      System.out.println(sql);
       return new AssertQuery(connectionFactory, sql);
     }
 

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcImplementor.java
Patch:
@@ -56,7 +56,9 @@ public JdbcImplementor(SqlDialect dialect, JavaTypeFactory typeFactory) {
   public Result result(SqlNode node, Collection<Clause> clauses, RelNode rel) {
     final String alias2 = SqlValidatorUtil.getAlias(node, -1);
     final String alias3 = alias2 != null ? alias2 : "t";
-    final String alias4 = SqlValidatorUtil.uniquify(alias3, aliasSet);
+    final String alias4 =
+        SqlValidatorUtil.uniquify(
+            alias3, aliasSet, SqlValidatorUtil.EXPR_SUGGESTER);
     final String alias5 = alias2 == null || !alias2.equals(alias4) ? alias4
         : null;
     return new Result(node, clauses, alias5,

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1736,7 +1736,9 @@ protected void addToSelectList(
         final boolean includeSystemVars)
     {
         String alias = SqlValidatorUtil.getAlias(exp, -1);
-        String uniqueAlias = SqlValidatorUtil.uniquify(alias, aliases);
+        String uniqueAlias =
+            SqlValidatorUtil.uniquify(
+                alias, aliases, SqlValidatorUtil.EXPR_SUGGESTER);
         if (!alias.equals(uniqueAlias)) {
             exp = SqlValidatorUtil.addAlias(exp, uniqueAlias);
         }

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -194,7 +194,6 @@ public class ReflectiveSchemaTest {
   /**
    * Tests a view with a path.
    */
-  @Ignore
   @Test public void testViewPath() throws SQLException, ClassNotFoundException {
     Class.forName("net.hydromatic.optiq.jdbc.Driver");
     Connection connection =

File: core/src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -263,6 +263,8 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
     // Plan should contain 'join'. If it doesn't, maybe int-vs-Integer
     // data type incompatibility has caused it to use a cartesian product
     // instead, and that would be wrong.
+    //
+    // inventory_fact_1997 is on the LHS because it is larger than store.
     assertThat()
         .with(OptiqAssert.Config.FOODMART_CLONE)
         .query(

File: core/src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -268,7 +268,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
         .query(
             "select \"store\".\"store_country\" as \"c0\", sum(\"inventory_fact_1997\".\"supply_time\") as \"m0\" from \"store\" as \"store\", \"inventory_fact_1997\" as \"inventory_fact_1997\" where \"inventory_fact_1997\".\"store_id\" = \"store\".\"store_id\" group by \"store\".\"store_country\"")
         .planContains(
-            "  final net.hydromatic.linq4j.Enumerable _inputEnumerable = root.getRootSchema().getSubSchema(\"foodmart2\").getTable(\"store\", java.lang.Object[].class).asEnumerable().join(root.getRootSchema().getSubSchema(\"foodmart2\").getTable(\"inventory_fact_1997\", java.lang.Object[].class).asEnumerable(), new net.hydromatic.linq4j.function.Function1() {\n");
+            "  final net.hydromatic.linq4j.Enumerable _inputEnumerable1 = left.join(right, new net.hydromatic.linq4j.function.Function1() {\n");
   }
 }
 

File: avatica/src/main/java/net/hydromatic/avatica/UnregisteredDriver.java
Patch:
@@ -83,10 +83,10 @@ protected String getFactoryClassName(JdbcVersion jdbcVersion) {
     case JDBC_30:
       return "net.hydromatic.avatica.AvaticaFactoryJdbc3Impl";
     case JDBC_40:
-      return "net.hydromatic.avatica.AvaticaFactoryJdbc4Impl";
+      return "net.hydromatic.avatica.AvaticaJdbc40Factory";
     case JDBC_41:
     default:
-      return "net.hydromatic.avatica.AvaticaFactoryJdbc41";
+      return "net.hydromatic.avatica.AvaticaJdbc41Factory";
     }
   }
 

File: avatica/src/main/java/net/hydromatic/avatica/UnregisteredDriver.java
Patch:
@@ -83,10 +83,10 @@ protected String getFactoryClassName(JdbcVersion jdbcVersion) {
     case JDBC_30:
       return "net.hydromatic.avatica.AvaticaFactoryJdbc3Impl";
     case JDBC_40:
-      return "net.hydromatic.avatica.AvaticaFactoryJdbc4Impl";
+      return "net.hydromatic.avatica.AvaticaJdbc40Factory";
     case JDBC_41:
     default:
-      return "net.hydromatic.avatica.AvaticaFactoryJdbc41";
+      return "net.hydromatic.avatica.AvaticaJdbc41Factory";
     }
   }
 

File: core/src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -39,6 +39,7 @@
  */
 public enum BuiltinMethod {
   QUERYABLE_SELECT(Queryable.class, "select", FunctionExpression.class),
+  QUERYABLE_AS_ENUMERABLE(Queryable.class, "asEnumerable"),
   AS_QUERYABLE(Enumerable.class, "asQueryable"),
   ABSTRACT_ENUMERABLE_CTOR(AbstractEnumerable.class),
   INTO(ExtendedEnumerable.class, "into", Collection.class),

File: core/src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -268,7 +268,7 @@ public class JdbcFrontJdbcBackLinqMiddleTest {
         .query(
             "select \"store\".\"store_country\" as \"c0\", sum(\"inventory_fact_1997\".\"supply_time\") as \"m0\" from \"store\" as \"store\", \"inventory_fact_1997\" as \"inventory_fact_1997\" where \"inventory_fact_1997\".\"store_id\" = \"store\".\"store_id\" group by \"store\".\"store_country\"")
         .planContains(
-            "  final net.hydromatic.linq4j.Enumerable _inputEnumerable = root.getRootSchema().getSubSchema(\"foodmart2\").getTable(\"store\", java.lang.Object[].class).join(root.getRootSchema().getSubSchema(\"foodmart2\").getTable(\"inventory_fact_1997\", java.lang.Object[].class), new net.hydromatic.linq4j.function.Function1() {\n");
+            "  final net.hydromatic.linq4j.Enumerable _inputEnumerable = root.getRootSchema().getSubSchema(\"foodmart2\").getTable(\"store\", java.lang.Object[].class).asEnumerable().join(root.getRootSchema().getSubSchema(\"foodmart2\").getTable(\"inventory_fact_1997\", java.lang.Object[].class).asEnumerable(), new net.hydromatic.linq4j.function.Function1() {\n");
   }
 }
 

File: core/src/main/java/net/hydromatic/optiq/rules/java/PhysTypeImpl.java
Patch:
@@ -504,6 +504,8 @@ public Expression generateAccessor(
         return Expressions.lambda(
             Function1.class,
             Expressions.call(
+                List.class,
+                null,
                 BuiltinMethod.ARRAYS_AS_LIST.method,
                 Expressions.newArrayInit(
                     Object.class,

File: core/src/test/java/net/hydromatic/optiq/test/OptiqSuite.java
Patch:
@@ -90,6 +90,9 @@
     ReflectiveSchemaTest.class,
     JdbcTest.class,
 
+    // test cases
+    TableInRootSchemaTest.class,
+
     // slow tests that don't break often
     PartiallyOrderedSetTest.class
 })

File: avatica/src/main/java/net/hydromatic/avatica/AvaticaStatement.java
Patch:
@@ -350,8 +350,10 @@ void onResultSetClose(ResultSet resultSet) {
    *
    * <p>The default implementation returns the empty list, because non-prepared
    * statements have no parameters.</p>
+   *
+   * @see net.hydromatic.avatica.AvaticaConnection.Trojan#getParameterValues(AvaticaStatement)
    */
-  public List<Object> getParameterValues() {
+  protected List<Object> getParameterValues() {
     return Collections.emptyList();
   }
 }

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqStatement.java
Patch:
@@ -59,15 +59,16 @@ protected <T> OptiqPrepare.PrepareResult<T> prepare(Queryable<T> queryable) {
   protected void close_() {
     if (!closed) {
       closed = true;
-      ((OptiqConnectionImpl) connection).server.removeStatement(this);
+      final OptiqConnectionImpl connection1 = (OptiqConnectionImpl) connection;
+      connection1.server.removeStatement(this);
       if (openResultSet != null) {
         AvaticaResultSet c = openResultSet;
         openResultSet = null;
         c.close();
       }
       // If onStatementClose throws, this method will throw an exception (later
       // converted to SQLException), but this statement still gets closed.
-      connection.driver.handler.onStatementClose(this);
+      connection1.getDriver().handler.onStatementClose(this);
     }
   }
 }

File: core/src/main/java/net/hydromatic/optiq/TableFunction.java
Patch:
@@ -29,7 +29,7 @@ public interface TableFunction<T> {
    *
    * @return Parameters; never null
    */
-  List<Parameter> getParameters();
+  List<net.hydromatic.optiq.Parameter> getParameters();
 
   /**
    * Returns the record type of the table yielded by this function when

File: core/src/main/java/net/hydromatic/optiq/impl/TableInSchemaImpl.java
Patch:
@@ -31,6 +31,7 @@ public class TableInSchemaImpl extends Schema.TableInSchema {
   public TableInSchemaImpl(
       Schema schema, String name, Schema.TableType tableType, Table table) {
     super(schema, name, tableType);
+    assert table != null;
     this.table = table;
   }
 

File: core/src/main/java/net/hydromatic/optiq/jdbc/Meta.java
Patch:
@@ -588,6 +588,7 @@ public MetaTable(
         String tableName,
         String tableType) {
       this.optiqTable = optiqTable;
+      assert optiqTable != null;
       this.tableCat = tableCat;
       this.tableSchem = tableSchem;
       this.tableName = tableName;

File: core/src/main/java/org/eigenbase/rel/rules/PullUpProjectsAboveJoinRule.java
Patch:
@@ -215,7 +215,7 @@ public void onMatch(RelOptRuleCall call)
             CalcRel.createProject(
                 newJoinRel,
                 newProjExprs,
-                Pair.right(projects));
+                joinRel.getRowType().getFieldNames());
 
         call.transformTo(newProjRel);
     }

File: core/src/main/java/org/eigenbase/util/JsonBuilder.java
Patch:
@@ -81,7 +81,9 @@ private void append(StringBuilder buf, int indent, Object o) {
             appendList(buf, indent, (List) o);
         } else if (o instanceof String) {
             buf.append('"')
-                .append(((String) o).replace("\"", "\\\\"))
+                .append(
+                    ((String) o).replace("\"", "\\\"")
+                        .replace("\n", "\\n"))
                 .append('"');
         } else {
             assert o instanceof Number || o instanceof Boolean;

File: core/src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -55,7 +55,7 @@ public class OptiqAssert {
    * To run against MySQL, specify '-Doptiq.test.db=mysql' on the java command
    * line.</p> */
   public static final ConnectionSpec CONNECTION_SPEC =
-      "mysql".equals(System.getProperty("optiq.test.db"))
+      Util.first(System.getProperty("optiq.test.db"), "hsqldb").equals("mysql")
           ? ConnectionSpec.MYSQL
           : ConnectionSpec.HSQLDB;
 

File: core/src/main/java/org/eigenbase/relopt/volcano/RelSet.java
Patch:
@@ -48,6 +48,9 @@ class RelSet
     //~ Instance fields --------------------------------------------------------
 
     final List<RelNode> rels = new ArrayList<RelNode>();
+    /** Relational expressions that have a subset in this set as a child. This
+     * is a multi-set. If multiple relational expressions in this set have the
+     * same parent, there will be multiple entries. */
     final List<RelNode> parents = new ArrayList<RelNode>();
     final List<RelSubset> subsets = new ArrayList<RelSubset>();
 

File: core/src/main/java/org/eigenbase/relopt/volcano/RelSubset.java
Patch:
@@ -219,8 +219,8 @@ private static List<RelSubset> inputSubsets(RelNode parent) {
 
     /** Returns a list of relational expressions one of whose children is this
      * subset. The elements of the list are distinct. */
-    public List<RelNode> getParentRels() {
-        final List<RelNode> list = new ArrayList<RelNode>();
+    public Collection<RelNode> getParentRels() {
+        final Set<RelNode> list = new LinkedHashSet<RelNode>();
     parentLoop:
         for (RelNode parent : set.getParentRels()) {
             for (RelSubset rel : inputSubsets(parent)) {
@@ -230,7 +230,6 @@ public List<RelNode> getParentRels() {
                 }
             }
         }
-        assert Util.isDistinct(list);
         return list;
     }
 

File: core/src/main/java/org/eigenbase/relopt/volcano/VolcanoRuleCall.java
Patch:
@@ -299,7 +299,7 @@ private void matchRecurse(int solve)
                 getRule().operands.get(previousOperandOrdinal);
             RelOptRuleOperand operand = getRule().operands.get(operandOrdinal);
 
-            List<RelNode> successors;
+            Collection<RelNode> successors;
             if (ascending) {
                 assert (previousOperand.getParent() == operand);
                 final RelNode childRel = rels[previousOperandOrdinal];

File: core/src/main/java/org/eigenbase/sql/pretty/SqlPrettyWriter.java
Patch:
@@ -891,6 +891,7 @@ private static boolean needWhitespaceBefore(String s)
         return !(s.equals(",")
             || s.equals(".")
             || s.equals(")")
+            || s.equals("[")
             || s.equals("]")
             || s.equals(""));
     }

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexToLixTranslator.java
Patch:
@@ -136,6 +136,9 @@ Expression translateCast(
       Expression operand) {
     Expression convert = null;
     switch (targetType.getSqlTypeName()) {
+    case ANY:
+      convert = operand;
+      break;
     case BOOLEAN:
       switch (sourceType.getSqlTypeName()) {
       case CHAR:

File: core/src/main/java/org/eigenbase/sql/type/FamilyOperandTypeChecker.java
Patch:
@@ -77,9 +77,10 @@ public boolean checkSingleOperandType(
                 node);
         SqlTypeName typeName = type.getSqlTypeName();
 
-        /* Pass type checking for operators if its of type 'ANY' */
-        if (typeName.getFamily() == SqlTypeFamily.ANY)
+        // Pass type checking for operators if it's of type 'ANY'.
+        if (typeName.getFamily() == SqlTypeFamily.ANY) {
             return true;
+        }
 
         if (!family.getTypeNames().contains(typeName)) {
             if (throwOnFailure) {

File: core/src/main/java/org/eigenbase/sql/type/SqlTypeFamily.java
Patch:
@@ -85,6 +85,8 @@ public enum SqlTypeFamily
 
     MAP(SqlTypeName.MAP),
 
+    NULL(SqlTypeName.NULL),
+
     ANY(SqlTypeName.allTypes),
 
     CURSOR(SqlTypeName.CURSOR),
@@ -156,7 +158,7 @@ public enum SqlTypeFamily
         sqlTypeToFamily[SqlTypeName.TIMESTAMP.ordinal()] = TIMESTAMP;
         sqlTypeToFamily[SqlTypeName.INTERVAL_YEAR_MONTH.ordinal()] =
             INTERVAL_YEAR_MONTH;
-        sqlTypeToFamily[SqlTypeName.NULL.ordinal()] = ANY;
+        sqlTypeToFamily[SqlTypeName.NULL.ordinal()] = NULL;
         sqlTypeToFamily[SqlTypeName.ANY.ordinal()] = ANY;
         sqlTypeToFamily[SqlTypeName.INTERVAL_DAY_TIME.ordinal()] =
             INTERVAL_DAY_TIME;

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcUtils.java
Patch:
@@ -53,9 +53,11 @@ SqlDialect get(DataSource dataSource) {
         List key = Arrays.asList(productName, productVersion);
         SqlDialect dialect = map.get(key);
         if (dialect == null) {
+          final SqlDialect.DatabaseProduct product =
+              SqlDialect.getProduct(productName, productVersion);
           dialect =
               new SqlDialect(
-                  SqlDialect.getProduct(productName, productVersion),
+                  product,
                   productName,
                   metaData.getIdentifierQuoteString());
           map.put(key, dialect);

File: core/src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -150,7 +150,7 @@ public enum BuiltinMethod {
   ROUND_INT(SqlFunctions.class, "round", int.class, int.class),
   DATE_TO_INT(SqlFunctions.class, "toInt", java.util.Date.class),
   TIME_TO_INT(SqlFunctions.class, "toInt", Time.class),
-  TIMESTAMP_TO_LONG(SqlFunctions.class, "toInt", Timestamp.class),
+  TIMESTAMP_TO_LONG(SqlFunctions.class, "toLong", Timestamp.class),
   ;
 
   public final Method method;

File: core/src/main/java/net/hydromatic/optiq/impl/clone/ColumnLoader.java
Patch:
@@ -238,7 +238,7 @@ public int size() {
    * {@link java.sql.Date} and {@link java.sql.Time} values to
    * {@link Integer}. */
   private static List wrap(List list, RelDataType type) {
-//    if (type.isNullable()) {
+    if (type.isNullable()) {
       switch (type.getSqlTypeName()) {
       case TIMESTAMP:
         return Functions.adapt(list, TIMESTAMP_TO_LONG);
@@ -247,7 +247,7 @@ private static List wrap(List list, RelDataType type) {
       case DATE:
         return Functions.adapt(list, DATE_TO_INT);
       }
-//    }
+    }
     return list;
   }
 

File: core/src/main/java/net/hydromatic/optiq/prepare/Prepare.java
Patch:
@@ -40,7 +40,6 @@
  * the process of preparing and executing SQL expressions.
  */
 public abstract class Prepare {
-  public static final String connectionVariable = "connection";
   protected static final Logger tracer = EigenbaseTrace.getStatementTracer();
   protected final CatalogReader catalogReader;
   protected String queryString = null;

File: core/src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -462,8 +462,8 @@ static OptiqConnection getConnection(
     BasicDataSource dataSource = new BasicDataSource();
     dataSource.setDriverClassName(JDBC_DRIVER);
     dataSource.setUrl(JDBC_URL);
-    dataSource.setUsername("foodmart");
-    dataSource.setPassword("foodmart");
+    dataSource.setUsername("FOODMART");
+    dataSource.setPassword("FOODMART");
 
     JdbcSchema foodmart =
         JdbcSchema.create(

File: core/src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -54,11 +54,11 @@ public class OptiqAssert {
   private static final DateFormat UTC_TIMESTAMP_FORMAT;
   static {
     final TimeZone utc = TimeZone.getTimeZone("UTC");
-    UTC_DATE_FORMAT = new SimpleDateFormat("YYYY-MM-dd");
+    UTC_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");
     UTC_DATE_FORMAT.setTimeZone(utc);
     UTC_TIME_FORMAT = new SimpleDateFormat("HH:mm:ss");
     UTC_TIME_FORMAT.setTimeZone(utc);
-    UTC_TIMESTAMP_FORMAT = new SimpleDateFormat("YYYY-MM-dd'T'HH:mm:ss'Z'");
+    UTC_TIMESTAMP_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
     UTC_TIMESTAMP_FORMAT.setTimeZone(utc);
   }
 

File: core/src/main/java/org/eigenbase/util/JsonBuilder.java
Patch:
@@ -71,7 +71,9 @@ public String toJsonString(Object o) {
 
     /** Appends a JSON object to a string builder. */
     private void append(StringBuilder buf, int indent, Object o) {
-        if (o instanceof Map) {
+        if (o == null) {
+            buf.append("null");
+        } else if (o instanceof Map) {
             //noinspection unchecked
             appendMap(buf, indent, (Map) o);
         } else if (o instanceof List) {

File: core/src/main/java/net/hydromatic/optiq/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -29,6 +29,7 @@
 import org.eigenbase.reltype.*;
 import org.eigenbase.sql.type.*;
 import org.eigenbase.util.Pair;
+import org.eigenbase.util.Util;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -250,8 +251,7 @@ private SyntheticRecordType(RelDataType relType, String name) {
       this.relType = relType;
       this.name = name;
       assert relType == null
-             || new HashSet<String>(relType.getFieldNames()).size()
-                == relType.getFieldNames().size()
+             || Util.isDistinct(relType.getFieldNames())
           : "field names not distinct: " + relType;
     }
 

File: core/src/main/java/org/eigenbase/rel/CorrelatorRel.java
Patch:
@@ -22,6 +22,7 @@
 import org.eigenbase.relopt.*;
 import org.eigenbase.rex.*;
 
+import com.google.common.collect.ImmutableSet;
 
 /**
  * A <code>CorrelatorRel</code> behaves like a kind of {@link JoinRel}, but
@@ -70,7 +71,7 @@ public CorrelatorRel(
             right,
             joinCond,
             joinType,
-            Collections.<String>emptySet());
+            ImmutableSet.<String>of());
         this.correlations = correlations;
         assert (joinType == JoinRelType.LEFT)
             || (joinType == JoinRelType.INNER);

File: core/src/main/java/org/eigenbase/rel/JoinRel.java
Patch:
@@ -141,7 +141,7 @@ public JoinRel copy(
             right,
             conditionExpr,
             this.joinType,
-            new HashSet<String>(this.variablesStopped),
+            this.variablesStopped,
             this.semiJoinDone,
             systemFieldList);
     }

File: core/src/main/java/org/eigenbase/rel/rules/PushJoinThroughUnionRule.java
Patch:
@@ -22,6 +22,7 @@
 import org.eigenbase.rel.*;
 import org.eigenbase.relopt.*;
 
+import com.google.common.collect.ImmutableSet;
 
 /**
  * PushJoinThroughUnionRule implements the rule for pushing a
@@ -100,7 +101,7 @@ public void onMatch(RelOptRuleCall call)
                     joinRight,
                     joinRel.getCondition(),
                     joinRel.getJoinType(),
-                    Collections.<String>emptySet()));
+                    ImmutableSet.<String>of()));
         }
         UnionRel newUnionRel = new UnionRel(cluster, newUnionInputs, true);
         call.transformTo(newUnionRel);

File: core/src/main/java/org/eigenbase/rel/rules/SemiJoinRel.java
Patch:
@@ -26,6 +26,7 @@
 import org.eigenbase.rex.*;
 import org.eigenbase.util.ImmutableIntList;
 
+import com.google.common.collect.ImmutableSet;
 
 /**
  * A SemiJoinRel represents two relational expressions joined according to some
@@ -68,7 +69,7 @@ public SemiJoinRel(
             right,
             condition,
             JoinRelType.INNER,
-            Collections.<String>emptySet());
+            ImmutableSet.<String>of());
         this.leftKeys = ImmutableIntList.copyOf(leftKeys);
         this.rightKeys = ImmutableIntList.copyOf(rightKeys);
     }

File: core/src/main/java/org/eigenbase/relopt/hep/HepRuleCall.java
Patch:
@@ -55,7 +55,7 @@ public class HepRuleCall
     //~ Methods ----------------------------------------------------------------
 
     // implement RelOptRuleCall
-    public void transformTo(RelNode rel)
+    public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv)
     {
         final RelNode rel0 = rels[0];
         RelOptUtil.verifyTypeEquivalence(rel0, rel, rel0);

File: core/src/main/java/org/eigenbase/sql2rel/RelStructuredTypeFlattener.java
Patch:
@@ -29,6 +29,7 @@
 import org.eigenbase.util.*;
 import org.eigenbase.util.mapping.Mappings;
 
+import net.hydromatic.linq4j.function.Function1;
 
 // TODO jvs 10-Feb-2005:  factor out generic rewrite helper, with the
 // ability to map between old and new rels and field ordinals.  Also,
@@ -271,7 +272,7 @@ protected int getNewForOldInput(int oldOrdinal)
     private Mappings.TargetMapping getNewForOldInputMapping(RelNode oldRel) {
         final RelNode newRel = getNewForOldRel(oldRel);
         return Mappings.target(
-            new Util.Function1<Integer, Integer>() {
+            new Function1<Integer, Integer>() {
                 public Integer apply(Integer oldInput) {
                     return getNewForOldInput(oldInput);
                 }

File: core/src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -43,6 +43,7 @@
 import net.hydromatic.linq4j.Ord;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 
 /**
  * Converts a SQL parse tree (consisting of {@link org.eigenbase.sql.SqlNode}
@@ -2055,7 +2056,7 @@ protected RelNode createJoin(
             rightRel,
             joinCond,
             joinType,
-            Collections.<String>emptySet());
+            ImmutableSet.<String>of());
     }
 
     /**
@@ -3314,7 +3315,7 @@ public SqlNode getNode()
                     relNode,
                     rexBuilder.makeLiteral(true),
                     JoinRelType.INNER,
-                    Collections.<String>emptySet());
+                    ImmutableSet.<String>of());
         }
         return ret;
     }

File: core/src/main/java/org/eigenbase/util/mapping/Mappings.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.eigenbase.util.*;
 
+import net.hydromatic.linq4j.function.Function1;
 
 /**
  * Utility functions related to mappings.
@@ -284,7 +285,7 @@ public static TargetMapping target(
     }
 
     public static TargetMapping target(
-        Util.Function1<Integer, Integer> function,
+        Function1<Integer, Integer> function,
         int sourceCount,
         int targetCount)
     {
@@ -552,8 +553,7 @@ public String toString()
             StringBuilder buf = new StringBuilder();
             buf.append("[");
             int i = 0;
-            for (final Iterator<IntPair> iter = iterator(); iter.hasNext();) {
-                IntPair pair = iter.next();
+            for (IntPair pair : this) {
                 if (i++ > 0) {
                     buf.append(", ");
                 }

File: core/src/test/java/net/hydromatic/optiq/test/OptiqSuite.java
Patch:
@@ -19,6 +19,7 @@
 
 import net.hydromatic.optiq.impl.clone.ArrayTableTest;
 
+import net.hydromatic.optiq.util.PartiallyOrderedSetTest;
 import net.hydromatic.optiq.util.graph.DirectedGraphTest;
 
 import org.eigenbase.relopt.RelOptUtilTest;
@@ -40,6 +41,7 @@
 @Suite.SuiteClasses({
     ArrayTableTest.class,
     ArrayQueueTest.class,
+    PartiallyOrderedSetTest.class,
     DirectedGraphTest.class,
     ReflectVisitorTest.class,
     RelOptUtilTest.class,

File: core/src/test/java/org/eigenbase/test/MockRelOptPlanner.java
Patch:
@@ -221,7 +221,7 @@ private class MockRuleCall
         }
 
         // implement RelOptRuleCall
-        public void transformTo(RelNode rel)
+        public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv)
         {
             transformationResult = rel;
         }

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -63,8 +63,8 @@ abstract class OptiqConnectionImpl implements OptiqConnection, QueryProvider {
   final UnregisteredDriver driver;
   final net.hydromatic.optiq.jdbc.Factory factory;
   final Function0<OptiqPrepare> prepareFactory;
-  private final String url;
-  private final Properties info;
+  final String url;
+  final Properties info;
   private String schema;
   private final OptiqDatabaseMetaData metaData;
   final Helper helper = Helper.INSTANCE;

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqPrepare.java
Patch:
@@ -194,7 +194,7 @@ private Enumerable<T> getEnumerable(DataContext dataContext) {
       if (maxRowCount >= 0) {
         // Apply limit. In JDBC 0 means "no limit". But for us, -1 means
         // "no limit", and 0 is a valid limit.
-        enumerable = enumerable.take(maxRowCount);
+        enumerable = EnumerableDefaults.take(enumerable, maxRowCount);
       }
       return enumerable;
     }

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java
Patch:
@@ -310,11 +310,11 @@ public InputStream getBinaryStream(String columnLabel) throws SQLException {
   }
 
   public SQLWarning getWarnings() throws SQLException {
-    throw new UnsupportedOperationException();
+    return null; // no warnings, since warnings are not supported
   }
 
   public void clearWarnings() throws SQLException {
-    throw new UnsupportedOperationException();
+    // no-op since warnings are not supported
   }
 
   public String getCursorName() throws SQLException {

File: core/src/main/java/org/eigenbase/relopt/RelOptUtil.java
Patch:
@@ -2342,7 +2342,7 @@ public void visit(
     public static class VariableUsedVisitor
         extends RexShuttle
     {
-        public final Set<String> variables = new HashSet<String>();
+        public final Set<String> variables = new LinkedHashSet<String>();
 
         public RexNode visitCorrelVariable(RexCorrelVariable p)
         {

File: core/src/main/java/net/hydromatic/optiq/jdbc/Meta.java
Patch:
@@ -500,6 +500,8 @@ public NamedFieldGetter(Class clazz, String... names) {
           throw new RuntimeException(e);
         }
         Pair<Integer, String> pair = lookupType(field.getType());
+        ColumnMetaData.Rep rep =
+            ColumnMetaData.Rep.VALUE_MAP.get(field.getType());
         columnNames.add(
             new ColumnMetaData(
                 index, false, true, false, false,
@@ -508,7 +510,7 @@ public NamedFieldGetter(Class clazz, String... names) {
                     : DatabaseMetaData.columnNoNulls,
                 true, -1, name, name, null,
                 0, 0, null, null, pair.left, pair.right, true,
-                false, false, null, field.getType()));
+                false, false, null, rep));
         fields.add(field);
       }
     }

File: core/src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java
Patch:
@@ -34,7 +34,6 @@
  */
 public class OptiqResultSet implements ResultSet {
   private final OptiqStatement statement;
-  private final boolean[] wasNull = {false};
   private final List<ColumnMetaData> columnMetaDataList;
   private final Function0<Cursor> cursorFactory;
   private final ResultSetMetaData resultSetMetaData;
@@ -169,7 +168,7 @@ public boolean next() throws SQLException {
   }
 
   public boolean wasNull() throws SQLException {
-    return wasNull[0];
+    return cursor.wasNull();
   }
 
   public String getString(int columnIndex) throws SQLException {

File: core/src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -167,7 +167,7 @@ protected RelOptPlanner createPlanner(Context context) {
     planner.addRule(ReduceAggregatesRule.instance);
     planner.addRule(SwapJoinRule.instance);
     planner.addRule(PushJoinThroughJoinRule.RIGHT);
-//    planner.addRule(PushJoinThroughJoinRule.LEFT);
+    planner.addRule(PushJoinThroughJoinRule.LEFT);
     planner.addRule(WindowedAggSplitterRule.INSTANCE);
     context.spark().registerRules(planner);
     return planner;

File: core/src/main/java/org/eigenbase/relopt/volcano/RelSubset.java
Patch:
@@ -426,7 +426,8 @@ public RelNode visit(
             if (!inputs.equals(oldInputs)) {
                 final RelNode pOld = p;
                 p = p.copy(p.getTraitSet(), inputs);
-                planner.provenanceMap.put(p, pOld);
+                planner.provenanceMap.put(
+                    p, new VolcanoPlanner.DirectProvenance(pOld));
             }
             return p;
         }

File: core/src/main/java/net/hydromatic/optiq/rules/java/RexToLixTranslator.java
Patch:
@@ -29,7 +29,6 @@
 import org.eigenbase.reltype.RelDataTypeFactoryImpl;
 import org.eigenbase.rex.*;
 import org.eigenbase.sql.*;
-import org.eigenbase.sql.type.SqlTypeName;
 import org.eigenbase.util.*;
 
 import java.lang.reflect.Method;

File: core/src/main/java/org/eigenbase/sql2rel/SqlNodeToRexConverterImpl.java
Patch:
@@ -146,14 +146,14 @@ public RexNode convertLiteral(
                 (SqlIntervalLiteral.IntervalValue) value;
             l = SqlParserUtil.intervalToMonths(intervalValue);
             return rexBuilder.makeIntervalLiteral(
-                l,
+                BigDecimal.valueOf(l),
                 intervalValue.getIntervalQualifier());
         case INTERVAL_DAY_TIME:
             intervalValue =
                 (SqlIntervalLiteral.IntervalValue) value;
             l = SqlParserUtil.intervalToMillis(intervalValue);
             return rexBuilder.makeIntervalLiteral(
-                l,
+                BigDecimal.valueOf(l),
                 intervalValue.getIntervalQualifier());
         default:
             throw Util.unexpected(literal.getTypeName());

File: core/src/main/java/net/hydromatic/optiq/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -122,17 +122,19 @@ public Type getJavaClass(RelDataType type) {
     if (type.isStruct() && type.getFieldCount() == 1) {
       return getJavaClass(type.getFieldList().get(0).getType());
     }
-    if (type instanceof BasicSqlType) {
+    if (type instanceof BasicSqlType || type instanceof IntervalSqlType) {
       switch (type.getSqlTypeName()) {
       case VARCHAR:
       case CHAR:
         return String.class;
       case DATE:
       case TIME:
       case INTEGER:
+      case INTERVAL_YEAR_MONTH:
         return type.isNullable() ? Integer.class : int.class;
       case TIMESTAMP:
       case BIGINT:
+      case INTERVAL_DAY_TIME:
         return type.isNullable() ? Long.class : long.class;
       case SMALLINT:
         return type.isNullable() ? Short.class : short.class;

File: core/src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -2668,7 +2668,7 @@ public void validateLiteral(SqlLiteral literal)
             if (literal instanceof SqlIntervalLiteral) {
                 SqlIntervalLiteral.IntervalValue interval =
                     (SqlIntervalLiteral.IntervalValue)
-                    ((SqlIntervalLiteral) literal).getValue();
+                    literal.getValue();
                 SqlIntervalQualifier intervalQualifier =
                     interval.getIntervalQualifier();
 

File: core/src/main/java/net/hydromatic/optiq/rules/java/JavaRules.java
Patch:
@@ -20,7 +20,6 @@
 import net.hydromatic.optiq.BuiltinMethod;
 import net.hydromatic.optiq.ModifiableTable;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
-import net.hydromatic.optiq.jdbc.JavaTypeFactoryImpl;
 import net.hydromatic.optiq.prepare.Prepare;
 import net.hydromatic.optiq.runtime.SortedMultiMap;
 
@@ -1831,7 +1830,7 @@ public RelOptCost computeSelfCost(RelOptPlanner planner) {
     }
 
     public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
-      final JavaTypeFactoryImpl typeFactory = implementor.getTypeFactory();
+      final JavaTypeFactory typeFactory = implementor.getTypeFactory();
       final EnumerableRel child = (EnumerableRel) getChild();
 
       final BlockBuilder builder = new BlockBuilder();

File: core/src/main/java/org/eigenbase/rex/RexSqlStandardConvertletTable.java
Patch:
@@ -94,9 +94,7 @@ public RexSqlStandardConvertletTable()
         registerEquivOp(SqlStdOperatorTable.convertFunc);
         registerEquivOp(SqlStdOperatorTable.translateFunc);
         registerEquivOp(SqlStdOperatorTable.overlayFunc);
-        registerEquivOp(SqlStdOperatorTable.trimBothFunc);
-        registerEquivOp(SqlStdOperatorTable.trimLeadingFunc);
-        registerEquivOp(SqlStdOperatorTable.trimTrailingFunc);
+        registerEquivOp(SqlStdOperatorTable.trimFunc);
         registerEquivOp(SqlStdOperatorTable.positionFunc);
         registerEquivOp(SqlStdOperatorTable.charLengthFunc);
         registerEquivOp(SqlStdOperatorTable.characterLengthFunc);

File: core/src/main/java/org/eigenbase/sql/SqlFunction.java
Patch:
@@ -270,7 +270,7 @@ private RelDataType deriveType(
             // if we have a match on function name and parameter count, but
             // couldn't find a function with  a COLUMN_LIST type, retry, but
             // this time, don't convert the row argument to a COLUMN_LIST type;
-            // if we did find a match, go back and revalidate the row operands
+            // if we did find a match, go back and re-validate the row operands
             // (corresponding to column references), now that we can set the
             // scope to that of the source cursor referenced by that ColumnList
             // type
@@ -283,7 +283,7 @@ private RelDataType deriveType(
                         getFunctionType()))
                 {
                     // remove the already validated node types corresponding to
-                    // row arguments before revalidating
+                    // row arguments before re-validating
                     for (SqlNode operand : operands) {
                         if (operand.getKind() == SqlKind.ROW) {
                             validator.removeValidatedNodeType(operand);

File: core/src/main/java/org/eigenbase/sql2rel/SqlNodeToRexConverterImpl.java
Patch:
@@ -18,7 +18,6 @@
 package org.eigenbase.sql2rel;
 
 import java.math.*;
-
 import java.util.*;
 
 import org.eigenbase.reltype.*;
@@ -29,6 +28,7 @@
 import org.eigenbase.sql.validate.*;
 import org.eigenbase.util.*;
 
+import net.hydromatic.optiq.runtime.ByteString;
 
 /**
  * Standard implementation of {@link SqlNodeToRexConverter}.
@@ -126,8 +126,8 @@ public RexNode convertLiteral(
 
             // An even number of hexits (e.g. X'ABCD') makes whole number
             // of bytes.
-            byte [] bytes = bitString.getAsByteArray();
-            return rexBuilder.makeBinaryLiteral(bytes);
+            ByteString byteString = new ByteString(bitString.getAsByteArray());
+            return rexBuilder.makeBinaryLiteral(byteString);
         case SYMBOL:
             return rexBuilder.makeFlag(value);
         case TIMESTAMP:

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/EnumerableToSparkConverter.java
Patch:
@@ -67,7 +67,8 @@ public Result implementSpark(Implementor implementor) {
     final Expression source = null; // TODO:
     final Expression sparkContext =
         Expressions.call(
-            SparkMethod.GET_SPARK_CONTEXT.method);
+            SparkMethod.GET_SPARK_CONTEXT.method,
+            implementor.root);
     final Expression rdd =
         list.append(
             "rdd",

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/SparkMethod.java
Patch:
@@ -19,6 +19,8 @@
 
 import net.hydromatic.linq4j.Enumerable;
 import net.hydromatic.linq4j.expressions.Types;
+import net.hydromatic.optiq.DataContext;
+
 import org.apache.spark.api.java.JavaRDD;
 import org.apache.spark.api.java.JavaSparkContext;
 
@@ -36,7 +38,7 @@ public enum SparkMethod {
       Object[].class),
   CREATE_RDD(SparkRuntime.class, "createRdd", JavaSparkContext.class,
       Enumerable.class),
-  GET_SPARK_CONTEXT(SparkRuntime.class, "getSparkContext");
+  GET_SPARK_CONTEXT(SparkRuntime.class, "getSparkContext", DataContext.class);
 
   public final Method method;
 

File: spark/src/main/java/net/hydromatic/optiq/impl/spark/SparkToEnumerableConverter.java
Patch:
@@ -87,10 +87,11 @@ public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
 
   /** Implementation of
    * {@link net.hydromatic.optiq.impl.spark.SparkRel.Implementor}. */
-  private static class SparkImplementorImpl implements SparkRel.Implementor {
+  private static class SparkImplementorImpl extends SparkRel.Implementor {
     private final EnumerableRelImplementor implementor;
 
     public SparkImplementorImpl(EnumerableRelImplementor implementor) {
+      super(implementor.getRexBuilder());
       this.implementor = implementor;
     }
 

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcImplementor.java
Patch:
@@ -410,7 +410,7 @@ SqlSelect asSelect() {
 
     /** Converts a non-query node into a SELECT node. Set operators (UNION,
      * INTERSECT, EXCEPT) remain as is. */
-    SqlNode asQuery() {
+    public SqlNode asQuery() {
       if (node instanceof SqlCall
           && ((SqlCall) node).getOperator() instanceof SqlSetOperator) {
         return node;

File: core/src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcSchema.java
Patch:
@@ -52,7 +52,7 @@ public class JdbcSchema implements Schema {
   final String schema;
   final JavaTypeFactory typeFactory;
   private final Expression expression;
-  final SqlDialect dialect;
+  public final SqlDialect dialect;
   final JdbcConvention convention;
 
   /**

File: core/src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -186,7 +186,7 @@ public class ReflectiveSchemaTest {
     assertEquals(
         "empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
         + "empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n",
-        JdbcTest.toString(resultSet));
+        OptiqAssert.toString(resultSet));
   }
 
   /**

File: src/main/java/net/hydromatic/optiq/runtime/FlatLists.java
Patch:
@@ -378,9 +378,9 @@ public boolean equals(Object o) {
 
     public int hashCode() {
       int h = 1;
-      h = h * 31 + t0.hashCode();
-      h = h * 31 + t1.hashCode();
-      h = h * 31 + t2.hashCode();
+      h = h * 31 + Utilities.hash(t0);
+      h = h * 31 + Utilities.hash(t1);
+      h = h * 31 + Utilities.hash(t2);
       return h;
     }
 

File: src/main/java/org/eigenbase/rel/TableAccessRelBase.java
Patch:
@@ -25,7 +25,6 @@
 import org.eigenbase.rex.RexNode;
 import org.eigenbase.util.Util;
 
-
 /**
  * <code>TableAccessRelBase</code> is an abstract base class for implementations
  * of {@link TableAccessRel}.
@@ -41,7 +40,7 @@ public abstract class TableAccessRelBase
     /**
      * The table definition.
      */
-    protected RelOptTable table;
+    protected final RelOptTable table;
 
     //~ Constructors -----------------------------------------------------------
 

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -241,7 +241,7 @@ public SQLWarning getWarnings() throws SQLException {
   }
 
   public void clearWarnings() throws SQLException {
-    throw new UnsupportedOperationException();
+    // no-op since connection pooling often calls this.
   }
 
   public Statement createStatement(

File: src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -334,9 +334,9 @@ public void onStatementClose(OptiqStatement statement) {
         rootSchema, "hr", new HrSchema());
     connection.setSchema("hr");
     final Statement statement = connection.createStatement();
-    assertFalse(statement.isCloseOnCompletion());
-    statement.closeOnCompletion();
-    assertTrue(statement.isCloseOnCompletion());
+    assertFalse((Boolean) OptiqAssert.call(statement, "isCloseOnCompletion"));
+    OptiqAssert.call(statement, "closeOnCompletion");
+    assertTrue((Boolean) OptiqAssert.call(statement, "isCloseOnCompletion"));
     final ResultSet resultSet =
         statement.executeQuery("select * from \"emps\"");
 

File: src/main/java/org/eigenbase/relopt/volcano/VolcanoCost.java
Patch:
@@ -107,8 +107,9 @@ public boolean isLe(RelOptCost other)
         VolcanoCost that = (VolcanoCost) other;
         return (this == that)
             || ((this.dRows <= that.dRows)
-                && (this.dCpu <= that.dCpu)
-                && (this.dIo <= that.dIo));
+//                && (this.dCpu <= that.dCpu)
+//                && (this.dIo <= that.dIo)
+        );
     }
 
     public boolean isLt(RelOptCost other)

File: src/main/java/net/hydromatic/optiq/impl/java/ReflectiveSchema.java
Patch:
@@ -21,6 +21,7 @@
 import net.hydromatic.linq4j.expressions.*;
 
 import net.hydromatic.optiq.*;
+import net.hydromatic.optiq.Parameter;
 import net.hydromatic.optiq.impl.TableInSchemaImpl;
 
 import org.eigenbase.reltype.RelDataType;

File: src/main/java/net/hydromatic/optiq/rules/java/PhysTypeImpl.java
Patch:
@@ -243,7 +243,7 @@ public Pair<Expression, Expression> generateCollationKey(
                   Expressions.call(
                       Utilities.class,
                       fieldNullable(index)
-                          ? (nullsFirst != descending
+                          ? (nullsFirst
                           ? "compareNullsFirst"
                           : "compareNullsLast")
                           : "compare",

File: src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -1038,9 +1038,9 @@ public void testOrderByOnSortedTable2() {
             "[deptno INTEGER NOT NULL, empid INTEGER NOT NULL, commission INTEGER, RCNF INTEGER, RCNL INTEGER, R INTEGER, RD INTEGER]")
         .returns(
             "deptno=20; empid=200; commission=500; RCNF=1; RCNL=1; R=1; RD=1\n"
-            + "deptno=10; empid=150; commission=null; RCNF=3; RCNL=3; R=3; RD=1\n"
-            + "deptno=10; empid=110; commission=250; RCNF=2; RCNL=2; R=2; RD=2\n"
-            + "deptno=10; empid=100; commission=1000; RCNF=1; RCNL=1; R=1; RD=3\n");
+            + "deptno=10; empid=150; commission=null; RCNF=1; RCNL=3; R=3; RD=1\n"
+            + "deptno=10; empid=110; commission=250; RCNF=3; RCNL=2; R=2; RD=2\n"
+            + "deptno=10; empid=100; commission=1000; RCNF=2; RCNL=1; R=1; RD=3\n");
   }
 
   /** Tests WHERE comparing a nullable integer with an integer literal. */

File: src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -98,7 +98,6 @@ public enum BuiltinMethod {
   SORTED_MULTI_MAP_PUT_MULTI(SortedMultiMap.class, "putMulti", Object.class,
       Object.class),
   SORTED_MULTI_MAP_ARRAYS(SortedMultiMap.class, "arrays", Comparator.class),
-  SORTED_MULTI_MAP_LENGTH(SortedMultiMap.class, "length", Object[].class),
   ARRAY_ITEM(SqlFunctions.class, "arrayItem", List.class, int.class),
   MAP_ITEM(SqlFunctions.class, "mapItem", Map.class, Object.class),
   ANY_ITEM(SqlFunctions.class, "item", Object.class, Object.class),

File: src/main/java/net/hydromatic/optiq/impl/mongodb/MongoTable.java
Patch:
@@ -82,9 +82,8 @@ public Expression getExpression() {
         Expressions.call(
             schema.getExpression(),
             "getTable",
-            Expressions.<Expression>list()
-                .append(Expressions.constant(tableName))
-                .append(Expressions.constant(getElementType()))),
+            Expressions.constant(tableName),
+            Expressions.constant(getElementType())),
         MongoTable.class);
   }
 

File: src/main/java/net/hydromatic/optiq/jdbc/Meta.java
Patch:
@@ -567,9 +567,8 @@ public Expression getExpression() {
       return Expressions.call(
           schema.getExpression(),
           "getTable",
-          Expressions.<Expression>list()
-              .append(Expressions.constant(tableName))
-              .append(Expressions.constant(getElementType())));
+          Expressions.constant(tableName),
+          Expressions.constant(getElementType()));
     }
 
     public QueryProvider getProvider() {

File: src/main/java/net/hydromatic/optiq/runtime/SqlFunctions.java
Patch:
@@ -492,7 +492,7 @@ public static long mod(long b0, long b1) {
 
   // temporary
   public static BigDecimal mod(BigDecimal b0, int b1) {
-    return mod(b0, new BigDecimal(b1));
+    return mod(b0, BigDecimal.valueOf(b1));
   }
 
   // temporary

File: src/main/java/org/eigenbase/rel/RelFieldCollation.java
Patch:
@@ -84,7 +84,7 @@ public enum NullDirection {
     /**
      * Direction of sorting.
      */
-    private final Direction direction;
+    public final Direction direction;
 
     /**
      * Direction of sorting of nulls.

File: src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -35,7 +35,6 @@
 
 import net.hydromatic.linq4j.Linq4j;
 
-
 /**
  * Default implementation of {@link SqlValidator}.
  *
@@ -4385,7 +4384,9 @@ protected SqlNode visitScoped(SqlCall call)
             ArgHandler<SqlNode> argHandler =
                 new CallCopyingArgHandler(call, false);
             call.getOperator().acceptCall(this, call, true, argHandler);
-            return argHandler.result();
+          final SqlNode result = argHandler.result();
+          validator.setOriginal(result, call);
+          return result;
         }
     }
 

File: src/test/java/org/eigenbase/test/SargTest.java
Patch:
@@ -30,7 +30,6 @@
 
 import static org.junit.Assert.*;
 
-
 /**
  * Tests for the {@link org.eigenbase.sarg} class library.
  *
@@ -86,11 +85,11 @@ public SargTest() {
 
         rexBuilder = new RexBuilder(typeFactory);
         intLiteral7 = rexBuilder.makeExactLiteral(
-            new BigDecimal(7),
+            BigDecimal.valueOf(7),
             intType);
         intLiteral490 =
             rexBuilder.makeExactLiteral(
-                new BigDecimal(490),
+                BigDecimal.valueOf(490),
                 intType);
         intLiteral8point5 =
             rexBuilder.makeExactLiteral(

File: src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -87,6 +87,7 @@ public enum BuiltinMethod {
   MAP_PUT(Map.class, "put", Object.class, Object.class),
   MAP_GET(Map.class, "get", Object.class),
   LIST_ADD(List.class, "add", Object.class),
+  LIST_GET(List.class, "get", int.class),
   ARRAY_ITEM(SqlFunctions.class, "arrayItem", List.class, int.class),
   MAP_ITEM(SqlFunctions.class, "mapItem", Map.class, Object.class),
   ANY_ITEM(SqlFunctions.class, "item", Object.class, Object.class),

File: src/main/java/net/hydromatic/optiq/rules/java/EnumerableRelImplementor.java
Patch:
@@ -65,9 +65,9 @@ public EnumerableRel.Result visitChild(
     return child.implement(this, prefer);
   }
 
-  public ClassDeclaration implementRoot(EnumerableRel rootRel) {
-    final EnumerableRel.Result implement =
-        rootRel.implement(this, EnumerableRel.Prefer.ANY);
+  public ClassDeclaration implementRoot(EnumerableRel rootRel,
+      EnumerableRel.Prefer prefer) {
+    final EnumerableRel.Result implement = rootRel.implement(this, prefer);
     List<MemberDeclaration> memberDeclarations =
         new ArrayList<MemberDeclaration>();
     declareSyntheticClasses(implement.expression, memberDeclarations);

File: src/main/java/net/hydromatic/optiq/runtime/Utilities.java
Patch:
@@ -157,7 +157,7 @@ public static int compareNullsLast(List v0, List v1) {
     return v0 == v1 ? 0
         : v0 == null ? 1
             : v1 == null ? -1
-                : FlatLists.ComparableList.compare(v0, v1);
+                : FlatLists.ComparableListImpl.compare(v0, v1);
   }
 }
 

File: src/main/java/net/hydromatic/optiq/rules/java/JavaRowFormat.java
Patch:
@@ -85,7 +85,7 @@ public Expression field(
     }
   },
 
-  EMPTY_LIST() {
+  EMPTY_LIST {
     Type javaRowClass(
         JavaTypeFactory typeFactory,
         RelDataType type) {

File: src/main/java/org/eigenbase/rel/AggregateRel.java
Patch:
@@ -70,7 +70,7 @@ public AggregateRel(
 
     @Override
     public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new AggregateRel(
             getCluster(),
             sole(inputs),

File: src/main/java/org/eigenbase/rel/FilterRel.java
Patch:
@@ -58,7 +58,7 @@ public FilterRel(
 
 
     public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-        assert traitSet.contains(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new FilterRel(
             getCluster(),
             sole(inputs),

File: src/main/java/org/eigenbase/rel/IntersectRel.java
Patch:
@@ -52,7 +52,7 @@ public IntersectRel(
     public IntersectRel copy(
         RelTraitSet traitSet, List<RelNode> inputs, boolean all)
     {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new IntersectRel(
             getCluster(),
             inputs,

File: src/main/java/org/eigenbase/rel/JoinRel.java
Patch:
@@ -134,7 +134,7 @@ public JoinRel copy(
         RelNode left,
         RelNode right)
     {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new JoinRel(
             getCluster(),
             left,

File: src/main/java/org/eigenbase/rel/MinusRel.java
Patch:
@@ -53,7 +53,7 @@ public MinusRel(
     public MinusRel copy(
         RelTraitSet traitSet, List<RelNode> inputs, boolean all)
     {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new MinusRel(
             getCluster(),
             inputs,

File: src/main/java/org/eigenbase/rel/ProjectRel.java
Patch:
@@ -104,7 +104,7 @@ public ProjectRel(
     //~ Methods ----------------------------------------------------------------
 
     public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-        assert traitSet.contains(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new ProjectRel(
             getCluster(),
             sole(inputs),

File: src/main/java/org/eigenbase/rel/TableModificationRel.java
Patch:
@@ -62,7 +62,7 @@ public TableModificationRel(
     @Override
     public TableModificationRel copy(RelTraitSet traitSet, List<RelNode> inputs)
     {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new TableModificationRel(
             getCluster(),
             table,

File: src/main/java/org/eigenbase/rel/UnionRel.java
Patch:
@@ -52,7 +52,7 @@ public UnionRel(
     public UnionRel copy(
         RelTraitSet traitSet, List<RelNode> inputs, boolean all)
     {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.containsIfApplicable(Convention.NONE);
         return new UnionRel(
             getCluster(),
             inputs,

File: src/main/java/org/eigenbase/rel/rules/ReduceAggregatesRule.java
Patch:
@@ -228,8 +228,8 @@ private RexNode reduceAvg(
         RelDataType sumType =
             typeFactory.createTypeWithNullability(
                 avgInputType,
-                avgInputType.isNullable() || nGroups == 0);
-        SqlSumAggFunction sumAgg = new SqlSumAggFunction(sumType);
+                avgInputType.isNullable());
+        SqlAggFunction sumAgg = new SqlSumAggFunction(sumType);
         AggregateCall sumCall =
             new AggregateCall(
                 sumAgg,

File: src/main/java/org/eigenbase/relopt/RelOptRuleOperand.java
Patch:
@@ -133,7 +133,7 @@ protected RelOptRuleOperand(
             break;
         default:
             this.matchAnyChildren = false;
-            assert children.length == 1;
+            assert children.length > 0;
         }
         this.clazz = clazz;
         this.trait = trait;

File: src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -535,7 +535,8 @@ protected void convertSelectImpl(
             select.getOrderList(),
             orderExprList,
             collationList);
-        final RelCollationImpl collation = new RelCollationImpl(collationList);
+        final RelCollationImpl collation =
+            cluster.traitSetOf().canonize(new RelCollationImpl(collationList));
 
         if (validator.isAggregate(select)) {
             convertAgg(

File: src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcRules.java
Patch:
@@ -733,7 +733,7 @@ public RelNode convert(RelNode rel) {
           valuesRel.getCluster(),
           valuesRel.getRowType(),
           valuesRel.getTuples(),
-          valuesRel.getTraitSet().plus(out));
+          valuesRel.getTraitSet().replace(out));
     }
   }
 

File: src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcToEnumerableConverterRule.java
Patch:
@@ -40,9 +40,7 @@ public class JdbcToEnumerableConverterRule extends ConverterRule {
 
   @Override
   public RelNode convert(RelNode rel) {
-    RelTraitSet newTraitSet =
-        rel.getTraitSet().replace(
-            ConventionTraitDef.instance, getOutTrait());
+    RelTraitSet newTraitSet = rel.getTraitSet().replace(getOutTrait());
     return new JdbcToEnumerableConverter(
         rel.getCluster(), newTraitSet, rel);
   }

File: src/main/java/net/hydromatic/optiq/impl/mongodb/MongoRules.java
Patch:
@@ -84,8 +84,7 @@ public void onMatch(RelOptRuleCall call) {
           new MongoTableScan(cluster, table.getTraitSet(), table.getTable(),
               table.mongoTable, rowType, ops);
       final ProjectRel newProject =
-          new ProjectRel(cluster, newTable,
-              newProjects.toArray(new RexNode[newProjects.size()]),
+          new ProjectRel(cluster, newTable, newProjects,
               project.getRowType(), ProjectRel.Flags.Boxed,
               Collections.<RelCollation>emptyList());
       call.transformTo(newProject);

File: src/main/java/net/hydromatic/optiq/impl/mongodb/MongoToEnumerableConverterRule.java
Patch:
@@ -40,9 +40,7 @@ private MongoToEnumerableConverterRule() {
 
   @Override
   public RelNode convert(RelNode rel) {
-    RelTraitSet newTraitSet =
-        rel.getTraitSet().replace(
-            ConventionTraitDef.instance, getOutConvention());
+    RelTraitSet newTraitSet = rel.getTraitSet().replace(getOutConvention());
     return new MongoToEnumerableConverter(rel.getCluster(), newTraitSet, rel);
   }
 }

File: src/main/java/net/hydromatic/optiq/prepare/LixToRelTranslator.java
Patch:
@@ -125,7 +125,7 @@ public RelNode translate(Expression expression) {
         "unknown expression type " + expression.getNodeType());
   }
 
-  private RexNode[] toRex(
+  private List<RexNode> toRex(
       RelNode child, FunctionExpression expression) {
     List<RexNode> list = new ArrayList<RexNode>();
     RexBuilder rexBuilder = cluster.getRexBuilder();
@@ -141,7 +141,7 @@ private RexNode[] toRex(
     for (Expression expression1 : fieldExpressions(simple)) {
       rexList.add(translator.toRex(expression1));
     }
-    return rexList.toArray(new RexNode[rexList.size()]);
+    return rexList;
   }
 
   List<Expression> fieldExpressions(Expression expression) {

File: src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -362,10 +362,9 @@ public PreparedResult prepareQueryable(
       init(runtimeContextClass);
 
       final RelOptQuery query = new RelOptQuery(planner);
-      final RelTraitSet emptyTraitSet = planner.emptyTraitSet();
       final RelOptCluster cluster =
           query.createCluster(
-              rexBuilder.getTypeFactory(), rexBuilder, emptyTraitSet);
+              rexBuilder.getTypeFactory(), rexBuilder);
 
       RelNode rootRel =
           new LixToRelTranslator(cluster, OptiqPreparingStmt.this)

File: src/main/java/net/hydromatic/optiq/prepare/QueryableRelBuilder.java
Patch:
@@ -488,7 +488,7 @@ public <TResult> Queryable<TResult> select(
         new ProjectRel(
             translator.cluster,
             child,
-            nodes.toArray(new RexNode[nodes.size()]),
+            nodes,
             null,
             ProjectRelBase.Flags.Boxed));
     return null;

File: src/main/java/org/eigenbase/rel/TableAccessRelBase.java
Patch:
@@ -151,8 +151,8 @@ public RelNode project(
         return new ProjectRel(
             getCluster(),
             this,
-            exprList.toArray(new RexNode[exprList.size()]),
-            nameList.toArray(new String[nameList.size()]),
+            exprList,
+            nameList,
             ProjectRel.Flags.Boxed);
     }
 }

File: src/main/java/org/eigenbase/rel/rules/MergeCalcRule.java
Patch:
@@ -74,7 +74,7 @@ public void onMatch(RelOptRuleCall call)
                 bottomCalc.getChild(),
                 topCalc.getRowType(),
                 mergedProgram,
-                Collections.<RelCollation>emptyList());
+                topCalc.getCollationList());
 
         if (newCalc.getDigest().equals(bottomCalc.getDigest())) {
             // newCalc is equivalent to bottomCalc, which means that topCalc

File: src/main/java/org/eigenbase/relopt/RelOptUtil.java
Patch:
@@ -2372,7 +2372,7 @@ public static <T extends RelNode> T addTrait(
     {
         //noinspection unchecked
         return (T) rel.copy(
-            rel.getTraitSet().plus(trait),
+            rel.getTraitSet().replace(trait),
             (List) rel.getInputs());
     }
 

File: src/main/java/org/eigenbase/sql2rel/RelFieldTrimmer.java
Patch:
@@ -302,7 +302,7 @@ public TrimResult trimFields(
             ProjectRel newProject = new ProjectRel(
                 project.getCluster(),
                 newInput,
-                new RexNode[]{expr},
+                Collections.<RexNode>singletonList(expr),
                 newRowType,
                 project.getFlags(),
                 Collections.<RelCollation>emptyList());
@@ -341,7 +341,7 @@ public TrimResult trimFields(
 
         final RelNode newProject;
         if (RemoveTrivialProjectRule.isIdentity(
-                newProjectExprs,
+                newProjectExprList,
                 newRowType,
                 newInput.getRowType()))
         {
@@ -352,7 +352,7 @@ public TrimResult trimFields(
             newProject = new ProjectRel(
                 project.getCluster(),
                 newInput,
-                newProjectExprs,
+                newProjectExprList,
                 newRowType,
                 project.getFlags(),
                 newCollations);

File: src/test/java/org/eigenbase/relopt/volcano/VolcanoPlannerTest.java
Patch:
@@ -63,8 +63,7 @@ static RelOptCluster newCluster(VolcanoPlanner planner)
         RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl();
         return query.createCluster(
             typeFactory,
-            new RexBuilder(typeFactory),
-            RelTraitSet.createEmpty());
+            new RexBuilder(typeFactory));
     }
 
     /**

File: src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -357,7 +357,7 @@ public PreparedResult prepareQueryable(
       init(runtimeContextClass);
 
       final RelOptQuery query = new RelOptQuery(planner);
-      final RelTraitSet emptyTraitSet = RelTraitSet.createEmpty();
+      final RelTraitSet emptyTraitSet = planner.emptyTraitSet();
       final RelOptCluster cluster =
           query.createCluster(
               rexBuilder.getTypeFactory(), rexBuilder, emptyTraitSet);

File: src/main/java/org/eigenbase/rel/FilterRel.java
Patch:
@@ -58,7 +58,7 @@ public FilterRel(
 
 
     public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.contains(Convention.NONE);
         return new FilterRel(
             getCluster(),
             sole(inputs),

File: src/main/java/org/eigenbase/rel/ProjectRel.java
Patch:
@@ -101,7 +101,7 @@ public ProjectRel(
     //~ Methods ----------------------------------------------------------------
 
     public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.contains(Convention.NONE);
         return new ProjectRel(
             getCluster(),
             sole(inputs),

File: src/main/java/org/eigenbase/rel/SortRel.java
Patch:
@@ -81,10 +81,10 @@ public SortRel copy(
         RelNode newInput,
         RelCollation newCollation)
     {
-        assert traitSet.comprises(Convention.NONE);
+        assert traitSet.contains(Convention.NONE);
         return new SortRel(
             getCluster(),
-            getCluster().traitSetOf(Convention.NONE),
+            traitSet,
             newInput,
             newCollation);
     }

File: src/main/java/org/eigenbase/relopt/volcano/VolcanoPlanner.java
Patch:
@@ -258,6 +258,7 @@ public RelTraitSet emptyTraitSet() {
                 // TODO: restructure RelTraitSet to allow a list of entries
                 //  for any given trait
             }
+            traitSet = traitSet.plus(traitDef.getDefault());
         }
         return traitSet;
     }

File: src/main/java/org/eigenbase/sql2rel/SqlToRelConverter.java
Patch:
@@ -702,7 +702,7 @@ protected void convertOrder(
         bb.setRoot(
             new SortRel(
                 cluster,
-                cluster.traitSetOf(Convention.NONE),
+                cluster.traitSetOf(Convention.NONE).plus(collation),
                 bb.root,
                 collation),
             false);

File: src/main/java/org/eigenbase/rel/RelCollation.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.util.*;
 
+import org.eigenbase.relopt.RelTrait;
+
 
 /**
  * Description of the physical ordering of a relational expression.
@@ -30,7 +32,7 @@
  * @version $Id$
  * @since March 6, 2006
  */
-public interface RelCollation
+public interface RelCollation extends RelTrait
 {
     //~ Methods ----------------------------------------------------------------
 

File: src/main/java/org/eigenbase/relopt/volcano/RuleQueue.java
Patch:
@@ -86,7 +86,7 @@ class RuleQueue
     private final Comparator<RelSubset> relImportanceComparator =
         new RelImportanceComparator();
 
-    /*
+    /**
      * Maps a {@link VolcanoPlannerPhase} to a set of rule names.  Named rules
      * may be invoked in their corresponding phase.
      */
@@ -253,7 +253,7 @@ private int compare(int i1, int i2)
                 private int countChildren(RelSubset subset)
                 {
                     int count = 0;
-                    for (RelNode rel : subset.rels) {
+                    for (RelNode rel : subset.getRels()) {
                         count += rel.getInputs().size();
                     }
                     return count;
@@ -399,7 +399,7 @@ void addMatch(VolcanoRuleMatch match)
             // The importance of a subset is the max of its importance to its
             // parents
             importance = 0.0;
-            for (RelSubset parent : subset.getParentSubsets()) {
+            for (RelSubset parent : subset.getParentSubsets(planner)) {
                 final double childImportance =
                     computeImportanceOfChild(subset, parent);
                 importance = Math.max(importance, childImportance);

File: src/test/java/net/hydromatic/optiq/test/FoodmartTest.java
Patch:
@@ -17,7 +17,7 @@
 */
 package net.hydromatic.optiq.test;
 
-import mondrian.test.data.FoodMartData;
+import mondrian.test.data.FoodMartQuery;
 
 import org.eigenbase.util.IntegerIntervalSet;
 
@@ -83,7 +83,6 @@ public class FoodmartTest {
   };
 
   // Interesting tests. (We need to fix and remove from the disabled list.)
-  // 5677, 5681 only: assert into Context.toSql
   // 2452, 2453, 2454, 2457 only: RTRIM
   // 2436-2453,2455: agg_
   // 2518, 5960 only: "every derived table must have its own alias"
@@ -100,7 +99,7 @@ public static List<Object[]> getSqls() throws IOException {
     mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
     mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
 
-    final InputStream inputStream = new FoodMartData().getQueries();
+    final InputStream inputStream = new FoodMartQuery().getQueries();
     FoodmartRoot root = mapper.readValue(inputStream, FoodmartRoot.class);
     final List<Object[]> list = new ArrayList<Object[]>();
       final String idList = System.getProperty("optiq.ids");

File: src/main/java/net/hydromatic/optiq/impl/clone/ArrayTable.java
Patch:
@@ -107,6 +107,9 @@ public boolean moveNext() {
       public void reset() {
         i = -1;
       }
+
+      public void close() {
+      }
     };
   }
 

File: src/main/java/net/hydromatic/optiq/impl/java/ReflectiveSchema.java
Patch:
@@ -22,7 +22,6 @@
 
 import net.hydromatic.optiq.*;
 import net.hydromatic.optiq.impl.TableInSchemaImpl;
-import net.hydromatic.optiq.jdbc.OptiqConnection;
 
 import org.eigenbase.reltype.RelDataType;
 

File: src/test/java/net/hydromatic/optiq/impl/generate/RangeTable.java
Patch:
@@ -84,6 +84,9 @@ public boolean moveNext() {
       public void reset() {
         current = start - 1;
       }
+
+      public void close() {
+      }
     };
   }
 

File: src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -161,6 +161,9 @@ public boolean moveNext() {
           public void reset() {
             i = -1;
           }
+
+          public void close() {
+          }
         };
       }
     };

File: src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -574,7 +574,7 @@ public AssertQuery planContains(String expected) {
     public AssertQuery planHasSql(String expected) {
       return planContains(
           "getDataSource(), \"" + expected.replaceAll("\n", "\\\\n")
-              + "\")");
+              + "\"");
     }
 
     private void ensurePlan() {

File: src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcToEnumerableConverter.java
Patch:
@@ -96,7 +96,9 @@ public BlockExpression implement(EnumerableRelImplementor implementor) {
   }
 
   private String generateSql(SqlDialect dialect) {
-    final JdbcImplementor jdbcImplementor = new JdbcImplementor(dialect);
+    final JdbcImplementor jdbcImplementor =
+        new JdbcImplementor(dialect,
+            (JavaTypeFactory) getCluster().getTypeFactory());
     final JdbcImplementor.Result result =
         jdbcImplementor.visitChild(0, getChild());
     return result.asQuery().toSqlString(dialect).getSql();

File: src/main/java/org/eigenbase/rel/JoinRel.java
Patch:
@@ -154,7 +154,6 @@ public RelOptPlanWriter explainTerms(RelOptPlanWriter pw)
             return super.explainTerms(pw);
         }
         return super.explainTerms(pw)
-            .item("joinType", joinType.name().toLowerCase())
             .item("semiJoinDone", semiJoinDone);
     }
 

File: src/main/java/org/eigenbase/util/MainApp.java
Patch:
@@ -119,8 +119,7 @@ protected void initializeOptions()
                 "Prints command-line parameters",
                 false,
                 false,
-                false,
-                null));
+                false));
     }
 }
 

File: src/test/java/net/hydromatic/optiq/test/OptiqSqlOperatorTest.java
Patch:
@@ -33,12 +33,12 @@ public class OptiqSqlOperatorTest extends SqlOperatorBaseTest {
 
   private static SqlTester STATIC_TESTER;
 
-  public OptiqSqlOperatorTest(String testName) {
-    super(testName, false);
+  public OptiqSqlOperatorTest() {
+    super(false);
   }
 
   @Override
-  protected void setUp() throws Exception {
+  public void setUp() throws Exception {
     if (STATIC_TESTER != null) {
       return;
     }

File: src/test/java/org/eigenbase/sql/test/SqlTester.java
Patch:
@@ -35,9 +35,6 @@
  * <p>Specific implementations of <code>SqlTestser</code> might evaluate the
  * queries in different ways, for example, using a C++ versus Java calculator.
  * An implementation might even ignore certain calls altogether.
- *
- * @author Wael Chatila
- * @since May 22, 2004
  */
 public interface SqlTester
 {

File: src/test/java/org/eigenbase/test/MockCatalogReader.java
Patch:
@@ -35,8 +35,6 @@
 /**
  * Mock implementation of {@link SqlValidatorCatalogReader} which returns tables
  * "EMP", "DEPT", "BONUS", "SALGRADE" (same as Oracle's SCOTT schema).
- *
- * @author jhyde
  */
 public class MockCatalogReader
     implements Prepare.CatalogReader

File: src/test/java/org/eigenbase/test/MockRelOptCost.java
Patch:
@@ -23,8 +23,6 @@
 /**
  * MockRelOptCost is a mock implementation of the {@link RelOptCost} interface.
  * TODO: constructors for various scenarios
- *
- * @author John V. Sichi
  */
 public class MockRelOptCost
     implements RelOptCost

File: src/test/java/org/eigenbase/test/MockRelOptPlanner.java
Patch:
@@ -26,8 +26,6 @@
 /**
  * MockRelOptPlanner is a mock implementation of the {@link RelOptPlanner}
  * interface.
- *
- * @author John V. Sichi
  */
 public class MockRelOptPlanner
     extends AbstractRelOptPlanner

File: src/test/java/org/eigenbase/test/MockSqlOperatorTable.java
Patch:
@@ -28,8 +28,6 @@
 /**
  * Mock operator table for testing purposes. Contains the standard SQL operator
  * table, plus a list of operators.
- *
- * @author jhyde
  */
 public class MockSqlOperatorTable
     extends ChainedSqlOperatorTable

File: src/test/java/org/eigenbase/test/RelOptTestBase.java
Patch:
@@ -22,12 +22,12 @@
 import org.eigenbase.relopt.*;
 import org.eigenbase.relopt.hep.*;
 
+import static org.junit.Assert.*;
+
 
 /**
  * RelOptTestBase is an abstract base for tests which exercise a planner and/or
  * rules via {@link DiffRepository}.
- *
- * @author John V. Sichi
  */
 abstract class RelOptTestBase
     extends SqlToRelTestBase

File: src/test/java/org/eigenbase/test/concurrent/ConcurrentTestCommand.java
Patch:
@@ -23,8 +23,6 @@
  *
  * <p>ConcurrentTestCommand instances are normally instantiated by the
  * {@link ConcurrentTestCommandGenerator} class.
- *
- * @author Stephan Zuercher
  */
 public interface ConcurrentTestCommand
 {

File: src/test/java/org/eigenbase/test/concurrent/ConcurrentTestCommandExecutor.java
Patch:
@@ -24,8 +24,6 @@
 /**
  * ConcurrentTestCommandExecutor is a thread that executes a sequence of
  * {@link ConcurrentTestCommand commands} on a JDBC connection.
- *
- * @author Stephan Zuercher
  */
 class ConcurrentTestCommandExecutor extends Thread
 {

File: src/test/java/org/eigenbase/test/concurrent/ConcurrentTestCommandScript.java
Patch:
@@ -46,8 +46,6 @@
  * within a thread, and may be a sparse set.
  * See {@link ConcurrentTestCommandGenerator#synchronizeCommandSets} for other
  * considerations.
- *
- * @author Stephan Zuercher
  */
 public class ConcurrentTestCommandScript
     extends ConcurrentTestCommandGenerator

File: src/test/java/org/eigenbase/test/concurrent/ConcurrentTestPlugin.java
Patch:
@@ -21,8 +21,6 @@
 
 /**
  * Used to extend functionality of mtsql.
- *
- * @author jhahn
  */
 public abstract class ConcurrentTestPlugin
 {

File: src/test/java/org/eigenbase/test/concurrent/ConcurrentTestPluginCommand.java
Patch:
@@ -23,8 +23,6 @@
 
 /**
  * Used to extend functionality of mtsql.
- *
- * @author jhahn
  */
 public interface ConcurrentTestPluginCommand {
 

File: src/test/java/org/eigenbase/test/concurrent/ConcurrentTestTimedCommandGenerator.java
Patch:
@@ -29,8 +29,6 @@
  * has been exceeded. Therefore, the time limit can only be considered the
  * minimum length of time that the test will run and not a guarantee of how long
  * the test will take.
- *
- * @author Stephan Zuercher
  */
 public class ConcurrentTestTimedCommandGenerator
     extends ConcurrentTestCommandGenerator

File: src/main/java/org/eigenbase/rel/rules/PushJoinThroughJoinRule.java
Patch:
@@ -60,8 +60,8 @@ private PushJoinThroughJoinRule() {
         super(
             new RelOptRuleOperand(
                 JoinRel.class,
-                new RelOptRuleOperand(JoinRel.class),
-                new RelOptRuleOperand(RelNode.class)),
+                any(JoinRel.class),
+                any(RelNode.class)),
             "RotateJoinRule");
     }
 

File: src/main/java/org/eigenbase/rel/AggregateRelBase.java
Patch:
@@ -186,7 +186,7 @@ public RelDataTypeField get(int index) {
                         if (aggCall.getName() != null) {
                             name = aggCall.getName();
                         } else {
-                            name = "$f" + index;
+                            name = "$f" + (groupSet.cardinality() + index);
                         }
                         assert typeMatchesInferred(aggCall, true);
                         return new RelDataTypeFieldImpl(

File: src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -257,13 +257,13 @@ public void testDivide() throws Exception {
         "select \"wrapperLong\" / \"primitiveLong\" as c\n"
         + " from \"s\".\"everyTypes\" where \"primitiveLong\" <> 0")
         .planContains(
-            "return current13.wrapperLong == null ? null : Long.valueOf(current13.wrapperLong.longValue() / current13.primitiveLong);")
+            "return current13.wrapperLong == null ? (Long) null : Long.valueOf(current13.wrapperLong.longValue() / current13.primitiveLong);")
         .returns("C=null\n");
     with.query(
         "select \"wrapperLong\" / \"wrapperLong\" as c\n"
         + " from \"s\".\"everyTypes\" where \"primitiveLong\" <> 0")
         .planContains(
-            "return current13.wrapperLong == null ? null : Long.valueOf(current13.wrapperLong.longValue() / current13.wrapperLong.longValue());")
+            "return current13.wrapperLong == null ? (Long) null : Long.valueOf(current13.wrapperLong.longValue() / current13.wrapperLong.longValue());")
         .returns("C=null\n");
   }
 

File: src/main/java/net/hydromatic/optiq/rules/java/RexToLixTranslator.java
Patch:
@@ -202,7 +202,8 @@ Expression translateCast(
         case VARCHAR:
           // If this is a widening cast, no need to truncate.
           final int sourcePrecision = sourceType.getPrecision();
-          if (sourcePrecision >= 0
+          if (sourcePrecision < 0
+              || sourcePrecision >= 0
               && sourcePrecision <= targetPrecision) {
             break truncate;
           }

File: src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -79,6 +79,7 @@ public static TestSuite suite() {
     testSuite.addTestSuite(RexProgramTest.class);
     testSuite.addTestSuite(RexTransformerTest.class);
     testSuite.addTestSuite(JdbcAdapterTest.class);
+    testSuite.addTestSuite(MongoAdapterTest.class);
     testSuite.addTestSuite(JdbcTest.class);
     //testSuite.addTestSuite(VolcanoPlannerTraitTest.class);
     return testSuite;

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvEnumerator.java
Patch:
@@ -17,10 +17,10 @@
 */
 package net.hydromatic.optiq.impl.csv;
 
-import au.com.bytecode.opencsv.CSVReader;
-
 import net.hydromatic.linq4j.Enumerator;
 
+import au.com.bytecode.opencsv.CSVReader;
+
 import java.io.*;
 
 /** Enumerator that reads from a CSV file. */

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvSmartTable.java
Patch:
@@ -37,8 +37,7 @@ class CsvSmartTable extends CsvTable {
 
   public RelNode toRel(
       RelOptTable.ToRelContext context,
-      RelOptTable relOptTable)
-  {
+      RelOptTable relOptTable) {
     // Request all fields.
     final int fieldCount = relOptTable.getRowType().getFieldCount();
     final int[] fields = CsvEnumerator.identityList(fieldCount);

File: src/test/java/net/hydromatic/optiq/test/CsvTest.java
Patch:
@@ -17,9 +17,10 @@
 */
 package net.hydromatic.optiq.test;
 
-import junit.framework.TestCase;
 import net.hydromatic.linq4j.function.Function1;
 
+import junit.framework.TestCase;
+
 import java.io.PrintStream;
 import java.sql.*;
 import java.util.Properties;

File: src/main/java/org/eigenbase/rel/rules/MergeProjectRule.java
Patch:
@@ -116,18 +116,18 @@ public void onMatch(RelOptRuleCall call)
         // re-expand the topmost projection expressions, now that they
         // reference the children of the bottom-most project
         int nProjExprs = projExprs.length;
-        RexNode [] newProjExprs = new RexNode[nProjExprs];
+        List<RexNode> newProjExprs = new ArrayList<RexNode>();
         List<RexLocalRef> projList = mergedProgram.getProjectList();
         for (int i = 0; i < nProjExprs; i++) {
-            newProjExprs[i] = mergedProgram.expandLocalRef(projList.get(i));
+            newProjExprs.add(mergedProgram.expandLocalRef(projList.get(i)));
         }
 
         // replace the two projects with a combined projection
         ProjectRel newProjectRel =
             (ProjectRel) CalcRel.createProject(
                 bottomProject.getChild(),
                 newProjExprs,
-                RelOptUtil.getFieldNames(topProject.getRowType()));
+                topProject.getRowType().getFieldNames());
 
         call.transformTo(newProjectRel);
     }

File: src/main/java/org/eigenbase/rel/rules/PushFilterPastProjectRule.java
Patch:
@@ -69,8 +69,8 @@ public void onMatch(RelOptRuleCall call)
         ProjectRel newProjRel =
             (ProjectRel) CalcRel.createProject(
                 newFilterRel,
-                projRel.getProjectExps(),
-                RelOptUtil.getFieldNames(projRel.getRowType()));
+                projRel.getProjectExpList(),
+                projRel.getRowType().getFieldNames());
 
         call.transformTo(newProjRel);
     }

File: src/main/java/org/eigenbase/rel/rules/PushProjectIntoMultiJoinRule.java
Patch:
@@ -73,10 +73,10 @@ public void onMatch(RelOptRuleCall call)
         MultiJoinRel newMultiJoin =
             RelOptUtil.projectMultiJoin(multiJoin, project);
         ProjectRel newProject =
-            CalcRel.createProject(
+            (ProjectRel) CalcRel.createProject(
                 newMultiJoin,
-                project.getProjectExps(),
-                RelOptUtil.getFieldNames(project.getRowType()));
+                project.getProjectExpList(),
+                project.getRowType().getFieldNames());
 
         call.transformTo(newProject);
     }

File: src/main/java/org/eigenbase/rel/rules/PushSemiJoinPastProjectRule.java
Patch:
@@ -67,9 +67,9 @@ public void onMatch(RelOptRuleCall call)
         // otherwise, we wouldn't have created this semijoin
         List<Integer> newLeftKeys = new ArrayList<Integer>();
         List<Integer> leftKeys = semiJoin.getLeftKeys();
-        RexNode [] projExprs = project.getProjectExps();
+        List<RexNode> projExprs = project.getProjectExpList();
         for (int i = 0; i < leftKeys.size(); i++) {
-            RexInputRef inputRef = (RexInputRef) projExprs[leftKeys.get(i)];
+            RexInputRef inputRef = (RexInputRef) projExprs.get(leftKeys.get(i));
             newLeftKeys.add(inputRef.getIndex());
         }
 
@@ -93,7 +93,7 @@ public void onMatch(RelOptRuleCall call)
             CalcRel.createProject(
                 newSemiJoin,
                 projExprs,
-                RelOptUtil.getFieldNames(project.getRowType()));
+                project.getRowType().getFieldNames());
 
         call.transformTo(newProject);
     }

File: src/main/java/org/eigenbase/rel/rules/ReduceAggregatesRule.java
Patch:
@@ -136,7 +136,7 @@ private void reduceAggs(
                     input,
                     inputExprs,
                     CompositeList.of(
-                        RelOptUtil.getFieldNameList(input.getRowType()),
+                        input.getRowType().getFieldNames(),
                         Collections.<String>nCopies(
                             extraArgCount,
                             null)));
@@ -149,7 +149,7 @@ private void reduceAggs(
             CalcRel.createProject(
                 newAggRel,
                 projList,
-                RelOptUtil.getFieldNameList(oldAggRel.getRowType()));
+                oldAggRel.getRowType().getFieldNames());
 
         ruleCall.transformTo(projectRel);
     }

File: src/main/java/org/eigenbase/rel/rules/RemoveDistinctAggregateRule.java
Patch:
@@ -97,8 +97,7 @@ public void onMatch(RelOptRuleCall call)
         RelDataTypeField [] aggFields = aggregate.getRowType().getFields();
         final List<RexInputRef> refs =
             new ArrayList<RexInputRef>(aggFields.length);
-        final List<String> fieldNames =
-            RelOptUtil.getFieldNameList(aggregate.getRowType());
+        final List<String> fieldNames = aggregate.getRowType().getFieldNames();
         final BitSet groupSet = aggregate.getGroupSet();
         for (int i : Util.toIter(groupSet)) {
             refs.add(

File: src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -4412,9 +4412,7 @@ class OrderExpressionExpander
             super(getOrderScope(select));
             this.select = select;
             this.root = root;
-            this.aliasList =
-                RelOptUtil.getFieldNameList(
-                    getNamespace(select).getRowType());
+            this.aliasList = getNamespace(select).getRowType().getFieldNames();
         }
 
         public SqlNode go()

File: src/main/java/org/eigenbase/sql2rel/RelFieldTrimmer.java
Patch:
@@ -158,7 +158,7 @@ protected TrimResult trimChildRestore(
         final RelDataType rowType = input.getRowType();
         List<RelDataTypeField> fieldList = rowType.getFieldList();
         final List<RexNode> exprList = new ArrayList<RexNode>();
-        final List<String> nameList = RelOptUtil.getFieldNameList(rowType);
+        final List<String> nameList = rowType.getFieldNames();
         RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
         assert trimResult.right.getSourceCount() == fieldList.size();
         for (int i = 0; i < fieldList.size(); i++) {

File: src/main/java/net/hydromatic/optiq/impl/java/MapSchema.java
Patch:
@@ -98,8 +98,7 @@ public static MapSchema create(
     {
         MapSchema schema =
             new MapSchema(
-                parentSchema.getQueryProvider(),
-                parentSchema.getTypeFactory(),
+                parentSchema,
                 parentSchema.getSubSchemaExpression(name, Object.class));
         parentSchema.addSchema(name, schema);
         return schema;

File: src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -229,8 +229,7 @@ public OptiqConnection createConnection() throws Exception {
                             connection.unwrap(OptiqConnection.class);
                         MutableSchema rootSchema =
                             optiqConnection.getRootSchema();
-                        ReflectiveSchema.create(
-                            optiqConnection, rootSchema, name, schema);
+                        ReflectiveSchema.create(rootSchema, name, schema);
                         optiqConnection.setSchema(name);
                         return optiqConnection;
                     }

File: src/main/java/net/hydromatic/optiq/jdbc/Meta.java
Patch:
@@ -59,8 +59,7 @@ public boolean apply(T v1) {
      * schema called "metadata" that contains tables "TABLES", "COLUMNS" etc. */
     MapSchema createInformationSchema() {
         final MapSchema mapSchema =
-            MapSchema.create(
-                connection, connection.getRootSchema(), "metadata");
+            MapSchema.create(connection.getRootSchema(), "metadata");
         mapSchema.addTable(
             new TableInSchemaImpl(
                 mapSchema,

File: src/main/java/net/hydromatic/optiq/model/ModelHandler.java
Patch:
@@ -83,7 +83,7 @@ public void visit(JsonRoot root) {
     public void visit(JsonMapSchema jsonSchema) {
         final MutableSchema parentSchema = currentMutableSchema("schema");
         final MapSchema schema =
-            MapSchema.create(connection, parentSchema, jsonSchema.name);
+            MapSchema.create(parentSchema, jsonSchema.name);
         schema.initialize();
         populateSchema(jsonSchema, schema);
     }
@@ -119,7 +119,6 @@ public void visit(JsonCustomSchema jsonSchema) {
 
     public void visit(JsonJdbcSchema jsonSchema) {
         JdbcSchema.create(
-            connection,
             currentMutableSchema("jdbc schema"),
             dataSource(jsonSchema),
             jsonSchema.jdbcCatalog,
@@ -156,7 +155,6 @@ public void visit(JsonCustomTable jsonTable) {
                 (TableFactory) clazz.newInstance();
             final Table table =
                 tableFactory.create(
-                    connection.getTypeFactory(),
                     schema,
                     jsonTable.name,
                     jsonTable.operand,

File: src/test/java/net/hydromatic/optiq/test/JdbcFrontLinqBackTest.java
Patch:
@@ -243,8 +243,8 @@ public OptiqConnection createConnection() throws Exception {
                             OptiqConnection.class);
                         MutableSchema rootSchema =
                             optiqConnection.getRootSchema();
-                        MapSchema mapSchema = MapSchema.create(
-                            optiqConnection, rootSchema, "foo");
+                        MapSchema mapSchema =
+                            MapSchema.create(rootSchema, "foo");
                         final String tableName = "bar";
                         final JdbcTest.AbstractModifiableTable table =
                             new JdbcTest.AbstractModifiableTable(

File: src/test/java/net/hydromatic/optiq/test/ReflectiveSchemaTest.java
Patch:
@@ -143,7 +143,7 @@ public void _testOperator() throws SQLException, ClassNotFoundException {
             connection.unwrap(OptiqConnection.class);
         JavaTypeFactory typeFactory = optiqConnection.getTypeFactory();
         MutableSchema rootSchema = optiqConnection.getRootSchema();
-        MapSchema schema = MapSchema.create(optiqConnection, rootSchema, "s");
+        MapSchema schema = MapSchema.create(rootSchema, "s");
         schema.addTableFunction(
             "GenerateStrings",
             Schemas.methodMember(
@@ -176,7 +176,7 @@ public void testView() throws SQLException, ClassNotFoundException {
         OptiqConnection optiqConnection =
             connection.unwrap(OptiqConnection.class);
         MutableSchema rootSchema = optiqConnection.getRootSchema();
-        MapSchema schema = MapSchema.create(optiqConnection, rootSchema, "s");
+        MapSchema schema = MapSchema.create(rootSchema, "s");
         schema.addTableFunction(
             "emps_view",
             ViewTable.viewFunction(

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqConnection.java
Patch:
@@ -72,6 +72,9 @@ public interface OptiqConnection extends Connection, QueryProvider {
 
     // in java.sql.Connection from JDK 1.7, but declare here to allow other JDKs
     void setSchema(String schema) throws SQLException;
+
+    // in java.sql.Connection from JDK 1.7, but declare here to allow other JDKs
+    String getSchema() throws SQLException;
 }
 
 // End OptiqConnection.java

File: src/main/java/net/hydromatic/optiq/impl/csv/CsvTableScan.java
Patch:
@@ -91,8 +91,7 @@ public RelDataType deriveRowType() {
   }
 
   public BlockExpression implement(EnumerableRelImplementor implementor) {
-    Expression expression = null;
-    return Blocks.toBlock(expression);
+    return Blocks.toBlock(csvTable.getExpression());
   }
 }
 

File: src/main/java/net/hydromatic/optiq/model/JsonRoot.java
Patch:
@@ -36,6 +36,7 @@
  */
 public class JsonRoot {
     public String version;
+    public String defaultSchema;
     public final List<JsonSchema> schemas = new ArrayList<JsonSchema>();
 }
 

File: src/main/java/net/hydromatic/optiq/model/JsonSchema.java
Patch:
@@ -31,7 +31,8 @@
     defaultImpl = JsonMapSchema.class)
 @JsonSubTypes({
     @JsonSubTypes.Type(value = JsonMapSchema.class, name = "map"),
-    @JsonSubTypes.Type(value = JsonJdbcSchema.class, name = "jdbc")})
+    @JsonSubTypes.Type(value = JsonJdbcSchema.class, name = "jdbc"),
+    @JsonSubTypes.Type(value = JsonCustomSchema.class, name = "custom")})
 public abstract class JsonSchema {
     public String name;
 

File: src/main/java/net/hydromatic/linq4j/expressions/Expressions.java
Patch:
@@ -1388,6 +1388,8 @@ public static BinaryExpression makeBinary(ExpressionType binaryType,
     case LessThanOrEqual:
     case GreaterThan:
     case GreaterThanOrEqual:
+    case AndAlso:
+    case OrElse:
       type = Boolean.TYPE;
       break;
     default:

File: src/main/java/org/eigenbase/sql/SqlDataTypeSpec.java
Patch:
@@ -271,7 +271,7 @@ public RelDataType deriveType(SqlValidator validator)
     {
         String name = typeName.getSimple();
 
-        //for now we only support builtin datatypes
+        // for now we only support builtin datatypes
         if (SqlTypeName.get(name) == null) {
             throw validator.newValidationError(
                 this,
@@ -323,8 +323,7 @@ public RelDataType deriveType(RelDataTypeFactory typeFactory)
             // specification> is the default collating sequence for the
             // character repertoire of TD and the result of the <cast
             // specification> has the Coercible coercibility characteristic."
-            SqlCollation collation =
-                new SqlCollation(SqlCollation.Coercibility.Coercible);
+            SqlCollation collation = SqlCollation.COERCIBLE;
 
             Charset charset;
             if (null == charSetName) {

File: src/main/java/org/eigenbase/sql/SqlLiteral.java
Patch:
@@ -595,8 +595,7 @@ public RelDataType createSqlType(RelDataTypeFactory typeFactory)
             }
             SqlCollation collation = string.getCollation();
             if (null == collation) {
-                collation =
-                    new SqlCollation(SqlCollation.Coercibility.Coercible);
+                collation = SqlCollation.COERCIBLE;
             }
             RelDataType type =
                 typeFactory.createSqlType(

File: src/main/java/org/eigenbase/sql/SqlUtil.java
Patch:
@@ -780,7 +780,7 @@ public static RelDataType createNlsStringType(
         }
         SqlCollation collation = str.getCollation();
         if (null == collation) {
-            collation = new SqlCollation(SqlCollation.Coercibility.Coercible);
+            collation = SqlCollation.COERCIBLE;
         }
         RelDataType type =
             typeFactory.createSqlType(

File: src/main/java/org/eigenbase/sql/type/SqlTypeUtil.java
Patch:
@@ -1165,7 +1165,7 @@ public static RelDataType addCharsetAndCollation(
         }
         SqlCollation collation = type.getCollation();
         if (collation == null) {
-            collation = new SqlCollation(SqlCollation.Coercibility.Implicit);
+            collation = SqlCollation.IMPLICIT;
         }
 
         // todo: should get the implicit collation from repository

File: src/main/java/net/hydromatic/optiq/impl/ViewTable.java
Patch:
@@ -83,8 +83,7 @@ public RelNode toRel(
     {
         return expandView(
             context.getPreparingStmt(),
-            ((JavaTypeFactory) context.getCluster().getTypeFactory())
-                .createType(elementType),
+            getRowType(),
             viewSql);
     }
 

File: src/main/java/org/eigenbase/relopt/RelOptUtil.java
Patch:
@@ -1414,7 +1414,7 @@ public static void projectJoinInputs(
                 leftKeys.add(((RexInputRef) leftKey).getIndex());
             } else {
                 newLeftFields.add(leftKey);
-                newLeftFieldNames.add(leftKey.toString());
+                newLeftFieldNames.add("$left" + newLeftKeyCount);
                 leftKeys.add(origLeftInputSize + newLeftKeyCount);
                 newLeftKeyCount++;
             }
@@ -1441,7 +1441,7 @@ public static void projectJoinInputs(
                 rightKeys.add(((RexInputRef) rightKey).getIndex());
             } else {
                 newRightFields.add(rightKey);
-                newRightFieldNames.add(rightKey.toString());
+                newRightFieldNames.add("$right" + newRightKeyCount);
                 rightKeys.add(origRightInputSize + newRightKeyCount);
                 newRightKeyCount++;
             }

File: src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -136,6 +136,7 @@ protected RelOptPlanner createPlanner() {
         planner.addRule(PushFilterPastProjectRule.instance);
         planner.addRule(PushFilterPastJoinRule.instance);
         planner.addRule(RemoveDistinctAggregateRule.instance);
+        planner.addRule(ReduceAggregatesRule.instance);
         planner.addRule(SwapJoinRule.instance);
         return planner;
     }

File: src/main/java/net/hydromatic/optiq/rules/java/EnumerableRelImplementor.java
Patch:
@@ -201,7 +201,7 @@ private ClassDeclaration classDecl(
                         Expressions.field(thatParameter, field.getName())));
         }
         blockBuilder2.add(
-            Expressions.return_(null, JavaRules.EnumUtil.foldAnd(conditions)));
+            Expressions.return_(null, Expressions.foldAnd(conditions)));
         classDeclaration.memberDeclarations.add(
             Expressions.methodDecl(
                 Modifier.PUBLIC,

File: src/main/java/org/eigenbase/rel/rules/ReduceAggregatesRule.java
Patch:
@@ -232,7 +232,7 @@ private RexNode reduceAvg(
         RelDataType sumType =
             typeFactory.createTypeWithNullability(
                 avgInputType,
-                true);
+                avgInputType.isNullable() || nGroups == 0);
         SqlSumAggFunction sumAgg = new SqlSumAggFunction(sumType);
         AggregateCall sumCall =
             new AggregateCall(

File: src/test/java/net/hydromatic/optiq/test/SqlFunctionsTest.java
Patch:
@@ -32,7 +32,7 @@
  */
 public class SqlFunctionsTest extends TestCase {
     public void testCharLength() {
-        assertEquals((Integer) 3, charLength("xyz"));
+        assertEquals(3, charLength("xyz"));
     }
 
     public void testConcat() {

File: src/test/java/org/eigenbase/sql/test/SqlOperatorBaseTest.java
Patch:
@@ -4560,11 +4560,11 @@ public void testAvgFunc()
             "^avg(cast(null as varchar(2)))^",
             "(?s)Cannot apply 'AVG' to arguments of type 'AVG\\(<VARCHAR\\(2\\)>\\)'\\. Supported form\\(s\\): 'AVG\\(<NUMERIC>\\)'.*",
             false);
+        getTester().checkType("AVG(CAST(NULL AS INTEGER))", "INTEGER");
+        getTester().checkType("AVG(DISTINCT 1.5)", "DECIMAL(2, 1)");
         if (!enable) {
             return;
         }
-        getTester().checkType("AVG(CAST(NULL AS INTEGER))", "INTEGER");
-        getTester().checkType("AVG(DISTINCT 1.5)", "DECIMAL(2, 1)");
         final String [] values = { "0", "CAST(null AS FLOAT)", "3", "3" };
         getTester().checkAgg(
             "AVG(x)", values, 2d, 0d);

File: src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -159,7 +159,7 @@ public enum BuiltinMethod {
     UNIX_TIME_TO_STRING(
         SqlFunctions.class, "unixTimeToString", int.class),
     UNIX_TIMESTAMP_TO_STRING(
-        SqlFunctions.class, "unixTimestampToString", int.class),
+        SqlFunctions.class, "unixTimestampToString", long.class),
     BOOLEAN_TO_STRING(
         SqlFunctions.class, "toString", boolean.class),
     ROUND_LONG(

File: src/main/java/net/hydromatic/optiq/runtime/AbstractCursor.java
Patch:
@@ -87,6 +87,7 @@ protected Accessor createAccessor(ColumnMetaData type, int ordinal) {
         case Types.DATE:
             switch (Rep.of(type.internalClass)) {
             case PRIMITIVE_INT:
+            case INTEGER:
                 return new DateFromIntAccessor(getter);
             case JAVA_SQL_DATE:
                 return new DateAccessor(getter);
@@ -96,6 +97,7 @@ protected Accessor createAccessor(ColumnMetaData type, int ordinal) {
         case Types.TIME:
             switch (Rep.of(type.internalClass)) {
             case PRIMITIVE_INT:
+            case INTEGER:
                 return new TimeFromIntAccessor(getter);
             case JAVA_SQL_TIME:
                 return new TimeAccessor(getter);
@@ -105,6 +107,7 @@ protected Accessor createAccessor(ColumnMetaData type, int ordinal) {
         case Types.TIMESTAMP:
             switch (Rep.of(type.internalClass)) {
             case PRIMITIVE_LONG:
+            case LONG:
                 return new TimestampFromLongAccessor(getter);
             case JAVA_SQL_TIMESTAMP:
                 return new TimestampAccessor(getter);

File: src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -229,7 +229,7 @@ public OptiqConnection createConnection() throws Exception {
                             optiqConnection.getRootSchema();
                         ReflectiveSchema.create(
                             optiqConnection, rootSchema, name, schema);
-                        connection.setSchema(name);
+                        optiqConnection.setSchema(name);
                         return optiqConnection;
                     }
                 });

File: src/main/java/org/eigenbase/relopt/volcano/RelSubset.java
Patch:
@@ -383,7 +383,7 @@ public RelNode visit(
                     pw.flush();
                     final String dump = sw.toString();
                     RuntimeException e =
-                        new RuntimeException(dump);
+                        new RelOptPlanner.CannotPlanException(dump);
                     tracer.throwing(
                         getClass().getName(),
                         "visit",

File: src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -89,6 +89,8 @@ public enum BuiltinMethod {
         Functions.class, "identitySelector"),
     AS_ENUMERABLE(
         Linq4j.class, "asEnumerable", Object[].class),
+    AS_ENUMERABLE2(
+        Linq4j.class, "asEnumerable", Iterable.class),
     AS_LIST(
         Primitive.class, "asList", Object.class),
     ENUMERATOR_CURRENT(

File: src/main/java/net/hydromatic/optiq/jdbc/Meta.java
Patch:
@@ -443,7 +443,7 @@ public NamedFieldGetter(Class clazz, String... names) {
                             : DatabaseMetaData.columnNoNulls,
                         true, -1, name, name, null,
                         0, 0, null, null, Types.VARCHAR, "VARCHAR", true,
-                        false, false, null));
+                        false, false, null, field.getType()));
                 fields.add(field);
             }
         }

File: src/main/java/org/eigenbase/reltype/RelDataTypeImpl.java
Patch:
@@ -93,7 +93,9 @@ public RelDataTypeField getField(String fieldName)
             }
         }
         // Extra field
-        if (fields[fields.length - 1].getName().equals("_extra")) {
+        if (fields.length > 0
+            && fields[fields.length - 1].getName().equals("_extra"))
+        {
             return new RelDataTypeFieldImpl(
                 fieldName,
                 -1,

File: src/main/java/org/eigenbase/rel/rules/PushProjector.java
Patch:
@@ -627,8 +627,7 @@ private boolean preserve(RexNode call)
                 if (rightFields != null) {
                     totalFields += rightFields.size();
                 }
-                BitSet exprArgs = new BitSet(totalFields);
-                call.accept(new RelOptUtil.InputFinder(exprArgs));
+                final BitSet exprArgs = RelOptUtil.InputFinder.bits(call);
                 if (exprArgs.cardinality() > 0) {
                     if (RelOptUtil.contains(leftFields, exprArgs)) {
                         addExpr(preserveLeft, call);
@@ -649,7 +648,6 @@ private boolean preserve(RexNode call)
 
         public Void visitInputRef(RexInputRef inputRef)
         {
-//            if ()
             rexRefs.set(inputRef.getIndex());
             return null;
         }

File: src/main/java/org/eigenbase/rex/RexPermuteInputsShuttle.java
Patch:
@@ -86,7 +86,7 @@ public RexNode visitCall(RexCall call) {
                 return new RexInputRef(i, fields.get(i).getType());
             }
         }
-        return call;
+        return super.visitCall(call);
     }
 
     private static int lookup(List<RelDataTypeField> fields, String name) {

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqDatabaseMetaData.java
Patch:
@@ -882,7 +882,7 @@ public boolean next() {
                             }
                         };
                     }
-                });
+                }).execute();
         } catch (SQLException e) {
             throw new RuntimeException(e);
         }

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java
Patch:
@@ -130,7 +130,7 @@ void cancel() {
      * constructor occurs while the statement is locked, to make sure that
      * execute/cancel don't happen at the same time.</p>
      */
-    void execute() {
+    OptiqResultSet execute() {
         // Call driver's callback. It is permitted to throw a RuntimeException.
         final boolean autoTemp =
             ConnectionProperty.AUTO_TEMP.getBoolean(
@@ -151,6 +151,7 @@ public void toBeCompleted() {
         for (Map.Entry<String, Integer> entry : columnNameMap.entrySet()) {
             accessorMap.put(entry.getKey(), accessorList.get(entry.getValue()));
         }
+        return this;
     }
 
     public boolean next() throws SQLException {

File: src/main/java/net/hydromatic/optiq/jdbc/UnregisteredDriver.java
Patch:
@@ -114,9 +114,7 @@ protected static Factory instantiateFactory(String factoryClassName) {
         }
     }
 
-    public OptiqConnection connect(String url, Properties info)
-        throws SQLException
-    {
+    public Connection connect(String url, Properties info) throws SQLException {
         if (!acceptsURL(url)) {
             return null;
         }

File: src/main/java/org/eigenbase/oj/rel/IterCalcRel.java
Patch:
@@ -228,7 +228,7 @@ public static Expression implementAbstract(
     /**
      * Generates code for a Java expression satisfying the {@link
      * org.eigenbase.runtime.TupleIter} interface. The generated code allocates
-     * a {@link org.eigenbase.runtime.CalcTupleIter} with a dynamic {@link
+     * a {@code org.eigenbase.runtime.CalcTupleIter} with a dynamic {@link
      * org.eigenbase.runtime.TupleIter#fetchNext()} method. If the "abort on
      * error" flag is false, or an error handling tag is specified, then
      * fetchNext is written to handle row errors.
@@ -594,7 +594,7 @@ public static Expression implementAbstractTupleIter(
         memberList.add(fetchNextMethodDecl);
         Expression newTupleIterExp =
             new AllocationExpression(
-                OJUtil.typeNameForClass(CalcTupleIter.class),
+                OJUtil.typeNameForClass(Object.class/*CalcTupleIter.class*/),
                 new ExpressionList(childExp),
                 memberList);
 

File: src/main/java/org/eigenbase/oj/rel/IterOneRowRel.java
Patch:
@@ -72,7 +72,7 @@ public ParseTree implement(JavaRelImplementor implementor)
         Expression iterExp =
             new AllocationExpression(
                 OJUtil.typeNameForClass(
-                    RestartableCollectionTupleIter.class),
+                    Object.class /*RestartableCollectionTupleIter.class*/),
                 new ExpressionList(
                     new MethodCall(
                         OJUtil.typeNameForClass(Collections.class),

File: src/main/java/org/eigenbase/oj/rel/IterRules.java
Patch:
@@ -167,8 +167,9 @@ public RelNode convert(RelNode rel)
 
             // REVIEW: want to move canTranslate into RelImplementor
             // and implement it for Java & C++ calcs.
-            final JavaRelImplementor relImplementor =
+            final JavaRelImplementor relImplementor = null; /*
                 rel.getCluster().getPlanner().getJavaRelImplementor(rel);
+                */
             final RelNode convertedChild =
                 convert(
                     calc.getChild(),

File: src/main/java/org/eigenbase/oj/rel/JavaRelImplementor.java
Patch:
@@ -199,9 +199,7 @@ public JavaRel implementFieldAccess(
         JavaRel rel,
         String fieldName)
     {
-        if (rel instanceof ProjectRelBase) {
-            return ((ProjectRelBase) rel).implementFieldAccess(this, fieldName);
-        } else if (rel instanceof IterCalcRel) {
+        if (rel instanceof IterCalcRel) {
             return ((IterCalcRel) rel).implementFieldAccess(this, fieldName);
         } else {
             return null;

File: src/main/java/org/eigenbase/oj/stmt/OJPreparingStmt.java
Patch:
@@ -69,7 +69,7 @@ public abstract class OJPreparingStmt extends Prepare {
      */
     public OJPreparingStmt(CatalogReader catalogReader)
     {
-        super(catalogReader);
+        super(catalogReader, CallingConvention.RESULT_SET);
         this.containsJava = true;
     }
 

File: src/main/java/org/eigenbase/oj/util/OJClassMap.java
Patch:
@@ -26,7 +26,6 @@
 import openjava.ptree.*;
 
 import org.eigenbase.runtime.*;
-import org.eigenbase.trace.*;
 import org.eigenbase.util.*;
 
 
@@ -41,7 +40,8 @@ public class OJClassMap
 {
     //~ Static fields/initializers ---------------------------------------------
 
-    private static final Logger tracer = EigenbaseTrace.getClassMapTracer();
+    private static final Logger tracer =
+        Logger.getLogger(OJClassMap.class.getName());
 
     //~ Instance fields --------------------------------------------------------
 

File: src/main/java/org/eigenbase/relopt/CallingConvention.java
Patch:
@@ -40,11 +40,11 @@ public class CallingConvention
      * parent once for each row:
      *
      * <ul>
-     * <li>The <dfn>parent code</dfn> is generated by calling {@link
+     * <li>The <dfn>parent code</dfn> is generated by calling {@code
      * JavaRelImplementor#generateParentBody}, which in turn calls {@link
      * org.eigenbase.oj.rel.JavaLoopRel#implementJavaParent} on the parent.</li>
      * <li>The code is generated into the <dfn>current block</dfn> (gleaned from
-     * {@link org.eigenbase.oj.rel.JavaRelImplementor#getStatementList}).</li>
+     * {@code org.eigenbase.oj.rel.JavaRelImplementor#getStatementList}).</li>
      * </ul>
      * </p>
      */

File: src/test/java/org/eigenbase/test/SqlToRelTestBase.java
Patch:
@@ -21,10 +21,10 @@
 
 import junit.framework.*;
 
-import org.eigenbase.oj.util.*;
 import org.eigenbase.rel.*;
 import org.eigenbase.relopt.*;
 import org.eigenbase.reltype.*;
+import org.eigenbase.rex.RexBuilder;
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.fun.*;
 import org.eigenbase.sql.parser.*;
@@ -472,7 +472,7 @@ protected SqlToRelConverter createSqlToRelConverter(
                     validator,
                     catalogReader,
                     getPlanner(),
-                    new JavaRexBuilder(typeFactory));
+                    new RexBuilder(typeFactory));
         }
 
         protected final RelDataTypeFactory getTypeFactory()

File: src/test/java/net/hydromatic/optiq/test/SqlFunctionsTest.java
Patch:
@@ -73,7 +73,7 @@ public void testLesser() {
             // ok
         }
         assertEquals("a", lesser(null, "a"));
-        assertNull(lesser(null, null));
+        assertNull(lesser((String) null, null));
     }
 
     public void testGreater() {
@@ -86,7 +86,7 @@ public void testGreater() {
             // ok
         }
         assertEquals("a", greater(null, "a"));
-        assertNull(greater(null, null));
+        assertNull(greater((String) null, null));
     }
 
     /** Test for {@link SqlFunctions#rtrim}. */

File: src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackTest.java
Patch:
@@ -63,7 +63,7 @@ public Object apply(OptiqConnection a0) {
                                 buf.append(rset.getString(3)).append(';');
                             }
                             assertEquals(
-                                "account;agg_c_10_sales_fact_1997;agg_c_14_sales_fact_1997;agg_c_special_sales_fact_1997;agg_g_ms_pcat_sales_fact_1997;agg_l_03_sales_fact_1997;agg_l_04_sales_fact_1997;agg_l_05_sales_fact_1997;agg_lc_06_sales_fact_1997;agg_lc_100_sales_fact_1997;agg_ll_01_sales_fact_1997;agg_pl_01_sales_fact_1997;category;currency;customer;days;department;employee;employee_closure;expense_fact;inventory_fact_1997;inventory_fact_1998;position;product;product_class;products;promotion;region;reserve_employee;salary;sales_fact_1997;sales_fact_1998;sales_fact_dec_1998;store;store_ragged;time_by_day;warehouse;warehouse_class;",
+                                "account;agg_c_10_sales_fact_1997;agg_c_14_sales_fact_1997;agg_c_special_sales_fact_1997;agg_g_ms_pcat_sales_fact_1997;agg_l_03_sales_fact_1997;agg_l_04_sales_fact_1997;agg_l_05_sales_fact_1997;agg_lc_06_sales_fact_1997;agg_lc_100_sales_fact_1997;agg_ll_01_sales_fact_1997;agg_pl_01_sales_fact_1997;category;currency;customer;days;department;employee;employee_closure;expense_fact;inventory_fact_1997;inventory_fact_1998;position;product;product_class;products;promotion;region;reserve_employee;salary;sales_fact_1997;sales_fact_1998;sales_fact_dec_1998;store;store_ragged;time_by_day;warehouse;warehouse_class;COLUMNS;TABLES;",
                                 buf.toString());
                         } catch (SQLException e) {
                             throw new RuntimeException(e);
@@ -90,7 +90,7 @@ public Object apply(OptiqConnection a0) {
                                 buf.append(rset.getString(3)).append(';');
                             }
                             assertEquals(
-                                "account;agg_c_10_sales_fact_1997;agg_c_14_sales_fact_1997;agg_c_special_sales_fact_1997;agg_g_ms_pcat_sales_fact_1997;agg_l_03_sales_fact_1997;agg_l_04_sales_fact_1997;agg_l_05_sales_fact_1997;agg_lc_06_sales_fact_1997;agg_lc_100_sales_fact_1997;agg_ll_01_sales_fact_1997;agg_pl_01_sales_fact_1997;category;currency;customer;days;department;employee;employee_closure;expense_fact;inventory_fact_1997;inventory_fact_1998;position;product;product_class;products;promotion;region;reserve_employee;salary;sales_fact_1997;sales_fact_1998;sales_fact_dec_1998;store;store_ragged;time_by_day;warehouse;warehouse_class;",
+                                "COLUMNS;TABLES;",
                                 buf.toString());
                         } catch (SQLException e) {
                             throw new RuntimeException(e);

File: src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -788,7 +788,7 @@ public void testMetaTables() {
             .query("select * from \"metadata\".TABLES")
             .returns(
                 OptiqAssert.checkResultContains(
-                    "tableSchem=metadata; tableName=COLUMNS; tableType=null; "));
+                    "tableSchem=metadata; tableName=COLUMNS; tableType=SYSTEM_TABLE; "));
 
         OptiqAssert.assertThat()
             .with(OptiqAssert.Config.REGULAR_PLUS_METADATA)

File: src/main/java/net/hydromatic/optiq/MutableSchema.java
Patch:
@@ -29,7 +29,7 @@ public interface MutableSchema extends Schema {
     void addTableFunction(String name, TableFunction tableFunction);
 
     /** Defines a table within this schema. */
-    void addTable(String name, Table table);
+    void addTable(TableInSchema table);
 
     /** Adds a child schema of this schema. */
     void addSchema(String name, Schema schema);

File: src/main/java/net/hydromatic/optiq/impl/DelegatingSchema.java
Patch:
@@ -18,7 +18,6 @@
 package net.hydromatic.optiq.impl;
 
 import net.hydromatic.linq4j.QueryProvider;
-import net.hydromatic.linq4j.Queryable;
 import net.hydromatic.linq4j.expressions.Expression;
 import net.hydromatic.optiq.*;
 
@@ -56,8 +55,8 @@ public QueryProvider getQueryProvider() {
         return schema.getQueryProvider();
     }
 
-    public Collection<String> getTableNames() {
-        return schema.getTableNames();
+    public Collection<TableInSchema> getTables() {
+        return schema.getTables();
     }
 
     public <T> Table<T> getTable(String name, Class<T> elementType) {

File: src/main/java/net/hydromatic/optiq/impl/clone/CloneSchema.java
Patch:
@@ -21,6 +21,7 @@
 import net.hydromatic.linq4j.expressions.*;
 
 import net.hydromatic.optiq.*;
+import net.hydromatic.optiq.impl.TableInSchemaImpl;
 import net.hydromatic.optiq.impl.java.*;
 import net.hydromatic.optiq.jdbc.OptiqConnection;
 
@@ -62,7 +63,8 @@ public <E> Table<E> getTable(String name, Class<E> elementType) {
         if (sourceTable != null) {
             //noinspection unchecked
             table = createCloneTable(sourceTable, name);
-            addTable(name, table);
+            addTable(
+                new TableInSchemaImpl(this, name, TableType.TABLE, table));
             return table;
         }
         return null;

File: src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -124,7 +124,7 @@ public enum BuiltinMethod {
     LOWER(
         SqlFunctions.class, "lower", String.class),
     INITCAP(
-        SqlFunctions.class, "initCap", String.class),
+        SqlFunctions.class, "initcap", String.class),
     SUBSTRING(
         SqlFunctions.class, "substring", String.class, int.class, int.class),
     CHAR_LENGTH(

File: src/main/java/net/hydromatic/optiq/rules/java/RexImpTable.java
Patch:
@@ -64,7 +64,8 @@ public class RexImpTable {
     RexImpTable() {
         defineMethod(upperFunc, BuiltinMethod.UPPER.method, NullPolicy.STRICT);
         defineMethod(lowerFunc, BuiltinMethod.LOWER.method, NullPolicy.STRICT);
-        defineMethod(initcapFunc,  BuiltinMethod.INITCAP.method, NullPolicy.STRICT);
+        defineMethod(
+            initcapFunc,  BuiltinMethod.INITCAP.method, NullPolicy.STRICT);
         defineMethod(
             substringFunc, BuiltinMethod.SUBSTRING.method, NullPolicy.STRICT);
         defineMethod(

File: src/main/java/net/hydromatic/optiq/BuiltinMethod.java
Patch:
@@ -79,6 +79,8 @@ public enum BuiltinMethod {
         Functions.class, "nullsComparator", boolean.class, boolean.class),
     ARRAY_COMPARER(
         Functions.class, "arrayComparer"),
+    ARRAYS_AS_LIST(
+        SqlFunctions.class, "asList", Object[].class),
     IDENTITY_SELECTOR(
         Functions.class, "identitySelector"),
     AS_ENUMERABLE(

File: src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -200,9 +200,9 @@ public void testDistinctCount() {
                 + "group by c.\"state_province\", c.\"country\"\n"
                 + "order by c.\"state_province\", 2")
             .returns(
-                "state_province=CA; S=74748; DC=2716\n"
-                + "state_province=OR; S=67659; DC=1037\n"
-                + "state_province=WA; S=124366; DC=1828\n");
+                "state_province=CA; S=74748.0000; DC=2716\n"
+                + "state_province=OR; S=67659.0000; DC=1037\n"
+                + "state_province=WA; S=124366.0000; DC=1828\n");
     }
 
     public void testPlan() {

File: src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1386,6 +1386,8 @@ protected SqlSelect createSourceSelectForDelete(SqlDelete call)
             SqlParserPos.ZERO);
     }
 
+    /** Returns null if there is no common type. E.g. if the rows have a
+     * different number of columns. */
     RelDataType getTableConstructorRowType(
         SqlCall values,
         SqlValidatorScope scope)

File: src/main/java/net/hydromatic/linq4j/expressions/Expressions.java
Patch:
@@ -500,7 +500,8 @@ private static Type box(Type type) {
     return type;
   }
 
-  static boolean isConstantNull(Expression e) {
+  /** Returns whether an expression always evaluates to null. */
+  public static boolean isConstantNull(Expression e) {
     return e instanceof ConstantExpression
            && ((ConstantExpression) e).value == null;
   }

File: src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -56,6 +56,7 @@ public static TestSuite suite() {
         testSuite.addTestSuite(SqlFunctionsTest.class);
         testSuite.addTestSuite(SqlOperatorTest.class);
         testSuite.addTestSuite(OptiqSqlOperatorTest.class);
+        testSuite.addTestSuite(ModelTest.class);
         return testSuite;
     }
 

File: src/main/java/net/hydromatic/optiq/runtime/AbstractCursor.java
Patch:
@@ -70,6 +70,7 @@ protected Accessor createAccessor(ColumnMetaData type, int ordinal) {
         case Types.BOOLEAN:
             return new BooleanAccessor(getter);
         case Types.FLOAT:
+        case Types.REAL:
             return new FloatAccessor(getter);
         case Types.DOUBLE:
             return new DoubleAccessor(getter);
@@ -91,7 +92,7 @@ protected Accessor createAccessor(ColumnMetaData type, int ordinal) {
         case Types.OTHER: // e.g. map
             return new ObjectAccessor(getter);
         default:
-            throw new RuntimeException("unknown type " + type);
+            throw new RuntimeException("unknown type " + type.type);
         }
     }
 

File: src/main/java/org/eigenbase/rex/RexLiteral.java
Patch:
@@ -202,6 +202,7 @@ public static boolean valueMatchesType(
             // fall through
         case DECIMAL:
         case DOUBLE:
+        case FLOAT:
         case REAL:
         case BIGINT:
             return value instanceof BigDecimal;

File: src/test/java/net/hydromatic/optiq/test/OptiqSqlOperatorTest.java
Patch:
@@ -34,7 +34,7 @@ public class OptiqSqlOperatorTest extends SqlOperatorBaseTest {
     private static SqlTester STATIC_TESTER;
 
     public OptiqSqlOperatorTest(String testName) {
-        super(testName);
+        super(testName, false);
     }
 
     @Override

File: src/test/java/org/eigenbase/sql/test/SqlOperatorTest.java
Patch:
@@ -41,7 +41,7 @@ public class SqlOperatorTest
 
     public SqlOperatorTest(String testName)
     {
-        super(testName);
+        super(testName, false);
     }
 
     //~ Methods ----------------------------------------------------------------

File: src/test/java/net/hydromatic/optiq/test/SqlFunctionsTest.java
Patch:
@@ -63,7 +63,7 @@ public void testLesser() {
             // ok
         }
         assertEquals("a", lesser(null, "a"));
-        assertNull(lesser(null, null));
+        assertNull(lesser((Comparable) null, null));
     }
 
     public void testGreater() {
@@ -76,7 +76,7 @@ public void testGreater() {
             // ok
         }
         assertEquals("a", greater(null, "a"));
-        assertNull(greater(null, null));
+        assertNull(greater((Comparable) null, null));
     }
 
     /** Test for {@link SqlFunctions#rtrim}. */

File: src/main/java/net/hydromatic/optiq/jdbc/JavaRecordType.java
Patch:
@@ -20,6 +20,8 @@
 import org.eigenbase.reltype.RelDataTypeField;
 import org.eigenbase.reltype.RelRecordType;
 
+import java.util.List;
+
 /**
 * Record type based on a Java class. The fields of the type are the fields
  * of the class.
@@ -30,7 +32,7 @@
 public class JavaRecordType extends RelRecordType {
     final Class clazz;
 
-    public JavaRecordType(RelDataTypeField[] fields, Class clazz) {
+    public JavaRecordType(List<RelDataTypeField> fields, Class clazz) {
         super(fields);
         this.clazz = clazz;
         assert clazz != null;

File: src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -906,7 +906,7 @@ private SqlOperator toOp(String name, TableFunction fun) {
                     typeFactory.createType(fun.getElementType())),
                 new ExplicitOperandTypeInference(
                     argTypes.toArray(new RelDataType[argTypes.size()])),
-                new FamilyOperandTypeChecker(
+                SqlTypeStrategies.family(
                     typeFamilies.toArray(
                         new SqlTypeFamily[typeFamilies.size()])),
                 null);

File: src/main/java/org/eigenbase/rex/RexSqlStandardConvertletTable.java
Patch:
@@ -95,7 +95,9 @@ public RexSqlStandardConvertletTable()
         registerEquivOp(SqlStdOperatorTable.convertFunc);
         registerEquivOp(SqlStdOperatorTable.translateFunc);
         registerEquivOp(SqlStdOperatorTable.overlayFunc);
-        registerEquivOp(SqlStdOperatorTable.trimFunc);
+        registerEquivOp(SqlStdOperatorTable.trimBothFunc);
+        registerEquivOp(SqlStdOperatorTable.trimLeadingFunc);
+        registerEquivOp(SqlStdOperatorTable.trimTrailingFunc);
         registerEquivOp(SqlStdOperatorTable.positionFunc);
         registerEquivOp(SqlStdOperatorTable.charLengthFunc);
         registerEquivOp(SqlStdOperatorTable.characterLengthFunc);

File: src/main/java/org/eigenbase/sql/fun/SqlAbstractTimeFunction.java
Patch:
@@ -36,8 +36,7 @@ public class SqlAbstractTimeFunction
     //~ Static fields/initializers ---------------------------------------------
 
     private static final SqlOperandTypeChecker otcCustom =
-        new CompositeOperandTypeChecker(
-            CompositeOperandTypeChecker.Composition.OR,
+        SqlTypeStrategies.or(
             SqlTypeStrategies.otcPositiveIntLit,
             SqlTypeStrategies.otcNiladic);
 

File: src/main/java/org/eigenbase/sql/fun/SqlCaseOperator.java
Patch:
@@ -294,7 +294,7 @@ private static <T> T last(List<T> list) {
 
     public SqlOperandCountRange getOperandCountRange()
     {
-        return SqlOperandCountRange.Variadic;
+        return SqlOperandCountRanges.any();
     }
 
     public SqlSyntax getSyntax()

File: src/main/java/org/eigenbase/sql/fun/SqlLikeOperator.java
Patch:
@@ -95,7 +95,7 @@ public boolean isNegated()
 
     public SqlOperandCountRange getOperandCountRange()
     {
-        return SqlOperandCountRange.TwoOrThree;
+        return SqlOperandCountRanges.between(2, 3);
     }
 
     public boolean checkOperandTypes(
@@ -119,8 +119,8 @@ public boolean checkOperandTypes(
                 return false;
             }
 
-            //calc implementation should
-            //enforce the escape character length to be 1
+            // calc implementation should
+            // enforce the escape character length to be 1
             break;
         default:
             throw Util.newInternal(

File: src/main/java/org/eigenbase/sql/fun/SqlMultisetMemberOfOperator.java
Patch:
@@ -39,7 +39,7 @@ public class SqlMultisetMemberOfOperator
 
     public SqlMultisetMemberOfOperator()
     {
-        //TODO check if precedence is correct
+        // TODO check if precedence is correct
         super(
             "MEMBER OF",
             SqlKind.OTHER,
@@ -90,7 +90,7 @@ public boolean checkOperandTypes(
 
     public SqlOperandCountRange getOperandCountRange()
     {
-        return SqlOperandCountRange.Two;
+        return SqlOperandCountRanges.of(2);
     }
 }
 

File: src/main/java/org/eigenbase/sql/fun/SqlOverlayFunction.java
Patch:
@@ -33,8 +33,7 @@ public class SqlOverlayFunction
     //~ Static fields/initializers ---------------------------------------------
 
     private static final SqlOperandTypeChecker otcCustom =
-        new CompositeOperandTypeChecker(
-            CompositeOperandTypeChecker.Composition.OR,
+        SqlTypeStrategies.or(
             SqlTypeStrategies.otcStringX2Int,
             SqlTypeStrategies.otcStringX2IntX2);
 

File: src/main/java/org/eigenbase/sql/fun/SqlSubstringFunction.java
Patch:
@@ -172,7 +172,7 @@ public boolean checkOperandTypes(
 
     public SqlOperandCountRange getOperandCountRange()
     {
-        return SqlOperandCountRange.TwoOrThree;
+        return SqlOperandCountRanges.between(2, 3);
     }
 
     public void unparse(

File: src/main/java/org/eigenbase/sql/type/AbstractSqlType.java
Patch:
@@ -18,6 +18,7 @@
 package org.eigenbase.sql.type;
 
 import java.io.*;
+import java.util.List;
 
 import org.eigenbase.reltype.*;
 
@@ -50,7 +51,7 @@ public abstract class AbstractSqlType
     protected AbstractSqlType(
         SqlTypeName typeName,
         boolean isNullable,
-        RelDataTypeField [] fields)
+        List<? extends RelDataTypeField> fields)
     {
         super(fields);
         this.typeName = typeName;

File: src/main/java/org/eigenbase/sql/type/AssignableOperandTypeChecker.java
Patch:
@@ -54,7 +54,7 @@ public AssignableOperandTypeChecker(RelDataType [] paramTypes)
     // implement SqlOperandTypeChecker
     public SqlOperandCountRange getOperandCountRange()
     {
-        return new SqlOperandCountRange(paramTypes.length);
+        return SqlOperandCountRanges.of(paramTypes.length);
     }
 
     // implement SqlOperandTypeChecker

File: src/main/java/org/eigenbase/sql/type/ComparableOperandTypeChecker.java
Patch:
@@ -118,12 +118,10 @@ public boolean checkOperandTypes(
     // implement SqlOperandTypeChecker
     public String getAllowedSignatures(SqlOperator op, String opName)
     {
-        String [] array = new String[nOperands];
-        Arrays.fill(array, "COMPARABLE_TYPE");
         return SqlUtil.getAliasedSignature(
             op,
             opName,
-            Arrays.asList(array));
+            Collections.nCopies(nOperands, "COMPARABLE_TYPE"));
     }
 }
 

File: src/main/java/org/eigenbase/sql/type/LiteralOperandTypeChecker.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Parameter type-checking strategy type must be a literal (whether null is
- * allowede is determined by the constructor). <code>CAST(NULL as ...)</code> is
+ * allowed is determined by the constructor). <code>CAST(NULL as ...)</code> is
  * considered to be a NULL literal but not <code>CAST(CAST(NULL as ...) AS
  * ...)</code>
  *
@@ -91,7 +91,7 @@ public boolean checkOperandTypes(
 
     public SqlOperandCountRange getOperandCountRange()
     {
-        return SqlOperandCountRange.One;
+        return SqlOperandCountRanges.of(1);
     }
 
     public String getAllowedSignatures(SqlOperator op, String opName)

File: src/main/java/org/eigenbase/sql/type/MultisetOperandTypeChecker.java
Patch:
@@ -88,7 +88,7 @@ public boolean checkOperandTypes(
 
     public SqlOperandCountRange getOperandCountRange()
     {
-        return SqlOperandCountRange.Two;
+        return SqlOperandCountRanges.of(2);
     }
 
     public String getAllowedSignatures(SqlOperator op, String opName)

File: src/main/java/org/eigenbase/sql/type/MultisetSqlType.java
Patch:
@@ -32,7 +32,7 @@ public class MultisetSqlType
 {
     //~ Instance fields --------------------------------------------------------
 
-    private RelDataType elementType;
+    private final RelDataType elementType;
 
     //~ Constructors -----------------------------------------------------------
 

File: src/main/java/org/eigenbase/sql/type/ObjectSqlType.java
Patch:
@@ -17,6 +17,8 @@
 */
 package org.eigenbase.sql.type;
 
+import java.util.List;
+
 import org.eigenbase.reltype.*;
 import org.eigenbase.sql.*;
 
@@ -53,7 +55,7 @@ public ObjectSqlType(
         SqlTypeName typeName,
         SqlIdentifier sqlIdentifier,
         boolean nullable,
-        RelDataTypeField [] fields,
+        List<? extends RelDataTypeField> fields,
         RelDataTypeComparability comparability)
     {
         super(typeName, nullable, fields);

File: src/main/java/org/eigenbase/sql/type/SetopOperandTypeChecker.java
Patch:
@@ -120,7 +120,7 @@ public int size() {
 
     public SqlOperandCountRange getOperandCountRange()
     {
-        return SqlOperandCountRange.Two;
+        return SqlOperandCountRanges.of(2);
     }
 
     public String getAllowedSignatures(SqlOperator op, String opName)

File: src/test/java/org/eigenbase/test/MockCatalogReader.java
Patch:
@@ -109,12 +109,11 @@ protected void init()
                 SqlTypeName.STRUCTURED,
                 new SqlIdentifier("ADDRESS", SqlParserPos.ZERO),
                 false,
-                new RelDataTypeField[] {
+                Arrays.asList(
                     new RelDataTypeFieldImpl("STREET", 0, varchar20Type),
                     new RelDataTypeFieldImpl("CITY", 1, varchar20Type),
                     new RelDataTypeFieldImpl("ZIP", 1, intType),
-                    new RelDataTypeFieldImpl("STATE", 1, varchar20Type)
-                },
+                    new RelDataTypeFieldImpl("STATE", 1, varchar20Type)),
                 RelDataTypeComparability.None);
 
         // Register "SALES" schema.

File: src/main/java/org/eigenbase/sql/validate/SelectNamespace.java
Patch:
@@ -74,8 +74,9 @@ public SqlMonotonicity getMonotonicity(String columnName)
     {
         final RelDataType rowType = this.getRowTypeSansSystemColumns();
         final int field = SqlTypeUtil.findField(rowType, columnName);
-        final SqlNodeList selectList = select.getSelectList();
-        final SqlNode selectItem = selectList.get(field);
+        final SqlNode selectItem =
+            validator.getRawSelectScope(select)
+                .getExpandedSelectList().get(field);
         return validator.getSelectScope(select).getMonotonicity(selectItem);
     }
 }

File: src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -606,6 +606,8 @@ public void testCloneGroupBy() {
         + "c0=1997; c1=Sunday Paper; m0=4339.0000\n",
         "select \"store\".\"store_country\" as \"c0\", sum(\"inventory_fact_1997\".\"supply_time\") as \"m0\" from \"store\" as \"store\", \"inventory_fact_1997\" as \"inventory_fact_1997\" where \"inventory_fact_1997\".\"store_id\" = \"store\".\"store_id\" group by \"store\".\"store_country\"",
         "c0=USA; m0=10425\n",
+        "select \"sn\".\"desc\" as \"c0\" from (SELECT * FROM (VALUES (1, 'SameName')) AS \"t\" (\"id\", \"desc\")) as \"sn\" group by \"sn\".\"desc\" order by \"sn\".\"desc\" ASC NULLS LAST",
+        "c0=SameName\n",
     };
 
     /** A selection of queries generated by Mondrian. */

File: src/main/java/org/eigenbase/reltype/RelDataTypeImpl.java
Patch:
@@ -26,7 +26,6 @@
 import org.eigenbase.sql.*;
 import org.eigenbase.sql.parser.*;
 import org.eigenbase.sql.type.*;
-import org.eigenbase.util.*;
 
 
 /**
@@ -196,13 +195,13 @@ public SqlIntervalQualifier getIntervalQualifier()
     // implement RelDataType
     public int getPrecision()
     {
-        throw Util.newInternal("no precision: " + this);
+        return PRECISION_NOT_SPECIFIED;
     }
 
     // implement RelDataType
     public int getScale()
     {
-        throw Util.newInternal("no scale: " + this);
+        return SCALE_NOT_SPECIFIED;
     }
 
     // implement RelDataType

File: src/main/java/org/eigenbase/sql/type/SqlTypeFactoryImpl.java
Patch:
@@ -58,7 +58,7 @@ public RelDataType createSqlType(
     {
         assertBasic(typeName);
         assert (precision >= 0)
-            || (precision == BasicSqlType.PRECISION_NOT_SPECIFIED);
+            || (precision == RelDataType.PRECISION_NOT_SPECIFIED);
         RelDataType newType = new BasicSqlType(typeName, precision);
         newType = SqlTypeUtil.addCharsetAndCollation(newType, this);
         return canonize(newType);
@@ -72,7 +72,7 @@ public RelDataType createSqlType(
     {
         assertBasic(typeName);
         assert (precision >= 0)
-            || (precision == BasicSqlType.PRECISION_NOT_SPECIFIED);
+            || (precision == RelDataType.PRECISION_NOT_SPECIFIED);
         RelDataType newType = new BasicSqlType(typeName, precision, scale);
         newType = SqlTypeUtil.addCharsetAndCollation(newType, this);
         return canonize(newType);

File: src/main/java/net/hydromatic/linq4j/expressions/ConstantExpression.java
Patch:
@@ -98,6 +98,8 @@ private static ExpressionWriter write(ExpressionWriter writer,
         return writer.append(value).append("D");
       case LONG:
         return writer.append(value).append("L");
+      case SHORT:
+        return writer.append("(short)").append(value);
       default:
         return writer.append(value);
       }

File: src/main/java/net/hydromatic/linq4j/expressions/BlockBuilder.java
Patch:
@@ -346,7 +346,8 @@ public Expression visit(ParameterExpression parameterExpression) {
   }
 
   private static class UseCounter extends Visitor {
-    private final Map<ParameterExpression, Slot> map = new HashMap<ParameterExpression, Slot>();
+    private final Map<ParameterExpression, Slot> map =
+        new HashMap<ParameterExpression, Slot>();
 
     public Expression visit(ParameterExpression parameter) {
       final Slot slot = map.get(parameter);

File: src/main/java/org/eigenbase/rex/RexBuilder.java
Patch:
@@ -435,8 +435,9 @@ public RexNode makeCast(
             final Comparable value = literal.getValue();
             if (RexLiteral.valueMatchesType(value, sqlType, false)
                 && (!(value instanceof NlsString)
-                    || type.getPrecision()
-                       >= ((NlsString) value).getValue().length()))
+                    || (type instanceof BasicSqlType
+                        && type.getPrecision()
+                       >= ((NlsString) value).getValue().length())))
             {
                 return makeLiteral(value, type, literal.getTypeName());
             }

File: src/main/java/net/hydromatic/optiq/rules/java/RexToLixTranslator.java
Patch:
@@ -231,8 +231,9 @@ public static Expression translateLiteral(
                 ((Calendar) literal.getValue()).getTimeInMillis(), javaClass);
         case CHAR:
         case VARCHAR:
+            final NlsString nlsString = (NlsString) literal.getValue();
             return Expressions.constant(
-                ((NlsString) literal.getValue()).getValue(), javaClass);
+                nlsString == null ? null : nlsString.getValue(), javaClass);
         default:
             return Expressions.constant(literal.getValue(), javaClass);
         }

File: src/main/java/net/hydromatic/optiq/rules/java/JavaRules.java
Patch:
@@ -667,7 +667,8 @@ public BlockExpression implement(EnumerableRelImplementor implementor) {
                 statements.append(
                     "inputEnumerable",
                     implementor.visitChild(
-                        this, 0, child));
+                        this, 0, child),
+                    false);
             final Expression body =
                 Expressions.new_(
                     enumeratorType,

File: src/main/java/net/hydromatic/optiq/runtime/Cursor.java
Patch:
@@ -39,7 +39,7 @@ public interface Cursor {
      * @param types List of column types, per {@link java.sql.Types}.
      * @return List of column accessors
      */
-    List<Accessor> createAccessors(List<Integer> types);
+    List<Accessor> createAccessors(List<ColumnMetaData> types);
 
     /**
      * Moves to the next row.

File: src/main/java/net/hydromatic/lambda/streams/Stream.java
Patch:
@@ -29,9 +29,7 @@ public interface Stream<T> extends SequentialStreamOps<T>, Iterator<T> {
   public static final int STATE_SORTED = 2;
   public static final int STATE_SIZED = 4;
   public static final int STATE_MASK = 0x7;
-  public static final
-  int
-      STATE_UNKNOWN_MASK_V1 =
+  public static final int STATE_UNKNOWN_MASK_V1 =
       ~(STATE_UNIQUE | STATE_SORTED | STATE_SIZED);
 }
 

File: src/main/java/net/hydromatic/linq4j/expressions/ClassDeclaration.java
Patch:
@@ -59,9 +59,7 @@ public void accept(ExpressionWriter writer) {
   }
 
   public ClassDeclaration accept(Visitor visitor) {
-    final
-    List<MemberDeclaration>
-        members1 =
+    final List<MemberDeclaration> members1 =
         Expressions.acceptMemberDeclarations(memberDeclarations, visitor);
     return visitor.visit(this, members1);
   }

File: src/main/java/net/hydromatic/linq4j/expressions/ConstructorDeclaration.java
Patch:
@@ -56,8 +56,8 @@ public void accept(ExpressionWriter writer) {
       public String get(int index) {
         ParameterExpression parameter = parameters.get(index);
         final String modifiers = Modifier.toString(parameter.modifier);
-        return modifiers + (modifiers.isEmpty() ? "" : " ") + Types.className(
-            parameter.getType()) + " " + parameter.name;
+        return modifiers + (modifiers.isEmpty() ? "" : " ")
+               + Types.className(parameter.getType()) + " " + parameter.name;
       }
 
       public int size() {

File: src/main/java/net/hydromatic/linq4j/expressions/DeclarationExpression.java
Patch:
@@ -40,8 +40,9 @@ public DeclarationExpression(int modifiers, ParameterExpression parameter,
   @Override
   public Statement accept(Visitor visitor) {
     // do not visit parameter - visit may not return a ParameterExpression
-    Expression initializer = this.initializer != null ? this.initializer.accept(
-        visitor) : null;
+    Expression initializer = this.initializer != null
+        ? this.initializer.accept(visitor)
+        : null;
     return visitor.visit(this, parameter, initializer);
   }
 

File: src/main/java/net/hydromatic/linq4j/expressions/Evaluator.java
Patch:
@@ -24,9 +24,7 @@
  * Holds context for evaluating expressions.
  */
 class Evaluator {
-  final
-  List<ParameterExpression>
-      parameters =
+  final List<ParameterExpression> parameters =
       new ArrayList<ParameterExpression>();
   final List<Object> values = new ArrayList<Object>();
 

File: src/main/java/net/hydromatic/linq4j/expressions/NewExpression.java
Patch:
@@ -44,9 +44,7 @@ public NewExpression(Type type, List<Expression> arguments,
   public Expression accept(Visitor visitor) {
     final List<Expression> arguments = Expressions.acceptExpressions(
         this.arguments, visitor);
-    final
-    List<MemberDeclaration>
-        memberDeclarations =
+    final List<MemberDeclaration> memberDeclarations =
         Expressions.acceptMemberDeclarations(this.memberDeclarations, visitor);
     return visitor.visit(this, arguments, memberDeclarations);
   }

File: src/main/java/net/hydromatic/linq4j/expressions/Types.java
Patch:
@@ -482,9 +482,7 @@ static Type arrayType(Type type) {
 
   public static Type stripGenerics(Type type) {
     if (type instanceof GenericArrayType) {
-      final
-      Type
-          componentType =
+      final Type componentType =
           ((GenericArrayType) type).getGenericComponentType();
       return new ArrayType(stripGenerics(componentType));
     } else if (type instanceof ParameterizedType) {

File: src/main/java/net/hydromatic/linq4j/expressions/MethodCallExpression.java
Patch:
@@ -68,7 +68,7 @@ public boolean equals(Object obj) {
       final MethodCallExpression call = (MethodCallExpression) obj;
       return nodeType == call.nodeType
           && method == call.method
-          && Linq4j.equals(targetExpression, targetExpression)
+          && Linq4j.equals(targetExpression, call.targetExpression)
           && expressions.equals(call.expressions);
     }
     return false;

File: src/main/java/net/hydromatic/linq4j/expressions/ConstantExpression.java
Patch:
@@ -61,8 +61,9 @@ public int hashCode() {
   public boolean equals(Object obj) {
     // REVIEW: Should constants with the same value and different type
     // (e.g. 3L and 3) be considered equal.
-    return obj == this || obj instanceof ConstantExpression && Linq4j.equals(
-        value, ((ConstantExpression) obj).value);
+    return obj == this
+           || obj instanceof ConstantExpression
+              && Linq4j.equals(value, ((ConstantExpression) obj).value);
   }
 
   public Object evaluate(Evaluator evaluator) {

File: src/main/java/net/hydromatic/optiq/prepare/LixToRelTranslator.java
Patch:
@@ -90,7 +90,7 @@ public RelNode translate(Expression expression) {
                         null,
                         typeFactory.createJavaType(
                             Types.toClass(
-                                Types.getComponentType(
+                                Types.getElementType(
                                     call.targetExpression.getType()))),
                         new String[0],
                         call.targetExpression));

File: src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -53,6 +53,7 @@ public static TestSuite suite() {
         testSuite.addTestSuite(JdbcFrontJdbcBackLinqMiddleTest.class);
         testSuite.addTestSuite(JdbcFrontJdbcBackTest.class);
         testSuite.addTestSuite(SqlToRelConverterTest.class);
+        testSuite.addTestSuite(SqlFunctionsTest.class);
         testSuite.addTestSuite(SqlOperatorTest.class);
         if (Bug.TodoFixed) {
             // 96 failures currently

File: src/main/java/net/hydromatic/linq4j/expressions/Visitor.java
Patch:
@@ -189,7 +189,7 @@ public Expression visit(
         return expressions.equals(newArrayExpression.expressions)
             ? newArrayExpression
             : Expressions.newArrayInit(
-                Types.componentType(newArrayExpression.type),
+                Types.getComponentType(newArrayExpression.type),
                 expressions);
     }
 

File: src/main/java/org/eigenbase/sql/validate/EmptyScope.java
Patch:
@@ -58,7 +58,7 @@ public SqlValidator getValidator()
 
     public SqlIdentifier fullyQualify(SqlIdentifier identifier)
     {
-        return null;
+        return identifier;
     }
 
     public SqlNode getNode()

File: src/main/java/org/eigenbase/sql/validate/SqlValidatorImpl.java
Patch:
@@ -1002,7 +1002,7 @@ protected SqlNode performUnconditionalRewrites(
         final SqlKind kind = node.getKind();
         switch (kind) {
         case VALUES:
-            if (underFrom) {
+            if (underFrom || true) {
                 // leave FROM (VALUES(...)) [ AS alias ] clauses alone,
                 // otherwise they grow cancerously if this rewrite is invoked
                 // over and over
@@ -2294,6 +2294,7 @@ private void registerQuery(
 
         case VALUES:
             call = (SqlCall) node;
+            scopes.put(call, parentScope);
             final TableConstructorNamespace tableConstructorNamespace =
                 new TableConstructorNamespace(
                     this,
@@ -3493,6 +3494,7 @@ public void validateInsert(SqlInsert insert)
         RelDataType sourceRowType = getNamespace(source).getRowType();
         RelDataType logicalTargetRowType =
             getLogicalTargetRowType(targetRowType, insert);
+        setValidatedNodeType(insert, logicalTargetRowType);
         RelDataType logicalSourceRowType =
             getLogicalSourceRowType(sourceRowType, insert);
 

File: src/main/java/org/eigenbase/rex/RexBuilder.java
Patch:
@@ -929,7 +929,7 @@ public RexNode ensureType(
     }
 
     /**
-     * Ensure's type's nullability matches a value's nullability
+     * Ensures that a type's nullability matches a value's nullability.
      */
     public RelDataType matchNullability(
         RelDataType type,

File: src/main/java/net/hydromatic/optiq/jdbc/JavaTypeFactoryImpl.java
Patch:
@@ -147,6 +147,8 @@ public Type getJavaClass(RelDataType type) {
                 return Time.class;
             case TIMESTAMP:
                 return Timestamp.class;
+            case ANY:
+                return Object.class;
             }
         }
         return null;

File: src/main/java/org/eigenbase/sql/type/SqlTypeName.java
Patch:
@@ -74,7 +74,7 @@ public enum SqlTypeName
     BINARY(PrecScale.NoNo | PrecScale.YesNo, false, Types.BINARY),
     VARBINARY(PrecScale.NoNo | PrecScale.YesNo, false, Types.VARBINARY),
     NULL(PrecScale.NoNo, true, Types.NULL),
-    ANY(PrecScale.NoNo, true, Types.OTHER),
+    ANY(PrecScale.NoNo, true, Types.JAVA_OBJECT),
     SYMBOL(PrecScale.NoNo, true, Types.OTHER),
     MULTISET(PrecScale.NoNo, false, Types.ARRAY),
     DISTINCT(PrecScale.NoNo, false, Types.DISTINCT),
@@ -836,7 +836,7 @@ public int getMinPrecision()
     public int getMinScale()
     {
         switch (this) {
-        //TODO: Minimum numeric scale for decimal
+        // TODO: Minimum numeric scale for decimal
         case INTERVAL_DAY_TIME:
         case INTERVAL_YEAR_MONTH:
             return MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION;

File: src/main/java/net/hydromatic/optiq/impl/java/JavaTypeFactory.java
Patch:
@@ -37,7 +37,6 @@ public interface JavaTypeFactory extends RelDataTypeFactory {
      */
     RelDataType createStructType(Class clazz);
 
-
     /**
      * Creates a type, deducing whether a record, scalar or primitive type
      * is needed.
@@ -52,6 +51,9 @@ public interface JavaTypeFactory extends RelDataTypeFactory {
     /** Creates a synthetic Java class whose fields have the given Java
      * types. */
     Type createSyntheticType(List<Type> types);
+
+    /** Converts a type in Java format to a SQL-oriented type. */
+    RelDataType toSql(RelDataType type);
 }
 
 // End JavaTypeFactory.java

File: src/main/java/net/hydromatic/linq4j/expressions/BlockBuilder.java
Patch:
@@ -227,9 +227,7 @@ private void optimize() {
                     (DeclarationExpression) oldStatement;
                 final Slot slot = useCounter.map.get(statement.parameter);
                 int count = slot.count;
-                if (slot.expression instanceof ConstantExpression
-                    && ((ConstantExpression) slot.expression).value == null)
-                {
+                if (Expressions.isConstantNull(slot.expression)) {
                     // Don't allow 'final Type t = null' to be inlined. There
                     // is an implicit cast.
                     count = 100;

File: src/main/java/net/hydromatic/linq4j/expressions/Primitive.java
Patch:
@@ -592,7 +592,8 @@ public Object parse(String stringValue) {
     public boolean assignableFrom(Primitive primitive) {
         return family == primitive.family
             && ordinal() >= primitive.ordinal()
-            && !(this == SHORT && primitive == CHAR);
+            && !(this == SHORT && primitive == CHAR)
+            && !(this == CHAR && primitive == BYTE);
     }
 
     /** A place to send a value. */

File: src/test/java/net/hydromatic/linq4j/test/PrimitiveTest.java
Patch:
@@ -48,7 +48,7 @@ public void testIsAssignableFrom() {
         assertFalse(Primitive.SHORT.assignableFrom(Primitive.INT));
         assertFalse(Primitive.SHORT.assignableFrom(Primitive.LONG));
 
-        assertTrue(Primitive.CHAR.assignableFrom(Primitive.BYTE));
+        assertFalse(Primitive.CHAR.assignableFrom(Primitive.BYTE));
         assertFalse(Primitive.CHAR.assignableFrom(Primitive.SHORT));
         assertTrue(Primitive.CHAR.assignableFrom(Primitive.CHAR));
         assertFalse(Primitive.CHAR.assignableFrom(Primitive.INT));

File: src/main/java/net/hydromatic/optiq/jdbc/UnregisteredDriver.java
Patch:
@@ -194,7 +194,7 @@ protected enum JdbcVersion {
         JDBC_41;
 
         /** Deduces the current JDBC version. */
-        protected static JdbcVersion current() {
+        public static JdbcVersion current() {
             try {
                 // If java.sql.PseudoColumnUsage is present, we are running JDBC
                 // 4.1 or later.

File: src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcSchema.java
Patch:
@@ -206,8 +206,7 @@ public Table getTable(String name) {
             }
             final RelDataType type =
                 typeFactory.createStructType(fieldInfo);
-            Type javaType = typeFactory.getJavaClass(type);
-            return new JdbcTable<Object>(javaType, this, name);
+            return new JdbcTable(type, this, name);
         } catch (SQLException e) {
             throw new RuntimeException(
                 "Exception while reading definition of table '" + name + "'",

File: src/main/java/net/hydromatic/optiq/prepare/QueryableRelBuilder.java
Patch:
@@ -70,8 +70,7 @@ RelNode toRel(Queryable<T> queryable) {
                 translator.cluster,
                 new OptiqPrepareImpl.RelOptTableImpl(
                     null,
-                    translator.typeFactory.createType(
-                        queryable.getElementType()),
+                    ((Table) queryable).getRowType(),
                     new String[0],
                     (Table) queryable));
         }

File: src/main/java/org/eigenbase/oj/rel/JavaRel.java
Patch:
@@ -40,15 +40,14 @@
  * <li>{@link org.eigenbase.relopt.CallingConvention#MAP MAP},
  * <li>{@link org.eigenbase.relopt.CallingConvention#VECTOR VECTOR},
  * <li>{@link org.eigenbase.relopt.CallingConvention#HASHTABLE HASHTABLE},
- * <li>{@link org.eigenbase.relopt.CallingConvention#JAVA JAVA},
- * <li>{@link net.hydromatic.optiq.rules.java.JavaRules#CONVENTION ENUMERABLE}.
+ * <li>{@link org.eigenbase.relopt.CallingConvention#JAVA JAVA}.
  * </ul>
  * </li>
  * </ul>
  *
  * <p>For {@link org.eigenbase.relopt.CallingConvention#JAVA JAVA
  * calling-convention}, see the sub-interface {@link JavaLoopRel}, and the
- * auxilliary interface {@link JavaSelfRel}.
+ * auxiliary interface {@link JavaSelfRel}.
  *
  * @author jhyde
  * @version $Id$

File: src/main/java/org/eigenbase/reltype/RelDataType.java
Patch:
@@ -17,7 +17,6 @@
 */
 package org.eigenbase.reltype;
 
-import java.lang.reflect.Type;
 import java.nio.charset.*;
 
 import java.util.*;
@@ -38,7 +37,7 @@
  * @version $Id$
  * @since May 29, 2003
  */
-public interface RelDataType extends Type
+public interface RelDataType /*extends Type*/
 {
     //~ Methods ----------------------------------------------------------------
 

File: src/main/java/org/eigenbase/reltype/RelDataTypeField.java
Patch:
@@ -35,7 +35,7 @@
  * @since May 29, 2003
  */
 public interface RelDataTypeField
-    extends Types.RecordField, Map.Entry<String, RelDataType>
+    extends /*Types.RecordField, */Map.Entry<String, RelDataType>
 {
     //~ Methods ----------------------------------------------------------------
 

File: src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackLinqMiddleTest.java
Patch:
@@ -153,9 +153,9 @@ public void testJoinGroupByOrderBy() {
                 + "group by c.\"state_province\"\n"
                 + "order by c.\"state_province\"")
             .returns(
-                "EXPR$0=24442; state_province=CA; S=74748\n"
-                + "EXPR$0=21611; state_province=OR; S=67659\n"
-                + "EXPR$0=40784; state_province=WA; S=124366\n");
+                "EXPR$0=24442; state_province=CA; S=74748.0000\n"
+                + "EXPR$0=21611; state_province=OR; S=67659.0000\n"
+                + "EXPR$0=40784; state_province=WA; S=124366.0000\n");
     }
 
     public void testCompositeGroupBy() {

File: src/main/java/org/eigenbase/reltype/RelDataTypeFactoryImpl.java
Patch:
@@ -534,7 +534,7 @@ public Charset getDefaultCharset()
     /**
      * Type which is based upon a Java class.
      */
-    protected class JavaType
+    public class JavaType
         extends RelDataTypeImpl
     {
         private final Class clazz;

File: src/main/java/net/hydromatic/optiq/impl/clone/ColumnLoader.java
Patch:
@@ -220,7 +220,7 @@ ArrayTable.Representation chooseRep(int ordinal) {
             final int codeBitCount = log2(nextPowerOf2(map.size()));
             if (codeBitCount < 10 && values.size() > 2000) {
                 final ArrayTable.Representation representation =
-                    chooseFixedRep(-1, Primitive.INT, 0, map.size());
+                    chooseFixedRep(-1, Primitive.INT, 0, map.size() - 1);
                 return new ArrayTable.ObjectDictionary(ordinal, representation);
             }
             return new ArrayTable.ObjectArray(ordinal);

File: src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -180,7 +180,9 @@ <T> PrepareResult<T> prepare_(
                     false,
                     type.isNullable() ? 1 : 0,
                     true,
-                    0,
+                    sqlTypeName.allowsPrec()
+                        ? type.getPrecision()
+                        : -1,
                     field.getName(),
                     origins == null ? null : origins.get(2),
                     origins == null ? null : origins.get(0),

File: src/main/java/org/eigenbase/rex/RexLiteral.java
Patch:
@@ -547,12 +547,13 @@ public boolean isAlwaysTrue()
     public boolean equals(Object obj)
     {
         return (obj instanceof RexLiteral)
-            && equals(((RexLiteral) obj).value, value);
+            && equals(((RexLiteral) obj).value, value)
+            && equals(((RexLiteral) obj).type, type);
     }
 
     public int hashCode()
     {
-        return (value == null) ? 0 : value.hashCode();
+        return Util.hashV(value, type);
     }
 
     public static int intValue(RexNode node)

File: src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -347,7 +347,7 @@ public Type getElementType() {
         };
     }
 
-    static Connection getConnectionWithHrFoodmart()
+    static OptiqConnection getConnectionWithHrFoodmart()
         throws ClassNotFoundException, SQLException
     {
         Class.forName("net.hydromatic.optiq.jdbc.Driver");
@@ -360,7 +360,7 @@ static Connection getConnectionWithHrFoodmart()
             optiqConnection, rootSchema, "hr", new HrSchema());
         ReflectiveSchema.create(
             optiqConnection, rootSchema, "foodmart", new FoodmartSchema());
-        return connection;
+        return optiqConnection;
     }
 
     /**

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqResultSet.java
Patch:
@@ -167,7 +167,7 @@ public float getFloat(int columnIndex) throws SQLException {
     }
 
     public double getDouble(int columnIndex) throws SQLException {
-        return getAccessor(columnIndex).getDouble();
+        return getAccessor(columnIndex - 1).getDouble();
     }
 
     public BigDecimal getBigDecimal(

File: src/main/java/net/hydromatic/optiq/rules/java/JavaRules.java
Patch:
@@ -563,7 +563,7 @@ public BlockExpression implement(EnumerableRelImplementor implementor) {
                         Enumerator.class, inputJavaType),
                     "inputEnumerator");
             Expression input =
-                Expressions.convert_(
+                RexToLixTranslator.convert(
                     Expressions.call(
                         inputEnumerator,
                         BuiltinMethod.ENUMERATOR_CURRENT.method),

File: src/main/java/org/eigenbase/relopt/RelOptUtil.java
Patch:
@@ -1152,9 +1152,7 @@ private static void splitJoinCondition(
                         // perform casting
                         RelDataType targetKeyType =
                             typeFactory.leastRestrictive(
-                                new RelDataType[] {
-                                    leftKeyType, rightKeyType
-                                });
+                                Arrays.asList(leftKeyType, rightKeyType));
 
                         if (targetKeyType == null) {
                             throw Util.newInternal(

File: src/main/java/org/eigenbase/reltype/RelDataTypeFactory.java
Patch:
@@ -199,14 +199,14 @@ public RelDataType createTypeWithCharsetAndCollation(
      * may be a new type which is less restrictive than any of the input types,
      * e.g. leastRestrictive(INT, NUMERIC(3,2)) could be NUMERIC(12,2).
      *
-     * @param types input types to be unioned
+     * @param types input types to be combined using union
      *
      * @return canonical union type descriptor
      *
      * @pre types != null
      * @pre types.length >= 1
      */
-    public RelDataType leastRestrictive(RelDataType [] types);
+    public RelDataType leastRestrictive(List<RelDataType> types);
 
     /**
      * Creates a SQL type with no precision or scale.

File: src/main/java/org/eigenbase/sql/SqlOperator.java
Patch:
@@ -309,8 +309,8 @@ public final SqlCall createCall(
      * derivation methods). The default implementation is to just return the
      * original call without any rewrite.
      *
-     * @param validator
-     * @param call to be rewritten
+     * @param validator Validator
+     * @param call Call to be rewritten
      *
      * @return rewritten call
      */
@@ -550,7 +550,7 @@ public final RelDataType inferReturnType(
             new ExplicitOperatorBinding(
                 typeFactory,
                 this,
-                operandTypes));
+                Arrays.asList(operandTypes)));
     }
 
     /**

File: src/main/java/org/eigenbase/util/CompositeList.java
Patch:
@@ -59,7 +59,7 @@ public CompositeList(List<T>... lists)
      * {@link java.util.Arrays#asList(Object[])} or
      * {@link java.util.EnumSet#of(Enum, Enum[])}.
      *
-     * @param lists Consistituent lists
+     * @param lists Constituent lists
      * @param <T> Element type
      * @return List consisting of all lists
      */

File: src/test/java/net/hydromatic/optiq/test/OptiqAssert.java
Patch:
@@ -25,6 +25,7 @@
 import junit.framework.Assert;
 import junit.framework.TestSuite;
 
+import org.eigenbase.test.SqlToRelConverterTest;
 import org.eigenbase.util.Util;
 
 import java.io.PrintWriter;
@@ -49,6 +50,7 @@ public static TestSuite suite() {
         testSuite.addTestSuite(JdbcFrontLinqBackTest.class);
         testSuite.addTestSuite(JdbcFrontJdbcBackLinqMiddleTest.class);
         testSuite.addTestSuite(JdbcFrontJdbcBackTest.class);
+        testSuite.addTestSuite(SqlToRelConverterTest.class);
         return testSuite;
     }
 

File: src/main/java/net/hydromatic/linq4j/expressions/Expressions.java
Patch:
@@ -1468,7 +1468,8 @@ public static UnaryExpression makeUnary(
         Method method)
     {
         assert type != null;
-        throw Extensions.todo();
+        return new UnaryExpression(
+            expressionType, type, expression);
     }
 
     /** Creates a MemberMemberBinding that represents the recursive

File: src/main/java/net/hydromatic/optiq/impl/jdbc/JdbcSchema.java
Patch:
@@ -50,7 +50,7 @@ public class JdbcSchema implements Schema {
     final DataSource dataSource;
     private final String catalog;
     private final String schema;
-    private final JavaTypeFactory typeFactory;
+    final JavaTypeFactory typeFactory;
     private final Expression expression;
     final SqlDialect dialect;
 

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -406,7 +406,7 @@ public void setSchema(String schema) throws SQLException {
         this.schema = schema;
     }
 
-    public String getSchema() throws SQLException {
+    public String getSchema() {
         return schema;
     }
 

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqPrepare.java
Patch:
@@ -60,6 +60,8 @@ interface Context {
         JavaTypeFactory getTypeFactory();
 
         Schema getRootSchema();
+
+        List<String> getDefaultSchemaPath();
     }
 
     public static class ParseResult {

File: src/main/java/org/eigenbase/relopt/RelOptUtil.java
Patch:
@@ -1471,7 +1471,9 @@ private static void splitJoinCondition(
         }
 
         // Add this condition to the list of non-equi-join conditions.
-        nonEquiList.add(condition);
+        if (!condition.isAlwaysTrue()) {
+            nonEquiList.add(condition);
+        }
     }
 
     /**

File: src/test/java/net/hydromatic/optiq/test/JdbcFrontJdbcBackTest.java
Patch:
@@ -35,7 +35,7 @@
 public class JdbcFrontJdbcBackTest extends TestCase {
     public void testWhere2() {
         assertThat()
-            .inJdbcFoodmart2()
+            .with(OptiqAssert.Config.JDBC_FOODMART2)
             .query("select * from \"foodmart\".\"days\" where \"day\" < 3")
             .returns(
                 "day=1; week_day=Sunday\n"

File: src/test/java/net/hydromatic/optiq/test/LinqFrontJdbcBackTest.java
Patch:
@@ -21,7 +21,6 @@
 import net.hydromatic.linq4j.expressions.ParameterExpression;
 import net.hydromatic.linq4j.function.Predicate1;
 import net.hydromatic.optiq.Schema;
-import net.hydromatic.optiq.impl.jdbc.JdbcSchema;
 import net.hydromatic.optiq.jdbc.OptiqConnection;
 
 import junit.framework.TestCase;
@@ -36,7 +35,8 @@
 public class LinqFrontJdbcBackTest extends TestCase {
     public void testTableWhere() {
         try {
-            final OptiqConnection connection = JdbcTest.getConnection(null);
+            final OptiqConnection connection =
+                JdbcTest.getConnection(null, false);
             Schema schema =
                 connection.getRootSchema().getSubSchema("foodmart");
             ParameterExpression c =

File: src/main/java/net/hydromatic/linq4j/expressions/Expressions.java
Patch:
@@ -530,9 +530,9 @@ public static ConstantExpression constant(Object value) {
             type = Object.class;
         } else {
             final Class clazz = value.getClass();
-            final Class primitiveType = Types.toPrimitive(clazz);
-            if (primitiveType != null) {
-                type = primitiveType;
+            final Primitive primitive = Primitive.ofBox(clazz);
+            if (primitive != null) {
+                type = primitive.primitiveClass;
             } else {
                 type = clazz;
             }

File: src/main/java/net/hydromatic/linq4j/QueryableRecorder.java
Patch:
@@ -427,7 +427,7 @@ public void replay(QueryableFactory<T> factory) {
     public <TKey> Queryable<Grouping<TKey, T>> groupBy(
         final Queryable<T> source,
         final FunctionExpression<Function1<T, TKey>> keySelector,
-        final EqualityComparer<T> comparer)
+        final EqualityComparer<TKey> comparer)
     {
         return new NonLeafReplayableQueryable<T>(source) {
             public void replay(QueryableFactory<T> factory) {
@@ -468,7 +468,7 @@ Queryable<Grouping<TKey, TElement>> groupBy(
         final Queryable<T> source,
         final FunctionExpression<Function1<T, TKey>> keySelector,
         final FunctionExpression<Function1<T, TElement>> elementSelector,
-        final EqualityComparer<T> comparer)
+        final EqualityComparer<TKey> comparer)
     {
         return new NonLeafReplayableQueryable<T>(source) {
             public void replay(QueryableFactory<T> factory) {

File: src/main/java/net/hydromatic/optiq/prepare/QueryableRelBuilder.java
Patch:
@@ -302,7 +302,7 @@ public <TKey> Queryable<Grouping<TKey, T>> groupBy(
     public <TKey> Queryable<Grouping<TKey, T>> groupBy(
         Queryable<T> source,
         FunctionExpression<Function1<T, TKey>> keySelector,
-        EqualityComparer<T> comparer)
+        EqualityComparer<TKey> comparer)
     {
         throw new UnsupportedOperationException();
     }
@@ -328,7 +328,7 @@ public <TKey, TElement> Queryable<Grouping<TKey, TElement>> groupBy(
         Queryable<T> source,
         FunctionExpression<Function1<T, TKey>> keySelector,
         FunctionExpression<Function1<T, TElement>> elementSelector,
-        EqualityComparer<T> comparer)
+        EqualityComparer<TKey> comparer)
     {
         throw new UnsupportedOperationException();
     }

File: src/main/java/net/hydromatic/linq4j/DefaultEnumerable.java
Patch:
@@ -234,7 +234,7 @@ public <TKey> Enumerable<Grouping<TKey, T>> groupBy(
 
     public <TKey> Enumerable<Grouping<TKey, T>> groupBy(
         Function1<T, TKey> keySelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return EnumerableDefaults.groupBy(getThis(), keySelector, comparer);
     }

File: src/main/java/net/hydromatic/linq4j/DefaultQueryable.java
Patch:
@@ -248,7 +248,7 @@ public <TKey> Queryable<Grouping<TKey, T>> groupBy(
 
     public <TKey> Queryable<Grouping<TKey, T>> groupBy(
         FunctionExpression<Function1<T, TKey>> keySelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return factory.groupBy(getThis(), keySelector, comparer);
     }
@@ -277,7 +277,7 @@ public <TKey, TResult> Queryable<Grouping<TKey, TResult>> groupByK(
     public <TKey, TElement> Queryable<Grouping<TKey, TElement>> groupBy(
         FunctionExpression<Function1<T, TKey>> keySelector,
         FunctionExpression<Function1<T, TElement>> elementSelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return factory.groupBy(
             getThis(), keySelector, elementSelector, comparer);
@@ -287,7 +287,7 @@ public <TKey, TResult> Queryable<TResult> groupByK(
         FunctionExpression<Function1<T, TKey>> keySelector,
         FunctionExpression<Function2<TKey, Enumerable<T>, TResult>>
             elementSelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return factory.groupByK(
             getThis(), keySelector, elementSelector, comparer);

File: src/main/java/net/hydromatic/linq4j/EnumerableDefaults.java
Patch:
@@ -434,7 +434,7 @@ public static <TSource, TKey> Enumerable<Grouping<TKey, TSource>> groupBy(
     public static <TSource, TKey> Enumerable<Grouping<TKey, TSource>> groupBy(
         Enumerable<TSource> enumerable,
         Function1<TSource, TKey> keySelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return enumerable.toLookup(keySelector, comparer);
     }
@@ -472,7 +472,7 @@ Enumerable<Grouping<TKey, TElement>> groupBy(
         Enumerable<TSource> enumerable,
         Function1<TSource, TKey> keySelector,
         Function1<TSource, TElement> elementSelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         throw Extensions.todo();
     }

File: src/main/java/net/hydromatic/linq4j/EnumerableQueryable.java
Patch:
@@ -279,7 +279,7 @@ public <TKey> Queryable<Grouping<TKey, T>> groupBy(
 
     public <TKey> Queryable<Grouping<TKey, T>> groupBy(
         FunctionExpression<Function1<T, TKey>> keySelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return EnumerableDefaults
             .groupBy(
@@ -309,7 +309,7 @@ public <TKey, TResult> Queryable<Grouping<TKey, TResult>> groupByK(
     public <TKey, TElement> Queryable<Grouping<TKey, TElement>> groupBy(
         FunctionExpression<Function1<T, TKey>> keySelector,
         FunctionExpression<Function1<T, TElement>> elementSelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return EnumerableDefaults.groupBy(
             getThis(),
@@ -322,7 +322,7 @@ public <TKey, TResult> Queryable<TResult> groupByK(
         FunctionExpression<Function1<T, TKey>> keySelector,
         FunctionExpression<Function2<TKey, Enumerable<T>, TResult>>
             elementSelector,
-        EqualityComparer comparer)
+        EqualityComparer<TKey> comparer)
     {
         return EnumerableDefaults.groupBy(
             getThis(),

File: src/main/java/net/hydromatic/linq4j/ExtendedEnumerable.java
Patch:
@@ -260,7 +260,8 @@ <TKey> Enumerable<Grouping<TKey, TSource>> groupBy(
      * specified key selector function and compares the keys by using
      * a specified comparer. */
     <TKey> Enumerable<Grouping<TKey, TSource>> groupBy(
-        Function1<TSource, TKey> keySelector, EqualityComparer comparer);
+        Function1<TSource, TKey> keySelector,
+        EqualityComparer<TKey> comparer);
 
     /** Groups the elements of a sequence according to a
      * specified key selector function and projects the elements for

File: src/main/java/net/hydromatic/linq4j/QueryableFactory.java
Patch:
@@ -257,7 +257,7 @@ <TKey> Queryable<Grouping<TKey, T>> groupBy(
     <TKey> Queryable<Grouping<TKey, T>> groupBy(
         Queryable<T> source,
         FunctionExpression<Function1<T, TKey>> keySelector,
-        EqualityComparer<T> comparer);
+        EqualityComparer<TKey> comparer);
 
     /** Groups the elements of a sequence according to a
      * specified key selector function and projects the elements for
@@ -284,7 +284,7 @@ <TKey, TElement> Queryable<Grouping<TKey, TElement>> groupBy(
         Queryable<T> source,
         FunctionExpression<Function1<T, TKey>> keySelector,
         FunctionExpression<Function1<T, TElement>> elementSelector,
-        EqualityComparer<T> comparer);
+        EqualityComparer<TKey> comparer);
 
     /** Groups the elements of a sequence according to a
      * specified key selector function and creates a result value from

File: src/main/java/net/hydromatic/linq4j/QueryableRecorder.java
Patch:
@@ -427,7 +427,7 @@ public void replay(QueryableFactory<T> factory) {
     public <TKey> Queryable<Grouping<TKey, T>> groupBy(
         final Queryable<T> source,
         final FunctionExpression<Function1<T, TKey>> keySelector,
-        final EqualityComparer<T> comparer)
+        final EqualityComparer<TKey> comparer)
     {
         return new NonLeafReplayableQueryable<T>(source) {
             public void replay(QueryableFactory<T> factory) {
@@ -468,7 +468,7 @@ Queryable<Grouping<TKey, TElement>> groupBy(
         final Queryable<T> source,
         final FunctionExpression<Function1<T, TKey>> keySelector,
         final FunctionExpression<Function1<T, TElement>> elementSelector,
-        final EqualityComparer<T> comparer)
+        final EqualityComparer<TKey> comparer)
     {
         return new NonLeafReplayableQueryable<T>(source) {
             public void replay(QueryableFactory<T> factory) {

File: src/main/java/org/eigenbase/rex/RexInputRef.java
Patch:
@@ -55,7 +55,7 @@ public class RexInputRef
     //~ Static fields/initializers ---------------------------------------------
 
     // list of common names, to reduce memory allocations
-    private static final List<String> names = new SelfPopulatingList("$");
+    private static final List<String> names = new SelfPopulatingList("$", 30);
 
     //~ Constructors -----------------------------------------------------------
 

File: src/main/java/org/eigenbase/rex/RexLocalRef.java
Patch:
@@ -44,7 +44,7 @@ public class RexLocalRef
     //~ Static fields/initializers ---------------------------------------------
 
     // array of common names, to reduce memory allocations
-    private static final List<String> names = new SelfPopulatingList("$t");
+    private static final List<String> names = new SelfPopulatingList("$t", 30);
 
     //~ Constructors -----------------------------------------------------------
 

File: src/main/java/net/hydromatic/linq4j/expressions/FunctionExpression.java
Patch:
@@ -141,7 +141,8 @@ void accept(ExpressionWriter writer, int lprec, int rprec) {
         }
         Type resultType2 = bridgeResultType;
         if (bridgeResultType == Object.class
-            && !params.equals(bridgeParams))
+            && !params.equals(bridgeParams)
+            && !(body.getType() instanceof TypeVariable))
         {
             resultType2 = body.getType();
         }

File: src/main/java/net/hydromatic/optiq/jdbc/UnregisteredDriver.java
Patch:
@@ -71,6 +71,9 @@ private static String getFactoryClassName() {
     }
 
     public Connection connect(String url, Properties info) throws SQLException {
+        if (!acceptsURL(url)) {
+            return null;
+        }
         return factory.newConnection(this, factory, url, info);
     }
 

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -24,7 +24,6 @@
 import net.hydromatic.linq4j.expressions.ParameterExpression;
 import net.hydromatic.optiq.DataContext;
 import net.hydromatic.optiq.MutableSchema;
-import net.hydromatic.optiq.Schema;
 import net.hydromatic.optiq.impl.java.JavaTypeFactory;
 import net.hydromatic.optiq.impl.java.MapSchema;
 import net.hydromatic.optiq.runtime.ByteString;
@@ -145,7 +144,7 @@ public <T> Enumerator<T> executeQuery(Queryable<T> queryable) {
             OptiqStatement statement = createStatement();
             OptiqPrepare.PrepareResult enumerable =
                 statement.prepare(queryable);
-            return (Enumerator) enumerable.execute();
+            return (Enumerator<T>) enumerable.execute();
         } catch (SQLException e) {
             throw new RuntimeException(e);
         }

File: src/main/java/org/eigenbase/reltype/RelDataType.java
Patch:
@@ -17,6 +17,7 @@
 */
 package org.eigenbase.reltype;
 
+import java.lang.reflect.Type;
 import java.nio.charset.*;
 
 import java.util.*;
@@ -37,7 +38,7 @@
  * @version $Id$
  * @since May 29, 2003
  */
-public interface RelDataType
+public interface RelDataType extends Type
 {
     //~ Methods ----------------------------------------------------------------
 

File: src/main/java/org/eigenbase/reltype/RelDataTypeField.java
Patch:
@@ -17,6 +17,8 @@
 */
 package org.eigenbase.reltype;
 
+import net.hydromatic.linq4j.expressions.Types;
+
 /**
  * RelDataTypeField represents the definition of a field in a structured {@link
  * RelDataType}.
@@ -25,7 +27,7 @@
  * @version $Id$
  * @since May 29, 2003
  */
-public interface RelDataTypeField
+public interface RelDataTypeField extends Types.RecordField
 {
     //~ Methods ----------------------------------------------------------------
 

File: src/test/java/net/hydromatic/optiq/test/JdbcTest.java
Patch:
@@ -618,10 +618,11 @@ public void testJdbcBackendLinqFrontend() {
                     Expressions.<Predicate1<Customer>>lambda(
                         Expressions.lessThan(
                             Expressions.field(c, "customer_id"),
-                            Expressions.constant(50)),
+                            Expressions.constant(5)),
                         c))
                 .toList()
                 .toString();
+            System.out.println(s);
         } catch (Exception e) {
             throw new RuntimeException(e);
         }

File: src/main/java/net/hydromatic/linq4j/ExtendedEnumerable.java
Patch:
@@ -171,7 +171,7 @@ <TAccumulate, TResult> TResult aggregate(
      * obtain only those elements that can be cast to type TResult, use the
      * {@link #ofType(Class)} method instead.
      *
-     * @see EnumerableDefaults#cast(Enumerable
+     * @see EnumerableDefaults#cast
      * @see #ofType(Class)
      */
     <T2> Enumerable<T2> cast(Class<T2> clazz);

File: src/main/java/net/hydromatic/linq4j/Enumerable.java
Patch:
@@ -33,7 +33,7 @@ public interface Enumerable<T>
     /**
      * Converts this Enumerable to a Queryable.
      *
-     * @see Extensions#asQueryable(Enumerable)
+     * @see EnumerableDefaults#asQueryable(Enumerable
      */
     Queryable<T> asQueryable();
 

File: src/main/java/net/hydromatic/linq4j/ExtendedEnumerable.java
Patch:
@@ -171,7 +171,7 @@ <TAccumulate, TResult> TResult aggregate(
      * obtain only those elements that can be cast to type TResult, use the
      * {@link #ofType(Class)} method instead.
      *
-     * @see Extensions#cast(Enumerable, Class)
+     * @see EnumerableDefaults#cast(Enumerable
      * @see #ofType(Class)
      */
     <T2> Enumerable<T2> cast(Class<T2> clazz);

File: src/main/java/net/hydromatic/linq4j/Linq4j.java
Patch:
@@ -29,7 +29,7 @@ public class Linq4j {
      * enumerator method; does not attempt optimization. */
     public static final QueryProvider DEFAULT_PROVIDER =
         new QueryProviderImpl() {
-            protected <T> Enumerator<T> executeQuery(QueryableImpl<T> queryable)
+            public <T> Enumerator<T> executeQuery(Queryable<T> queryable)
             {
                 return queryable.enumerator();
             }

File: src/main/java/net/hydromatic/linq4j/LookupImpl.java
Patch:
@@ -99,7 +99,7 @@ public Enumerable<V> remove(Object key) {
 
     public void putAll(Map<? extends K, ? extends Enumerable<V>> m) {
         for (Entry<? extends K, ? extends Enumerable<V>> entry : m.entrySet()) {
-            map.put(entry.getKey(), Extensions.toList(entry.getValue()));
+            map.put(entry.getKey(), entry.getValue().toList());
         }
     }
 

File: src/main/java/net/hydromatic/linq4j/expressions/Types.java
Patch:
@@ -259,8 +259,7 @@ && allAssignable(
                 }
             }
             throw new RuntimeException(
-                "while resolving static method '" + methodName + "' in class "
-                + clazz,
+                "while resolving method '" + methodName + "' in class " + clazz,
                 e);
         }
     }

File: src/main/java/net/hydromatic/linq4j/function/Functions.java
Patch:
@@ -17,6 +17,7 @@
 */
 package net.hydromatic.linq4j.function;
 
+import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.util.*;
 
@@ -187,7 +188,7 @@ public boolean apply(T v1) {
      * @param aClass Return type
      * @return Function class
      */
-    public static Class<? extends Function> functionClass(Class aClass) {
+    public static Class<? extends Function> functionClass(Type aClass) {
         Class<? extends Function> c = FUNCTION1_CLASSES.get(aClass);
         if (c != null) {
             return c;

File: src/main/java/net/hydromatic/optiq/impl/java/package-info.java
Patch:
@@ -19,6 +19,6 @@
 /**
  * Main package for Optiq, the dynamic data management platform.
  */
-package net.hydromatic.optiq;
+package net.hydromatic.optiq.impl.java;
 
 // End package-info.java

File: src/main/java/net/hydromatic/optiq/impl/jdbc/package-info.java
Patch:
@@ -19,6 +19,6 @@
 /**
  * Main package for Optiq, the dynamic data management platform.
  */
-package net.hydromatic.optiq;
+package net.hydromatic.optiq.impl.jdbc;
 
 // End package-info.java

File: src/main/java/net/hydromatic/optiq/server/package-info.java
Patch:
@@ -19,6 +19,6 @@
 /**
  * Provides a server for hosting Optiq connections.
  */
-package net.hydromatic.optiq.runtime;
+package net.hydromatic.optiq.server;
 
 // End package-info.java

File: src/main/java/net/hydromatic/optiq/jdbc/OptiqConnectionImpl.java
Patch:
@@ -36,6 +36,7 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
+import java.math.BigDecimal;
 import java.sql.*;
 import java.util.*;
 import java.util.concurrent.Executor;
@@ -491,6 +492,8 @@ public Class getJavaClass(RelDataType type) {
                     return Short.class;
                 case TINYINT:
                     return Byte.class;
+                case DECIMAL:
+                    return BigDecimal.class;
                 case BOOLEAN:
                     return Boolean.class;
                 case BINARY:

File: src/main/java/net/hydromatic/linq4j/EnumerableOrderedQueryable.java
Patch:
@@ -37,7 +37,7 @@ class EnumerableOrderedQueryable<T>
         QueryProvider provider,
         Expression expression)
     {
-        super(enumerable, rowType, provider, expression);
+        super(provider, rowType, expression, enumerable);
     }
 
     public <TKey extends Comparable<TKey>> OrderedQueryable<T> thenBy(

File: src/main/java/net/hydromatic/optiq/prepare/OptiqPrepareImpl.java
Patch:
@@ -222,6 +222,7 @@ public OptiqPreparingStmt(
             planner.addRule(JavaRules.ENUMERABLE_CALC_RULE);
             planner.addRule(JavaRules.ENUMERABLE_AGGREGATE_RULE);
             planner.addRule(JavaRules.ENUMERABLE_SORT_RULE);
+            planner.addRule(JavaRules.ENUMERABLE_UNION_RULE);
             planner.addRule(TableAccessRule.instance);
 
             rexBuilder = new RexBuilder(typeFactory);

File: src/main/java/net/hydromatic/linq4j/EnumerableQueryable.java
Patch:
@@ -21,6 +21,7 @@
 import net.hydromatic.linq4j.expressions.FunctionExpression;
 import net.hydromatic.linq4j.function.*;
 
+import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -146,7 +147,7 @@ public <T2> Queryable<T2> cast(Class<T2> clazz) {
 
     // Queryable methods
 
-    public Class<T> getElementType() {
+    public Type getElementType() {
         return rowType;
     }
 

File: src/main/java/net/hydromatic/linq4j/OrderedQueryable.java
Patch:
@@ -18,6 +18,8 @@
 package net.hydromatic.linq4j;
 
 /**
+ * Represents the result of applying a sorting operation to a {@link Queryable}.
+ *
  * @author jhyde
  */
 public interface OrderedQueryable<T>

File: src/main/java/net/hydromatic/linq4j/Queryable.java
Patch:
@@ -17,8 +17,6 @@
 */
 package net.hydromatic.linq4j;
 
-import net.hydromatic.linq4j.expressions.Expression;
-
 /**
  * Provides functionality to evaluate queries against a specific data source
  * wherein the type of the data is known.

File: src/main/java/net/hydromatic/linq4j/RawQueryable.java
Patch:
@@ -19,6 +19,8 @@
 
 import net.hydromatic.linq4j.expressions.Expression;
 
+import java.lang.reflect.Type;
+
 /**
  * Core methods that define a {@link Queryable}.
  *
@@ -33,7 +35,7 @@ public interface RawQueryable<T> extends Enumerable<T> {
      * Gets the type of the element(s) that are returned when the expression
      * tree associated with this Queryable is executed.
      */
-    Class<T> getElementType();
+    Type getElementType();
 
     /** Gets the expression tree that is associated with this Queryable. */
     Expression getExpression();

File: src/main/java/net/hydromatic/linq4j/expressions/BlockExpression.java
Patch:
@@ -17,6 +17,7 @@
 */
 package net.hydromatic.linq4j.expressions;
 
+import java.lang.reflect.Type;
 import java.util.List;
 
 /**
@@ -26,7 +27,7 @@
 public class BlockExpression extends Expression {
     private final List<Expression> expressions;
 
-    BlockExpression(List<Expression> expressions, Class type) {
+    BlockExpression(List<Expression> expressions, Type type) {
         super(ExpressionType.Block, type);
         this.expressions = expressions;
     }

File: src/main/java/net/hydromatic/linq4j/expressions/UnaryExpression.java
Patch:
@@ -17,14 +17,16 @@
 */
 package net.hydromatic.linq4j.expressions;
 
+import java.lang.reflect.Type;
+
 /**
  * Represents an expression that has a unary operator.
  */
 public class UnaryExpression extends Expression {
     private final Expression expression;
 
     UnaryExpression(
-        ExpressionType nodeType, Class type, Expression expression)
+        ExpressionType nodeType, Type type, Expression expression)
     {
         super(nodeType, type);
         this.expression = expression;
@@ -48,8 +50,6 @@ void accept(ExpressionWriter writer, int lprec, int rprec) {
             writer.append(nodeType.op);
             expression.accept(writer, lprec, rprec);
         }
-
-//        (String) ((Object) "foo").
     }
 }
 

File: src/main/java/net/hydromatic/linq4j/DefaultQueryable.java
Patch:
@@ -439,7 +439,7 @@ public Queryable<T> skipWhile(FunctionExpression<Predicate1<T>> predicate) {
     }
 
     public Queryable<T> skipWhileN(
-        FunctionExpression<Function2<T, Integer, Boolean>> predicate)
+        FunctionExpression<Predicate2<T, Integer>> predicate)
     {
         return Extensions.skipWhileN(getThis(), predicate);
     }
@@ -501,7 +501,7 @@ public Queryable<T> takeWhile(FunctionExpression<Predicate1<T>> predicate) {
     }
 
     public Queryable<T> takeWhileN(
-        FunctionExpression<Function2<T, Integer, Boolean>> predicate)
+        FunctionExpression<Predicate2<T, Integer>> predicate)
     {
         return Extensions.takeWhileN(getThis(), predicate);
     }
@@ -521,7 +521,7 @@ public Queryable<T> whereN(
         //noinspection unchecked
         return Extensions.whereN(
             getThis(),
-            (FunctionExpression<Predicate2<T,Integer>>) predicate);
+            (FunctionExpression<Predicate2<T, Integer>>) predicate);
     }
 
     public <T1, TResult> Queryable<TResult> zip(

File: src/main/java/net/hydromatic/linq4j/EnumerableQueryable.java
Patch:
@@ -538,7 +538,7 @@ public Queryable<T> skipWhile(FunctionExpression<Predicate1<T>> predicate) {
     }
 
     public Queryable<T> skipWhileN(
-        FunctionExpression<Function2<T, Integer, Boolean>> predicate)
+        FunctionExpression<Predicate2<T, Integer>> predicate)
     {
         return Extensions.skipWhile(getThis(), predicate.getFunction())
             .asQueryable();
@@ -602,7 +602,7 @@ public Queryable<T> takeWhile(FunctionExpression<Predicate1<T>> predicate) {
     }
 
     public Queryable<T> takeWhileN(
-        FunctionExpression<Function2<T, Integer, Boolean>> predicate)
+        FunctionExpression<Predicate2<T, Integer>> predicate)
     {
         return Extensions.takeWhile(getThis(), predicate.getFunction())
             .asQueryable();

File: src/main/java/net/hydromatic/linq4j/ExtendedQueryable.java
Patch:
@@ -521,7 +521,7 @@ Queryable<TSource> skipWhile(
      * elements. The element's index is used in the logic of the
      * predicate function. */
     Queryable<TSource> skipWhileN(
-        FunctionExpression<Function2<TSource, Integer, Boolean>> predicate);
+        FunctionExpression<Predicate2<TSource, Integer>> predicate);
 
     /** Computes the sum of the sequence of Decimal values
      * that is obtained by invoking a projection function on each
@@ -592,7 +592,7 @@ Queryable<TSource> takeWhile(
      * specified condition is true. The element's index is used in the
      * logic of the predicate function. */
     Queryable<TSource> takeWhileN(
-        FunctionExpression<Function2<TSource, Integer, Boolean>> predicate);
+        FunctionExpression<Predicate2<TSource, Integer>> predicate);
 
     /** Produces the set union of two sequences by using
      * the default equality comparer. */

File: src/main/java/net/hydromatic/linq4j/expressions/Expressions.java
Patch:
@@ -91,7 +91,8 @@ public static BinaryExpression addAssignChecked(
         Expression expression0,
         Expression expression1)
     {
-        return makeBinary(ExpressionType.AddAssignChecked, expression0, expression1);
+        return makeBinary(
+            ExpressionType.AddAssignChecked, expression0, expression1);
     }
 
     /** Creates a BinaryExpression that represents an addition
@@ -1169,7 +1170,7 @@ public static LabelTarget label(Class type, String name) {
     }
 
     /** Creates a FunctionExpression from an actual function. */
-    public static <T, F extends Function<T>>
+    public static <F extends Function<?>>
     FunctionExpression<F> lambda(F function) {
         // REVIEW: Check that that function class is non-inner, has a public
         // default constructor, etc.?

File: src/main/java/net/hydromatic/linq4j/AbstractEnumerable.java
Patch:
@@ -29,7 +29,7 @@
  */
 public abstract class AbstractEnumerable<T> extends DefaultEnumerable<T> {
     public Iterator<T> iterator() {
-        return Extensions.enumeratorIterator(enumerator());
+        return Linq4j.enumeratorIterator(enumerator());
     }
 }
 

File: src/main/java/net/hydromatic/linq4j/AbstractEnumerable2.java
Patch:
@@ -27,7 +27,7 @@
  */
 public abstract class AbstractEnumerable2<T> extends DefaultEnumerable<T> {
     public Enumerator<T> enumerator() {
-        return Extensions.iterableEnumerator(this);
+        return Linq4j.iterableEnumerator(this);
     }
 }
 

File: src/main/java/net/hydromatic/linq4j/GroupingImpl.java
Patch:
@@ -55,7 +55,7 @@ public boolean equals(Object obj) {
 
     // implement Map.Entry
     public Enumerable<V> getValue() {
-        return Extensions.asEnumerable(values);
+        return Linq4j.asEnumerable(values);
     }
 
     // implement Map.Entry
@@ -71,7 +71,7 @@ public K getKey() {
     }
 
     public Enumerator<V> enumerator() {
-        return Extensions.enumerator(values);
+        return Linq4j.enumerator(values);
     }
 }
 

