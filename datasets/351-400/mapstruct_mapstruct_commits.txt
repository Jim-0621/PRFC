File: processor/src/main/java/org/mapstruct/ap/spi/util/IntrospectorUtils.java
Patch:
@@ -32,7 +32,7 @@ private IntrospectorUtils() {
      * @return The decapitalized version of the string.
      */
     public static String decapitalize(String name) {
-        if ( name == null || name.length() == 0 ) {
+        if ( name == null || name.isEmpty() ) {
             return name;
         }
         if ( name.length() > 1 && Character.isUpperCase( name.charAt( 1 ) ) &&

File: core/src/main/java/org/mapstruct/NullValuePropertyMappingStrategy.java
Patch:
@@ -10,7 +10,7 @@
  * {@link NullValuePropertyMappingStrategy} can be defined on {@link MapperConfig}, {@link Mapper}, {@link BeanMapping}
  * and {@link Mapping}.
  * Precedence is arranged  in the reverse order. So {@link Mapping} will override {@link BeanMapping}, will
- * overide {@link Mapper}
+ * override {@link Mapper}
  *
  * The enum <b>only applies to update methods</b>: methods that update a pre-existing target (annotated with
  * {@code @}{@link MappingTarget}).

File: processor/src/main/java/org/mapstruct/ap/internal/model/NestedTargetPropertyMappingHolder.java
Patch:
@@ -64,7 +64,7 @@ public List<Parameter> getProcessedSourceParameters() {
     }
 
     /**
-     * @return all the targets that were hanled
+     * @return all the targets that were handled
      */
     public Set<String> getHandledTargets() {
         return handledTargets;

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/Method.java
Patch:
@@ -83,7 +83,7 @@ public interface Method {
     Parameter getMappingTargetParameter();
 
     /**
-     * Returns whether the meethod is designated as bean factory for
+     * Returns whether the method is designated as bean factory for
      * mapping target {@link  org.mapstruct.ObjectFactory }
      *
      * @return true if it is a target bean factory.

File: processor/src/main/java/org/mapstruct/ap/internal/util/NativeTypes.java
Patch:
@@ -174,7 +174,7 @@ void removeAndValidateFloatingPointLiteralSuffix() {
             boolean endsWithDSuffix = PTRN_DOUBLE.matcher( val ).find();
             // error handling
             if ( isFloat && endsWithDSuffix ) {
-                throw new NumberFormatException( "Assiging double to a float" );
+                throw new NumberFormatException( "Assigning double to a float" );
             }
             // remove suffix
             if ( endsWithLSuffix || endsWithFSuffix || endsWithDSuffix ) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -1364,7 +1364,7 @@ else if ( !mapping.isIgnored() ) {
                 handledTargets.add( targetPropertyName );
             }
 
-            // its a constant
+            // it's a constant
             // if we have an unprocessed target that means that it most probably is nested and we should
             // not generated any mapping for it now. Eventually it will be done though
             else if ( mapping.getConstant() != null ) {
@@ -1384,7 +1384,7 @@ else if ( mapping.getConstant() != null ) {
                 handledTargets.add( targetPropertyName );
             }
 
-            // its an expression
+            // it's an expression
             // if we have an unprocessed target that means that it most probably is nested and we should
             // not generated any mapping for it now. Eventually it will be done though
             else if ( mapping.getJavaExpression() != null ) {
@@ -1400,7 +1400,7 @@ else if ( mapping.getJavaExpression() != null ) {
                     .build();
                 handledTargets.add( targetPropertyName );
             }
-            // its a plain-old property mapping
+            // it's a plain-old property mapping
             else  {
 
                 SourceReference sourceRef = mappingRef.getSourceReference();

File: processor/src/main/java/org/mapstruct/ap/internal/model/MappingBuilderContext.java
Patch:
@@ -259,7 +259,7 @@ public boolean canGenerateAutoSubMappingBetween(Type sourceType, Type targetType
     }
 
     /**
-     * @param type that MapStruct wants to use to genrate an autoamtic sub-mapping for/from
+     * @param type that MapStruct wants to use to generate an automatic sub-mapping for/from
      *
      * @return {@code true} if the type is not excluded from the {@link MappingExclusionProvider}
      */

File: processor/src/main/java/org/mapstruct/ap/internal/model/NestedTargetPropertyMappingHolder.java
Patch:
@@ -226,7 +226,7 @@ public NestedTargetPropertyMappingHolder build() {
                         handledTargets.add( entryByTP.getKey() );
                     }
 
-                    // For the nonNested mappings (assymetric) Mappings we also forge mappings
+                    // For the nonNested mappings (asymmetric) Mappings we also forge mappings
                     // However, here we do not forge name based mappings and we only
                     // do update on the defined Mappings.
                     if ( !groupedSourceReferences.nonNested.isEmpty() ) {
@@ -755,7 +755,7 @@ public String toString() {
     }
 
     /**
-     * This class is used to group Source references in respected to the nestings that they have.
+     * This class is used to group Source references in respected to the nesting that they have.
      *
      * This class contains all groupings by Property Entries if they are nested, or a list of all the other options
      * that could not have been popped.

File: processor/src/main/java/org/mapstruct/ap/internal/model/ValueMappingMethod.java
Patch:
@@ -274,7 +274,7 @@ private List<MappingEntry> enumToStringMapping(Method method, Type sourceType )
                 return mappings;
             }
 
-            // Start to fill the mappings with the defined valuemappings
+            // Start to fill the mappings with the defined valueMappings
             for ( ValueMappingOptions valueMapping : valueMappings.regularValueMappings ) {
                 mappings.add( new MappingEntry( valueMapping.getSource(), valueMapping.getTarget() ) );
                 unmappedSourceConstants.remove( valueMapping.getSource() );
@@ -305,7 +305,7 @@ private List<MappingEntry> stringToEnumMapping(Method method, Type targetType )
             }
             Set<String> mappedSources = new LinkedHashSet<>();
 
-            // Start to fill the mappings with the defined valuemappings
+            // Start to fill the mappings with the defined value mappings
             for ( ValueMappingOptions valueMapping : valueMappings.regularValueMappings ) {
                 mappedSources.add( valueMapping.getSource() );
                 mappings.add( new MappingEntry( valueMapping.getSource(), valueMapping.getTarget() ) );

File: processor/src/main/java/org/mapstruct/ap/spi/AccessorNamingStrategy.java
Patch:
@@ -68,7 +68,7 @@ default void init(MapStructProcessingEnvironment processingEnvironment) {
      *
      * @return getter name for collection properties
      *
-     * @deprecated MapStuct will not call this method anymore. Use {@link #getMethodType(ExecutableElement)} to
+     * @deprecated MapStruct will not call this method anymore. Use {@link #getMethodType(ExecutableElement)} to
      * determine the {@link MethodType}. When collections somehow need to be treated special, it should be done in
      * {@link #getMethodType(ExecutableElement) } as well. In the future, this method will be removed.
      */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/SourceMethod.java
Patch:
@@ -186,7 +186,7 @@ public Builder setPrototypeMethods(List<SourceMethod> prototypeMethods) {
             return this;
         }
 
-        public Builder setDefininingType(Type definingType) {
+        public Builder setDefiningType(Type definingType) {
             this.definingType = definingType;
             return this;
         }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MethodRetrievalProcessor.java
Patch:
@@ -389,7 +389,7 @@ private SourceMethod getReferencedMethod(TypeElement usedMapper, ExecutableType
 
         return new SourceMethod.Builder()
             .setDeclaringMapper( usedMapper.equals( mapperToImplement ) ? null : usedMapperAsType )
-            .setDefininingType( definingType )
+            .setDefiningType( definingType )
             .setExecutable( method )
             .setParameters( parameters )
             .setReturnType( returnType )

File: processor/src/main/java/org/mapstruct/ap/internal/model/AbstractBaseBuilder.java
Patch:
@@ -41,7 +41,7 @@ public B method(Method sourceMethod) {
     }
 
     /**
-     * Checks if MapStruct is allowed to generate an automatic sub-mapping between {@code sourceType} and @{code
+     * Checks if MapStruct is allowed to generate an automatic sub-mapping between {@code sourceType} and {@code
      * targetType}.
      * This will evaluate to {@code true}, when:
      * <li>
@@ -66,7 +66,7 @@ private boolean isDisableSubMappingMethodsGeneration() {
 
     /**
      * Creates a forged assignment from the provided {@code sourceRHS} and {@code forgedMethod}. If a mapping method
-     * for the {@code forgedMethod} already exists, then this method used for the assignment.
+     * for the {@code forgedMethod} already exists, this method will be used for the assignment.
      *
      * @param sourceRHS that needs to be used for the assignment
      * @param forgedMethod the forged method for which we want to create an {@link Assignment}

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/SourceRhsSelector.java
Patch:
@@ -12,7 +12,7 @@
 import org.mapstruct.ap.internal.model.source.Method;
 
 /**
- * Selector that tries to resolve an ambiquity between methods that contain source parameters and
+ * Selector that tries to resolve an ambiguity between methods that contain source parameters and
  * {@link org.mapstruct.ap.internal.model.common.SourceRHS SourceRHS} type parameters.
  * @author Filip Hrisafov
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Type.java
Patch:
@@ -50,7 +50,7 @@
 import org.mapstruct.ap.internal.util.TypeUtils;
 import org.mapstruct.ap.internal.util.accessor.Accessor;
 import org.mapstruct.ap.internal.util.accessor.AccessorType;
-import org.mapstruct.ap.internal.util.accessor.FieldElementAccessor;
+import org.mapstruct.ap.internal.util.accessor.ElementAccessor;
 import org.mapstruct.ap.internal.util.accessor.MapValueAccessor;
 import org.mapstruct.ap.internal.util.accessor.PresenceCheckAccessor;
 import org.mapstruct.ap.internal.util.accessor.ReadAccessor;
@@ -1047,7 +1047,7 @@ private List<Accessor> getAlternativeTargetAccessors() {
             List<Accessor> setterMethods = getSetters();
             List<Accessor> readAccessors = new ArrayList<>( getPropertyReadAccessors().values() );
             // All the fields are also alternative accessors
-            readAccessors.addAll( filters.fieldsIn( getAllFields(), FieldElementAccessor::new ) );
+            readAccessors.addAll( filters.fieldsIn( getAllFields(), ElementAccessor::new ) );
 
             // there could be a read accessor (field or  method) for a list/map that is not present as setter.
             // an accessor could substitute the setter in that case and act as setter.

File: processor/src/test/java/org/mapstruct/ap/internal/util/NativeTypesTest.java
Patch:
@@ -122,7 +122,7 @@ public void testIntegerLiteralFromJLS() {
             .isNotNull();
 
         // most negative int: dec / octal / int / binary
-        // NOTE parseInt should be changed to parseUnsignedInt in Java, than the - sign can disssapear (java8)
+        // NOTE parseInt should be changed to parseUnsignedInt in Java, than the - sign can dissapear (java8)
         // and the function will be true to what the compiler shows.
         assertThat( getLiteral( int.class.getCanonicalName(), "-2147483648" ) ).isNotNull();
         assertThat( getLiteral( int.class.getCanonicalName(), "0x8000_0000" ) ).isNotNull();
@@ -177,7 +177,7 @@ public void testIntegerLiteralFromJLS() {
      * The following example shows other ways you can use the underscore in numeric literals:
      */
     @Test
-    public void testFloatingPoingLiteralFromJLS() {
+    public void testFloatingPointLiteralFromJLS() {
 
         // The largest positive finite literal of type float is 3.4028235e38f.
         assertThat( getLiteral( float.class.getCanonicalName(), "3.4028235e38f" ) ).isNotNull();

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/AccessibilityTest.java
Patch:
@@ -41,7 +41,7 @@ public void testGeneratedModifiersFromInterfaceAreCorrect() throws Exception {
 
         assertTrue( isDefault( defaultFromIfc.getModifiers() ) );
 
-        assertTrue( isPublic( modifiersFor( defaultFromIfc, "implicitlyPublicSoureToTarget" ) ) );
+        assertTrue( isPublic( modifiersFor( defaultFromIfc, "implicitlyPublicSourceToTarget" ) ) );
     }
 
     private static Class<?> loadForMapper(Class<?> mapper) throws ClassNotFoundException {

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/DefaultSourceTargetMapperIfc.java
Patch:
@@ -12,5 +12,5 @@
  */
 @Mapper
 interface DefaultSourceTargetMapperIfc {
-    Target implicitlyPublicSoureToTarget(Source source);
+    Target implicitlyPublicSourceToTarget(Source source);
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -299,7 +299,7 @@ else if ( !method.isUpdateMethod() ) {
             boolean applyImplicitMappings =
                 shouldHandledDefinedMappings && !mappingReferences.isRestrictToDefinedMappings();
             if ( applyImplicitMappings ) {
-                applyImplicitMappings = beanMapping == null || !beanMapping.isignoreByDefault();
+                applyImplicitMappings = beanMapping == null || !beanMapping.isIgnoredByDefault();
             }
             if ( applyImplicitMappings ) {
 
@@ -1699,7 +1699,7 @@ private ReportingPolicyGem getUnmappedTargetPolicy() {
                 return ReportingPolicyGem.IGNORE;
             }
             // If we have ignoreByDefault = true, unprocessed target properties are not an issue.
-            if ( method.getOptions().getBeanMapping().isignoreByDefault() ) {
+            if ( method.getOptions().getBeanMapping().isIgnoredByDefault() ) {
                 return ReportingPolicyGem.IGNORE;
             }
             if ( method.getOptions().getBeanMapping() != null ) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/BeanMappingOptions.java
Patch:
@@ -223,7 +223,7 @@ public SelectionParameters getSelectionParameters() {
         return selectionParameters;
     }
 
-    public boolean isignoreByDefault() {
+    public boolean isIgnoredByDefault() {
         return Optional.ofNullable( beanMapping ).map( BeanMappingGem::ignoreByDefault )
             .map( GemValue::get )
             .orElse( false );

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -565,7 +565,7 @@ else if ( applicableReversePrototypeMethods.size() > 1 ) {
         }
 
         // @BeanMapping( ignoreByDefault = true )
-        if ( mappingOptions.getBeanMapping() != null && mappingOptions.getBeanMapping().isignoreByDefault() ) {
+        if ( mappingOptions.getBeanMapping() != null && mappingOptions.getBeanMapping().isIgnoredByDefault() ) {
             mappingOptions.applyIgnoreAll( method, typeFactory, mappingContext.getMessager() );
         }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -295,7 +295,9 @@ else if ( !method.isUpdateMethod() ) {
                 }
             }
 
-            boolean applyImplicitMappings = !mappingReferences.isRestrictToDefinedMappings();
+            // If defined mappings should not be handled then we should not apply implicit mappings
+            boolean applyImplicitMappings =
+                shouldHandledDefinedMappings && !mappingReferences.isRestrictToDefinedMappings();
             if ( applyImplicitMappings ) {
                 applyImplicitMappings = beanMapping == null || !beanMapping.isignoreByDefault();
             }

File: processor/src/main/java/org/mapstruct/ap/internal/model/ContainerMappingMethod.java
Patch:
@@ -46,7 +46,8 @@ public abstract class ContainerMappingMethod extends NormalTypeMappingMethod {
             afterMappingReferences );
         this.elementAssignment = parameterAssignment;
         this.loopVariableName = loopVariableName;
-        this.selectionParameters = selectionParameters;
+        this.selectionParameters = selectionParameters != null ? selectionParameters : SelectionParameters.empty();
+
         this.index1Name = Strings.getSafeVariableName( "i", existingVariables );
         this.index2Name = Strings.getSafeVariableName( "j", existingVariables );
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/BeanMappingOptions.java
Patch:
@@ -58,7 +58,7 @@ public static BeanMappingOptions forInheritance(BeanMappingOptions beanMapping,
     public static BeanMappingOptions forForgedMethods(BeanMappingOptions beanMapping) {
         BeanMappingOptions options = new BeanMappingOptions(
             beanMapping.selectionParameters != null ?
-                SelectionParameters.withoutResultType( beanMapping.selectionParameters ) : null,
+                SelectionParameters.withoutResultType( beanMapping.selectionParameters ) : SelectionParameters.empty(),
             Collections.emptyList(),
             beanMapping.beanMapping,
             beanMapping
@@ -78,7 +78,7 @@ public static BeanMappingOptions forSubclassForgedMethods(BeanMappingOptions bea
     }
 
     public static BeanMappingOptions empty(DelegatingOptions delegatingOptions) {
-        return new BeanMappingOptions( null, Collections.emptyList(), null, delegatingOptions );
+        return new BeanMappingOptions( SelectionParameters.empty(), Collections.emptyList(), null, delegatingOptions );
     }
 
     public static BeanMappingOptions getInstanceOn(BeanMappingGem beanMapping, MapperOptions mapperOptions,

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MapMappingOptions.java
Patch:
@@ -38,9 +38,9 @@ public static MapMappingOptions fromGem(MapMappingGem mapMapping, MapperOptions
         if ( mapMapping == null || !isConsistent( mapMapping, method, messager ) ) {
             MapMappingOptions options = new MapMappingOptions(
                 null,
+                SelectionParameters.empty(),
                 null,
-                null,
-                null,
+                SelectionParameters.empty(),
                 null,
                 mapperOptions
             );

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MappingOptions.java
Patch:
@@ -182,7 +182,7 @@ public static MappingOptions forIgnore(String targetName) {
             null,
             true,
             null,
-            null,
+            SelectionParameters.empty(),
             Collections.emptySet(),
             null,
             null,

File: processor/src/main/java/org/mapstruct/ap/spi/EnumMappingStrategy.java
Patch:
@@ -17,7 +17,7 @@
  *
  * @since 1.4
  */
-@Experimental("This SPI can have it's signature changed in subsequent releases")
+@Experimental("This SPI can have its signature changed in subsequent releases")
 public interface EnumMappingStrategy {
 
     /**

File: processor/src/main/java/org/mapstruct/ap/spi/EnumTransformationStrategy.java
Patch:
@@ -13,7 +13,7 @@
  * @author Filip Hrisafov
  * @since 1.4
  */
-@Experimental("This SPI can have it's signature changed in subsequent releases")
+@Experimental("This SPI can have its signature changed in subsequent releases")
 public interface EnumTransformationStrategy {
 
     /**

File: processor/src/test/java/org/mapstruct/ap/test/ignorebydefaultsource/ErroneousSourceTargetMapperWithIgnoreByDefault.java
Patch:
@@ -14,8 +14,9 @@
 @Mapper(
     unmappedTargetPolicy = ReportingPolicy.IGNORE,
     unmappedSourcePolicy = ReportingPolicy.ERROR)
-public interface SourceTargetMapper {
-    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+public interface ErroneousSourceTargetMapperWithIgnoreByDefault {
+    ErroneousSourceTargetMapperWithIgnoreByDefault INSTANCE = Mappers.getMapper(
+        ErroneousSourceTargetMapperWithIgnoreByDefault.class );
 
     @Mapping(source = "one", target = "one")
     @BeanMapping(ignoreByDefault = true)

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/CreateOrUpdateSelector.java
Patch:
@@ -32,6 +32,7 @@ public <T extends Method> List<SelectedMethod<T>> getMatchingMethods(List<Select
                                                                          SelectionContext context) {
         SelectionCriteria criteria = context.getSelectionCriteria();
         if ( criteria.isLifecycleCallbackRequired() || criteria.isObjectFactoryRequired()
+            || criteria.isSourceParameterCheckRequired()
             || criteria.isPresenceCheckRequired() ) {
             return methods;
         }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -470,7 +470,7 @@ private ConversionAssignment resolveViaConversion(Type sourceType, Type targetTy
         }
 
         private boolean isCandidateForMapping(Method methodCandidate) {
-            if ( methodCandidate.isPresenceCheck() ) {
+            if ( methodCandidate.getConditionOptions().isAnyStrategyApplicable() ) {
                 return false;
             }
             return isCreateMethodForMapping( methodCandidate ) || isUpdateMethodForMapping( methodCandidate );

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_3485/Issue3485Test.java
Patch:
@@ -15,7 +15,7 @@
 /**
  * @author hduelme
  */
-@IssueKey("3463")
+@IssueKey("3485")
 public class Issue3485Test {
 
     @ProcessorTest

File: processor/src/main/java/org/mapstruct/ap/internal/model/Javadoc.java
Patch:
@@ -31,7 +31,7 @@ public Builder value(String value) {
             return this;
         }
 
-        public Builder authors(List authors) {
+        public Builder authors(List<String> authors) {
             this.authors = authors;
             return this;
         }

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -84,6 +84,7 @@ public enum Message {
     PROPERTYMAPPING_CANNOT_DETERMINE_SOURCE_PROPERTY_FROM_TARGET("The type of parameter \"%s\" has no property named \"%s\". Please define the source property explicitly."),
     PROPERTYMAPPING_CANNOT_DETERMINE_SOURCE_PARAMETER_FROM_TARGET("No property named \"%s\" exists in source parameter(s). Please define the source explicitly."),
     PROPERTYMAPPING_NO_SUITABLE_COLLECTION_OR_MAP_CONSTRUCTOR( "%s does not have an accessible copy or no-args constructor." ),
+    PROPERTYMAPPING_EXPRESSION_AND_CONDITION_QUALIFIED_BY_NAME_BOTH_DEFINED( "Expression and condition qualified by name are both defined in @Mapping, either define an expression or a condition qualified by name." ),
 
     CONVERSION_LOSSY_WARNING( "%s has a possibly lossy conversion from %s to %s.", Diagnostic.Kind.WARNING ),
     CONVERSION_LOSSY_ERROR( "Can't map %s. It has a possibly lossy conversion from %s to %s." ),

File: core/src/main/java/org/mapstruct/SubclassMapping.java
Patch:
@@ -49,7 +49,7 @@
  * }
  * </code></pre>
  * <strong>Example 2:</strong> For parents that can be created. (e.g. normal classes or interfaces with
- * &#64;Mappper( uses = ObjectFactory.class ) )
+ * &#64;Mapper( uses = ObjectFactory.class ) )
  * <pre><code class='java'>
  * // generates
  * &#64;Override

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -825,7 +825,7 @@ private MethodMethod<T1, T2> getBestMatch(Type sourceType, Type targetType, Best
 
             for ( T2 yCandidate : yMethods ) {
                 Type ySourceType = yCandidate.getMappingSourceType();
-                ySourceType = ySourceType.resolveParameterToType( targetType, yCandidate.getResultType() ).getMatch();
+                ySourceType = ySourceType.resolveGenericTypeParameters( targetType, yCandidate.getResultType() );
                 Type yTargetType = yCandidate.getResultType();
                 if ( ySourceType == null
                     || !yTargetType.isRawAssignableTo( targetType )

File: processor/src/main/java/org/mapstruct/ap/internal/model/MappingMethod.java
Patch:
@@ -186,8 +186,8 @@ public String toString() {
         return returnType + " " + getName() + "(" + join( parameters, ", " ) + ")";
     }
 
-    private List<LifecycleCallbackMethodReference> filterMappingTarget(List<LifecycleCallbackMethodReference> methods,
-                                                                       boolean mustHaveMappingTargetParameter) {
+    protected static List<LifecycleCallbackMethodReference> filterMappingTarget(
+        List<LifecycleCallbackMethodReference> methods, boolean mustHaveMappingTargetParameter) {
         if ( methods == null ) {
             return Collections.emptyList();
         }

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -176,6 +176,7 @@ public enum Message {
     RETRIEVAL_MAPPER_USES_CYCLE( "The mapper %s is referenced itself in Mapper#uses.", Diagnostic.Kind.WARNING ),
     RETRIEVAL_AFTER_METHOD_NOT_IMPLEMENTED( "@AfterMapping can only be applied to an implemented method." ),
     RETRIEVAL_BEFORE_METHOD_NOT_IMPLEMENTED( "@BeforeMapping can only be applied to an implemented method." ),
+    RETRIEVAL_TARGET_PROPERTY_NAME_WRONG_TYPE( "@TargetPropertyName can only by applied to a String parameter." ),
 
     INHERITINVERSECONFIGURATION_DUPLICATES( "Several matching inverse methods exist: %s(). Specify a name explicitly." ),
     INHERITINVERSECONFIGURATION_INVALID_NAME( "None of the candidates %s() matches given name: \"%s\"." ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MappingOptions.java
Patch:
@@ -254,6 +254,9 @@ else if ( gem.nullValuePropertyMappingStrategy().hasValue()
             && gem.ignore().hasValue() && gem.ignore().getValue() ) {
             message = Message.PROPERTYMAPPING_IGNORE_AND_NVPMS;
         }
+        else if ( ".".equals( gem.target().get() ) && gem.ignore().hasValue() && gem.ignore().getValue() ) {
+            message = Message.PROPERTYMAPPING_TARGET_THIS_AND_IGNORE;
+        }
 
         if ( message == null ) {
             return true;

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -68,6 +68,7 @@ public enum Message {
     PROPERTYMAPPING_CONSTANT_VALUE_AND_NVPMS( "Constant and nullValuePropertyMappingStrategy are both defined in @Mapping, either define a constant or an nullValuePropertyMappingStrategy." ),
     PROPERTYMAPPING_DEFAULT_EXPERSSION_AND_NVPMS( "DefaultExpression and nullValuePropertyMappingStrategy are both defined in @Mapping, either define a defaultExpression or an nullValuePropertyMappingStrategy." ),
     PROPERTYMAPPING_IGNORE_AND_NVPMS( "Ignore and nullValuePropertyMappingStrategy are both defined in @Mapping, either define ignore or an nullValuePropertyMappingStrategy." ),
+    PROPERTYMAPPING_TARGET_THIS_AND_IGNORE( "Using @Mapping( target = \".\", ignore = true ) is not allowed. You need to use @BeanMapping( ignoreByDefault = true ) if you would like to ignore all non explicitly mapped target properties." ),
     PROPERTYMAPPING_EXPRESSION_AND_QUALIFIER_BOTH_DEFINED("Expression and a qualifier both defined in @Mapping, either define an expression or a qualifier."),
     PROPERTYMAPPING_INVALID_EXPRESSION( "Value for expression must be given in the form \"java(<EXPRESSION>)\"." ),
     PROPERTYMAPPING_INVALID_DEFAULT_EXPRESSION( "Value for default expression must be given in the form \"java(<EXPRESSION>)\"." ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MethodMatcher.java
Patch:
@@ -325,8 +325,7 @@ else if ( resolved.getParameter().isWildCardBoundByTypeVar()
          */
         private boolean candidatesWithinBounds(Map<Type, TypeVarCandidate> methodParCandidates ) {
             for ( Map.Entry<Type, TypeVarCandidate> entry : methodParCandidates.entrySet() ) {
-                Type bound = entry.getKey().getTypeBound();
-                if ( bound != null ) {
+                for ( Type bound : entry.getKey().getTypeBounds() ) {
                     for ( Type.ResolvedPair pair : entry.getValue().pairs ) {
                         if ( entry.getKey().hasUpperBound() ) {
                             if ( !pair.getMatch().asRawType().isAssignableTo( bound.asRawType() ) ) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/MethodSelectors.java
Patch:
@@ -37,7 +37,9 @@ public MethodSelectors(TypeUtils typeUtils, ElementUtils elementUtils, TypeFacto
             new InheritanceSelector(),
             new CreateOrUpdateSelector(),
             new SourceRhsSelector(),
-            new FactoryParameterSelector() );
+            new FactoryParameterSelector(),
+            new MostSpecificResultTypeSelector()
+        );
     }
 
     /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/LifecycleMethodResolver.java
Patch:
@@ -141,7 +141,7 @@ private static List<LifecycleCallbackMethodReference> collectLifecycleCallbackMe
             callbackMethods,
             Collections.emptyList(),
             targetType,
-            method.getReturnType(),
+            method.getResultType(),
             SelectionCriteria.forLifecycleMethods( selectionParameters ) );
 
         return toLifecycleCallbackMethodRefs(

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -196,7 +196,7 @@ private ResolvingAttempt(List<Method> sourceModel, Method mappingMethod, ForgedM
 
             this.mappingMethod = mappingMethod;
             this.description = description;
-            this.methods = filterPossibleCandidateMethods( sourceModel );
+            this.methods = filterPossibleCandidateMethods( sourceModel, mappingMethod );
             this.formattingParameters =
                 formattingParameters == null ? FormattingParameters.EMPTY : formattingParameters;
             this.sourceRHS = sourceRHS;
@@ -210,10 +210,10 @@ private ResolvingAttempt(List<Method> sourceModel, Method mappingMethod, ForgedM
         }
         // CHECKSTYLE:ON
 
-        private <T extends Method> List<T> filterPossibleCandidateMethods(List<T> candidateMethods) {
+        private <T extends Method> List<T> filterPossibleCandidateMethods(List<T> candidateMethods, T mappingMethod) {
             List<T> result = new ArrayList<>( candidateMethods.size() );
             for ( T candidate : candidateMethods ) {
-                if ( isCandidateForMapping( candidate ) ) {
+                if ( isCandidateForMapping( candidate ) && !candidate.equals( mappingMethod )) {
                     result.add( candidate );
                 }
             }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MethodMatcher.java
Patch:
@@ -374,7 +374,9 @@ else if ( typeFromCandidateMethodTypeParameter.isWildCardBoundByTypeVar()
                             // something went wrong
                             return null;
                         }
-                        typeArgs[i] = matchingType.getTypeMirror();
+                        // Use the boxed equivalent for the type arguments,
+                        // because a primitive type cannot be a type argument
+                        typeArgs[i] = matchingType.getBoxedEquivalent().getTypeMirror();
                     }
                     else {
                         // it is not a type var (e.g. Map<String, T> ), String is not a type var

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -307,7 +307,7 @@ private SortedSet<Type> getExtraImports(TypeElement element,  MapperOptions mapp
 
 
         for ( TypeMirror extraImport : mapperOptions.imports() ) {
-            Type type = typeFactory.getType( extraImport );
+            Type type = typeFactory.getAlwaysImportedType( extraImport );
             extraImports.add( type );
         }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/ForgedMethod.java
Patch:
@@ -196,7 +196,7 @@ private ForgedMethod(String name, Type sourceType, Type returnType, List<Paramet
     public ForgedMethod(String name, ForgedMethod forgedMethod) {
         this.parameters = forgedMethod.parameters;
         this.returnType = forgedMethod.returnType;
-        this.thrownTypes = new ArrayList<>();
+        this.thrownTypes = forgedMethod.thrownTypes;
         this.history = forgedMethod.history;
 
         this.sourceParameters = Parameter.getSourceParameters( parameters );

File: processor/src/test/java/org/mapstruct/ap/test/conversion/date/DateConversionTest.java
Patch:
@@ -17,6 +17,7 @@
 import org.junit.jupiter.api.condition.EnabledOnJre;
 import org.junit.jupiter.api.condition.JRE;
 import org.junitpioneer.jupiter.DefaultLocale;
+import org.junitpioneer.jupiter.ReadsDefaultTimeZone;
 import org.mapstruct.ap.testutil.IssueKey;
 import org.mapstruct.ap.testutil.ProcessorTest;
 import org.mapstruct.ap.testutil.WithClasses;
@@ -35,6 +36,7 @@
 })
 @IssueKey("43")
 @DefaultLocale("de")
+@ReadsDefaultTimeZone
 public class DateConversionTest {
 
     @ProcessorTest

File: processor/src/test/java/org/mapstruct/ap/test/naming/VariableNamingTest.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import org.junitpioneer.jupiter.ReadsDefaultTimeZone;
 import org.mapstruct.ap.testutil.IssueKey;
 import org.mapstruct.ap.testutil.ProcessorTest;
 import org.mapstruct.ap.testutil.WithClasses;
@@ -26,6 +27,7 @@
  */
 @WithClasses({ SourceTargetMapper.class, While.class, Break.class, Source.class })
 @IssueKey("53")
+@ReadsDefaultTimeZone
 public class VariableNamingTest {
 
     @ProcessorTest

File: processor/src/test/java/org/mapstruct/ap/test/nestedmethodcall/NestedMappingMethodInvocationTest.java
Patch:
@@ -17,6 +17,7 @@
 import javax.xml.namespace.QName;
 
 import org.junitpioneer.jupiter.DefaultLocale;
+import org.junitpioneer.jupiter.ReadsDefaultTimeZone;
 import org.mapstruct.ap.testutil.IssueKey;
 import org.mapstruct.ap.testutil.ProcessorTest;
 import org.mapstruct.ap.testutil.WithClasses;
@@ -31,6 +32,7 @@
  */
 @IssueKey("134")
 @DefaultLocale("de")
+@ReadsDefaultTimeZone
 public class NestedMappingMethodInvocationTest {
 
     public static final QName QNAME = new QName( "dont-care" );

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -59,7 +59,9 @@ public enum Message {
     PROPERTYMAPPING_EXPRESSION_AND_DEFAULT_VALUE_BOTH_DEFINED( "Expression and default value are both defined in @Mapping, either define a defaultValue or an expression." ),
     PROPERTYMAPPING_CONSTANT_AND_DEFAULT_VALUE_BOTH_DEFINED( "Constant and default value are both defined in @Mapping, either define a defaultValue or a constant." ),
     PROPERTYMAPPING_EXPRESSION_AND_DEFAULT_EXPRESSION_BOTH_DEFINED( "Expression and default expression are both defined in @Mapping, either define an expression or a default expression." ),
+    PROPERTYMAPPING_EXPRESSION_AND_CONDITION_EXPRESSION_BOTH_DEFINED( "Expression and condition expression are both defined in @Mapping, either define an expression or a condition expression." ),
     PROPERTYMAPPING_CONSTANT_AND_DEFAULT_EXPRESSION_BOTH_DEFINED( "Constant and default expression are both defined in @Mapping, either define a constant or a default expression." ),
+    PROPERTYMAPPING_CONSTANT_AND_CONDITION_EXPRESSION_BOTH_DEFINED( "Constant and condition expression are both defined in @Mapping, either define a constant or a condition expression." ),
     PROPERTYMAPPING_DEFAULT_VALUE_AND_DEFAULT_EXPRESSION_BOTH_DEFINED( "Default value and default expression are both defined in @Mapping, either define a default value or a default expression." ),
     PROPERTYMAPPING_DEFAULT_VALUE_AND_NVPMS( "Default value and nullValuePropertyMappingStrategy are both defined in @Mapping, either define a defaultValue or an nullValuePropertyMappingStrategy." ),
     PROPERTYMAPPING_EXPRESSION_VALUE_AND_NVPMS( "Expression and nullValuePropertyMappingStrategy are both defined in @Mapping, either define an expression or an nullValuePropertyMappingStrategy." ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/NestedPropertyMappingMethod.java
Patch:
@@ -103,7 +103,7 @@ public List<SafePropertyEntry> getPropertyEntries() {
     public Set<Type> getImportTypes() {
         Set<Type> types = super.getImportTypes();
         for ( SafePropertyEntry propertyEntry : safePropertyEntries) {
-            types.add( propertyEntry.getType() );
+            types.addAll( propertyEntry.getType().getImportTypes() );
             if ( propertyEntry.getPresenceChecker() != null ) {
                 types.addAll( propertyEntry.getPresenceChecker().getImportTypes() );
             }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/DefaultModelElementProcessorContext.java
Patch:
@@ -13,6 +13,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic.Kind;
 
 import org.mapstruct.ap.internal.model.common.TypeFactory;
@@ -46,14 +47,14 @@ public class DefaultModelElementProcessorContext implements ProcessorContext {
     private final RoundContext roundContext;
 
     public DefaultModelElementProcessorContext(ProcessingEnvironment processingEnvironment, Options options,
-            RoundContext roundContext, Map<String, String> notToBeImported) {
+            RoundContext roundContext, Map<String, String> notToBeImported, TypeElement mapperElement) {
 
         this.processingEnvironment = processingEnvironment;
         this.messager = new DelegatingMessager( processingEnvironment.getMessager(), options.isVerbose() );
         this.accessorNaming = roundContext.getAnnotationProcessorContext().getAccessorNaming();
         this.versionInformation = DefaultVersionInformation.fromProcessingEnvironment( processingEnvironment );
         this.delegatingTypes = TypeUtils.create( processingEnvironment, versionInformation );
-        this.delegatingElements = ElementUtils.create( processingEnvironment, versionInformation );
+        this.delegatingElements = ElementUtils.create( processingEnvironment, versionInformation, mapperElement );
         this.roundContext = roundContext;
         this.typeFactory = new TypeFactory(
             delegatingElements,

File: processor/src/main/java/org/mapstruct/ap/internal/util/EclipseElementUtilsDecorator.java
Patch:
@@ -13,8 +13,8 @@ public class EclipseElementUtilsDecorator extends AbstractElementUtilsDecorator
 
     private final Elements delegate;
 
-    EclipseElementUtilsDecorator(ProcessingEnvironment processingEnv) {
-        super( processingEnv );
+    EclipseElementUtilsDecorator(ProcessingEnvironment processingEnv, TypeElement mapperElement) {
+        super( processingEnv, mapperElement );
         this.delegate = processingEnv.getElementUtils();
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/util/JavacElementUtilsDecorator.java
Patch:
@@ -10,8 +10,8 @@
 
 public class JavacElementUtilsDecorator extends AbstractElementUtilsDecorator {
 
-    JavacElementUtilsDecorator(ProcessingEnvironment processingEnv) {
-        super( processingEnv );
+    JavacElementUtilsDecorator(ProcessingEnvironment processingEnv, TypeElement mapperElement) {
+        super( processingEnv, mapperElement );
     }
 
     @Override

File: core/src/main/java/org/mapstruct/DecoratedWith.java
Patch:
@@ -145,7 +145,7 @@
  * @author Gunnar Morling
  */
 @Target(ElementType.TYPE)
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 public @interface DecoratedWith {
 
     /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/SetterWrapperForCollectionsAndMapsWithNullCheck.java
Patch:
@@ -68,7 +68,7 @@ public boolean isDirectAssignment() {
     }
 
     public boolean isEnumSet() {
-        return "java.util.EnumSet".equals( targetType.getFullyQualifiedName() );
+        return targetType.isEnumSet();
     }
 
 }

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -80,6 +80,7 @@ public enum Message {
     PROPERTYMAPPING_WHITESPACE_TRIMMED( "The property named \"%s\" has whitespaces, using trimmed property \"%s\" instead.", Diagnostic.Kind.WARNING ),
     PROPERTYMAPPING_CANNOT_DETERMINE_SOURCE_PROPERTY_FROM_TARGET("The type of parameter \"%s\" has no property named \"%s\". Please define the source property explicitly."),
     PROPERTYMAPPING_CANNOT_DETERMINE_SOURCE_PARAMETER_FROM_TARGET("No property named \"%s\" exists in source parameter(s). Please define the source explicitly."),
+    PROPERTYMAPPING_NO_SUITABLE_COLLECTION_OR_MAP_CONSTRUCTOR( "%s does not have an accessible copy or no-args constructor." ),
 
     CONVERSION_LOSSY_WARNING( "%s has a possibly lossy conversion from %s to %s.", Diagnostic.Kind.WARNING ),
     CONVERSION_LOSSY_ERROR( "Can't map %s. It has a possibly lossy conversion from %s to %s." ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/NestedTargetPropertyMappingHolder.java
Patch:
@@ -21,6 +21,7 @@
 import org.mapstruct.ap.internal.model.beanmapping.SourceReference;
 import org.mapstruct.ap.internal.model.beanmapping.TargetReference;
 import org.mapstruct.ap.internal.model.common.Parameter;
+import org.mapstruct.ap.internal.util.accessor.ReadAccessor;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.MappingOptions;
 import org.mapstruct.ap.internal.model.source.Method;
@@ -642,7 +643,7 @@ private PropertyMapping createPropertyMappingForNestedTarget(MappingReferences m
                                                                      boolean forceUpdateMethod) {
 
             Accessor targetWriteAccessor = targetPropertiesWriteAccessors.get( targetPropertyName );
-            Accessor targetReadAccessor = targetType.getReadAccessor( targetPropertyName );
+            ReadAccessor targetReadAccessor = targetType.getReadAccessor( targetPropertyName );
             if ( targetWriteAccessor == null ) {
                 Set<String> readAccessors = targetType.getPropertyReadAccessors().keySet();
                 String mostSimilarProperty = Strings.getMostSimilarWord( targetPropertyName, readAccessors );

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -96,7 +96,8 @@ public class MapperCreationProcessor implements ModelElementProcessor<List<Sourc
     public Mapper process(ProcessorContext context, TypeElement mapperTypeElement, List<SourceMethod> sourceModel) {
         this.elementUtils = context.getElementUtils();
         this.typeUtils = context.getTypeUtils();
-        this.messager = context.getMessager();
+        this.messager =
+            new MapperAnnotatedFormattingMessenger( context.getMessager(), mapperTypeElement, context.getTypeUtils() );
         this.options = context.getOptions();
         this.versionInformation = context.getVersionInformation();
         this.typeFactory = context.getTypeFactory();

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -20,6 +20,8 @@ public enum Message {
     // CHECKSTYLE:OFF
     PROCESSING_NOTE( "processing: %s.", Diagnostic.Kind.NOTE ),
     CONFIG_NOTE( "applying mapper configuration: %s.", Diagnostic.Kind.NOTE ),
+    MESSAGE_MOVED_TO_MAPPER_ERROR( "%s Occured at '%s' in '%s'." ),
+    MESSAGE_MOVED_TO_MAPPER_WARNING( "%s Occured at '%s' in '%s'.", Diagnostic.Kind.WARNING ),
 
     BEANMAPPING_CREATE_NOTE( "creating bean mapping method implementation for %s.", Diagnostic.Kind.NOTE ),
     BEANMAPPING_NO_ELEMENTS( "'nullValueMappingStrategy', 'nullValuePropertyMappingStrategy', 'resultType' and 'qualifiedBy' are undefined in @BeanMapping, define at least one of them." ),

File: core/src/main/java/org/mapstruct/Mapping.java
Patch:
@@ -54,7 +54,7 @@
  * <p><strong>Example 2:</strong> Mapping properties with different names</p>
  * <pre><code class='java'>
  * // We need map Human.companyName to HumanDto.company
- * // we can use &#64;Mapping with parameters {@link #source()} and {@link #source()}
+ * // we can use &#64;Mapping with parameters {@link #source()} and {@link #target()}
  * &#64;Mapper
  * public interface HumanMapper {
  *    &#64;Mapping(source="companyName", target="company")
@@ -476,6 +476,4 @@ NullValuePropertyMappingStrategy nullValuePropertyMappingStrategy()
      */
     Class<? extends Annotation> mappingControl() default MappingControl.class;
 
-
-
 }

File: core/src/main/java/org/mapstruct/BeanMapping.java
Patch:
@@ -118,7 +118,7 @@ NullValuePropertyMappingStrategy nullValuePropertyMappingStrategy()
 
     /**
      * Default ignore all mappings. All mappings have to be defined manually. No automatic mapping will take place. No
-     * warning will be issued on missing target properties.
+     * warning will be issued on missing source or target properties.
      *
      * @return The ignore strategy (default false).
      *

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -125,7 +125,7 @@ public enum Message {
     GENERAL_AMBIGUOUS_MAPPING_METHOD( "Ambiguous mapping methods found for mapping %s to %s: %s. See " + FAQ_AMBIGUOUS_URL + " for more info." ),
     GENERAL_AMBIGUOUS_FACTORY_METHOD( "Ambiguous factory methods found for creating %s: %s. See " + FAQ_AMBIGUOUS_URL + " for more info." ),
     GENERAL_AMBIGUOUS_PRESENCE_CHECK_METHOD( "Ambiguous presence check methods found for checking %s: %s. See " + FAQ_AMBIGUOUS_URL + " for more info." ),
-    GENERAL_AMBIGUOUS_CONSTRUCTORS( "Ambiguous constructors found for creating %s. Either declare parameterless constructor or annotate the default constructor with an annotation named @Default." ),
+    GENERAL_AMBIGUOUS_CONSTRUCTORS( "Ambiguous constructors found for creating %s: %s. Either declare parameterless constructor or annotate the default constructor with an annotation named @Default." ),
     GENERAL_CONSTRUCTOR_PROPERTIES_NOT_MATCHING_PARAMETERS( "Incorrect @ConstructorProperties for %s. The size of the @ConstructorProperties does not match the number of constructor parameters" ),
     GENERAL_UNSUPPORTED_DATE_FORMAT_CHECK( "No dateFormat check is supported for types %s, %s" ),
     GENERAL_VALID_DATE( "Given date format \"%s\" is valid.", Diagnostic.Kind.NOTE ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -1170,6 +1170,7 @@ else if ( mapping.getJavaExpression() != null ) {
                             .build();
                         handledTargets.add( targetPropertyName );
                         unprocessedSourceParameters.remove( sourceRef.getParameter() );
+                        unprocessedSourceProperties.remove( sourceRef.getShallowestPropertyName() );
                     }
                     else {
                         errorOccured = true;

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/ReverseConversion.java
Patch:
@@ -5,12 +5,12 @@
  */
 package org.mapstruct.ap.internal.conversion;
 
-import java.util.Collections;
 import java.util.List;
+
+import org.mapstruct.ap.internal.model.HelperMethod;
 import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.FieldReference;
-import org.mapstruct.ap.internal.model.HelperMethod;
 
 /**
  *  * A {@link ConversionProvider} which creates the inversed conversions for a
@@ -42,7 +42,7 @@ public Assignment from(ConversionContext conversionContext) {
 
     @Override
     public List<HelperMethod> getRequiredHelperMethods(ConversionContext conversionContext) {
-        return Collections.emptyList();
+        return conversionProvider.getRequiredHelperMethods( conversionContext );
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/DateFormatValidatorFactory.java
Patch:
@@ -75,7 +75,7 @@ public DateFormatValidationResult validate(String dateFormat) {
 
     private static boolean isXmlGregorianCalendarSupposedToBeMapped(Type sourceType, Type targetType) {
         return typesEqualsOneOf(
-                        sourceType, targetType, XmlConstants.JAVAX_XML_DATATYPE_XMLGREGORIAN_CALENDAR );
+                        sourceType, targetType, XmlConstants.JAVAX_XML_XML_GREGORIAN_CALENDAR );
     }
 
     private static boolean isJodaDateTimeSupposed(Type sourceType, Type targetType) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/BuiltInMappingMethods.java
Patch:
@@ -59,12 +59,11 @@ public BuiltInMappingMethods(TypeFactory typeFactory) {
     }
 
     private static boolean isJaxbAvailable(TypeFactory typeFactory) {
-        return JaxbConstants.isJaxbElementPresent() && typeFactory.isTypeAvailable( JaxbConstants.JAXB_ELEMENT_FQN );
+        return typeFactory.isTypeAvailable( JaxbConstants.JAXB_ELEMENT_FQN );
     }
 
     private static boolean isXmlGregorianCalendarAvailable(TypeFactory typeFactory) {
-        return XmlConstants.isXmlGregorianCalendarPresent() &&
-            typeFactory.isTypeAvailable( XmlConstants.JAVAX_XML_DATATYPE_XMLGREGORIAN_CALENDAR );
+        return typeFactory.isTypeAvailable( XmlConstants.JAVAX_XML_XML_GREGORIAN_CALENDAR );
     }
 
     private static boolean isJodaTimeAvailable(TypeFactory typeFactory) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/JaxbElemToValue.java
Patch:
@@ -9,11 +9,10 @@
 
 import java.util.Set;
 
-import javax.xml.bind.JAXBElement;
-
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
+import org.mapstruct.ap.internal.util.JaxbConstants;
 
 /**
  * @author Sjaak Derksen
@@ -25,7 +24,7 @@ public class JaxbElemToValue extends BuiltInMethod {
     private final Set<Type> importTypes;
 
     public JaxbElemToValue(TypeFactory typeFactory) {
-        Type type = typeFactory.getType(  JAXBElement.class  );
+        Type type = typeFactory.getType( JaxbConstants.JAXB_ELEMENT_FQN );
         this.parameter = new Parameter( "element", type );
         this.returnType = type.getTypeParameters().get( 0 );
         this.importTypes = asSet( parameter.getType() );

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/JodaLocalDateTimeToXmlGregorianCalendar.java
Patch:
@@ -6,12 +6,12 @@
 package org.mapstruct.ap.internal.model.source.builtin;
 
 import java.util.Set;
-import javax.xml.datatype.DatatypeConstants;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -28,7 +28,7 @@ public JodaLocalDateTimeToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "dt", typeFactory.getType( JodaTimeConstants.LOCAL_DATE_TIME_FQN ) );
         this.importTypes = asSet(
             parameter.getType(),
-            typeFactory.getType( DatatypeConstants.class )
+            typeFactory.getType( XmlConstants.JAVAX_XML_DATATYPE_CONSTANTS )
         );
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/JodaLocalDateToXmlGregorianCalendar.java
Patch:
@@ -6,12 +6,12 @@
 package org.mapstruct.ap.internal.model.source.builtin;
 
 import java.util.Set;
-import javax.xml.datatype.DatatypeConstants;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -28,7 +28,7 @@ public JodaLocalDateToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "dt", typeFactory.getType( JodaTimeConstants.LOCAL_DATE_FQN ) );
         this.importTypes = asSet(
             parameter.getType(),
-            typeFactory.getType( DatatypeConstants.class )
+            typeFactory.getType( XmlConstants.JAVAX_XML_DATATYPE_CONSTANTS )
         );
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/JodaLocalTimeToXmlGregorianCalendar.java
Patch:
@@ -6,12 +6,12 @@
 package org.mapstruct.ap.internal.model.source.builtin;
 
 import java.util.Set;
-import javax.xml.datatype.DatatypeConstants;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -28,7 +28,7 @@ public JodaLocalTimeToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "dt", typeFactory.getType( JodaTimeConstants.LOCAL_TIME_FQN ) );
         this.importTypes = asSet(
             parameter.getType(),
-            typeFactory.getType( DatatypeConstants.class )
+            typeFactory.getType( XmlConstants.JAVAX_XML_DATATYPE_CONSTANTS )
         );
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/LocalDateTimeToXmlGregorianCalendar.java
Patch:
@@ -9,11 +9,10 @@
 import java.time.temporal.ChronoField;
 import java.util.Set;
 
-import javax.xml.datatype.DatatypeConstants;
-
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -30,7 +29,7 @@ public LocalDateTimeToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "localDateTime", typeFactory.getType( LocalDateTime.class ) );
         this.importTypes = asSet(
             parameter.getType(),
-            typeFactory.getType( DatatypeConstants.class ),
+            typeFactory.getType( XmlConstants.JAVAX_XML_DATATYPE_CONSTANTS ),
             typeFactory.getType( ChronoField.class )
         );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/LocalDateToXmlGregorianCalendar.java
Patch:
@@ -7,11 +7,11 @@
 
 import java.time.LocalDate;
 import java.util.Set;
-import javax.xml.datatype.DatatypeConstants;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -28,7 +28,7 @@ public LocalDateToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "localDate", typeFactory.getType( LocalDate.class ) );
         this.importTypes = asSet(
                 parameter.getType(),
-                typeFactory.getType( DatatypeConstants.class )
+                typeFactory.getType( XmlConstants.JAVAX_XML_DATATYPE_CONSTANTS )
         );
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToCalendar.java
Patch:
@@ -7,11 +7,11 @@
 
 import java.util.Calendar;
 import java.util.Set;
-import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -25,7 +25,7 @@ public class XmlGregorianCalendarToCalendar extends BuiltInMethod {
     private final Set<Type> importTypes;
 
     public XmlGregorianCalendarToCalendar(TypeFactory typeFactory) {
-        this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
+        this.parameter = new Parameter( "xcal", typeFactory.getType( XmlConstants.JAVAX_XML_XML_GREGORIAN_CALENDAR ) );
         this.returnType = typeFactory.getType( Calendar.class );
         this.importTypes = asSet( returnType, parameter.getType() );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToDate.java
Patch:
@@ -7,11 +7,11 @@
 
 import java.util.Date;
 import java.util.Set;
-import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -25,7 +25,7 @@ public class XmlGregorianCalendarToDate extends BuiltInMethod {
     private final Set<Type> importTypes;
 
     public XmlGregorianCalendarToDate(TypeFactory typeFactory) {
-        this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
+        this.parameter = new Parameter( "xcal", typeFactory.getType( XmlConstants.JAVAX_XML_XML_GREGORIAN_CALENDAR ) );
         this.returnType = typeFactory.getType( Date.class );
         this.importTypes = asSet( returnType, parameter.getType() );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToLocalDate.java
Patch:
@@ -7,11 +7,11 @@
 
 import java.time.LocalDate;
 import java.util.Set;
-import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -25,7 +25,7 @@ public class XmlGregorianCalendarToLocalDate extends BuiltInMethod {
     private final Set<Type> importTypes;
 
     public XmlGregorianCalendarToLocalDate(TypeFactory typeFactory) {
-        this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
+        this.parameter = new Parameter( "xcal", typeFactory.getType( XmlConstants.JAVAX_XML_XML_GREGORIAN_CALENDAR ) );
         this.returnType = typeFactory.getType( LocalDate.class );
         this.importTypes = asSet( returnType, parameter.getType() );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToString.java
Patch:
@@ -8,12 +8,12 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Set;
-import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -27,7 +27,7 @@ public class XmlGregorianCalendarToString extends BuiltInMethod {
     private final Set<Type> importTypes;
 
     public XmlGregorianCalendarToString(TypeFactory typeFactory) {
-        this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
+        this.parameter = new Parameter( "xcal", typeFactory.getType( XmlConstants.JAVAX_XML_XML_GREGORIAN_CALENDAR ) );
         this.returnType = typeFactory.getType( String.class );
         this.importTypes = asSet(
             parameter.getType(),

File: core/src/main/java/org/mapstruct/Named.java
Patch:
@@ -14,7 +14,7 @@
  * Marks mapping methods with the given qualifier name. Can be used to qualify a single method or all methods of a given
  * type by specifying this annotation on the type level.
  * <p>
- * Will be used to to select the correct mapping methods when mapping a bean property type, element of an iterable type
+ * Will be used to select the correct mapping methods when mapping a bean property type, element of an iterable type
  * or the key/value of a map type.
  * <p>
  * Example (both methods of {@code Titles} are capable to convert a string, but the ambiguity is resolved by applying

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -70,6 +70,7 @@ public enum Message {
     PROPERTYMAPPING_INVALID_PARAMETER_NAME( "Method has no source parameter named \"%s\". Method source parameters are: \"%s\"." ),
     PROPERTYMAPPING_NO_PROPERTY_IN_PARAMETER( "The type of parameter \"%s\" has no property named \"%s\"." ),
     PROPERTYMAPPING_INVALID_PROPERTY_NAME( "No property named \"%s\" exists in source parameter(s). Did you mean \"%s\"?" ),
+    PROPERTYMAPPING_INVALID_PROPERTY_NAME_SOURCE_HAS_NO_PROPERTIES( "No property named \"%s\" exists in source parameter(s). Type \"%s\" has no properties." ),
     PROPERTYMAPPING_NO_PRESENCE_CHECKER_FOR_SOURCE_TYPE( "Using custom source value presence checking strategy, but no presence checker found for %s in source type." ),
     PROPERTYMAPPING_NO_READ_ACCESSOR_FOR_TARGET_TYPE( "No read accessor found for property \"%s\" in target type." ),
     PROPERTYMAPPING_NO_WRITE_ACCESSOR_FOR_TARGET_TYPE( "No write accessor found for property \"%s\" in target type." ),

File: core/src/main/java/org/mapstruct/DecoratedWith.java
Patch:
@@ -22,7 +22,7 @@
  * <p>
  * <b>NOTE:</b> This annotation is not supported for the component model {@code cdi}. Use CDI's own
  * <a href="https://docs.jboss.org/cdi/spec/1.0/html/decorators.html">{@code @Decorator}</a> feature instead.
- * <p>
+ * </p>
  * <h2>Examples</h2>
  * <p>
  * For the examples below, consider the following mapper declaration:

File: core/src/main/java/org/mapstruct/InheritInverseConfiguration.java
Patch:
@@ -59,7 +59,7 @@
  *      }
  * }
  * </code></pre>
- * <p>
+ *
  * <pre><code class='java'>
  * &#64;Mapper
  * public interface CarMapper {

File: core/src/main/java/org/mapstruct/Mapping.java
Patch:
@@ -372,7 +372,6 @@
      *     }
      * </code></pre>
      * <p>
-     * <p>
      * Any types referenced in expressions must be given via their fully-qualified name. Alternatively, types can be
      * imported via {@link Mapper#imports()}.
      * <p>

File: core/src/main/java/org/mapstruct/control/MappingControl.java
Patch:
@@ -132,7 +132,7 @@ enum Use {
          * This means if source type and target type are of the same type, MapStruct will not perform
          * any mappings anymore and assign the target to the source direct.
          * <p>
-         * An exception are types from the package {@link java}, which will be mapped always directly.
+         * An exception are types from the package {@code java}, which will be mapped always directly.
          *
          * @since 1.4
          */

File: processor/src/main/java/org/mapstruct/ap/internal/model/ObjectFactoryMethodResolver.java
Patch:
@@ -40,10 +40,9 @@ private ObjectFactoryMethodResolver() {
      *
      * @param method target mapping method
      * @param selectionParameters parameters used in the selection process
-     * @param ctx
+     * @param ctx the mapping builder context
      *
      * @return a method reference to the factory method, or null if no suitable, or ambiguous method found
-     *
      */
     public static MethodReference getFactoryMethod( Method method,
                                                     SelectionParameters selectionParameters,
@@ -57,7 +56,7 @@ public static MethodReference getFactoryMethod( Method method,
      * @param method target mapping method
      * @param alternativeTarget alternative to {@link Method#getResultType()} e.g. when target is abstract
      * @param selectionParameters parameters used in the selection process
-     * @param ctx
+     * @param ctx the mapping builder context
      *
      * @return a method reference to the factory method, or null if no suitable, or ambiguous method found
      *

File: processor/src/main/java/org/mapstruct/ap/internal/model/beanmapping/TargetReference.java
Patch:
@@ -80,7 +80,7 @@ public List<String> getElementNames() {
     }
 
     /**
-     * returns the property name on the shallowest nesting level
+     * @return the property name on the shallowest nesting level
      */
     public String getShallowestPropertyName() {
         if ( propertyEntries.isEmpty() ) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/BeanMappingOptions.java
Patch:
@@ -39,6 +39,8 @@ public class BeanMappingOptions extends DelegatingOptions {
     /**
      * creates a mapping for inheritance. Will set
      *
+     * @param beanMapping the bean mapping options that should be used
+     *
      * @return new mapping
      */
     public static BeanMappingOptions forInheritance(BeanMappingOptions beanMapping) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MappingOptions.java
Patch:
@@ -502,6 +502,9 @@ public MappingOptions copyForInverseInheritance(SourceMethod templateMethod,
     /**
      * Creates a copy of this mapping
      *
+     * @param templateMethod the template method for the inheritance
+     * @param beanMappingOptions the bean mapping options
+     *
      * @return the copy
      */
     public MappingOptions copyForForwardInheritance(SourceMethod templateMethod,

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/SelectionParameters.java
Patch:
@@ -34,8 +34,9 @@ public class SelectionParameters {
      *
      * ResultType is not inherited.
      *
-     * @param selectionParameters
-     * @return
+     * @param selectionParameters the selection parameters that need to be copied
+     *
+     * @return the selection parameters based on the given ones
      */
     public static SelectionParameters forInheritance(SelectionParameters selectionParameters) {
         return new SelectionParameters(

File: processor/src/main/java/org/mapstruct/ap/internal/util/accessor/Accessor.java
Patch:
@@ -45,9 +45,7 @@ public interface Accessor {
     Element getElement();
 
     /**
-     * The accessor type
-     *
-     * @return
+     * @return type of the accessor
      */
     AccessorType getAccessorType();
 }

File: integrationtest/src/test/java/org/mapstruct/itest/tests/MavenIntegrationTest.java
Patch:
@@ -5,6 +5,7 @@
  */
 package org.mapstruct.itest.tests;
 
+import org.junit.jupiter.api.condition.DisabledForJreRange;
 import org.junit.jupiter.api.condition.EnabledForJreRange;
 import org.junit.jupiter.api.condition.JRE;
 import org.junit.jupiter.api.parallel.Execution;
@@ -25,6 +26,7 @@ void autoValueBuilderTest() {
     }
 
     @ProcessorTest(baseDir = "cdiTest")
+    @DisabledForJreRange(min = JRE.JAVA_16)
     void cdiTest() {
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -110,6 +110,7 @@ public enum Message {
     ENUMMAPPING_INCORRECT_TRANSFORMATION_STRATEGY( "There is no registered EnumTransformationStrategy for '%s'. Registered strategies are: %s." ),
     ENUMMAPPING_MISSING_CONFIGURATION( "Configuration has to be defined when strategy is defined." ),
     ENUMMAPPING_NO_ELEMENTS( "'nameTransformationStrategy', 'configuration' and 'unexpectedValueMappingException' are undefined in @EnumMapping, define at least one of them." ),
+    ENUMMAPPING_ILLEGAL_TRANSFORMATION( "Illegal transformation for '%s' EnumTransformationStrategy. Error: '%s'." ),
 
     LIFECYCLEMETHOD_AMBIGUOUS_PARAMETERS( "Lifecycle method has multiple matching parameters (e. g. same type), in this case please ensure to name the parameters in the lifecycle and mapping method identical. This lifecycle method will not be used for the mapping method '%s'.", Diagnostic.Kind.WARNING),
 

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DateFormatValidatorFactoryTest.java
Patch:
@@ -20,7 +20,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVisitor;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
 import org.mapstruct.ap.testutil.IssueKey;
 

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DefaultConversionContextTest.java
Patch:
@@ -20,7 +20,7 @@
 import javax.lang.model.type.TypeVisitor;
 import javax.tools.Diagnostic;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mapstruct.ap.internal.util.FormattingMessager;
 import org.mapstruct.ap.internal.util.Message;
 import org.mapstruct.ap.testutil.IssueKey;

File: processor/src/test/java/org/mapstruct/ap/internal/model/source/SelectionParametersTest.java
Patch:
@@ -24,7 +24,7 @@
 import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.type.WildcardType;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mapstruct.ap.internal.util.TypeUtils;
 
 import static org.assertj.core.api.Assertions.assertThat;

File: processor/src/test/java/org/mapstruct/ap/spi/util/IntrospectorUtilsTest.java
Patch:
@@ -5,9 +5,9 @@
  */
 package org.mapstruct.ap.spi.util;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
-import org.junit.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /**
  * @author Saheb Preet Singh

File: processor/src/test/java/org/mapstruct/ap/test/dependency/GraphAnalyzerTest.java
Patch:
@@ -5,16 +5,16 @@
  */
 package org.mapstruct.ap.test.dependency;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mapstruct.ap.internal.model.dependency.GraphAnalyzer;
 import org.mapstruct.ap.internal.util.Strings;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 /**
  * Unit test for {@link GraphAnalyzer}.
  *

File: processor/src/test/java/org/mapstruct/ap/test/gem/ConstantTest.java
Patch:
@@ -5,12 +5,12 @@
  */
 package org.mapstruct.ap.test.gem;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mapstruct.MappingConstants;
 import org.mapstruct.ap.internal.gem.MappingConstantsGem;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 /**
  * Test constants values
  *

File: processor/src/test/java/org/mapstruct/ap/test/gem/EnumGemsTest.java
Patch:
@@ -5,13 +5,11 @@
  */
 package org.mapstruct.ap.test.gem;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 import org.mapstruct.CollectionMappingStrategy;
 import org.mapstruct.InjectionStrategy;
 import org.mapstruct.MappingInheritanceStrategy;
@@ -25,6 +23,8 @@
 import org.mapstruct.ap.internal.gem.NullValueMappingStrategyGem;
 import org.mapstruct.ap.internal.gem.ReportingPolicyGem;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 /**
  * Test for manually created gems on enumeration types
  *

File: processor/src/test/java/org/mapstruct/ap/test/fields/FieldsMappingTest.java
Patch:
@@ -29,7 +29,7 @@ public void shouldMapSourceToTarget() {
         source.normalList = Lists.newArrayList( 10, 11, 12 );
         source.fieldOnlyWithGetter = 20;
 
-        Target target = SourceTargetMapper.INSTANCE.toSource( source );
+        Target target = SourceTargetMapper.INSTANCE.toTarget( source );
 
         assertThat( target ).isNotNull();
         assertThat( target.finalInt ).isEqualTo( "10" );

File: processor/src/test/java/org/mapstruct/ap/test/fields/SourceTargetMapper.java
Patch:
@@ -19,7 +19,7 @@ public interface SourceTargetMapper {
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mapping(target = "fieldWithMethods", source = "fieldOnlyWithGetter")
-    Target toSource(Source source);
+    Target toTarget(Source source);
 
     @InheritInverseConfiguration
     Source toSource(Target target);

File: processor/src/test/java/org/mapstruct/ap/test/gem/ConstantTest.java
Patch:
@@ -23,6 +23,7 @@ public void constantsShouldBeEqual() {
         assertThat( MappingConstants.ANY_REMAINING ).isEqualTo( MappingConstantsGem.ANY_REMAINING );
         assertThat( MappingConstants.ANY_UNMAPPED ).isEqualTo( MappingConstantsGem.ANY_UNMAPPED );
         assertThat( MappingConstants.NULL ).isEqualTo( MappingConstantsGem.NULL );
+        assertThat( MappingConstants.THROW_EXCEPTION ).isEqualTo( MappingConstantsGem.THROW_EXCEPTION );
         assertThat( MappingConstants.SUFFIX_TRANSFORMATION ).isEqualTo( MappingConstantsGem.SUFFIX_TRANSFORMATION );
         assertThat( MappingConstants.STRIP_SUFFIX_TRANSFORMATION )
             .isEqualTo( MappingConstantsGem.STRIP_SUFFIX_TRANSFORMATION );

File: integrationtest/src/test/resources/gradleIncrementalCompilationTest/src/main/java/org/mapstruct/itest/gradle/lib/TestMapper.java
Patch:
@@ -14,6 +14,6 @@
 
 @Mapper(unmappedTargetPolicy = ReportingPolicy.IGNORE)
 public interface TestMapper {
-    @Mapping(source = "value", target = "field")
+    @Mapping(target = "field", source = "value")
     public Target toTarget(Source source);
 }

File: integrationtest/src/test/resources/java8Test/src/main/java/org/mapstruct/ap/test/bugs/_636/SourceTargetMapper.java
Patch:
@@ -15,8 +15,8 @@ public interface SourceTargetMapper extends SourceTargetBaseMapper {
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mappings({
-        @Mapping(source = "idFoo", target = "foo"),
-        @Mapping(source = "idBar", target = "bar")
+        @Mapping(target = "foo", source = "idFoo"),
+        @Mapping(target = "bar", source = "idBar")
     })
     Target mapSourceToTarget(Source source);
 }

File: integrationtest/src/test/resources/java8Test/src/main/java/org/mapstruct/itest/java8/Java8Mapper.java
Patch:
@@ -14,7 +14,7 @@ public interface Java8Mapper {
 
     Java8Mapper INSTANCE = Mappers.getMapper( Java8Mapper.class );
 
-    @Mapping(source = "firstName", target = "givenName")
-    @Mapping(source = "lastName", target = "surname")
+    @Mapping(target = "givenName", source = "firstName")
+    @Mapping(target = "surname", source = "lastName")
     Target sourceToTarget(Source source);
 }

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetAbstractMapper.java
Patch:
@@ -16,9 +16,9 @@ public abstract class SourceTargetAbstractMapper {
     public static SourceTargetAbstractMapper INSTANCE = Mappers.getMapper( SourceTargetAbstractMapper.class );
 
     @Mappings({
-        @Mapping(source = "qax", target = "baz"),
-        @Mapping(source = "baz", target = "qax"),
-        @Mapping(source = "forNested.value", target = "fromNested")
+        @Mapping(target = "baz", source = "qax"),
+        @Mapping(target = "qax", source = "baz"),
+        @Mapping(target = "fromNested", source = "forNested.value")
     })
     public abstract Target sourceToTarget(Source source);
 

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetMapper.java
Patch:
@@ -17,9 +17,9 @@ public interface SourceTargetMapper {
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mappings({
-        @Mapping(source = "qax", target = "baz"),
-        @Mapping(source = "baz", target = "qax"),
-        @Mapping(source = "forNested.value", target = "fromNested")
+        @Mapping(target = "baz", source = "qax"),
+        @Mapping(target = "qax", source = "baz"),
+        @Mapping(target = "fromNested", source = "forNested.value")
     })
     Target sourceToTarget(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/AbstractSourceTargetMapperPrivate.java
Patch:
@@ -19,6 +19,6 @@ public abstract class AbstractSourceTargetMapperPrivate extends SourceTargetmapp
     public static final AbstractSourceTargetMapperPrivate INSTANCE =
             Mappers.getMapper( AbstractSourceTargetMapperPrivate.class );
 
-    @Mapping(source = "referencedSource", target = "referencedTarget")
+    @Mapping(target = "referencedTarget", source = "referencedSource")
     public abstract Target toTarget(Source source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/AbstractSourceTargetMapperProtected.java
Patch:
@@ -19,6 +19,6 @@ public abstract class AbstractSourceTargetMapperProtected extends SourceTargetma
     public static final AbstractSourceTargetMapperProtected INSTANCE =
             Mappers.getMapper( AbstractSourceTargetMapperProtected.class );
 
-    @Mapping(source = "referencedSource", target = "referencedTarget")
+    @Mapping(target = "referencedTarget", source = "referencedSource")
     public abstract Target toTarget(Source source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/SourceTargetMapperDefaultOther.java
Patch:
@@ -20,6 +20,6 @@ public interface SourceTargetMapperDefaultOther {
     SourceTargetMapperDefaultOther INSTANCE =
         Mappers.getMapper( SourceTargetMapperDefaultOther.class );
 
-    @Mapping(source = "referencedSource", target = "referencedTarget")
+    @Mapping(target = "referencedTarget", source = "referencedSource")
     Target toTarget(Source source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/SourceTargetMapperDefaultSame.java
Patch:
@@ -18,6 +18,6 @@ public interface SourceTargetMapperDefaultSame {
 
     SourceTargetMapperDefaultSame INSTANCE = Mappers.getMapper( SourceTargetMapperDefaultSame.class );
 
-    @Mapping(source = "referencedSource", target = "referencedTarget")
+    @Mapping(target = "referencedTarget", source = "referencedSource")
     Target toTarget(Source source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/SourceTargetMapperPrivate.java
Patch:
@@ -18,6 +18,6 @@ public interface SourceTargetMapperPrivate {
 
     SourceTargetMapperPrivate INSTANCE = Mappers.getMapper( SourceTargetMapperPrivate.class );
 
-    @Mapping(source = "referencedSource", target = "referencedTarget")
+    @Mapping(target = "referencedTarget", source = "referencedSource")
     Target toTarget(Source source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/SourceTargetMapperProtected.java
Patch:
@@ -18,6 +18,6 @@ public interface SourceTargetMapperProtected {
 
     SourceTargetMapperProtected INSTANCE = Mappers.getMapper( SourceTargetMapperProtected.class );
 
-    @Mapping(source = "referencedSource", target = "referencedTarget")
+    @Mapping(target = "referencedTarget", source = "referencedSource")
     Target toTarget(Source source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1124/Issue1124Mapper.java
Patch:
@@ -59,6 +59,6 @@ public void setEntity(DTO entity) {
     class MappingContext {
     }
 
-    @Mapping(source = "entity.id", target = "id")
+    @Mapping(target = "id", source = "entity.id")
     DTO map(Entity entity, @Context MappingContext context);
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1155/Issue1155Mapper.java
Patch:
@@ -17,6 +17,6 @@ public interface Issue1155Mapper {
 
     Issue1155Mapper INSTANCE = Mappers.getMapper( Issue1155Mapper.class );
 
-    @Mapping(source = "clientId", target = "client.id")
+    @Mapping(target = "client.id", source = "clientId")
     Entity toEntity(Entity.Dto dto);
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1650/AMapper.java
Patch:
@@ -15,12 +15,12 @@ public interface AMapper {
 
     AMapper INSTANCE = Mappers.getMapper( AMapper.class );
 
-    @Mapping(source = "b.c", target = "cPrime")
+    @Mapping(target = "cPrime", source = "b.c")
     APrime toAPrime(A a, @MappingTarget APrime mappingTarget);
 
     CPrime toCPrime(C c, @MappingTarget CPrime mappingTarget);
 
-    @Mapping(source = "b.c", target = "cPrime")
+    @Mapping(target = "cPrime", source = "b.c")
     APrime toAPrime(A a);
 
     CPrime toCPrime(C c);

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1714/Issue1714Mapper.java
Patch:
@@ -15,7 +15,7 @@ public interface Issue1714Mapper {
 
     Issue1714Mapper INSTANCE = Mappers.getMapper( Issue1714Mapper.class );
 
-    @Mapping(source = "programInstance", target = "seasonNumber", qualifiedByName = "getSeasonNumber")
+    @Mapping(target = "seasonNumber", source = "programInstance", qualifiedByName = "getSeasonNumber")
     OfferEntity map(OnDemand offerStatusDTO);
 
     @Named("getTitle")

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1881/VehicleDtoMapper.java
Patch:
@@ -15,9 +15,9 @@ public interface VehicleDtoMapper {
 
   VehicleDtoMapper INSTANCE = Mappers.getMapper( VehicleDtoMapper.class );
 
-  @Mapping(source = "name", target = "name")
-  @Mapping(source = "size", target = "vehicleProperties.size")
-  @Mapping(source = "type", target = "vehicleProperties.type")
+  @Mapping(target = "name", source = "name")
+  @Mapping(target = "vehicleProperties.size", source = "size")
+  @Mapping(target = "vehicleProperties.type", source = "type")
   VehicleDto map(Vehicle vehicle);
 
   class VehicleDto {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_394/SameNameForSourceAndTargetCarsMapper.java
Patch:
@@ -21,7 +21,7 @@ public interface SameNameForSourceAndTargetCarsMapper {
     SameNameForSourceAndTargetCarsMapper INSTANCE = Mappers.getMapper( SameNameForSourceAndTargetCarsMapper.class );
 
     @Mappings({
-        @Mapping(source = "numberOfSeats", target = "seatCount")
+        @Mapping(target = "seatCount", source = "numberOfSeats")
     })
     AnotherCar sourceCarToTargetCar(org.mapstruct.ap.test.bugs._394.source.AnotherCar car);
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_405/PersonMapper.java
Patch:
@@ -19,7 +19,7 @@ public abstract class PersonMapper {
     public static final PersonMapper INSTANCE = Mappers.getMapper( PersonMapper.class );
 
     @Mappings( {
-        @Mapping( source = "id", target = "name" ) }
+        @Mapping(target = "name",  source = "id") }
     )
     abstract People personToPeople(Person person);
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_846/Mapper846.java
Patch:
@@ -56,7 +56,7 @@ public void setaName(String name) {
     @Mapper
     interface MyMapper {
 
-        @Mapping(source = "name", target = "aName")
+        @Mapping(target = "aName", source = "name")
         A convert(BInterface b);
 
         @InheritInverseConfiguration

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_849/Issue849Mapper.java
Patch:
@@ -18,7 +18,7 @@ public interface Issue849Mapper {
 
     Issue849Mapper INSTANCE = Mappers.getMapper( Issue849Mapper.class );
 
-    @Mapping(source = "sourceList", target = "targetList")
+    @Mapping(target = "targetList", source = "sourceList")
     Target mapSourceToTarget(Source source);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_891/BuggyMapper.java
Patch:
@@ -18,6 +18,6 @@ public interface BuggyMapper {
 
     BuggyMapper INSTANCE = Mappers.getMapper( BuggyMapper.class );
 
-    @Mapping(source = "nested.propInt", target = "propLong")
+    @Mapping(target = "propLong", source = "nested.propInt")
     Dest convert(Src src);
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/SourceTargetMapper.java
Patch:
@@ -42,6 +42,6 @@ public interface SourceTargetMapper {
 
     TargetViaTargetType toTargetViaTargetType(Source source);
 
-    @Mapping(source = "pet", target = "pets")
+    @Mapping(target = "pets", source = "pet")
     Target fromSingleElementSource(SingleElementSource source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/defaultimplementation/SourceTargetMapper.java
Patch:
@@ -26,7 +26,7 @@ public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
-    @Mapping(source = "fooList", target = "fooListNoSetter")
+    @Mapping(target = "fooListNoSetter", source = "fooList")
     Target sourceToTarget(Source source);
 
     TargetFoo sourceFooToTargetFoo(SourceFoo sourceFoo);

File: processor/src/test/java/org/mapstruct/ap/test/complex/CarMapper.java
Patch:
@@ -24,8 +24,8 @@ public interface CarMapper {
     CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );
 
     @Mappings({
-        @Mapping(source = "numberOfSeats", target = "seatCount"),
-        @Mapping(source = "manufacturingDate", target = "manufacturingYear")
+        @Mapping(target = "seatCount", source = "numberOfSeats"),
+        @Mapping(target = "manufacturingYear", source = "manufacturingDate")
     })
     CarDto carToCarDto(Car car);
 

File: processor/src/test/java/org/mapstruct/ap/test/conversion/SourceTargetMapper.java
Patch:
@@ -17,8 +17,8 @@ public interface SourceTargetMapper {
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mappings({
-        @Mapping(source = "qax", target = "baz"),
-        @Mapping(source = "baz", target = "qax")
+        @Mapping(target = "baz", source = "qax"),
+        @Mapping(target = "qax", source = "baz")
     })
     Target sourceToTarget(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/test/conversion/java8time/localdatetimetoxmlgregoriancalendarconversion/SourceTargetMapper.java
Patch:
@@ -17,9 +17,9 @@ public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
-    @Mapping(source = "xmlGregorianCalendar", target = "localDateTime")
+    @Mapping(target = "localDateTime", source = "xmlGregorianCalendar")
     Target toTarget(Source source);
 
-    @Mapping(source = "localDateTime", target = "xmlGregorianCalendar")
+    @Mapping(target = "xmlGregorianCalendar", source = "localDateTime")
     Source toSource(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/attributereference/ErroneousMapper1.java
Patch:
@@ -13,7 +13,7 @@
 public interface ErroneousMapper1 {
 
     @Mappings({
-        @Mapping(source = "source.foobar", target = "foo")
+        @Mapping(target = "foo", source = "source.foobar")
     })
     Target sourceToTarget(Source source, DummySource source1);
 

File: processor/src/test/java/org/mapstruct/ap/test/fields/SourceTargetMapper.java
Patch:
@@ -18,7 +18,7 @@ public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
-    @Mapping(source = "fieldOnlyWithGetter", target = "fieldWithMethods")
+    @Mapping(target = "fieldWithMethods", source = "fieldOnlyWithGetter")
     Target toSource(Source source);
 
     @InheritInverseConfiguration

File: processor/src/test/java/org/mapstruct/ap/test/injectionstrategy/jsr330/compileoptionconstructor/CustomerJsr330CompileOptionConstructorMapper.java
Patch:
@@ -18,7 +18,7 @@
     uses = GenderJsr330CompileOptionConstructorMapper.class )
 public interface CustomerJsr330CompileOptionConstructorMapper {
 
-    @Mapping(source = "gender", target = "gender")
+    @Mapping(target = "gender", source = "gender")
     CustomerDto asTarget(CustomerEntity customerEntity);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/injectionstrategy/jsr330/constructor/CustomerJsr330ConstructorMapper.java
Patch:
@@ -20,7 +20,7 @@
     injectionStrategy = InjectionStrategy.CONSTRUCTOR )
 public interface CustomerJsr330ConstructorMapper {
 
-    @Mapping(source = "gender", target = "gender")
+    @Mapping(target = "gender", source = "gender")
     CustomerDto asTarget(CustomerEntity customerEntity);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/injectionstrategy/spring/compileoptionconstructor/CustomerSpringCompileOptionConstructorMapper.java
Patch:
@@ -18,6 +18,6 @@
     uses = GenderSpringCompileOptionConstructorMapper.class)
 public interface CustomerSpringCompileOptionConstructorMapper {
 
-    @Mapping( source = "gender", target = "gender" )
+    @Mapping(target = "gender", source = "gender")
     CustomerDto asTarget(CustomerEntity customerEntity);
 }

File: processor/src/test/java/org/mapstruct/ap/test/injectionstrategy/spring/constructor/CustomerSpringConstructorMapper.java
Patch:
@@ -20,6 +20,6 @@
     injectionStrategy = InjectionStrategy.CONSTRUCTOR )
 public interface CustomerSpringConstructorMapper {
 
-    @Mapping( source = "gender", target = "gender" )
+    @Mapping(target = "gender", source = "gender")
     CustomerDto asTarget(CustomerEntity customerEntity);
 }

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/base/StreamMapper.java
Patch:
@@ -21,8 +21,8 @@ public interface StreamMapper {
     StreamMapper INSTANCE = Mappers.getMapper( StreamMapper.class );
 
     @Mappings( {
-        @Mapping( source = "stream", target = "targetStream"),
-        @Mapping( source = "sourceElements", target = "targetElements")
+        @Mapping(target = "targetStream", source = "stream"),
+        @Mapping(target = "targetElements", source = "sourceElements")
     } )
     Target map(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/defaultimplementation/SourceTargetMapper.java
Patch:
@@ -22,7 +22,7 @@ public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
-    @Mapping(source = "fooStream", target = "fooListNoSetter")
+    @Mapping(target = "fooListNoSetter", source = "fooStream")
     Target sourceToTarget(Source source);
 
     TargetFoo sourceFooToTargetFoo(SourceFoo sourceFoo);

File: processor/src/test/java/org/mapstruct/ap/test/namesuggestion/erroneous/PersonAgeMapper.java
Patch:
@@ -16,7 +16,7 @@ public interface PersonAgeMapper {
 
     PersonAgeMapper MAPPER = Mappers.getMapper( PersonAgeMapper.class );
 
-    @Mapping(source = "agee", target = "fullAge")
+    @Mapping(target = "fullAge", source = "agee")
     Person mapPerson(PersonDto dto);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/namesuggestion/erroneous/PersonGarageWrongTargetMapper.java
Patch:
@@ -16,9 +16,9 @@ public interface PersonGarageWrongTargetMapper {
 
     PersonGarageWrongTargetMapper MAPPER = Mappers.getMapper( PersonGarageWrongTargetMapper.class );
 
-    @Mapping(source = "garage.color.rgb", target = "garage.colour.rgb")
+    @Mapping(target = "garage.colour.rgb", source = "garage.color.rgb")
     Person mapPerson(PersonDto dto);
 
-    @Mapping(source = "garage.color", target = "garage.colour")
+    @Mapping(target = "garage.colour", source = "garage.color")
     Person mapPersonGarage(PersonDto dto);
 }

File: processor/src/test/java/org/mapstruct/ap/test/namesuggestion/erroneous/PersonNameMapper.java
Patch:
@@ -16,7 +16,7 @@ public interface PersonNameMapper {
 
     PersonNameMapper MAPPER = Mappers.getMapper( PersonNameMapper.class );
 
-    @Mapping(source = "name", target = "fulName")
+    @Mapping(target = "fulName", source = "name")
     Person mapPerson(PersonDto dto);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedmethodcall/SourceTypeTargetDtoMapper.java
Patch:
@@ -17,7 +17,7 @@ public interface SourceTypeTargetDtoMapper {
 
     SourceTypeTargetDtoMapper INSTANCE = Mappers.getMapper( SourceTypeTargetDtoMapper.class );
 
-    @Mapping(source = "date", target = "date", dateFormat = "dd.MM.yyyy")
+    @Mapping(target = "date", source = "date", dateFormat = "dd.MM.yyyy")
     TargetDto sourceToTarget(SourceType source);
 
     SourceType targetToSource( TargetDto source );

File: processor/src/test/java/org/mapstruct/ap/test/nestedsource/exceptions/ResourceMapper.java
Patch:
@@ -15,7 +15,7 @@
 @Mapper
 public interface ResourceMapper {
 
-    @Mapping(source = "bucket.user.uuid", target = "userId")
+    @Mapping(target = "userId", source = "bucket.user.uuid")
     ResourceDto map(Resource r) throws NoSuchUser;
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/CustomerDefaultMapper.java
Patch:
@@ -16,10 +16,10 @@ public interface CustomerDefaultMapper {
 
     CustomerDefaultMapper INSTANCE = Mappers.getMapper( CustomerDefaultMapper.class );
 
-    @Mapping(source = "address", target = "homeDTO.addressDTO")
+    @Mapping(target = "homeDTO.addressDTO", source = "address")
     void mapCustomer(Customer customer, @MappingTarget UserDTO userDTO);
 
-    @Mapping(source = "houseNumber", target = "houseNo", defaultValue = "0")
+    @Mapping(target = "houseNo", defaultValue = "0", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/CustomerMapper.java
Patch:
@@ -16,10 +16,10 @@ public interface CustomerMapper {
 
     CustomerMapper INSTANCE = Mappers.getMapper( CustomerMapper.class );
 
-    @Mapping(source = "address", target = "homeDTO.addressDTO")
+    @Mapping(target = "homeDTO.addressDTO", source = "address")
     void mapCustomer(Customer customer, @MappingTarget UserDTO userDTO);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/CustomerNvpmsOnBeanMappingMethodMapper.java
Patch:
@@ -21,7 +21,7 @@ public interface CustomerNvpmsOnBeanMappingMethodMapper {
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
     @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/CustomerNvpmsOnConfigMapper.java
Patch:
@@ -17,7 +17,7 @@ public interface CustomerNvpmsOnConfigMapper {
 
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/CustomerNvpmsOnMapperMapper.java
Patch:
@@ -18,7 +18,7 @@ public interface CustomerNvpmsOnMapperMapper {
 
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/CustomerNvpmsPropertyMappingMapper.java
Patch:
@@ -21,7 +21,7 @@ public interface CustomerNvpmsPropertyMappingMapper {
     @Mapping( target = "details", nullValuePropertyMappingStrategy = IGNORE)
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/ErroneousCustomerMapper1.java
Patch:
@@ -21,7 +21,7 @@ public interface ErroneousCustomerMapper1 {
     @Mapping(target = "address", nullValuePropertyMappingStrategy = IGNORE)
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/ErroneousCustomerMapper2.java
Patch:
@@ -21,7 +21,7 @@ public interface ErroneousCustomerMapper2 {
     @Mapping(target = "address", nullValuePropertyMappingStrategy = IGNORE)
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/ErroneousCustomerMapper3.java
Patch:
@@ -21,7 +21,7 @@ public interface ErroneousCustomerMapper3 {
     @Mapping(target = "address", nullValuePropertyMappingStrategy = IGNORE)
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/ErroneousCustomerMapper4.java
Patch:
@@ -21,7 +21,7 @@ public interface ErroneousCustomerMapper4 {
     @Mapping(target = "address", nullValuePropertyMappingStrategy = IGNORE)
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/ErroneousCustomerMapper5.java
Patch:
@@ -21,7 +21,7 @@ public interface ErroneousCustomerMapper5 {
     @Mapping(target = "address", nullValuePropertyMappingStrategy = IGNORE)
     void map(Customer customer, @MappingTarget CustomerDTO mappingTarget);
 
-    @Mapping(source = "houseNumber", target = "houseNo")
+    @Mapping(target = "houseNo", source = "houseNumber")
     void mapCustomerHouse(Address address, @MappingTarget AddressDTO addrDTO);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/oneway/SourceTargetMapper.java
Patch:
@@ -14,7 +14,7 @@ public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
-    @Mapping(source = "qax", target = "qux")
+    @Mapping(target = "qux", source = "qax")
     Target sourceToTarget(Source source);
 
     Source targetToSource(Target target);

File: processor/src/test/java/org/mapstruct/ap/test/reverse/erroneous/SourceTargetMapperNonMatchingName.java
Patch:
@@ -22,9 +22,9 @@ public interface SourceTargetMapperNonMatchingName {
     SourceTargetMapperNonMatchingName INSTANCE = Mappers.getMapper( SourceTargetMapperNonMatchingName.class );
 
     @Mappings({
-        @Mapping(source = "stringPropX", target = "stringPropY"),
-        @Mapping(source = "integerPropX", target = "integerPropY"),
-        @Mapping(source = "propertyToIgnoreDownstream", target = "propertyNotToIgnoreUpstream")
+        @Mapping(target = "stringPropY", source = "stringPropX"),
+        @Mapping(target = "integerPropY", source = "integerPropX"),
+        @Mapping(target = "propertyNotToIgnoreUpstream", source = "propertyToIgnoreDownstream")
     })
     Target forward(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper1.java
Patch:
@@ -21,7 +21,7 @@ public interface ErroneousMapper1 {
     @Mappings({
         @Mapping(target = "stringConstant", constant = "stringConstant"),
         @Mapping(target = "emptyStringConstant", constant = ""),
-        @Mapping(source = "test", target = "integerConstant", constant = "14"),
+        @Mapping(target = "integerConstant", source = "test", constant = "14"),
         @Mapping(target = "longWrapperConstant", constant = "3001L"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),
         @Mapping(target = "nameConstants", constant = "jack-jill-tom"),

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper4.java
Patch:
@@ -21,7 +21,7 @@ public interface ErroneousMapper4 {
     @Mappings({
         @Mapping(target = "stringConstant", constant = "stringConstant"),
         @Mapping(target = "emptyStringConstant", constant = ""),
-        @Mapping(source = "test", target = "integerConstant", expression = "java('test')"),
+        @Mapping(target = "integerConstant", source = "test", expression = "java('test')"),
         @Mapping(target = "longWrapperConstant", constant = "3001L"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),
         @Mapping(target = "nameConstants", constant = "jack-jill-tom"),

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/SourceTargetMapperSeveralSources.java
Patch:
@@ -19,8 +19,8 @@ public interface SourceTargetMapperSeveralSources {
     SourceTargetMapperSeveralSources INSTANCE = Mappers.getMapper( SourceTargetMapperSeveralSources.class );
 
     @Mappings({
-        @Mapping(source = "s1.someProp", target = "someProp" ),
-        @Mapping(source = "s2.anotherProp", target = "anotherProp" ),
+        @Mapping(target = "someProp", source = "s1.someProp"),
+        @Mapping(target = "anotherProp", source = "s2.anotherProp"),
         @Mapping(target = "someConstant", constant = "stringConstant"),
     })
     Target2 sourceToTarget(Source1 s1, Source2 s2);

File: processor/src/test/java/org/mapstruct/ap/test/source/expressions/java/SourceTargetMapperSeveralSources.java
Patch:
@@ -20,8 +20,8 @@ public interface SourceTargetMapperSeveralSources {
     SourceTargetMapperSeveralSources INSTANCE = Mappers.getMapper( SourceTargetMapperSeveralSources.class );
 
     @Mappings( {
-        @Mapping( target = "timeAndFormat", expression = "java( new TimeAndFormat( s.getTime(), s.getFormat() ))" ),
-        @Mapping( source = "s1.anotherProp", target = "anotherProp" )
+        @Mapping(target = "timeAndFormat", expression = "java( new TimeAndFormat( s.getTime(), s.getFormat() ))"),
+        @Mapping(target = "anotherProp", source = "s1.anotherProp")
     } )
     Target sourceToTarget( Source s, Source2 s1 );
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/manysourcearguments/SourceTargetConfig.java
Patch:
@@ -11,8 +11,8 @@
 @MapperConfig
 public interface SourceTargetConfig {
 
-    @Mapping(source = "address.houseNo", target = "houseNumber")
-    @Mapping(source = "person.description", target = "description")
+    @Mapping(target = "houseNumber", source = "address.houseNo")
+    @Mapping(target = "description", source = "person.description")
     DeliveryAddress personAndAddressToDeliveryAddress(Person person, Address address);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/ErroneousOrganizationMapper1.java
Patch:
@@ -25,12 +25,12 @@ public interface ErroneousOrganizationMapper1 {
 
     void toCompanyEntity(CompanyDto dto, @MappingTarget CompanyEntity entity);
 
-    @Mapping(source = "type", target = "type")
+    @Mapping(target = "type", source = "type")
     void toName(String type, @MappingTarget OrganizationTypeEntity entity);
 
     @Mappings({
-        @Mapping( target = "employees", ignore = true ),
-        @Mapping( target = "secretaryToEmployee", ignore = true )
+        @Mapping(target = "employees", ignore = true ),
+        @Mapping(target = "secretaryToEmployee", ignore = true )
     })
     DepartmentEntity toDepartmentEntity(DepartmentDto dto);
 

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/ErroneousOrganizationMapper2.java
Patch:
@@ -25,7 +25,7 @@ public interface ErroneousOrganizationMapper2 {
 
     void toCompanyEntity(CompanyDto dto, @MappingTarget CompanyEntity entity);
 
-    @Mapping(source = "type", target = "type")
+    @Mapping(target = "type", source = "type")
     void toName(String type, @MappingTarget OrganizationTypeEntity entity);
 
     @Mappings({

File: core/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -47,7 +47,7 @@
  *      uses = MarkMapper.class,
  *      injectionStrategy = InjectionStrategy.CONSTRUCTOR)
  * public interface CarMapper {
- *     &#64;Mapping(source = "mark", target = "name")
+ *     &#64;Mapping(target = "name", source = "mark")
  *     CarDto convertMap(CarEntity carEntity);
  * }
  * </code></pre>

File: core/src/main/java/org/mapstruct/ValueMapping.java
Patch:
@@ -27,9 +27,9 @@
  *
  * public enum ExternalOrderType { RETAIL, B2B, SPECIAL, DEFAULT }
  *
- * &#64;ValueMapping(source = "EXTRA", target = "SPECIAL"),
- * &#64;ValueMapping(source = "STANDARD", target = "DEFAULT"),
- * &#64;ValueMapping(source = "NORMAL", target = "DEFAULT")
+ * &#64;ValueMapping(target = "SPECIAL", source = "EXTRA"),
+ * &#64;ValueMapping(target = "DEFAULT", source = "STANDARD"),
+ * &#64;ValueMapping(target = "DEFAULT", source = "NORMAL")
  * ExternalOrderType orderTypeToExternalOrderType(OrderType orderType);
  * </code>
  * Mapping result:

File: processor/src/main/java/org/mapstruct/ap/internal/model/beanmapping/SourceReference.java
Patch:
@@ -34,7 +34,7 @@
  * mapping method:
  *
  * <pre>
- * &#64;Mapping(source = "in.propA.propB" target = "propC")
+ * &#64;Mapping(target = "propC", source = "in.propA.propB")
  * TypeB mappingMethod(TypeA in);
  * </pre>
  *

File: processor/src/main/java/org/mapstruct/ap/internal/model/beanmapping/TargetReference.java
Patch:
@@ -32,7 +32,7 @@
  * method:
  *
  * <pre>
- * &#64;Mapping(source = "in.propA.propB" target = "propC")
+ * &#64;Mapping(target = "propC", source = "in.propA.propB")
  * TypeB mappingMethod(TypeA in);
  * </pre>
  *

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -115,6 +115,7 @@ public enum Message {
     DECORATOR_NO_SUBTYPE( "Specified decorator type is no subtype of the annotated mapper type." ),
     DECORATOR_CONSTRUCTOR( "Specified decorator type has no default constructor nor a constructor with a single parameter accepting the decorated mapper type." ),
 
+    GENERAL_CANNOT_IMPLEMENT_PRIVATE_MAPPER("Cannot create an implementation for mapper %s, because it is a private %s."),
     GENERAL_NO_IMPLEMENTATION( "No implementation type is registered for return type %s." ),
     GENERAL_ABSTRACT_RETURN_TYPE( "The return type %s is an abstract class or interface. Provide a non abstract / non interface result type or a factory method." ),
     GENERAL_AMBIGUOUS_MAPPING_METHOD( "Ambiguous mapping methods found for mapping %s to %s: %s. See " + FAQ_AMBIGUOUS_URL + " for more info." ),

File: core/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -143,7 +143,7 @@
      * {@code jsr330}: the generated mapper is annotated with {@code @javax.inject.Named} and
      * {@code @Singleton}, and can be retrieved via {@code @Inject}</li>
      * </ul>
-     * The method overrides an unmappedTargetPolicy set in a central configuration set
+     * The method overrides a componentModel set in a central configuration set
      * by {@link #config() }
      *
      * @return The component model for the generated mapper.

File: processor/src/test/resources/fixtures/org/mapstruct/ap/test/updatemethods/selection/OrganizationMapper1Impl.java
Patch:
@@ -9,7 +9,6 @@
 import org.mapstruct.ap.test.updatemethods.CompanyDto;
 import org.mapstruct.ap.test.updatemethods.CompanyEntity;
 import org.mapstruct.ap.test.updatemethods.DepartmentEntityFactory;
-import org.mapstruct.factory.Mappers;
 
 @Generated(
     value = "org.mapstruct.ap.MappingProcessor",
@@ -18,7 +17,7 @@
 )
 public class OrganizationMapper1Impl implements OrganizationMapper1 {
 
-    private final ExternalMapper externalMapper = Mappers.getMapper( ExternalMapper.class );
+    private final ExternalMapper externalMapper = ExternalMapper.INSTANCE;
     private final DepartmentEntityFactory departmentEntityFactory = new DepartmentEntityFactory();
 
     @Override

File: processor/src/test/resources/fixtures/org/mapstruct/ap/test/updatemethods/selection/OrganizationMapper3Impl.java
Patch:
@@ -9,7 +9,6 @@
 import org.mapstruct.ap.test.updatemethods.BossDto;
 import org.mapstruct.ap.test.updatemethods.BossEntity;
 import org.mapstruct.ap.test.updatemethods.ConstructableDepartmentEntity;
-import org.mapstruct.factory.Mappers;
 
 @Generated(
     value = "org.mapstruct.ap.MappingProcessor",
@@ -18,7 +17,7 @@
 )
 public class OrganizationMapper3Impl implements OrganizationMapper3 {
 
-    private final ExternalMapper externalMapper = Mappers.getMapper( ExternalMapper.class );
+    private final ExternalMapper externalMapper = ExternalMapper.INSTANCE;
 
     @Override
     public void toBossEntity(BossDto dto, BossEntity entity) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -656,6 +656,7 @@ private Assignment forgeWithElementMapping(Type sourceType, Type targetType, Sou
                 .method( methodRef )
                 .selectionParameters( selectionParameters )
                 .callingContextTargetPropertyName( targetPropertyName )
+                .positionHint( positionHint )
                 .build();
 
             return createForgedAssignment( source, methodRef, iterableMappingMethod );

File: processor/src/test/java/org/mapstruct/ap/test/exceptions/ExceptionTestMapper.java
Patch:
@@ -20,6 +20,6 @@ public Long toLong(Integer size) throws TestException1, TestException2 {
         else if ( size == 2 ) {
             throw new TestException2();
         }
-        return new Long(size);
+        return Long.valueOf( size );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -1315,6 +1315,7 @@ private void applyParameterNameBasedMapping() {
                         sourceParameters.remove();
                         unprocessedDefinedTargets.remove( targetProperty.getKey() );
                         unprocessedSourceProperties.remove( targetProperty.getKey() );
+                        unprocessedConstructorProperties.remove( targetProperty.getKey() );
                     }
                 }
             }

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/TypeFactory.java
Patch:
@@ -274,7 +274,9 @@ else if (componentTypeMirror.getKind().isPrimitive()) {
         else {
             isEnumType = false;
             isInterface = false;
-            name = mirror.toString();
+            // When the component type is primitive and is annotated with ElementType.TYPE_USE then
+            // the typeMirror#toString returns (@CustomAnnotation :: byte) for the javac compiler
+            name = mirror.getKind().isPrimitive() ? NativeTypes.getName( mirror.getKind() ) : mirror.toString();
             packageName = null;
             qualifiedName = name;
             typeElement = null;

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -367,7 +367,7 @@ private boolean allowDirect(Type type) {
             }
 
             if ( type.isArrayType() ) {
-                return type.isJavaLangType();
+                return type.isJavaLangType() || type.getComponentType().isPrimitive();
             }
 
             if ( type.isIterableOrStreamType() ) {

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/AdderTest.java
Patch:
@@ -178,7 +178,7 @@ public void testShouldPreferHumanSingular() {
     }
 
     @Test
-    public void testShouldFallBackToDaliSingularInAbsenseOfHumanSingular() {
+    public void testShouldFallBackToDaliSingularInAbsenceOfHumanSingular() {
         AdderUsageObserver.setUsed( false );
 
         SourceTeeth source = new SourceTeeth();

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousmapping/AmbiguousMapperTest.java
Patch:
@@ -17,7 +17,7 @@
 
 @IssueKey("2156")
 @RunWith(AnnotationProcessorTestRunner.class)
-public class AmbigiousMapperTest {
+public class AmbiguousMapperTest {
 
     @Test
     @WithClasses( ErroneousWithAmbiguousMethodsMapper.class)

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousmapping/ErroneousWithAmbiguousMethodsMapper.java
Patch:
@@ -19,7 +19,7 @@ default LeafEntity map1(LeafDTO dto) {
         return new LeafEntity();
     }
 
-    // duplicated method, triggering ambigious mapping method
+    // duplicated method, triggering ambiguous mapping method
     default LeafEntity map2(LeafDTO dto) {
         return new LeafEntity();
     }

File: processor/src/test/java/org/mapstruct/ap/test/source/manysourcearguments/ManySourceArgumentsTest.java
Patch:
@@ -176,7 +176,7 @@ public void shouldUseConfig() {
                 line = 16,
                 message = "Several possible source properties for target property \"description\".")
     })
-    public void shouldFailToGenerateMappingsForAmbigiousSourceProperty() {
+    public void shouldFailToGenerateMappingsForAmbiguousSourceProperty() {
     }
 
     @Test

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -73,6 +73,8 @@ public enum Message {
     PROPERTYMAPPING_NO_READ_ACCESSOR_FOR_TARGET_TYPE( "No read accessor found for property \"%s\" in target type." ),
     PROPERTYMAPPING_NO_WRITE_ACCESSOR_FOR_TARGET_TYPE( "No write accessor found for property \"%s\" in target type." ),
     PROPERTYMAPPING_WHITESPACE_TRIMMED( "The property named \"%s\" has whitespaces, using trimmed property \"%s\" instead.", Diagnostic.Kind.WARNING ),
+    PROPERTYMAPPING_CANNOT_DETERMINE_SOURCE_PROPERTY_FROM_TARGET("The type of parameter \"%s\" has no property named \"%s\". Please define the source property explicitly."),
+    PROPERTYMAPPING_CANNOT_DETERMINE_SOURCE_PARAMETER_FROM_TARGET("No property named \"%s\" exists in source parameter(s). Please define the source explicitly."),
 
     CONVERSION_LOSSY_WARNING( "%s has a possibly lossy conversion from %s to %s.", Diagnostic.Kind.WARNING ),
     CONVERSION_LOSSY_ERROR( "Can't map %s. It has a possibly lossy conversion from %s to %s." ),

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_2077/Issue2077ErroneousMapper.java
Patch:
@@ -8,16 +8,13 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.ReportingPolicy;
-import org.mapstruct.factory.Mappers;
 
 /**
  * @author Sjaak Derksen
  */
 @Mapper( unmappedTargetPolicy = ReportingPolicy.ERROR )
 public interface Issue2077ErroneousMapper {
 
-    Issue2077ErroneousMapper INSTANCE = Mappers.getMapper( Issue2077ErroneousMapper.class );
-
     @Mapping(target = "s1", defaultValue = "xyz" )
     Target map(String source);
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_2077/Issue2077Test.java
Patch:
@@ -30,8 +30,9 @@ public class Issue2077Test {
         diagnostics = {
             @Diagnostic(type = Issue2077ErroneousMapper.class,
                 kind = ERROR,
-                line = 22,
-                message = "Unmapped target property: \"s1\".")
+                line = 18,
+                message = "The type of parameter \"source\" has no property named \"s1\". Please define the source " +
+                    "property explicitly.")
         }
     )
     public void shouldNotCompile() {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1359/Issue1359Test.java
Patch:
@@ -15,7 +15,7 @@
 import org.mapstruct.ap.testutil.runner.AnnotationProcessorTestRunner;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.atIndex;
+import static org.assertj.core.api.InstanceOfAssertFactories.ITERABLE;
 
 /**
  * @author Filip Hrisafov
@@ -33,14 +33,14 @@ public class Issue1359Test {
     public void shouldCompile() {
 
         Target target = new Target();
-        assertThat( target ).extracting( "properties" ).contains( null, atIndex( 0 ) );
+        assertThat( target ).extracting( "properties" ).isNull();
 
         Set<String> properties = new HashSet<>();
         properties.add( "first" );
         Source source = new Source( properties );
         Issue1359Mapper.INSTANCE.map( target, source );
 
-        assertThat( target ).extracting( "properties" ).contains( properties, atIndex( 0 ) );
+        assertThat( target ).extracting( "properties", ITERABLE ).containsExactly( "first" );
 
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_895/Issue895Test.java
Patch:
@@ -32,6 +32,6 @@ public void properlyMapsMultiDimensionalArrays() {
         assertThat( listOfByteArray.getBytes() ).containsExactly( new byte[] { 0, 1 }, new byte[] { 1, 2 } );
 
         arrayOfByteArray = Mappers.getMapper( MultiArrayMapper.class ).convert( listOfByteArray );
-        assertThat( arrayOfByteArray.getBytes() ).containsExactly( new byte[] { 0, 1 }, new byte[] { 1, 2 } );
+        assertThat( arrayOfByteArray.getBytes() ).isDeepEqualTo( new byte[][] { { 0, 1 }, { 1, 2 } } );
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/builder/nestedprop/expanding/FlattenedStock.java
Patch:
@@ -5,7 +5,7 @@
  */
 package org.mapstruct.ap.test.builder.nestedprop.expanding;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 public class FlattenedStock {
     private String article1;
@@ -16,8 +16,8 @@ public FlattenedStock() {
     }
 
     public FlattenedStock(String article1, String article2, int count) {
-        this.article1 = checkNotNull( article1 );
-        this.article2 = checkNotNull( article2 );
+        this.article1 = requireNonNull( article1 );
+        this.article2 = requireNonNull( article2 );
         this.count = count;
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/collection/iterabletononiterable/StringListMapper.java
Patch:
@@ -8,12 +8,10 @@
 import java.util.Arrays;
 import java.util.List;
 
-import com.google.common.base.Joiner;
-
 public class StringListMapper {
 
     public String stringListToString(List<String> strings) {
-        return strings == null ? null : Joiner.on( "-" ).join( strings );
+        return strings == null ? null : String.join( "-", strings );
     }
 
     public List<String> stringToStringList(String string) {

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -149,6 +149,7 @@ public enum Message {
     RETRIEVAL_WILDCARD_SUPER_BOUND_SOURCE( "Can't generate mapping method for a wildcard super bound source." ),
     RETRIEVAL_WILDCARD_EXTENDS_BOUND_RESULT( "Can't generate mapping method for a wildcard extends bound result." ),
     RETRIEVAL_CONTEXT_PARAMS_WITH_SAME_TYPE( "The types of @Context parameters must be unique." ),
+    RETRIEVAL_MAPPER_USES_CYCLE( "The mapper %s is referenced itself in Mapper#uses.", Diagnostic.Kind.WARNING ),
 
     INHERITINVERSECONFIGURATION_DUPLICATES( "Several matching inverse methods exist: %s(). Specify a name explicitly." ),
     INHERITINVERSECONFIGURATION_INVALID_NAME( "None of the candidates %s() matches given name: \"%s\"." ),

File: integrationtest/src/test/resources/recordsTest/src/main/java/org/mapstruct/itest/records/CustomerMapper.java
Patch:
@@ -24,4 +24,7 @@ public interface CustomerMapper {
     @InheritInverseConfiguration
     CustomerDto toRecord(CustomerEntity entity);
 
+    @Mapping(target = "value", source = "name")
+    GenericRecord<String> toValue(CustomerEntity entity);
+
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/ContainerMappingMethodBuilder.java
Patch:
@@ -100,7 +100,8 @@ public final M build() {
             else {
                 reportCannotCreateMapping(
                     method,
-                    String.format( "%s \"%s\"", sourceRHS.getSourceErrorMessagePart(), sourceRHS.getSourceType() ),
+                    String.format( "%s \"%s\"", sourceRHS.getSourceErrorMessagePart(),
+                        sourceRHS.getSourceType().describe() ),
                     sourceRHS.getSourceType(),
                     targetElementType,
                     ""

File: processor/src/main/java/org/mapstruct/ap/internal/model/ForgedMethodHistory.java
Patch:
@@ -43,7 +43,7 @@ public Type getSourceType() {
     }
 
     public String createSourcePropertyErrorMessage() {
-        return conditionallyCapitalizedElementType() + " \"" + getSourceType() + " " +
+        return conditionallyCapitalizedElementType() + " \"" + getSourceType().describe() + " " +
             stripBrackets( getDottedSourceElement() ) + "\"";
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/NestedTargetPropertyMappingHolder.java
Patch:
@@ -662,7 +662,7 @@ private PropertyMapping createPropertyMappingForNestedTarget(MappingReferences m
                             mapping.getTargetAnnotationValue(),
                             Message.BEANMAPPING_UNKNOWN_PROPERTY_IN_TYPE,
                             targetPropertyName,
-                            targetType,
+                            targetType.describe(),
                             mapping.getTargetName(),
                             Strings.join( pathProperties, "." )
                         );

File: processor/src/main/java/org/mapstruct/ap/internal/model/ValueMappingMethod.java
Patch:
@@ -209,7 +209,7 @@ else if ( NULL.equals( targetConstant ) ) {
                         ForgedMethodHistory history = ( (ForgedMethod) method ).getHistory();
                         sourceErrorMessage = history.createSourcePropertyErrorMessage();
                         targetErrorMessage =
-                            "\"" + history.getTargetType().toString() + " " + history.createTargetPropertyName() + "\"";
+                            "\"" + history.getTargetType().describe() + " " + history.createTargetPropertyName() + "\"";
                     }
                     // all sources should now be matched, there's no default to fall back to, so if sources remain,
                     // we have an issue.

File: processor/src/main/java/org/mapstruct/ap/internal/model/beanmapping/AbstractReference.java
Patch:
@@ -112,18 +112,18 @@ public String toString() {
         }
         else if ( propertyEntries.isEmpty() ) {
             if ( parameter != null ) {
-                result = String.format( "parameter \"%s %s\"", parameter.getType(), parameter.getName() );
+                result = String.format( "parameter \"%s %s\"", parameter.getType().describe(), parameter.getName() );
             }
         }
         else if ( propertyEntries.size() == 1 ) {
             PropertyEntry propertyEntry = propertyEntries.get( 0 );
-            result = String.format( "property \"%s %s\"", propertyEntry.getType(), propertyEntry.getName() );
+            result = String.format( "property \"%s %s\"", propertyEntry.getType().describe(), propertyEntry.getName() );
         }
         else {
             PropertyEntry lastPropertyEntry = propertyEntries.get( propertyEntries.size() - 1 );
             result = String.format(
                 "property \"%s %s\"",
-                lastPropertyEntry.getType(),
+                lastPropertyEntry.getType().describe(),
                 Strings.join( getElementNames(), "." )
             );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/DefaultModelElementProcessorContext.java
Patch:
@@ -59,7 +59,8 @@ public DefaultModelElementProcessorContext(ProcessingEnvironment processingEnvir
             delegatingTypes,
             messager,
             roundContext,
-            notToBeImported
+            notToBeImported,
+            options.isVerbose()
         );
         this.options = options;
     }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -110,7 +110,8 @@ public Mapper process(ProcessorContext context, TypeElement mapperTypeElement, L
                 typeUtils,
                 typeFactory,
                 new ArrayList<>( sourceModel ),
-                mapperReferences
+                mapperReferences,
+                options.isVerbose()
             ),
             mapperTypeElement,
             //sourceModel is passed only to fetch the after/before mapping methods in lifecycleCallbackFactory;
@@ -325,7 +326,6 @@ else if ( method.isMapMapping() ) {
                     .keySelectionParameters( keySelectionParameters )
                     .valueFormattingParameters( valueFormattingParameters )
                     .valueSelectionParameters( valueSelectionParameters )
-                    .nullValueMappingStrategy( nullValueMappingStrategy )
                     .build();
 
                 hasFactoryMethod = mapMappingMethod.getFactoryMethod() != null;

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -77,8 +77,8 @@ public enum Message {
     CONVERSION_LOSSY_WARNING( "%s has a possibly lossy conversion from %s to %s.", Diagnostic.Kind.WARNING ),
     CONVERSION_LOSSY_ERROR( "Can't map %s. It has a possibly lossy conversion from %s to %s." ),
 
-    CONSTANTMAPPING_MAPPING_NOT_FOUND( "Can't map \"%s %s\" to \"%s %s\"." ),
-    CONSTANTMAPPING_MAPPING_NOT_FOUND_WITH_DETAILS( "Can't map \"%s %s\" to \"%s %s\". Reason: %s." ),
+    CONSTANTMAPPING_MAPPING_NOT_FOUND( "Can't map %s to \"%s %s\"." ),
+    CONSTANTMAPPING_MAPPING_NOT_FOUND_WITH_DETAILS( "Can't map %s to \"%s %s\". Reason: %s." ),
     CONSTANTMAPPING_NO_READ_ACCESSOR_FOR_TARGET_TYPE( "No read accessor found for property \"%s\" in target type." ),
     CONSTANTMAPPING_NON_EXISTING_CONSTANT( "Constant %s doesn't exist in enum type %s for property \"%s\"." ),
 

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DateFormatValidatorFactoryTest.java
Patch:
@@ -177,7 +177,8 @@ private Type typeWithFQN(String fullQualifiedName) {
             new HashMap<>(  ),
             new HashMap<>(  ),
                         false,
-                        false);
+                        false, false
+        );
     }
 
 }

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DefaultConversionContextTest.java
Patch:
@@ -125,7 +125,8 @@ private Type typeWithFQN(String fullQualifiedName) {
             new HashMap<>(  ),
             new HashMap<>(  ),
                         false,
-                        false);
+                        false, false
+        );
     }
 
     private static class StatefulMessagerMock implements FormattingMessager {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1029/Issue1029Test.java
Patch:
@@ -33,8 +33,8 @@ public class Issue1029Test {
         @Diagnostic(kind = Kind.WARNING, line = 37, type = ErroneousIssue1029Mapper.class,
             message = "Unmapped target property: \"lastUpdated\"."),
         @Diagnostic(kind = Kind.ERROR, line = 42, type = ErroneousIssue1029Mapper.class,
-            message = "Unknown property \"unknownProp\" in result type " +
-                "org.mapstruct.ap.test.bugs._1029.ErroneousIssue1029Mapper.Deck. Did you mean \"knownProp\"?")
+            message = "Unknown property \"unknownProp\" in result type ErroneousIssue1029Mapper.Deck. " +
+                "Did you mean \"knownProp\"?")
     })
     public void reportsProperWarningsAndError() {
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1283/Issue1283Test.java
Patch:
@@ -33,7 +33,7 @@ public class Issue1283Test {
             @Diagnostic(type = ErroneousInverseTargetHasNoSuitableConstructorMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 22L,
-                message = "org.mapstruct.ap.test.bugs._1283.Source does not have an accessible constructor."
+                message = "Source does not have an accessible constructor."
             )
         }
     )
@@ -48,7 +48,7 @@ public void inheritInverseConfigurationReturnTypeHasNoSuitableConstructor() {
             @Diagnostic(type = ErroneousTargetHasNoSuitableConstructorMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 18L,
-                message = "org.mapstruct.ap.test.bugs._1283.Source does not have an accessible constructor."
+                message = "Source does not have an accessible constructor."
             )
         }
     )

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1698/Issue1698Test.java
Patch:
@@ -24,9 +24,8 @@ public class Issue1698Test {
         diagnostics = {
             @Diagnostic(type = Erroneous1698Mapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                message = "Can't map property \"java.lang.String rabbit\" to \"org.mapstruct.ap.test.bugs._1698" +
-                    ".Erroneous1698Mapper.Rabbit rabbit\". Consider to declare/implement a mapping method: \"org" +
-                    ".mapstruct.ap.test.bugs._1698.Erroneous1698Mapper.Rabbit map(java.lang.String value)\".")
+                message = "Can't map property \"String rabbit\" to \"Erroneous1698Mapper.Rabbit rabbit\". " +
+                    "Consider to declare/implement a mapping method: \"Erroneous1698Mapper.Rabbit map(String value)\".")
         })
 
     public void testErrorMessage() {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_590/Issue590Test.java
Patch:
@@ -27,9 +27,8 @@ public class Issue590Test {
         diagnostics = {
             @Diagnostic(type = ErroneousSourceTargetMapper.class,
                 kind = Kind.ERROR,
-                message = "Can't map property \"java.lang.String prop\" to \"java.util.logging.XMLFormatter " +
-                    "prop\". Consider to declare/implement a mapping method: \"java.util.logging.XMLFormatter map" +
-                    "(java.lang.String value)\".")
+                message = "Can't map property \"String prop\" to \"XMLFormatter prop\". " +
+                    "Consider to declare/implement a mapping method: \"XMLFormatter map(String value)\".")
         })
     public void showsCantMapPropertyError() {
 

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/attributereference/ErroneousMappingsTest.java
Patch:
@@ -43,8 +43,7 @@ public class ErroneousMappingsTest {
             @Diagnostic(type = ErroneousMapper.class,
                 kind = Kind.ERROR,
                 line = 18,
-                message = "Unknown property \"bar\" in result type " +
-                    "org.mapstruct.ap.test.erroneous.attributereference.Target. Did you mean \"foo\"?"),
+                message = "Unknown property \"bar\" in result type Target. Did you mean \"foo\"?"),
             @Diagnostic(type = ErroneousMapper.class,
                 kind = Kind.ERROR,
                 line = 23,

File: processor/src/test/java/org/mapstruct/ap/test/ignore/IgnorePropertyTest.java
Patch:
@@ -82,8 +82,7 @@ public void propertyIsIgnoredInReverseMappingWhenSourceIsAlsoSpecifiedICWIgnore(
             @Diagnostic(type = ErroneousTargetHasNoWriteAccessorMapper.class,
                 kind = Kind.ERROR,
                 line = 22,
-                message = "Property \"hasClaws\" has no write accessor in " +
-                    "org.mapstruct.ap.test.ignore.PreditorDto.")
+                message = "Property \"hasClaws\" has no write accessor in PreditorDto.")
         }
     )
     public void shouldGiveErrorOnMappingForReadOnlyProp() {

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/attribute/AttributeInheritanceTest.java
Patch:
@@ -44,8 +44,8 @@ public void shouldMapAttributeFromSuperType() {
             type = ErroneousTargetSourceMapper.class,
             kind = Kind.ERROR,
             line = 16,
-            message = "Can't map property \"java.lang.CharSequence foo\" to \"java.lang.String foo\". Consider to " +
-                "declare/implement a mapping method: \"java.lang.String map(java.lang.CharSequence value)\"."
+            message = "Can't map property \"CharSequence foo\" to \"String foo\". " +
+                "Consider to declare/implement a mapping method: \"String map(CharSequence value)\"."
         ))
     public void shouldReportErrorDueToUnmappableAttribute() {
     }

File: processor/src/test/java/org/mapstruct/ap/test/nestedsourceproperties/NestedSourcePropertiesTest.java
Patch:
@@ -171,8 +171,7 @@ public void shouldUseGetAsTargetAccessor() {
             @Diagnostic(type = ArtistToChartEntryErroneous.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 34,
-                message = "org.mapstruct.ap.test.nestedsourceproperties.ArtistToChartEntryErroneous.ChartPosition " +
-                    "does not have an accessible constructor.")
+                message = "ArtistToChartEntryErroneous.ChartPosition does not have an accessible constructor.")
         }
     )
     @WithClasses({ ArtistToChartEntryErroneous.class })

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -486,7 +486,7 @@ else if ( applicableReversePrototypeMethods.size() > 1 ) {
 
         // @BeanMapping( ignoreByDefault = true )
         if ( mappingOptions.getBeanMapping() != null && mappingOptions.getBeanMapping().isignoreByDefault() ) {
-            mappingOptions.applyIgnoreAll( method, typeFactory );
+            mappingOptions.applyIgnoreAll( method, typeFactory, mappingContext.getMessager() );
         }
 
         mappingOptions.markAsFullyInitialized();

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -39,6 +39,7 @@ public enum Message {
     BEANMAPPING_UNMAPPED_SOURCES_ERROR( "Unmapped source %s." ),
     BEANMAPPING_CYCLE_BETWEEN_PROPERTIES( "Cycle(s) between properties given via dependsOn(): %s." ),
     BEANMAPPING_UNKNOWN_PROPERTY_IN_DEPENDS_ON( "\"%s\" is no property of the method return type." ),
+    BEANMAPPING_IGNORE_BY_DEFAULT_WITH_MAPPING_TARGET_THIS( "Using @BeanMapping( ignoreByDefault = true ) with @Mapping( target = \".\", ... ) is not allowed. You'll need to explicitly ignore the target properties that should be ignored instead." ),
 
     PROPERTYMAPPING_MAPPING_NOTE( "mapping property: %s to: %s.", Diagnostic.Kind.NOTE ),
     PROPERTYMAPPING_CREATE_NOTE( "creating property mapping: %s.", Diagnostic.Kind.NOTE ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/XmlElementDeclSelector.java
Patch:
@@ -69,7 +69,7 @@ public <T extends Method> List<SelectedMethod<T>> getMatchingMethods(Method mapp
             }
 
             String name = xmlElementDecl.name().get();
-            TypeMirror scope = xmlElementDecl.scope().get();
+            TypeMirror scope = xmlElementDecl.scope().getValue();
 
             boolean nameIsSetAndMatches = name != null && name.equals( xmlElementRefInfo.nameValue() );
             boolean scopeIsSetAndMatches =

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/exclusions/custom/Source.java
Patch:
@@ -39,4 +39,4 @@ public void setNested(NestedSource nested) {
     }
     // tag::documentation[]
 }
-// tag::documentation[]
+// end::documentation[]

File: processor/src/main/java/org/mapstruct/ap/internal/gem/GemGenerator.java
Patch:
@@ -14,6 +14,7 @@
 import org.mapstruct.Builder;
 import org.mapstruct.Context;
 import org.mapstruct.DecoratedWith;
+import org.mapstruct.EnumMapping;
 import org.mapstruct.InheritConfiguration;
 import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.IterableMapping;
@@ -43,6 +44,7 @@
 @GemDefinition(Mappings.class)
 @GemDefinition(IterableMapping.class)
 @GemDefinition(BeanMapping.class)
+@GemDefinition(EnumMapping.class)
 @GemDefinition(MapMapping.class)
 @GemDefinition(TargetType.class)
 @GemDefinition(MappingTarget.class)

File: processor/src/main/java/org/mapstruct/ap/internal/model/AbstractBaseBuilder.java
Patch:
@@ -86,6 +86,7 @@ Assignment createForgedAssignment(SourceRHS sourceRHS, BuilderType builderType,
             forgedMappingMethod = new ValueMappingMethod.Builder()
                 .method( forgedMethod )
                 .valueMappings( forgedMethod.getOptions().getValueMappings() )
+                .enumMapping( forgedMethod.getOptions().getEnumMappingOptions() )
                 .mappingContext( ctx )
                 .build();
         }

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -100,6 +100,7 @@ public enum Message {
     ENUMMAPPING_UNDEFINED_TARGET( "A target constant must be specified for mappings of an enum mapping method." ),
     ENUMMAPPING_UNMAPPED_SOURCES( "The following constants from the source enum have no corresponding constant in the target enum and must be be mapped via adding additional mappings: %s." ),
     ENUMMAPPING_REMOVED( "Mapping of Enums via @Mapping is removed. Please use @ValueMapping instead!" ),
+    ENUMMAPPING_INCORRECT_TRANSFORMATION_STRATEGY( "There is no registered EnumTransformationStrategy for '%s'. Registered strategies are: %s." ),
 
     LIFECYCLEMETHOD_AMBIGUOUS_PARAMETERS( "Lifecycle method has multiple matching parameters (e. g. same type), in this case please ensure to name the parameters in the lifecycle and mapping method identical. This lifecycle method will not be used for the mapping method '%s'.", Diagnostic.Kind.WARNING),
 

File: processor/src/test/java/org/mapstruct/ap/test/value/enum2string/OrderMapper.java
Patch:
@@ -5,6 +5,7 @@
  */
 package org.mapstruct.ap.test.value.enum2string;
 
+import org.mapstruct.EnumMapping;
 import org.mapstruct.Mapper;
 import org.mapstruct.MappingConstants;
 import org.mapstruct.ValueMapping;
@@ -27,6 +28,7 @@ public interface OrderMapper {
     })
     String mapNormal(OrderType orderType);
 
+    @EnumMapping(nameTransformationStrategy = "prefix", configuration = "PREFIX_")
     @ValueMappings({
         @ValueMapping( source = MappingConstants.NULL, target = "DEFAULT" ),
         @ValueMapping( source = "STANDARD", target = MappingConstants.NULL ),

File: integrationtest/src/test/java/org/mapstruct/itest/testutil/extension/ProcessorInvocationInterceptor.java
Patch:
@@ -71,6 +71,9 @@ private void doExecute(ExtensionContext extensionContext) throws Exception {
         }
         else {
             verifier = new Verifier( destination.getCanonicalPath() );
+            if ( processorTestContext.isForkJvm() ) {
+                verifier.setForkJvm( true );
+            }
         }
 
         List<String> goals = new ArrayList<>( 3 );

File: integrationtest/src/test/java/org/mapstruct/itest/testutil/extension/ProcessorTest.java
Patch:
@@ -106,4 +106,7 @@ ProcessorType[] processorTypes() default {
      * @return the {@link CommandLineEnhancer} implementation. Must have a default constructor.
      */
     Class<? extends CommandLineEnhancer> commandLineEnhancer() default CommandLineEnhancer.class;
+
+    boolean forkJvm() default false;
+
 }

File: integrationtest/src/test/java/org/mapstruct/itest/testutil/extension/ProcessorTestTemplateInvocationContextProvider.java
Patch:
@@ -34,7 +34,8 @@ public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContex
             .map( processorType -> new ProcessorTestTemplateInvocationContext( new ProcessorTestContext(
                 processorTest.baseDir(),
                 processorType,
-                processorTest.commandLineEnhancer()
+                processorTest.commandLineEnhancer(),
+                processorTest.forkJvm()
             ) ) );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/NormalTypeMappingMethod.java
Patch:
@@ -42,6 +42,9 @@ public Set<Type> getImportTypes() {
                 types.addAll( getReturnType().getImplementationType().getImportTypes() );
             }
         }
+        else if ( factoryMethod != null ) {
+            types.addAll( factoryMethod.getImportTypes() );
+        }
         return types;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -110,12 +110,14 @@ public enum Message {
     GENERAL_ABSTRACT_RETURN_TYPE( "The return type %s is an abstract class or interface. Provide a non abstract / non interface result type or a factory method." ),
     GENERAL_AMBIGIOUS_MAPPING_METHOD( "Ambiguous mapping methods found for mapping %s to %s: %s." ),
     GENERAL_AMBIGIOUS_FACTORY_METHOD( "Ambiguous factory methods found for creating %s: %s." ),
+    GENERAL_AMBIGIOUS_CONSTRUCTORS( "Ambiguous constructors found for creating %s. Either declare parameterless constructor or annotate the default constructor with an annotation named @Default." ),
+    GENERAL_CONSTRUCTOR_PROPERTIES_NOT_MATCHING_PARAMETERS( "Incorrect @ConstructorProperties for %s. The size of the @ConstructorProperties does not match the number of constructor parameters" ),
     GENERAL_UNSUPPORTED_DATE_FORMAT_CHECK( "No dateFormat check is supported for types %s, %s" ),
     GENERAL_VALID_DATE( "Given date format \"%s\" is valid.", Diagnostic.Kind.NOTE ),
     GENERAL_INVALID_DATE( "Given date format \"%s\" is invalid. Message: \"%s\"." ),
     GENERAL_JODA_NOT_ON_CLASSPATH( "Cannot validate Joda dateformat, no Joda on classpath. Consider adding Joda to the annotation processorpath.", Diagnostic.Kind.WARNING ),
     GENERAL_NOT_ALL_FORGED_CREATED( "Internal Error in creation of Forged Methods, it was expected all Forged Methods to finished with creation, but %s did not" ),
-    GENERAL_NO_SUITABLE_CONSTRUCTOR( "%s does not have an accessible parameterless constructor." ),
+    GENERAL_NO_SUITABLE_CONSTRUCTOR( "%s does not have an accessible constructor." ),
     GENERAL_NO_QUALIFYING_METHOD( "No qualifying method found for qualifiers: %s and / or qualifying names: %s" ),
 
     BUILDER_MORE_THAN_ONE_BUILDER_CREATION_METHOD( "More than one builder creation method for \"%s\". Found methods: \"%s\". Builder will not be used. Consider implementing a custom BuilderProvider SPI.", Diagnostic.Kind.WARNING ),

File: processor/src/main/java/org/mapstruct/ap/internal/util/ValueProvider.java
Patch:
@@ -6,7 +6,6 @@
 package org.mapstruct.ap.internal.util;
 
 import org.mapstruct.ap.internal.util.accessor.Accessor;
-import org.mapstruct.ap.internal.util.accessor.AccessorType;
 
 /**
  * This a wrapper class which provides the value that needs to be used in the models.
@@ -46,7 +45,7 @@ public static ValueProvider of(Accessor accessor) {
             return null;
         }
         String value = accessor.getSimpleName();
-        if ( accessor.getAccessorType() != AccessorType.FIELD ) {
+        if ( !accessor.getAccessorType().isFieldAssignment() ) {
             value += "()";
         }
         return new ValueProvider( value );

File: processor/src/main/java/org/mapstruct/ap/internal/util/accessor/Accessor.java
Patch:
@@ -8,9 +8,8 @@
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/util/accessor/FieldElementAccessor.java
Patch:
@@ -13,9 +13,9 @@
  *
  * @author Filip Hrisafov
  */
-public class VariableElementAccessor extends AbstractAccessor<VariableElement> {
+public class FieldElementAccessor extends AbstractAccessor<VariableElement> {
 
-    public VariableElementAccessor(VariableElement element) {
+    public FieldElementAccessor(VariableElement element) {
         super( element );
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1283/Source.java
Patch:
@@ -12,7 +12,7 @@ public class Source {
 
     private String source;
 
-    public Source(String source) {
+    private Source(String source) {
         this.source = source;
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/UpdateMethodsTest.java
Patch:
@@ -175,8 +175,8 @@ public void testShouldFailOnPropertyMappingNoPropertyGetter() { }
             @Diagnostic(type = ErroneousOrganizationMapper2.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 35,
-                message = "org.mapstruct.ap.test.updatemethods.DepartmentEntity does not have an accessible " +
-                    "parameterless constructor.")
+                message = "org.mapstruct.ap.test.updatemethods.ErroneousOrganizationMapper2.DepartmentEntity does not" +
+                    " have an accessible constructor.")
 
         })
     public void testShouldFailOnConstantMappingNoPropertyGetter() {

File: processor/src/main/java/org/mapstruct/ap/internal/processor/DefaultModelElementProcessorContext.java
Patch:
@@ -167,6 +167,7 @@ public void note( int level, Message msg, Object... args ) {
             }
         }
 
+        @Override
         public boolean isErroneous() {
             return isErroneous;
         }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -368,10 +368,10 @@ else if ( method.isStreamMapping() ) {
                     .returnTypeBuilder( typeFactory.builderTypeFor( method.getReturnType(), builder ) )
                     .build();
 
+                // We can consider that the bean mapping method can always be constructed. If there is a problem
+                // it would have been reported in its build
+                hasFactoryMethod = true;
                 if ( beanMappingMethod != null ) {
-                    // We can consider that the bean mapping method can always be constructed. If there is a problem
-                    // it would have been reported in its build
-                    hasFactoryMethod = true;
                     mappingMethods.add( beanMappingMethod );
                 }
             }

File: processor/src/main/java/org/mapstruct/ap/internal/util/FormattingMessager.java
Patch:
@@ -75,4 +75,6 @@ void printMessage(Element e,
      * @param args the arguments
      */
     void note(int level, Message log, Object... args);
+
+    boolean isErroneous();
 }

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -23,7 +23,9 @@ public enum Message {
     BEANMAPPING_NOT_ASSIGNABLE( "%s not assignable to: %s." ),
     BEANMAPPING_ABSTRACT( "The result type %s may not be an abstract class nor interface." ),
     BEANMAPPING_UNKNOWN_PROPERTY_IN_RESULTTYPE( "Unknown property \"%s\" in result type %s. Did you mean \"%s\"?" ),
+    BEANMAPPING_UNKNOWN_PROPERTY_IN_TYPE( "Unknown property \"%s\" in type %s for target name \"%s\". Did you mean \"%s\"?" ),
     BEANMAPPING_PROPERTY_HAS_NO_WRITE_ACCESSOR_IN_RESULTTYPE( "Property \"%s\" has no write accessor in %s." ),
+    BEANMAPPING_PROPERTY_HAS_NO_WRITE_ACCESSOR_IN_TYPE( "Property \"%s\" has no write accessor in %s for target name \"%s\"." ),
     BEANMAPPING_SEVERAL_POSSIBLE_SOURCES( "Several possible source properties for target property \"%s\"." ),
     BEANMAPPING_SEVERAL_POSSIBLE_TARGET_ACCESSORS( "Found several matching getters for property \"%s\"." ),
     BEANMAPPING_UNMAPPED_TARGETS_WARNING( "Unmapped target %s.", Diagnostic.Kind.WARNING ),

File: integrationtest/src/test/java/org/mapstruct/itest/tests/MavenIntegrationTest.java
Patch:
@@ -36,8 +36,7 @@ void externalBeanJarTest() {
     }
 
     @ProcessorTest(baseDir = "freeBuilderBuilderTest", processorTypes = {
-        ProcessorTest.ProcessorType.JAVAC,
-        ProcessorTest.ProcessorType.ECLIPSE_JDT
+        ProcessorTest.ProcessorType.JAVAC
     })
     void freeBuilderBuilderTest() {
     }

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/Compiler.java
Patch:
@@ -10,5 +10,5 @@
  *
  */
 public enum Compiler {
-    JDK, JDK11, ECLIPSE;
+    JDK, JDK11, ECLIPSE, ECLIPSE11;
 }

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/DisabledOnCompiler.java
Patch:
@@ -22,5 +22,5 @@
     /**
      * @return The compiler to use.
      */
-    Compiler value();
+    Compiler[] value();
 }

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/EnabledOnCompiler.java
Patch:
@@ -22,5 +22,5 @@
     /**
      * @return The compiler to use.
      */
-    Compiler value();
+    Compiler[] value();
 }

File: integrationtest/src/test/java/org/mapstruct/itest/testutil/extension/ProcessorInvocationInterceptor.java
Patch:
@@ -187,8 +187,8 @@ private String sourceTargetVersion() {
         }
         else if ( CURRENT_VERSION == JRE.OTHER ) {
             try {
-                // Extracting the major version is done with code from 
-                // org.junit.jupiter.api.condition.JRE when determing the current version
+                // Extracting the major version is done with code from
+                // org.junit.jupiter.api.condition.JRE when determining the current version
 
                 // java.lang.Runtime.version() is a static method available on Java 9+
                 // that returns an instance of java.lang.Runtime.Version which has the

File: integrationtest/src/test/resources/lombokBuilderTest/src/main/java/org/mapstruct/itest/lombok/Person.java
Patch:
@@ -8,9 +8,7 @@
 import lombok.Builder;
 import lombok.Getter;
 
-//TODO make MapStruct DefaultBuilderProvider work with custom builder name
-//@Builder(builderMethodName = "foo", buildMethodName = "create", builderClassName = "Builder")
-@Builder(builderClassName = "Builder")
+@Builder(builderMethodName = "foo", buildMethodName = "create", builderClassName = "Builder")
 @Getter
 public class Person {
     private final String name;

File: integrationtest/src/test/resources/lombokBuilderTest/src/test/java/org/mapstruct/itest/lombok/LombokMapperTest.java
Patch:
@@ -19,13 +19,13 @@ public class LombokMapperTest {
 
     @Test
     public void testSimpleImmutableBuilderHappyPath() {
-        PersonDto personDto = PersonMapper.INSTANCE.toDto( Person.builder()
+        PersonDto personDto = PersonMapper.INSTANCE.toDto( Person.foo()
             .age( 33 )
             .name( "Bob" )
             .address( Address.builder()
                 .addressLine( "Wild Drive" )
                 .build() )
-            .build() );
+            .create() );
         assertThat( personDto.getAge() ).isEqualTo( 33 );
         assertThat( personDto.getName() ).isEqualTo( "Bob" );
         assertThat( personDto.getAddress() ).isNotNull();

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/CarMapper.java
Patch:
@@ -39,7 +39,6 @@ public interface CarMapper {
     @BeanMapping(nullValueMappingStrategy = RETURN_DEFAULT)
     @Mappings({
         @Mapping(target = "seatCount", source = "car.numberOfSeats"),
-        @Mapping(target = "model", source = "model"), // TODO,  should not be needed, must be made based on name only
         @Mapping(target = "catalogId", expression = "java( UUID.randomUUID().toString() )")
     })
     CarDto carToCarDto(Car car, String model);

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/NullValueMappingTest.java
Patch:
@@ -83,6 +83,7 @@ public void shouldMapExpressionAndConstantRegardlessNullArgSeveralSources() {
         //then
         assertThat( carDto1 ).isNotNull();
         assertThat( carDto1.getMake() ).isEqualTo( car.getMake() );
+        assertThat( carDto1.getModel() ).isEqualTo( "ModelT" );
         assertThat( carDto1.getSeatCount() ).isEqualTo( car.getNumberOfSeats() );
         assertThat( carDto1.getCatalogId() ).isNotEmpty();
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/ObjectFactoryMethodResolver.java
Patch:
@@ -76,7 +76,7 @@ public static MethodReference getFactoryMethod( Method method,
             selectors.getMatchingMethods(
                 method,
                 getAllAvailableMethods( method, ctx.getSourceModel() ),
-                java.util.Collections.<Type> emptyList(),
+                java.util.Collections.emptyList(),
                 alternativeTarget,
                 SelectionCriteria.forFactoryMethods( selectionParameters ) );
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/ParameterProvidedMethods.java
Patch:
@@ -23,7 +23,7 @@
  */
 public class ParameterProvidedMethods {
     private static final ParameterProvidedMethods EMPTY =
-        new ParameterProvidedMethods( Collections.<Parameter, List<SourceMethod>> emptyMap() );
+        new ParameterProvidedMethods( Collections.emptyMap() );
 
     private final Map<Parameter, List<SourceMethod>> parameterToProvidedMethods;
     private final Map<SourceMethod, Parameter> methodToProvidingParameter;

File: processor/src/main/java/org/mapstruct/ap/internal/util/workarounds/EclipseAsMemberOfWorkaround.java
Patch:
@@ -6,7 +6,6 @@
 package org.mapstruct.ap.internal.util.workarounds;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
@@ -73,7 +72,7 @@ static TypeMirror asMemberOf(ProcessingEnvironment environment, DeclaredType con
             candidatesFromInterfaces );
 
         // there can be multiple matches for the same method name from adjacent interface hierarchies.
-        Collections.sort( candidatesFromInterfaces, MostSpecificMethodBindingComparator.INSTANCE );
+        candidatesFromInterfaces.sort( MostSpecificMethodBindingComparator.INSTANCE );
 
         if ( !candidatesFromInterfaces.isEmpty() ) {
             // return the most specific match

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/BeanMapping.java
Patch:
@@ -55,7 +55,7 @@ public static BeanMapping forInheritance(BeanMapping beanMapping) {
             beanMapping.nullValuePropertyMappingStrategy,
             beanMapping.nullValueCheckStrategy,
             beanMapping.reportingPolicy,
-            false,
+            beanMapping.ignoreByDefault,
             beanMapping.ignoreUnmappedSourceProperties,
             beanMapping.builder,
             beanMapping.mirror

File: processor/src/test/java/org/mapstruct/ap/test/builder/ignore/BuilderIgnoringMapper.java
Patch:
@@ -20,6 +20,7 @@ public interface BuilderIgnoringMapper {
     BuilderIgnoringMapper INSTANCE = Mappers.getMapper( BuilderIgnoringMapper.class );
 
     @InheritConfiguration(name = "mapBase")
+    @Mapping( target = "lastName" )
     Person mapWithIgnoringBase(PersonDto source);
 
     @BeanMapping(ignoreByDefault = true)

File: processor/src/test/java/org/mapstruct/ap/test/builder/ignore/BuilderIgnoringTest.java
Patch:
@@ -29,6 +29,7 @@
 public class BuilderIgnoringTest {
 
     @Test
+    @IssueKey( "1933" )
     public void shouldIgnoreBase() {
         PersonDto source = new PersonDto();
         source.setId( 100L );
@@ -38,7 +39,7 @@ public void shouldIgnoreBase() {
         Person target = BuilderIgnoringMapper.INSTANCE.mapWithIgnoringBase( source );
 
         assertThat( target.getId() ).isNull();
-        assertThat( target.getName() ).isEqualTo( "John" );
+        assertThat( target.getName() ).isNull();
         assertThat( target.getLastName() ).isEqualTo( "Doe" );
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/ignore/inherit/IgnorePropertyTest.java
Patch:
@@ -55,7 +55,7 @@ public void shouldIgnoreAllExeptOveriddenInherited() {
     }
 
     @Test
-    @IssueKey("1392")
+    @IssueKey("1933")
     public void shouldIgnoreBase() {
 
         WorkBenchDto workBenchDto = new WorkBenchDto();
@@ -67,7 +67,7 @@ public void shouldIgnoreBase() {
         WorkBenchEntity benchTarget = ToolMapper.INSTANCE.mapBench( workBenchDto );
 
         assertThat( benchTarget ).isNotNull();
-        assertThat( benchTarget.getArticleName() ).isEqualTo( "MyBench" );
+        assertThat( benchTarget.getArticleName() ).isNull();
         assertThat( benchTarget.getDescription() ).isEqualTo( "Beautiful" );
         assertThat( benchTarget.getKey() ).isNull();
         assertThat( benchTarget.getModificationDate() ).isNull();

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/AnnotationProcessorTestRunner.java
Patch:
@@ -130,10 +130,10 @@ public String describe() {
         }
 
         private Description withoutParameterizedName(Description description) {
-            String cleanDispayName = removeParameter( description.getDisplayName() );
+            String cleanDisplayName = removeParameter( description.getDisplayName() );
             Description cleanDescription =
                 Description.createSuiteDescription(
-                    cleanDispayName,
+                    cleanDisplayName,
                     description.getAnnotations().toArray( new Annotation[description.getAnnotations().size()] ) );
 
             for ( Description child : description.getChildren() ) {

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/FilteringParentClassLoader.java
Patch:
@@ -22,7 +22,7 @@ final class FilteringParentClassLoader extends ClassLoader {
      * @param excludedPrefixes class name prefixes to exclude
      */
     FilteringParentClassLoader(String... excludedPrefixes) {
-        this.excludedPrefixes = new ArrayList<String>( Arrays.asList( excludedPrefixes ) );
+        this.excludedPrefixes = new ArrayList<>( Arrays.asList( excludedPrefixes ) );
     }
 
     /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/AbstractMappingMethodBuilder.java
Patch:
@@ -58,7 +58,7 @@ Assignment forgeMapping(SourceRHS sourceRHS, Type sourceType, Type targetType) {
         return createForgedAssignment(
                         sourceRHS,
                         ctx.getTypeFactory()
-                           .builderTypeFor( targetType, BeanMapping.builderPrismFor( method ).orElse( null ) ),
+                           .builderTypeFor( targetType, BeanMapping.builderPrismFor( method ) ),
                         forgedMethod
         );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/beanmapping/TargetReference.java
Patch:
@@ -203,7 +203,7 @@ private List<PropertyEntry> getTargetEntries(Type type, String[] entryNames) {
                         );
                     }
                     else {
-                        BuilderPrism builderPrism = BeanMapping.builderPrismFor( method ).orElse( null );
+                        BuilderPrism builderPrism = BeanMapping.builderPrismFor( method );
                         builderType = typeFactory.builderTypeFor( nextType, builderPrism );
                         propertyEntry = PropertyEntry.forTargetReference( fullName,
                                         targetReadAccessor,
@@ -271,7 +271,7 @@ private Type typeBasedOnMethod(Type type) {
                 return type;
             }
             else {
-                BuilderPrism builderPrism = BeanMapping.builderPrismFor( method ).orElse( null );
+                BuilderPrism builderPrism = BeanMapping.builderPrismFor( method );
                 return typeFactory.effectiveResultTypeFor( type, builderPrism );
             }
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/BeanMapping.java
Patch:
@@ -213,9 +213,9 @@ public AnnotationMirror getMirror() {
     /**
      * derives the builder prism given the options and configuration
      * @param method containing mandatory configuration and the mapping options (optionally containing a beanmapping)
-     * @return a BuilderPrism as optional
+     * @return null if BuilderPrism not exist
      */
-    public static Optional<BuilderPrism> builderPrismFor(Method method) {
+    public static BuilderPrism builderPrismFor(Method method) {
         return method.getMapperConfiguration()
                      .getBuilderPrism( Optional.ofNullable( method.getMappingOptions().getBeanMapping() )
                                                .map( b -> b.builder )

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MappingOptions.java
Patch:
@@ -179,7 +179,7 @@ public void applyIgnoreAll(SourceMethod method, TypeFactory typeFactory ) {
         if ( !method.isUpdateMethod() ) {
             writeType = typeFactory.effectiveResultTypeFor(
                             writeType,
-                            BeanMapping.builderPrismFor( method ).orElse( null )
+                            BeanMapping.builderPrismFor( method )
             );
         }
         Map<String, Accessor> writeAccessors = writeType.getPropertyWriteAccessors( cms );

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -360,7 +360,7 @@ else if ( method.isStreamMapping() ) {
             }
             else {
                 this.messager.note( 1, Message.BEANMAPPING_CREATE_NOTE, method );
-                BuilderPrism builderPrism = BeanMapping.builderPrismFor( method ).orElse( null );
+                BuilderPrism builderPrism = BeanMapping.builderPrismFor( method );
                 BeanMappingMethod.Builder builder = new BeanMappingMethod.Builder();
                 BeanMappingMethod beanMappingMethod = builder
                     .mappingContext( mappingContext )

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/BuiltInMethod.java
Patch:
@@ -51,7 +51,7 @@ public String getName() {
      * @return the types used by this method for which import statements need to be generated
      */
     public Set<Type> getImportTypes() {
-        return Collections.<Type>emptySet();
+        return Collections.emptySet();
     }
 
     /**

File: processor/src/main/java/org/mapstruct/ap/MappingProcessor.java
Patch:
@@ -83,6 +83,7 @@
     MappingProcessor.SUPPRESS_GENERATOR_VERSION_INFO_COMMENT,
     MappingProcessor.UNMAPPED_TARGET_POLICY,
     MappingProcessor.DEFAULT_COMPONENT_MODEL,
+    MappingProcessor.DEFAULT_INJECTION_STRATEGY,
     MappingProcessor.VERBOSE
 })
 public class MappingProcessor extends AbstractProcessor {
@@ -97,6 +98,7 @@ public class MappingProcessor extends AbstractProcessor {
         "mapstruct.suppressGeneratorVersionInfoComment";
     protected static final String UNMAPPED_TARGET_POLICY = "mapstruct.unmappedTargetPolicy";
     protected static final String DEFAULT_COMPONENT_MODEL = "mapstruct.defaultComponentModel";
+    protected static final String DEFAULT_INJECTION_STRATEGY = "mapstruct.defaultInjectionStrategy";
     protected static final String ALWAYS_GENERATE_SERVICE_FILE = "mapstruct.alwaysGenerateServicesFile";
     protected static final String VERBOSE = "mapstruct.verbose";
 
@@ -136,6 +138,7 @@ private Options createOptions() {
             Boolean.valueOf( processingEnv.getOptions().get( SUPPRESS_GENERATOR_VERSION_INFO_COMMENT ) ),
             unmappedTargetPolicy != null ? ReportingPolicyPrism.valueOf( unmappedTargetPolicy.toUpperCase() ) : null,
             processingEnv.getOptions().get( DEFAULT_COMPONENT_MODEL ),
+            processingEnv.getOptions().get( DEFAULT_INJECTION_STRATEGY ),
             Boolean.valueOf( processingEnv.getOptions().get( ALWAYS_GENERATE_SERVICE_FILE ) ),
             Boolean.valueOf( processingEnv.getOptions().get( VERBOSE ) )
         );

File: processor/src/main/java/org/mapstruct/ap/internal/processor/AnnotationBasedComponentModelProcessor.java
Patch:
@@ -45,7 +45,7 @@ public Mapper process(ProcessorContext context, TypeElement mapperTypeElement, M
         MapperConfiguration mapperConfiguration = MapperConfiguration.getInstanceOn( mapperTypeElement );
 
         String componentModel = mapperConfiguration.componentModel( context.getOptions() );
-        InjectionStrategyPrism injectionStrategy = mapperConfiguration.getInjectionStrategy();
+        InjectionStrategyPrism injectionStrategy = mapperConfiguration.getInjectionStrategy( context.getOptions() );
 
         if ( !getComponentModelIdentifier().equalsIgnoreCase( componentModel ) ) {
             return mapper;

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/ValueMapping.java
Patch:
@@ -36,7 +36,7 @@ public static void fromMappingsPrism(ValueMappingsPrism mappingsAnnotation, Exec
 
         boolean anyFound = false;
         for ( ValueMappingPrism mappingPrism : mappingsAnnotation.value() ) {
-            ValueMapping mapping = fromMappingPrism( mappingPrism, method, messager );
+            ValueMapping mapping = fromMappingPrism( mappingPrism );
             if ( mapping != null ) {
 
                 if ( !mappings.contains( mapping ) ) {
@@ -68,8 +68,7 @@ public static void fromMappingsPrism(ValueMappingsPrism mappingsAnnotation, Exec
         }
     }
 
-    public static ValueMapping fromMappingPrism(ValueMappingPrism mappingPrism, ExecutableElement element,
-                                           FormattingMessager messager) {
+    public static ValueMapping fromMappingPrism( ValueMappingPrism mappingPrism ) {
 
         return new ValueMapping( mappingPrism.source(), mappingPrism.target(), mappingPrism.mirror,
             mappingPrism.values.source(), mappingPrism.values.target() );

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/MethodSelectors.java
Patch:
@@ -31,7 +31,7 @@ public MethodSelectors(Types typeUtils, Elements elementUtils, TypeFactory typeF
             new MethodFamilySelector(),
             new TypeSelector( typeFactory, messager ),
             new QualifierSelector( typeUtils, elementUtils ),
-            new TargetTypeSelector( typeUtils, elementUtils ),
+            new TargetTypeSelector( typeUtils ),
             new XmlElementDeclSelector( typeUtils ),
             new InheritanceSelector(),
             new CreateOrUpdateSelector(),

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/TargetTypeSelector.java
Patch:
@@ -9,7 +9,6 @@
 import java.util.List;
 
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import org.mapstruct.ap.internal.model.common.Type;
@@ -27,7 +26,7 @@ public class TargetTypeSelector implements MethodSelector {
 
     private final Types typeUtils;
 
-    public TargetTypeSelector( Types typeUtils, Elements elementUtils ) {
+    public TargetTypeSelector( Types typeUtils ) {
         this.typeUtils = typeUtils;
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/builder/lifecycle/Order.java
Patch:
@@ -17,7 +17,7 @@ public class Order {
     private final String creator;
 
     public Order(Builder builder) {
-        this.items = new ArrayList<Item>( builder.items );
+        this.items = new ArrayList<>( builder.items );
         this.creator = builder.creator;
     }
 
@@ -34,7 +34,7 @@ public static Builder builder() {
     }
 
     public static class Builder {
-        private List<Item> items = new ArrayList<Item>();
+        private List<Item> items = new ArrayList<>();
         private String creator;
 
         public Builder items(List<Item> items) {

File: processor/src/test/java/org/mapstruct/ap/test/callbacks/returning/Node.java
Patch:
@@ -25,8 +25,8 @@ public Node() {
 
     public Node(String name) {
         this.name = name;
-        this.children = new ArrayList<Node>();
-        this.attributes = new ArrayList<Attribute>();
+        this.children = new ArrayList<>();
+        this.attributes = new ArrayList<>();
     }
 
     public Node getParent() {

File: processor/src/test/java/org/mapstruct/ap/test/callbacks/returning/NodeMapperContext.java
Patch:
@@ -48,7 +48,7 @@ public static void setInstance(Object source, @MappingTarget Object target) {
         fireMethodCalled( level, "setInstance", source, target );
         if ( level == null ) {
             LEVEL.set( 1 );
-            MAPPING.set( new IdentityHashMap<Object, Object>() );
+            MAPPING.set( new IdentityHashMap<>() );
         }
         else {
             LEVEL.set( level + 1 );

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/Target.java
Patch:
@@ -24,15 +24,15 @@ public void setPets(List<Long> pets) {
     }
 
     public void addCat(Long cat) {
-        // dummy method to test selection mechanims
+        // dummy method to test selection mechanism
     }
 
     public void addDog(Long cat) {
-        // dummy method to test selection mechanims
+        // dummy method to test selection mechanism
     }
 
     public void addPets(Long cat) {
-        // dummy method to test selection mechanims
+        // dummy method to test selection mechanism
     }
 
     public Long addPet(Long pet) {

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/TargetOnlyGetter.java
Patch:
@@ -20,15 +20,15 @@ public List<Long> getPets() {
     }
 
     public void addCat(Long cat) {
-        // dummy method to test selection mechanims
+        // dummy method to test selection mechanism
     }
 
     public void addDog(Long cat) {
-        // dummy method to test selection mechanims
+        // dummy method to test selection mechanism
     }
 
     public void addPets(Long cat) {
-        // dummy method to test selection mechanims
+        // dummy method to test selection mechanism
     }
 
     public void addPet(Long pet) {

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/TargetWithAnimals.java
Patch:
@@ -13,7 +13,7 @@
  */
 public class TargetWithAnimals {
 
-    private List<String> animals = new ArrayList<String>();
+    private List<String> animals = new ArrayList<>();
 
     public List<String> getAnimals() {
         return animals;

File: processor/src/test/java/org/mapstruct/ap/test/context/CycleContext.java
Patch:
@@ -16,7 +16,7 @@
  * @author Andreas Gudian
  */
 public class CycleContext {
-    private Map<Object, Object> knownInstances = new IdentityHashMap<Object, Object>();
+    private Map<Object, Object> knownInstances = new IdentityHashMap<>();
 
     @SuppressWarnings("unchecked")
     public <T> T getMappedInstance(Object source, Class<T> targetType) {

File: processor/src/test/java/org/mapstruct/ap/test/conversion/currency/CurrencyConversionTest.java
Patch:
@@ -30,7 +30,7 @@ public class CurrencyConversionTest {
     public void shouldApplyCurrencyConversions() {
         final CurrencySource source = new CurrencySource();
         source.setCurrencyA( Currency.getInstance( "USD" ) );
-        Set<Currency> currencies = new HashSet<Currency>();
+        Set<Currency> currencies = new HashSet<>();
         currencies.add( Currency.getInstance( "EUR" ) );
         currencies.add( Currency.getInstance( "CHF" ) );
         source.setUniqueCurrencies( currencies );

File: processor/src/test/java/org/mapstruct/ap/test/conversion/lossy/LossyConversionTest.java
Patch:
@@ -61,7 +61,7 @@ public void testNoErrorCase() {
                 messageRegExp = "Can't map property \"long numberOfForks\". It has a possibly lossy conversion from "
                     + "long to int.")
         })
-    public void testConversionFromlongToint() {
+    public void testConversionFromLongToInt() {
     }
 
     @Test
@@ -100,7 +100,7 @@ public void test2StepConversionFromBigIntegerToLong() {
                 messageRegExp = "Can't map property \"java.lang.Double depth\". It has a possibly lossy conversion "
                     + "from java.lang.Double to float.")
         })
-    public void testConversionFromDoubleTofloat() {
+    public void testConversionFromDoubleToFloat() {
     }
 
     @Test
@@ -125,7 +125,7 @@ public void testConversionFromBigDecimalToFloat() {
                 line = 24,
                 messageRegExp = "property \"double height\" has a possibly lossy conversion from double to float.")
         })
-    public void test2StepConversionFromdoubleTofloat() {
+    public void test2StepConversionFromDoubleToFloat() {
     }
 
     @Test

File: processor/src/test/java/org/mapstruct/ap/test/conversion/lossy/VerySpecialNumberMapper.java
Patch:
@@ -8,16 +8,15 @@
 import java.math.BigInteger;
 
 /**
- *
  * @author Sjaak Derksen
  */
 public class VerySpecialNumberMapper {
 
-    VerySpecialNumber fromFLoat( float f ) {
+    VerySpecialNumber fromFloat(float f) {
         return new VerySpecialNumber();
     }
 
-    BigInteger toBigInteger( VerySpecialNumber v ) {
+    BigInteger toBigInteger(VerySpecialNumber v) {
         return new BigInteger( "10" );
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/nativetypes/BooleanConversionTest.java
Patch:
@@ -49,7 +49,7 @@ public void shouldApplyReverseBooleanConversion() {
 
     @Test
     @IssueKey( "229" )
-    public void wrapperToPrimitveIsNullSafe() {
+    public void wrapperToPrimitiveIsNullSafe() {
         BooleanTarget target = new BooleanTarget();
 
         BooleanSource source = BooleanMapper.INSTANCE.targetToSource( target );

File: processor/src/test/java/org/mapstruct/ap/test/conversion/nativetypes/CharConversionTest.java
Patch:
@@ -45,7 +45,7 @@ public void shouldApplyReverseCharConversion() {
 
     @Test
     @IssueKey( "229" )
-    public void wrapperToPrimitveIsNullSafe() {
+    public void wrapperToPrimitiveIsNullSafe() {
         CharTarget target = new CharTarget();
 
         CharSource source = CharMapper.INSTANCE.targetToSource( target );

File: processor/src/test/java/org/mapstruct/ap/test/conversion/nativetypes/NumberConversionTest.java
Patch:
@@ -441,7 +441,7 @@ public void shouldApplyDoubleWrapperConversions() {
 
     @Test
     @IssueKey( "229" )
-    public void wrapperToPrimitveIsNullSafe() {
+    public void wrapperToPrimitiveIsNullSafe() {
         assertThat( SourceTargetMapper.INSTANCE.sourceToTarget( new ByteWrapperSource() ) ).isNotNull();
         assertThat( SourceTargetMapper.INSTANCE.sourceToTarget( new DoubleWrapperSource() ) ).isNotNull();
         assertThat( SourceTargetMapper.INSTANCE.sourceToTarget( new ShortWrapperSource() ) ).isNotNull();

File: processor/src/test/java/org/mapstruct/ap/test/conversion/numbers/NumberFormatConversionTest.java
Patch:
@@ -133,7 +133,7 @@ public void shouldApplyStringConversionsToIterables() {
     @Test
     public void shouldApplyStringConversionsToMaps() {
 
-        Map<Float, Float> source1 = new HashMap<Float, Float>();
+        Map<Float, Float> source1 = new HashMap<>();
         source1.put( 1.0001f, 2.01f );
 
         Map<String, String> target = SourceTargetMapper.INSTANCE.sourceToTarget( source1 );

File: processor/src/test/java/org/mapstruct/ap/test/dependency/OrderingTest.java
Patch:
@@ -84,6 +84,6 @@ public void shouldReportErrorIfDependenciesContainCycle() {
             )
         }
     )
-    public void shouldReportErrorIfPropertiyGivenInDependsOnDoesNotExist() {
+    public void shouldReportErrorIfPropertyGivenInDependsOnDoesNotExist() {
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/factories/SourceTargetMapperAndBar2Factory.java
Patch:
@@ -40,10 +40,10 @@ public Bar2 createBar2() {
     }
 
     public CustomList<String> createCustomList() {
-        return new CustomListImpl<String>( "CUSTOMLIST" );
+        return new CustomListImpl<>( "CUSTOMLIST" );
     }
 
     public CustomMap<String, String> createCustomMap() {
-        return new CustomMapImpl<String, String>( "CUSTOMMAP" );
+        return new CustomMapImpl<>( "CUSTOMMAP" );
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/fields/Source.java
Patch:
@@ -22,7 +22,7 @@ public class Source {
     public Integer fieldOnlyWithGetter;
     // CHECKSTYLE:ON
 
-    private final List<Integer> privateFinalList = new ArrayList<Integer>( Arrays.asList( 3, 4, 5 ) );
+    private final List<Integer> privateFinalList = new ArrayList<>( Arrays.asList( 3, 4, 5 ) );
 
     public List<Integer> getPrivateFinalList() {
         return privateFinalList;

File: processor/src/test/java/org/mapstruct/ap/test/ignore/inherit/ToolMapper.java
Patch:
@@ -29,7 +29,7 @@ public interface ToolMapper {
     @InheritConfiguration( name = "mapBase" )
     ToolEntity mapTool(ToolDto source);
 
-    // demonstrates that all the businss stuff is mapped (implicit-by-name and defined)
+    // demonstrates that all the business stuff is mapped (implicit-by-name and defined)
     @InheritConfiguration( name = "mapBase" )
     @Mapping(target = "description", source = "articleDescription")
     WorkBenchEntity mapBench(WorkBenchDto source);

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/DisablingNestedSimpleBeansMappingTest.java
Patch:
@@ -38,7 +38,7 @@ public class DisablingNestedSimpleBeansMappingTest {
             )
         })
     @Test
-    public void shouldUseDisabledMethodGenerationOnMapper() throws Exception {
+    public void shouldUseDisabledMethodGenerationOnMapper() {
     }
 
     @WithClasses({
@@ -55,6 +55,6 @@ public void shouldUseDisabledMethodGenerationOnMapper() throws Exception {
             )
         })
     @Test
-    public void shouldUseDisabledMethodGenerationOnMapperConfig() throws Exception {
+    public void shouldUseDisabledMethodGenerationOnMapperConfig() {
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/exclusions/ErroneousJavaInternalTest.java
Patch:
@@ -53,6 +53,6 @@ public class ErroneousJavaInternalTest {
                     "mapping method: \".*List<.*String> map\\(.*List<.*MyType> value\\)\"\\.")
         })
     @Test
-    public void shouldNotNestIntoJavaPackageObjects() throws Exception {
+    public void shouldNotNestIntoJavaPackageObjects() {
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/other/CarDto.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.test.nestedbeans.other;
 
 import java.util.List;
+import java.util.Objects;
 
 public class CarDto {
 
@@ -60,10 +61,10 @@ public boolean equals(Object o) {
         if ( year != carDto.year ) {
             return false;
         }
-        if ( name != null ? !name.equals( carDto.name ) : carDto.name != null ) {
+        if ( !Objects.equals( name, carDto.name ) ) {
             return false;
         }
-        return wheels != null ? wheels.equals( carDto.wheels ) : carDto.wheels == null;
+        return Objects.equals( wheels, carDto.wheels );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedsourceproperties/NestedSourcePropertiesTest.java
Patch:
@@ -175,6 +175,6 @@ public void shouldUseGetAsTargetAccessor() {
             }
     )
     @WithClasses({ ArtistToChartEntryErroneous.class })
-    public void inverseShouldRaiseErrorForEmptyContructor() {
+    public void inverseShouldRaiseErrorForEmptyConstructor() {
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/NullValueMappingTest.java
Patch:
@@ -42,7 +42,7 @@
 public class NullValueMappingTest {
 
     @Test
-    public void shouldProvideMapperInstance() throws Exception {
+    public void shouldProvideMapperInstance() {
         assertThat( CarMapper.INSTANCE ).isNotNull();
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluepropertymapping/NullValuePropertyMappingTest.java
Patch:
@@ -76,7 +76,7 @@ public void testHierarchyIgnoreOnBeanMappingMethod() {
 
     @Test
     @WithClasses(CustomerNvpmsPropertyMappingMapper.class)
-    public void testHierarchyIgnoreOnPropertyMappingMehtod() {
+    public void testHierarchyIgnoreOnPropertyMappingMethod() {
         testConfig( CustomerNvpmsPropertyMappingMapper.INSTANCE::map );
     }
 

File: integrationtest/src/test/java/org/mapstruct/itest/testutil/runner/ProcessorSuiteRunner.java
Patch:
@@ -111,7 +111,7 @@ public ProcessorSuiteRunner(Class<?> clazz) throws InitializationError {
 
     private List<ProcessorTestCase> initializeTestCases(ProcessorSuite suite,
                 Constructor<? extends CommandLineEnhancer> cliEnhancerConstructor) {
-        List<ProcessorType> types = new ArrayList<ProcessorType>();
+        List<ProcessorType> types = new ArrayList<>();
 
         for ( ProcessorType compiler : suite.processorTypes() ) {
             if ( compiler.getIncluded().length > 0 ) {
@@ -190,7 +190,7 @@ private void doExecute(ProcessorTestCase child, Description description) throws
             verifier = new Verifier( destination.getCanonicalPath() );
         }
 
-        List<String> goals = new ArrayList<String>( 3 );
+        List<String> goals = new ArrayList<>( 3 );
 
         goals.add( "clean" );
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/HelperMethod.java
Patch:
@@ -51,7 +51,7 @@ public String getName() {
      * @return the types used by this method for which import statements need to be generated
      */
     public Set<Type> getImportTypes() {
-        return Collections.<Type>emptySet();
+        return Collections.emptySet();
     }
 
     /**

File: processor/src/main/java/org/mapstruct/ap/internal/util/Strings.java
Patch:
@@ -153,12 +153,12 @@ public static String getSafeVariableName(String name, Collection<String> existin
         }
 
         int c = 1;
-        String seperator = Character.isDigit( name.charAt( name.length() - 1 ) ) ? "_" : "";
-        while ( conflictingNames.contains( name + seperator + c ) ) {
+        String separator = Character.isDigit( name.charAt( name.length() - 1 ) ) ? "_" : "";
+        while ( conflictingNames.contains( name + separator + c ) ) {
             c++;
         }
 
-        return name + seperator + c;
+        return name + separator + c;
     }
 
     /**

File: processor/src/test/java/org/mapstruct/ap/test/dependency/GraphAnalyzerTest.java
Patch:
@@ -165,7 +165,7 @@ public void eightNodesWithoutCycle() {
     }
 
     private Set<String> asStrings(Set<List<String>> cycles) {
-        Set<String> asStrings = new HashSet<String>();
+        Set<String> asStrings = new HashSet<>();
 
         for ( List<String> cycle : cycles ) {
             asStrings.add( asString( cycle ) );

File: processor/src/test/java/org/mapstruct/ap/test/factories/FactoryTest.java
Patch:
@@ -84,11 +84,11 @@ private Source createSource() {
         foo4.setProp( "foo4" );
         source.setProp4( foo4 );
 
-        List<String> fooList = new ArrayList<String>();
+        List<String> fooList = new ArrayList<>();
         fooList.add( "fooListEntry" );
         source.setPropList( fooList );
 
-        Map<String, String> fooMap = new HashMap<String, String>();
+        Map<String, String> fooMap = new HashMap<>();
         fooMap.put( "key", "fooValue" );
         source.setPropMap( fooMap );
         return source;

File: processor/src/test/java/org/mapstruct/ap/test/fields/FieldsMappingTest.java
Patch:
@@ -23,7 +23,7 @@
 public class FieldsMappingTest {
 
     @Test
-    public void shouldMapSourceToTarget() throws Exception {
+    public void shouldMapSourceToTarget() {
         Source source = new Source();
         source.normalInt = 4;
         source.normalList = Lists.newArrayList( 10, 11, 12 );
@@ -42,7 +42,7 @@ public void shouldMapSourceToTarget() throws Exception {
     }
 
     @Test
-    public void shouldMapTargetToSource() throws Exception {
+    public void shouldMapTargetToSource() {
         Target target = new Target();
         target.finalInt = "40";
         target.normalInt = "4";

File: processor/src/test/java/org/mapstruct/ap/test/generics/genericsupertype/MapperWithGenericSuperClassTest.java
Patch:
@@ -32,7 +32,7 @@ public void canCreateImplementationForMapperWithGenericSuperClass() {
         Vessel vessel = new Vessel();
         vessel.setName( "Pacific Queen" );
 
-        SearchResult<Vessel> vessels = new SearchResult<Vessel>();
+        SearchResult<Vessel> vessels = new SearchResult<>();
         vessels.setValues( Arrays.asList( vessel ) );
         vessels.setSize( 1L );
 

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/ComplexInheritanceTest.java
Patch:
@@ -108,14 +108,14 @@ private SourceBase createSourceBase(int foo) {
     private SourceExt createSourceExt(int foo) {
         SourceExt s = new SourceExt();
         s.setFoo( foo );
-        s.setBar( Long.valueOf( 47 ) );
+        s.setBar( 47L );
         return s;
     }
 
     private SourceExt2 createSourceExt2(int foo) {
         SourceExt2 s = new SourceExt2();
         s.setFoo( foo );
-        s.setBaz( Long.valueOf( 47 ) );
+        s.setBaz( 47L );
         return s;
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedmethodcall/ObjectFactory.java
Patch:
@@ -15,6 +15,6 @@
 public class ObjectFactory {
 
     public JAXBElement<String> createDate(String date) {
-        return new JAXBElement<String>(  new QName( "dont-care" ), String.class, "06.07.2013" );
+        return new JAXBElement<>( new QName( "dont-care" ), String.class, "06.07.2013" );
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedsourceproperties/_target/ChartPositions.java
Patch:
@@ -13,7 +13,7 @@
  */
 public class ChartPositions {
 
-    private final List<Long> positions = new ArrayList<Long>();
+    private final List<Long> positions = new ArrayList<>();
 
     public List<Long> getPositions() {
         return positions;

File: processor/src/test/java/org/mapstruct/ap/test/nestedtargetproperties/ChartEntryToArtist.java
Patch:
@@ -52,10 +52,10 @@ public abstract class ChartEntryToArtist {
 
     protected List<Integer> mapPosition(Integer in) {
         if ( in != null ) {
-            return new ArrayList<Integer>( Arrays.asList( in ) );
+            return new ArrayList<>( Arrays.asList( in ) );
         }
         else {
-            return new ArrayList<Integer>();
+            return new ArrayList<>();
         }
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedtargetproperties/ChartEntryToArtistUpdate.java
Patch:
@@ -46,7 +46,7 @@ protected List<Integer> mapPosition(Integer in) {
             return Arrays.asList( in );
         }
         else {
-            return Collections.<Integer>emptyList();
+            return Collections.emptyList();
         }
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/references/ReferencedCustomMapper.java
Patch:
@@ -27,7 +27,7 @@ else if ( clazz == SomeOtherType.class ) {
             return (T) new SomeOtherType( string );
         }
         else if ( clazz == GenericWrapper.class ) {
-            return (T) new GenericWrapper<String>( string );
+            return (T) new GenericWrapper<>( string );
         }
 
         return null;

File: processor/src/test/java/org/mapstruct/ap/test/references/ReferencedMapperTest.java
Patch:
@@ -66,7 +66,7 @@ public void shouldUseGenericFactoryForIterable() {
     @Test
     @IssueKey( "136" )
     public void shouldUseGenericFactoryForMap() {
-        Map<String, String> source = new HashMap<String, String>();
+        Map<String, String> source = new HashMap<>();
         source.put( "foo1", "bar1" );
         source.put( "foo2", "bar2" );
         Map<SomeType, SomeOtherType> result = SourceTargetMapper.INSTANCE.fromStringMap( source );
@@ -85,7 +85,7 @@ public void shouldMapPrimitivesWithCustomMapper() {
         source.setProp1( new SomeType( "42" ) );
         source.setProp2( new SomeType( "1701" ) );
         source.setProp3( new SomeType( "true" ) );
-        source.setProp4( new GenericWrapper<SomeType>( new SomeType( "x" ) ) );
+        source.setProp4( new GenericWrapper<>( new SomeType( "x" ) ) );
 
         TargetWithPrimitives result = SourceTargetMapperWithPrimitives.INSTANCE.sourceToTarget( source );
 

File: processor/src/test/java/org/mapstruct/ap/test/selection/jaxb/test2/ObjectFactory.java
Patch:
@@ -29,7 +29,7 @@ public OrderShippingDetailsType createOrderShippingDetailsType() {
 
     @XmlElementDecl(namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", name = "OrderShippingDetails")
     public JAXBElement<OrderShippingDetailsType> createOrderShippingDetails(OrderShippingDetailsType value) {
-        return new JAXBElement<OrderShippingDetailsType>(
+        return new JAXBElement<>(
             ORDER_SHIPPING_DETAILS_QNAME,
             OrderShippingDetailsType.class, null, value
         );
@@ -38,7 +38,7 @@ public JAXBElement<OrderShippingDetailsType> createOrderShippingDetails(OrderShi
     @XmlElementDecl(namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", name = "orderShippedFrom",
         scope = OrderShippingDetailsType.class)
     public JAXBElement<String> createOrderShippingDetailsTypeOrderShippedFrom(String value) {
-        return new JAXBElement<String>(
+        return new JAXBElement<>(
             ORDER_SHIPPING_DETAILS_TYPE_ORDER_SHIPPED_FROM_QNAME, String.class,
             OrderShippingDetailsType.class, value
         );
@@ -47,7 +47,7 @@ public JAXBElement<String> createOrderShippingDetailsTypeOrderShippedFrom(String
     @XmlElementDecl(namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", name = "orderShippedTo",
         scope = OrderShippingDetailsType.class)
     public JAXBElement<String> createOrderShippingDetailsTypeOrderShippedTo(String value) {
-        return new JAXBElement<String>(
+        return new JAXBElement<>(
             ORDER_SHIPPING_DETAILS_TYPE_ORDER_SHIPPED_TO_QNAME, String.class,
             OrderShippingDetailsType.class, value
         );

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/QualifierTest.java
Patch:
@@ -68,7 +68,7 @@ public void shouldMatchClassAndMethod() {
         OriginalRelease foreignMovies = new OriginalRelease();
         foreignMovies.setTitle( "Sixth Sense, The" );
         foreignMovies.setKeyWords( Arrays.asList( "evergreen", "magnificent" ) );
-        Map<String, List<String>> facts = new HashMap<String, List<String>>();
+        Map<String, List<String>> facts = new HashMap<>();
         facts.put( "director", Arrays.asList( "M. Night Shyamalan" ) );
         facts.put( "cast", Arrays.asList( "Bruce Willis", "Haley Joel Osment", "Toni Collette" ) );
         facts.put( "plot keywords", Arrays.asList( "boy", "child psychologist", "I see dead people" ) );
@@ -150,7 +150,7 @@ public void testFactorySelectionWithQualifier() {
         OriginalRelease foreignMovies = new OriginalRelease();
         foreignMovies.setTitle( "Sixth Sense, The" );
         foreignMovies.setKeyWords( Arrays.asList( "evergreen", "magnificent" ) );
-        Map<String, List<String>> facts = new HashMap<String, List<String>>();
+        Map<String, List<String>> facts = new HashMap<>();
         facts.put( "director", Arrays.asList( "M. Night Shyamalan" ) );
         facts.put( "cast", Arrays.asList( "Bruce Willis", "Haley Joel Osment", "Toni Collette" ) );
         facts.put( "plot keywords", Arrays.asList( "boy", "child psychologist", "I see dead people" ) );

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/iterable/IterableAndQualifiersTest.java
Patch:
@@ -39,7 +39,7 @@ public class IterableAndQualifiersTest {
     public void testGenerationBasedOnQualifier() {
 
         TopologyDto topologyDto1 = new TopologyDto();
-        List<TopologyFeatureDto> topologyFeatures1 = new ArrayList<TopologyFeatureDto>();
+        List<TopologyFeatureDto> topologyFeatures1 = new ArrayList<>();
         RiverDto riverDto = new RiverDto();
         riverDto.setName( "Rhine" );
         riverDto.setLength( 5 );
@@ -53,7 +53,7 @@ public void testGenerationBasedOnQualifier() {
         assertThat( ( (RiverEntity) result1.getTopologyFeatures().get( 0 ) ).getLength() ).isEqualTo( 5 );
 
         TopologyDto topologyDto2 = new TopologyDto();
-        List<TopologyFeatureDto> topologyFeatures2 = new ArrayList<TopologyFeatureDto>();
+        List<TopologyFeatureDto> topologyFeatures2 = new ArrayList<>();
         CityDto cityDto = new CityDto();
         cityDto.setName( "Amsterdam" );
         cityDto.setPopulation( 800000 );

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/named/NamedTest.java
Patch:
@@ -62,7 +62,7 @@ public void shouldMatchClassAndMethod() {
         OriginalRelease foreignMovies = new OriginalRelease();
         foreignMovies.setTitle( "Sixth Sense, The" );
         foreignMovies.setKeyWords( Arrays.asList( "evergreen", "magnificent" ) );
-        Map<String, List<String>> facts = new HashMap<String, List<String>>();
+        Map<String, List<String>> facts = new HashMap<>();
         facts.put( "director", Arrays.asList( "M. Night Shyamalan" ) );
         facts.put( "cast", Arrays.asList( "Bruce Willis", "Haley Joel Osment", "Toni Collette" ) );
         facts.put( "plot keywords", Arrays.asList( "boy", "child psychologist", "I see dead people" ) );
@@ -96,7 +96,7 @@ public void testFactorySelectionWithQualifier() {
         OriginalRelease foreignMovies = new OriginalRelease();
         foreignMovies.setTitle( "Sixth Sense, The" );
         foreignMovies.setKeyWords( Arrays.asList( "evergreen", "magnificent" ) );
-        Map<String, List<String>> facts = new HashMap<String, List<String>>();
+        Map<String, List<String>> facts = new HashMap<>();
         facts.put( "director", Arrays.asList( "M. Night Shyamalan" ) );
         facts.put( "cast", Arrays.asList( "Bruce Willis", "Haley Joel Osment", "Toni Collette" ) );
         facts.put( "plot keywords", Arrays.asList( "boy", "child psychologist", "I see dead people" ) );

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/SourceConstantsTest.java
Patch:
@@ -228,8 +228,7 @@ public void cannotMapIntConstantToLong() throws ParseException {
 
     private Date getDate(String format, String date) throws ParseException {
         SimpleDateFormat dateFormat = new SimpleDateFormat( format );
-        Date result = dateFormat.parse( date );
-        return result;
+        return dateFormat.parse( date );
     }
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/expressions/java/JavaExpressionTest.java
Patch:
@@ -73,8 +73,7 @@ public void testJavaExpressionInsertionWithSeveralSources() throws ParseExceptio
 
     private Date getTime(String format, String date) throws ParseException {
         SimpleDateFormat dateFormat = new SimpleDateFormat( format );
-        Date result = dateFormat.parse( date );
-        return result;
+        return dateFormat.parse( date );
     }
 
    @Test

File: processor/src/test/java/org/mapstruct/ap/test/source/expressions/java/TargetList.java
Patch:
@@ -14,7 +14,7 @@
  */
 public class TargetList {
 
-    private List<String> list = new ArrayList<String>();
+    private List<String> list = new ArrayList<>();
 
     public List<String> getList() {
         return list;

File: processor/src/test/java/org/mapstruct/ap/test/source/presencecheck/spi/SoccerTeamTarget.java
Patch:
@@ -22,7 +22,7 @@ public List<String> getPlayers() {
 
     public void addPlayer(String player) {
         if ( this.players == null ) {
-            this.players = new ArrayList<String>();
+            this.players = new ArrayList<>();
         }
         this.players.add( player );
     }

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/selection/ExternalSelectionTest.java
Patch:
@@ -111,7 +111,7 @@ public void shouldSelectGeneratedExternalMapperForIterablesAndMaps() {
         SecretaryDto secretaryDto = new SecretaryDto();
         secretaryDto.setName( "Jim" );
         departmentDto.setEmployees( Arrays.asList( employeeDto ) );
-        Map<SecretaryDto, EmployeeDto> secretaryToEmployee = new HashMap<SecretaryDto, EmployeeDto>();
+        Map<SecretaryDto, EmployeeDto> secretaryToEmployee = new HashMap<>();
         secretaryToEmployee.put( secretaryDto, employeeDto );
         departmentDto.setSecretaryToEmployee( secretaryToEmployee );
 

File: processor/src/test/java/org/mapstruct/ap/test/value/EnumToEnumMappingTest.java
Patch:
@@ -186,7 +186,7 @@ public void shouldMappAllUnmappedToDefault() {
 
     @IssueKey( "1091" )
     @Test
-    public void shouldMapAnyRemainingToNullCorrectly() throws Exception {
+    public void shouldMapAnyRemainingToNullCorrectly() {
         ExternalOrderType externalOrderType = SpecialOrderMapper.INSTANCE.anyRemainingToNull( OrderType.RETAIL );
         assertThat( externalOrderType )
             .isNotNull()

File: processor/src/test/java/org/mapstruct/ap/testutil/assertions/JavaFileAssert.java
Patch:
@@ -11,6 +11,7 @@
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -92,9 +93,9 @@ public void containsNoImportFor(Class<?> importedClass) {
      * @param expected the file that should be matched
      */
     public void hasSameMapperContent(File expected) {
-        Charset charset = Charset.forName( "UTF-8" );
+        Charset charset = StandardCharsets.UTF_8;
         try {
-            List<Delta<String>> diffs = new ArrayList<Delta<String>>( this.diff.diff(
+            List<Delta<String>> diffs = new ArrayList<>( this.diff.diff(
                 actual,
                 charset,
                 expected,

File: processor/src/test/java/org/mapstruct/ap/testutil/compilation/model/DiagnosticDescriptor.java
Patch:
@@ -42,11 +42,11 @@ private DiagnosticDescriptor(String sourceFileName, Kind kind, Long line, Long a
     }
 
     public static DiagnosticDescriptor forDiagnostic(Diagnostic diagnostic) {
-        String soureFileName = diagnostic.type() != void.class
+        String sourceFileName = diagnostic.type() != void.class
             ? diagnostic.type().getName().replace( ".", File.separator ) + ".java"
             : null;
         return new DiagnosticDescriptor(
-            soureFileName,
+            sourceFileName,
             diagnostic.kind(),
             diagnostic.line() != -1 ? diagnostic.line() : null,
             diagnostic.alternativeLine() != -1 ? diagnostic.alternativeLine() : null,

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/AnnotationProcessorTestRunner.java
Patch:
@@ -68,7 +68,7 @@ private List<Runner> createRunners(Class<?> klass) throws Exception {
         WithSingleCompiler singleCompiler = klass.getAnnotation( WithSingleCompiler.class );
 
         if (singleCompiler != null) {
-            return Arrays.<Runner> asList( new InnerAnnotationProcessorRunner( klass, singleCompiler.value() ) );
+            return Arrays.asList( new InnerAnnotationProcessorRunner( klass, singleCompiler.value() ) );
         }
         else if ( IS_AT_LEAST_JAVA_9 ) {
             // Current tycho-compiler-jdt (0.26.0) is not compatible with Java 11
@@ -77,7 +77,7 @@ else if ( IS_AT_LEAST_JAVA_9 ) {
             return Arrays.asList( new InnerAnnotationProcessorRunner( klass, Compiler.JDK11 ) );
         }
 
-        return Arrays.<Runner> asList(
+        return Arrays.asList(
             new InnerAnnotationProcessorRunner( klass, Compiler.JDK ),
             new InnerAnnotationProcessorRunner( klass, Compiler.ECLIPSE )
             );

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/JdkCompilingStatement.java
Patch:
@@ -49,7 +49,7 @@ protected CompilationOutcomeDescriptor compileWithSpecificCompiler(CompilationRe
                                                                        String classOutputDir,
                                                                        String additionalCompilerClasspath) {
         JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
-        DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>();
+        DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
         StandardJavaFileManager fileManager = compiler.getStandardFileManager( null, null, null );
 
         Iterable<? extends JavaFileObject> compilationUnits =
@@ -97,7 +97,7 @@ protected CompilationOutcomeDescriptor compileWithSpecificCompiler(CompilationRe
     }
 
     private static List<File> asFiles(List<String> paths) {
-        List<File> classpath = new ArrayList<File>();
+        List<File> classpath = new ArrayList<>();
         for ( String path : paths ) {
             classpath.add( new File( path ) );
         }
@@ -112,7 +112,7 @@ private static List<File> asFiles(List<String> paths) {
      */
     @Override
     protected List<DiagnosticDescriptor> filterExpectedDiagnostics(List<DiagnosticDescriptor> expectedDiagnostics) {
-        List<DiagnosticDescriptor> filtered = new ArrayList<DiagnosticDescriptor>( expectedDiagnostics.size() );
+        List<DiagnosticDescriptor> filtered = new ArrayList<>( expectedDiagnostics.size() );
 
         DiagnosticDescriptor previous = null;
         for ( DiagnosticDescriptor diag : expectedDiagnostics ) {

File: processor/src/test/java/org/mapstruct/ap/internal/util/NativeTypesTest.java
Patch:
@@ -19,7 +19,7 @@
 public class NativeTypesTest {
 
     @Test
-    public void testIsNumber() throws Exception {
+    public void testIsNumber() {
         assertFalse( NativeTypes.isNumber( null ) );
         assertFalse( NativeTypes.isNumber( Object.class ) );
         assertFalse( NativeTypes.isNumber( String.class ) );

File: processor/src/test/java/org/mapstruct/ap/spi/util/IntrospectorUtilsTest.java
Patch:
@@ -15,7 +15,7 @@
 public class IntrospectorUtilsTest {
 
     @Test
-    public void testDecapitalize() throws Exception {
+    public void testDecapitalize() {
         assertThat( IntrospectorUtils.decapitalize( null ) ).isNull();
         assertThat( IntrospectorUtils.decapitalize( "" ) ).isEqualTo( "" );
         assertThat( IntrospectorUtils.decapitalize( "URL" ) ).isEqualTo( "URL" );

File: processor/src/test/java/org/mapstruct/ap/test/abstractclass/Source.java
Patch:
@@ -15,7 +15,7 @@ public class Source extends AbstractDto implements HasId, AlsoHasId {
     private final int size;
     private final Calendar birthday;
     private final String notAttractingEqualsMethod = "no way";
-    private final Holder<String> manuallyConverted = new Holder<String>( "What is the answer?" );
+    private final Holder<String> manuallyConverted = new Holder<>( "What is the answer?" );
 
     public Source() {
         publicSize = 191;

File: processor/src/test/java/org/mapstruct/ap/test/callbacks/ongeneratedmethods/CompanyMapperPostProcessing.java
Patch:
@@ -17,9 +17,9 @@ public  class CompanyMapperPostProcessing  {
     @AfterMapping
     public void toAddressDto(Address address, @MappingTarget AddressDto addressDto) {
         String addressLine = address.getAddressLine();
-        int seperatorIndex = addressLine.indexOf( ";" );
-        addressDto.setStreet( addressLine.substring( 0, seperatorIndex ) );
-        String houseNumber = addressLine.substring( seperatorIndex + 1, addressLine.length() );
+        int separatorIndex = addressLine.indexOf( ";" );
+        addressDto.setStreet( addressLine.substring( 0, separatorIndex ) );
+        String houseNumber = addressLine.substring( separatorIndex + 1 );
         addressDto.setHouseNumber( Integer.parseInt( houseNumber ) );
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/callbacks/ongeneratedmethods/MappingResultPostprocessorTest.java
Patch:
@@ -44,7 +44,7 @@ public void test() {
         Employee employee = new Employee();
         employee.setAddress( address );
         Company company = new Company();
-        company.setEmployees( Arrays.asList( new Employee[] { employee } ) );
+        company.setEmployees( Arrays.asList( employee ) );
 
         // test
         CompanyDto companyDto = CompanyMapper.INSTANCE.toCompanyDto( company );

File: processor/src/test/java/org/mapstruct/ap/test/callbacks/returning/CallbacksWithReturnValuesTest.java
Patch:
@@ -42,7 +42,7 @@ public void updatingWithDefaultHandlingRaisesStackOverflowError() {
 
     @Test
     public void mappingWithContextCorrectlyResolvesCycles() {
-        final AtomicReference<Integer> contextLevel = new AtomicReference<Integer>( null );
+        final AtomicReference<Integer> contextLevel = new AtomicReference<>( null );
         ContextListener contextListener = new ContextListener() {
             @Override
             public void methodCalled(Integer level, String method, Object source, Object target) {

File: processor/src/test/java/org/mapstruct/ap/test/context/Node.java
Patch:
@@ -21,8 +21,8 @@ public class Node {
 
     public Node(String name) {
         this.name = name;
-        this.children = new ArrayList<Node>();
-        this.attributes = new ArrayList<Attribute>();
+        this.children = new ArrayList<>();
+        this.attributes = new ArrayList<>();
     }
 
     public Node getParent() {

File: processor/src/test/java/org/mapstruct/ap/test/context/SelfContainingCycleContext.java
Patch:
@@ -19,7 +19,7 @@
  * @author Andreas Gudian
  */
 public class SelfContainingCycleContext {
-    private Map<Object, Object> knownInstances = new IdentityHashMap<Object, Object>();
+    private Map<Object, Object> knownInstances = new IdentityHashMap<>();
 
     @BeforeMapping
     @SuppressWarnings("unchecked")

File: processor/src/test/java/org/mapstruct/ap/test/conversion/nativetypes/CharConversionTest.java
Patch:
@@ -35,7 +35,7 @@ public void shouldApplyCharConversion() {
     @Test
     public void shouldApplyReverseCharConversion() {
         CharTarget target = new CharTarget();
-        target.setC( Character.valueOf( 'G' ) );
+        target.setC( 'G' );
 
         CharSource source = CharMapper.INSTANCE.targetToSource( target );
 

File: processor/src/test/java/org/mapstruct/ap/test/decorator/jsr330/Jsr330DecoratorTest.java
Patch:
@@ -78,7 +78,7 @@ public void springDown() {
     @Test
     public void shouldInvokeDecoratorMethods() {
         Calendar birthday = Calendar.getInstance();
-        birthday.set( 1928, 4, 23 );
+        birthday.set( 1928, Calendar.MAY, 23 );
         Person person = new Person( "Gary", "Crant", birthday.getTime(), new Address( "42 Ocean View Drive" ) );
 
         PersonDto personDto = personMapper.personToPersonDto( person );

File: processor/src/test/java/org/mapstruct/ap/test/decorator/spring/constructor/SpringDecoratorTest.java
Patch:
@@ -66,7 +66,7 @@ public void springDown() {
     public void shouldInvokeDecoratorMethods() {
         //given
         Calendar birthday = Calendar.getInstance();
-        birthday.set( 1928, 4, 23 );
+        birthday.set( 1928, Calendar.MAY, 23 );
         Person person = new Person( "Gary", "Crant", birthday.getTime(), new Address( "42 Ocean View Drive" ) );
 
         //when

File: processor/src/test/java/org/mapstruct/ap/test/decorator/spring/field/SpringDecoratorTest.java
Patch:
@@ -66,7 +66,7 @@ public void springDown() {
     public void shouldInvokeDecoratorMethods() {
         //given
         Calendar birthday = Calendar.getInstance();
-        birthday.set( 1928, 4, 23 );
+        birthday.set( 1928, Calendar.MAY, 23 );
         Person person = new Person( "Gary", "Crant", birthday.getTime(), new Address( "42 Ocean View Drive" ) );
 
         //when

File: processor/src/test/java/org/mapstruct/ap/test/collection/Target.java
Patch:
@@ -144,14 +144,14 @@ public void setStringLongMap(Map<String, Long> stringLongMap) {
 
     public List<String> getStringListNoSetter() {
         if ( stringListNoSetter == null ) {
-            stringListNoSetter = new ArrayList<String>();
+            stringListNoSetter = new ArrayList<>();
         }
         return stringListNoSetter;
     }
 
     public List<String> getStringListNoSetter2() {
         if ( stringListNoSetter2 == null ) {
-            stringListNoSetter2 = new ArrayList<String>();
+            stringListNoSetter2 = new ArrayList<>();
         }
         return stringListNoSetter2;
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/PetMapper.java
Patch:
@@ -63,7 +63,7 @@ else if ( "dog".equals( pet ) ) {
      * @throws DogException
      */
     public List<Long> toPets(List<String> pets) throws CatException, DogException {
-        List<Long> result = new ArrayList<Long>();
+        List<Long> result = new ArrayList<>();
         for ( String pet : pets ) {
             result.add( toPet( pet ) );
         }
@@ -82,7 +82,7 @@ public <T extends Pet> T toPet(String pet, @TargetType Class<T> clazz) throws Ca
     }
 
     public List<String> toSourcePets(List<Long> pets) throws CatException, DogException {
-        List<String> result = new ArrayList<String>();
+        List<String> result = new ArrayList<>();
         for ( Long pet : pets ) {
             result.add( PETS_TO_SOURCE.get( pet ) );
         }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/Target.java
Patch:
@@ -38,7 +38,7 @@ public void addPets(Long cat) {
     public Long addPet(Long pet) {
         AdderUsageObserver.setUsed( true );
         if ( pets == null ) {
-            pets = new ArrayList<Long>();
+            pets = new ArrayList<>();
         }
         pets.add( pet );
         return pet;

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/TargetDali.java
Patch:
@@ -26,7 +26,7 @@ public void setTeeth(List<Integer> teeth) {
     public void addTeeth(Integer tooth) {
         AdderUsageObserver.setUsed( true );
         if ( teeth == null ) {
-            teeth = new ArrayList<Integer>();
+            teeth = new ArrayList<>();
         }
         teeth.add( tooth );
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/TargetHuman.java
Patch:
@@ -26,14 +26,14 @@ public void setTeeth(List<Integer> teeth) {
     public void addTooth(Integer pet) {
         AdderUsageObserver.setUsed( true );
         if ( teeth == null ) {
-            teeth = new ArrayList<Integer>();
+            teeth = new ArrayList<>();
         }
         teeth.add( pet );
     }
 
     public void addTeeth(Integer tooth) {
         if ( teeth == null ) {
-            teeth = new ArrayList<Integer>();
+            teeth = new ArrayList<>();
         }
         teeth.add( tooth );
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/TargetOnlyGetter.java
Patch:
@@ -34,7 +34,7 @@ public void addPets(Long cat) {
     public void addPet(Long pet) {
         AdderUsageObserver.setUsed( true );
         if ( pets == null ) {
-            pets = new ArrayList<Long>();
+            pets = new ArrayList<>();
         }
         pets.add( pet );
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/TargetViaTargetType.java
Patch:
@@ -26,7 +26,7 @@ public void setPets(List<IndoorPet> pets) {
     public void addPet(IndoorPet pet) {
         AdderUsageObserver.setUsed( true );
         if ( pets == null ) {
-            pets = new ArrayList<IndoorPet>();
+            pets = new ArrayList<>();
         }
         pets.add( pet );
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/TargetWithoutSetter.java
Patch:
@@ -22,7 +22,7 @@ public List<Long> getPets() {
     public void addPet(Long pet) {
         AdderUsageObserver.setUsed( true );
         if ( pets == null ) {
-            pets = new ArrayList<Long>();
+            pets = new ArrayList<>();
         }
         pets.add( pet );
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/defaultimplementation/NoSetterCollectionMappingTest.java
Patch:
@@ -32,7 +32,7 @@ public class NoSetterCollectionMappingTest {
     public void compilesAndMapsCorrectly() {
         NoSetterSource source = new NoSetterSource();
         source.setListValues( Arrays.asList( "foo", "bar" ) );
-        HashMap<String, String> mapValues = new HashMap<String, String>();
+        HashMap<String, String> mapValues = new HashMap<>();
         mapValues.put( "fooKey", "fooVal" );
         mapValues.put( "barKey", "barVal" );
 

File: processor/src/test/java/org/mapstruct/ap/test/collection/defaultimplementation/Target.java
Patch:
@@ -14,7 +14,7 @@ public class Target {
 
     public List<TargetFoo> getFooListNoSetter() {
         if ( fooListNoSetter == null ) {
-            fooListNoSetter = new ArrayList<TargetFoo>();
+            fooListNoSetter = new ArrayList<>();
         }
         return fooListNoSetter;
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/immutabletarget/ImmutableProductTest.java
Patch:
@@ -34,7 +34,7 @@ public void shouldHandleImmutableTarget() {
         CupboardDto in = new CupboardDto();
         in.setContent( Arrays.asList( "cups", "soucers" ) );
         CupboardEntity out = new CupboardEntity();
-        out.setContent( Collections.<String>emptyList() );
+        out.setContent( Collections.emptyList() );
 
         CupboardMapper.INSTANCE.map( in, out );
 

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/BeanMapper.java
Patch:
@@ -29,7 +29,7 @@ BigDecimal map(JAXBElement<? extends BigDecimal> value) {
     }
 
     JAXBElement<? super BigDecimal> map(BigDecimal value) {
-        return new JAXBElement<BigDecimal>( new QName( "test" ), BigDecimal.class, value );
+        return new JAXBElement<>( new QName( "test" ), BigDecimal.class, value );
     }
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/WildCardTest.java
Patch:
@@ -140,7 +140,7 @@ public void shouldFailOnTypeVarTarget() {
     public void shouldMapBean() {
 
         GoodIdea aGoodIdea = new GoodIdea();
-        aGoodIdea.setContent( new JAXBElement<BigDecimal>( new QName( "test" ), BigDecimal.class, BigDecimal.ONE ) );
+        aGoodIdea.setContent( new JAXBElement<>( new QName( "test" ), BigDecimal.class, BigDecimal.ONE ) );
         aGoodIdea.setDescription( BigDecimal.ZERO );
 
         CunningPlan aCunningPlan = BeanMapper.STM.transformA( aGoodIdea );

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/defaultimplementation/NoSetterStreamMappingTest.java
Patch:
@@ -7,8 +7,8 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.Arrays;
 import java.util.List;
+import java.util.stream.Stream;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,7 +28,7 @@ public class NoSetterStreamMappingTest {
     @Test
     public void compilesAndMapsCorrectly() {
         NoSetterSource source = new NoSetterSource();
-        source.setListValues( Arrays.asList( "foo", "bar" ).stream() );
+        source.setListValues( Stream.of( "foo", "bar" ) );
 
         NoSetterTarget target = NoSetterMapper.INSTANCE.toTarget( source );
 
@@ -37,7 +37,7 @@ public void compilesAndMapsCorrectly() {
         // now test existing instances
 
         NoSetterSource source2 = new NoSetterSource();
-        source2.setListValues( Arrays.asList( "baz" ).stream() );
+        source2.setListValues( Stream.of( "baz" ) );
         List<String> originalCollectionInstance = target.getListValues();
 
         NoSetterTarget target2 = NoSetterMapper.INSTANCE.toTargetWithExistingTarget( source2, target );

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/defaultimplementation/NoSetterTarget.java
Patch:
@@ -13,7 +13,7 @@
  *
  */
 public class NoSetterTarget {
-    private List<String> listValues = new ArrayList<String>();
+    private List<String> listValues = new ArrayList<>();
 
     public List<String> getListValues() {
         return listValues;

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/defaultimplementation/Target.java
Patch:
@@ -14,7 +14,7 @@ public class Target {
 
     public List<TargetFoo> getFooListNoSetter() {
         if ( fooListNoSetter == null ) {
-            fooListNoSetter = new ArrayList<TargetFoo>();
+            fooListNoSetter = new ArrayList<>();
         }
         return fooListNoSetter;
     }

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/streamtononiterable/StreamToNonIterableMappingTest.java
Patch:
@@ -7,7 +7,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.Arrays;
+import java.util.stream.Stream;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,7 +23,7 @@ public class StreamToNonIterableMappingTest {
     @Test
     public void shouldMapStringStreamToStringUsingCustomMapper() {
         Source source = new Source();
-        source.setNames( Arrays.asList( "Alice", "Bob", "Jim" ).stream() );
+        source.setNames( Stream.of( "Alice", "Bob", "Jim" ) );
         Target target = SourceTargetMapper.INSTANCE.sourceToTarget( source );
 
         assertThat( target ).isNotNull();

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/streamtononiterable/StringListMapper.java
Patch:
@@ -16,6 +16,6 @@ public String stringListToString(Stream<String> strings) {
     }
 
     public Stream<String> stringToStringList(String string) {
-        return string == null ? null : Arrays.asList( string.split( "-" ) ).stream();
+        return string == null ? null : Arrays.stream( string.split( "-" ) );
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/Car.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.test.nestedbeans;
 
 import java.util.List;
+import java.util.Objects;
 
 public class Car {
 
@@ -60,10 +61,10 @@ public boolean equals(Object o) {
         if ( year != car.year ) {
             return false;
         }
-        if ( name != null ? !name.equals( car.name ) : car.name != null ) {
+        if ( !Objects.equals( name, car.name ) ) {
             return false;
         }
-        return wheels != null ? wheels.equals( car.wheels ) : car.wheels == null;
+        return Objects.equals( wheels, car.wheels );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/CarDto.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.test.nestedbeans;
 
 import java.util.List;
+import java.util.Objects;
 
 public class CarDto {
 
@@ -60,10 +61,10 @@ public boolean equals(Object o) {
         if ( year != carDto.year ) {
             return false;
         }
-        if ( name != null ? !name.equals( carDto.name ) : carDto.name != null ) {
+        if ( !Objects.equals( name, carDto.name ) ) {
             return false;
         }
-        return wheels != null ? wheels.equals( carDto.wheels ) : carDto.wheels == null;
+        return Objects.equals( wheels, carDto.wheels );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/MultipleForgedMethodsTest.java
Patch:
@@ -34,8 +34,8 @@ public class MultipleForgedMethodsTest {
     @Test
     public void testNestedMapsAutoMap() {
 
-        HashMap<WordDto, WordDto> dtoAntonyms = new HashMap<WordDto, WordDto>();
-        HashMap<Word, Word> entityAntonyms = new HashMap<Word, Word>();
+        HashMap<WordDto, WordDto> dtoAntonyms = new HashMap<>();
+        HashMap<Word, Word> entityAntonyms = new HashMap<>();
 
         String[] words = { "black", "good", "up", "left", "fast" };
         String[] antonyms = { "white", "bad", "down", "right", "slow" };

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/RoofDto.java
Patch:
@@ -5,6 +5,8 @@
  */
 package org.mapstruct.ap.test.nestedbeans;
 
+import java.util.Objects;
+
 public class RoofDto {
     private String color;
     private ExternalRoofType type;
@@ -48,7 +50,7 @@ public boolean equals(Object o) {
             return false;
         }
 
-        return color != null ? color.equals( roofDto.color ) : roofDto.color == null;
+        return Objects.equals( color, roofDto.color );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/maps/AntonymsDictionary.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.test.nestedbeans.maps;
 
 import java.util.Map;
+import java.util.Objects;
 
 public class AntonymsDictionary {
     private Map<Word, Word> antonyms;
@@ -36,7 +37,7 @@ public boolean equals(Object o) {
 
         AntonymsDictionary antonymsDictionary = (AntonymsDictionary) o;
 
-        return antonyms != null ? antonyms.equals( antonymsDictionary.antonyms ) : antonymsDictionary.antonyms == null;
+        return Objects.equals( antonyms, antonymsDictionary.antonyms );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/maps/Word.java
Patch:
@@ -5,6 +5,8 @@
  */
 package org.mapstruct.ap.test.nestedbeans.maps;
 
+import java.util.Objects;
+
 public class Word {
     private String textValue;
 
@@ -34,7 +36,7 @@ public boolean equals(Object o) {
 
         Word word = (Word) o;
 
-        return textValue != null ? textValue.equals( word.textValue ) : word.textValue == null;
+        return Objects.equals( textValue, word.textValue );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/maps/WordDto.java
Patch:
@@ -5,6 +5,8 @@
  */
 package org.mapstruct.ap.test.nestedbeans.maps;
 
+import java.util.Objects;
+
 public class WordDto {
     private String textValue;
 
@@ -34,7 +36,7 @@ public boolean equals(Object o) {
 
         WordDto wordDto = (WordDto) o;
 
-        return textValue != null ? textValue.equals( wordDto.textValue ) : wordDto.textValue == null;
+        return Objects.equals( textValue, wordDto.textValue );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/multiplecollections/Garage.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.test.nestedbeans.multiplecollections;
 
 import java.util.List;
+import java.util.Objects;
 
 import org.mapstruct.ap.test.nestedbeans.Car;
 
@@ -48,10 +49,10 @@ public boolean equals(Object o) {
 
         Garage garage = (Garage) o;
 
-        if ( cars != null ? !cars.equals( garage.cars ) : garage.cars != null ) {
+        if ( !Objects.equals( cars, garage.cars ) ) {
             return false;
         }
-        return usedCars != null ? usedCars.equals( garage.usedCars ) : garage.usedCars == null;
+        return Objects.equals( usedCars, garage.usedCars );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/multiplecollections/GarageDto.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.test.nestedbeans.multiplecollections;
 
 import java.util.List;
+import java.util.Objects;
 
 import org.mapstruct.ap.test.nestedbeans.CarDto;
 
@@ -49,10 +50,10 @@ public boolean equals(Object o) {
 
         GarageDto garageDto = (GarageDto) o;
 
-        if ( cars != null ? !cars.equals( garageDto.cars ) : garageDto.cars != null ) {
+        if ( !Objects.equals( cars, garageDto.cars ) ) {
             return false;
         }
-        return usedCars != null ? usedCars.equals( garageDto.usedCars ) : garageDto.usedCars == null;
+        return Objects.equals( usedCars, garageDto.usedCars );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/other/RoofDto.java
Patch:
@@ -5,6 +5,8 @@
  */
 package org.mapstruct.ap.test.nestedbeans.other;
 
+import java.util.Objects;
+
 public class RoofDto {
     private String color;
 
@@ -34,7 +36,7 @@ public boolean equals(Object o) {
 
         RoofDto roofDto = (RoofDto) o;
 
-        return color != null ? color.equals( roofDto.color ) : roofDto.color == null;
+        return Objects.equals( color, roofDto.color );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1061/Issue1061Test.java
Patch:
@@ -20,7 +20,7 @@
 public class Issue1061Test {
 
     @Test
-    public void shouldCompile() throws Exception {
+    public void shouldCompile() {
 
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1131/Issue1131Mapper.java
Patch:
@@ -20,7 +20,7 @@
 public abstract class Issue1131Mapper {
     public static final Issue1131Mapper INSTANCE = Mappers.getMapper( Issue1131Mapper.class );
 
-    public static final List<String> CALLED_METHODS = new ArrayList<String>();
+    public static final List<String> CALLED_METHODS = new ArrayList<>();
 
     public abstract void merge(Source source, @MappingTarget Target target);
 
@@ -40,7 +40,7 @@ protected Target.Nested createWithSource(Source source) {
     @ObjectFactory
     protected List<Target.Nested> createWithSourceList(List<Source.Nested> source) {
         CALLED_METHODS.add( "create(List<Source.Nested>)" );
-        List<Target.Nested> result = new ArrayList<Target.Nested>();
+        List<Target.Nested> result = new ArrayList<>();
         result.add( new Target.Nested( "from createWithSourceList" ) );
         return result;
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1131/Issue1131MapperWithContext.java
Patch:
@@ -22,7 +22,7 @@ public abstract class Issue1131MapperWithContext {
     public static final Issue1131MapperWithContext INSTANCE = Mappers.getMapper( Issue1131MapperWithContext.class );
 
     public static class MappingContext {
-        private final List<String> calledMethods = new ArrayList<String>();
+        private final List<String> calledMethods = new ArrayList<>();
 
         public Target.Nested create(Source.Nested source) {
             calledMethods.add( "create(Source.Nested)" );
@@ -32,10 +32,10 @@ public Target.Nested create(Source.Nested source) {
         public List<Target.Nested> create(List<Source.Nested> source) {
             calledMethods.add( "create(List<Source.Nested>)" );
             if ( source == null ) {
-                return new ArrayList<Target.Nested>();
+                return new ArrayList<>();
             }
             else {
-                return new ArrayList<Target.Nested>( source.size() );
+                return new ArrayList<>( source.size() );
             }
         }
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1131/Issue1131Test.java
Patch:
@@ -34,7 +34,7 @@ public void shouldUseCreateWithSourceNested() {
         Source source = new Source();
         source.setNested( new Source.Nested() );
         source.getNested().setProperty( "something" );
-        source.setMoreNested( new ArrayList<Source.Nested>() );
+        source.setMoreNested( new ArrayList<>() );
 
         Target target = new Target();
 
@@ -55,7 +55,7 @@ public void shouldUseContextObjectFactory() {
         Source source = new Source();
         source.setNested( new Source.Nested() );
         source.getNested().setProperty( "something" );
-        source.setMoreNested( new ArrayList<Source.Nested>() );
+        source.setMoreNested( new ArrayList<>() );
 
         Target target = new Target();
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1155/Issue1155Test.java
Patch:
@@ -25,7 +25,7 @@
 public class Issue1155Test {
 
     @Test
-    public void shouldCompile() throws Exception {
+    public void shouldCompile() {
 
         Entity.Dto dto = new Entity.Dto();
         dto.clientId = 10;

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1164/SourceTargetMapper.java
Patch:
@@ -21,14 +21,14 @@ public abstract class SourceTargetMapper {
     public abstract Target map(Source source);
 
     protected List<List<Target.TargetNested>> mapLists(List<List<Source.SourceNested>> lists) {
-        return new ArrayList<List<Target.TargetNested>>();
+        return new ArrayList<>();
     }
 
     protected Map<String, List<Target.MapNested>> map(Map<Integer, List<Source.SourceNested>> map) {
-        return new HashMap<String, List<Target.MapNested>>();
+        return new HashMap<>();
     }
 
     protected GenericHolder<List<Target.GenericNested>> map(GenericHolder<List<Source.SourceNested>> genericHolder) {
-        return new GenericHolder<List<Target.GenericNested>>();
+        return new GenericHolder<>();
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1255/Issue1255Test.java
Patch:
@@ -27,7 +27,7 @@
 public class Issue1255Test {
 
     @Test
-    public void shouldMapSomeBToSomeAWithoutField1() throws Exception {
+    public void shouldMapSomeBToSomeAWithoutField1() {
         SomeB someB = new SomeB();
         someB.setField1( "value1" );
         someB.setField2( "value2" );
@@ -41,7 +41,7 @@ public void shouldMapSomeBToSomeAWithoutField1() throws Exception {
     }
 
     @Test
-    public void shouldMapSomeAToSomeB() throws Exception {
+    public void shouldMapSomeAToSomeB() {
         SomeA someA = new SomeA();
         someA.setField1( "value1" );
         someA.setField2( "value2" );

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1273/Entity.java
Patch:
@@ -10,7 +10,7 @@
 
 public class Entity {
 
-    List<Long> longs = new ArrayList<Long>();
+    List<Long> longs = new ArrayList<>();
 
     public List<Long> getLongs() {
         return longs;

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1338/Source.java
Patch:
@@ -17,7 +17,7 @@ public class Source {
 
     public void addProperty(String property) {
         if ( properties == null ) {
-            properties = new ArrayList<String>();
+            properties = new ArrayList<>();
         }
         properties.add( property );
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1359/Issue1359Test.java
Patch:
@@ -35,7 +35,7 @@ public void shouldCompile() {
         Target target = new Target();
         assertThat( target ).extracting( "properties" ).contains( null, atIndex( 0 ) );
 
-        Set<String> properties = new HashSet<String>();
+        Set<String> properties = new HashSet<>();
         properties.add( "first" );
         Source source = new Source( properties );
         Issue1359Mapper.INSTANCE.map( target, source );

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1453/AuctionDto.java
Patch:
@@ -24,7 +24,7 @@ List<PaymentDto> takePayments() {
     }
 
     public void setPayments(List<? extends PaymentDto> payments) {
-        this.payments = payments == null ? null : new ArrayList<PaymentDto>( payments );
+        this.payments = payments == null ? null : new ArrayList<>( payments );
     }
 
     List<? super PaymentDto> takeOtherPayments() {
@@ -40,7 +40,7 @@ public void setOtherPayments(List<? super PaymentDto> otherPayments) {
     }
 
     public void setMapPayments(Map<? extends PaymentDto, ? extends PaymentDto> mapPayments) {
-        this.mapPayments = mapPayments == null ? null : new HashMap<PaymentDto, PaymentDto>( mapPayments );
+        this.mapPayments = mapPayments == null ? null : new HashMap<>( mapPayments );
     }
 
     public Map<? super PaymentDto, ? super PaymentDto> getMapSuperPayments() {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1523/java8/Issue1523Test.java
Patch:
@@ -58,7 +58,7 @@ public void testThatCorrectTimeZoneWillBeUsedInTarget() {
         // default one was explicitly set to UTC, thus +01:00 is a different one
         source.setValue( ZonedDateTime.parse( "2018-06-15T00:00:00+01:00" ) );
         Calendar cal = Calendar.getInstance( TimeZone.getTimeZone( "GMT+01:00" ) );
-        cal.set( 2018, 02, 15, 00, 00, 00 );
+        cal.set( 2018, Calendar.MARCH, 15, 00, 00, 00 );
         source.setValue2( cal );
 
         Target target = Issue1523Mapper.INSTANCE.map( source );

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1561/NestedTarget.java
Patch:
@@ -14,7 +14,7 @@
  */
 public class NestedTarget {
 
-    private List<String> properties = new ArrayList<String>();
+    private List<String> properties = new ArrayList<>();
 
     public Stream<String> getProperties() {
         return properties.stream();

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1596/Issue1596Test.java
Patch:
@@ -41,7 +41,7 @@
 public class Issue1596Test {
 
     @Test
-    public void shouldIncludeBuildeType() {
+    public void shouldIncludeBuildType() {
 
         ItemDTO item = ImmutableItemDTO.builder().id( "test" ).build();
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_516/Target.java
Patch:
@@ -26,7 +26,7 @@ public void setElements(List<String> elements) {
 
     public void addElement(String element) {
         if ( elements == null ) {
-            elements = new ArrayList<String>();
+            elements = new ArrayList<>();
         }
         elements.add( element );
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_634/GenericContainerTest.java
Patch:
@@ -33,7 +33,7 @@ public class GenericContainerTest {
     @IssueKey("634")
     public void canMapGenericSourceTypeToGenericTargetType() {
         List<Foo> items = Arrays.asList( new Foo( "42" ), new Foo( "84" ) );
-        Source<Foo> source = new Source<Foo>( items );
+        Source<Foo> source = new Source<>( items );
 
         Target<Bar> target = SourceTargetMapper.INSTANCE.mapSourceToTarget( source );
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_775/IterableWithBoundedElementTypeTest.java
Patch:
@@ -44,7 +44,7 @@ public void createsForgedMethodForIterableLowerBoundInteger() {
         IterableContainer result = MapperWithForgedIterableMapping.INSTANCE.toContainerWithIterable( source );
 
         ( (IterableAssert<Integer>) assertThat( result.getValues() ) )
-                .contains( Integer.valueOf( 42 ), Integer.valueOf( 47 ) );
+                .contains( 42, 47 );
     }
 
     @Test
@@ -55,6 +55,6 @@ public void usesListIntegerMethodForIterableLowerBoundInteger() {
         IterableContainer result = MapperWithCustomListMapping.INSTANCE.toContainerWithIterable( source );
 
         ( (IterableAssert<Integer>) assertThat( result.getValues() ) )
-                .contains( Integer.valueOf( 66 ), Integer.valueOf( 71 ) );
+                .contains( 66, 71 );
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_849/Issue849Test.java
Patch:
@@ -7,7 +7,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.io.Serializable;
 import java.util.Arrays;
 
 import org.junit.Test;
@@ -29,7 +28,7 @@ public class Issue849Test {
     public void shouldCompileWithAllImportsDeclared() {
 
         Source source = new Source();
-        source.setSourceList( Arrays.asList( (Serializable) "test" ) );
+        source.setSourceList( Arrays.asList( "test" ) );
 
         Target target = Issue849Mapper.INSTANCE.mapSourceToTarget( source );
         assertThat( target.getTargetList() ).containsExactly( "test" );

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_849/Target.java
Patch:
@@ -19,7 +19,7 @@ public class Target {
 
     public List<Serializable> getTargetList() {
         if ( targetList == null ) {
-            targetList = new ArrayList<Serializable>();
+            targetList = new ArrayList<>();
         }
         return targetList;
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_865/Issue865Test.java
Patch:
@@ -27,7 +27,7 @@
 public class Issue865Test {
 
     @Test
-    public void shouldGenerateNpeCheckBeforCallingAddAllWhenInUpdateMethods() {
+    public void shouldGenerateNpeCheckBeforeCallingAddAllWhenInUpdateMethods() {
 
         ProjectDto dto = new ProjectDto();
         dto.setName( "myProject" );
@@ -41,7 +41,8 @@ public void shouldGenerateNpeCheckBeforCallingAddAllWhenInUpdateMethods() {
         assertThat( entity.getCoreUsers() ).isNull();
     }
 
-    public void shouldGenerateNpeCheckBeforCallingAddAllWhenInUpdateMethodsAndTargetWithoutSetter() {
+    @Test
+    public void shouldGenerateNpeCheckBeforeCallingAddAllWhenInUpdateMethodsAndTargetWithoutSetter() {
 
         ProjectDto dto = new ProjectDto();
         dto.setName( "myProject" );

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_913/Domain.java
Patch:
@@ -14,8 +14,8 @@
  * @author Sjaak Derksen
  */
 public class Domain {
-    static final Set<String> DEFAULT_STRINGS = new HashSet<String>();
-    static final Set<Long> DEFAULT_LONGS = new HashSet<Long>();
+    static final Set<String> DEFAULT_STRINGS = new HashSet<>();
+    static final Set<Long> DEFAULT_LONGS = new HashSet<>();
 
     private Set<String> strings = DEFAULT_STRINGS;
     private Set<Long> longs = DEFAULT_LONGS;

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_913/Dto.java
Patch:
@@ -16,7 +16,7 @@
 public class Dto {
 
     private List<String> strings;
-    private List<String> stringsInitialized = new ArrayList<String>( Arrays.asList( "5" ) );
+    private List<String> stringsInitialized = new ArrayList<>( Arrays.asList( "5" ) );
     private List<String> stringsWithDefault;
 
     public List<String> getStrings() {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_913/DtoWithPresenceCheck.java
Patch:
@@ -16,7 +16,7 @@
 public class DtoWithPresenceCheck {
 
     private List<String> strings;
-    private List<String> stringsInitialized = new ArrayList<String>( Arrays.asList( "5" ) );
+    private List<String> stringsInitialized = new ArrayList<>( Arrays.asList( "5" ) );
     private List<String> stringsWithDefault;
 
     public boolean hasStrings() {

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/DateToStringConversion.java
Patch:
@@ -15,7 +15,6 @@
 import org.mapstruct.ap.internal.model.TypeConversion;
 import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
-import org.mapstruct.ap.internal.model.common.Type;
 
 import static java.util.Arrays.asList;
 import static org.mapstruct.ap.internal.util.Collections.asSet;
@@ -31,7 +30,7 @@ public class DateToStringConversion implements ConversionProvider {
     @Override
     public Assignment to(ConversionContext conversionContext) {
         return new TypeConversion( asSet( conversionContext.getTypeFactory().getType( SimpleDateFormat.class ) ),
-            Collections.<Type>emptyList(),
+            Collections.emptyList(),
             getConversionExpression( conversionContext, "format" )
         );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/Annotation.java
Patch:
@@ -27,7 +27,7 @@ public class Annotation extends ModelElement {
     private List<String> properties;
 
     public Annotation(Type type) {
-        this( type, Collections.<String>emptyList() );
+        this( type, Collections.emptyList() );
     }
 
     public Annotation(Type type, List<String> properties) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/MethodReference.java
Patch:
@@ -235,8 +235,7 @@ public Set<Type> getImportTypes() {
 
     @Override
     public List<Type> getThrownTypes() {
-        List<Type> exceptions = new ArrayList<>();
-        exceptions.addAll( thrownTypes );
+        List<Type> exceptions = new ArrayList<>( thrownTypes );
         if ( assignment != null ) {
             exceptions.addAll( assignment.getThrownTypes() );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MappingOptions.java
Patch:
@@ -85,7 +85,7 @@ public static MappingOptions forMappingsOnly(Set<Mapping> mappings,
             null,
             null,
             forForgedMethods ? BeanMapping.forForgedMethods() : null,
-            Collections.<ValueMapping>emptyList(),
+            Collections.emptyList(),
             restrictToDefinedMappings
         );
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/SelectionParameters.java
Patch:
@@ -144,8 +144,8 @@ private boolean equals(TypeMirror mirror1, TypeMirror mirror2) {
 
     public static SelectionParameters forSourceRHS(SourceRHS sourceRHS) {
         return new SelectionParameters(
-            Collections.<TypeMirror>emptyList(),
-            Collections.<String>emptyList(),
+            Collections.emptyList(),
+            Collections.emptyList(),
             null,
             null,
             sourceRHS

File: processor/src/main/java/org/mapstruct/ap/internal/util/AnnotationProcessorContext.java
Patch:
@@ -6,7 +6,6 @@
 package org.mapstruct.ap.internal.util;
 
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 import java.util.ServiceLoader;
 
@@ -113,8 +112,8 @@ private static List<AstModifyingAnnotationProcessor> findAstModifyingAnnotationP
                 AstModifyingAnnotationProcessor.class, AnnotationProcessorContext.class.getClassLoader()
         );
 
-        for ( Iterator<AstModifyingAnnotationProcessor> it = loader.iterator(); it.hasNext(); ) {
-            processors.add( it.next() );
+        for ( AstModifyingAnnotationProcessor astModifyingAnnotationProcessor : loader ) {
+            processors.add( astModifyingAnnotationProcessor );
         }
 
         return processors;

File: processor/src/main/java/org/mapstruct/ap/internal/util/Fields.java
Patch:
@@ -84,9 +84,7 @@ private static void addEnclosedElementsInHierarchy(Elements elementUtils, List<V
 
     private static void addFields(List<VariableElement> alreadyCollected, List<VariableElement> variablesToAdd) {
         List<VariableElement> safeToAdd = new ArrayList<>( variablesToAdd.size() );
-        for ( VariableElement toAdd : variablesToAdd ) {
-            safeToAdd.add( toAdd );
-        }
+        safeToAdd.addAll( variablesToAdd );
 
         alreadyCollected.addAll( 0, safeToAdd );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/util/MapperConfiguration.java
Patch:
@@ -99,8 +99,7 @@ public Set<DeclaredType> uses() {
     }
 
     public List<TypeMirror> imports() {
-        List<TypeMirror> imports = new ArrayList<>();
-        imports.addAll( mapperPrism.imports() );
+        List<TypeMirror> imports = new ArrayList<>( mapperPrism.imports() );
         if ( mapperConfigPrism != null ) {
             imports.addAll( mapperConfigPrism.imports() );
         }
@@ -262,7 +261,7 @@ public String componentModel(Options options) {
 
     public boolean isDisableSubMappingMethodsGeneration() {
         if ( mapperPrism.disableSubMappingMethodsGeneration() ) {
-            return mapperPrism.disableSubMappingMethodsGeneration();
+            return true;
         }
 
         if ( mapperConfigPrism != null && mapperConfigPrism.disableSubMappingMethodsGeneration() ) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -387,7 +387,7 @@ private Type getReturnTypeToConstructFromSelectionParameters(SelectionParameters
         private boolean canBeConstructed(Type typeToBeConstructed) {
             return !typeToBeConstructed.isAbstract()
                     && typeToBeConstructed.isAssignableTo( this.method.getResultType() )
-                    && typeToBeConstructed.hasEmptyAccessibleContructor();
+                    && typeToBeConstructed.hasEmptyAccessibleConstructor();
         }
 
         private void reportResultTypeFromBeanMappingNotConstructableError(Type resultType) {
@@ -410,7 +410,7 @@ else if ( !resultType.isAssignableTo( method.getResultType() ) ) {
                                 method.getResultType()
                 );
             }
-            else if ( !resultType.hasEmptyAccessibleContructor() ) {
+            else if ( !resultType.hasEmptyAccessibleConstructor() ) {
                 ctx.getMessager().printMessage(
                                 method.getExecutable(),
                                 BeanMappingPrism.getInstanceOn( method.getExecutable() ).mirror,
@@ -428,7 +428,7 @@ private void reportReturnTypeNotConstructableError(Type returnType) {
                                 returnType
                 );
             }
-            else if ( !returnType.hasEmptyAccessibleContructor() ) {
+            else if ( !returnType.hasEmptyAccessibleConstructor() ) {
                 ctx.getMessager().printMessage(
                                 method.getExecutable(),
                                 Message.GENERAL_NO_SUITABLE_CONSTRUCTOR,

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/AdderWrapper.java
Patch:
@@ -74,8 +74,7 @@ public boolean isSetExplicitlyToDefault() {
 
     @Override
     public Set<Type> getImportTypes() {
-        Set<Type> imported = new HashSet<>();
-        imported.addAll( super.getImportTypes() );
+        Set<Type> imported = new HashSet<>( super.getImportTypes() );
         imported.add( adderType.getTypeBound() );
         return imported;
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/ArrayCopyWrapper.java
Patch:
@@ -40,8 +40,7 @@ public ArrayCopyWrapper(Assignment rhs,
 
     @Override
     public Set<Type> getImportTypes() {
-        Set<Type> imported = new HashSet<>();
-        imported.addAll( getAssignment().getImportTypes() );
+        Set<Type> imported = new HashSet<>( getAssignment().getImportTypes() );
         imported.add( arraysType );
         imported.add( targetType );
         return imported;

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/ExistingInstanceSetterWrapperForCollectionsAndMaps.java
Patch:
@@ -60,7 +60,7 @@ public ExistingInstanceSetterWrapperForCollectionsAndMaps(Assignment decoratedAs
 
     @Override
     public Set<Type> getImportTypes() {
-        Set<Type> imported = new HashSet<Type>( super.getImportTypes() );
+        Set<Type> imported = new HashSet<>( super.getImportTypes() );
         if ( isMapNullToDefault() && ( targetType.getImplementationType() != null ) ) {
             imported.add( targetType.getImplementationType() );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/StreamAdderWrapper.java
Patch:
@@ -70,8 +70,7 @@ public boolean isSetExplicitlyToDefault() {
 
     @Override
     public Set<Type> getImportTypes() {
-        Set<Type> imported = new HashSet<>();
-        imported.addAll( super.getImportTypes() );
+        Set<Type> imported = new HashSet<>( super.getImportTypes() );
         imported.add( adderType.getTypeBound() );
         return imported;
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/UpdateWrapper.java
Patch:
@@ -74,8 +74,7 @@ public List<Type> getThrownTypes() {
 
     @Override
     public Set<Type> getImportTypes() {
-        Set<Type> imported = new HashSet<>();
-        imported.addAll( super.getImportTypes() );
+        Set<Type> imported = new HashSet<>( super.getImportTypes() );
         if ( factoryMethod != null ) {
             imported.addAll( factoryMethod.getImportTypes() );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/LifecycleMethodResolver.java
Patch:
@@ -91,7 +91,7 @@ private static List<LifecycleCallbackMethodReference> collectLifecycleCallbackMe
             MappingBuilderContext ctx, Set<String> existingVariableNames) {
 
         MethodSelectors selectors =
-            new MethodSelectors( ctx.getTypeUtils(), ctx.getElementUtils(), ctx.getTypeFactory() );
+            new MethodSelectors( ctx.getTypeUtils(), ctx.getElementUtils(), ctx.getTypeFactory(), ctx.getMessager() );
 
         Type targetType = method.getResultType();
 

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -90,7 +90,7 @@ public MappingResolverImpl(FormattingMessager messager, Elements elementUtils, T
 
         this.conversions = new Conversions( elementUtils, typeFactory );
         this.builtInMethods = new BuiltInMappingMethods( typeFactory );
-        this.methodSelectors = new MethodSelectors( typeUtils, elementUtils, typeFactory );
+        this.methodSelectors = new MethodSelectors( typeUtils, elementUtils, typeFactory, messager );
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -98,6 +98,8 @@ public enum Message {
     ENUMMAPPING_UNMAPPED_SOURCES( "The following constants from the source enum have no corresponding constant in the target enum and must be be mapped via adding additional mappings: %s." ),
     ENUMMAPPING_DEPRECATED( "Mapping of Enums via @Mapping is going to be removed in future versions of MapStruct. Please use @ValueMapping instead!", Diagnostic.Kind.WARNING ),
 
+    LIFECYCLEMETHOD_AMBIGUOUS_PARAMETERS( "Lifecycle method has multiple matching parameters (e. g. same type), in this case please ensure to name the parameters in the lifecycle and mapping method identical. This lifecycle method will not be used for the mapping method '%s'.", Diagnostic.Kind.WARNING),
+
     DECORATOR_NO_SUBTYPE( "Specified decorator type is no subtype of the annotated mapper type." ),
     DECORATOR_CONSTRUCTOR( "Specified decorator type has no default constructor nor a constructor with a single parameter accepting the decorated mapper type." ),
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -749,7 +749,7 @@ private void reportErrorForUnmappedTargetPropertiesIfRequired() {
                     ForgedMethodHistory history = forgedMethod.getHistory();
                     ctx.getMessager().printMessage(
                         this.method.getExecutable(),
-                        Message.PROPERTYMAPPING_MAPPING_NOT_FOUND,
+                        Message.PROPERTYMAPPING_FORGED_MAPPING_WITH_HISTORY_NOT_FOUND,
                         history.createSourcePropertyErrorMessage(),
                         history.getTargetType(),
                         history.createTargetPropertyName(),

File: processor/src/main/java/org/mapstruct/ap/internal/model/MapMappingMethod.java
Patch:
@@ -196,7 +196,6 @@ public MapMappingMethod build() {
                     .getFactoryMethod( method, method.getResultType(), null, ctx );
             }
 
-
             keyAssignment = new LocalVarWrapper( keyAssignment, method.getThrownTypes(), keyTargetType, false );
             valueAssignment = new LocalVarWrapper( valueAssignment, method.getThrownTypes(), valueTargetType, false );
 

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -39,7 +39,8 @@ public enum Message {
     PROPERTYMAPPING_CREATE_NOTE( "creating property mapping: %s.", Diagnostic.Kind.NOTE ),
     PROPERTYMAPPING_SELECT_NOTE( "selecting property mapping: %s.", Diagnostic.Kind.NOTE ),
     PROPERTYMAPPING_MAPPING_NOT_FOUND( "Can't map %s to \"%s %s\". Consider to declare/implement a mapping method: \"%s map(%s value)\"." ),
-    PROPERTYMAPPING_FORGED_MAPPING_NOT_FOUND( "Can't map %s to %s. Consider to implement a mapping method: \"%s map(%s value)\"." ),
+    PROPERTYMAPPING_FORGED_MAPPING_WITH_HISTORY_NOT_FOUND( "No target bean properties found: can't map %s to \"%s %s\". Consider to declare/implement a mapping method: \"%s map(%s value)\"." ),
+    PROPERTYMAPPING_FORGED_MAPPING_NOT_FOUND( "No target bean properties found: can't map %s to %s. Consider to implement a mapping method: \"%s map(%s value)\"." ),
     PROPERTYMAPPING_DUPLICATE_TARGETS( "Target property \"%s\" must not be mapped more than once." ),
     PROPERTYMAPPING_EMPTY_TARGET( "Target must not be empty in @Mapping." ),
     PROPERTYMAPPING_SOURCE_AND_CONSTANT_BOTH_DEFINED( "Source and constant are both defined in @Mapping, either define a source or a constant." ),

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/forged/ForgedStreamMappingTest.java
Patch:
@@ -70,9 +70,8 @@ public void shouldForgeNewIterableMappingMethod() {
             @Diagnostic(type = ErroneousStreamNonMappableStreamMapper.class,
                 kind = Kind.ERROR,
                 line = 17,
-                messageRegExp = "Can't map Stream element \".* nonMappableStream\" to \".* nonMappableStream\". "
-                    + "Consider to declare/implement a mapping method: .*."),
-        }
+                messageRegExp = "No target bean properties found: can't map Stream element \".* nonMappableStream\" "
+                                + "to \".* nonMappableStream\". Consider to declare/implement a mapping method: .*." ) }
     )
     public void shouldGenerateNonMappableMethodForSetMapping() {
     }

File: processor/src/test/java/org/mapstruct/ap/test/verbose/CreateMapMapping.java
Patch:
@@ -17,7 +17,6 @@ public interface CreateMapMapping {
 
     Map<TargetKey, TargetValue> map(Map<SourceKey, SourceValue> source);
 
-    // empty beans fail.. TODO check
     class SourceKey {
         private String name;
 

File: processor/src/main/java/org/mapstruct/ap/internal/writer/IndentationCorrectingWriter.java
Patch:
@@ -37,7 +37,7 @@ class IndentationCorrectingWriter extends Writer {
      * Set to true to enable output of written characters on the console.
      */
     private static final boolean DEBUG = false;
-    private static final String LINE_SEPARATOR = System.getProperty( "line.separator" );
+    private static final String LINE_SEPARATOR = System.lineSeparator( );
     private static final boolean IS_WINDOWS = System.getProperty( "os.name" ).startsWith( "Windows" );
 
     private State currentState = State.START_OF_LINE;

File: processor/src/main/java/org/mapstruct/ap/spi/DefaultBuilderProvider.java
Patch:
@@ -280,4 +280,5 @@ protected boolean isBuildMethod(ExecutableElement buildMethod, TypeElement typeE
     protected boolean shouldIgnore(TypeElement typeElement) {
         return typeElement == null || JAVA_JAVAX_PACKAGE.matcher( typeElement.getQualifiedName() ).matches();
     }
+
 }

File: processor/src/main/java/org/mapstruct/ap/spi/FreeBuilderAccessorNamingStrategy.java
Patch:
@@ -35,4 +35,5 @@ protected boolean isFluentSetter(ExecutableElement method) {
         // with set
         return false;
     }
+
 }

File: processor/src/main/java/org/mapstruct/ap/spi/ImmutablesAccessorNamingStrategy.java
Patch:
@@ -23,4 +23,5 @@ public class ImmutablesAccessorNamingStrategy extends DefaultAccessorNamingStrat
     protected boolean isFluentSetter(ExecutableElement method) {
         return super.isFluentSetter( method ) && !method.getSimpleName().toString().equals( "from" );
     }
+
 }

File: processor/src/main/java/org/mapstruct/ap/spi/ImmutablesBuilderProvider.java
Patch:
@@ -83,4 +83,5 @@ protected TypeElement asImmutableElement(TypeElement typeElement) {
         builderQualifiedName.append( "Immutable" ).append( typeElement.getSimpleName() );
         return elementUtils.getTypeElement( builderQualifiedName );
     }
+
 }

File: processor/src/main/java/org/mapstruct/ap/spi/NoOpBuilderProvider.java
Patch:
@@ -23,5 +23,6 @@ public class NoOpBuilderProvider implements BuilderProvider {
     public BuilderInfo findBuilderInfo(TypeMirror type) {
         return null;
     }
+
 }
 // end::documentation[]

File: processor/src/test/java/org/mapstruct/ap/testutil/WithServiceImplementation.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.testutil;
 
 import java.lang.annotation.ElementType;
+import java.lang.annotation.Repeatable;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
@@ -17,6 +18,7 @@
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ ElementType.TYPE, ElementType.METHOD })
+@Repeatable( WithServiceImplementations.class )
 public @interface WithServiceImplementation {
     /**
      * @return The service implementation class that is to be made available during the annotation processing.

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/Compiler.java
Patch:
@@ -10,5 +10,5 @@
  *
  */
 public enum Compiler {
-    JDK, ECLIPSE;
+    JDK, JDK11, ECLIPSE;
 }

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/CompilingStatement.java
Patch:
@@ -128,6 +128,7 @@ private static List<String> buildTestCompilationClasspath() {
                 "javax.inject",
                 "spring-beans",
                 "spring-context",
+                "jaxb-api",
                 "joda-time" };
 
         return filterBootClassPath( whitelist );

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/BuiltInMethod.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 
-import org.mapstruct.ap.internal.conversion.SimpleConversion;
 import org.mapstruct.ap.internal.model.common.Accessibility;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.Parameter;
@@ -27,7 +26,7 @@
 
 /**
  * Represents a "built-in" mapping method which will be added as private method to the generated mapper. Built-in
- * methods are used in cases where a {@link SimpleConversion} doesn't suffice, e.g. as several lines of source code or a
+ * methods are used in cases where a simple conversation doesn't suffice, e.g. as several lines of source code or a
  * try/catch block are required.
  *
  * @author Sjaak Derksen

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1685/UserMapper.java
Patch:
@@ -38,7 +38,6 @@ public interface UserMapper {
 
     @InheritInverseConfiguration
     @BeanMapping( nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.SET_TO_DEFAULT )
-    @Mapping( target = "phone", source = "contactDataDTO.phone", defaultValue = "0" )
     void updateUserFromUserAndDefaultDTO(UserDTO userDTO, @MappingTarget User user);
 
 }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -162,7 +162,7 @@ private Mapper getMapper(TypeElement element, MapperConfiguration mapperConfig,
 
         Mapper mapper = new Mapper.Builder()
             .element( element )
-            .mappingMethods( mappingMethods )
+            .methods( mappingMethods )
             .fields( fields )
             .constructorFragments(  constructorFragments )
             .options( options )

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/EnumStringConversion.java
Patch:
@@ -26,7 +26,7 @@ public String getToExpression(ConversionContext conversionContext) {
 
     @Override
     public String getFromExpression(ConversionContext conversionContext) {
-        return "Enum.valueOf( " + conversionContext.getTargetType().getReferenceName()
+        return "Enum.valueOf( " + conversionContext.getTargetType().createReferenceName()
             + ".class, <SOURCE> )";
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/JavaLocalDateToSqlDateConversion.java
Patch:
@@ -6,6 +6,7 @@
 package org.mapstruct.ap.internal.conversion;
 
 import java.sql.Date;
+import java.time.ZoneOffset;
 import java.util.Set;
 
 import org.mapstruct.ap.internal.model.common.ConversionContext;
@@ -14,7 +15,6 @@
 
 import static org.mapstruct.ap.internal.conversion.ConversionUtils.sqlDate;
 import static org.mapstruct.ap.internal.conversion.ConversionUtils.zoneOffset;
-import static org.mapstruct.ap.internal.util.JavaTimeConstants.ZONE_OFFSET_FQN;
 
 /**
  * SimpleConversion for mapping {@link java.time.LocalDate} to
@@ -34,7 +34,7 @@ protected String getToExpression(ConversionContext conversionContext) {
     protected Set<Type> getToConversionImportTypes(ConversionContext conversionContext) {
         return Collections.asSet(
             conversionContext.getTypeFactory().getType( Date.class ),
-            conversionContext.getTypeFactory().getType( ZONE_OFFSET_FQN )
+            conversionContext.getTypeFactory().getType( ZoneOffset.class )
         );
     }
 
@@ -46,7 +46,7 @@ protected String getFromExpression(ConversionContext conversionContext) {
     @Override
     protected Set<Type> getFromConversionImportTypes(ConversionContext conversionContext) {
         return Collections.asSet(
-            conversionContext.getTypeFactory().getType( ZONE_OFFSET_FQN )
+            conversionContext.getTypeFactory().getType( ZoneOffset.class )
         );
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/JodaDateTimeToCalendarConversion.java
Patch:
@@ -34,7 +34,7 @@ protected Set<Type> getToConversionImportTypes(ConversionContext conversionConte
 
     @Override
     protected String getFromExpression(ConversionContext conversionContext) {
-        return "new " + conversionContext.getTargetType().getReferenceName() + "( <SOURCE> )";
+        return "new " + conversionContext.getTargetType().createReferenceName() + "( <SOURCE> )";
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/JodaTimeToDateConversion.java
Patch:
@@ -32,7 +32,7 @@ protected String getToExpression(ConversionContext conversionContext) {
 
     @Override
     protected String getFromExpression(ConversionContext conversionContext) {
-        return "new " + conversionContext.getTargetType().getReferenceName() + "( <SOURCE> )";
+        return "new " + conversionContext.getTargetType().createReferenceName() + "( <SOURCE> )";
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/internal/model/GeneratedType.java
Patch:
@@ -224,7 +224,7 @@ protected void addIfImportRequired(Collection<Type> collection, Type typeToAdd)
     }
 
     private boolean needsImportDeclaration(Type typeToAdd) {
-        if ( !typeToAdd.isImported() ) {
+        if ( !typeToAdd.isToBeImported() ) {
             return false;
         }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/CalendarToZonedDateTime.java
Patch:
@@ -12,7 +12,6 @@
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
-import org.mapstruct.ap.internal.util.JavaTimeConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -28,7 +27,7 @@ public class CalendarToZonedDateTime extends BuiltInMethod {
     private final Set<Type> importedTypes;
 
     CalendarToZonedDateTime(TypeFactory typeFactory) {
-        this.returnType = typeFactory.getType( JavaTimeConstants.ZONED_DATE_TIME_FQN );
+        this.returnType = typeFactory.getType( ZonedDateTime.class );
         this.parameter = new Parameter( "cal", typeFactory.getType( Calendar.class ) );
         this.importedTypes = asSet( returnType, parameter.getType() );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/ZonedDateTimeToCalendar.java
Patch:
@@ -13,7 +13,6 @@
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
-import org.mapstruct.ap.internal.util.JavaTimeConstants;
 
 import static org.mapstruct.ap.internal.util.Collections.asSet;
 
@@ -29,7 +28,7 @@ public class ZonedDateTimeToCalendar extends BuiltInMethod {
 
     ZonedDateTimeToCalendar(TypeFactory typeFactory) {
         this.returnType = typeFactory.getType( Calendar.class );
-        this.parameter = new Parameter( "dateTime", typeFactory.getType( JavaTimeConstants.ZONED_DATE_TIME_FQN ) );
+        this.parameter = new Parameter( "dateTime", typeFactory.getType( ZonedDateTime.class ) );
         this.importedTypes = asSet( returnType, parameter.getType(), typeFactory.getType( TimeZone.class ) );
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/TypeFactory.java
Patch:
@@ -522,7 +522,7 @@ private BuilderInfo findBuilder(TypeMirror type) {
         try {
             return roundContext.getAnnotationProcessorContext()
                 .getBuilderProvider()
-                .findBuilderInfo( type, elementUtils, typeUtils );
+                .findBuilderInfo( type );
         }
         catch ( MoreThanOneBuilderCreationMethodException ex ) {
             messager.printMessage(

File: processor/src/main/java/org/mapstruct/ap/internal/util/AnnotationProcessorContext.java
Patch:
@@ -76,6 +76,7 @@ else if ( elementUtils.getTypeElement( FreeBuilderConstants.FREE_BUILDER_FQN ) !
         this.accessorNamingStrategy = Services.get( AccessorNamingStrategy.class, defaultAccessorNamingStrategy );
         this.accessorNamingStrategy.init( this );
         this.builderProvider = Services.get( BuilderProvider.class, defaultBuilderProvider );
+        this.builderProvider.init( this );
         this.accessorNaming = new AccessorNamingUtils( this.accessorNamingStrategy );
         this.initialized = true;
     }

File: processor/src/main/java/org/mapstruct/ap/spi/NoOpBuilderProvider.java
Patch:
@@ -8,8 +8,6 @@
 // tag::documentation[]
 
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 // end::documentation[]
 
@@ -22,7 +20,7 @@
 public class NoOpBuilderProvider implements BuilderProvider {
 
     @Override
-    public BuilderInfo findBuilderInfo(TypeMirror type, Elements elements, Types types) {
+    public BuilderInfo findBuilderInfo(TypeMirror type) {
         return null;
     }
 }

File: integrationtest/src/test/java/org/mapstruct/itest/tests/FullFeatureCompilationTest.java
Patch:
@@ -53,6 +53,9 @@ public static final class CompilationExclusionCliEnhancer implements CommandLine
         public Collection<String> getAdditionalCommandLineArguments(ProcessorType processorType) {
             List<String> additionalExcludes = new ArrayList<>();
 
+            // SPI not working correctly here.. (not picked up)
+            additionalExcludes.add( "org/mapstruct/ap/test/bugs/_1596/*.java" );
+
             switch ( processorType ) {
                 case ORACLE_JAVA_6:
                     additionalExcludes.add( "org/mapstruct/ap/test/abstractclass/generics/*.java" );

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -882,6 +882,9 @@ public Set<Type> getImportTypes() {
             types.addAll( getResultType().getEffectiveType().getImportTypes() );
         }
 
+        if ( getResultType().getBuilderType() != null ) {
+            types.add( getResultType().getBuilderType().getOwningType() );
+        }
 
         return types;
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/SetterWrapperForCollectionsAndMapsWithNullCheck.java
Patch:
@@ -63,6 +63,9 @@ public Set<Type> getImportTypes() {
         if (isDirectAssignment() || getSourcePresenceCheckerReference() == null ) {
             imported.addAll( getNullCheckLocalVarType().getImportTypes() );
         }
+        if ( isMapNullToDefault() && ( targetType.getImplementationType() != null ) ) {
+            imported.add( targetType.getImplementationType() );
+        }
         return imported;
     }
 

File: processor/src/main/java/org/mapstruct/ap/spi/DefaultAccessorNamingStrategy.java
Patch:
@@ -83,10 +83,10 @@ public boolean isGetterMethod(ExecutableElement method) {
     public boolean isSetterMethod(ExecutableElement method) {
         String methodName = method.getSimpleName().toString();
 
-        return methodName.startsWith( "set" ) && methodName.length() > 3 || isBuilderSetter( method );
+        return methodName.startsWith( "set" ) && methodName.length() > 3 || isFluentSetter( method );
     }
 
-    protected boolean isBuilderSetter(ExecutableElement method) {
+    protected boolean isFluentSetter(ExecutableElement method) {
         return method.getParameters().size() == 1 &&
             !JAVA_JAVAX_PACKAGE.matcher( method.getEnclosingElement().asType().toString() ).matches() &&
             !isAdderWithUpperCase4thCharacter( method ) &&
@@ -159,7 +159,7 @@ public String getPropertyName(ExecutableElement getterOrSetterMethod) {
         if ( methodName.startsWith( "is" ) || methodName.startsWith( "get" ) || methodName.startsWith( "set" ) ) {
             return IntrospectorUtils.decapitalize( methodName.substring( methodName.startsWith( "is" ) ? 2 : 3 ) );
         }
-        else if ( isBuilderSetter( getterOrSetterMethod ) ) {
+        else if ( isFluentSetter( getterOrSetterMethod ) ) {
             return methodName;
         }
         return IntrospectorUtils.decapitalize( methodName.substring( methodName.startsWith( "is" ) ? 2 : 3 ) );

File: processor/src/main/java/org/mapstruct/ap/spi/ImmutablesAccessorNamingStrategy.java
Patch:
@@ -17,7 +17,7 @@
 public class ImmutablesAccessorNamingStrategy extends DefaultAccessorNamingStrategy {
 
     @Override
-    protected boolean isBuilderSetter(ExecutableElement method) {
-        return super.isBuilderSetter( method ) && !method.getSimpleName().toString().equals( "from" );
+    protected boolean isFluentSetter(ExecutableElement method) {
+        return super.isFluentSetter( method ) && !method.getSimpleName().toString().equals( "from" );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/AbstractMappingMethodBuilder.java
Patch:
@@ -37,7 +37,7 @@ Assignment forgeMapping(SourceRHS sourceRHS, Type sourceType, Type targetType) {
         }
 
         String name = getName( sourceType, targetType );
-        name = Strings.getSaveVariableName( name, ctx.getNamesOfMappingsToGenerate() );
+        name = Strings.getSafeVariableName( name, ctx.getNamesOfMappingsToGenerate() );
         ForgedMethodHistory history = null;
         if ( method instanceof ForgedMethod ) {
             history = ( (ForgedMethod) method ).getHistory();

File: processor/src/main/java/org/mapstruct/ap/internal/model/ContainerMappingMethod.java
Patch:
@@ -41,8 +41,8 @@ public abstract class ContainerMappingMethod extends NormalTypeMappingMethod {
         this.elementAssignment = parameterAssignment;
         this.loopVariableName = loopVariableName;
         this.selectionParameters = selectionParameters;
-        this.index1Name = Strings.getSaveVariableName( "i", existingVariables );
-        this.index2Name = Strings.getSaveVariableName( "j", existingVariables );
+        this.index1Name = Strings.getSafeVariableName( "i", existingVariables );
+        this.index2Name = Strings.getSafeVariableName( "j", existingVariables );
     }
 
     public Parameter getSourceParameter() {

File: processor/src/main/java/org/mapstruct/ap/internal/model/ContainerMappingMethodBuilder.java
Patch:
@@ -73,7 +73,7 @@ public final M build() {
         Type targetElementType = getElementType( resultType );
 
         String loopVariableName =
-            Strings.getSaveVariableName( sourceElementType.getName(), method.getParameterNames() );
+            Strings.getSafeVariableName( sourceElementType.getName(), method.getParameterNames() );
 
         SourceRHS sourceRHS = new SourceRHS(
             loopVariableName,

File: processor/src/main/java/org/mapstruct/ap/internal/model/Decorator.java
Patch:
@@ -133,7 +133,7 @@ public Decorator build() {
     @SuppressWarnings( "checkstyle:parameternumber" )
     private Decorator(TypeFactory typeFactory, String packageName, String name, Type decoratorType,
                       String interfacePackage, String interfaceName, List<MappingMethod> methods,
-                      List<? extends Field> fields, Options options, VersionInformation versionInformation,
+                      List<Field> fields, Options options, VersionInformation versionInformation,
                       Accessibility accessibility, SortedSet<Type> extraImports,
                       DecoratorConstructor decoratorConstructor) {
         super(

File: processor/src/main/java/org/mapstruct/ap/internal/model/DefaultMapperReference.java
Patch:
@@ -37,7 +37,7 @@ public static DefaultMapperReference getInstance(Type type, boolean isAnnotatedM
             importTypes.add( typeFactory.getType( "org.mapstruct.factory.Mappers" ) );
         }
 
-        String variableName = Strings.getSaveVariableName(
+        String variableName = Strings.getSafeVariableName(
             type.getName(),
             otherMapperReferences
         );

File: processor/src/main/java/org/mapstruct/ap/internal/model/LifecycleCallbackMethodReference.java
Patch:
@@ -42,7 +42,7 @@ private LifecycleCallbackMethodReference(SelectedMethod<SourceMethod> lifecycleM
         this.methodResultType = containingMethod.getResultType();
 
         if ( hasReturnType() ) {
-            this.targetVariableName = Strings.getSaveVariableName( "target", existingVariableNames );
+            this.targetVariableName = Strings.getSafeVariableName( "target", existingVariableNames );
             existingVariableNames.add( this.targetVariableName );
         }
         else {

File: processor/src/main/java/org/mapstruct/ap/internal/model/MapMappingMethod.java
Patch:
@@ -266,21 +266,21 @@ public Set<Type> getImportTypes() {
     }
 
     public String getKeyVariableName() {
-        return Strings.getSaveVariableName(
+        return Strings.getSafeVariableName(
             "key",
             getParameterNames()
         );
     }
 
     public String getValueVariableName() {
-        return Strings.getSaveVariableName(
+        return Strings.getSafeVariableName(
             "value",
             getParameterNames()
         );
     }
 
     public String getEntryVariableName() {
-        return Strings.getSaveVariableName(
+        return Strings.getSafeVariableName(
             "entry",
             getParameterNames()
         );

File: processor/src/main/java/org/mapstruct/ap/internal/model/MappingMethod.java
Patch:
@@ -5,7 +5,7 @@
  */
 package org.mapstruct.ap.internal.model;
 
-import static org.mapstruct.ap.internal.util.Strings.getSaveVariableName;
+import static org.mapstruct.ap.internal.util.Strings.getSafeVariableName;
 import static org.mapstruct.ap.internal.util.Strings.join;
 
 import java.util.ArrayList;
@@ -91,12 +91,12 @@ private String initResultName(Collection<String> existingVarNames) {
             return targetParameter.getName();
         }
         else if ( getResultType().isArrayType() ) {
-            String name = getSaveVariableName( getResultType().getComponentType().getName() + "Tmp", existingVarNames );
+            String name = getSafeVariableName( getResultType().getComponentType().getName() + "Tmp", existingVarNames );
             existingVarNames.add( name );
             return name;
         }
         else {
-            String name = getSaveVariableName( getResultType().getName(), existingVarNames );
+            String name = getSafeVariableName( getResultType().getName(), existingVarNames );
             existingVarNames.add( name );
             return name;
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/NestedPropertyMappingMethod.java
Patch:
@@ -58,7 +58,7 @@ public NestedPropertyMappingMethod build() {
             final List<Type> thrownTypes = new ArrayList<Type>();
             List<SafePropertyEntry> safePropertyEntries = new ArrayList<SafePropertyEntry>();
             for ( PropertyEntry propertyEntry : propertyEntries ) {
-                String safeName = Strings.getSaveVariableName( propertyEntry.getName(), existingVariableNames );
+                String safeName = Strings.getSafeVariableName( propertyEntry.getName(), existingVariableNames );
                 safePropertyEntries.add( new SafePropertyEntry( propertyEntry, safeName ) );
                 existingVariableNames.add( safeName );
                 thrownTypes.addAll( ctx.getTypeFactory().getThrownTypes(

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -511,7 +511,7 @@ else if ( propertyEntries.size() == 1 ) {
 
                 // forge a method from the parameter type to the last entry type.
                 String forgedName = Strings.joinAndCamelize( sourceReference.getElementNames() );
-                forgedName = Strings.getSaveVariableName( forgedName, ctx.getNamesOfMappingsToGenerate() );
+                forgedName = Strings.getSafeVariableName( forgedName, ctx.getNamesOfMappingsToGenerate() );
                 ForgedMethod methodRef = new ForgedMethod(
                     forgedName,
                     sourceReference.getParameter().getType(),
@@ -601,7 +601,7 @@ private Assignment forgeWithElementMapping(Type sourceType, Type targetType, Sou
         private ForgedMethod prepareForgedMethod(Type sourceType, Type targetType, SourceRHS source,
                                                  ExecutableElement element, String suffix) {
             String name = getName( sourceType, targetType );
-            name = Strings.getSaveVariableName( name, ctx.getNamesOfMappingsToGenerate() );
+            name = Strings.getSafeVariableName( name, ctx.getNamesOfMappingsToGenerate() );
 
             // copy mapper configuration from the source method, its the same mapper
             MapperConfiguration config = method.getMapperConfiguration();
@@ -647,7 +647,7 @@ private Assignment forgeMapping(SourceRHS sourceRHS) {
             }
 
             String name = getName( sourceType, targetType );
-            name = Strings.getSaveVariableName( name, ctx.getNamesOfMappingsToGenerate() );
+            name = Strings.getSafeVariableName( name, ctx.getNamesOfMappingsToGenerate() );
 
             List<Parameter> parameters = new ArrayList<Parameter>( method.getContextParameters() );
             Type returnType;

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/SourceRHS.java
Patch:
@@ -69,7 +69,7 @@ public Type getSourceType() {
 
     @Override
     public String createLocalVarName(String desiredName) {
-        String result = Strings.getSaveVariableName( desiredName, existingVariableNames );
+        String result = Strings.getSafeVariableName( desiredName, existingVariableNames );
         existingVariableNames.add( result );
         return result;
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/ForgedMethod.java
Patch:
@@ -87,7 +87,7 @@ public ForgedMethod(String name, Type sourceType, Type returnType, MapperConfigu
                         ParameterProvidedMethods parameterProvidedMethods, ForgedMethodHistory history,
                         MappingOptions mappingOptions, boolean forgedNameBased) {
         String sourceParamName = Strings.decapitalize( sourceType.getName() );
-        String sourceParamSafeName = Strings.getSaveVariableName( sourceParamName );
+        String sourceParamSafeName = Strings.getSafeVariableName( sourceParamName );
 
         this.parameters = new ArrayList<Parameter>( 1 + additionalParameters.size() );
         Parameter sourceParameter = new Parameter( sourceParamSafeName, sourceType );

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/CalendarToZonedDateTime.java
Patch:
@@ -5,8 +5,6 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.time.ZonedDateTime;
 import java.util.Calendar;
 import java.util.Set;
@@ -16,6 +14,8 @@
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JavaTimeConstants;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * {@link BuiltInMethod} for mapping between {@link Calendar} and {@link ZonedDateTime}.
  * <p>

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/JaxbElemToValue.java
Patch:
@@ -5,16 +5,15 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.util.Set;
-
 import javax.xml.bind.JAXBElement;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToCalendar.java
Patch:
@@ -5,17 +5,16 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.util.Calendar;
 import java.util.Set;
-
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToDate.java
Patch:
@@ -5,17 +5,16 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.util.Date;
 import java.util.Set;
-
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToJodaDateTime.java
Patch:
@@ -5,8 +5,6 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.util.Set;
 import javax.xml.datatype.DatatypeConstants;
 import javax.xml.datatype.XMLGregorianCalendar;
@@ -16,6 +14,8 @@
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToJodaLocalDate.java
Patch:
@@ -5,8 +5,6 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.util.Set;
 import javax.xml.datatype.DatatypeConstants;
 import javax.xml.datatype.XMLGregorianCalendar;
@@ -16,6 +14,8 @@
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToJodaLocalDateTime.java
Patch:
@@ -5,8 +5,6 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.util.Set;
 import javax.xml.datatype.DatatypeConstants;
 import javax.xml.datatype.XMLGregorianCalendar;
@@ -16,6 +14,8 @@
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToJodaLocalTime.java
Patch:
@@ -5,8 +5,6 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.util.Set;
 import javax.xml.datatype.DatatypeConstants;
 import javax.xml.datatype.XMLGregorianCalendar;
@@ -16,6 +14,8 @@
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToLocalDate.java
Patch:
@@ -5,17 +5,16 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.time.LocalDate;
 import java.util.Set;
-
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Gunnar Morling
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/XmlGregorianCalendarToString.java
Patch:
@@ -5,19 +5,18 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Set;
-
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/ZonedDateTimeToCalendar.java
Patch:
@@ -5,8 +5,6 @@
  */
 package org.mapstruct.ap.internal.model.source.builtin;
 
-import static org.mapstruct.ap.internal.util.Collections.asSet;
-
 import java.time.ZonedDateTime;
 import java.util.Calendar;
 import java.util.Set;
@@ -17,6 +15,8 @@
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.util.JavaTimeConstants;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 /**
  * {@link BuiltInMethod} for mapping between {@link Calendar} and {@link ZonedDateTime}.
  * <p>

File: processor/src/main/java/org/mapstruct/ap/internal/util/Strings.java
Patch:
@@ -127,8 +127,8 @@ public static boolean isEmpty(String string) {
         return string == null || string.isEmpty();
     }
 
-    public static String getSaveVariableName(String name, String... existingVariableNames) {
-        return getSaveVariableName( name, Arrays.asList( existingVariableNames ) );
+    public static String getSafeVariableName(String name, String... existingVariableNames) {
+        return getSafeVariableName( name, Arrays.asList( existingVariableNames ) );
     }
 
     /**
@@ -141,7 +141,7 @@ public static String getSaveVariableName(String name, String... existingVariable
      * @return a variable name based on the given original name, not conflicting with any of the given other names or
      * any Java keyword; starting with a lower-case letter
      */
-    public static String getSaveVariableName(String name, Collection<String> existingVariableNames) {
+    public static String getSafeVariableName(String name, Collection<String> existingVariableNames) {
         name = decapitalize( sanitizeIdentifierName( name ) );
         name = joinAndCamelize( extractParts( name ) );
 

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DateFormatValidatorFactoryTest.java
Patch:
@@ -172,7 +172,7 @@ private Type typeWithFQN(String fullQualifiedName) {
                         false,
                         false,
                         false,
-                        false );
+                        false);
     }
 
 }

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DefaultConversionContextTest.java
Patch:
@@ -123,7 +123,7 @@ private Type typeWithFQN(String fullQualifiedName) {
                         false,
                         false,
                         false,
-                        false );
+                        false);
     }
 
     private static class StatefulMessagerMock implements FormattingMessager {

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/ReferencedAccessibilityTest.java
Patch:
@@ -37,7 +37,7 @@ public class ReferencedAccessibilityTest {
         diagnostics = {
             @Diagnostic(type = SourceTargetMapperPrivate.class,
                 kind = javax.tools.Diagnostic.Kind.WARNING,
-                line = 35,
+                line = 22,
                 messageRegExp = "Unmapped target property: \"bar\"\\. Mapping from property \"org\\.mapstruct\\.ap\\" +
                     ".test\\.accessibility\\.referenced\\.ReferencedSource referencedSource\" to \"org\\.mapstruct\\" +
                     ".ap\\.test\\.accessibility\\.referenced\\.ReferencedTarget referencedTarget\"")
@@ -65,7 +65,7 @@ public void shouldBeAbleToAccessProtectedMethodInReferencedInSamePackage() throw
         diagnostics = {
             @Diagnostic(type = SourceTargetMapperDefaultOther.class,
                 kind = javax.tools.Diagnostic.Kind.WARNING,
-                line = 37,
+                line = 24,
                 messageRegExp = "Unmapped target property: \"bar\"\\. Mapping from property \"org\\.mapstruct\\.ap\\" +
                     ".test\\.accessibility\\.referenced\\.ReferencedSource referencedSource\" to \"org\\.mapstruct\\" +
                     ".ap\\.test\\.accessibility\\.referenced\\.ReferencedTarget referencedTarget\"")
@@ -88,7 +88,7 @@ public void shouldBeAbleToAccessProtectedMethodInBase() throws Exception { }
         diagnostics = {
             @Diagnostic(type = AbstractSourceTargetMapperPrivate.class,
                 kind = javax.tools.Diagnostic.Kind.WARNING,
-                line = 36,
+                line = 23,
                 messageRegExp = "Unmapped target property: \"bar\"\\. Mapping from property \"org\\.mapstruct\\.ap\\" +
                     ".test\\.accessibility\\.referenced\\.ReferencedSource referencedSource\" to \"org\\.mapstruct\\" +
                     ".ap\\.test\\.accessibility\\.referenced\\.ReferencedTarget referencedTarget\"")

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1029/Issue1029Test.java
Patch:
@@ -28,11 +28,11 @@ public class Issue1029Test {
 
     @Test
     @ExpectedCompilationOutcome(value = CompilationResult.FAILED, diagnostics = {
-        @Diagnostic(kind = Kind.WARNING, line = 39, type = ErroneousIssue1029Mapper.class,
+        @Diagnostic(kind = Kind.WARNING, line = 26, type = ErroneousIssue1029Mapper.class,
             messageRegExp = "Unmapped target properties: \"knownProp, lastUpdated, computedMapping\"\\."),
-        @Diagnostic(kind = Kind.WARNING, line = 50, type = ErroneousIssue1029Mapper.class,
+        @Diagnostic(kind = Kind.WARNING, line = 37, type = ErroneousIssue1029Mapper.class,
             messageRegExp = "Unmapped target property: \"lastUpdated\"\\."),
-        @Diagnostic(kind = Kind.ERROR, line = 55, type = ErroneousIssue1029Mapper.class,
+        @Diagnostic(kind = Kind.ERROR, line = 42, type = ErroneousIssue1029Mapper.class,
             messageRegExp = "Unknown property \"unknownProp\" in result type " +
                 "org.mapstruct.ap.test.bugs._1029.ErroneousIssue1029Mapper.Deck\\. Did you mean \"knownProp\"?")
     })

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1153/Issue1153Test.java
Patch:
@@ -26,17 +26,17 @@ public class Issue1153Test {
         diagnostics = {
             @Diagnostic(type = ErroneousIssue1153Mapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 32,
+                line = 19,
                 messageRegExp = "Property \"readOnly\" has no write accessor in " +
                     "org.mapstruct.ap.test.bugs._1153.ErroneousIssue1153Mapper.Target\\."),
             @Diagnostic(type = ErroneousIssue1153Mapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 33,
+                line = 20,
                 messageRegExp = "Property \"nestedTarget.readOnly\" has no write accessor in " +
                     "org.mapstruct.ap.test.bugs._1153.ErroneousIssue1153Mapper.Target\\."),
             @Diagnostic(type = ErroneousIssue1153Mapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 36,
+                line = 23,
                 messageRegExp = "Unknown property \"nestedTarget2.writable2\" in result type " +
                     "org.mapstruct.ap.test.bugs._1153.ErroneousIssue1153Mapper.Target\\. " +
                     "Did you mean \"nestedTarget2\\.writable\"")

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1180/Issue1180Test.java
Patch:
@@ -32,7 +32,7 @@ public class Issue1180Test {
         diagnostics = {
             @Diagnostic(type = SharedConfig.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 33,
+                line = 20,
                 messageRegExp = "No property named \"sourceProperty\\.nonExistant\" exists.*")
         })
     public void shouldCompileButNotGiveNullPointer() {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1242/Issue1242Test.java
Patch:
@@ -57,7 +57,7 @@ public void factoryMethodWithSourceParamIsChosen() {
         diagnostics = {
             @Diagnostic(type = ErroneousIssue1242MapperMultipleSources.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 33,
+                line = 20,
                 messageRegExp = "Ambiguous factory methods found for creating .*TargetB:"
                     + " .*TargetB anotherTargetBCreator\\(.*SourceB source\\),"
                     + " .*TargetB .*TargetFactories\\.createTargetB\\(.*SourceB source,"
@@ -66,7 +66,7 @@ public void factoryMethodWithSourceParamIsChosen() {
                     + " .*TargetB .*TargetFactories\\.createTargetB\\(\\)."),
             @Diagnostic(type = ErroneousIssue1242MapperMultipleSources.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 33,
+                line = 20,
                 messageRegExp = ".*TargetB does not have an accessible parameterless constructor\\.")
         })
     public void ambiguousMethodErrorForTwoFactoryMethodsWithSourceParam() {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1283/Issue1283Test.java
Patch:
@@ -32,7 +32,7 @@ public class Issue1283Test {
         diagnostics = {
             @Diagnostic(type = ErroneousInverseTargetHasNoSuitableConstructorMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 35L,
+                line = 22L,
                 messageRegExp = ".*\\._1283\\.Source does not have an accessible parameterless constructor"
             )
         }
@@ -47,7 +47,7 @@ public void inheritInverseConfigurationReturnTypeHasNoSuitableConstructor() {
         diagnostics = {
             @Diagnostic(type = ErroneousTargetHasNoSuitableConstructorMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 31L,
+                line = 18L,
                 messageRegExp = ".*\\._1283\\.Source does not have an accessible parameterless constructor"
             )
         }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1353/Issue1353Test.java
Patch:
@@ -34,13 +34,13 @@ public class Issue1353Test {
         diagnostics = {
             @Diagnostic (type = Issue1353Mapper.class,
                 kind = javax.tools.Diagnostic.Kind.WARNING,
-                line = 35,
+                line = 22,
                 messageRegExp = "The property named \" source.string1\" has whitespaces,"
                                 + " using trimmed property \"source.string1\" instead."
             ),
             @Diagnostic (type = Issue1353Mapper.class,
                 kind = javax.tools.Diagnostic.Kind.WARNING,
-                line = 35,
+                line = 22,
                 messageRegExp = "The property named \"string2 \" has whitespaces,"
                                 + " using trimmed property \"string2\" instead."
             )

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_631/Issue631Test.java
Patch:
@@ -29,11 +29,11 @@ public class Issue631Test {
         diagnostics = {
             @Diagnostic(type = ErroneousSourceTargetMapper.class,
                 kind = Kind.ERROR,
-                line = 35,
+                line = 22,
                 messageRegExp = "Can't generate mapping method for a generic type variable target."),
             @Diagnostic(type = ErroneousSourceTargetMapper.class,
                 kind = Kind.ERROR,
-                line = 37,
+                line = 24,
                 messageRegExp = "Can't generate mapping method for a generic type variable source.")
         }
     )

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_880/Issue880Test.java
Patch:
@@ -40,7 +40,7 @@ public class Issue880Test {
     @ExpectedCompilationOutcome(
         value = CompilationResult.SUCCEEDED,
         diagnostics = @Diagnostic(kind = Kind.WARNING,
-            type = UsesConfigFromAnnotationMapper.class, line = 29,
+            type = UsesConfigFromAnnotationMapper.class, line = 16,
             messageRegExp = "Unmapped target property: \"core\"\\."))
     public void compilationSucceedsAndAppliesCorrectComponentModel() {
         generatedSource.forMapper( UsesConfigFromAnnotationMapper.class ).containsNoImportFor( Component.class );

File: processor/src/test/java/org/mapstruct/ap/test/builder/simple/SimpleImmutableBuilderTest.java
Patch:
@@ -56,7 +56,7 @@ public void testSimpleImmutableBuilderHappyPath() {
         diagnostics = @Diagnostic(
             kind = javax.tools.Diagnostic.Kind.ERROR,
             type = ErroneousSimpleBuilderMapper.class,
-            line = 34,
+            line = 21,
             messageRegExp = "Unmapped target property: \"name\"\\."))
     public void testSimpleImmutableBuilderMissingPropertyFailsToCompile() {
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/CollectionMappingTest.java
Patch:
@@ -86,7 +86,7 @@ public void shouldForgeNewMapMappingMethod() {
         diagnostics = {
             @Diagnostic(type = ErroneousCollectionNonMappableSetMapper.class,
                 kind = Kind.ERROR,
-                line = 30,
+                line = 17,
                 messageRegExp = "Can't map Collection element \".* nonMappableSet\" to \".* nonMappableSet\". "
                     + "Consider to declare/implement a mapping method: .*."),
         }
@@ -106,12 +106,12 @@ public void shouldGenerateNonMappleMethodForSetMapping() {
         diagnostics = {
             @Diagnostic(type = ErroneousCollectionNonMappableMapMapper.class,
                 kind = Kind.ERROR,
-                line = 30,
+                line = 17,
                 messageRegExp = "Can't map Map key \".* nonMappableMap\\{:key\\}\" to \".* nonMappableMap\\{:key\\}\". "
                     + "Consider to declare/implement a mapping method: .*."),
             @Diagnostic(type = ErroneousCollectionNonMappableMapMapper.class,
                 kind = Kind.ERROR,
-                line = 30,
+                line = 17,
                 messageRegExp = "Can't map Map value \".* nonMappableMap\\{:value\\}\" to \".* " +
                     "nonMappableMap\\{:value\\}\". Consider to declare/implement a mapping method: .*."),
         }

File: processor/src/test/java/org/mapstruct/ap/test/collection/immutabletarget/ImmutableProductTest.java
Patch:
@@ -52,7 +52,7 @@ public void shouldHandleImmutableTarget() {
         diagnostics = {
             @Diagnostic(type = ErroneousCupboardMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 35,
+                line = 22,
                 messageRegExp = "No write accessor found for property \"content\" in target type.")
         }
     )

File: processor/src/test/java/org/mapstruct/ap/test/context/ContextParameterErroneousTest.java
Patch:
@@ -39,7 +39,7 @@ public class ContextParameterErroneousTest {
     @ExpectedCompilationOutcome(value = CompilationResult.FAILED,
         diagnostics = @Diagnostic(
             kind = Kind.ERROR,
-            line = 33,
+            line = 20,
             type = ErroneousNodeMapperWithNonUniqueContextTypes.class,
             messageRegExp = "The types of @Context parameters must be unique"))
     public void reportsNonUniqueContextParamType() {

File: processor/src/test/java/org/mapstruct/ap/test/decorator/DecoratorTest.java
Patch:
@@ -181,7 +181,7 @@ public void shouldApplyCustomMappers() {
         diagnostics = {
             @Diagnostic(type = ErroneousPersonMapper.class,
                 kind = Kind.ERROR,
-                line = 27,
+                line = 14,
                 messageRegExp = "Specified decorator type is no subtype of the annotated mapper type")
         }
     )

File: processor/src/test/java/org/mapstruct/ap/test/dependency/OrderingTest.java
Patch:
@@ -62,7 +62,7 @@ public void shouldApplySeveralDependenciesConfiguredForOneProperty() {
         diagnostics = {
             @Diagnostic(type = ErroneousAddressMapperWithCyclicDependency.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 37,
+                line = 24,
                 messageRegExp = "Cycle\\(s\\) between properties given via dependsOn\\(\\): firstName -> lastName -> "
                     + "middleName -> firstName"
             )
@@ -79,7 +79,7 @@ public void shouldReportErrorIfDependenciesContainCycle() {
         diagnostics = {
             @Diagnostic(type = ErroneousAddressMapperWithUnknownPropertyInDependsOn.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 32,
+                line = 19,
                 messageRegExp = "\"doesnotexist\" is no property of the method return type"
             )
         }

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousannotatedfactorymethod/AmbiguousAnnotatedFactoryTest.java
Patch:
@@ -29,7 +29,7 @@ public class AmbiguousAnnotatedFactoryTest {
         diagnostics = {
             @Diagnostic(type = SourceTargetMapperAndBarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 35,
+                line = 22,
                 messageRegExp = "Ambiguous factory methods found for creating "
                         + "org.mapstruct.ap.test.erroneous.ambiguousannotatedfactorymethod.Bar: "
                         + "org.mapstruct.ap.test.erroneous.ambiguousannotatedfactorymethod.Bar "
@@ -39,7 +39,7 @@ public class AmbiguousAnnotatedFactoryTest {
                     + "ambiguousannotatedfactorymethod.Foo foo\\)."),
             @Diagnostic(type = SourceTargetMapperAndBarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 35,
+                line = 22,
                 messageRegExp = ".*\\.ambiguousannotatedfactorymethod.Bar does not have an accessible parameterless " +
                     "constructor\\.")
 

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousfactorymethod/FactoryTest.java
Patch:
@@ -33,14 +33,14 @@ public class FactoryTest {
         diagnostics = {
             @Diagnostic(type = SourceTargetMapperAndBarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 35,
+                line = 22,
                 messageRegExp = "Ambiguous factory methods found for creating "
                         + "org.mapstruct.ap.test.erroneous.ambiguousfactorymethod.Bar: "
                         + "org.mapstruct.ap.test.erroneous.ambiguousfactorymethod.Bar createBar\\(\\), "
                         + "org.mapstruct.ap.test.erroneous.ambiguousfactorymethod.Bar .*BarFactory.createBar\\(\\)."),
             @Diagnostic(type = SourceTargetMapperAndBarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 35,
+                line = 22,
                 messageRegExp = ".*\\.ambiguousfactorymethod\\.Bar does not have an accessible parameterless "
                     + "constructor\\.")
 

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/annotationnotfound/AnnotationNotFoundTest.java
Patch:
@@ -32,7 +32,7 @@ public class AnnotationNotFoundTest {
             diagnostics = {
                 @Diagnostic( type = ErroneousMapper.class,
                         kind = Kind.ERROR,
-                        line = 30,
+                        line = 17,
                         messageRegExp = "NotFoundAnnotation")
             }
     )

File: processor/src/test/java/org/mapstruct/ap/test/ignore/IgnorePropertyTest.java
Patch:
@@ -81,7 +81,7 @@ public void propertyIsIgnoredInReverseMappingWhenSourceIsAlsoSpecifiedICWIgnore(
         diagnostics = {
             @Diagnostic(type = ErroneousTargetHasNoWriteAccessorMapper.class,
                 kind = Kind.ERROR,
-                line = 35,
+                line = 22,
                 messageRegExp = "Property \"hasClaws\" has no write accessor in " +
                     "org.mapstruct.ap.test.ignore.PreditorDto\\.")
         }

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/attribute/AttributeInheritanceTest.java
Patch:
@@ -43,7 +43,7 @@ public void shouldMapAttributeFromSuperType() {
         diagnostics = @Diagnostic(
             type = ErroneousTargetSourceMapper.class,
             kind = Kind.ERROR,
-            line = 29,
+            line = 16,
             messageRegExp = "Can't map property \"java.lang.CharSequence foo\" to \"java.lang.String foo\""
         ))
     public void shouldReportErrorDueToUnmappableAttribute() {

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/ComplexInheritanceTest.java
Patch:
@@ -68,7 +68,7 @@ public void shouldMapAttributesWithSuperTypeUsingOtherMapper() {
         diagnostics = @Diagnostic(
             kind = Kind.ERROR,
             type = ErroneousSourceCompositeTargetCompositeMapper.class,
-            line = 32,
+            line = 19,
             messageRegExp =
                 "Ambiguous mapping methods found for mapping property "
                     + "\"org.mapstruct.ap.test.inheritance.complex.SourceExt prop1\" to .*Reference: "

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/forged/ForgedStreamMappingTest.java
Patch:
@@ -69,7 +69,7 @@ public void shouldForgeNewIterableMappingMethod() {
         diagnostics = {
             @Diagnostic(type = ErroneousStreamNonMappableStreamMapper.class,
                 kind = Kind.ERROR,
-                line = 30,
+                line = 17,
                 messageRegExp = "Can't map Stream element \".* nonMappableStream\" to \".* nonMappableStream\". "
                     + "Consider to declare/implement a mapping method: .*."),
         }

File: processor/src/test/java/org/mapstruct/ap/test/mapperconfig/ConfigTest.java
Patch:
@@ -57,7 +57,7 @@ public void shouldUseCustomMapperViaMapperConfigForFooToDto() {
     @ExpectedCompilationOutcome(value = CompilationResult.SUCCEEDED,
         diagnostics = {
             @Diagnostic(type = SourceTargetMapperWarn.class,
-                kind = javax.tools.Diagnostic.Kind.WARNING, line = 37,
+                kind = javax.tools.Diagnostic.Kind.WARNING, line = 24,
                 messageRegExp = "Unmapped target property: \"noFoo\"")
         })
     public void shouldUseWARNViaMapper() {
@@ -68,7 +68,7 @@ public void shouldUseWARNViaMapper() {
     @ExpectedCompilationOutcome(value = CompilationResult.FAILED,
         diagnostics = {
             @Diagnostic(type = SourceTargetMapperErroneous.class,
-                kind = javax.tools.Diagnostic.Kind.ERROR, line = 33,
+                kind = javax.tools.Diagnostic.Kind.ERROR, line = 20,
                 messageRegExp = "Unmapped target property: \"noFoo\"")
         })
     public void shouldUseERRORViaMapperConfig() {

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/DisablingNestedSimpleBeansMappingTest.java
Patch:
@@ -32,7 +32,7 @@ public class DisablingNestedSimpleBeansMappingTest {
         diagnostics = {
             @Diagnostic(type = ErroneousDisabledHouseMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 29,
+                line = 16,
                 messageRegExp = "Can't map property \".*\\.Roof roof\" to \".*\\.RoofDto roof\"\\. Consider to " +
                     "declare/implement a mapping method: \".*\\.RoofDto map\\(.*\\.Roof value\\)\"\\."
             )
@@ -49,7 +49,7 @@ public void shouldUseDisabledMethodGenerationOnMapper() throws Exception {
         diagnostics = {
             @Diagnostic(type = ErroneousDisabledViaConfigHouseMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 29,
+                line = 16,
                 messageRegExp = "Can't map property \".*\\.Roof roof\" to \".*\\.RoofDto roof\"\\. Consider to " +
                     "declare/implement a mapping method: \".*\\.RoofDto map\\(.*\\.Roof value\\)\"\\."
             )

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/exclusions/custom/ErroneousCustomExclusionTest.java
Patch:
@@ -32,7 +32,7 @@ public class ErroneousCustomExclusionTest {
         diagnostics = {
             @Diagnostic(type = ErroneousCustomExclusionMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
-                line = 30,
+                line = 17,
                 messageRegExp = "Can't map property \".*NestedSource nested\" to \".*NestedTarget nested\"\\. " +
                     "Consider to declare/implement a mapping method: \".*NestedTarget map\\(.*NestedSource value\\)" +
                     "\"\\.")

File: processor/src/test/java/org/mapstruct/ap/test/nestedsourceproperties/NestedSourcePropertiesTest.java
Patch:
@@ -170,7 +170,7 @@ public void shouldUseGetAsTargetAccessor() {
             diagnostics = {
                 @Diagnostic( type = ArtistToChartEntryErroneous.class,
                         kind = javax.tools.Diagnostic.Kind.ERROR,
-                        line = 47,
+                        line = 34,
                         messageRegExp = "java.lang.Integer does not have an accessible parameterless constructor." )
             }
     )

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/QualifierTest.java
Patch:
@@ -100,7 +100,7 @@ public void shouldMatchClassAndMethod() {
             diagnostics = {
                 @Diagnostic( type = ErroneousMapper.class,
                         kind = Kind.ERROR,
-                        line = 42,
+                        line = 29,
                         messageRegExp = "Ambiguous mapping methods found for mapping property "
                                 + "\"java.lang.String title\" to java.lang.String.*" )
             }
@@ -173,12 +173,12 @@ public void testFactorySelectionWithQualifier() {
         diagnostics = {
             @Diagnostic(type = ErroneousMovieFactoryMapper.class,
                 kind = Kind.ERROR,
-                line = 37,
+                line = 24,
                 messageRegExp = "'nullValueMappingStrategy', 'resultType' and 'qualifiedBy' are undefined in " +
                     "@BeanMapping, define at least one of them."),
             @Diagnostic(type = ErroneousMovieFactoryMapper.class,
                 kind = Kind.ERROR,
-                line = 37,
+                line = 24,
                 messageRegExp = "The return type .*\\.AbstractEntry is an abstract class or interface. Provide a non " +
                     "abstract / non interface result type or a factory method.")
         }

File: core-common/src/main/java/org/mapstruct/Builder.java
Patch:
@@ -37,7 +37,7 @@
 public @interface Builder {
 
     /**
-     * The name of the build method that needs to be invoked on the builder to create the type being build
+     * The name of the build method that needs to be invoked on the builder to create the type to be build
      *
      * @return the method that needs to tbe invoked on the builder
      */

File: core-common/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -210,8 +210,8 @@
      * NOTE: In case no builder is defined here, in {@link BeanMapping} or {@link MapperConfig} and there is a single
      * build method, then that method would be used.
      * <p>
-     * If the builder is defined and there is a single method that does not match the name of the finisher than
-     * a compile error will occurs
+     * If the builder is defined and there is a single method that does not match the name of the build method then
+     * a compile error will occur
      *
      * @return the builder information
      *

File: core-common/src/main/java/org/mapstruct/MapperConfig.java
Patch:
@@ -198,8 +198,8 @@ MappingInheritanceStrategy mappingInheritanceStrategy()
      * NOTE: In case no builder is defined here, in {@link BeanMapping} or {@link Mapper} and there is a single
      * build method, then that method would be used.
      * <p>
-     * If the builder is defined and there is a single method that does not match the name of the finisher than
-     * a compile error will occurs
+     * If the builder is defined and there is a single method that does not match the name of the build method then
+     * a compile error will occur
      *
      * @return the builder information
      *

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -287,7 +287,7 @@ private MethodReference getFinalizerMethod(Type resultType) {
                 return null;
             }
 
-            return MethodReference.forMethodCall( builderType.getBuildMethod() );
+            return BuilderFinisherMethodResolver.getBuilderFinisherMethod( method, builderType, ctx );
         }
 
         /**

File: processor/src/main/java/org/mapstruct/ap/internal/prism/PrismGenerator.java
Patch:
@@ -24,6 +24,7 @@
 import org.mapstruct.AfterMapping;
 import org.mapstruct.BeanMapping;
 import org.mapstruct.BeforeMapping;
+import org.mapstruct.Builder;
 import org.mapstruct.Context;
 import org.mapstruct.DecoratedWith;
 import org.mapstruct.InheritConfiguration;
@@ -71,6 +72,7 @@
     @GeneratePrism(value = ValueMapping.class, publicAccess = true),
     @GeneratePrism(value = ValueMappings.class, publicAccess = true),
     @GeneratePrism(value = Context.class, publicAccess = true),
+    @GeneratePrism(value = Builder.class, publicAccess = true),
 
     // external types
     @GeneratePrism(value = XmlElementDecl.class, publicAccess = true),

File: processor/src/main/java/org/mapstruct/ap/internal/processor/DefaultModelElementProcessorContext.java
Patch:
@@ -64,6 +64,7 @@ public DefaultModelElementProcessorContext(ProcessingEnvironment processingEnvir
         this.typeFactory = new TypeFactory(
             processingEnvironment.getElementUtils(),
             delegatingTypes,
+            messager,
             roundContext
         );
         this.options = options;

File: processor/src/main/java/org/mapstruct/ap/spi/BuilderProvider.java
Patch:
@@ -40,6 +40,8 @@ public interface BuilderProvider {
      *
      * @throws TypeHierarchyErroneousException if the type that needs to be visited is not ready yet, this signals the
      * MapStruct processor to postpone the generation of the mappers to the next round
+     * @throws MoreThanOneBuilderCreationMethodException if {@code type} has more than one method that can create the
+     * builder
      */
     BuilderInfo findBuilderInfo(TypeMirror type, Elements elements, Types types);
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -101,7 +101,7 @@ public Builder mappingContext(MappingBuilderContext mappingContext) {
             return this;
         }
 
-        public Builder souceMethod(SourceMethod sourceMethod) {
+        public Builder sourceMethod(SourceMethod sourceMethod) {
             singleMapping = new SourceMethodSingleMapping( sourceMethod );
             return setupMethodWithMapping( sourceMethod );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/EnumMappingMethod.java
Patch:
@@ -58,7 +58,7 @@ public Builder mappingContext(MappingBuilderContext mappingContext) {
             return this;
         }
 
-        public Builder souceMethod(SourceMethod sourceMethod) {
+        public Builder sourceMethod(SourceMethod sourceMethod) {
             this.method = sourceMethod;
             return this;
         }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -340,7 +340,7 @@ else if ( method.isEnumMapping() ) {
                 EnumMappingMethod.Builder builder = new EnumMappingMethod.Builder();
                 MappingMethod enumMappingMethod = builder
                     .mappingContext( mappingContext )
-                    .souceMethod( method )
+                    .sourceMethod( method )
                     .build();
 
                 if ( enumMappingMethod != null ) {
@@ -371,7 +371,7 @@ else if ( method.isStreamMapping() ) {
                 BeanMappingMethod.Builder builder = new BeanMappingMethod.Builder();
                 BeanMappingMethod beanMappingMethod = builder
                     .mappingContext( mappingContext )
-                    .souceMethod( method )
+                    .sourceMethod( method )
                     .nullValueMappingStrategy( nullValueMappingStrategy )
                     .selectionParameters( selectionParameters )
                     .build();

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -598,6 +598,7 @@ private Assignment forgeIterableMapping(Type sourceType, Type targetType, Source
         private Assignment forgeWithElementMapping(Type sourceType, Type targetType, SourceRHS source,
             ExecutableElement element, ContainerMappingMethodBuilder<?, ? extends ContainerMappingMethod> builder) {
 
+            targetType = targetType.withoutBounds();
             ForgedMethod methodRef = prepareForgedMethod( sourceType, targetType, source, element, "[]" );
 
             ContainerMappingMethod iterableMappingMethod = builder
@@ -634,6 +635,7 @@ private ForgedMethod prepareForgedMethod(Type sourceType, Type targetType, Sourc
         private Assignment forgeMapMapping(Type sourceType, Type targetType, SourceRHS source,
                                            ExecutableElement element) {
 
+            targetType = targetType.withoutBounds();
             ForgedMethod methodRef = prepareForgedMethod( sourceType, targetType, source, element, "{}" );
 
             MapMappingMethod.Builder builder = new MapMappingMethod.Builder();

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -260,7 +260,7 @@ private Assignment getTargetAssignment(Type sourceType, Type targetType) {
             // In case of 1. and the target type is still a wrapped or primitive type we must assume that the check
             // in NativeType is not successful. We don't want to go through type conversion, double mappings etc.
             // with something that we already know to be wrong.
-            if ( sourceType.hasOriginatedFromConstant()
+            if ( sourceType.isLiteral()
                 && "java.lang.String".equals( sourceType.getFullyQualifiedName( ) )
                 && targetType.isNative() ) {
                 // TODO: convey some error message

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -68,6 +68,7 @@ public enum Message {
     PROPERTYMAPPING_WHITESPACE_TRIMMED( "The property named \"%s\" has whitespaces, using trimmed property \"%s\" instead.", Diagnostic.Kind.WARNING ),
 
     CONSTANTMAPPING_MAPPING_NOT_FOUND( "Can't map \"%s %s\" to \"%s %s\"." ),
+    CONSTANTMAPPING_MAPPING_NOT_FOUND_WITH_DETAILS( "Can't map \"%s %s\" to \"%s %s\". Reason: %s." ),
     CONSTANTMAPPING_NO_READ_ACCESSOR_FOR_TARGET_TYPE( "No read accessor found for property \"%s\" in target type." ),
     CONSTANTMAPPING_NON_EXISTING_CONSTANT( "Constant %s doesn't exist in enum type %s for property \"%s\"." ),
 

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DateFormatValidatorFactoryTest.java
Patch:
@@ -185,7 +185,6 @@ private Type typeWithFQN(String fullQualifiedName) {
                         false,
                         false,
                         false,
-                        false,
                         false );
     }
 

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DefaultConversionContextTest.java
Patch:
@@ -136,7 +136,6 @@ private Type typeWithFQN(String fullQualifiedName) {
                         false,
                         false,
                         false,
-                        false,
                         false );
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/AbstractNumberToStringConversion.java
Patch:
@@ -40,7 +40,6 @@ public abstract class AbstractNumberToStringConversion extends SimpleConversion
     private final boolean sourceTypeNumberSubclass;
 
     public AbstractNumberToStringConversion(boolean sourceTypeNumberSubclass) {
-
         this.sourceTypeNumberSubclass = sourceTypeNumberSubclass;
     }
 
@@ -77,5 +76,4 @@ protected List<Type> getFromConversionExceptionTypes(ConversionContext conversio
             return super.getFromConversionExceptionTypes( conversionContext );
         }
     }
-
 }

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/DateToSqlTimeConversion.java
Patch:
@@ -25,6 +25,8 @@
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.util.Collections;
 
+import static org.mapstruct.ap.internal.conversion.ConversionUtils.time;
+
 /**
  * Conversion between {@link java.util.Date} and {@link java.sql.Time}.
  *
@@ -34,7 +36,7 @@ public class DateToSqlTimeConversion extends SimpleConversion {
 
     @Override
     protected String getToExpression(ConversionContext conversionContext) {
-        return "new Time( <SOURCE>.getTime() )";
+        return "new " + time( conversionContext ) + "( <SOURCE>.getTime() )";
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/DateToSqlTimestampConversion.java
Patch:
@@ -25,6 +25,8 @@
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.util.Collections;
 
+import static org.mapstruct.ap.internal.conversion.ConversionUtils.timestamp;
+
 /**
  * Conversion between {@link java.util.Date} and {@link java.sql.Timestamp}.
  *
@@ -34,7 +36,7 @@ public class DateToSqlTimestampConversion extends SimpleConversion {
 
     @Override
     protected String getToExpression(ConversionContext conversionContext) {
-        return "new Timestamp( <SOURCE>.getTime() )";
+        return "new " + timestamp( conversionContext ) + "( <SOURCE>.getTime() )";
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/JodaTimeToDateConversion.java
Patch:
@@ -45,7 +45,7 @@ protected String getToExpression(ConversionContext conversionContext) {
 
     @Override
     protected String getFromExpression(ConversionContext conversionContext) {
-        return "new " + conversionContext.getTargetType().getName() + "( <SOURCE> )";
+        return "new " + conversionContext.getTargetType().getReferenceName() + "( <SOURCE> )";
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/MappingProcessor.java
Patch:
@@ -127,7 +127,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         super.init( processingEnv );
 
         options = createOptions();
-        annotationProcessorContext = new AnnotationProcessorContext();
+        annotationProcessorContext = new AnnotationProcessorContext( processingEnv.getElementUtils() );
     }
 
     private Options createOptions() {

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -260,7 +260,9 @@ private Assignment getTargetAssignment(Type sourceType, Type targetType) {
             // In case of 1. and the target type is still a wrapped or primitive type we must assume that the check
             // in NativeType is not successful. We don't want to go through type conversion, double mappings etc.
             // with something that we already know to be wrong.
-            if ( sourceType.hasOriginatedFromConstant() && ( targetType.isPrimitive() || targetType.isBoxed() ) ) {
+            if ( sourceType.hasOriginatedFromConstant()
+                && "java.lang.String".equals( sourceType.getFullyQualifiedName( ) )
+                && targetType.isNative() ) {
                 // TODO: convey some error message
                 return null;
             }

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/SourceConstantsTest.java
Patch:
@@ -217,7 +217,7 @@ public void shouldMapSameSourcePropertyToSeveralTargetPropertiesFromSeveralSourc
     public void errorOnNonExistingEnumConstant() throws ParseException {
     }
 
-   @Test
+    @Test
     @IssueKey("1401")
     @WithClasses({
         Source.class,

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -101,7 +101,6 @@ public enum Message {
 
     RETRIEVAL_NO_INPUT_ARGS( "Can't generate mapping method with no input arguments." ),
     RETRIEVAL_DUPLICATE_MAPPING_TARGETS( "Can't generate mapping method with more than one @MappingTarget parameter." ),
-    RETRIEVAL_IMMUTABLE_TARGET( "Can't generate mapping method when @MappingTarget is supposed to be immutable (has a builder)." ),
     RETRIEVAL_VOID_MAPPING_METHOD( "Can't generate mapping method with return type void." ),
     RETRIEVAL_NON_ASSIGNABLE_RESULTTYPE( "The result type is not assignable to the the return type." ),
     RETRIEVAL_ITERABLE_TO_NON_ITERABLE( "Can't generate mapping method from iterable type to non-iterable type." ),

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -59,7 +59,7 @@ public enum Message {
     PROPERTYMAPPING_DEFAULT_VALUE_AND_DEFAULT_EXPRESSION_BOTH_DEFINED( "Default value and default expression are both defined in @Mapping, either define a default value or a default expression." ),
     PROPERTYMAPPING_INVALID_EXPRESSION( "Value for expression must be given in the form \"java(<EXPRESSION>)\"." ),
     PROPERTYMAPPING_INVALID_DEFAULT_EXPRESSION( "Value for default expression must be given in the form \"java(<EXPRESSION>)\"." ),
-    PROPERTYMAPPING_INVALID_PARAMETER_NAME( "Method has no parameter named \"%s\"." ),
+    PROPERTYMAPPING_INVALID_PARAMETER_NAME( "Method has no source parameter named \"%s\". Method source parameters are: \"%s\"." ),
     PROPERTYMAPPING_NO_PROPERTY_IN_PARAMETER( "The type of parameter \"%s\" has no property named \"%s\"." ),
     PROPERTYMAPPING_INVALID_PROPERTY_NAME( "No property named \"%s\" exists in source parameter(s). Did you mean \"%s\"?" ),
     PROPERTYMAPPING_NO_PRESENCE_CHECKER_FOR_SOURCE_TYPE( "Using custom source value presence checking strategy, but no presence checker found for %s in source type." ),

File: integrationtest/src/test/java/org/mapstruct/itest/tests/FullFeatureCompilationTest.java
Patch:
@@ -73,6 +73,7 @@ public Collection<String> getAdditionalCommandLineArguments(ProcessorType proces
                 case ECLIPSE_JDT_JAVA_6:
                 case ORACLE_JAVA_7:
                 case ECLIPSE_JDT_JAVA_7:
+                    additionalExcludes.add( "org/mapstruct/ap/test/bugs/_1425/*.java" );
                     additionalExcludes.add( "**/java8*/**/*.java" );
                     break;
                 case ORACLE_JAVA_9:

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -138,7 +138,7 @@ public MethodReference getFactoryMethod(final Method mappingMethod, Type targetT
                 mappingMethod,
                 sourceModel,
                 java.util.Collections.<Type> emptyList(),
-                targetType,
+                targetType.getEffectiveType(),
                 SelectionCriteria.forFactoryMethods( selectionParameters ) );
 
         if (matchingFactoryMethods.isEmpty()) {
@@ -149,7 +149,7 @@ java.util.Collections.<Type> emptyList(),
             messager.printMessage(
                 mappingMethod.getExecutable(),
                 Message.GENERAL_AMBIGIOUS_FACTORY_METHOD,
-                targetType,
+                targetType.getEffectiveType(),
                 Strings.join( matchingFactoryMethods, ", " ) );
 
             return null;

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -95,6 +95,7 @@ public enum Message {
     GENERAL_UNSUPPORTED_DATE_FORMAT_CHECK( "No dateFormat check is supported for types %s, %s" ),
     GENERAL_VALID_DATE( "Given date format \"%s\" is valid.", Diagnostic.Kind.NOTE ),
     GENERAL_INVALID_DATE( "Given date format \"%s\" is invalid. Message: \"%s\"." ),
+    GENERAL_JODA_NOT_ON_CLASSPATH( "Cannot validate Joda dateformat, no Joda on classpath. Consider adding Joda to the annotation processorpath.", Diagnostic.Kind.WARNING ),
     GENERAL_NOT_ALL_FORGED_CREATED( "Internal Error in creation of Forged Methods, it was expected all Forged Methods to finished with creation, but %s did not" ),
     GENERAL_NO_SUITABLE_CONSTRUCTOR( "%s does not have an accessible parameterless constructor." ),
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/MethodSelectors.java
Patch:
@@ -44,7 +44,7 @@ public MethodSelectors(Types typeUtils, Elements elementUtils, TypeFactory typeF
             new TypeSelector( typeFactory ),
             new QualifierSelector( typeUtils, elementUtils ),
             new TargetTypeSelector( typeUtils, elementUtils ),
-            new XmlElementDeclSelector( typeUtils, elementUtils ),
+            new XmlElementDeclSelector( typeUtils ),
             new InheritanceSelector(),
             new CreateOrUpdateSelector(),
             new FactoryParameterSelector() );

File: core-common/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -47,7 +47,8 @@
 
     /**
      * Additional types for which an import statement is to be added to the generated mapper implementation class.
-     * This allows to refer to those types from within mapping expressions given via {@link Mapping#expression()} using
+     * This allows to refer to those types from within mapping expressions given via {@link Mapping#expression()},
+     * {@link Mapping#defaultExpression()} or using
      * their simple name rather than their fully-qualified name.
      *
      * @return classes to add in the imports of the generated implementation.

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -455,6 +455,7 @@ else if ( mapping.getSourceName() != null ) {
                         .existingVariableNames( existingVariableNames )
                         .dependsOn( mapping.getDependsOn() )
                         .defaultValue( mapping.getDefaultValue() )
+                        .defaultJavaExpression( mapping.getDefaultJavaExpression() )
                         .build();
                     handledTargets.add( propertyName );
                     unprocessedSourceParameters.remove( sourceRef.getParameter() );

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -92,7 +92,7 @@ public enum Message {
     GENERAL_VALID_DATE( "Given date format \"%s\" is valid.", Diagnostic.Kind.NOTE ),
     GENERAL_INVALID_DATE( "Given date format \"%s\" is invalid. Message: \"%s\"." ),
     GENERAL_NOT_ALL_FORGED_CREATED( "Internal Error in creation of Forged Methods, it was expected all Forged Methods to finished with creation, but %s did not" ),
-    GENERAL_NO_SUITABLE_CONSTRUCTOR( "%s does not have an accessible empty constructor." ),
+    GENERAL_NO_SUITABLE_CONSTRUCTOR( "%s does not have an accessible parameterless constructor." ),
 
     RETRIEVAL_NO_INPUT_ARGS( "Can't generate mapping method with no input arguments." ),
     RETRIEVAL_DUPLICATE_MAPPING_TARGETS( "Can't generate mapping method with more than one @MappingTarget parameter." ),

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1242/Issue1242Test.java
Patch:
@@ -80,7 +80,7 @@ public void factoryMethodWithSourceParamIsChosen() {
             @Diagnostic(type = ErroneousIssue1242MapperMultipleSources.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 33,
-                messageRegExp = ".*TargetB does not have an accessible empty constructor\\.")
+                messageRegExp = ".*TargetB does not have an accessible parameterless constructor\\.")
         })
     public void ambiguousMethodErrorForTwoFactoryMethodsWithSourceParam() {
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1283/Issue1283Test.java
Patch:
@@ -46,7 +46,7 @@ public class Issue1283Test {
             @Diagnostic(type = ErroneousInverseTargetHasNoSuitableConstructorMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 35L,
-                messageRegExp = ".*\\._1283\\.Source does not have an accessible empty constructor"
+                messageRegExp = ".*\\._1283\\.Source does not have an accessible parameterless constructor"
             )
         }
     )
@@ -61,7 +61,7 @@ public void inheritInverseConfigurationReturnTypeHasNoSuitableConstructor() {
             @Diagnostic(type = ErroneousTargetHasNoSuitableConstructorMapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 31L,
-                messageRegExp = ".*\\._1283\\.Source does not have an accessible empty constructor"
+                messageRegExp = ".*\\._1283\\.Source does not have an accessible parameterless constructor"
             )
         }
     )

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousannotatedfactorymethod/AmbiguousAnnotatedFactoryTest.java
Patch:
@@ -53,7 +53,7 @@ public class AmbiguousAnnotatedFactoryTest {
             @Diagnostic(type = SourceTargetMapperAndBarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 35,
-                messageRegExp = ".*\\.ambiguousannotatedfactorymethod.Bar does not have an accessible empty " +
+                messageRegExp = ".*\\.ambiguousannotatedfactorymethod.Bar does not have an accessible parameterless " +
                     "constructor\\.")
 
         }

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousfactorymethod/FactoryTest.java
Patch:
@@ -54,7 +54,8 @@ public class FactoryTest {
             @Diagnostic(type = SourceTargetMapperAndBarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 35,
-                messageRegExp = ".*\\.ambiguousfactorymethod\\.Bar does not have an accessible empty constructor\\.")
+                messageRegExp = ".*\\.ambiguousfactorymethod\\.Bar does not have an accessible parameterless "
+                    + "constructor\\.")
 
         }
     )

File: processor/src/test/java/org/mapstruct/ap/test/nestedsourceproperties/NestedSourcePropertiesTest.java
Patch:
@@ -184,7 +184,7 @@ public void shouldUseGetAsTargetAccessor() {
                 @Diagnostic( type = ArtistToChartEntryErroneous.class,
                         kind = javax.tools.Diagnostic.Kind.ERROR,
                         line = 47,
-                        messageRegExp = "java.lang.Integer does not have an accessible empty constructor." )
+                        messageRegExp = "java.lang.Integer does not have an accessible parameterless constructor." )
             }
     )
     @WithClasses({ ArtistToChartEntryErroneous.class })

File: processor/src/test/java/org/mapstruct/ap/test/selection/generics/ConversionTest.java
Patch:
@@ -182,7 +182,7 @@ public void shouldFailOnSuperBounds2() {
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 29,
                 messageRegExp = ".*\\.generics\\.WildCardSuperWrapper<.*\\.generics\\.TypeA> does not have an " +
-                    "accessible empty constructor\\.")
+                    "accessible parameterless constructor\\.")
 
         })
     public void shouldFailOnNonMatchingWildCards() {

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/InheritanceSelectionTest.java
Patch:
@@ -64,7 +64,7 @@ public class InheritanceSelectionTest {
             @Diagnostic(type = ErroneousFruitMapper.class,
                 kind = Kind.ERROR,
                 line = 36,
-                messageRegExp = ".*Fruit does not have an accessible empty constructor\\.")
+                messageRegExp = ".*Fruit does not have an accessible parameterless constructor\\.")
         }
     )
     public void testForkedInheritanceHierarchyShouldResultInAmbigousMappingMethod() {
@@ -79,7 +79,7 @@ public void testForkedInheritanceHierarchyShouldResultInAmbigousMappingMethod()
             @Diagnostic(type = ErroneousResultTypeNoEmptyConstructorMapper.class,
                 kind = Kind.ERROR,
                 line = 31,
-                messageRegExp = ".*\\.resulttype\\.Banana does not have an accessible empty constructor\\.")
+                messageRegExp = ".*\\.resulttype\\.Banana does not have an accessible parameterless constructor\\.")
         }
     )
     public void testResultTypeHasNoSuitableEmptyConstructor() {

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/UpdateMethodsTest.java
Patch:
@@ -188,7 +188,7 @@ public void testShouldFailOnPropertyMappingNoPropertyGetter() { }
             @Diagnostic(type = ErroneousOrganizationMapper2.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 48,
-                messageRegExp = ".*\\.updatemethods\\.DepartmentEntity does not have an accessible empty " +
+                messageRegExp = ".*\\.updatemethods\\.DepartmentEntity does not have an accessible parameterless " +
                     "constructor\\.")
 
         })

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -504,6 +504,7 @@ Collections.<Parameter> emptyList(),
                 NestedPropertyMappingMethod nestedPropertyMapping = builder
                     .method( methodRef )
                     .propertyEntries( sourceReference.getPropertyEntries() )
+                    .mappingContext( ctx )
                     .build();
 
                 // add if not yet existing

File: processor/src/test/java/org/mapstruct/ap/test/decorator/spring/field/PersonMapper.java
Patch:
@@ -16,17 +16,18 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.decorator.spring;
+package org.mapstruct.ap.test.decorator.spring.field;
 
 import org.mapstruct.DecoratedWith;
+import org.mapstruct.InjectionStrategy;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.ap.test.decorator.Address;
 import org.mapstruct.ap.test.decorator.AddressDto;
 import org.mapstruct.ap.test.decorator.Person;
 import org.mapstruct.ap.test.decorator.PersonDto;
 
-@Mapper(componentModel = "spring")
+@Mapper(componentModel = "spring", injectionStrategy = InjectionStrategy.FIELD)
 @DecoratedWith(PersonMapperDecorator.class)
 public interface PersonMapper {
 

File: processor/src/test/java/org/mapstruct/ap/test/decorator/spring/field/PersonMapperDecorator.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.decorator.spring;
+package org.mapstruct.ap.test.decorator.spring.field;
 
 import org.mapstruct.ap.test.decorator.Person;
 import org.mapstruct.ap.test.decorator.PersonDto;

File: processor/src/test/java/org/mapstruct/ap/test/decorator/spring/field/SpringDecoratorTest.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.decorator.spring;
+package org.mapstruct.ap.test.decorator.spring.field;
 
 import static org.assertj.core.api.Assertions.assertThat;
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/DateFormatValidatorFactory.java
Patch:
@@ -25,6 +25,7 @@
 import org.mapstruct.ap.internal.util.JavaTimeConstants;
 import org.mapstruct.ap.internal.util.JodaTimeConstants;
 import org.mapstruct.ap.internal.util.Message;
+import org.mapstruct.ap.internal.util.XmlConstants;
 
 /**
  * Factory for {@link DateFormatValidator}. <p> Based on the types of source / target type  a specific {@link
@@ -42,7 +43,6 @@ final class DateFormatValidatorFactory {
     private static final String ORG_JODA_TIME_FORMAT_DATE_TIME_FORMAT = "org.joda.time.format.DateTimeFormat";
 
     private static final String FOR_PATTERN = "forPattern";
-    private static final String JAVAX_XML_DATATYPE_XMLGREGORIAN_CALENDAR = "javax.xml.datatype.XMLGregorianCalendar";
 
     private DateFormatValidatorFactory() {
     }
@@ -85,7 +85,7 @@ public DateFormatValidationResult validate(String dateFormat) {
 
     private static boolean isXmlGregorianCalendarSupposedToBeMapped(Type sourceType, Type targetType) {
         return typesEqualsOneOf(
-                        sourceType, targetType, JAVAX_XML_DATATYPE_XMLGREGORIAN_CALENDAR );
+                        sourceType, targetType, XmlConstants.JAVAX_XML_DATATYPE_XMLGREGORIAN_CALENDAR );
     }
 
     private static boolean isJodaDateTimeSupposed(Type sourceType, Type targetType) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/MethodSelectors.java
Patch:
@@ -46,7 +46,8 @@ public MethodSelectors(Types typeUtils, Elements elementUtils, TypeFactory typeF
             new TargetTypeSelector( typeUtils, elementUtils ),
             new XmlElementDeclSelector( typeUtils, elementUtils ),
             new InheritanceSelector(),
-            new CreateOrUpdateSelector() );
+            new CreateOrUpdateSelector(),
+            new FactoryParameterSelector() );
     }
 
     /**

File: core-common/src/main/java/org/mapstruct/ObjectFactory.java
Patch:
@@ -30,7 +30,7 @@
  * return type that is assignable to the required object type is present, then the factory method is used instead.
  * <p>
  * Factory methods can be defined without parameters, with an {@code @}{@link TargetType} parameter, a {@code @}
- * {@link Context} parameter, or with a mapping methods source parameter. If any of those parameters are defined, then
+ * {@link Context} parameter, or with the mapping source parameter. If any of those parameters are defined, then
  * the mapping method that is supposed to use the factory method needs to be declared with an assignable result type,
  * assignable context parameter, and/or assignable source types.
  * <p>

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/ConversionProvider.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.util.List;
 import org.mapstruct.ap.internal.model.TypeConversion;
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.HelperMethod;
 

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/DateToStringConversion.java
Patch:
@@ -27,10 +27,10 @@
 import java.util.Date;
 import java.util.List;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
-import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.HelperMethod;
 import org.mapstruct.ap.internal.model.TypeConversion;
+import org.mapstruct.ap.internal.model.common.Assignment;
+import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/ReverseConversion.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.util.Collections;
 import java.util.List;
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.HelperMethod;
 

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/SimpleConversion.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Set;
 
 import org.mapstruct.ap.internal.model.TypeConversion;
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.HelperMethod;
 import org.mapstruct.ap.internal.model.common.Type;

File: processor/src/main/java/org/mapstruct/ap/internal/model/AbstractBaseBuilder.java
Patch:
@@ -18,8 +18,9 @@
  */
 package org.mapstruct.ap.internal.model;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ParameterBinding;
+import org.mapstruct.ap.internal.model.common.SourceRHS;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.ForgedMethod;
 import org.mapstruct.ap.internal.model.source.MappingMethodUtils;

File: processor/src/main/java/org/mapstruct/ap/internal/model/AbstractMappingMethodBuilder.java
Patch:
@@ -19,7 +19,8 @@
 
 package org.mapstruct.ap.internal.model;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
+import org.mapstruct.ap.internal.model.common.SourceRHS;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.ForgedMethod;
 import org.mapstruct.ap.internal.model.source.ForgedMethodHistory;

File: processor/src/main/java/org/mapstruct/ap/internal/model/ContainerMappingMethod.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.Method;

File: processor/src/main/java/org/mapstruct/ap/internal/model/ContainerMappingMethodBuilder.java
Patch:
@@ -25,10 +25,11 @@
 import java.util.List;
 import java.util.Set;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
+import org.mapstruct.ap.internal.model.common.FormattingParameters;
+import org.mapstruct.ap.internal.model.common.SourceRHS;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.ForgedMethod;
-import org.mapstruct.ap.internal.model.common.FormattingParameters;
 import org.mapstruct.ap.internal.model.source.Method;
 import org.mapstruct.ap.internal.model.source.SelectionParameters;
 import org.mapstruct.ap.internal.prism.NullValueMappingStrategyPrism;

File: processor/src/main/java/org/mapstruct/ap/internal/model/IterableMappingMethod.java
Patch:
@@ -23,9 +23,9 @@
 import java.util.Collection;
 import java.util.List;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
 import org.mapstruct.ap.internal.model.assignment.LocalVarWrapper;
 import org.mapstruct.ap.internal.model.assignment.SetterWrapper;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.Method;
 import org.mapstruct.ap.internal.model.source.SelectionParameters;

File: processor/src/main/java/org/mapstruct/ap/internal/model/MapMappingMethod.java
Patch:
@@ -24,12 +24,13 @@
 import java.util.Map;
 import java.util.Set;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
 import org.mapstruct.ap.internal.model.assignment.LocalVarWrapper;
+import org.mapstruct.ap.internal.model.common.Assignment;
+import org.mapstruct.ap.internal.model.common.FormattingParameters;
 import org.mapstruct.ap.internal.model.common.Parameter;
+import org.mapstruct.ap.internal.model.common.SourceRHS;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.ForgedMethod;
-import org.mapstruct.ap.internal.model.common.FormattingParameters;
 import org.mapstruct.ap.internal.model.source.Method;
 import org.mapstruct.ap.internal.model.source.SelectionParameters;
 import org.mapstruct.ap.internal.prism.NullValueMappingStrategyPrism;

File: processor/src/main/java/org/mapstruct/ap/internal/model/MappingBuilderContext.java
Patch:
@@ -28,8 +28,9 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.FormattingParameters;
+import org.mapstruct.ap.internal.model.common.SourceRHS;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.model.source.ForgedMethod;

File: processor/src/main/java/org/mapstruct/ap/internal/model/MethodReference.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.ParameterBinding;

File: processor/src/main/java/org/mapstruct/ap/internal/model/StreamMappingMethod.java
Patch:
@@ -26,8 +26,8 @@
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
 import org.mapstruct.ap.internal.model.assignment.Java8FunctionWrapper;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.source.Method;
 import org.mapstruct.ap.internal.model.source.SelectionParameters;

File: processor/src/main/java/org/mapstruct/ap/internal/model/TypeConversion.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ModelElement;
 import org.mapstruct.ap.internal.model.common.Type;
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/AdderWrapper.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.util.Nouns;
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/ArrayCopyWrapper.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/AssignmentWrapper.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ModelElement;
 import org.mapstruct.ap.internal.model.common.Type;
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/EnumConstantWrapper.java
Patch:
@@ -20,6 +20,8 @@
 
 import java.util.HashSet;
 import java.util.Set;
+
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/ExistingInstanceSetterWrapperForCollectionsAndMaps.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.List;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.prism.NullValueCheckStrategyPrism;

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/GetterWrapperForCollectionsAndMaps.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/Java8FunctionWrapper.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**
@@ -53,7 +54,7 @@ public Set<Type> getImportTypes() {
     /**
      *
      * @return {@code true} if the wrapped assignment is
-     * {@link org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType#DIRECT}, {@code false} otherwise
+     * {@link Assignment.AssignmentType#DIRECT}, {@code false} otherwise
      */
     public boolean isDirectAssignment() {
         return getAssignment().getType() == AssignmentType.DIRECT;

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/LocalVarWrapper.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/SetterWrapper.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.prism.NullValueCheckStrategyPrism;
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/SetterWrapperForCollectionsAndMaps.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.List;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/SetterWrapperForCollectionsAndMapsWithNullCheck.java
Patch:
@@ -23,10 +23,11 @@
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 
-import static org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType.DIRECT;
+import static org.mapstruct.ap.internal.model.common.Assignment.AssignmentType.DIRECT;
 
 /**
  * This wrapper handles the situation where an assignment is done via the setter and a null check is needed.

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/WrapperForCollectionsAndMaps.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.Type;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Assignment.java
Patch:
@@ -16,13 +16,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.internal.model.assignment;
+package org.mapstruct.ap.internal.model.common;
 
 import java.util.List;
 import java.util.Set;
 
-import org.mapstruct.ap.internal.model.common.Type;
-
 /**
  * Assignment represents all kind of manners a source can be assigned to a target.
  *

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -42,14 +42,14 @@
 import org.mapstruct.ap.internal.model.MapperReference;
 import org.mapstruct.ap.internal.model.MappingBuilderContext.MappingResolver;
 import org.mapstruct.ap.internal.model.MethodReference;
-import org.mapstruct.ap.internal.model.SourceRHS;
 import org.mapstruct.ap.internal.model.VirtualMappingMethod;
-import org.mapstruct.ap.internal.model.assignment.Assignment;
+import org.mapstruct.ap.internal.model.common.Assignment;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.DefaultConversionContext;
+import org.mapstruct.ap.internal.model.common.FormattingParameters;
+import org.mapstruct.ap.internal.model.common.SourceRHS;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
-import org.mapstruct.ap.internal.model.common.FormattingParameters;
 import org.mapstruct.ap.internal.model.source.Method;
 import org.mapstruct.ap.internal.model.source.SelectionParameters;
 import org.mapstruct.ap.internal.model.source.builtin.BuiltInMappingMethods;

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -760,8 +760,9 @@ public List<PropertyMapping> getConstantMappings() {
         return constantMappings;
     }
 
-    public Map<String, List<PropertyMapping>> getPropertyMappingsByParameter() {
-        return mappingsByParameter;
+    public List<PropertyMapping> propertyMappingsByParameter(Parameter parameter) {
+        // issues: #909 and #1244. FreeMarker has problem getting values from a map when the search key is size or value
+        return mappingsByParameter.get( parameter.getName() );
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Parameter.java
Patch:
@@ -44,8 +44,7 @@ public class Parameter extends ModelElement {
     private final boolean mappingContext;
 
     private Parameter(String name, Type type, boolean mappingTarget, boolean targetType, boolean mappingContext) {
-        // issue #909: FreeMarker doesn't like "values" as a parameter name
-        this.name = "values".equals( name ) ? "values_" : name;
+        this.name = name;
         this.originalName = name;
         this.type = type;
         this.mappingTarget = mappingTarget;

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Type.java
Patch:
@@ -309,8 +309,8 @@ public Set<Type> getImportTypes() {
             result.addAll( parameter.getImportTypes() );
         }
 
-        if ( boundingBase != null ) {
-            result.addAll( boundingBase.getImportTypes() );
+        if ( ( isWildCardExtendsBound() || isWildCardSuperBound() ) && getTypeBound() != null ) {
+            result.addAll( getTypeBound().getImportTypes() );
         }
 
         return result;

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/TargetReference.java
Patch:
@@ -367,9 +367,10 @@ private MappingErrorMessage(Mapping mapping, SourceMethod method, FormattingMess
         abstract void report();
 
         protected void printErrorMessage(Message message, Object... args) {
-            Object[] errorArgs = new Object[args.length + 1];
+            Object[] errorArgs = new Object[args.length + 2];
             errorArgs[0] = mapping.getTargetName();
-            System.arraycopy( args, 0, errorArgs, 1, args.length );
+            errorArgs[1] = method.getResultType();
+            System.arraycopy( args, 0, errorArgs, 2, args.length );
             messager.printMessage( method.getExecutable(), mapping.getMirror(), mapping.getSourceAnnotationValue(),
                 message, errorArgs
             );

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -31,8 +31,8 @@ public enum Message {
     BEANMAPPING_NO_ELEMENTS( "'nullValueMappingStrategy', 'resultType' and 'qualifiedBy' are undefined in @BeanMapping, define at least one of them." ),
     BEANMAPPING_NOT_ASSIGNABLE( "%s not assignable to: %s." ),
     BEANMAPPING_ABSTRACT( "The result type %s may not be an abstract class nor interface." ),
-    BEANMAPPING_UNKNOWN_PROPERTY_IN_RESULTTYPE( "Unknown property \"%s\" in return type. Did you mean \"%s\"?" ),
-    BEANMAPPING_PROPERTY_HAS_NO_WRITE_ACCESSOR_IN_RESULTTYPE( "Property \"%s\" has no write accessor." ),
+    BEANMAPPING_UNKNOWN_PROPERTY_IN_RESULTTYPE( "Unknown property \"%s\" in result type %s. Did you mean \"%s\"?" ),
+    BEANMAPPING_PROPERTY_HAS_NO_WRITE_ACCESSOR_IN_RESULTTYPE( "Property \"%s\" has no write accessor in %s." ),
     BEANMAPPING_SEVERAL_POSSIBLE_SOURCES( "Several possible source properties for target property \"%s\"." ),
     BEANMAPPING_SEVERAL_POSSIBLE_TARGET_ACCESSORS( "Found several matching getters for property \"%s\"." ),
     BEANMAPPING_UNMAPPED_TARGETS_WARNING( "Unmapped target %s.", Diagnostic.Kind.WARNING ),

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1029/Issue1029Test.java
Patch:
@@ -46,7 +46,8 @@ public class Issue1029Test {
         @Diagnostic(kind = Kind.WARNING, line = 50, type = ErroneousIssue1029Mapper.class,
             messageRegExp = "Unmapped target property: \"lastUpdated\"\\."),
         @Diagnostic(kind = Kind.ERROR, line = 55, type = ErroneousIssue1029Mapper.class,
-            messageRegExp = "Unknown property \"unknownProp\" in return type\\. Did you mean \"knownProp\"?")
+            messageRegExp = "Unknown property \"unknownProp\" in result type " +
+                "org.mapstruct.ap.test.bugs._1029.ErroneousIssue1029Mapper.Deck\\. Did you mean \"knownProp\"?")
     })
     public void reportsProperWarningsAndError() {
     }

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/attributereference/ErroneousMappingsTest.java
Patch:
@@ -57,7 +57,8 @@ public class ErroneousMappingsTest {
             @Diagnostic(type = ErroneousMapper.class,
                 kind = Kind.ERROR,
                 line = 31,
-                messageRegExp = "Unknown property \"bar\" in return type. Did you mean \"foo\"?"),
+                messageRegExp = "Unknown property \"bar\" in result type " +
+                    "org.mapstruct.ap.test.erroneous.attributereference.Target. Did you mean \"foo\"?"),
             @Diagnostic(type = ErroneousMapper.class,
                 kind = Kind.ERROR,
                 line = 33,

File: processor/src/test/java/org/mapstruct/ap/test/ignore/IgnorePropertyTest.java
Patch:
@@ -93,7 +93,8 @@ public void shouldNotPropagateIgnoredPropertyInReverseMappingWhenSourceAndTarget
             @Diagnostic(type = ErroneousTargetHasNoWriteAccessorMapper.class,
                 kind = Kind.ERROR,
                 line = 35,
-                messageRegExp = "Property \"hasClaws\" has no write accessor\\.")
+                messageRegExp = "Property \"hasClaws\" has no write accessor in " +
+                    "org.mapstruct.ap.test.ignore.PreditorDto\\.")
         }
     )
     public void shouldGiveErrorOnMappingForReadOnlyProp() {

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -324,7 +324,9 @@ else if ( targetType.isArrayType() && sourceType.isArrayType() && assignment.get
          */
         private void reportCannotCreateMapping() {
             if ( method instanceof ForgedMethod && ( (ForgedMethod) method ).getHistory() != null ) {
-                ForgedMethodHistory history =  ( (ForgedMethod) method ).getHistory();
+                // The history that is part of the ForgedMethod misses the information from the current right hand
+                // side. Therefore we need to extract the most relevant history and use that in the error reporting.
+                ForgedMethodHistory history = getForgedMethodHistory( rightHandSide );
                 reportCannotCreateMapping(
                     method,
                     history.createSourcePropertyErrorMessage(),

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/exclusions/Source.java
Patch:
@@ -47,8 +47,6 @@ static class MyType {
     public MyType date;
     public MyType calendar;
     public List<MyType> types;
-    //TODO Nested error messages do not work yet. I think that this should be solved as part of #1150
-    // (or we solve that one first :))
-    //public NestedMyType nestedMyType;
+    public NestedMyType nestedMyType;
     //CHECKSTYLE:ON
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedbeans/exclusions/Target.java
Patch:
@@ -43,6 +43,6 @@ class TargetNested {
     public Date date;
     public GregorianCalendar calendar;
     public List<String> types;
-    //public TargetNested nestedMyType;
+    public TargetNested nestedMyType;
     //CHECKSTYLE:ON
 }

File: integrationtest/src/test/java/org/mapstruct/itest/tests/FullFeatureCompilationTest.java
Patch:
@@ -69,6 +69,7 @@ public Collection<String> getAdditionalCommandLineArguments(ProcessorType proces
             switch ( processorType ) {
                 case ORACLE_JAVA_6:
                     additionalExcludes.add( "org/mapstruct/ap/test/abstractclass/generics/*.java" );
+                    additionalExcludes.add( "org/mapstruct/ap/test/bugs/_1170/*.java" );
                 case ECLIPSE_JDT_JAVA_6:
                 case ORACLE_JAVA_7:
                 case ECLIPSE_JDT_JAVA_7:

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/AdderWrapper.java
Patch:
@@ -63,7 +63,7 @@ public List<Type> getThrownTypes() {
     public Set<Type> getImportTypes() {
         Set<Type> imported = new HashSet<Type>();
         imported.addAll( super.getImportTypes() );
-        imported.add( getSourceType().getTypeParameters().get( 0 ) );
+        imported.add( getSourceType().getTypeParameters().get( 0 ).getTypeBound() );
         return imported;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/GeneratedType.java
Patch:
@@ -235,7 +235,9 @@ private boolean needsImportDeclaration(Type typeToAdd) {
         }
 
         if ( typeToAdd.getPackageName() != null ) {
-            if ( typeToAdd.getPackageName().startsWith( JAVA_LANG_PACKAGE ) ) {
+            if ( typeToAdd.getPackageName().equals( JAVA_LANG_PACKAGE ) ) {
+                // only the types in the java.lang package are implicitly imported, the packages under java.lang
+                // like java.lang.management are not.
                 return false;
             }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Type.java
Patch:
@@ -572,7 +572,7 @@ private Accessor getAdderForType(Type collectionProperty, String pluralPropertyN
                         continue;
                     }
                     VariableElement arg = executable.getParameters().get( 0 );
-                    if ( arg.asType().equals( typeArg ) ) {
+                    if ( typeUtils.isSameType( arg.asType(), typeArg ) ) {
                         candidates.add( adder );
                     }
                 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MethodMatcher.java
Patch:
@@ -395,7 +395,7 @@ public Boolean visitWildcard(WildcardType t, TypeMirror p) {
      */
     private TypeParameterElement getTypeParamFromCandidate(TypeMirror t) {
         for ( TypeParameterElement candidateTypeParam : candidateMethod.getExecutable().getTypeParameters() ) {
-            if ( candidateTypeParam.asType().equals( t ) ) {
+            if ( typeUtils.isSameType( candidateTypeParam.asType(), t ) ) {
                 return candidateTypeParam;
             }
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Type.java
Patch:
@@ -290,7 +290,7 @@ public String getFullyQualifiedName() {
      * @return The name of this type as to be used within import statements.
      */
     public String getImportName() {
-        return isArrayType() ? qualifiedName.substring( 0, qualifiedName.length() - 2 ) : qualifiedName;
+        return isArrayType() ? TypeFactory.trimSimpleClassName( qualifiedName ) : qualifiedName;
     }
 
     @Override

File: core-common/src/main/java/org/mapstruct/NullValueCheckStrategy.java
Patch:
@@ -30,12 +30,13 @@ public enum NullValueCheckStrategy {
 
     /**
      * This option includes a null check. When:
-     * <p>
+     * <br>
+     * <br>
      * <ol>
      *   <li>a source value is directly assigned to a target</li>
      *   <li>a source value assigned to a target by calling a type conversion on the target first</li>
      * </ol>
-     * <p>
+     * <br>
      * <b>NOTE:</b> mapping methods (generated or hand written) are excluded from this null check. They are intended to
      * handle a null source value as 'valid' input.
      *

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/BigDecimalToStringConversion.java
Patch:
@@ -74,7 +74,7 @@ protected Set<Type> getFromConversionImportTypes(ConversionContext conversionCon
 
     @Override
     public List<HelperMethod> getRequiredHelperMethods(ConversionContext conversionContext) {
-        List<HelperMethod> helpers = new ArrayList();
+        List<HelperMethod> helpers = new ArrayList<HelperMethod>();
         if ( conversionContext.getNumberFormat() != null ) {
             helpers.add( new CreateDecimalFormat( conversionContext.getTypeFactory() ) );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/BigIntegerToStringConversion.java
Patch:
@@ -81,7 +81,7 @@ protected Set<Type> getFromConversionImportTypes(ConversionContext conversionCon
 
     @Override
     public List<HelperMethod> getRequiredHelperMethods(ConversionContext conversionContext) {
-        List<HelperMethod> helpers = new ArrayList();
+        List<HelperMethod> helpers = new ArrayList<HelperMethod>();
         if ( conversionContext.getNumberFormat() != null ) {
             helpers.add( new CreateDecimalFormat( conversionContext.getTypeFactory() ) );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/model/IterableCreation.java
Patch:
@@ -27,7 +27,7 @@
 
 /**
  * Model element that can be used to create a type of {@link Iterable} or {@link java.util.Map}. If an implementation
- * type is used and the target type has a constructor with {@link int} as parameter and the source parameter is of
+ * type is used and the target type has a constructor with {@code int} as parameter and the source parameter is of
  * {@link java.util.Collection}, {@link java.util.Map} or {@code Array} type then MapStruct will use that constructor
  * with the {@code size} / {@code length} from the source parameter.
  *

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/ImplementationType.java
Patch:
@@ -68,7 +68,7 @@ public Type getType() {
     }
 
     /**
-     * @return {@code true} if the underlying type has a constructor for {@link int} {@code initialCapacity}, {@code
+     * @return {@code true} if the underlying type has a constructor for {@code int} {@code initialCapacity}, {@code
      * false} otherwise
      */
     public boolean hasInitialCapacityConstructor() {

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/BeanMapper.java
Patch:
@@ -42,7 +42,7 @@ BigDecimal map(JAXBElement<? extends BigDecimal> value) {
     }
 
     JAXBElement<? super BigDecimal> map(BigDecimal value) {
-        return new JAXBElement( new QName( "test" ), BigDecimal.class, value );
+        return new JAXBElement<BigDecimal>( new QName( "test" ), BigDecimal.class, value );
     }
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/WildCardTest.java
Patch:
@@ -153,7 +153,7 @@ public void shouldFailOnTypeVarTarget() {
     public void shouldMapBean() {
 
         GoodIdea aGoodIdea = new GoodIdea();
-        aGoodIdea.setContent( new JAXBElement( new QName( "test" ), BigDecimal.class, BigDecimal.ONE ) );
+        aGoodIdea.setContent( new JAXBElement<BigDecimal>( new QName( "test" ), BigDecimal.class, BigDecimal.ONE ) );
         aGoodIdea.setDescription( BigDecimal.ZERO );
 
         CunningPlan aCunningPlan = BeanMapper.STM.transformA( aGoodIdea );

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -31,7 +31,7 @@ public enum Message {
     BEANMAPPING_NO_ELEMENTS( "'nullValueMappingStrategy', 'resultType' and 'qualifiedBy' are undefined in @BeanMapping, define at least one of them." ),
     BEANMAPPING_NOT_ASSIGNABLE( "%s not assignable to: %s." ),
     BEANMAPPING_ABSTRACT( "The result type %s may not be an abstract class nor interface." ),
-    BEANMAPPING_UNKNOWN_PROPERTY_IN_RESULTTYPE( "Unknown property \"%s\" in return type." ),
+    BEANMAPPING_UNKNOWN_PROPERTY_IN_RESULTTYPE( "Unknown property \"%s\" in return type. Did you mean \"%s\"?" ),
     BEANMAPPING_PROPERTY_HAS_NO_WRITE_ACCESSOR_IN_RESULTTYPE( "Property \"%s\" has no write accessor." ),
     BEANMAPPING_SEVERAL_POSSIBLE_SOURCES( "Several possible source properties for target property \"%s\"." ),
     BEANMAPPING_SEVERAL_POSSIBLE_TARGET_ACCESSORS( "Found several matching getters for property \"%s\"." ),
@@ -54,7 +54,7 @@ public enum Message {
     PROPERTYMAPPING_INVALID_EXPRESSION( "Value must be given in the form \"java(<EXPRESSION>)\"." ),
     PROPERTYMAPPING_INVALID_PARAMETER_NAME( "Method has no parameter named \"%s\"." ),
     PROPERTYMAPPING_NO_PROPERTY_IN_PARAMETER( "The type of parameter \"%s\" has no property named \"%s\"." ),
-    PROPERTYMAPPING_INVALID_PROPERTY_NAME( "No property named \"%s\" exists in source parameter(s)." ),
+    PROPERTYMAPPING_INVALID_PROPERTY_NAME( "No property named \"%s\" exists in source parameter(s). Did you mean \"%s\"?" ),
     PROPERTYMAPPING_NO_PRESENCE_CHECKER_FOR_SOURCE_TYPE( "Using custom source value presence checking strategy, but no presence checker found for %s in source type." ),
     PROPERTYMAPPING_NO_READ_ACCESSOR_FOR_TARGET_TYPE( "No read accessor found for property \"%s\" in target type." ),
     PROPERTYMAPPING_NO_WRITE_ACCESSOR_FOR_TARGET_TYPE( "No write accessor found for property \"%s\" in target type." ),

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1153/Issue1153Test.java
Patch:
@@ -48,7 +48,8 @@ public class Issue1153Test {
             @Diagnostic(type = ErroneousIssue1153Mapper.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 36,
-                messageRegExp = "Unknown property \"nestedTarget2.writable2\" in return type\\.")
+                messageRegExp = "Unknown property \"nestedTarget2.writable2\" in return type\\. " +
+                    "Did you mean \"nestedTarget2\\.writable\"")
         })
     @Test
     public void shouldReportErrorsCorrectly() {

File: processor/src/main/java/org/mapstruct/ap/internal/model/AbstractMappingMethodBuilder.java
Patch:
@@ -45,7 +45,7 @@ public AbstractMappingMethodBuilder(Class<B> selfType) {
     protected abstract boolean shouldUsePropertyNamesInHistory();
 
     Assignment forgeMapping(SourceRHS sourceRHS, Type sourceType, Type targetType) {
-        if ( isDisableSubMappingMethodsGeneration() ) {
+        if ( !canGenerateAutoSubMappingBetween( sourceType, targetType ) ) {
             return null;
         }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/ContainerMappingMethodBuilder.java
Patch:
@@ -121,7 +121,7 @@ public final M build() {
                 reportCannotCreateMapping(
                     method,
                     String.format( "%s \"%s\"", sourceRHS.getSourceErrorMessagePart(), sourceRHS.getSourceType() ),
-                    sourceRHS,
+                    sourceRHS.getSourceType(),
                     targetElementType,
                     ""
                 );

File: processor/src/main/java/org/mapstruct/ap/internal/model/MapMappingMethod.java
Patch:
@@ -125,7 +125,7 @@ public MapMappingMethod build() {
                             keySourceRHS.getSourceErrorMessagePart(),
                             keySourceRHS.getSourceType()
                         ),
-                        keySourceRHS,
+                        keySourceRHS.getSourceType(),
                         keyTargetType,
                         ""
                     );
@@ -175,7 +175,7 @@ public MapMappingMethod build() {
                             valueSourceRHS.getSourceErrorMessagePart(),
                             valueSourceRHS.getSourceType()
                         ),
-                        valueSourceRHS,
+                        valueSourceRHS.getSourceType(),
                         valueTargetType,
                         ""
                     );

File: processor/src/test/java/org/mapstruct/ap/test/collection/erroneous/ErroneousCollectionNoElementMappingFound.java
Patch:
@@ -18,10 +18,11 @@
  */
 package org.mapstruct.ap.test.collection.erroneous;
 
-import java.text.AttributedString;
 import java.util.List;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.ap.test.NoProperties;
+import org.mapstruct.ap.test.WithProperties;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -34,6 +35,6 @@ public interface ErroneousCollectionNoElementMappingFound {
     ErroneousCollectionNoElementMappingFound INSTANCE =
         Mappers.getMapper( ErroneousCollectionNoElementMappingFound.class );
 
-    List<String> map(List<AttributedString> source);
+    List<NoProperties> map(List<WithProperties> source);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/erroneous/ErroneousCollectionNoKeyMappingFound.java
Patch:
@@ -18,10 +18,11 @@
  */
 package org.mapstruct.ap.test.collection.erroneous;
 
-import java.text.AttributedString;
 import java.util.Map;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.ap.test.NoProperties;
+import org.mapstruct.ap.test.WithProperties;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -34,6 +35,6 @@ public interface ErroneousCollectionNoKeyMappingFound {
     ErroneousCollectionNoKeyMappingFound INSTANCE =
         Mappers.getMapper( ErroneousCollectionNoKeyMappingFound.class );
 
-    Map<String, String> map(Map<AttributedString, String> source);
+    Map<NoProperties, String> map(Map<WithProperties, String> source);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/erroneous/ErroneousCollectionNoValueMappingFound.java
Patch:
@@ -18,10 +18,11 @@
  */
 package org.mapstruct.ap.test.collection.erroneous;
 
-import java.text.AttributedString;
 import java.util.Map;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.ap.test.NoProperties;
+import org.mapstruct.ap.test.WithProperties;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -34,6 +35,6 @@ public interface ErroneousCollectionNoValueMappingFound {
     ErroneousCollectionNoValueMappingFound INSTANCE =
         Mappers.getMapper( ErroneousCollectionNoValueMappingFound.class );
 
-    Map<String, String> map(Map<String, AttributedString> source);
+    Map<String, NoProperties> map(Map<String, WithProperties> source);
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/erroneous/ErroneousListToStreamNoElementMappingFound.java
Patch:
@@ -18,11 +18,12 @@
  */
 package org.mapstruct.ap.test.java8stream.erroneous;
 
-import java.text.AttributedString;
 import java.util.List;
 import java.util.stream.Stream;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.ap.test.NoProperties;
+import org.mapstruct.ap.test.WithProperties;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -34,5 +35,5 @@ public interface ErroneousListToStreamNoElementMappingFound {
     ErroneousListToStreamNoElementMappingFound INSTANCE =
         Mappers.getMapper( ErroneousListToStreamNoElementMappingFound.class );
 
-    Stream<String> mapCollectionToStream(List<AttributedString> source);
+    Stream<NoProperties> mapCollectionToStream(List<WithProperties> source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/erroneous/ErroneousStreamToListNoElementMappingFound.java
Patch:
@@ -18,11 +18,12 @@
  */
 package org.mapstruct.ap.test.java8stream.erroneous;
 
-import java.text.AttributedString;
 import java.util.List;
 import java.util.stream.Stream;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.ap.test.NoProperties;
+import org.mapstruct.ap.test.WithProperties;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -34,5 +35,5 @@ public interface ErroneousStreamToListNoElementMappingFound {
     ErroneousStreamToListNoElementMappingFound INSTANCE =
         Mappers.getMapper( ErroneousStreamToListNoElementMappingFound.class );
 
-    List<String> mapStreamToCollection(Stream<AttributedString> source);
+    List<NoProperties> mapStreamToCollection(Stream<WithProperties> source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/erroneous/ErroneousStreamToStreamNoElementMappingFound.java
Patch:
@@ -18,10 +18,11 @@
  */
 package org.mapstruct.ap.test.java8stream.erroneous;
 
-import java.text.AttributedString;
 import java.util.stream.Stream;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.ap.test.NoProperties;
+import org.mapstruct.ap.test.WithProperties;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -33,5 +34,5 @@ public interface ErroneousStreamToStreamNoElementMappingFound {
     ErroneousStreamToStreamNoElementMappingFound INSTANCE =
         Mappers.getMapper( ErroneousStreamToStreamNoElementMappingFound.class );
 
-    Stream<String> mapStreamToStream(Stream<AttributedString> source);
+    Stream<NoProperties> mapStreamToStream(Stream<WithProperties> source);
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/SourceMethod.java
Patch:
@@ -200,7 +200,7 @@ public SourceMethod build() {
             if ( mappings != null ) {
                 for ( Map.Entry<String, List<Mapping>> entry : mappings.entrySet() ) {
                     for ( Mapping mapping : entry.getValue() ) {
-                        mapping.init( sourceMethod, messager, typeFactory, false );
+                        mapping.init( sourceMethod, messager, typeFactory );
                     }
                 }
             }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/WrapperForCollectionsAndMaps.java
Patch:
@@ -72,8 +72,7 @@ public List<Type> getThrownTypes() {
     public Set<Type> getImportTypes() {
         Set<Type> imported = new HashSet<Type>();
         imported.addAll( super.getImportTypes() );
-        imported.add( nullCheckLocalVarType );
-        imported.addAll( nullCheckLocalVarType.getTypeParameters() );
+        imported.addAll( nullCheckLocalVarType.getImportTypes() );
         return imported;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -87,6 +87,7 @@ public enum Message {
     GENERAL_UNSUPPORTED_DATE_FORMAT_CHECK( "No dateFormat check is supported for types %s, %s" ),
     GENERAL_VALID_DATE( "Given date format \"%s\" is valid.", Diagnostic.Kind.NOTE ),
     GENERAL_INVALID_DATE( "Given date format \"%s\" is invalid. Message: \"%s\"." ),
+    GENERAL_NOT_ALL_FORGED_CREATED( "Internal Error in creation of Forged Methods, it was expected all Forged Methods to finished with creation, but %s did not" ),
 
     RETRIEVAL_NO_INPUT_ARGS( "Can't generate mapping method with no input arguments." ),
     RETRIEVAL_DUPLICATE_MAPPING_TARGETS( "Can't generate mapping method with more than one @MappingTarget parameter." ),

File: processor/src/test/java/org/mapstruct/ap/test/nestedtargetproperties/NestedTargetPropertiesTest.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.nestedtargetproperties;
 
-import static org.assertj.core.api.Assertions.assertThat;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,6 +32,8 @@
 import org.mapstruct.ap.testutil.runner.AnnotationProcessorTestRunner;
 import org.mapstruct.ap.testutil.runner.GeneratedSource;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 /**
  *
  * @author Sjaak Derksen

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/TypeSelector.java
Patch:
@@ -59,7 +59,7 @@ public <T extends Method> List<SelectedMethod<T>> getMatchingMethods(Method mapp
         List<ParameterBinding> availableBindings;
         if ( sourceTypes.isEmpty() ) {
             // if no source types are given, we have a factory or lifecycle method
-            availableBindings = getAvailableParameterBindingsFromMethod( mappingMethod );
+            availableBindings = getAvailableParameterBindingsFromMethod( mappingMethod, targetType );
         }
         else {
             availableBindings = getAvailableParameterBindingsFromSourceTypes( sourceTypes, targetType, mappingMethod );
@@ -81,11 +81,11 @@ public <T extends Method> List<SelectedMethod<T>> getMatchingMethods(Method mapp
         return result;
     }
 
-    private List<ParameterBinding> getAvailableParameterBindingsFromMethod(Method method) {
+    private List<ParameterBinding> getAvailableParameterBindingsFromMethod(Method method, Type targetType) {
         List<ParameterBinding> availableParams = new ArrayList<ParameterBinding>( method.getParameters().size() + 2 );
 
         availableParams.addAll( ParameterBinding.fromParameters( method.getParameters() ) );
-        addMappingTargetAndTargetTypeBindings( availableParams, method.getResultType() );
+        addMappingTargetAndTargetTypeBindings( availableParams, targetType );
 
         return availableParams;
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_1124/Issue1124Test.java
Patch:
@@ -25,13 +25,15 @@
 import org.mapstruct.ap.test.bugs._1124.Issue1124Mapper.DTO;
 import org.mapstruct.ap.test.bugs._1124.Issue1124Mapper.Entity;
 import org.mapstruct.ap.test.bugs._1124.Issue1124Mapper.MappingContext;
+import org.mapstruct.ap.testutil.IssueKey;
 import org.mapstruct.ap.testutil.WithClasses;
 import org.mapstruct.ap.testutil.runner.AnnotationProcessorTestRunner;
 import org.mapstruct.factory.Mappers;
 
 /**
  * @author Andreas Gudian
  */
+@IssueKey("1124")
 @RunWith(AnnotationProcessorTestRunner.class)
 @WithClasses(Issue1124Mapper.class)
 public class Issue1124Test {

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/SourceTargetMapper.java
Patch:
@@ -61,7 +61,7 @@ public abstract class SourceTargetMapper {
     @InheritInverseConfiguration
     public abstract Set<Colour> stringSetToColourSet(Set<String> colours);
 
-    public abstract Set<Number> integerSetToNumberSet(Stream<Integer> integers);
+    public abstract Set<Number> integerStreamToNumberSet(Stream<Integer> integers);
 
     protected StringHolder toStringHolder(String string) {
         return new StringHolder( string );

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/StreamMappingTest.java
Patch:
@@ -209,9 +209,9 @@ public void shouldReverseMapSetOfEnumToStringSet() {
     }
 
     @Test
-    public void shouldMapIntegerSetToNumberSet() {
+    public void shouldMapIntegerStreamToNumberSet() {
         Set<Number> numbers = SourceTargetMapper.INSTANCE
-            .integerSetToNumberSet( new HashSet<Integer>( Arrays.asList( 123, 456 ) ).stream() );
+            .integerStreamToNumberSet( Arrays.asList( 123, 456 ).stream() );
 
         assertThat( numbers ).isNotNull();
         assertThat( numbers ).containsOnly( 123, 456 );

File: processor/src/test/java/org/mapstruct/ap/test/value/SpecialOrderMapper.java
Patch:
@@ -34,7 +34,7 @@
 public interface SpecialOrderMapper {
 
     SpecialOrderMapper INSTANCE = Mappers.getMapper( SpecialOrderMapper.class );
-    
+
     @Mapping(target = "orderType", source = "orderType", qualifiedByName = "orderTypeToExternalOrderType")
     OrderDto orderEntityToDto(OrderEntity order);
 

File: processor/src/test/java/org/mapstruct/ap/test/value/SpecialOrderMapper.java
Patch:
@@ -34,8 +34,7 @@
 public interface SpecialOrderMapper {
 
     SpecialOrderMapper INSTANCE = Mappers.getMapper( SpecialOrderMapper.class );
-
-
+    
     @Mapping(target = "orderType", source = "orderType", qualifiedByName = "orderTypeToExternalOrderType")
     OrderDto orderEntityToDto(OrderEntity order);
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Type.java
Patch:
@@ -758,10 +758,11 @@ public String getNull() {
             return "0";
         }
         if ( "char".equals( getName() ) ) {
-            return "'\\u0000'";
+            //"'\u0000'" would have been better, but depends on platform encoding
+                return "0";
         }
         if ( "double".equals( getName() ) ) {
-            return "0.0";
+            return "0.0d";
         }
         if ( "float".equals( getName() ) ) {
             return "0.0f";

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/CollectionMappingTest.java
Patch:
@@ -100,7 +100,7 @@ public void shouldForgeNewMapMappingMethod() {
             @Diagnostic(type = ErroneousCollectionNonMappableSetMapper.class,
                 kind = Kind.ERROR,
                 line = 30,
-                messageRegExp = "Can't map property \".* nonMappableSet\" to \".* nonMappableSet\". "
+                messageRegExp = "Can't map Collection element \".* nonMappableSet\" to \".* nonMappableSet\". "
                     + "Consider to declare/implement a mapping method: .*."),
         }
     )
@@ -120,7 +120,7 @@ public void shouldGenerateNonMappleMethodForSetMapping() {
             @Diagnostic(type = ErroneousCollectionNonMappableMapMapper.class,
                 kind = Kind.ERROR,
                 line = 30,
-                messageRegExp = "Can't map property \".* nonMappableMap\" to \".* nonMappableMap\". "
+                messageRegExp = "Can't map Map key \".* nonMappableMap\\{:key\\}\" to \".* nonMappableMap\\{:key\\}\". "
                     + "Consider to declare/implement a mapping method: .*."),
         }
     )

File: processor/src/test/java/org/mapstruct/ap/test/java8stream/forged/ForgedStreamMappingTest.java
Patch:
@@ -83,7 +83,7 @@ public void shouldForgeNewIterableMappingMethod() {
             @Diagnostic(type = ErroneousStreamNonMappableStreamMapper.class,
                 kind = Kind.ERROR,
                 line = 30,
-                messageRegExp = "Can't map property \".* nonMappableStream\" to \".* nonMappableStream\". "
+                messageRegExp = "Can't map Stream element \".* nonMappableStream\" to \".* nonMappableStream\". "
                     + "Consider to declare/implement a mapping method: .*."),
         }
     )

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -30,6 +30,7 @@ public enum Message {
     // CHECKSTYLE:OFF
     BEANMAPPING_NO_ELEMENTS( "'nullValueMappingStrategy', 'resultType' and 'qualifiedBy' are undefined in @BeanMapping, define at least one of them." ),
     BEANMAPPING_NOT_ASSIGNABLE( "%s not assignable to: %s." ),
+    BEANMAPPING_ABSTRACT( "The result type %s may not be an abstract class nor interface." ),
     BEANMAPPING_UNKNOWN_PROPERTY_IN_RESULTTYPE( "Unknown property \"%s\" in return type." ),
     BEANMAPPING_PROPERTY_HAS_NO_WRITE_ACCESSOR_IN_RESULTTYPE( "Property \"%s\" has no write accessor." ),
     BEANMAPPING_SEVERAL_POSSIBLE_SOURCES( "Several possible source properties for target property \"%s\"." ),
@@ -77,6 +78,7 @@ public enum Message {
     DECORATOR_CONSTRUCTOR( "Specified decorator type has no default constructor nor a constructor with a single parameter accepting the decorated mapper type." ),
 
     GENERAL_NO_IMPLEMENTATION( "No implementation type is registered for return type %s." ),
+    GENERAL_ABSTRACT_RETURN_TYPE( "The return type %s is an abstract class or interface. Provide a non abstract / non interface result type or a factory method." ),
     GENERAL_AMBIGIOUS_MAPPING_METHOD( "Ambiguous mapping methods found for mapping %s to %s: %s." ),
     GENERAL_AMBIGIOUS_FACTORY_METHOD( "Ambiguous factory methods found for creating %s: %s." ),
     GENERAL_UNSUPPORTED_DATE_FORMAT_CHECK( "No dateFormat check is supported for types %s, %s" ),

File: processor/src/test/java/org/mapstruct/ap/test/ignore/ErroneousTargetHasNoWriteAccessorMapper.java
Patch:
@@ -32,7 +32,7 @@ public interface ErroneousTargetHasNoWriteAccessorMapper {
     ErroneousTargetHasNoWriteAccessorMapper INSTANCE =
         Mappers.getMapper( ErroneousTargetHasNoWriteAccessorMapper.class );
 
-    @Mapping( target = "hasTallons", ignore = true )
+    @Mapping(target = "hasClaws", constant = "true")
     PreditorDto preditorToDto( Preditor preditor );
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/ignore/PreditorDto.java
Patch:
@@ -24,10 +24,10 @@
  */
 public class PreditorDto {
 
-    private boolean hasTallons;
+    private boolean hasClaws;
 
-    public boolean isHasTallons() {
-        return hasTallons;
+    public boolean isHasClaws() {
+        return hasClaws;
     }
 
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/Apple.java
Patch:
@@ -22,7 +22,7 @@
  *
  * @author Sjaak Derksen
  */
-public class Apple extends Fruit {
+public class Apple extends Fruit implements IsFruit {
 
     public Apple() {
         super( "constructed-by-constructor" );

File: core-common/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -18,13 +18,14 @@
  */
 package org.mapstruct;
 
+import static org.mapstruct.NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.mapstruct.factory.Mappers;
-import static org.mapstruct.NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
 
 /**
  * Marks an interface or abstract class as a mapper and activates the generation of a implementation of that type via

File: core-common/src/main/java/org/mapstruct/MapperConfig.java
Patch:
@@ -18,13 +18,14 @@
  */
 package org.mapstruct;
 
+import static org.mapstruct.NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.mapstruct.factory.Mappers;
-import static org.mapstruct.NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
 
 /**
  * Marks a class or interface as configuration source for generated mappers. This allows to share common configurations

File: integrationtest/src/test/resources/java8Test/src/main/java/org/mapstruct/ap/test/bugs/_636/Target.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.bugs._636;
 
-
 public class Target {
     private Foo foo;
     private Bar bar;

File: integrationtest/src/test/resources/jaxbTest/src/main/java/org/mapstruct/itest/jaxb/OrderDto.java
Patch:
@@ -30,7 +30,6 @@ public class OrderDto {
     private OrderDetailsDto orderDetails;
     private ShippingAddressDto shippingAddress;
 
-
     public Long getOrderNumber() {
         return orderNumber;
     }

File: integrationtest/src/test/resources/jaxbTest/src/main/java/org/mapstruct/itest/jaxb/SubTypeDto.java
Patch:
@@ -18,7 +18,7 @@
  */
 package org.mapstruct.itest.jaxb;
 
-public class SubTypeDto extends SuperTypeDto{
+public class SubTypeDto extends SuperTypeDto {
     private String declaredCamelCase;
     private String declaredUnderscore;
 

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/AbstractNumberToStringConversion.java
Patch:
@@ -18,14 +18,15 @@
  */
 package org.mapstruct.ap.internal.conversion;
 
-import org.mapstruct.ap.internal.model.common.ConversionContext;
-import org.mapstruct.ap.internal.model.common.Type;
 import java.text.DecimalFormat;
 import java.text.ParseException;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.internal.model.common.ConversionContext;
+import org.mapstruct.ap.internal.model.common.Type;
+
 /**
  * Abstract base class for {@link PrimitiveToStringConversion}, {@link WrapperToStringConversion},
  * {@link BigDecimalToStringConversion} and {@link BigIntegerToStringConversion}
@@ -43,7 +44,6 @@ public AbstractNumberToStringConversion(boolean sourceTypeNumberSubclass) {
         this.sourceTypeNumberSubclass = sourceTypeNumberSubclass;
     }
 
-
     @Override
     public Set<Type> getToConversionImportTypes(ConversionContext conversionContext) {
         if ( requiresDecimalFormat( conversionContext ) ) {

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/BigDecimalToStringConversion.java
Patch:
@@ -18,16 +18,16 @@
  */
 package org.mapstruct.ap.internal.conversion;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
 
 import java.math.BigDecimal;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
-import org.mapstruct.ap.internal.model.HelperMethod;
 
+import org.mapstruct.ap.internal.model.HelperMethod;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.Type;
-import static org.mapstruct.ap.internal.util.Collections.asSet;
 
 /**
  * Conversion between {@link BigDecimal} and {@link String}.
@@ -67,7 +67,6 @@ public String getFromExpression(ConversionContext conversionContext) {
         }
     }
 
-
     @Override
     protected Set<Type> getFromConversionImportTypes(ConversionContext conversionContext) {
         return asSet( conversionContext.getTypeFactory().getType( BigDecimal.class ) );

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/BigIntegerToStringConversion.java
Patch:
@@ -18,16 +18,16 @@
  */
 package org.mapstruct.ap.internal.conversion;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
 
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
-import org.mapstruct.ap.internal.model.HelperMethod;
 
+import org.mapstruct.ap.internal.model.HelperMethod;
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 import org.mapstruct.ap.internal.model.common.Type;
-import static org.mapstruct.ap.internal.util.Collections.asSet;
 
 /**
  * Conversion between {@link BigInteger} and {@link String}.

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/CreateDecimalFormat.java
Patch:
@@ -18,13 +18,15 @@
  */
 package org.mapstruct.ap.internal.conversion;
 
+import static org.mapstruct.ap.internal.util.Collections.asSet;
+
 import java.text.DecimalFormat;
 import java.util.Set;
+
 import org.mapstruct.ap.internal.model.HelperMethod;
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
-import static org.mapstruct.ap.internal.util.Collections.asSet;
 
 /**
  * HelperMethod that creates a {@link java.text.DecimalFormat}
@@ -36,7 +38,6 @@
  */
 public class CreateDecimalFormat extends HelperMethod {
 
-
     private final Parameter parameter;
     private final Type returnType;
     private final Set<Type> importTypes;

File: processor/src/main/java/org/mapstruct/ap/internal/conversion/DateToSqlDateConversion.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.internal.conversion;
 
-
 import org.mapstruct.ap.internal.model.common.ConversionContext;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/Field.java
Patch:
@@ -42,6 +42,7 @@ public Field(Type type, String variableName, boolean used) {
         this.used = used;
         this.typeRequiresImport = used;
     }
+
     public Field(Type type, String variableName) {
         this.type = type;
         this.variableName = variableName;

File: processor/src/main/java/org/mapstruct/ap/internal/model/IterableMappingMethod.java
Patch:
@@ -18,9 +18,9 @@
  */
 package org.mapstruct.ap.internal.model;
 
-import java.util.HashSet;
 import static org.mapstruct.ap.internal.util.Collections.first;
 
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -166,7 +166,6 @@ public IterableMappingMethod build() {
         }
     }
 
-
     private IterableMappingMethod(Method method, Assignment parameterAssignment, MethodReference factoryMethod,
                                   boolean mapNullToDefault, String loopVariableName,
                                  List<LifecycleCallbackMethodReference> beforeMappingReferences,

File: processor/src/main/java/org/mapstruct/ap/internal/model/MapMappingMethod.java
Patch:
@@ -18,9 +18,9 @@
  */
 package org.mapstruct.ap.internal.model;
 
-import java.util.HashSet;
 import static org.mapstruct.ap.internal.util.Collections.first;
 
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;

File: processor/src/main/java/org/mapstruct/ap/internal/model/MethodReference.java
Patch:
@@ -61,7 +61,6 @@ public class MethodReference extends MappingMethod implements Assignment {
      */
     private Assignment assignment;
 
-
     private final Type definingType;
 
     /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/ValueMappingMethod.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.mapstruct.ap.internal.model;
 
+import static org.mapstruct.ap.internal.util.Collections.first;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -30,7 +32,6 @@
 import org.mapstruct.ap.internal.model.source.ValueMapping;
 import org.mapstruct.ap.internal.prism.BeanMappingPrism;
 import org.mapstruct.ap.internal.prism.MappingConstantsPrism;
-import static org.mapstruct.ap.internal.util.Collections.first;
 import org.mapstruct.ap.internal.util.Message;
 import org.mapstruct.ap.internal.util.Strings;
 
@@ -56,7 +57,6 @@ public static class Builder {
         private ValueMapping nullTargetValue = null;
         private boolean applyNamebasedMappings = true;
 
-
         public Builder mappingContext(MappingBuilderContext mappingContext) {
             this.ctx = mappingContext;
             return this;

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/Assignment.java
Patch:
@@ -112,7 +112,5 @@ enum AssignmentType {
      */
     AssignmentType getType();
 
-
     boolean isUpdateMethod();
-
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/NullCheckWrapper.java
Patch:
@@ -27,7 +27,6 @@ public class NullCheckWrapper extends AssignmentWrapper {
 
     private final String sourcePresenceChecker;
 
-
     public NullCheckWrapper( Assignment decoratedAssignment, String sourcePresenceChecker ) {
         super( decoratedAssignment );
         this.sourcePresenceChecker = sourcePresenceChecker;

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/SetterWrapperForCollectionsAndMaps.java
Patch:
@@ -18,10 +18,11 @@
  */
 package org.mapstruct.ap.internal.model.assignment;
 
+import static org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType.DIRECT;
+
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
-import static org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType.DIRECT;
 
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Type.java
Patch:
@@ -93,7 +93,6 @@ public class Type extends ModelElement implements Comparable<Type> {
     private List<ExecutableElement> adders = null;
     private List<ExecutableElement> alternativeTargetAccessors = null;
 
-
     private Type boundingBase = null;
 
     private Boolean hasEmptyAccessibleContructor;
@@ -252,7 +251,6 @@ public boolean isWildCardExtendsBound() {
         return result;
     }
 
-
     public String getFullyQualifiedName() {
         return qualifiedName;
     }
@@ -796,7 +794,6 @@ public Type getTypeBound() {
         return boundingBase;
     }
 
-
     public boolean hasEmptyAccessibleContructor() {
 
         if ( this.hasEmptyAccessibleContructor == null ) {

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/IterableMapping.java
Patch:
@@ -87,7 +87,6 @@ private IterableMapping(FormattingParameters formattingParameters, SelectionPara
         this.nullValueMappingStrategy = nvms;
     }
 
-
     public SelectionParameters getSelectionParameters() {
         return selectionParameters;
     }
@@ -103,5 +102,4 @@ public AnnotationMirror getMirror() {
     public NullValueMappingStrategyPrism getNullValueMappingStrategy() {
         return nullValueMappingStrategy;
     }
-
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/MappingOptions.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.mapstruct.ap.internal.model.source;
 
+import static org.mapstruct.ap.internal.util.Collections.first;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -27,7 +29,6 @@
 import java.util.Set;
 
 import org.mapstruct.ap.internal.model.common.TypeFactory;
-import static org.mapstruct.ap.internal.util.Collections.first;
 import org.mapstruct.ap.internal.util.FormattingMessager;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/PropertyEntry.java
Patch:
@@ -18,9 +18,10 @@
  */
 package org.mapstruct.ap.internal.model.source;
 
-
 import java.util.Arrays;
+
 import javax.lang.model.element.ExecutableElement;
+
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.util.Strings;
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/SourceMethod.java
Patch:
@@ -210,7 +210,6 @@ public SourceMethod build() {
             }
             return sourceMethod;
         }
-
     }
 
     @SuppressWarnings( "checkstyle:parameternumber" )

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/SourceReference.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.mapstruct.ap.internal.model.source;
 
+import static org.mapstruct.ap.internal.model.source.PropertyEntry.forSourceReference;
 import static org.mapstruct.ap.internal.util.Collections.first;
 
 import java.util.ArrayList;
@@ -31,7 +32,6 @@
 import org.mapstruct.ap.internal.model.common.Parameter;
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
-import static org.mapstruct.ap.internal.model.source.PropertyEntry.forSourceReference;
 import org.mapstruct.ap.internal.util.FormattingMessager;
 import org.mapstruct.ap.internal.util.Message;
 import org.mapstruct.ap.internal.util.Strings;

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/TargetReference.java
Patch:
@@ -29,11 +29,10 @@
 import org.mapstruct.ap.internal.model.common.Type;
 import org.mapstruct.ap.internal.model.common.TypeFactory;
 import org.mapstruct.ap.internal.prism.CollectionMappingStrategyPrism;
+import org.mapstruct.ap.internal.util.Executables;
 import org.mapstruct.ap.internal.util.FormattingMessager;
 import org.mapstruct.ap.internal.util.Message;
 
-import org.mapstruct.ap.internal.util.Executables;
-
 /**
  * This class describes the target side of a property mapping.
  * <p>
@@ -182,7 +181,6 @@ private void reportMappingError(Message msg, Object... objects) {
         }
     }
 
-
     private TargetReference(Parameter sourceParameter, List<PropertyEntry> sourcePropertyEntries, boolean isValid) {
         this.parameter = sourceParameter;
         this.propertyEntries = sourcePropertyEntries;

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/ValueMapping.java
Patch:
@@ -19,9 +19,11 @@
 package org.mapstruct.ap.internal.model.source;
 
 import java.util.List;
+
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ExecutableElement;
+
 import org.mapstruct.ap.internal.prism.MappingConstantsPrism;
 import org.mapstruct.ap.internal.prism.ValueMappingPrism;
 import org.mapstruct.ap.internal.prism.ValueMappingsPrism;
@@ -85,7 +87,6 @@ public static ValueMapping fromMappingPrism(ValueMappingPrism mappingPrism, Exec
             mappingPrism.values.source(), mappingPrism.values.target() );
     }
 
-
     private ValueMapping(String source, String target, AnnotationMirror mirror, AnnotationValue sourceAnnotationValue,
         AnnotationValue targetAnnotationValue ) {
         this.source = source;
@@ -159,6 +160,4 @@ public boolean equals(Object obj) {
         }
         return true;
     }
-
-
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/StringToXmlGregorianCalendar.java
Patch:
@@ -44,7 +44,6 @@ public class StringToXmlGregorianCalendar extends BuiltInMethod {
     private final Type returnType;
     private final Set<Type> importTypes;
 
-
     public StringToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "date", typeFactory.getType( String.class ) );
         this.returnType = typeFactory.getType( XMLGregorianCalendar.class );

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -476,6 +476,7 @@ private Assignment resolveViaMethodAndConversion(Type sourceType, Type targetTyp
             }
             return conversionYRef;
         }
+
         private boolean isCandidateForMapping(Method methodCandidate) {
             return isCreateMethodForMapping( methodCandidate ) || isUpdateMethodForMapping( methodCandidate );
         }

File: processor/src/main/java/org/mapstruct/ap/internal/util/MapperConfiguration.java
Patch:
@@ -178,7 +178,6 @@ private boolean isMapToDefaultOnMapperAndMappingConfigLevel() {
         return NullValueMappingStrategyPrism.RETURN_DEFAULT == strategy;
     }
 
-
     public String componentModel(Options options) {
         if ( mapperPrism.values.componentModel() != null ) {
             return mapperPrism.componentModel();

File: processor/src/test/java/org/mapstruct/ap/test/array/ArrayMappingTest.java
Patch:
@@ -61,7 +61,6 @@ public void shouldForgeMappingForIntToString() {
         assertThat( dto.getPublicationYears() ).containsOnly( 1993, 1997 );
     }
 
-
     @Test
     public void shouldMapArrayToArray() {
         ScientistDto[] dtos = ScienceMapper.INSTANCE

File: processor/src/test/java/org/mapstruct/ap/test/array/source/Scientist.java
Patch:
@@ -24,7 +24,6 @@ public class Scientist {
     private String[] publications;
     private String[] publicationYears;
 
-
     public Scientist(String name) {
         this.name = name;
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_289/Issue289Test.java
Patch:
@@ -43,7 +43,6 @@
 @RunWith(AnnotationProcessorTestRunner.class)
 public class Issue289Test {
 
-
     @Test
     public void shouldLeaveEmptyTargetSetWhenSourceIsNullAndGetterOnlyForCreateMethod() {
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_306/Source.java
Patch:
@@ -20,7 +20,6 @@
 
 import java.util.Set;
 
-
 public class Source {
 
     private Set<String> fooSet;
@@ -32,5 +31,4 @@ public Set<String> getFooSet() {
     public void setFooSet(Set<String> fooSet) {
         this.fooSet = fooSet;
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_374/Issue374Mapper.java
Patch:
@@ -47,6 +47,4 @@ public interface Issue374Mapper {
     List<String> mapIterable(List<String> source, @MappingTarget List<String> target);
 
     Map<Integer, String> mapMap(Map<Integer, String> source, @MappingTarget Map<Integer, String> target);
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_374/Issue374VoidMapper.java
Patch:
@@ -42,6 +42,4 @@ public interface Issue374VoidMapper {
     void mapIterable(List<String> source, @MappingTarget List<String> target);
 
     void mapMap(Map<Integer, String> source, @MappingTarget Map<Integer, String> target);
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_374/Source.java
Patch:
@@ -33,7 +33,4 @@ public String getTest() {
     public void setTest(String test) {
         this.test = test;
     }
-
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_375/Issue375Mapper.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.bugs._375;
 
-
 import org.mapstruct.Mapper;
 import org.mapstruct.factory.Mappers;
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_405/EntityFactory.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.bugs._405;
 
-
 import org.mapstruct.TargetType;
 
 public class EntityFactory {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_405/People.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.bugs._405;
 
-
 import java.util.List;
 
 public class People {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_405/Person.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.bugs._405;
 
-
 import java.util.List;
 
 public class Person {

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_513/Issue513Mapper.java
Patch:
@@ -26,13 +26,11 @@ public interface Issue513Mapper {
 
     Issue513Mapper INSTANCE = Mappers.getMapper( Issue513Mapper.class );
 
-
     Target map(Source source) throws MappingException, MappingValueException, MappingKeyException;
 
     TargetElement mapElement(SourceElement source) throws MappingException;
 
     TargetKey mapKey(SourceKey source) throws MappingException, MappingKeyException;
 
     TargetValue mapValue(SourceValue source) throws MappingException, MappingValueException;
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_513/MappingException.java
Patch:
@@ -24,7 +24,6 @@
  */
 public class MappingException extends Exception {
 
-
     public MappingException() {
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_513/MappingKeyException.java
Patch:
@@ -24,7 +24,6 @@
  */
 public class MappingKeyException extends Exception {
 
-
     public MappingKeyException() {
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_513/MappingValueException.java
Patch:
@@ -24,7 +24,6 @@
  */
 public class MappingValueException extends Exception {
 
-
     public MappingValueException() {
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_513/Source.java
Patch:
@@ -30,7 +30,6 @@ public class Source {
     private Collection<SourceElement> collection;
     private Map<SourceKey, SourceValue> map;
 
-
     public Collection<SourceElement> getCollection() {
         return collection;
     }
@@ -46,5 +45,4 @@ public Map<SourceKey, SourceValue> getMap() {
     public void setMap(Map<SourceKey, SourceValue> map) {
         this.map = map;
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_515/Target.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.bugs._515;
 
-
 public class Target {
 
     private String id;
@@ -30,5 +29,4 @@ public String getId() {
     public void setId(String id) {
         this.id = id;
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_631/Issue631Test.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.bugs._631;
 
-
 import javax.tools.Diagnostic.Kind;
 
 import org.junit.Test;

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_843/Issue843Test.java
Patch:
@@ -18,8 +18,10 @@
  */
 package org.mapstruct.ap.test.bugs._843;
 
-import java.util.Date;
 import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.Date;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mapstruct.ap.testutil.IssueKey;

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_849/Issue849Test.java
Patch:
@@ -18,9 +18,10 @@
  */
 package org.mapstruct.ap.test.bugs._849;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.io.Serializable;
 import java.util.Arrays;
-import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_913/DomainWithoutSetter.java
Patch:
@@ -54,6 +54,4 @@ public Set<Long> getLongsInitialized() {
     public List<String> getStringsWithDefault() {
         return stringsWithDefault;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_913/Issue913SetterMapperForCollectionsTest.java
Patch:
@@ -18,9 +18,11 @@
  */
 package org.mapstruct.ap.test.bugs._913;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.util.HashSet;
 import java.util.Set;
-import static org.assertj.core.api.Assertions.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mapstruct.ap.testutil.IssueKey;

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_971/CollectionSource.java
Patch:
@@ -29,7 +29,6 @@ public class CollectionSource {
     private List<Integer> integers;
     private List<Integer> integersCollection;
 
-
     public List<Integer> getIntegers() {
         return integers;
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_971/MapSource.java
Patch:
@@ -29,7 +29,6 @@ public class MapSource {
     private Map<Integer, String> integersSortedMap;
     private Map<Integer, String> integersBaseMap;
 
-
     public Map<Integer, String> getIntegersSortedMap() {
         return integersSortedMap;
     }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_971/MapTarget.java
Patch:
@@ -30,7 +30,6 @@ public class MapTarget {
     private SortedMap<String, Integer> integersSortedMap;
     private Map<String, Integer> integersBaseMap;
 
-
     public SortedMap<String, Integer> getIntegersSortedMap() {
         return integersSortedMap;
     }

File: processor/src/test/java/org/mapstruct/ap/test/builtin/bean/JaxbElementProperty.java
Patch:
@@ -24,7 +24,6 @@ public class JaxbElementProperty {
 
     private JAXBElement<String> prop;
 
-
     public JAXBElement<String> getProp() {
         return prop;
     }

File: processor/src/test/java/org/mapstruct/ap/test/builtin/bean/StringProperty.java
Patch:
@@ -22,13 +22,11 @@ public class StringProperty {
 
     private String prop;
 
-
     public String getProp() {
         return prop;
     }
 
     public void setProp( String prop ) {
         this.prop = prop;
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/builtin/mapper/MapSourceTargetMapper.java
Patch:
@@ -34,6 +34,6 @@ public interface MapSourceTargetMapper {
     MapSourceTargetMapper INSTANCE = Mappers.getMapper( MapSourceTargetMapper.class );
 
     MapTarget sourceToTarget(MapSource source);
-    Map<String, String> longDateMapToStringStringMap(Map<JAXBElement<String>, XMLGregorianCalendar> source);
 
+    Map<String, String> longDateMapToStringStringMap(Map<JAXBElement<String>, XMLGregorianCalendar> source);
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/_target/OutdoorPet.java
Patch:
@@ -36,6 +36,4 @@ public Long getValue() {
     public void setValue(Long value) {
         this.value = value;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/erroneous/EmptyItererableMappingMapper.java
Patch:
@@ -31,8 +31,6 @@
 @Mapper
 public interface EmptyItererableMappingMapper {
 
-
     @IterableMapping
     List<String> stringListToDateList(List<Date> dates);
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/erroneous/ErroneousCollectionMappingTest.java
Patch:
@@ -81,7 +81,7 @@ public void shouldFailToGenerateImplementationBetweenCollectionAndPrimitive() {
         diagnostics = {
             @Diagnostic(type = EmptyItererableMappingMapper.class,
                 kind = Kind.ERROR,
-                line = 36,
+                line = 35,
                 messageRegExp = "'nullValueMappingStrategy','dateformat', 'qualifiedBy' and 'elementTargetType' are "
                     + "undefined in @IterableMapping, define at least one of them.")
         }

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/CollectionMapper.java
Patch:
@@ -27,5 +27,6 @@ public interface CollectionMapper {
     CollectionMapper INSTANCE = Mappers.getMapper( CollectionMapper.class );
 
     Target sourceToTarget(Source source);
+
     Source targetToSource(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/CollectionMapperNullValueMappingReturnDefault.java
Patch:
@@ -29,5 +29,6 @@ public interface CollectionMapperNullValueMappingReturnDefault {
         Mappers.getMapper( CollectionMapperNullValueMappingReturnDefault.class );
 
     Target sourceToTarget( Source source );
+
     Source targetToSource( Target target );
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/CollectionMappingTest.java
Patch:
@@ -120,7 +120,6 @@ public void shouldGenerateNonMappleMethodForSetMapping() {
     public void shouldGenerateNonMappleMethodForMapMapping() {
     }
 
-
     @Test
     @IssueKey( "640" )
     @WithClasses({ CollectionMapper.class, Source.class, Target.class })

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/ErroneousNonMappableMapSource.java
Patch:
@@ -31,6 +31,4 @@ public Map<Foo, Foo> getNonMappableMap() {
     public void setNonMappableMap(Map<Foo, Foo> nonMappableMap) {
         this.nonMappableMap = nonMappableMap;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/Target.java
Patch:
@@ -59,6 +59,4 @@ public Map<String, String> getBarMap2() {
     public void setBarMap2( Map<String, String> barMap2 ) {
         this.barMap2 = barMap2;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/map/SourceTargetMapper.java
Patch:
@@ -34,6 +34,7 @@ public interface SourceTargetMapper {
 
     @MapMapping(valueDateFormat = "dd.MM.yyyy")
     Map<String, String> longDateMapToStringStringMap(Map<Long, Date> source);
+
     @InheritInverseConfiguration
     Map<Long, Date> stringStringMapToLongDateMap(Map<String, String> source);
 
@@ -46,6 +47,7 @@ Map<Long, Date> stringStringMapToLongDateMapUsingTargetParameterAndReturn(Map<St
                                                                               @MappingTarget Map<Long, Date> target);
 
     Target sourceToTarget(Source source);
+
     @InheritInverseConfiguration
     Source targetToSource(Target target);
 

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/CunningPlan.java
Patch:
@@ -27,8 +27,6 @@
  * @author Sjaak Derksen
  */
 public class CunningPlan {
-
-
     private BigDecimal content;
     private JAXBElement<? super BigDecimal> description;
 
@@ -47,5 +45,4 @@ public JAXBElement<? super BigDecimal> getDescription() {
     public void setDescription(JAXBElement<? super BigDecimal> description) {
         this.description = description;
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/SuperBoundTarget.java
Patch:
@@ -45,6 +45,4 @@ public void setElements(List<? super Plan> elements) {
     public void setEntries(Map<? super Plan, ? super Plan> entries) {
         this.entries = entries;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/Target.java
Patch:
@@ -45,6 +45,4 @@ public Map<Plan, Plan> getEntries() {
     public void setEntries(Map<Plan, Plan> entries) {
         this.entries = entries;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/wildcard/WildCardTest.java
Patch:
@@ -137,7 +137,6 @@ public void shouldFailOnTypeVarSource() {
     public void shouldFailOnTypeVarTarget() {
     }
 
-
     @Test
     @WithClasses( { BeanMapper.class, GoodIdea.class, CunningPlan.class } )
     public void shouldMapBean() {

File: processor/src/test/java/org/mapstruct/ap/test/complex/source/Car.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.Date;
 import java.util.List;
 
-
 public class Car {
 
     private String make;

File: processor/src/test/java/org/mapstruct/ap/test/conversion/SourceTargetMapper.java
Patch:
@@ -34,6 +34,7 @@ public interface SourceTargetMapper {
         @Mapping(source = "baz", target = "qax")
     })
     Target sourceToTarget(Source source);
+
     @InheritInverseConfiguration
     Source targetToSource(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/date/DateConversionTest.java
Patch:
@@ -137,7 +137,6 @@ public void shouldApplyStringConversionForReverseArrayMethod() {
         );
     }
 
-
     @Test
     public void shouldApplyStringConversionForReverseArrayArrayMethod() {
          Date[] dates = new Date[]{

File: processor/src/test/java/org/mapstruct/ap/test/conversion/java8time/Target.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.Calendar;
 import java.util.Date;
+
 /**
  *
  */

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/annotationnotfound/Source.java
Patch:
@@ -33,7 +33,4 @@ public Integer getFoo() {
     public void setFoo( Integer foo ) {
         this.foo = foo;
     }
-
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/annotationnotfound/Target.java
Patch:
@@ -33,7 +33,4 @@ public String getFoo() {
     public void setFoo( String foo ) {
         this.foo = foo;
     }
-
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/exceptions/ExceptionTest.java
Patch:
@@ -129,7 +129,6 @@ public void shouldThrowTestException2InMapValueMapping() throws TestException2 {
         sourceTargetMapper.integerValueMapToLongValueMap( source );
     }
 
-
     @Test( expected = RuntimeException.class )
     @IssueKey( "198" )
     public void shouldThrowRuntimeInBeanMappingViaBaseException() throws TestExceptionBase {

File: processor/src/test/java/org/mapstruct/ap/test/exceptions/SourceTargetMapper.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.exceptions;
 
-
 import java.text.ParseException;
 import java.util.List;
 import java.util.Map;
@@ -34,7 +33,7 @@
  */
 @Mapper( uses = ExceptionTestMapper.class )
 @DecoratedWith( ExceptionTestDecorator.class )
-public  interface SourceTargetMapper {
+public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 

File: processor/src/test/java/org/mapstruct/ap/test/ignore/IgnorePropertyTest.java
Patch:
@@ -18,9 +18,10 @@
  */
 package org.mapstruct.ap.test.ignore;
 
-import javax.tools.Diagnostic.Kind;
 import static org.assertj.core.api.Assertions.assertThat;
 
+import javax.tools.Diagnostic.Kind;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mapstruct.ap.testutil.IssueKey;

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/AdditionalMappingHelper.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.inheritance.complex;
 
-
 public class AdditionalMappingHelper {
 
     public Reference asReference(SourceBase source) {

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/SourceBaseMappingHelper.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.Collection;
 import java.util.List;
 
-
 public class SourceBaseMappingHelper {
     public Reference asReference(SourceBase source) {
         if ( null == source ) {

File: processor/src/test/java/org/mapstruct/ap/test/inheritedmappingmethod/_target/CarDto.java
Patch:
@@ -28,6 +28,4 @@ public int getHorsepower() {
     public void setHorsepower(int horsepower) {
         this.horsepower = horsepower;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/inheritedmappingmethod/source/Car.java
Patch:
@@ -28,6 +28,4 @@ public int getHorsepower() {
     public void setHorsepower(int horsepower) {
         this.horsepower = horsepower;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/mapperconfig/SourceTargetMapper.java
Patch:
@@ -31,5 +31,6 @@ public interface SourceTargetMapper {
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     Target toTarget( Source source );
+
     Source toSource( Target target );
 }

File: processor/src/test/java/org/mapstruct/ap/test/naming/Break.java
Patch:
@@ -43,7 +43,6 @@ public void setSomeNumber(String someNumber) {
         this.someNumber = someNumber;
     }
 
-
     public Map<String, String> getMap() {
         return map;
     }

File: processor/src/test/java/org/mapstruct/ap/test/nestedmethodcall/OrderType.java
Patch:
@@ -32,7 +32,6 @@ public class OrderType {
     private JAXBElement<OrderDetailsType> orderDetails;
     private List<JAXBElement<XMLGregorianCalendar>> dates;
 
-
     public JAXBElement<Long> getOrderNumber() {
         return orderNumber;
     }

File: processor/src/test/java/org/mapstruct/ap/test/nestedmethodcall/SourceTypeTargetDtoMapper.java
Patch:
@@ -32,6 +32,6 @@ public interface SourceTypeTargetDtoMapper {
 
     @Mapping(source = "date", target = "date", dateFormat = "dd.MM.yyyy")
     TargetDto sourceToTarget(SourceType source);
-    SourceType targetToSource( TargetDto source );
 
+    SourceType targetToSource( TargetDto source );
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedsource/parameter/LetterEntity.java
Patch:
@@ -69,6 +69,4 @@ public String getLetterSignature() {
     public void setLetterSignature(String letterSignature) {
         this.letterSignature = letterSignature;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedsourceproperties/source/Artist.java
Patch:
@@ -26,7 +26,6 @@ public class Artist {
     private String name;
     private Label label;
 
-
     public String getName() {
         return name;
     }
@@ -42,5 +41,4 @@ public Label getLabel() {
     public void setLabel(Label label) {
         this.label = label;
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/nestedtargetproperties/ChartEntryToArtist.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+
 import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
@@ -48,7 +49,6 @@ public abstract class ChartEntryToArtist {
     })
     public abstract Chart map(ChartEntry chartEntry);
 
-
     @Mappings({
         @Mapping(target = "type", ignore = true),
         @Mapping(target = "name", source = "chartEntry2.chartName"),
@@ -71,6 +71,7 @@ protected List<Integer> mapPosition(Integer in) {
             return Collections.<Integer>emptyList();
         }
     }
+
     protected Integer mapPosition(List<Integer> in) {
         if ( in != null && !in.isEmpty() ) {
             return in.get( 0 );
@@ -79,5 +80,4 @@ protected Integer mapPosition(List<Integer> in) {
             return null;
         }
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullcheck/NullObjectMapper.java
Patch:
@@ -23,7 +23,6 @@
  */
 public class NullObjectMapper {
 
-
     public String toNullString(NullObject in) {
         return in.toString();
     }

File: processor/src/test/java/org/mapstruct/ap/test/nullcheck/Target.java
Patch:
@@ -70,6 +70,4 @@ public MyLongWrapper getSomeLong() {
     public void setSomeLong(MyLongWrapper someLong) {
         this.someLong = someLong;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/CarMapper.java
Patch:
@@ -57,7 +57,6 @@ public interface CarMapper {
     })
     CarDto carToCarDto(Car car, String model);
 
-
     @IterableMapping(nullValueMappingStrategy = RETURN_DEFAULT)
     List<CarDto> carsToCarDtos(List<Car> cars);
 

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/CarMapperSettingOnConfig.java
Patch:
@@ -44,11 +44,9 @@ public interface CarMapperSettingOnConfig {
     })
     CarDto carToCarDto(Car car);
 
-
     @IterableMapping(dateFormat = "dummy")
     List<CarDto> carsToCarDtos(List<Car> cars);
 
-
     @MapMapping(nullValueMappingStrategy = NullValueMappingStrategy.RETURN_NULL)
     Map<Integer, CarDto> carsToCarDtoMap(Map<Integer, Car> cars);
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/CarMapperSettingOnMapper.java
Patch:
@@ -44,11 +44,9 @@ public interface CarMapperSettingOnMapper {
     })
     CarDto carToCarDto(Car car);
 
-
     @IterableMapping(nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT)
     List<CarDto> carsToCarDtos(List<Car> cars);
 
-
     @MapMapping(nullValueMappingStrategy = NullValueMappingStrategy.RETURN_NULL)
     Map<Integer, CarDto> carsToCarDtoMap(Map<Integer, Car> cars);
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/_target/CarDto.java
Patch:
@@ -25,7 +25,6 @@ public class CarDto {
     private String model;
     private String catalogId;
 
-
     public CarDto() {
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/source/Car.java
Patch:
@@ -18,13 +18,11 @@
  */
 package org.mapstruct.ap.test.nullvaluemapping.source;
 
-
 public class Car {
 
     private String make;
     private int numberOfSeats;
 
-
     public Car() {
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/prism/ConstantTest.java
Patch:
@@ -20,7 +20,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-
 import org.junit.Test;
 import org.mapstruct.MappingConstants;
 import org.mapstruct.ap.internal.prism.MappingConstantsPrism;
@@ -38,5 +37,4 @@ public void constantsShouldBeEqual() {
         assertThat( MappingConstants.ANY_UNMAPPED ).isEqualTo( MappingConstantsPrism.ANY_UNMAPPED );
         assertThat( MappingConstants.NULL ).isEqualTo( MappingConstantsPrism.NULL );
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/reverse/Source.java
Patch:
@@ -62,6 +62,4 @@ public String getPropertyToIgnoreDownstream() {
     public void setPropertyToIgnoreDownstream(String propertyToIgnoreDownstream) {
         this.propertyToIgnoreDownstream = propertyToIgnoreDownstream;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/reverse/Target.java
Patch:
@@ -52,6 +52,4 @@ public String getPropertyNotToIgnoreUpstream() {
     public void setPropertyNotToIgnoreUpstream(String propertyNotToIgnoreUpstream) {
         this.propertyNotToIgnoreUpstream = propertyNotToIgnoreUpstream;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/generics/ErroneousSource6.java
Patch:
@@ -29,7 +29,4 @@ public WildCardSuperWrapper<String> getFoo() {
     public void setFoo(WildCardSuperWrapper<String> foo) {
         this.foo = foo;
     }
-
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/jaxb/test1/ObjectFactory.java
Patch:
@@ -37,7 +37,6 @@ public class ObjectFactory {
     public static final QName ORDER_TYPE_SHIPPING_DETAILS_QNAME =
         new QName( "http://www.mapstruct.org/ap/test/jaxb/selection/test1", "shippingDetails" );
 
-
     public ObjectFactory() {
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/selection/jaxb/test1/OrderType.java
Patch:
@@ -26,7 +26,6 @@
 
 import org.mapstruct.ap.test.selection.jaxb.test2.OrderShippingDetailsType;
 
-
 @XmlAccessorType(XmlAccessType.FIELD)
 @XmlType(name = "OrderType", propOrder = {
     "orderNumber1",

File: processor/src/test/java/org/mapstruct/ap/test/selection/jaxb/test2/ObjectFactory.java
Patch:
@@ -40,7 +40,6 @@ public OrderShippingDetailsType createOrderShippingDetailsType() {
         return new OrderShippingDetailsType();
     }
 
-
     @XmlElementDecl(namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", name = "OrderShippingDetails")
     public JAXBElement<OrderShippingDetailsType> createOrderShippingDetails(OrderShippingDetailsType value) {
         return new JAXBElement<OrderShippingDetailsType>(

File: processor/src/test/java/org/mapstruct/ap/test/selection/jaxb/test2/OrderShippingDetailsType.java
Patch:
@@ -24,7 +24,6 @@
 import javax.xml.bind.annotation.XmlElementRef;
 import javax.xml.bind.annotation.XmlType;
 
-
 @XmlAccessorType(XmlAccessType.FIELD)
 @XmlType(name = "OrderShippingDetailsType", propOrder = {
     "orderShippedFrom",

File: processor/src/test/java/org/mapstruct/ap/test/selection/primitives/Source.java
Patch:
@@ -42,6 +42,4 @@ public Integer getWrappedInt() {
     public void setWrappedInt( Integer wrappedInt ) {
         this.wrappedInt = wrappedInt;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/KeyWordMapper.java
Patch:
@@ -43,7 +43,6 @@ public abstract class KeyWordMapper {
             .put( "box office flop", "Kasse Flop" )
             .build();
 
-
     public static final KeyWordMapper INSTANCE = Mappers.getMapper( KeyWordMapper.class );
 
     @IterableMapping( dateFormat = "", qualifiedBy = { EnglishToGerman.class } )

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/QualifierTest.java
Patch:
@@ -122,7 +122,6 @@ public void shouldMatchClassAndMethod() {
     public void shouldNotProduceMatchingMethod() {
     }
 
-
     @Test
     @WithClasses( {
         MapperWithoutQualifiedBy.class,

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/bean/AbstractEntry.java
Patch:
@@ -56,6 +56,4 @@ public Map<String, List<String> > getFacts() {
     public void setFacts( Map<String, List<String> > facts ) {
         this.facts = facts;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/handwritten/Titles.java
Patch:
@@ -20,11 +20,11 @@
 
 import java.util.Map;
 
+import org.mapstruct.Named;
 import org.mapstruct.ap.test.selection.qualifier.annotation.EnglishToGerman;
 import org.mapstruct.ap.test.selection.qualifier.annotation.TitleTranslator;
 
 import com.google.common.collect.ImmutableMap;
-import org.mapstruct.Named;
 
 /**
  *
@@ -48,9 +48,7 @@ public String translateTitle(String title) {
         return EN_GER.get( title );
     }
 
-
     public String methodNotToSelect( String title ) {
         throw new AssertionError( "method should not be called" );
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/hybrid/ReleaseMapper.java
Patch:
@@ -35,10 +35,8 @@ public interface ReleaseMapper {
 
     ReleaseMapper INSTANCE = Mappers.getMapper( ReleaseMapper.class );
 
-
     @Mappings( {
         @Mapping( target = "title", qualifiedBy = { TitleTranslator.class }, qualifiedByName = { "EnglishToGerman" } )
     } )
     TargetRelease toGerman( SourceRelease movies );
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/iterable/IterableAndQualifiersTest.java
Patch:
@@ -18,9 +18,11 @@
  */
 package org.mapstruct.ap.test.selection.qualifier.iterable;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.util.ArrayList;
 import java.util.List;
-import static org.assertj.core.api.Assertions.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mapstruct.ap.testutil.IssueKey;

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/named/KeyWordMapper.java
Patch:
@@ -43,7 +43,6 @@ public abstract class KeyWordMapper {
             .put( "box office flop", "Kasse Flop" )
             .build();
 
-
     public static final KeyWordMapper INSTANCE = Mappers.getMapper( KeyWordMapper.class );
 
     @IterableMapping( dateFormat = "", qualifiedByName = "EnglishToGerman" )

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/Apple.java
Patch:
@@ -24,13 +24,11 @@
  */
 public class Apple extends Fruit {
 
-
     public Apple() {
         super( "constructed-by-constructor" );
     }
 
     public Apple(String type) {
         super( type );
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/Fruit.java
Patch:
@@ -37,6 +37,4 @@ public String getType() {
     public void setType(String type) {
         this.type = type;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/FruitDto.java
Patch:
@@ -37,6 +37,4 @@ public String getType() {
     public void setType(String type) {
         this.type = type;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/InheritanceSelectionTest.java
Patch:
@@ -50,7 +50,6 @@
 @RunWith(AnnotationProcessorTestRunner.class)
 public class InheritanceSelectionTest {
 
-
     @Test
     @WithClasses( { ConflictingFruitFactory.class, ErroneousFruitMapper.class, Banana.class } )
     @ExpectedCompilationOutcome(

File: processor/src/test/java/org/mapstruct/ap/test/severalsources/DeliveryAddress.java
Patch:
@@ -90,7 +90,6 @@ public void setHouseNumber(int houseNumber) {
         this.houseNumber = houseNumber;
     }
 
-
     public String getDescription() {
         return description;
     }

File: processor/src/test/java/org/mapstruct/ap/test/severalsources/ReferencedMapper.java
Patch:
@@ -38,5 +38,5 @@ public static boolean isBeforeMappingCalled() {
 
     public static void setBeforeMappingCalled(boolean beforeMappingCalled) {
         ReferencedMapper.beforeMappingCalled = beforeMappingCalled;
-    };
+    }
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/Source.java
Patch:
@@ -32,6 +32,4 @@ public String getPropertyThatShouldBeMapped() {
     public void setPropertyThatShouldBeMapped(String propertyThatShouldBeMapped) {
         this.propertyThatShouldBeMapped = propertyThatShouldBeMapped;
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/StringListMapper.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.Arrays;
 import java.util.List;
 
-
 public class StringListMapper {
 
     public List<String> stringToStringList(String string) {

File: processor/src/test/java/org/mapstruct/ap/test/source/expressions/java/BooleanWorkAroundMapper.java
Patch:
@@ -33,5 +33,6 @@ public interface BooleanWorkAroundMapper {
 
     @Mapping( expression = "java(source.isVal())", target = "val" )
     TargetBooleanWorkAround mapST( SourceBooleanWorkAround source );
+
     SourceBooleanWorkAround mapTS( TargetBooleanWorkAround target );
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/nullvaluecheckstrategy/RockFestivalMapper.java
Patch:
@@ -38,6 +38,4 @@ public abstract class RockFestivalMapper {
     public Stage artistToStage( String name ) {
         return Stage.forArtist( name );
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/nullvaluecheckstrategy/RockFestivalMapperConfig.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.mapstruct.MapperConfig;
 import org.mapstruct.NullValueCheckStrategy;
+
 /**
  *
  * @author Sjaak Derksen

File: processor/src/test/java/org/mapstruct/ap/test/source/nullvaluecheckstrategy/RockFestivalMapperOveridingConfig.java
Patch:
@@ -18,10 +18,11 @@
  */
 package org.mapstruct.ap.test.source.nullvaluecheckstrategy;
 
+import static org.mapstruct.NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
+
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.factory.Mappers;
-import static org.mapstruct.NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
 
 /**
  *
@@ -39,6 +40,4 @@ public abstract class RockFestivalMapperOveridingConfig {
     public Stage artistToStage( String name ) {
         return Stage.forArtist( name );
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/nullvaluecheckstrategy/RockFestivalMapperWithConfig.java
Patch:
@@ -38,6 +38,4 @@ public abstract class RockFestivalMapperWithConfig {
     public Stage artistToStage( String name ) {
         return Stage.forArtist( name );
     }
-
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/presencecheck/spi/PresenceCheckTest.java
Patch:
@@ -18,9 +18,10 @@
  */
 package org.mapstruct.ap.test.source.presencecheck.spi;
 
-import java.util.Arrays;
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.util.Arrays;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mapstruct.ap.testutil.WithClasses;

File: processor/src/test/java/org/mapstruct/ap/test/source/presencecheck/spi/SoccerTeamMapper.java
Patch:
@@ -36,7 +36,6 @@ public interface SoccerTeamMapper {
     @Mapping( target = "goalKeeperName", ignore = true )
     SoccerTeamTarget mapAdder( SoccerTeamSource in );
 
-
     @Mappings({
         @Mapping(target = "players", ignore = true),
         @Mapping(target = "goalKeeperName", source = "goalKeeper.name")

File: processor/src/test/java/org/mapstruct/ap/test/source/presencecheck/spi/SoccerTeamTarget.java
Patch:
@@ -29,7 +29,6 @@ public class SoccerTeamTarget {
     private List<String> players;
     private String goalKeeperName;
 
-
     public List<String> getPlayers() {
         return players;
     }

File: processor/src/test/java/org/mapstruct/ap/test/source/presencecheck/spi/SourceTargetMapper.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.Arrays;
 import java.util.List;
+
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.MappingTarget;
@@ -48,7 +49,6 @@ public abstract class SourceTargetMapper {
     } )
     abstract Target sourceToTargetWitDefaults(Source source);
 
-
     protected List<String> toList( String in ) {
         return Arrays.asList( in.split( "," ) );
     }

File: processor/src/test/java/org/mapstruct/ap/test/template/NestedSource.java
Patch:
@@ -30,7 +30,6 @@ public NestedSource(String nested) {
         this.nested = nested;
     }
 
-
     public String getNested() {
         return nested;
     }

File: processor/src/test/java/org/mapstruct/ap/test/template/Source.java
Patch:
@@ -30,7 +30,6 @@ public class Source {
 
     private NestedSource nestedSourceProp;
 
-
     public String getStringPropX() {
         return stringPropX;
     }

File: processor/src/test/java/org/mapstruct/ap/test/template/SourceTargetMapperSingle.java
Patch:
@@ -42,8 +42,6 @@ public interface SourceTargetMapperSingle {
     })
     Target forwardCreate(Source s1);
 
-
     @InheritConfiguration
     void forwardUpdate(Source source, @MappingTarget Target target);
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/DepartmentEntityFactory.java
Patch:
@@ -24,9 +24,7 @@
  */
 public class DepartmentEntityFactory {
 
-
     public DepartmentEntity createDepartmentEntity() {
         return new DepartmentEntity(5);
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/selection/ExternalHandWrittenMapper.java
Patch:
@@ -35,7 +35,6 @@
  */
 public class ExternalHandWrittenMapper {
 
-
     public void toDepartmentEntity(DepartmentDto dto, @MappingTarget DepartmentEntity entity) {
         if ( entity != null && dto != null ) {
             entity.setName( dto.getName() );

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/selection/ExternalSelectionTest.java
Patch:
@@ -102,7 +102,6 @@ public void shouldSelectGeneratedHandWrittenExternalMapper() {
         OrganizationMapper2.INSTANCE.toCompanyEntity( dto, entity );
     }
 
-
     @Test
     @IssueKey( "487" )
     public void shouldSelectGeneratedExternalMapperForIterablesAndMaps() {

File: processor/src/main/java/org/mapstruct/ap/internal/model/IterableMappingMethod.java
Patch:
@@ -304,6 +304,9 @@ public boolean equals(Object obj) {
         }
 
         for ( int i = 0; i < getSourceParameters().size(); i++ ) {
+            if ( !getSourceParameters().get( i ).getType().equals( other.getSourceParameters().get( i ).getType() ) ) {
+                return false;
+            }
             List<Type> thisTypeParameters = getSourceParameters().get( i ).getType().getTypeParameters();
             List<Type> otherTypeParameters = other.getSourceParameters().get( i ).getType().getTypeParameters();
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/UpdateWrapper.java
Patch:
@@ -78,6 +78,7 @@ public Set<Type> getImportTypes() {
         imported.addAll( super.getImportTypes() );
         if ( targetImplementationType != null ) {
             imported.add( targetImplementationType );
+            imported.addAll( targetImplementationType.getTypeParameters() );
         }
         return imported;
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/StringHolderArrayList.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * @author Stefan May
  */
-public class StringArrayList extends ArrayList<String> {
+public class StringHolderArrayList extends ArrayList<StringHolder> {
 
     private static final long serialVersionUID = 1L;
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/StringHolderToLongMap.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * @author Stefan May
  */
-public class StringToLongMap extends HashMap<String, Long> {
+public class StringHolderToLongMap extends HashMap<StringHolder, Long> {
 
     private static final long serialVersionUID = 1L;
 

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/CompilingStatement.java
Patch:
@@ -399,6 +399,9 @@ private List<String> getProcessorOptions() {
             result.add( asOptionString( option ) );
         }
 
+        // Add all debugging info to class files
+        result.add( "-g:source,lines,vars" );
+
         return result;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/SetterWrapperForCollectionsAndMaps.java
Patch:
@@ -41,7 +41,6 @@ public class SetterWrapperForCollectionsAndMaps extends AssignmentWrapper {
 
     private final String targetGetterName;
     private final Assignment newCollectionOrMapAssignment;
-    private final Type targetType;
     private final String localVarName;
 
     public SetterWrapperForCollectionsAndMaps(Assignment decoratedAssignment,
@@ -53,7 +52,6 @@ public SetterWrapperForCollectionsAndMaps(Assignment decoratedAssignment,
 
         this.targetGetterName = targetGetterName;
         this.newCollectionOrMapAssignment = newCollectionOrMapAssignment;
-        this.targetType = targetType;
         this.localVarName = Strings.getSaveVariableName( targetType.getName(), existingVariableNames );
         existingVariableNames.add( localVarName );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/ForgedMethod.java
Patch:
@@ -57,12 +57,12 @@ public class ForgedMethod implements Method {
      */
     public ForgedMethod(String name, Type sourceType, Type targetType, MapperConfiguration mapperConfiguration,
         ExecutableElement positionHintElement) {
-        String sourceParamName = Strings.decapitalize( sourceType.getName().replace( "[]", "" ) );
+        String sourceParamName = Strings.decapitalize( sourceType.getName() );
         String sourceParamSafeName = Strings.getSaveVariableName( sourceParamName );
         this.parameters = Arrays.asList( new Parameter( sourceParamSafeName, sourceType ) );
         this.returnType = targetType;
         this.thrownTypes = new ArrayList<Type>();
-        this.name = name;
+        this.name = Strings.sanitizeIdentifierName( name );
         this.mapperConfiguration = mapperConfiguration;
         this.positionHintElement = positionHintElement;
     }

File: processor/src/main/java/org/mapstruct/ap/MappingProcessor.java
Patch:
@@ -127,13 +127,12 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
 
     private Options createOptions() {
         String unmappedTargetPolicy = processingEnv.getOptions().get( UNMAPPED_TARGET_POLICY );
-        String defaultComponentModel = processingEnv.getOptions().get( DEFAULT_COMPONENT_MODEL );
 
         return new Options(
             Boolean.valueOf( processingEnv.getOptions().get( SUPPRESS_GENERATOR_TIMESTAMP ) ),
             Boolean.valueOf( processingEnv.getOptions().get( SUPPRESS_GENERATOR_VERSION_INFO_COMMENT ) ),
-            unmappedTargetPolicy != null ? ReportingPolicy.valueOf( unmappedTargetPolicy ) : null,
-            defaultComponentModel == null ? "default" : defaultComponentModel,
+            unmappedTargetPolicy != null ? ReportingPolicy.valueOf( unmappedTargetPolicy.toUpperCase() ) : null,
+            processingEnv.getOptions().get( DEFAULT_COMPONENT_MODEL ),
             Boolean.valueOf( processingEnv.getOptions().get( ALWAYS_GENERATE_SERVICE_FILE ) )
         );
     }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/GetterWrapperForCollectionsAndMaps.java
Patch:
@@ -75,6 +75,7 @@ public Set<Type> getImportTypes() {
         Set<Type> imported = new HashSet<Type>();
         imported.addAll( super.getImportTypes() );
         imported.add( localVarType ); /* is a local var */
+        imported.addAll( localVarType.getTypeParameters() );
         return imported;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -56,6 +56,7 @@ public enum Message {
 
     CONSTANTMAPPING_MAPPING_NOT_FOUND( "Can't map \"%s %s\" to \"%s %s\"." ),
     CONSTANTMAPPING_NO_READ_ACCESSOR_FOR_TARGET_TYPE( "No read accessor found for property \"%s\" in target type." ),
+    CONSTANTMAPPING_NON_EXISTING_CONSTANT( "Constant %s doesn't exist in enum type %s for property \"%s\"." ),
 
     MAPMAPPING_KEY_MAPPING_NOT_FOUND( "No implementation can be generated for this method. Found no method nor implicit conversion for mapping source key type to target key type." ),
     MAPMAPPING_VALUE_MAPPING_NOT_FOUND( "No implementation can be generated for this method. Found no method nor implicit conversion for mapping source value type to target value type." ),

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper1.java
Patch:
@@ -37,7 +37,8 @@ public interface ErroneousMapper1 {
         @Mapping(source = "test", target = "integerConstant", constant = "14"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),
-        @Mapping(target = "nameConstants", constant = "jack-jill-tom")
+        @Mapping(target = "nameConstants", constant = "jack-jill-tom"),
+        @Mapping(target = "country", constant = "THE_NETHERLANDS")
     })
     Target sourceToTarget(Source s);
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper2.java
Patch:
@@ -36,7 +36,8 @@ public interface ErroneousMapper2 {
         @Mapping(target = "integerConstant"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),
-        @Mapping(target = "nameConstants", constant = "jack-jill-tom")
+        @Mapping(target = "nameConstants", constant = "jack-jill-tom"),
+        @Mapping(target = "country", constant = "THE_NETHERLANDS")
     })
     Target sourceToTarget(Source s);
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper3.java
Patch:
@@ -37,7 +37,8 @@ public interface ErroneousMapper3 {
         @Mapping(target = "integerConstant", expression = "java('test')", constant = "14"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),
-        @Mapping(target = "nameConstants", constant = "jack-jill-tom")
+        @Mapping(target = "nameConstants", constant = "jack-jill-tom"),
+        @Mapping(target = "country", constant = "THE_NETHERLANDS")
     })
     Target sourceToTarget(Source s);
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper4.java
Patch:
@@ -37,7 +37,8 @@ public interface ErroneousMapper4 {
         @Mapping(source = "test", target = "integerConstant", expression = "java('test')"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),
-        @Mapping(target = "nameConstants", constant = "jack-jill-tom")
+        @Mapping(target = "nameConstants", constant = "jack-jill-tom"),
+        @Mapping(target = "country", constant = "THE_NETHERLANDS")
     })
     Target sourceToTarget(Source s);
 }

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/SourceTargetMapper.java
Patch:
@@ -37,7 +37,8 @@ public interface SourceTargetMapper {
         @Mapping(target = "integerConstant", constant = "14"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),
-        @Mapping(target = "nameConstants", constant = "jack-jill-tom")
+        @Mapping(target = "nameConstants", constant = "jack-jill-tom"),
+        @Mapping(target = "country", constant = "THE_NETHERLANDS")
     })
     Target sourceToTarget(Source s);
 

File: processor/src/main/java/org/mapstruct/ap/internal/util/workarounds/EclipseAsMemberOfWorkaround.java
Patch:
@@ -41,7 +41,7 @@
 /**
  * Contains the workaround for {@link Types#asMemberOf(DeclaredType, Element)} using Eclipse implementation types.
  * <p>
- * <strong>This class may only be loaded when running within Eclipse</strong>
+ * <strong>This class may only be accessed through {@link EclipseClassLoaderBridge} when running within Eclipse</strong>
  *
  * @author Andreas Gudian
  */

File: processor/src/test/java/org/mapstruct/ap/test/source/presencecheck/spi/PresenceCheckTest.java
Patch:
@@ -23,10 +23,8 @@
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mapstruct.ap.spi.PresenceCheckAccessorNamingStrategy;
 import org.mapstruct.ap.testutil.WithClasses;
 import org.mapstruct.ap.testutil.runner.AnnotationProcessorTestRunner;
-import org.mapstruct.ap.testutil.WithServiceImplementation;
 
 /**
  * Test for correct handling of source presence checks.
@@ -42,7 +40,6 @@
     GoalKeeper.class,
     SoccerTeamTarget.class
 })
-@WithServiceImplementation( PresenceCheckAccessorNamingStrategy.class )
 @RunWith(AnnotationProcessorTestRunner.class)
 public class PresenceCheckTest {
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -294,6 +294,7 @@ else if ( mapping.getSourceName() != null ) {
                                     .sourceReference( sourceRef )
                                     .selectionParameters( mapping.getSelectionParameters() )
                                     .dateFormat( mapping.getDateFormat() )
+                                    .numberFormat( mapping.getNumberFormat() )
                                     .existingVariableNames( existingVariableNames )
                                     .dependsOn( mapping.getDependsOn() )
                                     .defaultValue( mapping.getDefaultValue() )
@@ -416,6 +417,7 @@ private void applyPropertyNameBasedMapping() {
                                 .sourceReference( sourceRef )
                                 .selectionParameters( mapping != null ? mapping.getSelectionParameters() : null )
                                 .dateFormat( mapping != null ? mapping.getDateFormat() : null )
+                                .numberFormat( mapping != null ? mapping.getNumberFormat() : null )
                                 .defaultValue( mapping != null ? mapping.getDefaultValue() : null )
                                 .existingVariableNames( existingVariableNames )
                                 .dependsOn( mapping != null ? mapping.getDependsOn() : Collections.<String>emptyList() )
@@ -480,6 +482,7 @@ private void applyParameterNameBasedMapping() {
                             .sourceReference( sourceRef )
                             .selectionParameters( mapping != null ? mapping.getSelectionParameters() : null )
                             .dateFormat( mapping != null ? mapping.getDateFormat() : null )
+                            .numberFormat( mapping != null ? mapping.getNumberFormat() : null )
                             .existingVariableNames( existingVariableNames )
                             .dependsOn( mapping != null ? mapping.getDependsOn() : Collections.<String>emptyList() )
                             .build();

File: processor/src/main/java/org/mapstruct/ap/internal/model/MapMappingMethod.java
Patch:
@@ -51,6 +51,7 @@ public class MapMappingMethod extends MappingMethod {
     public static class Builder {
 
         private String keyDateFormat;
+        private String keyNumberFormat;
         private String valueDateFormat;
         private Method method;
         private MappingBuilderContext ctx;

File: processor/src/main/java/org/mapstruct/ap/internal/model/MappingBuilderContext.java
Patch:
@@ -91,6 +91,7 @@ public interface MappingResolver {
          * <li>null, no assignment found</li>
          * </ol>
          */
+        @SuppressWarnings("checkstyle:parameternumber")
         Assignment getTargetAssignment(Method mappingMethod, String mappedElement, Type sourceType, Type targetType,
                                        String targetPropertyName, String dateFormat,
                                        SelectionParameters selectionParameters, String sourceReference,

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/ConversionContext.java
Patch:
@@ -43,6 +43,8 @@ public interface ConversionContext {
      */
     String getDateFormat();
 
+    String getNumberFormat();
+
     TypeFactory getTypeFactory();
 
 }

File: processor/src/test/java/org/mapstruct/ap/internal/model/common/DefaultConversionContextTest.java
Patch:
@@ -78,7 +78,7 @@ public void testInvalidDateFormatValidation() {
         Type type = typeWithFQN( JavaTimeConstants.ZONED_DATE_TIME_FQN );
         StatefulMessagerMock statefulMessagerMock = new StatefulMessagerMock();
         new DefaultConversionContext(
-                        null, statefulMessagerMock, type, type, "qwertz" );
+                        null, statefulMessagerMock, type, type, "qwertz", null);
         assertThat( statefulMessagerMock.getLastKindPrinted() ).isEqualTo( Diagnostic.Kind.ERROR );
     }
 
@@ -87,7 +87,7 @@ public void testNullDateFormatValidation() {
         Type type = typeWithFQN( JavaTimeConstants.ZONED_DATE_TIME_FQN );
         StatefulMessagerMock statefulMessagerMock = new StatefulMessagerMock();
         new DefaultConversionContext(
-                        null, statefulMessagerMock, type, type, null );
+                        null, statefulMessagerMock, type, type, null, null);
         assertThat( statefulMessagerMock.getLastKindPrinted() ).isNull();
     }
 
@@ -96,7 +96,7 @@ public void testUnsupportedType() {
         Type type = typeWithFQN( "java.lang.String" );
         StatefulMessagerMock statefulMessagerMock = new StatefulMessagerMock();
         new DefaultConversionContext(
-                        null, statefulMessagerMock, type, type, "qwertz" );
+                        null, statefulMessagerMock, type, type, "qwertz", null);
         assertThat( statefulMessagerMock.getLastKindPrinted() ).isNull();
     }
 

File: core-common/src/main/java/org/mapstruct/DecoratedWith.java
Patch:
@@ -38,7 +38,6 @@
  * <p>
  * <b>NOTE:</b> The decorator feature when used with component model {@code jsr330} is considered <em>experimental</em>
  * and it may change in future releases.
- * <p>
  * <h2>Examples</h2>
  * <p>
  * For the examples below, consider the following mapper declaration:

File: core-common/src/main/java/org/mapstruct/Named.java
Patch:
@@ -96,6 +96,8 @@
 
     /**
      * A name qualifying the annotated element
+     *
+     * @return the name.
      */
     String value();
 }

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -522,7 +522,7 @@ private Assignment forgeMapOrIterableMapping(Type sourceType, Type targetType, S
             name = Strings.getSaveVariableName( name, ctx.getNamesOfMappingsToGenerate() );
 
             if ( ( sourceType.isCollectionType() || sourceType.isArrayType() )
-                && ( targetType.isCollectionType() || targetType.isArrayType() ) ) {
+                && ( targetType.isIterableType() ) ) {
 
                 // copy mapper configuration from the source method, its the same mapper
                 MapperConfiguration config = method.getMapperConfiguration();

File: processor/src/main/java/org/mapstruct/ap/internal/model/Mapper.java
Patch:
@@ -193,8 +193,6 @@ public void removeDecorator() {
 
     /**
      * Checks if the mapper has a custom implementation that is a custom suffix of an explicit destination package.
-     *
-     * @return
      */
     public boolean hasCustomImplementation() {
         return customImplName || customPackage;

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/selector/CreateOrUpdateSelector.java
Patch:
@@ -46,7 +46,6 @@ public <T extends Method> List<T> getMatchingMethods(Method mappingMethod, List<
                                                          Type sourceType, Type targetType,
                                                          SelectionCriteria criteria) {
 
-        boolean isCreateMethod = mappingMethod.getMappingTargetParameter() == null;
         List<T> createCandidates = new ArrayList<T>();
         List<T> updateCandidates = new ArrayList<T>();
         for ( T method : methods ) {

File: processor/src/main/java/org/mapstruct/ap/internal/util/TypeHierarchyErroneousException.java
Patch:
@@ -27,6 +27,7 @@
  *
  */
 public class TypeHierarchyErroneousException extends RuntimeException {
+    private static final long serialVersionUID = 1L;
 
     private TypeElement element;
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/Decorator.java
Patch:
@@ -171,7 +171,7 @@ private Decorator(TypeFactory typeFactory, String packageName, String name, Type
     @Override
     public SortedSet<Type> getImportTypes() {
         SortedSet<Type> importTypes = super.getImportTypes();
-        addWithDependents( importTypes, decoratorType );
+        addIfImportRequired( importTypes, decoratorType );
         return importTypes;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/IterableMappingMethod.java
Patch:
@@ -194,7 +194,6 @@ public Set<Type> getImportTypes() {
             types.addAll( elementAssignment.getImportTypes() );
         }
         if ( ( factoryMethod == null ) && ( !isExistingInstanceMapping() ) ) {
-            types.addAll( getReturnType().getImportTypes() );
             if ( getReturnType().getImplementationType() != null ) {
                 types.addAll( getReturnType().getImplementationType().getImportTypes() );
             }

File: core-common/src/main/java/org/mapstruct/MapMapping.java
Patch:
@@ -93,9 +93,9 @@
     Class<? extends Annotation>[] valueQualifiedBy() default { };
 
     /**
-     * String-based form of qualifiers; When looking for a suitable mapping method to map this map mapping method's value
-     * type, MapStruct will only consider those methods carrying directly or indirectly (i.e. on the class-level) a
-     * {@link Named} annotation for each of the specified qualifier names.
+     * String-based form of qualifiers; When looking for a suitable mapping method to map this map mapping method's
+     * value type, MapStruct will only consider those methods carrying directly or indirectly (i.e. on the class-level)
+     * a {@link Named} annotation for each of the specified qualifier names.
      * <p>
      * Note that annotation-based qualifiers are generally preferable as they allow more easily to find references and
      * are safe for refactorings, but name-based qualifiers can be a less verbose alternative when requiring a large

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -33,7 +33,7 @@
 import java.util.Set;
 
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 
@@ -407,8 +407,7 @@ private void applyPropertyNameBasedMapping() {
                         ExecutableElement sourceAccessor = getSourceAccessor( targetProperty.getKey(), candidates );
                         if ( sourceAccessor != null ) {
                             Mapping mapping = method.getSingleMappingByTargetPropertyName( targetProperty.getKey() );
-
-                            TypeElement sourceType = sourceParameter.getType().getTypeElement();
+                            DeclaredType sourceType = (DeclaredType) sourceParameter.getType().getTypeMirror();
 
                             SourceReference sourceRef = new SourceReference.BuilderFromProperty()
                                 .sourceParameter( sourceParameter )

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -544,8 +544,8 @@ private boolean isPropertyMappable(Type sourceType, Type targetType) {
          */
         private boolean hasCompatibleCopyConstructor(Type sourceType, Type targetType) {
             if ( targetType.isPrimitive() ) {
-				return false;
-			}
+                return false;
+            }
 
             List<ExecutableElement> targetTypeConstructors = ElementFilter.constructorsIn(
                 targetType.getTypeElement().getEnclosedElements() );

File: processor/src/main/java/org/mapstruct/ap/internal/model/Decorator.java
Patch:
@@ -131,7 +131,7 @@ public Decorator build() {
                 elementPackage,
                 mapperElement.getKind() == ElementKind.INTERFACE ? mapperElement.getSimpleName().toString() : null,
                 methods,
-                Arrays.asList(  new Field( typeFactory.getType( mapperElement ), "delegate", true ) ) ,
+                Arrays.asList( new Field( typeFactory.getType( mapperElement ), "delegate", true ) ),
                 options,
                 versionInformation,
                 Accessibility.fromModifiers( mapperElement.getModifiers() ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/NestedPropertyMappingMethod.java
Patch:
@@ -63,7 +63,7 @@ public NestedPropertyMappingMethod build() {
             }
             List<SafePropertyEntry> safePropertyEntries = new ArrayList<SafePropertyEntry>();
             for ( PropertyEntry propertyEntry : propertyEntries ) {
-                String safeName = Strings.getSaveVariableName( propertyEntry.getName(), existingVariableNames);
+                String safeName = Strings.getSaveVariableName( propertyEntry.getName(), existingVariableNames );
                 safePropertyEntries.add( new SafePropertyEntry( propertyEntry, safeName ) );
                 existingVariableNames.add( safeName );
             }

File: processor/src/main/java/org/mapstruct/ap/internal/model/assignment/Assignment.java
Patch:
@@ -30,7 +30,7 @@
  */
 public interface Assignment {
 
-    public static enum AssignmentType {
+    enum AssignmentType {
         /** assignment is direct */
         DIRECT,
         /** assignment is type converted */

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Accessibility.java
Patch:
@@ -32,7 +32,7 @@ public enum Accessibility {
 
     private final String keyword;
 
-    private Accessibility(String keyword) {
+    Accessibility(String keyword) {
         this.keyword = keyword;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/dependency/Node.java
Patch:
@@ -44,7 +44,7 @@ class Node {
      */
     private final Set<String> allDescendants;
 
-    public Node(String name) {
+    Node(String name) {
         this.name = name;
         descendants = new ArrayList<Node>();
         allDescendants = new HashSet<String>();

File: processor/src/main/java/org/mapstruct/ap/internal/option/ReportingPolicy.java
Patch:
@@ -37,7 +37,7 @@ public enum ReportingPolicy {
     private final boolean requiresReport;
     private final boolean failsBuild;
 
-    private ReportingPolicy(Diagnostic.Kind diagnosticKind, boolean requiresReport, boolean failsBuild) {
+    ReportingPolicy(Diagnostic.Kind diagnosticKind, boolean requiresReport, boolean failsBuild) {
         this.requiresReport = requiresReport;
         this.diagnosticKind = diagnosticKind;
         this.failsBuild = failsBuild;

File: processor/src/main/java/org/mapstruct/ap/internal/writer/FreeMarkerModelElementWriter.java
Patch:
@@ -59,7 +59,7 @@ private static class ExternalParamsTemplateModel implements TemplateHashModel {
         private final BeanModel object;
         private final SimpleMapModel extParams;
 
-        public ExternalParamsTemplateModel(BeanModel object, SimpleMapModel extParams) {
+        ExternalParamsTemplateModel(BeanModel object, SimpleMapModel extParams) {
             this.object = object;
             this.extParams = extParams;
         }

File: processor/src/test/java/org/mapstruct/ap/test/array/ArrayMappingTest.java
Patch:
@@ -46,7 +46,7 @@ public void shouldCopyArraysInBean() {
 
         assertThat( dto ).isNotNull();
         assertThat( dto ).isNotEqualTo( source );
-        assertThat( dto.getPublications() ).containsOnly( "the Lancet", "Nature");
+        assertThat( dto.getPublications() ).containsOnly( "the Lancet", "Nature" );
     }
 
     @Test

File: processor/src/test/java/org/mapstruct/ap/test/callbacks/ongeneratedmethods/MappingResultPostprocessorTest.java
Patch:
@@ -52,7 +52,7 @@ public void test() {
 
         // setup
         Address address = new Address();
-        address.setAddressLine( "RoadToNowhere;5");
+        address.setAddressLine( "RoadToNowhere;5" );
         address.setTown( "SmallTown" );
         Employee employee = new Employee();
         employee.setAddress( address );

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/CollectionMappingTest.java
Patch:
@@ -51,7 +51,7 @@ public class CollectionMappingTest {
     public void shouldForgeNewIterableMappingMethod() {
 
         Source source = new Source();
-        source.setFooSet( Collections.asSet( "1", "2") );
+        source.setFooSet( Collections.asSet( "1", "2" ) );
 
         Target target = CollectionMapper.INSTANCE.sourceToTarget( source );
         assertThat( target ).isNotNull();

File: processor/src/test/java/org/mapstruct/ap/test/nestedmethodcall/NestedMappingMethodInvocationTest.java
Patch:
@@ -106,7 +106,7 @@ public void shouldMapViaConversionAndMethod() throws DatatypeConfigurationExcept
 
         assertThat( source ).isNotNull();
         assertThat( source.getDate().getValue() ).isEqualTo( "06.07.2013" );
-        assertThat( source.getDate().getName()).isEqualTo( QNAME );
+        assertThat( source.getDate().getName() ).isEqualTo( QNAME );
     }
 
     private OrderType createOrderType() throws DatatypeConfigurationException {

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/QualifierTest.java
Patch:
@@ -100,7 +100,7 @@ public void shouldMatchClassAndMethod() {
         assertThat( germanMovies.getFacts() ).includes(
                 entry( "Regisseur", Arrays.asList( "M. Night Shyamalan" ) ),
                 entry( "Besetzung", Arrays.asList( "Bruce Willis", "Haley Joel Osment", "Toni Collette" ) ),
-                entry( "Handlungstichwrter", Arrays.asList( "Jungen", "Kinderpsychologe", "Ich sehe tote Menschen" ) )
+            entry( "Handlungstichwrter", Arrays.asList( "Jungen", "Kinderpsychologe", "Ich sehe tote Menschen" ) )
         );
     }
 
@@ -139,7 +139,7 @@ public void shouldNotUseQualifierAnnotatedMethod() {
 
         GermanRelease result = MapperWithoutQualifiedBy.INSTANCE.map( foreignMovies );
         assertThat( result ).isNotNull();
-        assertThat( result.getTitle() ).isEqualTo( "ehT ,esneS htxiS");
+        assertThat( result.getTitle() ).isEqualTo( "ehT ,esneS htxiS" );
 
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/source/expressions/java/JavaExpressionTest.java
Patch:
@@ -60,7 +60,7 @@ public void testJavaExpressionInsertion() throws ParseException {
     @Test
     @WithClasses({
         Source.class,
-        Source2.class ,
+        Source2.class,
         Target.class,
         TimeAndFormat.class,
         SourceTargetMapperSeveralSources.class

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/UpdateMethodsTest.java
Patch:
@@ -76,7 +76,7 @@ public void testPreferUpdateMethod() {
         assertThat( organizationEntity.getCompany() ).isEqualTo( companyEntity );
         assertThat( organizationEntity.getCompany().getName() ).isEqualTo( "PepsiCo" );
         assertThat( organizationEntity.getType().getType() ).isEqualTo( "commercial" );
-        assertThat( organizationEntity.getTypeNr().getNumber()).isEqualTo( 5 );
+        assertThat( organizationEntity.getTypeNr().getNumber() ).isEqualTo( 5 );
         assertThat( organizationEntity.getCompany().getDepartment().getName() ).isEqualTo( "finance" );
     }
 
@@ -124,7 +124,7 @@ public void testPreferUpdateMethodSourceObjectNotDefined() {
 
         assertThat( organizationEntity.getCompany().getName() ).isEqualTo( "PepsiCo" );
         assertThat( organizationEntity.getType().getType() ).isEqualTo( "commercial" );
-        assertThat( organizationEntity.getTypeNr().getNumber()).isEqualTo( 5 );
+        assertThat( organizationEntity.getTypeNr().getNumber() ).isEqualTo( 5 );
         assertThat( organizationEntity.getCompany().getDepartment().getName() ).isEqualTo( "finance" );
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/updatemethods/selection/ExternalHandWrittenMapper.java
Patch:
@@ -57,7 +57,8 @@ public void toSecretaryEmployeeEntityMap(Map<SecretaryDto, EmployeeDto> dtoMap,
 
         if ( entityMap != null && dtoMap != null ) {
             for ( Map.Entry<SecretaryDto, EmployeeDto> dtoEntry : dtoMap.entrySet() ) {
-                entityMap.put( DepartmentMapper.INSTANCE.toSecretaryEntity( dtoEntry.getKey() ) ,
+                entityMap.put(
+                    DepartmentMapper.INSTANCE.toSecretaryEntity( dtoEntry.getKey() ),
                     DepartmentMapper.INSTANCE.toEmployeeEntity( dtoEntry.getValue() )  );
             }
         }

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/ModifiableURLClassLoader.java
Patch:
@@ -98,7 +98,7 @@ private static void tryRegisterAsParallelCapable() {
     private static final class FilteringParentClassLoader extends ClassLoader {
         private String excludedPackage;
 
-        public FilteringParentClassLoader(String excludedPackage) {
+        FilteringParentClassLoader(String excludedPackage) {
             this.excludedPackage = excludedPackage;
         }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/SourceReference.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.mapstruct.ap.internal.model.source;
 
+import static org.mapstruct.ap.internal.util.Collections.first;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -32,8 +34,6 @@
 import org.mapstruct.ap.internal.util.Message;
 import org.mapstruct.ap.internal.util.Strings;
 
-import static org.mapstruct.ap.internal.util.Collections.first;
-
 /**
  * This class describes the source side of a property mapping.
  * <p>
@@ -176,7 +176,7 @@ private List<PropertyEntry> getSourceEntries(Type type, String[] entryNames) {
                 Map<String, ExecutableElement> sourceReadAccessors = newType.getPropertyReadAccessors();
                 for (  Map.Entry<String, ExecutableElement> getter : sourceReadAccessors.entrySet() ) {
                     if ( getter.getKey().equals( entryName ) ) {
-                        newType = typeFactory.getType( getter.getValue().getReturnType() );
+                        newType = typeFactory.getReturnType( newType.getTypeElement(), getter.getValue() );
                         sourceEntries.add( new PropertyEntry( entryName, getter.getValue(), newType ) );
                         matchFound = true;
                         break;

File: processor/src/main/java/org/mapstruct/ap/internal/processor/creation/MappingResolverImpl.java
Patch:
@@ -47,7 +47,6 @@
 import org.mapstruct.ap.internal.model.source.selector.SelectionCriteria;
 import org.mapstruct.ap.internal.util.FormattingMessager;
 import org.mapstruct.ap.internal.util.Message;
-import org.mapstruct.ap.internal.util.SpecificCompilerWorkarounds;
 import org.mapstruct.ap.internal.util.Strings;
 
 /**
@@ -559,7 +558,7 @@ private boolean collectionTypeHasCompatibleConstructor(Type sourceType, Type tar
                 ? typeFactory.getType( Object.class ).getTypeMirror()
                 : targetType.getTypeParameters().get( 0 ).getTypeMirror();
 
-            return SpecificCompilerWorkarounds.isAssignable( typeUtils, sourceElementType, targetElementType );
+            return typeUtils.isAssignable( sourceElementType, targetElementType );
         }
 
         /**

File: processor/src/main/java/org/mapstruct/ap/internal/util/Executables.java
Patch:
@@ -38,7 +38,7 @@
 import org.mapstruct.ap.spi.MethodType;
 
 import static javax.lang.model.util.ElementFilter.methodsIn;
-import static org.mapstruct.ap.internal.util.SpecificCompilerWorkarounds.replaceTypeElementIfNecessary;
+import static org.mapstruct.ap.internal.util.workarounds.SpecificCompilerWorkarounds.replaceTypeElementIfNecessary;
 
 /**
  * Provides functionality around {@link ExecutableElement}s.

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/AnnotationProcessorTestRunner.java
Patch:
@@ -33,7 +33,7 @@
 /**
  * A JUnit4 runner for Annotation Processor tests.
  * <p>
- * Test classes are safe to be executed in parallel, the methods must not executed in parallel.
+ * Test classes are safe to be executed in parallel, but test methods are not safe to be executed in parallel.
  * <p>
  * The classes to be compiled for a given test method must be specified via {@link WithClasses}. In addition the
  * following things can be configured optionally :

File: processor/src/test/java/org/mapstruct/ap/testutil/runner/EclipseCompilingStatement.java
Patch:
@@ -30,7 +30,7 @@
 import org.mapstruct.ap.testutil.compilation.model.CompilationOutcomeDescriptor;
 
 /**
- * Statement that uses the JDK compiler to compile.
+ * Statement that uses the Eclipse JDT compiler to compile.
  *
  * @author Andreas Gudian
  */

File: processor/src/test/java/org/mapstruct/ap/test/conversion/jodatime/JodaConversionTest.java
Patch:
@@ -57,7 +57,7 @@ public void testDateTimeToString() {
         src.setDateTime( new DateTime( 2014, 1, 1, 0, 0, 0, DateTimeZone.UTC ) );
         Target target = SourceTargetMapper.INSTANCE.sourceToTargetDateTimeMapped( src );
         assertThat( target ).isNotNull();
-        assertThat( target.getDateTime() ).isIn( "01.01.2014 00:00 UTC", "01.01.2014 00:00 +00:00" );
+        assertThat( target.getDateTime() ).isEqualTo( "01.01.2014 00:00 UTC" );
     }
 
     @Test
@@ -99,15 +99,15 @@ public void testSourceToTargetMappingForStrings() {
         Target target = SourceTargetMapper.INSTANCE.sourceToTarget( src );
 
         assertThat( target ).isNotNull();
-        assertThat( target.getDateTime() ).isIn( "01.01.2014 00:00 UTC", "01.01.2014 00:00 +00:00" );
+        assertThat( target.getDateTime() ).isEqualTo( "01.01.2014 00:00 UTC" );
         assertThat( target.getLocalDateTime() ).isEqualTo( "01.01.2014 00:00" );
         assertThat( target.getLocalDate() ).isEqualTo( "01.01.2014" );
         assertThat( target.getLocalTime() ).isEqualTo( "00:00" );
 
         // and now with default mappings
         target = SourceTargetMapper.INSTANCE.sourceToTargetDefaultMapping( src );
         assertThat( target ).isNotNull();
-        assertThat( target.getDateTime() ).isIn( "1. Januar 2014 00:00:00 UTC", "1. Januar 2014 00:00:00 +00:00" );
+        assertThat( target.getDateTime() ).isEqualTo( "1. Januar 2014 00:00:00 UTC" );
         assertThat( target.getLocalDateTime() ).isEqualTo( "1. Januar 2014 00:00:00" );
         assertThat( target.getLocalDate() ).isEqualTo( "1. Januar 2014" );
         assertThat( target.getLocalTime() ).isEqualTo( "00:00:00" );

File: processor/src/test/java/org/mapstruct/ap/test/conversion/jodatime/JodaConversionTest.java
Patch:
@@ -57,7 +57,7 @@ public void testDateTimeToString() {
         src.setDateTime( new DateTime( 2014, 1, 1, 0, 0, 0, DateTimeZone.UTC ) );
         Target target = SourceTargetMapper.INSTANCE.sourceToTargetDateTimeMapped( src );
         assertThat( target ).isNotNull();
-        assertThat( target.getDateTime() ).isEqualTo( "01.01.2014 00:00 UTC" );
+        assertThat( target.getDateTime() ).isIn( "01.01.2014 00:00 UTC", "01.01.2014 00:00 +00:00" );
     }
 
     @Test
@@ -99,15 +99,15 @@ public void testSourceToTargetMappingForStrings() {
         Target target = SourceTargetMapper.INSTANCE.sourceToTarget( src );
 
         assertThat( target ).isNotNull();
-        assertThat( target.getDateTime() ).isEqualTo( "01.01.2014 00:00 UTC" );
+        assertThat( target.getDateTime() ).isIn( "01.01.2014 00:00 UTC", "01.01.2014 00:00 +00:00" );
         assertThat( target.getLocalDateTime() ).isEqualTo( "01.01.2014 00:00" );
         assertThat( target.getLocalDate() ).isEqualTo( "01.01.2014" );
         assertThat( target.getLocalTime() ).isEqualTo( "00:00" );
 
         // and now with default mappings
         target = SourceTargetMapper.INSTANCE.sourceToTargetDefaultMapping( src );
         assertThat( target ).isNotNull();
-        assertThat( target.getDateTime() ).isEqualTo( "1. Januar 2014 00:00:00 UTC" );
+        assertThat( target.getDateTime() ).isIn( "1. Januar 2014 00:00:00 UTC", "1. Januar 2014 00:00:00 +00:00" );
         assertThat( target.getLocalDateTime() ).isEqualTo( "1. Januar 2014 00:00:00" );
         assertThat( target.getLocalDate() ).isEqualTo( "1. Januar 2014" );
         assertThat( target.getLocalTime() ).isEqualTo( "00:00:00" );

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/ForgedMethod.java
Patch:
@@ -198,7 +198,7 @@ public boolean isDefault() {
     }
 
     @Override
-    public Type getStaticMethodFromInterfaceType() {
+    public Type getDefiningType() {
         return null;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/Method.java
Patch:
@@ -152,11 +152,10 @@ public interface Method {
     boolean isDefault();
 
     /**
-     * Returns method's enclosing type if method is Java 8 static method
      *
-     * @return type of static method from Java 8 interface
+     *  @return the Type (class or interface) that defines this method.
      */
-    Type getStaticMethodFromInterfaceType();
+    Type getDefiningType();
 
     /**
      *

File: processor/src/main/java/org/mapstruct/ap/internal/model/source/builtin/BuiltInMethod.java
Patch:
@@ -245,7 +245,7 @@ public boolean isDefault() {
     }
 
     @Override
-    public Type getStaticMethodFromInterfaceType() {
+    public Type getDefiningType() {
         return null;
     }
 

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MapperCreationProcessor.java
Patch:
@@ -187,7 +187,7 @@ private Decorator getDecorator(TypeElement element, List<SourceMethod> methods,
                 }
             }
             Type declaringMapper = mappingMethod.getDeclaringMapper();
-            if ( implementationRequired ) {
+            if ( implementationRequired && !( mappingMethod.isDefault() || mappingMethod.isStatic()) ) {
                 if ( ( declaringMapper == null ) || declaringMapper.equals( typeFactory.getType( element ) ) ) {
                     mappingMethods.add( new DelegatingMethod( mappingMethod ) );
                 }

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -74,7 +74,7 @@ public enum Message {
 
     GENERAL_NO_IMPLEMENTATION( "No implementation type is registered for return type %s." ),
     GENERAL_AMBIGIOUS_MAPPING_METHOD( "Ambiguous mapping methods found for mapping %s to %s: %s." ),
-    GENERAL_AMBIGIOUS_FACTORY_METHOD( "Ambiguous mapping methods found for factorizing %s: %s." ),
+    GENERAL_AMBIGIOUS_FACTORY_METHOD( "Ambiguous factory methods found for creating %s: %s." ),
     GENERAL_UNSUPPORTED_DATE_FORMAT_CHECK( "No dateFormat check is supported for types %s, %s" ),
     GENERAL_VALID_DATE( "Given date format \"%s\" is valid.", Diagnostic.Kind.NOTE ),
     GENERAL_INVALID_DATE( "Given date format \"%s\" is invalid. Message: \"%s\"." ),

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousfactorymethod/FactoryTest.java
Patch:
@@ -47,7 +47,7 @@ public class FactoryTest {
             @Diagnostic(type = SourceTargetMapperAndBarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 35,
-                messageRegExp = "Ambiguous mapping methods found for factorizing "
+                messageRegExp = "Ambiguous factory methods found for creating "
                         + "org.mapstruct.ap.test.erroneous.ambiguousfactorymethod.Bar: "
                         + "org.mapstruct.ap.test.erroneous.ambiguousfactorymethod.Bar createBar\\(\\), "
                         + "org.mapstruct.ap.test.erroneous.ambiguousfactorymethod.Bar .*BarFactory.createBar\\(\\)." )

File: integrationtest/src/test/resources/cdiTest/src/main/java/org/mapstruct/itest/cdi/DecoratedSourceTargetMapper.java
Patch:
@@ -26,4 +26,6 @@
 public interface DecoratedSourceTargetMapper {
 
     Target sourceToTarget(Source source);
+
+    Target undecoratedSourceToTarget(Source source);
 }

File: integrationtest/src/test/resources/springTest/src/main/java/org/mapstruct/itest/spring/DecoratedSourceTargetMapper.java
Patch:
@@ -27,4 +27,6 @@
 public interface DecoratedSourceTargetMapper {
 
     Target sourceToTarget(Source source);
+
+    Target undecoratedSourceToTarget(Source source);
 }

File: processor/src/main/java/org/mapstruct/ap/internal/processor/CdiComponentProcessor.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.mapstruct.ap.internal.processor;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -46,8 +47,8 @@ protected List<Annotation> getTypeAnnotations(Mapper mapper) {
     }
 
     @Override
-    protected Annotation getMapperReferenceAnnotation() {
-        return new Annotation( getTypeFactory().getType( "javax.inject.Inject" ) );
+    protected List<Annotation> getMapperReferenceAnnotations() {
+        return Arrays.asList( new Annotation( getTypeFactory().getType( "javax.inject.Inject" ) ) );
     }
 
     @Override

File: core-common/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -96,8 +96,8 @@
     String implementationName() default "<CLASS_NAME>Impl";
 
     /**
-     * Specifies the target package for the generated implementation. The {@code <CLASS_NAME>} will be replaced
-     * by the interface's or abstract class' package.
+     * Specifies the target package for the generated implementation. The {@code <PACKAGE_NAME>} will be replaced by the
+     * interface's or abstract class' package.
      * <p>
      * Defaults to using the same package as the mapper interface/abstract class
      *

File: core-common/src/main/java/org/mapstruct/MapperConfig.java
Patch:
@@ -96,8 +96,8 @@
     String implementationName() default "<CLASS_NAME>Impl";
 
     /**
-     * Specifies the target package for the generated implementation. The {@code <CLASS_NAME>} will be replaced
-     * by the interface's or abstract class' package.
+     * Specifies the target package for the generated implementation. The {@code <PACKAGE_NAME>} will be replaced by the
+     * interface's or abstract class' package.
      * <p>
      * Defaults to using the same package as the mapper interface/abstract class
      *

File: core-common/src/test/java/org/mapstruct/factory/MappersTest.java
Patch:
@@ -16,12 +16,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct;
+package org.mapstruct.factory;
 
 import static org.fest.assertions.Assertions.assertThat;
 
 import org.junit.Test;
-import org.mapstruct.factory.Mappers;
 import org.mapstruct.test.model.Foo;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/internal/writer/ModelWriter.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import javax.tools.JavaFileObject;
+import javax.tools.FileObject;
 
 import org.mapstruct.ap.internal.writer.Writable.Context;
 
@@ -74,7 +74,7 @@ public class ModelWriter {
         CONFIGURATION.setLocalizedLookup( false );
     }
 
-    public void writeModel(JavaFileObject sourceFile, Writable model) {
+    public void writeModel(FileObject sourceFile, Writable model) {
         try {
             BufferedWriter writer = new BufferedWriter( new IndentationCorrectingWriter( sourceFile.openWriter() ) );
 

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper1.java
Patch:
@@ -33,6 +33,7 @@ public interface ErroneousMapper1 {
 
     @Mappings({
         @Mapping(target = "stringConstant", constant = "stringConstant"),
+        @Mapping(target = "emptyStringConstant", constant = ""),
         @Mapping(source = "test", target = "integerConstant", constant = "14"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper3.java
Patch:
@@ -33,6 +33,7 @@ public interface ErroneousMapper3 {
 
     @Mappings({
         @Mapping(target = "stringConstant", constant = "stringConstant"),
+        @Mapping(target = "emptyStringConstant", constant = ""),
         @Mapping(target = "integerConstant", expression = "java('test')", constant = "14"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/ErroneousMapper4.java
Patch:
@@ -33,6 +33,7 @@ public interface ErroneousMapper4 {
 
     @Mappings({
         @Mapping(target = "stringConstant", constant = "stringConstant"),
+        @Mapping(target = "emptyStringConstant", constant = ""),
         @Mapping(source = "test", target = "integerConstant", expression = "java('test')"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/SourceTargetMapper.java
Patch:
@@ -33,6 +33,7 @@ public interface SourceTargetMapper {
 
     @Mappings({
         @Mapping(target = "stringConstant", constant = "stringConstant"),
+        @Mapping(target = "emptyStringConstant", constant = ""),
         @Mapping(target = "integerConstant", constant = "14"),
         @Mapping(target = "longWrapperConstant", constant = "3001"),
         @Mapping(target = "dateConstant", dateFormat = "dd-MM-yyyy", constant = "09-01-2014"),

File: core-common/src/main/java/org/mapstruct/BeanMapping.java
Patch:
@@ -61,5 +61,5 @@
      *
      * @return The strategy to be applied when {@code null} is passed as source value to the methods of this mapping.
      */
-    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.DEFAULT;
+    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
 }

File: core-common/src/main/java/org/mapstruct/IterableMapping.java
Patch:
@@ -73,5 +73,5 @@
      *
      * @return The strategy to be applied when {@code null} is passed as source value to the methods of this mapping.
      */
-    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.DEFAULT;
+    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
 }

File: core-common/src/main/java/org/mapstruct/MapMapping.java
Patch:
@@ -104,5 +104,5 @@
      *
      * @return The strategy to be applied when {@code null} is passed as source value to the methods of this mapping.
      */
-    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.DEFAULT;
+    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
 }

File: processor/src/main/java/org/mapstruct/ap/internal/option/ReportingPolicy.java
Patch:
@@ -31,8 +31,7 @@ public enum ReportingPolicy {
 
     IGNORE( null, false, false ),
     WARN( Kind.WARNING, true, false ),
-    ERROR( Kind.ERROR, true, true ),
-    DEFAULT( Kind.WARNING, true, false );
+    ERROR( Kind.ERROR, true, true );
 
     private final Diagnostic.Kind diagnosticKind;
     private final boolean requiresReport;

File: processor/src/main/java/org/mapstruct/ap/internal/prism/CollectionMappingStrategyPrism.java
Patch:
@@ -27,6 +27,5 @@ public enum CollectionMappingStrategyPrism {
 
     ACCESSOR_ONLY,
     SETTER_PREFERRED,
-    ADDER_PREFERRED,
-    DEFAULT;
+    ADDER_PREFERRED;
 }

File: processor/src/main/java/org/mapstruct/ap/internal/prism/MappingInheritanceStrategyPrism.java
Patch:
@@ -26,6 +26,5 @@
  */
 public enum MappingInheritanceStrategyPrism {
     EXPLICIT,
-    AUTO_INHERIT_FROM_CONFIG,
-    DEFAULT;
+    AUTO_INHERIT_FROM_CONFIG;
 }

File: processor/src/main/java/org/mapstruct/ap/internal/prism/NullValueMappingStrategyPrism.java
Patch:
@@ -26,6 +26,5 @@
 public enum NullValueMappingStrategyPrism {
 
     RETURN_NULL,
-    RETURN_DEFAULT,
-    DEFAULT;
+    RETURN_DEFAULT;
 }

File: processor/src/test/java/org/mapstruct/ap/test/nullvaluemapping/CarMapperSettingOnConfig.java
Patch:
@@ -21,9 +21,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+
 import org.mapstruct.IterableMapping;
 import org.mapstruct.MapMapping;
-
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
@@ -45,7 +45,7 @@ public interface CarMapperSettingOnConfig {
     CarDto carToCarDto(Car car);
 
 
-    @IterableMapping(nullValueMappingStrategy = NullValueMappingStrategy.DEFAULT, dateFormat = "dummy")
+    @IterableMapping(dateFormat = "dummy")
     List<CarDto> carsToCarDtos(List<Car> cars);
 
 

File: processor/src/main/java/org/mapstruct/ap/internal/model/BeanMappingMethod.java
Patch:
@@ -302,6 +302,7 @@ else if ( mapping.getSourceName() != null ) {
                                     .dateFormat( mapping.getDateFormat() )
                                     .existingVariableNames( existingVariableNames )
                                     .dependsOn( mapping.getDependsOn() )
+                                    .defaultValue( mapping.getDefaultValue() )
                                     .build();
                                 handledTargets.add( mapping.getTargetName() );
                                 unprocessedSourceParameters.remove( sourceRef.getParameter() );
@@ -424,6 +425,7 @@ private void applyPropertyNameBasedMapping() {
                                 .qualifiers( mapping != null ? mapping.getQualifiers() : null )
                                 .resultType( mapping != null ? mapping.getResultType() : null )
                                 .dateFormat( mapping != null ? mapping.getDateFormat() : null )
+                                .defaultValue( mapping != null ? mapping.getDefaultValue() : null )
                                 .existingVariableNames( existingVariableNames )
                                 .dependsOn( mapping != null ? mapping.getDependsOn() : Collections.<String>emptyList() )
                                 .build();

File: processor/src/main/java/org/mapstruct/ap/internal/util/Message.java
Patch:
@@ -44,6 +44,8 @@ public enum Message {
     PROPERTYMAPPING_SOURCE_AND_CONSTANT_BOTH_DEFINED( "Source and constant are both defined in @Mapping, either define a source or a constant." ),
     PROPERTYMAPPING_SOURCE_AND_EXPRESSION_BOTH_DEFINED( "Source and expression are both defined in @Mapping, either define a source or an expression." ),
     PROPERTYMAPPING_EXPRESSION_AND_CONSTANT_BOTH_DEFINED( "Expression and constant are both defined in @Mapping, either define an expression or a constant." ),
+    PROPERTYMAPPING_EXPRESSION_AND_DEFAULT_VALUE_BOTH_DEFINED( "Expression and default value are both defined in @Mapping, either define a defaultValue or an expression." ),
+    PROPERTYMAPPING_CONSTANT_AND_DEFAULT_VALUE_BOTH_DEFINED( "Constant and default value are both defined in @Mapping, either define a defaultValue or a constant." ),
     PROPERTYMAPPING_INVALID_EXPRESSION( "Value must be given in the form \"java(<EXPRESSION>)\"." ),
     PROPERTYMAPPING_REVERSAL_PROBLEM( "Parameter %s cannot be reversed." ),
     PROPERTYMAPPING_INVALID_PARAMETER_NAME( "Method has no parameter named \"%s\"." ),

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -256,7 +256,7 @@ private Assignment assignObject(Type sourceType, Type targetType, TargetWriteAcc
                     Assignment factoryMethod =
                         ctx.getMappingResolver().getFactoryMethod( method, targetType, null, null );
                     result = new UpdateWrapper( result, method.getThrownTypes(), factoryMethod,
-                        targetType.getImplementationType() );
+                        targetType );
                 }
                 else {
                     result = new SetterWrapper( result, method.getThrownTypes() );
@@ -330,7 +330,7 @@ private Assignment assignCollection(Type targetType,
                     Assignment factoryMethod
                         = ctx.getMappingResolver().getFactoryMethod( method, targetType, null, null );
                     result = new UpdateWrapper( result, method.getThrownTypes(), factoryMethod,
-                        targetType.getImplementationType() );
+                        targetType );
                 }
                 else {
                     // wrap the assignment in the setter method
@@ -623,7 +623,7 @@ public PropertyMapping build() {
                         Assignment factoryMethod =
                             ctx.getMappingResolver().getFactoryMethod( method, targetType, null, null );
                         assignment = new UpdateWrapper( assignment, method.getThrownTypes(), factoryMethod,
-                            targetType.getImplementationType() );
+                            targetType );
                     }
                     else {
                         assignment = new SetterWrapper( assignment, method.getThrownTypes() );

File: processor/src/main/java/org/mapstruct/ap/internal/model/PropertyMapping.java
Patch:
@@ -47,6 +47,7 @@
 import org.mapstruct.ap.internal.util.Strings;
 
 import static org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType.DIRECT;
+import static org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType.MAPPED_TYPE_CONVERTED;
 import static org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType.TYPE_CONVERTED;
 import static org.mapstruct.ap.internal.model.assignment.Assignment.AssignmentType.TYPE_CONVERTED_MAPPED;
 
@@ -262,7 +263,8 @@ private Assignment assignObject(Type sourceType, Type targetType, TargetWriteAcc
                     && !sourceReference.getPropertyEntries().isEmpty() /* parameter null taken care of by beanmapper */
                     && ( result.getType() == TYPE_CONVERTED
                     || result.getType() == TYPE_CONVERTED_MAPPED
-                    || result.getType() == DIRECT && targetType.isPrimitive() ) ) {
+                    || result.getType() == MAPPED_TYPE_CONVERTED
+                    || ( result.getType() == DIRECT && targetType.isPrimitive() ) ) ) {
                     // for primitive types null check is not possible at all, but a conversion needs
                     // a null check.
                     result = new NullCheckWrapper( result );

File: processor/src/main/java/org/mapstruct/ap/internal/model/common/Type.java
Patch:
@@ -398,7 +398,7 @@ public Map<String, ExecutableElement> getPropertyWriteAccessors( CollectionMappi
                 // first check if there's a setter method.
                 ExecutableElement adderMethod = null;
                 if ( Executables.isSetterMethod( candidate ) ) {
-                    Type targetType = typeFactory.getSingleParameter( candidate ).getType();
+                    Type targetType = typeFactory.getSingleParameter( typeElement, candidate ).getType();
                     // ok, the current accessor is a setter. So now the strategy determines what to use
                     if ( cmStrategy == CollectionMappingStrategyPrism.ADDER_PREFERRED ) {
                         adderMethod = getAdderForType( targetType, targetPropertyName );
@@ -407,7 +407,7 @@ public Map<String, ExecutableElement> getPropertyWriteAccessors( CollectionMappi
                 else if ( Executables.isGetterMethod( candidate ) ) {
                         // the current accessor is a getter (no setter available). But still, an add method is according
                     // to the above strategy (SETTER_PREFERRED || ADDER_PREFERRED) preferred over the getter.
-                    Type targetType = typeFactory.getReturnType( candidate );
+                    Type targetType = typeFactory.getReturnType( typeFactory.getMethodType( typeElement, candidate ) );
                     adderMethod = getAdderForType( targetType, targetPropertyName );
                 }
                 if ( adderMethod != null ) {

File: processor/src/main/java/org/mapstruct/ap/internal/processor/MethodRetrievalProcessor.java
Patch:
@@ -181,7 +181,7 @@ private SourceMethod getMethod(TypeElement usedMapper,
 
         ExecutableType methodType = typeFactory.getMethodType( usedMapper, method );
         List<Parameter> parameters = typeFactory.getParameters( methodType, method );
-        Type returnType = typeFactory.getReturnType( method );
+        Type returnType = typeFactory.getReturnType( methodType );
 
         boolean methodRequiresImplementation = method.getModifiers().contains( Modifier.ABSTRACT );
         boolean containsTargetTypeParameter = SourceMethod.containsTargetTypeParameter( parameters );

File: processor/src/main/java/org/mapstruct/ap/processor/MethodRetrievalProcessor.java
Patch:
@@ -48,6 +48,7 @@
 import org.mapstruct.ap.prism.MappingPrism;
 import org.mapstruct.ap.prism.MappingsPrism;
 import org.mapstruct.ap.util.AnnotationProcessingException;
+import org.mapstruct.ap.util.Executables;
 import org.mapstruct.ap.util.FormattingMessager;
 import org.mapstruct.ap.util.MapperConfiguration;
 import org.mapstruct.ap.util.Message;
@@ -272,7 +273,7 @@ private SourceMethod getReferencedMethod(TypeElement usedMapper, ExecutableType
     }
 
     private boolean isValidLifecycleCallbackMethod(ExecutableElement method, Type returnType) {
-        return isVoid( returnType ) && SourceMethod.isLifecycleCallbackMethod( method );
+        return isVoid( returnType ) && Executables.isLifecycleCallbackMethod( method );
     }
 
     private boolean isValidReferencedMethod(List<Parameter> parameters) {

File: processor/src/main/java/org/mapstruct/ap/services/Services.java
Patch:
@@ -48,10 +48,12 @@ public static AccessorNamingStrategy getAccessorNamingStrategy() {
     }
 
     private static AccessorNamingStrategy findAccessorNamingStrategy() {
+        AccessorNamingStrategy defaultImpl = new DefaultAccessorNamingStrategy();
         AccessorNamingStrategy impl = find( AccessorNamingStrategy.class );
         if ( impl == null ) {
-            impl = new DefaultAccessorNamingStrategy();
+            impl = defaultImpl;
         }
+        impl.setDefaultAccessorNamingStrategy( defaultImpl );
         return impl;
     }
 

File: processor/src/main/java/org/mapstruct/ap/processor/creation/MappingResolverImpl.java
Patch:
@@ -47,6 +47,7 @@
 import org.mapstruct.ap.model.source.selector.SelectionCriteria;
 import org.mapstruct.ap.util.FormattingMessager;
 import org.mapstruct.ap.util.Message;
+import org.mapstruct.ap.util.SpecificCompilerWorkarounds;
 import org.mapstruct.ap.util.Strings;
 
 /**
@@ -551,7 +552,7 @@ private boolean collectionTypeHasCompatibleConstructor(Type sourceType, Type tar
                 ? typeFactory.getType( Object.class ).getTypeMirror()
                 : targetType.getTypeParameters().get( 0 ).getTypeMirror();
 
-            return typeUtils.isAssignable( sourceElementType, targetElementType );
+            return SpecificCompilerWorkarounds.isAssignable( typeUtils, sourceElementType, targetElementType );
         }
 
         /**

File: processor/src/main/java/org/mapstruct/ap/model/Direct.java
Patch:
@@ -49,7 +49,7 @@ public Set<Type> getImportTypes() {
     }
 
     @Override
-    public List<Type> getExceptionTypes() {
+    public List<Type> getThrownTypes() {
         return Collections.emptyList();
     }
 

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -123,7 +123,7 @@ public IterableMappingMethod build() {
             else {
                 if ( method instanceof ForgedMethod ) {
                     ForgedMethod forgedMethod = (ForgedMethod) method;
-                    forgedMethod.addThrownTypes( assignment.getExceptionTypes() );
+                    forgedMethod.addThrownTypes( assignment.getThrownTypes() );
                 }
             }
             // target accessor is setter, so decorate assignment as setter

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -154,10 +154,10 @@ public MapMappingMethod build() {
             if ( method instanceof ForgedMethod ) {
                 ForgedMethod forgedMethod = (ForgedMethod) method;
                 if ( keyAssignment != null ) {
-                    forgedMethod.addThrownTypes( keyAssignment.getExceptionTypes() );
+                    forgedMethod.addThrownTypes( keyAssignment.getThrownTypes() );
                 }
                 if ( valueAssignment != null ) {
-                    forgedMethod.addThrownTypes( valueAssignment.getExceptionTypes() );
+                    forgedMethod.addThrownTypes( valueAssignment.getThrownTypes() );
                 }
             }
 

File: processor/src/main/java/org/mapstruct/ap/model/assignment/Assignment.java
Patch:
@@ -57,7 +57,7 @@ public static enum AssignmentType {
      *
      * @return exceptions thrown
      */
-    List<Type> getExceptionTypes();
+     List<Type> getThrownTypes();
 
     /**
      * An assignment in itself can wrap another assignment. E.g.:

File: processor/src/main/java/org/mapstruct/ap/model/assignment/AssignmentWrapper.java
Patch:
@@ -42,8 +42,8 @@ public Set<Type> getImportTypes() {
     }
 
     @Override
-    public List<Type> getExceptionTypes() {
-        return decoratedAssignment.getExceptionTypes();
+    public List<Type> getThrownTypes() {
+        return decoratedAssignment.getThrownTypes();
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -179,6 +179,9 @@ public Set<Type> getImportTypes() {
         }
         if ( ( factoryMethod == null ) && ( !isExistingInstanceMapping() ) ) {
             types.addAll( getReturnType().getImportTypes() );
+            if ( getReturnType().getImplementationType() != null ) {
+                types.addAll( getReturnType().getImplementationType().getImportTypes() );
+            }
         }
         return types;
     }

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -217,6 +217,9 @@ public Set<Type> getImportTypes() {
         }
         if ( ( factoryMethod == null ) && ( !isExistingInstanceMapping() ) ) {
             types.addAll( getReturnType().getImportTypes() );
+            if ( getReturnType().getImplementationType() != null ) {
+                types.addAll( getReturnType().getImplementationType().getImportTypes() );
+            }
         }
 
         return types;

File: processor/src/main/java/org/mapstruct/ap/model/PropertyMapping.java
Patch:
@@ -253,7 +253,7 @@ private Assignment assignObject(Type sourceType, Type targetType, TargetWriteAcc
                     }
                     Assignment factoryMethod =
                         ctx.getMappingResolver().getFactoryMethod( method, targetType, null, null );
-                    result = new UpdateWrapper( result, method.getThrownTypes(), targetType, factoryMethod );
+                    result = new UpdateWrapper( result, method.getThrownTypes(), factoryMethod );
                 }
                 else {
                     result = new SetterWrapper( result, method.getThrownTypes() );
@@ -579,8 +579,7 @@ public PropertyMapping build() {
                         }
                         Assignment factoryMethod =
                             ctx.getMappingResolver().getFactoryMethod( method, targetType, null, null );
-                        assignment =
-                            new UpdateWrapper( assignment, method.getThrownTypes(), targetType, factoryMethod );
+                        assignment = new UpdateWrapper( assignment, method.getThrownTypes(), factoryMethod );
                     }
                     else {
                         assignment = new SetterWrapper( assignment, method.getThrownTypes() );

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -177,7 +177,7 @@ public Set<Type> getImportTypes() {
         if ( elementAssignment != null ) {
             types.addAll( elementAssignment.getImportTypes() );
         }
-        if ( factoryMethod == null ) {
+        if ( ( factoryMethod == null ) && ( !isExistingInstanceMapping() ) ) {
             types.addAll( getReturnType().getImportTypes() );
         }
         return types;

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -215,7 +215,7 @@ public Set<Type> getImportTypes() {
         if ( valueAssignment != null ) {
             types.addAll( valueAssignment.getImportTypes() );
         }
-        if ( factoryMethod == null ) {
+        if ( ( factoryMethod == null ) && ( !isExistingInstanceMapping() ) ) {
             types.addAll( getReturnType().getImportTypes() );
         }
 

File: core-common/src/main/java/org/mapstruct/InheritConfiguration.java
Patch:
@@ -35,7 +35,7 @@
  * method:
  *
  * <pre>
- * {@code
+ * <code>
  * &#64;Mappings({
  *     &#64;Mapping(target="make", source="brand"),
  *     &#64;Mapping(target="seatCount", source="numberOfSeats")
@@ -44,7 +44,7 @@
  *
  * &#64;InheritConfiguration
  * void updateCarDto(Car car, &#64;MappingTarget CarDto carDto);
- * }
+ * </code>
  * </pre>
  *
  * @author Sjaak Derksen

File: core/src/main/java/org/mapstruct/Mapping.java
Patch:
@@ -94,7 +94,6 @@
      * <p>
      * Currently, Java is the only supported "expression language" and expressions must be given in form of Java
      * expressions using the following format: {@code java(<EXPRESSION>)}. For instance the mapping
-     * <p>
      *
      * <pre>
      * {@code @Mapping(

File: processor/src/main/java/org/mapstruct/ap/conversion/AbstractJodaTypeToStringConversion.java
Patch:
@@ -110,12 +110,12 @@ private String defaultDateFormatPattern() {
     }
 
     /**
-     * Returns the default format style to be applied if non is given explicitly.
+     * @return the default format style to be applied if non is given explicitly.
      */
     protected abstract String formatStyle();
 
     /**
-     * Returns the name of the parse method for converting a String into a specific Joda-Time type.
+     * @return the name of the parse method for converting a String into a specific Joda-Time type.
      */
     protected abstract String parseMethod();
 }

File: processor/src/main/java/org/mapstruct/ap/model/BeanMappingMethod.java
Patch:
@@ -528,8 +528,6 @@ private ExecutableElement getTargetPropertyReadAccessor( String propertyName ) {
          * be returned. If that is not set either, the default value from {@code Mapper#unmappedTargetPolicy()} will be
          * returned.
          *
-         * @param element The type declaring the generated mapper type
-         *
          * @return The effective policy for reporting unmapped target properties.
          */
         private ReportingPolicy getEffectiveUnmappedTargetPolicy() {

File: processor/src/main/java/org/mapstruct/ap/model/PropertyMapping.java
Patch:
@@ -680,7 +680,7 @@ private PropertyMapping(String name, String sourceBeanName, String targetWriteAc
     }
 
     /**
-     * Returns the name of this mapping (property name on the target side)
+     * @return the name of this mapping (property name on the target side)
      */
     public String getName() {
         return name;

File: processor/src/main/java/org/mapstruct/ap/model/source/EnumMapping.java
Patch:
@@ -34,14 +34,14 @@ public EnumMapping(String source, String target) {
     }
 
     /**
-     * Returns the name of the constant in the source enum.
+     * @return the name of the constant in the source enum.
      */
     public String getSource() {
         return source;
     }
 
     /**
-     * Returns the name of the constant in the target enum.
+     * @return the name of the constant in the target enum.
      */
     public String getTarget() {
         return target;

File: processor/src/main/java/org/mapstruct/ap/model/source/Mapping.java
Patch:
@@ -322,6 +322,9 @@ public Mapping reverse(SourceMethod method, FormattingMessager messager, TypeFac
 
     /**
      * Creates a copy of this mapping, which is adapted to the given method
+     *
+     * @param method the method to create the copy for
+     * @return the copy
      */
     public Mapping copyForInheritanceTo(SourceMethod method) {
         Mapping mapping = new Mapping(

File: processor/src/main/java/org/mapstruct/ap/model/source/SourceReference.java
Patch:
@@ -292,6 +292,9 @@ public Type getType() {
 
     /**
      * Creates a copy of this reference, which is adapted to the given method
+     *
+     * @param method the method to create the copy for
+     * @return the copy
      */
     public SourceReference copyForInheritanceTo(SourceMethod method) {
         List<Parameter> replacementParamCandidates = new ArrayList<Parameter>();

File: processor/src/main/java/org/mapstruct/ap/model/source/selector/XmlElementDeclSelector.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.xml.bind.annotation.XmlElementDecl;
@@ -38,7 +39,7 @@
  * <li>Name matches</li>
  * </ol>
  * If there are name and scope matches, only those will be returned, otherwise the next in line (scope matches), etc. If
- * the given method is not annotated with {@code} XmlElementDecl} it will be considered as matching.
+ * the given method is not annotated with {@code XmlElementDecl} it will be considered as matching.
  *
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/prism/NullValueMappingStrategyPrism.java
Patch:
@@ -19,7 +19,7 @@
 package org.mapstruct.ap.prism;
 
 /**
- * Prism for the enum {@link org.mapstruct.MapNullToDefaultStrategy}
+ * Prism for the enum {@link org.mapstruct.NullValueMappingStrategy}
  *
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/processor/creation/MappingResolverImpl.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.List;
 import java.util.Set;
 
-import org.mapstruct.ap.util.FormattingMessager;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -46,6 +45,7 @@
 import org.mapstruct.ap.model.source.builtin.BuiltInMethod;
 import org.mapstruct.ap.model.source.selector.MethodSelectors;
 import org.mapstruct.ap.model.source.selector.SelectionCriteria;
+import org.mapstruct.ap.util.FormattingMessager;
 import org.mapstruct.ap.util.Message;
 import org.mapstruct.ap.util.Strings;
 
@@ -499,8 +499,6 @@ private MapperReference findMapperReference(SourceMethod method) {
          * implementation type) accepts the source type.</li>
          * </ul>
          *
-         * @param property The property mapping to check.
-         *
          * @return {@code true} if the specified property can be mapped, {@code false} otherwise.
          */
         private boolean isPropertyMappable(Type sourceType, Type targetType) {

File: processor/src/main/java/org/mapstruct/ap/util/Nouns.java
Patch:
@@ -88,6 +88,9 @@ private Nouns() {
     /**
      * Converts given pluralized noun into the singular form. If no singular form could be determined, the given word
      * itself is returned.
+     *
+     * @param plural plural word
+     * @return singular form, if available
      */
     public static String singularize(String plural) {
         for ( ReplaceRule replaceRule : SINGULAR_RULES ) {

File: processor/src/main/java/org/mapstruct/ap/writer/Writable.java
Patch:
@@ -39,7 +39,7 @@ interface Context {
          * Retrieves the object with the given type from this context.
          *
          * @param type The type of the object to retrieve from this context.
-         *
+         * @param <T> the type
          * @return The object with the given type from this context.
          */
         <T> T get(Class<T> type);
@@ -50,6 +50,7 @@ interface Context {
      *
      * @param context Provides additional data specific to the used implementation of the serialization mechanism.
      * @param writer The writer to write this element to. Must not be closed by implementations.
+     * @throws Exception in case of an error
      */
     void write(Context context, Writer writer) throws Exception;
 }

File: processor/src/main/java/org/mapstruct/ap/conversion/AbstractJodaTypeToStringConversion.java
Patch:
@@ -37,7 +37,7 @@ public abstract class AbstractJodaTypeToStringConversion extends SimpleConversio
 
     @Override
     protected String getToExpression(ConversionContext conversionContext) {
-        return conversionString( conversionContext, "print" );
+        return conversionString( conversionContext, "print" ) + ".trim()";
     }
 
     @Override

File: processor/src/test/java/org/mapstruct/ap/test/conversion/jodatime/SourceTargetMapper.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.mapstruct.ap.test.conversion.jodatime;
 
-import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
@@ -45,7 +44,6 @@ public interface SourceTargetMapper {
     })
     Target sourceToTarget(Source source);
 
-    @InheritInverseConfiguration( name = "targetToSource" ) // TODO: FIXME
     Target sourceToTargetDefaultMapping(Source source);
 
     @Mapping(target = "dateTime", dateFormat = DATE_TIME_FORMAT)
@@ -80,6 +78,5 @@ public interface SourceTargetMapper {
     @Mapping(target = "localTime", dateFormat = LOCAL_TIME_FORMAT)
     Source targetToSourceLocalTimeMapped(Target target);
 
-    @InheritInverseConfiguration( name = "sourceToTarget" ) // TODO: FIXME
     Source targetToSourceDefaultMapping(Target target);
 }

File: processor/src/main/java/org/mapstruct/ap/model/PropertyMapping.java
Patch:
@@ -320,7 +320,7 @@ private Assignment assignCollection(Type targetType,
                 result = new GetterWrapperForCollectionsAndMaps(
                     result,
                     method.getThrownTypes(),
-                    targetType,
+                    ctx.getTypeFactory().asCollectionOrMap( targetType ),
                     existingVariableNames
                 );
             }
@@ -591,7 +591,7 @@ public PropertyMapping build() {
                     assignment = new GetterWrapperForCollectionsAndMaps(
                         assignment,
                         method.getThrownTypes(),
-                        targetType,
+                        ctx.getTypeFactory().asCollectionOrMap( targetType ),
                         existingVariableNames
                     );
                 }
@@ -643,7 +643,7 @@ public PropertyMapping build() {
                 assignment = new GetterWrapperForCollectionsAndMaps(
                     assignment,
                     method.getThrownTypes(),
-                    targetType,
+                    ctx.getTypeFactory().asCollectionOrMap( targetType ),
                     existingVariableNames
                 );
             }

File: processor/src/test/java/org/mapstruct/ap/test/references/GenericWrapper.java
Patch:
@@ -22,7 +22,7 @@
  * @author Andreas Gudian
  *
  */
-public class GenericWrapper<T> {
+public class GenericWrapper<T> extends BaseType {
     private final T wrapped;
 
     public GenericWrapper(T someType) {

File: processor/src/test/java/org/mapstruct/ap/test/references/ReferencedCustomMapper.java
Patch:
@@ -39,6 +39,9 @@ public <T extends BaseType> T convert(String string, @TargetType Class<T> clazz)
         else if ( clazz == SomeOtherType.class ) {
             return (T) new SomeOtherType( string );
         }
+        else if ( clazz == GenericWrapper.class ) {
+            return (T) new GenericWrapper<String>( string );
+        }
 
         return null;
     }

File: core-common/src/main/java/org/mapstruct/NullValueMappingStrategy.java
Patch:
@@ -49,8 +49,8 @@ public enum NullValueMappingStrategy {
      * When given via {@link Mapper#nullValueMappingStrategy()}, causes the setting specified via
      * {@link MapperConfig#nullValueMappingStrategy()} to be applied, if present.
      * <p>
-     * When given via {@link NullValueMapping#value()}, causes the setting specified via
-     * {@link Mapper#nullValueMappingStrategy() ()} to be applied, if present.
+     * When given on specific mapping methods (e.g. via @ BeanMapping#nullValueMappingStrategy()}), causes the setting
+     * specified via {@link Mapper#nullValueMappingStrategy() ()} to be applied, if present.
      * <p>
      * Otherwise causes {@link #RETURN_NULL} to be applied.
      */

File: processor/src/main/java/org/mapstruct/ap/model/source/Mapping.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ElementKind;
@@ -321,8 +322,6 @@ public Mapping reverse(SourceMethod method, FormattingMessager messager, TypeFac
 
     /**
      * Creates a copy of this mapping, which is adapted to the given method
-     *
-     * @param the method to adapt the copy to
      */
     public Mapping copyForInheritanceTo(SourceMethod method) {
         Mapping mapping = new Mapping(

File: processor/src/main/java/org/mapstruct/ap/model/source/SourceMethod.java
Patch:
@@ -44,9 +44,8 @@
  * Represents a mapping method with source and target type and the mappings between the properties of source and target
  * type.
  * <p>
- * A method can either be configured by itself or by another method for the inverse mapping direction (one of
- * {@link #setMappings(Map)}, {@link #setIterableMapping(IterableMapping)} or {@link #setMapMapping(MapMapping)} will be
- * called in this case).
+ * A method can either be configured by itself or by another method for the inverse mapping direction (the appropriate
+ * setter on {@link MappingOptions} will be called in this case).
  *
  * @author Gunnar Morling
  */

File: processor/src/main/java/org/mapstruct/ap/model/source/SourceReference.java
Patch:
@@ -292,8 +292,6 @@ public Type getType() {
 
     /**
      * Creates a copy of this reference, which is adapted to the given method
-     *
-     * @param the method to adapt the copy to
      */
     public SourceReference copyForInheritanceTo(SourceMethod method) {
         List<Parameter> replacementParamCandidates = new ArrayList<Parameter>();

File: processor/src/main/java/org/mapstruct/ap/model/source/selector/TargetTypeSelector.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -30,8 +31,8 @@
 /**
  * This selector selects a best match based on the result type.
  * <p>
- *  Suppose: Sedan -> Car -> Vehicle, MotorCycle -> Vehicle
- *  By means of this selector one can pinpoint the exact desired return type (Sedan, Car, MotorCycle, Vehicle)
+ * Suppose: Sedan -&gt; Car -&gt; Vehicle, MotorCycle -&gt; Vehicle By means of this selector one can pinpoint the exact
+ * desired return type (Sedan, Car, MotorCycle, Vehicle)
  *
  * @author Sjaak Derksen
  */

File: processor/src/main/java/org/mapstruct/ap/util/Message.java
Patch:
@@ -35,6 +35,7 @@ public enum Message {
     BEANMAPPING_SEVERAL_POSSIBLE_TARGET_ACCESSORS( "Found several matching getters for property \"%s\"." ),
     BEANMAPPING_UNMAPPED_TARGETS_WARNING( "Unmapped target %s.", Diagnostic.Kind.WARNING ),
     BEANMAPPING_UNMAPPED_TARGETS_ERROR( "Unmapped target %s." ),
+    BEANMAPPING_CYCLE_BETWEEN_PROPERTIES( "Cycle(s) between properties given via dependsOn(): %s." ),
 
     PROPERTYMAPPING_MAPPING_NOT_FOUND( "Can't map %s to \"%s %s\". Consider to declare/implement a mapping method: \"%s map(%s value)\"." ),
     PROPERTYMAPPING_DUPLICATE_TARGETS( "Target property \"%s\" must not be mapped more than once." ),

File: processor/src/main/java/org/mapstruct/ap/model/common/TypeFactory.java
Patch:
@@ -58,6 +58,7 @@
 import org.mapstruct.ap.util.SpecificCompilerWorkarounds;
 
 import static org.mapstruct.ap.util.SpecificCompilerWorkarounds.erasure;
+import static org.mapstruct.ap.util.SpecificCompilerWorkarounds.replaceTypeElementIfNecessary;
 
 /**
  * Factory creating {@link Type} instances.
@@ -258,7 +259,8 @@ else if ( type.isPrimitive() ) {
      * @return the ExecutableType representing the method as part of usedMapper
      */
     public ExecutableType getMethodType(TypeElement usedMapper, ExecutableElement method) {
-        TypeMirror asMemberOf = typeUtils.asMemberOf( (DeclaredType) usedMapper.asType(), method );
+        DeclaredType asType = (DeclaredType) replaceTypeElementIfNecessary( elementUtils, usedMapper ).asType();
+        TypeMirror asMemberOf = typeUtils.asMemberOf( asType, method );
         ExecutableType methodType = asMemberOf.accept( new ExecutableTypeRetrievalVisitor(), null );
         return methodType;
     }

File: core-common/src/main/java/org/mapstruct/BeanMapping.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Configures the mapping between two bean types.
  * <p>
- * Either {@link #resultType()} , {@link #qualifiedBy()} or {@link #qualifiedBy()}must be specified.
+ * Either {@link #resultType()} , {@link #qualifiedBy()} or {@link #nullValueMappingStrategy()} must be specified.
  * </p>
  *
  * @author Sjaak Derksen

File: processor/src/main/java/org/mapstruct/ap/model/BeanMappingMethod.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+
 import javax.lang.model.element.ExecutableElement;
 import javax.tools.Diagnostic;
 
@@ -43,9 +44,9 @@
 import org.mapstruct.ap.prism.BeanMappingPrism;
 import org.mapstruct.ap.prism.CollectionMappingStrategyPrism;
 import org.mapstruct.ap.prism.NullValueMappingPrism;
-import org.mapstruct.ap.util.Message;
 import org.mapstruct.ap.util.Executables;
 import org.mapstruct.ap.util.MapperConfig;
+import org.mapstruct.ap.util.Message;
 import org.mapstruct.ap.util.Strings;
 
 /**
@@ -145,7 +146,7 @@ private boolean handleDefinedSourceMappings() {
 
             Set<String> handledTargets = new HashSet<String>();
 
-            for ( Map.Entry<String, List<Mapping>> entry : method.getMappings().entrySet() ) {
+            for ( Map.Entry<String, List<Mapping>> entry : method.getMappingOptions().getMappings().entrySet() ) {
                 for ( Mapping mapping : entry.getValue() ) {
 
                     PropertyMapping propertyMapping = null;

File: processor/src/main/java/org/mapstruct/ap/model/source/selector/InheritanceSelector.java
Patch:
@@ -25,6 +25,8 @@
 import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.Method;
 
+import static org.mapstruct.ap.util.Collections.first;
+
 /**
  * Selects on inheritance distance, e.g. the amount of inheritance steps from the parameter type.
  *
@@ -50,7 +52,7 @@ public <T extends Method> List<T> getMatchingMethods(
 
         // find the methods with the minimum distance regarding getParameter getParameter type
         for ( T method : methods ) {
-            Parameter singleSourceParam = method.getSourceParameters().iterator().next();
+            Parameter singleSourceParam = first( method.getSourceParameters() );
 
             int sourceTypeDistance = sourceType.distanceTo( singleSourceParam.getType() );
             bestMatchingSourceTypeDistance =

File: processor/src/test/java/org/mapstruct/ap/test/template/SourceTargetMapperSingle.java
Patch:
@@ -40,7 +40,7 @@ public interface SourceTargetMapperSingle {
         @Mapping(target = "constantProp", constant = "constant"),
         @Mapping(target = "expressionProp", expression = "java(\"expression\")"),
     })
-    Target forwardCreate(Source source);
+    Target forwardCreate(Source s1);
 
 
     @InheritConfiguration

File: processor/src/main/java/org/mapstruct/ap/util/Message.java
Patch:
@@ -50,11 +50,11 @@ public enum Message {
 
     CONSTANTMAPPING_MAPPING_NOT_FOUND( "Can't map \"%s %s\" to \"%s %s\"." ),
 
-    MAPMAPPING_KEY_MAPPING_NOT_FOUND( "Can't create implementation of method %s. Found no method nor built-in conversion for mapping source key type to target key type." ),
-    MAPMAPPING_VALUE_MAPPING_NOT_FOUND( "Can't create implementation of method %s. Found no method nor built-in conversion for mapping source value type to target value type." ),
+    MAPMAPPING_KEY_MAPPING_NOT_FOUND( "No implementation can be generated for this method. Found no method nor implicit conversion for mapping source key type to target key type." ),
+    MAPMAPPING_VALUE_MAPPING_NOT_FOUND( "No implementation can be generated for this method. Found no method nor implicit conversion for mapping source value type to target value type." ),
     MAPMAPPING_NO_ELEMENTS( "'keyDateFormat', 'keyQualifiedBy', 'keyTargetType', 'valueDateFormat', 'valueQualfiedBy' and 'valueTargetType' are all undefined in @MapMapping, define at least one of them." ),
 
-    ITERABLEMAPPING_MAPPING_NOT_FOUND( "Can't create implementation of method %s. Found no method nor built-in conversion for mapping source element type into target element type." ),
+    ITERABLEMAPPING_MAPPING_NOT_FOUND( "No implementation can be generated for this method. Found no method nor implicit conversion for mapping source element type into target element type." ),
     ITERABLEMAPPING_NO_ELEMENTS( "'dateformat', 'qualifiedBy' and 'elementTargetType' are undefined in @IterableMapping, define at least one of them." ),
 
     ENUMMAPPING_MULTIPLE_TARGETS( "One enum constant must not be mapped to more than one target constant, but constant %s is mapped to %s." ),

File: processor/src/main/java/org/mapstruct/ap/util/Message.java
Patch:
@@ -70,7 +70,7 @@ public enum Message {
     GENERAL_AMBIGIOUS_MAPPING_METHOD( "Ambiguous mapping methods found for mapping %s to %s: %s." ),
     GENERAL_AMBIGIOUS_FACTORY_METHOD( "Ambiguous mapping methods found for factorizing %s: %s." ),
     GENERAL_UNSUPPORTED_DATE_FORMAT_CHECK( "No dateFormat check is supported for types %s, %s" ),
-    GENERAL_VALID_DATE( "Given date format \"%s\" is valid." ),
+    GENERAL_VALID_DATE( "Given date format \"%s\" is valid.", Diagnostic.Kind.NOTE ),
     GENERAL_INVALID_DATE( "Given date format \"%s\" is invalid. Message: \"%s\"." ),
 
     RETRIEVAL_NO_INPUT_ARGS( "Can't generate mapping method with no input arguments." ),

File: processor/src/main/java/org/mapstruct/ap/processor/creation/MappingResolverImpl.java
Patch:
@@ -473,7 +473,7 @@ private <T extends Method> T getBestMatch(List<T> methods, Type sourceType, Type
                 }
                 else {
                     messager.printMessage( mappingMethod.getExecutable(),
-                        Message.GENERAL_AMBIGIOUSFACTORY_METHOD,
+                        Message.GENERAL_AMBIGIOUS_FACTORY_METHOD,
                         returnType,
                         Strings.join( candidates, ", " )
                     );

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/ResultTypeSelectingFruitMapper.java
Patch:
@@ -28,10 +28,9 @@
  * @author Sjaak Derksen
  */
 @Mapper(uses = ConflictingFruitFactory.class)
+public interface ResultTypeSelectingFruitMapper {
 
-public interface TargetTypeSelectingFruitMapper {
-
-    TargetTypeSelectingFruitMapper INSTANCE = Mappers.getMapper( TargetTypeSelectingFruitMapper.class );
+    ResultTypeSelectingFruitMapper INSTANCE = Mappers.getMapper( ResultTypeSelectingFruitMapper.class );
 
     @BeanMapping(resultType = Apple.class)
     @Mapping(target = "type", ignore = true)

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -100,6 +100,7 @@ public IterableMappingMethod build() {
                 null, // there is no targetPropertyName
                 dateFormat,
                 qualifiers,
+                null, // resulttype does not seem to make sense
                 loopVariableName
             );
 

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -102,6 +102,7 @@ public MapMappingMethod build() {
                 null, // there is no targetPropertyName
                 keyDateFormat,
                 keyQualifiers,
+                null, // resulttype does not seem to make sense
                 "entry.getKey()"
             );
 
@@ -125,6 +126,7 @@ public MapMappingMethod build() {
                 null, // there is no targetPropertyName
                 valueDateFormat,
                 valueQualifiers,
+                null, // resulttype does not seem to make sense
                 "entry.getValue()"
             );
 

File: processor/src/main/java/org/mapstruct/ap/model/MappingBuilderContext.java
Patch:
@@ -80,6 +80,7 @@ public interface MappingResolver {
          * @param targetPropertyName name of the target property
          * @param dateFormat used for formatting dates in build in methods that need context information
          * @param qualifiers used for further select the appropriate mapping method based on class and name
+         * @param resultType used for further select the appropriate mapping method based on class and name
          * @param sourceReference call to source type as string
          *
          * @return an assignment to a method parameter, which can either be:
@@ -92,7 +93,7 @@ public interface MappingResolver {
          */
         Assignment getTargetAssignment(Method mappingMethod, String mappedElement, Type sourceType, Type targetType,
                                        String targetPropertyName, String dateFormat, List<TypeMirror> qualifiers,
-                                       String sourceReference);
+                                       TypeMirror resultType, String sourceReference);
 
         /**
          * returns a no arg factory method

File: processor/src/main/java/org/mapstruct/ap/model/source/SourceMethod.java
Patch:
@@ -170,7 +170,7 @@ public SourceMethod createSourceMethod() {
         }
     }
 
-    //CHECKSTYLE:OFF
+    @SuppressWarnings( "checkstyle:parameternumber" )
     private SourceMethod( Type declaringMapper, ExecutableElement executable, List<Parameter> parameters,
                          Type returnType, List<Type> exceptionTypes, Map<String, List<Mapping>> mappings,
                          IterableMapping iterableMapping, MapMapping mapMapping, Types typeUtils,
@@ -192,7 +192,6 @@ private SourceMethod( Type declaringMapper, ExecutableElement executable, List<P
         this.messager = messager;
         this.config = config;
     }
-    //CHECKSTYLE:ON
 
     private Parameter determineTargetParameter(Iterable<Parameter> parameters) {
         for ( Parameter parameter : parameters ) {

File: processor/src/main/java/org/mapstruct/ap/processor/creation/MappingResolverImpl.java
Patch:
@@ -124,9 +124,10 @@ public Assignment getTargetAssignment(
         String targetPropertyName,
         String dateFormat,
         List<TypeMirror> qualifiers,
+        TypeMirror resultType,
         String sourceReference) {
 
-        SelectionCriteria criteria = new SelectionCriteria(qualifiers, targetPropertyName, null );
+        SelectionCriteria criteria = new SelectionCriteria(qualifiers, targetPropertyName, resultType );
 
         ResolvingAttempt attempt = new ResolvingAttempt(
             sourceModel,

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/Apple.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 /**
  *

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/AppleDto.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 /**
  *

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/Banana.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 /**
  *

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/BananaDto.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 /**
  *

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/ConflictingFruitFactory.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 /**
  *
@@ -31,4 +31,5 @@ public Apple createApple() {
     public Banana createBanana() {
         return new Banana( "banana" );
     }
+
 }

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/ErroneousFruitMapper.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/Fruit.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 /**
  *

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/FruitDto.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 /**
  *

File: processor/src/test/java/org/mapstruct/ap/test/selection/resulttype/TargetTypeSelectingFruitMapper.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.selection.inheritance;
+package org.mapstruct.ap.test.selection.resulttype;
 
 import org.mapstruct.BeanMapping;
 import org.mapstruct.Mapper;

File: processor/src/main/java/org/mapstruct/ap/model/source/IterableMapping.java
Patch:
@@ -49,7 +49,7 @@ public static IterableMapping fromPrism(IterableMappingPrism iterableMapping, Ex
         if ( iterableMapping.dateFormat().isEmpty() && iterableMapping.qualifiedBy().isEmpty() ) {
             messager.printMessage(
                 Diagnostic.Kind.ERROR,
-                "'dateformat' and 'qualifiedBy' are are are undefined in @IterableMapping, "
+                "'dateformat' and 'qualifiedBy' are undefined in @IterableMapping, "
                     + "define at least one of them.",
                 method
             );

File: processor/src/main/java/org/mapstruct/ap/model/common/TypeFactory.java
Patch:
@@ -194,7 +194,7 @@ else if ( mirror.getKind() == TypeKind.ARRAY ) {
         }
 
         return new Type(
-            typeUtils, elementUtils,
+            typeUtils, elementUtils, this,
             mirror,
             typeElement,
             getTypeParameters( mirror ),
@@ -377,6 +377,7 @@ private Type getImplementationType(TypeMirror mirror) {
             return new Type(
                 typeUtils,
                 elementUtils,
+                this,
                 typeUtils.getDeclaredType(
                     implementationType.getTypeElement(),
                     declaredType.getTypeArguments().toArray( new TypeMirror[] { } )

File: processor/src/test/java/org/mapstruct/ap/model/common/DateFormatValidatorFactoryTest.java
Patch:
@@ -164,6 +164,7 @@ private void assertValidDateFormat(Type sourceType, Type targetType) {
 
     private Type typeWithFQN(String fullQualifiedName) {
         return new Type(
+                        null,
                         null,
                         null,
                         voidTypeMirror,

File: processor/src/test/java/org/mapstruct/ap/model/common/DefaultConversionContextTest.java
Patch:
@@ -100,6 +100,7 @@ public void testUnsupportedType() {
 
     private Type typeWithFQN(String fullQualifiedName) {
         return new Type(
+                        null,
                         null,
                         null,
                         voidTypeMirror,

File: processor/src/main/java/org/mapstruct/ap/model/source/selector/MethodSelectors.java
Patch:
@@ -42,9 +42,10 @@ public MethodSelectors(Types typeUtils, Elements elementUtils, TypeFactory typeF
         selectors =
             Arrays.<MethodSelector>asList(
                 new TypeSelector( typeFactory ),
-                new InheritanceSelector(),
+                new QualifierSelector( typeUtils, elementUtils ),
+                new TargetTypeSelector( typeUtils, elementUtils ),
                 new XmlElementDeclSelector( typeUtils ),
-                new QualifierSelector( typeUtils, elementUtils )
+                new InheritanceSelector()
             );
     }
 

File: processor/src/main/java/org/mapstruct/ap/prism/PrismGenerator.java
Patch:
@@ -22,6 +22,7 @@
 
 import net.java.dev.hickory.prism.GeneratePrism;
 import net.java.dev.hickory.prism.GeneratePrisms;
+import org.mapstruct.BeanMapping;
 import org.mapstruct.DecoratedWith;
 import org.mapstruct.InheritConfiguration;
 import org.mapstruct.InheritInverseConfiguration;
@@ -46,6 +47,7 @@
     @GeneratePrism(value = Mapping.class, publicAccess = true),
     @GeneratePrism(value = Mappings.class, publicAccess = true),
     @GeneratePrism(value = IterableMapping.class, publicAccess = true),
+    @GeneratePrism(value = BeanMapping.class, publicAccess = true),
     @GeneratePrism(value = MapMapping.class, publicAccess = true),
     @GeneratePrism(value = TargetType.class, publicAccess = true),
     @GeneratePrism(value = MappingTarget.class, publicAccess = true),

File: processor/src/main/java/org/mapstruct/ap/model/GeneratedType.java
Patch:
@@ -164,8 +164,6 @@ private void addWithDependents(Collection<Type> collection, Type typeToAdd) {
             }
         }
 
-        addWithDependents( collection, typeToAdd.getImplementationType() );
-
         for ( Type type : typeToAdd.getTypeParameters() ) {
             addWithDependents( collection, type );
         }

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -166,7 +166,9 @@ public Set<Type> getImportTypes() {
         if ( elementAssignment != null ) {
             types.addAll( elementAssignment.getImportTypes() );
         }
-
+        if ( factoryMethod == null ) {
+            types.addAll( getReturnType().getImportTypes() );
+        }
         return types;
     }
 

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -195,6 +195,9 @@ public Set<Type> getImportTypes() {
         if ( valueAssignment != null ) {
             types.addAll( valueAssignment.getImportTypes() );
         }
+        if ( factoryMethod == null ) {
+            types.addAll( getReturnType().getImportTypes() );
+        }
 
         return types;
     }

File: processor/src/main/java/org/mapstruct/ap/model/MappingMethod.java
Patch:
@@ -111,7 +111,6 @@ public Set<Type> getImportTypes() {
         }
 
         types.add( getReturnType() );
-        types.addAll( getReturnType().getImportTypes() );
         types.addAll( thrownTypes );
         return types;
     }

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetAbstractMapper.java
Patch:
@@ -30,10 +30,12 @@ public abstract class SourceTargetAbstractMapper {
 
     @Mappings({
         @Mapping(source = "qax", target = "baz"),
-        @Mapping(source = "baz", target = "qax")
+        @Mapping(source = "baz", target = "qax"),
+        @Mapping(source = "forNested.value", target = "fromNested")
     })
     public abstract Target sourceToTarget(Source source);
 
+    @Mapping(target = "forNested", ignore = true)
     public abstract Source targetToSource(Target target);
 
     protected void isNeverCalled(Source source) {

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetMapper.java
Patch:
@@ -31,10 +31,12 @@ public interface SourceTargetMapper {
 
     @Mappings({
         @Mapping(source = "qax", target = "baz"),
-        @Mapping(source = "baz", target = "qax")
+        @Mapping(source = "baz", target = "qax"),
+        @Mapping(source = "forNested.value", target = "fromNested")
     })
     Target sourceToTarget(Source source);
 
     @InheritInverseConfiguration
+    @Mapping(target = "forNested", ignore = true)
     Source targetToSource(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_394/source/AnotherCar.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.collection.map.source;
+package org.mapstruct.ap.test.bugs._394.source;
 
 public class AnotherCar {
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_394/source/Cars.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.collection.map.source;
+package org.mapstruct.ap.test.bugs._394.source;
 
 import java.util.Map;
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_394/target/AnotherCar.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.collection.map.targets;
+package org.mapstruct.ap.test.bugs._394.target;
 
 public class AnotherCar {
 

File: processor/src/test/java/org/mapstruct/ap/test/bugs/_394/target/Cars.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.collection.map.targets;
+package org.mapstruct.ap.test.bugs._394.target;
 
 import java.util.Map;
 

File: processor/src/test/java/org/mapstruct/ap/test/bool/PersonMapper.java
Patch:
@@ -21,7 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.factory.Mappers;
 
-@Mapper
+@Mapper( uses = YesNoMapper.class )
 public interface PersonMapper {
 
     PersonMapper INSTANCE = Mappers.getMapper( PersonMapper.class );

File: processor/src/test/java/org/mapstruct/ap/model/common/DateFormatValidatorFactoryTest.java
Patch:
@@ -172,6 +172,7 @@ private Type typeWithFQN(String fullQualifiedName) {
                         null,
                         null,
                         null,
+                        null,
                         fullQualifiedName,
                         false,
                         false,

File: processor/src/test/java/org/mapstruct/ap/model/common/DefaultConversionContextTest.java
Patch:
@@ -108,6 +108,7 @@ private Type typeWithFQN(String fullQualifiedName) {
                         null,
                         null,
                         null,
+                        null,
                         fullQualifiedName,
                         false,
                         false,

File: processor/src/main/java/org/mapstruct/ap/conversion/AbstractJodaTypeToStringConversion.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.mapstruct.ap.model.common.ConversionContext;
 import org.mapstruct.ap.model.common.Type;
+import org.mapstruct.ap.util.JodaTimeConstants;
 import org.mapstruct.ap.util.Strings;
 
 import static org.mapstruct.ap.util.Collections.asSet;

File: processor/src/main/java/org/mapstruct/ap/conversion/Conversions.java
Patch:
@@ -29,6 +29,7 @@
 import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.util.JavaTimeConstants;
+import org.mapstruct.ap.util.JodaTimeConstants;
 import org.mapstruct.ap.util.NativeTypes;
 
 import static org.mapstruct.ap.conversion.ReverseConversion.reverse;

File: processor/src/main/java/org/mapstruct/ap/conversion/JodaDateTimeToStringConversion.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.mapstruct.ap.conversion;
 
+import org.mapstruct.ap.util.JodaTimeConstants;
+
 /**
  * Conversion between {@code DateTime} and {@code String}.
  *

File: processor/src/main/java/org/mapstruct/ap/conversion/JodaLocalDateTimeToStringConversion.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.mapstruct.ap.conversion;
 
+import org.mapstruct.ap.util.JodaTimeConstants;
+
 /**
  * Conversion between {@code LocalDateTime} and {@code String}.
  *

File: processor/src/main/java/org/mapstruct/ap/util/JodaTimeConstants.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.conversion;
+package org.mapstruct.ap.util;
 
 /**
  * Helper holding constants for working with Joda-Time.

File: integrationtest/src/test/java/org/mapstruct/itest/tests/Jsr330Test.java
Patch:
@@ -28,6 +28,6 @@
  *
  */
 @RunWith( ProcessorSuiteRunner.class )
-@ProcessorSuite( baseDir = "springTest", processorTypes = ProcessorType.ALL )
+@ProcessorSuite( baseDir = "jsr330Test", processorTypes = ProcessorType.ALL )
 public class Jsr330Test {
 }

File: processor/src/test/java/org/mapstruct/ap/test/abstractclass/AbstractClassTest.java
Patch:
@@ -39,6 +39,8 @@
     ReferencedMapperInterface.class,
     AbstractDto.class,
     Identifiable.class,
+    HasId.class,
+    AlsoHasId.class,
     Measurable.class
 })
 @RunWith(AnnotationProcessorTestRunner.class)

File: processor/src/test/java/org/mapstruct/ap/test/abstractclass/Source.java
Patch:
@@ -19,9 +19,10 @@
 package org.mapstruct.ap.test.abstractclass;
 
 import java.util.Calendar;
+
 import javax.xml.ws.Holder;
 
-public class Source extends AbstractDto {
+public class Source extends AbstractDto implements HasId, AlsoHasId {
 
     private final int size;
     private final Calendar birthday;

File: core-common/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -44,7 +44,7 @@
 
     /**
      * Additional types for which an import statement is to be added to the generated mapper implementation class.
-     * This allows to refer to those types from within mapping expressions given via {@link #expression()} using
+     * This allows to refer to those types from within mapping expressions given via {@link Mapping#expression()} using
      * their simple name rather than their fully-qualified name.
      *
      * @return classes to add in the imports of the generated implementation.

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/ZonedDateTimeToCalendar.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.mapstruct.ap.model.source.builtin;
 
+import java.time.ZonedDateTime;
 import java.util.Calendar;
 import java.util.Set;
 
@@ -28,9 +29,8 @@
 import org.mapstruct.ap.util.JavaTimeConstants;
 
 /**
- * {@link BuiltInMethod} for mapping between {@link java.util.Calendar}
- * and {@link java.time.ZonedDateTime}.
- * <br />
+ * {@link BuiltInMethod} for mapping between {@link Calendar} and {@link ZonedDateTime}.
+ * <p>
  * Template is at org.mapstruct.ap.model.builtin.ZonedDateTimeToCalendar.ftl
  */
 public class ZonedDateTimeToCalendar extends BuiltInMethod {

File: processor/src/main/java/org/mapstruct/ap/model/source/selector/QualifierSelector.java
Patch:
@@ -45,7 +45,6 @@
  * removed from the list of potential mapping methods</li>
  * <li>If multiple qualifiers (qualifedBy) are specified, all should match to make a match.</li>
  * </ol>
- * </p>
  *
  * @author Sjaak Derksen
  */

File: core-common/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -109,5 +109,5 @@
      *
      * @return The strategy applied when determining whether to return null or an empty object, list or map.
      */
-    MapNullToDefaultStrategy mapNullToDefaultStrategy() default MapNullToDefaultStrategy.DEFAULT;
+    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.DEFAULT;
 }

File: core-common/src/main/java/org/mapstruct/MapperConfig.java
Patch:
@@ -87,5 +87,5 @@
      *
      * @return The strategy applied when determining whether to return null or an empty object, list or map.
      */
-    MapNullToDefaultStrategy mapNullToDefaultStrategy() default MapNullToDefaultStrategy.DEFAULT;
+    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.DEFAULT;
 }

File: core-common/src/main/java/org/mapstruct/NullValueMapping.java
Patch:
@@ -38,9 +38,9 @@
  *
  * @author Sjaak Derksen
  */
-@Target( { ElementType.METHOD, ElementType.TYPE } )
+@Target( { ElementType.METHOD } )
 @Retention( RetentionPolicy.SOURCE )
-public @interface MapNullToDefault {
+public @interface NullValueMapping {
 
-    MapNullToDefaultStrategy value() default MapNullToDefaultStrategy.MAP_NULL_TO_DEFAULT;
+    NullValueMappingStrategy value() default NullValueMappingStrategy.RETURN_DEFAULT;
 }

File: processor/src/main/java/org/mapstruct/ap/model/BeanMappingMethod.java
Patch:
@@ -40,7 +40,7 @@
 import org.mapstruct.ap.model.source.SourceMethod;
 import org.mapstruct.ap.model.source.SourceReference;
 import org.mapstruct.ap.option.ReportingPolicy;
-import org.mapstruct.ap.prism.MapNullToDefaultPrism;
+import org.mapstruct.ap.prism.NullValueMappingPrism;
 import org.mapstruct.ap.prism.CollectionMappingStrategyPrism;
 import org.mapstruct.ap.util.Executables;
 import org.mapstruct.ap.util.MapperConfig;
@@ -100,7 +100,7 @@ public BeanMappingMethod build() {
             reportErrorForUnmappedTargetPropertiesIfRequired();
 
             // mapNullToDefault
-            MapNullToDefaultPrism prism = MapNullToDefaultPrism.getInstanceOn( method.getExecutable() );
+            NullValueMappingPrism prism = NullValueMappingPrism.getInstanceOn( method.getExecutable() );
             boolean mapNullToDefault =
                     MapperConfig.getInstanceOn( ctx.getMapperTypeElement() ).isMapToDefault( prism );
 

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -31,7 +31,7 @@
 import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.model.source.Method;
-import org.mapstruct.ap.prism.MapNullToDefaultPrism;
+import org.mapstruct.ap.prism.NullValueMappingPrism;
 import org.mapstruct.ap.util.MapperConfig;
 import org.mapstruct.ap.util.Strings;
 
@@ -109,7 +109,7 @@ public IterableMappingMethod build() {
             assignment = new SetterWrapper( assignment, method.getThrownTypes() );
 
             // mapNullToDefault
-            MapNullToDefaultPrism prism = MapNullToDefaultPrism.getInstanceOn( method.getExecutable() );
+            NullValueMappingPrism prism = NullValueMappingPrism.getInstanceOn( method.getExecutable() );
             boolean mapNullToDefault
                     = MapperConfig.getInstanceOn( ctx.getMapperTypeElement() ).isMapToDefault( prism );
 

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -31,7 +31,7 @@
 import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.model.source.Method;
-import org.mapstruct.ap.prism.MapNullToDefaultPrism;
+import org.mapstruct.ap.prism.NullValueMappingPrism;
 import org.mapstruct.ap.util.MapperConfig;
 import org.mapstruct.ap.util.Strings;
 
@@ -141,7 +141,7 @@ public MapMappingMethod build() {
             }
 
            // mapNullToDefault
-            MapNullToDefaultPrism prism = MapNullToDefaultPrism.getInstanceOn( method.getExecutable() );
+            NullValueMappingPrism prism = NullValueMappingPrism.getInstanceOn( method.getExecutable() );
             boolean mapNullToDefault =
                     MapperConfig.getInstanceOn( ctx.getMapperTypeElement() ).isMapToDefault( prism );
 

File: processor/src/main/java/org/mapstruct/ap/prism/NullValueMappingStrategyPrism.java
Patch:
@@ -23,9 +23,9 @@
  *
  * @author Sjaak Derksen
  */
-public enum MapNullToDefaultStrategyPrism {
+public enum NullValueMappingStrategyPrism {
 
-    MAP_NULL_TO_NULL,
-    MAP_NULL_TO_DEFAULT,
+    RETURN_NULL,
+    RETURN_DEFAULT,
     DEFAULT;
 }

File: processor/src/main/java/org/mapstruct/ap/prism/PrismGenerator.java
Patch:
@@ -27,7 +27,7 @@
 import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.IterableMapping;
 import org.mapstruct.MapMapping;
-import org.mapstruct.MapNullToDefault;
+import org.mapstruct.NullValueMapping;
 import org.mapstruct.Mapper;
 import org.mapstruct.MapperConfig;
 import org.mapstruct.Mapping;
@@ -53,7 +53,7 @@
     @GeneratePrism(value = MapperConfig.class, publicAccess = true),
     @GeneratePrism(value = InheritInverseConfiguration.class, publicAccess = true),
     @GeneratePrism( value = Qualifier.class, publicAccess = true ),
-    @GeneratePrism( value = MapNullToDefault.class, publicAccess = true ),
+    @GeneratePrism( value = NullValueMapping.class, publicAccess = true ),
 
     // external types
     @GeneratePrism(value = XmlElementDecl.class, publicAccess = true)

File: processor/src/test/java/org/mapstruct/ap/test/mapnulltodefault/CentralConfig.java
Patch:
@@ -18,14 +18,14 @@
  */
 package org.mapstruct.ap.test.mapnulltodefault;
 
-import org.mapstruct.MapNullToDefaultStrategy;
+import org.mapstruct.NullValueMappingStrategy;
 import org.mapstruct.MapperConfig;
 
 /**
  *
  * @author Sjaak Derksen
  */
-@MapperConfig( mapNullToDefaultStrategy = MapNullToDefaultStrategy.MAP_NULL_TO_DEFAULT )
+@MapperConfig( nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT )
 public class CentralConfig {
 
 }

File: processor/src/main/java/org/mapstruct/ap/MappingProcessor.java
Patch:
@@ -93,9 +93,9 @@ public class MappingProcessor extends AbstractProcessor {
      */
     private static final boolean ANNOTATIONS_CLAIMED_EXCLUSIVELY = false;
 
-    protected static final String SUPPRESS_GENERATOR_TIMESTAMP = "suppressGeneratorTimestamp";
-    protected static final String UNMAPPED_TARGET_POLICY = "unmappedTargetPolicy";
-    protected static final String DEFAULT_COMPONENT_MODEL = "defaultComponentModel";
+    protected static final String SUPPRESS_GENERATOR_TIMESTAMP = "mapstruct.suppressGeneratorTimestamp";
+    protected static final String UNMAPPED_TARGET_POLICY = "mapstruct.unmappedTargetPolicy";
+    protected static final String DEFAULT_COMPONENT_MODEL = "mapstruct.defaultComponentModel";
 
     private Options options;
 

File: processor/src/test/java/org/mapstruct/ap/test/severalsources/SeveralSourceParametersTest.java
Patch:
@@ -100,7 +100,7 @@ public void shouldReturnNullIfAllParametersAreNull() {
 
     @Test
     @WithClasses({ ErroneousSourceTargetMapper.class, Address.class, DeliveryAddress.class })
-    @ProcessorOption(name = "unmappedTargetPolicy", value = "IGNORE")
+    @ProcessorOption(name = "mapstruct.unmappedTargetPolicy", value = "IGNORE")
     @ExpectedCompilationOutcome(
         value = CompilationResult.FAILED,
         diagnostics = {

File: processor/src/test/java/org/mapstruct/ap/test/unmappedtarget/UnmappedTargetTest.java
Patch:
@@ -87,7 +87,7 @@ public void shouldRaiseErrorDueToUnsetTargetProperty() {
 
     @Test
     @WithClasses({ Source.class, Target.class, SourceTargetMapper.class })
-    @ProcessorOption(name = "unmappedTargetPolicy", value = "ERROR")
+    @ProcessorOption(name = "mapstruct.unmappedTargetPolicy", value = "ERROR")
     @ExpectedCompilationOutcome(
         value = CompilationResult.FAILED,
         diagnostics = {

File: processor/src/main/java/org/mapstruct/ap/util/SpecificCompilerWorkarounds.java
Patch:
@@ -66,7 +66,7 @@ public static boolean isSubType(Types types, TypeMirror t1, TypeMirror t2) {
      * @jls 4.6 Type Erasure
      */
     public static TypeMirror erasure(Types types, TypeMirror t) {
-        if ( t.getKind() == TypeKind.VOID ) {
+        if ( t.getKind() == TypeKind.VOID || t.getKind() == TypeKind.NULL ) {
             return t;
         }
         else {

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetAbstractMapper.java
Patch:
@@ -23,7 +23,7 @@
 import org.mapstruct.Mappings;
 import org.mapstruct.factory.Mappers;
 
-@Mapper
+@Mapper( uses = ReferencedCustomMapper.class )
 public abstract class SourceTargetAbstractMapper {
 
     public static SourceTargetAbstractMapper INSTANCE = Mappers.getMapper( SourceTargetAbstractMapper.class );

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetMapper.java
Patch:
@@ -24,7 +24,7 @@
 import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.factory.Mappers;
 
-@Mapper
+@Mapper(uses = ReferencedCustomMapper.class)
 public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

File: processor/src/main/java/org/mapstruct/ap/processor/creation/MappingResolverImpl.java
Patch:
@@ -426,8 +426,7 @@ private <T extends Method> T getBestMatch(List<T> methods, Type sourceType, Type
             if ( candidates.size() > 1 ) {
 
                 String errorMsg = String.format(
-                    "Ambiguous mapping methods found for mapping " + mappedElement + " from %s to %s: %s.",
-                    sourceType,
+                    "Ambiguous mapping methods found for mapping " + mappedElement + " to %s: %s.",
                     returnType,
                     Strings.join( candidates, ", " )
                 );

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/ComplexInheritanceTest.java
Patch:
@@ -84,7 +84,7 @@ public void shouldMapAttributesWithSuperTypeUsingOtherMapper() {
             line = 32,
             messageRegExp =
                 "Ambiguous mapping methods found for mapping property "
-                    + "\"org.mapstruct.ap.test.inheritance.complex.SourceExt prop1\" from .*SourceExt to .*Reference: "
+                    + "\"org.mapstruct.ap.test.inheritance.complex.SourceExt prop1\" to .*Reference: "
                     + ".*Reference .*AdditionalMappingHelper\\.asReference\\(.*SourceBase source\\), "
                     + ".*Reference .*AdditionalMappingHelper\\.asReference\\(.*AdditionalFooSource source\\)"))
     public void ambiguousMappingMethodsReportError() {

File: processor/src/test/java/org/mapstruct/ap/test/selection/qualifier/QualifierTest.java
Patch:
@@ -110,7 +110,7 @@ public void shouldMatchClassAndMethod() {
                         kind = Kind.ERROR,
                         line = 42,
                         messageRegExp = "Ambiguous mapping methods found for mapping property "
-                                + "\"java.lang.String title\" from java.lang.String to java.lang.String.*" )
+                                + "\"java.lang.String title\" to java.lang.String.*" )
             }
     )
     public void shouldNotProduceMatchingMethod() {

File: processor/src/main/java/org/mapstruct/ap/model/BeanMappingMethod.java
Patch:
@@ -309,10 +309,9 @@ private void applyPropertyNameBasedMapping() {
                                     .dateFormat( mapping != null ? mapping.getDateFormat() : null )
                                     .build();
 
-                            // candidates are handled
-                            candidates.clear();
                         }
-
+                        // candidates are handled
+                        candidates.clear();
 
                         if ( propertyMapping != null && newPropertyMapping != null ) {
                             // TODO improve error message

File: processor/src/test/java/org/mapstruct/ap/test/abstractclass/Source.java
Patch:
@@ -22,7 +22,7 @@
 
 import javax.xml.ws.Holder;
 
-public class Source {
+public class Source extends AbstractDto {
 
     private final int size;
     private final Calendar birthday;
@@ -33,6 +33,8 @@ public Source() {
         size = 181;
         birthday = Calendar.getInstance();
         birthday.set( 1948, 3, 26 );
+
+        super.setId( 42L );
     }
 
     public int getSize() {

File: processor/src/test/java/org/mapstruct/ap/test/abstractclass/Target.java
Patch:
@@ -18,7 +18,7 @@
  */
 package org.mapstruct.ap.test.abstractclass;
 
-public class Target {
+public class Target extends AbstractDto {
 
     private Long size;
     private String birthday;

File: processor/src/test/java/org/mapstruct/ap/test/naming/VariableNamingTest.java
Patch:
@@ -34,7 +34,7 @@
 import org.mapstruct.ap.testutil.runner.AnnotationProcessorTestRunner;
 
 /**
- * Test for aming of variables/members which conflict with keywords or parameter names.
+ * Test for naming of variables/members which conflict with keywords or parameter names.
  *
  * @author Gunnar Morling
  */

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapper.java
Patch:
@@ -49,7 +49,7 @@ public interface SourceTargetMapper {
     @InheritInverseConfiguration(name = "forward")
     @Mappings({
         @Mapping(target = "someConstantDownstream", constant = "test"),
-        @Mapping(source = "propertyToIgnoreDownstream", ignore = true)
+        @Mapping(target = "propertyToIgnoreDownstream", ignore = true)
     })
     Source reverse(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapperAmbiguous1.java
Patch:
@@ -49,7 +49,7 @@ public interface SourceTargetMapperAmbiguous1 {
     @InheritInverseConfiguration
     @Mappings({
         @Mapping(target = "someConstantDownstream", constant = "test"),
-        @Mapping(source = "propertyToIgnoreDownstream", ignore = true)
+        @Mapping(target = "propertyToIgnoreDownstream", ignore = true)
     })
     Source reverse(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapperAmbiguous2.java
Patch:
@@ -49,7 +49,7 @@ public interface SourceTargetMapperAmbiguous2 {
     @InheritInverseConfiguration(name = "blah")
     @Mappings({
         @Mapping(target = "someConstantDownstream", constant = "test"),
-        @Mapping(source = "propertyToIgnoreDownstream", ignore = true)
+        @Mapping(target = "propertyToIgnoreDownstream", ignore = true)
     })
     Source reverse(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapperAmbiguous3.java
Patch:
@@ -50,7 +50,7 @@ public interface SourceTargetMapperAmbiguous3 {
     @InheritInverseConfiguration(name = "forward")
     @Mappings({
         @Mapping(target = "someConstantDownstream", constant = "test"),
-        @Mapping(source = "propertyToIgnoreDownstream", ignore = true)
+        @Mapping(target = "propertyToIgnoreDownstream", ignore = true)
     })
     Source reverse(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapperErroneouslyAnnotated.java
Patch:
@@ -42,7 +42,7 @@ public interface SourceTargetMapperErroneouslyAnnotated {
     @InheritInverseConfiguration(name = "forward")
     @Mappings({
         @Mapping(target = "someConstantDownstream", constant = "test"),
-        @Mapping(source = "propertyToIgnoreDownstream", ignore = true)
+        @Mapping(target = "propertyToIgnoreDownstream", ignore = true)
     })
     Source reverse(Target target);
 

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapperNonMatchingName.java
Patch:
@@ -42,7 +42,7 @@ public interface SourceTargetMapperNonMatchingName {
     @InheritInverseConfiguration(name = "blah")
     @Mappings({
         @Mapping(target = "someConstantDownstream", constant = "test"),
-        @Mapping(source = "propertyToIgnoreDownstream", ignore = true)
+        @Mapping(target = "propertyToIgnoreDownstream", ignore = true)
     })
     Source reverse(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/string/StringConversionTest.java
Patch:
@@ -34,7 +34,7 @@
 @RunWith(AnnotationProcessorTestRunner.class)
 public class StringConversionTest {
 
-    private static final String STRING_CONTANT = "String contant";
+    private static final String STRING_CONSTANT = "String constant";
 
     @Test
     public void shouldApplyStringConversions() {
@@ -122,11 +122,11 @@ public void shouldApplyReverseStringConversions() {
     @IssueKey( "328" )
     public void stringShouldBeMappedToObjectByReference() {
         Target target = new Target();
-        target.setObject( STRING_CONTANT );
+        target.setObject( STRING_CONSTANT );
 
         Source source = SourceTargetMapper.INSTANCE.targetToSource( target );
 
         // no conversion, no built-in method
-        assertThat( source.getObject() ).isSameAs( STRING_CONTANT );
+        assertThat( source.getObject() ).isSameAs( STRING_CONSTANT );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/model/common/Type.java
Patch:
@@ -106,7 +106,7 @@ public Type(Types typeUtils, Elements elementUtils, TypeMirror typeMirror, TypeE
         this.isCollectionType = isCollectionType;
         this.isMapType = isMapType;
         this.isImported = isImported;
-        this.isVoid = typeMirror.getKind().equals(  TypeKind.VOID );
+        this.isVoid = typeMirror.getKind() == TypeKind.VOID;
 
         if ( isEnumType ) {
             enumConstants = new ArrayList<String>();

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetMapper.java
Patch:
@@ -21,7 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -35,6 +35,6 @@ public interface SourceTargetMapper {
     })
     Target sourceToTarget(Source source);
 
-    @ReverseMappingMethod
+    @InheritInverseConfiguration
     Source targetToSource(Target target);
 }

File: processor/src/main/java/org/mapstruct/ap/prism/PrismGenerator.java
Patch:
@@ -22,15 +22,16 @@
 
 import net.java.dev.hickory.prism.GeneratePrism;
 import net.java.dev.hickory.prism.GeneratePrisms;
+
 import org.mapstruct.DecoratedWith;
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.IterableMapping;
 import org.mapstruct.MapMapping;
 import org.mapstruct.Mapper;
 import org.mapstruct.MapperConfig;
 import org.mapstruct.Mapping;
 import org.mapstruct.MappingTarget;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.TargetType;
 
 /**
@@ -48,7 +49,7 @@
     @GeneratePrism(value = MappingTarget.class, publicAccess = true),
     @GeneratePrism(value = DecoratedWith.class, publicAccess = true),
     @GeneratePrism(value = MapperConfig.class, publicAccess = true),
-    @GeneratePrism(value = ReverseMappingMethod.class, publicAccess = true),
+    @GeneratePrism(value = InheritInverseConfiguration.class, publicAccess = true),
 
     // external types
     @GeneratePrism(value = XmlElementDecl.class, publicAccess = true)

File: processor/src/test/java/org/mapstruct/ap/test/collection/map/SourceTargetMapper.java
Patch:
@@ -24,7 +24,7 @@
 import org.mapstruct.MapMapping;
 import org.mapstruct.Mapper;
 import org.mapstruct.MappingTarget;
-import org.mapstruct.ReverseMappingMethod;
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.factory.Mappers;
 
 @Mapper(uses = CustomNumberMapper.class)
@@ -34,7 +34,7 @@ public interface SourceTargetMapper {
 
     @MapMapping(valueDateFormat = "dd.MM.yyyy")
     Map<String, String> longDateMapToStringStringMap(Map<Long, Date> source);
-    @ReverseMappingMethod
+    @InheritInverseConfiguration
     Map<Long, Date> stringStringMapToLongDateMap(Map<String, String> source);
 
     @MapMapping(valueDateFormat = "dd.MM.yyyy")
@@ -46,7 +46,7 @@ Map<Long, Date> stringStringMapToLongDateMapUsingTargetParameterAndReturn(Map<St
                                                                               @MappingTarget Map<Long, Date> target);
 
     Target sourceToTarget(Source source);
-    @ReverseMappingMethod
+    @InheritInverseConfiguration
     Source targetToSource(Target target);
 
     Map<Number, Number> intIntToNumberNumberMap(Map<Integer, Integer> source);

File: processor/src/test/java/org/mapstruct/ap/test/conversion/SourceTargetMapper.java
Patch:
@@ -21,7 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -34,6 +34,6 @@ public interface SourceTargetMapper {
         @Mapping(source = "baz", target = "qax")
     })
     Target sourceToTarget(Source source);
-    @ReverseMappingMethod
+    @InheritInverseConfiguration
     Source targetToSource(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/date/SourceTargetMapper.java
Patch:
@@ -24,7 +24,7 @@
 import org.mapstruct.IterableMapping;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
-import org.mapstruct.ReverseMappingMethod;
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -34,11 +34,11 @@ public interface SourceTargetMapper {
 
     @Mapping(source = "date", dateFormat = "dd.MM.yyyy")
     Target sourceToTarget(Source source);
-    @ReverseMappingMethod
+    @InheritInverseConfiguration
     Source targetToSource(Target target);
 
     @IterableMapping(dateFormat = "dd.MM.yyyy")
     List<String> stringListToDateList(List<Date> dates);
-    @ReverseMappingMethod
+    @InheritInverseConfiguration
     List<Date> dateListToStringList(List<String> strings);
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/java8time/SourceTargetMapper.java
Patch:
@@ -18,10 +18,10 @@
  */
 package org.mapstruct.ap.test.conversion.java8time;
 
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -81,6 +81,6 @@ public interface SourceTargetMapper {
     @Mapping( source = "localTime", dateFormat = LOCAL_TIME_FORMAT )
     Source targetToSourceLocalTimeMapped(Target target);
 
-    @ReverseMappingMethod(configuredBy = "sourceToTarget")
+    @InheritInverseConfiguration( name = "sourceToTarget" )
     Source targetToSourceDefaultMapping(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/jodatime/SourceTargetMapper.java
Patch:
@@ -18,10 +18,10 @@
  */
 package org.mapstruct.ap.test.conversion.jodatime;
 
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -45,7 +45,7 @@ public interface SourceTargetMapper {
     })
     Target sourceToTarget(Source source);
 
-    @ReverseMappingMethod(configuredBy = "targetToSource") // TODO: FIXME
+    @InheritInverseConfiguration( name = "targetToSource" ) // TODO: FIXME
     Target sourceToTargetDefaultMapping(Source source);
 
     @Mapping(source = "dateTime", dateFormat = DATE_TIME_FORMAT)
@@ -81,6 +81,6 @@ public interface SourceTargetMapper {
     @Mapping(source = "localTime", dateFormat = LOCAL_TIME_FORMAT)
     Source targetToSourceLocalTimeMapped(Target target);
 
-    @ReverseMappingMethod(configuredBy = "sourceToTarget") // TODO: FIXME
+    @InheritInverseConfiguration( name = "sourceToTarget" ) // TODO: FIXME
     Source targetToSourceDefaultMapping(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/ignore/AnimalMapper.java
Patch:
@@ -21,7 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -34,6 +34,6 @@ public interface AnimalMapper {
         @Mapping(target = "age", ignore = true)
     })
     AnimalDto animalToDto(Animal animal);
-    @ReverseMappingMethod
+    @InheritInverseConfiguration
     Animal animalDtoToAnimal(AnimalDto animalDto);
 }

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapper.java
Patch:
@@ -18,10 +18,10 @@
  */
 package org.mapstruct.ap.test.reverse;
 
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -48,7 +48,7 @@ public interface SourceTargetMapper {
     } )
     Target forwardNotToReverse( Source source );
 
-    @ReverseMappingMethod(configuredBy = "forward")
+    @InheritInverseConfiguration( name = "forward" )
     @Mappings( {
         @Mapping( target = "someConstantDownstream", constant = "test" ),
         @Mapping( source = "propertyToIgnoreDownstream", ignore = true )

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapperErroneouslyAnnotated.java
Patch:
@@ -18,10 +18,10 @@
  */
 package org.mapstruct.ap.test.reverse;
 
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -41,14 +41,14 @@ public interface SourceTargetMapperErroneouslyAnnotated {
     } )
     Target forward( Source source );
 
-    @ReverseMappingMethod(configuredBy = "forward")
+    @InheritInverseConfiguration( name = "forward" )
     @Mappings( {
         @Mapping( target = "someConstantDownstream", constant = "test" ),
         @Mapping( source = "propertyToIgnoreDownstream", ignore = true )
     } )
     Source reverse( Target target );
 
-    @ReverseMappingMethod(configuredBy = "reverse")
+    @InheritInverseConfiguration( name = "reverse" )
     @Mappings( {
         @Mapping( source = "stringPropX", target = "stringPropY" ),
         @Mapping( source = "integerPropX", target = "integerPropY" ),

File: processor/src/test/java/org/mapstruct/ap/test/reverse/SourceTargetMapperNonMatchingName.java
Patch:
@@ -18,10 +18,10 @@
  */
 package org.mapstruct.ap.test.reverse;
 
+import org.mapstruct.InheritInverseConfiguration;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
-import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 /**
@@ -41,7 +41,7 @@ public interface SourceTargetMapperNonMatchingName {
     } )
     Target forward( Source source );
 
-    @ReverseMappingMethod(configuredBy = "blah")
+    @InheritInverseConfiguration( name = "blah" )
     @Mappings( {
         @Mapping( target = "someConstantDownstream", constant = "test" ),
         @Mapping( source = "propertyToIgnoreDownstream", ignore = true )

File: integrationtest/src/test/resources/simpleTest/src/main/java/org/mapstruct/itest/simple/SourceTargetMapper.java
Patch:
@@ -21,6 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
+import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -34,5 +35,6 @@ public interface SourceTargetMapper {
     })
     Target sourceToTarget(Source source);
 
+    @ReverseMappingMethod
     Source targetToSource(Target target);
 }

File: processor/src/main/java/org/mapstruct/ap/prism/PrismGenerator.java
Patch:
@@ -30,6 +30,7 @@
 import org.mapstruct.Mapping;
 import org.mapstruct.MappingTarget;
 import org.mapstruct.Mappings;
+import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.TargetType;
 
 /**
@@ -47,6 +48,7 @@
     @GeneratePrism(value = MappingTarget.class, publicAccess = true),
     @GeneratePrism(value = DecoratedWith.class, publicAccess = true),
     @GeneratePrism(value = MapperConfig.class, publicAccess = true),
+    @GeneratePrism(value = ReverseMappingMethod.class, publicAccess = true),
 
     // external types
     @GeneratePrism(value = XmlElementDecl.class, publicAccess = true)

File: processor/src/test/java/org/mapstruct/ap/test/collection/CollectionMappingTest.java
Patch:
@@ -131,7 +131,7 @@ public void shouldMapListWithClearAndAddAll() {
         source.setOtherStringList( Arrays.asList( "Bob" ) );
         List<String> originalInstance = target.getOtherStringList();
 
-        SourceTargetMapper.INSTANCE.sourceToTarget( source, target );
+        SourceTargetMapper.INSTANCE.sourceToTargetTwoArg( source, target );
 
         assertThat( target.getOtherStringList() ).isSameAs( originalInstance );
         assertThat( target.getOtherStringList() ).containsExactly( "Bob" );
@@ -359,7 +359,7 @@ public void shouldMapMapWithClearAndPutAll() {
         TestMap.setPuttAllCalled( false );
         target.setOtherStringLongMap( originalInstance );
 
-        SourceTargetMapper.INSTANCE.sourceToTarget( source, target );
+        SourceTargetMapper.INSTANCE.sourceToTargetTwoArg( source, target );
 
         assertThat( target.getOtherStringLongMap() ).isSameAs( originalInstance );
         assertThat( target.getOtherStringLongMap() ).hasSize( 1 );

File: processor/src/test/java/org/mapstruct/ap/test/collection/map/SourceTargetMapper.java
Patch:
@@ -24,6 +24,7 @@
 import org.mapstruct.MapMapping;
 import org.mapstruct.Mapper;
 import org.mapstruct.MappingTarget;
+import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 @Mapper(uses = CustomNumberMapper.class)
@@ -33,7 +34,7 @@ public interface SourceTargetMapper {
 
     @MapMapping(valueDateFormat = "dd.MM.yyyy")
     Map<String, String> longDateMapToStringStringMap(Map<Long, Date> source);
-
+    @ReverseMappingMethod
     Map<Long, Date> stringStringMapToLongDateMap(Map<String, String> source);
 
     @MapMapping(valueDateFormat = "dd.MM.yyyy")
@@ -45,7 +46,7 @@ Map<Long, Date> stringStringMapToLongDateMapUsingTargetParameterAndReturn(Map<St
                                                                               @MappingTarget Map<Long, Date> target);
 
     Target sourceToTarget(Source source);
-
+    @ReverseMappingMethod
     Source targetToSource(Target target);
 
     Map<Number, Number> intIntToNumberNumberMap(Map<Integer, Integer> source);

File: processor/src/test/java/org/mapstruct/ap/test/conversion/SourceTargetMapper.java
Patch:
@@ -21,6 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
+import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -33,6 +34,6 @@ public interface SourceTargetMapper {
         @Mapping(source = "baz", target = "qax")
     })
     Target sourceToTarget(Source source);
-
+    @ReverseMappingMethod
     Source targetToSource(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/date/SourceTargetMapper.java
Patch:
@@ -24,6 +24,7 @@
 import org.mapstruct.IterableMapping;
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
+import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -33,11 +34,11 @@ public interface SourceTargetMapper {
 
     @Mapping(source = "date", dateFormat = "dd.MM.yyyy")
     Target sourceToTarget(Source source);
-
+    @ReverseMappingMethod
     Source targetToSource(Target target);
 
     @IterableMapping(dateFormat = "dd.MM.yyyy")
     List<String> stringListToDateList(List<Date> dates);
-
+    @ReverseMappingMethod
     List<Date> dateListToStringList(List<String> strings);
 }

File: processor/src/test/java/org/mapstruct/ap/test/conversion/jodatime/JodaConversionTest.java
Patch:
@@ -196,7 +196,7 @@ public void testCalendar() {
         src.setDateTimeForCalendarConversion( dateTimeWithCalendar );
         Target target = SourceTargetMapper.INSTANCE.sourceToTarget( src );
         assertThat( target ).isNotNull();
-        assertThat( target.getDateTimeForCalendarConversion() ).isEqualTo( calendar );
+        assertThat( target.getDateTimeForCalendarConversion().getTime() ).isEqualTo( calendar.getTime() );
 
         Source mappedSource = SourceTargetMapper.INSTANCE.targetToSource( target );
         assertThat( mappedSource ).isNotNull();

File: processor/src/test/java/org/mapstruct/ap/test/conversion/jodatime/SourceTargetMapper.java
Patch:
@@ -21,6 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
+import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -44,6 +45,7 @@ public interface SourceTargetMapper {
     })
     Target sourceToTarget(Source source);
 
+    @ReverseMappingMethod(configuredBy = "targetToSource") // TODO: FIXME
     Target sourceToTargetDefaultMapping(Source source);
 
     @Mapping(source = "dateTime", dateFormat = DATE_TIME_FORMAT)
@@ -79,5 +81,6 @@ public interface SourceTargetMapper {
     @Mapping(source = "localTime", dateFormat = LOCAL_TIME_FORMAT)
     Source targetToSourceLocalTimeMapped(Target target);
 
+    @ReverseMappingMethod(configuredBy = "sourceToTarget") // TODO: FIXME
     Source targetToSourceDefaultMapping(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/ignore/AnimalMapper.java
Patch:
@@ -21,6 +21,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.Mappings;
+import org.mapstruct.ReverseMappingMethod;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
@@ -33,6 +34,6 @@ public interface AnimalMapper {
         @Mapping(target = "age", ignore = true)
     })
     AnimalDto animalToDto(Animal animal);
-
+    @ReverseMappingMethod
     Animal animalDtoToAnimal(AnimalDto animalDto);
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/forged/CollectionMappingTest.java
Patch:
@@ -34,7 +34,7 @@
  *
  * @author Sjaak Derksen
  */
-@IssueKey("4")
+@IssueKey("4, 306")
 @RunWith(AnnotationProcessorTestRunner.class)
 public class CollectionMappingTest {
 

File: processor/src/test/java/org/mapstruct/ap/test/source/constants/SourceConstantsTest.java
Patch:
@@ -43,7 +43,7 @@
 public class SourceConstantsTest {
 
     @Test
-    @IssueKey("187")
+    @IssueKey("187, 305")
     @WithClasses({
         Source.class,
         Source2.class,

File: processor/src/main/java/org/mapstruct/ap/MappingProcessor.java
Patch:
@@ -137,7 +137,7 @@ public boolean process(final Set<? extends TypeElement> annotations, final Round
 
                 // on some JDKs, RoundEnvironment.getElementsAnnotatedWith( ... ) returns types with
                 // annotations unknown to the compiler, even though they are not declared Mappers
-                if ( MapperPrism.getInstanceOn( mapperTypeElement ) == null ) {
+                if ( mapperTypeElement == null || MapperPrism.getInstanceOn( mapperTypeElement ) == null ) {
                     continue;
                 }
 

File: processor/src/main/java/org/mapstruct/ap/model/source/Mapping.java
Patch:
@@ -235,7 +235,7 @@ public AnnotationValue getTargetAnnotationValue() {
     public Mapping reverse() {
         Mapping reverse = null;
         // mapping can only be reversed if the source was not a constant nor an expression
-        if ( constant != null && expression != null ) {
+        if ( constant.isEmpty() && expression.isEmpty() ) {
             reverse = new Mapping(
                 targetName,
                 null,

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/StringToXmlGregorianCalendar.java
Patch:
@@ -21,7 +21,6 @@
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
-import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.Set;
 import javax.xml.datatype.DatatypeConfigurationException;
@@ -50,7 +49,6 @@ public StringToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.returnType = typeFactory.getType( XMLGregorianCalendar.class );
         this.importTypes = asSet(
             returnType,
-            typeFactory.getType( Date.class ),
             typeFactory.getType( GregorianCalendar.class ),
             typeFactory.getType( SimpleDateFormat.class ),
             typeFactory.getType( DateFormat.class ),

File: processor/src/test/java/org/mapstruct/ap/test/builtin/mapper/IterableSourceTargetMapper.java
Patch:
@@ -16,8 +16,10 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.mapper;
 
+import org.mapstruct.ap.test.builtin.target.IterableTarget;
+import org.mapstruct.ap.test.builtin.source.IterableSource;
 import java.util.List;
 
 import javax.xml.datatype.XMLGregorianCalendar;

File: processor/src/test/java/org/mapstruct/ap/test/builtin/mapper/MapSourceTargetMapper.java
Patch:
@@ -16,8 +16,10 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.mapper;
 
+import org.mapstruct.ap.test.builtin.target.MapTarget;
+import org.mapstruct.ap.test.builtin.source.MapSource;
 import java.util.Map;
 
 import javax.xml.bind.JAXBElement;

File: processor/src/test/java/org/mapstruct/ap/test/builtin/mapper/SourceTargetWithDateMapper.java
Patch:
@@ -16,8 +16,10 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.mapper;
 
+import org.mapstruct.ap.test.builtin.target.TargetWithDate;
+import org.mapstruct.ap.test.builtin.source.SourceWithDate;
 import org.mapstruct.Mapper;
 import org.mapstruct.factory.Mappers;
 

File: processor/src/test/java/org/mapstruct/ap/test/builtin/source/IterableSource.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.source;
 
 import java.util.List;
 

File: processor/src/test/java/org/mapstruct/ap/test/builtin/source/MapSource.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.source;
 
 import java.util.Map;
 

File: processor/src/test/java/org/mapstruct/ap/test/builtin/source/SourceWithDate.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.source;
 
 import java.util.Date;
 

File: processor/src/test/java/org/mapstruct/ap/test/builtin/target/IterableTarget.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.target;
 
 import java.util.List;
 

File: processor/src/test/java/org/mapstruct/ap/test/builtin/target/MapTarget.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.target;
 
 import java.util.Map;
 

File: processor/src/test/java/org/mapstruct/ap/test/builtin/target/TargetWithDate.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.builtin;
+package org.mapstruct.ap.test.builtin.target;
 
 import javax.xml.datatype.XMLGregorianCalendar;
 

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/CalendarToXmlGregorianCalendar.java
Patch:
@@ -46,6 +46,7 @@ public CalendarToXmlGregorianCalendar(TypeFactory typeFactory) {
 
         this.importTypes = asSet(
             returnType,
+            parameter.getType(),
             typeFactory.getType( DatatypeFactory.class ),
             typeFactory.getType( GregorianCalendar.class ),
             typeFactory.getType( DatatypeConfigurationException.class )

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/XmlGregorianCalendarToCalendar.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.Calendar;
 import java.util.Set;
+
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.model.common.Parameter;
@@ -40,7 +41,7 @@ public class XmlGregorianCalendarToCalendar extends BuiltInMethod {
     public XmlGregorianCalendarToCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
         this.returnType = typeFactory.getType( Calendar.class );
-        this.importTypes = asSet( returnType, typeFactory.getType( XMLGregorianCalendar.class ) );
+        this.importTypes = asSet( returnType, parameter.getType() );
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/XmlGregorianCalendarToDate.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.Date;
 import java.util.Set;
+
 import javax.xml.datatype.XMLGregorianCalendar;
 
 import org.mapstruct.ap.model.common.Parameter;
@@ -40,7 +41,7 @@ public class XmlGregorianCalendarToDate extends BuiltInMethod {
     public XmlGregorianCalendarToDate(TypeFactory typeFactory) {
         this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
         this.returnType = typeFactory.getType( Date.class );
-        this.importTypes = asSet( returnType, typeFactory.getType( XMLGregorianCalendar.class ) );
+        this.importTypes = asSet( returnType, parameter.getType() );
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/XmlGregorianCalendarToString.java
Patch:
@@ -43,7 +43,7 @@ public XmlGregorianCalendarToString(TypeFactory typeFactory) {
         this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
         this.returnType = typeFactory.getType( String.class );
         this.importTypes = asSet(
-            typeFactory.getType( XMLGregorianCalendar.class ),
+            parameter.getType(),
             typeFactory.getType( Date.class ),
             typeFactory.getType( SimpleDateFormat.class )
         );

File: processor/src/test/java/org/mapstruct/ap/test/nullcheck/NullCheckTest.java
Patch:
@@ -18,14 +18,13 @@
  */
 package org.mapstruct.ap.test.nullcheck;
 
+import static org.fest.assertions.Assertions.assertThat;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mapstruct.ap.testutil.IssueKey;
 import org.mapstruct.ap.testutil.WithClasses;
 import org.mapstruct.ap.testutil.runner.AnnotationProcessorTestRunner;
 
-import static org.fest.assertions.Assertions.assertThat;
-
 /**
  * Test for correct handling of null checks.
  *

File: processor/src/main/java/org/mapstruct/ap/conversion/Conversions.java
Patch:
@@ -28,6 +28,7 @@
 
 import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.common.TypeFactory;
+import org.mapstruct.ap.util.JavaTimeConstants;
 import org.mapstruct.ap.util.NativeTypes;
 
 import static org.mapstruct.ap.conversion.ReverseConversion.reverse;

File: processor/src/test/java/org/mapstruct/ap/test/abstractclass/SourceTargetMapper.java
Patch:
@@ -25,7 +25,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.factory.Mappers;
 
-@Mapper
+@Mapper( uses = ReferencedMapper.class )
 public abstract class SourceTargetMapper extends AbstractBaseMapper {
 
     public static final SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
@@ -34,6 +34,6 @@ public abstract class SourceTargetMapper extends AbstractBaseMapper {
 
     protected String calendarToString(Calendar calendar) {
         DateFormat format = new SimpleDateFormat( "dd.MM.yyyy" );
-        return format.format( calendar.getTime() );
+        return "Birthday: " + format.format( calendar.getTime() );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/DateToXmlGregorianCalendar.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.Set;
+
 import javax.xml.datatype.DatatypeConfigurationException;
 import javax.xml.datatype.DatatypeFactory;
 import javax.xml.datatype.XMLGregorianCalendar;
@@ -46,6 +47,7 @@ public DateToXmlGregorianCalendar(TypeFactory typeFactory) {
 
         this.importTypes = asSet(
             returnType,
+            parameter.getType(),
             typeFactory.getType( GregorianCalendar.class ),
             typeFactory.getType( DatatypeFactory.class ),
             typeFactory.getType( DatatypeConfigurationException.class )

File: core-common/src/main/java/org/mapstruct/factory/Mappers.java
Patch:
@@ -54,7 +54,7 @@ private Mappers() {
      * Returns an instance of the given mapper type.
      *
      * @param clazz The type of the mapper to return.
-     *
+     * @param <T> The type of the mapper to create.
      * @return An instance of the given mapper type.
      */
     public static <T> T getMapper(Class<T> clazz) {

File: core-jdk8/src/main/java/org/mapstruct/Mapping.java
Patch:
@@ -40,7 +40,7 @@
      * The source to use for this Mapping. This can either be:
      * <ol>
      * <li>The source name of the configured property as defined by the JavaBeans specification.</li>
-     * <li>When used to map an enum constant, the name of the constant member is to be given<./li>.
+     * <li>When used to map an enum constant, the name of the constant member is to be given.</li>
      * </ol>
      * Either this attribute or {@link #constant()} or {@link #expression()} may be specified for a given mapping,
      * but not two at the same time. If this attribute is given, the target property must be specified via

File: core/src/main/java/org/mapstruct/Mapping.java
Patch:
@@ -38,7 +38,7 @@
      * The source to use for this Mapping. This can either be:
      * <ol>
      * <li>The source name of the configured property as defined by the JavaBeans specification.</li>
-     * <li>When used to map an enum constant, the name of the constant member is to be given<./li>.
+     * <li>When used to map an enum constant, the name of the constant member is to be given.</li>
      * </ol>
      * Either this attribute or {@link #constant()} or {@link #expression()} may be specified for a given mapping,
      * but not two at the same time. If this attribute is given, the target property must be specified via

File: processor/src/main/java/org/mapstruct/ap/MappingProcessor.java
Patch:
@@ -39,6 +39,7 @@
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.tools.Diagnostic.Kind;
 
+import org.mapstruct.ap.model.Mapper;
 import org.mapstruct.ap.option.Options;
 import org.mapstruct.ap.option.ReportingPolicy;
 import org.mapstruct.ap.processor.DefaultModelElementProcessorContext;

File: processor/src/main/java/org/mapstruct/ap/conversion/ConversionProvider.java
Patch:
@@ -19,6 +19,7 @@
 package org.mapstruct.ap.conversion;
 
 import org.mapstruct.ap.model.Assignment;
+import org.mapstruct.ap.model.assignment.TypeConversion;
 import org.mapstruct.ap.model.common.ConversionContext;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.Set;
 
+import org.mapstruct.ap.model.assignment.TypeConversion;
 import org.mapstruct.ap.model.common.Parameter;
 import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.SourceMethod;

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.util.Set;
 
+import org.mapstruct.ap.model.assignment.TypeConversion;
 import org.mapstruct.ap.model.common.Parameter;
 import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.SourceMethod;

File: processor/src/main/java/org/mapstruct/ap/model/common/ConversionContext.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.mapstruct.ap.model.common;
 
+import java.util.Date;
+
 /**
  * Context object passed to conversion providers and built-in methods.
  *

File: processor/src/main/java/org/mapstruct/ap/processor/ModelElementProcessor.java
Patch:
@@ -98,7 +98,7 @@ public interface ProcessorContext {
      * order from highest to lowest priority, starting with the mapping method
      * retrieval processor (priority 1) and finishing with the code generation
      * processor (priority 10000). Processors working on the built
-     * {@code Mapper} model must have a priority > 1000.
+     * {@code Mapper} model must have a priority &gt; 1000.
      *
      * @return The priority value of this processor.
      */

File: processor/src/test/java/org/mapstruct/ap/test/collection/adder/source/SingleElementSource.java
Patch:
@@ -30,7 +30,7 @@ public String getPet() {
         return pet;
     }
 
-    public void setPet( String pet ) {
+    public void setPet(String pet) {
         this.pet = pet;
     }
 }

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -76,6 +76,7 @@
 
 import static org.mapstruct.ap.model.Assignment.AssignmentType.DIRECT;
 import static org.mapstruct.ap.model.Assignment.AssignmentType.TYPE_CONVERTED;
+import static org.mapstruct.ap.model.Assignment.AssignmentType.TYPE_CONVERTED_MAPPED;
 
 /**
  * A {@link ModelElementProcessor} which creates a {@link Mapper} from the given
@@ -800,6 +801,7 @@ else if ( Executables.isAdderMethod( targetAccessor ) ) {
                     assignment = new SetterWrapper( assignment, method.getThrownTypes() );
                     if ( !sourceType.isPrimitive() &&
                         ( assignment.getType() == TYPE_CONVERTED ||
+                          assignment.getType() == TYPE_CONVERTED_MAPPED ||
                           assignment.getType() == DIRECT && targetType.isPrimitive() ) ) {
                         // for primitive types null check is not possible at all, but a conversion needs
                         // a null check.

File: processor/src/test/java/org/mapstruct/ap/test/npe/SourceTargetMapper.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author Sjaak Derksen
  */
-@Mapper (uses = NullObjectMapper.class)
+@Mapper (uses = { NullObjectMapper.class, MyBigIntMapper.class } )
 public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

File: processor/src/main/java/org/mapstruct/ap/model/assignment/MethodReference.java
Patch:
@@ -23,11 +23,11 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+
 import org.mapstruct.ap.model.Assignment;
 import org.mapstruct.ap.model.FactoryMethod;
 import org.mapstruct.ap.model.MapperReference;
 import org.mapstruct.ap.model.MappingMethod;
-
 import org.mapstruct.ap.model.common.ConversionContext;
 import org.mapstruct.ap.model.common.Parameter;
 import org.mapstruct.ap.model.common.Type;
@@ -74,7 +74,7 @@ public MethodReference(SourceMethod method, MapperReference declaringMapper, Typ
         super( method );
         this.declaringMapper = declaringMapper;
         this.contextParam = null;
-        Set<Type> imported = new HashSet( method.getThrownTypes() );
+        Set<Type> imported = new HashSet<Type>( method.getThrownTypes() );
         if ( targetType != null ) {
             imported.add( targetType );
         }
@@ -130,7 +130,7 @@ public Type getSingleSourceParameterType() {
 
     @Override
     public Set<Type> getImportTypes() {
-        Set<Type> imported = org.mapstruct.ap.util.Collections.asSet( importTypes, super.getImportTypes() );
+        Set<Type> imported = new HashSet<Type>( importTypes );
         if ( assignment != null ) {
             imported.addAll( assignment.getImportTypes() );
         }

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/ReferencedAccessibilityTest.java
Patch:
@@ -84,7 +84,6 @@ public void shouldNotBeAbleToAccessDefaultMethodInReferencedInOtherPackage() thr
     @WithClasses( { AbstractSourceTargetMapperProtected.class, SourceTargetmapperProtectedBase.class } )
     public void shouldBeAbleToAccessProtectedMethodInBase() throws Exception { }
 
-
     @Test
     @IssueKey( "206" )
     @WithClasses( { AbstractSourceTargetMapperPrivate.class, SourceTargetmapperPrivateBase.class } )

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/ReferencedMapperPrivate.java
Patch:
@@ -19,12 +19,12 @@
 package org.mapstruct.ap.test.accessibility.referenced;
 
 /**
- *
  * @author Sjaak Derksen
  */
 public class ReferencedMapperPrivate {
 
-    private ReferencedTarget sourceToTarget( ReferencedSource source ) {
+    @SuppressWarnings("unused")
+    private ReferencedTarget sourceToTarget(ReferencedSource source) {
         ReferencedTarget target = new ReferencedTarget();
         target.setFoo( source.getFoo() );
         return target;

File: processor/src/test/java/org/mapstruct/ap/test/accessibility/referenced/SourceTargetmapperPrivateBase.java
Patch:
@@ -19,12 +19,12 @@
 package org.mapstruct.ap.test.accessibility.referenced;
 
 /**
- *
  * @author Sjaak Derksen
  */
 public class SourceTargetmapperPrivateBase {
 
-    private ReferencedTarget sourceToTarget( ReferencedSource source ) {
+    @SuppressWarnings("unused")
+    private ReferencedTarget sourceToTarget(ReferencedSource source) {
         ReferencedTarget target = new ReferencedTarget();
         target.setFoo( source.getFoo() );
         return target;

File: processor/src/main/java/org/mapstruct/ap/conversion/ReverseConversion.java
Patch:
@@ -40,7 +40,7 @@ private ReverseConversion(ConversionProvider conversionProvider) {
     }
 
     @Override
-    public Assignment to( ConversionContext conversionContext) {
+    public Assignment to(ConversionContext conversionContext) {
         return conversionProvider.from( conversionContext );
     }
 

File: processor/src/test/java/org/mapstruct/ap/test/exceptions/SourceTargetMapper.java
Patch:
@@ -19,6 +19,7 @@
 package org.mapstruct.ap.test.exceptions;
 
 
+import java.text.ParseException;
 import org.mapstruct.ap.test.exceptions.imports.TestExceptionBase;
 import java.util.List;
 import java.util.Map;
@@ -36,7 +37,7 @@ public  interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
-    Target sourceToTarget(Source source) throws TestException2;
+    Target sourceToTarget(Source source) throws TestException2, ParseException;
 
     List<Long> integerListToLongList(List<Integer> sizes) throws TestException2;
 

File: processor/src/main/java/org/mapstruct/ap/model/source/SourceMethod.java
Patch:
@@ -351,7 +351,7 @@ public static boolean containsTargetTypeParameter(List<Parameter> parameters) {
         return false;
     }
 
-    public List<Type> getExceptionTypes() {
+    public List<Type> getThrownTypes() {
         return exceptionTypes;
     }
 }

File: processor/src/test/java/org/mapstruct/ap/test/exceptions/TestException2.java
Patch:
@@ -18,9 +18,11 @@
  */
 package org.mapstruct.ap.test.exceptions;
 
+import org.mapstruct.ap.test.exceptions.imports.TestExceptionBase;
+
 /**
  *
  * @author Sjaak Derksen
  */
-public class TestException2 extends Exception {
+public class TestException2 extends TestExceptionBase {
 }

File: processor/src/test/java/org/mapstruct/ap/test/exceptions/imports/TestException1.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.exceptions;
+package org.mapstruct.ap.test.exceptions.imports;
 
 /**
  *

File: processor/src/main/java/org/mapstruct/ap/processor/MethodRetrievalProcessor.java
Patch:
@@ -145,6 +145,7 @@ private SourceMethod getMethod(TypeElement element,
                                    boolean mapperRequiresImplementation) {
         List<Parameter> parameters = typeFactory.getParameters( method );
         Type returnType = typeFactory.getReturnType( method );
+        List<Type> exceptionTypes = typeFactory.getThrownTypes( method );
 
         //add method with property mappings if an implementation needs to be generated
         boolean methodRequiresImplementation = method.getModifiers().contains( Modifier.ABSTRACT );
@@ -170,6 +171,7 @@ private SourceMethod getMethod(TypeElement element,
                         method,
                         parameters,
                         returnType,
+                        exceptionTypes,
                         getMappings( method ),
                         IterableMapping.fromPrism( IterableMappingPrism.getInstanceOn( method ) ),
                         MapMapping.fromPrism( MapMappingPrism.getInstanceOn( method ) ),
@@ -188,6 +190,7 @@ else if ( isValidReferencedMethod( parameters ) || isValidFactoryMethod( paramet
                     method,
                     parameters,
                     returnType,
+                    exceptionTypes,
                     typeUtils
                 );
         }

File: processor/src/main/java/org/mapstruct/ap/conversion/BigDecimalToBigIntegerConversion.java
Patch:
@@ -35,12 +35,12 @@
 public class BigDecimalToBigIntegerConversion extends SimpleConversion {
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", ".toBigInteger()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression("new BigDecimal( ", " )");
     }
 

File: processor/src/main/java/org/mapstruct/ap/conversion/BigDecimalToPrimitiveConversion.java
Patch:
@@ -44,12 +44,12 @@ public BigDecimalToPrimitiveConversion(Class<?> targetType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", "." + targetType.getName() + "Value()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "BigDecimal.valueOf( ", " )" );
     }
 

File: processor/src/main/java/org/mapstruct/ap/conversion/BigDecimalToStringConversion.java
Patch:
@@ -34,12 +34,12 @@
 public class BigDecimalToStringConversion extends SimpleConversion {
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", ".toString()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "new BigDecimal( ", " )" );
     }
 

File: processor/src/main/java/org/mapstruct/ap/conversion/BigDecimalToWrapperConversion.java
Patch:
@@ -45,12 +45,12 @@ public BigDecimalToWrapperConversion(Class<?> targetType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", "." + targetType.getName() + "Value()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "BigDecimal.valueOf( ",  " )" );
     }
 

File: processor/src/main/java/org/mapstruct/ap/conversion/BigIntegerToPrimitiveConversion.java
Patch:
@@ -44,12 +44,12 @@ public BigIntegerToPrimitiveConversion(Class<?> targetType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", "." + targetType.getName() + "Value()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         String castString = "";
         if ( targetType == float.class || targetType == double.class ) {
             castString = "(long) ";

File: processor/src/main/java/org/mapstruct/ap/conversion/BigIntegerToStringConversion.java
Patch:
@@ -34,12 +34,12 @@
 public class BigIntegerToStringConversion extends SimpleConversion {
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", ".toString()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "new BigInteger( ", " )" );
     }
 

File: processor/src/main/java/org/mapstruct/ap/conversion/BigIntegerToWrapperConversion.java
Patch:
@@ -45,12 +45,12 @@ public BigIntegerToWrapperConversion(Class<?> targetType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", "." + targetType.getName() + "Value()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
 
         String toLongValueStr = "";
         if ( targetType == float.class || targetType == double.class ) {

File: processor/src/main/java/org/mapstruct/ap/conversion/CharToStringConversion.java
Patch:
@@ -28,12 +28,12 @@
 public class CharToStringConversion extends SimpleConversion {
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "String.valueOf( ", " )" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", ".charAt( 0 )" );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/conversion/CharWrapperToStringConversion.java
Patch:
@@ -28,12 +28,12 @@
 public class CharWrapperToStringConversion extends SimpleConversion {
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", ".toString()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", ".charAt( 0 )" );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/conversion/DateToStringConversion.java
Patch:
@@ -28,6 +28,7 @@
 import org.mapstruct.ap.model.common.Type;
 
 import static org.mapstruct.ap.util.Collections.asSet;
+import static java.util.Arrays.asList;
 
 /**
  * Conversion between {@link String} and {@link Date}.
@@ -40,7 +41,7 @@ public class DateToStringConversion implements ConversionProvider {
     public Assignment to(ConversionContext conversionContext) {
         return AssignmentFactory.createTypeConversion(
             asSet( conversionContext.getTypeFactory().getType( SimpleDateFormat.class ) ),
-            Collections.<Type>emptySet(),
+            Collections.<Type>emptyList(),
             getOpenExpression( conversionContext, "format" ),
             getCloseExpression() );
 
@@ -50,7 +51,7 @@ public Assignment to(ConversionContext conversionContext) {
     public Assignment from(ConversionContext conversionContext) {
         return AssignmentFactory.createTypeConversion(
             asSet( conversionContext.getTypeFactory().getType( SimpleDateFormat.class ) ),
-            asSet( conversionContext.getTypeFactory().getType( ParseException.class ) ),
+            asList( conversionContext.getTypeFactory().getType( ParseException.class ) ),
             getOpenExpression( conversionContext, "parse" ),
             getCloseExpression()
         );

File: processor/src/main/java/org/mapstruct/ap/conversion/EnumStringConversion.java
Patch:
@@ -33,12 +33,12 @@
 public class EnumStringConversion extends SimpleConversion {
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression("", ".toString()" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression(
                 "Enum.valueOf( " + conversionContext.getTargetType().getName() + ".class, ",
                 " )" );

File: processor/src/main/java/org/mapstruct/ap/conversion/PrimitiveToPrimitiveConversion.java
Patch:
@@ -38,12 +38,12 @@ public PrimitiveToPrimitiveConversion(Class<?> sourceType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return ConversionExpression.empty();
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "(" + sourceType + ") ", "" );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/conversion/PrimitiveToStringConversion.java
Patch:
@@ -43,12 +43,12 @@ public PrimitiveToStringConversion(Class<?> sourceType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "String.valueOf( ", " )" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( wrapperType.getSimpleName() + ".parse" +
                 Strings.capitalize( sourceType.getSimpleName() ) + "( ",  " )" );
     }

File: processor/src/main/java/org/mapstruct/ap/conversion/PrimitiveToWrapperConversion.java
Patch:
@@ -45,7 +45,7 @@ public PrimitiveToWrapperConversion(Class<?> sourceType, Class<?> targetType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         if ( sourceType == targetType ) {
             return ConversionExpression.empty();
         }
@@ -55,7 +55,7 @@ public ConversionExpression getToExpressions(ConversionContext conversionContext
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "", "." + sourceType.getName() + "Value()" );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/conversion/WrapperToStringConversion.java
Patch:
@@ -42,12 +42,12 @@ public WrapperToStringConversion(Class<?> sourceType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         return new ConversionExpression( "String.valueOf( ", " )" );
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         return new ConversionExpression( sourceType.getSimpleName() + ".parse" +
                 Strings.capitalize( primitiveType.getSimpleName() ) + "( ", " )" );
     }

File: processor/src/main/java/org/mapstruct/ap/conversion/WrapperToWrapperConversion.java
Patch:
@@ -44,7 +44,7 @@ public WrapperToWrapperConversion(Class<?> sourceType, Class<?> targetType) {
     }
 
     @Override
-    public ConversionExpression getToExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getToExpression(ConversionContext conversionContext) {
         if ( sourceType == targetType ) {
             return ConversionExpression.empty();
         }
@@ -54,7 +54,7 @@ public ConversionExpression getToExpressions(ConversionContext conversionContext
     }
 
     @Override
-    public ConversionExpression getFromExpressions(ConversionContext conversionContext) {
+    public ConversionExpression getFromExpression(ConversionContext conversionContext) {
         if ( sourceType == targetType ) {
             return ConversionExpression.empty();
         }

File: processor/src/main/java/org/mapstruct/ap/model/Assignment.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.mapstruct.ap.model;
 
+import java.util.List;
 import java.util.Set;
 import org.mapstruct.ap.model.common.Type;
 
@@ -40,7 +41,7 @@ public interface Assignment {
      *
      * @return exceptions thrown
      */
-     Set<Type> getExceptionTypes();
+     List<Type> getExceptionTypes();
 
      /**
       * An assignment in itself can wrap another assignment. E.g.:

File: processor/src/main/java/org/mapstruct/ap/model/FactoryMethod.java
Patch:
@@ -18,7 +18,7 @@
  */
 package org.mapstruct.ap.model;
 
-import java.util.Set;
+import java.util.List;
 import org.mapstruct.ap.model.common.Type;
 
 /**
@@ -28,6 +28,6 @@
  */
 public interface FactoryMethod {
 
-     Set<Type> getExceptionTypes();
+     List<Type> getExceptionTypes();
 
 }

File: processor/src/main/java/org/mapstruct/ap/model/assignment/AssignmentFactory.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.mapstruct.ap.model.assignment;
 
+import java.util.List;
 import java.util.Set;
 import org.mapstruct.ap.model.Assignment;
 import org.mapstruct.ap.model.FactoryMethod;
@@ -38,7 +39,7 @@ private AssignmentFactory() {
     }
 
     public static Assignment createTypeConversion( Set<Type> importTypes,
-            Set<Type> exceptionTypes,
+            List<Type> exceptionTypes,
             String openExpression,
             String closeExpression ) {
         return new TypeConversion( importTypes, exceptionTypes, openExpression, closeExpression );

File: processor/src/main/java/org/mapstruct/ap/model/assignment/AssignmentWrapper.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.mapstruct.ap.model.assignment;
 
+import java.util.List;
 import java.util.Set;
 import org.mapstruct.ap.model.Assignment;
 import org.mapstruct.ap.model.common.ModelElement;
@@ -42,7 +43,7 @@ public Set<Type> getImportTypes() {
     }
 
     @Override
-    public Set<Type> getExceptionTypes() {
+    public List<Type> getExceptionTypes() {
         return decoratedAssignment.getExceptionTypes();
     }
 

File: processor/src/main/java/org/mapstruct/ap/model/BeanMappingMethod.java
Patch:
@@ -38,11 +38,11 @@
 public class BeanMappingMethod extends MappingMethod {
 
     private final List<PropertyMapping> propertyMappings;
-    private final MethodReference factoryMethod;
+    private final Factory factoryMethod;
 
     public BeanMappingMethod(SourceMethod method,
                              List<PropertyMapping> propertyMappings,
-                             MethodReference factoryMethod) {
+                             Factory factoryMethod) {
         super( method );
         this.propertyMappings = propertyMappings;
         this.factoryMethod = factoryMethod;
@@ -78,7 +78,7 @@ public Set<Type> getImportTypes() {
         return types;
     }
 
-    public MethodReference getFactoryMethod() {
+    public Factory getFactoryMethod() {
         return this.factoryMethod;
     }
 

File: processor/src/main/java/org/mapstruct/ap/model/common/TypeFactory.java
Patch:
@@ -162,7 +162,7 @@ public Type getType(TypeMirror mirror) {
         }
 
         return new Type(
-            typeUtils,
+            typeUtils, elementUtils,
             mirror,
             typeElement,
             getTypeParameters( mirror ),
@@ -283,6 +283,7 @@ private Type getImplementationType(TypeMirror mirror) {
         if ( implementationType != null ) {
             return new Type(
                 typeUtils,
+                elementUtils,
                 typeUtils.getDeclaredType(
                     implementationType.getTypeElement(),
                     declaredType.getTypeArguments().toArray( new TypeMirror[] { } )

File: core/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -45,7 +45,7 @@
     /**
      * How unmapped properties of the target type of a mapping should be
      * reported. The method overrides an unmappedTargetPolicy set in a central
-     * configuration set by {@link #mapperConfig() }
+     * configuration set by {@link #config() }
      *
      * @return The reporting policy for unmapped target properties.
      */
@@ -68,7 +68,7 @@
      * can be retrieved via {@code @Inject}</li>
      * </ul>
      * The method overrides an unmappedTargetPolicy set in a central configuration set
-     * by {@link #mapperConfig() }
+     * by {@link #config() }
 
 * @return The component model for the generated mapper.
      */
@@ -79,6 +79,6 @@
      *
      * @return a centralized class with {@link MapperConfig} annotation.
      */
-    Class<?> mapperConfig() default void.class;
+    Class<?> config() default void.class;
 
 }

File: processor/src/main/java/org/mapstruct/ap/processor/AnnotationBasedComponentModelProcessor.java
Patch:
@@ -27,7 +27,7 @@
 import org.mapstruct.ap.model.MapperReference;
 import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.option.OptionsHelper;
-import org.mapstruct.ap.util.MapperSettings;
+import org.mapstruct.ap.util.MapperConfig;
 
 /**
  * An {@link ModelElementProcessor} which converts the given {@link Mapper}
@@ -45,7 +45,7 @@ public abstract class AnnotationBasedComponentModelProcessor implements ModelEle
     public Mapper process(ProcessorContext context, TypeElement mapperTypeElement, Mapper mapper) {
         this.typeFactory = context.getTypeFactory();
 
-        String componentModel = MapperSettings.getInstanceOn( mapperTypeElement ).componentModel();
+        String componentModel = MapperConfig.getInstanceOn( mapperTypeElement ).componentModel();
         String effectiveComponentModel = OptionsHelper.getEffectiveComponentModel(
             context.getOptions(),
             componentModel

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -71,7 +71,7 @@
 import org.mapstruct.ap.prism.MapperPrism;
 import org.mapstruct.ap.util.Executables;
 import org.mapstruct.ap.util.Filters;
-import org.mapstruct.ap.util.MapperSettings;
+import org.mapstruct.ap.util.MapperConfig;
 import org.mapstruct.ap.util.Strings;
 
 /**
@@ -152,7 +152,7 @@ private Mapper getMapper(TypeElement element, List<SourceMethod> methods) {
      * @return The effective policy for reporting unmapped getReturnType properties.
      */
     private ReportingPolicy getEffectiveUnmappedTargetPolicy(TypeElement element) {
-        MapperSettings mapperSettings = MapperSettings.getInstanceOn( element );
+        MapperConfig mapperSettings = MapperConfig.getInstanceOn( element );
         boolean setViaAnnotation = mapperSettings.isSetUnmappedTargetPolicy();
         ReportingPolicy annotationValue = ReportingPolicy.valueOf( mapperSettings.unmappedTargetPolicy() );
 
@@ -244,7 +244,7 @@ private List<MapperReference> getReferencedMappers(TypeElement element) {
         List<MapperReference> mapperReferences = new LinkedList<MapperReference>();
         List<String> variableNames = new LinkedList<String>();
 
-        MapperSettings mapperPrism = MapperSettings.getInstanceOn( element );
+        MapperConfig mapperPrism = MapperConfig.getInstanceOn( element );
 
         for ( TypeMirror usedMapper : mapperPrism.uses() ) {
             DefaultMapperReference mapperReference = DefaultMapperReference.getInstance(

File: processor/src/main/java/org/mapstruct/ap/processor/MethodRetrievalProcessor.java
Patch:
@@ -48,7 +48,7 @@
 import org.mapstruct.ap.prism.MappingPrism;
 import org.mapstruct.ap.prism.MappingsPrism;
 import org.mapstruct.ap.util.AnnotationProcessingException;
-import org.mapstruct.ap.util.MapperSettings;
+import org.mapstruct.ap.util.MapperConfig;
 
 /**
  * A {@link ModelElementProcessor} which retrieves a list of {@link SourceMethod}s
@@ -99,7 +99,7 @@ private List<SourceMethod> retrieveMethods(TypeElement element, boolean mapperRe
 
         //Add all methods of used mappers in order to reference them in the aggregated model
         if ( mapperRequiresImplementation ) {
-            MapperSettings mapperSettings = MapperSettings.getInstanceOn( element );
+            MapperConfig mapperSettings = MapperConfig.getInstanceOn( element );
             if ( !mapperSettings.isValid() ) {
                 throw new AnnotationProcessingException(
                     "Couldn't retrieve @Mapper annotation", element, mapperSettings.getAnnotationMirror()

File: processor/src/test/java/org/mapstruct/ap/test/mapperconfig/SourceTargetMapper.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author Sjaak Derksen
  */
-@Mapper(uses = { CustomMapperViaMapper.class }, mapperConfig = CentralConfig.class )
+@Mapper(uses = { CustomMapperViaMapper.class }, config = CentralConfig.class )
 public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );

File: processor/src/test/java/org/mapstruct/ap/test/mapperconfig/SourceTargetMapperError.java
Patch:
@@ -25,7 +25,7 @@
  *
  * @author Sjaak Derksen
  */
-@Mapper(uses = { CustomMapperViaMapper.class }, mapperConfig = CentralConfig.class )
+@Mapper(uses = { CustomMapperViaMapper.class }, config = CentralConfig.class )
 public interface SourceTargetMapperError {
 
     SourceTargetMapperError INSTANCE = Mappers.getMapper( SourceTargetMapperError.class );

File: processor/src/test/java/org/mapstruct/ap/test/mapperconfig/SourceTargetMapperWarn.java
Patch:
@@ -27,7 +27,7 @@
  * @author Sjaak Derksen
  */
 @Mapper(uses = { CustomMapperViaMapper.class },
-        mapperConfig = CentralConfig.class,
+        config = CentralConfig.class,
         unmappedTargetPolicy = ReportingPolicy.WARN
 )
 public interface SourceTargetMapperWarn {

File: core/src/main/java/org/mapstruct/MapperConfig.java
Patch:
@@ -26,15 +26,14 @@
 import org.mapstruct.factory.Mappers;
 
 /**
- * Marks an interface as mapper interface and activates the generation of a
- * mapper implementation for that interface.
+ * Marks a class-, interface-, enum declaration or package declaration as (common) configuration.
  *
  * The {@link #unmappedTargetPolicy() } and {@link #componentModel() } an be overruled by a specific {@link Mapper}
  * annotation. {@link #uses() } will be used in addition to what is specified in the {@link Mapper} annotation.
  *
  * @author Sjaak Derksen
  */
-@Target(ElementType.TYPE)
+@Target( { ElementType.TYPE, ElementType.PACKAGE } )
 @Retention(RetentionPolicy.SOURCE)
 public @interface MapperConfig {
 

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/JaxbElemToValue.java
Patch:
@@ -41,7 +41,7 @@ public JaxbElemToValue(TypeFactory typeFactory) {
     public boolean doTypeVarsMatch(Type sourceType, Type targetType) {
         boolean match = false;
         if ( sourceType.getTypeParameters().size() == 1 ) {
-            match = sourceType.getTypeParameters().get( 0 ).equals( targetType );
+            match = sourceType.getTypeParameters().get( 0 ).isAssignableTo( targetType );
         }
         return match;
     }

File: processor/src/test/java/org/mapstruct/ap/test/decorator/DecoratorTest.java
Patch:
@@ -137,7 +137,7 @@ public void shouldApplyDelegateToClassBasedMapper() {
         EmployerDto.class,
         EmployerMapper.class,
         SportsClub.class,
-        SportsClubDto.class,
+        SportsClubDto.class
     })
     public void shouldApplyCustomMappers() {
         //given

File: processor/src/test/java/org/mapstruct/ap/test/enums/EnumMappingTest.java
Patch:
@@ -113,7 +113,7 @@ public void shouldRaiseErrorIfUnknownEnumConstantsAreSpecifiedInMapping() {
                 kind = Kind.ERROR,
                 line = 34,
                 messageRegExp = "The following constants from the source enum have no corresponding constant in the " +
-                    "target enum and must be be mapped via @Mapping: EXTRA, STANDARD, NORMAL"),
+                    "target enum and must be be mapped via @Mapping: EXTRA, STANDARD, NORMAL")
         }
     )
     public void shouldRaiseErrorIfSourceConstantWithoutMatchingConstantInTargetTypeIsNotMapped() {

File: processor/src/test/java/org/mapstruct/ap/test/enums/ErroneousOrderMapperUsingUnknownEnumConstants.java
Patch:
@@ -35,7 +35,7 @@ public interface ErroneousOrderMapperUsingUnknownEnumConstants {
 
     @Mappings({
         @Mapping(source = "FOO", target = "SPECIAL"),
-        @Mapping(source = "EXTRA", target = "BAR"),
+        @Mapping(source = "EXTRA", target = "BAR")
     })
     ExternalOrderType orderTypeToExternalOrderType(OrderType orderType);
 }

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/ambiguousfactorymethod/FactoryTest.java
Patch:
@@ -45,11 +45,11 @@ public class FactoryTest extends MapperTestBase {
             @Diagnostic(type = BarFactory.class,
                 kind = javax.tools.Diagnostic.Kind.ERROR,
                 line = 29,
-                messageRegExp = "^Ambiguous factory methods: \"org\\.mapstruct\\.ap\\.test\\.erroneous\\."
+                messageRegExp = "Ambiguous factory methods: \"org\\.mapstruct\\.ap\\.test\\.erroneous\\."
                     + "ambiguousfactorymethod\\.Bar createBar\\(\\)\" conflicts with "
                     + "\"org\\.mapstruct\\.ap\\.test\\.erroneous\\.ambiguousfactorymethod\\.Bar "
                     + "org\\.mapstruct\\.ap\\.test\\.erroneous\\.ambiguousfactorymethod"
-                    + "\\.a\\.BarFactory\\.createBar\\(\\)\"\\.$")
+                    + "\\.a\\.BarFactory\\.createBar\\(\\)\"\\")
         }
     )
     public void shouldUseTwoFactoryMethods() {

File: core/src/main/java/org/mapstruct/DecoratedWith.java
Patch:
@@ -41,7 +41,7 @@
  * @author Gunnar Morling
  */
 @Target(ElementType.TYPE)
-@Retention(RetentionPolicy.RUNTIME)
+@Retention(RetentionPolicy.SOURCE)
 public @interface DecoratedWith {
 
     /**

File: processor/src/main/java/org/mapstruct/ap/model/AnnotationMapperReference.java
Patch:
@@ -44,6 +44,6 @@ public Annotation getAnnotation() {
 
     @Override
     public Set<Type> getImportTypes() {
-        return Collections.asSet( annotation.getImportTypes(), super.getMapperType() );
+        return Collections.asSet( annotation.getImportTypes(), super.getType() );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/processor/AnnotationBasedComponentModelProcessor.java
Patch:
@@ -74,7 +74,7 @@ public Mapper process(ProcessorContext context, TypeElement mapperTypeElement, M
      */
     protected MapperReference replacementMapperReference(MapperReference originalReference) {
         return new AnnotationMapperReference(
-            originalReference.getMapperType(),
+            originalReference.getType(),
             originalReference.getVariableName(),
             getMapperReferenceAnnotation()
         );

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -1155,7 +1155,7 @@ private MethodReference getMappingMethodReference(SourceMethod method, List<Mapp
 
     private MapperReference findMapperReference(List<MapperReference> mapperReferences, SourceMethod method) {
         for ( MapperReference ref : mapperReferences ) {
-            if ( ref.getMapperType().equals( method.getDeclaringMapper() ) ) {
+            if ( ref.getType().equals( method.getDeclaringMapper() ) ) {
                 return ref;
             }
         }

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -1075,7 +1075,7 @@ private MethodReference getMappingMethodReferenceBasedOnParameter(SourceMethod m
                     mappedElement,
                     mapperReferences,
                     methods,
-                    methodYCandidate.getParameters().get( 0 ).getType(),
+                    methodYCandidate.getSourceParameters().get( 0 ).getType(),
                     returnType,
                     targetPropertyName,
                     dateFormat

File: core/src/main/java/org/mapstruct/MappingTarget.java
Patch:
@@ -25,9 +25,6 @@
  * Declares a parameter of a mapping method to be the target of the mapping.
  * <p>
  * Not more than one parameter can be declared as {@code MappingTarget}.
- * <p>
- * For methods with return type {@code void}, the last parameter of the method is regarded as {@code MappingTarget},
- * unless another parameter carries this annotation.
  *
  * @author Andreas Gudian
  */

File: processor/src/main/java/org/mapstruct/ap/model/common/Type.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
+
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;

File: processor/src/main/java/org/mapstruct/ap/prism/PrismGenerator.java
Patch:
@@ -27,6 +27,7 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.Mapping;
 import org.mapstruct.MappingTarget;
+import org.mapstruct.TargetType;
 import org.mapstruct.Mappings;
 
 /**
@@ -40,6 +41,7 @@
     @GeneratePrism(value = Mappings.class, publicAccess = true),
     @GeneratePrism(value = IterableMapping.class, publicAccess = true),
     @GeneratePrism(value = MapMapping.class, publicAccess = true),
+    @GeneratePrism(value = TargetType.class, publicAccess = true),
     @GeneratePrism(value = MappingTarget.class, publicAccess = true),
 
     // external types

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/typemismatch/ErroneousMapper.java
Patch:
@@ -19,6 +19,7 @@
 package org.mapstruct.ap.test.erroneous.typemismatch;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.TargetType;
 
 @Mapper
 public interface ErroneousMapper {
@@ -30,4 +31,6 @@ public interface ErroneousMapper {
     long sourceToLong(Source source);
 
     Source longToSource(long id);
+
+    Target sourceToTargetWithMappingTargetType(Source source, @TargetType Class<?> clazz);
 }

File: processor/src/test/java/org/mapstruct/ap/test/factories/Bar1.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * @author Sjaak Derksen
  */
-public class Bar1 {
+public class Bar1 implements FactoryCreatable {
     private String prop;
 
     private final String someTypeProp;

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/StringToXmlGregorianCalendar.java
Patch:
@@ -21,6 +21,7 @@
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
+import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.Set;
 import javax.xml.datatype.DatatypeConfigurationException;
@@ -48,6 +49,7 @@ public StringToXmlGregorianCalendar(TypeFactory typeFactory) {
         this.parameter = new Parameter( "date", typeFactory.getType( String.class ) );
         this.returnType = typeFactory.getType( XMLGregorianCalendar.class );
         this.importTypes = asSet(
+            typeFactory.getType( Date.class ),
             typeFactory.getType( GregorianCalendar.class ),
             typeFactory.getType( SimpleDateFormat.class ),
             typeFactory.getType( DateFormat.class ),

File: processor/src/test/java/org/mapstruct/ap/test/jaxb/selection/test2/OrderShippingDetailsType.java
Patch:
@@ -34,10 +34,10 @@
 public class OrderShippingDetailsType {
 
     @XmlElementRef(name = "orderShippedFrom",
-            namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", type = JAXBElement.class)
+        namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", type = JAXBElement.class)
     private JAXBElement<String> orderShippedFrom;
     @XmlElementRef(name = "orderShippedTo",
-            namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", type = JAXBElement.class)
+        namespace = "http://www.mapstruct.org/ap/test/jaxb/selection/test2", type = JAXBElement.class)
     private JAXBElement<String> orderShippedTo;
 
     public JAXBElement<String> getOrderShippedFrom() {

File: processor/src/test/java/org/mapstruct/ap/test/enums/ErroneousOrderMapperMappingSameConstantTwice.java
Patch:
@@ -36,6 +36,8 @@ public interface ErroneousOrderMapperMappingSameConstantTwice {
     @Mappings({
         @Mapping(source = "EXTRA", target = "SPECIAL"),
         @Mapping(source = "EXTRA", target = "DEFAULT"),
+        @Mapping(source = "STANDARD", target = "DEFAULT"),
+        @Mapping(source = "NORMAL", target = "DEFAULT")
     })
     ExternalOrderType orderTypeToExternalOrderType(OrderType orderType);
 }

File: processor/src/main/java/org/mapstruct/ap/model/source/builtin/XmlGregorianCalendarToString.java
Patch:
@@ -26,16 +26,15 @@
 import org.mapstruct.ap.model.common.TypeFactory;
 
 /**
- *
  * @author Sjaak Derksen
  */
 public class XmlGregorianCalendarToString extends BuiltInMethod {
 
     private final Parameter parameter;
     private final Type returnType;
 
-    public XmlGregorianCalendarToString( TypeFactory typeFactory ) {
-        this.parameter = typeFactory.createParameter( "xcal" , XMLGregorianCalendar.class );
+    public XmlGregorianCalendarToString(TypeFactory typeFactory) {
+        this.parameter = new Parameter( "xcal", typeFactory.getType( XMLGregorianCalendar.class ) );
         this.returnType = typeFactory.getType( String.class );
     }
 

File: processor/src/test/java/org/mapstruct/ap/testutil/compilation/annotation/Diagnostic.java
Patch:
@@ -32,7 +32,7 @@
      *
      * @return The type for which the diagnostic was created.
      */
-    Class<?> type() default Diagnostic.class;
+    Class<?> type() default void.class;
 
     /**
      * The expected kind of diagnostic.
@@ -46,7 +46,7 @@
      *
      * @return The expected line number of the diagnostic.
      */
-    int line() default -1;
+    long line() default -1;
 
     /**
      * A regular expression matching the expected message of the diagnostic.

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -231,8 +231,8 @@ private MethodReference getFactoryMethod(List<MapperReference> mapperReferences,
                                Kind.ERROR,
                                String.format(
                                    "Ambigious factory method: \"%s\" conflicts with \"%s\".",
-                                   result.getName(),
-                                   method.getName()
+                                   result,
+                                   method
                                ),
                            method.getExecutable()
                           );

File: processor/src/main/java/org/mapstruct/ap/model/Mapper.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.List;
 import java.util.SortedSet;
 import java.util.TreeSet;
-
 import javax.annotation.Generated;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
@@ -149,7 +148,8 @@ private void addWithDependents(Collection<Type> collection, Type typeToAdd) {
             return;
         }
 
-        if ( typeToAdd.getPackageName() != null &&
+        if ( typeToAdd.isImported() &&
+            typeToAdd.getPackageName() != null &&
             !typeToAdd.getPackageName().equals( packageName ) &&
             !typeToAdd.getPackageName().startsWith( "java.lang" ) ) {
             collection.add( typeToAdd );

File: processor/src/test/java/org/mapstruct/ap/test/references/samename/Jsr330SourceTargetMapper.java
Patch:
@@ -20,6 +20,8 @@
 
 import org.mapstruct.Mapper;
 import org.mapstruct.ap.test.references.samename.a.CustomMapper;
+import org.mapstruct.ap.test.references.samename.model.Source;
+import org.mapstruct.ap.test.references.samename.model.Target;
 import org.mapstruct.factory.Mappers;
 
 /**

File: processor/src/test/java/org/mapstruct/ap/test/references/samename/SourceTargetMapper.java
Patch:
@@ -20,6 +20,8 @@
 
 import org.mapstruct.Mapper;
 import org.mapstruct.ap.test.references.samename.a.CustomMapper;
+import org.mapstruct.ap.test.references.samename.model.Source;
+import org.mapstruct.ap.test.references.samename.model.Target;
 import org.mapstruct.factory.Mappers;
 
 /**

File: processor/src/test/java/org/mapstruct/ap/test/references/samename/model/Source.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.references.samename;
+package org.mapstruct.ap.test.references.samename.model;
 
 public class Source {
 

File: processor/src/test/java/org/mapstruct/ap/test/references/samename/model/Target.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.references.samename;
+package org.mapstruct.ap.test.references.samename.model;
 
 public class Target {
 

File: processor/src/main/java/org/mapstruct/ap/conversion/ConversionProvider.java
Patch:
@@ -20,9 +20,9 @@
 
 import java.util.Date;
 
-import org.mapstruct.ap.model.Type;
 import org.mapstruct.ap.model.TypeConversion;
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.Type;
+import org.mapstruct.ap.model.common.TypeFactory;
 
 /**
  * Implementations create inline {@link TypeConversion}s such as

File: processor/src/main/java/org/mapstruct/ap/conversion/Conversions.java
Patch:
@@ -26,8 +26,8 @@
 
 import javax.lang.model.util.Elements;
 
-import org.mapstruct.ap.model.Type;
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.Type;
+import org.mapstruct.ap.model.common.TypeFactory;
 
 import static org.mapstruct.ap.conversion.ReverseConversion.reverse;
 

File: processor/src/main/java/org/mapstruct/ap/conversion/DateToStringConversion.java
Patch:
@@ -24,8 +24,8 @@
 import java.util.Collections;
 import java.util.Date;
 
-import org.mapstruct.ap.model.Type;
 import org.mapstruct.ap.model.TypeConversion;
+import org.mapstruct.ap.model.common.Type;
 
 import static org.mapstruct.ap.util.Collections.asSet;
 

File: processor/src/main/java/org/mapstruct/ap/conversion/DefaultConversionContext.java
Patch:
@@ -19,8 +19,8 @@
 package org.mapstruct.ap.conversion;
 
 import org.mapstruct.ap.conversion.ConversionProvider.Context;
-import org.mapstruct.ap.model.Type;
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.Type;
+import org.mapstruct.ap.model.common.TypeFactory;
 
 /**
  * Default implementation of the {@link Context} passed to conversion providers.

File: processor/src/main/java/org/mapstruct/ap/model/Annotation.java
Patch:
@@ -21,6 +21,9 @@
 import java.util.Collections;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.ModelElement;
+import org.mapstruct.ap.model.common.Type;
+
 /**
  * Represents a Java 5 annotation.
  *

File: processor/src/main/java/org/mapstruct/ap/model/AnnotationMapperReference.java
Patch:
@@ -21,6 +21,7 @@
 import java.beans.Introspector;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.util.Collections;
 import org.mapstruct.ap.util.Strings;
 

File: processor/src/main/java/org/mapstruct/ap/model/BeanMappingMethod.java
Patch:
@@ -24,6 +24,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.Parameter;
+import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.Method;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/model/DefaultMapperReference.java
Patch:
@@ -21,6 +21,8 @@
 import java.beans.Introspector;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.Type;
+import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.util.Collections;
 import org.mapstruct.ap.util.Strings;
 

File: processor/src/main/java/org/mapstruct/ap/model/IterableMappingMethod.java
Patch:
@@ -21,6 +21,8 @@
 import java.beans.Introspector;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.Parameter;
+import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.Method;
 import org.mapstruct.ap.util.Strings;
 

File: processor/src/main/java/org/mapstruct/ap/model/MapMappingMethod.java
Patch:
@@ -20,6 +20,8 @@
 
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.Parameter;
+import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.Method;
 import org.mapstruct.ap.util.Strings;
 

File: processor/src/main/java/org/mapstruct/ap/model/MapperReference.java
Patch:
@@ -18,6 +18,9 @@
  */
 package org.mapstruct.ap.model;
 
+import org.mapstruct.ap.model.common.ModelElement;
+import org.mapstruct.ap.model.common.Type;
+
 /**
  * A reference to another mapper class, which itself may be generated or hand-written.
  *

File: processor/src/main/java/org/mapstruct/ap/model/MappingMethod.java
Patch:
@@ -24,6 +24,9 @@
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.ModelElement;
+import org.mapstruct.ap.model.common.Parameter;
+import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.Method;
 import org.mapstruct.ap.util.Strings;
 

File: processor/src/main/java/org/mapstruct/ap/model/MappingMethodReference.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.model.source.Method;
 import org.mapstruct.ap.util.Strings;
 

File: processor/src/main/java/org/mapstruct/ap/model/PropertyMapping.java
Patch:
@@ -21,6 +21,9 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.ModelElement;
+import org.mapstruct.ap.model.common.Type;
+
 /**
  * Represents the mapping between a source and target property, e.g. from
  * {@code String Source#foo} to {@code int Target#bar}. Name and type of source

File: processor/src/main/java/org/mapstruct/ap/model/TypeConversion.java
Patch:
@@ -23,6 +23,9 @@
 import java.util.List;
 import java.util.Set;
 
+import org.mapstruct.ap.model.common.ModelElement;
+import org.mapstruct.ap.model.common.Type;
+
 /**
  * An inline conversion between source and target type of a mapping.
  *

File: processor/src/main/java/org/mapstruct/ap/model/common/ModelElement.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.model;
+package org.mapstruct.ap.model.common;
 
 import java.io.Writer;
 import java.util.Set;

File: processor/src/main/java/org/mapstruct/ap/model/common/Parameter.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.model;
+package org.mapstruct.ap.model.common;
 
 import java.util.Set;
 

File: processor/src/main/java/org/mapstruct/ap/model/common/Type.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.model;
+package org.mapstruct.ap.model.common;
 
 import java.util.Collections;
 import java.util.List;

File: processor/src/main/java/org/mapstruct/ap/model/common/TypeFactory.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.model;
+package org.mapstruct.ap.model.common;
 
 import java.util.ArrayList;
 import java.util.Collection;

File: processor/src/main/java/org/mapstruct/ap/model/source/Method.java
Patch:
@@ -22,11 +22,12 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 
-import org.mapstruct.ap.model.Parameter;
-import org.mapstruct.ap.model.Type;
+import org.mapstruct.ap.model.common.Parameter;
+import org.mapstruct.ap.model.common.Type;
 import org.mapstruct.ap.util.Strings;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/model/source/MethodMatcher.java
Patch:
@@ -35,7 +35,7 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import org.mapstruct.ap.model.Type;
+import org.mapstruct.ap.model.common.Type;
 
 /**
  * MethodMatcher $8.4 of the JavaLanguage specification describes a method body as such:

File: processor/src/main/java/org/mapstruct/ap/processor/AnnotationBasedComponentModelProcessor.java
Patch:
@@ -26,7 +26,7 @@
 import org.mapstruct.ap.model.AnnotationMapperReference;
 import org.mapstruct.ap.model.Mapper;
 import org.mapstruct.ap.model.MapperReference;
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.option.OptionsHelper;
 import org.mapstruct.ap.prism.MapperPrism;
 

File: processor/src/main/java/org/mapstruct/ap/processor/DefaultModelElementProcessorContext.java
Patch:
@@ -28,7 +28,7 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.option.Options;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -52,11 +52,11 @@
 import org.mapstruct.ap.model.MapperReference;
 import org.mapstruct.ap.model.MappingMethod;
 import org.mapstruct.ap.model.MappingMethodReference;
-import org.mapstruct.ap.model.Parameter;
 import org.mapstruct.ap.model.PropertyMapping;
-import org.mapstruct.ap.model.Type;
 import org.mapstruct.ap.model.TypeConversion;
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.Parameter;
+import org.mapstruct.ap.model.common.Type;
+import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.model.source.Mapping;
 import org.mapstruct.ap.model.source.Method;
 import org.mapstruct.ap.model.source.MethodMatcher;

File: processor/src/main/java/org/mapstruct/ap/processor/MethodRetrievalProcessor.java
Patch:
@@ -34,9 +34,9 @@
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic.Kind;
 
-import org.mapstruct.ap.model.Parameter;
-import org.mapstruct.ap.model.Type;
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.Parameter;
+import org.mapstruct.ap.model.common.Type;
+import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.model.source.IterableMapping;
 import org.mapstruct.ap.model.source.MapMapping;
 import org.mapstruct.ap.model.source.Mapping;

File: processor/src/main/java/org/mapstruct/ap/processor/ModelElementProcessor.java
Patch:
@@ -25,7 +25,7 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
-import org.mapstruct.ap.model.TypeFactory;
+import org.mapstruct.ap.model.common.TypeFactory;
 import org.mapstruct.ap.option.Options;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/model/common/TypeFactory.java
Patch:
@@ -45,7 +45,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import org.mapstruct.ap.MappingTargetPrism;
+import org.mapstruct.ap.prism.MappingTargetPrism;
 import org.mapstruct.ap.util.AnnotationProcessingException;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/model/source/IterableMapping.java
Patch:
@@ -21,7 +21,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 
-import org.mapstruct.ap.IterableMappingPrism;
+import org.mapstruct.ap.prism.IterableMappingPrism;
 
 /**
  * Represents an iterable mapping as configured via {@code @IterableMapping}.

File: processor/src/main/java/org/mapstruct/ap/model/source/MapMapping.java
Patch:
@@ -20,7 +20,7 @@
 
 import javax.lang.model.element.AnnotationMirror;
 
-import org.mapstruct.ap.MapMappingPrism;
+import org.mapstruct.ap.prism.MapMappingPrism;
 
 /**
  * Represents a map mapping as configured via {@code @MapMapping}.

File: processor/src/main/java/org/mapstruct/ap/model/source/Mapping.java
Patch:
@@ -27,8 +27,8 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 
-import org.mapstruct.ap.MappingPrism;
-import org.mapstruct.ap.MappingsPrism;
+import org.mapstruct.ap.prism.MappingPrism;
+import org.mapstruct.ap.prism.MappingsPrism;
 import org.mapstruct.ap.util.AnnotationProcessingException;
 
 /**

File: processor/src/main/java/org/mapstruct/ap/processor/AnnotationBasedComponentModelProcessor.java
Patch:
@@ -22,13 +22,13 @@
 
 import javax.lang.model.element.TypeElement;
 
-import org.mapstruct.ap.MapperPrism;
 import org.mapstruct.ap.model.Annotation;
 import org.mapstruct.ap.model.AnnotationMapperReference;
 import org.mapstruct.ap.model.Mapper;
 import org.mapstruct.ap.model.MapperReference;
 import org.mapstruct.ap.model.TypeFactory;
 import org.mapstruct.ap.option.OptionsHelper;
+import org.mapstruct.ap.prism.MapperPrism;
 
 /**
  * An {@link ModelElementProcessor} which converts the given {@link Mapper}

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -41,7 +41,6 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
-import org.mapstruct.ap.MapperPrism;
 import org.mapstruct.ap.conversion.ConversionProvider;
 import org.mapstruct.ap.conversion.Conversions;
 import org.mapstruct.ap.conversion.DefaultConversionContext;
@@ -63,6 +62,7 @@
 import org.mapstruct.ap.model.source.MethodMatcher;
 import org.mapstruct.ap.option.Options;
 import org.mapstruct.ap.option.ReportingPolicy;
+import org.mapstruct.ap.prism.MapperPrism;
 import org.mapstruct.ap.util.Executables;
 import org.mapstruct.ap.util.Filters;
 import org.mapstruct.ap.util.Strings;

File: processor/src/test/java/org/mapstruct/ap/test/oneway/SourceTargetMapper.java
Patch:
@@ -19,13 +19,15 @@
 package org.mapstruct.ap.test.oneway;
 
 import org.mapstruct.Mapper;
+import org.mapstruct.Mapping;
 import org.mapstruct.factory.Mappers;
 
 @Mapper
 public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
+    @Mapping(source = "qax", target = "qux")
     Target sourceToTarget(Source source);
 
     Source targetToSource(Target target);

File: processor/src/main/java/org/mapstruct/ap/util/Executables.java
Patch:
@@ -150,4 +150,5 @@ public List<Parameter> retrieveParameters(ExecutableElement method) {
     public Type retrieveReturnType(ExecutableElement method) {
         return typeFactory.getType( method.getReturnType() );
     }
+
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/SourceTargetMapper.java
Patch:
@@ -33,7 +33,8 @@ public interface SourceTargetMapper {
     @Mappings({
         @Mapping(source = "integerList", target = "integerCollection"),
         @Mapping(source = "integerSet", target = "set"),
-        @Mapping(source = "anotherIntegerSet", target = "anotherStringSet")
+        @Mapping(source = "anotherIntegerSet", target = "anotherStringSet"),
+        @Mapping(source = "stringList2", target = "stringListNoSetter")
     })
     Target sourceToTarget(Source source);
 

File: processor/src/main/java/org/mapstruct/ap/model/DefaultMapperReference.java
Patch:
@@ -40,7 +40,7 @@ public class DefaultMapperReference extends AbstractModelElement implements Mapp
     public DefaultMapperReference(Type type, TypeFactory typeFactory) {
         this.type = type;
 
-        isAnnotatedMapper = type.isAnnotatedMapper();
+        isAnnotatedMapper = type.isAnnotatedWith( "org.mapstruct.Mapper" );
         importTypes = Collections.asSet( type );
 
         if ( isAnnotatedMapper() ) {

File: processor/src/test/java/org/mapstruct/ap/test/collection/CollectionMappingTest.java
Patch:
@@ -18,8 +18,6 @@
  */
 package org.mapstruct.ap.test.collection;
 
-import static org.fest.assertions.Assertions.assertThat;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
@@ -33,6 +31,8 @@
 import org.mapstruct.ap.testutil.WithClasses;
 import org.testng.annotations.Test;
 
+import static org.fest.assertions.Assertions.assertThat;
+
 @WithClasses({ Source.class, Target.class, Colour.class, SourceTargetMapper.class })
 public class CollectionMappingTest extends MapperTestBase {
 

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/AdditionalMappingHelper.java
Patch:
@@ -20,6 +20,7 @@
 
 
 public class AdditionalMappingHelper {
+
     public Reference asReference(SourceBase source) {
         if ( null == source ) {
             return null;

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/SourceCompositeTargetCompositeMapper.java
Patch:
@@ -21,10 +21,10 @@
 import org.mapstruct.Mapper;
 import org.mapstruct.factory.Mappers;
 
-@Mapper( uses = { SourceBaseMappingHelper.class } )
+@Mapper(uses = { SourceBaseMappingHelper.class })
 public interface SourceCompositeTargetCompositeMapper {
+
     SourceCompositeTargetCompositeMapper INSTANCE = Mappers.getMapper( SourceCompositeTargetCompositeMapper.class );
 
     TargetComposite sourceToTarget(SourceComposite source);
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/inheritance/complex/StandaloneSourceCompositeTargetCompositeMapper.java
Patch:
@@ -25,6 +25,7 @@
 
 @Mapper
 public interface StandaloneSourceCompositeTargetCompositeMapper {
+
     StandaloneSourceCompositeTargetCompositeMapper INSTANCE =
         Mappers.getMapper( StandaloneSourceCompositeTargetCompositeMapper.class );
 

File: processor/src/main/java/org/mapstruct/ap/model/DefaultMapperReference.java
Patch:
@@ -40,7 +40,7 @@ public class DefaultMapperReference extends AbstractModelElement implements Mapp
     public DefaultMapperReference(Type type, TypeFactory typeFactory) {
         this.type = type;
 
-        isAnnotatedMapper = type.isAnnotatedWith( "org.mapstruct.ap.model.Mapper" );
+        isAnnotatedMapper = type.isAnnotatedMapper();
         importTypes = Collections.asSet( type );
 
         if ( isAnnotatedMapper() ) {

File: processor/src/main/java/org/mapstruct/ap/model/source/Method.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 
@@ -205,7 +206,7 @@ private boolean equals(Object o1, Object o2) {
 
     @Override
     public String toString() {
-        return returnType + " " + getName() + "(" + Strings.join( parameters, ", " ) + ")";
+        return returnType + " " + declaringMapper + "." + getName() + "(" + Strings.join( parameters, ", " ) + ")";
     }
 
     public Mapping getMapping(String targetPropertyName) {

File: processor/src/test/java/org/mapstruct/ap/test/collection/CollectionMappingTest.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.mapstruct.ap.test.collection;
 
+import static org.fest.assertions.Assertions.assertThat;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
@@ -31,8 +33,6 @@
 import org.mapstruct.ap.testutil.WithClasses;
 import org.testng.annotations.Test;
 
-import static org.fest.assertions.Assertions.assertThat;
-
 @WithClasses({ Source.class, Target.class, Colour.class, SourceTargetMapper.class })
 public class CollectionMappingTest extends MapperTestBase {
 

File: processor/src/test/java/org/mapstruct/ap/test/collection/defaultimplementation/SourceTargetMapper.java
Patch:
@@ -38,8 +38,6 @@ public interface SourceTargetMapper {
 
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
-    Target sourceToTarget(Source source);
-
     TargetFoo sourceFooToTargetFoo(SourceFoo sourceFoo);
 
     List<TargetFoo> sourceFoosToTargetFoos(List<SourceFoo> foos);

File: processor/src/test/java/org/mapstruct/ap/test/collection/map/SourceTargetMapper.java
Patch:
@@ -48,5 +48,5 @@ Map<Long, Date> stringStringMapToLongDateMapUsingTargetParameterAndReturn(Map<St
 
     Source targetToSource(Target target);
 
-    Map<Object, Object> stringStringMapToObjectObjectMap(Map<String, String> source);
+    Map<Number, Number> intIntToNumberNumberMap(Map<Integer, Integer> source);
 }

File: processor/src/test/java/org/mapstruct/ap/testutil/compilation/annotation/Diagnostic.java
Patch:
@@ -32,7 +32,7 @@
      *
      * @return The type for which the diagnostic was created.
      */
-    Class<?> type();
+    Class<?> type() default Diagnostic.class;
 
     /**
      * The expected kind of diagnostic.
@@ -46,7 +46,7 @@
      *
      * @return The expected line number of the diagnostic.
      */
-    int line();
+    int line() default -1;
 
     /**
      * A regular expression matching the expected message of the diagnostic.

File: processor/src/main/java/org/mapstruct/ap/model/Type.java
Patch:
@@ -188,6 +188,8 @@ public boolean isAnnotatedWith(String annotationTypeName) {
      *
      * @return {@code true} if and only if this type is assignable to the given other type.
      */
+    // TODO This doesn't yet take wild card types into account; e.g. ? extends Integer wouldn't be assignable to Number
+    // atm.
     public boolean isAssignableTo(Type other) {
         if ( equals( other ) ) {
             return true;

File: processor/src/test/java/org/mapstruct/ap/test/collection/SourceTargetMapper.java
Patch:
@@ -46,4 +46,6 @@ public interface SourceTargetMapper {
     Set<String> colourSetToStringSet(Set<Colour> colours);
 
     Set<Colour> stringSetToColourSet(Set<String> colours);
+
+    Set<Number> integerSetToNumberSet(Set<Integer> integers);
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/map/SourceTargetMapper.java
Patch:
@@ -47,4 +47,6 @@ Map<Long, Date> stringStringMapToLongDateMapUsingTargetParameterAndReturn(Map<St
     Target sourceToTarget(Source source);
 
     Source targetToSource(Target target);
+
+    Map<Object, Object> stringStringMapToObjectObjectMap(Map<String, String> source);
 }

File: processor/src/main/java/org/mapstruct/ap/util/MethodMatcher.java
Patch:
@@ -138,8 +138,7 @@ public Boolean visitPrimitive(PrimitiveType t, TypeMirror p) {
         public Boolean visitArray(ArrayType t, TypeMirror p) {
 
             if ( p.getKind().equals( TypeKind.ARRAY) ) {
-                t.getComponentType().accept( this, ( (ArrayType) p ).getComponentType() );
-                return Boolean.TRUE;
+                return t.getComponentType().accept( this, ( (ArrayType) p ).getComponentType() );
             }
             else {
                 return Boolean.FALSE;

File: processor/src/test/java/org/mapstruct/ap/test/collection/erroneous/ErroneousCollectionMappingTest.java
Patch:
@@ -63,7 +63,7 @@ public void shouldFailToGenerateImplementationBetweenCollectionAndNonCollection(
                 kind = Kind.ERROR,
                 line = 26,
                 messageRegExp = "Can't map property \"java\\.util\\.Set<java\\.lang\\.String> fooSet\" to" +
-                        " \"java\\.util\\.Set<java\\.lang\\.Long> fooSet\""),
+                        " \"java\\.util\\.Set<java\\.lang\\.Long> fooSet\"" )
         }
     )
     public void shouldFailToGenerateImplementationDueToDifferentlyParameterizedCollections() {

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/attributereference/ErroneousMappingsTest.java
Patch:
@@ -60,7 +60,7 @@ public class ErroneousMappingsTest extends MapperTestBase {
             @Diagnostic(type = ErroneousMapper.class,
                 kind = Kind.WARNING,
                 line = 36,
-                messageRegExp = "Unmapped target property: \"bar\""),
+                messageRegExp = "Unmapped target property: \"bar\"")
         }
     )
     public void shouldFailToGenerateMappings() {

File: processor/src/test/java/org/mapstruct/ap/test/collection/erroneous/ErroneousCollectionToNonCollectionMapper.java
Patch:
@@ -23,7 +23,7 @@
 import org.mapstruct.Mapper;
 
 @Mapper
-public interface ErronuousMapper {
+public interface ErroneousCollectionToNonCollectionMapper {
 
     Integer stringSetToInteger(Set<String> strings);
 

File: processor/src/main/java/org/mapstruct/ap/processor/MapperCreationProcessor.java
Patch:
@@ -562,7 +562,7 @@ private MappingMethodReference getMappingMethodReference(Iterable<Method> method
      * @param property The property mapping to check.
      */
     private void reportErrorIfPropertyCanNotBeMapped(Method method, PropertyMapping property) {
-        if ( property.getSourceType().equals( property.getTargetType() ) ||
+        if ( property.getSourceType().isAssignableTo( property.getTargetType() ) ||
             property.getMappingMethod() != null ||
             property.getConversion() != null ||
             property.getTargetType().getImplementationType() != null ) {
@@ -573,9 +573,9 @@ private void reportErrorIfPropertyCanNotBeMapped(Method method, PropertyMapping
             Kind.ERROR,
             String.format(
                 "Can't map property \"%s %s\" to \"%s %s\".",
-                property.getSourceType().getName(),
+                property.getSourceType(),
                 property.getSourceName(),
-                property.getTargetType().getName(),
+                property.getTargetType(),
                 property.getTargetName()
             ),
             method.getExecutable()

File: processor/src/main/java/org/mapstruct/ap/processor/MethodRetrievalProcessor.java
Patch:
@@ -207,7 +207,7 @@ private boolean checkParameterAndReturnType(ExecutableElement method, List<Param
         }
 
         if ( returnType.getTypeMirror().getKind() != TypeKind.VOID &&
-            !typeFactory.isAssignable( resultType, returnType ) ) {
+            !resultType.isAssignableTo( returnType ) ) {
             messager.printMessage(
                 Kind.ERROR,
                 "The result type is not assignable to the the return type.",

File: processor/src/main/java/org/mapstruct/ap/conversion/ConversionProvider.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.mapstruct.ap.model.Type;
 import org.mapstruct.ap.model.TypeConversion;
+import org.mapstruct.ap.util.TypeFactory;
 
 /**
  * Implementations create inline {@link TypeConversion}s such as
@@ -80,5 +81,7 @@ public interface Context {
          * @return The date format if this conversion.
          */
         String getDateFormat();
+
+        TypeFactory getTypeFactory();
     }
 }

File: processor/src/main/java/org/mapstruct/ap/conversion/DateToStringConversion.java
Patch:
@@ -39,7 +39,7 @@ public class DateToStringConversion implements ConversionProvider {
     @Override
     public TypeConversion to(String sourceReference, Context conversionContext) {
         return new TypeConversion(
-            asSet( Type.forClass( SimpleDateFormat.class ) ),
+            asSet( conversionContext.getTypeFactory().getType( SimpleDateFormat.class ) ),
             Collections.<Type>emptyList(),
             getConversionString( sourceReference, conversionContext, "format" )
         );
@@ -48,8 +48,8 @@ public TypeConversion to(String sourceReference, Context conversionContext) {
     @Override
     public TypeConversion from(String targetReference, Context conversionContext) {
         return new TypeConversion(
-            asSet( Type.forClass( SimpleDateFormat.class ) ),
-            Arrays.asList( Type.forClass( ParseException.class ) ),
+            asSet( conversionContext.getTypeFactory().getType( SimpleDateFormat.class ) ),
+            Arrays.asList( conversionContext.getTypeFactory().getType( ParseException.class ) ),
             getConversionString( targetReference, conversionContext, "parse" )
         );
     }

File: processor/src/main/java/org/mapstruct/ap/model/MappingMethod.java
Patch:
@@ -92,6 +92,7 @@ public Set<Type> getImportTypes() {
         }
 
         types.add( getReturnType() );
+        types.addAll( getReturnType().getImportTypes() );
 
         return types;
     }

File: processor/src/main/java/org/mapstruct/ap/processor/CdiComponentProcessor.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.mapstruct.ap.model.Annotation;
 import org.mapstruct.ap.model.Mapper;
-import org.mapstruct.ap.model.Type;
 
 /**
  * A {@link ModelElementProcessor} which converts the given {@link Mapper}
@@ -38,11 +37,11 @@ protected String getComponentModelIdentifier() {
 
     @Override
     protected Annotation getTypeAnnotation() {
-        return new Annotation( new Type( "javax.enterprise.context", "ApplicationScoped" ) );
+        return new Annotation( getTypeFactory().getType( "javax.enterprise.context.ApplicationScoped" ) );
     }
 
     @Override
     protected Annotation getMapperReferenceAnnotation() {
-        return new Annotation( new Type( "javax.inject", "Inject" ) );
+        return new Annotation( getTypeFactory().getType( "javax.inject.Inject" ) );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/processor/Jsr330ComponentProcessor.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.mapstruct.ap.model.Annotation;
 import org.mapstruct.ap.model.Mapper;
-import org.mapstruct.ap.model.Type;
 
 /**
  * A {@link ModelElementProcessor} which converts the given {@link Mapper}
@@ -38,11 +37,11 @@ protected String getComponentModelIdentifier() {
 
     @Override
     protected Annotation getTypeAnnotation() {
-        return new Annotation( new Type( "javax.inject", "Named" ) );
+        return new Annotation( getTypeFactory().getType( "javax.inject.Named" ) );
     }
 
     @Override
     protected Annotation getMapperReferenceAnnotation() {
-        return new Annotation( new Type( "javax.inject", "Inject" ) );
+        return new Annotation( getTypeFactory().getType( "javax.inject.Inject" ) );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/processor/ModelElementProcessor.java
Patch:
@@ -26,6 +26,7 @@
 import javax.tools.Diagnostic.Kind;
 
 import org.mapstruct.ap.model.Options;
+import org.mapstruct.ap.util.TypeFactory;
 
 /**
  * A processor which performs one task of the mapper generation, e.g. retrieving
@@ -55,6 +56,8 @@ public interface ProcessorContext {
 
         Elements getElementUtils();
 
+        TypeFactory getTypeFactory();
+
         Messager getMessager();
 
         Options getOptions();

File: processor/src/main/java/org/mapstruct/ap/processor/SpringComponentProcessor.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.mapstruct.ap.model.Annotation;
 import org.mapstruct.ap.model.Mapper;
-import org.mapstruct.ap.model.Type;
 
 /**
  * A {@link ModelElementProcessor} which converts the given {@link Mapper}
@@ -38,11 +37,11 @@ protected String getComponentModelIdentifier() {
 
     @Override
     protected Annotation getTypeAnnotation() {
-        return new Annotation( new Type( "org.springframework.stereotype", "Component" ) );
+        return new Annotation( getTypeFactory().getType( "org.springframework.stereotype.Component" ) );
     }
 
     @Override
     protected Annotation getMapperReferenceAnnotation() {
-        return new Annotation( new Type( "org.springframework.beans.factory.annotation", "Autowired" ) );
+        return new Annotation( getTypeFactory().getType( "org.springframework.beans.factory.annotation.Autowired" ) );
     }
 }

File: processor/src/main/java/org/mapstruct/ap/util/TypeUtil.java
Patch:
@@ -60,6 +60,7 @@ public Type getType(DeclaredType type) {
             ( (TypeElement) type.asElement() ).getQualifiedName().toString(),
             elementUtils.getPackageOf( type.asElement() ).toString(),
             type.asElement().getSimpleName().toString(),
+            type.asElement().getKind() == ElementKind.INTERFACE,
             type.asElement().getKind() == ElementKind.ENUM,
             isCollectionType( type ),
             isIterableType,

File: processor/src/main/java/org/mapstruct/ap/model/Mapper.java
Patch:
@@ -83,7 +83,9 @@ private void addWithDependents(Collection<Type> collection, Type typeToAdd) {
 
         addWithDependents( collection, typeToAdd.getCollectionImplementationType() );
         addWithDependents( collection, typeToAdd.getIterableImplementationType() );
-        addWithDependents( collection, typeToAdd.getElementType() );
+        for ( Type type : typeToAdd.getTypeParameters() ) {
+            addWithDependents( collection, type );
+        }
     }
 
     @Override

File: processor/src/main/java/org/mapstruct/ap/processor/AnnotationBasedComponentModelProcessor.java
Patch:
@@ -88,6 +88,6 @@ protected MapperReference replacementMapperReference(MapperReference originalRef
 
     @Override
     public int getPriority() {
-        return 1105;
+        return 1100;
     }
 }

File: processor/src/main/java/org/mapstruct/ap/processor/CdiComponentProcessor.java
Patch:
@@ -30,6 +30,7 @@
  * @author Gunnar Morling
  */
 public class CdiComponentProcessor extends AnnotationBasedComponentModelProcessor {
+
     @Override
     protected String getComponentModelIdentifier() {
         return "cdi";

File: core/src/main/java/org/mapstruct/Mapper.java
Patch:
@@ -57,6 +57,9 @@
      * <li>
      * {@code cdi}: the generated mapper is an application-scoped CDI bean and
      * can be retrieved via {@code @Inject}</li>
+     * <li>
+     * {@code spring}: the generated mapper is a Spring bean and
+     * can be retrieved via {@code @Autowired}</li>
      * </ul>
      *
      * @return The component model for the generated mapper.

File: processor/src/test/java/org/mapstruct/ap/test/oneway/SourceTargetMapper.java
Patch:
@@ -27,4 +27,6 @@ public interface SourceTargetMapper {
     SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     Target sourceToTarget(Source source);
+
+    Source targetToSource(Target target);
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/erronuous/ErronuousCollectionMappingTest.java
Patch:
@@ -44,11 +44,11 @@ public class ErronuousCollectionMappingTest extends MapperTestBase {
             @Diagnostic(type = ErronuousMapper.class,
                 kind = Kind.ERROR,
                 line = 28,
-                messageRegExp = "Can't generate mapping method from iterable type to non-iterable type\\."),
+                messageRegExp = ".*Can't generate mapping method from iterable type to non-iterable type\\."),
             @Diagnostic(type = ErronuousMapper.class,
                 kind = Kind.ERROR,
                 line = 30,
-                messageRegExp = "Can't generate mapping method from non-iterable type to iterable type\\.")
+                messageRegExp = ".*Can't generate mapping method from non-iterable type to iterable type\\.")
         }
     )
     public void shouldFailToGenerateMappingFromListToString() {

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/attributereference/ErroneousMappingsTest.java
Patch:
@@ -44,11 +44,11 @@ public class ErroneousMappingsTest extends MapperTestBase {
             @Diagnostic(type = ErroneousMapper.class,
                 kind = Kind.ERROR,
                 line = 27,
-                messageRegExp = "Unknown property \"bar\" in return type.*"),
+                messageRegExp = ".*Unknown property \"bar\" in return type.*"),
             @Diagnostic(type = ErroneousMapper.class,
                 kind = Kind.ERROR,
                 line = 30,
-                messageRegExp = "Unknown property \"bar\" in parameter type.*")
+                messageRegExp = ".*Unknown property \"bar\" in parameter type.*")
         }
     )
     public void shouldFailToGenerateMappings() {

File: processor/src/main/java/org/mapstruct/ap/model/Type.java
Patch:
@@ -39,9 +39,9 @@ public class Type implements Comparable<Type> {
     );
 
     private static final ConcurrentMap<String, Type> DEFAULT_ITERABLE_IMPLEMENTATION_TYPES =
-            new ConcurrentHashMap<String, Type>();
+        new ConcurrentHashMap<String, Type>();
     private static final ConcurrentMap<String, Type> DEFAULT_COLLECTION_IMPLEMENTATION_TYPES =
-            new ConcurrentHashMap<String, Type>();
+        new ConcurrentHashMap<String, Type>();
 
     static {
         DEFAULT_COLLECTION_IMPLEMENTATION_TYPES.put( List.class.getName(), forClass( ArrayList.class ) );

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/typemismatch/ErroneousMapper.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.erroneous;
+package org.mapstruct.ap.test.erroneous.typemismatch;
 
 import org.mapstruct.Mapper;
 

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/typemismatch/ErroneousMappingsTest.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.erroneous;
+package org.mapstruct.ap.test.erroneous.typemismatch;
 
 import javax.tools.Diagnostic.Kind;
 

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/typemismatch/Source.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.erroneous;
+package org.mapstruct.ap.test.erroneous.typemismatch;
 
 public class Source {
 

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/typemismatch/Target.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.erroneous;
+package org.mapstruct.ap.test.erroneous.typemismatch;
 
 public class Target {
 

File: integrationtest/src/main/java/org/mapstruct/itest/SourceTargetMapper.java
Patch:
@@ -26,7 +26,7 @@
 @Mapper
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mappings({
         @Mapping(source = "qax", target = "baz"),

File: processor/src/main/java/org/mapstruct/ap/conversion/PrimitiveToStringConversion.java
Patch:
@@ -43,6 +43,7 @@ public String to(String sourcePropertyAccessor, Type type) {
 
     @Override
     public String from(String targetPropertyAccessor, Type type) {
-        return wrapperType.getSimpleName() + ".parse" + Strings.capitalize( sourceType.getSimpleName() ) + "( " + targetPropertyAccessor + " )";
+        return wrapperType.getSimpleName() + ".parse" + Strings.capitalize( sourceType.getSimpleName() ) + "( " +
+            targetPropertyAccessor + " )";
     }
 }

File: processor/src/main/java/org/mapstruct/ap/conversion/WrapperToStringConversion.java
Patch:
@@ -43,6 +43,7 @@ public String to(String sourcePropertyAccessor, Type type) {
 
     @Override
     public String from(String targetPropertyAccessor, Type type) {
-        return sourceType.getSimpleName() + ".parse" + Strings.capitalize( primitiveType.getSimpleName() ) + "( " + targetPropertyAccessor + " )";
+        return sourceType.getSimpleName() + ".parse" + Strings.capitalize( primitiveType.getSimpleName() ) + "( " +
+            targetPropertyAccessor + " )";
     }
 }

File: processor/src/main/java/org/mapstruct/ap/model/BeanMapping.java
Patch:
@@ -31,7 +31,8 @@ public class BeanMapping {
     private final String toConversion;
     private final String fromConversion;
 
-    public BeanMapping(Type sourceType, Type targetType, List<PropertyMapping> propertyMappings, MappingMethod mappingMethod,
+    public BeanMapping(Type sourceType, Type targetType, List<PropertyMapping> propertyMappings,
+                       MappingMethod mappingMethod,
                        MappingMethod reverseMappingMethod, String toConversion, String fromConversion) {
         this.sourceType = sourceType;
         this.targetType = targetType;

File: processor/src/main/java/org/mapstruct/ap/model/Mapper.java
Patch:
@@ -35,7 +35,8 @@ public class Mapper {
     private final SortedSet<Type> importedTypes;
 
     public Mapper(String packageName, String interfaceName,
-                  String implementationName, List<BeanMapping> beanMappings, List<Type> usedMapperTypes, Options options) {
+                  String implementationName, List<BeanMapping> beanMappings, List<Type> usedMapperTypes,
+                  Options options) {
         this.packageName = packageName;
         this.interfaceName = interfaceName;
         this.implementationName = implementationName;

File: processor/src/main/java/org/mapstruct/ap/model/source/MappedProperty.java
Patch:
@@ -32,7 +32,8 @@ public class MappedProperty {
     private final Type targetType;
 
     public MappedProperty(String sourceName, String sourceReadAccessorName, String sourceWriteAccessorName,
-                          Type sourceType, String targetName, String targetReadAccessorName, String targetWriteAccessorName,
+                          Type sourceType, String targetName, String targetReadAccessorName,
+                          String targetWriteAccessorName,
                           Type targetType) {
         this.sourceName = sourceName;
         this.sourceReadAccessorName = sourceReadAccessorName;

File: processor/src/main/java/org/mapstruct/ap/model/source/Method.java
Patch:
@@ -33,7 +33,8 @@ public class Method {
     private final Type targetType;
     private final List<MappedProperty> mappedProperties;
 
-    public Method(Type declaringMapper, ExecutableElement executable, String parameterName, Type sourceType, Type targetType, List<MappedProperty> mappedProperties) {
+    public Method(Type declaringMapper, ExecutableElement executable, String parameterName, Type sourceType,
+                  Type targetType, List<MappedProperty> mappedProperties) {
         this.declaringMapper = declaringMapper;
         this.executable = executable;
         this.parameterName = parameterName;

File: processor/src/main/java/org/mapstruct/ap/util/Executables.java
Patch:
@@ -30,6 +30,9 @@
  */
 public class Executables {
 
+    private Executables() {
+    }
+
     public static boolean isGetterMethod(ExecutableElement method) {
         return isNonBooleanGetterMethod( method ) || isBooleanGetterMethod( method );
     }

File: processor/src/main/java/org/mapstruct/ap/util/Filters.java
Patch:
@@ -32,6 +32,9 @@
  */
 public class Filters {
 
+    private Filters() {
+    }
+
     public static List<ExecutableElement> getterMethodsIn(Iterable<? extends Element> elements) {
         List<ExecutableElement> getterMethods = new LinkedList<ExecutableElement>();
 

File: processor/src/main/java/org/mapstruct/ap/util/Strings.java
Patch:
@@ -20,8 +20,10 @@
 
 public class Strings {
 
+    private Strings() {
+    }
+
     public static String capitalize(String name) {
         return name == null ? null : name.substring( 0, 1 ).toUpperCase() + name.substring( 1 );
     }
-
 }

File: processor/src/test/java/org/mapstruct/ap/test/collection/SourceTargetMapper.java
Patch:
@@ -28,7 +28,7 @@
 @Mapper
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mappings({
         @Mapping(source = "integerList", target = "integerCollection"),

File: processor/src/test/java/org/mapstruct/ap/test/collection/defaultimplementation/SourceTargetMapper.java
Patch:
@@ -28,7 +28,7 @@
 @Mapper
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     Target sourceToTarget(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/test/collection/iterabletononiterable/SourceTargetMapper.java
Patch:
@@ -24,7 +24,7 @@
 @Mapper(uses = StringListMapper.class)
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     Target sourceToTarget(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/test/conversion/SourceTargetMapper.java
Patch:
@@ -26,7 +26,7 @@
 @Mapper
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mappings({
         @Mapping(source = "qax", target = "baz"),

File: processor/src/test/java/org/mapstruct/ap/test/conversion/nativetypes/BooleanMapper.java
Patch:
@@ -24,7 +24,7 @@
 @Mapper
 public interface BooleanMapper {
 
-    public static BooleanMapper INSTANCE = Mappers.getMapper( BooleanMapper.class );
+    BooleanMapper INSTANCE = Mappers.getMapper( BooleanMapper.class );
 
     BooleanTarget sourceToTarget(BooleanSource source);
 

File: processor/src/test/java/org/mapstruct/ap/test/conversion/nativetypes/CharMapper.java
Patch:
@@ -24,7 +24,7 @@
 @Mapper
 public interface CharMapper {
 
-    public static CharMapper INSTANCE = Mappers.getMapper( CharMapper.class );
+    CharMapper INSTANCE = Mappers.getMapper( CharMapper.class );
 
     CharTarget sourceToTarget(CharSource source);
 

File: processor/src/test/java/org/mapstruct/ap/test/conversion/nativetypes/SourceTargetMapper.java
Patch:
@@ -24,7 +24,7 @@
 @Mapper
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     ByteTarget sourceToTarget(ByteSource source);
 

File: processor/src/test/java/org/mapstruct/ap/test/conversion/precedence/SourceTargetMapper.java
Patch:
@@ -24,7 +24,7 @@
 @Mapper(uses = IntegerStringMapper.class)
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     Target sourceToTarget(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/test/conversion/string/SourceTargetMapper.java
Patch:
@@ -24,7 +24,7 @@
 @Mapper
 public interface SourceTargetMapper {
 
-    public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
+    SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     Target sourceToTarget(Source source);
 

File: processor/src/test/java/org/mapstruct/ap/testutil/compilation/model/DiagnosticDescriptor.java
Patch:
@@ -49,7 +49,8 @@ public static DiagnosticDescriptor forDiagnostic(Diagnostic diagnostic) {
         return new DiagnosticDescriptor( soureFileName, diagnostic.kind(), diagnostic.line(), "" );
     }
 
-    public static DiagnosticDescriptor forDiagnostic(String sourceDir, javax.tools.Diagnostic<? extends JavaFileObject> diagnostic) {
+    public static DiagnosticDescriptor forDiagnostic(String sourceDir,
+                                                     javax.tools.Diagnostic<? extends JavaFileObject> diagnostic) {
         return new DiagnosticDescriptor(
             getSourceName( sourceDir, diagnostic ),
             diagnostic.getKind(),

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/Source.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.erronuous;
+package org.mapstruct.ap.test.erroneous;
 
 public class Source {
 

File: processor/src/test/java/org/mapstruct/ap/test/erroneous/Target.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.erronuous;
+package org.mapstruct.ap.test.erroneous;
 
 public class Target {
 

File: processor/src/main/java/org/mapstruct/ap/conversion/CharToStringConversion.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.mapstruct.ap.model.Type;
 
-public class IntStringConversion implements Conversion {
+public class CharToStringConversion implements Conversion {
 
     @Override
     public String to(String sourcePropertyAccessor, Type type) {
@@ -29,6 +29,6 @@ public String to(String sourcePropertyAccessor, Type type) {
 
     @Override
     public String from(String targetPropertyAccessor, Type type) {
-        return "Integer.parseInt( " + targetPropertyAccessor + " )";
+        return targetPropertyAccessor + ".charAt( 0 )";
     }
 }

File: processor/src/main/java/org/mapstruct/ap/model/Mapper.java
Patch:
@@ -68,8 +68,8 @@ private void addWithDependents(Collection<Type> collection, Type typeToAdd) {
         }
 
         if ( typeToAdd.getPackageName() != null &&
-                !typeToAdd.getPackageName().equals( packageName ) &&
-                !typeToAdd.getPackageName().startsWith( "java.lang" ) ) {
+            !typeToAdd.getPackageName().equals( packageName ) &&
+            !typeToAdd.getPackageName().startsWith( "java.lang" ) ) {
             collection.add( typeToAdd );
         }
 

File: processor/src/test/java/org/mapstruct/ap/test/collection/defaultimplementation/DefaultCollectionImplementationTest.java
Patch:
@@ -37,7 +37,6 @@
 })
 public class DefaultCollectionImplementationTest extends MapperTestBase {
 
-
     @Test
     @IssueKey("6")
     public void shouldUseDefaultImplementationForList() {

File: processor/src/test/java/org/mapstruct/ap/test/complex/source/Car.java
Patch:
@@ -16,11 +16,12 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.complex;
+package org.mapstruct.ap.test.complex.source;
 
 import java.util.Date;
 import java.util.List;
 
+
 public class Car {
 
     private String make;

File: processor/src/test/java/org/mapstruct/ap/test/complex/source/Category.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.complex;
+package org.mapstruct.ap.test.complex.source;
 
 public enum Category {
     SEDAN, CONVERTIBLE, TRUCK;

File: processor/src/test/java/org/mapstruct/ap/test/complex/source/Person.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.complex;
+package org.mapstruct.ap.test.complex.source;
 
 public class Person {
 

File: processor/src/test/java/org/mapstruct/ap/test/complex/target/CarDto.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.complex;
+package org.mapstruct.ap.test.complex.target;
 
 import java.util.List;
 

File: processor/src/test/java/org/mapstruct/ap/test/complex/target/PersonDto.java
Patch:
@@ -16,7 +16,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package org.mapstruct.ap.test.complex;
+package org.mapstruct.ap.test.complex.target;
 
 public class PersonDto {
 

File: processor/src/test/java/org/mapstruct/ap/testutil/MapperTestBase.java
Patch:
@@ -59,7 +59,7 @@ public abstract class MapperTestBase {
     private DiagnosticCollector<JavaFileObject> diagnostics;
 
     public MapperTestBase() {
-        this.libraries = Arrays.asList( "mapstruct.jar" );
+        this.libraries = Arrays.asList( "mapstruct.jar", "guava.jar" );
     }
 
     @BeforeClass
@@ -107,7 +107,7 @@ public void generateMapperImplementation(Method testMethod) {
 
         if ( expectedResult.getCompilationResult() == CompilationResult.SUCCEEDED ) {
             assertThat( actualResult.getCompilationResult() )
-                .describedAs( "Compilation failed. Diagnostics: " + actualResult.getDiagnostics() )
+                .describedAs( "Compilation failed. Diagnostics: " + diagnostics.getDiagnostics() )
                 .isEqualTo( CompilationResult.SUCCEEDED );
         }
         else {

File: processor/src/main/java/org/mapstruct/ap/conversion/Conversions.java
Patch:
@@ -54,6 +54,9 @@ public Conversion getConversion(Type sourceType, Type targetType) {
         if ( sourceType.isEnumType() && targetType.equals( typeUtil.getType( stringType ) ) ) {
             sourceType = typeUtil.getType( enumType );
         }
+        else if ( targetType.isEnumType() && sourceType.equals( typeUtil.getType( stringType ) ) ) {
+            targetType = typeUtil.getType( enumType );
+        }
 
         return conversions.get( new Key( sourceType, targetType ) );
     }

File: processor/src/test/java/org/mapstruct/ap/test/collection/SourceTargetMapper.java
Patch:
@@ -26,7 +26,8 @@ public interface SourceTargetMapper {
     public static SourceTargetMapper INSTANCE = Mappers.getMapper( SourceTargetMapper.class );
 
     @Mappings({
-        @Mapping(source = "integerList", target = "integerCollection")
+        @Mapping(source = "integerList", target = "integerCollection"),
+        @Mapping(source = "integerSet", target = "set")
     })
     Target sourceToTarget(Source source);
 

