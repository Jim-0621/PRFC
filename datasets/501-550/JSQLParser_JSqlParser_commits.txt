File: src/main/java/net/sf/jsqlparser/statement/select/WithItem.java
Patch:
@@ -15,14 +15,14 @@
 import net.sf.jsqlparser.statement.insert.ParenthesedInsert;
 import net.sf.jsqlparser.statement.update.ParenthesedUpdate;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 
-public class WithItem<T extends ParenthesedStatement> {
-
+public class WithItem<T extends ParenthesedStatement> implements Serializable {
     private T statement;
     private Alias alias;
     private List<SelectItem<?>> withItemList;

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -114,6 +114,7 @@ public class ParserKeywordsUtils {
             {"OUTER", RESTRICTED_JSQLPARSER},
             {"OUTPUT", RESTRICTED_JSQLPARSER},
             {"OPTIMIZE ", RESTRICTED_JSQLPARSER},
+            {"OVERWRITE ", RESTRICTED_JSQLPARSER},
             {"PIVOT", RESTRICTED_JSQLPARSER},
             {"PLUS", RESTRICTED_JSQLPARSER},
             {"PREFERRING", RESTRICTED_JSQLPARSER},

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/LikeExpression.java
Patch:
@@ -117,7 +117,7 @@ public LikeExpression withRightExpression(Expression arg0) {
     }
 
     public enum KeyWord {
-        LIKE, ILIKE, RLIKE, REGEXP_LIKE, REGEXP, SIMILAR_TO;
+        LIKE, ILIKE, RLIKE, REGEXP_LIKE, REGEXP, SIMILAR_TO, MATCH_ANY, MATCH_ALL, MATCH_PHRASE, MATCH_PHRASE_PREFIX, MATCH_REGEXP;
 
         public static KeyWord from(String keyword) {
             return Enum.valueOf(KeyWord.class, keyword.toUpperCase().replaceAll("\\s+", "_"));

File: src/main/java/net/sf/jsqlparser/statement/select/ParenthesedSelect.java
Patch:
@@ -75,6 +75,9 @@ private static Alias getAliasFromItem(FromItem fromItem) {
         if (fromItem instanceof Table && fromItem.getAlias() == null) {
             Table t = (Table) fromItem;
             return new Alias(t.getName(), true);
+        } else if (fromItem instanceof TableFunction && fromItem.getAlias() == null) {
+            TableFunction t = (TableFunction) fromItem;
+            return new Alias(t.getName(), true);
         } else {
             return new Alias(fromItem.getAlias().getName(), true);
         }

File: src/main/java/net/sf/jsqlparser/expression/CastExpression.java
Patch:
@@ -273,7 +273,7 @@ public boolean isText() {
     }
 
     public enum DataType {
-        ARRAY, BIT, BITSTRING, BLOB, BYTEA, BINARY, VARBINARY, BYTES, BOOLEAN, BOOL, ENUM, INTERVAL, LIST, MAP, STRUCT, TINYINT, INT1, SMALLINT, INT2, SHORT, INTEGER, INT4, INT, SIGNED, BIGINT, INT8, LONG, HUGEINT, UTINYINT, USMALLINT, UINTEGER, UBIGINT, UHUGEINT, DECIMAL, NUMBER, NUMERIC, REAL, FLOAT4, FLOAT, DOUBLE, DOUBLE_PRECISION, FLOAT8, FLOAT64, UUID, VARCHAR, NVARCHAR, CHAR, NCHAR, BPCHAR, STRING, TEXT, CLOB, DATE, TIME, TIME_WITHOUT_TIME_ZONE, TIMETZ, TIME_WITH_TIME_ZONE, TIMESTAMP_NS, TIMESTAMP, TIMESTAMP_WITHOUT_TIME_ZONE, DATETIME, TIMESTAMP_MS, TIMESTAMP_S, TIMESTAMPTZ, TIMESTAMP_WITH_TIME_ZONE, UNKNOWN, VARBYTE;
+        ARRAY, BIT, BITSTRING, BLOB, BYTEA, BINARY, VARBINARY, BYTES, BOOLEAN, BOOL, ENUM, INTERVAL, LIST, MAP, STRUCT, TINYINT, INT1, SMALLINT, INT2, SHORT, INTEGER, INT4, INT, SIGNED, BIGINT, INT8, LONG, HUGEINT, UTINYINT, USMALLINT, UINTEGER, UBIGINT, UHUGEINT, DECIMAL, NUMBER, NUMERIC, REAL, FLOAT4, FLOAT, DOUBLE, DOUBLE_PRECISION, FLOAT8, FLOAT64, UUID, VARCHAR, NVARCHAR, CHAR, NCHAR, BPCHAR, STRING, TEXT, CLOB, DATE, TIME, TIME_WITHOUT_TIME_ZONE, TIMETZ, TIME_WITH_TIME_ZONE, TIMESTAMP_NS, TIMESTAMP, TIMESTAMP_WITHOUT_TIME_ZONE, DATETIME, TIMESTAMP_MS, TIMESTAMP_S, TIMESTAMPTZ, TIMESTAMP_WITH_TIME_ZONE, UNKNOWN, VARBYTE, JSON;
 
         public static DataType from(String typeStr) {
             Matcher matcher = PATTERN.matcher(typeStr.trim().replaceAll("\\s+", "_").toUpperCase());

File: src/main/java/net/sf/jsqlparser/expression/JsonKeyValuePair.java
Patch:
@@ -18,13 +18,13 @@
  */
 
 public class JsonKeyValuePair implements Serializable {
-    private final String key;
+    private final Object key;
     private final Object value;
     private boolean usingKeyKeyword = false;
     private boolean usingValueKeyword = false;
     private boolean usingFormatJson = false;
 
-    public JsonKeyValuePair(String key, Object value, boolean usingKeyKeyword,
+    public JsonKeyValuePair(Object key, Object value, boolean usingKeyKeyword,
             boolean usingValueKeyword) {
         this.key = Objects.requireNonNull(key, "The KEY of the Pair must not be null");
         this.value = value;
@@ -93,7 +93,7 @@ public boolean equals(Object obj) {
         return Objects.equals(this.key, other.key);
     }
 
-    public String getKey() {
+    public Object getKey() {
         return key;
     }
 

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,7 +10,7 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, CONVERT, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, ADD_PARTITION, DROP_PARTITION, TRUNCATE_PARTITION, LOCK;
+    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, CONVERT, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, ADD_PARTITION, DROP_PARTITION, TRUNCATE_PARTITION, SET_TABLE_OPTION, LOCK;
 
     public static AlterOperation from(String operation) {
         return Enum.valueOf(AlterOperation.class, operation.toUpperCase());

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -68,6 +68,7 @@ public class ParserKeywordsUtils {
             {"EXCEPT", RESTRICTED_SQL2016},
             {"EXCLUDES", RESTRICTED_JSQLPARSER},
             {"EXISTS", RESTRICTED_SQL2016},
+            {"FALSE", RESTRICTED_SQL2016},
             {"FETCH", RESTRICTED_SQL2016},
             {"FINAL", RESTRICTED_JSQLPARSER},
             {"FOR", RESTRICTED_SQL2016},
@@ -131,6 +132,7 @@ public class ParserKeywordsUtils {
             {"TABLES", RESTRICTED_ALIAS},
             {"TOP", RESTRICTED_SQL2016},
             {"TRAILING", RESTRICTED_SQL2016},
+            {"TRUE", RESTRICTED_SQL2016},
             {"UNBOUNDED", RESTRICTED_JSQLPARSER},
             {"UNION", RESTRICTED_SQL2016},
             {"UNIQUE", RESTRICTED_SQL2016},

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,7 +10,7 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, CONVERT, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, ADD_PARTITION, TRUNCATE_PARTITION, LOCK;
+    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, CONVERT, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, ADD_PARTITION, DROP_PARTITION, TRUNCATE_PARTITION, LOCK;
 
     public static AlterOperation from(String operation) {
         return Enum.valueOf(AlterOperation.class, operation.toUpperCase());

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,7 +10,7 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, CONVERT, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, TRUNCATE_PARTITION, LOCK;
+    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, CONVERT, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, ADD_PARTITION, TRUNCATE_PARTITION, LOCK;
 
     public static AlterOperation from(String operation) {
         return Enum.valueOf(AlterOperation.class, operation.toUpperCase());

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,7 +10,7 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, TRUNCATE_PARTITION;
+    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC, TRUNCATE_PARTITION, LOCK;
 
     public static AlterOperation from(String operation) {
         return Enum.valueOf(AlterOperation.class, operation.toUpperCase());

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -116,6 +116,7 @@ public class ParserKeywordsUtils {
             {"PIVOT", RESTRICTED_JSQLPARSER},
             {"PLUS", RESTRICTED_JSQLPARSER},
             {"PREFERRING", RESTRICTED_JSQLPARSER},
+            {"PRIOR", RESTRICTED_ALIAS},
             {"PROCEDURE", RESTRICTED_ALIAS},
             {"PUBLIC", RESTRICTED_ALIAS},
             {"RETURNING", RESTRICTED_JSQLPARSER},

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -3055,10 +3055,11 @@ public void testReservedKeyword2() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed(stmt);
     }
 
+    // PRIOR is a reserved keyword in Oracle
     @Test
     public void testReservedKeyword3() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed(
-                "SELECT * FROM mytable1 t JOIN mytable2 AS prior ON t.id = prior.id");
+                "SELECT * FROM mytable1 t JOIN mytable2 AS \"prior\" ON t.id = \"prior\".id");
     }
 
     @Test

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -80,7 +80,8 @@ public class SpecialOracleTest {
             "condition08.sql", "condition09.sql", "condition10.sql", "condition12.sql",
             "condition14.sql", "condition15.sql", "condition19.sql", "condition20.sql",
             "connect_by01.sql", "connect_by02.sql", "connect_by03.sql", "connect_by04.sql",
-            "connect_by05.sql", "connect_by06.sql", "connect_by07.sql", "datetime01.sql",
+            "connect_by05.sql", "connect_by06.sql", "connect_by07.sql", "connect_by08.sql",
+            "connect_by09.sql", "connect_by10.sql", "datetime01.sql",
             "datetime02.sql", "datetime04.sql", "datetime05.sql", "datetime06.sql", "dblink01.sql",
             "for_update01.sql", "for_update02.sql", "for_update03.sql", "function04.sql",
             "function05.sql", "for_update04.sql", "for_update05.sql", "for_update06.sql",

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -56,6 +56,7 @@ public class ParserKeywordsUtils {
             {"CHECK", RESTRICTED_SQL2016},
             {"CONNECT", RESTRICTED_ALIAS},
             {"CONNECT_BY_ROOT", RESTRICTED_JSQLPARSER},
+            {"PRIOR", RESTRICTED_JSQLPARSER},
             {"CONSTRAINT", RESTRICTED_SQL2016},
             {"CREATE", RESTRICTED_ALIAS},
             {"CROSS", RESTRICTED_SQL2016},

File: src/test/java/net/sf/jsqlparser/statement/select/PostgresTest.java
Patch:
@@ -11,6 +11,7 @@
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.expression.JsonExpression;
+import net.sf.jsqlparser.expression.StringValue;
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.Statements;
@@ -58,7 +59,7 @@ public void testJSonExpressionIssue1696() throws JSQLParserException {
         PlainSelect plainSelect = (PlainSelect) assertSqlCanBeParsedAndDeparsed(sqlStr, true);
         SelectItem<?> selectExpressionItem =
                 plainSelect.getSelectItems().get(0);
-        Assertions.assertEquals("'key'",
+        Assertions.assertEquals(new StringValue("key"),
                 selectExpressionItem.getExpression(JsonExpression.class).getIdent(0).getKey());
     }
 

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -27,6 +27,7 @@
 import net.sf.jsqlparser.expression.operators.relational.Between;
 import net.sf.jsqlparser.expression.operators.relational.ContainedBy;
 import net.sf.jsqlparser.expression.operators.relational.Contains;
+import net.sf.jsqlparser.expression.operators.relational.CosineSimilarity;
 import net.sf.jsqlparser.expression.operators.relational.DoubleAnd;
 import net.sf.jsqlparser.expression.operators.relational.EqualsTo;
 import net.sf.jsqlparser.expression.operators.relational.ExcludesExpression;
@@ -665,4 +666,6 @@ default void visit(PriorTo priorTo) {
     default void visit(Inverse inverse) {
         this.visit(inverse, null);
     }
+
+    <S> T visit(CosineSimilarity cosineSimilarity, S context);
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/DeleteDeParser.java
Patch:
@@ -95,6 +95,9 @@ public void deParse(Delete delete) {
 
         deparseWhereClause(delete);
 
+        if (delete.getPreferringClause() != null) {
+            buffer.append(" ").append(delete.getPreferringClause());
+        }
         if (delete.getOrderByElements() != null) {
             new OrderByDeParser(expressionVisitor, buffer).deParse(delete.getOrderByElements());
         }

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -93,6 +93,9 @@ public void deParse(Update update) {
 
         deparseWhereClause(update);
 
+        if (update.getPreferringClause() != null) {
+            buffer.append(" ").append(update.getPreferringClause());
+        }
         if (update.getOrderByElements() != null) {
             new OrderByDeParser(expressionVisitor, buffer).deParse(update.getOrderByElements());
         }

File: src/main/java/net/sf/jsqlparser/schema/MultiPartName.java
Patch:
@@ -27,7 +27,7 @@ static String unquote(String quotedIdentifier) {
     }
 
     static boolean isQuoted(String identifier) {
-        return LEADING_TRAILING_QUOTES_PATTERN.matcher(identifier).find();
+        return identifier!=null && LEADING_TRAILING_QUOTES_PATTERN.matcher(identifier).find();
     }
 
     String getFullyQualifiedName();

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -381,7 +381,7 @@ public <S> StringBuilder visit(DescribeStatement describe, S context) {
 
     @Override
     public <S> StringBuilder visit(ExplainStatement explainStatement, S context) {
-        buffer.append("EXPLAIN ");
+        buffer.append(explainStatement.getKeyword()).append(" ");
         if (explainStatement.getTable() != null) {
             buffer.append(explainStatement.getTable());
         } else if (explainStatement.getOptions() != null) {

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/LikeExpression.java
Patch:
@@ -117,7 +117,7 @@ public LikeExpression withRightExpression(Expression arg0) {
     }
 
     public enum KeyWord {
-        LIKE, ILIKE, RLIKE, REGEXP, SIMILAR_TO;
+        LIKE, ILIKE, RLIKE, REGEXP_LIKE, REGEXP, SIMILAR_TO;
 
         public static KeyWord from(String keyword) {
             return Enum.valueOf(KeyWord.class, keyword.toUpperCase().replaceAll("\\s+", "_"));

File: src/test/java/net/sf/jsqlparser/statement/StatementSeparatorTest.java
Patch:
@@ -53,7 +53,6 @@ void testNewLineNotGoIssue() throws JSQLParserException {
     void testOracleBlock() throws JSQLParserException {
         String sqlStr = "BEGIN\n" + "\n" + "SELECT * FROM TABLE;\n" + "\n" + "END\n" + "/\n";
         Statement statement = TestUtils.assertSqlCanBeParsedAndDeparsed(sqlStr, true);
-        System.out.println(statement);
     }
 
     @Test
@@ -69,14 +68,12 @@ void testSOQLIncludes() throws JSQLParserException {
         String sqlStr =
                 "select name,\ngoods from test_table where option includes ('option1', 'option2')";
         Statement statement = TestUtils.assertSqlCanBeParsedAndDeparsed(sqlStr, true);
-        System.out.println(statement);
     }
 
     @Test
     void testSOQLExcludes() throws JSQLParserException {
         String sqlStr =
                 "select name,\ngoods from test_table where option excludes ('option1', 'option2')";
         Statement statement = TestUtils.assertSqlCanBeParsedAndDeparsed(sqlStr, true);
-        System.out.println(statement);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapter.java
Patch:
@@ -711,7 +711,7 @@ public <S> T visit(GeometryDistance geometryDistance, S context) {
     public <S> T visit(Select select, S context) {
         if (selectVisitor != null) {
             if (select.getWithItemsList() != null) {
-                for (WithItem item : select.getWithItemsList()) {
+                for (WithItem<?> item : select.getWithItemsList()) {
                     item.accept(selectVisitor, context);
                 }
             }

File: src/main/java/net/sf/jsqlparser/statement/select/SelectVisitor.java
Patch:
@@ -29,9 +29,9 @@ default void visit(SetOperationList setOpList) {
         this.visit(setOpList, null);
     }
 
-    <S> T visit(WithItem withItem, S context);
+    <S> T visit(WithItem<?> withItem, S context);
 
-    default void visit(WithItem withItem) {
+    default void visit(WithItem<?> withItem) {
         this.visit(withItem, null);
     }
 

File: src/main/java/net/sf/jsqlparser/statement/select/SelectVisitorAdapter.java
Patch:
@@ -31,7 +31,7 @@ public <S> T visit(SetOperationList setOpList, S context) {
     }
 
     @Override
-    public <S> T visit(WithItem withItem, S context) {
+    public <S> T visit(WithItem<?> withItem, S context) {
         return withItem.getSelect().accept(this, context);
     }
 

File: src/main/java/net/sf/jsqlparser/util/AddAliasesVisitor.java
Patch:
@@ -100,7 +100,7 @@ public void setPrefix(String prefix) {
     }
 
     @Override
-    public <S> T visit(WithItem withItem, S context) {
+    public <S> T visit(WithItem<?> withItem, S context) {
         throw new UnsupportedOperationException(NOT_SUPPORTED_YET);
     }
 

File: src/main/java/net/sf/jsqlparser/util/ConnectExpressionsVisitor.java
Patch:
@@ -99,7 +99,7 @@ public <S> T visit(SetOperationList setOpList, S context) {
     }
 
     @Override
-    public <S> T visit(WithItem withItem, S context) {
+    public <S> T visit(WithItem<?> withItem, S context) {
         return null;
     }
 

File: src/main/java/net/sf/jsqlparser/util/deparser/DeleteDeParser.java
Patch:
@@ -40,8 +40,9 @@ public DeleteDeParser(ExpressionVisitor<StringBuilder> expressionVisitor,
     public void deParse(Delete delete) {
         if (delete.getWithItemsList() != null && !delete.getWithItemsList().isEmpty()) {
             buffer.append("WITH ");
-            for (Iterator<WithItem> iter = delete.getWithItemsList().iterator(); iter.hasNext();) {
-                WithItem withItem = iter.next();
+            for (Iterator<WithItem<?>> iter = delete.getWithItemsList().iterator(); iter
+                    .hasNext();) {
+                WithItem<?> withItem = iter.next();
                 buffer.append(withItem);
                 if (iter.hasNext()) {
                     buffer.append(",");

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -633,7 +633,7 @@ public <S> StringBuilder visit(Select select, S context) {
         if (selectVisitor != null) {
             if (select.getWithItemsList() != null) {
                 buffer.append("WITH ");
-                for (Iterator<WithItem> iter = select.getWithItemsList().iterator(); iter
+                for (Iterator<WithItem<?>> iter = select.getWithItemsList().iterator(); iter
                         .hasNext();) {
                     iter.next().accept(selectVisitor, null);
                     if (iter.hasNext()) {

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -41,8 +41,9 @@ public InsertDeParser(ExpressionVisitor<StringBuilder> expressionVisitor,
     public void deParse(Insert insert) {
         if (insert.getWithItemsList() != null && !insert.getWithItemsList().isEmpty()) {
             buffer.append("WITH ");
-            for (Iterator<WithItem> iter = insert.getWithItemsList().iterator(); iter.hasNext();) {
-                WithItem withItem = iter.next();
+            for (Iterator<WithItem<?>> iter = insert.getWithItemsList().iterator(); iter
+                    .hasNext();) {
+                WithItem<?> withItem = iter.next();
                 withItem.accept(this.selectVisitor, null);
                 if (iter.hasNext()) {
                     buffer.append(",");

File: src/main/java/net/sf/jsqlparser/util/deparser/MergeDeParser.java
Patch:
@@ -30,11 +30,11 @@ public MergeDeParser(ExpressionDeParser expressionDeParser, SelectDeParser selec
 
     @Override
     public void deParse(Merge merge) {
-        List<WithItem> withItemsList = merge.getWithItemsList();
+        List<WithItem<?>> withItemsList = merge.getWithItemsList();
         if (withItemsList != null && !withItemsList.isEmpty()) {
             buffer.append("WITH ");
-            for (Iterator<WithItem> iter = withItemsList.iterator(); iter.hasNext();) {
-                iter.next().accept(expressionDeParser, null);
+            for (Iterator<WithItem<?>> iter = withItemsList.iterator(); iter.hasNext();) {
+                iter.next().accept(selectDeParser, null);
                 if (iter.hasNext()) {
                     buffer.append(",");
                 }

File: src/main/java/net/sf/jsqlparser/util/deparser/TableStatementDeParser.java
Patch:
@@ -67,7 +67,7 @@ public <S> StringBuilder visit(SetOperationList setOperationList, S context) {
     }
 
     @Override
-    public <S> StringBuilder visit(WithItem withItem, S context) {
+    public <S> StringBuilder visit(WithItem<?> withItem, S context) {
 
         return buffer;
     }

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -40,8 +40,9 @@ public UpdateDeParser(ExpressionVisitor<StringBuilder> expressionVisitor,
     public void deParse(Update update) {
         if (update.getWithItemsList() != null && !update.getWithItemsList().isEmpty()) {
             buffer.append("WITH ");
-            for (Iterator<WithItem> iter = update.getWithItemsList().iterator(); iter.hasNext();) {
-                WithItem withItem = iter.next();
+            for (Iterator<WithItem<?>> iter = update.getWithItemsList().iterator(); iter
+                    .hasNext();) {
+                WithItem<?> withItem = iter.next();
                 buffer.append(withItem);
                 if (iter.hasNext()) {
                     buffer.append(",");

File: src/test/java/net/sf/jsqlparser/util/deparser/StatementDeParserTest.java
Patch:
@@ -108,7 +108,7 @@ public void shouldUseProvidedDeparsersWhenDeParsingInsert() {
         duplicateUpdateSets.add(new UpdateSet(duplicateUpdateColumn2, duplicateUpdateExpression2));
 
         PlainSelect select = mock(PlainSelect.class);
-        List<WithItem> withItemsList = new ArrayList<WithItem>();
+        List<WithItem<?>> withItemsList = new ArrayList<WithItem<?>>();
         WithItem withItem1 = spy(new WithItem());
         WithItem withItem2 = spy(new WithItem());
         ParenthesedSelect withItem1SubSelect = mock(ParenthesedSelect.class);
@@ -140,7 +140,7 @@ public void shouldUseProvidedDeParsersWhenDeParsingSelect() {
         WithItem withItem2 = spy(new WithItem());
         withItem2.setSelect(mock(ParenthesedSelect.class));
 
-        List<WithItem> withItemsList = new ArrayList<WithItem>();
+        List<WithItem<?>> withItemsList = new ArrayList<WithItem<?>>();
         withItemsList.add(withItem1);
         withItemsList.add(withItem2);
 
@@ -289,7 +289,7 @@ public void shouldUseProvidedDeparsersWhenDeParsingUpsertWithExpressionList() {
         Expression duplicateUpdateExpression1 = mock(Expression.class);
         Expression duplicateUpdateExpression2 = mock(Expression.class);
         PlainSelect select = mock(PlainSelect.class);
-        List<WithItem> withItemsList = new ArrayList<WithItem>();
+        List<WithItem<?>> withItemsList = new ArrayList<WithItem<?>>();
         WithItem withItem1 = spy(new WithItem());
         WithItem withItem2 = spy(new WithItem());
         ParenthesedSelect withItem1SubSelect = mock(ParenthesedSelect.class);

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -306,7 +306,7 @@ public <S> StringBuilder visit(ShowTablesStatement showTables, S context) {
     public <S> StringBuilder visit(Block block, S context) {
         buffer.append("BEGIN\n");
         if (block.getStatements() != null) {
-            for (Statement stmt : block.getStatements().getStatements()) {
+            for (Statement stmt : block.getStatements()) {
                 stmt.accept(this, context);
                 buffer.append(";\n");
             }

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -60,6 +60,7 @@ public class ParserKeywordsUtils {
             {"CREATE", RESTRICTED_ALIAS},
             {"CROSS", RESTRICTED_SQL2016},
             {"CURRENT", RESTRICTED_JSQLPARSER},
+            {"DEFAULT", RESTRICTED_ALIAS},
             {"DISTINCT", RESTRICTED_SQL2016},
             {"DOUBLE", RESTRICTED_ALIAS},
             {"ELSE", RESTRICTED_JSQLPARSER},

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -312,7 +312,7 @@ public static void buildGrammarForRelObjectNameWithoutValue(File file) throws Ex
                 + "{    Token tk = null; }\n"
                 + "{\n"
                 // @todo: find a way to avoid those hardcoded compound tokens
-                + "    ( tk=<DATA_TYPE> | tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> |  tk=<K_DATE_LITERAL> | tk=<K_DATETIMELITERAL> | tk=<K_STRING_FUNCTION_NAME> | tk=<K_ISOLATION> | tk=<K_TIME_KEY_EXPR> \n"
+                + "    ( tk=<DATA_TYPE> | tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> |  tk=<K_DATE_LITERAL> | tk=<K_DATETIMELITERAL> | tk=<K_STRING_FUNCTION_NAME> | tk=<K_ISOLATION> | tk=<K_TIME_KEY_EXPR> | tk=<K_TEXT_LITERAL> \n"
                 + "      ");
 
         for (String keyword : allKeywords) {

File: src/test/java/net/sf/jsqlparser/parser/ParserKeywordsUtilsTest.java
Patch:
@@ -52,7 +52,7 @@ class ParserKeywordsUtilsTest {
 
 
     private static void addTokenImage(TreeSet<String> allKeywords, RStringLiteral literal) {
-        if (CHARSET_ENCODER.canEncode(literal.image) && literal.image.matches("[A-Za-z]+")) {
+        if (CHARSET_ENCODER.canEncode(literal.image) && literal.image.matches("\\w+")) {
             allKeywords.add(literal.image);
         }
     }

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -1330,9 +1330,6 @@ public void visit(UseStatement use) {
 
     @Override
     public <S> Void visit(ParenthesedFromItem parenthesis, S context) {
-        if (parenthesis.getAlias() != null) {
-            otherItemNames.add(parenthesis.getAlias().getName());
-        }
         parenthesis.getFromItem().accept(this, context);
         // support join keyword in fromItem
         visitJoins(parenthesis.getJoins(), context);

File: src/main/java/net/sf/jsqlparser/expression/Alias.java
Patch:
@@ -16,6 +16,7 @@
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
+
 import net.sf.jsqlparser.statement.create.table.ColDataType;
 
 public class Alias implements Serializable {

File: src/main/java/net/sf/jsqlparser/expression/AllValue.java
Patch:
@@ -14,8 +14,8 @@
 public class AllValue extends ASTNodeAccessImpl implements Expression {
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -41,7 +41,7 @@ public class AnalyticExpression extends ASTNodeAccessImpl implements Expression
     private Expression filterExpression = null;
     private List<OrderByElement> funcOrderBy = null;
     private String windowName = null; // refers to an external window definition (paritionBy,
-                                      // orderBy, windowElement)
+    // orderBy, windowElement)
     private WindowDefinition windowDef = new WindowDefinition();
 
     private Function.HavingClause havingClause;
@@ -84,8 +84,8 @@ public AnalyticExpression(Function function) {
 
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public List<OrderByElement> getOrderByElements() {

File: src/main/java/net/sf/jsqlparser/expression/AnyComparisonExpression.java
Patch:
@@ -32,8 +32,8 @@ public Select getSelect() {
 
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public AnyType getAnyType() {

File: src/main/java/net/sf/jsqlparser/expression/ArrayExpression.java
Patch:
@@ -73,8 +73,8 @@ public void setStopIndexExpression(Expression stopIndexExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/CollateExpression.java
Patch:
@@ -26,8 +26,8 @@ public CollateExpression(Expression leftExpression, String collate) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public Expression getLeftExpression() {

File: src/main/java/net/sf/jsqlparser/expression/ConnectByRootOperator.java
Patch:
@@ -26,11 +26,11 @@
 package net.sf.jsqlparser.expression;
 
 import java.util.Objects;
+
 import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.schema.Column;
 
 /**
- *
  * @author are
  */
 public class ConnectByRootOperator extends ASTNodeAccessImpl implements Expression {
@@ -46,8 +46,8 @@ public Column getColumn() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public StringBuilder appendTo(StringBuilder builder) {

File: src/main/java/net/sf/jsqlparser/expression/DateTimeLiteralExpression.java
Patch:
@@ -33,8 +33,8 @@ public void setType(DateTime type) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/DateValue.java
Patch:
@@ -38,8 +38,8 @@ public DateValue(String value) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public Date getValue() {

File: src/main/java/net/sf/jsqlparser/expression/DoubleValue.java
Patch:
@@ -41,8 +41,8 @@ public DoubleValue(final double value) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public double getValue() {

File: src/main/java/net/sf/jsqlparser/expression/ExtractExpression.java
Patch:
@@ -23,8 +23,8 @@ public class ExtractExpression extends ASTNodeAccessImpl implements Expression {
     private Expression expression;
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public String getName() {

File: src/main/java/net/sf/jsqlparser/expression/IntervalExpression.java
Patch:
@@ -15,9 +15,9 @@
 
 public class IntervalExpression extends ASTNodeAccessImpl implements Expression {
 
+    private final boolean intervalKeyword;
     private String parameter = null;
     private String intervalType = null;
-    private final boolean intervalKeyword;
     private Expression expression = null;
 
     public IntervalExpression() {
@@ -71,8 +71,8 @@ public String toString() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public IntervalExpression withParameter(String parameter) {

File: src/main/java/net/sf/jsqlparser/expression/JdbcNamedParameter.java
Patch:
@@ -39,8 +39,8 @@ public void setName(String name) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/JdbcParameter.java
Patch:
@@ -67,8 +67,8 @@ public void setUseFixedIndex(boolean useFixedIndex) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/JsonAggregateOnNullType.java
Patch:
@@ -26,7 +26,6 @@
 package net.sf.jsqlparser.expression;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 public enum JsonAggregateOnNullType {

File: src/main/java/net/sf/jsqlparser/expression/JsonAggregateUniqueKeysType.java
Patch:
@@ -26,7 +26,6 @@
 package net.sf.jsqlparser.expression;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 public enum JsonAggregateUniqueKeysType {

File: src/main/java/net/sf/jsqlparser/expression/JsonFunctionExpression.java
Patch:
@@ -14,7 +14,6 @@
 import java.util.Objects;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 
@@ -26,6 +25,7 @@ public class JsonFunctionExpression implements Serializable {
     public JsonFunctionExpression(Expression expression) {
         this.expression = Objects.requireNonNull(expression, "The EXPRESSION must not be null");
     }
+
     public Expression getExpression() {
         return expression;
     }
@@ -37,12 +37,12 @@ public boolean isUsingFormatJson() {
     public void setUsingFormatJson(boolean usingFormatJson) {
         this.usingFormatJson = usingFormatJson;
     }
-    
+
     public JsonFunctionExpression withUsingFormatJson(boolean usingFormatJson) {
         this.setUsingFormatJson(usingFormatJson);
         return this;
     }
-    
+
     public StringBuilder append(StringBuilder builder) {
         return builder.append(getExpression()).append(isUsingFormatJson() ? " FORMAT JSON" : "");
     }

File: src/main/java/net/sf/jsqlparser/expression/JsonFunctionType.java
Patch:
@@ -11,7 +11,6 @@
 package net.sf.jsqlparser.expression;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 public enum JsonFunctionType {

File: src/main/java/net/sf/jsqlparser/expression/KeepExpression.java
Patch:
@@ -14,6 +14,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
+
 import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.OrderByElement;
 
@@ -24,8 +25,8 @@ public class KeepExpression extends ASTNodeAccessImpl implements Expression {
     private boolean first = false;
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public List<OrderByElement> getOrderByElements() {

File: src/main/java/net/sf/jsqlparser/expression/LambdaExpression.java
Patch:
@@ -66,7 +66,7 @@ public String toString() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/MySQLGroupConcat.java
Patch:
@@ -59,8 +59,8 @@ public void setSeparator(String separator) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/NextValExpression.java
Patch:
@@ -6,6 +6,7 @@
 
 import java.util.List;
 import java.util.regex.Pattern;
+
 import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 public class NextValExpression extends ASTNodeAccessImpl implements Expression {
@@ -59,7 +60,7 @@ public String toString() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/NotExpression.java
Patch:
@@ -42,8 +42,8 @@ public final void setExpression(Expression expression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/NullValue.java
Patch:
@@ -14,8 +14,8 @@
 public class NullValue extends ASTNodeAccessImpl implements Expression {
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/NumericBind.java
Patch:
@@ -24,8 +24,8 @@ public void setBindId(int bindId) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/OracleHierarchicalExpression.java
Patch:
@@ -13,10 +13,10 @@
 
 public class OracleHierarchicalExpression extends ASTNodeAccessImpl implements Expression {
 
+    boolean connectFirst = false;
     private Expression startExpression;
     private Expression connectExpression;
     private boolean noCycle = false;
-    boolean connectFirst = false;
 
     public Expression getStartExpression() {
         return startExpression;
@@ -51,8 +51,8 @@ public void setConnectFirst(boolean connectFirst) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/OracleNamedFunctionParameter.java
Patch:
@@ -10,10 +10,10 @@
 package net.sf.jsqlparser.expression;
 
 import java.util.Objects;
+
 import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 public class OracleNamedFunctionParameter extends ASTNodeAccessImpl implements Expression {
@@ -36,8 +36,8 @@ public Expression getExpression() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public StringBuilder appendTo(StringBuilder builder) {

File: src/main/java/net/sf/jsqlparser/expression/OverlapsCondition.java
Patch:
@@ -30,8 +30,8 @@ public ExpressionList<?> getRight() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/RangeExpression.java
Patch:
@@ -44,7 +44,7 @@ public String toString() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/RowConstructor.java
Patch:
@@ -42,7 +42,7 @@ public RowConstructor<?> withName(String name) {
     }
 
     @Override
-    public <K, S> K accept(ExpressionVisitor<K> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <K, S> K accept(ExpressionVisitor<K> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/RowGetExpression.java
Patch:
@@ -21,8 +21,8 @@ public RowGetExpression(Expression expression, String columnName) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/SQLServerHints.java
Patch:
@@ -18,8 +18,7 @@ public class SQLServerHints implements Serializable {
     private Boolean noLock;
     private String indexName;
 
-    public SQLServerHints() {
-    }
+    public SQLServerHints() {}
 
     public SQLServerHints withNoLock() {
         this.noLock = true;

File: src/main/java/net/sf/jsqlparser/expression/SignedExpression.java
Patch:
@@ -48,8 +48,8 @@ public final void setExpression(Expression expression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/TimeKeyExpression.java
Patch:
@@ -24,8 +24,8 @@ public TimeKeyExpression(final String value) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public String getStringValue() {

File: src/main/java/net/sf/jsqlparser/expression/TimeValue.java
Patch:
@@ -32,8 +32,8 @@ public TimeValue(String value) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public Time getValue() {

File: src/main/java/net/sf/jsqlparser/expression/TimestampValue.java
Patch:
@@ -19,9 +19,9 @@
  */
 public final class TimestampValue extends ASTNodeAccessImpl implements Expression {
 
+    private static final char QUOTATION = '\'';
     private Timestamp value;
     private String rawValue;
-    private static final char QUOTATION = '\'';
 
     public TimestampValue() {
         // empty constructor
@@ -37,8 +37,8 @@ public TimestampValue(String value) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public Timestamp getValue() {

File: src/main/java/net/sf/jsqlparser/expression/TimezoneExpression.java
Patch:
@@ -17,8 +17,8 @@
 
 public class TimezoneExpression extends ASTNodeAccessImpl implements Expression {
 
-    private Expression leftExpression;
     private final ExpressionList<Expression> timezoneExpressions = new ExpressionList<>();
+    private Expression leftExpression;
 
     public TimezoneExpression() {
         leftExpression = null;
@@ -39,8 +39,8 @@ public TimezoneExpression setLeftExpression(Expression expression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public List<Expression> getTimezoneExpressions() {

File: src/main/java/net/sf/jsqlparser/expression/TranscodingFunction.java
Patch:
@@ -80,8 +80,8 @@ public TranscodingFunction setTranscodeStyle(boolean transcodeStyle) {
         return this;
     }
 
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public StringBuilder appendTo(StringBuilder builder) {

File: src/main/java/net/sf/jsqlparser/expression/UserVariable.java
Patch:
@@ -36,8 +36,8 @@ public void setName(String name) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public boolean isDoubleAdd() {

File: src/main/java/net/sf/jsqlparser/expression/VariableAssignment.java
Patch:
@@ -50,8 +50,8 @@ public String toString() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
 

File: src/main/java/net/sf/jsqlparser/expression/WhenClause.java
Patch:
@@ -27,8 +27,8 @@ public WhenClause(Expression whenExpression, Expression thenExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public Expression getThenExpression() {

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/Addition.java
Patch:
@@ -22,8 +22,8 @@ public Addition(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/BitwiseAnd.java
Patch:
@@ -22,8 +22,8 @@ public BitwiseAnd(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/BitwiseLeftShift.java
Patch:
@@ -22,8 +22,8 @@ public BitwiseLeftShift(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/BitwiseOr.java
Patch:
@@ -22,8 +22,8 @@ public BitwiseOr(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/BitwiseRightShift.java
Patch:
@@ -22,8 +22,8 @@ public BitwiseRightShift(Expression leftExpression, Expression rightExpression)
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/BitwiseXor.java
Patch:
@@ -22,8 +22,8 @@ public BitwiseXor(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/Concat.java
Patch:
@@ -22,8 +22,8 @@ public Concat(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/Division.java
Patch:
@@ -22,8 +22,8 @@ public Division(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/IntegerDivision.java
Patch:
@@ -22,8 +22,8 @@ public IntegerDivision(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/Modulo.java
Patch:
@@ -25,8 +25,8 @@ public Modulo(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/Multiplication.java
Patch:
@@ -22,8 +22,8 @@ public Multiplication(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/arithmetic/Subtraction.java
Patch:
@@ -22,8 +22,8 @@ public Subtraction(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/conditional/OrExpression.java
Patch:
@@ -35,8 +35,8 @@ public OrExpression withRightExpression(Expression expression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/conditional/XorExpression.java
Patch:
@@ -35,8 +35,8 @@ public XorExpression withRightExpression(Expression expression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ContainedBy.java
Patch:
@@ -18,8 +18,8 @@ public ContainedBy() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }
 

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/Contains.java
Patch:
@@ -18,8 +18,8 @@ public Contains() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }
 

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/DoubleAnd.java
Patch:
@@ -18,7 +18,7 @@ public DoubleAnd() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/EqualsTo.java
Patch:
@@ -25,8 +25,8 @@ public EqualsTo(Expression left, Expression right) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExistsExpression.java
Patch:
@@ -35,8 +35,8 @@ public void setNot(boolean b) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     public String getStringExpression() {

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/GeometryDistance.java
Patch:
@@ -22,7 +22,7 @@ public GeometryDistance(String operator) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/GreaterThan.java
Patch:
@@ -23,8 +23,8 @@ public GreaterThan(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/GreaterThanEquals.java
Patch:
@@ -27,8 +27,8 @@ public GreaterThanEquals(Expression leftExpression, Expression rightExpression)
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/IsDistinctExpression.java
Patch:
@@ -25,8 +25,8 @@ public void setNot(boolean b) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/JsonOperator.java
Patch:
@@ -22,8 +22,8 @@ public JsonOperator(String op) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/Matches.java
Patch:
@@ -15,8 +15,8 @@
 public class Matches extends OldOracleJoinBinaryExpression {
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/MemberOfExpression.java
Patch:
@@ -57,7 +57,7 @@ public String toString() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/MinorThan.java
Patch:
@@ -23,8 +23,8 @@ public MinorThan(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/MinorThanEquals.java
Patch:
@@ -27,8 +27,8 @@ public MinorThanEquals(Expression leftExpression, Expression rightExpression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/NotEqualsTo.java
Patch:
@@ -39,8 +39,8 @@ public NotEqualsTo withRightExpression(Expression expression) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/RegExpMatchOperator.java
Patch:
@@ -10,6 +10,7 @@
 package net.sf.jsqlparser.expression.operators.relational;
 
 import java.util.Objects;
+
 import net.sf.jsqlparser.expression.BinaryExpression;
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
@@ -28,8 +29,8 @@ public RegExpMatchOperatorType getOperatorType() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/SimilarToExpression.java
Patch:
@@ -27,8 +27,8 @@ public void setNot(boolean b) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/TSQLLeftJoin.java
Patch:
@@ -18,7 +18,7 @@ public TSQLLeftJoin() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/TSQLRightJoin.java
Patch:
@@ -18,7 +18,7 @@ public TSQLRightJoin() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -193,7 +193,7 @@ public static List<String> getReservedKeywords(int restriction) {
      */
     public static void main(String[] args) throws Exception {
         if (args.length < 2) {
-            throw new IllegalArgumentException("No filename provided as parameters ARGS[0]");
+            throw new IllegalArgumentException("No filename provided aS context ARGS[0]");
         }
 
         File grammarFile = new File(args[0]);

File: src/main/java/net/sf/jsqlparser/parser/StatementListener.java
Patch:
@@ -12,7 +12,6 @@
 import net.sf.jsqlparser.statement.Statement;
 
 /**
- *
  * @author Tobias Warneke (t.warneke@gmx.net)
  */
 public interface StatementListener {

File: src/main/java/net/sf/jsqlparser/parser/feature/FeatureConfiguration.java
Patch:
@@ -24,7 +24,7 @@ public class FeatureConfiguration {
     public FeatureConfiguration() {
         // set default-value for all switchable features
         EnumSet.allOf(Feature.class).stream().filter(Feature::isConfigurable)
-        .forEach(f -> setValue(f, f.getDefaultValue()));
+                .forEach(f -> setValue(f, f.getDefaultValue()));
     }
 
     /**
@@ -46,8 +46,7 @@ public FeatureConfiguration setValue(Feature feature, Object value) {
     /**
      * @param feature
      * @return the configured feature value - can be <code>null</code>
-     * @throws IllegalStateException - if given {@link Feature#isConfigurable()} ==
-     *                               false
+     * @throws IllegalStateException - if given {@link Feature#isConfigurable()} == false
      */
     public Object getValue(Feature feature) {
         if (feature.isConfigurable()) {

File: src/main/java/net/sf/jsqlparser/schema/Synonym.java
Patch:
@@ -23,8 +23,7 @@ public class Synonym extends ASTNodeAccessImpl implements MultiPartName {
     private static final int SERVER_IDX = 3;
     private List<String> partItems = new ArrayList<>();
 
-    public Synonym() {
-    }
+    public Synonym() {}
 
     public Synonym(List<String> partItems) {
         this.partItems = new ArrayList<>(partItems);

File: src/main/java/net/sf/jsqlparser/statement/Block.java
Patch:
@@ -31,8 +31,8 @@ public void setSemicolonAfterEnd(boolean hasSemicolonAfterEnd) {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public StringBuilder appendTo(StringBuilder builder) {

File: src/main/java/net/sf/jsqlparser/statement/Commit.java
Patch:
@@ -11,8 +11,8 @@
 
 public class Commit implements Statement {
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/DeclareType.java
Patch:
@@ -10,7 +10,6 @@
 package net.sf.jsqlparser.statement;
 
 /**
- *
  * @author tobens
  */
 public enum DeclareType {

File: src/main/java/net/sf/jsqlparser/statement/DescribeStatement.java
Patch:
@@ -38,8 +38,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public DescribeStatement withTable(Table table) {

File: src/main/java/net/sf/jsqlparser/statement/PurgeObjectType.java
Patch:
@@ -10,7 +10,6 @@
 package net.sf.jsqlparser.statement;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 public enum PurgeObjectType {

File: src/main/java/net/sf/jsqlparser/statement/PurgeStatement.java
Patch:
@@ -11,11 +11,11 @@
 package net.sf.jsqlparser.statement;
 
 import java.util.Objects;
+
 import net.sf.jsqlparser.schema.Table;
 import net.sf.jsqlparser.statement.create.table.Index;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  * @see <a href=
  *      "https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9018.htm">Purge</a>
@@ -51,8 +51,8 @@ public PurgeStatement(PurgeObjectType purgeObjectType, String tableSpaceName, St
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     @SuppressWarnings({"PMD.MissingBreakInSwitch", "PMD.SwitchStmtsShouldHaveDefault",

File: src/main/java/net/sf/jsqlparser/statement/ReferentialAction.java
Patch:
@@ -62,9 +62,8 @@ public int hashCode() {
 
     @Override
     public String toString() {
-        return new StringBuilder(" ON ").append(getType().name()).append(" ")
-                .append(getAction().getAction())
-                .toString();
+        return " ON " + getType().name() + " " +
+                getAction().getAction();
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/ResetStatement.java
Patch:
@@ -41,8 +41,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
 }

File: src/main/java/net/sf/jsqlparser/statement/ShowColumnsStatement.java
Patch:
@@ -35,8 +35,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public ShowColumnsStatement withTableName(String tableName) {

File: src/main/java/net/sf/jsqlparser/statement/ShowStatement.java
Patch:
@@ -35,8 +35,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public ShowStatement withName(String name) {

File: src/main/java/net/sf/jsqlparser/statement/Statements.java
Patch:
@@ -26,8 +26,8 @@ public void setStatements(List<Statement> statements) {
         this.addAll(statements);
     }
 
-    public void accept(StatementVisitor<?> statementVisitor) {
-        statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public <E extends Statement> E get(Class<E> type, int index) {

File: src/main/java/net/sf/jsqlparser/statement/UnsupportedStatement.java
Patch:
@@ -15,7 +15,6 @@
 import java.util.Objects;
 
 /**
- *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 
@@ -35,8 +34,8 @@ public UnsupportedStatement(String upfront, List<String> declarations) {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     @SuppressWarnings({"PMD.MissingBreakInSwitch", "PMD.SwitchStmtsShouldHaveDefault",

File: src/main/java/net/sf/jsqlparser/statement/UseStatement.java
Patch:
@@ -49,8 +49,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public UseStatement withName(String name) {

File: src/main/java/net/sf/jsqlparser/statement/alter/Alter.java
Patch:
@@ -15,6 +15,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
+
 import net.sf.jsqlparser.schema.Table;
 import net.sf.jsqlparser.statement.Statement;
 import net.sf.jsqlparser.statement.StatementVisitor;
@@ -73,8 +74,8 @@ public void setAlterExpressions(List<AlterExpression> alterExpressions) {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterSessionOperation.java
Patch:
@@ -11,7 +11,6 @@
 package net.sf.jsqlparser.statement.alter;
 
 /**
- *
  * @author are
  */
 public enum AlterSessionOperation {

File: src/main/java/net/sf/jsqlparser/statement/alter/RenameTableStatement.java
Patch:
@@ -15,12 +15,12 @@
 import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Set;
+
 import net.sf.jsqlparser.schema.Table;
 import net.sf.jsqlparser.statement.Statement;
 import net.sf.jsqlparser.statement.StatementVisitor;
 
 /**
- *
  * @author are
  * @see <a href=
  *      "https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_9019.htm">Rename</a>
@@ -115,8 +115,8 @@ public Set<Map.Entry<Table, Table>> getTableNames() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public StringBuilder appendTo(StringBuilder builder) {

File: src/main/java/net/sf/jsqlparser/statement/analyze/Analyze.java
Patch:
@@ -18,8 +18,8 @@ public class Analyze implements Statement {
     private Table table;
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public Table getTable() {

File: src/main/java/net/sf/jsqlparser/statement/comment/Comment.java
Patch:
@@ -23,8 +23,8 @@ public class Comment implements Statement {
     private StringValue comment;
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public Table getTable() {

File: src/main/java/net/sf/jsqlparser/statement/create/function/CreateFunction.java
Patch:
@@ -26,7 +26,7 @@ public CreateFunction() {
     public CreateFunction(List<String> functionDeclarationParts) {
         this(false, functionDeclarationParts);
     }
-    
+
     public CreateFunction(boolean orReplace, List<String> functionDeclarationParts) {
         super(orReplace, "FUNCTION", functionDeclarationParts);
     }

File: src/main/java/net/sf/jsqlparser/statement/create/procedure/CreateProcedure.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Collection;
 import java.util.List;
+
 import net.sf.jsqlparser.statement.CreateFunctionalStatement;
 
 /**
@@ -41,7 +42,8 @@ public CreateProcedure addFunctionDeclarationParts(String... functionDeclaration
     }
 
     @Override
-    public CreateProcedure addFunctionDeclarationParts(Collection<String> functionDeclarationParts) {
+    public CreateProcedure addFunctionDeclarationParts(
+            Collection<String> functionDeclarationParts) {
         return (CreateProcedure) super.addFunctionDeclarationParts(functionDeclarationParts);
     }
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/CheckConstraint.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Collection;
 import java.util.List;
+
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.schema.Table;
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/CreateTable.java
Patch:
@@ -42,8 +42,8 @@ public class CreateTable implements Statement {
     private SpannerInterleaveIn interleaveIn = null;
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public Table getTable() {

File: src/main/java/net/sf/jsqlparser/statement/create/table/ExcludeConstraint.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Collection;
 import java.util.List;
+
 import net.sf.jsqlparser.expression.Expression;
 
 public class ExcludeConstraint extends Index {
@@ -74,7 +75,8 @@ public ExcludeConstraint addColumns(ColumnParams... functionDeclarationParts) {
     }
 
     @Override
-    public ExcludeConstraint addColumns(Collection<? extends ColumnParams> functionDeclarationParts) {
+    public ExcludeConstraint addColumns(
+            Collection<? extends ColumnParams> functionDeclarationParts) {
         return (ExcludeConstraint) super.addColumns(functionDeclarationParts);
     }
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/NamedConstraint.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Collection;
 import java.util.List;
+
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
 public class NamedConstraint extends Index {

File: src/main/java/net/sf/jsqlparser/statement/create/table/RowMovement.java
Patch:
@@ -12,7 +12,8 @@
 import java.io.Serializable;
 
 /**
- * Holds data for the {@code row_movement} clause: https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_7002.htm#i2204697
+ * Holds data for the {@code row_movement} clause:
+ * https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_7002.htm#i2204697
  */
 public class RowMovement implements Serializable {
 

File: src/main/java/net/sf/jsqlparser/statement/create/view/CreateView.java
Patch:
@@ -10,6 +10,7 @@
 package net.sf.jsqlparser.statement.create.view;
 
 import java.util.List;
+
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.schema.Table;
@@ -34,8 +35,8 @@ public class CreateView implements Statement {
     private List<String> viewCommentOptions = null;
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public Table getView() {

File: src/main/java/net/sf/jsqlparser/statement/execute/Execute.java
Patch:
@@ -63,8 +63,8 @@ public boolean isParenthesis() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/insert/Insert.java
Patch:
@@ -74,8 +74,8 @@ public void setOutputClause(OutputClause outputClause) {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public Table getTable() {

File: src/main/java/net/sf/jsqlparser/statement/insert/InsertConflictTarget.java
Patch:
@@ -16,14 +16,14 @@
 
 /**
  * https://www.postgresql.org/docs/current/sql-insert.html
- * 
+ *
  * <pre>
  * conflict_target can be one of:
  *
  *     ( { index_column_name | ( index_expression ) } [ COLLATE collation ] [ opclass ] [, ...] ) [ WHERE index_predicate ]
  *     ON CONSTRAINT constraint_name
  * </pre>
- * 
+ * <p>
  * Currently, COLLATE is not supported yet.
  */
 public class InsertConflictTarget implements Serializable {

File: src/main/java/net/sf/jsqlparser/statement/merge/Merge.java
Patch:
@@ -192,8 +192,8 @@ public void setMergeUpdate(MergeUpdate mergeUpdate) {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public boolean isInsertFirst() {

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeDelete.java
Patch:
@@ -30,8 +30,8 @@ public MergeDelete withAndPredicate(Expression andPredicate) {
     }
 
     @Override
-    public void accept(MergeOperationVisitor mergeOperationVisitor) {
-        mergeOperationVisitor.visit(this);
+    public <S, T> T accept(MergeOperationVisitor<T> mergeOperationVisitor, S context) {
+        return mergeOperationVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeInsert.java
Patch:
@@ -58,8 +58,8 @@ public void setWhereCondition(Expression whereCondition) {
     }
 
     @Override
-    public void accept(MergeOperationVisitor mergeOperationVisitor) {
-        mergeOperationVisitor.visit(this);
+    public <S, T> T accept(MergeOperationVisitor<T> mergeOperationVisitor, S context) {
+        return mergeOperationVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeOperation.java
Patch:
@@ -13,5 +13,5 @@
  * Marker interface to cover {@link MergeDelete}, {@link MergeUpdate} and {@link MergeInsert}
  */
 public interface MergeOperation {
-    void accept(MergeOperationVisitor mergeOperationVisitor);
+    <S, T> T accept(MergeOperationVisitor<T> mergeOperationVisitor, S context);
 }

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeUpdate.java
Patch:
@@ -62,8 +62,8 @@ public void setDeleteWhereCondition(Expression deleteWhereCondition) {
     }
 
     @Override
-    public void accept(MergeOperationVisitor mergeOperationVisitor) {
-        mergeOperationVisitor.visit(this);
+    public <S, T> T accept(MergeOperationVisitor<T> mergeOperationVisitor, S context) {
+        return mergeOperationVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/refresh/RefreshMaterializedViewStatement.java
Patch:
@@ -91,8 +91,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public RefreshMaterializedViewStatement withTableName(Table view) {

File: src/main/java/net/sf/jsqlparser/statement/select/AllTableColumns.java
Patch:
@@ -59,7 +59,7 @@ public StringBuilder appendTo(StringBuilder builder) {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S arguments) {
-        return expressionVisitor.visit(this, arguments);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(this, context);
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/select/IntoTableVisitorAdapter.java
Patch:
@@ -15,7 +15,7 @@
 public class IntoTableVisitorAdapter<T> implements IntoTableVisitor<T> {
 
     @Override
-    public <S> T visit(Table tableName, S parameters) {
+    public <S> T visit(Table tableName, S context) {
         return null;
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/select/MySqlSqlCacheFlags.java
Patch:
@@ -10,7 +10,6 @@
 package net.sf.jsqlparser.statement.select;
 
 /**
- *
  * @author tw
  */
 public enum MySqlSqlCacheFlags {

File: src/main/java/net/sf/jsqlparser/statement/select/OrderByVisitorAdapter.java
Patch:
@@ -13,7 +13,7 @@
 public class OrderByVisitorAdapter<T> implements OrderByVisitor<T> {
 
     @Override
-    public <S> T visit(OrderByElement orderBy, S parameters) {
+    public <S> T visit(OrderByElement orderBy, S context) {
         return null;
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/select/Pivot.java
Patch:
@@ -30,8 +30,8 @@ public class Pivot implements Serializable {
     private List<SelectItem<ExpressionList<?>>> multiInItems;
     private Alias alias;
 
-    public <T, S> T accept(PivotVisitor<T> pivotVisitor, S arguments) {
-        return pivotVisitor.visit(this, arguments);
+    public <T, S> T accept(PivotVisitor<T> pivotVisitor, S context) {
+        return pivotVisitor.visit(this, context);
     }
 
     public List<SelectItem<?>> getSingleInItems() {

File: src/main/java/net/sf/jsqlparser/statement/select/PivotVisitorAdapter.java
Patch:
@@ -13,19 +13,19 @@
 public class PivotVisitorAdapter<T> implements PivotVisitor<T> {
 
     @Override
-    public <S> T visit(Pivot pivot, S parameters) {
+    public <S> T visit(Pivot pivot, S context) {
 
         return null;
     }
 
     @Override
-    public <S> T visit(PivotXml pivot, S parameters) {
+    public <S> T visit(PivotXml pivot, S context) {
 
         return null;
     }
 
     @Override
-    public <S> T visit(UnPivot unpivot, S parameters) {
+    public <S> T visit(UnPivot unpivot, S context) {
 
         return null;
     }

File: src/main/java/net/sf/jsqlparser/statement/select/PivotXml.java
Patch:
@@ -23,8 +23,8 @@ public class PivotXml extends Pivot {
     private boolean inAny = false;
 
     @Override
-    public <T, S> T accept(PivotVisitor<T> pivotVisitor, S arguments) {
-        return pivotVisitor.visit(this, arguments);
+    public <T, S> T accept(PivotVisitor<T> pivotVisitor, S context) {
+        return pivotVisitor.visit(this, context);
     }
 
     public Select getInSelect() {

File: src/main/java/net/sf/jsqlparser/statement/select/SelectItem.java
Patch:
@@ -79,8 +79,8 @@ public void setExpression(T expression) {
         this.expression = expression;
     }
 
-    public <K, S> K accept(SelectItemVisitor<K> selectItemVisitor, S arguments) {
-        return selectItemVisitor.visit(this, arguments);
+    public <K, S> K accept(SelectItemVisitor<K> selectItemVisitor, S context) {
+        return selectItemVisitor.visit(this, context);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/SelectItemVisitorAdapter.java
Patch:
@@ -14,7 +14,7 @@
 @SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class SelectItemVisitorAdapter<T> implements SelectItemVisitor<T> {
     @Override
-    public <S> T visit(SelectItem<? extends Expression> item, S parameters) {
+    public <S> T visit(SelectItem<? extends Expression> item, S context) {
         return null;
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/select/UnPivot.java
Patch:
@@ -25,8 +25,8 @@ public class UnPivot implements Serializable {
     private List<SelectItem<?>> unpivotInClause;
     private Alias alias;
 
-    public <T, S> T accept(PivotVisitor<T> pivotVisitor, S arguments) {
-        return pivotVisitor.visit(this, arguments);
+    public <T, S> T accept(PivotVisitor<T> pivotVisitor, S context) {
+        return pivotVisitor.visit(this, context);
     }
 
     public boolean getIncludeNulls() {

File: src/main/java/net/sf/jsqlparser/statement/select/Wait.java
Patch:
@@ -25,7 +25,7 @@ public void setTimeout(long timeout) {
 
     /**
      * Returns a String containing the WAIT clause and its timeout, where TIMEOUT is specified by
-     * {@link #getTimeout()}. The returned string will null     be:<code>
+     * {@link #getTimeout()}. The returned string will null be:<code>
      * &quot; WAIT &lt;TIMEOUT&gt;&quot;
      * </code>
      */

File: src/main/java/net/sf/jsqlparser/statement/select/WithIsolation.java
Patch:
@@ -19,6 +19,7 @@ public class WithIsolation implements Serializable {
     public String getIsolation() {
         return this.isolation;
     }
+
     public void setIsolation(String s) {
         this.isolation = s;
     }

File: src/main/java/net/sf/jsqlparser/statement/select/WithItem.java
Patch:
@@ -59,8 +59,8 @@ public StringBuilder appendSelectBodyTo(StringBuilder builder) {
     }
 
     @Override
-    public <T, S> T accept(SelectVisitor<T> selectVisitor, S arguments) {
-        return selectVisitor.visit(this, arguments);
+    public <T, S> T accept(SelectVisitor<T> selectVisitor, S context) {
+        return selectVisitor.visit(this, context);
     }
 
 

File: src/main/java/net/sf/jsqlparser/statement/show/ShowIndexStatement.java
Patch:
@@ -13,7 +13,6 @@
 import net.sf.jsqlparser.statement.StatementVisitor;
 
 /**
- *
  * @author Jayant Kumar Yadav
  */
 
@@ -43,8 +42,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public ShowIndexStatement withTableName(String tableName) {

File: src/main/java/net/sf/jsqlparser/statement/show/ShowTablesStatement.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * A {@code SHOW TABLES} statement
- * 
+ *
  * @see <a href="https://dev.mysql.com/doc/refman/8.0/en/show-tables.html">MySQL show tables</a>
  */
 public class ShowTablesStatement implements Statement {
@@ -98,8 +98,8 @@ public String toString() {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public enum SelectionMode {

File: src/main/java/net/sf/jsqlparser/statement/upsert/Upsert.java
Patch:
@@ -55,8 +55,8 @@ public Upsert setDuplicateUpdateSets(List<UpdateSet> duplicateUpdateSets) {
     }
 
     @Override
-    public <T> T accept(StatementVisitor<T> statementVisitor) {
-        return statementVisitor.visit(this);
+    public <T, S> T accept(StatementVisitor<T> statementVisitor, S context) {
+        return statementVisitor.visit(this, context);
     }
 
     public UpsertType getUpsertType() {

File: src/main/java/net/sf/jsqlparser/util/cnfexpression/CloneHelper.java
Patch:
@@ -25,7 +25,6 @@
  * condition part of the tree.
  *
  * @author messfish
- *
  */
 class CloneHelper {
 

File: src/main/java/net/sf/jsqlparser/util/cnfexpression/MultiAndExpression.java
Patch:
@@ -17,7 +17,6 @@
  * This helper class is mainly used for handling the CNF conversion.
  *
  * @author messfish
- *
  */
 public final class MultiAndExpression extends MultipleExpression {
 

File: src/main/java/net/sf/jsqlparser/util/cnfexpression/MultipleExpression.java
Patch:
@@ -10,6 +10,7 @@
 package net.sf.jsqlparser.util.cnfexpression;
 
 import java.util.List;
+
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
 import net.sf.jsqlparser.expression.NullValue;
@@ -19,7 +20,6 @@
  * This is a helper class that mainly used for handling the CNF conversion.
  *
  * @author messfish
- *
  */
 public abstract class MultipleExpression extends ASTNodeAccessImpl implements Expression {
 
@@ -34,8 +34,8 @@ public int size() {
     }
 
     @Override
-    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S parameters) {
-        return expressionVisitor.visit(new NullValue(), parameters);
+    public <T, S> T accept(ExpressionVisitor<T> expressionVisitor, S context) {
+        return expressionVisitor.visit(new NullValue(), context);
     }
 
     public List<Expression> getList() {

File: src/main/java/net/sf/jsqlparser/util/deparser/AbstractDeParser.java
Patch:
@@ -27,7 +27,7 @@ protected AbstractDeParser(StringBuilder buffer) {
     }
 
     public static void deparseUpdateSets(List<UpdateSet> updateSets, StringBuilder buffer,
-            ExpressionVisitor visitor) {
+            ExpressionVisitor<StringBuilder> visitor) {
         ExpressionListDeParser<?> expressionListDeParser =
                 new ExpressionListDeParser<>(visitor, buffer);
         int j = 0;

File: src/main/java/net/sf/jsqlparser/util/deparser/AlterViewDeParser.java
Patch:
@@ -15,7 +15,7 @@
 
 public class AlterViewDeParser extends AbstractDeParser<AlterView> {
 
-    private SelectVisitor<StringBuilder> selectVisitor;
+    private final SelectVisitor<StringBuilder> selectVisitor;
 
     public AlterViewDeParser(StringBuilder buffer) {
         super(buffer);

File: src/main/java/net/sf/jsqlparser/util/deparser/DropDeParser.java
Patch:
@@ -39,7 +39,8 @@ public void deParse(Drop drop) {
         }
 
         if (drop.getParameters() != null && !drop.getParameters().isEmpty()) {
-            buffer.append(" ").append(PlainSelect.getStringList(drop.getParameters(), false, false));
+            buffer.append(" ")
+                    .append(PlainSelect.getStringList(drop.getParameters(), false, false));
         }
     }
 

File: src/main/java/net/sf/jsqlparser/util/deparser/OrderByDeParser.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+
 import net.sf.jsqlparser.expression.ExpressionVisitor;
 import net.sf.jsqlparser.statement.select.OrderByElement;
 

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -125,8 +125,8 @@ public void setExpressionVisitor(ExpressionVisitor<StringBuilder> visitor) {
     }
 
     @Override
-    public <S> StringBuilder visit(OrderByElement orderBy, S parameters) {
-        orderBy.getExpression().accept(expressionVisitor, parameters);
+    public <S> StringBuilder visit(OrderByElement orderBy, S context) {
+        orderBy.getExpression().accept(expressionVisitor, context);
         if (!orderBy.isAsc()) {
             buffer.append(" DESC");
         } else if (orderBy.isAscDescPresent()) {

File: src/main/java/net/sf/jsqlparser/util/validation/ContextKey.java
Patch:
@@ -10,8 +10,8 @@
 package net.sf.jsqlparser.util.validation;
 
 /**
- * the context key - a ValidationCapability should define constants of expected
- * context - values needed for validation.
+ * the context key - a ValidationCapability should define constants of expected context - values
+ * needed for validation.
  */
 public interface ContextKey {
 

File: src/main/java/net/sf/jsqlparser/util/validation/ParseCapability.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.function.Consumer;
+
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;
 import net.sf.jsqlparser.statement.Statements;

File: src/main/java/net/sf/jsqlparser/util/validation/ParseException.java
Patch:
@@ -12,9 +12,8 @@
 import net.sf.jsqlparser.JSQLParserException;
 
 /**
- * wraps a {@link JSQLParserException} to add to the errors collected by
- * validation
- * 
+ * wraps a {@link JSQLParserException} to add to the errors collected by validation
+ *
  * @author gitmotte
  */
 public class ParseException extends ValidationException {

File: src/main/java/net/sf/jsqlparser/util/validation/UnexpectedValidationException.java
Patch:
@@ -11,7 +11,7 @@
 
 /**
  * can be used on unexpected errors during validation
- * 
+ *
  * @author gitmotte
  */
 public class UnexpectedValidationException extends ValidationException {

File: src/main/java/net/sf/jsqlparser/util/validation/ValidationUtil.java
Patch:
@@ -13,6 +13,7 @@
 import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collectors;
+
 import net.sf.jsqlparser.expression.Alias;
 
 public class ValidationUtil {

File: src/main/java/net/sf/jsqlparser/util/validation/feature/FeatureSetValidation.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.Set;
 import java.util.function.Consumer;
+
 import net.sf.jsqlparser.parser.feature.Feature;
 import net.sf.jsqlparser.parser.feature.FeatureSet;
 import net.sf.jsqlparser.util.validation.ValidationCapability;

File: src/main/java/net/sf/jsqlparser/util/validation/feature/H2Version.java
Patch:
@@ -137,8 +137,7 @@ public enum H2Version implements Version {
                     // http://www.h2database.com/html/commands.html#grant_role
                     Feature.grant,
                     // http://h2database.com/html/commands.html#commit
-                    Feature.commit
-            ));
+                    Feature.commit));
 
     private Set<Feature> features;
     private String versionString;

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MariaDbVersion.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
+
 import net.sf.jsqlparser.parser.feature.Feature;
 
 /**

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -12,11 +12,12 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
+
 import net.sf.jsqlparser.parser.feature.Feature;
 
 /**
  * Please add Features supported and place a link to public documentation
- * 
+ *
  * @author gitmotte
  * @see <a href=
  *      "https://dev.mysql.com/doc/refman/8.0/en/">https://dev.mysql.com/doc/refman/8.0/en/</a>

File: src/main/java/net/sf/jsqlparser/util/validation/feature/PostgresqlVersion.java
Patch:
@@ -12,6 +12,7 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
+
 import net.sf.jsqlparser.parser.feature.Feature;
 
 /**

File: src/main/java/net/sf/jsqlparser/util/validation/feature/SQLVersion.java
Patch:
@@ -12,12 +12,12 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
+
 import net.sf.jsqlparser.parser.feature.Feature;
 
 /**
- * Enum containing the ANSI SQL Standard Versions - features are not guaranteed
- * to be complete, just add them if you are sure they are part of the standard
- * :)
+ * Enum containing the ANSI SQL Standard Versions - features are not guaranteed to be complete, just
+ * add them if you are sure they are part of the standard :)
  *
  * @author gitmotte
  * @see <a href=

File: src/main/java/net/sf/jsqlparser/util/validation/metadata/DatabaseException.java
Patch:
@@ -10,10 +10,12 @@
 package net.sf.jsqlparser.util.validation.metadata;
 
 import java.sql.SQLException;
+
 import net.sf.jsqlparser.util.validation.ValidationException;
 
 /**
  * database-errors wrapping a {@link SQLException} or PersistenceException
+ *
  * @author gitmotte
  */
 public class DatabaseException extends ValidationException {

File: src/main/java/net/sf/jsqlparser/util/validation/metadata/MetadataContext.java
Patch:
@@ -17,8 +17,7 @@ public enum MetadataContext implements ContextKey {
      */
     named,
     /**
-     * <code>true</code>, check for existence,
-     * <code>false</code>, check for non-existence
+     * <code>true</code>, check for existence, <code>false</code>, check for non-existence
      */
     exists
 }

File: src/main/java/net/sf/jsqlparser/util/validation/validator/AbstractValidator.java
Patch:
@@ -45,12 +45,10 @@
  */
 public abstract class AbstractValidator<S> implements Validator<S> {
 
-    private ValidationContext context = new ValidationContext();
-
     private final Map<ValidationCapability, Set<ValidationException>> errors = new HashMap<>();
-
     private final Map<Class<? extends AbstractValidator<?>>, AbstractValidator<?>> validatorForwards =
             new HashMap<>();
+    private ValidationContext context = new ValidationContext();
 
     public <T extends AbstractValidator<?>> T getValidator(Class<T> type) {
         return type.cast(validatorForwards.computeIfAbsent(type, this::newObject));

File: src/main/java/net/sf/jsqlparser/util/validation/validator/AlterSessionValidator.java
Patch:
@@ -17,6 +17,6 @@
 public class AlterSessionValidator extends AbstractValidator<AlterSession> {
     @Override
     public void validate(AlterSession statement) {
-        //@todo: implement this method
+        // @todo: implement this method
     }
 }

File: src/main/java/net/sf/jsqlparser/util/validation/validator/AnalyzeValidator.java
Patch:
@@ -14,7 +14,7 @@
 import net.sf.jsqlparser.util.validation.ValidationCapability;
 import net.sf.jsqlparser.util.validation.metadata.NamedObject;
 
-public class AnalyzeValidator  extends AbstractValidator<Analyze>{
+public class AnalyzeValidator extends AbstractValidator<Analyze> {
     @Override
     public void validate(Analyze analyze) {
         for (ValidationCapability c : getCapabilities()) {

File: src/main/java/net/sf/jsqlparser/statement/select/AllTableColumns.java
Patch:
@@ -21,7 +21,7 @@ public class AllTableColumns extends AllColumns {
     private Table table;
 
     public AllTableColumns(Table table, ExpressionList<Column> exceptColumns,
-            List<SelectItem<?>> replaceExpressions) {
+            List<SelectItem<Column>> replaceExpressions) {
         super(exceptColumns, replaceExpressions);
         this.table = table;
     }

File: src/main/java/net/sf/jsqlparser/expression/DoubleValue.java
Patch:
@@ -51,6 +51,7 @@ public double getValue() {
 
     public void setValue(Double d) {
         value = d;
+        stringValue = String.valueOf(value);
     }
 
     @Override

File: src/main/java/module-info.java
Patch:
@@ -8,6 +8,8 @@
  * #L%
  */
 module net.sf.jsqlparser {
+    requires java.sql;
+
     exports net.sf.jsqlparser;
     exports net.sf.jsqlparser.expression;
     exports net.sf.jsqlparser.expression.operators.arithmetic;

File: src/main/java/net/sf/jsqlparser/util/deparser/AbstractDeParser.java
Patch:
@@ -28,8 +28,8 @@ protected AbstractDeParser(StringBuilder buffer) {
 
     public static void deparseUpdateSets(List<UpdateSet> updateSets, StringBuilder buffer,
             ExpressionVisitor visitor) {
-        ExpressionListDeParser expressionListDeParser =
-                new ExpressionListDeParser(visitor, buffer);
+        ExpressionListDeParser<?> expressionListDeParser =
+                new ExpressionListDeParser<>(visitor, buffer);
         int j = 0;
         if (updateSets != null) {
             for (UpdateSet updateSet : updateSets) {

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -84,7 +84,7 @@ public class SpecialOracleTest {
             "datetime02.sql", "datetime04.sql", "datetime05.sql", "datetime06.sql", "dblink01.sql",
             "for_update01.sql", "for_update02.sql", "for_update03.sql", "function04.sql",
             "function05.sql", "for_update04.sql", "for_update05.sql", "for_update06.sql",
-            "for_update08.sql", "function01.sql", "function02.sql", "function03.sql",
+            "function01.sql", "function02.sql", "function03.sql",
             "function06.sql",
             "groupby01.sql",
             "groupby02.sql", "groupby03.sql", "groupby04.sql", "groupby05.sql", "groupby06.sql",

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -53,7 +53,7 @@ public class AnalyticExpression extends ASTNodeAccessImpl implements Expression
     public AnalyticExpression() {}
 
     public AnalyticExpression(Function function) {
-        this.name = function.getName();
+        this.name = String.join(" ", function.getMultipartName());
         this.allColumns = function.isAllColumns();
         this.distinct = function.isDistinct();
         this.unique = function.isUnique();

File: src/main/java/net/sf/jsqlparser/expression/Function.java
Patch:
@@ -104,7 +104,9 @@ public void accept(ExpressionVisitor expressionVisitor) {
     }
 
     public String getName() {
-        return nameparts == null ? null : String.join(".", nameparts);
+        return nameparts == null ? null
+                : String.join(nameparts.get(0).equalsIgnoreCase("APPROXIMATE") ? " " : ".",
+                        nameparts);
     }
 
     public List<String> getMultipartName() {

File: src/test/java/net/sf/jsqlparser/parser/CCJSqlParserUtilTest.java
Patch:
@@ -40,6 +40,7 @@
 import net.sf.jsqlparser.statement.select.PlainSelect;
 import net.sf.jsqlparser.statement.select.TableStatement;
 import net.sf.jsqlparser.test.MemoryLeakVerifier;
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.function.Executable;
 
@@ -237,6 +238,7 @@ public void execute() throws Throwable {
     }
 
     @Test
+    @Disabled
     public void testParseASTFail() throws Exception {
         assertThrows(JSQLParserException.class,
                 () -> CCJSqlParserUtil.parseAST("select * from dual;WHATEVER!!"));

File: src/test/java/net/sf/jsqlparser/statement/UnsupportedStatementTest.java
Patch:
@@ -61,8 +61,8 @@ public void testUnsupportedStatementsMiddleInBlock() throws JSQLParserException
         String sqlStr = "Select * from dual; This is an unsupported statement; Select * from dual;";
 
         Statements statements = CCJSqlParserUtil.parseStatements(sqlStr,
-                parser -> parser.withUnsupportedStatements(true));
-        Assertions.assertEquals(3, statements.getStatements().size());
+                parser -> parser.withUnsupportedStatements(true).withErrorRecovery(true));
+        Assertions.assertEquals(3, statements.size());
 
         Assertions.assertInstanceOf(Select.class, statements.getStatements().get(0));
         Assertions.assertInstanceOf(UnsupportedStatement.class, statements.getStatements().get(1));

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -99,7 +99,7 @@ public class SpecialOracleTest {
             "join21.sql", "keywordasidentifier01.sql", "keywordasidentifier02.sql",
             "keywordasidentifier03.sql", "keywordasidentifier04.sql", "keywordasidentifier05.sql",
             "lexer02.sql", "lexer03.sql", "lexer04.sql", "lexer05.sql", "like01.sql", "merge01.sql",
-            "merge02.sql", "merge03.sql", "merge04.sql", "order_by01.sql", "order_by02.sql",
+            "merge02.sql", "merge03.sql", "merge04.sql", "object_access01.sql", "order_by01.sql", "order_by02.sql",
             "order_by03.sql", "order_by04.sql",
             "order_by05.sql", "order_by06.sql", "pivot01.sql", "pivot02.sql", "pivot03.sql",
             "pivot04.sql", "pivot05.sql", "pivot06.sql", "pivot07.sql", "pivot07_Parenthesis.sql",

File: src/test/java/net/sf/jsqlparser/expression/BinaryExpressionTest.java
Patch:
@@ -1,13 +1,13 @@
 package net.sf.jsqlparser.expression;
 
+import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
-import org.locationtech.jts.util.Assert;
 
 class BinaryExpressionTest {
 
     @Test
     void testAddition() {
         Expression addition = BinaryExpression.add(new LongValue(1), new LongValue(1));
-        Assert.equals("1 + 1", addition.toString());
+        Assertions.assertEquals("1 + 1", addition.toString());
     }
 }

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -215,9 +215,9 @@ public static void main(String[] args) throws Exception {
 
     public static TreeSet<String> getAllKeywordsUsingRegex(File file) throws IOException {
         Pattern tokenBlockPattern = Pattern.compile(
-                "TOKEN\\s*:\\s*(?:/\\*.*\\*/*)(?:\\r?\\n|\\r)\\{(?:[^\\}\\{]+|\\{(?:[^\\}\\{]+|\\{[^\\}\\{]*\\})*\\})*\\}",
+                "TOKEN\\s*:\\s*/\\*.*\\*/*(?:\\r?\\n|\\r)\\{(?:[^}{]+|\\{(?:[^}{]+|\\{[^}{]*})*})*}",
                 Pattern.MULTILINE);
-        Pattern tokenStringValuePattern = Pattern.compile("\\\"(\\w{2,})\\\"", Pattern.MULTILINE);
+        Pattern tokenStringValuePattern = Pattern.compile("\"(\\w{2,})\"", Pattern.MULTILINE);
 
         TreeSet<String> allKeywords = new TreeSet<>();
 
@@ -257,7 +257,7 @@ public static void buildGrammarForRelObjectNameWithoutValue(File file) throws Ex
                 + "{    Token tk = null; }\n"
                 + "{\n"
                 // @todo: find a way to avoid those hardcoded compound tokens
-                + "    ( tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> |  tk=<K_DATE_LITERAL> | tk=<K_DATETIMELITERAL> | tk=<K_STRING_FUNCTION_NAME> | tk=<K_ISOLATION> | tk=<K_TIME_KEY_EXPR> \n"
+                + "    ( tk=<DATA_TYPE> | tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> |  tk=<K_DATE_LITERAL> | tk=<K_DATETIMELITERAL> | tk=<K_STRING_FUNCTION_NAME> | tk=<K_ISOLATION> | tk=<K_TIME_KEY_EXPR> \n"
                 + "      ");
 
         for (String keyword : allKeywords) {

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -2749,7 +2749,8 @@ public void testUnPivotWithAlias() throws JSQLParserException {
                         + " WHERE simulation_id = 210 AND data_timestamp BETWEEN convert(datetime, '2021-09-14', 120) AND convert(datetime, '2021-09-18', 120)"
                         + " GROUP BY simulation_id) sim_data" + " UNPIVOT" + " (" + "val"
                         + " FOR signal IN (DosingOnStatus_TenMinutes_sim, DosingOnDuration_Hour_sim)"
-                        + ") un_piv_alias");
+                        + ") un_piv_alias",
+                true);
     }
 
     @Test

File: src/test/java/net/sf/jsqlparser/test/TestUtils.java
Patch:
@@ -68,7 +68,7 @@ public class TestUtils {
      */
     public static Statement assertSqlCanBeParsedAndDeparsed(String statement)
             throws JSQLParserException {
-        return assertSqlCanBeParsedAndDeparsed(statement, false);
+        return assertSqlCanBeParsedAndDeparsed(statement, true);
     }
 
     /**

File: src/test/java/net/sf/jsqlparser/statement/select/NestedBracketsPerformanceTest.java
Patch:
@@ -124,12 +124,10 @@ public void testRecursiveBracketExpressionIssue1019() {
     }
 
     // maxDepth = 10 collides with the Parser Timeout = 6 seconds
-    // temporarily restrict it to maxDepth = 4 for the moment
     // @todo: implement methods to set the Parser Timeout explicitly and on demand
-    // @todo Investigate performance deterioration since JSQLParser 5.0pre development
     @Test
     public void testRecursiveBracketExpressionIssue1019_2() throws JSQLParserException {
-        doIncreaseOfParseTimeTesting("IF(1=1, $1, 2)", "1", 4);
+        doIncreaseOfParseTimeTesting("IF(1=1, $1, 2)", "1", 8);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -246,4 +246,5 @@ public interface ExpressionVisitor {
 
     void visit(TSQLRightJoin tsqlRightJoin);
 
+    void visit(StructType structType);
 }

File: src/test/java/net/sf/jsqlparser/test/TestUtils.java
Patch:
@@ -59,7 +59,7 @@ public class TestUtils {
 
     // Assure SPACE around Syntax Characters
     private static final Pattern SQL_SANITATION_PATTERN2 =
-            Pattern.compile("\\s*([!/,()=+\\-*|\\]<>:])\\s*", Pattern.MULTILINE);
+            Pattern.compile("\\s*([!/,()=+\\-*|\\]<>:\\[\\]])\\s*", Pattern.MULTILINE);
 
     /**
      * @param statement

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -110,7 +110,6 @@ public class ParserKeywordsUtils {
             {"PROCEDURE", RESTRICTED_ALIAS},
             {"PUBLIC", RESTRICTED_ALIAS},
             {"RECURSIVE", RESTRICTED_SQL2016},
-            {"REGEXP", RESTRICTED_SQL2016},
             {"RETURNING", RESTRICTED_JSQLPARSER},
             {"RIGHT", RESTRICTED_SQL2016},
             {"SAMPLE", RESTRICTED_ALIAS},

File: src/main/java/net/sf/jsqlparser/expression/JsonAggregateFunction.java
Patch:
@@ -214,7 +214,7 @@ public StringBuilder appendObject(StringBuilder builder) {
         }
         
         if (onNullType!=null) {
-            switch(onNullType) {
+            switch (onNullType) {
                 case NULL:
                     builder.append(" NULL ON NULL");
                     break;
@@ -227,7 +227,7 @@ public StringBuilder appendObject(StringBuilder builder) {
         }
         
         if (uniqueKeysType!=null) {
-            switch(uniqueKeysType) {
+            switch (uniqueKeysType) {
                 case WITH:
                     builder.append(" WITH UNIQUE KEYS");
                     break;
@@ -260,7 +260,7 @@ public StringBuilder appendArray(StringBuilder builder) {
         expressionOrderBy.toStringOrderByElements(builder);
         
         if (onNullType!=null) {
-            switch(onNullType) {
+            switch (onNullType) {
                 case NULL:
                     builder.append(" NULL ON NULL ");
                     break;

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -328,7 +328,7 @@ public void visit(IsBooleanExpression isBooleanExpression) {
 
     @Override
     public void visit(JdbcParameter jdbcParameter) {
-        buffer.append("?");
+        buffer.append(jdbcParameter.getParameterCharacter());
         if (jdbcParameter.isUseFixedIndex()) {
             buffer.append(jdbcParameter.getIndex());
         }

File: src/main/java/net/sf/jsqlparser/expression/DoubleValue.java
Patch:
@@ -24,6 +24,9 @@ public DoubleValue() {
     }
 
     public DoubleValue(final String value) {
+        if (value == null || value.length() == 0) {
+            throw new IllegalArgumentException("value can neither be null nor empty.");
+        }
         String val = value;
         if (val.charAt(0) == '+') {
             val = val.substring(1);

File: src/main/java/net/sf/jsqlparser/expression/LongValue.java
Patch:
@@ -26,6 +26,9 @@ public LongValue() {
     }
 
     public LongValue(final String value) {
+        if (value == null || value.length() == 0) {
+            throw new IllegalArgumentException("value can neither be null nor empty.");
+        }
         String val = value;
         if (val.charAt(0) == '+') {
             val = val.substring(1);

File: src/main/java/net/sf/jsqlparser/expression/TimeValue.java
Patch:
@@ -25,6 +25,9 @@ public TimeValue() {
     }
 
     public TimeValue(String value) {
+        if (value == null || value.length() == 0) {
+            throw new IllegalArgumentException("value can neither be null nor empty.");
+        }
         this.value = Time.valueOf(value.substring(1, value.length() - 1));
     }
 

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterExpression.java
Patch:
@@ -773,7 +773,8 @@ public ColumnDataType(
 
         @Override
         public String toString() {
-            return getColumnName() + (withType ? " TYPE " : " ") + toStringDataTypeAndSpec();
+            return getColumnName() + (withType ? " TYPE " : getColDataType() == null ? "" : " ")
+                    + toStringDataTypeAndSpec();
         }
 
         @Override

File: src/test/java/net/sf/jsqlparser/parser/CCJSqlParserUtilTest.java
Patch:
@@ -389,7 +389,7 @@ public void run() {
         assertDoesNotThrow(new Executable() {
             @Override
             public void execute() throws Throwable {
-                executorService.awaitTermination(10, TimeUnit.SECONDS);
+                executorService.awaitTermination(20, TimeUnit.SECONDS);
             }
         });
 

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,7 +10,7 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, UNSPECIFIC;
+    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, COMMENT_WITH_EQUAL_SIGN, UNSPECIFIC;
 
     public static AlterOperation from(String operation) {
         return Enum.valueOf(AlterOperation.class, operation.toUpperCase());

File: src/test/java/net/sf/jsqlparser/statement/select/PostgresTest.java
Patch:
@@ -57,9 +57,9 @@ public void testJSonExpressionIssue1696() throws JSQLParserException {
         String sqlStr = "SELECT '{\"key\": \"value\"}'::json -> 'key' AS X";
         PlainSelect plainSelect = (PlainSelect) assertSqlCanBeParsedAndDeparsed(sqlStr, true);
         SelectItem<?> selectExpressionItem =
-                (SelectItem) plainSelect.getSelectItems().get(0);
+                plainSelect.getSelectItems().get(0);
         Assertions.assertEquals("'key'",
-                selectExpressionItem.getExpression(JsonExpression.class).getIdents().get(0));
+                selectExpressionItem.getExpression(JsonExpression.class).getIdent(0).getKey());
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -1067,7 +1067,9 @@ public void visit(DescribeStatement describe) {
 
     @Override
     public void visit(ExplainStatement explain) {
-        explain.getStatement().accept((StatementVisitor) this);
+        if (explain.getStatement() != null) {
+            explain.getStatement().accept((StatementVisitor) this);
+        }
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -115,6 +115,7 @@ public enum MySqlVersion implements Version {
 
                     // https://dev.mysql.com/doc/refman/8.0/en/describe.html
                     Feature.describe,
+                    Feature.desc,
                     // https://dev.mysql.com/doc/refman/8.0/en/explain.html
                     Feature.explain,
                     // https://dev.mysql.com/doc/refman/8.0/en/show.html

File: src/main/java/net/sf/jsqlparser/statement/delete/Delete.java
Patch:
@@ -188,7 +188,9 @@ public String toString() {
         }
 
         b.append("DELETE");
-
+        if (oracleHint != null) {
+            b.append(oracleHint).append(" ");
+        }
         if (modifierPriority != null) {
             b.append(" ").append(modifierPriority.name());
         }

File: src/main/java/net/sf/jsqlparser/statement/insert/Insert.java
Patch:
@@ -218,6 +218,9 @@ public String toString() {
             }
         }
         sql.append("INSERT ");
+        if (oracleHint != null) {
+            sql.append(oracleHint).append(" ");
+        }
         if (modifierPriority != null) {
             sql.append(modifierPriority.name()).append(" ");
         }

File: src/main/java/net/sf/jsqlparser/statement/update/Update.java
Patch:
@@ -292,6 +292,9 @@ public String toString() {
             }
         }
         b.append("UPDATE ");
+        if (oracleHint != null) {
+            b.append(oracleHint).append(" ");
+        }
         if (modifierPriority != null) {
             b.append(modifierPriority.name()).append(" ");
         }

File: src/main/java/net/sf/jsqlparser/util/deparser/DeleteDeParser.java
Patch:
@@ -48,6 +48,9 @@ public void deParse(Delete delete) {
             }
         }
         buffer.append("DELETE");
+        if (delete.getOracleHint() != null) {
+            buffer.append(delete.getOracleHint()).append(" ");
+        }
         if (delete.getModifierPriority() != null) {
             buffer.append(" ").append(delete.getModifierPriority());
         }

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -54,6 +54,9 @@ public void deParse(Insert insert) {
         if (insert.getModifierPriority() != null) {
             buffer.append(insert.getModifierPriority()).append(" ");
         }
+        if (insert.getOracleHint() != null) {
+            buffer.append(insert.getOracleHint()).append(" ");
+        }
         if (insert.isModifierIgnore()) {
             buffer.append("IGNORE ");
         }

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -48,6 +48,9 @@ public void deParse(Update update) {
             }
         }
         buffer.append("UPDATE ");
+        if (update.getOracleHint() != null) {
+            buffer.append(update.getOracleHint()).append(" ");
+        }
         if (update.getModifierPriority() != null) {
             buffer.append(update.getModifierPriority()).append(" ");
         }

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -38,6 +38,7 @@ public enum MySqlVersion implements Version {
                     Feature.selectForUpdateOfTable,
                     Feature.selectForUpdateNoWait,
                     Feature.selectForUpdateSkipLocked,
+                    Feature.selectForShare,
                     Feature.distinct,
 
                     Feature.setOperation,

File: src/main/java/net/sf/jsqlparser/util/validation/feature/PostgresqlVersion.java
Patch:
@@ -73,6 +73,9 @@ public enum PostgresqlVersion implements Version {
                     Feature.orderBy,
                     Feature.orderByNullOrdering,
 
+                    Feature.selectForNoKeyUpdate,
+                    Feature.selectForKeyShare,
+                    Feature.selectForShare,
                     Feature.selectForUpdate,
                     Feature.selectForUpdateOfTable,
                     Feature.selectForUpdateNoWait,

File: src/main/java/net/sf/jsqlparser/statement/select/SelectVisitor.java
Patch:
@@ -22,4 +22,6 @@ public interface SelectVisitor {
     void visit(Values aThis);
 
     void visit(LateralSubSelect lateralSubSelect);
+
+    void visit(TableStatement tableStatement);
 }

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -60,6 +60,7 @@ public enum MySqlVersion implements Version {
                     Feature.insert,
                     Feature.insertValues,
                     Feature.values,
+                    Feature.tableStatement,
                     Feature.insertFromSelect, Feature.insertUseSet, Feature.insertModifierPriority,
                     Feature.insertModifierIgnore, Feature.insertUseDuplicateKeyUpdate,
 

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,7 +10,7 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, COMMENT, UNSPECIFIC;
+    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, RENAME_INDEX, RENAME_KEY, RENAME_CONSTRAINT, COMMENT, UNSPECIFIC;
 
     public static AlterOperation from(String operation) {
         return Enum.valueOf(AlterOperation.class, operation.toUpperCase());

File: src/main/java/net/sf/jsqlparser/util/validation/validator/CreateViewValidator.java
Patch:
@@ -33,6 +33,8 @@ public void validate(CreateView createView) {
                     Feature.createViewTemporary);
             validateFeature(c, createView.isMaterialized(), Feature.createViewMaterialized);
             validateName(c, NamedObject.view, createView.getView().getFullyQualifiedName(), false);
+            validateFeature(c, createView.getViewCommentOptions() != null,
+                    Feature.createViewWithComment);
         }
         SelectValidator v = getValidator(SelectValidator.class);
         Select select = createView.getSelect();

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -29,6 +29,7 @@
 import net.sf.jsqlparser.statement.grant.Grant;
 import net.sf.jsqlparser.statement.insert.Insert;
 import net.sf.jsqlparser.statement.merge.Merge;
+import net.sf.jsqlparser.statement.refresh.RefreshMaterializedViewStatement;
 import net.sf.jsqlparser.statement.select.Select;
 import net.sf.jsqlparser.statement.show.ShowIndexStatement;
 import net.sf.jsqlparser.statement.show.ShowTablesStatement;
@@ -68,6 +69,8 @@ public interface StatementVisitor {
 
     void visit(AlterView alterView);
 
+    void visit(RefreshMaterializedViewStatement materializedView);
+
     void visit(Alter alter);
 
     void visit(Statements stmts);

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -53,7 +53,7 @@ public AnalyticExpression(Function function) {
         unique = function.isUnique();
         funcOrderBy = function.getOrderByElements();
 
-        ExpressionList<Expression> list = function.getParameters();
+        ExpressionList<? extends Expression> list = function.getParameters();
         if (list != null) {
             if (list.getExpressions().size() > 3) {
                 throw new IllegalArgumentException(

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeUpdate.java
Patch:
@@ -22,8 +22,7 @@ public class MergeUpdate implements Serializable {
     private Expression whereCondition;
     private Expression deleteWhereCondition;
 
-    public MergeUpdate() {
-    }
+    public MergeUpdate() {}
 
     public MergeUpdate(List<UpdateSet> updateSets) {
         this.updateSets = updateSets;
@@ -98,7 +97,7 @@ public MergeUpdate withDeleteWhereCondition(Expression deleteWhereCondition) {
 
     public <E extends Expression> E getAndPredicate(Class<E> type) {
         return type.cast(getAndPredicate());
-}
+    }
 
     public <E extends Expression> E getWhereCondition(Class<E> type) {
         return type.cast(getWhereCondition());

File: src/main/java/net/sf/jsqlparser/statement/update/UpdateSet.java
Patch:
@@ -72,7 +72,7 @@ public void add(Column column, Expression value) {
      * @param column
      */
     public void add(Column column) {
-        if (columns.size() < 2 && !(columns instanceof ParenthesedExpressionList)) {
+        if (!columns.isEmpty() && !(columns instanceof ParenthesedExpressionList)) {
             columns = new ParenthesedExpressionList<>(columns);
         }
         columns.add(column);
@@ -85,7 +85,7 @@ public void add(Column column) {
      * @param expression
      */
     public void add(Expression expression) {
-        if (values.size() < 2 && !(values instanceof ParenthesedExpressionList)) {
+        if (!values.isEmpty() && !(values instanceof ParenthesedExpressionList)) {
             values = new ParenthesedExpressionList<>(values);
         }
         values.add(expression);

File: src/test/java/net/sf/jsqlparser/util/TablesNamesFinderTest.java
Patch:
@@ -490,10 +490,10 @@ public void testConnectedByRootOperator() throws JSQLParserException {
     void testJoinSubSelect() throws JSQLParserException {
         String sqlStr = "select * from A left join B on A.id=B.id and A.age = (select age from C)";
         Set<String> tableNames = TablesNamesFinder.findTables(sqlStr);
-        assertThat( tableNames ).containsExactlyInAnyOrder("A", "B", "C");
+        assertThat(tableNames).containsExactlyInAnyOrder("A", "B", "C");
 
         String exprStr = "A.id=B.id and A.age = (select age from C)";
         tableNames = TablesNamesFinder.findTablesInExpression(exprStr);
-        assertThat( tableNames ).containsExactlyInAnyOrder("A", "B", "C");
+        assertThat(tableNames).containsExactlyInAnyOrder("A", "B", "C");
     }
 }

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -72,6 +72,7 @@ public class ParserKeywordsUtils {
             {"FOREIGN", RESTRICTED_SQL2016},
             {"FROM", RESTRICTED_SQL2016},
             {"FULL", RESTRICTED_SQL2016},
+            {"GLOBAL", RESTRICTED_ALIAS},
             {"GROUP", RESTRICTED_SQL2016},
             {"GROUPING", RESTRICTED_ALIAS},
             {"QUALIFY", RESTRICTED_ALIAS},

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -214,7 +214,7 @@ public static void main(String[] args) throws Exception {
 
     public static TreeSet<String> getAllKeywordsUsingRegex(File file) throws IOException {
         Pattern tokenBlockPattern = Pattern.compile(
-                "TOKEN\\s*:\\s*(?:/\\*.*\\*/*)\\n\\{(?:[^\\}\\{]+|\\{(?:[^\\}\\{]+|\\{[^\\}\\{]*\\})*\\})*\\}",
+                "TOKEN\\s*:\\s*(?:/\\*.*\\*/*)(?:\\r?\\n|\\r)\\{(?:[^\\}\\{]+|\\{(?:[^\\}\\{]+|\\{[^\\}\\{]*\\})*\\})*\\}",
                 Pattern.MULTILINE);
         Pattern tokenStringValuePattern = Pattern.compile("\\\"(\\w{2,})\\\"", Pattern.MULTILINE);
 

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -481,6 +481,9 @@ public void deparseJoin(Join join) {
             } else if (join.isApply()) {
                 buffer.append(" APPLY ");
             } else {
+                if (join.getJoinHint() != null) {
+                    buffer.append(" ").append(join.getJoinHint());
+                }
                 buffer.append(" JOIN ");
             }
 

File: src/test/java/net/sf/jsqlparser/statement/builder/ReflectionModelTest.java
Patch:
@@ -169,7 +169,7 @@ public class ReflectionModelTest {
             new net.sf.jsqlparser.statement.merge.Merge(),
             new net.sf.jsqlparser.statement.merge.MergeUpdate(new ArrayList<UpdateSet>()),
             new net.sf.jsqlparser.statement.select.AllColumns(),
-            new net.sf.jsqlparser.statement.select.AllTableColumns(),
+            // new net.sf.jsqlparser.statement.select.AllTableColumns(new Table()),
             new net.sf.jsqlparser.statement.select.Distinct(),
             new net.sf.jsqlparser.statement.select.ExceptOp(),
             new net.sf.jsqlparser.statement.select.Fetch(),
@@ -190,7 +190,7 @@ public class ReflectionModelTest {
             new net.sf.jsqlparser.statement.select.PivotXml(),
             // new net.sf.jsqlparser.statement.select.PlainSelect(),
             // new net.sf.jsqlparser.statement.select.Select(),
-            new net.sf.jsqlparser.statement.select.SelectItem(),
+            new net.sf.jsqlparser.statement.select.SelectItem<>(),
             // new net.sf.jsqlparser.statement.select.SetOperationList(),
             new net.sf.jsqlparser.statement.select.Skip(),
             // new net.sf.jsqlparser.statement.select.ParenthesedSelect(),

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -270,7 +270,7 @@ public void testAllColumnsFromTable() throws Exception {
         Table t = new Table("tableName");
         assertDeparse(
                 new PlainSelect()
-                        .addSelectItems(new AllTableColumns().withTable(t)).withFromItem(t),
+                        .addSelectItems(new AllTableColumns(t)).withFromItem(t),
                 statement);
     }
 

File: src/test/java/net/sf/jsqlparser/statement/insert/InsertTest.java
Patch:
@@ -203,11 +203,11 @@ public void testInsertMultiRowValue() throws JSQLParserException {
         String statement = "INSERT INTO mytable (col1, col2) VALUES (a, b), (d, e)";
         assertSqlCanBeParsedAndDeparsed(statement);
 
-        ExpressionList<Column> multiExpressionList = new ExpressionList<>()
+        ExpressionList<Expression> multiExpressionList = new ExpressionList<>()
                 .addExpression(
-                        new ParenthesedExpressionList<Column>(new Column("a"), new Column("b")))
+                        new ParenthesedExpressionList<Expression>(new Column("a"), new Column("b")))
                 .addExpression(
-                        new ParenthesedExpressionList<Column>(new Column("d"), new Column("e")));
+                        new ParenthesedExpressionList<Expression>(new Column("d"), new Column("e")));
 
         Select select = new Values().withExpressions(multiExpressionList);
 

File: src/test/java/net/sf/jsqlparser/util/TablesNamesFinderTest.java
Patch:
@@ -493,7 +493,7 @@ void testJoinSubSelect() throws JSQLParserException {
         assertThat( tableNames ).containsExactlyInAnyOrder("A", "B", "C");
 
         String exprStr = "A.id=B.id and A.age = (select age from C)";
-        tableNames = TablesNamesFinder.findTables(sqlStr);
+        tableNames = TablesNamesFinder.findTablesInExpression(exprStr);
         assertThat( tableNames ).containsExactlyInAnyOrder("A", "B", "C");
     }
 }

File: src/test/java/net/sf/jsqlparser/statement/builder/ReflectionModelTest.java
Patch:
@@ -194,7 +194,7 @@ public class ReflectionModelTest {
             // new net.sf.jsqlparser.statement.select.SetOperationList(),
             new net.sf.jsqlparser.statement.select.Skip(),
             // new net.sf.jsqlparser.statement.select.ParenthesedSelect(),
-            new net.sf.jsqlparser.statement.select.TableFunction(),
+            // new net.sf.jsqlparser.statement.select.TableFunction("LATERAL", new Function()),
             new net.sf.jsqlparser.statement.select.Top(),
             new net.sf.jsqlparser.statement.select.UnPivot(),
             new net.sf.jsqlparser.statement.select.UnionOp(),

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -3349,7 +3349,7 @@ public void testTableFunctionWithNoParams() throws Exception {
 
         assertTrue(plainSelect.getFromItem() instanceof TableFunction);
         TableFunction fromItem = (TableFunction) plainSelect.getFromItem();
-        Function function = fromItem.getExpression();
+        Function function = fromItem.getFunction();
         assertNotNull(function);
         assertEquals("SOME_FUNCTION", function.getName());
         assertNull(function.getParameters());

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -461,7 +461,7 @@ public static int getUnbalancedPosition(String text) {
                     return i; // Return position of unbalanced closing bracket
                 }
                 char top = stack.pop();
-                if ((c == ')' && top != '(') || (c == ']' && top != '[') || (c == '}' && top != '{')) {
+                if (c == ')' && top != '(' || c == ']' && top != '[' || c == '}' && top != '{') {
                     return i; // Return position of unbalanced closing bracket
                 }
             }

File: src/main/java/net/sf/jsqlparser/statement/ReturningClause.java
Patch:
@@ -15,9 +15,9 @@
 import java.util.List;
 
 /**
- * RETURNING clause according to
- * {@see https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/DELETE.html#GUID-156845A5-B626-412B-9F95-8869B988ABD7
- * } Part of UPDATE, INSERT, DELETE statements
+ * RETURNING clause according to <a href=
+ * "https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/DELETE.html#GUID-156845A5-B626-412B-9F95-8869B988ABD7"
+ * /> Part of UPDATE, INSERT, DELETE statements
  */
 
 public class ReturningClause extends ArrayList<SelectItem<?>> {

File: src/main/java/net/sf/jsqlparser/statement/select/FromItem.java
Patch:
@@ -43,4 +43,5 @@ default FromItem withUnPivot(UnPivot unpivot) {
 
     void setUnPivot(UnPivot unpivot);
 
+
 }

File: src/test/java/net/sf/jsqlparser/parser/CCJSqlParserUtilTest.java
Patch:
@@ -496,8 +496,9 @@ public void execute() throws Throwable {
     void testUnbalancedPosition() {
         String sqlStr = "SELECT * from ( test ";
         sqlStr = "select\n" +
-                " concat('{','\"dffs\":\"',if(dffs is null,'',cast(dffs as string),'\",\"djr\":\"',if(djr is null,'',cast(djr as string),'\",\"djrq\":\"',if(djrq is null,'',cast(djrq as string),'\",\"thjssj\":\"',if(thjssj is null,'',cast(thjssj as string),'\",\"thkssj\":\"',if(thkssj is null,'',cast(thkssj as string),'\",\"sjc\":\"',if(sjc is null,'',cast(sjc as string),'\",\"ldhm\":\"',if(ldhm is null,'',cast(ldhm as string),'\",\"lxdh\":\"',if(lxdh is null,'',cast(lxdh as string),'\",\"md\":\"',if(md is null,'',cast(md as string),'\",\"nr\":\"',if(nr is null,'',cast(nr as string),'\",\"nrfl\":\"',if(nrfl is null,'',cast(nrfl as string),'\",\"nrwjid\":\"',if(nrwjid is null,'',cast(nrwjid as string),'\",\"sfbm\":\"',if(sfbm is null,'',cast(sfbm as string),'\",\"sjly\":\"',if(sjly is null,'',cast(sjly as string),'\",\"wtsd\":\"',if(wtsd is null,'',cast(wtsd as string),'\",\"xb\":\"',if(xb is null,'',cast(xb as string),'\",\"xfjbh\":\"',if(xfjbh is null,'',cast(xfjbh as string),'\",\"xfjid\":\"',if(xfjid is null,'',cast(xfjid as string),'\",\"xm\":\"',if(xm is null,'',cast(xm as string),'\",\"zhut\":\"',if(zhut is null,'',cast(zhut as string),'\",\"zt\":\"',if(zt is null,'',cast(zt as string),'\"}')\n" +
+                " concat('{','\"dffs\":\"',if(dffs is null,'',cast(dffs as string),'\",\"djr\":\"',if(djr is null,'',cast(djr as string),'\",\"djrq\":\"',if(djrq is null,'',cast(djrq as string),'\",\"thjssj\":\"',if(thjssj is null,'',cast(thjssj as string),'\",\"thkssj\":\"',if(thkssj is null,'',cast(thkssj as string),'\",\"sjc\":\"',if(sjc is null,'',cast(sjc as string),'\",\"ldhm\":\"',if(ldhm is null,'',cast(ldhm as string),'\",\"lxdh\":\"',if(lxdh is null,'',cast(lxdh as string),'\",\"md\":\"',if(md is null,'',cast(md as string),'\",\"nr\":\"',if(nr is null,'',cast(nr as string),'\",\"nrfl\":\"',if(nrfl is null,'',cast(nrfl as string),'\",\"nrwjid\":\"',if(nrwjid is null,'',cast(nrwjid as string),'\",\"sfbm\":\"',if(sfbm is null,'',cast(sfbm as string),'\",\"sjly\":\"',if(sjly is null,'',cast(sjly as string),'\",\"wtsd\":\"',if(wtsd is null,'',cast(wtsd as string),'\",\"xb\":\"',if(xb is null,'',cast(xb as string),'\",\"xfjbh\":\"',if(xfjbh is null,'',cast(xfjbh as string),'\",\"xfjid\":\"',if(xfjid is null,'',cast(xfjid as string),'\",\"xm\":\"',if(xm is null,'',cast(xm as string),'\",\"zhut\":\"',if(zhut is null,'',cast(zhut as string),'\",\"zt\":\"',if(zt is null,'',cast(zt as string),'\"}')\n"
+                +
                 " from tab";
-        assertEquals(-1 , CCJSqlParserUtil.getUnbalancedPosition(sqlStr));
+        assertEquals(1122, CCJSqlParserUtil.getUnbalancedPosition(sqlStr));
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -44,7 +44,6 @@
 import net.sf.jsqlparser.expression.operators.relational.MinorThanEquals;
 import net.sf.jsqlparser.expression.operators.relational.NotEqualsTo;
 import net.sf.jsqlparser.expression.operators.relational.RegExpMatchOperator;
-import net.sf.jsqlparser.expression.operators.relational.RegExpMySQLOperator;
 import net.sf.jsqlparser.expression.operators.relational.SimilarToExpression;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.AllColumns;
@@ -168,8 +167,6 @@ public interface ExpressionVisitor {
 
     void visit(JsonOperator jsonExpr);
 
-    void visit(RegExpMySQLOperator regExpMySQLOperator);
-
     void visit(UserVariable var);
 
     void visit(NumericBind bind);

File: src/main/java/net/sf/jsqlparser/expression/TrimFunction.java
Patch:
@@ -96,7 +96,7 @@ public void accept(ExpressionVisitor expressionVisitor) {
         expressionVisitor.visit(this);
     }
 
-    StringBuilder appendTo(StringBuilder builder) {
+    public StringBuilder appendTo(StringBuilder builder) {
         builder.append("Trim(");
 
         if (trimSpecification != null) {

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExpressionList.java
Patch:
@@ -74,7 +74,7 @@ public ExpressionList withExpressions(T... expressions) {
         return addExpressions(expressions);
     }
 
-    public ExpressionList withExpressions(Collection<T> expressions) {
+    public ExpressionList<?> withExpressions(Collection<T> expressions) {
         this.clear();
         return addExpressions(expressions);
     }

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -299,7 +299,7 @@ public static Statement parseStatement(CCJSqlParser parser, ExecutorService exec
         Statement statement = null;
         Future<Statement> future = executorService.submit(new Callable<Statement>() {
             @Override
-            public Statement call() throws Exception {
+            public Statement call() throws ParseException {
                 return parser.Statement();
             }
         });
@@ -380,7 +380,7 @@ public static Statements parseStatements(CCJSqlParser parser, ExecutorService ex
         Statements statements = null;
         Future<Statements> future = executorService.submit(new Callable<Statements>() {
             @Override
-            public Statements call() throws Exception {
+            public Statements call() throws ParseException {
                 return parser.Statements();
             }
         });

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -59,6 +59,7 @@ public class ParserKeywordsUtils {
             {"FORCE", RESTRICTED_SQL2016}, {"FOREIGN", RESTRICTED_SQL2016},
             {"FROM", RESTRICTED_SQL2016}, {"FULL", RESTRICTED_SQL2016},
             {"GROUP", RESTRICTED_SQL2016}, {"GROUPING", RESTRICTED_ALIAS},
+            {"QUALIFY", RESTRICTED_ALIAS},
             {"HAVING", RESTRICTED_SQL2016}, {"IF", RESTRICTED_SQL2016}, {"IIF", RESTRICTED_ALIAS},
             {"IGNORE", RESTRICTED_ALIAS}, {"ILIKE", RESTRICTED_SQL2016}, {"IN", RESTRICTED_SQL2016},
             {"INNER", RESTRICTED_SQL2016}, {"INTERSECT", RESTRICTED_SQL2016},

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -60,7 +60,6 @@ public void deParse(Insert insert) {
         buffer.append("INTO ");
 
         buffer.append(insert.getTable().toString());
-
         if (insert.getColumns() != null) {
             buffer.append(" (");
             for (Iterator<Column> iter = insert.getColumns().iterator(); iter.hasNext();) {

File: src/main/java/net/sf/jsqlparser/util/validation/validator/SelectValidator.java
Patch:
@@ -233,7 +233,7 @@ public void validateOptionalJoin(Join join) {
             validateOptionalFeature(c, join.getUsingColumns(), Feature.joinUsingColumns);
         }
 
-        validateOptionalFromItem(join.getRightItem());
+        validateOptionalFromItem(join.getFromItem());
         for (Expression onExpression : join.getOnExpressions()) {
             validateOptionalExpression(onExpression);
         }

File: src/test/java/net/sf/jsqlparser/statement/builder/ReflectionModelTest.java
Patch:
@@ -118,8 +118,6 @@ public class ReflectionModelTest {
             new net.sf.jsqlparser.expression.operators.relational.NotEqualsTo(),
             new net.sf.jsqlparser.expression.operators.relational.RegExpMatchOperator(
                     RegExpMatchOperatorType.MATCH_CASEINSENSITIVE),
-            new net.sf.jsqlparser.expression.operators.relational.RegExpMySQLOperator(
-                    RegExpMatchOperatorType.NOT_MATCH_CASESENSITIVE),
             new net.sf.jsqlparser.expression.operators.relational.SimilarToExpression(),
             new net.sf.jsqlparser.schema.Column(), new net.sf.jsqlparser.schema.Database("db"),
             new net.sf.jsqlparser.schema.Sequence(),

File: src/test/java/net/sf/jsqlparser/statement/select/HiveTest.java
Patch:
@@ -30,7 +30,7 @@ public void testLeftSemiJoin() throws Exception {
         PlainSelect plainSelect = (PlainSelect) assertSqlCanBeParsedAndDeparsed(sql, true);
         assertEquals(1, plainSelect.getJoins().size());
         assertEquals("Othertable",
-                ((Table) plainSelect.getJoins().get(0).getRightItem()).getFullyQualifiedName());
+                ((Table) plainSelect.getJoins().get(0).getFromItem()).getFullyQualifiedName());
         assertTrue(plainSelect.getJoins().get(0).isLeft());
         assertTrue(plainSelect.getJoins().get(0).isSemi());
     }

File: src/test/java/net/sf/jsqlparser/statement/select/KSQLTest.java
Patch:
@@ -31,7 +31,7 @@ public void testKSQLWindowedJoin() throws Exception {
 
         assertEquals(1, plainSelect.getJoins().size());
         assertEquals("table2",
-                ((Table) plainSelect.getJoins().get(0).getRightItem()).getFullyQualifiedName());
+                ((Table) plainSelect.getJoins().get(0).getFromItem()).getFullyQualifiedName());
         assertTrue(plainSelect.getJoins().get(0).isWindowJoin());
         assertEquals(5L, plainSelect.getJoins().get(0).getJoinWindow().getDuration());
         assertEquals("HOURS",
@@ -51,7 +51,7 @@ public void testKSQLBeforeAfterWindowedJoin() throws Exception {
 
         assertEquals(1, plainSelect.getJoins().size());
         assertEquals("table2",
-                ((Table) plainSelect.getJoins().get(0).getRightItem()).getFullyQualifiedName());
+                ((Table) plainSelect.getJoins().get(0).getFromItem()).getFullyQualifiedName());
         assertTrue(plainSelect.getJoins().get(0).isWindowJoin());
         assertEquals(1L, plainSelect.getJoins().get(0).getJoinWindow().getBeforeDuration());
         assertEquals("MINUTE",

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExpressionList.java
Patch:
@@ -74,7 +74,7 @@ public ExpressionList withExpressions(T... expressions) {
         return addExpressions(expressions);
     }
 
-    public ExpressionList withExpressions(Collection<T> expressions) {
+    public ExpressionList<?> withExpressions(Collection<T> expressions) {
         this.clear();
         return addExpressions(expressions);
     }

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -60,7 +60,6 @@ public void deParse(Insert insert) {
         buffer.append("INTO ");
 
         buffer.append(insert.getTable().toString());
-
         if (insert.getColumns() != null) {
             buffer.append(" (");
             for (Iterator<Column> iter = insert.getColumns().iterator(); iter.hasNext();) {

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -44,7 +44,6 @@
 import net.sf.jsqlparser.expression.operators.relational.MinorThanEquals;
 import net.sf.jsqlparser.expression.operators.relational.NotEqualsTo;
 import net.sf.jsqlparser.expression.operators.relational.RegExpMatchOperator;
-import net.sf.jsqlparser.expression.operators.relational.RegExpMySQLOperator;
 import net.sf.jsqlparser.expression.operators.relational.SimilarToExpression;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.AllColumns;
@@ -168,8 +167,6 @@ public interface ExpressionVisitor {
 
     void visit(JsonOperator jsonExpr);
 
-    void visit(RegExpMySQLOperator regExpMySQLOperator);
-
     void visit(UserVariable var);
 
     void visit(NumericBind bind);

File: src/test/java/net/sf/jsqlparser/statement/builder/ReflectionModelTest.java
Patch:
@@ -118,8 +118,6 @@ public class ReflectionModelTest {
             new net.sf.jsqlparser.expression.operators.relational.NotEqualsTo(),
             new net.sf.jsqlparser.expression.operators.relational.RegExpMatchOperator(
                     RegExpMatchOperatorType.MATCH_CASEINSENSITIVE),
-            new net.sf.jsqlparser.expression.operators.relational.RegExpMySQLOperator(
-                    RegExpMatchOperatorType.NOT_MATCH_CASESENSITIVE),
             new net.sf.jsqlparser.expression.operators.relational.SimilarToExpression(),
             new net.sf.jsqlparser.schema.Column(), new net.sf.jsqlparser.schema.Database("db"),
             new net.sf.jsqlparser.schema.Sequence(),

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -59,6 +59,7 @@ public class ParserKeywordsUtils {
             {"FORCE", RESTRICTED_SQL2016}, {"FOREIGN", RESTRICTED_SQL2016},
             {"FROM", RESTRICTED_SQL2016}, {"FULL", RESTRICTED_SQL2016},
             {"GROUP", RESTRICTED_SQL2016}, {"GROUPING", RESTRICTED_ALIAS},
+            {"QUALIFY", RESTRICTED_ALIAS},
             {"HAVING", RESTRICTED_SQL2016}, {"IF", RESTRICTED_SQL2016}, {"IIF", RESTRICTED_ALIAS},
             {"IGNORE", RESTRICTED_ALIAS}, {"ILIKE", RESTRICTED_SQL2016}, {"IN", RESTRICTED_SQL2016},
             {"INNER", RESTRICTED_SQL2016}, {"INTERSECT", RESTRICTED_SQL2016},

File: src/main/java/net/sf/jsqlparser/expression/TrimFunction.java
Patch:
@@ -96,7 +96,7 @@ public void accept(ExpressionVisitor expressionVisitor) {
         expressionVisitor.visit(this);
     }
 
-    StringBuilder appendTo(StringBuilder builder) {
+    public StringBuilder appendTo(StringBuilder builder) {
         builder.append("Trim(");
 
         if (trimSpecification != null) {

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -820,12 +820,12 @@ public void visit(IntervalExpression intervalExpression) {
         if (intervalExpression.isUsingIntervalKeyword()) {
             buffer.append("INTERVAL ");
         }
-        if (intervalExpression.getExpression()!=null) {
+        if (intervalExpression.getExpression() != null) {
             intervalExpression.getExpression().accept(this);
         } else {
             buffer.append(intervalExpression.getParameter());
         }
-        if (intervalExpression.getIntervalType()!=null) {
+        if (intervalExpression.getIntervalType() != null) {
             buffer.append(" ").append(intervalExpression.getIntervalType());
         }
     }

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -4213,7 +4213,8 @@ public void testSqlContainIsNullFunctionShouldBeParsed3() throws JSQLParserExcep
     @Test
     public void testForXmlPath() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed(
-                "SELECT '|' + person_name FROM person JOIN person_group ON person.person_id = person_group.person_id WHERE person_group.group_id = 1 FOR XML PATH('')");
+                "SELECT '|' + person_name FROM person JOIN person_group ON person.person_id = person_group.person_id WHERE person_group.group_id = 1 FOR XML PATH('')",
+                true);
     }
 
     // @Test

File: src/main/java/net/sf/jsqlparser/expression/Parenthesis.java
Patch:
@@ -18,8 +18,7 @@ public class Parenthesis extends ASTNodeAccessImpl implements Expression {
 
     private Expression expression;
 
-    public Parenthesis() {
-    }
+    public Parenthesis() {}
 
     public Parenthesis(Expression expression) {
         setExpression(expression);
@@ -40,7 +39,7 @@ public void accept(ExpressionVisitor expressionVisitor) {
 
     @Override
     public String toString() {
-        return "(" + expression + ")";
+        return "(" + (expression != null ? expression : "") + ")";
     }
 
     public Parenthesis withExpression(Expression expression) {

File: src/main/java/net/sf/jsqlparser/expression/TimezoneExpression.java
Patch:
@@ -9,15 +9,15 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
-import java.util.ArrayList;
 import java.util.List;
 
 public class TimezoneExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression leftExpression;
-    private ArrayList<Expression> timezoneExpressions = new ArrayList<>();
+    private ExpressionList<Expression> timezoneExpressions = new ExpressionList<>();
 
     public Expression getLeftExpression() {
         return leftExpression;

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExistsExpression.java
Patch:
@@ -15,8 +15,8 @@
 
 public class ExistsExpression extends ASTNodeAccessImpl implements Expression {
 
-    private Expression rightExpression;
-    private boolean not = false;
+    protected Expression rightExpression;
+    protected boolean not = false;
 
     public Expression getRightExpression() {
         return rightExpression;

File: src/main/java/net/sf/jsqlparser/parser/feature/Feature.java
Patch:
@@ -44,7 +44,6 @@
 import net.sf.jsqlparser.statement.execute.Execute;
 import net.sf.jsqlparser.statement.grant.Grant;
 import net.sf.jsqlparser.statement.merge.Merge;
-import net.sf.jsqlparser.statement.replace.Replace;
 import net.sf.jsqlparser.statement.select.Fetch;
 import net.sf.jsqlparser.statement.select.First;
 import net.sf.jsqlparser.statement.select.KSQLWindow;
@@ -53,7 +52,6 @@
 import net.sf.jsqlparser.statement.select.OptimizeFor;
 import net.sf.jsqlparser.statement.select.Pivot;
 import net.sf.jsqlparser.statement.select.PivotXml;
-import net.sf.jsqlparser.statement.select.SelectExpressionItem;
 import net.sf.jsqlparser.statement.select.Skip;
 import net.sf.jsqlparser.statement.select.TableFunction;
 import net.sf.jsqlparser.statement.select.Top;
@@ -741,7 +739,7 @@ public enum Feature {
      */
     allowUnsupportedStatements(false),
 
-    timeOut(6000),
+    timeOut(8000),
 
     /**
      * allows Backslash '\' as Escape Character

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -29,7 +29,6 @@
 import net.sf.jsqlparser.statement.grant.Grant;
 import net.sf.jsqlparser.statement.insert.Insert;
 import net.sf.jsqlparser.statement.merge.Merge;
-import net.sf.jsqlparser.statement.replace.Replace;
 import net.sf.jsqlparser.statement.select.Select;
 import net.sf.jsqlparser.statement.show.ShowIndexStatement;
 import net.sf.jsqlparser.statement.show.ShowTablesStatement;
@@ -55,8 +54,6 @@ public interface StatementVisitor {
 
     void visit(Insert insert);
 
-    void visit(Replace replace);
-
     void visit(Drop drop);
 
     void visit(Truncate truncate);

File: src/main/java/net/sf/jsqlparser/statement/select/TableFunction.java
Patch:
@@ -13,7 +13,7 @@
 import net.sf.jsqlparser.expression.Function;
 
 @SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
-public class TableFunction extends FunctionItem implements FromItem {
+public class TableFunction extends SelectItem<Function> implements FromItem {
 
     @Override
     public void accept(FromItemVisitor fromItemVisitor) {
@@ -46,8 +46,8 @@ public TableFunction withAlias(Alias alias) {
     }
 
     @Override
-    public TableFunction withFunction(Function function) {
-        return (TableFunction) super.withFunction(function);
+    public TableFunction withExpression(Function function) {
+        return (TableFunction) super.withExpression(function);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/util/deparser/ValuesStatementDeParser.java
Patch:
@@ -9,14 +9,14 @@
  */
 package net.sf.jsqlparser.util.deparser;
 
-import net.sf.jsqlparser.expression.operators.relational.ItemsListVisitor;
+import net.sf.jsqlparser.expression.ExpressionVisitor;
 import net.sf.jsqlparser.statement.select.Values;
 
 public class ValuesStatementDeParser extends AbstractDeParser<Values> {
 
-    private final ItemsListVisitor expressionVisitor;
+    private final ExpressionVisitor expressionVisitor;
 
-    public ValuesStatementDeParser(ItemsListVisitor expressionVisitor, StringBuilder buffer) {
+    public ValuesStatementDeParser(ExpressionVisitor expressionVisitor, StringBuilder buffer) {
         super(buffer);
         this.expressionVisitor = expressionVisitor;
     }

File: src/main/java/net/sf/jsqlparser/util/validation/validator/ExecuteValidator.java
Patch:
@@ -25,13 +25,14 @@ public class ExecuteValidator extends AbstractValidator<Execute> {
     public void validate(Execute execute) {
         for (ValidationCapability c : getCapabilities()) {
             validateFeature(c, Feature.execute);
-            validateFeature(c, ExecType.EXECUTE.equals(execute.getExecType()), Feature.executeExecute);
+            validateFeature(c, ExecType.EXECUTE.equals(execute.getExecType()),
+                    Feature.executeExecute);
             validateFeature(c, ExecType.EXEC.equals(execute.getExecType()), Feature.executeExec);
             validateFeature(c, ExecType.CALL.equals(execute.getExecType()), Feature.executeCall);
             validateName(NamedObject.procedure, execute.getName());
         }
 
-        validateOptionalItemsList(execute.getExprList());
+        validateOptionalExpression(execute.getExprList());
     }
 
 }

File: src/main/java/net/sf/jsqlparser/util/validation/validator/UpdateValidator.java
Patch:
@@ -28,7 +28,7 @@ public void validate(Update update) {
             validateFeature(c, update.isUseSelect(), Feature.updateUseSelect);
             validateOptionalFeature(c, update.getOrderByElements(), Feature.updateOrderBy);
             validateOptionalFeature(c, update.getLimit(), Feature.updateLimit);
-            validateOptionalFeature(c, update.getReturningExpressionList(),
+            validateOptionalFeature(c, update.getReturningClause(),
                     Feature.updateReturning);
         }
 
@@ -59,9 +59,9 @@ public void validate(Update update) {
             getValidator(LimitValidator.class).validate(update.getLimit());
         }
 
-        if (isNotEmpty(update.getReturningExpressionList())) {
+        if (update.getReturningClause() != null) {
             SelectValidator v = getValidator(SelectValidator.class);
-            update.getReturningExpressionList().forEach(c -> c.accept(v));
+            update.getReturningClause().forEach(c -> c.accept(v));
         }
     }
 

File: src/main/java/net/sf/jsqlparser/util/validation/validator/ValuesStatementValidator.java
Patch:
@@ -20,6 +20,6 @@ public class ValuesStatementValidator extends AbstractValidator<Values> {
     @Override
     public void validate(Values values) {
         validateFeature(Feature.values);
-        validateOptionalItemsList(values.getExpressions());
+        validateOptionalExpression(values.getExpressions());
     }
 }

File: src/test/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapterTest.java
Patch:
@@ -45,11 +45,11 @@ public void testInExpressionProblem() throws JSQLParserException {
             public void visit(InExpression expr) {
                 super.visit(expr);
                 exprList.add(expr.getLeftExpression());
-                exprList.add(expr.getRightItemsList());
+                exprList.add(expr.getRightExpression());
             }
         });
 
-        assertTrue(exprList.get(0) instanceof Expression);
+        assertTrue(exprList.get(0) instanceof Column);
         assertTrue(exprList.get(1) instanceof ExpressionList);
     }
 
@@ -69,7 +69,7 @@ public void visit(InExpression expr) {
             }
         });
 
-        assertTrue(exprList.get(0) instanceof RowConstructor);
+        assertTrue(exprList.get(0) instanceof ExpressionList<?>);
         assertTrue(exprList.get(1) instanceof Select);
     }
 

File: src/test/java/net/sf/jsqlparser/expression/mysql/MySqlSqlCalcFoundRowsTest.java
Patch:
@@ -20,8 +20,6 @@
 import net.sf.jsqlparser.statement.select.SelectVisitorAdapter;
 import org.junit.jupiter.api.Test;
 
-import java.util.Arrays;
-
 import static net.sf.jsqlparser.test.TestUtils.assertDeparse;
 import static net.sf.jsqlparser.test.TestUtils.assertEqualsObjectTree;
 import static net.sf.jsqlparser.test.TestUtils.assertSqlCanBeParsedAndDeparsed;
@@ -47,7 +45,7 @@ public void testPossibleParsingWithSqlCalcFoundRowsHint() throws JSQLParserExcep
 
         Statement parsed = assertSqlCanBeParsedAndDeparsed(sqlCalcFoundRowsContainingSql);
         assertSqlCanBeParsedAndDeparsed(generalSql);
-        Select created = new PlainSelect().addSelectItems(Arrays.asList(new AllColumns()))
+        Select created = new PlainSelect().addSelectItem(new AllColumns())
                 .withMySqlSqlCalcFoundRows(true).withFromItem(new Table("TABLE"));
         assertDeparse(created, sqlCalcFoundRowsContainingSql);
         assertEqualsObjectTree(parsed, created);

File: src/test/java/net/sf/jsqlparser/util/SelectUtilsTest.java
Patch:
@@ -21,7 +21,6 @@
 import net.sf.jsqlparser.statement.select.Join;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 import net.sf.jsqlparser.statement.select.Select;
-import net.sf.jsqlparser.statement.select.SelectExpressionItem;
 import org.junit.jupiter.api.Test;
 
 import java.util.Arrays;
@@ -79,8 +78,7 @@ public void testBuildSelectFromTableAndParsedExpression() throws JSQLParserExcep
                 .buildSelectFromTableAndExpressions(new Table("mytable"), "a+b", "test");
         assertEquals("SELECT a + b, test FROM mytable", select.toString());
 
-        assertTrue(((SelectExpressionItem) select
-                .getSelectItems().get(0)).getExpression() instanceof Addition);
+        assertTrue(select.getSelectItems().get(0).getExpression() instanceof Addition);
     }
 
     @Test

File: src/test/java/net/sf/jsqlparser/util/validation/validator/ReplaceValidatorTest.java
Patch:
@@ -34,7 +34,9 @@ public void testValidateReplaceNotAllowed() throws JSQLParserException {
         for (String sql : Arrays.asList("REPLACE mytable SET col1='as', col2=?, col3=565",
                 "REPLACE mytable (col1, col2, col3) VALUES ('as', ?, 565)",
                 "REPLACE mytable (col1, col2, col3) SELECT * FROM mytable3")) {
-            validateNotAllowed(sql, 1, 1, FeaturesAllowed.SELECT.copy().add(FeaturesAllowed.JDBC), Feature.upsert);
+            validateNotAllowed(sql, 1, 1,
+                    FeaturesAllowed.SELECT.copy().add(FeaturesAllowed.JDBC).add(Feature.values),
+                    Feature.upsert);
         }
     }
 

File: src/test/java/net/sf/jsqlparser/util/validation/validator/UpsertValidatorTest.java
Patch:
@@ -37,7 +37,7 @@ public void testValidationExecuteNotSupported() throws Exception {
     public void testValidationExecuteNotAllowed() throws Exception {
         for (String sql : Arrays.asList("UPSERT INTO TEST (NAME, ID) VALUES ('foo', 123)",
                 "UPSERT INTO TEST (ID, COUNTER) VALUES (123, 0) ON DUPLICATE KEY UPDATE COUNTER = COUNTER + 1")) {
-            validateNotAllowed(sql, 1, 1, FeaturesAllowed.DDL, Feature.upsert);
+            validateNotAllowed(sql, 1, 1, FeaturesAllowed.DDL, Feature.upsert, Feature.values);
         }
     }
 

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -299,7 +299,7 @@ public static Statement parseStatement(CCJSqlParser parser, ExecutorService exec
         Statement statement = null;
         Future<Statement> future = executorService.submit(new Callable<Statement>() {
             @Override
-            public Statement call() throws Exception {
+            public Statement call() throws ParseException {
                 return parser.Statement();
             }
         });
@@ -380,7 +380,7 @@ public static Statements parseStatements(CCJSqlParser parser, ExecutorService ex
         Statements statements = null;
         Future<Statements> future = executorService.submit(new Callable<Statements>() {
             @Override
-            public Statements call() throws Exception {
+            public Statements call() throws ParseException {
                 return parser.Statements();
             }
         });

File: src/test/java/net/sf/jsqlparser/statement/UnsupportedStatementTest.java
Patch:
@@ -93,7 +93,7 @@ void testCreate() throws JSQLParserException {
         String sqlStr =
                 "create trigger stud_marks before INSERT on Student for each row set Student.total = Student.subj1 + Student.subj2, Student.per = Student.total * 60 / 100";
         Statement statement = TestUtils.assertSqlCanBeParsedAndDeparsed(sqlStr, true);
-        Assertions.assertTrue(statement instanceof UnsupportedStatement);
+        assertTrue(statement instanceof UnsupportedStatement);
 
         sqlStr =
                 "create domain TNOTIFICATION_ACTION as ENUM ('ADD', 'CHANGE', 'DEL')";

File: src/test/java/net/sf/jsqlparser/statement/UnsupportedStatementTest.java
Patch:
@@ -85,7 +85,7 @@ void testAlter() throws JSQLParserException {
         String sqlStr =
                 "ALTER INDEX idx_t_fa RENAME TO idx_t_fb";
         Statement statement = TestUtils.assertSqlCanBeParsedAndDeparsed(sqlStr, true);
-        Assertions.assertTrue(statement instanceof UnsupportedStatement);
+        assertTrue(statement instanceof UnsupportedStatement);
     }
 
     @Test

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -61,7 +61,6 @@
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Level;
 
 import static net.sf.jsqlparser.test.TestUtils.assertDeparse;
 import static net.sf.jsqlparser.test.TestUtils.assertExpressionCanBeDeparsedAs;

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -104,6 +104,7 @@ public static Statement parse(String sql, ExecutorService executorService,
             LOGGER.info("Trying SIMPLE parsing " + (allowComplex ? "first" : "only"));
             statement = parseStatement(parser.withAllowComplexParsing(false), executorService);
         } catch (JSQLParserException ex) {
+            LOGGER.info("Nesting Depth" + getNestingDepth(sql));
             if (allowComplex && getNestingDepth(sql) <= ALLOWED_NESTING_DEPTH) {
                 LOGGER.info("Trying COMPLEX parsing when SIMPLE parsing failed");
                 // beware: the parser must not be reused, but needs to be re-initiated

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -61,6 +61,7 @@
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.logging.Level;
 
 import static net.sf.jsqlparser.test.TestUtils.assertDeparse;
 import static net.sf.jsqlparser.test.TestUtils.assertExpressionCanBeDeparsedAs;

File: src/test/java/net/sf/jsqlparser/statement/UnsupportedStatementTest.java
Patch:
@@ -17,14 +17,12 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.function.Executable;
 
-import static net.sf.jsqlparser.test.TestUtils.assertSqlCanBeParsedAndDeparsed;
-
 public class UnsupportedStatementTest {
     @Test
     public void testSingleUnsupportedStatement() throws JSQLParserException {
         String sqlStr = "this is an unsupported statement";
 
-        assertSqlCanBeParsedAndDeparsed(sqlStr, true,
+        TestUtils.assertSqlCanBeParsedAndDeparsed(sqlStr, true,
                 parser -> parser.withUnsupportedStatements(true));
 
         Assertions.assertThrowsExactly(JSQLParserException.class, new Executable() {

File: src/test/java/net/sf/jsqlparser/statement/ShowStatementTest.java
Patch:
@@ -43,6 +43,6 @@ void testShowCreateTable() throws JSQLParserException {
         String sqlStr =
                 "show create table my_table";
         Statement statement = assertSqlCanBeParsedAndDeparsed(sqlStr, true);
-        Assertions.assertTrue( statement instanceof UnsupportedStatement);
+        Assertions.assertTrue(statement instanceof UnsupportedStatement);
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/upsert/Upsert.java
Patch:
@@ -9,7 +9,6 @@
  */
 package net.sf.jsqlparser.statement.upsert;
 
-import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.schema.Table;
@@ -30,7 +29,7 @@ public class Upsert implements Statement {
 
     private Table table;
     private ExpressionList<Column> columns;
-    private ExpressionList expressions;
+    private ExpressionList<?> expressions;
     private Select select;
     private List<UpdateSet> updateSets;
     private List<UpdateSet> duplicateUpdateSets;
@@ -111,7 +110,7 @@ public void setExpressions(ExpressionList list) {
     }
 
     @Deprecated
-    public ExpressionList<Expression> getSetExpressions() {
+    public ExpressionList<?> getSetExpressions() {
         return expressions;
     }
 

File: src/main/java/net/sf/jsqlparser/util/validation/validator/InsertValidator.java
Patch:
@@ -37,7 +37,7 @@ public void validate(Insert insert) {
             validateOptionalFeature(c, insert.getSelect(), Feature.insertFromSelect);
             validateFeature(c, insert.isUseSet(), Feature.insertUseSet);
             validateFeature(c, insert.isUseDuplicate(), Feature.insertUseDuplicateKeyUpdate);
-            validateOptionalFeature(c, insert.getReturningExpressionList(),
+            validateOptionalFeature(c, insert.getReturningClause(),
                     Feature.insertReturningExpressionList);
         }
 
@@ -71,9 +71,9 @@ public void validate(Insert insert) {
             }
         }
 
-        if (isNotEmpty(insert.getReturningExpressionList())) {
+        if (insert.getReturningClause() != null) {
             SelectValidator v = getValidator(SelectValidator.class);
-            insert.getReturningExpressionList().forEach(c -> c.accept(v));
+            insert.getReturningClause().forEach(c -> c.accept(v));
         }
     }
 

File: src/main/java/net/sf/jsqlparser/util/validation/validator/UpdateValidator.java
Patch:
@@ -28,7 +28,7 @@ public void validate(Update update) {
             validateFeature(c, update.isUseSelect(), Feature.updateUseSelect);
             validateOptionalFeature(c, update.getOrderByElements(), Feature.updateOrderBy);
             validateOptionalFeature(c, update.getLimit(), Feature.updateLimit);
-            validateOptionalFeature(c, update.getReturningExpressionList(),
+            validateOptionalFeature(c, update.getReturningClause(),
                     Feature.updateReturning);
         }
 
@@ -59,9 +59,9 @@ public void validate(Update update) {
             getValidator(LimitValidator.class).validate(update.getLimit());
         }
 
-        if (isNotEmpty(update.getReturningExpressionList())) {
+        if (update.getReturningClause() != null) {
             SelectValidator v = getValidator(SelectValidator.class);
-            update.getReturningExpressionList().forEach(c -> c.accept(v));
+            update.getReturningClause().forEach(c -> c.accept(v));
         }
     }
 

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -89,7 +89,8 @@ public class SpecialOracleTest {
             "groupby08.sql", "groupby09.sql", "groupby10.sql", "groupby11.sql", "groupby12.sql",
             "groupby13.sql", "groupby14.sql", "groupby15.sql", "groupby16.sql", "groupby17.sql",
             "groupby19.sql", "groupby20.sql", "groupby21.sql", "groupby22.sql", "groupby23.sql",
-            "insert02.sql", "interval02.sql", "interval04.sql", "interval05.sql", "join01.sql",
+            "insert02.sql", "insert11.sql", "insert12.sql", "interval02.sql", "interval04.sql",
+            "interval05.sql", "join01.sql",
             "join02.sql", "join03.sql", "join04.sql", "join06.sql", "join07.sql", "join08.sql",
             "join09.sql", "join10.sql", "join11.sql", "join12.sql", "join13.sql", "join14.sql",
             "join15.sql", "join16.sql", "join17.sql", "join18.sql", "join19.sql", "join20.sql",

File: src/test/java/net/sf/jsqlparser/statement/update/UpdateTest.java
Patch:
@@ -341,7 +341,7 @@ public void testUpdateSetsIssue1590() throws JSQLParserException {
     }
 
     @Test
-    void testIssue() throws JSQLParserException {
+    void testArrayColumnsIssue1083() throws JSQLParserException {
         String sqlStr = "SELECT listes[(SELECT cardinality(listes))]";
         assertSqlCanBeParsedAndDeparsed(sqlStr, true);
 

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -39,6 +39,7 @@
 import net.sf.jsqlparser.expression.operators.relational.JsonOperator;
 import net.sf.jsqlparser.expression.operators.relational.LikeExpression;
 import net.sf.jsqlparser.expression.operators.relational.Matches;
+import net.sf.jsqlparser.expression.operators.relational.MemberOfExpression;
 import net.sf.jsqlparser.expression.operators.relational.MinorThan;
 import net.sf.jsqlparser.expression.operators.relational.MinorThanEquals;
 import net.sf.jsqlparser.expression.operators.relational.NotEqualsTo;
@@ -135,6 +136,8 @@ public interface ExpressionVisitor {
 
     void visit(ExistsExpression existsExpression);
 
+    void visit(MemberOfExpression memberOfExpression);
+
     void visit(AnyComparisonExpression anyComparisonExpression);
 
     void visit(Concat concat);

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExistsExpression.java
Patch:
@@ -15,8 +15,8 @@
 
 public class ExistsExpression extends ASTNodeAccessImpl implements Expression {
 
-    private Expression rightExpression;
-    private boolean not = false;
+    protected Expression rightExpression;
+    protected boolean not = false;
 
     public Expression getRightExpression() {
         return rightExpression;

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -228,4 +228,6 @@ public interface ExpressionVisitor {
     void visit(TranscodingFunction transcodingFunction);
 
     void visit(TrimFunction trimFunction);
+
+    void visit(RangeExpression rangeExpression);
 }

File: src/test/java/net/sf/jsqlparser/util/APISanitationTest.java
Patch:
@@ -39,7 +39,7 @@ interface Visitor<T> {
 
 
 public class APISanitationTest {
-    private final static TreeSet<Class<?>> CLASSES = new TreeSet<>(new Comparator<>() {
+    private final static TreeSet<Class<?>> CLASSES = new TreeSet<>(new Comparator<Class<?>>() {
         @Override
         public int compare(Class o1, Class o2) {
             return o1.getName().compareTo(o2.getName());
@@ -94,7 +94,7 @@ private static String createClassName(File root, File file) {
 
     @BeforeAll
     static void findRelevantClasses() {
-        findClasses(new Visitor<>() {
+        findClasses(new Visitor<String>() {
             @Override
             public boolean visit(String clazz) {
                 if (clazz.startsWith("net.sf.jsqlparser.statement")
@@ -129,7 +129,7 @@ public boolean visit(String clazz) {
      */
 
     private static Stream<Field> fields() {
-        TreeSet<Field> fields = new TreeSet<>(new Comparator<>() {
+        TreeSet<Field> fields = new TreeSet<>(new Comparator<Field>() {
             @Override
             public int compare(Field o1, Field o2) {
                 return o1.toString().compareTo(o2.toString());

File: src/main/java/net/sf/jsqlparser/expression/DateTimeLiteralExpression.java
Patch:
@@ -68,7 +68,7 @@ public String getDateTime() {
             this.dateTime = dateTime;
         }
 
-        public static DateTime from(String dateTimeStr) {
+        private final DateTime from(String dateTimeStr) {
             return Enum.valueOf(DateTime.class, dateTimeStr.toUpperCase());
         }
     }

File: src/main/java/net/sf/jsqlparser/expression/DateTimeLiteralExpression.java
Patch:
@@ -68,7 +68,7 @@ public String getDateTime() {
             this.dateTime = dateTime;
         }
 
-        private final DateTime from(String dateTimeStr) {
+        public static DateTime from(String dateTimeStr) {
             return Enum.valueOf(DateTime.class, dateTimeStr.toUpperCase());
         }
     }

File: src/test/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapterTest.java
Patch:
@@ -11,7 +11,6 @@
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.expression.operators.conditional.XorExpression;
-import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.expression.operators.relational.InExpression;
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;
 import net.sf.jsqlparser.schema.Column;
@@ -45,12 +44,12 @@ public void testInExpressionProblem() throws JSQLParserException {
             public void visit(InExpression expr) {
                 super.visit(expr);
                 exprList.add(expr.getLeftExpression());
-                exprList.add(expr.getRightItemsList());
+                exprList.add(expr.getRightExpression());
             }
         });
 
         assertTrue(exprList.get(0) instanceof Expression);
-        assertTrue(exprList.get(1) instanceof ExpressionList);
+        assertTrue(exprList.get(1) instanceof RowConstructor);
     }
 
     @Test

File: src/test/java/net/sf/jsqlparser/statement/select/ClickHouseTest.java
Patch:
@@ -51,10 +51,10 @@ public void testSelectUsingFinal() throws JSQLParserException {
 
     @Test
     public void testLimitBy() throws JSQLParserException {
-        String sqlStr ="SELECT * FROM limit_by ORDER BY id, val LIMIT 1, 2 BY id";
+        String sqlStr = "SELECT * FROM limit_by ORDER BY id, val LIMIT 1, 2 BY id";
         assertSqlCanBeParsedAndDeparsed(sqlStr, true);
 
-        sqlStr ="SELECT\n"
+        sqlStr = "SELECT\n"
                 + "    domainWithoutWWW(URL) AS domain,\n"
                 + "    domainWithoutWWW(REFERRER_URL) AS referrer,\n"
                 + "    device_type,\n"

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -9,8 +9,6 @@
  */
 package net.sf.jsqlparser.util.deparser;
 
-import java.util.Iterator;
-
 import net.sf.jsqlparser.expression.ExpressionVisitor;
 import net.sf.jsqlparser.expression.ExpressionVisitorAdapter;
 import net.sf.jsqlparser.statement.select.Join;
@@ -21,6 +19,8 @@
 import net.sf.jsqlparser.statement.update.Update;
 import net.sf.jsqlparser.statement.update.UpdateSet;
 
+import java.util.Iterator;
+
 public class UpdateDeParser extends AbstractDeParser<Update> implements OrderByVisitor {
 
     private ExpressionVisitor expressionVisitor = new ExpressionVisitorAdapter();
@@ -129,7 +129,7 @@ public void deParse(Update update) {
             new OrderByDeParser(expressionVisitor, buffer).deParse(update.getOrderByElements());
         }
         if (update.getLimit() != null) {
-            new LimitDeparser(buffer).deParse(update.getLimit());
+            new LimitDeparser(expressionVisitor, buffer).deParse(update.getLimit());
         }
 
         if (update.getReturningExpressionList() != null) {

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -82,7 +82,8 @@ public class SpecialOracleTest {
             "datetime02.sql", "datetime04.sql", "datetime05.sql", "datetime06.sql", "dblink01.sql",
             "for_update01.sql", "for_update02.sql", "for_update03.sql", "function04.sql",
             "function05.sql", "for_update04.sql", "for_update05.sql", "for_update06.sql",
-            "for_update08.sql", "function01.sql", "function02.sql", "groupby01.sql",
+            "for_update08.sql", "function01.sql", "function02.sql", "function03.sql",
+            "groupby01.sql",
             "groupby02.sql", "groupby03.sql", "groupby04.sql", "groupby05.sql", "groupby06.sql",
             "groupby08.sql", "groupby09.sql", "groupby10.sql", "groupby11.sql", "groupby12.sql",
             "groupby13.sql", "groupby14.sql", "groupby15.sql", "groupby16.sql", "groupby17.sql",

File: src/test/java/net/sf/jsqlparser/statement/values/ValuesTest.java
Patch:
@@ -40,7 +40,8 @@ public void testDuplicateKey() throws JSQLParserException {
     @Test
     public void testComplexWithQueryIssue561() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed(
-                "WITH split (word, str, hascomma) AS (VALUES ('', 'Auto,A,1234444', 1) UNION ALL SELECT substr(str, 0, CASE WHEN instr(str, ',') THEN instr(str, ',') ELSE length(str) + 1 END), ltrim(substr(str, instr(str, ',')), ','), instr(str, ',') FROM split WHERE hascomma) SELECT trim(word) FROM split WHERE word != ''");
+                "WITH split (word, str, hascomma) AS (VALUES ('', 'Auto,A,1234444', 1) UNION ALL SELECT substr(str, 0, CASE WHEN instr(str, ',') THEN instr(str, ',') ELSE length(str) + 1 END), ltrim(substr(str, instr(str, ',')), ','), instr(str, ',') FROM split WHERE hascomma) SELECT trim(word) FROM split WHERE word != ''",
+                true);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -66,6 +66,7 @@ public class ParserKeywordsUtils {
             ,  { "EXCEPT" , RESTRICTED_SQL2016 }
             ,  { "EXISTS" , RESTRICTED_SQL2016 }
             ,  { "FETCH" , RESTRICTED_SQL2016 }
+            ,  { "FINAL" , RESTRICTED_JSQLPARSER }
             ,  { "FOR" , RESTRICTED_SQL2016 }
             ,  { "FORCE" , RESTRICTED_SQL2016 }
             ,  { "FOREIGN" , RESTRICTED_SQL2016 }

File: src/main/java/net/sf/jsqlparser/statement/select/LateralView.java
Patch:
@@ -55,7 +55,7 @@ public void setTableAlias(Alias tableAlias) {
 
     public LateralView withTableAlias(Alias tableAlias) {
         // "AS" is not allowed here, so overwrite hard
-        this.setTableAlias( tableAlias !=null ? tableAlias.withUseAs(false) : null);
+        this.setTableAlias(tableAlias != null ? tableAlias.withUseAs(false) : null);
         return this;
     }
 
@@ -68,7 +68,7 @@ public void setColumnAlias(Alias columnAlias) {
     }
 
     public LateralView withColumnAlias(Alias columnAlias) {
-        //"AS" is required here, so overwrite
+        // "AS" is required here, so overwrite
         this.setColumnAlias(columnAlias.withUseAs(true));
         return this;
     }

File: src/main/java/net/sf/jsqlparser/parser/feature/FeatureConfiguration.java
Patch:
@@ -61,8 +61,8 @@ public boolean getAsBoolean(Feature f) {
         return Boolean.parseBoolean(String.valueOf(getValue(f)));
     }
 
-    public Integer getAsInteger(Feature f) {
-        return Integer.valueOf(String.valueOf(getValue(f)));
+    public Long getAsLong(Feature f) {
+        return Long.valueOf(String.valueOf(getValue(f)));
     }
 
     public String getAsString(Feature f) {

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ItemsListVisitor.java
Patch:
@@ -9,11 +9,11 @@
  */
 package net.sf.jsqlparser.expression.operators.relational;
 
-import net.sf.jsqlparser.statement.select.SubSelect;
+import net.sf.jsqlparser.statement.select.ParenthesedSelect;
 
 public interface ItemsListVisitor {
 
-    void visit(SubSelect subSelect);
+    void visit(ParenthesedSelect selectBody);
 
     void visit(ExpressionList expressionList);
 

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ItemsListVisitorAdapter.java
Patch:
@@ -9,13 +9,13 @@
  */
 package net.sf.jsqlparser.expression.operators.relational;
 
-import net.sf.jsqlparser.statement.select.SubSelect;
+import net.sf.jsqlparser.statement.select.ParenthesedSelect;
 
 @SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class ItemsListVisitorAdapter implements ItemsListVisitor {
 
     @Override
-    public void visit(SubSelect subSelect) {
+    public void visit(ParenthesedSelect subSelect) {
 
     }
 

File: src/main/java/net/sf/jsqlparser/util/deparser/AlterViewDeParser.java
Patch:
@@ -43,7 +43,7 @@ public void deParse(AlterView alterView) {
         }
         buffer.append(" AS ");
 
-        alterView.getSelectBody().accept(selectVisitor);
+        alterView.getSelect().accept(selectVisitor);
     }
 
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ValuesStatementDeParser.java
Patch:
@@ -10,9 +10,9 @@
 package net.sf.jsqlparser.util.deparser;
 
 import net.sf.jsqlparser.expression.operators.relational.ItemsListVisitor;
-import net.sf.jsqlparser.statement.values.ValuesStatement;
+import net.sf.jsqlparser.statement.select.Values;
 
-public class ValuesStatementDeParser extends AbstractDeParser<ValuesStatement> {
+public class ValuesStatementDeParser extends AbstractDeParser<Values> {
 
     private final ItemsListVisitor expressionVisitor;
 
@@ -22,7 +22,7 @@ public ValuesStatementDeParser(ItemsListVisitor expressionVisitor, StringBuilder
     }
 
     @Override
-    public void deParse(ValuesStatement values) {
+    public void deParse(Values values) {
         buffer.append("VALUES ");
         values.getExpressions().accept(expressionVisitor);
     }

File: src/main/java/net/sf/jsqlparser/util/validation/validator/AlterViewValidator.java
Patch:
@@ -27,7 +27,7 @@ public void validate(AlterView alterView) {
             validateName(c, NamedObject.view, alterView.getView().getFullyQualifiedName());
             validateOptionalColumnNames(c, alterView.getColumnNames());
         }
-        alterView.getSelectBody().accept(getValidator(SelectValidator.class));
+        alterView.getSelect().accept(getValidator(SelectValidator.class));
     }
 
 }

File: src/main/java/net/sf/jsqlparser/util/validation/validator/MergeValidator.java
Patch:
@@ -25,7 +25,7 @@ public void validate(Merge merge) {
             validateFeature(c, Feature.merge);
         }
         validateOptionalExpression(merge.getOnCondition());
-        validateOptionalExpression(merge.getUsingSelect());
+        // validateOptionalExpression(merge.getFromItem());
         if (merge.getMergeInsert() != null) {
             validateOptionalExpressions(merge.getMergeInsert().getColumns());
             validateOptionalExpressions(merge.getMergeInsert().getValues());
@@ -36,7 +36,8 @@ public void validate(Merge merge) {
             validateOptionalExpression(merge.getMergeUpdate().getDeleteWhereCondition());
             validateOptionalExpression(merge.getMergeUpdate().getWhereCondition());
         }
-        validateOptionalFromItems(merge.getTable(), merge.getUsingTable(), merge.getUsingSelect());
+        // validateOptionalFromItems(merge.getTable(), merge.getUsingTable(),
+        // merge.getUsingSelect());
     }
 
 }

File: src/main/java/net/sf/jsqlparser/util/validation/validator/ValuesStatementValidator.java
Patch:
@@ -10,15 +10,15 @@
 package net.sf.jsqlparser.util.validation.validator;
 
 import net.sf.jsqlparser.parser.feature.Feature;
-import net.sf.jsqlparser.statement.values.ValuesStatement;
+import net.sf.jsqlparser.statement.select.Values;
 
 /**
  * @author gitmotte
  */
-public class ValuesStatementValidator extends AbstractValidator<ValuesStatement> {
+public class ValuesStatementValidator extends AbstractValidator<Values> {
 
     @Override
-    public void validate(ValuesStatement values) {
+    public void validate(Values values) {
         validateFeature(Feature.values);
         validateOptionalItemsList(values.getExpressions());
     }

File: src/test/java/net/sf/jsqlparser/statement/select/PostgresTest.java
Patch:
@@ -15,6 +15,8 @@
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 
+import static net.sf.jsqlparser.test.TestUtils.assertSqlCanBeParsedAndDeparsed;
+
 public class PostgresTest {
     @Test
     public void testExtractFunction() throws JSQLParserException {
@@ -44,9 +46,7 @@ public void testExtractFunctionIssue1582() throws JSQLParserException {
     @Test
     public void testJSonExpressionIssue1696() throws JSQLParserException {
         String sqlStr = "SELECT '{\"key\": \"value\"}'::json -> 'key' AS X";
-        Select select = (Select) TestUtils.assertSqlCanBeParsedAndDeparsed(sqlStr, true);
-
-        PlainSelect plainSelect = (PlainSelect) select.getSelectBody();
+        PlainSelect plainSelect = (PlainSelect) assertSqlCanBeParsedAndDeparsed(sqlStr, true);
         SelectExpressionItem selectExpressionItem =
                 (SelectExpressionItem) plainSelect.getSelectItems().get(0);
         Assertions.assertEquals("'key'",

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MariaDbVersion.java
Patch:
@@ -133,6 +133,8 @@ public enum MariaDbVersion implements Version {
                     Feature.showTables,
                     // https://mariadb.com/kb/en/show-columns/
                     Feature.showColumns,
+                    // https://mariadb.com/kb/en/show-index/
+                    Feature.showIndex,
                     // https://mariadb.com/kb/en/use/
                     Feature.use,
                     // https://mariadb.com/kb/en/grant/

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -118,6 +118,8 @@ public enum MySqlVersion implements Version {
                     Feature.showTables,
                     // https://dev.mysql.com/doc/refman/8.0/en/show-columns.html
                     Feature.showColumns,
+                    // https://dev.mysql.com/doc/refman/8.0/en/show-index.html
+                    Feature.showIndex,
                     // https://dev.mysql.com/doc/refman/8.0/en/grant.html
                     Feature.grant,
                     // https://dev.mysql.com/doc/refman/8.0/en/use.html

File: src/test/java/net/sf/jsqlparser/statement/builder/ReflectionModelTest.java
Patch:
@@ -117,6 +117,7 @@ public class ReflectionModelTest {
             new net.sf.jsqlparser.statement.ExplainStatement.Option(OptionType.COSTS),
             new net.sf.jsqlparser.statement.SetStatement("name", null),
             new net.sf.jsqlparser.statement.ShowColumnsStatement(),
+            new net.sf.jsqlparser.statement.show.ShowIndexStatement(),
             new net.sf.jsqlparser.statement.ShowStatement(), new net.sf.jsqlparser.statement.Statements(),
             new net.sf.jsqlparser.statement.UseStatement(),
             new net.sf.jsqlparser.statement.alter.Alter(),

File: src/test/java/net/sf/jsqlparser/test/TestUtils.java
Patch:
@@ -157,7 +157,8 @@ private static void writeTestToFile(String sanitizedInputSqlStr) {
                 }
                 IOUtils.write("\n\n", fileWriter);
             } catch (IOException ex) {
-                Logger.getLogger(TestUtils.class.getName()).log(Level.SEVERE, "Writing SQL to file failed.", ex);
+                Logger.getLogger(TestUtils.class.getName()).log(Level.SEVERE,
+                        "Writing SQL to file failed.", ex);
             }
         }
     }

File: src/main/java/net/sf/jsqlparser/expression/StringValue.java
Patch:
@@ -23,7 +23,7 @@ public final class StringValue extends ASTNodeAccessImpl implements Expression {
     private String value = "";
     private String prefix = null;
 
-    public static final List<String> ALLOWED_PREFIXES = Arrays.asList("N", "U", "E", "R", "B", "RB", "_utf8");
+    public static final List<String> ALLOWED_PREFIXES = Arrays.asList("N", "U", "E", "R", "B", "RB", "_utf8", "Q");
 
     public StringValue() {
         // empty constructor

File: src/main/java/net/sf/jsqlparser/Model.java
Patch:
@@ -9,10 +9,12 @@
  */
 package net.sf.jsqlparser;
 
+import java.io.Serializable;
+
 /**
  * <p>A marker interface for jsqlparser-model-classes.</p>
  * <p>The datastructure where the sql syntax is represented by a tree consists of {@link Model}'s</p>   
  */
-public interface Model {
+public interface Model extends Serializable {
 
 }

File: src/main/java/net/sf/jsqlparser/expression/Alias.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.expression;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -17,7 +18,7 @@
 import java.util.Optional;
 import net.sf.jsqlparser.statement.create.table.ColDataType;
 
-public class Alias {
+public class Alias implements Serializable {
 
     private String name;
     private boolean useAs = true;
@@ -104,7 +105,7 @@ public Alias addAliasColumns(Collection<? extends AliasColumn> aliasColumns) {
         return this.withAliasColumns(collection);
     }
 
-    public static class AliasColumn {
+    public static class AliasColumn implements Serializable {
 
         public final String name;
         public final ColDataType colDataType;

File: src/main/java/net/sf/jsqlparser/expression/JsonFunctionExpression.java
Patch:
@@ -10,14 +10,15 @@
 
 package net.sf.jsqlparser.expression;
 
+import java.io.Serializable;
 import java.util.Objects;
 
 /**
  *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 
-public class JsonFunctionExpression {
+public class JsonFunctionExpression implements Serializable {
     private final Expression expression;
 
     private boolean usingFormatJson = false;

File: src/main/java/net/sf/jsqlparser/expression/JsonKeyValuePair.java
Patch:
@@ -10,14 +10,15 @@
 
 package net.sf.jsqlparser.expression;
 
+import java.io.Serializable;
 import java.util.Objects;
 
 /**
  *
  * @author <a href="mailto:andreas@manticore-projects.com">Andreas Reichel</a>
  */
 
-public class JsonKeyValuePair {
+public class JsonKeyValuePair implements Serializable {
   private final String key;
   private boolean usingKeyKeyword = false;
   private final Object value;

File: src/main/java/net/sf/jsqlparser/expression/MySQLIndexHint.java
Patch:
@@ -9,9 +9,10 @@
  */
 package net.sf.jsqlparser.expression;
 
+import java.io.Serializable;
 import java.util.List;
 
-public class MySQLIndexHint  {
+public class MySQLIndexHint implements Serializable {
 
     private final String action;
     private final String indexQualifier;

File: src/main/java/net/sf/jsqlparser/expression/OrderByClause.java
Patch:
@@ -9,14 +9,15 @@
  */
 package net.sf.jsqlparser.expression;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 import net.sf.jsqlparser.statement.select.OrderByElement;
 
-public class OrderByClause {
+public class OrderByClause implements Serializable {
     private List<OrderByElement> orderByElements;
 
     public List<OrderByElement> getOrderByElements() {

File: src/main/java/net/sf/jsqlparser/expression/PartitionByClause.java
Patch:
@@ -12,7 +12,9 @@
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
-public class PartitionByClause {
+import java.io.Serializable;
+
+public class PartitionByClause implements Serializable {
     ExpressionList partitionExpressionList;
     boolean brackets = false;
 

File: src/main/java/net/sf/jsqlparser/expression/SQLServerHints.java
Patch:
@@ -9,10 +9,11 @@
  */
 package net.sf.jsqlparser.expression;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
-public class SQLServerHints {
+public class SQLServerHints implements Serializable {
 
     private Boolean noLock;
     private String indexName;

File: src/main/java/net/sf/jsqlparser/expression/WindowDefinition.java
Patch:
@@ -9,11 +9,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import java.io.Serializable;
 import java.util.List;
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.statement.select.OrderByElement;
 
-public class WindowDefinition {
+public class WindowDefinition implements Serializable {
 
 
     final OrderByClause orderBy = new OrderByClause();

File: src/main/java/net/sf/jsqlparser/expression/WindowElement.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.expression;
 
-public class WindowElement {
+import java.io.Serializable;
+
+public class WindowElement implements Serializable {
 
     public enum Type {
 

File: src/main/java/net/sf/jsqlparser/expression/WindowOffset.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.expression;
 
-public class WindowOffset {
+import java.io.Serializable;
+
+public class WindowOffset implements Serializable {
 
     public enum Type {
 

File: src/main/java/net/sf/jsqlparser/expression/WindowRange.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.expression;
 
-public class WindowRange {
+import java.io.Serializable;
+
+public class WindowRange implements Serializable {
 
     private WindowOffset start;
     private WindowOffset end;

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExpressionList.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.expression.operators.relational;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -21,7 +22,7 @@
 /**
  * A list of expressions, as in SELECT A FROM TAB WHERE B IN (expr1,expr2,expr3)
  */
-public class ExpressionList implements ItemsList {
+public class ExpressionList implements ItemsList, Serializable {
 
     private List<Expression> expressions;
     private boolean usingBrackets = true;

File: src/main/java/net/sf/jsqlparser/parser/ASTNodeAccess.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.parser;
 
-public interface ASTNodeAccess {
+import java.io.Serializable;
+
+public interface ASTNodeAccess extends Serializable {
 
     SimpleNode getASTNode();
 

File: src/main/java/net/sf/jsqlparser/parser/ASTNodeAccessImpl.java
Patch:
@@ -11,7 +11,7 @@
 
 public class ASTNodeAccessImpl implements ASTNodeAccess {
 
-    private SimpleNode node;
+    private transient SimpleNode node;
 
     @Override
     public SimpleNode getASTNode() {

File: src/main/java/net/sf/jsqlparser/statement/DeclareStatement.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -189,7 +190,7 @@ public DeclareStatement addColumnDefinitions(Collection<? extends ColumnDefiniti
         return this.withColumnDefinitions(collection);
     }
 
-    public static class TypeDefExpr {
+    public static class TypeDefExpr implements Serializable {
 
         public final UserVariable userVariable;
         public final ColDataType colDataType;

File: src/main/java/net/sf/jsqlparser/statement/ExplainStatement.java
Patch:
@@ -11,6 +11,7 @@
 
 import net.sf.jsqlparser.statement.select.Select;
 
+import java.io.Serializable;
 import java.util.LinkedHashMap;
 import java.util.stream.Collectors;
 
@@ -88,7 +89,7 @@ public enum OptionType {
         FORMAT
     }
 
-    public static class Option {
+    public static class Option implements Serializable {
 
         private final OptionType type;
         private String value;

File: src/main/java/net/sf/jsqlparser/statement/OutputClause.java
Patch:
@@ -14,6 +14,7 @@
 import net.sf.jsqlparser.statement.select.PlainSelect;
 import net.sf.jsqlparser.statement.select.SelectItem;
 
+import java.io.Serializable;
 import java.util.List;
 import java.util.Objects;
 
@@ -37,7 +38,7 @@
  *     | $action
  * </pre>
  */
-public class OutputClause {
+public class OutputClause implements Serializable {
     List<SelectItem> selectItemList;
     UserVariable tableVariable;
     Table outputTable;

File: src/main/java/net/sf/jsqlparser/statement/ReferentialAction.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.statement;
 
-public class ReferentialAction {
+import java.io.Serializable;
+
+public class ReferentialAction implements Serializable {
 
     private Type type;
     private Action action;

File: src/main/java/net/sf/jsqlparser/statement/SetStatement.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 import net.sf.jsqlparser.expression.Expression;
@@ -127,7 +128,7 @@ public void accept(StatementVisitor statementVisitor) {
         statementVisitor.visit(this);
     }
 
-    static class NameExpr {
+    static class NameExpr implements Serializable {
 
         private Object name;
         private List<Expression> expressions;

File: src/main/java/net/sf/jsqlparser/statement/Statements.java
Patch:
@@ -9,13 +9,14 @@
  */
 package net.sf.jsqlparser.statement;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 
-public class Statements {
+public class Statements implements Serializable {
 
     private List<Statement> statements;
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/ColDataType.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.create.table;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -17,7 +18,7 @@
 import static java.util.stream.Collectors.joining;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
-public class ColDataType {
+public class ColDataType implements Serializable {
 
     private String dataType;
     private List<String> argumentsStringList;

File: src/main/java/net/sf/jsqlparser/statement/create/table/ColumnDefinition.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.create.table;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -20,7 +21,7 @@
 /**
  * Globally used definition class for columns.
  */
-public class ColumnDefinition {
+public class ColumnDefinition implements Serializable {
 
     private String columnName;
     private ColDataType colDataType;

File: src/main/java/net/sf/jsqlparser/statement/create/table/RowMovement.java
Patch:
@@ -9,10 +9,12 @@
  */
 package net.sf.jsqlparser.statement.create.table;
 
+import java.io.Serializable;
+
 /**
  * Holds data for the {@code row_movement} clause: https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_7002.htm#i2204697
  */
-public class RowMovement {
+public class RowMovement implements Serializable {
 
     private RowMovementMode mode;
 

File: src/main/java/net/sf/jsqlparser/statement/insert/InsertConflictTarget.java
Patch:
@@ -11,6 +11,8 @@
 
 import net.sf.jsqlparser.expression.Expression;
 
+import java.io.Serializable;
+
 /**
  * https://www.postgresql.org/docs/current/sql-insert.html
  * <pre>
@@ -21,7 +23,7 @@
  * </pre>
  * Currently, COLLATE is not supported yet.
  */
-public class InsertConflictTarget {
+public class InsertConflictTarget implements Serializable {
 
     String indexColumnName;
     Expression indexExpression;

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeInsert.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.merge;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -18,7 +19,7 @@
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
-public class MergeInsert {
+public class MergeInsert implements Serializable {
 
     private List<Column> columns = null;
     private List<Expression> values = null;

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeUpdate.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.merge;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -17,7 +18,7 @@
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.schema.Column;
 
-public class MergeUpdate {
+public class MergeUpdate implements Serializable {
 
     private List<Column> columns = null;
     private List<Expression> values = null;

File: src/main/java/net/sf/jsqlparser/statement/select/Distinct.java
Patch:
@@ -9,13 +9,14 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 
-public class Distinct {
+public class Distinct implements Serializable {
 
     private List<SelectItem> onSelectItems;
     private boolean useUnique = false;

File: src/main/java/net/sf/jsqlparser/statement/select/ExpressionListItem.java
Patch:
@@ -12,7 +12,9 @@
 import net.sf.jsqlparser.expression.Alias;
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 
-public class ExpressionListItem {
+import java.io.Serializable;
+
+public class ExpressionListItem implements Serializable {
 
     private ExpressionList expressionList;
     private Alias alias;

File: src/main/java/net/sf/jsqlparser/statement/select/Fetch.java
Patch:
@@ -11,7 +11,9 @@
 
 import net.sf.jsqlparser.expression.JdbcParameter;
 
-public class Fetch {
+import java.io.Serializable;
+
+public class Fetch implements Serializable {
 
     private long rowCount;
     private JdbcParameter fetchJdbcParameter = null;

File: src/main/java/net/sf/jsqlparser/statement/select/First.java
Patch:
@@ -11,7 +11,9 @@
 
 import net.sf.jsqlparser.expression.JdbcParameter;
 
-public class First {
+import java.io.Serializable;
+
+public class First implements Serializable {
 
     public enum Keyword {
         FIRST,

File: src/main/java/net/sf/jsqlparser/statement/select/GroupByElement.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -17,7 +18,7 @@
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 
-public class GroupByElement {
+public class GroupByElement implements Serializable {
     // ExpressionList has 'usingBrackets = true' and so we need to switch it off explicitly
     private ExpressionList groupByExpressions = new ExpressionList().withUsingBrackets(false);
     private List groupingSets = new ArrayList();

File: src/main/java/net/sf/jsqlparser/statement/select/Offset.java
Patch:
@@ -11,7 +11,9 @@
 
 import net.sf.jsqlparser.expression.Expression;
 
-public class Offset {
+import java.io.Serializable;
+
+public class Offset implements Serializable {
     private Expression offsetExpression = null;
     private String offsetParam = null;
 

File: src/main/java/net/sf/jsqlparser/statement/select/OptimizeFor.java
Patch:
@@ -9,10 +9,12 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+import java.io.Serializable;
+
 /**
  * A optimize for clause.
  */
-public class OptimizeFor {
+public class OptimizeFor implements Serializable {
 
     private long rowCount;
 

File: src/main/java/net/sf/jsqlparser/statement/select/OrderByElement.java
Patch:
@@ -11,7 +11,9 @@
 
 import net.sf.jsqlparser.expression.Expression;
 
-public class OrderByElement {
+import java.io.Serializable;
+
+public class OrderByElement implements Serializable {
 
     public enum NullOrdering {
         NULLS_FIRST,

File: src/main/java/net/sf/jsqlparser/statement/select/Pivot.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -17,7 +18,7 @@
 import net.sf.jsqlparser.expression.Alias;
 import net.sf.jsqlparser.schema.Column;
 
-public class Pivot {
+public class Pivot implements Serializable {
 
     private List<FunctionItem> functionItems;
     private List<Column> forColumns;

File: src/main/java/net/sf/jsqlparser/statement/select/Skip.java
Patch:
@@ -11,7 +11,9 @@
 
 import net.sf.jsqlparser.expression.JdbcParameter;
 
-public class Skip {
+import java.io.Serializable;
+
+public class Skip implements Serializable {
 
     private Long rowCount;
     private JdbcParameter jdbcParameter;

File: src/main/java/net/sf/jsqlparser/statement/select/Top.java
Patch:
@@ -11,7 +11,9 @@
 
 import net.sf.jsqlparser.expression.Expression;
 
-public class Top {
+import java.io.Serializable;
+
+public class Top implements Serializable {
 
     private boolean hasParenthesis = false;
     private boolean isPercentage = false;

File: src/main/java/net/sf/jsqlparser/statement/select/UnPivot.java
Patch:
@@ -12,9 +12,10 @@
 import net.sf.jsqlparser.expression.Alias;
 import net.sf.jsqlparser.schema.Column;
 
+import java.io.Serializable;
 import java.util.List;
 
-public class UnPivot {
+public class UnPivot implements Serializable {
 
     private boolean includeNulls = false;
     private boolean includeNullsSpecified = false;

File: src/main/java/net/sf/jsqlparser/statement/select/Wait.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.statement.select;
 
-public class Wait {
+import java.io.Serializable;
+
+public class Wait implements Serializable {
 
     private long timeout;
 

File: src/main/java/net/sf/jsqlparser/statement/select/WithIsolation.java
Patch:
@@ -10,7 +10,9 @@
 package net.sf.jsqlparser.statement.select;
 
 
-public class WithIsolation {
+import java.io.Serializable;
+
+public class WithIsolation implements Serializable {
 
     private String isolation = "UR";
 

File: src/main/java/net/sf/jsqlparser/statement/update/UpdateSet.java
Patch:
@@ -13,11 +13,12 @@
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.schema.Column;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Objects;
 
-public class UpdateSet {
+public class UpdateSet implements Serializable {
     protected boolean usingBracketsForColumns = false;
     protected boolean usingBracketsForValues = false;
     protected ArrayList<Column> columns = new ArrayList<>();

File: src/main/java/net/sf/jsqlparser/util/deparser/DropDeParser.java
Patch:
@@ -21,6 +21,9 @@ public DropDeParser(StringBuilder buffer) {
     @Override
     public void deParse(Drop drop) {
         buffer.append("DROP ");
+        if (drop.isUsingTemporary()) {
+            buffer.append("TEMPORARY ");
+        }
         if (drop.isMaterialized()) {
             buffer.append("MATERIALIZED ");
         }

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MariaDbVersion.java
Patch:
@@ -9,12 +9,12 @@
  */
 package net.sf.jsqlparser.util.validation.feature;
 
+import net.sf.jsqlparser.parser.feature.Feature;
+
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
 
-import net.sf.jsqlparser.parser.feature.Feature;
-
 /**
  * Please add Features supported and place a link to public documentation
  *
@@ -99,7 +99,7 @@ public enum MariaDbVersion implements Version {
                     Feature.dropViewIfExists, Feature.dropSchemaIfExists, Feature.dropSequenceIfExists,
 
                     // https://mariadb.com/kb/en/replace/
-                    Feature.replace,
+                    Feature.upsert,
 
                     // https://mariadb.com/kb/en/alter/
                     Feature.alterTable,

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -9,10 +9,11 @@
  */
 package net.sf.jsqlparser.util.validation.feature;
 
+import net.sf.jsqlparser.parser.feature.Feature;
+
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Set;
-import net.sf.jsqlparser.parser.feature.Feature;
 
 /**
  * Please add Features supported and place a link to public documentation
@@ -65,7 +66,7 @@ public enum MySqlVersion implements Version {
                     Feature.update, Feature.updateJoins, Feature.updateOrderBy, Feature.updateLimit,
 
                     // https://dev.mysql.com/doc/refman/8.0/en/replace.html
-                    Feature.replace,
+                    Feature.upsert,
 
                     // https://dev.mysql.com/doc/refman/8.0/en/delete.html
                     Feature.delete, Feature.deleteJoin, Feature.deleteTables, Feature.deleteLimit,

File: src/test/java/net/sf/jsqlparser/util/validation/validator/ReplaceValidatorTest.java
Patch:
@@ -9,14 +9,15 @@
  */
 package net.sf.jsqlparser.util.validation.validator;
 
-import java.util.Arrays;
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.feature.Feature;
 import net.sf.jsqlparser.util.validation.ValidationTestAsserts;
 import net.sf.jsqlparser.util.validation.feature.DatabaseType;
 import net.sf.jsqlparser.util.validation.feature.FeaturesAllowed;
 import org.junit.jupiter.api.Test;
 
+import java.util.Arrays;
+
 public class ReplaceValidatorTest extends ValidationTestAsserts {
 
     @Test
@@ -33,7 +34,7 @@ public void testValidateReplaceNotAllowed() throws JSQLParserException {
         for (String sql : Arrays.asList("REPLACE mytable SET col1='as', col2=?, col3=565",
                 "REPLACE mytable (col1, col2, col3) VALUES ('as', ?, 565)",
                 "REPLACE mytable (col1, col2, col3) SELECT * FROM mytable3")) {
-            validateNotAllowed(sql, 1, 1, FeaturesAllowed.SELECT.copy().add(FeaturesAllowed.JDBC), Feature.replace);
+            validateNotAllowed(sql, 1, 1, FeaturesAllowed.SELECT.copy().add(FeaturesAllowed.JDBC), Feature.upsert);
         }
     }
 

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateViewDeParser.java
Patch:
@@ -60,6 +60,9 @@ public void deParse(CreateView createView) {
             buffer.append("MATERIALIZED ");
         }
         buffer.append("VIEW ").append(createView.getView().getFullyQualifiedName());
+        if (createView.isIfNotExists()) {
+            buffer.append(" IF NOT EXISTS");
+        }
         if (createView.getColumnNames() != null) {
             buffer.append(PlainSelect.getStringList(createView.getColumnNames(), true, true));
         }

File: src/main/java/net/sf/jsqlparser/statement/Statements.java
Patch:
@@ -35,8 +35,8 @@ public void accept(StatementVisitor statementVisitor) {
     public String toString() {
         StringBuilder b = new StringBuilder();
         for (Statement stmt : statements) {
-            if (stmt instanceof IfElseStatement) {
-                // IfElseStatements print the Semicolons by themselves
+            // IfElseStatements and Blocks control the Semicolons by themselves
+            if (stmt instanceof IfElseStatement || stmt instanceof Block) {
                 b.append(stmt).append("\n");
             } else {
                 b.append(stmt).append(";\n");

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateTableDeParser.java
Patch:
@@ -120,6 +120,9 @@ public void deParse(CreateTable createTable) {
                 buffer.append(")");
             }
         }
+        if (createTable.getSpannerInterleaveIn() != null) {
+            buffer.append(", ").append(createTable.getSpannerInterleaveIn());
+        }
     }
 
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -294,6 +294,9 @@ public void visit(Block block) {
             }
         }
         buffer.append("END");
+        if (block.hasSemicolonAfterEnd()) {
+            buffer.append(";");
+        }
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/AnalyticType.java
Patch:
@@ -12,5 +12,7 @@
 public enum AnalyticType {
     OVER,
     WITHIN_GROUP,
+
+    WITHIN_GROUP_OVER,
     FILTER_ONLY
 }

File: src/main/java/net/sf/jsqlparser/expression/OrderByClause.java
Patch:
@@ -27,7 +27,7 @@ public void setOrderByElements(List<OrderByElement> orderByElements) {
         this.orderByElements = orderByElements;
     }
 
-    void toStringOrderByElements(StringBuilder b) {
+    public void toStringOrderByElements(StringBuilder b) {
         if (orderByElements != null && !orderByElements.isEmpty()) {
             b.append("ORDER BY ");
             for (int i = 0; i < orderByElements.size(); i++) {

File: src/main/java/net/sf/jsqlparser/expression/PartitionByClause.java
Patch:
@@ -29,7 +29,7 @@ public void setPartitionExpressionList(ExpressionList partitionExpressionList, b
         this.brackets = brackets;
     }
 
-    void toStringPartitionBy(StringBuilder b) {
+    public void toStringPartitionBy(StringBuilder b) {
         if (partitionExpressionList != null && !partitionExpressionList.getExpressions().isEmpty()) {
             b.append("PARTITION BY ");
             b.append(PlainSelect.

File: src/main/java/net/sf/jsqlparser/parser/ParserKeywordsUtils.java
Patch:
@@ -365,7 +365,7 @@ public static void buildGrammarForRelObjectNameWithoutValue(File file) throws Ex
                        + "{    Token tk = null; }\n"
                        + "{\n"
                        //@todo: find a way to avoid those hardcoded compound tokens
-                       + "    ( tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> |  tk=<K_DATE_LITERAL> | tk=<K_DATETIMELITERAL> | tk=<K_STRING_FUNCTION_NAME> | tk=<K_ISOLATION> \n"
+                       + "    ( tk=<S_IDENTIFIER> | tk=<S_QUOTED_IDENTIFIER> |  tk=<K_DATE_LITERAL> | tk=<K_DATETIMELITERAL> | tk=<K_STRING_FUNCTION_NAME> | tk=<K_ISOLATION> | tk=<K_TIME_KEY_EXPR> \n"
                        + "      ");
 
         for (String keyword: allKeywords) {

File: src/main/java/net/sf/jsqlparser/statement/select/PlainSelect.java
Patch:
@@ -572,7 +572,7 @@ public static String getStringList(List<?> list, boolean useComma, boolean useBr
      */
     public static StringBuilder appendStringListTo(StringBuilder builder, List<?> list, boolean useComma, boolean useBrackets) {
         if (list != null) {
-            String comma = useComma ? "," : "";
+            String comma = useComma ? ", " : " ";
 
             if (useBrackets) {
                 builder.append("(");
@@ -581,7 +581,7 @@ public static StringBuilder appendStringListTo(StringBuilder builder, List<?> li
             int size = list.size();
             for (int i = 0; i < size; i++) {
                 builder.append(list.get(i)).append(i < size - 1
-                        ? comma + " "
+                        ? comma
                         : "");
             }
 

File: src/main/java/net/sf/jsqlparser/statement/select/ValuesList.java
Patch:
@@ -88,7 +88,7 @@ public String toString() {
         StringBuilder b = new StringBuilder();
 
         b.append("(VALUES ");
-        for (Iterator<ExpressionList> it = getMultiExpressionList().getExprList().iterator(); it.
+        for (Iterator<ExpressionList> it = getMultiExpressionList().getExpressionLists().iterator(); it.
                 hasNext();) {
             b.append(PlainSelect.getStringList(it.next().getExpressions(), true, !isNoBrackets()));
             if (it.hasNext()) {
@@ -97,7 +97,7 @@ public String toString() {
         }
         b.append(")");
         if (alias != null) {
-            b.append(alias.toString());
+            b.append(alias);
 
             if (columnNames != null) {
                 b.append("(");

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -55,6 +55,8 @@ public class SpecialOracleTest {
 
     private final List<String> EXPECTED_SUCCESSES = Arrays.asList(
             "aggregate01.sql",
+            "analytic_query04.sql",
+            "analytic_query05.sql",
             "analytic_query06.sql",
             "analytic_query08.sql",
             "analytic_query09.sql",
@@ -218,6 +220,7 @@ public class SpecialOracleTest {
             "query_factoring02.sql",
             "query_factoring03.sql",
             "query_factoring06.sql",
+            "query_factoring07.sql",
             "query_factoring08.sql",
             "query_factoring09.sql",
             "query_factoring11.sql",

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -135,6 +135,7 @@ public class SpecialOracleTest {
             "function05.sql",
             "for_update04.sql",
             "for_update05.sql",
+            "for_update06.sql",
             "for_update08.sql",
             "function01.sql",
             "function02.sql",
@@ -162,6 +163,7 @@ public class SpecialOracleTest {
             "insert02.sql",
             "interval02.sql",
             "interval04.sql",
+            "interval05.sql",
             "join01.sql",
             "join02.sql",
             "join03.sql",

File: src/main/java/net/sf/jsqlparser/parser/AbstractJSqlParser.java
Patch:
@@ -66,5 +66,4 @@ public void setErrorRecovery(boolean errorRecovery) {
     public List<ParseException> getParseErrors() {
         return parseErrors;
     }
-
 }

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -370,5 +370,4 @@ public static int getNestingDepth(String sql) {
       }
       return maxlevel;
     }
-
 }

File: src/main/java/net/sf/jsqlparser/statement/drop/Drop.java
Patch:
@@ -84,7 +84,7 @@ public String toString() {
         }
 
         if (parameters != null && !parameters.isEmpty()) {
-            sql += " " + PlainSelect.getStringList(parameters);
+            sql += " " + PlainSelect.getStringList(parameters, false, false);
         }
 
         return sql;

File: src/main/java/net/sf/jsqlparser/util/deparser/DropDeParser.java
Patch:
@@ -33,7 +33,7 @@ public void deParse(Drop drop) {
         }
 
         if (drop.getParameters() != null && !drop.getParameters().isEmpty()) {
-            buffer.append(" ").append(PlainSelect.getStringList(drop.getParameters()));
+            buffer.append(" ").append(PlainSelect.getStringList(drop.getParameters(), false, false));
         }
     }
 

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -185,6 +185,7 @@ public class SpecialOracleTest {
             "keywordasidentifier01.sql",
             "keywordasidentifier02.sql",
             "keywordasidentifier03.sql",
+            "keywordasidentifier04.sql",
             "keywordasidentifier05.sql",
             "lexer02.sql",
             "lexer03.sql",

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.function.Consumer;
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.expression.Expression;
+import net.sf.jsqlparser.parser.feature.Feature;
 import net.sf.jsqlparser.statement.Statement;
 import net.sf.jsqlparser.statement.Statements;
 
@@ -33,7 +34,6 @@
 @SuppressWarnings("PMD.CyclomaticComplexity")
 public final class CCJSqlParserUtil {
     public final static int ALLOWED_NESTING_DEPTH = 10;
-    public static final int PARSER_TIMEOUT = 6000;
 
     private CCJSqlParserUtil() {
     }
@@ -255,7 +255,7 @@ public Statement call() throws Exception {
             });
             executorService.shutdown();
 
-            statement = future.get(PARSER_TIMEOUT, TimeUnit.MILLISECONDS);
+            statement = future.get( parser.getConfiguration().getAsInteger(Feature.timeOut), TimeUnit.MILLISECONDS);
         } catch (TimeoutException ex) {
             parser.interrupted = true;
             throw new JSQLParserException("Time out occurred.", ex);
@@ -319,7 +319,7 @@ public Statements call() throws Exception {
             });
             executorService.shutdown();
 
-            statements = future.get(PARSER_TIMEOUT, TimeUnit.MILLISECONDS);
+            statements = future.get( parser.getConfiguration().getAsInteger(Feature.timeOut) , TimeUnit.MILLISECONDS);
         } catch (TimeoutException ex) {
             parser.interrupted = true;
             throw new JSQLParserException("Time out occurred.", ex);

File: src/main/java/net/sf/jsqlparser/parser/feature/Feature.java
Patch:
@@ -741,6 +741,8 @@ public enum Feature {
      * needs to be switched off, when VALIDATING statements or parsing blocks
      */
     allowUnsupportedStatements(false),
+
+    timeOut( 6000)
     ;
 
     private Object value;

File: src/test/java/net/sf/jsqlparser/util/cnfexpression/CloneHelperTest.java
Patch:
@@ -32,15 +32,15 @@ public void testChangeBack() {
         MultipleExpression ors = transform( Arrays.asList("a>b", "5=a", "b=c", "a>c"));
         Expression expr = CloneHelper.changeBack(true, ors);
         assertThat(expr).isInstanceOf(Parenthesis.class);
-        assertThat(expr.toString()).isEqualTo("a > b OR 5 = a OR b = c OR a > c");
+        assertThat(expr.toString()).isEqualTo("(a > b OR 5 = a OR b = c OR a > c)");
     }
     
     @Test
     public void testChangeBackOddNumberOfExpressions() {
         MultipleExpression ors = transform( Arrays.asList("a>b", "5=a", "b=c", "a>c", "e<f"));
         Expression expr = CloneHelper.changeBack(true, ors);
         assertThat(expr).isInstanceOf(Parenthesis.class);
-        assertThat(expr.toString()).isEqualTo("a > b OR 5 = a OR b = c OR a > c OR e < f");
+        assertThat(expr.toString()).isEqualTo("(a > b OR 5 = a OR b = c OR a > c OR e < f)");
     }
     
     private static MultipleExpression transform(List<String> expressions) {

File: src/test/java/net/sf/jsqlparser/util/cnfexpression/CloneHelperTest.java
Patch:
@@ -17,7 +17,6 @@
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.Parenthesis;
-import net.sf.jsqlparser.expression.operators.conditional.OrExpression;
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;
 import static org.assertj.core.api.Assertions.assertThat;
 import org.junit.jupiter.api.Test;

File: src/test/java/net/sf/jsqlparser/util/cnfexpression/CloneHelperTest.java
Patch:
@@ -16,6 +16,7 @@
 import static java.util.stream.Collectors.toList;
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.expression.Expression;
+import net.sf.jsqlparser.expression.Parenthesis;
 import net.sf.jsqlparser.expression.operators.conditional.OrExpression;
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -31,15 +32,15 @@ public class CloneHelperTest {
     public void testChangeBack() {
         MultipleExpression ors = transform( Arrays.asList("a>b", "5=a", "b=c", "a>c"));
         Expression expr = CloneHelper.changeBack(true, ors);
-        assertThat(expr).isInstanceOf(OrExpression.class);
+        assertThat(expr).isInstanceOf(Parenthesis.class);
         assertThat(expr.toString()).isEqualTo("a > b OR 5 = a OR b = c OR a > c");
     }
     
     @Test
     public void testChangeBackOddNumberOfExpressions() {
         MultipleExpression ors = transform( Arrays.asList("a>b", "5=a", "b=c", "a>c", "e<f"));
         Expression expr = CloneHelper.changeBack(true, ors);
-        assertThat(expr).isInstanceOf(OrExpression.class);
+        assertThat(expr).isInstanceOf(Parenthesis.class);
         assertThat(expr.toString()).isEqualTo("a > b OR 5 = a OR b = c OR a > c OR e < f");
     }
     

File: src/main/java/net/sf/jsqlparser/expression/StringValue.java
Patch:
@@ -31,7 +31,7 @@ public StringValue() {
 
     public StringValue(String escapedValue) {
         // removing "'" at the start and at the end
-        if (escapedValue.startsWith("'") && escapedValue.endsWith("'")) {
+        if (escapedValue.length() >= 2 && escapedValue.startsWith("'") && escapedValue.endsWith("'")) {
             value = escapedValue.substring(1, escapedValue.length() - 1);
             return;
         }

File: src/main/java/net/sf/jsqlparser/util/validation/feature/H2Version.java
Patch:
@@ -100,6 +100,7 @@ public enum H2Version implements Version {
                     // http://h2database.com/html/commands.html#insert
                     Feature.insert,
                     Feature.insertValues,
+                    Feature.values,
                     Feature.insertFromSelect,
                     // http://h2database.com/html/commands.html#update
                     Feature.update,
@@ -136,7 +137,8 @@ public enum H2Version implements Version {
                     // http://www.h2database.com/html/commands.html#grant_role
                     Feature.grant,
                     // http://h2database.com/html/commands.html#commit
-                    Feature.commit));
+                    Feature.commit
+            ));
 
     private Set<Feature> features;
     private String versionString;

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MariaDbVersion.java
Patch:
@@ -60,7 +60,7 @@ public enum MariaDbVersion implements Version {
                     Feature.withItem, Feature.withItemRecursive,
 
                     // https://mariadb.com/kb/en/insert/
-                    Feature.insert, Feature.insertValues,
+                    Feature.insert, Feature.insertValues, Feature.values,
                     Feature.insertFromSelect, Feature.insertModifierPriority, Feature.insertModifierIgnore,
                     Feature.insertUseSet, Feature.insertUseDuplicateKeyUpdate, Feature.insertReturningExpressionList,
 

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -54,6 +54,7 @@ public enum MySqlVersion implements Version {
                     // https://dev.mysql.com/doc/refman/8.0/en/insert.html
                     Feature.insert,
                     Feature.insertValues,
+                    Feature.values,
                     Feature.insertFromSelect, Feature.insertUseSet, Feature.insertModifierPriority,
                     Feature.insertModifierIgnore, Feature.insertUseDuplicateKeyUpdate,
 

File: src/main/java/net/sf/jsqlparser/util/validation/feature/OracleVersion.java
Patch:
@@ -88,6 +88,7 @@ public enum OracleVersion implements Version {
                     // https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/INSERT.html
                     Feature.insert,
                     Feature.insertValues,
+                    Feature.values,
                     // https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/INSERT.html
                     // see "single_table_insert"
                     Feature.insertFromSelect,

File: src/main/java/net/sf/jsqlparser/util/validation/feature/PostgresqlVersion.java
Patch:
@@ -109,6 +109,7 @@ public enum PostgresqlVersion implements Version {
                     // https://www.postgresql.org/docs/current/sql-insert.html
                     Feature.insert,
                     Feature.insertValues,
+                    Feature.values,
                     Feature.insertFromSelect,
                     Feature.insertReturningAll, Feature.insertReturningExpressionList,
                     // https://www.postgresql.org/docs/current/sql-update.html

File: src/main/java/net/sf/jsqlparser/util/validation/feature/SQLVersion.java
Patch:
@@ -29,10 +29,13 @@ public enum SQLVersion implements Version {
             Feature.jdbcParameter,
             Feature.jdbcNamedParameter,
             // common features
+            Feature.setOperation,
             Feature.select,
             Feature.selectGroupBy, Feature.function,
             Feature.insert,
+            Feature.insertFromSelect,
             Feature.insertValues,
+            Feature.values,
             Feature.update,
             Feature.delete,
             Feature.truncate,

File: src/main/java/net/sf/jsqlparser/util/validation/validator/InsertValidator.java
Patch:
@@ -29,7 +29,6 @@ public void validate(Insert insert) {
             validateOptionalFeature(c, insert.getSelect(), Feature.insertFromSelect);
             validateFeature(c, insert.isUseSet(), Feature.insertUseSet);
             validateFeature(c, insert.isUseDuplicate(), Feature.insertUseDuplicateKeyUpdate);
-            validateFeature(c, insert.isReturningAllColumns(), Feature.insertReturningAll);
             validateOptionalFeature(c, insert.getReturningExpressionList(), Feature.insertReturningExpressionList);
         }
 
@@ -60,8 +59,8 @@ public void validate(Insert insert) {
         }
 
         if (isNotEmpty(insert.getReturningExpressionList())) {
-            ExpressionValidator v = getValidator(ExpressionValidator.class);
-            insert.getReturningExpressionList().forEach(c -> c.getExpression().accept(v));
+            SelectValidator v = getValidator(SelectValidator.class);
+            insert.getReturningExpressionList().forEach(c -> c .accept(v));
         }
     }
 

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -5193,6 +5193,9 @@ public void testWithIsolation() throws JSQLParserException {
         isolation = ((PlainSelect) select.getSelectBody()).getWithIsolation().getIsolation();
         assertEquals("Cs", isolation);
         assertSqlCanBeParsedAndDeparsed(statement);
+
+        statement = "SELECT rs.col, * FROM mytable RS WHERE mytable.col = 9";
+        assertSqlCanBeParsedAndDeparsed(statement);
     }
     
     @Test

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -120,4 +120,6 @@ public interface StatementVisitor {
     void visit(PurgeStatement purgeStatement);
 
     void visit(AlterSystemStatement alterSystemStatement);
+
+    void visit(UnsupportedStatement unsupportedStatement);
 }

File: src/test/java/net/sf/jsqlparser/statement/create/CreateTableTest.java
Patch:
@@ -170,7 +170,6 @@ public void testCreateTableUniqueConstraint() throws JSQLParserException {
         CreateTable createTable
                 = (CreateTable) CCJSqlParserUtil.parseStatements(sqlStr).getStatements().get(0);
 
-        System.out.println(createTable.toString());
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/expression/JsonFunctionType.java
Patch:
@@ -18,4 +18,5 @@ public enum JsonFunctionType {
     OBJECT
     , ARRAY
     , POSTGRES_OBJECT
+    , MYSQL_OBJECT
 }

File: src/test/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapterTest.java
Patch:
@@ -216,7 +216,7 @@ public void testAtTimeZoneExpression() throws JSQLParserException {
     public void testJsonFunction() throws JSQLParserException {
         ExpressionVisitorAdapter adapter = new ExpressionVisitorAdapter();
         CCJSqlParserUtil
-                .parseExpression("JSON_OBJECT( KEY foo VALUE bar, KEY foo VALUE bar)")
+                .parseExpression("JSON_OBJECT( KEY 'foo' VALUE bar, KEY 'foo' VALUE bar)")
                 .accept(adapter);
         CCJSqlParserUtil
                 .parseExpression("JSON_ARRAY( (SELECT * from dual) )")

File: src/test/java/net/sf/jsqlparser/test/TestUtils.java
Patch:
@@ -54,8 +54,9 @@ public class TestUtils {
     private static final Pattern SQL_SANITATION_PATTERN
             = Pattern.compile("(\\s+)", Pattern.MULTILINE);
 
+    // Assure SPACE around Syntax Characters
     private static final Pattern SQL_SANITATION_PATTERN2
-            = Pattern.compile("\\s*([!/,()=+\\-*|\\]<>])\\s*", Pattern.MULTILINE);
+            = Pattern.compile("\\s*([!/,()=+\\-*|\\]<>:])\\s*", Pattern.MULTILINE);
 
     /**
      * @param statement
@@ -265,7 +266,7 @@ public static String buildSqlString(final String originalSql, boolean laxDeparsi
             // redundant white space
             sanitizedSqlStr = SQL_SANITATION_PATTERN.matcher(sanitizedSqlStr).replaceAll(" ");
 
-            // replace some more stuff
+            // assure spacing around Syntax Characters
             sanitizedSqlStr = SQL_SANITATION_PATTERN2.matcher(sanitizedSqlStr).replaceAll("$1");
             return sanitizedSqlStr.trim().toLowerCase();
         } else {

File: src/test/java/net/sf/jsqlparser/util/validation/validator/ExpressionValidatorTest.java
Patch:
@@ -226,7 +226,7 @@ public void testJsonFunctionExpression() throws JSQLParserException {
     public void testJsonAggregartFunctionExpression() throws JSQLParserException {
         validateNoErrors("SELECT JSON_ARRAYAGG( a FORMAT JSON ABSENT ON NULL ) FILTER( WHERE name = 'Raj' ) OVER( PARTITION BY name ) FROM mytbl", 1,
                 EXPRESSIONS);
-        validateNoErrors("SELECT JSON_OBJECT( KEY foo VALUE bar FORMAT JSON, foo:bar, foo:bar ABSENT ON NULL) FROM mytbl", 1,
+        validateNoErrors("SELECT JSON_OBJECT( KEY 'foo' VALUE bar FORMAT JSON, 'foo':bar, 'foo':bar ABSENT ON NULL) FROM mytbl", 1,
                 EXPRESSIONS);
     }
 

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapter.java
Patch:
@@ -492,12 +492,10 @@ public void visit(UnPivot unpivot) {
 
     @Override
     public void visit(AllColumns allColumns) {
-        allColumns.accept((ExpressionVisitor) this);
     }
 
     @Override
     public void visit(AllTableColumns allTableColumns) {
-        allTableColumns.accept((ExpressionVisitor) this);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -188,4 +188,6 @@ public interface ExpressionVisitor {
     void visit(AllValue allValue);
 
     void visit(IsDistinctExpression isDistinctExpression);
+
+    void visit(GeometryDistance geometryDistance);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SetOperationList.java
Patch:
@@ -97,8 +97,8 @@ public void setFetch(Fetch fetch) {
         this.fetch = fetch;
     }
 
-    public Fetch getWithIsolation() {
-        return fetch;
+    public WithIsolation getWithIsolation() {
+        return this.withIsolation;
     }
 
     public void setWithIsolation(WithIsolation withIsolation) {

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -115,6 +115,8 @@ public interface ExpressionVisitor {
 
     void visit(CastExpression cast);
 
+    void visit(TryCastExpression cast);
+
     void visit(Modulo modulo);
 
     void visit(AnalyticExpression aexpr);

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -264,9 +264,10 @@ public void visit(JdbcParameter jdbcParameter) {
     public void visit(LikeExpression likeExpression) {
         visitBinaryExpression(likeExpression,
                 (likeExpression.isNot() ? " NOT" : "") + (likeExpression.isCaseInsensitive() ? " ILIKE " : " LIKE "));
-        String escape = likeExpression.getEscape();
+        Expression escape = likeExpression.getEscape();
         if (escape != null) {
-            buffer.append(" ESCAPE '").append(escape).append('\'');
+            buffer.append(" ESCAPE ");
+            likeExpression.getEscape().accept(this);
         }
     }
 

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -1446,7 +1446,7 @@ public void testLike() throws JSQLParserException {
         plainSelect = (PlainSelect) select.getSelectBody();
         assertEquals("test", ((StringValue) ((LikeExpression) plainSelect.getWhere()).
                 getRightExpression()).getValue());
-        assertEquals("test2", ((LikeExpression) plainSelect.getWhere()).getEscape());
+        assertEquals(new StringValue("test2"), ((LikeExpression) plainSelect.getWhere()).getEscape());
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapter.java
Patch:
@@ -185,8 +185,6 @@ public void visit(InExpression expr) {
             expr.getRightExpression().accept(this);
         } else if (expr.getRightItemsList() != null) {
             expr.getRightItemsList().accept(this);
-        } else {
-            expr.getMultiExpressionList().accept(this);
         }
     }
 

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -242,8 +242,6 @@ public void visit(InExpression inExpression) {
             inExpression.getRightExpression().accept(this);
         } else if (inExpression.getRightItemsList() != null) {
             inExpression.getRightItemsList().accept(this);
-        } else {
-            inExpression.getMultiExpressionList().accept(this);
         }
     }
 

File: src/main/java/net/sf/jsqlparser/util/validation/validator/ExpressionValidator.java
Patch:
@@ -149,8 +149,6 @@ public void visit(InExpression inExpression) {
                 validateFeature(c, Feature.oracleOldJoinSyntax);
             }
         }
-
-        validateOptionalMultiExpressionList(inExpression.getMultiExpressionList());
         validateOptionalExpression(inExpression.getRightExpression(), this);
         validateOptionalItemsList(inExpression.getRightItemsList());
     }

File: src/test/java/net/sf/jsqlparser/statement/builder/JSQLParserFluentModelTests.java
Patch:
@@ -59,7 +59,8 @@ public void testParseAndBuild() throws JSQLParserException {
                 )).withRightExpression(
                 new InExpression()
                         .withLeftExpression(new Column(asList("t1", "col3")))
-                        .withRightItemsList(new ExpressionList().addExpressions(new StringValue("A"))));
+                        .withRightItemsList(new ExpressionList(new StringValue("A"))));
+
         Select select = new Select().withSelectBody(new PlainSelect().addSelectItems(new AllColumns()).withFromItem(t1)
                 .addJoins(new Join().withRightItem(t2)
                         .withOnExpression(
@@ -95,8 +96,7 @@ public void testParseAndBuildForXOR() throws JSQLParserException {
                         .withRightExpression(
                                 new InExpression()
                                         .withLeftExpression(new Column(asList("t1", "col3")))
-                                        .withRightItemsList(new ExpressionList()
-                                                .addExpressions(new StringValue("B"), new StringValue("C")))))
+                                        .withRightItemsList(new ExpressionList(new StringValue("B"), new StringValue("C")))))
                 .withRightExpression(new Column(asList("t2", "col4")));
 
         Select select = new Select().withSelectBody(new PlainSelect().addSelectItems(new AllColumns()).withFromItem(t1)

File: src/main/java/net/sf/jsqlparser/statement/select/WithItem.java
Patch:
@@ -89,7 +89,7 @@ public void setRecursive(boolean recursive) {
     }
 
     public SubSelect getSubSelect() {
-        return subSelect.withUseBrackets(false);
+        return subSelect;
     }
 
     public void setSubSelect(SubSelect subSelect) {

File: src/main/java/net/sf/jsqlparser/expression/JsonFunctionType.java
Patch:
@@ -17,4 +17,5 @@
 public enum JsonFunctionType {
     OBJECT
     , ARRAY
+    , POSTGRES_OBJECT
 }

File: src/main/java/net/sf/jsqlparser/expression/JsonKeyValuePair.java
Patch:
@@ -27,7 +27,7 @@ public class JsonKeyValuePair {
   public JsonKeyValuePair(String key, Object value, boolean usingKeyKeyword,
       boolean usingValueKeyword) {
     this.key = Objects.requireNonNull(key, "The KEY of the Pair must not be null");
-    this.value = Objects.requireNonNull(value, "The VALUE of the Pair must not be null");
+    this.value = value;
     this.usingKeyKeyword = usingKeyKeyword;
     this.usingValueKeyword = usingValueKeyword;
   }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -182,4 +182,6 @@ public interface ExpressionVisitor {
     void visit(AllColumns allColumns);
 
     void visit(AllTableColumns allTableColumns);
+
+    void visit(AllValue allValue);
 }

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,5 +10,5 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, COMMENT, UNSPECIFIC;
+    ADD, ALTER, DROP, DROP_PRIMARY_KEY, DROP_UNIQUE, DROP_FOREIGN_KEY, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, COMMENT, UNSPECIFIC;
 }

File: src/main/java/net/sf/jsqlparser/util/AddAliasesVisitor.java
Patch:
@@ -52,7 +52,7 @@ public void visit(SetOperationList setOpList) {
 
     @Override
     public void visit(AllTableColumns allTableColumns) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_YET);
+
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapter.java
Patch:
@@ -489,12 +489,12 @@ public void visit(UnPivot unpivot) {
 
     @Override
     public void visit(AllColumns allColumns) {
-
+        allColumns.accept((ExpressionVisitor) this);
     }
 
     @Override
     public void visit(AllTableColumns allTableColumns) {
-
+        allTableColumns.accept((ExpressionVisitor) this);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/Function.java
Patch:
@@ -207,8 +207,6 @@ public String toString() {
             } else {
                 params = namedParameters.toString();
             }
-        } else if (isAllColumns()) {
-            params = "(*)";
         } else {
             params = "()";
         }

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,5 +10,5 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM, RENAME, COMMENT, UNSPECIFIC;
+    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM, RENAME, RENAME_TABLE, COMMENT, UNSPECIFIC;
 }

File: src/test/java/net/sf/jsqlparser/statement/ExplainTest.java
Patch:
@@ -65,5 +65,8 @@ public void getOption_returnsValues() throws JSQLParserException {
 
         ExplainStatement.Option buffers = explain.getOption(ExplainStatement.OptionType.BUFFERS);
         assertThat(buffers).isNotNull().extracting(ExplainStatement.Option::getValue).isEqualTo("FALSE");
+
+        explain = (ExplainStatement) CCJSqlParserUtil.parse("EXPLAIN SELECT * FROM mytable");
+        assertThat(explain.getOption(ExplainStatement.OptionType.ANALYZE)).isNull();
     }
 }

File: src/test/java/net/sf/jsqlparser/statement/IfElseStatementTest.java
Patch:
@@ -82,7 +82,7 @@ public void testObjectBuilder() throws JSQLParserException {
   }
 
   @Test
-  public void testValidation() throws JSQLParserException {
+  public void testValidation() {
     String sqlStr = "IF OBJECT_ID('tOrigin', 'U') IS NOT NULL DROP TABLE tOrigin1;";
     List<ValidationError> errors =
         Validation.validate(Arrays.asList(DatabaseType.SQLSERVER, FeaturesAllowed.DROP), sqlStr);

File: src/main/java/net/sf/jsqlparser/util/SelectUtils.java
Patch:
@@ -83,7 +83,7 @@ public static void addExpression(Select select, final Expression expr) {
      */
     public static Join addJoin(Select select, final Table table, final Expression onExpression) {
         if (select.getSelectBody() instanceof PlainSelect) {
-            Join join = new Join().withRightItem(table).withOnExpression(onExpression);
+            Join join = new Join().withRightItem(table).addOnExpression(onExpression);
             select.getSelectBody(PlainSelect.class).addJoins(join);
             return join;
         } else {

File: src/test/java/net/sf/jsqlparser/statement/alter/RenameTableStatementTest.java
Patch:
@@ -89,7 +89,7 @@ public void testTableNamesFinder() throws JSQLParserException {
   public void testValidator() throws JSQLParserException {
     String sqlStr = "RENAME oldTableName TO newTableName";
 
-    ValidationTestAsserts.validateNoErrors(sqlStr, 1, DatabaseType.ORACLE);
+    ValidationTestAsserts.validateNoErrors(sqlStr, 1, DatabaseType.POSTGRESQL);
   }
   
   @Test

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -115,10 +115,12 @@ public class SpecialOracleTest {
             "condition14.sql",
             "condition19.sql",
             "condition20.sql",
+            "connect_by01.sql",
             "connect_by02.sql",
             "connect_by03.sql",
             "connect_by04.sql",
             "connect_by05.sql",
+            "connect_by06.sql",
             "connect_by07.sql",
             "datetime01.sql",
             "datetime02.sql",
@@ -175,6 +177,7 @@ public class SpecialOracleTest {
             "join14.sql",
             "join15.sql",
             "join16.sql",
+            "join17.sql",
             "join18.sql",
             "join19.sql",
             "join20.sql",

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -169,7 +169,7 @@ public void visit(Update update) {
         selectDeParser.setBuffer(buffer);
         expressionDeParser.setSelectVisitor(selectDeParser);
         expressionDeParser.setBuffer(buffer);
-        UpdateDeParser updateDeParser = new UpdateDeParser(expressionDeParser, selectDeParser, buffer);
+        UpdateDeParser updateDeParser = new UpdateDeParser(expressionDeParser, buffer);
         selectDeParser.setExpressionVisitor(expressionDeParser);
         updateDeParser.deParse(update);
 

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -17,7 +17,6 @@
 import net.sf.jsqlparser.statement.select.OrderByElement;
 import net.sf.jsqlparser.statement.select.OrderByVisitor;
 import net.sf.jsqlparser.statement.select.SelectExpressionItem;
-import net.sf.jsqlparser.statement.select.SelectVisitor;
 import net.sf.jsqlparser.statement.select.WithItem;
 import net.sf.jsqlparser.statement.update.Update;
 import net.sf.jsqlparser.statement.update.UpdateSet;
@@ -30,7 +29,7 @@ public UpdateDeParser() {
         super(new StringBuilder());
     }
 
-    public UpdateDeParser(ExpressionVisitor expressionVisitor, SelectVisitor selectVisitor, StringBuilder buffer) {
+    public UpdateDeParser(ExpressionVisitor expressionVisitor, StringBuilder buffer) {
         super(buffer);
         this.expressionVisitor = expressionVisitor;
     }

File: src/test/java/net/sf/jsqlparser/statement/create/CreateTableTest.java
Patch:
@@ -603,9 +603,9 @@ private String getLine(BufferedReader in) throws Exception {
     while (true) {
       line = in.readLine();
       if (line != null) {
-        if ((line.length() != 0)
-            && ((line.length() < 2)
-                || (line.length() >= 2) && !(line.charAt(0) == '/' && line.charAt(1) == '/'))) {
+        if (line.length() != 0
+            && (line.length() < 2
+                || line.length() >= 2 && !(line.charAt(0) == '/' && line.charAt(1) == '/'))) {
           break;
         }
       } else {

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -173,5 +173,6 @@ public interface ExpressionVisitor {
 
     void visit(JsonFunction aThis);
 
+    void visit(ConnectByRootOperator aThis);
     void visit(OracleNamedFunctionParameter aThis);
 }

File: src/main/java/net/sf/jsqlparser/statement/Statement.java
Patch:
@@ -12,6 +12,5 @@
 import net.sf.jsqlparser.Model;
 
 public interface Statement extends Model {
-
     void accept(StatementVisitor statementVisitor);
 }

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -114,6 +114,7 @@ public interface StatementVisitor {
 
     void visit(AlterSession alterSession);
 
+    void visit(IfElseStatement aThis);
     void visit(RenameTableStatement renameTableStatement);
 
     void visit(PurgeStatement purgeStatement);

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,5 +10,5 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM, RENAME, COMMENT;
+    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM, RENAME, COMMENT, UNSPECIFIC;
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -172,4 +172,6 @@ public interface ExpressionVisitor {
     void visit(JsonAggregateFunction aThis);
 
     void visit(JsonFunction aThis);
+
+    void visit(OracleNamedFunctionParameter aThis);
 }

File: src/main/java/net/sf/jsqlparser/expression/LongValue.java
Patch:
@@ -41,7 +41,7 @@ public void accept(ExpressionVisitor expressionVisitor) {
     }
 
     public long getValue() {
-        return Long.valueOf(stringValue);
+        return Long.parseLong(stringValue);
     }
 
     public BigInteger getBigIntegerValue() {

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -120,7 +120,7 @@ public static Expression parseExpression(String expression, boolean allowPartial
             consumer.accept(parser);
         }
         try {
-            Expression expr = parser.SimpleExpression();
+            Expression expr = parser.Expression();
             if (!allowPartialParse && parser.getNextToken().kind != CCJSqlParserTokenManager.EOF) {
                 throw new JSQLParserException("could only parse partial expression " + expr.toString());
             }

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -11,6 +11,7 @@
 
 import net.sf.jsqlparser.statement.alter.Alter;
 import net.sf.jsqlparser.statement.alter.AlterSession;
+import net.sf.jsqlparser.statement.alter.RenameTableStatement;
 import net.sf.jsqlparser.statement.alter.sequence.AlterSequence;
 import net.sf.jsqlparser.statement.comment.Comment;
 import net.sf.jsqlparser.statement.create.index.CreateIndex;
@@ -112,5 +113,7 @@ public interface StatementVisitor {
 
     void visit(AlterSession alterSession);
 
+    void visit(RenameTableStatement renameTableStatement);
+
     void visit(PurgeStatement purgeStatement);
 }

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -179,7 +179,7 @@ public void setIgnoreNulls(boolean ignoreNulls) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity", "PMD.MissingBreakInSwitch"})
     public String toString() {
         StringBuilder b = new StringBuilder();
 

File: src/main/java/net/sf/jsqlparser/expression/AnyType.java
Patch:
@@ -12,5 +12,6 @@
 public enum AnyType {
 
     ANY,
-    SOME
+    SOME,
+    ALL
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -99,8 +99,6 @@ public interface ExpressionVisitor {
 
     void visit(ExistsExpression existsExpression);
 
-    void visit(AllComparisonExpression allComparisonExpression);
-
     void visit(AnyComparisonExpression anyComparisonExpression);
 
     void visit(Concat concat);

File: src/test/java/net/sf/jsqlparser/statement/builder/ReflectionModelTest.java
Patch:
@@ -34,9 +34,10 @@ public class ReflectionModelTest {
 
     private static final List<Object> MODEL_OBJECTS = asList(new net.sf.jsqlparser.expression.Alias("a"),
             new net.sf.jsqlparser.expression.Alias.AliasColumn("a", new ColDataType("varchar")),
-            new net.sf.jsqlparser.expression.AllComparisonExpression(new SubSelect()),
             new net.sf.jsqlparser.expression.AnalyticExpression(),
             new net.sf.jsqlparser.expression.AnyComparisonExpression(AnyType.ANY, new SubSelect()),
+            new net.sf.jsqlparser.expression.AnyComparisonExpression(AnyType.ALL, new SubSelect()),
+             new net.sf.jsqlparser.expression.AnyComparisonExpression(AnyType.SOME, new SubSelect()),
             new net.sf.jsqlparser.expression.ArrayExpression(),
             new net.sf.jsqlparser.expression.CaseExpression(), new net.sf.jsqlparser.expression.CastExpression(),
             new net.sf.jsqlparser.expression.CollateExpression(),

File: src/test/java/net/sf/jsqlparser/statement/insert/InsertTest.java
Patch:
@@ -334,9 +334,8 @@ public void testInsertKeyWordIntervalIssue682() throws JSQLParserException {
     }
 
     @Test
-    @Ignore
     public void testWithAtFront() throws JSQLParserException {
-        assertSqlCanBeParsedAndDeparsed("WITH foo AS ( SELECT attr FROM bar ) INSERT INTO lalelu (attr) SELECT attr FROM foo");
+        assertSqlCanBeParsedAndDeparsed("WITH foo AS ( SELECT attr FROM bar ) INSERT INTO lalelu (attr) SELECT attr FROM foo", true);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -10,6 +10,7 @@
 package net.sf.jsqlparser.statement;
 
 import net.sf.jsqlparser.statement.alter.Alter;
+import net.sf.jsqlparser.statement.alter.AlterSession;
 import net.sf.jsqlparser.statement.alter.sequence.AlterSequence;
 import net.sf.jsqlparser.statement.comment.Comment;
 import net.sf.jsqlparser.statement.create.index.CreateIndex;
@@ -102,4 +103,6 @@ public interface StatementVisitor {
     void visit(CreateFunctionalStatement createFunctionalStatement);
 
     void visit(CreateSynonym createSynonym);
+
+    void visit(AlterSession alterSession);
 }

File: src/main/java/net/sf/jsqlparser/statement/create/view/CreateView.java
Patch:
@@ -116,6 +116,8 @@ public String toString() {
             case NO_FORCE:
                 sql.append("NO FORCE ");
                 break;
+            default:
+                // nothing
         }
 
         if (temp != TemporaryOption.NONE) {

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateViewDeParser.java
Patch:
@@ -50,6 +50,8 @@ public void deParse(CreateView createView) {
             break;
         case NONE:
             break;
+        default:
+            // nothing
         }
         if (createView.getTemporary() != TemporaryOption.NONE) {
             buffer.append(createView.getTemporary().name()).append(" ");

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -147,7 +147,7 @@ public List<String> getTableList(Expression expr) {
     @Override
     public void visit(WithItem withItem) {
         otherItemNames.add(withItem.getName().toLowerCase());
-        withItem.getSelectBody().accept(this);
+    withItem.getSubSelect().accept((ItemsListVisitor) this);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/util/validation/validator/SelectValidator.java
Patch:
@@ -287,7 +287,7 @@ public void visit(WithItem withItem) {
         if (isNotEmpty(withItem.getWithItemList())) {
             withItem.getWithItemList().forEach(wi -> wi.accept(this));
         }
-        withItem.getSelectBody().accept(this);
+        withItem.getSubSelect().accept(this);
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -179,7 +179,7 @@ public void setIgnoreNulls(boolean ignoreNulls) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public String toString() {
         StringBuilder b = new StringBuilder();
 

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapter.java
Patch:
@@ -30,7 +30,7 @@
 import net.sf.jsqlparser.statement.select.UnPivot;
 import net.sf.jsqlparser.statement.select.WithItem;
 
-@SuppressWarnings({"PMD.CyclomaticComplexity"})
+@SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.UncommentedEmptyMethodBody"})
 public class ExpressionVisitorAdapter implements ExpressionVisitor, ItemsListVisitor, PivotVisitor, SelectItemVisitor {
 
     private SelectVisitor selectVisitor;

File: src/main/java/net/sf/jsqlparser/expression/Function.java
Patch:
@@ -168,7 +168,7 @@ public void setKeep(KeepExpression keep) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public String toString() {
         String params;
 

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ItemsListVisitorAdapter.java
Patch:
@@ -11,6 +11,7 @@
 
 import net.sf.jsqlparser.statement.select.SubSelect;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class ItemsListVisitorAdapter implements ItemsListVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitorAdapter.java
Patch:
@@ -33,6 +33,7 @@
 import net.sf.jsqlparser.statement.upsert.Upsert;
 import net.sf.jsqlparser.statement.values.ValuesStatement;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class StatementVisitorAdapter implements StatementVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterExpression.java
Patch:
@@ -360,7 +360,7 @@ public void setUk(boolean uk) {
   }
 
   @Override
-  @SuppressWarnings({"PMD.CyclomaticComplexity"})
+  @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
   public String toString() {
 
     StringBuilder b = new StringBuilder();

File: src/main/java/net/sf/jsqlparser/statement/create/table/CreateTable.java
Patch:
@@ -141,7 +141,7 @@ public void setRowMovement(RowMovement rowMovement) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public String toString() {
         String sql;
         String createOps = PlainSelect.getStringList(createOptionsStrings, false, false);

File: src/main/java/net/sf/jsqlparser/statement/insert/Insert.java
Patch:
@@ -207,7 +207,7 @@ public void setWithItemsList(List<WithItem> withItemsList) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public String toString() {
         StringBuilder sql = new StringBuilder();
         if (withItemsList != null && !withItemsList.isEmpty()) {

File: src/main/java/net/sf/jsqlparser/statement/select/FromItemVisitorAdapter.java
Patch:
@@ -11,6 +11,7 @@
 
 import net.sf.jsqlparser.schema.Table;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class FromItemVisitorAdapter implements FromItemVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/GroupByElement.java
Patch:
@@ -55,6 +55,7 @@ public void addGroupingSet(ExpressionList list) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         StringBuilder b = new StringBuilder();
         b.append("GROUP BY ");

File: src/main/java/net/sf/jsqlparser/statement/select/IntoTableVisitorAdapter.java
Patch:
@@ -11,6 +11,7 @@
 
 import net.sf.jsqlparser.schema.Table;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class IntoTableVisitorAdapter implements IntoTableVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/Join.java
Patch:
@@ -263,6 +263,7 @@ public boolean isWindowJoin() {
 
     /**
      * Return the "WITHIN" join window (if any)
+     * @return 
      */
     public KSQLJoinWindow getJoinWindow() {
         return joinWindow;
@@ -278,7 +279,7 @@ public void setJoinWindow(KSQLJoinWindow joinWindow) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public String toString() {
         if (isSimple() && isOuter()) {
             return "OUTER " + rightItem;

File: src/main/java/net/sf/jsqlparser/statement/select/OrderByVisitorAdapter.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class OrderByVisitorAdapter implements OrderByVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/PivotVisitorAdapter.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class PivotVisitorAdapter implements PivotVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/PlainSelect.java
Patch:
@@ -322,7 +322,7 @@ public void setKsqlWindow(KSQLWindow ksqlWindow) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity" , "PMD.ExcessiveMethodLength", "PMD.NPathComplexity"})
     public String toString() {
         StringBuilder sql = new StringBuilder();
         if (useBrackets) {

File: src/main/java/net/sf/jsqlparser/statement/select/Select.java
Patch:
@@ -42,6 +42,7 @@ public void setSelectBody(SelectBody body) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public String toString() {
         StringBuilder retval = new StringBuilder();
         if (withItemsList != null && !withItemsList.isEmpty()) {

File: src/main/java/net/sf/jsqlparser/statement/select/SelectItemVisitorAdapter.java
Patch:
@@ -9,6 +9,7 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class SelectItemVisitorAdapter implements SelectItemVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/SelectVisitorAdapter.java
Patch:
@@ -11,6 +11,7 @@
 
 import net.sf.jsqlparser.statement.values.ValuesStatement;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class SelectVisitorAdapter implements SelectVisitor {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/TableFunction.java
Patch:
@@ -12,6 +12,7 @@
 import net.sf.jsqlparser.expression.Alias;
 import net.sf.jsqlparser.expression.Function;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class TableFunction extends FunctionItem implements FromItem {
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/select/ValuesList.java
Patch:
@@ -19,6 +19,7 @@
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.expression.operators.relational.MultiExpressionList;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class ValuesList implements FromItem {
 
     private Alias alias;

File: src/main/java/net/sf/jsqlparser/statement/select/WithItem.java
Patch:
@@ -60,6 +60,7 @@ public void setWithItemList(List<SelectItem> withItemList) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         return (recursive ? "RECURSIVE " : "") + name + ((withItemList != null) ? " " + PlainSelect.
                 getStringList(withItemList, true, true) : "")

File: src/main/java/net/sf/jsqlparser/util/ConnectExpressionsVisitor.java
Patch:
@@ -21,6 +21,7 @@
  *
  * @author tw
  */
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public abstract class ConnectExpressionsVisitor implements SelectVisitor, SelectItemVisitor {
 
     private String alias = "expr";

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateTableDeParser.java
Patch:
@@ -32,7 +32,7 @@ public CreateTableDeParser(StatementDeParser statementDeParser, StringBuilder bu
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public void deParse(CreateTable createTable) {
         buffer.append("CREATE ");
         if (createTable.isUnlogged()) {

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateViewDeParser.java
Patch:
@@ -35,7 +35,7 @@ public CreateViewDeParser(StringBuilder buffer, SelectVisitor selectVisitor) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public void deParse(CreateView createView) {
         buffer.append("CREATE ");
         if (createView.isOrReplace()) {

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -478,7 +478,7 @@ public void visit(Column tableColumn) {
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public void visit(Function function) {
         if (function.isEscaped()) {
             buffer.append("{fn ");

File: src/main/java/net/sf/jsqlparser/util/deparser/GroupByDeParser.java
Patch:
@@ -31,6 +31,7 @@ public GroupByDeParser(ExpressionVisitor expressionVisitor, StringBuilder buffer
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public void deParse(GroupByElement groupBy) {
         buffer.append("GROUP BY ");
         for (Iterator<Expression> iter = groupBy.getGroupByExpressions().iterator(); iter.hasNext();) {

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -40,7 +40,7 @@ public InsertDeParser(ExpressionVisitor expressionVisitor, SelectVisitor selectV
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength", "PMD.NPathComplexity"})
     public void deParse(Insert insert) {
         if (insert.getWithItemsList() != null && !insert.getWithItemsList().isEmpty()) {
             buffer.append("WITH ");

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -74,7 +74,7 @@ public SelectDeParser(ExpressionVisitor expressionVisitor, StringBuilder buffer)
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength", "PMD.NPathComplexity"})
     public void visit(PlainSelect plainSelect) {
         if (plainSelect.isUseBrackets()) {
             buffer.append("(");

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -41,7 +41,7 @@ public UpdateDeParser(ExpressionVisitor expressionVisitor, SelectVisitor selectV
     }
 
     @Override
-    @SuppressWarnings({"PMD.CyclomaticComplexity"})
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.NPathComplexity"})
     public void deParse(Update update) {
          if (update.getWithItemsList() != null && !update.getWithItemsList().isEmpty()) {
             buffer.append("WITH ");

File: src/main/java/net/sf/jsqlparser/util/deparser/UpsertDeParser.java
Patch:
@@ -23,6 +23,7 @@
 import net.sf.jsqlparser.statement.select.WithItem;
 import net.sf.jsqlparser.statement.upsert.Upsert;
 
+@SuppressWarnings({"PMD.UncommentedEmptyMethodBody"})
 public class UpsertDeParser extends AbstractDeParser<Upsert> implements ItemsListVisitor {
 
     private ExpressionVisitor expressionVisitor;

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -12,6 +12,7 @@
 import net.sf.jsqlparser.expression.operators.arithmetic.*;
 import net.sf.jsqlparser.expression.operators.conditional.AndExpression;
 import net.sf.jsqlparser.expression.operators.conditional.OrExpression;
+import net.sf.jsqlparser.expression.operators.conditional.XorExpression;
 import net.sf.jsqlparser.expression.operators.relational.*;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.SubSelect;
@@ -62,6 +63,8 @@ public interface ExpressionVisitor {
 
     void visit(OrExpression orExpression);
 
+    void visit(XorExpression orExpression);
+
     void visit(Between between);
 
     void visit(EqualsTo equalsTo);

File: src/test/java/net/sf/jsqlparser/statement/builder/ReflectionModelTest.java
Patch:
@@ -78,6 +78,7 @@ public class ReflectionModelTest {
             new net.sf.jsqlparser.expression.operators.arithmetic.Subtraction(),
             new net.sf.jsqlparser.expression.operators.conditional.AndExpression(),
             new net.sf.jsqlparser.expression.operators.conditional.OrExpression(),
+            new net.sf.jsqlparser.expression.operators.conditional.XorExpression(),
             new net.sf.jsqlparser.expression.operators.relational.Between(),
             new net.sf.jsqlparser.expression.operators.relational.EqualsTo(),
             new net.sf.jsqlparser.expression.operators.relational.ExistsExpression(),

File: src/main/java/net/sf/jsqlparser/parser/AbstractJSqlParser.java
Patch:
@@ -25,6 +25,9 @@ public P withSquareBracketQuotation(boolean allowSquareBracketQuotation) {
         return withFeature(Feature.allowSquareBracketQuotation, allowSquareBracketQuotation);
     }
 
+    public P withAllowComplexParsing(boolean allowComplexParsing) {
+      return withFeature(Feature.allowComplexParsing, allowComplexParsing);
+    }
     public P withFeature(Feature f, boolean enabled) {
         getConfiguration().setValue(f, enabled);
         return me();

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -163,4 +163,6 @@ public interface ExpressionVisitor {
     void visit(VariableAssignment aThis);
 
     void visit(XMLSerializeExpr aThis);
+
+    void visit(TimezoneExpression aThis);
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -604,7 +604,7 @@ public void visit(TimeValue timeValue) {
 
     @Override
     public void visit(CaseExpression caseExpression) {
-        buffer.append("CASE ");
+        buffer.append(caseExpression.isUsingBrackets() ? "(" : "").append("CASE ");
         Expression switchExp = caseExpression.getSwitchExpression();
         if (switchExp != null) {
             switchExp.accept(this);
@@ -622,7 +622,7 @@ public void visit(CaseExpression caseExpression) {
             buffer.append(" ");
         }
 
-        buffer.append("END");
+        buffer.append("END").append(caseExpression.isUsingBrackets() ? ")" : "");
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/DateValue.java
Patch:
@@ -31,7 +31,7 @@ public DateValue(Date value) {
     /**
      * A Date in the form {d 'yyyy-mm-dd'}
      *
-     * @param value
+     * @param value The text presentation of the Date to be parsed.
      */
     public DateValue(String value) {
         this(Date.valueOf(value.substring(1, value.length() - 1)));

File: src/main/java/net/sf/jsqlparser/expression/Function.java
Patch:
@@ -71,7 +71,6 @@ public boolean isIgnoreNulls() {
      * This is at the moment only necessary for AnalyticExpression initialization and not for normal
      * functions. Therefore there is no deparsing for it for normal functions.
      *
-     * @param ignoreNulls
      */
     public void setIgnoreNulls(boolean ignoreNulls) {
         this.ignoreNulls = ignoreNulls;

File: src/main/java/net/sf/jsqlparser/expression/JdbcParameter.java
Patch:
@@ -12,7 +12,7 @@
 import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
- * A '?' in a statement or a ?<number> e.g. ?4
+ * A '?' in a statement or a ?&lt;number&gt; e.g. ?4
  */
 public class JdbcParameter extends ASTNodeAccessImpl implements Expression {
 

File: src/main/java/net/sf/jsqlparser/parser/feature/Feature.java
Patch:
@@ -33,6 +33,7 @@
 import net.sf.jsqlparser.statement.create.procedure.CreateProcedure;
 import net.sf.jsqlparser.statement.create.schema.CreateSchema;
 import net.sf.jsqlparser.statement.create.sequence.CreateSequence;
+import net.sf.jsqlparser.statement.create.synonym.CreateSynonym;
 import net.sf.jsqlparser.statement.create.table.CreateTable;
 import net.sf.jsqlparser.statement.create.view.AlterView;
 import net.sf.jsqlparser.statement.create.view.CreateView;

File: src/main/java/net/sf/jsqlparser/statement/create/table/CreateTable.java
Patch:
@@ -56,7 +56,7 @@ public void setUnlogged(boolean unlogged) {
     }
 
     /**
-     * A list of {@link ColumnDefinition}s of this table.
+     * @return a list of {@link ColumnDefinition}s of this table.
      */
     public List<ColumnDefinition> getColumnDefinitions() {
         return columnDefinitions;
@@ -67,7 +67,7 @@ public void setColumnDefinitions(List<ColumnDefinition> list) {
     }
 
     /**
-     * A list of options (as simple strings) of this table definition, as ("TYPE", "=", "MYISAM")
+     * @return a list of options (as simple strings) of this table definition, as ("TYPE", "=", "MYISAM")
      */
     public List<String> getTableOptionsStrings() {
         return tableOptionsStrings;
@@ -86,7 +86,7 @@ public void setCreateOptionsStrings(List<String> createOptionsStrings) {
     }
 
     /**
-     * A list of {@link Index}es (for example "PRIMARY KEY") of this table.<br>
+     * @return a list of {@link Index}es (for example "PRIMARY KEY") of this table.<br>
      * Indexes created with column definitions (as in mycol INT PRIMARY KEY) are not inserted into
      * this list.
      */

File: src/main/java/net/sf/jsqlparser/statement/create/table/Index.java
Patch:
@@ -84,9 +84,10 @@ public String getType() {
      * Please note that:
      *  Oracle - the type might be BITMAP, indicating a bitmap kind of index
      *  MySQL - the type might be FULLTEXT or SPATIAL
+     *  @param using
      */
-    public void setUsing(String string) {
-        using = string;
+    public void setUsing(String using) {
+        this.using = using;
     }
 
     public void setColumnsNames(List<String> list) {

File: src/test/java/net/sf/jsqlparser/test/TestUtils.java
Patch:
@@ -82,7 +82,7 @@ public static Statement assertSqlCanBeParsedAndDeparsed(String statement, boolea
      * @param laxDeparsingCheck removes all linefeeds from the original and
      *                          removes all double spaces. The check is
      *                          caseinsensitive.
-     * @param consumer
+     * @param consumer - a parser-consumer for parser-configurations from outside
      * @return the parsed {@link Statement}
      * @throws JSQLParserException
      */

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -166,6 +166,7 @@ public void setIgnoreNulls(boolean ignoreNulls) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         StringBuilder b = new StringBuilder();
 

File: src/main/java/net/sf/jsqlparser/expression/DateTimeLiteralExpression.java
Patch:
@@ -52,7 +52,7 @@ public DateTimeLiteralExpression withType(DateTime type) {
         return this;
     }
 
-    public static enum DateTime {
+    public enum DateTime {
         DATE, TIME, TIMESTAMP;
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapter.java
Patch:
@@ -29,6 +29,7 @@
 import net.sf.jsqlparser.statement.select.UnPivot;
 import net.sf.jsqlparser.statement.select.WithItem;
 
+@SuppressWarnings({"PMD.CyclomaticComplexity"})
 public class ExpressionVisitorAdapter implements ExpressionVisitor, ItemsListVisitor, PivotVisitor, SelectItemVisitor {
 
     private SelectVisitor selectVisitor;

File: src/main/java/net/sf/jsqlparser/expression/Function.java
Patch:
@@ -155,6 +155,7 @@ public void setKeep(KeepExpression keep) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         String params;
 

File: src/main/java/net/sf/jsqlparser/parser/feature/Feature.java
Patch:
@@ -717,7 +717,7 @@ public enum Feature {
     /**
      * a feature which can't configured within the parser
      */
-    private Feature() {
+    Feature() {
         this.value = null;
         this.configurable = false;
     }
@@ -727,7 +727,7 @@ private Feature() {
      *
      * @param value
      */
-    private Feature(Object value) {
+    Feature(Object value) {
         this.value = value;
         this.configurable = true;
     }

File: src/main/java/net/sf/jsqlparser/parser/feature/FeatureSet.java
Patch:
@@ -16,7 +16,7 @@
 
 public interface FeatureSet {
 
-    public Set<Feature> getFeatures();
+    Set<Feature> getFeatures();
 
     /**
      * @return <code>true</code> if the feature is identical to one of the features

File: src/main/java/net/sf/jsqlparser/statement/ExplainStatement.java
Patch:
@@ -110,7 +110,9 @@ public void setValue(String value) {
         }
 
         public String formatOption() {
-            return type.name() + (value != null ? (" " + value) : "");
+            return type.name() + ( value != null 
+                                                        ? " " + value 
+                                                        : "" );
         }
 
         public Option withValue(String value) {

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -87,11 +87,11 @@ public interface StatementVisitor {
 
     void visit(DescribeStatement describe);
 
-    public void visit(ExplainStatement aThis);
+    void visit(ExplainStatement aThis);
 
-    public void visit(ShowStatement aThis);
+    void visit(ShowStatement aThis);
 
-    public void visit(DeclareStatement aThis);
+    void visit(DeclareStatement aThis);
 
     void visit(Grant grant);
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/ColumnDefinition.java
Patch:
@@ -68,8 +68,9 @@ public String toString() {
     }
 
     public String toStringDataTypeAndSpec() {
-        return colDataType + ((columnSpecs != null && !columnSpecs.isEmpty())? " " + PlainSelect.
-                getStringList(columnSpecs, false, false) : "");
+        return colDataType + ( columnSpecs != null && !columnSpecs.isEmpty() 
+                                                        ? " " + PlainSelect.getStringList(columnSpecs, false, false) 
+                                                        : "" );
     }
 
     public ColumnDefinition withColumnName(String columnName) {

File: src/main/java/net/sf/jsqlparser/statement/create/table/CreateTable.java
Patch:
@@ -141,6 +141,7 @@ public void setRowMovement(RowMovement rowMovement) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         String sql;
         String createOps = PlainSelect.getStringList(createOptionsStrings, false, false);

File: src/main/java/net/sf/jsqlparser/statement/insert/Insert.java
Patch:
@@ -27,6 +27,7 @@
 import net.sf.jsqlparser.statement.select.SelectExpressionItem;
 import net.sf.jsqlparser.statement.select.WithItem;
 
+@SuppressWarnings({"PMD.CyclomaticComplexity"})
 public class Insert implements Statement {
 
     private Table table;
@@ -206,6 +207,7 @@ public void setWithItemsList(List<WithItem> withItemsList) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         StringBuilder sql = new StringBuilder();
         if (withItemsList != null && !withItemsList.isEmpty()) {

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeInsert.java
Patch:
@@ -53,7 +53,9 @@ public String toString() {
         return " WHEN NOT MATCHED THEN INSERT "
                 + (columns.isEmpty() ? "" : PlainSelect.getStringList(columns, true, true))
                 + " VALUES " + PlainSelect.getStringList(values, true, true)
-                + (whereCondition != null ? (" WHERE " + whereCondition) : "");
+                + ( whereCondition != null 
+                        ? " WHERE " + whereCondition
+                        : "" );
     }
 
     public MergeInsert withColumns(List<Column> columns) {

File: src/main/java/net/sf/jsqlparser/statement/replace/Replace.java
Patch:
@@ -104,7 +104,9 @@ public String toString() {
             // each element from expressions match up with a column from columns.
             for (int i = 0, s = columns.size(); i < s; i++) {
                 sql.append(columns.get(i)).append("=").append(expressions.get(i));
-                sql.append((i < s - 1) ? ", " : "");
+                sql.append( i < s - 1 
+                                      ? ", " 
+                                      : "" );
             }
         } else if (columns != null) {
             // the REPLACE mytab (col1, col2) [...] case

File: src/main/java/net/sf/jsqlparser/statement/select/FromItemVisitor.java
Patch:
@@ -25,5 +25,5 @@ public interface FromItemVisitor {
 
     void visit(TableFunction tableFunction);
 
-    public void visit(ParenthesisFromItem aThis);
+    void visit(ParenthesisFromItem aThis);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/Join.java
Patch:
@@ -278,6 +278,7 @@ public void setJoinWindow(KSQLJoinWindow joinWindow) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         if (isSimple() && isOuter()) {
             return "OUTER " + rightItem;

File: src/main/java/net/sf/jsqlparser/statement/select/SubSelect.java
Patch:
@@ -102,6 +102,7 @@ public void accept(ItemsListVisitor itemsListVisitor) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         StringBuilder retval = new StringBuilder();
         if (useBrackets) {

File: src/main/java/net/sf/jsqlparser/statement/update/Update.java
Patch:
@@ -172,6 +172,7 @@ public void setReturningExpressionList(List<SelectExpressionItem> returningExpre
     }
     
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         StringBuilder b = new StringBuilder("UPDATE ");
         b.append(table);

File: src/main/java/net/sf/jsqlparser/statement/upsert/Upsert.java
Patch:
@@ -113,6 +113,7 @@ public List<Expression> getDuplicateUpdateExpressionList() {
     }
     
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public String toString() {
         StringBuilder sb = new StringBuilder();
         

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -107,6 +107,7 @@
  *
  * Override extractTableName method to modify the extracted table names (e.g. without schema).
  */
+@SuppressWarnings({"PMD.CyclomaticComplexity"})
 public class TablesNamesFinder implements SelectVisitor, FromItemVisitor, ExpressionVisitor, ItemsListVisitor, SelectItemVisitor, StatementVisitor {
 
     private static final String NOT_SUPPORTED_YET = "Not supported yet.";

File: src/main/java/net/sf/jsqlparser/util/cnfexpression/CNFConverter.java
Patch:
@@ -391,6 +391,7 @@ private void handleNot(int index) {
      * tree where all the same multi operators store in the same odd level of the tree or in the
      * same even level of the tree.
      */
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     private void gather() {
         Queue<Expression> queue = new LinkedList<Expression>();
         queue.offer(temp1);
@@ -526,6 +527,7 @@ private void pushAndUp() {
      *
      * @param stack the stack stores a list of combined data.
      */
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     private void pushAnd(Stack<Mule> stack) {
         int level = 0;
         if (!stack.isEmpty()) {

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateTableDeParser.java
Patch:
@@ -32,6 +32,7 @@ public CreateTableDeParser(StatementDeParser statementDeParser, StringBuilder bu
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public void deParse(CreateTable createTable) {
         buffer.append("CREATE ");
         if (createTable.isUnlogged()) {

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateViewDeParser.java
Patch:
@@ -35,6 +35,7 @@ public CreateViewDeParser(StringBuilder buffer, SelectVisitor selectVisitor) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public void deParse(CreateView createView) {
         buffer.append("CREATE ");
         if (createView.isOrReplace()) {

File: src/main/java/net/sf/jsqlparser/util/deparser/DeclareStatementDeParser.java
Patch:
@@ -23,6 +23,7 @@ public DeclareStatementDeParser(ExpressionVisitor expressionVisitor, StringBuild
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public void deParse(DeclareStatement declare) {
         buffer.append("DECLARE ");
 

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -101,6 +101,7 @@
 import net.sf.jsqlparser.statement.select.SubSelect;
 import net.sf.jsqlparser.statement.select.WithItem;
 
+@SuppressWarnings({"PMD.CyclomaticComplexity"})
 public class ExpressionDeParser extends AbstractDeParser<Expression>
         // FIXME maybe we should implement an ItemsListDeparser too?
         implements ExpressionVisitor, ItemsListVisitor {
@@ -469,6 +470,7 @@ public void visit(Column tableColumn) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public void visit(Function function) {
         if (function.isEscaped()) {
             buffer.append("{fn ");
@@ -686,6 +688,7 @@ public void visit(Modulo modulo) {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public void visit(AnalyticExpression aexpr) {
         String name = aexpr.getName();
         Expression expression = aexpr.getExpression();

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -40,6 +40,7 @@ public InsertDeParser(ExpressionVisitor expressionVisitor, SelectVisitor selectV
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength"})
     public void deParse(Insert insert) {
         if (insert.getWithItemsList() != null && !insert.getWithItemsList().isEmpty()) {
             buffer.append("WITH ");

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -50,6 +50,7 @@
 import net.sf.jsqlparser.statement.select.WithItem;
 import net.sf.jsqlparser.statement.values.ValuesStatement;
 
+@SuppressWarnings({"PMD.CyclomaticComplexity"})
 public class SelectDeParser extends AbstractDeParser<PlainSelect>
         implements SelectVisitor, SelectItemVisitor, FromItemVisitor, PivotVisitor {
 
@@ -69,6 +70,7 @@ public SelectDeParser(ExpressionVisitor expressionVisitor, StringBuilder buffer)
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.ExcessiveMethodLength"})
     public void visit(PlainSelect plainSelect) {
         if (plainSelect.isUseBrackets()) {
             buffer.append("(");
@@ -377,6 +379,7 @@ public void visit(SubJoin subjoin) {
         }
     }
 
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public void deparseJoin(Join join) {
         if (join.isSimple() && join.isOuter()) {
             buffer.append(", OUTER ");

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -40,6 +40,7 @@ public UpdateDeParser(ExpressionVisitor expressionVisitor, SelectVisitor selectV
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public void deParse(Update update) {
         buffer.append("UPDATE ").append(update.getTable());
         if (update.getStartJoins() != null) {

File: src/main/java/net/sf/jsqlparser/util/validation/feature/FeatureSetValidation.java
Patch:
@@ -19,7 +19,7 @@
 
 public interface FeatureSetValidation extends ValidationCapability, FeatureSet {
 
-    public static final String DEFAULT_NAME = "feature set";
+    String DEFAULT_NAME = "feature set";
 
     @Override
     default void validate(ValidationContext context, Consumer<ValidationException> errorConsumer) {
@@ -33,12 +33,12 @@ default void validate(ValidationContext context, Consumer<ValidationException> e
      * @return all supported {@link Feature}'s
      */
     @Override
-    public Set<Feature> getFeatures();
+    Set<Feature> getFeatures();
 
     /**
      * @return the default message if not contained in the feature set
      */
-    public ValidationException getMessage(Feature feature);
+    ValidationException getMessage(Feature feature);
 
     @Override
     default String getName() {

File: src/main/java/net/sf/jsqlparser/util/validation/feature/H2Version.java
Patch:
@@ -146,7 +146,7 @@ public enum H2Version implements Version {
      * @param featuresSupported
      * @see #copy() to copy from previous version
      */
-    private H2Version(String versionString, Set<Feature> featuresSupported) {
+    H2Version(String versionString, Set<Feature> featuresSupported) {
         this(versionString, featuresSupported, Collections.emptySet());
     }
 
@@ -156,7 +156,7 @@ private H2Version(String versionString, Set<Feature> featuresSupported) {
      * @param unsupported
      * @see #copy() to copy from previous version
      */
-    private H2Version(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
+    H2Version(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
         this.versionString = versionString;
         this.features = featuresSupported;
         this.features.removeAll(unsupported);

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MariaDbVersion.java
Patch:
@@ -150,7 +150,7 @@ public enum MariaDbVersion implements Version {
      * @param featuresSupported
      * @see #copy() to copy from previous version
      */
-    private MariaDbVersion(String versionString, Set<Feature> featuresSupported) {
+    MariaDbVersion(String versionString, Set<Feature> featuresSupported) {
         this(versionString, featuresSupported, Collections.emptySet());
     }
 
@@ -160,7 +160,7 @@ private MariaDbVersion(String versionString, Set<Feature> featuresSupported) {
      * @param unsupported
      * @see #copy() to copy from previous version
      */
-    private MariaDbVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
+    MariaDbVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
         this.versionString = versionString;
         this.features = featuresSupported;
         this.features.removeAll(unsupported);

File: src/main/java/net/sf/jsqlparser/util/validation/feature/MySqlVersion.java
Patch:
@@ -132,7 +132,7 @@ public enum MySqlVersion implements Version {
      * @param featuresSupported
      * @see #copy() to copy from previous version
      */
-    private MySqlVersion(String versionString, Set<Feature> featuresSupported) {
+    MySqlVersion(String versionString, Set<Feature> featuresSupported) {
         this(versionString, featuresSupported, Collections.emptySet());
     }
 
@@ -142,7 +142,7 @@ private MySqlVersion(String versionString, Set<Feature> featuresSupported) {
      * @param unsupported
      * @see #copy() to copy from previous version
      */
-    private MySqlVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
+    MySqlVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
         this.versionString = versionString;
         this.features = featuresSupported;
         this.features.removeAll(unsupported);

File: src/main/java/net/sf/jsqlparser/util/validation/feature/OracleVersion.java
Patch:
@@ -168,7 +168,7 @@ public enum OracleVersion implements Version {
      * @param featuresSupported
      * @see #copy() to copy from previous version
      */
-    private OracleVersion(String versionString, Set<Feature> featuresSupported) {
+    OracleVersion(String versionString, Set<Feature> featuresSupported) {
         this(versionString, featuresSupported, Collections.emptySet());
     }
 
@@ -178,7 +178,7 @@ private OracleVersion(String versionString, Set<Feature> featuresSupported) {
      * @param unsupported
      * @see #copy() to copy from previous version
      */
-    private OracleVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
+    OracleVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
         this.versionString = versionString;
         this.features = featuresSupported;
         this.features.removeAll(unsupported);

File: src/main/java/net/sf/jsqlparser/util/validation/feature/PostgresqlVersion.java
Patch:
@@ -157,7 +157,7 @@ public enum PostgresqlVersion implements Version {
      * @param featuresSupported
      * @see #copy() to copy from previous version
      */
-    private PostgresqlVersion(String versionString, Set<Feature> featuresSupported) {
+    PostgresqlVersion(String versionString, Set<Feature> featuresSupported) {
         this(versionString, featuresSupported, Collections.emptySet());
     }
 
@@ -167,7 +167,7 @@ private PostgresqlVersion(String versionString, Set<Feature> featuresSupported)
      * @param unsupported
      * @see #copy() to copy from previous version
      */
-    private PostgresqlVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
+    PostgresqlVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
         this.versionString = versionString;
         this.features = featuresSupported;
         this.features.removeAll(unsupported);

File: src/main/java/net/sf/jsqlparser/util/validation/feature/SQLVersion.java
Patch:
@@ -56,7 +56,7 @@ public enum SQLVersion implements Version {
      * @param featuresSupported
      * @see #copy() to copy from previous version
      */
-    private SQLVersion(String versionString, Set<Feature> featuresSupported) {
+    SQLVersion(String versionString, Set<Feature> featuresSupported) {
         this(versionString, featuresSupported, Collections.emptySet());
     }
 
@@ -66,7 +66,7 @@ private SQLVersion(String versionString, Set<Feature> featuresSupported) {
      * @param unsupported
      * @see #copy() to copy from previous version
      */
-    private SQLVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
+    SQLVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
         this.versionString = versionString;
         this.features = featuresSupported;
         this.features.removeAll(unsupported);

File: src/main/java/net/sf/jsqlparser/util/validation/feature/SqlServerVersion.java
Patch:
@@ -144,7 +144,7 @@ public enum SqlServerVersion implements Version {
      * @param featuresSupported
      * @see #copy() to copy from previous version
      */
-    private SqlServerVersion(String versionString, Set<Feature> featuresSupported) {
+    SqlServerVersion(String versionString, Set<Feature> featuresSupported) {
         this(versionString, featuresSupported, Collections.emptySet());
     }
 
@@ -154,7 +154,7 @@ private SqlServerVersion(String versionString, Set<Feature> featuresSupported) {
      * @param unsupported
      * @see #copy() to copy from previous version
      */
-    private SqlServerVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
+    SqlServerVersion(String versionString, Set<Feature> featuresSupported, Set<Feature> unsupported) {
         this.versionString = versionString;
         this.features = featuresSupported;
         this.features.removeAll(unsupported);

File: src/main/java/net/sf/jsqlparser/util/validation/feature/Version.java
Patch:
@@ -17,7 +17,7 @@ public interface Version extends FeatureSetValidation {
     /**
      * @return the version string
      */
-    public String getVersionString();
+    String getVersionString();
 
     /**
      * @return <code>featureName + " not supported."</code>

File: src/main/java/net/sf/jsqlparser/util/validation/metadata/AbstractDatabaseMetaDataCapability.java
Patch:
@@ -73,6 +73,7 @@ public AbstractDatabaseMetaDataCapability clearCache() {
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     public final boolean exists(Named named) {
         Objects.requireNonNull(named);
 

File: src/main/java/net/sf/jsqlparser/util/validation/metadata/DatabaseMetaDataValidation.java
Patch:
@@ -18,7 +18,7 @@
 
 public interface DatabaseMetaDataValidation extends ValidationCapability {
 
-    public static final String NAME = "meta data";
+    String NAME = "meta data";
 
     /**
      * @param context
@@ -37,7 +37,7 @@ default void validate(ValidationContext context, Consumer<ValidationException> e
         } catch (ValidationException ve) {
             errorConsumer.accept(ve);
         } catch (UnsupportedOperationException uoe) {
-            // should we log this on a trace level?
+            errorConsumer.accept(new ValidationException("This Operation " + named.toString() + "  is not supported yet.", uoe));
         } catch (Exception e) {
             errorConsumer.accept(getUnexpectedErrorMessage(named, e));
         }
@@ -55,7 +55,7 @@ default void validate(ValidationContext context, Consumer<ValidationException> e
      * @throws UnsupportedOperationException - if testing of given
      *                                       {@link NamedObject} is not supported.
      */
-    public boolean exists(Named named);
+    boolean exists(Named named);
 
     /**
      * @param named

File: src/main/java/net/sf/jsqlparser/util/validation/metadata/JdbcDatabaseMetaDataCapability.java
Patch:
@@ -60,6 +60,7 @@ public JdbcDatabaseMetaDataCapability(Connection connection, UnaryOperator<Strin
     }
 
     @Override
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     protected boolean columnExists(Map<Named, Boolean> results, Named named) throws ValidationException {
         String[] names = splitAndValidateMinMax(COLUMN, named.getFqnLookup(), 1, 4);
         String columnName = names[names.length - 1];
@@ -121,6 +122,7 @@ protected boolean tableExists(Map<Named, Boolean> results, Named named) throws V
         return jdbcMetadataTables(named, TABLE);
     }
 
+    @SuppressWarnings({"PMD.CyclomaticComplexity"})
     protected boolean jdbcMetadataTables(Named named, String type) throws ValidationException {
         String[] names = splitAndValidateMinMax(type, named.getFqnLookup(), 1, 3);
 

File: src/main/java/net/sf/jsqlparser/util/validation/metadata/NamesLookup.java
Patch:
@@ -21,7 +21,7 @@ public enum NamesLookup implements UnaryOperator<String> {
 
     private Function<String, String> strategy;
 
-    private NamesLookup(UnaryOperator<String> strategy) {
+    NamesLookup(UnaryOperator<String> strategy) {
         this.strategy = strategy;
     }
 

File: src/main/java/net/sf/jsqlparser/util/validation/validator/ExpressionValidator.java
Patch:
@@ -98,6 +98,7 @@
 /**
  * @author gitmotte
  */
+@SuppressWarnings({"PMD.CyclomaticComplexity"})
 public class ExpressionValidator extends AbstractValidator<Expression> implements ExpressionVisitor {
 
 

File: src/test/java/net/sf/jsqlparser/util/deparser/ExecuteDeParserTest.java
Patch:
@@ -22,7 +22,7 @@
 import net.sf.jsqlparser.expression.JdbcParameter;
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.statement.execute.Execute;
-import net.sf.jsqlparser.statement.execute.Execute.EXEC_TYPE;
+import net.sf.jsqlparser.statement.execute.Execute.ExecType;
 
 public class ExecuteDeParserTest {
 
@@ -49,7 +49,7 @@ public void shouldDeParseExecute() {
         expressions.add(new JdbcParameter());
 
         execute.withName(name)
-        .withExecType(EXEC_TYPE.EXECUTE).withParenthesis(true)
+        .withExecType(ExecType.EXECUTE).withParenthesis(true)
         .withExprList(new ExpressionList().withExpressions(expressions));
 
         executeDeParser.deParse(execute);

File: src/test/java/net/sf/jsqlparser/statement/select/KSQLTest.java
Patch:
@@ -58,7 +58,7 @@ public void testKSQLBeforeAfterWindowedJoin() throws Exception {
         sql = "SELECT *\n"
                 + "FROM table1 t1\n"
                 + "INNER JOIN table2 t2\n"
-                + "WITHIN (2 MINUTES, 5 MINUTES)\n"
+                + "WITHIN (1 MINUTE, 5 MINUTES)\n"
                 + "ON t1.id = t2.id\n";
 
         statement = CCJSqlParserUtil.parse(sql);
@@ -71,8 +71,8 @@ public void testKSQLBeforeAfterWindowedJoin() throws Exception {
         assertEquals("table2", ((Table) plainSelect.getJoins().get(0).getRightItem()).
                 getFullyQualifiedName());
         assertTrue(plainSelect.getJoins().get(0).isWindowJoin());
-        assertEquals(2L, plainSelect.getJoins().get(0).getJoinWindow().getBeforeDuration());
-        assertEquals("MINUTES", plainSelect.getJoins().get(0).getJoinWindow().getBeforeTimeUnit().toString());
+        assertEquals(1L, plainSelect.getJoins().get(0).getJoinWindow().getBeforeDuration());
+        assertEquals("MINUTE", plainSelect.getJoins().get(0).getJoinWindow().getBeforeTimeUnit().toString());
         assertEquals(5L, plainSelect.getJoins().get(0).getJoinWindow().getAfterDuration());
         assertEquals("MINUTES", plainSelect.getJoins().get(0).getJoinWindow().getAfterTimeUnit().toString());
         assertTrue(plainSelect.getJoins().get(0).getJoinWindow().isBeforeAfterWindow());

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -158,6 +158,8 @@ public interface ExpressionVisitor {
 
     public void visit(ArrayExpression aThis);
 
+    public void visit(ArrayConstructor aThis);
+
     public void visit(VariableAssignment aThis);
 
     public void visit(XMLSerializeExpr aThis);

File: src/test/java/net/sf/jsqlparser/statement/create/CreateTableTest.java
Patch:
@@ -680,5 +680,5 @@ public void testCreateTableWithCommentIssue413_2() throws JSQLParserException {
     @Test
     public void testCreateTableWithParameterDefaultFalseIssue1089() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed("create table ADDRESS_TYPE ( address_type CHAR(1) not null, at_name VARCHAR(250) not null, is_disabled BOOL not null default FALSE, constraint PK_ADDRESS_TYPE primary key (address_type) )", true);
-    }
+    }   
 }

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -4330,6 +4330,7 @@ public void testIssue1068() throws JSQLParserException {
     @Test
     public void selectWithSingleIn() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed("SELECT 1 FROM dual WHERE a IN 1");
+    }
     
     @Test
     public void testKeywordSequenceIssue1075() throws JSQLParserException {
@@ -4338,5 +4339,6 @@ public void testKeywordSequenceIssue1075() throws JSQLParserException {
     
     @Test
     public void testKeywordSequenceIssue1074() throws JSQLParserException {
+        assertSqlCanBeParsedAndDeparsed("SELECT * FROM t_user WITH (NOLOCK)");
     }
 }

File: src/test/java/net/sf/jsqlparser/statement/create/CreateIndexTest.java
Patch:
@@ -16,7 +16,6 @@
 import static net.sf.jsqlparser.test.TestUtils.*;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import org.junit.Ignore;
 import org.junit.Test;
 
 public class CreateIndexTest {
@@ -107,7 +106,6 @@ public void testCreateIndex7() throws JSQLParserException {
     }
 
     @Test
-    @Ignore
     public void testCreateIndexIssue633() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed("CREATE INDEX idx_american_football_action_plays_1 ON american_football_action_plays USING btree (play_type)");
     }

File: src/main/java/net/sf/jsqlparser/expression/AnalyticType.java
Patch:
@@ -11,5 +11,6 @@
 
 public enum AnalyticType {
     OVER,
-    WITHIN_GROUP
+    WITHIN_GROUP,
+    FILTER_ONLY
 }

File: src/main/java/net/sf/jsqlparser/expression/Expression.java
Patch:
@@ -9,9 +9,11 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.Model;
 import net.sf.jsqlparser.parser.ASTNodeAccess;
 
-public interface Expression extends ASTNodeAccess {
+public interface Expression extends ASTNodeAccess, Model {
 
     void accept(ExpressionVisitor expressionVisitor);
+
 }

File: src/main/java/net/sf/jsqlparser/statement/Statement.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.statement;
 
-public interface Statement {
+import net.sf.jsqlparser.Model;
+
+public interface Statement extends Model {
 
     void accept(StatementVisitor statementVisitor);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/AllColumns.java
Patch:
@@ -13,9 +13,6 @@
 
 public class AllColumns extends ASTNodeAccessImpl implements SelectItem {
 
-    public AllColumns() {
-    }
-
     @Override
     public void accept(SelectItemVisitor selectItemVisitor) {
         selectItemVisitor.visit(this);
@@ -25,4 +22,5 @@ public void accept(SelectItemVisitor selectItemVisitor) {
     public String toString() {
         return "*";
     }
+
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SelectBody.java
Patch:
@@ -9,7 +9,9 @@
  */
 package net.sf.jsqlparser.statement.select;
 
-public interface SelectBody {
+import net.sf.jsqlparser.Model;
+
+public interface SelectBody extends Model {
 
     void accept(SelectVisitor selectVisitor);
 }

File: src/test/java/net/sf/jsqlparser/expression/operators/relational/LikeExpressionTest.java
Patch:
@@ -23,7 +23,6 @@ public class LikeExpressionTest {
     public void testLikeNotIssue660() {
         LikeExpression instance = new LikeExpression();
         assertFalse(instance.isNot());
-        instance.setNot(true);
-        assertTrue(instance.isNot());
+        assertTrue(instance.withNot(true).isNot());
     }
 }

File: src/test/java/net/sf/jsqlparser/util/SelectUtilsTest.java
Patch:
@@ -99,8 +99,8 @@ public void testBuildSelectFromTableAndParsedExpression() throws JSQLParserExcep
                 buildSelectFromTableAndExpressions(new Table("mytable"), "a+b", "test");
         assertEquals("SELECT a + b, test FROM mytable", select.toString());
 
-        assertTrue(((SelectExpressionItem) ((PlainSelect) select.getSelectBody()).getSelectItems().
-                get(0)).getExpression() instanceof Addition);
+        assertTrue(((SelectExpressionItem) select.getSelectBody(PlainSelect.class)
+                .getSelectItems().get(0)).getExpression() instanceof Addition);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitorAdapter.java
Patch:
@@ -172,8 +172,10 @@ public void visit(InExpression expr) {
         }
         if (expr.getRightExpression() != null) {
             expr.getRightExpression().accept(this);
-        } else {
+        } else if (expr.getRightItemsList() != null) {
             expr.getRightItemsList().accept(this);
+        } else {
+            expr.getMultiExpressionList().accept(this);
         }
     }
 

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -98,7 +98,7 @@ public void visit(Addition addition) {
 
     @Override
     public void visit(AndExpression andExpression) {
-        visitBinaryExpression(andExpression, " AND ");
+        visitBinaryExpression(andExpression, andExpression.isUseOperator()?" && ":" AND ");
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,5 +10,5 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM, RENAME;
+    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM, RENAME, COMMENT;
 }

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -12,6 +12,7 @@
 import net.sf.jsqlparser.statement.alter.Alter;
 import net.sf.jsqlparser.statement.comment.Comment;
 import net.sf.jsqlparser.statement.create.index.CreateIndex;
+import net.sf.jsqlparser.statement.create.schema.CreateSchema;
 import net.sf.jsqlparser.statement.create.table.CreateTable;
 import net.sf.jsqlparser.statement.create.view.AlterView;
 import net.sf.jsqlparser.statement.create.view.CreateView;
@@ -46,6 +47,8 @@ public interface StatementVisitor {
     void visit(Truncate truncate);
 
     void visit(CreateIndex createIndex);
+    
+    void visit(CreateSchema aThis);
 
     void visit(CreateTable createTable);
 

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateTableDeParser.java
Patch:
@@ -68,8 +68,8 @@ public void deParse(CreateTable createTable) {
                     buffer.append(columnDefinition.getColumnName());
                     buffer.append(" ");
                     buffer.append(columnDefinition.getColDataType().toString());
-                    if (columnDefinition.getColumnSpecStrings() != null) {
-                        for (String s : columnDefinition.getColumnSpecStrings()) {
+                    if (columnDefinition.getColumnSpecs() != null) {
+                        for (String s : columnDefinition.getColumnSpecs()) {
                             buffer.append(" ");
                             buffer.append(s);
                         }

File: src/test/java/net/sf/jsqlparser/statement/create/CreateTableTest.java
Patch:
@@ -438,8 +438,8 @@ public void testRUBiSCreateList() throws Exception {
                             }
 
                             if (!unique) {
-                                if (columnDefinition.getColumnSpecStrings() != null) {
-                                    for (Iterator iterator = columnDefinition.getColumnSpecStrings().
+                                if (columnDefinition.getColumnSpecs() != null) {
+                                    for (Iterator iterator = columnDefinition.getColumnSpecs().
                                             iterator(); iterator
                                                     .hasNext();) {
                                         String par = (String) iterator.next();

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -509,7 +509,7 @@ public void visit(ExtractExpression eexpr) {
     public void visit(LateralSubSelect lateralSubSelect) {
         lateralSubSelect.getSubSelect().getSelectBody().accept(this);
     }
-
+    
     @Override
     public void visit(MultiExpressionList multiExprList) {
         for (ExpressionList exprList : multiExprList.getExprList()) {

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -184,7 +184,6 @@ public void visit(SelectExpressionItem selectExpressionItem) {
         if (selectExpressionItem.getAlias() != null) {
             buffer.append(selectExpressionItem.getAlias().toString());
         }
-
     }
 
     @Override

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -3773,5 +3773,5 @@ public void testArrayIssue377() throws JSQLParserException {
     @Test
     public void testArrayIssue378() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed("select ta.attname, ia.attnum, ic.relname, n.nspname, tc.relname from pg_catalog.pg_attribute ta, pg_catalog.pg_attribute ia, pg_catalog.pg_class tc, pg_catalog.pg_index i, pg_catalog.pg_namespace n, pg_catalog.pg_class ic where tc.relname = 'business' and n.nspname = 'public' and tc.oid = i.indrelid and n.oid = tc.relnamespace and i.indisprimary = 't' and ia.attrelid = i.indexrelid and ta.attrelid = i.indrelid and ta.attnum = i.indkey[ia.attnum-1] and (not ta.attisdropped) and (not ia.attisdropped) and ic.oid = i.indexrelid order by ia.attnum", true);
-    }
+    } 
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -812,6 +812,8 @@ public void visit(SimilarToExpression expr) {
     @Override
     public void visit(ArrayExpression array) {
         array.getObjExpression().accept(this);
+        buffer.append("[");
         array.getIndexExpression().accept(this);
+        buffer.append("]");
     }
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateViewDeParser.java
Patch:
@@ -76,6 +76,9 @@ public void deParse(CreateView createView) {
             buffer.append(" ");
         }
         createView.getSelect().getSelectBody().accept(selectVisitor);
+        if (createView.isWithReadOnly()) {
+            buffer.append(" WITH READ ONLY");
+        }
     }
 
     public StringBuilder getBuffer() {

File: src/test/java/net/sf/jsqlparser/statement/DeclareStatementTest.java
Patch:
@@ -44,7 +44,7 @@ public void testDeclareTypeList2() throws JSQLParserException {
     
     @Test
     public void testDeclareTable() throws JSQLParserException {
-        assertSqlCanBeParsedAndDeparsed("DECLARE @MyTableVar table(EmpID int NOT NULL, OldVacationHours int, NewVacationHours int, ModifiedDate datetime)");
+        assertSqlCanBeParsedAndDeparsed("DECLARE @MyTableVar TABLE (EmpID int NOT NULL, OldVacationHours int, NewVacationHours int, ModifiedDate datetime)");
     }
     
     @Test

File: src/main/java/net/sf/jsqlparser/statement/select/Join.java
Patch:
@@ -195,7 +195,7 @@ public String toString() {
         if (isSimple() && isOuter()) {
             return "OUTER " + rightItem;
         } else if (isSimple()) {
-            return ", " + rightItem;
+            return "" + rightItem;
         } else {
             String type = "";
 

File: src/main/java/net/sf/jsqlparser/statement/select/Join.java
Patch:
@@ -195,7 +195,7 @@ public String toString() {
         if (isSimple() && isOuter()) {
             return "OUTER " + rightItem;
         } else if (isSimple()) {
-            return "" + rightItem;
+            return ", " + rightItem;
         } else {
             String type = "";
 

File: src/main/java/net/sf/jsqlparser/statement/select/SubJoin.java
Patch:
@@ -65,7 +65,7 @@ public String toString() {
         StringBuilder sb = new StringBuilder();
         sb.append("(").append(left);
         for (Join j : joinList) {
-            sb.append(" ").append(j);
+            sb.append(j.isSimple() ? "" : " ").append(j);
         }
 
         sb.append(")").append((alias != null) ? (" " + alias.toString()) : "").append((pivot != null) ? " " + pivot : "");

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/FullTextSearch.java
Patch:
@@ -69,6 +69,8 @@ public String toString() {
                 columnsListCommaSeperated += ",";
             }
         }
-        return "MATCH (" + columnsListCommaSeperated + ") AGAINST (" + this._againstValue + " " + this._searchModifier + ")";
+
+        return "MATCH (" + columnsListCommaSeperated + ") AGAINST (" + this._againstValue +
+                (this._searchModifier != null ? " " + this._searchModifier : "") + ")";
     }
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -215,7 +215,8 @@ public void visit(FullTextSearch fullTextSearch) {
                 columnsListCommaSeperated += ",";
             }
         }
-        buffer.append("MATCH (" + columnsListCommaSeperated + ") AGAINST (" + fullTextSearch.getAgainstValue() + " " + fullTextSearch.getSearchModifier() + ")");
+        buffer.append("MATCH (" + columnsListCommaSeperated + ") AGAINST (" + fullTextSearch.getAgainstValue() +
+                (fullTextSearch.getSearchModifier() != null ? " " + fullTextSearch.getSearchModifier() : "") + ")");
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/FullTextSearch.java
Patch:
@@ -69,6 +69,8 @@ public String toString() {
                 columnsListCommaSeperated += ",";
             }
         }
-        return "MATCH (" + columnsListCommaSeperated + ") AGAINST (" + this._againstValue + " " + this._searchModifier + ")";
+
+        return "MATCH (" + columnsListCommaSeperated + ") AGAINST (" + this._againstValue +
+                (this._searchModifier != null ? " " + this._searchModifier : "") + ")";
     }
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -215,7 +215,8 @@ public void visit(FullTextSearch fullTextSearch) {
                 columnsListCommaSeperated += ",";
             }
         }
-        buffer.append("MATCH (" + columnsListCommaSeperated + ") AGAINST (" + fullTextSearch.getAgainstValue() + " " + fullTextSearch.getSearchModifier() + ")");
+        buffer.append("MATCH (" + columnsListCommaSeperated + ") AGAINST (" + fullTextSearch.getAgainstValue() +
+                (fullTextSearch.getSearchModifier() != null ? " " + fullTextSearch.getSearchModifier() : "") + ")");
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -37,6 +37,7 @@
 import net.sf.jsqlparser.expression.operators.relational.NotEqualsTo;
 import net.sf.jsqlparser.expression.operators.relational.RegExpMatchOperator;
 import net.sf.jsqlparser.expression.operators.relational.RegExpMySQLOperator;
+import net.sf.jsqlparser.expression.operators.relational.SimilarToExpression;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.SubSelect;
 
@@ -172,4 +173,6 @@ public interface ExpressionVisitor {
 
     public void visit(CollateExpression aThis);
 
+    public void visit(SimilarToExpression aThis);
+
 }

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -61,7 +61,7 @@ public interface StatementVisitor {
 
     void visit(SetStatement set);
 
-    void visit(ShowStatement set);
+    void visit(ShowColumnsStatement set);
 
     void visit(Merge merge);
 
@@ -78,4 +78,6 @@ public interface StatementVisitor {
     void visit(DescribeStatement describe);
 
     public void visit(ExplainStatement aThis);
+
+    public void visit(ShowStatement aThis);
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ShowStatementDeParser.java
Patch:
@@ -28,6 +28,6 @@ public void setBuffer(StringBuilder buffer) {
     }
 
     public void deParse(ShowStatement show) {
-        buffer.append("SHOW COLUMNS FROM ").append(show.getTableName());
+        buffer.append("SHOW ").append(show.getName());
     }
 }

File: src/main/java/net/sf/jsqlparser/schema/Table.java
Patch:
@@ -94,7 +94,8 @@ public void setAlias(Alias alias) {
     }
 
     private void setIndex(int idx, String value) {
-        for (int i = 0; i < idx - partItems.size() + 1; i++) {
+        int size = partItems.size();
+        for (int i = 0; i < idx - size + 1; i++) {
             partItems.add(null);
         }
         partItems.set(idx, value);

File: src/test/java/net/sf/jsqlparser/statement/select/NestedBracketsPerformanceTest.java
Patch:
@@ -11,18 +11,17 @@
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.test.TestUtils;
-import org.junit.Ignore;
 import org.junit.Test;
 
 /**
  *
  * @author tw
  */
 public class NestedBracketsPerformanceTest {
+
     @Test
-    @Ignore
     public void testIssue766() throws JSQLParserException {
-        TestUtils.assertSqlCanBeParsedAndDeparsed("SELECT concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat('1','2'),'3'),'4'),'5'),'6'),'7'),'8'),'9'),'10'),'11'),'12'),'13'),'14'),'15'),'16'),'17'),'18'),'19'),'20'),'21'),col1 FROM tbl t1");
+        TestUtils.assertSqlCanBeParsedAndDeparsed("SELECT concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat(concat('1','2'),'3'),'4'),'5'),'6'),'7'),'8'),'9'),'10'),'11'),'12'),'13'),'14'),'15'),'16'),'17'),'18'),'19'),'20'),'21'),col1 FROM tbl t1", true);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -410,6 +410,7 @@ public void visit(Function function) {
             buffer.append("()");
         } else {
             boolean oldUseBracketsInExprList = useBracketsInExprList;
+            useBracketsInExprList = true;
             if (function.isDistinct()) {
                 useBracketsInExprList = false;
                 buffer.append("(DISTINCT ");

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -39,7 +39,7 @@ public class SpecialOracleTest {
     private static final File SQLS_DIR = new File("target/test-classes/net/sf/jsqlparser/statement/oracle-tests");
     private static final Logger LOG = Logger.getLogger(SpecialOracleTest.class.getName());
 
-    private List<String> successes = Arrays.asList("aggregate01.sql",
+    private final List<String> successes = Arrays.asList("aggregate01.sql",
             "analytic_query06.sql",
             "analytic_query08.sql",
             "analytic_query09.sql",

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -579,12 +579,12 @@ public void visit(BitwiseXor bitwiseXor) {
     public void visit(CastExpression cast) {
         if (cast.isUseCastKeyword()) {
             buffer.append("CAST(");
-            buffer.append(cast.getLeftExpression());
+            cast.getLeftExpression().accept(this);
             buffer.append(" AS ");
             buffer.append(cast.getType());
             buffer.append(")");
         } else {
-            buffer.append(cast.getLeftExpression());
+            cast.getLeftExpression().accept(this);
             buffer.append("::");
             buffer.append(cast.getType());
         }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -170,4 +170,6 @@ public interface ExpressionVisitor {
 
     public void visit(NextValExpression aThis);
 
+    public void visit(CollateExpression aThis);
+
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -431,6 +431,8 @@ public void visit(Function function) {
 
         if (function.getAttribute() != null) {
             buffer.append(".").append(function.getAttribute());
+        } else if (function.getAttributeName() != null) {
+            buffer.append(".").append(function.getAttributeName());
         }
         if (function.getKeep() != null) {
             buffer.append(" ").append(function.getKeep());

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -10,5 +10,5 @@
 package net.sf.jsqlparser.statement.alter;
 
 public enum AlterOperation {
-    ADD, ALTER, DROP, MODIFY, CHANGE;
+    ADD, ALTER, DROP, MODIFY, CHANGE, ALGORITHM;
 }

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -41,7 +41,7 @@ public class SelectTest {
 
     @Before
     public void setup() {
-        System.out.println(name.getMethodName());
+//        System.out.println(name.getMethodName());
     }
 
     // From statement multipart

File: src/main/java/net/sf/jsqlparser/statement/alter/AlterOperation.java
Patch:
@@ -26,5 +26,5 @@
  * @author toben
  */
 public enum AlterOperation {
-    ADD, DROP, MODIFY, CHANGE;
+    ADD, ALTER, DROP, MODIFY, CHANGE;
 }

File: src/test/java/net/sf/jsqlparser/statement/alter/AlterTest.java
Patch:
@@ -12,7 +12,6 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import org.junit.Ignore;
 import org.junit.Test;
 
 public class AlterTest {
@@ -313,8 +312,7 @@ public void testIssue633() throws JSQLParserException {
     }
 
     @Test
-    @Ignore
     public void testIssue679() throws JSQLParserException {
-        assertSqlCanBeParsedAndDeparsed("ALTER TABLE tb_session_status ADD INDEX idx_user_id(user_id)");
+        assertSqlCanBeParsedAndDeparsed("ALTER TABLE tb_session_status ADD INDEX idx_user_id_name (user_id, user_name(10)), ADD INDEX idx_user_name (user_name)");
     }
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/LikeExpression.java
Patch:
@@ -38,15 +38,14 @@ public class LikeExpression extends BinaryExpression {
 //    public void setNot(boolean b) {
 //        not = b;
 //    }
-
     @Override
     public void accept(ExpressionVisitor expressionVisitor) {
         expressionVisitor.visit(this);
     }
 
     @Override
     public String getStringExpression() {
-        return (isNot() ? "NOT " : "") + (caseInsensitive ? "ILIKE" : "LIKE");
+        return caseInsensitive ? "ILIKE" : "LIKE";
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/util/deparser/AlterDeParser.java
Patch:
@@ -30,7 +30,7 @@
  */
 public class AlterDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
 
     public AlterDeParser(StringBuilder buffer) {
         this.buffer = buffer;

File: src/main/java/net/sf/jsqlparser/util/deparser/AlterViewDeParser.java
Patch:
@@ -31,7 +31,7 @@
  */
 public class AlterViewDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private SelectVisitor selectVisitor;
 
     /**

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateIndexDeParser.java
Patch:
@@ -34,7 +34,7 @@
  */
 public class CreateIndexDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
 
     /**
      * @param buffer the buffer that will be filled with the create

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateTableDeParser.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class CreateTableDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private StatementDeParser statementDeParser;
 
     /**

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateViewDeParser.java
Patch:
@@ -34,7 +34,7 @@
  */
 public class CreateViewDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private final SelectVisitor selectVisitor;
 
     /**

File: src/main/java/net/sf/jsqlparser/util/deparser/DeleteDeParser.java
Patch:
@@ -33,7 +33,7 @@
  */
 public class DeleteDeParser {
 
-    private StringBuilder buffer = new StringBuilder();
+    protected StringBuilder buffer = new StringBuilder();
     private ExpressionVisitor expressionVisitor = new ExpressionVisitorAdapter();
 
     public DeleteDeParser() {

File: src/main/java/net/sf/jsqlparser/util/deparser/DropDeParser.java
Patch:
@@ -29,7 +29,7 @@
  */
 public class DropDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
 
     public DropDeParser(StringBuilder buffer) {
         this.buffer = buffer;

File: src/main/java/net/sf/jsqlparser/util/deparser/ExecuteDeParser.java
Patch:
@@ -28,7 +28,7 @@
 
 public class ExecuteDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private ExpressionVisitor expressionVisitor;
 
     /**

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -107,7 +107,7 @@
 public class ExpressionDeParser implements ExpressionVisitor, ItemsListVisitor {
 
     private static final String NOT = "NOT ";
-    private StringBuilder buffer = new StringBuilder();
+    protected StringBuilder buffer = new StringBuilder();
     private SelectVisitor selectVisitor;
     private boolean useBracketsInExprList = true;
     private OrderByDeParser orderByDeParser = new OrderByDeParser();

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -41,7 +41,7 @@
  */
 public class InsertDeParser implements ItemsListVisitor {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private ExpressionVisitor expressionVisitor;
     private SelectVisitor selectVisitor;
 

File: src/main/java/net/sf/jsqlparser/util/deparser/LimitDeparser.java
Patch:
@@ -25,7 +25,7 @@
 
 public class LimitDeparser {
 
-    private final StringBuilder buffer;
+    protected final StringBuilder buffer;
 
     public LimitDeparser(StringBuilder buffer) {
         this.buffer = buffer;

File: src/main/java/net/sf/jsqlparser/util/deparser/OrderByDeParser.java
Patch:
@@ -29,7 +29,7 @@
 
 public class OrderByDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private ExpressionVisitor expressionVisitor;
 
     OrderByDeParser() {

File: src/main/java/net/sf/jsqlparser/util/deparser/ReplaceDeParser.java
Patch:
@@ -39,7 +39,7 @@
  */
 public class ReplaceDeParser implements ItemsListVisitor {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private ExpressionVisitor expressionVisitor;
     private SelectVisitor selectVisitor;
 

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -33,7 +33,7 @@
  */
 public class SelectDeParser implements SelectVisitor, SelectItemVisitor, FromItemVisitor, PivotVisitor {
 
-    private StringBuilder buffer = new StringBuilder();
+    protected StringBuilder buffer = new StringBuilder();
     private ExpressionVisitor expressionVisitor = new ExpressionVisitorAdapter();
 
     public SelectDeParser() {

File: src/main/java/net/sf/jsqlparser/util/deparser/SetStatementDeParser.java
Patch:
@@ -26,7 +26,7 @@
 
 public class SetStatementDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private ExpressionVisitor expressionVisitor;
 
     /**

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -53,7 +53,7 @@ public class StatementDeParser implements StatementVisitor {
 
     private SelectDeParser selectDeParser;
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
 
     public StatementDeParser(StringBuilder buffer) {
         this(new ExpressionDeParser(), new SelectDeParser(), buffer);

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -43,7 +43,7 @@
  */
 public class UpdateDeParser implements OrderByVisitor {
 
-    private StringBuilder buffer = new StringBuilder();
+    protected StringBuilder buffer = new StringBuilder();
     private ExpressionVisitor expressionVisitor = new ExpressionVisitorAdapter();
     private SelectVisitor selectVisitor = new SelectVisitorAdapter();
 

File: src/main/java/net/sf/jsqlparser/util/deparser/UpsertDeParser.java
Patch:
@@ -41,7 +41,7 @@
  */
 public class UpsertDeParser implements ItemsListVisitor {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private ExpressionVisitor expressionVisitor;
     private SelectVisitor selectVisitor;
     

File: src/main/java/net/sf/jsqlparser/util/deparser/UseStatementDeParser.java
Patch:
@@ -25,7 +25,7 @@
 
 public class UseStatementDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
 
     public UseStatementDeParser(StringBuilder buffer) {
         this.buffer = buffer;

File: src/main/java/net/sf/jsqlparser/util/deparser/ValuesStatementDeParser.java
Patch:
@@ -27,7 +27,7 @@
 
 public class ValuesStatementDeParser {
 
-    private StringBuilder buffer;
+    protected StringBuilder buffer;
     private final ExpressionVisitor expressionVisitor;
 
     public ValuesStatementDeParser(ExpressionVisitor expressionVisitor, StringBuilder buffer) {

File: src/test/java/net/sf/jsqlparser/statement/values/ValuesTest.java
Patch:
@@ -5,14 +5,14 @@
 import org.junit.Test;
 
 public class ValuesTest {
-    
+
     @Test
     public void testDuplicateKey() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed("VALUES (1, 2, 'test')");
     }
-    
+
     @Test
     public void testComplexWithQueryIssue561() throws JSQLParserException {
-        assertSqlCanBeParsedAndDeparsed("WITH split(word, str, hascomma) AS (values('', 'Auto,A,1234444', 1) UNION ALL SELECT substr(str, 0, case when instr(str, ',') then instr(str, ',') else length(str)+1 end), ltrim(substr(str, instr(str, ',')), ','), instr(str, ',') FROM split WHERE hascomma) SELECT trim(word) FROM split WHERE word!=''");
+        assertSqlCanBeParsedAndDeparsed("WITH split (word, str, hascomma) AS (VALUES ('', 'Auto,A,1234444', 1) UNION ALL SELECT substr(str, 0, CASE WHEN instr(str, ',') THEN instr(str, ',') ELSE length(str) + 1 END), ltrim(substr(str, instr(str, ',')), ','), instr(str, ',') FROM split WHERE hascomma) SELECT trim(word) FROM split WHERE word != ''");
     }
 }

File: src/test/java/net/sf/jsqlparser/util/ConnectExpressionsVisitorTest.java
Patch:
@@ -9,10 +9,10 @@
 import net.sf.jsqlparser.statement.select.Select;
 import org.junit.After;
 import org.junit.AfterClass;
+import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
-import static org.junit.Assert.*;
 
 /**
  *

File: src/main/java/net/sf/jsqlparser/JSQLParserException.java
Patch:
@@ -48,7 +48,7 @@ public JSQLParserException(String arg0, Throwable arg1) {
     }
 
     @Override
-    public Throwable getCause() {
+    public synchronized Throwable getCause() {
         return cause;
     }
 

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -1780,7 +1780,7 @@ public void testAnalyticFunctionProblem1b() throws JSQLParserException {
 
     @Test
     public void testAnalyticFunctionIssue670() throws JSQLParserException {
-        assertSqlCanBeParsedAndDeparsed("SELECT last_value(some_column IGNORE NULLS) OVER ( PARTITION BY some_other_column_1, some_other_column_2 ORDER BY some_other_column_3 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) column_alias FROM some_table");
+        assertSqlCanBeParsedAndDeparsed("SELECT last_value(some_column IGNORE NULLS) OVER (PARTITION BY some_other_column_1, some_other_column_2 ORDER BY some_other_column_3 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) column_alias FROM some_table");
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/statement/merge/MergeInsert.java
Patch:
@@ -53,7 +53,8 @@ public void setValues(List<Expression> values) {
 
     @Override
     public String toString() {
-        return " WHEN NOT MATCHED THEN INSERT " + PlainSelect.getStringList(columns, true, true)
+        return " WHEN NOT MATCHED THEN INSERT "
+                + (columns.isEmpty() ? "" : PlainSelect.getStringList(columns, true, true))
                 + " VALUES " + PlainSelect.getStringList(values, true, true);
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -77,4 +77,6 @@ public interface StatementVisitor {
 
     void visit(UseStatement use);
 
+    void visit(Block block);
+
 }

File: src/test/java/net/sf/jsqlparser/expression/StringValueTest.java
Patch:
@@ -79,12 +79,12 @@ public void testGetNotExcapedValue() {
 
     @Test
     public void testPrefixes() {
-        checkStringValue("E'test'", "test", 'E');
+        checkStringValue("E'test'", "test", "E");
         checkStringValue("'test'", "test", null);
 
     }
 
-    private void checkStringValue(String original, String expectedValue, Character expectedPrefix) {
+    private void checkStringValue(String original, String expectedValue, String expectedPrefix) {
         StringValue v = new StringValue(original);
         assertEquals(expectedValue, v.getValue());
         assertEquals(expectedPrefix, v.getPrefix());

File: src/main/java/net/sf/jsqlparser/statement/truncate/Truncate.java
Patch:
@@ -56,7 +56,7 @@ public void setCascade(boolean c){
 
     @Override
     public String toString() {
-        if(cascade==true){
+        if(cascade){
             return "TRUNCATE TABLE " + table+" CASCADE";
         }
         return "TRUNCATE TABLE " + table;

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -3215,5 +3215,5 @@ public void testMultiPartNamesIssue163() throws JSQLParserException {
     @Test
     public void testMultiPartNamesIssue608() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed("SELECT @@session.tx_read_only");
-    }
+    } 
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -283,7 +283,7 @@ public void deparseOffset(Offset offset) {
         // or OFFSET offset (ROW | ROWS)
         if (offset.getOffsetJdbcParameter() != null) {
             buffer.append(" OFFSET ").append(offset.getOffsetJdbcParameter());
-        } else if (offset.getOffset() != 0) {
+        } else {
             buffer.append(" OFFSET ");
             buffer.append(offset.getOffset());
         }

File: src/test/java/net/sf/jsqlparser/statement/create/AlterViewTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.create;
+package net.sf.jsqlparser.statement.create;
 
 import net.sf.jsqlparser.JSQLParserException;
 import static net.sf.jsqlparser.test.TestUtils.*;

File: src/test/java/net/sf/jsqlparser/statement/create/CreateIndexTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.create;
+package net.sf.jsqlparser.statement.create;
 
 import java.io.StringReader;
 

File: src/test/java/net/sf/jsqlparser/statement/create/CreateTableTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.create;
+package net.sf.jsqlparser.statement.create;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;

File: src/test/java/net/sf/jsqlparser/statement/create/CreateViewTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.create;
+package net.sf.jsqlparser.statement.create;
 
 import java.io.StringReader;
 

File: src/test/java/net/sf/jsqlparser/statement/delete/DeleteTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.delete;
+package net.sf.jsqlparser.statement.delete;
 
 import static net.sf.jsqlparser.test.TestUtils.assertSqlCanBeParsedAndDeparsed;
 
@@ -8,7 +8,6 @@
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
-import net.sf.jsqlparser.statement.delete.Delete;
 import static org.junit.Assert.assertEquals;
 
 public class DeleteTest {

File: src/test/java/net/sf/jsqlparser/statement/drop/DropTest.java
Patch:
@@ -1,10 +1,9 @@
-package net.sf.jsqlparser.test.drop;
+package net.sf.jsqlparser.statement.drop;
 
 import java.io.StringReader;
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
-import net.sf.jsqlparser.statement.drop.Drop;
 import static net.sf.jsqlparser.test.TestUtils.*;
 import static org.junit.Assert.assertEquals;
 import org.junit.Test;

File: src/test/java/net/sf/jsqlparser/statement/insert/InsertTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.insert;
+package net.sf.jsqlparser.statement.insert;
 
 import java.io.StringReader;
 
@@ -11,7 +11,6 @@
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.schema.Table;
-import net.sf.jsqlparser.statement.insert.Insert;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
 import static net.sf.jsqlparser.test.TestUtils.assertSqlCanBeParsedAndDeparsed;

File: src/test/java/net/sf/jsqlparser/statement/merge/MergeTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA 02110-1301  USA
  */
-package net.sf.jsqlparser.test.merge;
+package net.sf.jsqlparser.statement.merge;
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;

File: src/test/java/net/sf/jsqlparser/statement/replace/ReplaceTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.replace;
+package net.sf.jsqlparser.statement.replace;
 
 import java.io.StringReader;
 
@@ -9,7 +9,6 @@
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
 import net.sf.jsqlparser.schema.Column;
-import net.sf.jsqlparser.statement.replace.Replace;
 import net.sf.jsqlparser.statement.select.SubSelect;
 import net.sf.jsqlparser.test.TestUtils;
 import static org.junit.Assert.assertEquals;

File: src/test/java/net/sf/jsqlparser/statement/select/HiveTest.java
Patch:
@@ -1,10 +1,8 @@
-package net.sf.jsqlparser.test.select;
+package net.sf.jsqlparser.statement.select;
 
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;
 import net.sf.jsqlparser.schema.Table;
 import net.sf.jsqlparser.statement.Statement;
-import net.sf.jsqlparser.statement.select.PlainSelect;
-import net.sf.jsqlparser.statement.select.Select;
 
 import static net.sf.jsqlparser.test.TestUtils.*;
 import static org.junit.Assert.assertEquals;

File: src/test/java/net/sf/jsqlparser/statement/select/MemoryTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.select;
+package net.sf.jsqlparser.statement.select;
 
 import java.io.StringReader;
 

File: src/test/java/net/sf/jsqlparser/statement/select/SelectTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.select;
+package net.sf.jsqlparser.statement.select;
 
 import junit.framework.*;
 import net.sf.jsqlparser.*;
@@ -8,7 +8,6 @@
 import net.sf.jsqlparser.parser.*;
 import net.sf.jsqlparser.schema.*;
 import net.sf.jsqlparser.statement.*;
-import net.sf.jsqlparser.statement.select.*;
 import org.apache.commons.io.*;
 
 import java.io.*;

File: src/test/java/net/sf/jsqlparser/statement/select/SpecialOracleTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA 02110-1301  USA
  */
-package net.sf.jsqlparser.test.select;
+package net.sf.jsqlparser.statement.select;
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.CCJSqlParserUtil;
@@ -45,7 +45,7 @@
  */
 public class SpecialOracleTest {
 
-    private static final File SQLS_DIR = new File("target/test-classes/net/sf/jsqlparser/test/oracle-tests");
+    private static final File SQLS_DIR = new File("target/test-classes/net/sf/jsqlparser/statement/oracle-tests");
     private static final Logger LOG = Logger.getLogger(SpecialOracleTest.class.getName());
 
     @Test

File: src/test/java/net/sf/jsqlparser/statement/select/SpeedTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.select;
+package net.sf.jsqlparser.statement.select;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
@@ -11,9 +11,8 @@
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
 import net.sf.jsqlparser.statement.Statement;
-import net.sf.jsqlparser.statement.select.Select;
 import net.sf.jsqlparser.test.TestException;
-import net.sf.jsqlparser.test.simpleparsing.CCJSqlParserManagerTest;
+import net.sf.jsqlparser.statement.simpleparsing.CCJSqlParserManagerTest;
 import net.sf.jsqlparser.util.TablesNamesFinder;
 import org.junit.Test;
 

File: src/test/java/net/sf/jsqlparser/statement/simpleparsing/CCJSqlParserManagerTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.simpleparsing;
+package net.sf.jsqlparser.statement.simpleparsing;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
@@ -7,7 +7,7 @@
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
 import net.sf.jsqlparser.test.TestException;
-import net.sf.jsqlparser.test.create.CreateTableTest;
+import net.sf.jsqlparser.statement.create.CreateTableTest;
 import org.junit.Test;
 
 public class CCJSqlParserManagerTest {

File: src/test/java/net/sf/jsqlparser/statement/truncate/TruncateTest.java
Patch:
@@ -1,9 +1,8 @@
-package net.sf.jsqlparser.test.truncate;
+package net.sf.jsqlparser.statement.truncate;
 
 import java.io.StringReader;
 
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
-import net.sf.jsqlparser.statement.truncate.Truncate;
 import static org.junit.Assert.assertEquals;
 import org.junit.Test;
 

File: src/test/java/net/sf/jsqlparser/statement/update/UpdateTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.update;
+package net.sf.jsqlparser.statement.update;
 
 import java.io.StringReader;
 
@@ -9,7 +9,6 @@
 import net.sf.jsqlparser.expression.operators.relational.GreaterThanEquals;
 import net.sf.jsqlparser.parser.CCJSqlParserManager;
 import net.sf.jsqlparser.schema.Column;
-import net.sf.jsqlparser.statement.update.Update;
 import static net.sf.jsqlparser.test.TestUtils.*;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;

File: src/test/java/net/sf/jsqlparser/statement/upsert/UpsertTest.java
Patch:
@@ -1,4 +1,4 @@
-package net.sf.jsqlparser.test.upsert;
+package net.sf.jsqlparser.statement.upsert;
 
 import static net.sf.jsqlparser.test.TestUtils.assertSqlCanBeParsedAndDeparsed;
 import static org.junit.Assert.*;
@@ -15,7 +15,6 @@
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.schema.Table;
 import net.sf.jsqlparser.statement.select.PlainSelect;
-import net.sf.jsqlparser.statement.upsert.Upsert;
 
 public class UpsertTest {
 

File: src/test/java/net/sf/jsqlparser/util/TablesNamesFinderTest.java
Patch:
@@ -21,7 +21,7 @@
 import net.sf.jsqlparser.statement.update.Update;
 import net.sf.jsqlparser.statement.upsert.Upsert;
 import net.sf.jsqlparser.test.TestException;
-import net.sf.jsqlparser.test.simpleparsing.CCJSqlParserManagerTest;
+import net.sf.jsqlparser.statement.simpleparsing.CCJSqlParserManagerTest;
 import static org.junit.Assert.*;
 import org.junit.Test;
 

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -604,6 +604,9 @@ public void visit(AnalyticExpression aexpr) {
         WindowElement windowElement = aexpr.getWindowElement();
 
         buffer.append(name).append("(");
+        if (aexpr.isDistinct()) {
+            buffer.append("DISTINCT ");
+        }
         if (expression != null) {
             expression.accept(this);
             if (offset != null) {

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -458,7 +458,9 @@ public void visit(AnyComparisonExpression anyComparisonExpression) {
     @Override
     public void visit(SubJoin subjoin) {
         subjoin.getLeft().accept(this);
-        subjoin.getJoin().getRightItem().accept(this);
+        for(Join join : subjoin.getJoinList()) {
+            join.getRightItem().accept(this);
+        }
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -329,7 +329,9 @@ public void setExpressionVisitor(ExpressionVisitor visitor) {
     public void visit(SubJoin subjoin) {
         buffer.append("(");
         subjoin.getLeft().accept(this);
-        deparseJoin(subjoin.getJoin());
+        for(Join join : subjoin.getJoinList()) {
+            deparseJoin(join);
+        }
         buffer.append(")");
 
         if (subjoin.getPivot() != null) {

File: src/main/java/net/sf/jsqlparser/expression/SignedExpression.java
Patch:
@@ -24,7 +24,7 @@
 import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
- * It represents a "-" or "+" before an expression
+ * It represents a "-" or "+" or "~" before an expression
  */
 public class SignedExpression extends ASTNodeAccessImpl implements Expression {
 
@@ -42,8 +42,8 @@ public char getSign() {
 
     public final void setSign(char sign) {
         this.sign = sign;
-        if (sign != '+' && sign != '-') {
-            throw new IllegalArgumentException("illegal sign character, only + - allowed");
+        if (sign != '+' && sign != '-' && sign != '~') {
+            throw new IllegalArgumentException("illegal sign character, only + - ~ allowed");
         }
     }
 

File: src/main/java/net/sf/jsqlparser/expression/AllComparisonExpression.java
Patch:
@@ -21,9 +21,10 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.SubSelect;
 
-public class AllComparisonExpression implements Expression {
+public class AllComparisonExpression extends ASTNodeAccessImpl implements Expression {
 
     private final SubSelect subSelect;
 

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -21,6 +21,7 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.OrderByElement;
 
 import java.util.List;
@@ -35,7 +36,7 @@
  *
  * @author tw
  */
-public class AnalyticExpression implements Expression {
+public class AnalyticExpression extends ASTNodeAccessImpl implements Expression {
 
     private ExpressionList partitionExpressionList;
     private List<OrderByElement> orderByElements;

File: src/main/java/net/sf/jsqlparser/expression/AnyComparisonExpression.java
Patch:
@@ -21,14 +21,15 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.SubSelect;
 
 /**
  * Combines ANY and SOME expressions.
  *
  * @author toben
  */
-public class AnyComparisonExpression implements Expression {
+public class AnyComparisonExpression extends ASTNodeAccessImpl implements Expression {
 
     private final SubSelect subSelect;
     private final AnyType anyType;

File: src/main/java/net/sf/jsqlparser/expression/BinaryExpression.java
Patch:
@@ -21,11 +21,13 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * A basic class for binary expressions, that is expressions having a left member and a right member
  * which are in turn expressions.
  */
-public abstract class BinaryExpression implements Expression {
+public abstract class BinaryExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression leftExpression;
     private Expression rightExpression;

File: src/main/java/net/sf/jsqlparser/expression/CaseExpression.java
Patch:
@@ -23,6 +23,7 @@
 
 import java.util.List;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
 /**
@@ -56,7 +57,7 @@
  *
  * @author Havard Rast Blok
  */
-public class CaseExpression implements Expression {
+public class CaseExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression switchExpression;
     private List<WhenClause> whenClauses;

File: src/main/java/net/sf/jsqlparser/expression/CastExpression.java
Patch:
@@ -21,13 +21,14 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.create.table.ColDataType;
 
 /**
  *
  * @author tw
  */
-public class CastExpression implements Expression {
+public class CastExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression leftExpression;
     private ColDataType type;

File: src/main/java/net/sf/jsqlparser/expression/DateTimeLiteralExpression.java
Patch:
@@ -39,11 +39,13 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  *
  * @author toben
  */
-public class DateTimeLiteralExpression implements Expression {
+public class DateTimeLiteralExpression extends ASTNodeAccessImpl implements Expression {
 
     private String value;
     private DateTime type;

File: src/main/java/net/sf/jsqlparser/expression/DateValue.java
Patch:
@@ -21,12 +21,14 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 import java.sql.Date;
 
 /**
  * A Date in the form {d 'yyyy-mm-dd'}
  */
-public class DateValue implements Expression {
+public class DateValue extends ASTNodeAccessImpl implements Expression {
 
     private Date value;
 

File: src/main/java/net/sf/jsqlparser/expression/DoubleValue.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * Every number with a point or a exponential format is a DoubleValue
  */
-public class DoubleValue implements Expression {
+public class DoubleValue extends ASTNodeAccessImpl implements Expression {
 
     private double value;
     private String stringValue;

File: src/main/java/net/sf/jsqlparser/expression/Expression.java
Patch:
@@ -21,7 +21,9 @@
  */
 package net.sf.jsqlparser.expression;
 
-public interface Expression {
+import net.sf.jsqlparser.parser.ASTNodeAccess;
+
+public interface Expression extends ASTNodeAccess {
 
     void accept(ExpressionVisitor expressionVisitor);
 }

File: src/main/java/net/sf/jsqlparser/expression/ExtractExpression.java
Patch:
@@ -21,13 +21,15 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * Extract value from date/time expression. The name stores the part - name to get from the
  * following date/time expression.
  *
  * @author tw
  */
-public class ExtractExpression implements Expression {
+public class ExtractExpression extends ASTNodeAccessImpl implements Expression {
 
     private String name;
     private Expression expression;

File: src/main/java/net/sf/jsqlparser/expression/HexValue.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * Every number with a point or a exponential format is a DoubleValue
  */
-public class HexValue implements Expression {
+public class HexValue extends ASTNodeAccessImpl implements Expression {
 
     private String stringValue;
 

File: src/main/java/net/sf/jsqlparser/expression/IntervalExpression.java
Patch:
@@ -21,11 +21,13 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  *
  * @author wumpz
  */
-public class IntervalExpression implements Expression {
+public class IntervalExpression extends ASTNodeAccessImpl implements Expression {
 
     private String parameter = null;
     private String intervalType = null;

File: src/main/java/net/sf/jsqlparser/expression/JdbcNamedParameter.java
Patch:
@@ -21,11 +21,13 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  *
  * @author aud
  */
-public class JdbcNamedParameter implements Expression {
+public class JdbcNamedParameter extends ASTNodeAccessImpl implements Expression {
 
     private String name;
 

File: src/main/java/net/sf/jsqlparser/expression/JdbcParameter.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * A '?' in a statement or a ?<number> e.g. ?4
  */
-public class JdbcParameter implements Expression {
+public class JdbcParameter extends ASTNodeAccessImpl implements Expression {
 
     private Integer index;
     private boolean useFixedIndex = false;

File: src/main/java/net/sf/jsqlparser/expression/JsonExpression.java
Patch:
@@ -23,13 +23,15 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.schema.Column;
 
 /**
  *
  * @author toben
  */
-public class JsonExpression implements Expression {
+public class JsonExpression extends ASTNodeAccessImpl implements Expression {
 
     private Column column;
 

File: src/main/java/net/sf/jsqlparser/expression/KeepExpression.java
Patch:
@@ -21,6 +21,7 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.OrderByElement;
 
 import java.util.List;
@@ -33,7 +34,7 @@
  *
  * @author tw
  */
-public class KeepExpression implements Expression {
+public class KeepExpression extends ASTNodeAccessImpl implements Expression {
 
     private String name;
     private List<OrderByElement> orderByElements;

File: src/main/java/net/sf/jsqlparser/expression/LongValue.java
Patch:
@@ -21,12 +21,14 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 import java.math.BigInteger;
 
 /**
  * Every number without a point or an exponential format is a LongValue.
  */
-public class LongValue implements Expression {
+public class LongValue extends ASTNodeAccessImpl implements Expression {
 
     private String stringValue;
 

File: src/main/java/net/sf/jsqlparser/expression/MySQLGroupConcat.java
Patch:
@@ -41,14 +41,15 @@
 
 import java.util.List;
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.OrderByElement;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
 /**
  *
  * @author toben
  */
-public class MySQLGroupConcat implements Expression {
+public class MySQLGroupConcat extends ASTNodeAccessImpl implements Expression {
 
     private ExpressionList expressionList;
     private boolean distinct = false;

File: src/main/java/net/sf/jsqlparser/expression/NotExpression.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * It represents a "-" or "+" before an expression
  */
-public class NotExpression implements Expression {
+public class NotExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression expression;
 

File: src/main/java/net/sf/jsqlparser/expression/NullValue.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * A "NULL" in a sql statement
  */
-public class NullValue implements Expression {
+public class NullValue extends ASTNodeAccessImpl implements Expression {
 
     @Override
     public void accept(ExpressionVisitor expressionVisitor) {

File: src/main/java/net/sf/jsqlparser/expression/NumericBind.java
Patch:
@@ -21,11 +21,13 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  *
  * @author aud
  */
-public class NumericBind implements Expression {
+public class NumericBind extends ASTNodeAccessImpl implements Expression {
 
     private int bindId;
 

File: src/main/java/net/sf/jsqlparser/expression/OracleHierarchicalExpression.java
Patch:
@@ -21,11 +21,13 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  *
  * @author toben
  */
-public class OracleHierarchicalExpression implements Expression {
+public class OracleHierarchicalExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression startExpression;
     private Expression connectExpression;

File: src/main/java/net/sf/jsqlparser/expression/OracleHint.java
Patch:
@@ -21,6 +21,8 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -29,7 +31,7 @@
  *
  * @author valdo
  */
-public class OracleHint implements Expression {
+public class OracleHint extends ASTNodeAccessImpl implements Expression {
 
     private static final Pattern SINGLE_LINE = Pattern.compile("--\\+ *([^ ].*[^ ])");
     private static final Pattern MULTI_LINE = Pattern.

File: src/main/java/net/sf/jsqlparser/expression/Parenthesis.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * It represents an expression like "(" expression ")"
  */
-public class Parenthesis implements Expression {
+public class Parenthesis extends ASTNodeAccessImpl implements Expression {
 
     private Expression expression;
     private boolean not = false;

File: src/main/java/net/sf/jsqlparser/expression/RowConstructor.java
Patch:
@@ -22,13 +22,14 @@
 package net.sf.jsqlparser.expression;
 
 import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
  * Rowconstructor.
  *
  * @author tw
  */
-public class RowConstructor implements Expression {
+public class RowConstructor extends ASTNodeAccessImpl implements Expression {
 
     private ExpressionList exprList;
     private String name = null;

File: src/main/java/net/sf/jsqlparser/expression/SignedExpression.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * It represents a "-" or "+" before an expression
  */
-public class SignedExpression implements Expression {
+public class SignedExpression extends ASTNodeAccessImpl implements Expression {
 
     private char sign;
     private Expression expression;

File: src/main/java/net/sf/jsqlparser/expression/StringValue.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * A string as in 'example_string'
  */
-public class StringValue implements Expression {
+public class StringValue extends ASTNodeAccessImpl implements Expression {
 
     private String value = "";
 

File: src/main/java/net/sf/jsqlparser/expression/TimeKeyExpression.java
Patch:
@@ -21,7 +21,9 @@
  */
 package net.sf.jsqlparser.expression;
 
-public class TimeKeyExpression implements Expression {
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
+public class TimeKeyExpression extends ASTNodeAccessImpl implements Expression {
 
     private String stringValue;
 

File: src/main/java/net/sf/jsqlparser/expression/TimeValue.java
Patch:
@@ -21,12 +21,14 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 import java.sql.Time;
 
 /**
  * A Time in the form {t 'hh:mm:ss'}
  */
-public class TimeValue implements Expression {
+public class TimeValue extends ASTNodeAccessImpl implements Expression {
 
     private Time value;
 

File: src/main/java/net/sf/jsqlparser/expression/TimestampValue.java
Patch:
@@ -21,12 +21,14 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 import java.sql.Timestamp;
 
 /**
  * A Timestamp in the form {ts 'yyyy-mm-dd hh:mm:ss.f . . .'}
  */
-public class TimestampValue implements Expression {
+public class TimestampValue extends ASTNodeAccessImpl implements Expression {
 
     private Timestamp value;
     private char quotation = '\'';

File: src/main/java/net/sf/jsqlparser/expression/UserVariable.java
Patch:
@@ -21,12 +21,14 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * Simple uservariables like @test.
  *
  * @author aud
  */
-public class UserVariable implements Expression {
+public class UserVariable extends ASTNodeAccessImpl implements Expression {
 
     private String name;
     private boolean doubleAdd = false;

File: src/main/java/net/sf/jsqlparser/expression/WhenClause.java
Patch:
@@ -21,12 +21,14 @@
  */
 package net.sf.jsqlparser.expression;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * A clause of following syntax: WHEN condition THEN expression. Which is part of a CaseExpression.
  *
  * @author Havard Rast Blok
  */
-public class WhenClause implements Expression {
+public class WhenClause extends ASTNodeAccessImpl implements Expression {
 
     private Expression whenExpression;
     private Expression thenExpression;

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/Between.java
Patch:
@@ -23,11 +23,12 @@
 
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
  * A "BETWEEN" expr1 expr2 statement
  */
-public class Between implements Expression {
+public class Between extends ASTNodeAccessImpl implements Expression {
 
     private Expression leftExpression;
     private boolean not = false;

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExistsExpression.java
Patch:
@@ -23,8 +23,9 @@
 
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
-public class ExistsExpression implements Expression {
+public class ExistsExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression rightExpression;
     private boolean not = false;

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/InExpression.java
Patch:
@@ -23,8 +23,9 @@
 
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
-public class InExpression implements Expression, SupportsOldOracleJoinSyntax {
+public class InExpression extends ASTNodeAccessImpl implements Expression, SupportsOldOracleJoinSyntax {
 
     private Expression leftExpression;
     private ItemsList leftItemsList;

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/IsNullExpression.java
Patch:
@@ -23,8 +23,9 @@
 
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
-public class IsNullExpression implements Expression {
+public class IsNullExpression extends ASTNodeAccessImpl implements Expression {
 
     private Expression leftExpression;
     private boolean not = false;

File: src/main/java/net/sf/jsqlparser/statement/select/AllColumns.java
Patch:
@@ -21,10 +21,12 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
+
 /**
  * All the columns (as in "SELECT * FROM ...")
  */
-public class AllColumns implements SelectItem {
+public class AllColumns extends ASTNodeAccessImpl implements SelectItem {
 
     public AllColumns() {
     }

File: src/main/java/net/sf/jsqlparser/statement/select/AllTableColumns.java
Patch:
@@ -24,9 +24,10 @@
 /**
  * All the columns of a table (as in "SELECT TableName.* FROM ...")
  */
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.schema.*;
 
-public class AllTableColumns implements SelectItem {
+public class AllTableColumns extends ASTNodeAccessImpl implements SelectItem {
 
     private Table table;
 

File: src/main/java/net/sf/jsqlparser/statement/select/Join.java
Patch:
@@ -24,12 +24,13 @@
 import java.util.List;
 
 import net.sf.jsqlparser.expression.Expression;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.schema.Column;
 
 /**
  * A join clause
  */
-public class Join {
+public class Join extends ASTNodeAccessImpl {
 
     private boolean outer = false;
     private boolean right = false;

File: src/main/java/net/sf/jsqlparser/statement/select/Limit.java
Patch:
@@ -22,11 +22,12 @@
 package net.sf.jsqlparser.statement.select;
 
 import net.sf.jsqlparser.expression.Expression;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
  * A limit clause in the form [LIMIT {[offset,] row_count) | (row_count | ALL) OFFSET offset}]
  */
-public class Limit {
+public class Limit extends ASTNodeAccessImpl {
 
     private Expression rowCount;
     private Expression offset;

File: src/main/java/net/sf/jsqlparser/statement/select/PlainSelect.java
Patch:
@@ -25,6 +25,7 @@
 import net.sf.jsqlparser.expression.OracleHierarchicalExpression;
 import net.sf.jsqlparser.expression.OracleHint;
 import net.sf.jsqlparser.schema.Table;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -34,7 +35,7 @@
 /**
  * The core of a "SELECT" statement (no UNION, no ORDER BY)
  */
-public class PlainSelect implements SelectBody {
+public class PlainSelect extends ASTNodeAccessImpl implements SelectBody {
 
     private Distinct distinct = null;
     private List<SelectItem> selectItems;

File: src/main/java/net/sf/jsqlparser/statement/select/SelectExpressionItem.java
Patch:
@@ -23,11 +23,12 @@
 
 import net.sf.jsqlparser.expression.Alias;
 import net.sf.jsqlparser.expression.Expression;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
  * An expression as in "SELECT expr1 AS EXPR"
  */
-public class SelectExpressionItem implements SelectItem {
+public class SelectExpressionItem extends ASTNodeAccessImpl implements SelectItem {
 
     private Expression expression;
     private Alias alias;

File: src/main/java/net/sf/jsqlparser/statement/select/SelectItem.java
Patch:
@@ -21,11 +21,13 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+import net.sf.jsqlparser.parser.ASTNodeAccess;
+
 /**
  * Anything between "SELECT" and "FROM"<BR>
  * (that is, any column or expression etc to be retrieved with the query)
  */
-public interface SelectItem {
+public interface SelectItem extends ASTNodeAccess {
 
     void accept(SelectItemVisitor selectItemVisitor);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SetOperation.java
Patch:
@@ -21,14 +21,15 @@
  */
 package net.sf.jsqlparser.statement.select;
 
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 import net.sf.jsqlparser.statement.select.SetOperationList.SetOperationType;
 
 /**
  * Single Set-Operation (name). Placeholder for one specific set operation, e.g. union, intersect.
  *
  * @author tw
  */
-public abstract class SetOperation {
+public abstract class SetOperation extends ASTNodeAccessImpl {
 
     private SetOperationType type;
 

File: src/main/java/net/sf/jsqlparser/statement/select/SubSelect.java
Patch:
@@ -28,11 +28,12 @@
 import net.sf.jsqlparser.expression.ExpressionVisitor;
 import net.sf.jsqlparser.expression.operators.relational.ItemsList;
 import net.sf.jsqlparser.expression.operators.relational.ItemsListVisitor;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
  * A subselect followed by an optional alias.
  */
-public class SubSelect implements FromItem, Expression, ItemsList {
+public class SubSelect extends ASTNodeAccessImpl implements FromItem, Expression, ItemsList {
 
     private SelectBody selectBody;
     private Alias alias;

File: src/main/java/net/sf/jsqlparser/util/cnfexpression/MultipleExpression.java
Patch:
@@ -26,13 +26,14 @@
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
 import net.sf.jsqlparser.expression.NullValue;
+import net.sf.jsqlparser.parser.ASTNodeAccessImpl;
 
 /**
  * This is a helper class that mainly used for handling the CNF conversion.
  * @author messfish
  *
  */
-public abstract class MultipleExpression implements Expression {
+public abstract class MultipleExpression extends ASTNodeAccessImpl implements Expression {
 
     private final List<Expression> childlist;
     

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserManager.java
Patch:
@@ -33,7 +33,7 @@ public class CCJSqlParserManager implements JSqlParser {
 
     @Override
     public Statement parse(Reader statementReader) throws JSQLParserException {
-        CCJSqlParser parser = new CCJSqlParser(statementReader);
+        CCJSqlParser parser = new CCJSqlParser(new StreamProvider(statementReader));
         try {
             return parser.Statement();
         } catch (Exception ex) {

File: src/test/java/net/sf/jsqlparser/util/TablesNamesFinderTest.java
Patch:
@@ -195,7 +195,7 @@ public void testGetTableListFromDelete2() throws Exception {
     
     @Test
     public void testGetTableListFromDeleteWithJoin() throws Exception {
-        String sql = "DELETE FROM MY_TABLE1 JOIN MY_TABLE2";
+        String sql = "DELETE t1, t2 FROM MY_TABLE1 t1 JOIN MY_TABLE2 t2 ON t1.id = t2.id";
         net.sf.jsqlparser.statement.Statement statement = pm.parse(new StringReader(sql));
 
         Delete deleteStatement = (Delete) statement;

File: src/test/java/net/sf/jsqlparser/util/TablesNamesFinderTest.java
Patch:
@@ -3,10 +3,8 @@
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.io.StringReader;
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-import java.util.StringTokenizer;
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.OracleHint;

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -75,4 +75,6 @@ public interface StatementVisitor {
 
     void visit(Upsert upsert);
 
+    void visit(UseStatement use);
+
 }

File: src/main/java/net/sf/jsqlparser/expression/CaseExpression.java
Patch:
@@ -59,7 +59,7 @@
 public class CaseExpression implements Expression {
 
     private Expression switchExpression;
-    private List<Expression> whenClauses;
+    private List<WhenClause> whenClauses;
     private Expression elseExpression;
 
     @Override
@@ -98,14 +98,14 @@ public void setElseExpression(Expression elseExpression) {
     /**
      * @return Returns the whenClauses.
      */
-    public List<Expression> getWhenClauses() {
+    public List<WhenClause> getWhenClauses() {
         return whenClauses;
     }
 
     /**
      * @param whenClauses The whenClauses to set.
      */
-    public void setWhenClauses(List<Expression> whenClauses) {
+    public void setWhenClauses(List<WhenClause> whenClauses) {
         this.whenClauses = whenClauses;
     }
 

File: src/main/java/net/sf/jsqlparser/util/deparser/ExecuteDeParser.java
Patch:
@@ -52,7 +52,7 @@ public void setBuffer(StringBuilder buffer) {
     }
 
     public void deParse(Execute execute) {
-        buffer.append("EXECUTE ").append(execute.getName());
+        buffer.append(execute.getExecType().name()).append(" ").append(execute.getName());
         List<Expression> expressions = execute.getExprList().getExpressions();
         for (int i = 0; i < expressions.size(); i++) {
             if (i > 0) {

File: src/main/java/net/sf/jsqlparser/schema/Table.java
Patch:
@@ -145,8 +145,8 @@ public void setHint(MySQLIndexHint hint) {
     @Override
     public String toString() {
         return getFullyQualifiedName()
-                + ((pivot != null) ? " " + pivot : "")
                 + ((alias != null) ? alias.toString() : "")
+                + ((pivot != null) ? " " + pivot : "")
                 + ((hint != null) ? hint.toString() : "");
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/select/LateralSubSelect.java
Patch:
@@ -70,7 +70,7 @@ public void setPivot(Pivot pivot) {
     @Override
     public String toString() {
         return "LATERAL" + subSelect.toString()
-                + ((pivot != null) ? " " + pivot : "")
-                + ((alias != null) ? alias.toString() : "");
+                + ((alias != null) ? alias.toString() : "")
+                + ((pivot != null) ? " " + pivot : "");
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SubJoin.java
Patch:
@@ -77,7 +77,7 @@ public void setAlias(Alias alias) {
     @Override
     public String toString() {
         return "(" + left + " " + join + ")"
-                + ((pivot != null) ? " " + pivot : "")
-                + ((alias != null) ? alias.toString() : "");
+                + ((alias != null) ? alias.toString() : "")
+                + ((pivot != null) ? " " + pivot : "");
     }
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SubSelect.java
Patch:
@@ -122,12 +122,12 @@ public String toString() {
             retval.append(")");
         }
 
-        if (pivot != null) {
-            retval.append(" ").append(pivot);
-        }
         if (alias != null) {
             retval.append(alias.toString());
         }
+        if (pivot != null) {
+            retval.append(" ").append(pivot);
+        }
 
         return retval.toString();
     }

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -38,7 +38,7 @@
 
 public interface StatementVisitor {
 
-    void visit(Select select);
+    void visit(Commit commit);
 
     void visit(Delete delete);
 
@@ -69,4 +69,6 @@ public interface StatementVisitor {
     void visit(SetStatement set);
 
     void visit(Merge merge);
+
+    void visit(Select select);
 }

File: src/test/java/net/sf/jsqlparser/test/simpleparsing/CCJSqlParserManagerTest.java
Patch:
@@ -60,8 +60,8 @@ public static String getLine(BufferedReader in) throws Exception {
         while (true) {
             line = in.readLine();
             if (line != null) {
-                if (((line.length() < 2) || (line.length() >= 2) && !(line.charAt(0) == '/' && line.
-                        charAt(1) == '/'))) {
+                if ((line.length() < 2) || (line.length() >= 2) && !(line.charAt(0) == '/' && line.
+                        charAt(1) == '/')) {
                     break;
                 }
             } else {

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -172,4 +172,6 @@ public interface ExpressionVisitor {
 
     void visit(DateTimeLiteralExpression literal);
 
+    public void visit(NotExpression aThis);
+
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -25,6 +25,7 @@
 
 import net.sf.jsqlparser.expression.Expression;
 import net.sf.jsqlparser.expression.ExpressionVisitor;
+import net.sf.jsqlparser.expression.ExpressionVisitorAdapter;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.Join;
 import net.sf.jsqlparser.statement.select.PlainSelect;
@@ -40,8 +41,8 @@
  */
 public class UpdateDeParser implements OrderByVisitor {
 
-    private StringBuilder buffer;
-    private ExpressionVisitor expressionVisitor;
+    private StringBuilder buffer = new StringBuilder();
+    private ExpressionVisitor expressionVisitor = new ExpressionVisitorAdapter();
     private SelectVisitor selectVisitor;
 
     /**

File: src/main/java/net/sf/jsqlparser/util/deparser/SelectDeParser.java
Patch:
@@ -33,8 +33,8 @@
  */
 public class SelectDeParser implements SelectVisitor, SelectItemVisitor, FromItemVisitor, PivotVisitor {
 
-    private StringBuilder buffer;
-    private ExpressionVisitor expressionVisitor;
+    private StringBuilder buffer = new StringBuilder();
+    private ExpressionVisitor expressionVisitor = new ExpressionVisitorAdapter();
 
     public SelectDeParser() {
     }

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -76,7 +76,7 @@ public void testAllSqlsParseDeparse() throws IOException {
         }
 
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success >= 135);
+        assertTrue(success >= 139);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -167,4 +167,6 @@ public interface ExpressionVisitor {
 
     void visit(TimeKeyExpression timeKeyExpression);
 
+    void visit(DateTimeLiteralExpression literal);
+
 }

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -76,7 +76,7 @@ public void testAllSqlsParseDeparse() throws IOException {
         }
 
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success >= 130);
+        assertTrue(success >= 135);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -24,6 +24,7 @@
 import net.sf.jsqlparser.statement.alter.Alter;
 import net.sf.jsqlparser.statement.create.index.CreateIndex;
 import net.sf.jsqlparser.statement.create.table.CreateTable;
+import net.sf.jsqlparser.statement.create.view.AlterView;
 import net.sf.jsqlparser.statement.create.view.CreateView;
 import net.sf.jsqlparser.statement.delete.Delete;
 import net.sf.jsqlparser.statement.drop.Drop;
@@ -56,6 +57,8 @@ public interface StatementVisitor {
 	void visit(CreateTable createTable);
 
 	void visit(CreateView createView);
+    
+    void visit(AlterView alterView);
 	
 	void visit(Alter alter);
     

File: src/main/java/net/sf/jsqlparser/statement/merge/Merge.java
Patch:
@@ -112,13 +112,13 @@ public String toString() {
         StringBuilder b = new StringBuilder();
         b.append("MERGE INTO ");
         b.append(table);
-        b.append(" USING (");
+        b.append(" USING ");
         if (usingTable != null) {
             b.append(usingTable.toString());
         } else if (usingSelect != null) {
-            b.append(usingSelect.toString());
+            b.append("(").append(usingSelect.toString()).append(")");
         }
-        b.append(")");
+        
         if (usingAlias != null) {
             b.append(usingAlias.toString());
         }

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -38,7 +38,7 @@
  */
 public class ExpressionDeParser implements ExpressionVisitor, ItemsListVisitor {
 
-    private static final String NOT = " NOT ";
+    private static final String NOT = "NOT ";
 	private StringBuilder buffer;
     private SelectVisitor selectVisitor;
     private boolean useBracketsInExprList = true;

File: src/test/java/net/sf/jsqlparser/util/AddAliasesVisitorTest.java
Patch:
@@ -80,6 +80,6 @@ public void testVisit_SetOperationList() throws JSQLParserException {
 		final AddAliasesVisitor instance = new AddAliasesVisitor();
 		setOpList.getSelectBody().accept(instance);
 
-		assertEquals("(SELECT 3 + 4 AS A1 FROM test) UNION (SELECT 7 + 8 AS A1 FROM test2)", setOpList.toString());
+		assertEquals("SELECT 3 + 4 AS A1 FROM test UNION SELECT 7 + 8 AS A1 FROM test2", setOpList.toString());
 	}
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/RegExpMatchOperator.java
Patch:
@@ -55,6 +55,8 @@ public String getStringExpression() {
 				return "!~";
 			case NOT_MATCH_CASEINSENSITIVE:
 				return "!~*";
+			default:
+				break;
 		}
 		return null;
 	}

File: src/main/java/net/sf/jsqlparser/statement/create/table/CreateTable.java
Patch:
@@ -132,7 +132,7 @@ public void setIfNotExists(boolean ifNotExists) {
 
     @Override
     public String toString() {
-        String sql = "";
+        String sql;
         String createOps = PlainSelect.getStringList(createOptionsStrings, false, false);
 
         sql = "CREATE " + (unlogged ? "UNLOGGED " : "") + 

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/RegExpMatchOperator.java
Patch:
@@ -55,6 +55,8 @@ public String getStringExpression() {
 				return "!~";
 			case NOT_MATCH_CASEINSENSITIVE:
 				return "!~*";
+			default:
+				break;
 		}
 		return null;
 	}

File: src/main/java/net/sf/jsqlparser/statement/create/table/CreateTable.java
Patch:
@@ -132,7 +132,7 @@ public void setIfNotExists(boolean ifNotExists) {
 
     @Override
     public String toString() {
-        String sql = "";
+        String sql;
         String createOps = PlainSelect.getStringList(createOptionsStrings, false, false);
 
         sql = "CREATE " + (unlogged ? "UNLOGGED " : "") + 

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ExistsExpression.java
Patch:
@@ -51,7 +51,7 @@ public void accept(ExpressionVisitor expressionVisitor) {
 	}
 
 	public String getStringExpression() {
-		return ((not) ? "NOT " : "") + "EXISTS";
+		return (not ? "NOT " : "") + "EXISTS";
 	}
 
 	@Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/InExpression.java
Patch:
@@ -97,7 +97,7 @@ private String getLeftExpressionString() {
 
 	@Override
 	public String toString() {
-		return (leftExpression == null ? leftItemsList : getLeftExpressionString()) + " " + ((not) ? "NOT " : "") + "IN " + rightItemsList + "";
+		return (leftExpression == null ? leftItemsList : getLeftExpressionString()) + " " + (not ? "NOT " : "") + "IN " + rightItemsList + "";
 	}
 
 	@Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/IsNullExpression.java
Patch:
@@ -52,6 +52,6 @@ public void accept(ExpressionVisitor expressionVisitor) {
 
 	@Override
 	public String toString() {
-		return leftExpression + " IS " + ((not) ? "NOT " : "") + "NULL";
+		return leftExpression + " IS " + (not ? "NOT " : "") + "NULL";
 	}
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/LikeExpression.java
Patch:
@@ -46,7 +46,7 @@ public void accept(ExpressionVisitor expressionVisitor) {
 
 	@Override
 	public String getStringExpression() {
-		return ((not) ? "NOT " : "") + (caseInsensitive?"ILIKE":"LIKE");
+		return (not ? "NOT " : "") + (caseInsensitive?"ILIKE":"LIKE");
 	}
 
 	@Override

File: src/main/java/net/sf/jsqlparser/statement/select/Fetch.java
Patch:
@@ -65,6 +65,6 @@ public void setFetchParamFirst(boolean b) {
 
 	@Override
 	public String toString() {
-		return " FETCH " + (isFetchParamFirst ? "FIRST" : "NEXT") + " " + (fetchJdbcParameter ? "?" : rowCount + "") + " "+ fetchParam + " ONLY";
+		return " FETCH " + (isFetchParamFirst ? "FIRST" : "NEXT") + " " + (fetchJdbcParameter ? "?" : Long.toString(rowCount)) + " " + fetchParam + " ONLY";
 	}
 }

File: src/main/java/net/sf/jsqlparser/statement/select/Limit.java
Patch:
@@ -90,10 +90,10 @@ public String toString() {
 		if (limitNull) {
             retVal += " LIMIT NULL";
         } else if (rowCount >= 0 || rowCountJdbcParameter) {
-			retVal += " LIMIT " + (rowCountJdbcParameter ? "?" : rowCount + "");
+			retVal += " LIMIT " + (rowCountJdbcParameter ? "?" : Long.toString(rowCount));
 		}
 		if (offset > 0 || offsetJdbcParameter) {
-			retVal += " OFFSET " + (offsetJdbcParameter ? "?" : offset + "");
+			retVal += " OFFSET " + (offsetJdbcParameter ? "?" : Long.toString(offset));
 		}
 		return retVal;
 	}

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -34,6 +34,9 @@
  * @author toben
  */
 public final class CCJSqlParserUtil {
+	
+	private CCJSqlParserUtil() {}
+	
 	public static Statement parse(Reader statementReader) throws JSQLParserException {
 		CCJSqlParser parser = new CCJSqlParser(statementReader);
 		try {
@@ -122,6 +125,4 @@ public static Statements parseStatements(String sqls) throws JSQLParserException
 		} 
 	}
 
-	private CCJSqlParserUtil() {
-	}
 }

File: src/main/java/net/sf/jsqlparser/expression/AnalyticExpression.java
Patch:
@@ -37,7 +37,6 @@
  */
 public class AnalyticExpression implements Expression {
 
-    //private List<Column> partitionByColumns;
     private ExpressionList partitionExpressionList;
     private List<OrderByElement> orderByElements;
     private String name;

File: src/main/java/net/sf/jsqlparser/schema/Server.java
Patch:
@@ -35,7 +35,6 @@ public Server(String serverAndInstanceName) {
         if (serverAndInstanceName != null) {
             final Matcher matcher = SERVER_PATTERN.matcher(serverAndInstanceName);
             if (!matcher.find()) {
-                //throw new IllegalArgumentException(String.format("%s is not a valid database reference", serverAndInstanceName));
                 simpleName = serverAndInstanceName;
             } else {
                 setServerName(matcher.group(1));

File: src/main/java/net/sf/jsqlparser/statement/select/PlainSelect.java
Patch:
@@ -318,7 +318,6 @@ public String toString() {
                     }
                 }
             }
-            // sql += getFormatedList(joins, "", false, false);
             if (where != null) {
                 sql.append(" WHERE ").append(where);
             }

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -30,6 +30,7 @@
 import net.sf.jsqlparser.expression.operators.relational.MultiExpressionList;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.insert.Insert;
+import net.sf.jsqlparser.statement.insert.InsertModifierPriority;
 import net.sf.jsqlparser.statement.select.SelectExpressionItem;
 import net.sf.jsqlparser.statement.select.SelectVisitor;
 import net.sf.jsqlparser.statement.select.SubSelect;
@@ -76,7 +77,7 @@ public void setBuffer(StringBuilder buffer) {
     public void deParse(Insert insert) {
         buffer.append("INSERT ");
         if(insert.getModifierPriority() != null){
-            buffer.append(insert.getModifierPriority() + " ");
+            buffer.append(insert.getModifierPriority()).append(" ");
         }
         if(insert.isModifierIgnore()){
             buffer.append("IGNORE ");

File: src/main/java/net/sf/jsqlparser/util/deparser/LimitDeparser.java
Patch:
@@ -25,7 +25,7 @@
 
 public class LimitDeparser {
 
-    private StringBuilder buffer;
+    private final StringBuilder buffer;
 
     public LimitDeparser(StringBuilder buffer) {
         this.buffer = buffer;

File: src/main/java/net/sf/jsqlparser/util/deparser/OrderByDeParser.java
Patch:
@@ -30,8 +30,8 @@
 
 public class OrderByDeParser {
 
-    private StringBuilder buffer;
-    private ExpressionVisitor expressionVisitor;
+    private final StringBuilder buffer;
+    private final ExpressionVisitor expressionVisitor;
 
     public OrderByDeParser(ExpressionVisitor expressionVisitor, StringBuilder buffer) {
         this.expressionVisitor= expressionVisitor;

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -79,7 +79,8 @@ public void visit(Delete delete) {
 
     @Override
     public void visit(Drop drop) {
-        // TODO Auto-generated method stub
+        DropDeParser dropDeParser = new DropDeParser(buffer);
+        dropDeParser.deParse(drop);
     }
 
     @Override
@@ -90,7 +91,6 @@ public void visit(Insert insert) {
         selectDeParser.setExpressionVisitor(expressionDeParser);
         InsertDeParser insertDeParser = new InsertDeParser(expressionDeParser, selectDeParser, buffer);
         insertDeParser.deParse(insert);
-
     }
 
     @Override

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -162,4 +162,7 @@ public interface ExpressionVisitor {
     void visit(MySQLGroupConcat groupConcat);
     
     void visit(RowConstructor rowConstructor);
+    
+    void visit(OracleHint hint);
+    
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -62,8 +62,10 @@ public interface ExpressionVisitor {
     void visit(JdbcNamedParameter jdbcNamedParameter);
 
 	void visit(DoubleValue doubleValue);
-
+	
 	void visit(LongValue longValue);
+	
+	void visit(HexValue hexValue);
 
 	void visit(DateValue dateValue);
 

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -158,4 +158,6 @@ public interface ExpressionVisitor {
     void visit(KeepExpression aexpr);
     
     void visit(MySQLGroupConcat groupConcat);
+    
+    void visit(RowConstructor rowConstructor);
 }

File: src/test/java/net/sf/jsqlparser/test/select/SelectTest.java
Patch:
@@ -1615,8 +1615,7 @@ public void testOracleHierarchicalQuery3() throws JSQLParserException {
 
     public void testOracleHierarchicalQuery4() throws JSQLParserException {
         String stmt = "SELECT last_name, employee_id, manager_id, LEVEL FROM employees CONNECT BY PRIOR employee_id = manager_id START WITH employee_id = 100 ORDER SIBLINGS BY last_name";
-        Statement parsed = CCJSqlParserUtil.parse(new StringReader(stmt));
-        assertStatementCanBeDeparsedAs(parsed, "SELECT last_name, employee_id, manager_id, LEVEL FROM employees START WITH employee_id = 100 CONNECT BY PRIOR employee_id = manager_id ORDER SIBLINGS BY last_name");
+        assertSqlCanBeParsedAndDeparsed(stmt);
     }
 
     public void testPostgreSQLRegExpCaseSensitiveMatch() throws JSQLParserException {

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -156,4 +156,6 @@ public interface ExpressionVisitor {
     void visit(NumericBind bind);
     
     void visit(KeepExpression aexpr);
+    
+    void visit(MySQLGroupConcat groupConcat);
 }

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -61,8 +61,8 @@ public void testAllSqlsParseDeparse() throws IOException {
                     success++;
                     LOG.info("   -> SUCCESS");
                 } catch (JSQLParserException ex) {
-                    LOG.log(Level.SEVERE, null, ex);
-                    LOG.info("   -> PROBLEM");
+                    //LOG.log(Level.SEVERE, null, ex);
+                    LOG.log(Level.INFO, "   -> PROBLEM {0}", ex.toString());
                 }
             }
         }

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -68,7 +68,7 @@ public void testAllSqlsParseDeparse() throws IOException {
         }
         
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success>=127);
+        assertTrue(success>=128);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -154,4 +154,6 @@ public interface ExpressionVisitor {
     void visit(UserVariable var);
     
     void visit(NumericBind bind);
+    
+    void visit(KeepExpression aexpr);
 }

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -61,14 +61,14 @@ public void testAllSqlsParseDeparse() throws IOException {
                     success++;
                     LOG.info("   -> SUCCESS");
                 } catch (JSQLParserException ex) {
-                    //LOG.log(Level.SEVERE, null, ex);
+                    LOG.log(Level.SEVERE, null, ex);
                     LOG.info("   -> PROBLEM");
                 }
             }
         }
         
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success>=122);
+        assertTrue(success>=127);
     }
 
     @Test

File: src/test/java/net/sf/jsqlparser/test/select/SelectTest.java
Patch:
@@ -1725,4 +1725,7 @@ public void testSelectKeywordPercent() throws JSQLParserException {
         assertSqlCanBeParsedAndDeparsed("SELECT percent FROM MY_TABLE");
     }
     
+    public void testSelectJPQLPositionalParameter() throws JSQLParserException {
+        assertSqlCanBeParsedAndDeparsed("SELECT email FROM users WHERE (type LIKE 'B') AND (username LIKE ?1)");
+    }
 }

File: src/test/java/net/sf/jsqlparser/test/create/CreateViewTest.java
Patch:
@@ -51,7 +51,7 @@ public void testCreateViewWithColumnNames1() throws JSQLParserException {
 	
 	public void testCreateView5() throws JSQLParserException {
 		String statement = "CREATE VIEW myview AS (SELECT * FROM mytab)";
-		String statement2 = "CREATE VIEW myview AS SELECT * FROM mytab";
+		String statement2 = "CREATE VIEW myview AS (SELECT * FROM mytab)";
 		CreateView createView = (CreateView) parserManager.parse(new StringReader(statement));
 		assertFalse(createView.isOrReplace());
 		assertEquals("myview", createView.getView().getName());

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -68,7 +68,7 @@ public void testAllSqlsParseDeparse() throws IOException {
         }
         
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success>=121);
+        assertTrue(success>=122);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/statement/StatementVisitor.java
Patch:
@@ -61,4 +61,6 @@ public interface StatementVisitor {
     void visit(Statements stmts);
     
     void visit(Execute execute);
+    
+    void visit(SetStatement set);
 }

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -182,7 +182,7 @@ public void visit(JdbcParameter jdbcParameter) {
 
     @Override
     public void visit(LikeExpression likeExpression) {
-        visitBinaryExpression(likeExpression, " LIKE ");
+        visitBinaryExpression(likeExpression, likeExpression.isCaseInsensitive()?" ILIKE ":" LIKE ");
         String escape = likeExpression.getEscape();
         if (escape != null) {
             buffer.append(" ESCAPE '").append(escape).append('\'');

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -68,7 +68,7 @@ public void testAllSqlsParseDeparse() throws IOException {
         }
         
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success>=112);
+        assertTrue(success>=113);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/statement/create/table/Index.java
Patch:
@@ -66,6 +66,6 @@ public void setType(String string) {
 
 	@Override
 	public String toString() {
-		return type + " " + PlainSelect.getStringList(columnsNames, true, true) + (name != null ? " " + name : "");
+		return type + (name != null ? " " + name : "") + " " + PlainSelect.getStringList(columnsNames, true, true);
 	}
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -152,4 +152,6 @@ public interface ExpressionVisitor {
 	void visit(RegExpMySQLOperator regExpMySQLOperator);
     
     void visit(UserVariable var);
+    
+    void visit(NumericBind bind);
 }

File: src/main/java/net/sf/jsqlparser/expression/UserVariable.java
Patch:
@@ -2,7 +2,7 @@
  * #%L
  * JSQLParser library
  * %%
- * Copyright (C) 2004 - 2013 JSQLParser
+ * Copyright (C) 2004 - 2015 JSQLParser
  * %%
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as 

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -68,7 +68,7 @@ public void testAllSqlsParseDeparse() throws IOException {
         }
         
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success>=109);
+        assertTrue(success>=112);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -150,4 +150,6 @@ public interface ExpressionVisitor {
     void visit(JsonExpression jsonExpr);
 
 	void visit(RegExpMySQLOperator regExpMySQLOperator);
+    
+    void visit(UserVariable var);
 }

File: src/main/java/net/sf/jsqlparser/expression/ExpressionVisitor.java
Patch:
@@ -136,6 +136,8 @@ public interface ExpressionVisitor {
 	void visit(Modulo modulo);
 
 	void visit(AnalyticExpression aexpr);
+    
+    void visit(WithinGroupExpression wgexpr);
 
 	void visit(ExtractExpression eexpr);
 

File: src/test/java/net/sf/jsqlparser/test/select/SpecialOracleTest.java
Patch:
@@ -68,7 +68,7 @@ public void testAllSqlsParseDeparse() throws IOException {
         }
         
         LOG.log(Level.INFO, "tested {0} files. got {1} correct parse results", new Object[]{count, success});
-        assertTrue(success>=106);
+        assertTrue(success>=109);
     }
 
     @Test

File: src/main/java/net/sf/jsqlparser/util/deparser/UpdateDeParser.java
Patch:
@@ -25,6 +25,7 @@
 import net.sf.jsqlparser.expression.ExpressionVisitor;
 import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.Join;
+import net.sf.jsqlparser.statement.select.PlainSelect;
 import net.sf.jsqlparser.statement.update.Update;
 
 /**
@@ -56,7 +57,7 @@ public void setBuffer(StringBuilder buffer) {
 	}
 
 	public void deParse(Update update) {
-		buffer.append("UPDATE ").append(update.getTable()).append(" SET ");
+		buffer.append("UPDATE ").append(PlainSelect.getStringList(update.getTables(), true, false)).append(" SET ");
 		for (int i = 0; i < update.getColumns().size(); i++) {
 			Column column = update.getColumns().get(i);
 			buffer.append(column.getFullyQualifiedName()).append(" = ");

File: src/test/java/net/sf/jsqlparser/test/select/SelectTest.java
Patch:
@@ -1025,12 +1025,12 @@ public void testAnalyticFunction16() throws JSQLParserException {
     }
 
     public void testAnalyticFunction17() throws JSQLParserException {
-        String statement = "SELECT AVG(sal) OVER (PARTITION BY deptno ORDER BY sal ROWS BETWEEN 0 PRECEDING  AND  0 PRECEDING ) AS avg_of_current_sal FROM emp";
+        String statement = "SELECT AVG(sal) OVER (PARTITION BY deptno ORDER BY sal ROWS BETWEEN 0 PRECEDING AND  0 PRECEDING) AS avg_of_current_sal FROM emp";
         assertSqlCanBeParsedAndDeparsed(statement);
     }
 
     public void testAnalyticFunction18() throws JSQLParserException {
-        String statement = "SELECT AVG(sal) OVER (PARTITION BY deptno ORDER BY sal RANGE CURRENT ROW ) AS avg_of_current_sal FROM emp";
+        String statement = "SELECT AVG(sal) OVER (PARTITION BY deptno ORDER BY sal RANGE CURRENT ROW) AS avg_of_current_sal FROM emp";
         assertSqlCanBeParsedAndDeparsed(statement);
     }
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/ColumnDefinition.java
Patch:
@@ -68,6 +68,6 @@ public void setColumnName(String string) {
 
 	@Override
 	public String toString() {
-		return columnName + " " + colDataType + " " + PlainSelect.getStringList(columnSpecStrings, false, false);
+		return columnName + " " + colDataType + (columnSpecStrings != null ? " " + PlainSelect.getStringList(columnSpecStrings, false, false) : "");
 	}
 }

File: src/main/java/net/sf/jsqlparser/expression/CastExpression.java
Patch:
@@ -31,7 +31,7 @@ public class CastExpression implements Expression {
 
 	private Expression leftExpression;
 	private ColDataType type;
-	boolean useCastKeyword;
+	private boolean useCastKeyword;
 
 	public ColDataType getType() {
 		return type;

File: src/main/java/net/sf/jsqlparser/expression/Expression.java
Patch:
@@ -23,5 +23,5 @@
 
 public interface Expression {
 
-	public void accept(ExpressionVisitor expressionVisitor);
+	void accept(ExpressionVisitor expressionVisitor);
 }

File: src/main/java/net/sf/jsqlparser/expression/LongValue.java
Patch:
@@ -34,7 +34,7 @@ public LongValue(String value) {
 			value = value.substring(1);
 		}
 		this.value = Long.parseLong(value);
-		setStringValue(value);
+        this.stringValue = value;
 	}
 
 	@Override

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ItemsList.java
Patch:
@@ -27,5 +27,5 @@
  */
 public interface ItemsList {
 
-	public void accept(ItemsListVisitor itemsListVisitor);
+	void accept(ItemsListVisitor itemsListVisitor);
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/ItemsListVisitor.java
Patch:
@@ -25,9 +25,9 @@
 
 public interface ItemsListVisitor {
 
-	public void visit(SubSelect subSelect);
+	void visit(SubSelect subSelect);
 
-	public void visit(ExpressionList expressionList);
+	void visit(ExpressionList expressionList);
 
-	public void visit(MultiExpressionList multiExprList);
+	void visit(MultiExpressionList multiExprList);
 }

File: src/main/java/net/sf/jsqlparser/expression/operators/relational/MultiExpressionList.java
Patch:
@@ -44,8 +44,6 @@
 import java.util.Iterator;
 import java.util.List;
 import net.sf.jsqlparser.expression.Expression;
-import net.sf.jsqlparser.statement.select.FromItem;
-import net.sf.jsqlparser.statement.select.FromItemVisitor;
 
 /**
  * A list of ExpressionList items. e.g. multi values of insert statements. This
@@ -55,7 +53,7 @@
  */
 public class MultiExpressionList implements ItemsList {
 
-	List<ExpressionList> exprList;
+	private List<ExpressionList> exprList;
 
 	public MultiExpressionList() {
 		this.exprList = new ArrayList<ExpressionList>();

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserManager.java
Patch:
@@ -21,9 +21,7 @@
  */
 package net.sf.jsqlparser.parser;
 
-import java.io.InputStream;
 import java.io.Reader;
-import java.io.StringReader;
 
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.statement.Statement;

File: src/main/java/net/sf/jsqlparser/parser/CCJSqlParserUtil.java
Patch:
@@ -24,16 +24,14 @@
 import java.io.InputStream;
 import java.io.Reader;
 import java.io.StringReader;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import net.sf.jsqlparser.JSQLParserException;
 import net.sf.jsqlparser.statement.Statement;
 
 /**
  * Toolfunctions to start and use JSqlParser.
  * @author toben
  */
-public class CCJSqlParserUtil {
+public final class CCJSqlParserUtil {
 	public static Statement parse(Reader statementReader) throws JSQLParserException {
 		CCJSqlParser parser = new CCJSqlParser(statementReader);
 		try {

File: src/main/java/net/sf/jsqlparser/parser/JSqlParser.java
Patch:
@@ -31,5 +31,5 @@
  */
 public interface JSqlParser {
 
-	public Statement parse(Reader statementReader) throws JSQLParserException;
+	Statement parse(Reader statementReader) throws JSQLParserException;
 }

File: src/main/java/net/sf/jsqlparser/statement/Statement.java
Patch:
@@ -26,5 +26,5 @@
  */
 public interface Statement {
 
-	public void accept(StatementVisitor statementVisitor);
+	void accept(StatementVisitor statementVisitor);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/FromItem.java
Patch:
@@ -27,9 +27,9 @@
  */
 public interface FromItem {
 
-	public void accept(FromItemVisitor fromItemVisitor);
+	void accept(FromItemVisitor fromItemVisitor);
 
-	public String getAlias();
+	String getAlias();
 
-	public void setAlias(String alias);
+	void setAlias(String alias);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/IntoTableVisitor.java
Patch:
@@ -25,5 +25,5 @@
 
 public interface IntoTableVisitor {
 
-	public void visit(Table tableName);
+	void visit(Table tableName);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/OrderByVisitor.java
Patch:
@@ -23,5 +23,5 @@
 
 public interface OrderByVisitor {
 
-	public void visit(OrderByElement orderBy);
+	void visit(OrderByElement orderBy);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SelectBody.java
Patch:
@@ -23,5 +23,5 @@
 
 public interface SelectBody {
 
-	public void accept(SelectVisitor selectVisitor);
+	void accept(SelectVisitor selectVisitor);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SelectItem.java
Patch:
@@ -27,5 +27,5 @@
  */
 public interface SelectItem {
 
-	public void accept(SelectItemVisitor selectItemVisitor);
+	void accept(SelectItemVisitor selectItemVisitor);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SelectItemVisitor.java
Patch:
@@ -23,9 +23,9 @@
 
 public interface SelectItemVisitor {
 
-	public void visit(AllColumns allColumns);
+	void visit(AllColumns allColumns);
 
-	public void visit(AllTableColumns allTableColumns);
+	void visit(AllTableColumns allTableColumns);
 
-	public void visit(SelectExpressionItem selectExpressionItem);
+	void visit(SelectExpressionItem selectExpressionItem);
 }

File: src/main/java/net/sf/jsqlparser/statement/select/SelectVisitor.java
Patch:
@@ -23,9 +23,9 @@
 
 public interface SelectVisitor {
 
-	public void visit(PlainSelect plainSelect);
+	void visit(PlainSelect plainSelect);
 
-	public void visit(SetOperationList setOpList);
+	void visit(SetOperationList setOpList);
 
-	public void visit(WithItem withItem);
+	void visit(WithItem withItem);
 }

File: src/main/java/net/sf/jsqlparser/statement/update/Update.java
Patch:
@@ -21,7 +21,6 @@
  */
 package net.sf.jsqlparser.statement.update;
 
-import java.util.Iterator;
 import java.util.List;
 
 import net.sf.jsqlparser.expression.Expression;

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -22,7 +22,6 @@
 package net.sf.jsqlparser.util;
 
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 import net.sf.jsqlparser.expression.AllComparisonExpression;
 import net.sf.jsqlparser.expression.AnalyticExpression;

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateIndexDeParser.java
Patch:
@@ -33,7 +33,8 @@
  * @author Raymond Augé
  */
 public class CreateIndexDeParser {
-	protected StringBuilder buffer;
+
+    private StringBuilder buffer;
 
 	/**
 	 * @param buffer the buffer that will be filled with the create

File: src/main/java/net/sf/jsqlparser/util/deparser/CreateViewDeParser.java
Patch:
@@ -30,7 +30,7 @@
  */
 public class CreateViewDeParser {
 
-	protected StringBuilder buffer;
+	private StringBuilder buffer;
 
 	/**
 	 * @param buffer the buffer that will be filled with the select

File: src/main/java/net/sf/jsqlparser/util/deparser/InsertDeParser.java
Patch:
@@ -39,9 +39,9 @@
  */
 public class InsertDeParser implements ItemsListVisitor {
 
-	protected StringBuilder buffer;
-	protected ExpressionVisitor expressionVisitor;
-	protected SelectVisitor selectVisitor;
+	private StringBuilder buffer;
+    private ExpressionVisitor expressionVisitor;
+    private SelectVisitor selectVisitor;
 
 	public InsertDeParser() {
 	}

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -38,7 +38,7 @@
 
 public class StatementDeParser implements StatementVisitor {
 
-	protected StringBuilder buffer;
+	private StringBuilder buffer;
 
 	public StatementDeParser(StringBuilder buffer) {
 		this.buffer = buffer;

File: src/main/java/net/sf/jsqlparser/util/TablesNamesFinder.java
Patch:
@@ -292,7 +292,7 @@ public void visit(GreaterThanEquals greaterThanEquals) {
 	@Override
 	public void visit(InExpression inExpression) {
 		inExpression.getLeftExpression().accept(this);
-		inExpression.getItemsList().accept(this);
+		inExpression.getRightItemsList().accept(this);
 	}
 
 	@Override

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -292,7 +292,7 @@ public void visit(StringValue stringValue) {
 
 	@Override
 	public void visit(Subtraction subtraction) {
-		visitBinaryExpression(subtraction, "-");
+		visitBinaryExpression(subtraction, " - ");
 
 	}
 

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -471,7 +471,7 @@ public void visit(CastExpression cast) {
 		buffer.append("CAST(");
 		buffer.append(cast.getLeftExpression());
 		buffer.append(" AS ");
-		buffer.append(cast.getTypeName());
+		buffer.append(cast.getType());
 		buffer.append(")");
 	}
 

File: src/main/java/net/sf/jsqlparser/util/deparser/ExpressionDeParser.java
Patch:
@@ -1,7 +1,6 @@
 package net.sf.jsqlparser.util.deparser;
 
 import java.util.Iterator;
-import java.util.List;
 
 import net.sf.jsqlparser.expression.AllComparisonExpression;
 import net.sf.jsqlparser.expression.AnalyticExpression;

File: src/main/java/net/sf/jsqlparser/util/deparser/ReplaceDeParser.java
Patch:
@@ -84,8 +84,8 @@ public void deParse(Replace replace) {
 
 	public void visit(ExpressionList expressionList) {
 		buffer.append(" VALUES (");
-		for (Iterator iter = expressionList.getExpressions().iterator(); iter.hasNext();) {
-			Expression expression = (Expression) iter.next();
+		for (Iterator<Expression> iter = expressionList.getExpressions().iterator(); iter.hasNext();) {
+			Expression expression = iter.next();
 			expression.accept(expressionVisitor);
 			if (iter.hasNext())
 				buffer.append(", ");

File: src/main/java/net/sf/jsqlparser/util/deparser/StatementDeParser.java
Patch:
@@ -65,8 +65,8 @@ public void visit(Select select) {
 		selectDeParser.setExpressionVisitor(expressionDeParser);
 		if (select.getWithItemsList() != null && !select.getWithItemsList().isEmpty()) {
 			buffer.append("WITH ");
-			for (Iterator iter = select.getWithItemsList().iterator(); iter.hasNext();) {
-				WithItem withItem = (WithItem) iter.next();
+			for (Iterator<WithItem> iter = select.getWithItemsList().iterator(); iter.hasNext();) {
+				WithItem withItem = iter.next();
 				buffer.append(withItem);
 				if (iter.hasNext())
 					buffer.append(",");

File: src/main/java/net/sf/jsqlparser/expression/CaseExpression.java
Patch:
@@ -60,7 +60,7 @@ public class CaseExpression implements Expression {
 
 	private Expression switchExpression;
 
-	private List whenClauses;
+	private List<Expression> whenClauses;
 
 	private Expression elseExpression;
 
@@ -106,15 +106,15 @@ public void setElseExpression(Expression elseExpression) {
 	/**
 	 * @return Returns the whenClauses.
 	 */
-	public List getWhenClauses() {
+	public List<Expression> getWhenClauses() {
 		return whenClauses;
 	}
 
 	/**
 	 * @param whenClauses
 	 *            The whenClauses to set.
 	 */
-	public void setWhenClauses(List whenClauses) {
+	public void setWhenClauses(List<Expression> whenClauses) {
 		this.whenClauses = whenClauses;
 	}
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/ColDataType.java
Patch:
@@ -7,17 +7,17 @@
 public class ColDataType {
 
 	private String dataType;
-	private List argumentsStringList;
+	private List<String> argumentsStringList;
 
-	public List getArgumentsStringList() {
+	public List<String> getArgumentsStringList() {
 		return argumentsStringList;
 	}
 
 	public String getDataType() {
 		return dataType;
 	}
 
-	public void setArgumentsStringList(List list) {
+	public void setArgumentsStringList(List<String> list) {
 		argumentsStringList = list;
 	}
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/ColumnDefinition.java
Patch:
@@ -11,17 +11,17 @@
 public class ColumnDefinition {
 	private String columnName;
 	private ColDataType colDataType;
-	private List columnSpecStrings;
+	private List<String> columnSpecStrings;
 
 	/**
 	 * A list of strings of every word after the datatype of the column.<br>
 	 * Example ("NOT", "NULL")
 	 */
-	public List getColumnSpecStrings() {
+	public List<String> getColumnSpecStrings() {
 		return columnSpecStrings;
 	}
 
-	public void setColumnSpecStrings(List list) {
+	public void setColumnSpecStrings(List<String> list) {
 		columnSpecStrings = list;
 	}
 

File: src/main/java/net/sf/jsqlparser/statement/create/table/Index.java
Patch:
@@ -10,13 +10,13 @@
 public class Index {
 
 	private String type;
-	private List columnsNames;
+	private List<String> columnsNames;
 	private String name;
 
 	/**
 	 * A list of strings of all the columns regarding this index
 	 */
-	public List getColumnsNames() {
+	public List<String> getColumnsNames() {
 		return columnsNames;
 	}
 
@@ -31,7 +31,7 @@ public String getType() {
 		return type;
 	}
 
-	public void setColumnsNames(List list) {
+	public void setColumnsNames(List<String> list) {
 		columnsNames = list;
 	}
 

File: src/main/java/net/sf/jsqlparser/statement/drop/Drop.java
Patch:
@@ -9,7 +9,7 @@
 public class Drop implements Statement {
 	private String type;
 	private String name;
-	private List parameters;
+	private List<String> parameters;
 
 	public void accept(StatementVisitor statementVisitor) {
 		statementVisitor.visit(this);
@@ -19,7 +19,7 @@ public String getName() {
 		return name;
 	}
 
-	public List getParameters() {
+	public List<String> getParameters() {
 		return parameters;
 	}
 
@@ -31,7 +31,7 @@ public void setName(String string) {
 		name = string;
 	}
 
-	public void setParameters(List list) {
+	public void setParameters(List<String> list) {
 		parameters = list;
 	}
 

File: src/main/java/net/sf/jsqlparser/statement/select/Distinct.java
Patch:
@@ -6,18 +6,18 @@
  * A DISTINCT [ON (expression, ...)] clause
  */
 public class Distinct {
-	private List onSelectItems;
+	private List<SelectItem> onSelectItems;
 
 	/**
 	 * A list of {@link SelectItem}s expressions, as in "select DISTINCT ON (a,b,c) a,b FROM..."
 	 * 
 	 * @return a list of {@link SelectItem}s expressions
 	 */
-	public List getOnSelectItems() {
+	public List<SelectItem> getOnSelectItems() {
 		return onSelectItems;
 	}
 
-	public void setOnSelectItems(List list) {
+	public void setOnSelectItems(List<SelectItem> list) {
 		onSelectItems = list;
 	}
 

File: src/main/java/net/sf/jsqlparser/statement/select/WithItem.java
Patch:
@@ -7,7 +7,7 @@
  */
 public class WithItem {
 	private String name;
-	private List withItemList;
+	private List<SelectItem> withItemList;
 	private SelectBody selectBody;
 
 	/**
@@ -41,11 +41,11 @@ public void setSelectBody(SelectBody selectBody) {
 	 * 
 	 * @return a list of {@link SelectItem}s
 	 */
-	public List getWithItemList() {
+	public List<SelectItem> getWithItemList() {
 		return withItemList;
 	}
 
-	public void setWithItemList(List withItemList) {
+	public void setWithItemList(List<SelectItem> withItemList) {
 		this.withItemList = withItemList;
 	}
 

File: src/net/sf/jsqlparser/statement/create/table/ColumnDefinition.java
Patch:
@@ -2,9 +2,6 @@
 
 import java.util.List;
 
-import sun.net.www.content.text.PlainTextInputStream;
-
-import net.sf.jsqlparser.schema.Column;
 import net.sf.jsqlparser.statement.select.PlainSelect;
 
 /**

