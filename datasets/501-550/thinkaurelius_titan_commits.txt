File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanIoRegistry.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.graphdb.tinkerpop;
 
+import com.thinkaurelius.titan.core.attribute.Geoshape;
 import com.thinkaurelius.titan.graphdb.relations.RelationIdentifier;
 import com.thinkaurelius.titan.graphdb.tinkerpop.io.graphson.TitanGraphSONModule;
 import org.apache.tinkerpop.gremlin.structure.io.AbstractIoRegistry;
@@ -8,6 +9,7 @@
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
+ * @author Stephen Mallette (http://stephen.genoprime.com)
  */
 public class TitanIoRegistry extends AbstractIoRegistry {
 
@@ -18,5 +20,6 @@ public class TitanIoRegistry extends AbstractIoRegistry {
     public TitanIoRegistry() {
         register(GraphSONIo.class, null, TitanGraphSONModule.getInstance());
         register(GryoIo.class, RelationIdentifier.class, null);
+        register(GryoIo.class, Geoshape.class, new Geoshape.GeoShapeGryoSerializer());
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanVertexStep.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public class TitanVertexStep<E extends Element> extends VertexStep<E> implements HasStepFolder<Vertex, E>, Profiling {
+public class TitanVertexStep<E extends Element> extends VertexStep<E> implements HasStepFolder<Vertex, E>, Profiling, MultiQueriable<Vertex,E> {
 
     public TitanVertexStep(VertexStep<E> originalStep) {
         super(originalStep.getTraversal(), originalStep.getReturnClass(), originalStep.getDirection(), originalStep.getEdgeLabels());
@@ -45,7 +45,8 @@ public TitanVertexStep(VertexStep<E> originalStep) {
     private Map<TitanVertex, Iterable<? extends TitanElement>> multiQueryResults = null;
     private QueryProfiler queryProfiler = QueryProfiler.NO_OP;
 
-    void setUseMultiQuery(boolean useMultiQuery) {
+    @Override
+    public void setUseMultiQuery(boolean useMultiQuery) {
         this.useMultiQuery = useMultiQuery;
     }
 

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -75,6 +75,7 @@ public BerkeleyJEStoreManager(Configuration configuration) throws BackendExcepti
                     .keyOrdered(true)
                     .scanTxConfig(GraphDatabaseConfiguration.buildGraphConfiguration()
                             .set(ISOLATION_LEVEL, IsolationLevel.READ_UNCOMMITTED.toString()))
+                    .supportsInterruption(false)
                     .build();
 
 //        features = new StoreFeatures();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/BasicVertexCentricQueryBuilder.java
Patch:
@@ -151,6 +151,8 @@ public boolean hasQueryOnlyGivenVertex() {
         return queryOnlyGivenVertex;
     }
 
+    public boolean hasQueryOnlyLoaded() { return queryOnlyLoaded; }
+
     /* ---------------------------------------------------------------
      * Utility Methods
 	 * ---------------------------------------------------------------

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexCentricQueryBuilder.java
Patch:
@@ -58,7 +58,7 @@ protected VertexCentricQueryBuilder getThis() {
     protected<Q> Q execute(RelationCategory returnType, ResultConstructor<Q> resultConstructor) {
         BaseVertexCentricQuery bq = super.constructQuery(returnType);
         if (bq.isEmpty()) return resultConstructor.emptyResult();
-        if (returnType==RelationCategory.PROPERTY && hasTypes()
+        if (returnType==RelationCategory.PROPERTY && hasSingleType() && !hasQueryOnlyLoaded()
                 && tx.getConfiguration().hasPropertyPrefetching()) {
             //Preload properties
             vertex.query().properties().iterator().hasNext();

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -602,7 +602,7 @@ public void mutate(Map<String, Map<String, IndexMutation>> mutations, KeyInforma
                     boolean actualFailure = false;
                     for(BulkItemResponse response : bulkItemResponses.getItems()) {
                         //The document may have been deleted, which is OK
-                        if(response.getFailure().getStatus() != RestStatus.NOT_FOUND) {
+                        if(response.isFailed() && response.getFailure().getStatus() != RestStatus.NOT_FOUND) {
                             log.error("Failed to execute ES query {}", response.getFailureMessage());
                             actualFailure = true;
                         }
@@ -681,6 +681,7 @@ private static String convertToJsType(Object value) throws PermanentBackendExcep
             int prefixLength = "{\"value\":".length();
             int suffixLength = "}".length();
             String result = s.substring(prefixLength, s.length() - suffixLength);
+            result = result.replace("$", "\\$");
             return result;
         } catch (IOException e) {
             throw new PermanentBackendException("Could not write json");

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -602,7 +602,7 @@ public void mutate(Map<String, Map<String, IndexMutation>> mutations, KeyInforma
                     boolean actualFailure = false;
                     for(BulkItemResponse response : bulkItemResponses.getItems()) {
                         //The document may have been deleted, which is OK
-                        if(response.getFailure().getStatus() != RestStatus.NOT_FOUND) {
+                        if(response.isFailed() && response.getFailure().getStatus() != RestStatus.NOT_FOUND) {
                             log.error("Failed to execute ES query {}", response.getFailureMessage());
                             actualFailure = true;
                         }
@@ -681,6 +681,7 @@ private static String convertToJsType(Object value) throws PermanentBackendExcep
             int prefixLength = "{\"value\":".length();
             int suffixLength = "}".length();
             String result = s.substring(prefixLength, s.length() - suffixLength);
+            result = result.replace("$", "\\$");
             return result;
         } catch (IOException e) {
             throw new PermanentBackendException("Could not write json");

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -257,8 +257,8 @@ public void initialize(Configuration config) {
                 long edgeStoreCacheSize = Math.round(cacheSizeBytes * EDGESTORE_CACHE_PERCENT);
                 long indexStoreCacheSize = Math.round(cacheSizeBytes * INDEXSTORE_CACHE_PERCENT);
 
-                edgeStore = new ExpirationKCVSCache(edgeStoreRaw,getMetricsCacheName("edgeStore"),expirationTime,cleanWaitTime,edgeStoreCacheSize);
-                indexStore = new ExpirationKCVSCache(indexStoreRaw,getMetricsCacheName("indexStore"),expirationTime,cleanWaitTime,indexStoreCacheSize);
+                edgeStore = new ExpirationKCVSCache(edgeStoreRaw,getMetricsCacheName(EDGESTORE_NAME),expirationTime,cleanWaitTime,edgeStoreCacheSize);
+                indexStore = new ExpirationKCVSCache(indexStoreRaw,getMetricsCacheName(INDEXSTORE_NAME),expirationTime,cleanWaitTime,indexStoreCacheSize);
             } else {
                 edgeStore = new NoKCVSCache(edgeStoreRaw);
                 indexStore = new NoKCVSCache(indexStoreRaw);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanBlueprintsTransaction.java
Patch:
@@ -106,7 +106,7 @@ public TitanVertex addVertex(Object... keyValues) {
 //            if (!keyValues[i].equals(T.id) && !keyValues[i].equals(T.label))
 //                ((StandardTitanTx)this).addPropertyInternal(vertex,getOrCreatePropertyKey((String) keyValues[i]),keyValues[i+1]);
 //        }
-        ElementHelper.attachProperties(vertex, keyValues);
+        com.thinkaurelius.titan.graphdb.util.ElementHelper.attachProperties(vertex, keyValues);
         return vertex;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeUtil.java
Patch:
@@ -99,7 +99,7 @@ public static List<CompositeIndexType> getUniqueIndexes(PropertyKey key) {
     public static boolean hasAnyIndex(PropertyKey key) {
         InternalRelationType type = (InternalRelationType) key;
         return !Iterables.isEmpty(type.getKeyIndexes()) ||
-                !Iterables.isEmpty(type.getRelationIndexes());
+                Iterables.size(type.getRelationIndexes())>1; //The type itself is also returned as an index
     }
 
     private static <T> T getTypeModifier(final SchemaSource schema,

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -38,7 +38,7 @@ public abstract class SystemTypeManager {
 
 
             ADDITIONAL_RESERVED_NAMES = ImmutableSet.of(
-                "key", "vertex", "edge", "element", "property" /* TODO #730, "label" */);
+                "key", "vertex", "edge", "element", "property", "label");
         }
         assert SYSTEM_TYPES_BY_ID.size()==17;
         assert SYSTEM_TYPES_BY_NAME.size()==17;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementTest.java
Patch:
@@ -19,7 +19,7 @@ public abstract class ManagementTest extends TitanGraphBaseTest {
     private static final Set<String> ILLEGAL_USER_DEFINED_NAMES = ImmutableSet.of(
             "~key", "~value", "~id", "~nid", "~label", "~adjacent",
             "~timestamp", "~ttl", "~visibility",
-            "key", "vertex", "edge", "element", "property", /* TODO #730 "label", */
+            "key", "vertex", "edge", "element", "property", "label",
             "~T$VertexExists",
             "~T$SchemaName",
             "~T$SchemaDefinitionProperty",

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/HBaseStorageSetup.java
Patch:
@@ -34,7 +34,7 @@ public class HBaseStorageSetup {
 
     public static final String HBASE_PARENT_DIR_PROP = "test.hbase.parentdir";
 
-    private static final Pattern HBASE_SUPPORTED_VERSION_PATTERN = Pattern.compile("^0\\.(9[468])\\..*");
+    private static final Pattern HBASE_SUPPORTED_VERSION_PATTERN = Pattern.compile("^((0\\.9[468])|(1\\.[01]))\\..*");
 
     private static final String HBASE_PARENT_DIR;
 
@@ -64,8 +64,8 @@ public static String getConfDirForHBaseVersion(String hv) {
     public static String getDirForHBaseVersion(String hv, String lastSubdir) {
         Matcher m = HBASE_SUPPORTED_VERSION_PATTERN.matcher(hv);
         if (m.matches()) {
-            String minor = m.group(1);
-            String result = String.format("%s%stitan-hbase-0%s/%s/", HBASE_PARENT_DIR, File.separator, minor, lastSubdir);
+            String majorDotMinor = m.group(1);
+            String result = String.format("%s%stitan-hbase-%s/%s/", HBASE_PARENT_DIR, File.separator, majorDotMinor.replace(".", ""), lastSubdir);
             log.debug("Built {} path for HBase version {}: {}", lastSubdir, hv, result);
             return result;
         } else {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -38,7 +38,7 @@ public abstract class SystemTypeManager {
 
 
             ADDITIONAL_RESERVED_NAMES = ImmutableSet.of(
-                /*"key", "vertex", "edge", "element", "property", "label"*/); // TODO #634, #730
+                "key", "vertex", "edge", "element", "property" /* TODO #730, "label" */);
         }
         assert SYSTEM_TYPES_BY_ID.size()==17;
         assert SYSTEM_TYPES_BY_NAME.size()==17;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementTest.java
Patch:
@@ -19,6 +19,7 @@ public abstract class ManagementTest extends TitanGraphBaseTest {
     private static final Set<String> ILLEGAL_USER_DEFINED_NAMES = ImmutableSet.of(
             "~key", "~value", "~id", "~nid", "~label", "~adjacent",
             "~timestamp", "~ttl", "~visibility",
+            "key", "vertex", "edge", "element", "property", /* TODO #730 "label", */
             "~T$VertexExists",
             "~T$SchemaName",
             "~T$SchemaDefinitionProperty",
@@ -27,8 +28,6 @@ public abstract class ManagementTest extends TitanGraphBaseTest {
             "~T$SchemaUpdateTimestamp",
             "~T$SchemaRelated",
             "~T$VertexLabel");
-            // TODO #634 add to list: "key"
-            // TODO #730 add to list: "vertex", "edge", "element", "property", "label"
 
     @Test
     public void testReservedNamesRejectedForPropertyKeys() {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -35,7 +35,7 @@ public enum Partitioner {
 
         RANDOM, BYTEORDER;
 
-        public static Partitioner getPartitioner(IPartitioner<?> partitioner) {
+        public static Partitioner getPartitioner(IPartitioner partitioner) {
             return getPartitioner(partitioner.getClass().getSimpleName());
         }
 
@@ -195,7 +195,7 @@ public final Partitioner getPartitioner() {
         return partitioner;
     }
 
-    public abstract IPartitioner<? extends Token<?>> getCassandraPartitioner() throws BackendException;
+    public abstract IPartitioner getCassandraPartitioner() throws BackendException;
 
     @Override
     public StoreTransaction beginTransaction(final BaseTransactionConfig config) {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -296,7 +296,7 @@ public Deployment getDeployment() {
 
     @Override
     @SuppressWarnings("unchecked")
-    public IPartitioner<? extends Token<?>> getCassandraPartitioner() throws BackendException {
+    public IPartitioner getCassandraPartitioner() throws BackendException {
         Cluster cl = clusterContext.getClient();
         try {
             return FBUtilities.newPartitioner(cl.describePartitioner());

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -215,7 +215,7 @@ public Deployment getDeployment() {
 
     @Override
     @SuppressWarnings("unchecked")
-    public IPartitioner<? extends Token<?>> getCassandraPartitioner() throws BackendException {
+    public IPartitioner getCassandraPartitioner() throws BackendException {
         CTConnection conn = null;
         try {
             conn = pool.borrowObject(SYSTEM_KS);
@@ -340,7 +340,7 @@ public synchronized CassandraThriftKeyColumnValueStore openDatabase(final String
     @Override
     public List<KeyRange> getLocalKeyPartition() throws BackendException {
         CTConnection conn = null;
-        IPartitioner<?> partitioner = getCassandraPartitioner();
+        IPartitioner partitioner = getCassandraPartitioner();
 
         if (!(partitioner instanceof AbstractByteOrderedPartitioner))
             throw new UnsupportedOperationException("getLocalKeyPartition() only supported by byte ordered partitioner.");

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/MapReduceIndexManagement.java
Patch:
@@ -138,7 +138,7 @@ public TitanManagement.IndexJobFuture updateIndex(TitanIndex index, SchemaAction
         if (CASSANDRA_STORE_MANAGER_CLASSES.contains(storeManagerClass)) {
             inputFormat = CassandraBinaryInputFormat.class;
             // Set the partitioner
-            IPartitioner<?> part =
+            IPartitioner part =
                     ((AbstractCassandraStoreManager)graph.getBackend().getStoreManager()).getCassandraPartitioner();
             hadoopConf.set("cassandra.input.partitioner.class", part.getClass().getName());
         } else if (HBASE_STORE_MANAGER_CLASSES.contains(storeManagerClass)) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/BasicConfiguration.java
Patch:
@@ -81,7 +81,7 @@ public Map<ConfigElement.PathIdentifier,Object> getAll() {
                 Preconditions.checkArgument(pid.element.isOption() && !pid.lastIsUmbrella);
                 result.put(pid,get((ConfigOption)pid.element,pid.umbrellaElements));
             } catch (IllegalArgumentException e) {
-                log.info("Ignored configuration entry for {} since it does not map to an option",key,e);
+                log.debug("Ignored configuration entry for {} since it does not map to an option",key,e);
                 continue;
             }
         }

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -536,7 +536,7 @@ private static Object convertToEsType(Object value) {
             return value;
         } else if (value instanceof UUID) {
             return value.toString();
-        } else throw new IllegalArgumentException("Unsupported type: " + value);
+        } else throw new IllegalArgumentException("Unsupported type: " + value.getClass() + " (value: " + value + ")");
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/util/datastructures/IntHashSet.java
Patch:
@@ -1,16 +1,16 @@
 package com.thinkaurelius.titan.util.datastructures;
 
-import com.carrotsearch.hppc.IntIntOpenHashMap;
+import com.carrotsearch.hppc.IntIntHashMap;
 import com.carrotsearch.hppc.cursors.IntCursor;
 
 import java.util.Iterator;
 
 /**
- * Implementation of {@link IntSet} against {@link IntIntOpenHashMap}.
+ * Implementation of {@link IntSet} against {@link IntIntHashMap}.
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public class IntHashSet extends IntIntOpenHashMap implements IntSet {
+public class IntHashSet extends IntIntHashMap implements IntSet {
 
     private static final long serialVersionUID = -7297353805905443841L;
     private static final int defaultValue = 1;

File: titan-core/src/main/java/com/thinkaurelius/titan/util/stats/IntegerDoubleFrequency.java
Patch:
@@ -3,7 +3,7 @@
 
 import com.carrotsearch.hppc.IntCollection;
 import com.carrotsearch.hppc.IntDoubleMap;
-import com.carrotsearch.hppc.IntDoubleOpenHashMap;
+import com.carrotsearch.hppc.IntDoubleHashMap;
 
 /**
  * Count relative integer frequencies
@@ -16,7 +16,7 @@ public class IntegerDoubleFrequency {
     private double total;
 
     public IntegerDoubleFrequency() {
-        counts = new IntDoubleOpenHashMap();
+        counts = new IntDoubleHashMap();
         total = 0;
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/TestByteBuffer.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan;
 
 import com.carrotsearch.hppc.LongObjectMap;
-import com.carrotsearch.hppc.LongObjectOpenHashMap;
+import com.carrotsearch.hppc.LongObjectHashMap;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
@@ -66,7 +66,7 @@ private static long testObject() {
     }
 
     private static long testByte() {
-        LongObjectMap<ConcurrentSkipListSet<ByteEntry>> tx = new LongObjectOpenHashMap<ConcurrentSkipListSet<ByteEntry>>(NUM);
+        LongObjectMap<ConcurrentSkipListSet<ByteEntry>> tx = new LongObjectHashMap<ConcurrentSkipListSet<ByteEntry>>(NUM);
         for (int i = 0; i < NUM; i++) {
             tx.put(i, new ConcurrentSkipListSet<ByteEntry>());
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanPartitionGraphTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb;
 
 
-import com.carrotsearch.hppc.IntOpenHashSet;
+import com.carrotsearch.hppc.IntHashSet;
 import com.carrotsearch.hppc.IntSet;
 import com.carrotsearch.hppc.LongArrayList;
 import com.google.common.collect.*;
@@ -352,7 +352,7 @@ private void testPartitionSpread(boolean flush, boolean batchCommit) {
         int[] groupDegrees = {10,15,10,17,10,4,7,20,11};
         int numVertices = setupGroupClusters(groupDegrees,batchCommit?CommitMode.BATCH:CommitMode.PER_VERTEX);
 
-        IntSet partitionIds = new IntOpenHashSet(numVertices); //to track the "spread" of partition ids
+        IntSet partitionIds = new IntHashSet(numVertices); //to track the "spread" of partition ids
         for (int i=0;i<groupDegrees.length;i++) {
             TitanVertex g = getOnlyVertex(tx.query().has("groupid","group"+i));
             assertCount(groupDegrees[i],g.edges(Direction.OUT,"contain"));
@@ -458,7 +458,7 @@ public void testKeybasedGraphPartitioning() {
         int[] groupDegrees = {5,5,5,5,5,5,5,5};
         int numVertices = setupGroupClusters(groupDegrees,CommitMode.PER_VERTEX);
 
-        IntSet partitionIds = new IntOpenHashSet(numVertices); //to track the "spread" of partition ids
+        IntSet partitionIds = new IntHashSet(numVertices); //to track the "spread" of partition ids
         for (int i=0;i<groupDegrees.length;i++) {
             TitanVertex g = getOnlyVertex(tx.query().has("groupid","group"+i));
             int partitionId = -1;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/PartitionIDRangeTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.idmanagement;
 
-import com.carrotsearch.hppc.IntOpenHashSet;
+import com.carrotsearch.hppc.IntHashSet;
 import com.carrotsearch.hppc.IntSet;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.idmanagement;
 
-import com.carrotsearch.hppc.LongOpenHashSet;
+import com.carrotsearch.hppc.LongHashSet;
 import com.carrotsearch.hppc.LongSet;
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanGraph;
@@ -96,8 +96,8 @@ private static TitanGraph getInMemoryGraph() {
 
     @Test
     public void testIDAssignment() {
-        LongSet vertexIds = new LongOpenHashSet();
-        LongSet relationIds = new LongOpenHashSet();
+        LongSet vertexIds = new LongHashSet();
+        LongSet relationIds = new LongHashSet();
         int totalRelations = 0;
         int totalVertices = 0;
         for (int trial = 0; trial < 10; trial++) {

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -602,7 +602,7 @@ public void mutate(Map<String, Map<String, IndexMutation>> mutations, KeyInforma
                     boolean actualFailure = false;
                     for(BulkItemResponse response : bulkItemResponses.getItems()) {
                         //The document may have been deleted, which is OK
-                        if(response.getFailure().getStatus() != RestStatus.NOT_FOUND) {
+                        if(response.isFailed() && response.getFailure().getStatus() != RestStatus.NOT_FOUND) {
                             log.error("Failed to execute ES query {}", response.getFailureMessage());
                             actualFailure = true;
                         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraGraphComputer.java
Patch:
@@ -353,8 +353,7 @@ public Features features() {
         return new Features() {
             @Override
             public boolean supportsResultGraphPersistCombination(final ResultGraph resultGraph, final Persist persist) {
-                return (persist == Persist.NOTHING || persist == Persist.VERTEX_PROPERTIES) &&
-                        (resultGraph == ResultGraph.NEW || resultGraph == ResultGraph.ORIGINAL);
+                return persist == Persist.NOTHING || persist == Persist.VERTEX_PROPERTIES;
             }
 
             @Override

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/process/BerkeleyTitanProcessPerformanceTest.java
Patch:
@@ -11,7 +11,6 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-@Ignore
 @RunWith(ProcessPerformanceSuite.class)
 @GraphProviderClass(provider = BerkeleyGraphProvider.class, graph = TitanGraph.class)
 public class BerkeleyTitanProcessPerformanceTest {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -117,6 +117,7 @@ public void process(StaticBuffer key, Map<SliceQuery, EntryList> entries, ScanMe
         Preconditions.checkArgument(vertex instanceof PreloadedVertex,
                 "The bounding transaction is not configured correctly");
         PreloadedVertex v = (PreloadedVertex)vertex;
+        v.setAccessCheck(PreloadedVertex.OPENSTAR_CHECK);
         for (Map.Entry<SliceQuery,EntryList> entry : entries.entrySet()) {
             SliceQuery sq = entry.getKey();
             if (sq.equals(VERTEX_EXISTS_QUERY)) continue;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/PartitionedVertexProgramExecutor.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.olap.computer;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.diskstorage.EntryList;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.scan.ScanMetrics;
@@ -16,7 +15,6 @@
 import org.slf4j.LoggerFactory;
 
 import java.util.Map;
-import java.util.concurrent.ExecutorService;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -91,7 +89,7 @@ public void run() {
                 Preconditions.checkArgument(vertex instanceof PreloadedVertex,
                         "The bounding transaction is not configured correctly");
                 PreloadedVertex v = (PreloadedVertex)vertex;
-                v.setAccessCheck(PreloadedVertex.STAR_CHECK);
+                v.setAccessCheck(PreloadedVertex.CLOSEDSTAR_CHECK);
                 v.addToQueryCache(VertexProgramScanJob.SYSTEM_PROPS_QUERY,preloaded);
                 VertexMemoryHandler.Partition<M> vh = new VertexMemoryHandler.Partition<M>(vertexMemory,v);
                 v.setPropertyMixing(vh);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -3282,7 +3282,7 @@ public static void evaluateQuery(TitanVertexQuery query, RelationCategory result
         int subQueryCounter = 0;
         for (SimpleQueryProfiler subProfiler : profiler) {
             assertNotNull(subProfiler);
-            if (subProfiler.)
+            if (subProfiler.getGroupName().equals(QueryProfiler.OPTIMIZATION)) continue;
             if (subQuerySpecs.length == 2) { //0=>fitted, 1=>ordered
                 assertEquals(subQuerySpecs[0], (Boolean) subProfiler.getAnnotation(QueryProfiler.FITTED_ANNOTATION));
                 assertEquals(subQuerySpecs[1], (Boolean) subProfiler.getAnnotation(QueryProfiler.ORDERED_ANNOTATION));
@@ -4313,7 +4313,7 @@ public static void evaluateQuery(TitanGraphQuery query, ElementCategory resultTy
         for (PropertyKey key : orderMap.keySet()) assertTrue(orders.containsKey(key));
 
         //Check subqueries
-        SimpleQueryProfiler subp = Iterables.getOnlyElement(profiler);
+        SimpleQueryProfiler subp = Iterables.getOnlyElement(Iterables.filter(profiler, p -> !p.getGroupName().equals(QueryProfiler.OPTIMIZATION)));
         if (subQuerySpecs.length == 2) { //0=>fitted, 1=>ordered
             assertEquals(subQuerySpecs[0], (Boolean) subp.getAnnotation(QueryProfiler.FITTED_ANNOTATION));
             assertEquals(subQuerySpecs[1], (Boolean) subp.getAnnotation(QueryProfiler.ORDERED_ANNOTATION));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/PartitionedVertexProgramExecutor.java
Patch:
@@ -91,7 +91,7 @@ public void run() {
                 Preconditions.checkArgument(vertex instanceof PreloadedVertex,
                         "The bounding transaction is not configured correctly");
                 PreloadedVertex v = (PreloadedVertex)vertex;
-                v.setExceptionOnRetrieve(true);
+                v.setAccessCheck(PreloadedVertex.STAR_CHECK);
                 v.addToQueryCache(VertexProgramScanJob.SYSTEM_PROPS_QUERY,preloaded);
                 VertexMemoryHandler.Partition<M> vh = new VertexMemoryHandler.Partition<M>(vertexMemory,v);
                 v.setPropertyMixing(vh);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexProgramScanJob.java
Patch:
@@ -83,7 +83,7 @@ public void process(TitanVertex vertex, ScanMetrics metrics) {
         PreloadedVertex v = (PreloadedVertex)vertex;
         long vertexId = v.longId();
         VertexMemoryHandler<M> vh = new VertexMemoryHandler(vertexMemory,v);
-        v.setExceptionOnRetrieve(true);
+        v.setAccessCheck(PreloadedVertex.STAR_CHECK);
         if (idManager.isPartitionedVertex(vertexId)) {
             if (idManager.isCanonicalVertexId(vertexId)) {
                 EntryList results = v.getFromCache(SYSTEM_PROPS_QUERY);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -10,7 +10,7 @@
 import com.thinkaurelius.titan.diskstorage.StandardIndexProvider;
 import com.thinkaurelius.titan.diskstorage.StandardStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.ttl.TTLKCVSManager;
-import com.thinkaurelius.titan.graphdb.tinkerpop.BlueprintsDefaultSchemaMaker;
+import com.thinkaurelius.titan.graphdb.tinkerpop.TitanDefaultSchemaMaker;
 import com.thinkaurelius.titan.graphdb.tinkerpop.Tp3DefaultSchemaMaker;
 import com.thinkaurelius.titan.graphdb.database.management.ManagementSystem;
 import com.thinkaurelius.titan.graphdb.types.typemaker.DisableDefaultSchemaMaker;
@@ -247,7 +247,7 @@ public class GraphDatabaseConfiguration {
     public static final ConfigOption<String> AUTO_TYPE = new ConfigOption<String>(SCHEMA_NS,"default",
             "Configures the DefaultSchemaMaker to be used by this graph. If set to 'none', automatic schema creation is disabled. " +
                     "Defaults to a blueprints compatible schema maker with MULTI edge labels and SINGLE property keys",
-            ConfigOption.Type.MASKABLE, "blueprints" , new Predicate<String>() {
+            ConfigOption.Type.MASKABLE, "default" , new Predicate<String>() {
         @Override
         public boolean apply(@Nullable String s) {
             if (s==null) return false;
@@ -263,7 +263,7 @@ public boolean apply(@Nullable String s) {
 
     private static final Map<String, DefaultSchemaMaker> preregisteredAutoType = new HashMap<String, DefaultSchemaMaker>() {{
         put("none", DisableDefaultSchemaMaker.INSTANCE);
-        put("blueprints", BlueprintsDefaultSchemaMaker.INSTANCE);
+        put("default", TitanDefaultSchemaMaker.INSTANCE);
         put("tp3", Tp3DefaultSchemaMaker.INSTANCE);
     }};
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanFeatures.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
+import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 import org.apache.tinkerpop.gremlin.structure.util.StringFactory;
@@ -147,9 +148,9 @@ private class TitanVertexFeatures implements VertexFeatures {
 
         @Override
         public VertexProperty.Cardinality getCardinality(final String key) {
-            TitanTransaction tx = TitanFeatures.this.graph.newTransaction();
+            StandardTitanTx tx = (StandardTitanTx)TitanFeatures.this.graph.newTransaction();
             try {
-                if (!tx.containsPropertyKey(key)) return VertexProperty.Cardinality.list; //DEFAULT
+                if (!tx.containsPropertyKey(key)) return tx.getConfiguration().getAutoSchemaMaker().defaultPropertyCardinality(key).convert();
                 return tx.getPropertyKey(key).cardinality().convert();
             } finally {
                 tx.rollback();

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/AbstractIndexManagementIT.java
Patch:
@@ -18,7 +18,7 @@
 import com.thinkaurelius.titan.graphdb.olap.job.IndexRemoveJob;
 import com.thinkaurelius.titan.graphdb.olap.job.IndexRepairJob;
 import org.apache.tinkerpop.gremlin.structure.Direction;
-import org.apache.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.process.traversal.Order;
 import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.junit.Test;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -82,7 +82,7 @@ public class StandardTitanGraph extends TitanBlueprintsGraph {
 
     static {
         TraversalStrategies graphStrategies = TraversalStrategies.GlobalCache.getStrategies(Graph.class).clone()
-                .addStrategies(TitanGraphStepStrategy.instance(), TitanLocalQueryOptimizerStrategy.instance()); //TitanElementStepStrategy.instance()
+                .addStrategies(TitanLocalQueryOptimizerStrategy.instance(),TitanGraphStepStrategy.instance()); //TitanElementStepStrategy.instance()
 
         //Register with cache
         TraversalStrategies.GlobalCache.registerStrategies(StandardTitanGraph.class,graphStrategies);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/PreloadedVertex.java
Patch:
@@ -106,6 +106,8 @@ public EntryList loadRelations(SliceQuery query, Retriever<SliceQuery, EntryList
 
     @Override
     public <V> TitanVertexProperty<V> property(VertexProperty.Cardinality cardinality, String key, V value, Object... keyValues) {
+        if(this.mapReduceJob)
+            throw GraphComputer.Exceptions.vertexPropertiesCanNotBeUpdatedInMapReduce();
         TitanVertexProperty<V> p = mixin.property(cardinality, key, value);
         ElementHelper.attachProperties(p, keyValues);
         return p;

File: titan-hadoop-parent/titan-hadoop-1/src/main/java/com/thinkaurelius/titan/hadoop/formats/TitanH1OutputFormat.java
Patch:
@@ -52,7 +52,7 @@ public RecordWriter<NullWritable, VertexWritable> getRecordWriter(TaskAttemptCon
         // returned by VertexProgram.getComputeKeys()
         if (null == persistableKeys) {
             try {
-                persistableKeys = VertexProgram.createVertexProgram(
+                persistableKeys = VertexProgram.createVertexProgram(graph,
                        ConfUtil.makeApacheConfiguration(taskAttemptContext.getConfiguration())).getElementComputeKeys();
                 log.debug("Set persistableKeys={}", Joiner.on(",").join(persistableKeys));
             } catch (Exception e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanFeatures.java
Patch:
@@ -149,7 +149,7 @@ private class TitanVertexFeatures implements VertexFeatures {
         public VertexProperty.Cardinality getCardinality(final String key) {
             TitanTransaction tx = TitanFeatures.this.graph.newTransaction();
             try {
-                if (!tx.containsPropertyKey(key)) return VertexProperty.Cardinality.single; //DEFAULT
+                if (!tx.containsPropertyKey(key)) return VertexProperty.Cardinality.list; //DEFAULT
                 return tx.getPropertyKey(key).cardinality().convert();
             } finally {
                 tx.rollback();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -38,6 +38,7 @@ public InMemoryStoreManager(final Configuration configuration) {
             .orderedScan(true)
             .unorderedScan(true)
             .keyOrdered(true)
+            .persists(false)
             .keyConsistent(GraphDatabaseConfiguration.buildGraphConfiguration())
             .build();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanIoRegistry.java
Patch:
@@ -20,7 +20,7 @@ public class TitanIoRegistry extends AbstractIoRegistry {
 
     public static TitanIoRegistry INSTANCE = new TitanIoRegistry();
 
-    public TitanIoRegistry() {
+    private TitanIoRegistry() {
         register(GraphSONIo.class, null, TitanGraphSONModule.getInstance());
         register(GryoIo.class, RelationIdentifier.class, null);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/io/graphson/TitanGraphSONModule.java
Patch:
@@ -50,11 +50,10 @@ public void serializeWithType(final RelationIdentifier relationIdentifier, final
             //  0=relationId, 1=outVertexId, 2=typeId, 3=inVertexId (optional)
             jsonGenerator.writeNumberField("relationId",asLong[0]);
             jsonGenerator.writeNumberField("outVertexId", asLong[1]);
-            jsonGenerator.writeNumberField("typeId",asLong[2]);
+            jsonGenerator.writeNumberField("typeId", asLong[2]);
             if (asLong.length>3) jsonGenerator.writeNumberField("inVertexId",asLong[3]);
             jsonGenerator.writeEndObject();
         }
 
-
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/BaseVertexCentricQueryBuilder.java
Patch:
@@ -10,6 +10,7 @@
 import com.thinkaurelius.titan.graphdb.query.*;
 import com.thinkaurelius.titan.graphdb.query.condition.*;
 import com.thinkaurelius.titan.graphdb.relations.RelationIdentifier;
+import com.thinkaurelius.titan.graphdb.tinkerpop.ElementUtils;
 import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 import com.thinkaurelius.titan.graphdb.types.system.SystemRelationType;
 import org.apache.tinkerpop.gremlin.structure.*;
@@ -85,7 +86,7 @@ private Q addConstraint(String type, TitanPredicate rel, Object value) {
             Preconditions.checkArgument(value instanceof Number,"Expected valid vertex id: %s",value);
             return adjacent(getVertex(((Number)value).longValue()));
         } else if (type.equals(ImplicitKey.ID.name())) {
-            Preconditions.checkArgument(value instanceof RelationIdentifier,"Expected valid relation id: %s",value);
+            value = ElementUtils.getEdgeId(value);
             return addConstraint(ImplicitKey.TITANID.name(),rel,((RelationIdentifier)value).getRelationId());
         } else {
             Preconditions.checkArgument(rel.isValidCondition(value),"Invalid condition provided: " + value);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -44,6 +44,7 @@
 import com.thinkaurelius.titan.graphdb.tinkerpop.TitanBlueprintsGraph;
 import com.thinkaurelius.titan.graphdb.tinkerpop.TitanFeatures;
 import com.thinkaurelius.titan.graphdb.tinkerpop.optimize.TitanGraphStepStrategy;
+import com.thinkaurelius.titan.graphdb.tinkerpop.optimize.TitanIdsValidationStrategy;
 import com.thinkaurelius.titan.graphdb.tinkerpop.optimize.TitanLocalQueryOptimizerStrategy;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTransactionBuilder;
@@ -82,7 +83,7 @@ public class StandardTitanGraph extends TitanBlueprintsGraph {
 
     static {
         TraversalStrategies graphStrategies = TraversalStrategies.GlobalCache.getStrategies(Graph.class).clone()
-                .addStrategies(TitanGraphStepStrategy.instance(), TitanLocalQueryOptimizerStrategy.instance()); //TitanElementStepStrategy.instance()
+                .addStrategies(TitanIdsValidationStrategy.instance(), TitanGraphStepStrategy.instance(), TitanLocalQueryOptimizerStrategy.instance()); //TitanElementStepStrategy.instance()
 
         //Register with cache
         TraversalStrategies.GlobalCache.registerStrategies(StandardTitanGraph.class,graphStrategies);

File: titan-test/src/main/java/com/thinkaurelius/titan/StorageSetup.java
Patch:
@@ -13,6 +13,7 @@
 import org.apache.commons.lang.StringUtils;
 
 import java.io.File;
+import java.time.Duration;
 
 public class StorageSetup {
 
@@ -55,7 +56,7 @@ public static final void deleteHomeDir(String subdir) {
     }
 
     public static ModifiableConfiguration getInMemoryConfiguration() {
-        return buildGraphConfiguration().set(STORAGE_BACKEND, "inmemory");
+        return buildGraphConfiguration().set(STORAGE_BACKEND, "inmemory").set(IDAUTHORITY_WAIT, Duration.ZERO);
     }
 
     public static TitanGraph getInMemoryGraph() {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -159,6 +159,7 @@ public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
 
             shutdownHook = new ShutdownThread(this);
             Runtime.getRuntime().addShutdownHook(shutdownHook);
+            log.debug("Installed shutdown hook {}", shutdownHook, new Throwable("Hook creation trace"));
         }
     }
 
@@ -245,6 +246,7 @@ private synchronized void removeHook() {
         // Remove shutdown hook to avoid reference retention
         try {
             Runtime.getRuntime().removeShutdownHook(tmp);
+            log.debug("Removed shutdown hook {}", tmp);
         } catch (IllegalStateException e) {
             log.warn("Failed to remove shutdown hook", e);
         }
@@ -803,8 +805,7 @@ public ShutdownThread(StandardTitanGraph graph) {
 
         @Override
         public void start() {
-            if (graph.isOpen && log.isDebugEnabled())
-                log.debug("Shutting down graph {} using built-in shutdown hook.", graph);
+            log.debug("Shutting down graph {} using shutdown hook {}", graph, this);
 
             graph.closeInternal();
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/ConfigElement.java
Patch:
@@ -154,7 +154,7 @@ public static String getPath(ConfigElement element, boolean includeRoot, String.
         if (includeRoot) {
             // Assumes that roots are not umbrellas
             // If roots could be umbrellas, we might have to change the interpretation of umbrellaElements
-            path = (element.isNamespace() ?
+            path = (element.isRoot() ?
                     element.getName() :
                     element.getNamespace().getName()) + SEPARATOR + path;
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanPropertiesStep.java
Patch:
@@ -12,7 +12,7 @@
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.step.map.PropertiesStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;
-import org.apache.tinkerpop.gremlin.process.traversal.FastNoSuchElementException;
+import org.apache.tinkerpop.gremlin.process.traversal.util.FastNoSuchElementException;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.structure.*;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanVertexStep.java
Patch:
@@ -15,7 +15,7 @@
 import org.apache.tinkerpop.gremlin.process.traversal.step.Profileable;
 import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;
-import org.apache.tinkerpop.gremlin.process.traversal.FastNoSuchElementException;
+import org.apache.tinkerpop.gremlin.process.traversal.util.FastNoSuchElementException;
 import org.apache.tinkerpop.gremlin.process.traversal.util.MutableMetrics;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.structure.*;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -355,15 +355,15 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> batch, StoreT
 
                 if (titanMutation.hasDeletions()) {
                     ColumnListMutation<ByteBuffer> dels = m.withRow(columnFamily, key);
-                    dels.setTimestamp(commitTime.getDeletionTime(times.getUnit()));
+                    dels.setTimestamp(commitTime.getDeletionTime(times));
 
                     for (StaticBuffer b : titanMutation.getDeletions())
                         dels.deleteColumn(b.as(StaticBuffer.BB_FACTORY));
                 }
 
                 if (titanMutation.hasAdditions()) {
                     ColumnListMutation<ByteBuffer> upds = m.withRow(columnFamily, key);
-                    upds.setTimestamp(commitTime.getAdditionTime(times.getUnit()));
+                    upds.setTimestamp(commitTime.getAdditionTime(times));
 
                     for (Entry e : titanMutation.getAdditions()) {
                         Integer ttl = (Integer) e.getMetaData().get(EntryMetaData.TTL);
@@ -465,7 +465,7 @@ private AstyanaxContext.Builder getContextBuilder(Configuration config, int maxC
 
         final int maxOperationsPerConnection = config.get(MAX_OPERATIONS_PER_CONNECTION);
 
-        final int connectionTimeout = (int) connectionTimeoutMS.getLength(TimeUnit.MILLISECONDS);
+        final int connectionTimeout = (int) connectionTimeoutMS.toMillis();
 
         ConnectionPoolConfigurationImpl cpool =
                 new ConnectionPoolConfigurationImpl(usedFor + "TitanConnectionPool")

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -154,7 +154,7 @@ public EntryList getSlice(KeySliceQuery query, StoreTransaction txh) throws Back
          * {@link ReadCommand#create(String, ByteBuffer, String, long, IDiskAtomFilter)}.
          * {@code create(...)} in turn passes that timestamp to the SliceFromReadCommand constructor.
          */
-        final long nowMillis = times.getTime().getTimestamp(TimeUnit.MILLISECONDS);
+        final long nowMillis = times.getTime().toEpochMilli();
         SliceQueryFilter sqf = new SliceQueryFilter(query.getSliceStart().asByteBuffer(), query.getSliceEnd().asByteBuffer(), false, query.getLimit() + (query.hasLimit()?1:0));
         ReadCommand sliceCmd = new SliceFromReadCommand(keyspace, query.getKey().asByteBuffer(), columnFamily, nowMillis, sqf);
 
@@ -340,7 +340,7 @@ public RowIterator(Token minimum, Token maximum, SliceQuery sliceQuery, int page
             this.sliceQuery = sliceQuery;
             this.maximumToken = maximum;
             this.txh = txh;
-            this.nowMillis = times.getTime().getTimestamp(TimeUnit.MILLISECONDS);
+            this.nowMillis = times.getTime().toEpochMilli();
             this.keys = getRowsIterator(getKeySlice(minimum, maximum, sliceQuery, pageSize, nowMillis));
         }
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -177,16 +177,16 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
                         Integer ttl = (Integer) e.getMetaData().get(EntryMetaData.TTL);
 
                         if (null != ttl && ttl > 0) {
-                            rm.add(columnFamily, e.getColumnAs(StaticBuffer.BB_FACTORY), e.getValueAs(StaticBuffer.BB_FACTORY), commitTime.getAdditionTime(times.getUnit()), ttl);
+                            rm.add(columnFamily, e.getColumnAs(StaticBuffer.BB_FACTORY), e.getValueAs(StaticBuffer.BB_FACTORY), commitTime.getAdditionTime(times), ttl);
                         } else {
-                            rm.add(columnFamily, e.getColumnAs(StaticBuffer.BB_FACTORY), e.getValueAs(StaticBuffer.BB_FACTORY), commitTime.getAdditionTime(times.getUnit()));
+                            rm.add(columnFamily, e.getColumnAs(StaticBuffer.BB_FACTORY), e.getValueAs(StaticBuffer.BB_FACTORY), commitTime.getAdditionTime(times));
                         }
                     }
                 }
 
                 if (mut.hasDeletions()) {
                     for (StaticBuffer col : mut.getDeletions()) {
-                        rm.delete(columnFamily, col.as(StaticBuffer.BB_FACTORY), commitTime.getDeletionTime(times.getUnit()));
+                        rm.delete(columnFamily, col.as(StaticBuffer.BB_FACTORY), commitTime.getDeletionTime(times));
                     }
                 }
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -165,7 +165,7 @@ public CassandraThriftStoreManager(Configuration config) throws BackendException
          * This is eventually passed to Thrift's TSocket constructor. The
          * constructor parameter is of type int.
          */
-        int thriftTimeoutMS = (int)config.get(GraphDatabaseConfiguration.CONNECTION_TIMEOUT).getLength(TimeUnit.MILLISECONDS);
+        int thriftTimeoutMS = (int)config.get(GraphDatabaseConfiguration.CONNECTION_TIMEOUT).toMillis();
 
         thriftFrameSizeBytes = config.get(THRIFT_FRAME_SIZE) * 1024 * 1024;
 
@@ -276,7 +276,7 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
                         SlicePredicate sp = new SlicePredicate();
                         sp.addToColumn_names(buf.as(StaticBuffer.BB_FACTORY));
                         d.setPredicate(sp);
-                        d.setTimestamp(commitTime.getDeletionTime(times.getUnit()));
+                        d.setTimestamp(commitTime.getDeletionTime(times));
                         org.apache.cassandra.thrift.Mutation m = new org.apache.cassandra.thrift.Mutation();
                         m.setDeletion(d);
                         thriftMutation.add(m);
@@ -289,7 +289,7 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
                         Column column = new Column(ent.getColumnAs(StaticBuffer.BB_FACTORY));
                         column.setValue(ent.getValueAs(StaticBuffer.BB_FACTORY));
 
-                        column.setTimestamp(commitTime.getAdditionTime(times.getUnit()));
+                        column.setTimestamp(commitTime.getAdditionTime(times));
 
                         Integer ttl = (Integer) ent.getMetaData().get(EntryMetaData.TTL);
                         if (null != ttl && ttl > 0) {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -4,10 +4,11 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
@@ -44,7 +45,7 @@ private static ModifiableConfiguration getGenericConfiguration(String ks, String
         config.set(CASSANDRA_KEYSPACE, cleanKeyspaceName(ks));
         log.debug("Set keyspace name: {}", config.get(CASSANDRA_KEYSPACE));
         config.set(PAGE_SIZE,500);
-        config.set(CONNECTION_TIMEOUT, new StandardDuration(60L, TimeUnit.SECONDS));
+        config.set(CONNECTION_TIMEOUT, Duration.ofSeconds(60L));
         config.set(STORAGE_BACKEND, backend);
         return config;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/log/LogProcessorBuilder.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.core.log;
 
+import java.time.Instant;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -32,11 +33,10 @@ public interface LogProcessorBuilder {
     /**
      * Sets the time at which this log processor should start processing transaction log entries
      *
-     * @param sinceEpoch
-     * @param unit
+     * @param startTime
      * @return
      */
-    public LogProcessorBuilder setStartTime(long sinceEpoch, TimeUnit unit);
+    public LogProcessorBuilder setStartTime(Instant startTime);
 
     /**
      * Indicates that the transaction log processor should process newly added events.

File: titan-core/src/main/java/com/thinkaurelius/titan/core/log/TransactionId.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.core.log;
 
-import com.thinkaurelius.titan.core.attribute.Timestamp;
+
+import java.time.Instant;
 
 /**
  * Identifies a transaction. Used when processing user log entries to know which transaction caused a given change.
@@ -31,6 +32,6 @@ public interface TransactionId {
      *
      * @return
      */
-    public Timestamp getTransactionTime();
+    public Instant getTransactionTime();
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/util/ReflectiveConfigOptionLoader.java
Patch:
@@ -10,7 +10,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import com.thinkaurelius.titan.diskstorage.util.time.Timer;
-import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProviders;
 import org.reflections.Reflections;
 import org.reflections.scanners.SubTypesScanner;
 import org.reflections.scanners.TypeAnnotationsScanner;
@@ -118,7 +118,7 @@ public void loadStandard(Class<?> caller) {
             //"com.thinkaurelius.titan.graphdb.TestMockLog",
             "com.thinkaurelius.titan.diskstorage.berkeleyje.BerkeleyJEStoreManager");
 
-        Timer t = new Timer(Timestamps.MILLI);
+        Timer t = new Timer(TimestampProviders.MILLI);
         t.start();
 
         List<ClassLoader> loaders = getClassLoaders(cfg, caller);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/util/TitanCleanup.java
Patch:
@@ -2,11 +2,12 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 
+import java.time.Duration;
 import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 
@@ -39,7 +40,7 @@ public Boolean call() throws Exception {
             }
             @Override
             public String toString() { return "ClearBackend"; }
-        },new StandardDuration(20, TimeUnit.SECONDS));
+        }, Duration.ofSeconds(20));
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.core.TitanConfigurationException;
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.core.TitanFactory;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.core.schema.TitanManagement;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDAuthority;
@@ -49,6 +49,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.time.Duration;
 import java.util.*;
 import java.util.concurrent.*;
 
@@ -345,7 +346,7 @@ public StandardScanner.Builder buildGraphIndexScanJob() {
     private StandardScanner.Builder buildStoreIndexScanJob(String storeName) {
         TimestampProvider provider = configuration.get(TIMESTAMP_PROVIDER);
         ModifiableConfiguration jobConfig = GraphDatabaseConfiguration.buildJobConfiguration();
-        jobConfig.set(JOB_START_TIME,provider.getTime().getTimestamp(TimeUnit.MILLISECONDS));
+        jobConfig.set(JOB_START_TIME,provider.getTime().toEpochMilli());
         return scanner.build()
                 .setStoreName(storeName)
                 .setTimestampProvider(provider)

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BackendTransaction.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage;
 
+import java.time.Duration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -16,7 +17,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.indexing.IndexQuery;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexTransaction;
 import com.thinkaurelius.titan.diskstorage.indexing.RawQuery;
@@ -233,7 +234,6 @@ public void acquireEdgeLock(StaticBuffer key, Entry entry) throws BackendExcepti
      *
      * @param key           Key on which to lock
      * @param column        Column the column on which to lock
-     * @param expectedValue The expected value for the specified key-column pair on which to lock. Null if it is expected that the pair does not exist
      */
     public void acquireIndexLock(StaticBuffer key, StaticBuffer column) throws BackendException {
         acquiredLock = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthority.java
Patch:
@@ -1,10 +1,11 @@
 package com.thinkaurelius.titan.diskstorage;
 
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 
+import java.time.Duration;
 import java.util.List;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/UserModifiableConfiguration.java
Patch:
@@ -1,10 +1,11 @@
 package com.thinkaurelius.titan.diskstorage.configuration;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.core.schema.TitanConfiguration;
 
 import java.lang.reflect.Array;
+import java.time.Duration;
 
 /**
  * Helper class for inspecting and modifying a configuration for Titan.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDAuthority.java
Patch:
@@ -1,14 +1,16 @@
 package com.thinkaurelius.titan.diskstorage.idmanagement;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 
+import java.time.Duration;
+
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID;
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -1,12 +1,13 @@
 package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
 import com.thinkaurelius.titan.graphdb.database.idhandling.VariableLong;
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
 
+import java.time.Duration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreFeatures.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
-import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProviders;
 
 /**
  * Describes features supported by a storage backend.
@@ -105,7 +105,7 @@ public interface StoreFeatures {
      *
      * @return null or a Timestamps enum value
      */
-    public Timestamps getPreferredTimestamps();
+    public TimestampProviders getPreferredTimestamps();
 
     /**
      * Returns true if this storage backend support time-to-live (TTL) settings for column-value entries. If such a value

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;
@@ -17,6 +17,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.time.Duration;
 import java.util.*;
 import java.util.concurrent.Callable;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LockStatus.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
+
+import java.time.Instant;
 
 /**
  * A single held lock's expiration time. This is used by {@link AbstractLocker}.
@@ -15,5 +16,5 @@ public interface LockStatus {
      *
      * @return The expiration instant of this lock
      */
-    public Timepoint getExpirationTimestamp();
+    public Instant getExpirationTimestamp();
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStoreManager.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
@@ -10,6 +10,7 @@
 import com.thinkaurelius.titan.diskstorage.locking.LockerProvider;
 import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 
+import java.time.Duration;
 import java.util.HashMap;
 import java.util.Map;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingTransaction.java
Patch:
@@ -5,7 +5,7 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.locking.LocalLockMediator;
@@ -18,6 +18,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.time.Duration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/LockCleanerService.java
Patch:
@@ -3,6 +3,8 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
 
+import java.time.Instant;
+
 public interface LockCleanerService {
-    public void clean(KeyColumn target, long cutoff, StoreTransaction tx);
+    public void clean(KeyColumn target, Instant cutoff, StoreTransaction tx);
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/Message.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 
+import java.time.Instant;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -23,7 +24,7 @@ public interface Message {
      * @param unit
      * @return
      */
-    public long getTimestamp(TimeUnit unit);
+    public Instant getTimestamp();
 
     /**
      * Returns the content of the message

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -24,7 +24,6 @@
 import com.thinkaurelius.titan.diskstorage.log.kcvs.KCVSLog;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
-import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.cache.SchemaCache;
@@ -65,6 +64,7 @@
 
 import javax.annotation.Nullable;
 import java.io.IOException;
+import java.time.Instant;
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutionException;
@@ -642,7 +642,7 @@ public void commit(final Collection<InternalRelation> addedRelations,
         //1. Finalize transaction
         log.debug("Saving transaction. Added {}, removed {}", addedRelations.size(), deletedRelations.size());
         if (!tx.getConfiguration().hasCommitTime()) tx.getConfiguration().setCommitTime(times.getTime());
-        final Timepoint txTimestamp = tx.getConfiguration().getCommitTime();
+        final Instant txTimestamp = tx.getConfiguration().getCommitTime();
         final long transactionId = txCounter.incrementAndGet();
 
         //2. Assign TitanVertex IDs
@@ -655,7 +655,7 @@ public void commit(final Collection<InternalRelation> addedRelations,
         final boolean hasTxIsolation = backend.getStoreFeatures().hasTxIsolation();
         final boolean logTransaction = config.hasLogTransactions() && !tx.getConfiguration().hasEnabledBatchLoading();
         final KCVSLog txLog = logTransaction?backend.getSystemTxLog():null;
-        final TransactionLogHeader txLogHeader = new TransactionLogHeader(transactionId,txTimestamp);
+        final TransactionLogHeader txLogHeader = new TransactionLogHeader(transactionId,txTimestamp, times);
         ModificationSummary commitSummary;
 
         try {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/IDBlockSizer.java
Patch:
@@ -7,7 +7,7 @@
 public interface IDBlockSizer {
 
     /**
-     * The size of the id block to be returned by calls {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, com.thinkaurelius.titan.core.attribute.Duration)}
+     * The size of the id block to be returned by calls {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, Duration)}
      * for the given id namespace.
      * In other words, for the returned array of the above mentioned call, it must hold that the difference between the second
      * and first value is equal to the block size returned by this method (for the same partition id).
@@ -18,7 +18,7 @@ public interface IDBlockSizer {
     public long getBlockSize(int idNamespace);
 
     /**
-     * Returns the upper bound for any id block returned by {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, com.thinkaurelius.titan.core.attribute.Duration)}
+     * Returns the upper bound for any id block returned by {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, Duration)}
      * for the given id namespace.
      * In other words, it must hold that the second value of the returned array is smaller than this value for the same partition id.
      *

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.graphdb.relations.EdgeDirection;
 import com.thinkaurelius.titan.graphdb.relations.ReassignableRelation;
 import com.thinkaurelius.titan.util.stats.NumberUtil;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.Backend;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
@@ -27,6 +27,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.time.Duration;
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/GraphIndexStatusReport.java
Patch:
@@ -1,8 +1,9 @@
 package com.thinkaurelius.titan.graphdb.database.management;
 
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 
+import java.time.Duration;
 import java.util.Map;
 
 public class GraphIndexStatusReport {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/RelationIndexStatusReport.java
Patch:
@@ -1,8 +1,10 @@
 package com.thinkaurelius.titan.graphdb.database.management;
 
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 
+import java.time.Duration;
+
 public class RelationIndexStatusReport {
 
     private final boolean succeeded;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/FakeLock.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.core.attribute.Duration;
+
+import java.time.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/TransactionLock.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.core.attribute.Duration;
+
+import java.time.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/util/system/ConfigurationPrinter.java
Patch:
@@ -3,6 +3,7 @@
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -12,7 +13,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.collect.Iterables;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.core.util.ReflectiveConfigOptionLoader;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigElement;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigNamespace;
@@ -212,7 +213,7 @@ private String getStringForDefaultValue(ConfigOption<?> c) {
             return "(no default value)";
         } else if (o instanceof Duration) {
             Duration d = (Duration)o;
-            return d.getLength(TimeUnit.MILLISECONDS) + " ms";
+            return d.toMillis() + " ms";
         } else if (o instanceof String[]) {
             return Joiner.on(",").join((String[])o);
         }

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/CassandraScanJobIT.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.scan.ScanJob;
 import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
-import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProviders;
 import com.thinkaurelius.titan.graphdb.TitanGraphBaseTest;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
@@ -51,7 +51,7 @@ public void testSimpleScan()
 
         KeyColumnValueStoreManager mgr = new CassandraThriftStoreManager(GraphDatabaseConfiguration.buildGraphConfiguration());
         KeyColumnValueStore store = mgr.openDatabase("edgestore");
-        StoreTransaction tx = mgr.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MICRO));
+        StoreTransaction tx = mgr.beginTransaction(StandardBaseTransactionConfig.of(TimestampProviders.MICRO));
         KeyColumnValueStoreUtil.loadValues(store, tx, values);
         tx.commit(); // noop on Cassandra, but harmless
 

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -13,7 +13,7 @@ public class SolrRunner {
     protected static final int NUM_SERVERS = 1;
     protected static final String[] COLLECTIONS = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee",
             "composite", "psearch", "esearch", "vsearch", "mi", "mixed", "index1", "index2", "index3",
-            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "booleanIndex", "dateIndex", "uuidIndex" };
+            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "booleanIndex", "dateIndex", "instantIndex", "uuidIndex" };
 
     protected static final String[] KEY_FIELDS = new String[0];
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/AbstractKCVSTest.java
Patch:
@@ -2,15 +2,15 @@
 
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreManager;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
-import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProviders;
 import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public class AbstractKCVSTest {
 
-    protected static final TimestampProvider times = Timestamps.MICRO;
+    protected static final TimestampProvider times = TimestampProviders.MICRO;
 
     protected StandardBaseTransactionConfig getTxConfig() {
         return StandardBaseTransactionConfig.of(times);

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/log/KCVSLogTest.java
Patch:
@@ -1,13 +1,14 @@
 package com.thinkaurelius.titan.diskstorage.log;
 
+import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 
 import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreManager;
 import com.thinkaurelius.titan.diskstorage.log.kcvs.KCVSLogManager;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
 /**
@@ -29,7 +30,7 @@ public LogManager openLogManager(String senderId, boolean requiresOrderPreservin
         storeManager = openStorageManager();
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();
         config.set(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID,senderId);
-        config.set(GraphDatabaseConfiguration.LOG_READ_INTERVAL, new StandardDuration(500L, TimeUnit.MILLISECONDS), LOG_NAME);
+        config.set(GraphDatabaseConfiguration.LOG_READ_INTERVAL, Duration.ofMillis(500L), LOG_NAME);
         //To ensure that the write order is preserved in reading, we need to ensure that all writes go to the same partition
         //otherwise readers will independently read from the partitions out-of-order by design to avoid having to synchronize
         config.set(KCVSLogManager.LOG_FIXED_PARTITION, requiresOrderPreserving, LOG_NAME);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeBenchmark.java
Patch:
@@ -14,7 +14,7 @@
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
-import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProviders;
 import com.thinkaurelius.titan.graphdb.types.StandardEdgeLabelMaker;
 import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 
@@ -50,7 +50,7 @@ public void testDataSequential() throws Exception {
         SliceQuery query = new SliceQuery(BufferUtil.zeroBuffer(8),BufferUtil.oneBuffer(8));
         query.setLimit(2);
         Stopwatch watch = Stopwatch.createStarted();
-        StoreTransaction txh = manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MILLI));
+        StoreTransaction txh = manager.beginTransaction(StandardBaseTransactionConfig.of(TimestampProviders.MILLI));
         KeyIterator iter = store.getKeys(query,txh);
         int numV = 0;
         while(iter.hasNext()) {

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/KCVSConfigTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.configuration;
 
 import com.thinkaurelius.titan.diskstorage.BackendException;
-import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProviders;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.KCVSConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
@@ -19,12 +19,12 @@ public class KCVSConfigTest extends WritableConfigurationTest {
     public WriteConfiguration getConfig() {
         final KeyColumnValueStoreManager manager = new InMemoryStoreManager(Configuration.EMPTY);
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();
-        config.set(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER,Timestamps.MICRO);
+        config.set(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER, TimestampProviders.MICRO);
         try {
             return new KCVSConfiguration(new BackendOperation.TransactionalProvider() {
                 @Override
                 public StoreTransaction openTx() throws BackendException {
-                    return manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MICRO, manager.getFeatures().getKeyConsistentTxConfig()));
+                    return manager.beginTransaction(StandardBaseTransactionConfig.of(TimestampProviders.MICRO, manager.getFeatures().getKeyConsistentTxConfig()));
                 }
 
                 @Override

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/MockIDAuthority.java
Patch:
@@ -3,14 +3,15 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import com.thinkaurelius.titan.diskstorage.*;
-import com.thinkaurelius.titan.core.attribute.Duration;
+
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDPoolExhaustedException;
 import com.thinkaurelius.titan.graphdb.database.idassigner.StaticIDBlockSizer;
 
+import java.time.Duration;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.core.TitanVertex;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StandardStoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
@@ -21,6 +21,7 @@
 import org.junit.runners.Parameterized;
 import static org.junit.Assert.*;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -89,7 +90,7 @@ private static TitanGraph getInMemoryGraph() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, InMemoryStoreManager.class.getCanonicalName());
         config.set(GraphDatabaseConfiguration.IDS_FLUSH, false);
-        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT, new StandardDuration(1L, TimeUnit.MILLISECONDS));
+        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT, Duration.ofMillis(1L));
         return TitanFactory.open(config);
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -1574,9 +1574,9 @@ public void testPropertyCardinality() {
 
         newTx();
 
-        assertCount(0, Iterables.size(tx.query().has("name", "name1").vertices()));
-        assertCount(1, Iterables.size(tx.query().has("name", "name2").vertices()));
-        assertCount(1, Iterables.size(tx.query().has("uid", 512).vertices()));
+        assertCount(0, tx.query().has("name", "name1").vertices());
+        assertCount(1, tx.query().has("name", "name2").vertices());
+        assertCount(1, tx.query().has("uid", 512).vertices());
     }
 
     /**

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -156,7 +156,7 @@ public BerkeleyJEKeyValueStore openDatabase(String name) throws BackendException
         }
         try {
             DatabaseConfig dbConfig = new DatabaseConfig();
-            dbConfig.setReadOnly(isReadOnly);
+            dbConfig.setReadOnly(false);
             dbConfig.setAllowCreate(true);
             dbConfig.setTransactional(transactional);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/AbstractStoreManager.java
Patch:
@@ -22,12 +22,10 @@
 public abstract class AbstractStoreManager implements StoreManager {
 
     protected final boolean transactional;
-    protected final boolean isReadOnly;
     protected final boolean batchLoading;
     protected final Configuration storageConfig;
 
     public AbstractStoreManager(Configuration storageConfig) {
-        isReadOnly = storageConfig.get(STORAGE_READONLY);
         batchLoading = storageConfig.get(STORAGE_BATCH);
         boolean transactional = storageConfig.get(STORAGE_TRANSACTIONAL);
         if (batchLoading) {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/MapReduceIndexJobs.java
Patch:
@@ -144,10 +144,11 @@ private static ModifiableConfiguration getIndexJobConf(String indexName, String
     }
 
     private static void copyPropertiesToInputAndOutputConf(org.apache.hadoop.conf.Configuration sink, Properties source) {
+        final String prefix = ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS, true) + ".";
         for (Map.Entry<Object, Object> e : source.entrySet()) {
             String k;
             String v = e.getValue().toString();
-            k = ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + e.getKey().toString();
+            k = prefix + e.getKey().toString();
             sink.set(k, v);
             log.info("Set {}={}", k, v);
         }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/CassandraHadoopScanRunner.java
Patch:
@@ -45,8 +45,9 @@ public ScanMetrics run() throws InterruptedException, IOException, ClassNotFound
 
         if (null != titanConf) {
             for (String k : titanConf.getKeys("")) {
-                hadoopConf.set(ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
-                log.debug("Set: {}={}", ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k,
+                String prefix = ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS, true) + ".";
+                hadoopConf.set(prefix + k, titanConf.get(k, Object.class).toString());
+                log.debug("Set: {}={}", prefix + k,
                         titanConf.<Object>get(k, Object.class).toString());
             }
         }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HBaseHadoopScanRunner.java
Patch:
@@ -36,10 +36,10 @@ public ScanMetrics run() throws InterruptedException, IOException, ClassNotFound
                 baseHadoopConf : new org.apache.hadoop.conf.Configuration();
 
         if (null != titanConf) {
+            String prefix = ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS, true) + ".";
             for (String k : titanConf.getKeys("")) {
-                hadoopConf.set(ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
-                log.debug("Set: {}={}", ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k,
-                        titanConf.<Object>get(k, Object.class).toString());
+                hadoopConf.set(prefix + k, titanConf.get(k, Object.class).toString());
+                log.debug("Set: {}={}", prefix + k, titanConf.get(k, Object.class).toString());
             }
         }
         Preconditions.checkNotNull(hadoopConf);

File: titan-hadoop-parent/titan-hadoop-1/src/main/java/com/thinkaurelius/titan/hadoop/formats/TitanH1OutputFormat.java
Patch:
@@ -44,7 +44,7 @@ public RecordWriter<NullWritable, VertexWritable> getRecordWriter(TaskAttemptCon
                 Configuration hadoopConf = taskAttemptContext.getConfiguration();
                 ModifiableHadoopConfiguration mhc =
                         ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, hadoopConf);
-                graph = (StandardTitanGraph) TitanFactory.open(mhc.getTitanInputConf());
+                graph = (StandardTitanGraph) TitanFactory.open(mhc.getTitanGraphConf());
             }
         }
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/MapReduceIndexJobs.java
Patch:
@@ -147,7 +147,7 @@ private static void copyPropertiesToInputAndOutputConf(org.apache.hadoop.conf.Co
         for (Map.Entry<Object, Object> e : source.entrySet()) {
             String k;
             String v = e.getValue().toString();
-            k = ConfigElement.getPath(TitanHadoopConfiguration.TITAN_INPUT_CONFIG_KEYS) + "." + e.getKey().toString();
+            k = ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + e.getKey().toString();
             sink.set(k, v);
             log.info("Set {}={}", k, v);
         }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/MapReduceIndexManagement.java
Patch:
@@ -161,7 +161,7 @@ public TitanManagement.IndexJobFuture updateIndex(TitanIndex index, SchemaAction
         copyIndexJobKeys(hadoopConf, indexName, relationTypeName);
         titanmrConf.set(TitanHadoopConfiguration.SCAN_JOB_CONFIG_ROOT,
                 GraphDatabaseConfiguration.class.getName() + "#JOB_NS");
-        // Copy the StandardTitanGraph configuration under TitanHadoopConfiguration.TITAN_INPUT_CONFIG_KEYS
+        // Copy the StandardTitanGraph configuration under TitanHadoopConfiguration.GRAPH_CONFIG_KEYS
         org.apache.commons.configuration.Configuration localbc = graph.getConfiguration().getLocalConfiguration();
         localbc.clearProperty(Graph.GRAPH);
         copyInputKeys(hadoopConf, localbc);
@@ -191,7 +191,7 @@ private static void copyInputKeys(org.apache.hadoop.conf.Configuration hadoopCon
             if (!pid.element.isOption())
                 continue;
 
-            String k = ConfigElement.getPath(TitanHadoopConfiguration.TITAN_INPUT_CONFIG_KEYS) + "." + key;
+            String k = ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + key;
             String v = source.getProperty(key).toString();
 
             hadoopConf.set(k, v);

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/AbstractBinaryInputFormat.java
Patch:
@@ -20,7 +20,7 @@ public void setConf(final Configuration config) {
 
         this.mrConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
         this.hadoopConf = config;
-        this.titanConf = mrConf.getTitanInputConf();
+        this.titanConf = mrConf.getTitanGraphConf();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -4,7 +4,6 @@
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.RelationReader;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
@@ -35,7 +34,7 @@ public class TitanHadoopSetupImpl extends TitanHadoopSetupCommon {
 
     public TitanHadoopSetupImpl(final Configuration config) {
         scanConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
-        BasicConfiguration bc = scanConf.getTitanInputConf();
+        BasicConfiguration bc = scanConf.getTitanGraphConf();
         graph = (StandardTitanGraph) TitanFactory.open(bc);
         tx = (StandardTitanTx)graph.buildTransaction().readOnly().vertexCacheSize(200).start();
     }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/CassandraHadoopScanRunner.java
Patch:
@@ -45,8 +45,9 @@ public ScanMetrics run() throws InterruptedException, IOException, ClassNotFound
 
         if (null != titanConf) {
             for (String k : titanConf.getKeys("")) {
-                hadoopConf.set(ConfigElement.getPath(TitanHadoopConfiguration.TITAN_INPUT_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
-                log.error("Set: {}={}", ConfigElement.getPath(TitanHadoopConfiguration.TITAN_INPUT_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
+                hadoopConf.set(ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
+                log.debug("Set: {}={}", ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k,
+                        titanConf.<Object>get(k, Object.class).toString());
             }
         }
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HBaseHadoopScanRunner.java
Patch:
@@ -37,8 +37,9 @@ public ScanMetrics run() throws InterruptedException, IOException, ClassNotFound
 
         if (null != titanConf) {
             for (String k : titanConf.getKeys("")) {
-                hadoopConf.set(ConfigElement.getPath(TitanHadoopConfiguration.TITAN_INPUT_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
-                log.error("Set: {}={}", ConfigElement.getPath(TitanHadoopConfiguration.TITAN_INPUT_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
+                hadoopConf.set(ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k, titanConf.<Object>get(k, Object.class).toString());
+                log.debug("Set: {}={}", ConfigElement.getPath(TitanHadoopConfiguration.GRAPH_CONFIG_KEYS) + "." + k,
+                        titanConf.<Object>get(k, Object.class).toString());
             }
         }
         Preconditions.checkNotNull(hadoopConf);

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanMapper.java
Patch:
@@ -219,7 +219,7 @@ private ScanJob getJob(Configuration scanConf) {
 
     static ModifiableConfiguration getTitanConfiguration(Context context) {
         org.apache.hadoop.conf.Configuration hadoopConf = DEFAULT_COMPAT.getContextConfiguration(context);
-        return ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, hadoopConf).getTitanInputConf();
+        return ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, hadoopConf).getTitanGraphConf();
     }
 
     static Configuration getJobConfiguration(ModifiableHadoopConfiguration scanConf) {

File: titan-core/src/main/java/com/thinkaurelius/titan/example/GraphOfTheGodsFactory.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
 import com.thinkaurelius.titan.core.schema.TitanGraphIndex;
 import com.thinkaurelius.titan.core.schema.TitanManagement;
-import org.apache.tinkerpop.gremlin.process.traversal.T;
+import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.tinkerpop.gremlin.structure.Edge;
 import org.apache.tinkerpop.gremlin.structure.Order;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -40,7 +40,6 @@
 import com.thinkaurelius.titan.graphdb.types.StandardEdgeLabelMaker;
 import com.thinkaurelius.titan.graphdb.types.StandardPropertyKeyMaker;
 import com.thinkaurelius.titan.graphdb.types.StandardRelationTypeMaker;
-import com.thinkaurelius.titan.graphdb.types.StandardVertexLabelMaker;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionDescription;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionMap;
@@ -848,7 +847,7 @@ private void setStatusVertex(TitanSchemaVertex vertex, SchemaStatus status) {
             }
         }
         //Add new status
-        TitanVertexProperty p = transaction.addPropertyInternal(vertex, BaseKey.SchemaDefinitionProperty, status);
+        TitanVertexProperty p = transaction.addProperty(vertex, BaseKey.SchemaDefinitionProperty, status);
         p.property(BaseKey.SchemaDefinitionDesc.name(), TypeDefinitionDescription.of(TypeDefinitionCategory.STATUS));
     }
 
@@ -996,7 +995,7 @@ public void changeName(TitanSchemaElement element, String newName) {
             checkIndexName(newName);
         }
 
-        transaction.addPropertyInternal(schemaVertex, BaseKey.SchemaName, schemaCategory.getSchemaName(newName));
+        transaction.addProperty(schemaVertex, BaseKey.SchemaName, schemaCategory.getSchemaName(newName));
         updateSchemaVertex(schemaVertex);
         schemaVertex.resetCache();
         updatedTypes.add(schemaVertex);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraVertexProperty.java
Patch:
@@ -94,7 +94,7 @@ public boolean isRemoved() {
 
     @Override
     public <V> V value(String key) {
-        throw Property.Exceptions.propertyDoesNotExist(key);
+        throw Property.Exceptions.propertyDoesNotExist(this,key);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexProgramScanJob.java
Patch:
@@ -93,7 +93,7 @@ public void process(TitanVertex vertex, ScanMetrics metrics) {
             for (MessageScope scope : vertexMemory.getPreviousScopes()) {
                 if (scope instanceof MessageScope.Local) {
                     M combinedMsg = null;
-                    for (Iterator<M> msgIter = vh.receiveMessages(scope); msgIter.hasNext(); ) {
+                    for (Iterator<M> msgIter = vh.receiveMessages(scope).iterator(); msgIter.hasNext(); ) {
                         M msg = msgIter.next();
                         if (combinedMsg==null) combinedMsg=msg;
                         else combinedMsg = combiner.combine(combinedMsg,msg);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexRemoveJob.java
Patch:
@@ -115,7 +115,7 @@ public void process(StaticBuffer key, Map<SliceQuery, EntryList> entries, ScanMe
             final List<Entry> deletions;
             if (entries.size()==1) deletions = Iterables.getOnlyElement(entries.values());
             else {
-                int size = StreamFactory.stream(entries.values()).map( e -> e.size()).reduce(0, (x,y) -> x+y);
+                int size = StreamFactory.stream(entries.values().iterator()).map( e -> e.size()).reduce(0, (x,y) -> x+y);
                 deletions = new ArrayList<>(size);
                 entries.values().forEach(e -> deletions.addAll(e));
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -123,7 +123,7 @@ public <O> O valueOrNull(PropertyKey key) {
     public <O> O value(String key) {
         verifyAccess();
         O val = valueInternal(tx().getPropertyKey(key));
-        if (val==null) throw Property.Exceptions.propertyDoesNotExist(key);
+        if (val==null) throw Property.Exceptions.propertyDoesNotExist(this,key);
         return val;
     }
 
@@ -141,7 +141,7 @@ public <V> Iterator<Property<V>> properties(final String... keyNames) {
         Stream<PropertyKey> keys;
 
         if (keyNames==null || keyNames.length==0) {
-            keys = StreamFactory.stream(it().getPropertyKeysDirect());
+            keys = StreamFactory.stream(it().getPropertyKeysDirect().iterator());
         } else {
             keys = Stream.of(keyNames)
                     .map(s -> tx().getPropertyKey(s)).filter(rt -> rt != null && getValueDirect(rt)!=null);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheVertexProperty.java
Patch:
@@ -5,7 +5,6 @@
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
 import com.thinkaurelius.titan.core.PropertyKey;
-import com.thinkaurelius.titan.core.RelationType;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
@@ -61,7 +60,7 @@ private synchronized InternalRelation update() {
         copyProperties(copy);
         copy.remove();
 
-        StandardVertexProperty u = (StandardVertexProperty) tx().addPropertyInternal(getVertex(0), propertyKey(), value());
+        StandardVertexProperty u = (StandardVertexProperty) tx().addProperty(getVertex(0), propertyKey(), value());
         if (type.getConsistencyModifier()!= ConsistencyModifier.FORK) u.setId(super.longId());
         u.setPreviousID(super.longId());
         copyProperties(u);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/computer/bulkloader/BulkLoaderVertexProgram.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.core.schema.TitanManagement;
 import com.thinkaurelius.titan.util.system.IOUtils;
 import org.apache.tinkerpop.gremlin.process.computer.GraphComputer;
-import org.apache.tinkerpop.gremlin.process.traversal.T;
+import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.process.computer.Memory;
 import org.apache.tinkerpop.gremlin.process.computer.MessageScope;
 import org.apache.tinkerpop.gremlin.process.computer.Messenger;
@@ -146,7 +146,7 @@ public void execute(final Vertex vertex, final Messenger<long[]> messenger, fina
         } else {
             // create a id/titan_id map and populate it with all the incoming messages
             final Map<Long, Long> idPairs = new HashMap<>();
-            messenger.receiveMessages(this.messageScope).forEachRemaining(idPair -> idPairs.put(idPair[0], idPair[1]));
+            messenger.receiveMessages().forEachRemaining(idPair -> idPairs.put(idPair[0], idPair[1]));
             // get the titan vertex out of titan given the dummy id property
             Object vid = vertex.value(TITAN_ID);
             final Vertex titanVertex = graph.vertices(vid).next();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanGraphStep.java
Patch:
@@ -28,8 +28,7 @@ public class TitanGraphStep<E extends Element> extends GraphStep<E> implements H
 
     public TitanGraphStep(final GraphStep<E> originalStep) {
         super(originalStep.getTraversal(), originalStep.getReturnClass(), originalStep.getIds());
-        if (originalStep.getLabel().isPresent())
-            this.setLabel(originalStep.getLabel().get());
+        originalStep.getLabels().forEach(this::addLabel);
         this.setIteratorSupplier(() -> {
             TitanTransaction tx = TitanTraversalUtil.getTx(traversal);
             TitanGraphQuery query = tx.query();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanPropertiesStep.java
Patch:
@@ -29,8 +29,7 @@ public class TitanPropertiesStep<E> extends PropertiesStep<E> implements HasStep
 
     public TitanPropertiesStep(PropertiesStep<E> originalStep) {
         super(originalStep.getTraversal(), originalStep.getReturnType(), originalStep.getPropertyKeys());
-        if (originalStep.getLabel().isPresent())
-            this.setLabel(originalStep.getLabel().get());
+        originalStep.getLabels().forEach(this::addLabel);
         this.hasContainers = new ArrayList<>();
         this.limit = Query.NO_LIMIT;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanVertexStep.java
Patch:
@@ -23,8 +23,7 @@ public class TitanVertexStep<E extends Element> extends VertexStep<E> implements
 
     public TitanVertexStep(VertexStep<E> originalStep) {
         super(originalStep.getTraversal(), originalStep.getReturnClass(), originalStep.getDirection(), originalStep.getEdgeLabels());
-        if (originalStep.getLabel().isPresent())
-            this.setLabel(originalStep.getLabel().get());
+        originalStep.getLabels().forEach(this::addLabel);
         this.hasContainers = new ArrayList<>();
         this.limit = Query.NO_LIMIT;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.graphdb.internal.*;
-import org.apache.tinkerpop.gremlin.process.traversal.T;
+import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.commons.lang.StringUtils;
 import static com.thinkaurelius.titan.graphdb.internal.Token.*;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/TitanVertexDeserializer.java
Patch:
@@ -12,7 +12,7 @@
 import com.thinkaurelius.titan.graphdb.types.TypeInspector;
 import com.thinkaurelius.titan.hadoop.formats.util.input.SystemTypeInspector;
 import com.thinkaurelius.titan.hadoop.formats.util.input.TitanHadoopSetup;
-import org.apache.tinkerpop.gremlin.process.traversal.T;
+import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerEdge;
 import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -23,7 +23,7 @@
 import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 import com.thinkaurelius.titan.testutil.TestGraphConfigs;
 
-import org.apache.tinkerpop.gremlin.process.traversal.T;
+import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.Edge;
 import org.apache.tinkerpop.gremlin.structure.Element;
 import org.apache.tinkerpop.gremlin.structure.Vertex;

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -287,7 +287,7 @@ public void execute(Vertex vertex, Messenger<Integer> messenger, Memory memory)
             if (memory.isInitialIteration()) {
                 messenger.sendMessage(DEG_MSG, 1);
             } else {
-                int degree = StreamFactory.stream(messenger.receiveMessages(DEG_MSG)).reduce(0, (a, b) -> a + b);
+                int degree = StreamFactory.stream(messenger.receiveMessages()).reduce(0, (a, b) -> a + b);
                 vertex.property(VertexProperty.Cardinality.single, DEGREE, degree);
                 if (memory.getIteration()<length) messenger.sendMessage(DEG_MSG, degree);
             }

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/PageRankVertexProgram.java
Patch:
@@ -76,12 +76,12 @@ public void execute(Vertex vertex, Messenger<Double> messenger, Memory memory) {
             messenger.sendMessage(inE, 1D);
         } else if (1 == memory.getIteration()) {
             double initialPageRank = 1D / vertexCount;
-            double edgeCount = StreamFactory.stream(messenger.receiveMessages(inE)).reduce(0D, (a, b) -> a + b);
+            double edgeCount = StreamFactory.stream(messenger.receiveMessages()).reduce(0D, (a, b) -> a + b);
             vertex.property(VertexProperty.Cardinality.single, PAGE_RANK, initialPageRank);
             vertex.property(VertexProperty.Cardinality.single, OUTGOING_EDGE_COUNT, edgeCount);
             messenger.sendMessage(outE, initialPageRank / edgeCount);
         } else {
-            double newPageRank = StreamFactory.stream(messenger.receiveMessages(outE)).reduce(0D, (a, b) -> a + b);
+            double newPageRank = StreamFactory.stream(messenger.receiveMessages()).reduce(0D, (a, b) -> a + b);
             newPageRank =  (dampingFactor * newPageRank) + ((1D - dampingFactor) / vertexCount);
             vertex.property(VertexProperty.Cardinality.single, PAGE_RANK, newPageRank);
             messenger.sendMessage(outE, newPageRank / vertex.<Double>value(OUTGOING_EDGE_COUNT));

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/ShortestDistanceVertexProgram.java
Patch:
@@ -118,7 +118,7 @@ public void execute(final Vertex vertex, Messenger<Long> messenger, final Memory
                 messenger.sendMessage(incidentMessageScope, 0L);
             }
         } else {
-            Iterator<Long> distances = messenger.receiveMessages(incidentMessageScope);
+            Iterator<Long> distances = messenger.receiveMessages();
 
             // Find minimum distance among all incoming messages, or null if no messages came in
             Long shortestDistanceSeenOnThisIteration =

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -92,7 +92,6 @@ public synchronized void remove() {
         //Remove all system types on the vertex
         for (TitanRelation r : it().query().noPartitionRestriction().system().relations()) {
             RelationType t = r.getType();
-            assert t==BaseLabel.VertexLabelEdge || t==BaseKey.VertexExists;
             r.remove();
         }
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/computer/bulkloader/BulkLoaderVertexProgram.java
Patch:
@@ -35,7 +35,7 @@
  */
 public class BulkLoaderVertexProgram implements VertexProgram<long[]> {
 
-    // TODO: Be sure to accont for hidden properties --- though we may be changing the TP3 API soon for this.
+    // TODO: Be sure to account for hidden properties --- though we may be changing the TP3 API soon for this.
 
     private static final Logger LOGGER = LoggerFactory.getLogger(BulkLoaderVertexProgram.class);
 

File: titan-all/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/plugin/TitanGremlinPlugin.java
Patch:
@@ -11,6 +11,7 @@
 
 import java.util.HashSet;;
 import java.util.Set;
+import java.util.concurrent.TimeUnit;
 
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
@@ -34,6 +35,7 @@ public class TitanGremlinPlugin implements GremlinPlugin {
         add(IMPORT_STATIC + Text.class.getName() + DOT_STAR);
         add(IMPORT_STATIC + Multiplicity.class.getName() + DOT_STAR);
         add(IMPORT_STATIC + Cardinality.class.getName() + DOT_STAR);
+        add(IMPORT_STATIC + TimeUnit.class.getName() + DOT_STAR);
     }};
 
     @Override

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -29,6 +29,7 @@
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
 import com.thinkaurelius.titan.diskstorage.PermanentBackendException;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
+import com.thinkaurelius.titan.diskstorage.StoreMetaData;
 import com.thinkaurelius.titan.diskstorage.TemporaryBackendException;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigNamespace;
@@ -320,7 +321,7 @@ public void close() {
     }
 
     @Override
-    public synchronized AstyanaxKeyColumnValueStore openDatabase(String name) throws BackendException {
+    public synchronized AstyanaxKeyColumnValueStore openDatabase(String name, StoreMetaData.Container metaData) throws BackendException {
         if (openStores.containsKey(name)) return openStores.get(name);
         else {
             ensureColumnFamilyExists(name);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -112,7 +112,7 @@ public void close() {
     }
 
     @Override
-    public synchronized KeyColumnValueStore openDatabase(String name) throws BackendException {
+    public synchronized KeyColumnValueStore openDatabase(String name, StoreMetaData.Container metaData) throws BackendException {
         if (openStores.containsKey(name))
             return openStores.get(name);
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -326,7 +326,7 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
     }
 
     @Override // TODO: *BIG FAT WARNING* 'synchronized is always *bad*, change openStores to use ConcurrentLinkedHashMap
-    public synchronized CassandraThriftKeyColumnValueStore openDatabase(final String name) throws BackendException {
+    public synchronized CassandraThriftKeyColumnValueStore openDatabase(final String name, StoreMetaData.Container metaData) throws BackendException {
         if (openStores.containsKey(name))
             return openStores.get(name);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSManagerProxy.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
+import com.thinkaurelius.titan.diskstorage.StoreMetaData;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 
 import java.util.List;
@@ -52,8 +53,8 @@ public List<KeyRange> getLocalKeyPartition() throws BackendException {
     }
 
     @Override
-    public KeyColumnValueStore openDatabase(String name) throws BackendException {
-        return manager.openDatabase(name);
+    public KeyColumnValueStore openDatabase(String name, StoreMetaData.Container metaData) throws BackendException {
+        return manager.openDatabase(name, metaData);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
+import com.thinkaurelius.titan.diskstorage.StoreMetaData;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
@@ -79,7 +80,7 @@ public StoreFeatures getFeatures() {
     }
 
     @Override
-    public KeyColumnValueStore openDatabase(final String name) throws BackendException {
+    public KeyColumnValueStore openDatabase(final String name, StoreMetaData.Container metaData) throws BackendException {
         if (!stores.containsKey(name)) {
             stores.putIfAbsent(name, new InMemoryKeyColumnValueStore(name));
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/ttl/TTLKCVS.java
Patch:
@@ -23,7 +23,7 @@ public TTLKCVS(KeyColumnValueStore store, int ttl) {
 
     @Override
     public void mutate(StaticBuffer key, List<Entry> additions, List<StaticBuffer> deletions, StoreTransaction txh) throws BackendException {
-        TTLKVCSManager.applyTTL(additions,ttl);
+        TTLKCVSManager.applyTTL(additions, ttl);
         store.mutate(key, additions, deletions, unwrapTx(txh));
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -10,7 +10,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.StandardIndexProvider;
 import com.thinkaurelius.titan.diskstorage.StandardStoreManager;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.ttl.TTLKVCSManager;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.ttl.TTLKCVSManager;
 import com.thinkaurelius.titan.graphdb.tinkerpop.BlueprintsDefaultSchemaMaker;
 import com.thinkaurelius.titan.graphdb.tinkerpop.Tp3DefaultSchemaMaker;
 import com.thinkaurelius.titan.graphdb.database.management.ManagementSystem;
@@ -648,6 +648,7 @@ public boolean apply(@Nullable String s) {
             "Whether to include visibility in retrieved entries for storage backends that automatically annotated entries with timestamps",
             ConfigOption.Type.GLOBAL, true);
 
+
     // ################ CLUSTERING ###########################
     // ################################################
 
@@ -1446,7 +1447,7 @@ else if (globalWrite.has(ALLOW_STALE_CONFIG))
         Preconditions.checkArgument(!combinedConfig.has(LOG_SEND_DELAY,TRANSACTION_LOG) ||
                 combinedConfig.get(LOG_SEND_DELAY, TRANSACTION_LOG).isZeroLength(),"Send delay must be 0 for transaction log.");
         overwrite.set(LOG_SEND_DELAY, StandardDuration.ZERO,TRANSACTION_LOG);
-        if (!combinedConfig.has(LOG_STORE_TTL,TRANSACTION_LOG) && TTLKVCSManager.supportsStoreTTL(storeFeatures)) {
+        if (!combinedConfig.has(LOG_STORE_TTL,TRANSACTION_LOG) && TTLKCVSManager.supportsAnyTTL(storeFeatures)) {
             overwrite.set(LOG_STORE_TTL,TRANSACTION_LOG_DEFAULT_TTL,TRANSACTION_LOG);
         }
         //SYSTEM MANAGEMENT LOG: backend=default and send_delay=0 and key_consistent=true and fixed-partitions=true

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -1447,7 +1447,7 @@ else if (globalWrite.has(ALLOW_STALE_CONFIG))
         Preconditions.checkArgument(!combinedConfig.has(LOG_SEND_DELAY,TRANSACTION_LOG) ||
                 combinedConfig.get(LOG_SEND_DELAY, TRANSACTION_LOG).isZeroLength(),"Send delay must be 0 for transaction log.");
         overwrite.set(LOG_SEND_DELAY, StandardDuration.ZERO,TRANSACTION_LOG);
-        if (!combinedConfig.has(LOG_STORE_TTL,TRANSACTION_LOG) && TTLKCVSManager.supportsStoreTTL(storeFeatures)) {
+        if (!combinedConfig.has(LOG_STORE_TTL,TRANSACTION_LOG) && TTLKCVSManager.supportsAnyTTL(storeFeatures)) {
             overwrite.set(LOG_STORE_TTL,TRANSACTION_LOG_DEFAULT_TTL,TRANSACTION_LOG);
         }
         //SYSTEM MANAGEMENT LOG: backend=default and send_delay=0 and key_consistent=true and fixed-partitions=true

File: titan-all/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/plugin/TitanGremlinPlugin.java
Patch:
@@ -27,7 +27,7 @@ public class TitanGremlinPlugin implements GremlinPlugin {
         add(IMPORT + "com.thinkaurelius.titan.core.schema" + DOT_STAR);
         add(IMPORT + GraphOfTheGodsFactory.class.getName());
         add(IMPORT + BulkLoaderVertexProgram.class.getPackage().getName() + DOT_STAR);
-        add(IMPORT + "com.thinkaurelius.titan.hadoop.MapReduceIndexJobs");
+        add(IMPORT + "com.thinkaurelius.titan.hadoop.MapReduceIndexManagement");
 
         // Static imports on enum values used in query constraint expressions
         add(IMPORT_STATIC + Geo.class.getName() + DOT_STAR);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -131,6 +131,8 @@ public synchronized KeyColumnValueStore openDatabase(String name, StoreMetaData.
      * (unparameterized) type.
      */
     public List<KeyRange> getLocalKeyPartition() throws BackendException {
+        ensureKeyspaceExists(keySpaceName);
+
         @SuppressWarnings("rawtypes")
         Collection<Range<Token>> ranges = StorageService.instance.getLocalPrimaryRanges(keySpaceName);
         List<KeyRange> keyRanges = new ArrayList<KeyRange>(ranges.size());

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan;
 
 import static com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager.CASSANDRA_KEYSPACE;
-import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.CLUSTER_PARTITION;
 
 import java.io.File;
 import java.io.IOException;
@@ -59,7 +58,6 @@ public static ModifiableConfiguration getEmbeddedConfiguration(String ks) {
 
     public static ModifiableConfiguration getEmbeddedCassandraPartitionConfiguration(String ks) {
         ModifiableConfiguration config = getEmbeddedConfiguration(ks);
-        config.set(CLUSTER_PARTITION, true);
         config.set(IDS_FLUSH,false);
         return config;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDAuthority.java
Patch:
@@ -86,7 +86,7 @@ public ConsistentKeyIDAuthority(KeyColumnValueStore idStore, StoreManager manage
         this.waitGracePeriod = idApplicationWaitMS.multiply(0.1D);
         Preconditions.checkNotNull(times);
 
-        partitionBitWdith = config.has(CLUSTER_PARTITION)? NumberUtil.getPowerOf2(config.get(CLUSTER_MAX_PARTITIONS)):0;
+        partitionBitWdith = NumberUtil.getPowerOf2(config.get(CLUSTER_MAX_PARTITIONS));
         Preconditions.checkArgument(partitionBitWdith>=0 && partitionBitWdith<=16);
 
         uniqueIdBitWidth = config.get(IDAUTHORITY_CAV_BITS);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSUtil.java
Patch:
@@ -46,15 +46,15 @@ public static StaticBuffer get(KeyColumnValueStore store, StaticBuffer key, Stat
     }
 
     public static KeyIterator getKeys(KeyColumnValueStore store, StoreFeatures features, int keyLength, int sliceLength, StoreTransaction txh) throws BackendException {
-        return getKeys(store,new SliceQuery(BufferUtil.zeroBuffer(sliceLength), BufferUtil.oneBuffer(sliceLength)).setLimit(1),
+        return getKeys(store,new SliceQuery(BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(sliceLength)).setLimit(1),
                 features,keyLength,txh);
     }
 
     public static KeyIterator getKeys(KeyColumnValueStore store, SliceQuery slice, StoreFeatures features, int keyLength, StoreTransaction txh) throws BackendException {
         if (features.hasUnorderedScan()) {
             return store.getKeys(slice, txh);
         } else if (features.hasOrderedScan()) {
-            return store.getKeys(new KeyRangeQuery(BufferUtil.zeroBuffer(keyLength), BufferUtil.oneBuffer(keyLength), slice), txh);
+            return store.getKeys(new KeyRangeQuery(BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(keyLength), slice), txh);
         } else throw new UnsupportedOperationException("Provided stores does not support scan operations: " + store);
     }
 
@@ -71,7 +71,7 @@ public static boolean containsKeyColumn(KeyColumnValueStore store, StaticBuffer
         return get(store, key, column, txh) != null;
     }
 
-    private static final StaticBuffer START = BufferUtil.zeroBuffer(8), END = BufferUtil.oneBuffer(32);
+    private static final StaticBuffer START = BufferUtil.zeroBuffer(1), END = BufferUtil.oneBuffer(32);
 
     public static boolean containsKey(KeyColumnValueStore store, StaticBuffer key, StoreTransaction txh) throws BackendException {
         return containsKey(store,key,32,txh);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/scan/StandardScannerExecutor.java
Patch:
@@ -29,7 +29,7 @@ class StandardScannerExecutor extends AbstractFuture<ScanMetrics> implements Tit
             LoggerFactory.getLogger(StandardScannerExecutor.class);
 
     private static final int QUEUE_SIZE = 1000;
-    private static final int TIMEOUT_MS = 60000; // 60 seconds
+    private static final int TIMEOUT_MS = 180000; // 60 seconds
     private static final int MAX_KEY_LENGTH = 128; //in bytes
 
     private final ScanJob job;
@@ -93,8 +93,8 @@ public void run() {
                 //It is assumed that the first query is the grounding query if multiple queries exist
                 SliceQuery ground = queries.get(0);
                 StaticBuffer start = ground.getSliceStart();
-                Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(start.length())),
-                        "Expected start of first query to be all 0s: %s",start);
+                Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(1)),
+                        "Expected start of first query to be a single 0s: %s",start);
                 StaticBuffer end = ground.getSliceEnd();
                 Preconditions.checkArgument(end.equals(BufferUtil.oneBuffer(end.length())),
                         "Expected end of first query to be all 1s: %s",end);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/Timer.java
Patch:
@@ -50,7 +50,7 @@ public Timer stop() {
 
     public Duration elapsed() {
         if (null == start) {
-            return ZeroDuration.INSTANCE;
+            return StandardDuration.ZERO;
         }
         final Timepoint stopTime = (null==stop? times.getTime() : stop);
         return new StandardDuration(stopTime.getNativeTimestamp() - start.getNativeTimestamp(), times.getUnit());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StandardDurationSerializer.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
 import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StandardTimepointSerializer.java
Patch:
@@ -6,6 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardTimepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 
@@ -14,7 +15,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public class StandardTimepointSerializer implements AttributeSerializer<StandardTimepoint> {
+public class StandardTimepointSerializer implements AttributeSerializer<Timepoint> {
 
     private final LongSerializer longs = new LongSerializer();
     private final EnumSerializer<Timestamps> timestamp = new EnumSerializer<>(Timestamps.class);
@@ -27,7 +28,7 @@ public StandardTimepoint read(ScanBuffer buffer) {
     }
 
     @Override
-    public void write(WriteBuffer buffer, StandardTimepoint attribute) {
+    public void write(WriteBuffer buffer, Timepoint attribute) {
         TimestampProvider provider = attribute.getProvider();
         Preconditions.checkArgument(provider instanceof Timestamps,"Cannot serialize time point due to invalid provider: %s",attribute);
         timestamp.write(buffer, (Timestamps)provider);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -36,7 +36,7 @@ public class VertexJobConverter implements ScanJob {
     private static final Logger log =
             LoggerFactory.getLogger(VertexJobConverter.class);
 
-    protected static final SliceQuery VERTEX_EXISTS_QUERY = new SliceQuery(BufferUtil.zeroBuffer(4),BufferUtil.oneBuffer(4)).setLimit(1);
+    protected static final SliceQuery VERTEX_EXISTS_QUERY = new SliceQuery(BufferUtil.zeroBuffer(1),BufferUtil.oneBuffer(4)).setLimit(1);
 
     public static final String GHOST_VERTEX_COUNT = "ghost-vertices";
     /**
@@ -76,7 +76,7 @@ public static StandardTitanTx startTransaction(StandardTitanGraph graph) {
         txb.setPreloadedData(true);
         txb.checkInternalVertexExistence(false);
         txb.dirtyVertexSize(0);
-        txb.vertexCacheSize(500);
+        txb.vertexCacheSize(0);
         return (StandardTitanTx)txb.start();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/GhostVertexRemover.java
Patch:
@@ -32,7 +32,7 @@ public class GhostVertexRemover extends VertexJobConverter {
 
     private static final int RELATION_COUNT_LIMIT = 10000;
 
-    private static final SliceQuery EVERYTHING_QUERY = new SliceQuery(BufferUtil.zeroBuffer(4),BufferUtil.oneBuffer(4));
+    private static final SliceQuery EVERYTHING_QUERY = new SliceQuery(BufferUtil.zeroBuffer(1),BufferUtil.oneBuffer(4));
 
     public static final String REMOVED_RELATION_COUNT = "removed-relations";
     public static final String REMOVED_VERTEX_COUNT = "removed-vertices";

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexUpdateJob.java
Patch:
@@ -42,7 +42,7 @@ public abstract class IndexUpdateJob {
     public static final ConfigOption<String> INDEX_RELATION_TYPE = new ConfigOption<String>(INDEX_JOB_NS,"relation-type",
             "For a vertex-centric index, this is the name of the index associated with the " +
                     "relation type configured under index-name. This should remain empty for global graph indexes.",
-            ConfigOption.Type.LOCAL, "");
+            ConfigOption.Type.LOCAL, "", str -> null != str);
 
 
     protected String indexRelationTypeName = null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/MultiVertexCentricQueryBuilder.java
Patch:
@@ -87,7 +87,7 @@ protected<Q> Map<TitanVertex,Q> execute(RelationCategory returnType, ResultConst
                 for (InternalVertex v : vertices) {
                     if (isPartitionedVertex(v)) {
                         adjVertices.remove(v);
-                        adjVertices.addAll(allRepresentatives(v));
+                        adjVertices.addAll(allRequiredRepresentatives(v));
                     }
                 }
                 tx.executeMultiQuery(adjVertices, sq.getBackendQuery());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanBlueprintsGraph.java
Patch:
@@ -165,11 +165,13 @@ public TitanIndexQuery indexQuery(String indexName, String query) {
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(TitanVertex... vertices) {
         return getAutoStartTx().multiQuery(vertices);
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(Collection<TitanVertex> vertices) {
         return getAutoStartTx().multiQuery(vertices);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanPropertiesStep.java
Patch:
@@ -70,6 +70,7 @@ void makeVertrexProperties() {
         this.isVertexProperties = true;
     }
 
+    @SuppressWarnings("deprecation")
     private void initialize() {
         assert !initialized;
         initialized = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanVertexStep.java
Patch:
@@ -53,6 +53,7 @@ public<Q extends BaseVertexQuery> Q makeQuery(Q query) {
         return query;
     }
 
+    @SuppressWarnings("deprecation")
     private void initialize() {
         assert !initialized;
         initialized = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -1005,13 +1005,15 @@ public VertexCentricQueryBuilder query(TitanVertex vertex) {
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(TitanVertex... vertices) {
         MultiVertexCentricQueryBuilder builder = new MultiVertexCentricQueryBuilder(this);
         for (TitanVertex v : vertices) builder.addVertex(v);
         return builder;
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(Collection<TitanVertex> vertices) {
         MultiVertexCentricQueryBuilder builder = new MultiVertexCentricQueryBuilder(this);
         builder.addAllVertices(vertices);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/PreloadedVertex.java
Patch:
@@ -72,7 +72,7 @@ public List<InternalRelation> getAddedRelations(Predicate<InternalRelation> quer
 
     @Override
     public VertexCentricQueryBuilder query() {
-        if (super.getQueryCacheSize()>0) return super.query();
+        if (super.getQueryCacheSize()>0) return super.query().queryOnlyGivenVertex();
         else throw stubVertexException();
     }
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/compat/HadoopCompat.java
Patch:
@@ -119,4 +119,6 @@ public interface HadoopCompat {
     public Configuration newImmutableConfiguration(Configuration base);
 
     public ScanMetrics getMetrics(Counters c);
+
+    public String getJobFailureString(Job j);
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/AbstractBinaryInputFormat.java
Patch:
@@ -3,7 +3,6 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import org.apache.hadoop.conf.Configurable;
@@ -13,14 +12,15 @@
 public abstract class AbstractBinaryInputFormat extends InputFormat<StaticBuffer, Iterable<Entry>> implements Configurable {
 
     protected Configuration hadoopConf;
+    protected ModifiableHadoopConfiguration mrConf;
     protected ModifiableConfiguration titanConf;
 
     @Override
     public void setConf(final Configuration config) {
 
-        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
+        this.mrConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
         this.hadoopConf = config;
-        this.titanConf = faunusConf.getTitanInputConf();
+        this.titanConf = mrConf.getTitanInputConf();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanMapper.java
Patch:
@@ -72,7 +72,7 @@ protected void finishSetup(ModifiableHadoopConfiguration scanConf, Configuration
         if (0 < subsequentQueries.size()) {
             //It is assumed that the first query is the grounding query if multiple queries exist
             StaticBuffer start = initialQuery.getSliceStart();
-            Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(start.length())),
+            Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(1)),
                     "Expected start of first query to be all 0s: %s", start);
             StaticBuffer end = initialQuery.getSliceEnd();
             Preconditions.checkArgument(end.equals(BufferUtil.oneBuffer(end.length())),
@@ -228,7 +228,8 @@ static Configuration getJobConfiguration(ModifiableHadoopConfiguration scanConf)
             return null;
         }
         ConfigNamespace jobRoot = getJobRoot(scanConf.get(TitanHadoopConfiguration.SCAN_JOB_CONFIG_ROOT));
-        return ModifiableHadoopConfiguration.subset(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS, scanConf);
+        return ModifiableHadoopConfiguration.prefixView(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS,
+                scanConf);
     }
 
     static ConfigNamespace getJobRoot(String confRootName) {

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -715,7 +715,7 @@ private final byte[] zeroExtend(byte[] dataToPad) {
         return padded;
     }
 
-    private String shortenCfName(String longName) throws PermanentBackendException {
+    public static String shortenCfName(String longName) throws PermanentBackendException {
         final String s;
         if (SHORT_CF_NAME_MAP.containsKey(longName)) {
             s = SHORT_CF_NAME_MAP.get(longName);

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/HBaseStorageSetup.java
Patch:
@@ -76,7 +76,6 @@ public static ModifiableConfiguration getHBaseConfiguration(String tableName) {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, "hbase");
         if (!StringUtils.isEmpty(tableName)) config.set(HBaseStoreManager.HBASE_TABLE,tableName);
-        config.set(GraphDatabaseConfiguration.CLUSTER_PARTITION, true);
         config.set(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER, HBaseStoreManager.PREFERRED_TIMESTAMPS);
         config.set(SimpleBulkPlacementStrategy.CONCURRENT_PARTITIONS, 1);
 //        config.set(GraphDatabaseConfiguration.STORAGE_NS.getName()+"."+HBaseStoreManager.HBASE_CONFIGURATION_NAMESPACE+

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneExample.java
Patch:
@@ -65,8 +65,8 @@ private SpatialStrategy getSpatialStrategy(String key) {
     @Test
     public void example1() throws Exception {
         Directory dir = FSDirectory.open(path);
-        Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_41);
-        IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_41, analyzer);
+        Analyzer analyzer = new StandardAnalyzer();
+        IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);
 
         iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);
         IndexWriter writer = new IndexWriter(dir, iwc);
@@ -93,7 +93,7 @@ public void example1() throws Exception {
         //Search
         IndexReader reader = DirectoryReader.open(FSDirectory.open(path));
         IndexSearcher searcher = new IndexSearcher(reader);
-        analyzer = new StandardAnalyzer(Version.LUCENE_41);
+        analyzer = new StandardAnalyzer();
 
         //Auesee
         BooleanFilter filter = new BooleanFilter();

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/BerkeleySolrTest.java
Patch:
@@ -22,6 +22,7 @@ public WriteConfiguration getConfiguration() {
         //Add index
         config.set(INDEX_BACKEND,"solr",INDEX);
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), INDEX);
+        config.set(SolrIndex.WAIT_SEARCHER, true, INDEX);
         //TODO: set SOLR specific config options
         return config.getConfiguration();
     }

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/ThriftSolrTest.java
Patch:
@@ -22,7 +22,7 @@ public WriteConfiguration getConfiguration() {
                 CassandraStorageSetup.getCassandraThriftConfiguration(ThriftSolrTest.class.getName());
         //Add index
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), INDEX);
-
+        config.set(SolrIndex.WAIT_SEARCHER, true, INDEX);
         config.set(INDEX_BACKEND,"solr",INDEX);
         //TODO: set SOLR specific config options
         return config.getConfiguration();

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthorityTest.java
Patch:
@@ -134,7 +134,6 @@ public void open() throws BackendException {
                 log.debug("Setting unique instance id: {}", uniqueGraphId);
                 sc.set(UNIQUE_INSTANCE_ID, uniqueGraphId);
             }
-            sc.set(GraphDatabaseConfiguration.CLUSTER_PARTITION,true);
             sc.set(GraphDatabaseConfiguration.CLUSTER_MAX_PARTITIONS,MAX_NUM_PARTITIONS);
 
             manager[i] = openStorageManager();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeBenchmark.java
Patch:
@@ -49,8 +49,7 @@ public void testDataSequential() throws Exception {
         KeyColumnValueStore store = manager.openDatabase(Backend.EDGESTORE_NAME);
         SliceQuery query = new SliceQuery(BufferUtil.zeroBuffer(8),BufferUtil.oneBuffer(8));
         query.setLimit(2);
-        Stopwatch watch = new Stopwatch();
-        watch.start();
+        Stopwatch watch = Stopwatch.createStarted();
         StoreTransaction txh = manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MILLI));
         KeyIterator iter = store.getKeys(query,txh);
         int numV = 0;

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/locking/ConsistentKeyLockerTest.java
Patch:
@@ -145,7 +145,7 @@ public int compare(BaseTransactionConfig actual, BaseTransactionConfig ignored)
         Method timeInSpecifiedUnit = FakeTimestampProvider.class.getMethod("getTime", long.class, TimeUnit.class);
         Method sleepPast = FakeTimestampProvider.class.getMethod("sleepPast", Timepoint.class);
 
-        times = ctrl.createMock(FakeTimestampProvider.class, timeInNativeUnit, timeInSpecifiedUnit, sleepPast);
+        times = EasyMock.createMockBuilder(FakeTimestampProvider.class).addMockedMethod(timeInNativeUnit).addMockedMethod(timeInSpecifiedUnit).addMockedMethod(sleepPast).createMock(ctrl);
         store = ctrl.createMock(KeyColumnValueStore.class);
         mediator = ctrl.createMock(LocalLockMediator.class);
         lockState = ctrl.createMock(LockerState.class);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VariableLongTest.java
Patch:
@@ -14,7 +14,7 @@
 
 import java.util.Random;
 
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -289,7 +289,7 @@ public void byteOrderPreservingPositiveBackward() {
                 assertEquals(l[i], VariableLong.readPositiveBackward(res));
             }
 //            System.out.println(l[0] + " vs " + l[1]);
-            assertEquals(Math.signum(Long.compare(l[0],l[1])),Math.signum(b[0].compareTo(b[1])));
+            assertEquals(Math.signum(Long.compare(l[0],l[1])),Math.signum(b[0].compareTo(b[1])), 0.01);
         }
 
     }

File: titan-all/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/plugin/TitanGremlinPlugin.java
Patch:
@@ -27,7 +27,7 @@ public class TitanGremlinPlugin implements GremlinPlugin {
         add(IMPORT + "com.thinkaurelius.titan.core.schema" + DOT_STAR);
         add(IMPORT + GraphOfTheGodsFactory.class.getName());
         add(IMPORT + BulkLoaderVertexProgram.class.getPackage().getName() + DOT_STAR);
-        add(IMPORT + "com.thinkaurelius.titan.hadoop.MapReduceIndexJobs");
+        add(IMPORT + "com.thinkaurelius.titan.hadoop.MapReduceIndexManagement");
 
         // Static imports on enum values used in query constraint expressions
         add(IMPORT_STATIC + Geo.class.getName() + DOT_STAR);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -131,6 +131,8 @@ public synchronized KeyColumnValueStore openDatabase(String name) throws Backend
      * (unparameterized) type.
      */
     public List<KeyRange> getLocalKeyPartition() throws BackendException {
+        ensureKeyspaceExists(keySpaceName);
+
         @SuppressWarnings("rawtypes")
         Collection<Range<Token>> ranges = StorageService.instance.getLocalPrimaryRanges(keySpaceName);
         List<KeyRange> keyRanges = new ArrayList<KeyRange>(ranges.size());

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/KCVSConfiguration.java
Patch:
@@ -169,7 +169,7 @@ private Map<String,Object> toMap() {
         List<Entry> result = BackendOperation.execute(new BackendOperation.Transactional<List<Entry>>() {
             @Override
             public List<Entry> call(StoreTransaction txh) throws BackendException {
-                return store.getSlice(new KeySliceQuery(rowKey, BufferUtil.zeroBuffer(128), BufferUtil.oneBuffer(128)),txh);
+                return store.getSlice(new KeySliceQuery(rowKey, BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(128)),txh);
             }
 
             @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSUtil.java
Patch:
@@ -46,15 +46,15 @@ public static StaticBuffer get(KeyColumnValueStore store, StaticBuffer key, Stat
     }
 
     public static KeyIterator getKeys(KeyColumnValueStore store, StoreFeatures features, int keyLength, int sliceLength, StoreTransaction txh) throws BackendException {
-        return getKeys(store,new SliceQuery(BufferUtil.zeroBuffer(sliceLength), BufferUtil.oneBuffer(sliceLength)).setLimit(1),
+        return getKeys(store,new SliceQuery(BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(sliceLength)).setLimit(1),
                 features,keyLength,txh);
     }
 
     public static KeyIterator getKeys(KeyColumnValueStore store, SliceQuery slice, StoreFeatures features, int keyLength, StoreTransaction txh) throws BackendException {
         if (features.hasUnorderedScan()) {
             return store.getKeys(slice, txh);
         } else if (features.hasOrderedScan()) {
-            return store.getKeys(new KeyRangeQuery(BufferUtil.zeroBuffer(keyLength), BufferUtil.oneBuffer(keyLength), slice), txh);
+            return store.getKeys(new KeyRangeQuery(BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(keyLength), slice), txh);
         } else throw new UnsupportedOperationException("Provided stores does not support scan operations: " + store);
     }
 
@@ -71,7 +71,7 @@ public static boolean containsKeyColumn(KeyColumnValueStore store, StaticBuffer
         return get(store, key, column, txh) != null;
     }
 
-    private static final StaticBuffer START = BufferUtil.zeroBuffer(8), END = BufferUtil.oneBuffer(32);
+    private static final StaticBuffer START = BufferUtil.zeroBuffer(1), END = BufferUtil.oneBuffer(32);
 
     public static boolean containsKey(KeyColumnValueStore store, StaticBuffer key, StoreTransaction txh) throws BackendException {
         return containsKey(store,key,32,txh);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/scan/StandardScannerExecutor.java
Patch:
@@ -93,8 +93,8 @@ public void run() {
                 //It is assumed that the first query is the grounding query if multiple queries exist
                 SliceQuery ground = queries.get(0);
                 StaticBuffer start = ground.getSliceStart();
-                Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(start.length())),
-                        "Expected start of first query to be all 0s: %s",start);
+                Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(1)),
+                        "Expected start of first query to be a single 0s: %s",start);
                 StaticBuffer end = ground.getSliceEnd();
                 Preconditions.checkArgument(end.equals(BufferUtil.oneBuffer(end.length())),
                         "Expected end of first query to be all 1s: %s",end);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -736,6 +736,7 @@ public boolean apply(@Nullable Integer integer) {
     // ################ IDAUTHORITY ###################
     // ################################################
 
+    //    public static final String STORAGE_NAMESPACE = "storage";
     public static final ConfigNamespace IDAUTHORITY_NS = new ConfigNamespace(IDS_NS,"authority","Configuration options for graph element ID reservation/allocation");
 
     /**
@@ -776,6 +777,8 @@ public boolean apply(@Nullable Integer integer) {
     public static final ConfigOption<Integer> IDAUTHORITY_CAV_RETRIES = new ConfigOption<Integer>(IDAUTHORITY_NS,"randomized-conflict-avoidance-retries",
             "Number of times the system attempts ID block reservations with random conflict avoidance tags before giving up and throwing an exception",
             ConfigOption.Type.MASKABLE, 5);
+//    public static final String IDAUTHORITY_RETRY_COUNT_KEY = "idauthority-retries";
+//    public static final int IDAUTHORITY_RETRY_COUNT_DEFAULT = 20;
 
     /**
      * Configures the number of bits of Titan assigned ids that are reserved for a unique id marker that
@@ -1292,7 +1295,6 @@ public boolean apply(@Nullable String s) {
     private String uniqueGraphId;
     private ModifiableConfiguration localConfiguration;
 
-
     private boolean readOnly;
     private boolean flushIDs;
     private boolean forceIndexUsage;
@@ -1851,7 +1853,6 @@ public org.apache.commons.configuration.Configuration getLocalConfiguration() {
     }
 
 
-
 	/* ----------------------------------------
      Methods for writing/reading config files
 	-------------------------------------------*/

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -36,7 +36,7 @@ public class VertexJobConverter implements ScanJob {
     private static final Logger log =
             LoggerFactory.getLogger(VertexJobConverter.class);
 
-    protected static final SliceQuery VERTEX_EXISTS_QUERY = new SliceQuery(BufferUtil.zeroBuffer(4),BufferUtil.oneBuffer(4)).setLimit(1);
+    protected static final SliceQuery VERTEX_EXISTS_QUERY = new SliceQuery(BufferUtil.zeroBuffer(1),BufferUtil.oneBuffer(4)).setLimit(1);
 
     public static final String GHOST_VERTEX_COUNT = "ghost-vertices";
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/GhostVertexRemover.java
Patch:
@@ -32,7 +32,7 @@ public class GhostVertexRemover extends VertexJobConverter {
 
     private static final int RELATION_COUNT_LIMIT = 10000;
 
-    private static final SliceQuery EVERYTHING_QUERY = new SliceQuery(BufferUtil.zeroBuffer(4),BufferUtil.oneBuffer(4));
+    private static final SliceQuery EVERYTHING_QUERY = new SliceQuery(BufferUtil.zeroBuffer(1),BufferUtil.oneBuffer(4));
 
     public static final String REMOVED_RELATION_COUNT = "removed-relations";
     public static final String REMOVED_VERTEX_COUNT = "removed-vertices";

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexUpdateJob.java
Patch:
@@ -42,7 +42,7 @@ public abstract class IndexUpdateJob {
     public static final ConfigOption<String> INDEX_RELATION_TYPE = new ConfigOption<String>(INDEX_JOB_NS,"relation-type",
             "For a vertex-centric index, this is the name of the index associated with the " +
                     "relation type configured under index-name. This should remain empty for global graph indexes.",
-            ConfigOption.Type.LOCAL, "");
+            ConfigOption.Type.LOCAL, "", str -> null != str);
 
 
     protected String indexRelationTypeName = null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanVertexStep.java
Patch:
@@ -53,6 +53,7 @@ public<Q extends BaseVertexQuery> Q makeQuery(Q query) {
         return query;
     }
 
+    @SuppressWarnings("deprecation")
     private void initialize() {
         assert !initialized;
         initialized = true;

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -920,7 +920,7 @@ else if (Geoshape.class.isAssignableFrom(datatype)) {
     public Iterable<RawQuery.Result<String>> query(RawQuery query, KeyInformation.IndexRetriever informations, BaseTransaction tx) throws BackendException {
         SearchRequestBuilder srb = client.prepareSearch(indexName);
         srb.setTypes(query.getStore());
-        srb.setQuery(QueryBuilders.queryString(query.getQuery()));
+        srb.setQuery(QueryBuilders.queryStringQuery(query.getQuery()));
 
         srb.setFrom(query.getOffset());
         if (query.hasLimit()) srb.setSize(query.getLimit());

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/compat/HadoopCompat.java
Patch:
@@ -119,4 +119,6 @@ public interface HadoopCompat {
     public Configuration newImmutableConfiguration(Configuration base);
 
     public ScanMetrics getMetrics(Counters c);
+
+    public String getJobFailureString(Job j);
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/AbstractBinaryInputFormat.java
Patch:
@@ -3,7 +3,6 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import org.apache.hadoop.conf.Configurable;
@@ -13,14 +12,15 @@
 public abstract class AbstractBinaryInputFormat extends InputFormat<StaticBuffer, Iterable<Entry>> implements Configurable {
 
     protected Configuration hadoopConf;
+    protected ModifiableHadoopConfiguration mrConf;
     protected ModifiableConfiguration titanConf;
 
     @Override
     public void setConf(final Configuration config) {
 
-        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
+        this.mrConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
         this.hadoopConf = config;
-        this.titanConf = faunusConf.getTitanInputConf();
+        this.titanConf = mrConf.getTitanInputConf();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanMapper.java
Patch:
@@ -72,7 +72,7 @@ protected void finishSetup(ModifiableHadoopConfiguration scanConf, Configuration
         if (0 < subsequentQueries.size()) {
             //It is assumed that the first query is the grounding query if multiple queries exist
             StaticBuffer start = initialQuery.getSliceStart();
-            Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(start.length())),
+            Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(1)),
                     "Expected start of first query to be all 0s: %s", start);
             StaticBuffer end = initialQuery.getSliceEnd();
             Preconditions.checkArgument(end.equals(BufferUtil.oneBuffer(end.length())),
@@ -228,7 +228,8 @@ static Configuration getJobConfiguration(ModifiableHadoopConfiguration scanConf)
             return null;
         }
         ConfigNamespace jobRoot = getJobRoot(scanConf.get(TitanHadoopConfiguration.SCAN_JOB_CONFIG_ROOT));
-        return ModifiableHadoopConfiguration.subset(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS, scanConf);
+        return ModifiableHadoopConfiguration.prefixView(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS,
+                scanConf);
     }
 
     static ConfigNamespace getJobRoot(String confRootName) {

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -715,7 +715,7 @@ private final byte[] zeroExtend(byte[] dataToPad) {
         return padded;
     }
 
-    private String shortenCfName(String longName) throws PermanentBackendException {
+    public static String shortenCfName(String longName) throws PermanentBackendException {
         final String s;
         if (SHORT_CF_NAME_MAP.containsKey(longName)) {
             s = SHORT_CF_NAME_MAP.get(longName);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -144,7 +144,9 @@ public void testIDAssignment() {
                         assertTrue(relationIds.add(id));
                     }
                 } catch (IDPoolExhaustedException e) {
-                    assertTrue(totalRelations>maxIDAssignments || totalVertices>maxIDAssignments);
+                    //Since the id assignment process is randomized, we divide by 3/2 to account for minor variations
+                    assertTrue("Max Avail: " + maxIDAssignments + " vs. ["+totalVertices+","+totalRelations+"]",
+                            totalRelations>=maxIDAssignments/3*2 || totalVertices>=maxIDAssignments/3*2);
                 } finally {
                     graph.tx().rollback();
                     graph.close();

File: titan-all/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/plugin/TitanGremlinPlugin.java
Patch:
@@ -27,7 +27,7 @@ public class TitanGremlinPlugin implements GremlinPlugin {
         add(IMPORT + "com.thinkaurelius.titan.core.schema" + DOT_STAR);
         add(IMPORT + GraphOfTheGodsFactory.class.getName());
         add(IMPORT + BulkLoaderVertexProgram.class.getPackage().getName() + DOT_STAR);
-        add(IMPORT + "com.thinkaurelius.titan.hadoop.MapReduceIndexJobs");
+        add(IMPORT + "com.thinkaurelius.titan.hadoop.MapReduceIndexManagement");
 
         // Static imports on enum values used in query constraint expressions
         add(IMPORT_STATIC + Geo.class.getName() + DOT_STAR);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -131,6 +131,8 @@ public synchronized KeyColumnValueStore openDatabase(String name) throws Backend
      * (unparameterized) type.
      */
     public List<KeyRange> getLocalKeyPartition() throws BackendException {
+        ensureKeyspaceExists(keySpaceName);
+
         @SuppressWarnings("rawtypes")
         Collection<Range<Token>> ranges = StorageService.instance.getLocalPrimaryRanges(keySpaceName);
         List<KeyRange> keyRanges = new ArrayList<KeyRange>(ranges.size());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -1295,7 +1295,6 @@ public boolean apply(@Nullable String s) {
     private String uniqueGraphId;
     private ModifiableConfiguration localConfiguration;
 
-
     private boolean readOnly;
     private boolean flushIDs;
     private boolean forceIndexUsage;
@@ -1854,7 +1853,6 @@ public org.apache.commons.configuration.Configuration getLocalConfiguration() {
     }
 
 
-
 	/* ----------------------------------------
      Methods for writing/reading config files
 	-------------------------------------------*/

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/compat/HadoopCompat.java
Patch:
@@ -119,4 +119,6 @@ public interface HadoopCompat {
     public Configuration newImmutableConfiguration(Configuration base);
 
     public ScanMetrics getMetrics(Counters c);
+
+    public String getJobFailureString(Job j);
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/AbstractBinaryInputFormat.java
Patch:
@@ -3,7 +3,6 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import org.apache.hadoop.conf.Configurable;
@@ -13,14 +12,15 @@
 public abstract class AbstractBinaryInputFormat extends InputFormat<StaticBuffer, Iterable<Entry>> implements Configurable {
 
     protected Configuration hadoopConf;
+    protected ModifiableHadoopConfiguration mrConf;
     protected ModifiableConfiguration titanConf;
 
     @Override
     public void setConf(final Configuration config) {
 
-        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
+        this.mrConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
         this.hadoopConf = config;
-        this.titanConf = faunusConf.getTitanInputConf();
+        this.titanConf = mrConf.getTitanInputConf();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanMapper.java
Patch:
@@ -228,7 +228,8 @@ static Configuration getJobConfiguration(ModifiableHadoopConfiguration scanConf)
             return null;
         }
         ConfigNamespace jobRoot = getJobRoot(scanConf.get(TitanHadoopConfiguration.SCAN_JOB_CONFIG_ROOT));
-        return ModifiableHadoopConfiguration.subset(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS, scanConf);
+        return ModifiableHadoopConfiguration.prefixView(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS,
+                scanConf);
     }
 
     static ConfigNamespace getJobRoot(String confRootName) {

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -715,7 +715,7 @@ private final byte[] zeroExtend(byte[] dataToPad) {
         return padded;
     }
 
-    private String shortenCfName(String longName) throws PermanentBackendException {
+    public static String shortenCfName(String longName) throws PermanentBackendException {
         final String s;
         if (SHORT_CF_NAME_MAP.containsKey(longName)) {
             s = SHORT_CF_NAME_MAP.get(longName);

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/MapReduceIndexManagement.java
Patch:
@@ -120,7 +120,7 @@ public TitanManagement.IndexJobFuture updateIndex(TitanIndex index, SchemaAction
             readCF = Backend.EDGESTORE_NAME;
         } else {
             TitanGraphIndex gindex = (TitanGraphIndex)index;
-            if (gindex.isMixedIndex())
+            if (gindex.isMixedIndex() && !updateAction.equals(SchemaAction.REINDEX))
                 throw new UnsupportedOperationException("External mixed indexes must be removed in the indexing system directly.");
 
             Preconditions.checkState(TitanGraphIndex.class.isAssignableFrom(index.getClass()));

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/compat/HadoopCompat.java
Patch:
@@ -119,4 +119,6 @@ public interface HadoopCompat {
     public Configuration newImmutableConfiguration(Configuration base);
 
     public ScanMetrics getMetrics(Counters c);
+
+    public String getJobFailureString(Job j);
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanRunner.java
Patch:
@@ -6,6 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.scan.ScanJob;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.scan.ScanMetrics;
 import com.thinkaurelius.titan.graphdb.olap.VertexScanJob;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import org.apache.hadoop.io.NullWritable;
@@ -124,8 +125,8 @@ public static ScanMetrics runJob(org.apache.hadoop.conf.Configuration hadoopConf
             String f;
             try {
                 // Just in case one of Job's methods throws an exception
-                f = String.format("MapReduce JobID %s terminated in state %s",
-                        job.getJobID().toString(), job.getStatus().getState().name());
+                f = String.format("MapReduce JobID %s terminated abnormally: %s",
+                        job.getJobID().toString(), HadoopCompatLoader.DEFAULT_COMPAT.getJobFailureString(job));
             } catch (RuntimeException e) {
                 f = "Job failed (unable to read job status programmatically -- see MapReduce logs for information)";
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -1295,7 +1295,6 @@ public boolean apply(@Nullable String s) {
     private String uniqueGraphId;
     private ModifiableConfiguration localConfiguration;
 
-
     private boolean readOnly;
     private boolean flushIDs;
     private boolean forceIndexUsage;
@@ -1854,7 +1853,6 @@ public org.apache.commons.configuration.Configuration getLocalConfiguration() {
     }
 
 
-
 	/* ----------------------------------------
      Methods for writing/reading config files
 	-------------------------------------------*/

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/AbstractBinaryInputFormat.java
Patch:
@@ -3,7 +3,6 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import org.apache.hadoop.conf.Configurable;
@@ -13,14 +12,15 @@
 public abstract class AbstractBinaryInputFormat extends InputFormat<StaticBuffer, Iterable<Entry>> implements Configurable {
 
     protected Configuration hadoopConf;
+    protected ModifiableHadoopConfiguration mrConf;
     protected ModifiableConfiguration titanConf;
 
     @Override
     public void setConf(final Configuration config) {
 
-        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
+        this.mrConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
         this.hadoopConf = config;
-        this.titanConf = faunusConf.getTitanInputConf();
+        this.titanConf = mrConf.getTitanInputConf();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanMapper.java
Patch:
@@ -228,7 +228,8 @@ static Configuration getJobConfiguration(ModifiableHadoopConfiguration scanConf)
             return null;
         }
         ConfigNamespace jobRoot = getJobRoot(scanConf.get(TitanHadoopConfiguration.SCAN_JOB_CONFIG_ROOT));
-        return ModifiableHadoopConfiguration.subset(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS, scanConf);
+        return ModifiableHadoopConfiguration.prefixView(jobRoot, TitanHadoopConfiguration.SCAN_JOB_CONFIG_KEYS,
+                scanConf);
     }
 
     static ConfigNamespace getJobRoot(String confRootName) {

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -715,7 +715,7 @@ private final byte[] zeroExtend(byte[] dataToPad) {
         return padded;
     }
 
-    private String shortenCfName(String longName) throws PermanentBackendException {
+    public static String shortenCfName(String longName) throws PermanentBackendException {
         final String s;
         if (SHORT_CF_NAME_MAP.containsKey(longName)) {
             s = SHORT_CF_NAME_MAP.get(longName);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/KCVSConfiguration.java
Patch:
@@ -169,7 +169,7 @@ private Map<String,Object> toMap() {
         List<Entry> result = BackendOperation.execute(new BackendOperation.Transactional<List<Entry>>() {
             @Override
             public List<Entry> call(StoreTransaction txh) throws BackendException {
-                return store.getSlice(new KeySliceQuery(rowKey, BufferUtil.zeroBuffer(128), BufferUtil.oneBuffer(128)),txh);
+                return store.getSlice(new KeySliceQuery(rowKey, BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(128)),txh);
             }
 
             @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDAuthority.java
Patch:
@@ -50,7 +50,7 @@ public class ConsistentKeyIDAuthority extends AbstractIDAuthority implements Bac
 
     private static final Logger log = LoggerFactory.getLogger(ConsistentKeyIDAuthority.class);
 
-    private static final StaticBuffer LOWER_SLICE = BufferUtil.zeroBuffer(16);
+    private static final StaticBuffer LOWER_SLICE = BufferUtil.zeroBuffer(1);
     private static final StaticBuffer UPPER_SLICE = BufferUtil.oneBuffer(16);
 
     private final StoreManager manager;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSUtil.java
Patch:
@@ -46,15 +46,15 @@ public static StaticBuffer get(KeyColumnValueStore store, StaticBuffer key, Stat
     }
 
     public static KeyIterator getKeys(KeyColumnValueStore store, StoreFeatures features, int keyLength, int sliceLength, StoreTransaction txh) throws BackendException {
-        return getKeys(store,new SliceQuery(BufferUtil.zeroBuffer(sliceLength), BufferUtil.oneBuffer(sliceLength)).setLimit(1),
+        return getKeys(store,new SliceQuery(BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(sliceLength)).setLimit(1),
                 features,keyLength,txh);
     }
 
     public static KeyIterator getKeys(KeyColumnValueStore store, SliceQuery slice, StoreFeatures features, int keyLength, StoreTransaction txh) throws BackendException {
         if (features.hasUnorderedScan()) {
             return store.getKeys(slice, txh);
         } else if (features.hasOrderedScan()) {
-            return store.getKeys(new KeyRangeQuery(BufferUtil.zeroBuffer(keyLength), BufferUtil.oneBuffer(keyLength), slice), txh);
+            return store.getKeys(new KeyRangeQuery(BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(keyLength), slice), txh);
         } else throw new UnsupportedOperationException("Provided stores does not support scan operations: " + store);
     }
 
@@ -71,7 +71,7 @@ public static boolean containsKeyColumn(KeyColumnValueStore store, StaticBuffer
         return get(store, key, column, txh) != null;
     }
 
-    private static final StaticBuffer START = BufferUtil.zeroBuffer(8), END = BufferUtil.oneBuffer(32);
+    private static final StaticBuffer START = BufferUtil.zeroBuffer(1), END = BufferUtil.oneBuffer(32);
 
     public static boolean containsKey(KeyColumnValueStore store, StaticBuffer key, StoreTransaction txh) throws BackendException {
         return containsKey(store,key,32,txh);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/scan/StandardScannerExecutor.java
Patch:
@@ -93,7 +93,7 @@ public void run() {
                 //It is assumed that the first query is the grounding query if multiple queries exist
                 SliceQuery ground = queries.get(0);
                 StaticBuffer start = ground.getSliceStart();
-                Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(start.length())),
+                Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(1)),
                         "Expected start of first query to be all 0s: %s",start);
                 StaticBuffer end = ground.getSliceEnd();
                 Preconditions.checkArgument(end.equals(BufferUtil.oneBuffer(end.length())),

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -128,7 +128,7 @@ public class ConsistentKeyLocker extends AbstractLocker<ConsistentKeyLockStatus>
 
     private static final StaticBuffer zeroBuf = BufferUtil.getIntBuffer(0); // TODO this does not belong here
 
-    public static final StaticBuffer LOCK_COL_START = BufferUtil.zeroBuffer(9);
+    public static final StaticBuffer LOCK_COL_START = BufferUtil.zeroBuffer(1);
     public static final StaticBuffer LOCK_COL_END   = BufferUtil.oneBuffer(9);
 
     private static final Logger log = LoggerFactory.getLogger(ConsistentKeyLocker.class);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -36,7 +36,7 @@ public class VertexJobConverter implements ScanJob {
     private static final Logger log =
             LoggerFactory.getLogger(VertexJobConverter.class);
 
-    protected static final SliceQuery VERTEX_EXISTS_QUERY = new SliceQuery(BufferUtil.zeroBuffer(4),BufferUtil.oneBuffer(4)).setLimit(1);
+    protected static final SliceQuery VERTEX_EXISTS_QUERY = new SliceQuery(BufferUtil.zeroBuffer(1),BufferUtil.oneBuffer(4)).setLimit(1);
 
     public static final String GHOST_VERTEX_COUNT = "ghost-vertices";
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/GhostVertexRemover.java
Patch:
@@ -32,7 +32,7 @@ public class GhostVertexRemover extends VertexJobConverter {
 
     private static final int RELATION_COUNT_LIMIT = 10000;
 
-    private static final SliceQuery EVERYTHING_QUERY = new SliceQuery(BufferUtil.zeroBuffer(4),BufferUtil.oneBuffer(4));
+    private static final SliceQuery EVERYTHING_QUERY = new SliceQuery(BufferUtil.zeroBuffer(1),BufferUtil.oneBuffer(4));
 
     public static final String REMOVED_RELATION_COUNT = "removed-relations";
     public static final String REMOVED_VERTEX_COUNT = "removed-vertices";

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanMapper.java
Patch:
@@ -72,7 +72,7 @@ protected void finishSetup(ModifiableHadoopConfiguration scanConf, Configuration
         if (0 < subsequentQueries.size()) {
             //It is assumed that the first query is the grounding query if multiple queries exist
             StaticBuffer start = initialQuery.getSliceStart();
-            Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(start.length())),
+            Preconditions.checkArgument(start.equals(BufferUtil.zeroBuffer(1)),
                     "Expected start of first query to be all 0s: %s", start);
             StaticBuffer end = initialQuery.getSliceEnd();
             Preconditions.checkArgument(end.equals(BufferUtil.oneBuffer(end.length())),

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexRemoveJob.java
Patch:
@@ -164,7 +164,7 @@ public Predicate<StaticBuffer> getKeyFilter() {
                 try {
                     return indexSerializer.getIndexIdFromKey(k) == graphIndexId;
                 } catch (RuntimeException e) {
-                    log.debug("Filtering key {} due to exception", k, e);
+                    log.error("Filtering key {} due to exception", k, e);
                     return false;
                 }
             });

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexRemoveJob.java
Patch:
@@ -137,7 +137,7 @@ public void process(StaticBuffer key, Map<SliceQuery, EntryList> entries, ScanMe
     public List<SliceQuery> getQueries() {
         if (isGlobalGraphIndex()) {
             //Everything
-            return ImmutableList.of(new SliceQuery(BufferUtil.zeroBuffer(128), BufferUtil.oneBuffer(128)));
+            return ImmutableList.of(new SliceQuery(BufferUtil.zeroBuffer(1), BufferUtil.oneBuffer(128)));
         } else {
             RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;
             InternalRelationType wrappedType = wrapper.getWrappedType();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanVertexStep.java
Patch:
@@ -53,6 +53,7 @@ public<Q extends BaseVertexQuery> Q makeQuery(Q query) {
         return query;
     }
 
+    @SuppressWarnings("deprecation")
     private void initialize() {
         assert !initialized;
         initialized = true;

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -920,7 +920,7 @@ else if (Geoshape.class.isAssignableFrom(datatype)) {
     public Iterable<RawQuery.Result<String>> query(RawQuery query, KeyInformation.IndexRetriever informations, BaseTransaction tx) throws BackendException {
         SearchRequestBuilder srb = client.prepareSearch(indexName);
         srb.setTypes(query.getStore());
-        srb.setQuery(QueryBuilders.queryString(query.getQuery()));
+        srb.setQuery(QueryBuilders.queryStringQuery(query.getQuery()));
 
         srb.setFrom(query.getOffset());
         if (query.hasLimit()) srb.setSize(query.getLimit());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexUpdateJob.java
Patch:
@@ -42,7 +42,7 @@ public abstract class IndexUpdateJob {
     public static final ConfigOption<String> INDEX_RELATION_TYPE = new ConfigOption<String>(INDEX_JOB_NS,"relation-type",
             "For a vertex-centric index, this is the name of the index associated with the " +
                     "relation type configured under index-name. This should remain empty for global graph indexes.",
-            ConfigOption.Type.LOCAL, "");
+            ConfigOption.Type.LOCAL, "", str -> null != str);
 
 
     protected String indexRelationTypeName = null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanBlueprintsGraph.java
Patch:
@@ -165,11 +165,13 @@ public TitanIndexQuery indexQuery(String indexName, String query) {
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(TitanVertex... vertices) {
         return getAutoStartTx().multiQuery(vertices);
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(Collection<TitanVertex> vertices) {
         return getAutoStartTx().multiQuery(vertices);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanPropertiesStep.java
Patch:
@@ -70,6 +70,7 @@ void makeVertrexProperties() {
         this.isVertexProperties = true;
     }
 
+    @SuppressWarnings("deprecation")
     private void initialize() {
         assert !initialized;
         initialized = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -1005,13 +1005,15 @@ public VertexCentricQueryBuilder query(TitanVertex vertex) {
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(TitanVertex... vertices) {
         MultiVertexCentricQueryBuilder builder = new MultiVertexCentricQueryBuilder(this);
         for (TitanVertex v : vertices) builder.addVertex(v);
         return builder;
     }
 
     @Override
+    @Deprecated
     public TitanMultiVertexQuery multiQuery(Collection<TitanVertex> vertices) {
         MultiVertexCentricQueryBuilder builder = new MultiVertexCentricQueryBuilder(this);
         builder.addAllVertices(vertices);

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneExample.java
Patch:
@@ -65,8 +65,8 @@ private SpatialStrategy getSpatialStrategy(String key) {
     @Test
     public void example1() throws Exception {
         Directory dir = FSDirectory.open(path);
-        Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_41);
-        IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_41, analyzer);
+        Analyzer analyzer = new StandardAnalyzer();
+        IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);
 
         iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);
         IndexWriter writer = new IndexWriter(dir, iwc);
@@ -93,7 +93,7 @@ public void example1() throws Exception {
         //Search
         IndexReader reader = DirectoryReader.open(FSDirectory.open(path));
         IndexSearcher searcher = new IndexSearcher(reader);
-        analyzer = new StandardAnalyzer(Version.LUCENE_41);
+        analyzer = new StandardAnalyzer();
 
         //Auesee
         BooleanFilter filter = new BooleanFilter();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeBenchmark.java
Patch:
@@ -49,8 +49,7 @@ public void testDataSequential() throws Exception {
         KeyColumnValueStore store = manager.openDatabase(Backend.EDGESTORE_NAME);
         SliceQuery query = new SliceQuery(BufferUtil.zeroBuffer(8),BufferUtil.oneBuffer(8));
         query.setLimit(2);
-        Stopwatch watch = new Stopwatch();
-        watch.start();
+        Stopwatch watch = Stopwatch.createStarted();
         StoreTransaction txh = manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MILLI));
         KeyIterator iter = store.getKeys(query,txh);
         int numV = 0;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -1625,6 +1625,7 @@ public void testSelfLoop() {
      * are bound to single-threaded graph transactions
      */
     @Test
+    @SuppressWarnings("deprecation")
     public void testThreadBoundTx() {
         PropertyKey t = mgmt.makePropertyKey("type").dataType(Integer.class).make();
         mgmt.buildIndex("etype",Edge.class).addKey(t).buildCompositeIndex();
@@ -2387,6 +2388,7 @@ private void awaitAllThreadsReady() {
      ==================================================================================*/
 
    @Test
+   @SuppressWarnings("deprecation")
    public void testVertexCentricQuery() {
        makeVertexIndexedUniqueKey("name",String.class);
        PropertyKey time = makeKey("time",Integer.class);

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/locking/ConsistentKeyLockerTest.java
Patch:
@@ -145,7 +145,7 @@ public int compare(BaseTransactionConfig actual, BaseTransactionConfig ignored)
         Method timeInSpecifiedUnit = FakeTimestampProvider.class.getMethod("getTime", long.class, TimeUnit.class);
         Method sleepPast = FakeTimestampProvider.class.getMethod("sleepPast", Timepoint.class);
 
-        times = ctrl.createMock(FakeTimestampProvider.class, timeInNativeUnit, timeInSpecifiedUnit, sleepPast);
+        times = EasyMock.createMockBuilder(FakeTimestampProvider.class).addMockedMethod(timeInNativeUnit).addMockedMethod(timeInSpecifiedUnit).addMockedMethod(sleepPast).createMock(ctrl);
         store = ctrl.createMock(KeyColumnValueStore.class);
         mediator = ctrl.createMock(LocalLockMediator.class);
         lockState = ctrl.createMock(LockerState.class);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VariableLongTest.java
Patch:
@@ -14,7 +14,7 @@
 
 import java.util.Random;
 
-import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -289,7 +289,7 @@ public void byteOrderPreservingPositiveBackward() {
                 assertEquals(l[i], VariableLong.readPositiveBackward(res));
             }
 //            System.out.println(l[0] + " vs " + l[1]);
-            assertEquals(Math.signum(Long.compare(l[0],l[1])),Math.signum(b[0].compareTo(b[1])));
+            assertEquals(Math.signum(Long.compare(l[0],l[1])),Math.signum(b[0].compareTo(b[1])), 0.01);
         }
 
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -76,7 +76,7 @@ public static StandardTitanTx startTransaction(StandardTitanGraph graph) {
         txb.setPreloadedData(true);
         txb.checkInternalVertexExistence(false);
         txb.dirtyVertexSize(0);
-        txb.vertexCacheSize(500);
+        txb.vertexCacheSize(0);
         return (StandardTitanTx)txb.start();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -76,7 +76,7 @@ public static StandardTitanTx startTransaction(StandardTitanGraph graph) {
         txb.setPreloadedData(true);
         txb.checkInternalVertexExistence(false);
         txb.dirtyVertexSize(0);
-        txb.vertexCacheSize(500);
+        txb.vertexCacheSize(0);
         return (StandardTitanTx)txb.start();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/scan/StandardScannerExecutor.java
Patch:
@@ -29,7 +29,7 @@ class StandardScannerExecutor extends AbstractFuture<ScanMetrics> implements Tit
             LoggerFactory.getLogger(StandardScannerExecutor.class);
 
     private static final int QUEUE_SIZE = 1000;
-    private static final int TIMEOUT_MS = 60000; // 60 seconds
+    private static final int TIMEOUT_MS = 180000; // 60 seconds
     private static final int MAX_KEY_LENGTH = 128; //in bytes
 
     private final ScanJob job;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexCentricQueryBuilder.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
 import com.thinkaurelius.titan.graphdb.query.BackendQueryHolder;
 import com.thinkaurelius.titan.graphdb.query.QueryProcessor;
+import com.thinkaurelius.titan.graphdb.vertices.PreloadedVertex;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -37,8 +38,6 @@ public class VertexCentricQueryBuilder extends BasicVertexCentricQueryBuilder<Ve
      */
     private final InternalVertex vertex;
 
-
-
     public VertexCentricQueryBuilder(InternalVertex v) {
         super(v.tx());
         Preconditions.checkNotNull(v);
@@ -58,7 +57,7 @@ protected VertexCentricQueryBuilder getThis() {
     protected<Q> Q execute(RelationCategory returnType, ResultConstructor<Q> resultConstructor) {
         BaseVertexCentricQuery bq = super.constructQuery(returnType);
         if (bq.isEmpty()) return resultConstructor.emptyResult();
-        if (isPartitionedVertex(vertex)) {
+        if (isPartitionedVertex(vertex) && !hasQueryOnlyGivenVertex()) { //If it's a preloaded vertex we shouldn't preload data explicitly
             List<InternalVertex> vertices = allRequiredRepresentatives(vertex);
             if (vertices.size()>1) {
                 for (BackendQueryHolder<SliceQuery> sq : bq.getQueries()) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/PreloadedVertex.java
Patch:
@@ -72,7 +72,7 @@ public List<InternalRelation> getAddedRelations(Predicate<InternalRelation> quer
 
     @Override
     public VertexCentricQueryBuilder query() {
-        if (super.getQueryCacheSize()>0) return super.query();
+        if (super.getQueryCacheSize()>0) return super.query().queryOnlyGivenVertex();
         else throw stubVertexException();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -83,6 +83,7 @@ public VertexIDAssigner(Configuration config, IDAuthority idAuthority, StoreFeat
             //If no placement strategy is configured and the storage backend cannot exploit locality, use the default with one partition block
             placementStrategy = new SimpleBulkPlacementStrategy(1);
         }
+        placementStrategy.injectIDManager(idManager);
         log.debug("Partition IDs? [{}], Local Partitions? [{}]",true,hasLocalPartitions);
 
         long baseBlockSize = config.get(IDS_BLOCK_SIZE);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -321,7 +321,7 @@ public void close() {
     }
 
     @Override
-    public synchronized AstyanaxKeyColumnValueStore openDatabase(String name, Map<StoreMetaData, Object> metaData) throws BackendException {
+    public synchronized AstyanaxKeyColumnValueStore openDatabase(String name, StoreMetaData.Container metaData) throws BackendException {
         if (openStores.containsKey(name)) return openStores.get(name);
         else {
             ensureColumnFamilyExists(name);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -112,7 +112,7 @@ public void close() {
     }
 
     @Override
-    public synchronized KeyColumnValueStore openDatabase(String name, Map<StoreMetaData, Object> metaData) throws BackendException {
+    public synchronized KeyColumnValueStore openDatabase(String name, StoreMetaData.Container metaData) throws BackendException {
         if (openStores.containsKey(name))
             return openStores.get(name);
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -320,7 +320,7 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
     }
 
     @Override // TODO: *BIG FAT WARNING* 'synchronized is always *bad*, change openStores to use ConcurrentLinkedHashMap
-    public synchronized CassandraThriftKeyColumnValueStore openDatabase(final String name, final Map<StoreMetaData, Object> metaData) throws BackendException {
+    public synchronized CassandraThriftKeyColumnValueStore openDatabase(final String name, StoreMetaData.Container metaData) throws BackendException {
         if (openStores.containsKey(name))
             return openStores.get(name);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSManagerProxy.java
Patch:
@@ -53,7 +53,7 @@ public List<KeyRange> getLocalKeyPartition() throws BackendException {
     }
 
     @Override
-    public KeyColumnValueStore openDatabase(String name, Map<StoreMetaData, Object> metaData) throws BackendException {
+    public KeyColumnValueStore openDatabase(String name, StoreMetaData.Container metaData) throws BackendException {
         return manager.openDatabase(name, metaData);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -80,7 +80,7 @@ public StoreFeatures getFeatures() {
     }
 
     @Override
-    public KeyColumnValueStore openDatabase(final String name, Map<StoreMetaData, Object> metaData) throws BackendException {
+    public KeyColumnValueStore openDatabase(final String name, StoreMetaData.Container metaData) throws BackendException {
         if (!stores.containsKey(name)) {
             stores.putIfAbsent(name, new InMemoryKeyColumnValueStore(name));
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreManagerAdapter.java
Patch:
@@ -66,11 +66,11 @@ public void clearStorage() throws BackendException {
 
     @Override
     public synchronized OrderedKeyValueStoreAdapter openDatabase(String name) throws BackendException {
-        return openDatabase(name, ImmutableMap.of());
+        return openDatabase(name, StoreMetaData.EMPTY);
     }
 
     @Override
-    public synchronized OrderedKeyValueStoreAdapter openDatabase(String name, Map<StoreMetaData, Object> metaData)
+    public synchronized OrderedKeyValueStoreAdapter openDatabase(String name, StoreMetaData.Container metaData)
             throws BackendException {
         if (!stores.containsKey(name) || stores.get(name).isClosed()) {
             OrderedKeyValueStoreAdapter store = wrapKeyValueStore(manager.openDatabase(name), keyLengths);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLogManager.java
Patch:
@@ -200,7 +200,7 @@ private static void checkValidPartitionId(int partitionId, int partitionBitWidth
     @Override
     public synchronized KCVSLog openLog(final String name) throws BackendException {
         if (openLogs.containsKey(name)) return openLogs.get(name);
-        Map<StoreMetaData, Object> storeOptions = Maps.newHashMap();
+        StoreMetaData.Container storeOptions = new StoreMetaData.Container();
         if (0 < indexStoreTTL) {
             storeOptions.put(StoreMetaData.TTL, indexStoreTTL);
         }

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -439,7 +439,7 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
     }
 
     @Override
-    public KeyColumnValueStore openDatabase(String longName, Map<StoreMetaData, Object> metaData) throws BackendException {
+    public KeyColumnValueStore openDatabase(String longName, StoreMetaData.Container metaData) throws BackendException {
 
         HBaseKeyColumnValueStore store = openStores.get(longName);
 
@@ -453,8 +453,8 @@ public KeyColumnValueStore openDatabase(String longName, Map<StoreMetaData, Obje
             if (store == null) {
                 if (!skipSchemaCheck) {
                     int cfTTLInSeconds = -1;
-                    if (metaData.containsKey(StoreMetaData.TTL)) {
-                        cfTTLInSeconds = (Integer) metaData.get(StoreMetaData.TTL);
+                    if (metaData.contains(StoreMetaData.TTL)) {
+                        cfTTLInSeconds = metaData.get(StoreMetaData.TTL);
                     }
                     ensureColumnFamilyExists(tableName, cfName, cfTTLInSeconds);
                 }

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -1092,7 +1092,7 @@ public void testStoreTTL() throws Exception {
 
         final TimeUnit sec = TimeUnit.SECONDS;
         final int storeTTLSeconds = (int)TestGraphConfigs.getTTL(sec);
-        Map<StoreMetaData, Object> opts = Maps.newHashMap();
+        StoreMetaData.Container opts = new StoreMetaData.Container();
         opts.put(StoreMetaData.TTL, storeTTLSeconds);
         KeyColumnValueStore storeWithTTL = storeManager.openDatabase("testStore_with_TTL", opts);
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -29,6 +29,7 @@
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
 import com.thinkaurelius.titan.diskstorage.PermanentBackendException;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
+import com.thinkaurelius.titan.diskstorage.StoreMetaData;
 import com.thinkaurelius.titan.diskstorage.TemporaryBackendException;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigNamespace;
@@ -320,7 +321,7 @@ public void close() {
     }
 
     @Override
-    public synchronized AstyanaxKeyColumnValueStore openDatabase(String name, Configuration options) throws BackendException {
+    public synchronized AstyanaxKeyColumnValueStore openDatabase(String name, Map<StoreMetaData, Object> metaData) throws BackendException {
         if (openStores.containsKey(name)) return openStores.get(name);
         else {
             ensureColumnFamilyExists(name);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -112,7 +112,7 @@ public void close() {
     }
 
     @Override
-    public synchronized KeyColumnValueStore openDatabase(String name, Configuration options) throws BackendException {
+    public synchronized KeyColumnValueStore openDatabase(String name, Map<StoreMetaData, Object> metaData) throws BackendException {
         if (openStores.containsKey(name))
             return openStores.get(name);
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -320,7 +320,7 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
     }
 
     @Override // TODO: *BIG FAT WARNING* 'synchronized is always *bad*, change openStores to use ConcurrentLinkedHashMap
-    public synchronized CassandraThriftKeyColumnValueStore openDatabase(final String name, final Configuration options) throws BackendException {
+    public synchronized CassandraThriftKeyColumnValueStore openDatabase(final String name, final Map<StoreMetaData, Object> metaData) throws BackendException {
         if (openStores.containsKey(name))
             return openStores.get(name);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSManagerProxy.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
+import com.thinkaurelius.titan.diskstorage.StoreMetaData;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 
 import java.util.List;
@@ -52,8 +53,8 @@ public List<KeyRange> getLocalKeyPartition() throws BackendException {
     }
 
     @Override
-    public KeyColumnValueStore openDatabase(String name, Configuration options) throws BackendException {
-        return manager.openDatabase(name);
+    public KeyColumnValueStore openDatabase(String name, Map<StoreMetaData, Object> metaData) throws BackendException {
+        return manager.openDatabase(name, metaData);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
+import com.thinkaurelius.titan.diskstorage.StoreMetaData;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
@@ -79,7 +80,7 @@ public StoreFeatures getFeatures() {
     }
 
     @Override
-    public KeyColumnValueStore openDatabase(final String name, Configuration options) throws BackendException {
+    public KeyColumnValueStore openDatabase(final String name, Map<StoreMetaData, Object> metaData) throws BackendException {
         if (!stores.containsKey(name)) {
             stores.putIfAbsent(name, new InMemoryKeyColumnValueStore(name));
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/ConfigOption.java
Patch:
@@ -74,6 +74,7 @@ public enum Type {
                 Boolean.class,
                 Short.class,
                 Integer.class,
+                Byte.class,
                 Long.class,
                 Float.class,
                 Double.class,

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan;
 
 import static com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager.CASSANDRA_KEYSPACE;
-import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.CLUSTER_PARTITION;
 
 import java.io.File;
 import java.io.IOException;
@@ -59,7 +58,6 @@ public static ModifiableConfiguration getEmbeddedConfiguration(String ks) {
 
     public static ModifiableConfiguration getEmbeddedCassandraPartitionConfiguration(String ks) {
         ModifiableConfiguration config = getEmbeddedConfiguration(ks);
-        config.set(CLUSTER_PARTITION, true);
         config.set(IDS_FLUSH,false);
         return config;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDAuthority.java
Patch:
@@ -86,7 +86,7 @@ public ConsistentKeyIDAuthority(KeyColumnValueStore idStore, StoreManager manage
         this.waitGracePeriod = idApplicationWaitMS.multiply(0.1D);
         Preconditions.checkNotNull(times);
 
-        partitionBitWdith = config.has(CLUSTER_PARTITION)? NumberUtil.getPowerOf2(config.get(CLUSTER_MAX_PARTITIONS)):0;
+        partitionBitWdith = NumberUtil.getPowerOf2(config.get(CLUSTER_MAX_PARTITIONS));
         Preconditions.checkArgument(partitionBitWdith>=0 && partitionBitWdith<=16);
 
         uniqueIdBitWidth = config.get(IDAUTHORITY_CAV_BITS);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/placement/PartitionIDRange.java
Patch:
@@ -113,6 +113,9 @@ public int getRandomID() {
         return (random.nextInt(partitionWidth) + lowerID) % idUpperBound;
     }
 
+    /*
+    =========== Helper methods to generate PartitionIDRanges ============
+     */
 
     public static List<PartitionIDRange> getGlobalRange(final int partitionBits) {
         Preconditions.checkArgument(partitionBits>=0 && partitionBits<(Integer.SIZE-1),"Invalid partition bits: %s",partitionBits);

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/HBaseStorageSetup.java
Patch:
@@ -76,7 +76,6 @@ public static ModifiableConfiguration getHBaseConfiguration(String tableName) {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, "hbase");
         if (!StringUtils.isEmpty(tableName)) config.set(HBaseStoreManager.HBASE_TABLE,tableName);
-        config.set(GraphDatabaseConfiguration.CLUSTER_PARTITION, true);
         config.set(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER, HBaseStoreManager.PREFERRED_TIMESTAMPS);
         config.set(SimpleBulkPlacementStrategy.CONCURRENT_PARTITIONS, 1);
 //        config.set(GraphDatabaseConfiguration.STORAGE_NS.getName()+"."+HBaseStoreManager.HBASE_CONFIGURATION_NAMESPACE+

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthorityTest.java
Patch:
@@ -134,7 +134,6 @@ public void open() throws BackendException {
                 log.debug("Setting unique instance id: {}", uniqueGraphId);
                 sc.set(UNIQUE_INSTANCE_ID, uniqueGraphId);
             }
-            sc.set(GraphDatabaseConfiguration.CLUSTER_PARTITION,true);
             sc.set(GraphDatabaseConfiguration.CLUSTER_MAX_PARTITIONS,MAX_NUM_PARTITIONS);
 
             manager[i] = openStorageManager();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -230,7 +230,7 @@ private Log openLog(String logManagerName, String logName) {
             }
             StoreFeatures f = logStoreManager.getFeatures();
             boolean part = f.isDistributed() && f.isKeyOrdered();
-            configuration.set(GraphDatabaseConfiguration.CLUSTER_PARTITION, part);
+            if (part) configuration.set(KCVSLogManager.LOG_MAX_PARTITIONS,4);
             assert logStoreManager!=null;
             if (!logManagers.containsKey(logManagerName)) {
                 //Open log manager - only supports KCVSLog

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/KCVSConfiguration.java
Patch:
@@ -11,7 +11,6 @@
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
-import com.thinkaurelius.titan.diskstorage.util.time.ZeroDuration;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.ConcurrentWriteConfiguration;
@@ -22,7 +21,6 @@
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
 import com.thinkaurelius.titan.graphdb.database.serialize.StandardSerializer;
 
@@ -69,7 +67,7 @@ public KCVSConfiguration(BackendOperation.TransactionalProvider txProvider, Conf
 
     public void setMaxOperationWaitTime(Duration waitTime) {
 
-        Preconditions.checkArgument(ZeroDuration.INSTANCE.compareTo(waitTime) < 0,
+        Preconditions.checkArgument(StandardDuration.ZERO.compareTo(waitTime) < 0,
                 "Wait time must be nonnegative: %s", waitTime);
         this.maxOperationWaitTime = waitTime;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/Timer.java
Patch:
@@ -50,7 +50,7 @@ public Timer stop() {
 
     public Duration elapsed() {
         if (null == start) {
-            return ZeroDuration.INSTANCE;
+            return StandardDuration.ZERO;
         }
         final Timepoint stopTime = (null==stop? times.getTime() : stop);
         return new StandardDuration(stopTime.getNativeTimestamp() - start.getNativeTimestamp(), times.getUnit());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StandardDurationSerializer.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
 import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StandardTimepointSerializer.java
Patch:
@@ -6,6 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardTimepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 
@@ -14,7 +15,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public class StandardTimepointSerializer implements AttributeSerializer<StandardTimepoint> {
+public class StandardTimepointSerializer implements AttributeSerializer<Timepoint> {
 
     private final LongSerializer longs = new LongSerializer();
     private final EnumSerializer<Timestamps> timestamp = new EnumSerializer<>(Timestamps.class);
@@ -27,7 +28,7 @@ public StandardTimepoint read(ScanBuffer buffer) {
     }
 
     @Override
-    public void write(WriteBuffer buffer, StandardTimepoint attribute) {
+    public void write(WriteBuffer buffer, Timepoint attribute) {
         TimestampProvider provider = attribute.getProvider();
         Preconditions.checkArgument(provider instanceof Timestamps,"Cannot serialize time point due to invalid provider: %s",attribute);
         timestamp.write(buffer, (Timestamps)provider);

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/BerkeleySolrTest.java
Patch:
@@ -22,6 +22,7 @@ public WriteConfiguration getConfiguration() {
         //Add index
         config.set(INDEX_BACKEND,"solr",INDEX);
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), INDEX);
+        config.set(SolrIndex.WAIT_SEARCHER, true, INDEX);
         //TODO: set SOLR specific config options
         return config.getConfiguration();
     }

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrIndexTest.java
Patch:
@@ -54,7 +54,7 @@ private Configuration getLocalSolrTestConfig() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();
 
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), index);
-
+        config.set(SolrIndex.WAIT_SEARCHER, true, index);
         return config.restrictTo(index);
     }
 

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/ThriftSolrTest.java
Patch:
@@ -22,7 +22,7 @@ public WriteConfiguration getConfiguration() {
                 CassandraStorageSetup.getCassandraThriftConfiguration(ThriftSolrTest.class.getName());
         //Add index
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), INDEX);
-
+        config.set(SolrIndex.WAIT_SEARCHER, true, INDEX);
         config.set(INDEX_BACKEND,"solr",INDEX);
         //TODO: set SOLR specific config options
         return config.getConfiguration();

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/BerkeleySolrTest.java
Patch:
@@ -22,6 +22,7 @@ public WriteConfiguration getConfiguration() {
         //Add index
         config.set(INDEX_BACKEND,"solr",INDEX);
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), INDEX);
+        config.set(SolrIndex.WAIT_SEARCHER, true, INDEX);
         //TODO: set SOLR specific config options
         return config.getConfiguration();
     }

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrIndexTest.java
Patch:
@@ -54,7 +54,7 @@ private Configuration getLocalSolrTestConfig() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();
 
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), index);
-
+        config.set(SolrIndex.WAIT_SEARCHER, true, index);
         return config.restrictTo(index);
     }
 

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/ThriftSolrTest.java
Patch:
@@ -22,7 +22,7 @@ public WriteConfiguration getConfiguration() {
                 CassandraStorageSetup.getCassandraThriftConfiguration(ThriftSolrTest.class.getName());
         //Add index
         config.set(SolrIndex.ZOOKEEPER_URL, SolrRunner.getMiniCluster().getZkServer().getZkAddress(), INDEX);
-
+        config.set(SolrIndex.WAIT_SEARCHER, true, INDEX);
         config.set(INDEX_BACKEND,"solr",INDEX);
         //TODO: set SOLR specific config options
         return config.getConfiguration();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/MultiVertexCentricQueryBuilder.java
Patch:
@@ -87,7 +87,7 @@ protected<Q> Map<TitanVertex,Q> execute(RelationCategory returnType, ResultConst
                 for (InternalVertex v : vertices) {
                     if (isPartitionedVertex(v)) {
                         adjVertices.remove(v);
-                        adjVertices.addAll(allRepresentatives(v));
+                        adjVertices.addAll(allRequiredRepresentatives(v));
                     }
                 }
                 tx.executeMultiQuery(adjVertices, sq.getBackendQuery());

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Geoshape.java
Patch:
@@ -511,8 +511,8 @@ public void write(WriteBuffer buffer, Geoshape attribute) {
      */
     public static class GeoshapeGsonSerializer extends StdSerializer<Geoshape> {
 
-        public GeoshapeGsonSerializer(Class<Geoshape> t) {
-            super(t);
+        public GeoshapeGsonSerializer() {
+            super(Geoshape.class);
         }
 
         @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/io/graphson/TitanGraphSONModule.java
Patch:
@@ -7,6 +7,7 @@
 import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
+import com.thinkaurelius.titan.core.attribute.Geoshape;
 import com.thinkaurelius.titan.graphdb.relations.RelationIdentifier;
 
 import java.io.IOException;
@@ -18,6 +19,7 @@ public class TitanGraphSONModule extends SimpleModule {
 
     private TitanGraphSONModule() {
         addSerializer(RelationIdentifier.class, new RelationIdentifierSerializer());
+        addSerializer(Geoshape.class, new Geoshape.GeoshapeGsonSerializer());
     }
 
     private static final TitanGraphSONModule INSTANCE = new TitanGraphSONModule();

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/attribute/GeoshapeTest.java
Patch:
@@ -218,7 +218,7 @@ public void testGeoJsonGeometry() throws IOException {
     @Test
     public void testGeoJsonSerialization() throws IOException {
         SimpleModule module = new SimpleModule();
-        module.addSerializer(new Geoshape.GeoshapeGsonSerializer(Geoshape.class));
+        module.addSerializer(new Geoshape.GeoshapeGsonSerializer());
         final ObjectMapper om = new ObjectMapper();
         om.registerModule(module);
         assertEquals("{\"type\":\"Point\",\"coordinates\":[20.5,10.5]}", om.writeValueAsString(Geoshape.point(10.5, 20.5)));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardSerializer.java
Patch:
@@ -76,7 +76,7 @@ public StandardSerializer() {
         registrations = HashBiMap.create(60);
 
         //Setup
-        registerClassInternal(1, Object.class, new NoSerializer<>(Object.class));
+        registerClassInternal(1, Object.class, new ObjectSerializer());
 
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanIndexQuery.java
Patch:
@@ -1,9 +1,7 @@
 package com.thinkaurelius.titan.core;
 
 import com.thinkaurelius.titan.core.schema.Parameter;
-import org.apache.tinkerpop.gremlin.structure.Edge;
 import org.apache.tinkerpop.gremlin.structure.Element;
-import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
  * A GraphQuery that queries for graph elements directly against a particular indexing backend and hence allows this

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Timestamp.java
Patch:
@@ -15,8 +15,6 @@ public class Timestamp implements Comparable<Timestamp> {
     private long sinceEpoch;
     private TimeUnit unit;
 
-    private Timestamp() {} //For Kryo serialization
-
     public Timestamp(long sinceEpoch, TimeUnit unit) {
         Preconditions.checkNotNull(unit);
         this.sinceEpoch = sinceEpoch;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/Parameter.java
Patch:
@@ -15,8 +15,6 @@ public class Parameter<V> {
     private String key;
     private V value;
 
-    private Parameter() {} //For serialization
-
     public Parameter(String key, V value) {
         Preconditions.checkArgument(StringUtils.isNotBlank(key),"Invalid key");
         this.key = key;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -429,8 +429,7 @@ private static KCVSConfiguration getConfiguration(final BackendOperation.Transac
                                                             final Configuration config) {
         try {
             KCVSConfiguration kcvsConfig =
-                    new KCVSConfiguration(txProvider,config,store,identifier,
-                            config.get(GraphDatabaseConfiguration.KRYO_INSTANCE_CACHE));
+                    new KCVSConfiguration(txProvider,config,store,identifier);
             kcvsConfig.setMaxOperationWaitTime(config.get(SETUP_WAITTIME));
             return kcvsConfig;
         } catch (BackendException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLogManager.java
Patch:
@@ -14,7 +14,6 @@
 import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.graphdb.database.idassigner.placement.PartitionIDRange;
 import com.thinkaurelius.titan.graphdb.database.serialize.StandardSerializer;
-import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoInstanceCacheImpl;
 import com.thinkaurelius.titan.util.encoding.ConversionHelper;
 import com.thinkaurelius.titan.util.stats.NumberUtil;
 import com.thinkaurelius.titan.util.system.IOUtils;
@@ -179,8 +178,7 @@ public KCVSLogManager(KeyColumnValueStoreManager storeManager, final Configurati
             this.readPartitionIds=new int[]{0};
         }
 
-        KryoInstanceCacheImpl kcache = configuration.get(GraphDatabaseConfiguration.KRYO_INSTANCE_CACHE);
-        this.serializer = new StandardSerializer(false, kcache);
+        this.serializer = new StandardSerializer();
     }
 
     private static void checkValidPartitionId(int partitionId, int partitionBitWidth) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/AttributeHandler.java
Patch:
@@ -1,13 +1,13 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
-import com.thinkaurelius.titan.core.attribute.AttributeHandler;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface AttributeHandling {
+public interface AttributeHandler {
 
-    public <T> void registerClass(Class<T> type, AttributeHandler<T> attributeHandler);
+    public <T> void registerClass(int registrationNo, Class<T> type, AttributeSerializer<T> attributeHandler);
 
     public boolean validDataType(Class datatype);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/SupportsNullSerializer.java
Patch:
@@ -1,5 +1,8 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
+import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
+
 /**
  * Marker interface to indicate that a given serializer supports serializing
  * null values effectively.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/StandardTransactionId.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.graphdb.log;
 
+import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.attribute.Timestamp;
 import com.thinkaurelius.titan.core.log.TransactionId;
 import org.apache.commons.lang.builder.HashCodeBuilder;
@@ -13,9 +14,8 @@ public class StandardTransactionId implements TransactionId {
     private long transactionId;
     private Timestamp transactionTime;
 
-    private StandardTransactionId() {} //For serialization
-
     public StandardTransactionId(String instanceId, long transactionId, Timestamp transactionTime) {
+        Preconditions.checkArgument(instanceId!=null && transactionId>=0 && transactionTime!=null);
         this.instanceId = instanceId;
         this.transactionId = transactionId;
         this.transactionTime = transactionTime;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardEdgeLabelMaker.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.core.schema.EdgeLabelMaker;
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.graphdb.database.IndexSerializer;
-import com.thinkaurelius.titan.graphdb.database.serialize.AttributeHandling;
+import com.thinkaurelius.titan.graphdb.database.serialize.AttributeHandler;
 import com.thinkaurelius.titan.graphdb.internal.Order;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
@@ -24,7 +24,7 @@ public class StandardEdgeLabelMaker extends StandardRelationTypeMaker implements
 
     public StandardEdgeLabelMaker(final StandardTitanTx tx,
                                   final String name, final IndexSerializer indexSerializer,
-                                  final AttributeHandling attributeHandler) {
+                                  final AttributeHandler attributeHandler) {
         super(tx, name, indexSerializer, attributeHandler);
         unidirectionality = Direction.BOTH;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardPropertyKeyMaker.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.core.schema.PropertyKeyMaker;
 import com.thinkaurelius.titan.graphdb.database.IndexSerializer;
-import com.thinkaurelius.titan.graphdb.database.serialize.AttributeHandling;
+import com.thinkaurelius.titan.graphdb.database.serialize.AttributeHandler;
 import com.thinkaurelius.titan.graphdb.internal.Order;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
@@ -24,7 +24,7 @@ public class StandardPropertyKeyMaker extends StandardRelationTypeMaker implemen
     private Class<?> dataType;
 
     public StandardPropertyKeyMaker(StandardTitanTx tx, String name, IndexSerializer indexSerializer,
-                                    final AttributeHandling attributeHandler) {
+                                    final AttributeHandler attributeHandler) {
         super(tx, name, indexSerializer, attributeHandler);
         dataType = null;
         cardinality(Cardinality.SINGLE);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeDefinitionDescription.java
Patch:
@@ -10,8 +10,6 @@ public class TypeDefinitionDescription {
     private TypeDefinitionCategory category;
     private Object modifier;
 
-    private TypeDefinitionDescription() {} //For Kryo
-
     public TypeDefinitionDescription(TypeDefinitionCategory category, Object modifier) {
         Preconditions.checkNotNull(category);
         if (category.isProperty()) Preconditions.checkArgument(modifier==null);

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -395,7 +395,7 @@ public void register(String store, String key, KeyInformation information, BaseT
             } else if (dataType == Float.class) {
                 log.debug("Registering float type for {}", key);
                 mapping.field("type", "float");
-            } else if (dataType == Double.class || dataType == Decimal.class || dataType == Precision.class) {
+            } else if (dataType == Double.class) {
                 log.debug("Registering double type for {}", key);
                 mapping.field("type", "double");
             } else if (dataType == Byte.class) {

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -464,7 +464,7 @@ public void testUUIDIndexing() {
     @Test
     public void testConditionalIndexing() {
         PropertyKey name = makeKey("name", String.class);
-        PropertyKey weight = makeKey("weight",Decimal.class);
+        PropertyKey weight = makeKey("weight",Double.class);
         PropertyKey text = makeKey("text", String.class);
 
         VertexLabel person = mgmt.makeVertexLabel("person").make();
@@ -640,7 +640,7 @@ public void testConditionalIndexing() {
     @Test
     public void testCompositeAndMixedIndexing() {
         PropertyKey name = makeKey("name", String.class);
-        PropertyKey weight = makeKey("weight",Decimal.class);
+        PropertyKey weight = makeKey("weight",Double.class);
         PropertyKey text = makeKey("text", String.class);
         PropertyKey flag = makeKey("flag",Boolean.class);
 
@@ -1043,7 +1043,7 @@ public void testIndexUpdatesWithoutReindex() throws InterruptedException, Execut
         //Creates types and index only one key
         PropertyKey time = mgmt.makePropertyKey("time").dataType(Integer.class).make();
         PropertyKey text = mgmt.makePropertyKey("text").dataType(String.class).make();
-        PropertyKey height = mgmt.makePropertyKey("height").dataType(Decimal.class).make();
+        PropertyKey height = mgmt.makePropertyKey("height").dataType(Double.class).make();
         TitanGraphIndex index = mgmt.buildIndex("theIndex",Vertex.class)
                 .addKey(text, getTextMapping(), getFieldMap(text)).buildMixedIndex(INDEX);
         finishSchema();

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/query/QueryTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.query;
 
 import com.thinkaurelius.titan.core.*;
-import com.thinkaurelius.titan.core.attribute.Decimal;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
@@ -38,7 +37,7 @@ public void shutdown() {
     @Test
     public void testOrderList() {
         PropertyKey name = tx.makePropertyKey("name").dataType(String.class).make();
-        PropertyKey weight = tx.makePropertyKey("weight").dataType(Decimal.class).make();
+        PropertyKey weight = tx.makePropertyKey("weight").dataType(Double.class).make();
         PropertyKey time = tx.makePropertyKey("time").dataType(Long.class).make();
 
         OrderList ol1 = new OrderList();

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanElement.java
Patch:
@@ -93,15 +93,15 @@ public default Object id() {
     public<V> Property<V> property(String key, V value);
 
     /**
-     * Retrieves the value associated with the given key on this vertex and casts it to the specified type.
+     * Retrieves the value associated with the given key on this element and casts it to the specified type.
      * If the key has cardinality SINGLE, then there can be at most one value and this value is returned (or null).
      * Otherwise a list of all associated values is returned, or an empty list if non exist.
      * <p/>
      *
      * @param key key
      * @return value or list of values associated with key
      */
-    public <V> V valueOrNull(RelationType key);
+    public <V> V valueOrNull(PropertyKey key);
 
     //########### LifeCycle Status ##########
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanProperty.java
Patch:
@@ -1,18 +1,17 @@
 package com.thinkaurelius.titan.core;
 
-import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.apache.tinkerpop.gremlin.structure.Property;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public interface TitanProperty<V> extends Property<V> {
 
-    public RelationType getType();
+    public PropertyKey propertyKey();
 
     @Override
     public default String key() {
-        return getType().name();
+        return propertyKey().name();
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/EdgeLabelMaker.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.titan.core.EdgeLabel;
 import com.thinkaurelius.titan.core.Multiplicity;
+import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.core.RelationType;
 
 /**
@@ -42,7 +43,7 @@ public interface EdgeLabelMaker extends RelationTypeMaker {
 
 
     @Override
-    public EdgeLabelMaker signature(RelationType... types);
+    public EdgeLabelMaker signature(PropertyKey... types);
 
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/PropertyKeyMaker.java
Patch:
@@ -38,7 +38,7 @@ public interface PropertyKeyMaker extends RelationTypeMaker {
     public PropertyKeyMaker dataType(Class<?> clazz);
 
     @Override
-    public PropertyKeyMaker signature(RelationType... types);
+    public PropertyKeyMaker signature(PropertyKey... types);
 
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/RelationTypeMaker.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.core.schema;
 
+import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.core.RelationType;
 
 /**
@@ -39,10 +40,10 @@ public interface RelationTypeMaker {
      * <br />
      * The signature is empty by default.
      *
-     * @param types RelationTypes composing the signature for the configured relation type. The order is irrelevant.
+     * @param keys PropertyKey composing the signature for the configured relation type. The order is irrelevant.
      * @return this RelationTypeMaker
      */
-    public RelationTypeMaker signature(RelationType... types);
+    public RelationTypeMaker signature(PropertyKey... keys);
 
     /**
      * Builds the configured relation type

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/ModificationDeserializer.java
Patch:
@@ -49,7 +49,7 @@ public static InternalRelation parseRelation(TransactionLogHeader.Modification m
         }
         if (state==Change.REMOVED && relCache.hasProperties()) { //copy over properties
             for (LongObjectCursor<Object> entry : relCache) {
-                rel.setPropertyDirect(tx.getExistingRelationType(entry.key),entry.value);
+                rel.setPropertyDirect(tx.getExistingPropertyKey(entry.key),entry.value);
             }
         }
         return rel;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationComparator.java
Patch:
@@ -121,10 +121,10 @@ public static int compareValues(Object v1, Object v2) {
     }
 
     private int compareOnKey(TitanRelation r1, TitanRelation r2, long typeid, Order order) {
-        return compareOnKey(r1,r2,tx.getExistingRelationType(typeid),order);
+        return compareOnKey(r1,r2,tx.getExistingPropertyKey(typeid),order);
     }
 
-    private int compareOnKey(TitanRelation r1, TitanRelation r2, RelationType type, Order order) {
+    private int compareOnKey(TitanRelation r1, TitanRelation r2, PropertyKey type, Order order) {
         Object v1 = r1.valueOrNull(type), v2 = r2.valueOrNull(type);
         return compareValues(v1, v2,order);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardEdgeLabelMaker.java
Patch:
@@ -58,13 +58,13 @@ public StandardEdgeLabelMaker multiplicity(Multiplicity multiplicity) {
     }
 
     @Override
-    public StandardEdgeLabelMaker signature(RelationType... types) {
+    public StandardEdgeLabelMaker signature(PropertyKey... types) {
         super.signature(types);
         return this;
     }
 
     @Override
-    public StandardEdgeLabelMaker sortKey(RelationType... types) {
+    public StandardEdgeLabelMaker sortKey(PropertyKey... types) {
         super.sortKey(types);
         return this;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardPropertyKeyMaker.java
Patch:
@@ -56,13 +56,13 @@ public StandardPropertyKeyMaker invisible() {
     }
 
     @Override
-    public StandardPropertyKeyMaker signature(RelationType... types) {
+    public StandardPropertyKeyMaker signature(PropertyKey... types) {
         super.signature(types);
         return this;
     }
 
     @Override
-    public StandardPropertyKeyMaker sortKey(RelationType... types) {
+    public StandardPropertyKeyMaker sortKey(PropertyKey... types) {
         super.sortKey(types);
         return this;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyVertex.java
Patch:
@@ -66,7 +66,7 @@ public VertexLabel vertexLabel() {
     }
 
     @Override
-    public <O> O valueOrNull(RelationType key) {
+    public <O> O valueOrNull(PropertyKey key) {
         if (key instanceof ImplicitKey) return ((ImplicitKey)key).computeProperty(this);
         return null;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -125,7 +125,7 @@ public VertexCentricQueryBuilder query() {
     }
 
     @Override
-    public <O> O valueOrNull(RelationType key) {
+    public <O> O valueOrNull(PropertyKey key) {
         return (O)property(key.name()).orElse(null);
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/TestBed.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan;
 
-import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
@@ -51,11 +50,11 @@ private static final void doSomethingExpensive(int milliseconds) {
      * @throws java.io.IOException
      */
     public static void main(String[] args) throws Exception {
-        IDHandler.EdgeTypeParse ep = IDHandler.readEdgeType(StaticArrayBuffer.of(new byte[]{36}).asReadBuffer());
+        IDHandler.RelationTypeParse ep = IDHandler.readRelationType(StaticArrayBuffer.of(new byte[]{36}).asReadBuffer());
         System.out.println(ep.typeId + " "+ BaseLabel.VertexLabelEdge.longId());
 
         WriteBuffer out = new WriteByteBuffer(20);
-        IDHandler.writeEdgeType(out, BaseKey.VertexExists.longId(),IDHandler.DirectionID.PROPERTY_DIR, BaseKey.VertexExists.isInvisibleType());
+        IDHandler.writeRelationType(out, BaseKey.VertexExists.longId(), IDHandler.DirectionID.PROPERTY_DIR, BaseKey.VertexExists.isInvisibleType());
         StaticBuffer b = out.getStaticBuffer();
         System.exit(0);
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/process/groovy/BerkeleyTitanGroovyProcessComputerTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.blueprints.process.groovy;
 
+import com.thinkaurelius.titan.blueprints.BerkeleyGraphComputerProvider;
 import com.thinkaurelius.titan.blueprints.BerkeleyGraphProvider;
 import com.thinkaurelius.titan.core.TitanGraph;
 import org.apache.tinkerpop.gremlin.process.GroovyProcessComputerSuite;
@@ -10,6 +11,6 @@
  * @author Bryn Cooke
  */
 @RunWith(GroovyProcessComputerSuite.class)
-@ProcessStandardSuite.GraphProviderClass(provider = BerkeleyGraphProvider.class, graph = TitanGraph.class)
+@ProcessStandardSuite.GraphProviderClass(provider = BerkeleyGraphComputerProvider.class, graph = TitanGraph.class)
 public class BerkeleyTitanGroovyProcessComputerTest {
 }
\ No newline at end of file

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanBlueprintsTransaction.java
Patch:
@@ -102,7 +102,7 @@ public TitanVertex addVertex(Object... keyValues) {
         }
 
         final TitanVertex vertex = addVertex(null,label);
-        ElementHelper.attachProperties(vertex, VertexProperty.Cardinality.single, keyValues);
+        ElementHelper.attachProperties(vertex, keyValues);
         return vertex;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -866,8 +866,9 @@ public boolean apply(@Nullable Integer uniqueIdBitWidth) {
 
     public static final ConfigOption<Boolean> INDEX_NAME_MAPPING = new ConfigOption<Boolean>(INDEX_NS,"map-name",
             "Whether to use the name of the property key as the field name in the index. It must be ensured, that the" +
-                    "indexed property key names are valid field names. Renaming the property key will NOT rename the field.",
-            ConfigOption.Type.GLOBAL, false);
+                    "indexed property key names are valid field names. Renaming the property key will NOT rename the field " +
+                    "and its the developers responsibility to avoid field collisions.",
+            ConfigOption.Type.GLOBAL, true);
 
 
     // ############## Logging System ######################

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraVertexMemory.java
Patch:
@@ -137,7 +137,7 @@ public void aggregateMessage(long vertexId, M message, MessageScope scope) {
         getPartitioned(vertexId).addMessage(message,normalizeScope(scope),previousScopes,combiner);
     }
 
-    public M getAggregateMessage(long vertexId, MessageScope scope) {
+    M getAggregateMessage(long vertexId, MessageScope scope) {
         return getPartitioned(vertexId).getMessage(normalizeScope(scope),previousScopes);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexMemoryHandler.java
Patch:
@@ -87,7 +87,7 @@ public Iterator<M> receiveMessages(MessageScope messageScope) {
 
             return StreamFactory.iterable(StreamFactory.stream(reverseIncident)
                     .map(e -> {
-                        M msg = vertexMemory.getMessage(((TitanEdge) e).otherVertex(vertex).longId(), localMessageScope);
+                        M msg = vertexMemory.getMessage(vertexMemory.getCanonicalId(((TitanEdge) e).otherVertex(vertex).longId()), localMessageScope);
                         return msg == null ? null : edgeFct.apply(msg, e);
                     })
                     .filter(m -> m != null)

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyComputerTest.java
Patch:
@@ -2,14 +2,12 @@
 
 import com.thinkaurelius.titan.core.TitanGraph;
 import org.apache.tinkerpop.gremlin.process.ProcessComputerSuite;
-import org.apache.tinkerpop.gremlin.structure.StructureStandardSuite;
-import org.junit.Ignore;
 import org.junit.runner.RunWith;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 @RunWith(ProcessComputerSuite.class)
-@ProcessComputerSuite.GraphProviderClass(provider = BerkeleyNonTxGraphProvider.class, graph = TitanGraph.class)
+@ProcessComputerSuite.GraphProviderClass(provider = BerkeleyGraphComputerProvider.class, graph = TitanGraph.class)
 public class BerkeleyComputerTest {
 }
\ No newline at end of file

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyGraphComputerProvider.java
Patch:
@@ -8,7 +8,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public class BerkeleyNonTxGraphProvider extends AbstractTitanGraphProvider {
+public class BerkeleyGraphComputerProvider extends AbstractTitanGraphComputerProvider {
 
     @Override
     public ModifiableConfiguration getTitanConfiguration(String graphName, Class<?> test, String testMethodName) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/ElementHelper.java
Patch:
@@ -43,6 +43,7 @@ public static long getCompareId(Element element) {
     }
 
     public static void attachProperties(TitanElement element, Object... keyValues) {
+        if (keyValues==null || keyValues.length==0) return; //Do nothing
         org.apache.tinkerpop.gremlin.structure.util.ElementHelper.legalPropertyKeyValueArray(keyValues);
         if (org.apache.tinkerpop.gremlin.structure.util.ElementHelper.getIdValue(keyValues).isPresent()) throw Edge.Exceptions.userSuppliedIdsNotSupported();
         if (org.apache.tinkerpop.gremlin.structure.util.ElementHelper.getLabelValue(keyValues).isPresent()) throw new IllegalArgumentException("Cannot provide label as argument");

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -136,10 +136,10 @@ public <O> O valueOrNull(RelationType key) {
 
     @Override
     public<V> TitanVertexProperty<V> property(String key, V value) {
-        return tx().addProperty(it(), tx().getOrCreatePropertyKey(key), value);
+        return property(key,value,new Object[0]);
     }
 
-    public<V> VertexProperty<V> property(final String key, final V value, final Object... keyValues) {
+    public<V> TitanVertexProperty<V> property(final String key, final V value, final Object... keyValues) {
         TitanVertexProperty<V> p = tx().addProperty(it(), tx().getOrCreatePropertyKey(key), value);
         ElementHelper.attachProperties(p,keyValues);
         return p;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanBlueprintsTransaction.java
Patch:
@@ -102,7 +102,7 @@ public TitanVertex addVertex(Object... keyValues) {
         }
 
         final TitanVertex vertex = addVertex(null,label);
-        ElementHelper.attachProperties(vertex, VertexProperty.Cardinality.list, keyValues);
+        ElementHelper.attachProperties(vertex, VertexProperty.Cardinality.single, keyValues);
         return vertex;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -265,7 +265,7 @@ public boolean apply(@Nullable String s) {
     public static final ConfigOption<Boolean> VERTEXPROPERTY_SINGLE = new ConfigOption<Boolean>(SCHEMA_NS,"single-cardinality",
             "Whether calls to vertex.property(key,value) should be executed with default cardinality SINGLE overwriting " +
                     "the key's defined cardinality",
-            ConfigOption.Type.GLOBAL, false);
+            ConfigOption.Type.MASKABLE, false);
 
     private static final Map<String, DefaultSchemaMaker> preregisteredAutoType = new HashMap<String, DefaultSchemaMaker>() {{
         put("none", DisableDefaultSchemaMaker.INSTANCE);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -844,7 +844,7 @@ private void setStatusVertex(TitanSchemaVertex vertex, SchemaStatus status) {
             }
         }
         //Add new status
-        TitanVertexProperty p = transaction.addProperty(vertex, BaseKey.SchemaDefinitionProperty, status);
+        TitanVertexProperty p = transaction.addPropertyInternal(vertex, BaseKey.SchemaDefinitionProperty, status);
         p.property(BaseKey.SchemaDefinitionDesc.name(), TypeDefinitionDescription.of(TypeDefinitionCategory.STATUS));
     }
 
@@ -992,7 +992,7 @@ public void changeName(TitanSchemaElement element, String newName) {
             checkIndexName(newName);
         }
 
-        transaction.addProperty(schemaVertex, BaseKey.SchemaName, schemaCategory.getSchemaName(newName));
+        transaction.addPropertyInternal(schemaVertex, BaseKey.SchemaName, schemaCategory.getSchemaName(newName));
         updateSchemaVertex(schemaVertex);
         schemaVertex.resetCache();
         updatedTypes.add(schemaVertex);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheVertexProperty.java
Patch:
@@ -61,7 +61,7 @@ private synchronized InternalRelation update() {
         copyProperties(copy);
         copy.remove();
 
-        StandardVertexProperty u = (StandardVertexProperty) tx().addProperty(getVertex(0), propertyKey(), value());
+        StandardVertexProperty u = (StandardVertexProperty) tx().addPropertyInternal(getVertex(0), propertyKey(), value());
         if (type.getConsistencyModifier()!= ConsistencyModifier.FORK) u.setId(super.longId());
         u.setPreviousID(super.longId());
         copyProperties(u);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanLocalQueryOptimizerStrategy.java
Patch:
@@ -90,7 +90,7 @@ public void apply(final Traversal.Admin<?, ?> traversal) {
 //        });
 
         TraversalHelper.getStepsOfClass(LocalStep.class, traversal).forEach(localStep -> {
-            Traversal.Admin localTraversal = localStep.getTraversal();
+            Traversal.Admin localTraversal = ((LocalStep<?,?>)localStep).getLocalChildren().get(0);
 
             Step localStart = localTraversal.getStartStep();
             if (localStart instanceof VertexStep) {

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/AbstractTitanGraphProvider.java
Patch:
@@ -99,6 +99,7 @@ public Map<String, Object> getBaseConfiguration(String graphName, Class<?> test,
         ModifiableConfiguration conf = getTitanConfiguration(graphName,test,testMethodName);
         conf.set(GraphDatabaseConfiguration.COMPUTER_RESULT_MODE,"persist");
         conf.set(GraphDatabaseConfiguration.AUTO_TYPE, "tp3");
+        conf.set(GraphDatabaseConfiguration.VERTEXPROPERTY_SINGLE,true);
         Map<String,Object> result = new HashMap<>();
         conf.getAll().entrySet().stream().forEach( e -> result.put(ConfigElement.getPath(e.getKey().element, e.getKey().umbrellaElements),e.getValue()));
         result.put(Graph.GRAPH, TitanFactory.class.getName());

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -296,8 +296,7 @@ public void testConsistencyModifier() throws InterruptedException {
         e = getOnlyElement(v.query().direction(OUT).labels("em").edges());
         assertEquals(wintx,e.<Integer>value("sig").intValue());
         assertNotEquals(rs[4].longId(),getId(e));
-        for (Iterator<Edge> eeiter = v.edges(OUT,"emf"); eeiter.hasNext(); ) {
-            Edge ee = eeiter.next();
+        for (Edge ee : v.query().direction(OUT).labels("emf").edges()) {
             assertNotEquals(rs[5].longId(),getId(ee));
             assertEquals(uid,ee.inVertex().id());
         }
@@ -335,7 +334,7 @@ private void processTx(TitanTransaction tx, int txid, long vid, long uid) {
         e.remove();
         sign(v.addEdge("o2m",u),txid);
         for (String label : new String[]{"em","emf"}) {
-            e = getOnlyElement(v.edges(OUT,label));
+            e = getOnlyElement(v.query().direction(OUT).labels(label).edges());
             assertEquals(1,e.<Integer>value("sig").intValue());
             sign((TitanEdge)e,txid);
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphConcurrentTest.java
Patch:
@@ -374,8 +374,7 @@ public void run() {
                 // Make or break relType between two (possibly same) random nodes
                 TitanVertex source = Iterables.<TitanVertex>getOnlyElement(tx.query().has(idKey, 0).vertices());
                 TitanVertex sink = Iterables.<TitanVertex>getOnlyElement(tx.query().has(idKey, 1).vertices());
-                for (Iterator<Edge> riter = source.edges(Direction.OUT,elabel); riter.hasNext();) {
-                    Edge r = riter.next();
+                for (Edge r : source.query().direction(Direction.OUT).labels(elabel).edges()) {
                     if (getId(r.inVertex()) == getId(sink)) {
                         r.remove();
                         continue;

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -231,7 +231,7 @@ public void degreeCountingDistance() throws Exception {
 
             TitanGraphTransaction gview = null;
             switch (mode) {
-                case LOCALTX: gview = (TitanGraph) result.graph(); break;
+                case LOCALTX: gview = (TitanGraphTransaction) result.graph(); break;
                 case PERSIST: newTx(); gview = tx; break;
                 case NONE: break;
                 default: throw new AssertionError(mode);

File: titan-test/src/main/java/com/thinkaurelius/titan/testutil/TitanAssert.java
Patch:
@@ -42,7 +42,7 @@ public static boolean isEmpty(Object obj) {
         if (obj instanceof Traversal) return !((Traversal) obj).hasNext();
         else if (obj instanceof Collection) return ((Collection)obj).isEmpty();
         else if (obj instanceof Iterable) return Iterables.isEmpty((Iterable)obj);
-        else if (obj instanceof Iterator) return ((Iterator)obj).hasNext();
+        else if (obj instanceof Iterator) return !((Iterator)obj).hasNext();
         else if (obj.getClass().isArray()) return Array.getLength(obj)==0;
         throw new IllegalArgumentException("Cannot determine size of: " + obj);
     }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/TitanVertexDeserializer.java
Patch:
@@ -12,7 +12,7 @@
 import com.thinkaurelius.titan.graphdb.types.TypeInspector;
 import com.thinkaurelius.titan.hadoop.formats.util.input.SystemTypeInspector;
 import com.thinkaurelius.titan.hadoop.formats.util.input.TitanHadoopSetup;
-import org.apache.tinkerpop.gremlin.process.T;
+import org.apache.tinkerpop.gremlin.process.traversal.T;
 import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerEdge;
 import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph;
@@ -186,7 +186,7 @@ public TinkerVertex readHadoopVertex(final StaticBuffer key, Iterable<Entry> ent
         if (!foundVertexState) {
             log.trace("Vertex {} has unknown lifecycle state", vertexId);
             return null;
-        } else if (!tv.edgeIterator(Direction.BOTH).hasNext() && !tv.propertyIterator().hasNext()) {
+        } else if (!tv.edges(Direction.BOTH).hasNext() && !tv.properties().hasNext()) {
             log.trace("Vertex {} has no relations", vertexId);
             return null;
         }
@@ -197,7 +197,7 @@ public TinkerVertex getOrCreateVertex(final long vertexId, final String label, f
         TinkerVertex v;
 
         try {
-            v = (TinkerVertex)tg.V(vertexId).next();
+            v = (TinkerVertex)tg.vertices(vertexId).next();
         } catch (NoSuchElementException e) {
             if (null != label) {
                 v = (TinkerVertex) tg.addVertex(T.label, label, T.id, vertexId);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/EdgeSerializerTest.java
Patch:
@@ -4,13 +4,12 @@
 import com.thinkaurelius.titan.core.EdgeLabel;
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.core.TitanEdge;
+import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.core.schema.TitanManagement;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.graphdb.database.EdgeSerializer;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
-import org.apache.tinkerpop.gremlin.structure.Edge;
-import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -30,7 +29,7 @@ public void testValueOrdering() {
         mgmt.commit();
 
         TitanVertex v1 = graph.addVertex(), v2 = graph.addVertex();
-        Edge e1 = v1.addEdge("father",v2);
+        TitanEdge e1 = v1.addEdge("father",v2);
         for (int i=1;i<=5;i++) e1.property("key"+i,i);
 
         graph.tx().commit();

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/SerializerGraphConfiguration.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import org.apache.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 import org.junit.*;
 
 import static org.junit.Assert.*;
@@ -48,7 +49,7 @@ public void testOnlyRegisteredSerialization() {
         tx.commit();
 
         tx = graph.newTransaction();
-        v = (Vertex)tx.V().has("time",5).next();
+        v = tx.query().has("time",5).vertices().iterator().next();
         assertEquals(5.0, v.<Precision>value("any").doubleValue(),0.0);
         tx.rollback();
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeBenchmark.java
Patch:
@@ -16,6 +16,7 @@
 import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.graphdb.types.StandardEdgeLabelMaker;
+import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 
 import java.util.Random;
 import java.util.concurrent.*;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphPerformanceMemoryTest.java
Patch:
@@ -7,9 +7,11 @@
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.tinkerpop.gremlin.structure.Edge;
 import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.apache.commons.math.stat.descriptive.SummaryStatistics;
+import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
@@ -121,7 +123,7 @@ public void run() {
                         TitanVertex v = getVertex(tx,"uid", random.nextInt(maxUID) + 1);
                         assertCount(2, v.properties());
                         int count = 0;
-                        for (Edge e : v.bothE().toList()) {
+                        for (TitanEdge e : v.query().direction(Direction.BOTH).edges()) {
                             count++;
                             assertTrue(e.<Integer>value("time") >= 0);
                         }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanOperationCountingTest.java
Patch:
@@ -33,6 +33,7 @@
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.testcategory.SerialTests;
 import com.thinkaurelius.titan.util.stats.MetricManager;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.tinkerpop.gremlin.structure.Edge;
 import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.apache.tinkerpop.gremlin.structure.VertexProperty;
@@ -185,7 +186,7 @@ public void testReadOperations(boolean cache) {
             tx = graph.buildTransaction().groupName(metricsPrefix).start();
             v = getOnlyElement(tx.query().has("uid",1).vertices());
             assertEquals(1,v.<Integer>value("uid").intValue());
-            u = getOnlyElement(v.both("knows"));
+            u = getOnlyElement(v.query().direction(Direction.BOTH).labels("knows").vertices());
             e = getOnlyElement(u.query().direction(Direction.IN).labels("knows").edges());
             assertEquals("juju",u.value("name"));
             assertEquals("edge",e.value("name"));
@@ -382,7 +383,7 @@ public void checkFastPropertyAndLocking(boolean fastProperty) {
         //Check no further locks on read all
         tx = graph.buildTransaction().groupName(metricsPrefix).start();
         v = getV(tx,v);
-        for (VertexProperty p : v.properties().toList()) {
+        for (TitanVertexProperty p : v.query().properties()) {
             assertNotNull(p.value());
             assertNotNull(p.key());
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeBenchmark.java
Patch:
@@ -96,7 +96,7 @@ public void run() {
                     TitanVertex[] vs = new TitanVertex[verticesPerTask];
                     for (int j=0;j<verticesPerTask;j++) {
                         vs[j]=tx.addVertex();
-                        vs[j].singleProperty("w", random.nextInt(maxWeight));
+                        vs[j].property(VertexProperty.Cardinality.single, "w",  random.nextInt(maxWeight));
                     }
                     for (int j=0;j<verticesPerTask*10;j++) {
                         TitanEdge e = vs[random.nextInt(verticesPerTask)].addEdge("l",vs[random.nextInt(verticesPerTask)]);

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/PageRankVertexProgram.java
Patch:
@@ -75,13 +75,13 @@ public void execute(Vertex vertex, Messenger<Double> messenger, Memory memory) {
         } else if (1 == memory.getIteration()) {
             double initialPageRank = 1D / vertexCount;
             double edgeCount = StreamFactory.stream(messenger.receiveMessages(inE)).reduce(0D, (a, b) -> a + b);
-            vertex.singleProperty(PAGE_RANK, initialPageRank);
-            vertex.singleProperty(OUTGOING_EDGE_COUNT, edgeCount);
+            vertex.property(VertexProperty.Cardinality.single, PAGE_RANK,  initialPageRank);
+            vertex.property(VertexProperty.Cardinality.single, OUTGOING_EDGE_COUNT,  edgeCount);
             messenger.sendMessage(outE, initialPageRank / edgeCount);
         } else {
             double newPageRank = StreamFactory.stream(messenger.receiveMessages(outE)).reduce(0D, (a, b) -> a + b);
             newPageRank =  (dampingFactor * newPageRank) + ((1D - dampingFactor) / vertexCount);
-            vertex.singleProperty(PAGE_RANK, newPageRank);
+            vertex.property(VertexProperty.Cardinality.single, PAGE_RANK,  newPageRank);
             messenger.sendMessage(outE, newPageRank / vertex.<Double>value(OUTGOING_EDGE_COUNT));
         }
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/ShortestDistanceVertexProgram.java
Patch:
@@ -102,7 +102,7 @@ public void execute(final Vertex vertex, Messenger<Long> messenger, final Memory
                 // The seed sends a single message to start the computation
                 log.debug("Sent initial message from {}", vertex.id());
                 // The seed's distance to itself is zero
-                vertex.singleProperty(DISTANCE, 0L);
+                vertex.property(VertexProperty.Cardinality.single, DISTANCE,  0L);
                 messenger.sendMessage(incidentMessageScope, 0L);
             }
         } else {
@@ -120,7 +120,7 @@ public void execute(final Vertex vertex, Messenger<Long> messenger, final Memory
             if (!currentShortestVP.isPresent() ||
                     currentShortestVP.value() > shortestDistanceSeenOnThisIteration) {
                 // First/shortest distance seen by this vertex: store it and forward to neighbors
-                vertex.singleProperty(DISTANCE, shortestDistanceSeenOnThisIteration);
+                vertex.property(VertexProperty.Cardinality.single, DISTANCE,  shortestDistanceSeenOnThisIteration);
                 messenger.sendMessage(incidentMessageScope, shortestDistanceSeenOnThisIteration);
             }
             // else: no new winner, ergo no reason to send message to neighbors

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/EdgeSerializerTest.java
Patch:
@@ -29,7 +29,7 @@ public void testValueOrdering() {
         for (int i=1;i<=5;i++) mgmt.makePropertyKey("key" + i).dataType(Integer.class).make();
         mgmt.commit();
 
-        Vertex v1 = graph.addVertex(), v2 = graph.addVertex();
+        TitanVertex v1 = graph.addVertex(), v2 = graph.addVertex();
         Edge e1 = v1.addEdge("father",v2);
         for (int i=1;i<=5;i++) e1.property("key"+i,i);
 

File: titan-all/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/plugin/TitanGremlinPlugin.java
Patch:
@@ -6,8 +6,8 @@
 import com.thinkaurelius.titan.core.attribute.Text;
 import com.thinkaurelius.titan.example.GraphOfTheGodsFactory;
 import com.thinkaurelius.titan.graphdb.tinkerpop.computer.bulkloader.BulkLoaderVertexProgram;
-import com.tinkerpop.gremlin.groovy.plugin.GremlinPlugin;
-import com.tinkerpop.gremlin.groovy.plugin.PluginAcceptor;
+import org.apache.tinkerpop.gremlin.groovy.plugin.GremlinPlugin;
+import org.apache.tinkerpop.gremlin.groovy.plugin.PluginAcceptor;
 
 import java.util.HashSet;;
 import java.util.Set;

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyComputerTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.blueprints;
 
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.tinkerpop.gremlin.process.ProcessComputerSuite;
-import com.tinkerpop.gremlin.structure.StructureStandardSuite;
+import org.apache.tinkerpop.gremlin.process.ProcessComputerSuite;
+import org.apache.tinkerpop.gremlin.structure.StructureStandardSuite;
 import org.junit.Ignore;
 import org.junit.runner.RunWith;
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyPerformanceTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.blueprints;
 
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.tinkerpop.gremlin.process.ProcessComputerSuite;
-import com.tinkerpop.gremlin.structure.StructurePerformanceSuite;
+import org.apache.tinkerpop.gremlin.process.ProcessComputerSuite;
+import org.apache.tinkerpop.gremlin.structure.StructurePerformanceSuite;
 import org.junit.Ignore;
 import org.junit.runner.RunWith;
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyProcessTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.blueprints;
 
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.tinkerpop.gremlin.process.ProcessStandardSuite;
-import com.tinkerpop.gremlin.structure.StructureStandardSuite;
+import org.apache.tinkerpop.gremlin.process.ProcessStandardSuite;
+import org.apache.tinkerpop.gremlin.structure.StructureStandardSuite;
 import org.junit.runner.RunWith;
 
 /**

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyStructureTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.blueprints;
 
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.tinkerpop.gremlin.structure.StructureStandardSuite;
+import org.apache.tinkerpop.gremlin.structure.StructureStandardSuite;
 import org.junit.runner.RunWith;
 
 /**

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/thrift/ThriftComputerTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.tinkerpop.gremlin.process.ProcessComputerSuite;
+import org.apache.tinkerpop.gremlin.process.ProcessComputerSuite;
 import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/thrift/ThriftProcessTest.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.tinkerpop.gremlin.process.ProcessStandardSuite;
-import com.tinkerpop.gremlin.structure.StructureStandardSuite;
+import org.apache.tinkerpop.gremlin.process.ProcessStandardSuite;
+import org.apache.tinkerpop.gremlin.structure.StructureStandardSuite;
 import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/thrift/ThriftStructureTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.tinkerpop.gremlin.structure.StructureStandardSuite;
+import org.apache.tinkerpop.gremlin.structure.StructureStandardSuite;
 import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/BaseVertexQuery.java
Patch:
@@ -2,9 +2,9 @@
 package com.thinkaurelius.titan.core;
 
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Order;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
  * BaseVertexQuery constructs and executes a query over incident edges or properties from the perspective of a vertex.

File: titan-core/src/main/java/com/thinkaurelius/titan/core/Cardinality.java
Patch:
@@ -1,5 +1,7 @@
 package com.thinkaurelius.titan.core;
 
+// TODO is this vestigial now that TP3's VertexProperty.Cardinality exists?
+
 /**
  * The cardinality of the values associated with given key for a particular element.
  *

File: titan-core/src/main/java/com/thinkaurelius/titan/core/Multiplicity.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.core;
 
 import com.google.common.base.Preconditions;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * The multiplicity of edges between vertices for a given label. Multiplicity here is understood in the same sense as

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanEdge.java
Patch:
@@ -1,9 +1,9 @@
 
 package com.thinkaurelius.titan.core;
 
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
  * A TitanEdge connects two {@link TitanVertex}. It extends the functionality provided by Blueprint's {@link Edge} and

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanElement.java
Patch:
@@ -4,8 +4,8 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalElement;
 import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 import com.thinkaurelius.titan.util.datastructures.Removable;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Property;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Property;
 
 /**
  * TitanElement represents the abstract concept of an entity in the graph and specifies basic methods for interacting

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanGraphComputer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.core;
 
-import com.tinkerpop.gremlin.process.computer.GraphComputer;
+import org.apache.tinkerpop.gremlin.process.computer.GraphComputer;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanGraphQuery.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.core;
 
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
-import com.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Order;
 
 /**
  * Constructs a query against a mixed index to retrieve all elements (either vertices or edges)

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanGraphTransaction.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.core;
 
 import com.thinkaurelius.titan.core.schema.SchemaManager;
-import com.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.Graph;
 
 import java.util.Collection;
 import java.util.Map;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanIndexQuery.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.core;
 
 import com.thinkaurelius.titan.core.schema.Parameter;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
  * A GraphQuery that queries for graph elements directly against a particular indexing backend and hence allows this

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanMultiVertexQuery.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.core;
 
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Order;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import java.util.Collection;
 import java.util.Map;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanProperty.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.core;
 
-import com.tinkerpop.gremlin.structure.Graph;
-import com.tinkerpop.gremlin.structure.Property;
+import org.apache.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.Property;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanRelation.java
Patch:
@@ -1,8 +1,8 @@
 
 package com.thinkaurelius.titan.core;
 
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
  * TitanRelation is the most abstract form of a relation between a vertex and some other entity, where

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanVertexProperty.java
Patch:
@@ -1,7 +1,7 @@
 
 package com.thinkaurelius.titan.core;
 
-import com.tinkerpop.gremlin.structure.VertexProperty;
+import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 
 /**
  * TitanProperty is a {@link TitanRelation} connecting a vertex to a value.

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanVertexQuery.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.core;
 
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Order;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
  * A TitanVertexQuery is a VertexQuery executed for a single vertex.

File: titan-core/src/main/java/com/thinkaurelius/titan/core/log/ChangeState.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.core.log;
 
 import com.thinkaurelius.titan.core.*;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import java.util.Set;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/RelationTypeIndex.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.core.schema;
 
 import com.thinkaurelius.titan.core.RelationType;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Order;
 
 /**
  * A RelationTypeIndex is an index installed on a {@link RelationType} to speed up vertex-centric indexes for that type.

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/TitanGraphIndex.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.core.schema;
 
 import com.thinkaurelius.titan.core.PropertyKey;
-import com.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Element;
 
 /**
  * A TitanGraphIndex is an index installed on the graph in order to be able to efficiently retrieve graph elements

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/TitanManagement.java
Patch:
@@ -3,9 +3,9 @@
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.scan.ScanMetrics;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Order;
 
 import java.util.Set;
 import java.util.concurrent.Future;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/KCVSConfiguration.java
Patch:
@@ -28,7 +28,7 @@
 
 import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoInstanceCacheImpl;
 import com.thinkaurelius.titan.util.system.IOUtils;
-import com.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.apache.commons.lang.StringUtils;
 
 import javax.annotation.Nullable;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -35,7 +35,7 @@
 import com.thinkaurelius.titan.util.system.ConfigurationUtil;
 import com.thinkaurelius.titan.util.system.NetworkUtil;
 
-import com.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.Graph;
 import info.ganglia.gmetric4j.gmetric.GMetric.UDPAddressingMode;
 
 import java.io.File;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/EdgeSerializer.java
Patch:
@@ -25,7 +25,7 @@
 import com.thinkaurelius.titan.graphdb.types.TypeInspector;
 import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 import com.thinkaurelius.titan.util.datastructures.Interval;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/RelationFactory.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database;
 
 import com.thinkaurelius.titan.core.RelationType;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/RelationQueryCache.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelationType;
 import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.io.Closeable;
 import java.util.EnumMap;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -64,8 +64,8 @@
 import com.thinkaurelius.titan.graphdb.vertices.CacheVertex;
 import com.thinkaurelius.titan.graphdb.vertices.PreloadedVertex;
 import com.thinkaurelius.titan.graphdb.vertices.StandardVertex;
-import com.tinkerpop.gremlin.process.TraversalStrategies;
-import com.tinkerpop.gremlin.structure.*;
+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategies;
+import org.apache.tinkerpop.gremlin.structure.*;
 import com.thinkaurelius.titan.util.system.TXUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/cache/MetricInstrumentedSchemaCache.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.system.BaseRelationType;
 import com.thinkaurelius.titan.util.stats.MetricManager;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/cache/SchemaCache.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.thinkaurelius.titan.diskstorage.EntryList;
 import com.thinkaurelius.titan.graphdb.types.system.BaseRelationType;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * This interface defines the methods that a SchemaCache must implement. A SchemaCache is maintained by the Titan graph

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/cache/StandardSchemaCache.java
Patch:
@@ -10,7 +10,7 @@
 import com.thinkaurelius.titan.graphdb.types.system.BaseLabel;
 import com.thinkaurelius.titan.graphdb.types.system.BaseRelationType;
 import com.thinkaurelius.titan.graphdb.types.system.SystemRelationType;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.cliffc.high_scale_lib.NonBlockingHashMapLong;
 
 import java.util.Iterator;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
 import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import static com.thinkaurelius.titan.graphdb.idmanagement.IDManager.VertexIDType.*;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/RelationTypeIndexWrapper.java
Patch:
@@ -6,8 +6,8 @@
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelationType;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Order;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/TitanGraphIndexWrapper.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.graphdb.types.MixedIndexType;
 import com.thinkaurelius.titan.graphdb.types.IndexField;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
-import com.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Element;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -22,7 +22,7 @@
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionDescription;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardTimepoint;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.*;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/ElementCategory.java
Patch:
@@ -7,9 +7,9 @@
 import com.thinkaurelius.titan.graphdb.types.VertexLabelVertex;
 import com.thinkaurelius.titan.graphdb.types.vertices.EdgeLabelVertex;
 import com.thinkaurelius.titan.graphdb.types.vertices.PropertyKeyVertex;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
 * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalRelationType.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.core.RelationType;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * Internal Type interface adding methods that should only be used by Titan

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/TitanSchemaCategory.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionMap;
 import com.thinkaurelius.titan.graphdb.types.TypeUtil;
-import com.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Element;
 import org.apache.commons.lang.StringUtils;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/Token.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.internal;
 
 import com.google.common.base.Preconditions;
-import com.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.apache.commons.lang.StringUtils;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/ModificationDeserializer.java
Patch:
@@ -12,7 +12,7 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
 import com.thinkaurelius.titan.graphdb.relations.*;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/StandardChangeState.java
Patch:
@@ -8,8 +8,8 @@
 import com.thinkaurelius.titan.core.log.ChangeState;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import javax.annotation.Nullable;
 import java.util.EnumMap;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/QueryContainer.java
Patch:
@@ -12,8 +12,8 @@
 import com.thinkaurelius.titan.graphdb.query.vertex.BaseVertexCentricQuery;
 import com.thinkaurelius.titan.graphdb.query.vertex.BasicVertexCentricQueryBuilder;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Order;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Order;
 import org.apache.commons.lang.StringUtils;
 
 import java.util.*;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraMapEmitter.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.olap.computer;
 
-import com.tinkerpop.gremlin.process.computer.MapReduce;
-import com.tinkerpop.gremlin.tinkergraph.process.computer.TinkerMapEmitter;
+import org.apache.tinkerpop.gremlin.process.computer.MapReduce;
+import org.apache.tinkerpop.gremlin.tinkergraph.process.computer.TinkerMapEmitter;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraMemory.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.graphdb.olap.computer;
 
-import com.tinkerpop.gremlin.process.computer.MapReduce;
-import com.tinkerpop.gremlin.process.computer.VertexProgram;
-import com.tinkerpop.gremlin.tinkergraph.process.computer.TinkerMemory;
+import org.apache.tinkerpop.gremlin.process.computer.MapReduce;
+import org.apache.tinkerpop.gremlin.process.computer.VertexProgram;
+import org.apache.tinkerpop.gremlin.tinkergraph.process.computer.TinkerMemory;
 
 import java.util.Set;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraReduceEmitter.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.graphdb.olap.computer;
 
-import com.tinkerpop.gremlin.process.computer.MapReduce;
-import com.tinkerpop.gremlin.tinkergraph.process.computer.TinkerReduceEmitter;
-import com.tinkerpop.gremlin.process.computer.KeyValue;
+import org.apache.tinkerpop.gremlin.process.computer.MapReduce;
+import org.apache.tinkerpop.gremlin.tinkergraph.process.computer.TinkerReduceEmitter;
+import org.apache.tinkerpop.gremlin.process.computer.KeyValue;
 
 import java.util.Queue;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/PartitionVertexAggregate.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.graphdb.olap.computer;
 
 import com.thinkaurelius.titan.diskstorage.EntryList;
-import com.tinkerpop.gremlin.process.computer.MessageCombiner;
-import com.tinkerpop.gremlin.process.computer.MessageScope;
+import org.apache.tinkerpop.gremlin.process.computer.MessageCombiner;
+import org.apache.tinkerpop.gremlin.process.computer.MessageScope;
 
 import java.util.Collections;
 import java.util.Map;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexMapJob.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.graphdb.olap.VertexJobConverter;
 import com.thinkaurelius.titan.graphdb.olap.VertexScanJob;
 import com.thinkaurelius.titan.graphdb.vertices.PreloadedVertex;
-import com.tinkerpop.gremlin.process.computer.MapReduce;
+import org.apache.tinkerpop.gremlin.process.computer.MapReduce;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexState.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.graphdb.olap.computer;
 
 import com.google.common.base.Preconditions;
-import com.tinkerpop.gremlin.process.computer.MessageCombiner;
-import com.tinkerpop.gremlin.process.computer.MessageScope;
+import org.apache.tinkerpop.gremlin.process.computer.MessageCombiner;
+import org.apache.tinkerpop.gremlin.process.computer.MessageScope;
 
 import java.util.HashSet;
 import java.util.Map;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexRemoveJob.java
Patch:
@@ -34,8 +34,8 @@
 import com.thinkaurelius.titan.graphdb.types.CompositeIndexType;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.util.StreamFactory;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.util.StreamFactory;
 
 import java.util.ArrayList;
 import java.util.List;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexRepairJob.java
Patch:
@@ -27,7 +27,7 @@
 import com.thinkaurelius.titan.graphdb.types.MixedIndexType;
 import com.thinkaurelius.titan.graphdb.types.system.BaseLabel;
 import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.*;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -10,7 +10,7 @@
 import com.thinkaurelius.titan.graphdb.query.condition.*;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.system.SystemTypeManager;
-import com.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.Graph;
 
 import javax.annotation.Nullable;
 import java.util.*;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/TitanPredicate.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.thinkaurelius.titan.core.attribute.Cmp;
 import com.thinkaurelius.titan.core.attribute.Contain;
-import com.tinkerpop.gremlin.structure.Compare;
-import com.tinkerpop.gremlin.structure.Contains;
+import org.apache.tinkerpop.gremlin.structure.Compare;
+import org.apache.tinkerpop.gremlin.structure.Contains;
 
 import java.util.function.BiPredicate;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/DirectionCondition.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.core.TitanRelation;
 import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.graphdb.relations.CacheEdge;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/IncidenceDirectionCondition.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.core.TitanEdge;
 import com.thinkaurelius.titan.core.TitanRelation;
 import com.thinkaurelius.titan.core.TitanVertex;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/PredicateCondition.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalRelationType;
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
 import com.thinkaurelius.titan.graphdb.util.ElementHelper;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 import java.util.Iterator;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/GraphCentricQueryBuilder.java
Patch:
@@ -118,7 +118,7 @@ public GraphCentricQueryBuilder limit(final int limit) {
     }
 
     @Override
-    public GraphCentricQueryBuilder orderBy(String keyName, com.tinkerpop.gremlin.structure.Order order) {
+    public GraphCentricQueryBuilder orderBy(String keyName, org.apache.tinkerpop.gremlin.structure.Order order) {
         Preconditions.checkArgument(tx.containsPropertyKey(keyName),"Provided key does not exist: %s",keyName);
         PropertyKey key = tx.getPropertyKey(keyName);
         Preconditions.checkArgument(key!=null && order!=null,"Need to specify and key and an order");

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/IndexQueryBuilder.java
Patch:
@@ -12,9 +12,9 @@
 import com.thinkaurelius.titan.graphdb.internal.ElementCategory;
 import com.thinkaurelius.titan.graphdb.query.BaseQuery;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/BaseVertexCentricQuery.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.graphdb.query.QueryUtil;
 import com.thinkaurelius.titan.graphdb.query.condition.Condition;
 import com.thinkaurelius.titan.graphdb.query.condition.FixedCondition;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.ArrayList;
 import java.util.List;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/BaseVertexCentricQueryBuilder.java
Patch:
@@ -12,7 +12,7 @@
 import com.thinkaurelius.titan.graphdb.relations.RelationIdentifier;
 import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 import com.thinkaurelius.titan.graphdb.types.system.SystemRelationType;
-import com.tinkerpop.gremlin.structure.*;
+import org.apache.tinkerpop.gremlin.structure.*;
 import org.apache.commons.lang.StringUtils;
 
 import java.util.*;
@@ -174,7 +174,7 @@ public Q limit(int limit) {
     }
 
     @Override
-    public Q orderBy(String keyName, com.tinkerpop.gremlin.structure.Order order) {
+    public Q orderBy(String keyName, org.apache.tinkerpop.gremlin.structure.Order order) {
         Preconditions.checkArgument(schemaInspector.containsPropertyKey(keyName),"Provided key does not exist: %s",keyName);
         PropertyKey key = schemaInspector.getPropertyKey(keyName);
         Preconditions.checkArgument(key!=null && order!=null,"Need to specify and key and an order");

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/BasicVertexCentricQueryBuilder.java
Patch:
@@ -16,7 +16,7 @@
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 import com.thinkaurelius.titan.graphdb.types.system.SystemRelationType;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import com.thinkaurelius.titan.util.datastructures.Interval;
 import com.thinkaurelius.titan.util.datastructures.PointInterval;
 import com.thinkaurelius.titan.util.datastructures.RangeInterval;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/MultiVertexCentricQueryBuilder.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
 import com.thinkaurelius.titan.graphdb.query.BackendQueryHolder;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import java.util.*;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexCentricQuery.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.graphdb.query.ElementQuery;
 import com.thinkaurelius.titan.graphdb.query.condition.Condition;
 import com.thinkaurelius.titan.graphdb.relations.RelationComparator;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.Comparator;
 import java.util.List;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexCentricQueryBuilder.java
Patch:
@@ -8,8 +8,8 @@
 import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
 import com.thinkaurelius.titan.graphdb.query.BackendQueryHolder;
 import com.thinkaurelius.titan.graphdb.query.QueryProcessor;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheEdge.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
 import com.thinkaurelius.titan.graphdb.transaction.RelationConstructor;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import javax.annotation.Nullable;
 import java.util.ArrayList;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/EdgeDirection.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.relations;
 
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * IMPORTANT: The byte values of the proper directions must be sequential,

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationCache.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.carrotsearch.hppc.LongObjectOpenHashMap;
 import com.carrotsearch.hppc.cursors.LongObjectCursor;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.*;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationComparator.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.graphdb.internal.*;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.Comparator;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationIdentifier.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.graphdb.query.vertex.VertexCentricQueryBuilder;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.util.encoding.LongEncoding;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 import java.util.Arrays;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/SimpleTitanProperty.java
Patch:
@@ -6,9 +6,9 @@
 import com.thinkaurelius.titan.core.RelationType;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelationType;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Graph;
-import com.tinkerpop.gremlin.structure.util.StringFactory;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.util.StringFactory;
 import org.apache.commons.lang3.builder.HashCodeBuilder;
 
 import java.util.NoSuchElementException;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/schema/EdgeLabelDefinition.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.thinkaurelius.titan.core.EdgeLabel;
 import com.thinkaurelius.titan.core.Multiplicity;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/schema/PropertyKeyDefinition.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.core.Cardinality;
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.core.PropertyKey;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/schema/RelationTypeDefinition.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.thinkaurelius.titan.core.Cardinality;
 import com.thinkaurelius.titan.core.Multiplicity;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanFeatures.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.tinkerpop.gremlin.structure.Graph;
-import com.tinkerpop.gremlin.structure.util.StringFactory;
+import org.apache.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.util.StringFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanGraphVariables.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.google.common.collect.Sets;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
-import com.tinkerpop.gremlin.structure.Graph;
-import com.tinkerpop.gremlin.structure.util.StringFactory;
+import org.apache.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.util.StringFactory;
 import org.apache.commons.lang3.StringUtils;
 
 import java.util.Optional;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanIo.java
Patch:
@@ -4,9 +4,9 @@
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.relations.RelationIdentifier;
 import com.thinkaurelius.titan.graphdb.tinkerpop.io.graphson.TitanGraphSONModule;
-import com.tinkerpop.gremlin.structure.io.DefaultIo;
-import com.tinkerpop.gremlin.structure.io.graphson.GraphSONMapper;
-import com.tinkerpop.gremlin.structure.io.kryo.KryoMapper;
+import org.apache.tinkerpop.gremlin.structure.io.DefaultIo;
+import org.apache.tinkerpop.gremlin.structure.io.graphson.GraphSONMapper;
+import org.apache.tinkerpop.gremlin.structure.io.kryo.KryoMapper;
 
 /**
  *

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/RelationConstructor.java
Patch:
@@ -14,7 +14,7 @@
 import com.thinkaurelius.titan.graphdb.relations.RelationCache;
 import com.thinkaurelius.titan.graphdb.types.TypeInspector;
 import com.thinkaurelius.titan.graphdb.types.TypeUtil;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.Iterator;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -61,7 +61,7 @@
 import com.thinkaurelius.titan.graphdb.vertices.StandardVertex;
 import com.thinkaurelius.titan.util.datastructures.Retriever;
 import com.thinkaurelius.titan.util.stats.MetricManager;
-import com.tinkerpop.gremlin.structure.*;
+import org.apache.tinkerpop.gremlin.structure.*;
 
 import org.apache.commons.lang.StringUtils;
 import org.cliffc.high_scale_lib.NonBlockingHashMap;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/SchemaSource.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardEdgeLabelMaker.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.graphdb.internal.Order;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import static com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory.INVISIBLE;
 import static com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory.UNIDIRECTIONAL;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardRelationTypeMaker.java
Patch:
@@ -13,8 +13,8 @@
 import com.thinkaurelius.titan.graphdb.internal.Token;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.system.SystemTypeManager;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Property;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Property;
 import org.apache.commons.lang.StringUtils;
 
 import java.util.*;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardVertexLabelMaker.java
Patch:
@@ -7,8 +7,8 @@
 import com.thinkaurelius.titan.graphdb.internal.Token;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.system.SystemTypeManager;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Graph;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.apache.commons.lang.StringUtils;
 
 import static com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory.*;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeDefinitionCategory.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.internal.ElementCategory;
 import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.Set;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeUtil.java
Patch:
@@ -9,9 +9,9 @@
 import com.thinkaurelius.titan.graphdb.internal.ElementCategory;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelationType;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Element;
-import com.tinkerpop.gremlin.structure.Property;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Property;
 import org.apache.commons.lang.StringUtils;
 
 import java.util.ArrayList;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/indextype/CompositeIndexTypeWrapper.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.types.ParameterType;
 import com.thinkaurelius.titan.graphdb.types.*;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/indextype/IndexTypeWrapper.java
Patch:
@@ -10,7 +10,7 @@
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.graphdb.types.SchemaSource;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.Map;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/indextype/MixedIndexTypeWrapper.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.core.schema.Parameter;
 import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.graphdb.types.*;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseKey.java
Patch:
@@ -15,7 +15,7 @@
 import com.thinkaurelius.titan.graphdb.types.IndexField;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionDescription;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import java.util.Collections;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseLabel.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.core.EdgeLabel;
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 public class BaseLabel extends BaseRelationType implements EdgeLabel {
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseVertexLabel.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.types.system;
 
 import com.thinkaurelius.titan.graphdb.internal.InternalVertexLabel;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -11,8 +11,8 @@
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.graphdb.internal.*;
-import com.tinkerpop.gremlin.process.T;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.process.traversal.T;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.commons.lang.StringUtils;
 import static com.thinkaurelius.titan.graphdb.internal.Token.*;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/EdgeLabelVertex.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.core.EdgeLabel;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 public class EdgeLabelVertex extends RelationTypeVertex implements EdgeLabel {
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/PropertyKeyVertex.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 public class PropertyKeyVertex extends RelationTypeVertex implements PropertyKey {
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/RelationTypeVertex.java
Patch:
@@ -12,7 +12,7 @@
 import com.thinkaurelius.titan.graphdb.types.SchemaSource;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.thinkaurelius.titan.graphdb.types.TypeUtil;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 
 import javax.annotation.Nullable;
 import java.util.List;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanSchemaVertex.java
Patch:
@@ -17,8 +17,8 @@
 import com.thinkaurelius.titan.graphdb.types.system.BaseKey;
 import com.thinkaurelius.titan.graphdb.types.system.BaseLabel;
 import com.thinkaurelius.titan.graphdb.vertices.CacheVertex;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import javax.annotation.Nullable;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/AllEdgesIterable.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.util;
 
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import java.util.Iterator;
 import java.util.Set;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/IndexHelper.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.graphdb.types.CompositeIndexType;
 import com.thinkaurelius.titan.graphdb.types.IndexField;
 import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
-import com.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.structure.Element;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/VertexCentricEdgeIterable.java
Patch:
@@ -4,9 +4,9 @@
 import com.thinkaurelius.titan.core.TitanRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
 import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import java.util.Iterator;
 import java.util.NoSuchElementException;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/PreloadedVertex.java
Patch:
@@ -13,9 +13,9 @@
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.util.ElementHelper;
 import com.thinkaurelius.titan.util.datastructures.Retriever;
-import com.tinkerpop.gremlin.structure.Direction;
-import com.tinkerpop.gremlin.structure.Vertex;
-import com.tinkerpop.gremlin.structure.VertexProperty;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 
 import java.util.Collections;
 import java.util.Iterator;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/StandardVertex.java
Patch:
@@ -12,7 +12,7 @@
 import com.thinkaurelius.titan.graphdb.transaction.addedrelations.ConcurrentAddedRelations;
 import com.thinkaurelius.titan.graphdb.transaction.addedrelations.SimpleAddedRelations;
 import com.thinkaurelius.titan.util.datastructures.Retriever;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 
 import java.util.Collection;
 import java.util.Collections;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/GiraphInputFormat.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.hadoop.formats.util.input.TitanHadoopSetup;
 import com.thinkaurelius.titan.util.system.ConfigurationUtil;
-import com.tinkerpop.gremlin.hadoop.structure.io.VertexWritable;
+import org.apache.tinkerpop.gremlin.hadoop.structure.io.VertexWritable;
 import org.apache.hadoop.conf.Configurable;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.io.NullWritable;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/GiraphRecordReader.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
-import com.tinkerpop.gremlin.hadoop.structure.io.VertexWritable;
-import com.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex;
+import org.apache.tinkerpop.gremlin.hadoop.structure.io.VertexWritable;
+import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex;
 import org.apache.hadoop.io.NullWritable;
 import org.apache.hadoop.mapreduce.InputSplit;
 import org.apache.hadoop.mapreduce.RecordReader;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -21,7 +21,7 @@
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.formats.util.input.SystemTypeInspector;
 import com.thinkaurelius.titan.hadoop.formats.util.input.TitanHadoopSetupCommon;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.hadoop.conf.Configuration;
 
 /**

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -13,9 +13,9 @@
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.testcategory.SerialTests;
 
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
-import com.tinkerpop.gremlin.structure.VertexProperty;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 import org.slf4j.Logger;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphConcurrentTest.java
Patch:
@@ -6,8 +6,8 @@
 import com.thinkaurelius.titan.testcategory.PerformanceTests;
 import com.thinkaurelius.titan.testutil.JUnitBenchmarkProvider;
 import com.thinkaurelius.titan.testutil.RandomGenerator;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphPerformanceMemoryTest.java
Patch:
@@ -7,8 +7,8 @@
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.apache.commons.math.stat.descriptive.SummaryStatistics;
 import org.junit.Rule;
 import org.junit.Test;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -24,9 +24,9 @@
 import com.thinkaurelius.titan.graphdb.types.StandardEdgeLabelMaker;
 import com.thinkaurelius.titan.testcategory.BrittleTests;
 import com.thinkaurelius.titan.testutil.TestGraphConfigs;
-import com.tinkerpop.gremlin.process.T;
-import com.tinkerpop.gremlin.process.graph.GraphTraversal;
-import com.tinkerpop.gremlin.structure.*;
+import org.apache.tinkerpop.gremlin.process.T;
+import org.apache.tinkerpop.gremlin.process.graph.GraphTraversal;
+import org.apache.tinkerpop.gremlin.structure.*;
 import org.junit.Assert;
 import org.junit.Rule;
 import org.junit.Test;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanOperationCountingTest.java
Patch:
@@ -33,9 +33,9 @@
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.testcategory.SerialTests;
 import com.thinkaurelius.titan.util.stats.MetricManager;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
-import com.tinkerpop.gremlin.structure.VertexProperty;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/ShortestDistanceMessageCombiner.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.olap;
 
-import com.tinkerpop.gremlin.process.computer.MessageCombiner;
+import org.apache.tinkerpop.gremlin.process.computer.MessageCombiner;
 
 import java.util.Optional;
 

File: titan-test/src/main/java/com/thinkaurelius/titan/testutil/TitanAssert.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.testutil;
 
-import com.tinkerpop.gremlin.process.graph.GraphTraversal;
-import com.tinkerpop.gremlin.structure.Element;
+import org.apache.tinkerpop.gremlin.process.graph.GraphTraversal;
+import org.apache.tinkerpop.gremlin.structure.Element;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StaticArrayEntryTest.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntryList;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.relations.RelationCache;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.junit.Test;
 
 import javax.annotation.Nullable;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/TestCoreElements.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.core.Cardinality;
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.graphdb.internal.Order;
-import com.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.junit.Test;
 
 import static org.junit.Assert.*;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/EdgeSerializerTest.java
Patch:
@@ -9,8 +9,8 @@
 import com.thinkaurelius.titan.graphdb.database.EdgeSerializer;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
-import com.tinkerpop.gremlin.structure.Edge;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Edge;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/SerializerGraphConfiguration.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
-import com.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.structure.Vertex;
 import org.junit.*;
 
 import static org.junit.Assert.*;

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -46,6 +46,7 @@
 import org.elasticsearch.indices.IndexMissingException;
 import org.elasticsearch.node.Node;
 import org.elasticsearch.node.NodeBuilder;
+import org.elasticsearch.script.ScriptService;
 import org.elasticsearch.search.SearchHit;
 import org.elasticsearch.search.SearchHits;
 import org.elasticsearch.search.sort.FieldSortBuilder;
@@ -547,7 +548,7 @@ public void mutate(Map<String, Map<String, IndexMutation>> mutations, KeyInforma
                                 }
                                 log.trace("Deleting individual field [{}] for document {}", key, docid);
                             }
-                            brb.add(client.prepareUpdate(indexName, storename, docid).setScript(script.toString()));
+                            brb.add(client.prepareUpdate(indexName, storename, docid).setScript(script.toString(), ScriptService.ScriptType.INLINE));
                             bulkrequests++;
                         }
 

File: titan-es/src/test/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchConfigTest.java
Patch:
@@ -244,8 +244,8 @@ public void testIndexCreationOptions() throws InterruptedException, BackendExcep
         NodeBuilder nodeBuilder = NodeBuilder.nodeBuilder().settings(settingsBuilder.build());
         nodeBuilder.client(true).data(false).local(false);
         Node n = nodeBuilder.build().start();
-        GetSettingsRequest request = new GetSettingsRequestBuilder((NodeClient)n.client(), "titan").request();
-        GetSettingsResponse response = n.client().admin().indices().getSettings(request).actionGet();
+
+        GetSettingsResponse response = n.client().admin().indices().getSettings(new GetSettingsRequest().indices("titan")).actionGet();
         assertEquals(String.valueOf(shards), response.getSetting("titan", "index.number_of_shards"));
 
         n.stop();

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -46,6 +46,7 @@
 import org.elasticsearch.indices.IndexMissingException;
 import org.elasticsearch.node.Node;
 import org.elasticsearch.node.NodeBuilder;
+import org.elasticsearch.script.ScriptService;
 import org.elasticsearch.search.SearchHit;
 import org.elasticsearch.search.SearchHits;
 import org.elasticsearch.search.sort.FieldSortBuilder;
@@ -547,7 +548,7 @@ public void mutate(Map<String, Map<String, IndexMutation>> mutations, KeyInforma
                                 }
                                 log.trace("Deleting individual field [{}] for document {}", key, docid);
                             }
-                            brb.add(client.prepareUpdate(indexName, storename, docid).setScript(script.toString()));
+                            brb.add(client.prepareUpdate(indexName, storename, docid).setScript(script.toString(), ScriptService.ScriptType.INLINE));
                             bulkrequests++;
                         }
 

File: titan-es/src/test/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchConfigTest.java
Patch:
@@ -244,8 +244,8 @@ public void testIndexCreationOptions() throws InterruptedException, BackendExcep
         NodeBuilder nodeBuilder = NodeBuilder.nodeBuilder().settings(settingsBuilder.build());
         nodeBuilder.client(true).data(false).local(false);
         Node n = nodeBuilder.build().start();
-        GetSettingsRequest request = new GetSettingsRequestBuilder((NodeClient)n.client(), "titan").request();
-        GetSettingsResponse response = n.client().admin().indices().getSettings(request).actionGet();
+
+        GetSettingsResponse response = n.client().admin().indices().getSettings(new GetSettingsRequest().indices("titan")).actionGet();
         assertEquals(String.valueOf(shards), response.getSetting("titan", "index.number_of_shards"));
 
         n.stop();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementTest.java
Patch:
@@ -26,8 +26,9 @@ public abstract class ManagementTest extends TitanGraphBaseTest {
             "~T$SchemaDefinitionDescription",
             "~T$SchemaUpdateTimestamp",
             "~T$SchemaRelated",
-            "~T$VertexLabel"
-            /* "key", "vertex", "edge", "element", "property", "label"*/);
+            "~T$VertexLabel");
+            // TODO #634 add to list: "key"
+            // TODO #730 add to list: "vertex", "edge", "element", "property", "label"
 
     @Test
     public void testReservedNamesRejectedForPropertyKeys() {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -87,7 +87,7 @@ public void setUp() throws Exception {
         }
 
         open();
-        k = KeyValueStoreUtil.getBuffer("key");
+        k = KeyValueStoreUtil.getBuffer("testkey");
         c1 = KeyValueStoreUtil.getBuffer("col1");
         c2 = KeyValueStoreUtil.getBuffer("col2");
         v1 = KeyValueStoreUtil.getBuffer("val1");

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardEdgeLabelMaker.java
Patch:
@@ -22,9 +22,10 @@ public class StandardEdgeLabelMaker extends StandardRelationTypeMaker implements
 
     private Direction unidirectionality;
 
-    public StandardEdgeLabelMaker(StandardTitanTx tx, IndexSerializer indexSerializer,
+    public StandardEdgeLabelMaker(final StandardTitanTx tx,
+                                  final String name, final IndexSerializer indexSerializer,
                                   final AttributeHandling attributeHandler) {
-        super(tx, indexSerializer, attributeHandler);
+        super(tx, name, indexSerializer, attributeHandler);
         unidirectionality = Direction.BOTH;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardPropertyKeyMaker.java
Patch:
@@ -23,9 +23,9 @@ public class StandardPropertyKeyMaker extends StandardRelationTypeMaker implemen
 
     private Class<?> dataType;
 
-    public StandardPropertyKeyMaker(StandardTitanTx tx, IndexSerializer indexSerializer,
+    public StandardPropertyKeyMaker(StandardTitanTx tx, String name, IndexSerializer indexSerializer,
                                     final AttributeHandling attributeHandler) {
-        super(tx, indexSerializer, attributeHandler);
+        super(tx, name, indexSerializer, attributeHandler);
         dataType = null;
         cardinality(Cardinality.SINGLE);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -242,9 +242,6 @@ private synchronized void closeInternal() {
             IOUtils.closeQuietly(backend);
             IOUtils.closeQuietly(queryCache);
             IOUtils.closeQuietly(serializer);
-
-            // Remove shutdown hook to avoid reference retention
-            Runtime.getRuntime().removeShutdownHook(shutdownHook);
         } finally {
             isOpen = false;
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -55,6 +55,7 @@
 import com.thinkaurelius.titan.testcategory.BrittleTests;
 import com.thinkaurelius.titan.testutil.TestGraphConfigs;
 import com.tinkerpop.gremlin.process.Step;
+import com.tinkerpop.gremlin.process.T;
 import com.tinkerpop.gremlin.process.Traversal;
 import com.tinkerpop.gremlin.process.graph.step.map.LocalStep;
 import com.tinkerpop.gremlin.process.graph.step.map.OrderStep;
@@ -4506,7 +4507,7 @@ public void testVertexTTLWithCompositeIndex() throws Exception {
         assertEquals(1, mgmt.getTTL(label1).getLength(TimeUnit.SECONDS));
         mgmt.commit();
 
-        Vertex v1 = tx.addVertex("event","name", "some event","time", System.currentTimeMillis());
+        Vertex v1 = tx.addVertex(T.label, "event","name", "some event","time", System.currentTimeMillis());
         tx.commit();
         Object id = v1.id();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/scan/StandardScannerExecutor.java
Patch:
@@ -253,7 +253,7 @@ private Processor(ScanJob job, BlockingQueue<Row> processorQueue) {
         public void run() {
             try {
                 job.workerIterationStart(jobConfiguration, graphConfiguration, metrics);
-                while (!finished) {
+                while (!finished || !processorQueue.isEmpty()) {
                     Row row;
                     while ((row=processorQueue.poll(100,TimeUnit.MILLISECONDS))!=null) {
                         if (numProcessed>=workBlockSize) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -9,6 +9,7 @@
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.core.schema.TitanManagement;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDAuthority;
 import com.thinkaurelius.titan.diskstorage.indexing.*;
@@ -353,7 +354,7 @@ private StandardScanner.Builder buildStoreIndexScanJob(String storeName) {
                 .setWorkBlockSize(10000);
     }
 
-    public StandardScanner.ScanResult getScanJobStatus(Object jobId) {
+    public TitanManagement.IndexJobFuture getScanJobStatus(Object jobId) {
         return scanner.getRunningJob(jobId);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/scan/StandardScannerExecutor.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.util.concurrent.AbstractFuture;
+import com.thinkaurelius.titan.core.schema.TitanManagement;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
@@ -22,7 +23,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-class StandardScannerExecutor extends AbstractFuture<ScanMetrics> implements StandardScanner.ScanResult, Runnable {
+class StandardScannerExecutor extends AbstractFuture<ScanMetrics> implements TitanManagement.IndexJobFuture, Runnable {
 
     private static final Logger log =
             LoggerFactory.getLogger(StandardScannerExecutor.class);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/RelationIndexStatusWatcher.java
Patch:
@@ -68,7 +68,7 @@ public RelationIndexStatusReport call() throws InterruptedException {
             if (timedOut) {
                 LOGGER.info("Timed out ({}) while waiting for index {} (relation type {}) to reach status {}",
                         timeout, relationIndexName, relationTypeName, status);
-                return new RelationIndexStatusReport(true, relationIndexName, relationTypeName, actualStatus, status, t.elapsed());
+                return new RelationIndexStatusReport(false, relationIndexName, relationTypeName, actualStatus, status, t.elapsed());
             }
 
             Thread.sleep(poll.getLength(TimeUnit.MILLISECONDS));

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -73,6 +73,8 @@ public BerkeleyJEStoreManager(Configuration configuration) throws BackendExcepti
                     .keyConsistent(GraphDatabaseConfiguration.buildGraphConfiguration())
                     .locking(true)
                     .keyOrdered(true)
+                    .scanTxConfig(GraphDatabaseConfiguration.buildGraphConfiguration()
+                            .set(ISOLATION_LEVEL, IsolationLevel.READ_UNCOMMITTED))
                     .build();
 
 //        features = new StoreFeatures();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -349,7 +349,8 @@ private StandardScanner.Builder buildStoreIndexScanJob(String storeName) {
                 .setTimestampProvider(provider)
                 .setJobConfiguration(jobConfig)
                 .setGraphConfiguration(configuration)
-                .setNumProcessingThreads(1);
+                .setNumProcessingThreads(1)
+                .setWorkBlockSize(10000);
     }
 
     public StandardScanner.ScanResult getScanJobStatus(Object jobId) {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopScanMapper.java
Patch:
@@ -57,7 +57,7 @@ protected void finishSetup(ModifiableHadoopConfiguration scanConf, Configuration
         // Allowed to be null for jobs that specify no configuration and no configuration root
         //Preconditions.checkNotNull(jobConf);
         Preconditions.checkNotNull(job);
-        job.setup(jobConf, graphConf, metrics);
+        job.workerIterationStart(jobConf, graphConf, metrics);
         keyFilter = job.getKeyFilter();
         List<SliceQuery> sliceQueries = job.getQueries();
         Preconditions.checkArgument(null != sliceQueries, "Job cannot specify null query list");
@@ -115,7 +115,7 @@ protected void map(StaticBuffer key, Iterable<Entry> values, Context context) th
     @Override
     protected void cleanup(Context context) throws IOException, InterruptedException {
         super.cleanup(context);
-        job.teardown(metrics);
+        job.workerIterationEnd(metrics);
     }
 
     private EntryList findEntriesMatchingQuery(SliceQuery query, EntryList sortedEntries) {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -1195,6 +1195,7 @@ private ScanMetrics runSimpleJob(StandardScanner scanner, ScanJob job, Configura
         jobBuilder.setStoreName(store.getName());
         jobBuilder.setJobConfiguration(jobConf);
         jobBuilder.setNumProcessingThreads(2);
+        jobBuilder.setWorkBlockSize(100);
         jobBuilder.setTimestampProvider(times);
         jobBuilder.setJob(job);
         return jobBuilder.execute().get();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -27,7 +27,7 @@
 import com.tinkerpop.gremlin.process.T;
 import com.tinkerpop.gremlin.process.graph.GraphTraversal;
 import com.tinkerpop.gremlin.structure.*;
-import junit.framework.Assert;
+import org.junit.Assert;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyOLAPTest.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
-import com.thinkaurelius.titan.olap.FulgoraOLAPTest;
+import com.thinkaurelius.titan.olap.OLAPTest;
 
-public class BerkeleyOLAPTest extends FulgoraOLAPTest {
+public class BerkeleyOLAPTest extends OLAPTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftOLAPTest.java
Patch:
@@ -2,10 +2,10 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
-import com.thinkaurelius.titan.olap.FulgoraOLAPTest;
+import com.thinkaurelius.titan.olap.OLAPTest;
 import org.junit.BeforeClass;
 
-public class ThriftOLAPTest extends FulgoraOLAPTest {
+public class ThriftOLAPTest extends OLAPTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/graphdb/hbase/HBaseOLAPTest.java
Patch:
@@ -2,15 +2,15 @@
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
-import com.thinkaurelius.titan.olap.FulgoraOLAPTest;
-
+import com.thinkaurelius.titan.olap.OLAPTest;
 import org.apache.hadoop.hbase.util.VersionInfo;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
 import java.io.IOException;
 
-public class HBaseOLAPTest extends FulgoraOLAPTest {
+public class HBaseOLAPTest extends OLAPTest {
+
     @BeforeClass
     public static void startHBase() throws IOException {
         HBaseStorageSetup.startHBase();

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/inmemory/InMemoryOLAPTest.java
Patch:
@@ -4,13 +4,13 @@
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.olap.FulgoraOLAPTest;
+import com.thinkaurelius.titan.olap.OLAPTest;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class InMemoryOLAPTest extends FulgoraOLAPTest {
+public class InMemoryOLAPTest extends OLAPTest {
 
     public WriteConfiguration getConfiguration() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildGraphConfiguration();

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -152,7 +152,7 @@ public class ElasticSearchIndex implements IndexProvider {
             new ConfigNamespace(ES_CREATE_NS, "ext", "Overrides for arbitrary settings applied at index creation", true);
 
     private static final IndexFeatures ES_FEATURES = new IndexFeatures.Builder().supportsDocumentTTL()
-            .setDefaultStringMapping(Mapping.TEXT).supportedStringMappings(Mapping.TEXT, Mapping.TEXTSTRING, Mapping.STRING).build();
+            .setDefaultStringMapping(Mapping.TEXT).supportedStringMappings(Mapping.TEXT, Mapping.TEXTSTRING, Mapping.STRING).setWildcardField("_all").build();
 
     public static final int HOST_PORT_DEFAULT = 9300;
 

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -152,7 +152,7 @@ public class ElasticSearchIndex implements IndexProvider {
             new ConfigNamespace(ES_CREATE_NS, "ext", "Overrides for arbitrary settings applied at index creation", true);
 
     private static final IndexFeatures ES_FEATURES = new IndexFeatures.Builder().supportsDocumentTTL()
-            .setDefaultStringMapping(Mapping.TEXT).supportedStringMappings(Mapping.TEXT, Mapping.TEXTSTRING, Mapping.STRING).build();
+            .setDefaultStringMapping(Mapping.TEXT).supportedStringMappings(Mapping.TEXT, Mapping.TEXTSTRING, Mapping.STRING).setWildcardField("_all").build();
 
     public static final int HOST_PORT_DEFAULT = 9300;
 

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -152,7 +152,7 @@ public class ElasticSearchIndex implements IndexProvider {
             new ConfigNamespace(ES_CREATE_NS, "ext", "Overrides for arbitrary settings applied at index creation", true);
 
     private static final IndexFeatures ES_FEATURES = new IndexFeatures.Builder().supportsDocumentTTL()
-            .setDefaultStringMapping(Mapping.TEXT).supportedStringMappings(Mapping.TEXT, Mapping.TEXTSTRING, Mapping.STRING).build();
+            .setDefaultStringMapping(Mapping.TEXT).supportedStringMappings(Mapping.TEXT, Mapping.TEXTSTRING, Mapping.STRING).setWildcardField("_all").build();
 
     public static final int HOST_PORT_DEFAULT = 9300;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -68,6 +68,7 @@ public StandardAttributeHandling() {
         registerClass(String.class, new StringSerializer()); //supports null serialization
         registerClass(Float.class, new FloatSerializer());
         registerClass(Double.class, new DoubleSerializer());
+        registerClass(UUID.class, new UUIDSerializer());
 
 
         //Arrays (support null serialization)

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -13,7 +13,7 @@ public class SolrRunner {
     protected static final int NUM_SERVERS = 1;
     protected static final String[] COLLECTIONS = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee",
             "composite", "psearch", "esearch", "vsearch", "mi", "mixed", "index1", "index2", "index3",
-            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "booleanIndex", "dateIndex" };
+            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "booleanIndex", "dateIndex", "uuidIndex" };
 
     protected static final String[] KEY_FIELDS = new String[0];
 

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -13,7 +13,7 @@ public class SolrRunner {
     protected static final int NUM_SERVERS = 1;
     protected static final String[] COLLECTIONS = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee",
             "composite", "psearch", "esearch", "vsearch", "mi", "mixed", "index1", "index2", "index3",
-            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "uuidIndex" };
+            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "booleanIndex", "dateIndex", "uuidIndex" };
 
     protected static final String[] KEY_FIELDS = new String[0];
 

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -13,7 +13,7 @@ public class SolrRunner {
     protected static final int NUM_SERVERS = 1;
     protected static final String[] COLLECTIONS = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee",
             "composite", "psearch", "esearch", "vsearch", "mi", "mixed", "index1", "index2", "index3",
-            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges" };
+            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "booleanIndex", "dateIndex" };
 
     protected static final String[] KEY_FIELDS = new String[0];
 

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -13,7 +13,7 @@ public class SolrRunner {
     protected static final int NUM_SERVERS = 1;
     protected static final String[] COLLECTIONS = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee",
             "composite", "psearch", "esearch", "vsearch", "mi", "mixed", "index1", "index2", "index3",
-            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges" };
+            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "booleanIndex", "dateIndex" };
 
     protected static final String[] KEY_FIELDS = new String[0];
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -68,6 +68,7 @@ public StandardAttributeHandling() {
         registerClass(String.class, new StringSerializer()); //supports null serialization
         registerClass(Float.class, new FloatSerializer());
         registerClass(Double.class, new DoubleSerializer());
+        registerClass(UUID.class, new UUIDSerializer());
 
 
         //Arrays (support null serialization)

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -13,7 +13,7 @@ public class SolrRunner {
     protected static final int NUM_SERVERS = 1;
     protected static final String[] COLLECTIONS = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee",
             "composite", "psearch", "esearch", "vsearch", "mi", "mixed", "index1", "index2", "index3",
-            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges" };
+            "ecategory", "vcategory", "pcategory", "theIndex", "vertices", "edges", "uuidIndex" };
 
     protected static final String[] KEY_FIELDS = new String[0];
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.schema.*;
 import com.thinkaurelius.titan.core.util.ManagementUtil;
+import com.thinkaurelius.titan.graphdb.database.management.ManagementSystem;
 import com.thinkaurelius.titan.graphdb.internal.Order;
 import com.thinkaurelius.titan.core.attribute.*;
 import com.thinkaurelius.titan.core.log.TransactionRecovery;
@@ -967,7 +968,7 @@ public void testIndexUpdatesWithoutReindex() throws InterruptedException {
         assertTrue(mgmt.updateIndex(mgmt.getGraphIndex("theIndex"), SchemaAction.REGISTER_INDEX));
         mgmt.commit();
 
-        ManagementUtil.awaitGraphIndexUpdate(graph, "theIndex", 10, TimeUnit.SECONDS);
+        ManagementSystem.awaitGraphIndexStatus(graph, "theIndex").timeout(10L, TimeUnit.SECONDS).call();
 
         finishSchema();
         assertTrue(mgmt.updateIndex(mgmt.getGraphIndex("theIndex"), SchemaAction.ENABLE_INDEX));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -229,10 +229,11 @@ private synchronized void closeInternal() {
                 }
                 // Throw an exception if at least one transaction failed to close
                 if (1 == txCloseExceptions.size()) {
-                    throw new TitanException("Unable to close transaction",
+                    // TP3's test suite requires that this be of type ISE
+                    throw new IllegalStateException("Unable to close transaction",
                             Iterables.getOnlyElement(txCloseExceptions.values()));
                 } else if (1 < txCloseExceptions.size()) {
-                    throw new TitanException(String.format(
+                    throw new IllegalStateException(String.format(
                             "Unable to close %s transactions (see warnings in log output for details)",
                             txCloseExceptions.size()));
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -709,7 +709,9 @@ private static Locker openManagedLocker(String classname, String lockerName) {
 
         try {
             props = new Properties();
-            InputStream in = TitanFactory.class.getClassLoader().getResourceAsStream(TitanConstants.TITAN_PROPERTIES_FILE);
+            final String res = TitanConstants.TITAN_PROPERTIES_RESOURCE_NAME;
+            log.debug("Reading Titan config resource: {}", res);
+            InputStream in = TitanFactory.class.getClassLoader().getResourceAsStream(res);
             if (in != null && in.available() > 0) {
                 props.load(in);
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -3,13 +3,13 @@
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Iterators;
+import com.thinkaurelius.titan.core.attribute.Timestamp;
 import com.thinkaurelius.titan.core.log.LogProcessorFramework;
 import com.thinkaurelius.titan.core.log.TransactionRecovery;
 import com.thinkaurelius.titan.diskstorage.Backend;
 import com.thinkaurelius.titan.diskstorage.StandardStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.CommonsConfiguration;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardTimestamp;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.*;
@@ -158,7 +158,7 @@ public static LogProcessorFramework openTransactionLog(TitanGraph graph) {
      * @return
      */
     public static TransactionRecovery startTransactionRecovery(TitanGraph graph, long sinceEpoch, TimeUnit unit) {
-        return new StandardTransactionLogProcessor((StandardTitanGraph)graph, new StandardTimestamp(sinceEpoch,unit));
+        return new StandardTransactionLogProcessor((StandardTitanGraph)graph, new Timestamp(sinceEpoch,unit));
     }
 
     //###################################

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/Durations.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.attribute.Duration;
-import com.thinkaurelius.titan.core.attribute.Timestamp;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -21,7 +20,7 @@ public static Duration min(Duration x, Duration y) {
      * This method is based on the method of the same name in Stopwatch.java in
      * Google Guava 14.0.1, where it was defined with private visibility.
      */
-    static String abbreviate(TimeUnit unit) {
+    public static String abbreviate(TimeUnit unit) {
         switch (unit) {
         case NANOSECONDS:
             return "ns";

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -6,8 +6,8 @@
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.*;
 import com.thinkaurelius.titan.core.schema.*;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardTimestamp;
 import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
+import com.thinkaurelius.titan.core.attribute.Timestamp;
 import com.thinkaurelius.titan.graphdb.database.log.LogTxStatus;
 import com.thinkaurelius.titan.graphdb.database.management.MgmtLogType;
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.*;
@@ -41,7 +41,7 @@ public class StandardAttributeHandling implements AttributeHandling {
                     Parameter.class, Parameter[].class, ParameterType.class, RelationCategory.class,
                     Order.class, Multiplicity.class, Cardinality.class, Direction.class, ElementCategory.class,
                     ConsistencyModifier.class, SchemaStatus.class, LogTxStatus.class, MgmtLogType.class,
-                    StandardDuration.class, StandardTimepoint.class, StandardTransactionId.class, StandardTimestamp.class,
+                    StandardDuration.class, StandardTimepoint.class, StandardTransactionId.class, Timestamp.class,
                     Timestamps.class
             );
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/StandardLogProcessorFramework.java
Patch:
@@ -12,7 +12,6 @@
 import com.thinkaurelius.titan.core.log.ChangeProcessor;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.log.*;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardTimestamp;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.database.log.LogTxMeta;
@@ -128,7 +127,7 @@ public LogProcessorBuilder setProcessorIdentifier(String name) {
 
         @Override
         public LogProcessorBuilder setStartTime(long sinceEpoch, TimeUnit unit) {
-            this.startTime = new StandardTimestamp(sinceEpoch,unit);
+            this.startTime = new Timestamp(sinceEpoch,unit);
             return this;
         }
 
@@ -228,7 +227,7 @@ public void read(Message message) {
                         transactionId = (StandardTransactionId)txentry.getMetadata().get(LogTxMeta.SOURCE_TRANSACTION);
                     } else {
                         transactionId = new StandardTransactionId(senderId,txentry.getHeader().getId(),
-                                new StandardTimestamp(txentry.getHeader().getTimestamp(times.getUnit()),times.getUnit()));
+                                new Timestamp(txentry.getHeader().getTimestamp(times.getUnit()),times.getUnit()));
                     }
                     readRelations(txentry,tx,changes);
                 } catch (Throwable e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/StandardTransactionLogProcessor.java
Patch:
@@ -18,7 +18,6 @@
 import com.thinkaurelius.titan.diskstorage.log.*;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardTimestamp;
 import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
@@ -325,7 +324,7 @@ public void read(Message message) {
             TransactionLogHeader.Entry txentry = TransactionLogHeader.parse(content,serializer,times);
             TransactionLogHeader txheader = txentry.getHeader();
             StandardTransactionId transactionId = new StandardTransactionId(senderId,txheader.getId(),
-                    new StandardTimestamp(txheader.getTimestamp(times.getUnit()),times.getUnit()));
+                    new Timestamp(txheader.getTimestamp(times.getUnit()),times.getUnit()));
 
             TxEntry entry;
             try {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -4,13 +4,12 @@
 import com.google.common.collect.ImmutableMap;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.Duration;
-import com.thinkaurelius.titan.core.attribute.Timestamp;
 import com.thinkaurelius.titan.core.Cardinality;
+import com.thinkaurelius.titan.core.attribute.Timestamp;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
-import com.thinkaurelius.titan.diskstorage.util.time.StandardTimestamp;
 import com.thinkaurelius.titan.graphdb.internal.*;
 import com.tinkerpop.gremlin.process.T;
 import com.tinkerpop.gremlin.structure.Direction;
@@ -87,7 +86,7 @@ public<O> O computeProperty(InternalElement e) {
                     Long time = r.getValueDirect(this);
                     if (time==null) return null; //there is no timestamp
                     TimeUnit unit = r.tx().getConfiguration().getTimestampProvider().getUnit();
-                    return (O) new StandardTimestamp(time, unit);
+                    return (O) new Timestamp(time, unit);
                 }
             } else {
                 return null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -165,7 +165,8 @@ public static <E extends TitanElement> And<E> constraints2QNF(StandardTitanTx tx
             RelationType type = getType(tx, atom.getKey());
 
             if (type == null) {
-                if (atom.getPredicate() == Cmp.EQUAL && atom.getValue() == null)
+                if (atom.getPredicate() == Cmp.EQUAL && atom.getValue() == null ||
+                        (atom.getPredicate() == Cmp.NOT_EQUAL && atom.getValue() != null))
                     continue; //Ignore condition, its trivially satisfied
 
                 return null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -845,7 +845,7 @@ public boolean apply(@Nullable Integer uniqueIdBitWidth) {
     public static final ConfigOption<String[]> INDEX_HOSTS = new ConfigOption<String[]>(INDEX_NS,"hostname",
             "The hostname or comma-separated list of hostnames of index backend servers.  " +
             "This is only applicable to some index backends, such as elasticsearch and solr.",
-            ConfigOption.Type.GLOBAL, new String[]{NetworkUtil.getLoopbackAddress()});
+            ConfigOption.Type.MASKABLE, new String[]{NetworkUtil.getLoopbackAddress()});
 
     public static final ConfigOption<Integer> INDEX_PORT = new ConfigOption<Integer>(INDEX_NS,"port",
             "The port on which to connect to index backend servers",

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -93,8 +93,8 @@ public class GraphDatabaseConfiguration {
 
     public static final ConfigOption<Boolean> ALLOW_SETTING_VERTEX_ID = new ConfigOption<Boolean>(GRAPH_NS,"set-vertex-id",
             "Whether user provided vertex ids should be enabled and Titan's automatic id allocation be disabled. " +
-                "Useful when operating Titan in concert with another storage system that assigns long ids but disables some" +
-                    "of Titan's advanced features which can lead to inconsistent data. EXPERT FEATURE - USE WITH GREAT CARE.",
+            "Useful when operating Titan in concert with another storage system that assigns long ids but disables some " +
+            "of Titan's advanced features which can lead to inconsistent data. EXPERT FEATURE - USE WITH GREAT CARE.",
             ConfigOption.Type.FIXED, false);
 
     public static final ConfigOption<Timestamps> TIMESTAMP_PROVIDER = new ConfigOption<Timestamps>(GRAPH_NS, "timestamps",

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -844,7 +844,7 @@ public EdgeLabel makeEdgeLabel(String name, TypeDefinitionMap definition) {
 
     public TitanSchemaVertex getSchemaVertex(String schemaName) {
         Long schemaId = newTypeCache.get(schemaName);
-        if (schemaId==null) schemaId=graph.getSchemaCache().getSchemaId(schemaName, this);
+        if (schemaId==null) schemaId=graph.getSchemaCache().getSchemaId(schemaName);
         if (schemaId != null) {
             InternalVertex typeVertex = vertexCache.get(schemaId, existingVertexRetriever);
             assert typeVertex!=null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanSchemaVertex.java
Patch:
@@ -37,7 +37,7 @@ public String name() {
             if (isLoaded()) {
                 StandardTitanTx tx = tx();
                 p = (TitanVertexProperty) Iterables.getOnlyElement(RelationConstructor.readRelation(this,
-                        tx.getGraph().getSchemaCache().getSchemaRelations(longId(), BaseKey.SchemaName, Direction.OUT, tx()),
+                        tx.getGraph().getSchemaCache().getSchemaRelations(longId(), BaseKey.SchemaName, Direction.OUT),
                         tx), null);
             } else {
                 p = Iterables.getOnlyElement(query().type(BaseKey.SchemaName).properties(), null);
@@ -65,7 +65,7 @@ public TypeDefinitionMap getDefinition() {
             if (isLoaded()) {
                 StandardTitanTx tx = tx();
                 ps = (Iterable)RelationConstructor.readRelation(this,
-                        tx.getGraph().getSchemaCache().getSchemaRelations(longId(), BaseKey.SchemaDefinitionProperty, Direction.OUT, tx()),
+                        tx.getGraph().getSchemaCache().getSchemaRelations(longId(), BaseKey.SchemaDefinitionProperty, Direction.OUT),
                         tx);
             } else {
                 ps = query().type(BaseKey.SchemaDefinitionProperty).properties();
@@ -96,7 +96,7 @@ public Iterable<Entry> getRelated(TypeDefinitionCategory def, Direction dir) {
             if (isLoaded()) {
                 StandardTitanTx tx = tx();
                 edges = (Iterable)RelationConstructor.readRelation(this,
-                        tx.getGraph().getSchemaCache().getSchemaRelations(longId(), BaseLabel.SchemaDefinitionEdge, dir, tx()),
+                        tx.getGraph().getSchemaCache().getSchemaRelations(longId(), BaseLabel.SchemaDefinitionEdge, dir),
                         tx);
             } else {
                 edges = query().type(BaseLabel.SchemaDefinitionEdge).direction(dir).edges();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -425,7 +425,9 @@ private static KCVSConfiguration getConfiguration(final BackendOperation.Transac
                                                             final KeyColumnValueStore store, final String identifier,
                                                             final Configuration config) {
         try {
-            KCVSConfiguration kcvsConfig = new KCVSConfiguration(txProvider,config,store,identifier);
+            KCVSConfiguration kcvsConfig =
+                    new KCVSConfiguration(txProvider,config,store,identifier,
+                            config.get(GraphDatabaseConfiguration.KRYO_INSTANCE_CACHE));
             kcvsConfig.setMaxOperationWaitTime(config.get(SETUP_WAITTIME));
             return kcvsConfig;
         } catch (BackendException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLogManager.java
Patch:
@@ -10,12 +10,11 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.ttl.TTLKVCSManager;
 import com.thinkaurelius.titan.diskstorage.log.Log;
 import com.thinkaurelius.titan.diskstorage.log.LogManager;
-import com.thinkaurelius.titan.diskstorage.log.ReadMarker;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.graphdb.database.idassigner.placement.PartitionIDRange;
-import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
 import com.thinkaurelius.titan.graphdb.database.serialize.StandardSerializer;
+import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoInstanceCacheImpl;
 import com.thinkaurelius.titan.util.encoding.ConversionHelper;
 import com.thinkaurelius.titan.util.stats.NumberUtil;
 import com.thinkaurelius.titan.util.system.IOUtils;
@@ -180,7 +179,8 @@ public KCVSLogManager(KeyColumnValueStoreManager storeManager, final Configurati
             this.readPartitionIds=new int[]{0};
         }
 
-        this.serializer = new StandardSerializer(false);
+        KryoInstanceCacheImpl kcache = configuration.get(GraphDatabaseConfiguration.KRYO_INSTANCE_CACHE);
+        this.serializer = new StandardSerializer(false, kcache);
     }
 
     private static void checkValidPartitionId(int partitionId, int partitionBitWidth) {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Contain.java
Patch:
@@ -59,7 +59,7 @@ public boolean isValidValueType(Class<?> clazz) {
 
     @Override
     public boolean isValidCondition(Object condition) {
-        return condition != null && (condition instanceof Collection) && !((Collection) condition).isEmpty();
+        return condition != null && (condition instanceof Collection);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanPropertiesStep.java
Patch:
@@ -29,6 +29,8 @@ public class TitanPropertiesStep<E> extends PropertiesStep<E> implements HasStep
 
     public TitanPropertiesStep(PropertiesStep<E> originalStep) {
         super(originalStep.getTraversal(), originalStep.getReturnType(), originalStep.getPropertyKeys());
+        if (TraversalHelper.isLabeled(originalStep))
+            this.setLabel(originalStep.getLabel());
         this.hasContainers = new ArrayList<>();
         this.limit = Query.NO_LIMIT;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanVertexStep.java
Patch:
@@ -23,6 +23,8 @@ public class TitanVertexStep<E extends Element> extends VertexStep<E> implements
 
     public TitanVertexStep(VertexStep<E> originalStep) {
         super(originalStep.getTraversal(), originalStep.getReturnClass(), originalStep.getDirection(), originalStep.getEdgeLabels());
+        if (TraversalHelper.isLabeled(originalStep))
+            this.setLabel(originalStep.getLabel());
         this.hasContainers = new ArrayList<>();
         this.limit = Query.NO_LIMIT;
     }
@@ -67,7 +69,7 @@ private void initialize() {
             super.setFunction(v -> (Iterator<E>)results.get(v.get()).iterator());
         } else {
             super.setFunction( v -> {
-                TitanVertexQuery query = makeQuery(((TitanVertex) v.get()).query());
+                TitanVertexQuery query = makeQuery((TitanTraversalUtil.getTitanVertex(v)).query());
                 return (Vertex.class.isAssignableFrom(getReturnClass())) ? query.vertices().iterator() : query.edges().iterator();
             } );
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraGraphComputer.java
Patch:
@@ -76,14 +76,14 @@ public TitanGraphComputer isolation(final Isolation isolation) {
     }
 
     @Override
-    public TitanGraphComputer setResultMode(ResultMode mode) {
+    public TitanGraphComputer resultMode(ResultMode mode) {
         Preconditions.checkArgument(mode!=null,"Need to specify mode");
         this.resultMode = mode;
         return this;
     }
 
     @Override
-    public TitanGraphComputer setNumProcessingThreads(int threads) {
+    public TitanGraphComputer workers(int threads) {
         Preconditions.checkArgument(threads>0,"Invalid number of threads: %s",threads);
         numThreads = threads;
         return this;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraUtil.java
Patch:
@@ -34,7 +34,7 @@ public class FulgoraUtil {
 
     static {
         try {
-            FULGORA_STRATEGIES = TraversalStrategies.GlobalCache.getStrategies(Vertex.class).clone().addStrategies(TitanElementStepStrategy.instance(), TitanLocalQueryOptimizerStrategy.instance());
+            FULGORA_STRATEGIES = TraversalStrategies.GlobalCache.getStrategies(Vertex.class).clone().addStrategies(TitanLocalQueryOptimizerStrategy.instance());
         } catch (final CloneNotSupportedException e) {
             throw new IllegalStateException(e.getMessage(), e);
         }
@@ -46,7 +46,7 @@ public static Traversal<Vertex,Edge> getTraversal(final MessageScope.Local<?> sc
         FulgoraElementTraversal<Vertex,Edge> result = FulgoraElementTraversal.of(graph);
         for (Step step : incident.asAdmin().getSteps()) result.addStep(step);
         result.asAdmin().setStrategies(FULGORA_STRATEGIES);
-        incident.asAdmin().applyStrategies(TraversalEngine.COMPUTER);
+        result.asAdmin().applyStrategies(TraversalEngine.COMPUTER);
         verifyIncidentTraversal(result);
         return result;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanGraphStepStrategy.java
Patch:
@@ -37,7 +37,7 @@ public void apply(final Traversal.Admin<?, ?> traversal, final TraversalEngine e
                 TraversalHelper.replaceStep(startStep, titanGraphStep, traversal);
 
                 HasStepFolder.foldInHasContainer(titanGraphStep,traversal);
-                HasStepFolder.foldInOrder(titanGraphStep,traversal,titanGraphStep.returnsVertices());
+                HasStepFolder.foldInOrder(titanGraphStep,traversal,traversal,titanGraphStep.returnsVertices());
                 HasStepFolder.foldInRange(titanGraphStep,traversal);
             }
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -766,7 +766,7 @@ public boolean apply(@Nullable InternalRelation p) {
     @Override
     public Iterable<TitanEdge> getEdges(RelationIdentifier... ids) {
         verifyOpen();
-        if (ids==null || ids.length==0) new VertexCentricEdgeIterable(getInternalVertices(),RelationCategory.EDGE);
+        if (ids==null || ids.length==0) return new VertexCentricEdgeIterable(getInternalVertices(),RelationCategory.EDGE);
 
         if (null != config.getGroupName()) {
             MetricManager.INSTANCE.getCounter(config.getGroupName(), "db", "getEdgesByID").inc();

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanTransaction.java
Patch:
@@ -50,6 +50,8 @@ public interface TitanTransaction extends TitanGraphTransaction {
     /**
      * Retrieves the vertex for the specified id.
      *
+     * This method is intended for internal use only. Use {@link com.tinkerpop.gremlin.structure.Graph#V(Object...)} instead.
+     *
      * @param id id of the vertex to retrieve
      * @return vertex with the given id if it exists, else null
      */

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/scan/StandardScanner.java
Patch:
@@ -178,7 +178,7 @@ public ScanResult execute() throws BackendException {
             openStores.add(kcvs);
             try {
                 StandardScannerExecutor executor = new StandardScannerExecutor(job, finishJob, kcvs, storeTx,
-                        manager.getFeatures(), numProcessingThreads, jobConfiguration);
+                        manager.getFeatures(), numProcessingThreads, jobConfiguration, graphConfiguration);
                 addJob(jobId,executor);
                 new Thread(executor).start();
                 return executor;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -66,8 +66,8 @@ public static ScanJob convert(VertexScanJob vertexJob) {
     }
 
     @Override
-    public void setup(Configuration config, ScanMetrics metrics) {
-        graph.initializeGraph(config);
+    public void setup(Configuration jobConfig, Configuration graphConfig, ScanMetrics metrics) {
+        graph.initializeGraph(graphConfig);
         idManager = graph.get().getIDManager();
         StandardTransactionBuilder txb = graph.get().buildTransaction().readOnly();
         txb.setPreloadedData(true);
@@ -76,7 +76,7 @@ public void setup(Configuration config, ScanMetrics metrics) {
         txb.vertexCacheSize(500);
         try {
             tx = (StandardTitanTx)txb.start();
-            job.setup(graph.get(), config, metrics);
+            job.setup(graph.get(), jobConfig, metrics);
         } catch (Throwable e) {
             close();
             throw e;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/job/IndexUpdateJob.java
Patch:
@@ -44,7 +44,6 @@ public abstract class IndexUpdateJob {
                     "relation type configured under index-name. This should remain empty for global graph indexes.",
             ConfigOption.Type.LOCAL, "");
 
-
     protected StandardTitanGraph graph;
     protected ManagementSystem mgmt = null;
     protected StandardTitanTx writeTx;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/SimpleScanJob.java
Patch:
@@ -61,7 +61,8 @@ public SimpleScanJob(SliceQuery q) {
         this(ImmutableList.of(q),k -> true);
     }
 
-    public void setup(Configuration config, ScanMetrics metrics) {
+    @Override
+    public void setup(Configuration config, Configuration graphConfig, ScanMetrics metrics) {
         assertNotNull(config);
         metrics.incrementCustom(SETUP_COUNT);
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/AbstractBinaryInputFormat.java
Patch:
@@ -13,14 +13,14 @@
 public abstract class AbstractBinaryInputFormat extends InputFormat<StaticBuffer, Iterable<Entry>> implements Configurable {
 
     protected Configuration hadoopConf;
-    protected ModifiableConfiguration inputConf;
+    protected ModifiableConfiguration titanConf;
 
     @Override
     public void setConf(final Configuration config) {
 
-        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.SCAN_NS, config);
-        this.inputConf = faunusConf.getInputConf(GraphDatabaseConfiguration.ROOT_NS);
+        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, config);
         this.hadoopConf = config;
+        this.titanConf = faunusConf.getTitanInputConf();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/scan/HadoopVertexScanMapper.java
Patch:
@@ -20,7 +20,7 @@ public class HadoopVertexScanMapper extends HadoopScanMapper {
     protected void setup(Context context) throws IOException, InterruptedException {
         /* Don't call super implementation super.setup(context); */
         org.apache.hadoop.conf.Configuration hadoopConf = DEFAULT_COMPAT.getContextConfiguration(context);
-        ModifiableHadoopConfiguration scanConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.SCAN_NS, hadoopConf);
+        ModifiableHadoopConfiguration scanConf = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, hadoopConf);
         VertexScanJob vertexScan = null; // TODO
         TitanGraph graph = TitanFactory.open(getTitanConfiguration(context));
         job = VertexJobConverter.convert(graph, vertexScan);
@@ -30,6 +30,6 @@ protected void setup(Context context) throws IOException, InterruptedException {
 
     private ModifiableConfiguration getTitanConfiguration(Context context) {
         Configuration hadoopConf = DEFAULT_COMPAT.getContextConfiguration(context);
-        return ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.SCAN_NS, hadoopConf).getInputConf(GraphDatabaseConfiguration.ROOT_NS);
+        return ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.MAPRED_NS, hadoopConf).getTitanInputConf();
     }
 }

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyComputerTest.java
Patch:
@@ -10,6 +10,6 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 @RunWith(ProcessComputerSuite.class)
-@ProcessComputerSuite.GraphProviderClass(provider = BerkeleyGraphProvider.class, graph = TitanGraph.class)
+@ProcessComputerSuite.GraphProviderClass(provider = BerkeleyNonTxGraphProvider.class, graph = TitanGraph.class)
 public class BerkeleyComputerTest {
 }
\ No newline at end of file

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanElementTraversal.java
Patch:
@@ -18,6 +18,7 @@ public class TitanElementTraversal<S, E>  extends DefaultGraphTraversal<S, E> {
     static {
         final DefaultTraversalStrategies traversalStrategies = new DefaultTraversalStrategies();
         GraphTraversalStrategyRegistry.instance().getTraversalStrategies().forEach(traversalStrategies::addStrategy);
+        traversalStrategies.addStrategy(TitanElementStepStrategy.instance());
         traversalStrategies.addStrategy(TitanLocalQueryOptimizerStrategy.instance());
         TraversalStrategies.GlobalCache.registerStrategies(TitanElementTraversal.class, traversalStrategies);
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/AbstractTitanGraphProvider.java
Patch:
@@ -79,7 +79,7 @@ public void clear(Graph g, final Configuration configuration) throws Exception {
     @Override
     public Map<String, Object> getBaseConfiguration(String graphName, Class<?> test, String testMethodName) {
         ModifiableConfiguration conf = getTitanConfiguration(graphName,test,testMethodName);
-//        conf.set(GraphDatabaseConfiguration.ATTRIBUTE_ALLOW_ALL_SERIALIZABLE,false);
+        conf.set(GraphDatabaseConfiguration.COMPUTER_RESULT_MODE,"persist");
         initializeSchema(conf,test,testMethodName);
         Map<String,Object> result = new HashMap<>();
         conf.getAll().entrySet().stream().forEach( e -> result.put(ConfigElement.getPath(e.getKey().element, e.getKey().umbrellaElements),e.getValue()));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/FulgoraReduceEmitter.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.tinkerpop.gremlin.process.computer.MapReduce;
 import com.tinkerpop.gremlin.tinkergraph.process.computer.TinkerReduceEmitter;
-import org.javatuples.Pair;
+import com.tinkerpop.gremlin.process.computer.KeyValue;
 
 import java.util.Queue;
 
@@ -15,7 +15,7 @@ protected void complete(final MapReduce<?, ?, OK, OV, ?> mapReduce) {
         super.complete(mapReduce);
     }
 
-    protected Queue<Pair<OK, OV>> getQueue() {
+    protected Queue<KeyValue<OK, OV>> getQueue() {
         return reduceQueue;
     }
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyComputerTest.java
Patch:
@@ -9,7 +9,6 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-@Ignore
 @RunWith(ProcessComputerSuite.class)
 @ProcessComputerSuite.GraphProviderClass(provider = BerkeleyGraphProvider.class, graph = TitanGraph.class)
 public class BerkeleyComputerTest {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/VertexJobConverter.java
Patch:
@@ -109,6 +109,7 @@ public void process(StaticBuffer key, Map<SliceQuery, EntryList> entries, ScanMe
         PreloadedVertex v = (PreloadedVertex)vertex;
         for (Map.Entry<SliceQuery,EntryList> entry : entries.entrySet()) {
             SliceQuery sq = entry.getKey();
+            if (sq.equals(VERTEX_EXISTS_QUERY)) continue;
             EntryList entryList = entry.getValue();
             if (entryList.size()>=sq.getLimit()) metrics.incrementCustom(TRUNCATED_ENTRY_LISTS);
             v.addToQueryCache(sq.updateLimit(Query.NO_LIMIT),entryList);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexMemoryHandler.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.core.TitanVertexProperty;
 import com.thinkaurelius.titan.graphdb.vertices.PreloadedVertex;
 import com.tinkerpop.gremlin.process.Traversal;
+import com.tinkerpop.gremlin.process.computer.GraphComputer;
 import com.tinkerpop.gremlin.process.computer.MessageScope;
 import com.tinkerpop.gremlin.process.computer.Messenger;
 import com.tinkerpop.gremlin.structure.Edge;
@@ -68,7 +69,7 @@ public <V> TitanVertexProperty<V> property(String key, V value) {
 
     @Override
     public <V> TitanVertexProperty<V> singleProperty(String key, V value) {
-        assert supports(key);
+        if (!supports(key)) throw GraphComputer.Exceptions.providedKeyIsNotAnElementComputeKey(key);
         Preconditions.checkArgument(value != null);
         vertexMemory.setProperty(vertexId, key, value);
         return constructProperty(key,value);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexProgramScanJob.java
Patch:
@@ -64,8 +64,9 @@ private VertexProgramScanJob(StandardTitanGraph graph, FulgoraMemory memory,
         this.memory = memory;
         this.vertexMemory = vertexMemory;
         this.vertexProgram = vertexProgram;
-        this.combiner = vertexProgram.getMessageCombiner().get();
+        this.combiner = FulgoraUtil.getMessageCombiner(vertexProgram);
         this.scopes = vertexProgram.getMessageScopes(memory);
+
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/olap/computer/VertexState.java
Patch:
@@ -54,7 +54,7 @@ private void initializeCurrentMessages(Map<MessageScope,Integer> scopeMap) {
 
     public synchronized void setMessage(M message, MessageScope scope, Map<MessageScope,Integer> scopeMap) {
         assert message!=null && scope!=null;
-        assert scopeMap.containsKey(scope);
+        Preconditions.checkArgument(scopeMap.containsKey(scope),"Provided scope was not declared in the VertexProgram: %s",scope);
         initializeCurrentMessages(scopeMap);
         if (scopeMap.size()==1) currentMessages = message;
         else ((Object[])currentMessages)[scopeMap.get(scope)]=message;
@@ -63,6 +63,7 @@ public synchronized void setMessage(M message, MessageScope scope, Map<MessageSc
     public synchronized void addMessage(M message, MessageScope scope, Map<MessageScope,Integer> scopeMap,
                                         MessageCombiner<M> combiner) {
         assert message!=null && scope!=null && combiner!=null;
+        Preconditions.checkArgument(scopeMap.containsKey(scope),"Provided scope was not declared in the VertexProgram: %s",scope);
         assert scopeMap.containsKey(scope);
         initializeCurrentMessages(scopeMap);
         if (scopeMap.size()==1) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanFeatures.java
Patch:
@@ -43,7 +43,7 @@ public VariableFeatures variables() {
 
             @Override
             public boolean supportsComputer() {
-                return false; //TODO: set to true
+                return true;
             }
         };
         vertexFeatures = new VertexFeatures() {

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -269,7 +269,7 @@ public void execute(Vertex vertex, Messenger<Integer> messenger, Memory memory)
 
         @Override
         public boolean terminate(Memory memory) {
-            return memory.getIteration()>=length+1;
+            return memory.getIteration()>=length;
         }
 
         @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/hbase/HBaseInputFormat.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.thinkaurelius.titan.hadoop.formats.util.GiraphInputFormat;
 
-public class HBaseinputFormat extends GiraphInputFormat {
-    public HBaseinputFormat() {
+public class HBaseInputFormat extends GiraphInputFormat {
+    public HBaseInputFormat() {
         super(new HBaseBinaryInputFormat());
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/computer/bulkloader/BulkLoaderVertexProgram.java
Patch:
@@ -139,8 +139,8 @@ public Set<String> getElementComputeKeys() {
     }
 
     @Override
-    public Set<MessageScope> getMessageScopes(int i) {
-        return ImmutableSet.of(messageScope); // TODO is this correct? optimal?
+    public Set<MessageScope> getMessageScopes(final Memory memory) {
+        return ImmutableSet.of(messageScope);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexLongList.java
Patch:
@@ -8,6 +8,7 @@
 
 import java.util.Arrays;
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
 /**
  * An implementation of {@link VertexListInternal} that stores only the vertex ids
@@ -124,6 +125,7 @@ public boolean hasNext() {
 
             @Override
             public TitanVertex next() {
+                if (!hasNext()) throw new NoSuchElementException();
                 pos++;
                 return get(pos);
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -420,8 +420,7 @@ private VertexConstructor(boolean verifyExistence, boolean createStubVertex) {
 
         @Override
         public InternalVertex get(Long vertexid) {
-            Preconditions.checkNotNull(vertexid);
-            Preconditions.checkArgument(vertexid > 0);
+            Preconditions.checkArgument(vertexid!=null && vertexid > 0, "Invalid vertex id: %s",vertexid);
             Preconditions.checkArgument(idInspector.isSchemaVertexId(vertexid) || idInspector.isUserVertexId(vertexid), "Not a valid vertex id: %s", vertexid);
 
             byte lifecycle = ElementLifeCycle.Loaded;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -176,7 +176,7 @@ private static ReadConfiguration getLocalConfiguration(String shortcutOrFile) {
             BaseConfiguration config = new BaseConfiguration();
             ModifiableConfiguration writeConfig = new ModifiableConfiguration(ROOT_NS,new CommonsConfiguration(config), BasicConfiguration.Restriction.NONE);
             writeConfig.set(STORAGE_BACKEND,backend);
-            ConfigOption option = Backend.getStoreShorthandOptions().get(backend.toLowerCase());
+            ConfigOption option = Backend.getOptionForShorthand(backend);
             if (option==null) {
                 Preconditions.checkArgument(secondArg==null);
             } else if (option==STORAGE_DIRECTORY || option==STORAGE_CONF_FILE) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/StandardStoreManager.java
Patch:
@@ -54,11 +54,11 @@ public String getManagerClass() {
         ALL_MANAGER_CLASSES = ImmutableMap.copyOf(tempClassMap);
     }
 
-    public static final List<String> getAllShorthands() {
+    public static List<String> getAllShorthands() {
         return ALL_SHORTHANDS;
     }
 
-    public static final Map<String, String> getAllManagerClasses() {
+    public static Map<String, String> getAllManagerClasses() {
         return ALL_MANAGER_CLASSES;
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -5,8 +5,8 @@
 import com.google.common.collect.Iterators;
 import com.thinkaurelius.titan.core.log.LogProcessorFramework;
 import com.thinkaurelius.titan.core.log.TransactionRecovery;
-import com.thinkaurelius.titan.core.util.ReflectiveConfigOptionLoader;
 import com.thinkaurelius.titan.diskstorage.Backend;
+import com.thinkaurelius.titan.diskstorage.StandardStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.CommonsConfiguration;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardTimestamp;
@@ -170,13 +170,13 @@ private static ReadConfiguration getLocalConfiguration(String shortcutOrFile) {
             int pos = shortcutOrFile.indexOf(':');
             if (pos<0) pos = shortcutOrFile.length();
             String backend = shortcutOrFile.substring(0,pos);
-            Preconditions.checkArgument(Backend.REGISTERED_STORAGE_MANAGERS_SHORTHAND.containsKey(backend.toLowerCase()), "Backend shorthand unknown: %s", backend);
+            Preconditions.checkArgument(StandardStoreManager.getAllManagerClasses().containsKey(backend.toLowerCase()), "Backend shorthand unknown: %s", backend);
             String secondArg = null;
             if (pos+1<shortcutOrFile.length()) secondArg = shortcutOrFile.substring(pos + 1).trim();
             BaseConfiguration config = new BaseConfiguration();
             ModifiableConfiguration writeConfig = new ModifiableConfiguration(ROOT_NS,new CommonsConfiguration(config), BasicConfiguration.Restriction.NONE);
             writeConfig.set(STORAGE_BACKEND,backend);
-            ConfigOption option = Backend.REGISTERED_STORAGE_MANAGERS_SHORTHAND.get(backend.toLowerCase());
+            ConfigOption option = Backend.getStoreShorthandOptions().get(backend.toLowerCase());
             if (option==null) {
                 Preconditions.checkArgument(secondArg==null);
             } else if (option==STORAGE_DIRECTORY || option==STORAGE_CONF_FILE) {

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TestMockIndexProvider.java
Patch:
@@ -32,7 +32,7 @@ public class TestMockIndexProvider implements IndexProvider {
 
     public TestMockIndexProvider(Configuration config) {
         this.index = Backend.getImplementationClass(config, config.get(INDEX_BACKEND_PROXY),
-                Backend.REGISTERED_INDEX_PROVIDERS);
+                StandardIndexProvider.getAllProviderClasses());
         this.failAdds = config.get(INDEX_MOCK_FAILADD);
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/TitanFactoryShorthandTest.java
Patch:
@@ -16,6 +16,6 @@ public class TitanFactoryShorthandTest {
     @Test
     public void testTitanFactoryShorthand() {
         TitanGraph g = TitanFactory.open("inmemory");
-        g.shutdown();
+        g.close();
     }
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/config/HBaseAuthHelper.java
Patch:
@@ -67,7 +67,7 @@ public static void setHBaseAuthToken(Configuration configuration, Job job) throw
                 Object user = getCurrent.invoke(null);
                 Method obtainAuthTokenForJob = clazz.getMethod("obtainAuthTokenForJob", Configuration.class, Job.class);
                 obtainAuthTokenForJob.invoke(user, configuration, job);
-                log.error("Obtained HBase Auth Token from ZooKeeper quorum {} for job {}", configuration.get(quorumCfgKey), job.getJobName());
+                log.info("Obtained HBase Auth Token from ZooKeeper quorum {} for job {}", configuration.get(quorumCfgKey), job.getJobName());
             } catch (ClassNotFoundException e) {
                 log.error("Failed to generate or store HBase auth token", e);
             } catch (InvocationTargetException e) {
@@ -81,7 +81,7 @@ public static void setHBaseAuthToken(Configuration configuration, Job job) throw
             }
 
         } else {
-            log.error("Not obtaining HBase Auth Token for MapReduce job " + job.getJobName());
+            log.info("Not obtaining HBase Auth Token for MapReduce job " + job.getJobName());
         }
     }
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.RelationReader;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
@@ -18,6 +19,7 @@
 import com.thinkaurelius.titan.graphdb.types.system.BaseLabel;
 import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
+import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.formats.util.input.SystemTypeInspector;
 import com.thinkaurelius.titan.hadoop.formats.util.input.TitanHadoopSetupCommon;
 import com.thinkaurelius.titan.hadoop.formats.util.input.VertexReader;
@@ -33,9 +35,8 @@ public class TitanHadoopSetupImpl extends TitanHadoopSetupCommon {
     private final StandardTitanTx tx;
 
     public TitanHadoopSetupImpl(final Configuration config) {
-        BasicConfiguration bc = ModifiableHadoopConfiguration.of(config).getInputConf();
+        BasicConfiguration bc = ModifiableHadoopConfiguration.of(TitanHadoopConfiguration.SCAN_NS, config).getInputConf(GraphDatabaseConfiguration.ROOT_NS);
         graph = (StandardTitanGraph) TitanFactory.open(bc);
-
         tx = (StandardTitanTx)graph.buildTransaction().readOnly().vertexCacheSize(200).start();
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -61,7 +61,7 @@ private ScanMetrics executeScanJob(ScanJob job) throws Exception {
         return scanner.build()
                 .setNumProcessingThreads(2)
                 .setStoreName(Backend.EDGESTORE_NAME)
-                .setConfiguration(config)
+                .setGraphConfiguration(config)
                 .setTimestampProvider(config.get(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER))
                 .setJob(job)
                 .execute().get();

File: titan-core/src/main/java/com/thinkaurelius/titan/util/datastructures/Retriever.java
Patch:
@@ -1,5 +1,7 @@
 package com.thinkaurelius.titan.util.datastructures;
 
+import java.util.Collections;
+
 /**
  * Interface for the Retriever design pattern.
  *

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -1293,7 +1293,9 @@ public void scanTestWithSimpleJob() throws Exception {
                             new SliceQuery(BufferUtil.zeroBuffer(1),BufferUtil.oneBuffer(1))
                     )));
             fail();
-        } catch (IllegalArgumentException e) {}
+        } catch (Exception e) {
+            assertTrue(e.getCause() instanceof IllegalArgumentException);
+        }
 
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -1309,7 +1309,7 @@ public GraphDatabaseConfiguration(ReadConfiguration localConfig) {
                 String version = globalWrite.get(INITIAL_TITAN_VERSION);
                 Preconditions.checkArgument(version!=null,"Titan version has not been initialized");
                 if (!TitanConstants.VERSION.equals(version) && !TitanConstants.COMPATIBLE_VERSIONS.contains(version)) {
-                    throw new TitanException("StorageBackend version is incompatible with current Titan version: " + version + " vs. " + TitanConstants.VERSION);
+                    throw new TitanException("StorageBackend version is incompatible with current Titan version: storage=" + version + " vs. runtime=" + TitanConstants.VERSION);
                 }
 
                 final boolean managedOverridesAllowed;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -181,7 +181,7 @@ public Iterator<Vertex> vertexIterator(Direction direction, String... strings) {
     public <V> Iterator<VertexProperty<V>> propertyIterator(boolean hidden, String... keys) {
         if (!Stream.of(keys).map(s -> tx().getPropertyKey(s)).filter(k -> k!=null && ((InternalRelationType)k).isInvisibleType()).findAny().isPresent()
                 && tx().getConfiguration().hasPropertyPrefetching()) {
-            properties().count().next();
+            Iterables.size(query().properties());
         }
 
         if (keys==null) keys=new String[0];

File: titan-core/src/main/java/com/thinkaurelius/titan/core/SchemaViolationException.java
Patch:
@@ -5,7 +5,7 @@
  * in the representable space of longs are valid.  This exception can
  * be thrown when an invalid long ID is encountered.
  */
-public class SchemaViolationException extends TitanException {
+public class SchemaViolationException extends IllegalArgumentException {
 
     public SchemaViolationException(String msg) {
         super(msg);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -397,7 +397,7 @@ private static KCVSConfiguration getConfiguration(final BackendOperation.Transac
                                                             final KeyColumnValueStore store, final String identifier,
                                                             final Configuration config) {
         try {
-            KCVSConfiguration kcvsConfig = new KCVSConfiguration(txProvider,config.get(TIMESTAMP_PROVIDER),store,identifier);
+            KCVSConfiguration kcvsConfig = new KCVSConfiguration(txProvider,config,store,identifier);
             kcvsConfig.setMaxOperationWaitTime(config.get(SETUP_WAITTIME));
             return kcvsConfig;
         } catch (BackendException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/AttributeHandling.java
Patch:
@@ -5,11 +5,12 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public interface AttributeHandling {
 
     public <T> void registerClass(Class<T> type, AttributeHandler<T> attributeHandler);
 
+    public boolean validDataType(Class datatype);
+
     public<V> void verifyAttribute(Class<V> datatype, Object value);
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/TitanFeatures.java
Patch:
@@ -33,7 +33,7 @@ public boolean supportsVariables() {
             }
 
             @Override
-            public boolean supportsSerializableValues() { return false; }
+            public boolean supportsSerializableValues() { return true; }
         };
         graphFeatures = new GraphFeatures() {
             @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardPropertyKeyMaker.java
Patch:
@@ -76,6 +76,7 @@ public StandardPropertyKeyMaker sortOrder(Order order) {
     @Override
     public PropertyKey make() {
         Preconditions.checkArgument(dataType != null, "Need to specify a datatype");
+        Preconditions.checkArgument(tx.validDataType(dataType), "Not a supported data type: %s",dataType);
         Preconditions.checkArgument(!dataType.isPrimitive(), "Primitive types are not supported. Use the corresponding object type, e.g. Integer.class instead of int.class [%s]", dataType);
         Preconditions.checkArgument(!dataType.isInterface(), "Datatype must be a class and not an interface: %s", dataType);
         Preconditions.checkArgument(dataType.isArray() || !Modifier.isAbstract(dataType.getModifiers()), "Datatype cannot be an abstract class: %s", dataType);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -82,7 +82,7 @@ public boolean isModified() {
 
     @Override
     public synchronized void remove() {
-        if (isRemoved()) throw InvalidElementException.removedException(this);
+        if (isRemoved()) return; //Remove() is idempotent
         Iterator<TitanRelation> iter = it().query().noPartitionRestriction().relations().iterator();
         while (iter.hasNext()) {
             iter.next();
@@ -119,7 +119,7 @@ public VertexLabel vertexLabel() {
 
     @Override
     public VertexCentricQueryBuilder query() {
-        Preconditions.checkArgument(!isRemoved(), "Cannot access a removed vertex: %s", this);
+        verifyAccess();
         return tx().query(this);
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/AbstractTitanGraphProvider.java
Patch:
@@ -59,6 +59,7 @@ public void clear(Graph g, final Configuration configuration) throws Exception {
     @Override
     public Map<String, Object> getBaseConfiguration(String graphName, Class<?> test, String testMethodName) {
         ModifiableConfiguration conf = getTitanConfiguration(graphName,test,testMethodName);
+        conf.set(GraphDatabaseConfiguration.ATTRIBUTE_ALLOW_ALL_SERIALIZABLE,false);
         initializeSchema(conf,test,testMethodName);
         Map<String,Object> result = new HashMap<>();
         conf.getAll().entrySet().stream().forEach( e -> result.put(ConfigElement.getPath(e.getKey().element, e.getKey().umbrellaElements),e.getValue()));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraVertex.java
Patch:
@@ -15,6 +15,7 @@
 import com.thinkaurelius.titan.graphdb.types.system.BaseVertexLabel;
 import com.thinkaurelius.titan.graphdb.vertices.CacheVertex;
 import com.tinkerpop.gremlin.structure.Property;
+import com.tinkerpop.gremlin.structure.VertexProperty;
 
 import java.util.Collections;
 import java.util.List;
@@ -50,7 +51,7 @@ public<A> A valueInternal(String key) {
     @Override
     public<A> A value(String key) {
         A val = valueInternal(key);
-        if (val==null) throw Property.Exceptions.propertyDoesNotExist(key);
+        if (val==null) return null;// throw Property.Exceptions.propertyDoesNotExist(key);
         return val;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/StandardEdge.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
 import com.thinkaurelius.titan.core.EdgeLabel;
 import com.thinkaurelius.titan.core.RelationType;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
@@ -67,7 +68,7 @@ public void setPropertyDirect(RelationType type, Object value) {
 
     @Override
     public Iterable<RelationType> getPropertyKeysDirect() {
-        return properties.keySet();
+        return Lists.newArrayList(properties.keySet());
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/StandardVertexProperty.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
 import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.core.RelationType;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
@@ -67,7 +68,7 @@ public void setPropertyDirect(RelationType type, Object value) {
 
     @Override
     public Iterable<RelationType> getPropertyKeysDirect() {
-        return properties.keySet();
+        return Lists.newArrayList(properties.keySet());
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/computer/bulkloader/BulkLoaderVertexProgram.java
Patch:
@@ -32,7 +32,7 @@ public class BulkLoaderVertexProgram implements VertexProgram<Long[]> {
         elementComputeKeys.add(TITAN_ID);
     }
 
-    private MessageType.Local messageType = MessageType.Local.to(() -> GraphTraversal.<Vertex>of().outE());
+    private MessageType.Local messageType = MessageType.Local.of(() -> GraphTraversal.<Vertex>of().outE());
     private TitanGraph graph;
     private String location;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanGraphStep.java
Patch:
@@ -29,7 +29,7 @@ public TitanGraphStep(final Traversal traversal, final Class<E> returnClass) {
 
     @Override
     public void generateTraverserIterator(final boolean trackPaths) {
-        TitanTransaction tx = (TitanTransaction)this.traversal.sideEffects().getGraph();
+        TitanTransaction tx = TitanTraversal.getTx(traversal);
         TitanGraphQuery query = tx.query();
         for (HasContainer condition : hasContainers) {
             if (condition.predicate instanceof Contains && condition.value==null) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanGraphStepStrategy.java
Patch:
@@ -24,7 +24,7 @@ public void apply(final Traversal<?, ?> traversal, final TraversalEngine engine)
 
         final TitanGraphStep titanGraphStep = (TitanGraphStep) TraversalHelper.getStart(traversal);
         HasStepFolder.foldInHasContainer(titanGraphStep,traversal);
-        HasStepFolder.foldInLastOrderBy(titanGraphStep,traversal);
+        HasStepFolder.foldInLastOrderBy(titanGraphStep,traversal,titanGraphStep.returnsVertices());
         HasStepFolder.foldInRange(titanGraphStep,traversal,RangeStep.class);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanLocalQueryOptimizerStrategy.java
Patch:
@@ -39,7 +39,7 @@ public void apply(final Traversal<?, ?> traversal, final TraversalEngine engine)
         TraversalHelper.getStepsOfClass(TitanVertexStep.class, traversal).forEach(step -> {
             if (step.isEdgeStep()) {
                 HasStepFolder.foldInHasContainer(step,traversal);
-                OrderByStep ostep = HasStepFolder.foldInLastOrderBy(step,traversal);
+                OrderByStep ostep = HasStepFolder.foldInLastOrderBy(step,traversal,false);
                 boolean hasLocalRange = HasStepFolder.foldInRange(step, traversal, LocalRangeStep.class);
                 if (ostep!=null && !hasLocalRange) TraversalHelper.insertAfterStep(ostep,step,traversal);
             } else {
@@ -81,7 +81,7 @@ public void apply(final Traversal<?, ?> traversal, final TraversalEngine engine)
             if (isVertexProperties) {
                 step.makeVertrexProperties();
                 HasStepFolder.foldInHasContainer(step,traversal);
-                OrderByStep ostep = HasStepFolder.foldInLastOrderBy(step,traversal);
+                OrderByStep ostep = HasStepFolder.foldInLastOrderBy(step,traversal,false);
                 boolean hasLocalRange = HasStepFolder.foldInRange(step, traversal, LocalRangeStep.class);
                 if (ostep!=null && !hasLocalRange) TraversalHelper.insertAfterStep(ostep,step,traversal);
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanPropertiesStep.java
Patch:
@@ -100,7 +100,7 @@ private void initialize() {
 
     @Override
     protected Traverser<E> processNextStart() {
-        if (!initialized) initialize();
+        //if (!initialized) initialize();
         return super.processNextStart();
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -9,6 +9,7 @@
 import com.thinkaurelius.titan.graphdb.TitanGraphBaseTest;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.tinkerpop.gremlin.structure.Direction;
+import com.tinkerpop.gremlin.structure.Property;
 import com.tinkerpop.gremlin.structure.Vertex;
 import org.junit.Test;
 
@@ -243,8 +244,8 @@ public Long combine(Long m1, Long m2) {
         builder.setJob(new OLAPJob() {
             @Override
             public PageRank process(TitanVertex vertex) {
-                Long degree = vertex.<Long>value("degree");
-                return new PageRank(degree==null?0:degree,1.0d/numVertices);
+                Long degree = vertex.value("degree");
+                return new PageRank(degree!=null?degree:0,1.0d/numVertices);
             }
         });
         OLAPResult<PageRank> ranks;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/computer/bulkloader/BulkLoaderVertexProgram.java
Patch:
@@ -40,7 +40,7 @@ public class BulkLoaderVertexProgram implements VertexProgram<Long[]> {
         elementComputeKeys.add(TITAN_ID);
     }
 
-    private MessageType.Local messageType = MessageType.Local.to(() -> GraphTraversal.<Vertex>of().outE());
+    private MessageType.Local messageType = MessageType.Local.of(() -> GraphTraversal.<Vertex>of().outE());
     private static ThreadLocal<TitanGraph> graphThreadLocal = new ThreadLocal<>();
     private Configuration configuration;  // TODO: TitanGraph.configuration() needs to be implemented
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyGraphProvider.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.blueprints;
 
 import com.thinkaurelius.titan.BerkeleyStorageSetup;
+import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 
@@ -15,7 +16,7 @@ public class BerkeleyGraphProvider extends AbstractTitanGraphProvider {
 
     @Override
     public ModifiableConfiguration getTitanConfiguration(String graphName, Class<?> test, String testMethodName) {
-        return BerkeleyStorageSetup.getBerkeleyJEConfiguration(graphName);
+        return BerkeleyStorageSetup.getBerkeleyJEConfiguration(StorageSetup.getHomeDir(graphName));
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanElement.java
Patch:
@@ -98,7 +98,7 @@ public interface TitanElement extends Element, Idfiable, Removable {
      * @param key key
      * @return value or list of values associated with key
      */
-    public <V> V value(PropertyKey key);
+    public <V> V valueOrNull(RelationType key);
 
     //########### LifeCycle Status ##########
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanGraph.java
Patch:
@@ -18,6 +18,7 @@
 @Graph.OptIn(Graph.OptIn.SUITE_STRUCTURE_PERFORMANCE)
 @Graph.OptIn(Graph.OptIn.SUITE_PROCESS_STANDARD)
 @Graph.OptIn(Graph.OptIn.SUITE_PROCESS_COMPUTER)
+
 public interface TitanGraph extends TitanGraphTransaction {
 
    /* ---------------------------------------------------------------

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -266,9 +266,9 @@ public Collection<IndexUpdate> getIndexUpdates(InternalRelation relation) {
                     if (record==null) continue;
                     update = new IndexUpdate<StaticBuffer,Entry>(iIndex,updateType,getIndexKey(iIndex,record),getIndexEntry(iIndex,record,relation), relation);
                 } else {
-                    assert relation.value(key)!=null;
+                    assert relation.valueOrNull(key)!=null;
                     if (((MixedIndexType)index).getField(key).getStatus()== SchemaStatus.DISABLED) continue;
-                    update = getMixedIndexUpdate(relation, key, relation.value(key), (MixedIndexType) index, updateType);
+                    update = getMixedIndexUpdate(relation, key, relation.valueOrNull(key), (MixedIndexType) index, updateType);
                 }
                 if (ttl>0) update.setTTL(ttl);
                 updates.add(update);
@@ -386,7 +386,7 @@ public static RecordEntry[] indexMatch(TitanRelation relation, CompositeIndexTyp
         RecordEntry[] match = new RecordEntry[fields.length];
         for (int i = 0; i <fields.length; i++) {
             IndexField f = fields[i];
-            Object value = relation.value(f.getFieldKey());
+            Object value = relation.valueOrNull(f.getFieldKey());
             if (value==null) return null; //No match
             match[i] = new RecordEntry(relation.longId(),value,f.getFieldKey());
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraNeighborVertex.java
Patch:
@@ -48,7 +48,7 @@ public<A> A value(String key) {
     }
 
     @Override
-    public <O> O value(PropertyKey key) {
+    public <O> O valueOrNull(RelationType key) {
         if (key instanceof ImplicitKey) return ((ImplicitKey)key).computeProperty(this);
         throw getAccessException();
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/OrderList.java
Patch:
@@ -139,8 +139,8 @@ public int hashCode() {
 
         @Override
         public int compare(TitanElement o1, TitanElement o2) {
-            Object v1 = o1.value(key);
-            Object v2 = o2.value(key);
+            Object v1 = o1.valueOrNull(key);
+            Object v2 = o2.valueOrNull(key);
             if (v1 == null || v2 == null) {
                 if (v1 == null && v2 == null) return 0;
                 else if (v1 == null) return 1;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/TitanSchemaCategory.java
Patch:
@@ -35,7 +35,7 @@ public boolean hasName() {
 
     public String getSchemaName(String name) {
         Preconditions.checkState(hasName());
-        TypeUtil.checkTypeName(name);
+        TypeUtil.checkTypeName(this,name);
         String prefix;
         switch(this) {
             case EDGELABEL:

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/TitanPredicate.java
Patch:
@@ -104,7 +104,7 @@ public static final TitanPredicate convert(BiPredicate p) {
         }
 
         public static final boolean supports(BiPredicate p) {
-            return convert(p)!=null;
+            return convertInternal(p)!=null;
         }
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationComparator.java
Patch:
@@ -125,7 +125,7 @@ private int compareOnKey(TitanRelation r1, TitanRelation r2, long typeid, Order
     }
 
     private int compareOnKey(TitanRelation r1, TitanRelation r2, RelationType type, Order order) {
-        Object v1 = r1.value(type.name()), v2 = r2.value(type.name());
+        Object v1 = r1.valueOrNull(type), v2 = r2.valueOrNull(type);
         return compareValues(v1, v2,order);
     }
 }
\ No newline at end of file

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardVertexLabelMaker.java
Patch:
@@ -29,8 +29,7 @@ public StandardVertexLabelMaker(StandardTitanTx tx) {
     }
 
     public static void checkName(String name) {
-        if (name==null) throw Element.Exceptions.labelCanNotBeNull();
-        if (StringUtils.isBlank(name)) throw Element.Exceptions.labelCanNotBeEmpty();
+        TypeUtil.checkTypeName(TitanSchemaCategory.VERTEXLABEL,name);
         if (Token.isSystemName(name)) throw Element.Exceptions.labelCanNotBeASystemKey(name);
         for (char c : StandardRelationTypeMaker.RESERVED_CHARS)
             Preconditions.checkArgument(name.indexOf(c) < 0, "Name contains reserved character %s: %s", c, name);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -8,6 +8,7 @@
 public abstract class SystemTypeManager {
 
     public static final String systemETprefix = "^T$";
+    public static final String NON_EXISTANT_TYPE = systemETprefix+"doesNotExist";
 
     private volatile static Map<Long, SystemRelationType> SYSTEM_TYPES_BY_ID;
     private volatile static Map<String, SystemRelationType> SYSTEM_TYPES_BY_NAME;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanSchemaVertex.java
Patch:
@@ -71,7 +71,7 @@ public TypeDefinitionMap getDefinition() {
                 ps = query().type(BaseKey.SchemaDefinitionProperty).properties();
             }
             for (TitanVertexProperty property : ps) {
-                TypeDefinitionDescription desc = property.value(BaseKey.SchemaDefinitionDesc);
+                TypeDefinitionDescription desc = property.valueOrNull(BaseKey.SchemaDefinitionDesc);
                 Preconditions.checkArgument(desc!=null && desc.getCategory().isProperty());
                 def.setValue(desc.getCategory(), property.value());
             }
@@ -104,7 +104,7 @@ public Iterable<Entry> getRelated(TypeDefinitionCategory def, Direction dir) {
             for (TitanEdge edge: edges) {
                 TitanVertex oth = edge.vertex(dir.opposite());
                 assert oth instanceof TitanSchemaVertex;
-                TypeDefinitionDescription desc = edge.value(BaseKey.SchemaDefinitionDesc);
+                TypeDefinitionDescription desc = edge.valueOrNull(BaseKey.SchemaDefinitionDesc);
                 Object modifier = null;
                 if (desc.getCategory().hasDataType()) {
                     assert desc.getModifier()!=null && desc.getModifier().getClass().equals(desc.getCategory().getDataType());
@@ -141,7 +141,7 @@ public Iterable<TitanEdge> getEdges(final TypeDefinitionCategory def, final Dire
         return Iterables.filter(query.edges(),new Predicate<TitanEdge>() {
             @Override
             public boolean apply(@Nullable TitanEdge edge) {
-                TypeDefinitionDescription desc = edge.value(BaseKey.SchemaDefinitionDesc);
+                TypeDefinitionDescription desc = edge.valueOrNull(BaseKey.SchemaDefinitionDesc);
                 return desc.getCategory()==def;
             }
         });

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/ElementHelper.java
Patch:
@@ -18,7 +18,7 @@ public class ElementHelper {
 
     public static Iterable<Object> getValues(TitanElement element, PropertyKey key) {
         if (element instanceof TitanRelation) {
-            Object value = element.value(key);
+            Object value = element.valueOrNull(key);
             if (value==null) return Collections.EMPTY_LIST;
             else return ImmutableList.of(value);
         } else {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -124,8 +124,8 @@ public VertexCentricQueryBuilder query() {
     }
 
     @Override
-    public <O> O value(PropertyKey key) {
-        return value(key.name());
+    public <O> O valueOrNull(RelationType key) {
+        return (O)property(key.name()).orElse(null);
     }
 
     @Override

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/inmemory/InMemoryGraphTest.java
Patch:
@@ -46,6 +46,9 @@ public void testManagedOptionMasking() {}
     @Override
     public void testTransactionConfiguration() {}
 
+    @Override
+    public void testTinkerPopOptimizationStrategies() {}
+
     @Override
     public void testDataTypes() {}
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanGraphStepStrategy.java
Patch:
@@ -34,8 +34,7 @@ public static TitanGraphStepStrategy instance() {
 
     @Override
     public int compareTo(TraversalStrategy ts) {
-        if (ts instanceof LocalRangeStrategy) return -1;
-        return ts instanceof NoDependencies ? 0 : 1;
+        return -1;
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/tinkerpop/optimize/TitanLocalQueryOptimizerStrategy.java
Patch:
@@ -59,7 +59,7 @@ public void apply(final Traversal<?, ?> traversal, final TraversalEngine engine)
             Step previousStep = step;
             while ((previousStep=previousStep.getPreviousStep())!= EmptyStep.instance()) {
                 if (previousStep instanceof FilterStep || previousStep instanceof OrderStep ||
-                        previousStep instanceof OrderByStep || previousStep instanceof SideEffectStep ||
+                        previousStep instanceof OrderByStep ||
                         previousStep instanceof IdentityStep) {
                     continue; //we can skip over those since they don't alter the element type
                 }
@@ -79,6 +79,7 @@ public void apply(final Traversal<?, ?> traversal, final TraversalEngine engine)
             }
 
             if (isVertexProperties) {
+                step.makeVertrexProperties();
                 HasStepFolder.foldInHasContainer(step,traversal);
                 OrderByStep ostep = HasStepFolder.foldInLastOrderBy(step,traversal);
                 boolean hasLocalRange = HasStepFolder.foldInRange(step, traversal, LocalRangeStep.class);
@@ -93,8 +94,7 @@ public static TitanLocalQueryOptimizerStrategy instance() {
 
     @Override
     public int compareTo(TraversalStrategy ts) {
-        if (ts instanceof LocalRangeStrategy) return -1;
-        return ts instanceof NoDependencies ? 0 : 1;
+        return -1;
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardRelationTypeMaker.java
Patch:
@@ -67,8 +67,7 @@ protected Multiplicity getMultiplicity() {
     }
 
     public static void checkName(String name) {
-        if (name==null) throw Element.Exceptions.labelCanNotBeNull();
-        if (StringUtils.isBlank(name)) throw Element.Exceptions.labelCanNotBeEmpty();
+        TypeUtil.checkTypeName(name);
         if (SystemTypeManager.isSystemType(name.toLowerCase())
                 || Token.isSystemName(name)) throw Element.Exceptions.labelCanNotBeASystemKey(name);
         for (char c : RESERVED_CHARS)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/ElementHelper.java
Patch:
@@ -4,6 +4,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.*;
+import com.tinkerpop.gremlin.structure.Edge;
 
 import javax.annotation.Nullable;
 import java.util.Collections;
@@ -34,6 +35,8 @@ public Object apply(@Nullable TitanVertexProperty titanProperty) {
 
     public static void attachProperties(TitanElement element, Object... keyValues) {
         com.tinkerpop.gremlin.structure.util.ElementHelper.legalPropertyKeyValueArray(keyValues);
+        if (com.tinkerpop.gremlin.structure.util.ElementHelper.getIdValue(keyValues).isPresent()) throw Edge.Exceptions.userSuppliedIdsNotSupported();
+        if (com.tinkerpop.gremlin.structure.util.ElementHelper.getLabelValue(keyValues).isPresent()) throw new IllegalArgumentException("Cannot provide label as argument");
         com.tinkerpop.gremlin.structure.util.ElementHelper.attachProperties(element,keyValues);
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/TestBed.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan;
 
+import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
@@ -44,6 +45,8 @@ private static final void doSomethingExpensive(int milliseconds) {
      * @throws java.io.IOException
      */
     public static void main(String[] args) throws Exception {
+        System.out.println(TitanFactory.class.getName());
+
         IDHandler.EdgeTypeParse ep = IDHandler.readEdgeType(StaticArrayBuffer.of(new byte[]{36}).asReadBuffer());
         System.out.println(ep.typeId + " "+ BaseLabel.VertexLabelEdge.longId());
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -7,7 +7,7 @@
 
 public abstract class SystemTypeManager {
 
-    public static final String systemETprefix = "^internal$";
+    public static final String systemETprefix = "%&%T$";
 
     private volatile static Map<Long, SystemRelationType> SYSTEM_TYPES_BY_ID;
     private volatile static Map<String, SystemRelationType> SYSTEM_TYPES_BY_NAME;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/LoaderScriptWrapper.java
Patch:
@@ -87,7 +87,7 @@ public enum Counters {
     );
 
     private static final ImmutableMap<String, String> vpropArguments = ImmutableMap.of(
-            "faunusProperty", TitanProperty.class.getCanonicalName(),
+            "titanProperty", TitanProperty.class.getCanonicalName(),
             "vertex", TitanVertex.class.getCanonicalName(),
             "graph", TitanGraph.class.getCanonicalName(),
             "context", TASK_IO_CONTEXT,
@@ -155,9 +155,9 @@ public TitanVertex getVertex(FaunusVertex faunusVertex, TitanGraph graph, Mapper
         }
     }
 
-    public void getVProp(TitanProperty faunusProperty, TitanVertex vertex, TitanGraph graph, Mapper.Context context) {
+    public void getVProp(TitanProperty titanProperty, TitanVertex vertex, TitanGraph graph, Mapper.Context context) {
         Bindings bindings = new SimpleBindings();
-        bindings.put("faunusProperty", faunusProperty);
+        bindings.put("titanProperty", titanProperty);
         bindings.put("vertex", vertex);
         bindings.put("graph", graph);
         bindings.put("context", context);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -78,7 +78,7 @@ private Parameter getStringMapping() {
     private Parameter getTextMapping() {
         if (indexFeatures.supportsStringMapping(Mapping.TEXT)) return Mapping.TEXT.getParameter();
         else if (indexFeatures.supportsStringMapping(Mapping.TEXTSTRING)) return Mapping.TEXTSTRING.getParameter();
-        throw new AssertionError("String mapping not supported");
+        throw new AssertionError("Text mapping not supported");
     }
 
     private Parameter getFieldMap(PropertyKey key) {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -100,17 +100,17 @@ public byte getByte() {
     public static final ConfigOption<Integer> CPOOL_MAX_TOTAL =
             new ConfigOption<Integer>(CPOOL_NS, "max-total",
             "Max number of allowed Thrift connections, idle or active (-1 to leave undefined)",
-            ConfigOption.Type.MASKABLE, 32);
+            ConfigOption.Type.MASKABLE, -1);
 
     public static final ConfigOption<Integer> CPOOL_MAX_ACTIVE =
             new ConfigOption<Integer>(CPOOL_NS, "max-active",
             "Maximum number of concurrently in-use connections (-1 to leave undefined)",
-            ConfigOption.Type.MASKABLE, -1);
+            ConfigOption.Type.MASKABLE, 16);
 
     public static final ConfigOption<Integer> CPOOL_MAX_IDLE =
             new ConfigOption<Integer>(CPOOL_NS, "max-idle",
             "Maximum number of concurrently idle connections (-1 to leave undefined)",
-            ConfigOption.Type.MASKABLE, -1);
+            ConfigOption.Type.MASKABLE, 4);
 
     public static final ConfigOption<Integer> CPOOL_MIN_IDLE =
             new ConfigOption<Integer>(CPOOL_NS, "min-idle",

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -1148,7 +1148,7 @@ public void testEdgeTTLWithMixedIndices() throws Exception {
         mgmt.buildIndex("index1",Edge.class).
                 addKey(name, getStringMapping()).addKey(time).buildMixedIndex(INDEX);
         mgmt.buildIndex("index2",Edge.class).indexOnly(label).
-                addKey(text, getTextMapping()).buildMixedIndex(INDEX);
+                addKey(text, getTextMapping(), getFieldMap(text)).buildMixedIndex(INDEX);
 
         assertEquals(0, mgmt.getTTL(name).getLength(TimeUnit.SECONDS));
         assertEquals(likesTTLSeconds, mgmt.getTTL(label).getLength(TimeUnit.SECONDS));

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -364,7 +364,7 @@ public void testConditionalIndexing() {
         TitanGraphIndex index1 = mgmt.buildIndex("index1",Vertex.class).
                 addKey(name, getStringMapping()).buildMixedIndex(INDEX);
         TitanGraphIndex index2 = mgmt.buildIndex("index2",Vertex.class).indexOnly(person).
-                addKey(text, getTextMapping(), getFieldMap(text)).addKey(weight).buildMixedIndex(INDEX);
+                addKey(text, getTextMapping()).addKey(weight).buildMixedIndex(INDEX);
         TitanGraphIndex index3 = mgmt.buildIndex("index3",Vertex.class).indexOnly(org).
                 addKey(text, getTextMapping()).addKey(weight).buildMixedIndex(INDEX);
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -364,7 +364,7 @@ public void testConditionalIndexing() {
         TitanGraphIndex index1 = mgmt.buildIndex("index1",Vertex.class).
                 addKey(name, getStringMapping()).buildMixedIndex(INDEX);
         TitanGraphIndex index2 = mgmt.buildIndex("index2",Vertex.class).indexOnly(person).
-                addKey(text, getTextMapping()).addKey(weight).buildMixedIndex(INDEX);
+                addKey(text, getTextMapping(), getFieldMap(text)).addKey(weight).buildMixedIndex(INDEX);
         TitanGraphIndex index3 = mgmt.buildIndex("index3",Vertex.class).indexOnly(org).
                 addKey(text, getTextMapping()).addKey(weight).buildMixedIndex(INDEX);
 
@@ -460,7 +460,7 @@ public void testConditionalIndexing() {
         org = tx.getVertexLabel("org");
 
         final int numV = 200;
-        String[] strs = {"aaa","bbb","ccc","ddd"};
+        String[] strs = {"houseboat","humanoid","differential","extraordinary"};
         String[] strs2= new String[strs.length];
         for (int i=0;i<strs.length;i++) strs2[i]=strs[i]+" "+strs[i];
         final int modulo = 5;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/GraphCentricQueryBuilder.java
Patch:
@@ -253,7 +253,7 @@ this index covers. The index with the highest score (as long as it covers at lea
                 Set<Condition> subcover = Sets.newHashSet();
                 Object subcondition;
                 boolean supportsSort = orders.isEmpty();
-                //Check that this index actually applies
+                //Check that this index actually applies in case of a schema constraint
                 if (index.hasSchemaTypeConstraint()) {
                     TitanSchemaType type = index.getSchemaTypeConstraint();
                     boolean matchesTypeConstraint = false;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -16,7 +16,7 @@ public abstract class SystemTypeManager {
             ImmutableMap.Builder<Long, SystemRelationType> idBuilder = ImmutableMap.builder();
             ImmutableMap.Builder<String, SystemRelationType> nameBuilder = ImmutableMap.builder();
             for (SystemRelationType et : new SystemRelationType[]{BaseKey.SchemaCategory, BaseKey.SchemaDefinitionDesc,
-                    BaseKey.SchemaDefinitionProperty, BaseKey.SchemaName,
+                    BaseKey.SchemaDefinitionProperty, BaseKey.SchemaName, BaseKey.SchemaUpdateTime,
                     BaseKey.VertexExists,
                     BaseLabel.VertexLabelEdge, BaseLabel.SchemaDefinitionEdge,
                     ImplicitKey.ID, ImplicitKey.TITANID, ImplicitKey.LABEL, ImplicitKey.ADJACENT_ID,
@@ -29,8 +29,8 @@ public abstract class SystemTypeManager {
             SYSTEM_TYPES_BY_ID = idBuilder.build();
             SYSTEM_TYPES_BY_NAME = nameBuilder.build();
         }
-        assert SYSTEM_TYPES_BY_ID.size()==14;
-        assert SYSTEM_TYPES_BY_NAME.size()==14;
+        assert SYSTEM_TYPES_BY_ID.size()==15;
+        assert SYSTEM_TYPES_BY_NAME.size()==15;
     }
 
     public static SystemRelationType getSystemType(long id) {

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -10,9 +10,10 @@
 
 public class SolrRunner {
 
-    protected static final int NUM_SERVERS = 5;
+    protected static final int NUM_SERVERS = 1;
     protected static final String[] CORES = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee",
-            "composite", "vsearch", "mi", "mixed", "index1", "index2", "index3", "ecategory", "vcategory", "theIndex" };
+            "composite", "psearch", "esearch", "vsearch", "mi", "mixed", "index1", "index2", "index3",
+            "ecategory", "vcategory", "pcategory", "theIndex" };
 
     protected static final String[] KEY_FIELDS;
 

File: titan-es/src/test/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchConfigTest.java
Patch:
@@ -208,14 +208,15 @@ private void simpleWriteAndQuery(IndexProvider idx) throws BackendException, Int
 
         final Duration maxWrite = new StandardDuration(2000L, TimeUnit.MILLISECONDS);
         final String storeName = "jvmlocal_test_store";
+        final KeyInformation.IndexRetriever indexRetriever = IndexProviderTest.getIndexRetriever(IndexProviderTest.getMapping(idx.getFeatures()));
 
         BaseTransactionConfig txConfig = StandardBaseTransactionConfig.of(Timestamps.MILLI);
-        IndexTransaction itx = new IndexTransaction(idx, IndexProviderTest.indexRetriever, txConfig, maxWrite);
+        IndexTransaction itx = new IndexTransaction(idx, indexRetriever, txConfig, maxWrite);
         assertEquals(0, itx.query(new IndexQuery(storeName, PredicateCondition.of(IndexProviderTest.NAME, Text.PREFIX, "ali"))).size());
         itx.add(storeName, "doc", IndexProviderTest.NAME, "alice", false);
         itx.commit();
         Thread.sleep(1500L); // Slightly longer than default 1s index.refresh_interval
-        itx = new IndexTransaction(idx, IndexProviderTest.indexRetriever, txConfig, maxWrite);
+        itx = new IndexTransaction(idx, indexRetriever, txConfig, maxWrite);
         assertEquals(0, itx.query(new IndexQuery(storeName, PredicateCondition.of(IndexProviderTest.NAME, Text.PREFIX, "zed"))).size());
         assertEquals(1, itx.query(new IndexQuery(storeName, PredicateCondition.of(IndexProviderTest.NAME, Text.PREFIX, "ali"))).size());
         itx.rollback();

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrIndexTest.java
Patch:
@@ -93,7 +93,7 @@ public void testSupport() {
         assertTrue(index.supports(of(String.class, new Parameter("mapping", Mapping.DEFAULT)), Text.CONTAINS_PREFIX));
         assertTrue(index.supports(of(String.class, new Parameter("mapping", Mapping.TEXTSTRING)), Text.CONTAINS_REGEX));
         assertFalse(index.supports(of(String.class, new Parameter("mapping", Mapping.TEXT)), Text.REGEX));
-        assertFalse(index.supports(of(String.class, new Parameter("mapping",Mapping.TEXTSTRING)), Text.CONTAINS));
+        assertTrue(index.supports(of(String.class, new Parameter("mapping",Mapping.TEXTSTRING)), Text.CONTAINS));
         assertTrue(index.supports(of(String.class, new Parameter("mapping", Mapping.DEFAULT)), Text.PREFIX));
         assertTrue(index.supports(of(String.class, new Parameter("mapping", Mapping.DEFAULT)), Text.REGEX));
         assertTrue(index.supports(of(String.class, new Parameter("mapping",Mapping.DEFAULT)), Cmp.EQUAL));

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/SolrRunner.java
Patch:
@@ -10,7 +10,8 @@
 public class SolrRunner {
 
     protected static final int NUM_SERVERS = 5;
-    protected static final String[] CORES = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee" };
+//    protected static final String[] CORES = new String[] { "store1", "store2", "vertex", "edge", "namev", "namee" };
+    protected static final String[] CORES = new String[] { "store1", "store2", "vertex", "edge" };
 
     private static MiniSolrCloudCluster miniSolrCloudCluster;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/EdgeSerializer.java
Patch:
@@ -133,6 +133,7 @@ public RelationCache parseRelation(Entry data, boolean excludeProperties, TypeIn
                 in.movePositionTo(data.getValuePosition());
                 other = readPropertyValue(in,key);
             }
+            Preconditions.checkState(other!=null,"Encountered error in deserializer [null value returned]. Check serializer compatibility.");
         }
         assert other!=null;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsTransaction.java
Patch:
@@ -129,7 +129,7 @@ public TitanEdge addEdge(TitanVertex outVertex, TitanVertex inVertex, String lab
         if (null == label) {
             throw new IllegalArgumentException("Edge label must be non-null");
         }
-        return addEdge(outVertex, inVertex, getEdgeLabel(label));
+        return addEdge(outVertex, inVertex, getOrCreateEdgeLabel(label));
     }
 
 
@@ -165,7 +165,7 @@ public Iterable<Edge> getEdges(String key, Object value) {
 
     @Override
     public TitanProperty addProperty(TitanVertex vertex, String key, Object attribute) {
-        return addProperty(vertex, getPropertyKey(key), attribute);
+        return addProperty(vertex, getOrCreatePropertyKey(key), attribute);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/GraphCentricQueryBuilder.java
Patch:
@@ -132,11 +132,13 @@ public GraphCentricQueryBuilder limit(final int limit) {
 
     @Override
     public GraphCentricQueryBuilder orderBy(String key, Order order) {
+        Preconditions.checkArgument(tx.containsPropertyKey(key),"Provided key does not exist: %s",key);
         return orderBy(tx.getPropertyKey(key), order);
     }
 
     @Override
     public GraphCentricQueryBuilder orderBy(PropertyKey key, Order order) {
+        Preconditions.checkArgument(key!=null && order!=null,"Need to specify and key and an order");
         Preconditions.checkArgument(Comparable.class.isAssignableFrom(key.getDataType()),
                 "Can only order on keys with comparable data type. [%s] has datatype [%s]", key.getName(), key.getDataType());
         Preconditions.checkArgument(key.getCardinality()== Cardinality.SINGLE, "Ordering is undefined on multi-valued key [%s]", key.getName());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -121,8 +121,8 @@ else if (type instanceof EdgeLabel) {
             Preconditions.checkArgument(value instanceof TitanVertex,"Value must be a vertex");
             setProperty((EdgeLabel) type, (InternalVertex) value);
         } else if (type==null) {
-            if (value instanceof TitanVertex) setProperty(tx().getEdgeLabel(key),(TitanVertex)value);
-            setProperty(tx().getPropertyKey(key),value);
+            if (value instanceof TitanVertex) setProperty(tx().getOrCreateEdgeLabel(key),(TitanVertex)value);
+            setProperty(tx().getOrCreatePropertyKey(key),value);
         } else throw new IllegalArgumentException("Invalid key argument: " + key);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -236,7 +236,7 @@ public TitanProperty addProperty(String key, Object attribute) {
 
     @Override
     public void setProperty(String key, Object value) {
-        setProperty(tx().getPropertyKey(key),value);
+        setProperty(tx().getOrCreatePropertyKey(key),value);
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/FaunusElement.java
Patch:
@@ -55,7 +55,7 @@ public FaunusElement(final long id) {
         this.id = id;
     }
 
-    public abstract FaunusTypeManager getTypeManager();
+    public abstract FaunusSchemaManager getTypeManager();
 
     @Override
     public InternalElement it() {
@@ -269,7 +269,7 @@ public void setProperty(PropertyKey key, Object value) {
     @Override
     public void setProperty(final String key, final Object value) {
         FaunusRelationType rt = getTypeManager().getRelationType(key);
-        if (rt==null) rt = getTypeManager().getPropertyKey(key);
+        if (rt==null) rt = getTypeManager().getOrCreatePropertyKey(key);
         setProperty(rt,value);
     }
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/FaunusPathElement.java
Patch:
@@ -79,8 +79,8 @@ public Configuration getFaunusConf() {
     }
 
     @Override
-    public FaunusTypeManager getTypeManager() {
-        return FaunusTypeManager.getTypeManager(configuration);
+    public FaunusSchemaManager getTypeManager() {
+        return FaunusSchemaManager.getTypeManager(configuration);
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/FaunusVertexQuery.java
Patch:
@@ -41,7 +41,7 @@ public FaunusVertexQuery(FaunusPathElement element) {
         this.baseElement = element;
     }
 
-    protected FaunusVertexQuery(FaunusTypeManager typeManager) {
+    protected FaunusVertexQuery(FaunusSchemaManager typeManager) {
         super(typeManager);
         this.baseElement = null;
     }
@@ -66,7 +66,7 @@ protected TitanVertex getVertex(long vertexid) {
      ################################################*/
 
     protected And<TitanRelation> getCondition(FaunusElement element, RelationCategory returnType) {
-        FaunusTypeManager typeManager = element.getTypeManager();
+        FaunusSchemaManager typeManager = element.getTypeManager();
         if (!(element instanceof FaunusVertex)) {
             Preconditions.checkArgument(dir!=Direction.IN,"Illegal direction for element: %s",dir);
             dir = Direction.OUT;
@@ -119,7 +119,7 @@ protected And<TitanRelation> getCondition(FaunusElement element, RelationCategor
     }
 
     protected Iterable<FaunusRelation> getRelations(FaunusElement element, RelationCategory returnType) {
-        FaunusTypeManager typeManager = element.getTypeManager();
+        FaunusSchemaManager typeManager = element.getTypeManager();
 
         final And<TitanRelation> condition = getCondition(element,returnType);
         if (condition==null) return Collections.EMPTY_LIST;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/StandardFaunusEdge.java
Patch:
@@ -7,7 +7,6 @@
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.graphdb.relations.EdgeDirection;
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
-import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.util.ExceptionFactory;
 import com.tinkerpop.blueprints.util.StringFactory;
@@ -47,7 +46,7 @@ public StandardFaunusEdge(final Configuration configuration, final long outVerte
     }
 
     public StandardFaunusEdge(final Configuration configuration, final long id, final long outVertex, final long inVertex, String label) {
-        this(configuration,id,outVertex,inVertex,FaunusTypeManager.getTypeManager(configuration).getEdgeLabel(label));
+        this(configuration,id,outVertex,inVertex, FaunusSchemaManager.getTypeManager(configuration).getOrCreateEdgeLabel(label));
     }
 
     public StandardFaunusEdge(final Configuration configuration, final long outVertex, final long inVertex, FaunusEdgeLabel label) {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/StandardFaunusProperty.java
Patch:
@@ -46,7 +46,7 @@ public StandardFaunusProperty(FaunusVertex vertex, FaunusPropertyKey type, Objec
     }
 
     public StandardFaunusProperty(long id, FaunusVertex vertex, String type, Object value) {
-        this(id, vertex, vertex.getTypeManager().getPropertyKey(type), value);
+        this(id, vertex, vertex.getTypeManager().getOrCreatePropertyKey(type), value);
     }
 
     public StandardFaunusProperty(long id, FaunusVertex vertex, FaunusPropertyKey type, Object value) {

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/mapreduce/util/ElementPickerTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.hadoop.mapreduce.util;
 
-import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.hadoop.*;
 
 import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
@@ -13,12 +12,12 @@
  */
 public class ElementPickerTest extends TestCase {
 
-    private FaunusTypeManager typeManager;
+    private FaunusSchemaManager typeManager;
 
     @Override
     public void setUp() throws Exception {
         super.setUp();
-        typeManager = FaunusTypeManager.getTypeManager(new ModifiableHadoopConfiguration());
+        typeManager = FaunusSchemaManager.getTypeManager(new ModifiableHadoopConfiguration());
         typeManager.setSchemaProvider(TestSchemaProvider.MULTIPLICITY);
         typeManager.clear();
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/MultiVertexCentricQueryBuilder.java
Patch:
@@ -46,7 +46,7 @@ protected MultiVertexCentricQueryBuilder getThis() {
     public TitanMultiVertexQuery addVertex(TitanVertex vertex) {
         assert vertex != null;
         assert vertex instanceof InternalVertex;
-        vertices.add((InternalVertex)vertex);
+        vertices.add(((InternalVertex)vertex).it());
         return this;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheEdge.java
Patch:
@@ -24,7 +24,7 @@
 public class CacheEdge extends AbstractEdge {
 
     public CacheEdge(long id, EdgeLabel label, InternalVertex start, InternalVertex end, Entry data) {
-        super(id, label, start, end);
+        super(id, label, start.it(), end.it());
         assert data != null;
 
         this.data = data;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheProperty.java
Patch:
@@ -21,8 +21,9 @@
  */
 
 public class CacheProperty extends AbstractProperty {
+
     public CacheProperty(long id, PropertyKey key, InternalVertex start, Object value, Entry data) {
-        super(id, key, start, value);
+        super(id, key, start.it(), value);
         this.data = data;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -1280,12 +1280,12 @@ private void close() {
     }
 
     @Override
-    public boolean isOpen() {
+    public final boolean isOpen() {
         return isOpen;
     }
 
     @Override
-    public boolean isClosed() {
+    public final boolean isClosed() {
         return !isOpen;
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -3322,7 +3322,7 @@ public void read(Message message) {
             assertEquals(4,userChangeCounter.get(Change.REMOVED).get());
         }
 
-        clopen();
+        clopen( option(VERBOSE_TX_RECOVERY), true );
         /*
         Transaction Recovery
          */

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -396,7 +396,7 @@ private Future<Message> add(StaticBuffer content, int partitionId) {
      * @return
      */
     private Future<Message> add(StaticBuffer content, int partitionId, ExternalPersistor persistor) {
-        Preconditions.checkArgument(isOpen,"Log {} has been closed",name);
+        Preconditions.checkArgument(isOpen,"Log [%s] has been closed",name);
         Preconditions.checkArgument(content!=null && content.length()>0,"Content is empty");
         Preconditions.checkArgument(partitionId>=0 && partitionId<(1<<manager.partitionBitWidth),"Invalid partition id: %s",partitionId);
         final Timepoint timestamp = times.getTime();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -1722,7 +1722,7 @@ public void testTransactionIsolation() {
         assertFalse(v3.isRemoved());
         newTx();
 
-        TitanTransaction tx3 = graph.buildTransaction().checkInternalVertexExistence().start();
+        TitanTransaction tx3 = graph.buildTransaction().checkInternalVertexExistence(true).start();
         v21 = tx3.getVertex(v21.getLongId());
         v3 = (TitanVertex) Iterables.getOnlyElement(v21.getVertices(OUT, "link"));
         assertTrue(v3.isRemoved());

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/MergedConfiguration.java
Patch:
@@ -20,6 +20,7 @@ public MergedConfiguration(Configuration first, Configuration second) {
     public boolean has(ConfigOption option, String... umbrellaElements) {
         return first.has(option, umbrellaElements) || second.has(option, umbrellaElements);
     }
+
     @Override
     public <O> O get(ConfigOption<O> option, String... umbrellaElements) {
         if (first.has(option, umbrellaElements))

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/util/TitanGraphOutputMapReduce.java
Patch:
@@ -184,8 +184,8 @@ public TitanVertex getCreateOrDeleteVertex(final FaunusVertex faunusVertex, fina
                 if (faunusVertex.isNew() || faunusVertex.isModified()) {
                     //Synchronize properties
                     for (final TitanProperty p : faunusVertex.query().queryAll().properties()) {
-                        if (null != loaderScript && loaderScript.hasPropMethod()) {
-                            loaderScript.getProp(p, titanVertex, graph, context);
+                        if (null != loaderScript && loaderScript.hasVPropMethod()) {
+                            loaderScript.getVProp(p, titanVertex, graph, context);
                         } else {
                             getCreateOrDeleteRelation(graph, trackState, OUT, faunusVertex, titanVertex,
                                     (StandardFaunusProperty) p, context);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/Mapping.java
Patch:
@@ -9,15 +9,16 @@
  * {@link TitanManagement#addIndexKey(TitanGraphIndex, com.thinkaurelius.titan.core.PropertyKey, Parameter[])}.
  * <p/>
  * This applies mostly to string data types of keys, where the mapping specifies whether the string value is tokenized
- * ({@link #TEXT}) or indexed as a whole ({@link #STRING}).
+ * ({@link #TEXT}) or indexed as a whole ({@link #STRING}), or both ({@link #TEXTSTRING}).
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public enum Mapping {
 
     DEFAULT,
     TEXT,
-    STRING;
+    STRING,
+    TEXTSTRING;
 
     /**
      * Returns the mapping as a parameter so that it can be passed to {@link TitanManagement#addIndexKey(TitanGraphIndex, com.thinkaurelius.titan.core.PropertyKey, Parameter[])}

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexProviderTest.java
Patch:
@@ -164,7 +164,7 @@ private void storeTest(String... stores) throws Exception {
             assertEquals(ImmutableSet.copyOf(result), ImmutableSet.copyOf(tx.query(new IndexQuery(store, PredicateCondition.of(TEXT, Text.CONTAINS, "wOrLD")))));
             assertEquals(1, tx.query(new IndexQuery(store, PredicateCondition.of(TEXT, Text.CONTAINS, "bob"))).size());
             assertEquals(0, tx.query(new IndexQuery(store, PredicateCondition.of(TEXT, Text.CONTAINS, "worl"))).size());
-            //assertEquals(0, tx.query(new IndexQuery(store, PredicateCondition.of(TEXT, Text.CONTAINS, "Tomorrow is the world"))).size());
+            assertEquals(0, tx.query(new IndexQuery(store, PredicateCondition.of(TEXT, Text.CONTAINS, "Tomorrow is the world"))).size());
 
             //Ordering
             result = tx.query(new IndexQuery(store, PredicateCondition.of(TEXT, Text.CONTAINS, "world"), orderTimeDesc));
@@ -197,7 +197,7 @@ private void storeTest(String... stores) throws Exception {
             for (TitanPredicate tp : new Text[]{Text.PREFIX, Text.REGEX}) {
                 try {
                     assertEquals(0, tx.query(new IndexQuery(store, PredicateCondition.of(TEXT, tp, "world"))).size());
-                    //fail();
+                    fail();
                 } catch (IllegalArgumentException e) {}
             }
             //String
@@ -209,7 +209,7 @@ private void storeTest(String... stores) throws Exception {
             for (TitanPredicate tp : new Text[]{Text.CONTAINS,Text.CONTAINS_PREFIX, Text.CONTAINS_REGEX}) {
                 try {
                     assertEquals(0, tx.query(new IndexQuery(store, PredicateCondition.of(NAME, tp, "world"))).size());
-                    //fail();
+                    fail();
                 } catch (IllegalArgumentException e) {}
             }
             if (index.supports(new StandardKeyInformation(String.class), Text.REGEX)) {

File: titan-solr/src/main/java/com/thinkaurelius/titan/diskstorage/solr/SolrIndex.java
Patch:
@@ -74,7 +74,7 @@ public class SolrIndex implements IndexProvider {
 
     public static final ConfigOption<String> ZOOKEEPER_URL = new ConfigOption<String>(INDEX_NS,"zookeeper-url",
             "Http connection max connections per host",
-            ConfigOption.Type.GLOBAL_OFFLINE, "http://localhost:2181");
+            ConfigOption.Type.GLOBAL_OFFLINE, "localhost:2181");
 
     public static final ConfigOption<String[]> CORES = new ConfigOption<String[]>(INDEX_NS,"cores",
             "Solr cores that are going to be used.",

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/tinkerpop/gremlin/Console.java
Patch:
@@ -62,6 +62,8 @@ public Console(final IO io, final String inputPrompt, final String resultPrompt)
         } catch (Error e) {
             //System.err.println(e.getMessage());
         }
+
+        System.exit(0);
     }
 
     public Console() {
@@ -72,4 +74,5 @@ public Console() {
     public static void main(final String[] args) {
         new Console();
     }
+
 }
\ No newline at end of file

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -88,7 +88,6 @@ public static TitanGraph open(BasicConfiguration configuration) {
      * @return Titan graph database
      */
     public static TitanGraph open(ReadConfiguration configuration) {
-        ReflectiveConfigOptionLoader.loadOnce();
         return new StandardTitanGraph(new GraphDatabaseConfiguration(configuration));
     }
 
@@ -110,7 +109,6 @@ public static class Builder extends UserModifiableConfiguration {
 
         private Builder() {
             super(GraphDatabaseConfiguration.buildConfiguration());
-            ReflectiveConfigOptionLoader.loadOnce();
         }
 
         /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/UserModifiableConfiguration.java
Patch:
@@ -48,11 +48,11 @@ public String get(String path) {
                 for (String sub : config.getContainedNamespaces(ns,pp.umbrellaElements)) {
                     s.append("+ ").append(sub).append("\n");
                 }
-            } else {
+            } /* else {
                 for (ConfigElement element : ns.getChildren()) {
                     s.append(ConfigElement.toStringSingle(element)).append("\n");
                 }
-            }
+            } */
             return s.toString();
         } else {
             Object value;

File: titan-core/src/main/java/com/thinkaurelius/titan/util/system/ConfigurationLint.java
Patch:
@@ -33,9 +33,6 @@ public static void main(String args[]) throws IOException {
     }
 
     public static Status validate(String filename) throws IOException {
-
-        ReflectiveConfigOptionLoader.loadOnce();
-
         Properties p = new Properties();
         FileInputStream fis = new FileInputStream(filename);
         p.load(fis);

File: titan-core/src/main/java/com/thinkaurelius/titan/util/system/ConfigurationPrinter.java
Patch:
@@ -39,7 +39,7 @@ public class ConfigurationPrinter {
     public static void main(String args[]) throws FileNotFoundException, IllegalAccessException,
             NoSuchFieldException, ClassNotFoundException {
 
-        ReflectiveConfigOptionLoader.loadOnce();
+        ReflectiveConfigOptionLoader.INSTANCE.loadStandard(ConfigurationPrinter.class);
 
         // Write to filename argument
         if (3 != args.length) {

File: titan-es/src/test/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndexTest.java
Patch:
@@ -39,6 +39,7 @@ public static final Configuration getLocalESTestConfig() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
         config.set(LOCAL_MODE, true, index);
         config.set(CLIENT_ONLY, false, index);
+        config.set(TTL_INTERVAL, "5s", index);
         config.set(GraphDatabaseConfiguration.INDEX_DIRECTORY, StorageSetup.getHomeDir("es"), index);
         return config.restrictTo(index);
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/DaemonRunner.java
Patch:
@@ -94,6 +94,7 @@ private synchronized void killAndUnregisterHook(final S stat) {
         }
 
         if (null != killerHook) {
+            Runtime.getRuntime().removeShutdownHook(killerHook);
             killerHook = null;
             log.debug("Unregistered killer hook: {}", killerHook);
         }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/config/TitanHadoopConfiguration.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Predicate;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
+import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoSerializer;
 import com.tinkerpop.blueprints.Direction;
 import org.apache.hadoop.conf.Configuration;
 
@@ -124,7 +125,7 @@ public class TitanHadoopConfiguration {
             "Attempts to serialize objects with larger serialized representations will generate an " +
             "exception.  This should be set large enough to accommodate any single sane datum written " +
             "by Kryo, and serves as a last-resort sanity check to avoid erroneously serializing reference cycles.",
-            ConfigOption.Type.LOCAL, Integer.class);
+            ConfigOption.Type.LOCAL, Integer.class, KryoSerializer.DEFAULT_MAX_OUTPUT_SIZE);
 
     public static final ConfigNamespace INDEX_NS =
             new ConfigNamespace(TRUNK_NS, "reindex", "Index repair configuration");

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -959,7 +959,7 @@ private int getServerCount(HBaseAdmin adm) {
     private void checkConfigDeprecation(com.thinkaurelius.titan.diskstorage.configuration.Configuration config) {
         if (config.has(GraphDatabaseConfiguration.STORAGE_PORT)) {
             logger.warn("The configuration property {} is ignored for HBase. Set hbase.zookeeper.property.clientPort in hbase-site.xml or {}.hbase.zookeeper.property.clientPort in Titan's configuration file.",
-                    GraphDatabaseConfiguration.STORAGE_PORT, HBASE_CONFIGURATION_NAMESPACE);
+                    ConfigElement.getPath(GraphDatabaseConfiguration.STORAGE_PORT), ConfigElement.getPath(HBASE_CONFIGURATION_NAMESPACE));
         }
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/WritableConfigurationTest.java
Patch:
@@ -60,6 +60,6 @@ public void configTest() {
         assertTrue(Arrays.equals(new String[]{"x", "y"},config.get("storage.duba",String[].class)));
         assertEquals(Thread.State.RUNNABLE, config.get("enum", Thread.State.class));
         assertEquals(new StandardDuration(60, TimeUnit.MINUTES), config.get("times.60m", Duration.class));
-        assertTrue(config.get("obj", Object.class).getClass().equals(Object.class));
+        assertTrue(Object.class.isAssignableFrom(config.get("obj", Object.class).getClass()));
     }
 }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -540,7 +540,7 @@ private void ensureKeyspaceExists(Cluster cl) throws BackendException {
 
             log.debug("Created keyspace {}", keySpaceName);
         } catch (ConnectionException e) {
-            log.debug("Failed to create keyspace {}, keySpaceName");
+            log.debug("Failed to create keyspace {}", keySpaceName);
             throw new TemporaryBackendException(e);
         }
     }

File: titan-rexster/src/main/java/com/thinkaurelius/titan/tinkerpop/rexster/TitanGraphConfiguration.java
Patch:
@@ -61,7 +61,7 @@ public Configuration convertConfiguration(final GraphConfigurationContext contex
 
             final Configuration rewriteConfig = new BaseConfiguration();
             final String location = properties.getString(Tokens.REXSTER_GRAPH_LOCATION, "");
-            if (titanConfig.getString("storage.backend").equals("local") && location.trim().length() > 0) {
+            if (titanConfig.getString("storage.backend").equals("berkeleyje") && location.trim().length() > 0) {
                 final File directory = new File(properties.getString(Tokens.REXSTER_GRAPH_LOCATION));
                 if (!directory.isDirectory()) {
                     if (!directory.mkdirs()) {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/thriftpool/CTConnectionFactory.java
Patch:
@@ -113,9 +113,9 @@ public boolean validateObject(String key, CTConnection c) {
         boolean isSameConfig = c.getConfig().equals(curCfg);
         if (log.isDebugEnabled()) {
             if (isSameConfig) {
-                log.debug("Validated Thrift connection {}", c);
+                log.trace("Validated {} by configuration {}", c, curCfg);
             } else {
-                log.debug("Rejected Thrift connection {}; current config is {}; connection config is {}",
+                log.trace("Rejected {}; current config is {}; rejected connection config is {}",
                           c, curCfg, c.getConfig());
             }
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -674,7 +674,7 @@ public void run() {
 
                 if (0 >  messageTimeStart.compareTo(messageTimeEnd)) {
                     // nextTimepoint is strictly earlier than timeWindowEnd
-                    log.debug("MessagePuller time window: [{}, {})", messageTimeStart, messageTimeEnd);
+                    log.trace("MessagePuller time window: [{}, {})", messageTimeStart, messageTimeEnd);
                 } else {
                     /*
                      * nextTimepoint is equal to or later than timeWindowEnd. We
@@ -704,7 +704,7 @@ public void run() {
                 StaticBuffer logKey = getLogKey(partitionId,bucketId,timeslice);
                 KeySliceQuery query = new KeySliceQuery(logKey, BufferUtil.getLongBuffer(messageTimeStart.getNativeTimestamp()), BufferUtil.getLongBuffer(messageTimeEnd.getNativeTimestamp()));
                 query.setLimit(maxReadMsg);
-                log.debug("Converted MessagePuller time window to {}", query);
+                log.trace("Converted MessagePuller time window to {}", query);
 
                 List<Entry> entries= BackendOperation.execute(getOperation(query),KCVSLog.this,times,maxReadTime);
                 prepareMessageProcessing(entries);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStoreManager.java
Patch:
@@ -57,10 +57,10 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
         boolean hasAtLeastOneLock = etx.prepareForMutations();
         if (hasAtLeastOneLock) {
             // Force all mutations on this transaction to use strong consistency
-            log.debug("Mutations on transaction {} using consistent store transaction {} due to held locks", etx, etx.getConsistentTx());
+            log.debug("Transaction {} holds one or more locks: writing using consistent transaction {} due to held locks", etx, etx.getConsistentTx());
             manager.mutateMany(mutations, etx.getConsistentTx());
         } else {
-            log.debug("Mutations on transaction {} using possibly-inconsistent store transaction {} due to no held locks", etx, etx.getInconsistentTx());
+            log.debug("Transaction {} holds no locks: writing mutations using store transaction {}", etx, etx.getInconsistentTx());
             manager.mutateMany(mutations, etx.getInconsistentTx());
         }
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementLogger.java
Patch:
@@ -123,6 +123,8 @@ private EvictionTrigger(long evictionId, Set<Callable<Boolean>> updatedTypeTrigg
         void receivedAcknowledgement(String senderId) {
             if (openInstances.contains(senderId)) {
                 int countdown = ackCounter.decrementAndGet();
+                log.debug("Received acknowledgement for eviction [{}] from senderID={} ({} more acks still outstanding)",
+                        evictionId, senderId, countdown);
                 if (countdown==0) { //Trigger actions
                     for (Callable<Boolean> trigger : updatedTypeTriggers) {
                         try {
@@ -172,6 +174,7 @@ public void run() {
                     out.writeObjectNotNull(originId);
                     VariableLong.writePositive(out,evictionId);
                     sysLog.add(out.getStaticBuffer());
+                    log.debug("Sent {}: evictionID={} originID={}", MgmtLogType.CACHED_TYPE_EVICTION_ACK, originId, evictionId);
                     break;
                 }
                 if (MAX_WAIT_TIME.compareTo(t.elapsed()) < 0) {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/util/ReflectiveConfigOptionLoader.java
Patch:
@@ -49,8 +49,8 @@ private static void loadAllClassesUnsafe() {
         Iterator<URL> i = scanUrls.iterator();
         while (i.hasNext()) {
             File f = new File(i.next().getPath());
-            if (!f.exists() || f.isDirectory()) {
-                log.trace("Skipping classpath element {}", f);
+            if (!f.exists() || !f.canRead()) {
+                log.trace("Skipping nonexistent or unreadable classpath element {}", f);
                 i.remove();
             }
             log.trace("Retaining classpath element {}", f);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanTransaction.java
Patch:
@@ -48,14 +48,14 @@ public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph
      *
      * @return New vertex in the graph created in the context of this transaction.
      */
-    public TitanVertex addVertex(String vertexLabel);
+    public TitanVertex addVertexWithLabel(String vertexLabel);
 
     /**
      * Creates a new vertex in the graph with the given vertex label.
      *
      * @return New vertex in the graph created in the context of this transaction.
      */
-    public TitanVertex addVertex(VertexLabel vertexLabel);
+    public TitanVertex addVertexWithLabel(VertexLabel vertexLabel);
 
 
     /**

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -446,7 +446,7 @@ public void testConditionalIndexing() {
         assert numV%(modulo*strs.length*2)==0;
 
         for (int i=0;i<numV;i++) {
-            TitanVertex v = tx.addVertex(i%2==0?person:org);
+            TitanVertex v = tx.addVertexWithLabel(i % 2 == 0 ? person : org);
             v.addProperty(name,strs[i%strs.length]);
             v.addProperty(text,strs[i%strs.length]);
             v.addProperty(weight,(i%modulo)+0.5);
@@ -1008,12 +1008,12 @@ public void testVertexTTLWithMixedIndices() throws Exception {
         assertEquals(2, mgmt.getTTL(event).getLength(TimeUnit.SECONDS));
         finishSchema();
 
-        Vertex v1 = tx.addVertex("event");
+        Vertex v1 = tx.addVertexWithLabel("event");
         v1.setProperty("name", "first event");
         v1.setProperty("text", "this text will help to identify the first event");
         long time1 = System.currentTimeMillis();
         v1.setProperty("time", time1);
-        Vertex v2 = tx.addVertex("event");
+        Vertex v2 = tx.addVertexWithLabel("event");
         v2.setProperty("name", "second event");
         v2.setProperty("text", "this text won't match");
         long time2 = time1 + 1;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanOperationCountingTest.java
Patch:
@@ -160,7 +160,7 @@ public void testReadOperations(boolean cache) {
         metricsPrefix = "add"+cache;
 
         tx = graph.buildTransaction().setGroupName(metricsPrefix).start();
-        TitanVertex v = tx.addVertex(), u = tx.addVertex("person");
+        TitanVertex v = tx.addVertex(), u = tx.addVertexWithLabel("person");
         v.setProperty("uid",1);
         u.setProperty("name","juju");
         TitanEdge e = v.addEdge("knows",u);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanPartitionGraphTest.java
Patch:
@@ -88,7 +88,7 @@ public void testVertexPartitioning() throws Exception {
         final long[] gids = new long[numG];
 
         for (int i = 0; i < numG; i++) {
-            TitanVertex g = tx.addVertex("group");
+            TitanVertex g = tx.addVertexWithLabel("group");
             g.setProperty("gid", i);
             g.setProperty("sig",0);
             for (String n : names) {
@@ -166,7 +166,7 @@ public void testVertexPartitioning() throws Exception {
             assertNotNull(g1);
             TitanVertex[] vs = new TitanVertex[vPerTx];
             for (int vi=0;vi<vPerTx;vi++) {
-                vs[vi] = tx.addVertex("person");
+                vs[vi] = tx.addVertexWithLabel("person");
                 vs[vi].setProperty("sig", t);
                 TitanEdge e = vs[vi].addEdge("knows",g1);
                 e.setProperty("sig",t);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/SerializerGraphConfiguration.java
Patch:
@@ -43,7 +43,7 @@ public void testOnlyRegisteredSerialization() {
         mgmt.commit();
 
         TitanTransaction tx = graph.newTransaction();
-        TitanVertex v = tx.addVertex("person");
+        TitanVertex v = tx.addVertexWithLabel("person");
         v.setProperty("time",5);
         v.setProperty("any",new Precision(5.0));
         tx.commit();
@@ -54,7 +54,7 @@ public void testOnlyRegisteredSerialization() {
         tx.rollback();
 
         tx = graph.newTransaction();
-        v = tx.addVertex("person");
+        v = tx.addVertexWithLabel("person");
         v.setProperty("any",TestEnum.One); //Should not be allowed
         try {
             tx.commit();

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJETx.java
Patch:
@@ -28,7 +28,7 @@ public BerkeleyJETx(Transaction t, LockMode lockMode, BaseTransactionConfig conf
         super(config);
         tx = t;
         lm = lockMode;
-        Preconditions.checkNotNull(tx);
+        // tx may be null
         Preconditions.checkNotNull(lm);
     }
 
@@ -87,7 +87,7 @@ public synchronized void commit() throws BackendException {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + tx.toString();
+        return getClass().getSimpleName() + (null == tx ? "nulltx" : tx.toString());
     }
 
     private static class TransactionClose extends Exception {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/config/TitanHadoopConfiguration.java
Patch:
@@ -63,7 +63,7 @@ public class TitanHadoopConfiguration {
     public static final ConfigOption<String> JOBDIR_LOCATION = new ConfigOption<String>(
             JOBDIR_NS, "location",
             "An HDFS path used to store temporary SequenceFiles in between executions of MR jobs chained together by Titan-Hadoop",
-            ConfigOption.Type.LOCAL, String.class);
+            ConfigOption.Type.LOCAL, "jobs");
 
     public static final ConfigOption<Boolean> JOBDIR_OVERWRITE = new ConfigOption<Boolean>(
             JOBDIR_NS, "overwrite",

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/HadoopGraph.java
Patch:
@@ -97,9 +97,6 @@ public void setInputLocation(final String path) {
     // JOB AND FILESYSTEM
 
     public Path getJobDir() {
-        if (!getTitanConf().has(JOBDIR_LOCATION))
-            return null;
-
         return new Path(getTitanConf().get(JOBDIR_LOCATION));
     }
 

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/graphson/GraphSONRecordReaderTest.java
Patch:
@@ -43,7 +43,7 @@ public void testRecordReader() throws Exception {
 
     public void testRecordReaderWithVertexQueryFilterDirection() throws Exception {
         Configuration config = new Configuration();
-        ModifiableHadoopConfiguration faunusConf = new ModifiableHadoopConfiguration();
+        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(config);
         faunusConf.set(TitanHadoopConfiguration.INPUT_VERTEX_QUERY_FILTER, "v.query().direction(OUT)");
         GraphSONRecordReader reader = new GraphSONRecordReader(VertexQueryFilter.create(config));
         reader.initialize(new FileSplit(new Path(GraphSONRecordReaderTest.class.getResource("graph-of-the-gods.json").toURI()), 0, Long.MAX_VALUE, new String[]{}),
@@ -61,7 +61,7 @@ public void testRecordReaderWithVertexQueryFilterDirection() throws Exception {
 
     public void testRecordReaderWithVertexQueryFilterLimit() throws Exception {
         Configuration config = new Configuration();
-        ModifiableHadoopConfiguration faunusConf = new ModifiableHadoopConfiguration();
+        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(config);
         faunusConf.set(TitanHadoopConfiguration.INPUT_VERTEX_QUERY_FILTER, "v.query().limit(0)");
         GraphSONRecordReader reader = new GraphSONRecordReader(VertexQueryFilter.create(config));
         reader.initialize(new FileSplit(new Path(GraphSONRecordReaderTest.class.getResource("graph-of-the-gods.json").toURI()), 0, Long.MAX_VALUE, new String[]{}),

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/edgelist/rdf/RDFRecordReaderTest.java
Patch:
@@ -3,6 +3,7 @@
 import com.thinkaurelius.titan.hadoop.BaseTest;
 import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 
+import com.thinkaurelius.titan.hadoop.config.ModifiableHadoopConfiguration;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.io.NullWritable;
@@ -16,7 +17,8 @@ public class RDFRecordReaderTest extends BaseTest {
 
     public void testRecordReader() throws Exception {
         Configuration conf = new Configuration();
-        conf.set(RDFInputFormat.TITAN_HADOOP_GRAPH_INPUT_RDF_FORMAT, "n-triples");
+        ModifiableHadoopConfiguration faunusConf = ModifiableHadoopConfiguration.of(conf);
+        faunusConf.getInputConf(RDFConfig.RDF_ROOT).set(RDFConfig.RDF_FORMAT, RDFConfig.Syntax.N_TRIPLES);
         RDFRecordReader reader = new RDFRecordReader(conf);
         reader.initialize(new FileSplit(new Path(RDFRecordReaderTest.class.getResource("graph-example-1.ntriple").toURI()), 0, Long.MAX_VALUE, new String[]{}),
                 HadoopCompatLoader.getCompat().newTask(conf, new TaskAttemptID()));

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanInputFormat.java
Patch:
@@ -38,7 +38,7 @@ public void setConf(final Configuration config) {
         this.vertexQuery = FaunusVertexQueryFilter.create(config);
 
         this.faunusConf = TitanHadoopConfiguration.of(config);
-        this.titanInputConf = faunusConf.extractInputGraphConfiguration();
+        this.titanInputConf = faunusConf.getInputConf();
         final String titanVersion = faunusConf.get(TITAN_INPUT_VERSION);
         this.trackPaths = faunusConf.get(PIPELINE_TRACK_PATHS);
         final String className = SETUP_PACKAGE_PREFIX + titanVersion + SETUP_CLASS_NAME;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -38,7 +38,7 @@ public class TitanHadoopSetupImpl extends TitanHadoopSetupCommon {
     private final StandardTitanTx tx;
 
     public TitanHadoopSetupImpl(final Configuration config) {
-        BasicConfiguration bc = TitanHadoopConfiguration.of(config).extractInputGraphConfiguration();
+        BasicConfiguration bc = TitanHadoopConfiguration.of(config).getInputConf();
         graph = (StandardTitanGraph)TitanFactory.open(bc);
 
         tx = (StandardTitanTx)graph.buildTransaction().readOnly().setVertexCacheSize(200).start();

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/config/TitanHadoopConfiguration.java
Patch:
@@ -14,7 +14,7 @@
 public class TitanHadoopConfiguration {
 
     public static final ConfigNamespace ROOT_NS =
-            new ConfigNamespace(null, "h-root", "titan-hadoop configuration root");
+            new ConfigNamespace(null, "faunus", "Faunus configuration root");
 
     public static final ConfigNamespace TRUNK_NS =
             new ConfigNamespace(new ConfigNamespace(ROOT_NS, "titan", "titan-hadoop namespace"), "hadoop", "titan-hadoop namespace"); // TODO fix descriptions

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/TitanIndexRepair.java
Patch:
@@ -39,7 +39,7 @@ public static void cassandraRepair(String titanPropertiesPath, String indexName,
     }
 
     public static void cassandraRepair(Properties titanInputProperties, String indexName, String indexType, String partitioner) throws Exception {
-        Configuration hadoopConfig = TitanGraphOutputMapReduce.createConfiguration();
+        Configuration hadoopConfig = new Configuration();
 
         hadoopConfig.set(ConfigElement.getPath(TitanHadoopConfiguration.INPUT_FORMAT), TitanCassandraInputFormat.class.getCanonicalName());
         ConfigHelper.setInputPartitioner(hadoopConfig, partitioner);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -147,7 +147,7 @@ public byte getByte() {
             new ConfigOption<Integer>(CPOOL_NS, "idle-tests-per-eviction-run",
             "When the value is negative, e.g. -n, roughly one nth of the idle connections are tested per run.  " +
             "When the value is positive, e.g. n, the min(idle-count, n) connections are tested per run.",
-            ConfigOption.Type.MASKABLE, -1);
+            ConfigOption.Type.MASKABLE, 0);
 
 
     private final Map<String, CassandraThriftKeyColumnValueStore> openStores;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -182,8 +182,7 @@ public Builder customCleaner(LockCleanerService s) {
         public Builder fromConfig(Configuration config) {
             rid(new StaticArrayBuffer(config.get(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID).getBytes()));
 
-            final String llmPrefix = config.get(
-                    ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX);
+            final String llmPrefix = config.get(GraphDatabaseConfiguration.LOCK_LOCAL_MEDIATOR_GROUP);
 
             times(config.get(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER));
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -20,6 +20,7 @@
 
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.*;
 
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
 import com.thinkaurelius.titan.util.system.BackgroundThread;
 
@@ -61,6 +62,7 @@
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
+@PreInitializeConfigOptions
 public class KCVSLog implements Log, BackendOperation.TransactionalProvider {
 
     private static final Logger log = LoggerFactory.getLogger(KCVSLog.class);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLogManager.java
Patch:
@@ -12,6 +12,7 @@
 import com.thinkaurelius.titan.diskstorage.log.LogManager;
 import com.thinkaurelius.titan.diskstorage.log.ReadMarker;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.graphdb.database.idassigner.placement.PartitionIDRange;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
 import com.thinkaurelius.titan.graphdb.database.serialize.StandardSerializer;
@@ -31,6 +32,7 @@
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
+@PreInitializeConfigOptions
 public class KCVSLogManager implements LogManager {
 
     private static final Logger log =

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanCassandraOutputFormatTest.java
Patch:
@@ -6,9 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.CommonsConfiguration;
-import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingStore;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.hadoop.FaunusTypeManager;
 import com.thinkaurelius.titan.hadoop.HadoopGraph;
 import com.thinkaurelius.titan.hadoop.formats.TitanOutputFormatTest;
 import com.thinkaurelius.titan.hadoop.tinkerpop.gremlin.Imports;
@@ -28,7 +26,7 @@ private static TitanGraph startUpCassandra() throws Exception {
         configuration.set(STORAGE_HOSTS,new String[]{"localhost"});
         configuration.set(STORAGE_CONF_FILE, TitanCassandraOutputFormat.class.getResource("cassandra.yaml").toString());
         configuration.set(DB_CACHE, false);
-        configuration.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX, "tmp");
+        configuration.set(GraphDatabaseConfiguration.LOCK_LOCAL_MEDIATOR_GROUP, "tmp");
         configuration.set(UNIQUE_INSTANCE_ID, "inst");
         Backend backend = new Backend(configuration);
         backend.initialize(configuration);

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanGraphMRTest.java
Patch:
@@ -23,7 +23,7 @@ public class TitanGraphMRTest extends TitanOutputFormatTest {
 //        configuration.set(STORAGE_HOSTS,new String[]{"localhost"});
 //        configuration.set(STORAGE_CONF_FILE, TitanCassandraOutputFormat.class.getResource("cassandra.yaml").toString());
 //        configuration.set(DB_CACHE, false);
-//        configuration.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX, "tmp");
+//        configuration.set(ExpectedValueCheckingStore.LOCK_LOCAL_MEDIATOR_GROUP, "tmp");
 //        configuration.set(UNIQUE_INSTANCE_ID, "inst");
 //        Backend backend = new Backend(configuration);
 //        backend.initialize(configuration);

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/titan/hbase/TitanHBaseOutputFormatTest.java
Patch:
@@ -6,7 +6,6 @@
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.CommonsConfiguration;
-import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingStore;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.hadoop.HadoopGraph;
 import com.thinkaurelius.titan.hadoop.formats.TitanOutputFormatTest;
@@ -27,7 +26,7 @@ private static TitanGraph startUpHBase() throws Exception {
         configuration.set(STORAGE_HOSTS,new String[]{"localhost"});
         configuration.set(STORAGE_PORT,2181);
         configuration.set(DB_CACHE, false);
-        configuration.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX, "tmp");
+        configuration.set(GraphDatabaseConfiguration.LOCK_LOCAL_MEDIATOR_GROUP, "tmp");
         configuration.set(UNIQUE_INSTANCE_ID, "inst");
         Backend backend = new Backend(configuration);
         backend.initialize(configuration);

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -111,7 +111,7 @@ public void open() throws BackendException {
             }
 
             ModifiableConfiguration sc = GraphDatabaseConfiguration.buildConfiguration();
-            sc.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX,concreteClassName + i);
+            sc.set(GraphDatabaseConfiguration.LOCK_LOCAL_MEDIATOR_GROUP,concreteClassName + i);
             sc.set(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID,"inst"+i);
             sc.set(GraphDatabaseConfiguration.LOCK_RETRY,10);
             sc.set(GraphDatabaseConfiguration.LOCK_EXPIRE, new StandardDuration(EXPIRE_MS, TimeUnit.MILLISECONDS));

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -13,7 +13,6 @@
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
-import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingStore;
 import com.thinkaurelius.titan.diskstorage.log.Log;
 import com.thinkaurelius.titan.diskstorage.log.LogManager;
 import com.thinkaurelius.titan.diskstorage.log.kcvs.KCVSLogManager;
@@ -64,7 +63,7 @@ public void setUp() throws Exception {
         TestGraphConfigs.applyOverrides(config);
         Preconditions.checkNotNull(config);
         ModifiableConfiguration configuration = new ModifiableConfiguration(GraphDatabaseConfiguration.ROOT_NS,config.copy(), BasicConfiguration.Restriction.NONE);
-        configuration.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX, "tmp");
+        configuration.set(GraphDatabaseConfiguration.LOCK_LOCAL_MEDIATOR_GROUP, "tmp");
         configuration.set(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID, "inst");
         Backend backend = new Backend(configuration);
         backend.initialize(configuration);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/ConfigElement.java
Patch:
@@ -136,7 +136,7 @@ public static String getPath(ConfigElement element, String... umbrellaElements)
         while (!element.isRoot() && !element.getNamespace().isRoot()) {
             ConfigNamespace parent = element.getNamespace();
             if (parent.isUmbrella()) {
-                Preconditions.checkArgument(umbrellaPos>=0,"Missing umbrella element path for element: {}",element);
+                Preconditions.checkArgument(umbrellaPos>=0,"Missing umbrella element path for element: %s",element);
                 String umbrellaName = umbrellaElements[umbrellaPos];
                 Preconditions.checkArgument(!StringUtils.containsAny(umbrellaName,ILLEGAL_CHARS),"Invalid umbrella name provided: %s. Contains illegal chars",umbrellaName);
                 path = umbrellaName + SEPARATOR + path;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/edgelist/rdf/RDFInputFormat.java
Patch:
@@ -18,6 +18,8 @@
 
 import java.io.IOException;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
@@ -34,7 +36,7 @@ public class RDFInputFormat extends FileInputFormat<NullWritable, FaunusElement>
 
     @Override
     public RecordReader<NullWritable, FaunusElement> createRecordReader(final InputSplit split, final TaskAttemptContext context) throws IOException {
-        return new RDFRecordReader(context.getConfiguration());
+        return new RDFRecordReader(DEFAULT_COMPAT.getContextConfiguration(context));
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/graphson/GraphSONRecordReader.java
Patch:
@@ -33,7 +33,6 @@ public GraphSONRecordReader(VertexQueryFilter vertexQuery) {
     public void initialize(final InputSplit genericSplit, final TaskAttemptContext context) throws IOException {
         this.lineRecordReader.initialize(genericSplit, context);
         this.configuration = DEFAULT_COMPAT.getContextConfiguration(context);
-        //this.configuration = context.getConfiguration();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/script/ScriptInputFormat.java
Patch:
@@ -16,6 +16,8 @@
 
 import java.io.IOException;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 /**
  * ScriptInputFormat supports the arbitrary parsing of a \n-based file format.
  * Each line of the file is passed to the Gremlin/Groovy script identified by the titan.hadoop.input.script.file property.
@@ -43,7 +45,7 @@ public RecordReader<NullWritable, FaunusVertex> createRecordReader(final InputSp
 
     @Override
     protected boolean isSplitable(final JobContext context, final Path file) {
-        return null == new CompressionCodecFactory(context.getConfiguration()).getCodec(file);
+        return null == new CompressionCodecFactory(DEFAULT_COMPAT.getJobContextConfiguration(context)).getCodec(file);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -80,7 +80,6 @@ public class Backend implements LockerProvider {
 
     public static final String SYSTEM_TX_LOG_NAME = "txlog";
     public static final String SYSTEM_MGMT_LOG_NAME = "systemlog";
-    public static final String USER_LOG_PREFIX = "ulog_";
 
     public static final double EDGESTORE_CACHE_PERCENT = 0.8;
     public static final double INDEXSTORE_CACHE_PERCENT = 0.2;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -810,6 +810,7 @@ public boolean apply(@Nullable Integer uniqueIdBitWidth) {
     public static final String MANAGEMENT_LOG = "titan";
     public static final String TRANSACTION_LOG = "tx";
     public static final String USER_LOG = "user";
+    public static final String USER_LOG_PREFIX = "ulog_";
 
     public static final StandardDuration TRANSACTION_LOG_DEFAULT_TTL = new StandardDuration(7,TimeUnit.DAYS);
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -190,7 +190,7 @@ public void closeLogManager(String logManagerName) {
     }
 
     public Log openUserLog(String identifier) {
-        return openLog(USER_LOG, Backend.USER_LOG_PREFIX +identifier);
+        return openLog(USER_LOG, GraphDatabaseConfiguration.USER_LOG_PREFIX +identifier);
     }
 
     public Log openTxLog() {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -20,7 +20,6 @@
 import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
 import com.thinkaurelius.titan.core.schema.EdgeLabelMaker;
-import com.thinkaurelius.titan.core.schema.ModifierType;
 import com.thinkaurelius.titan.core.schema.Parameter;
 import com.thinkaurelius.titan.core.schema.PropertyKeyMaker;
 import com.thinkaurelius.titan.core.schema.RelationTypeIndex;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ModifierType.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.core.schema;
+package com.thinkaurelius.titan.graphdb.database.management;
 
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalRelationType.java
Patch:
@@ -4,7 +4,6 @@
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.core.Order;
 import com.thinkaurelius.titan.core.RelationType;
-import com.thinkaurelius.titan.core.schema.ModifierType;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 import com.tinkerpop.blueprints.Direction;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeDefinitionCategory.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.core.Order;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
-import com.thinkaurelius.titan.core.schema.ModifierType;
+import com.thinkaurelius.titan.graphdb.database.management.ModifierType;
 import com.thinkaurelius.titan.core.schema.Parameter;
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.internal.ElementCategory;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeUtil.java
Patch:
@@ -1,11 +1,10 @@
 package com.thinkaurelius.titan.graphdb.types;
 
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.Cardinality;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
-import com.thinkaurelius.titan.core.schema.ModifierType;
+import com.thinkaurelius.titan.graphdb.database.management.ModifierType;
 import com.thinkaurelius.titan.graphdb.internal.ElementCategory;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelationType;
 import com.tinkerpop.blueprints.Direction;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseRelationType.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
-import com.thinkaurelius.titan.core.schema.ModifierType;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
 import org.apache.commons.lang.StringUtils;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyRelationType.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.thinkaurelius.titan.core.Order;
-import com.thinkaurelius.titan.core.schema.ModifierType;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelationType;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.core.schema.SchemaStatus;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/HadoopFileOutputFormat.java
Patch:
@@ -15,13 +15,15 @@
 import java.io.DataOutputStream;
 import java.io.IOException;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
 public abstract class HadoopFileOutputFormat extends FileOutputFormat<NullWritable, FaunusVertex> {
 
     public DataOutputStream getDataOuputStream(final TaskAttemptContext job) throws IOException, InterruptedException {
-        final Configuration conf = job.getConfiguration();
+        final Configuration conf = DEFAULT_COMPAT.getContextConfiguration(job);
         boolean isCompressed = getCompressOutput(job);
         CompressionCodec codec = null;
         String extension = "";

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/script/ScriptOutputFormat.java
Patch:
@@ -9,6 +9,8 @@
 
 import java.io.IOException;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
@@ -18,6 +20,6 @@ public class ScriptOutputFormat extends HadoopFileOutputFormat {
 
     @Override
     public RecordWriter<NullWritable, FaunusVertex> getRecordWriter(final TaskAttemptContext job) throws IOException, InterruptedException {
-        return new ScriptRecordWriter(super.getDataOuputStream(job), job.getConfiguration());
+        return new ScriptRecordWriter(super.getDataOuputStream(job), DEFAULT_COMPAT.getContextConfiguration(job));
     }
 }
\ No newline at end of file

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/hbase/TitanHBaseRecordReader.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
 import com.thinkaurelius.titan.hadoop.FaunusVertexQueryFilter;
-import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.hbase.mapreduce.TableRecordReader;
@@ -13,6 +12,8 @@
 
 import java.io.IOException;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
@@ -37,7 +38,7 @@ public TitanHBaseRecordReader(final TitanHBaseHadoopGraph graph, final FaunusVer
     @Override
     public void initialize(final InputSplit inputSplit, final TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException {
         this.reader.initialize(inputSplit, taskAttemptContext);
-        this.configuration = taskAttemptContext.getConfiguration();
+        this.configuration = DEFAULT_COMPAT.getContextConfiguration(taskAttemptContext);
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanOperationCountingTest.java
Patch:
@@ -456,7 +456,8 @@ public void testCacheConcurrency() throws InterruptedException {
                 option(GraphDatabaseConfiguration.METRICS_PREFIX),metricsPrefix};
         clopen(newConfig);
         final String prop = "property";
-        graph.makePropertyKey(prop).dataType(Integer.class).make();
+        makeKey(prop,Integer.class);
+        finishSchema();
 
         final int numV = 100;
         final long[] vids = new long[numV];

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -1088,9 +1088,10 @@ else if (query.getResultType() == ElementCategory.VERTEX) {
                     return !query.matches(result);
                 } else return false;
             } else if (query.getResultType() == ElementCategory.EDGE || query.getResultType()==ElementCategory.PROPERTY) {
-                //Loaded edges are immutable and new edges are previously filtered
+                //Loaded edges are immutable and new edges are previously filtered, however, we need to filter
+                //out new edges so that their old state doesn't reappear
                 Preconditions.checkArgument(result.isLoaded() || result.isNew());
-                return false;
+                return result.isNew();
             } else throw new IllegalArgumentException("Unexpected type: " + query.getResultType());
         }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -471,7 +471,7 @@ private Iterable<InternalVertex> getInternalVertices() {
             List<InternalVertex> newVs = vertexCache.getAllNew();
             Iterator<InternalVertex> viter = newVs.iterator();
             while (viter.hasNext()) {
-                if (viter.next() instanceof RelationType) viter.remove();
+                if (viter.next() instanceof TitanSchemaElement) viter.remove();
             }
             allVertices = Iterables.concat(newVs, new VertexIterable(graph, this));
         } else {

File: titan-core/src/main/java/com/thinkaurelius/titan/util/encoding/LongEncoding.java
Patch:
@@ -11,7 +11,7 @@
  */
 public class LongEncoding {
 
-    private static final String BASE_SYMBOLS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+    private static final String BASE_SYMBOLS = "0123456789abcdefghijklmnopqrstuvwxyz";
 
     public static long decode(String s) {
         return decode(s,BASE_SYMBOLS);
@@ -27,7 +27,7 @@ public static long decode(String s, String symbols) {
         for (char ch : s.toCharArray()) {
             num *= B;
             int pos = symbols.indexOf(ch);
-            if (pos<0) throw new NumberFormatException("Sybmol set does not match string");
+            if (pos<0) throw new NumberFormatException("Symbol set does not match string");
             num += pos;
         }
         return num;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -144,7 +144,7 @@ public ManagementSystem(StandardTitanGraph graph, KCVSConfiguration config, Log
         this.updatedTypeTriggers = new HashSet<Callable<Boolean>>();
         this.graphShutdownRequired = false;
 
-        this.transaction = (StandardTitanTx) graph.newTransaction();
+        this.transaction = (StandardTitanTx) graph.buildTransaction().disableBatchLoading().start();
         this.txStartTime = graph.getConfiguration().getTimestampProvider().getTime();
         this.isOpen = true;
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/ThriftBlueprintsTest.java
Patch:
@@ -17,7 +17,7 @@ public class ThriftBlueprintsTest extends AbstractCassandraBlueprintsTest {
 
     @Override
     public void beforeSuite() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxIDAuthorityTest.java
Patch:
@@ -15,7 +15,7 @@ public AstyanaxIDAuthorityTest(WriteConfiguration baseConfig) {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxLockStoreTest.java
Patch:
@@ -11,7 +11,7 @@ public class AstyanaxLockStoreTest extends LockKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxLogTest.java
Patch:
@@ -14,7 +14,7 @@ public class AstyanaxLogTest extends KCVSLogTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxMultiWriteStoreTest.java
Patch:
@@ -11,7 +11,7 @@ public class AstyanaxMultiWriteStoreTest extends MultiWriteKeyColumnValueStoreTe
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreTest.java
Patch:
@@ -13,7 +13,7 @@ public class AstyanaxStoreTest extends AbstractCassandraStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedLogTest.java
Patch:
@@ -14,7 +14,7 @@ public class EmbeddedLogTest extends KCVSLogTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedStoreTest.java
Patch:
@@ -19,7 +19,7 @@ public class EmbeddedStoreTest extends AbstractCassandraStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftDistributedStoreManagerTest.java
Patch:
@@ -12,7 +12,7 @@ public class ThriftDistributedStoreManagerTest extends DistributedStoreManagerTe
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Before

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftIDAuthorityTest.java
Patch:
@@ -15,7 +15,7 @@ public ThriftIDAuthorityTest(WriteConfiguration baseConfig) {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftLockStoreTest.java
Patch:
@@ -11,7 +11,7 @@ public class ThriftLockStoreTest extends LockKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftLogTest.java
Patch:
@@ -14,7 +14,7 @@ public class ThriftLogTest extends KCVSLogTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftMultiWriteStoreTest.java
Patch:
@@ -11,7 +11,7 @@ public class ThriftMultiWriteStoreTest extends MultiWriteKeyColumnValueStoreTest
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftStoreTest.java
Patch:
@@ -13,7 +13,7 @@ public class ThriftStoreTest extends AbstractCassandraStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/CassandraGraphTest.java
Patch:
@@ -13,7 +13,7 @@ public abstract class CassandraGraphTest extends TitanGraphTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/AstyanaxGraphConcurrentTest.java
Patch:
@@ -13,7 +13,7 @@ public class AstyanaxGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/AstyanaxGraphPerformanceMemoryTest.java
Patch:
@@ -10,7 +10,7 @@ public class AstyanaxGraphPerformanceMemoryTest extends TitanGraphPerformanceMem
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/AstyanaxPartitionGraphTest.java
Patch:
@@ -10,7 +10,7 @@ public class AstyanaxPartitionGraphTest extends TitanPartitionGraphTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedEventualGraphTest.java
Patch:
@@ -10,7 +10,7 @@ public class EmbeddedEventualGraphTest extends TitanEventualGraphTest {
 
     @BeforeClass
     public static void startEmbeddedCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedGraphConcurrentTest.java
Patch:
@@ -17,7 +17,7 @@ public class EmbeddedGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedGraphMemoryPerformanceTest.java
Patch:
@@ -14,7 +14,7 @@ public class EmbeddedGraphMemoryPerformanceTest extends TitanGraphPerformanceMem
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedPartitionGraphTest.java
Patch:
@@ -10,7 +10,7 @@ public class EmbeddedPartitionGraphTest extends TitanPartitionGraphTest {
 
     @BeforeClass
     public static void startEmbeddedCassandra() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftElasticsearchTest.java
Patch:
@@ -36,6 +36,6 @@ public boolean supportsLuceneStyleQueries() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftEventualGraphTest.java
Patch:
@@ -16,6 +16,6 @@ public WriteConfiguration getConfiguration() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphCacheTest.java
Patch:
@@ -16,7 +16,7 @@ public WriteConfiguration getConfiguration() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphConcurrentTest.java
Patch:
@@ -19,6 +19,6 @@ public WriteConfiguration getConfiguration() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphIterativeTest.java
Patch:
@@ -25,6 +25,6 @@ public KeyColumnValueStoreManager openStorageManager() throws BackendException {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphPerformanceMemoryTest.java
Patch:
@@ -17,6 +17,6 @@ public WriteConfiguration getConfiguration() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphSerialSpeedTest.java
Patch:
@@ -29,7 +29,7 @@ public ThriftGraphSerialSpeedTest() throws BackendException {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftOLAPTest.java
Patch:
@@ -15,6 +15,6 @@ public WriteConfiguration getConfiguration() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftOperationCountingTest.java
Patch:
@@ -9,7 +9,7 @@ public class ThriftOperationCountingTest extends TitanOperationCountingTest {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftPartitionGraphTest.java
Patch:
@@ -10,7 +10,7 @@ public class ThriftPartitionGraphTest extends TitanPartitionGraphTest {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftWritePerformanceTest.java
Patch:
@@ -17,6 +17,6 @@ public WriteConfiguration getConfiguration() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
+        CassandraStorageSetup.startCleanEmbedded();
     }
 }

File: titan-dist/src/test/java/com/thinkaurelius/titan/pkgtest/BerkeleyAssemblyIT.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-public class BerkeleyAssemblyIT extends AssemblyITSupport {
+public class BerkeleyAssemblyIT extends AbstractTitanAssemblyIT {
     
     @Test
     public void testBerkeleySimpleSession() throws Exception {

File: titan-dist/src/test/java/com/thinkaurelius/titan/pkgtest/BerkeleyESAssemblyIT.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 
-public class BerkeleyESAssemblyIT extends AssemblyITSupport {
+public class BerkeleyESAssemblyIT extends AbstractTitanAssemblyIT {
     
     @Test
     public void testBerkeleyGettingStarted() throws Exception {

File: titan-dist/src/test/java/com/thinkaurelius/titan/pkgtest/CassandraEmbeddedAssemblyIT.java
Patch:
@@ -1,10 +1,9 @@
 package com.thinkaurelius.titan.pkgtest;
 
 import org.junit.Test;
-import java.io.File;
 
-public class CassandraEmbeddedAssemblyIT extends AssemblyITSupport {
-    
+public class CassandraEmbeddedAssemblyIT extends AbstractTitanAssemblyIT {
+
     @Test
     public void testEmbeddedCassandraSimpleSession() throws Exception {
         testSimpleGremlinSession("conf/titan-cassandra-embedded.properties", "embeddedcassandra");

File: titan-dist/src/test/java/com/thinkaurelius/titan/pkgtest/CassandraEmbeddedESAssemblyIT.java
Patch:
@@ -1,10 +1,9 @@
 package com.thinkaurelius.titan.pkgtest;
 
 import org.junit.Test;
-import java.io.File;
 
-public class CassandraEmbeddedESAssemblyIT extends AssemblyITSupport {
-    
+public class CassandraEmbeddedESAssemblyIT extends AbstractTitanAssemblyIT {
+
     @Test
     public void testEmbeddedCassandraGettingStarted() throws Exception {
         testGettingStartedGremlinSession("conf/titan-cassandra-embedded-es.properties", "embeddedcassandra");

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -37,7 +37,6 @@
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingStoreManager;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.util.system.IOUtils;
 
 import static org.easymock.EasyMock.*;
 
@@ -376,11 +375,11 @@ public void testLocksOnMultipleStores() throws Exception {
         expect(mockLockerProvider.getLocker(anyObject(String.class))).andReturn(mockLocker).times(numStores);
 
         // acquireLock calls writeLock, and we do it 2/3 * numStores times
-        mockLocker.writeLock(eq(new KeyColumn(key, col)), eq(tx.getLockTransaction()));
+        mockLocker.writeLock(eq(new KeyColumn(key, col)), eq(tx.getConsistentTx()));
         expectLastCall().times(numStores / 3 * 2);
 
         // mutateMany calls checkLocks, and we do it 2/3 * numStores times
-        mockLocker.checkLocks(tx.getLockTransaction());
+        mockLocker.checkLocks(tx.getConsistentTx());
         expectLastCall().times(numStores / 3 * 2);
 
         replay(mockLockerProvider);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/SerializerTest.java
Patch:
@@ -201,14 +201,14 @@ public void testObjectVerification() {
         try {
             out.writeClassAndObject(dc);
             fail();
-        } catch (IllegalArgumentException e) {
+        } catch (Exception e) {
 
         }
         TestTransientClass d = new TestTransientClass(101);
         try {
             out.writeClassAndObject(d);
             fail();
-        } catch (IllegalArgumentException e) {
+        } catch (Exception e) {
 
         }
         out.writeObject(null, TestClass.class);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanTransaction.java
Patch:
@@ -36,7 +36,6 @@ public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph
     * ---------------------------------------------------------------
     */
 
-
     /**
      * Creates a new vertex in the graph.
      *

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -281,6 +281,7 @@ public TransactionConfiguration getConfiguration() {
         return config;
     }
 
+    @Override
     public StandardTitanGraph getGraph() {
         return graph;
     }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/tinkerpop/gremlin/FaunusGremlinScriptEngine.java
Patch:
@@ -22,7 +22,7 @@ public FaunusGremlinScriptEngine() {
         HadoopGremlin.load();
         final CompilerConfiguration conf = new CompilerConfiguration();
         conf.addCompilationCustomizers(FaunusGremlinScriptEngine.getImportCustomizer());
-        this.loader = new GroovyClassLoader(getParentLoader(), conf);
+        this.loader = new GroovyClassLoader(this.getParentLoader(), conf);
         try {
             this.setBindings(Imports.getEvaluateBindings(), ScriptContext.GLOBAL_SCOPE);
         } catch (IOException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -322,7 +322,7 @@ public void reindexElement(TitanElement element, MixedIndexType index, Map<Strin
         for (ParameterIndexField field: index.getFieldKeys()) {
             PropertyKey key = field.getFieldKey();
             if (field.getStatus()==SchemaStatus.DISABLED) continue;
-            Object value = element.getProperty(key);
+            Object value = element.getProperty(key.getName());
             if (value!=null) {
                 entries.add(new IndexEntry(key2Field(field), value));
             }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/FaunusElement.java
Patch:
@@ -156,7 +156,7 @@ protected void setRelation(final FaunusRelation relation) {
             // existing relations of that type, no matter how many -- log this
             // behavior and suggest addRelation to suppress the warning when
             // using a multi-valued type
-            log.warn( "setRelation deleted {} relations of type {} with multiplicity {}; " +
+            log.info( "setRelation deleted {} relations of type {} with multiplicity {}; " +
                       "use addRelation instead of setRelation to avoid deletion",
                       killedRels, relation.getType(), adjMulti);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -110,6 +110,7 @@ public static class Builder extends UserModifiableConfiguration {
 
         private Builder() {
             super(GraphDatabaseConfiguration.buildConfiguration());
+            ReflectiveConfigOptionLoader.loadOnce();
         }
 
         /**

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanCassandraOutputFormatTest.java
Patch:
@@ -33,6 +33,7 @@ private static TitanGraph startUpCassandra() throws Exception {
         Backend backend = new Backend(configuration);
         backend.initialize(configuration);
         backend.clearStorage();
+        backend.close();
 
         return TitanFactory.open(configuration);
     }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanGraphOutputMapReduce.java
Patch:
@@ -272,8 +272,8 @@ private static TitanRelation getIncidentRelation(final TitanGraph graph, final D
                 qb.adjacent((TitanVertex) graph.getVertex(edge.getVertexId(dir.opposite())));
             }
         }
-        qb.has(ImplicitKey.TITANID.getName(), Cmp.EQUAL, faunusRelation.getLongId());
-        TitanRelation titanRelation = (TitanRelation)Iterables.getFirst(qb.relations(),null);
+//        qb.has(ImplicitKey.TITANID.getName(), Cmp.EQUAL, faunusRelation.getLongId()); TODO: must check for multiplicity constraints
+        TitanRelation titanRelation = (TitanRelation)Iterables.getFirst(faunusRelation.isEdge()?qb.titanEdges():qb.properties(),null);
         assert titanRelation==null || titanRelation.getLongId()==faunusRelation.getLongId();
         return titanRelation;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/CommonsConfiguration.java
Patch:
@@ -10,6 +10,7 @@
 
 import org.apache.commons.configuration.BaseConfiguration;
 import org.apache.commons.configuration.Configuration;
+import org.apache.commons.configuration.HierarchicalINIConfiguration;
 import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/FaunusProperty.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.hadoop;
 
 import com.thinkaurelius.titan.core.TitanProperty;
-import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/graphson/GraphSONInputFormat.java
Patch:
@@ -1,7 +1,8 @@
 package com.thinkaurelius.titan.hadoop.formats.graphson;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
-import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 
 import org.apache.hadoop.conf.Configurable;
@@ -32,7 +33,7 @@ public RecordReader<NullWritable, FaunusVertex> createRecordReader(final InputSp
 
     @Override
     protected boolean isSplitable(final JobContext context, final Path file) {
-        return null == new CompressionCodecFactory(HadoopCompatLoader.getDefaultCompat().getJobContextConfiguration(context)).getCodec(file);
+        return null == new CompressionCodecFactory(DEFAULT_COMPAT.getJobContextConfiguration(context)).getCodec(file);
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/graphson/GraphSONRecordReader.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.hadoop.formats.graphson;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
 
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
-import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 
 import org.apache.hadoop.conf.Configuration;
@@ -32,7 +32,7 @@ public GraphSONRecordReader(VertexQueryFilter vertexQuery) {
     @Override
     public void initialize(final InputSplit genericSplit, final TaskAttemptContext context) throws IOException {
         this.lineRecordReader.initialize(genericSplit, context);
-        this.configuration = HadoopCompatLoader.getDefaultCompat().getContextConfiguration(context);
+        this.configuration = DEFAULT_COMPAT.getContextConfiguration(context);
         //this.configuration = context.getConfiguration();
     }
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanOutputFormat.java
Patch:
@@ -4,7 +4,6 @@
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
 import com.thinkaurelius.titan.hadoop.Holder;
 import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
-import com.thinkaurelius.titan.hadoop.config.ConfigurationUtil;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.formats.MapReduceFormat;
 import com.thinkaurelius.titan.hadoop.formats.noop.NoOpOutputFormat;
@@ -28,7 +27,8 @@ public abstract class TitanOutputFormat extends NoOpOutputFormat implements MapR
     @Override
     public void addMapReduceJobs(final HadoopCompiler compiler) {
 
-        final boolean inferSchema = ConfigurationUtil.get(compiler.getConf(), INFER_SCHEMA);
+        final boolean inferSchema =
+                TitanHadoopConfiguration.of(compiler.getConf()).get(INFER_SCHEMA);
 
         if (inferSchema) {
             compiler.addMapReduce(SchemaInferencerMapReduce.Map.class,

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanCassandraRecordReader.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.hadoop.formats.titan.cassandra;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
 import com.thinkaurelius.titan.hadoop.FaunusVertexQueryFilter;
-import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
-import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 
 import org.apache.cassandra.hadoop.ColumnFamilyRecordReader;
 import org.apache.hadoop.conf.Configuration;
@@ -34,7 +34,7 @@ public TitanCassandraRecordReader(final TitanCassandraHadoopGraph graph, final F
     @Override
     public void initialize(final InputSplit inputSplit, final TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException {
         this.reader.initialize(inputSplit, taskAttemptContext);
-        this.configuration = HadoopCompatLoader.getDefaultCompat().getContextConfiguration(taskAttemptContext);
+        this.configuration = DEFAULT_COMPAT.getContextConfiguration(taskAttemptContext);
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -22,6 +22,7 @@
 import com.thinkaurelius.titan.graphdb.types.system.BaseLabel;
 import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
 import com.thinkaurelius.titan.hadoop.config.ConfigurationUtil;
+import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 import com.thinkaurelius.titan.hadoop.formats.titan.input.SystemTypeInspector;
 import com.thinkaurelius.titan.hadoop.formats.titan.input.TitanHadoopSetupCommon;
@@ -37,7 +38,7 @@ public class TitanHadoopSetupImpl extends TitanHadoopSetupCommon {
     private final StandardTitanTx tx;
 
     public TitanHadoopSetupImpl(final Configuration config) {
-        BasicConfiguration bc = ConfigurationUtil.extractInputConfiguration(config);
+        BasicConfiguration bc = TitanHadoopConfiguration.of(config).extractInputGraphConfiguration();
         graph = (StandardTitanGraph)TitanFactory.open(bc);
 
         tx = (StandardTitanTx)graph.buildTransaction().readOnly().setVertexCacheSize(200).start();

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/filter/CyclicPathFilterMap.java
Patch:
@@ -1,10 +1,11 @@
 package com.thinkaurelius.titan.hadoop.mapreduce.filter;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
 import com.thinkaurelius.titan.hadoop.StandardFaunusEdge;
 import com.thinkaurelius.titan.hadoop.FaunusPathElement;
 import com.thinkaurelius.titan.hadoop.Tokens;
-import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
@@ -83,8 +84,7 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
                 }
             }
 
-            HadoopCompatLoader.getDefaultCompat().incrementContextCounter(context, Counters.PATHS_FILTERED, pathsFiltered);
-            //context.getCounter(Counters.PATHS_FILTERED).increment(pathsFiltered);
+            DEFAULT_COMPAT.incrementContextCounter(context, Counters.PATHS_FILTERED, pathsFiltered);
             context.write(NullWritable.get(), value);
         }
     }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VertexMap.java
Patch:
@@ -1,8 +1,9 @@
 package com.thinkaurelius.titan.hadoop.mapreduce.transform;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
 import com.thinkaurelius.titan.hadoop.Tokens;
-import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 
 import org.apache.hadoop.conf.Configuration;
@@ -48,8 +49,7 @@ public void setup(final Mapper.Context context) throws IOException, InterruptedE
         public void map(final NullWritable key, final FaunusVertex value, final Mapper<NullWritable, FaunusVertex, NullWritable, FaunusVertex>.Context context) throws IOException, InterruptedException {
             if (this.ids.contains(value.getLongId())) {
                 value.startPath();
-                HadoopCompatLoader.getDefaultCompat().incrementContextCounter(context, Counters.VERTICES_PROCESSED, 1L);
-//                context.getCounter(Counters.VERTICES_PROCESSED).increment(1l);
+                DEFAULT_COMPAT.incrementContextCounter(context, Counters.VERTICES_PROCESSED, 1L);
             } else {
                 value.clearPaths();
             }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VerticesVerticesMapReduce.java
Patch:
@@ -1,10 +1,11 @@
 package com.thinkaurelius.titan.hadoop.mapreduce.transform;
 
+import static com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader.DEFAULT_COMPAT;
+
 import com.thinkaurelius.titan.hadoop.FaunusVertex;
 import com.thinkaurelius.titan.hadoop.StandardFaunusEdge;
 import com.thinkaurelius.titan.hadoop.Holder;
 import com.thinkaurelius.titan.hadoop.Tokens;
-import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
@@ -78,8 +79,7 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
                     }
                 }
                 value.clearPaths();
-                HadoopCompatLoader.getDefaultCompat().incrementContextCounter(context, Counters.EDGES_TRAVERSED, edgesTraversed);
-//                context.getCounter(Counters.EDGES_TRAVERSED).increment(edgesTraversed);
+                DEFAULT_COMPAT.incrementContextCounter(context, Counters.EDGES_TRAVERSED, edgesTraversed);
             }
 
             this.longWritable.set(value.getLongId());

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/tinkerpop/gremlin/ResultHookClosure.java
Patch:
@@ -38,7 +38,7 @@ public Object call(final Object[] args) {
                 final HadoopPipeline pipeline = (HadoopPipeline) result;
                 pipeline.submit();
                 final FileSystem hdfs = FileSystem.get(pipeline.getGraph().getConf());
-                final Path output = HDFSTools.getOutputsFinalJob(hdfs, pipeline.getGraph().getTemporarySeqFileLocation().toString());
+                final Path output = HDFSTools.getOutputsFinalJob(hdfs, pipeline.getGraph().getJobDir().toString());
                 itty = new TextFileLineIterator(hdfs, hdfs.globStatus(new Path(output.toString() + "/" + Tokens.SIDEEFFECT + "*")), LINES);
             } catch (Exception e) {
                 throw new RuntimeException(e.getMessage(), e);

File: titan-core/src/main/java/com/thinkaurelius/titan/example/GraphOfTheGodsFactory.java
Patch:
@@ -43,16 +43,16 @@ public static void load(final TitanGraph graph) {
         //Create Schema
         TitanManagement mgmt = graph.getManagementSystem();
         final PropertyKey name = mgmt.makePropertyKey("name").dataType(String.class).make();
-        TitanGraphIndex namei = mgmt.buildIndex("name",Vertex.class).indexKey(name).unique().buildCompositeIndex();
+        TitanGraphIndex namei = mgmt.buildIndex("name",Vertex.class).addKey(name).unique().buildCompositeIndex();
         mgmt.setConsistency(namei, ConsistencyModifier.LOCK);
         final PropertyKey age = mgmt.makePropertyKey("age").dataType(Integer.class).make();
-        mgmt.buildIndex("vertices",Vertex.class).indexKey(age).buildMixedIndex(INDEX_NAME);
+        mgmt.buildIndex("vertices",Vertex.class).addKey(age).buildMixedIndex(INDEX_NAME);
 
         final PropertyKey time = mgmt.makePropertyKey("time").dataType(Integer.class).make();
         final PropertyKey reason = mgmt.makePropertyKey("reason").dataType(String.class).make();
         final PropertyKey place = mgmt.makePropertyKey("place").dataType(Geoshape.class).make();
         TitanGraphIndex eindex = mgmt.buildIndex("edges",Edge.class)
-                .indexKey(reason).indexKey(place).buildMixedIndex(INDEX_NAME);
+                .addKey(reason).addKey(place).buildMixedIndex(INDEX_NAME);
 
         mgmt.makeEdgeLabel("father").multiplicity(Multiplicity.MANY2ONE).make();
         mgmt.makeEdgeLabel("mother").multiplicity(Multiplicity.MANY2ONE).make();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -128,7 +128,7 @@ public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
         if (globalConfig.has(REGISTRATION_TIME,uniqueInstanceId)) {
             throw new TitanException(String.format("A Titan graph with the same instance id [%s] is already open. Might required forced shutdown.",uniqueInstanceId));
         }
-        globalConfig.set(REGISTRATION_TIME, config.getTimestampProvider().getTime(), uniqueInstanceId);
+        globalConfig.set(REGISTRATION_TIME, times.getTime(), uniqueInstanceId);
 
         Log mgmtLog = backend.getSystemMgmtLog();
         mgmtLogger = new ManagementLogger(this,mgmtLog,schemaCache,this.times);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -190,7 +190,7 @@ public void testLockException() {
 
     public void testBatchLoadingLocking(boolean batchloading) {
         PropertyKey uid = makeKey("uid",Long.class);
-        TitanGraphIndex uidIndex = mgmt.buildIndex("uid",Vertex.class).unique().indexKey(uid).buildCompositeIndex();
+        TitanGraphIndex uidIndex = mgmt.buildIndex("uid",Vertex.class).unique().addKey(uid).buildCompositeIndex();
         mgmt.setConsistency(uid, ConsistencyModifier.LOCK);
         mgmt.setConsistency(uidIndex,ConsistencyModifier.LOCK);
         EdgeLabel knows = mgmt.makeEdgeLabel("knows").multiplicity(Multiplicity.ONE2ONE).make();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -228,13 +228,13 @@ private Log openLog(String logManagerName, String logName) {
 
     public PropertyKey makeVertexIndexedKey(String name, Class datatype) {
         PropertyKey key = mgmt.makePropertyKey(name).dataType(datatype).cardinality(Cardinality.SINGLE).make();
-        mgmt.buildIndex(name,Vertex.class).indexKey(key).buildCompositeIndex();
+        mgmt.buildIndex(name,Vertex.class).addKey(key).buildCompositeIndex();
         return key;
     }
 
     public PropertyKey makeVertexIndexedUniqueKey(String name, Class datatype) {
         PropertyKey key = mgmt.makePropertyKey(name).dataType(datatype).cardinality(Cardinality.SINGLE).make();
-        mgmt.buildIndex(name,Vertex.class).indexKey(key).unique().buildCompositeIndex();
+        mgmt.buildIndex(name,Vertex.class).addKey(key).unique().buildCompositeIndex();
         return key;
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanOperationCountingTest.java
Patch:
@@ -323,7 +323,7 @@ public void checkFastPropertyFalse() {
 
     public void checkFastPropertyAndLocking(boolean fastProperty) {
         PropertyKey uid = makeKey("uid",String.class);
-        TitanGraphIndex index = mgmt.buildIndex("uid",Vertex.class).unique().indexKey(uid).buildCompositeIndex();
+        TitanGraphIndex index = mgmt.buildIndex("uid",Vertex.class).unique().addKey(uid).buildCompositeIndex();
         mgmt.setConsistency(index, ConsistencyModifier.LOCK);
         finishSchema();
 

File: titan-test/src/main/java/com/thinkaurelius/titan/testutil/gen/Schema.java
Patch:
@@ -239,12 +239,12 @@ public void makeTypes(TitanGraph g) {
         for (int i = 0; i < vertexPropKeys; i++) {
             PropertyKey key = mgmt.makePropertyKey(getVertexPropertyName(i)).dataType(Integer.class).cardinality(Cardinality.SINGLE).make();
             mgmt.setConsistency(key, ConsistencyModifier.LOCK);
-            mgmt.buildIndex("v-"+getVertexPropertyName(i),Vertex.class).indexKey(key).buildCompositeIndex();
+            mgmt.buildIndex("v-"+getVertexPropertyName(i),Vertex.class).addKey(key).buildCompositeIndex();
         }
         for (int i = 0; i < edgePropKeys; i++) {
             PropertyKey key = mgmt.makePropertyKey(getEdgePropertyName(i)).dataType(Integer.class).cardinality(Cardinality.SINGLE).make();
             mgmt.setConsistency(key, ConsistencyModifier.LOCK);
-            mgmt.buildIndex("e-"+getEdgePropertyName(i),Edge.class).indexKey(key).buildCompositeIndex();
+            mgmt.buildIndex("e-"+getEdgePropertyName(i),Edge.class).addKey(key).buildCompositeIndex();
         }
         for (int i = 0; i < edgeLabels; i++) {
             String labelName = getEdgeLabelName(i);
@@ -254,7 +254,7 @@ public void makeTypes(TitanGraph g) {
         }
 
         PropertyKey uid = mgmt.makePropertyKey(UID_PROP).dataType(Long.class).cardinality(Cardinality.SINGLE).make();
-        mgmt.buildIndex("v-uid",Vertex.class).unique().indexKey(uid).buildCompositeIndex();
+        mgmt.buildIndex("v-uid",Vertex.class).unique().addKey(uid).buildCompositeIndex();
         mgmt.setConsistency(uid, ConsistencyModifier.LOCK);
         mgmt.commit();
         log.debug("Committed types");

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/TitanIndexRepairMapper.java
Patch:
@@ -70,8 +70,6 @@ public class TitanIndexRepairMapper extends Mapper<NullWritable, FaunusVertex, N
     private TitanIndex index;
     private RelationType indexRelationType;
 
-    private Map<String, IndexMutation> reindexDocs;
-
     public enum Counters {
         SUCCESSFUL_TRANSACTIONS,
         FAILED_TRANSACTIONS,

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanOperationCountingTest.java
Patch:
@@ -166,7 +166,7 @@ public void testReadOperations(boolean cache) {
         verifyStoreMetrics(EDGESTORE_NAME);
         verifyStoreMetrics(INDEXSTORE_NAME, ImmutableMap.of(M_GET_SLICE, 1l, M_ACQUIRE_LOCK, 1l));
 
-        for (int i = 1; i <= 10; i++) {
+        for (int i = 1; i <= 20; i++) {
             metricsPrefix = "op"+i+cache;
             tx = graph.buildTransaction().setGroupName(metricsPrefix).start();
             v = (TitanVertex)Iterables.getOnlyElement(tx.query().has("uid",1).vertices());
@@ -179,7 +179,7 @@ public void testReadOperations(boolean cache) {
             if (!cache || i==0) {
                 verifyStoreMetrics(EDGESTORE_NAME, ImmutableMap.of(M_GET_SLICE, 4l));
                 verifyStoreMetrics(INDEXSTORE_NAME, ImmutableMap.of(M_GET_SLICE, 1l));
-            } else if (cache && i>5) { //Needs a couple of iterations for cache to be cleaned
+            } else if (cache && i>10) { //Needs a couple of iterations for cache to be cleaned
                 verifyStoreMetrics(EDGESTORE_NAME);
                 verifyStoreMetrics(INDEXSTORE_NAME);
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -513,6 +513,7 @@ public void clearStorage() throws BackendException {
         idAuthority.close();
         systemConfig.close();
         storeManager.clearStorage();
+        storeManager.close();
         //Indexes
         for (IndexProvider index : indexes.values()) index.clearStorage();
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/ConfigOption.java
Patch:
@@ -2,8 +2,10 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 
 import javax.annotation.Nullable;
+
 import java.lang.reflect.Array;
 import java.util.Collection;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -715,7 +715,7 @@ public boolean apply(@Nullable Integer integer) {
     public static final ConfigOption<ConflictAvoidanceMode> IDAUTHORITY_CONFLICT_AVOIDANCE = new ConfigOption<ConflictAvoidanceMode>(IDAUTHORITY_NS,"conflict-avoidance-mode",
             "This setting helps separate Titan instances sharing a single graph storage backend avoid contention when reserving ID blocks, " +
             "increasing overall throughput.",
-            ConfigOption.Type.GLOBAL_OFFLINE, ConflictAvoidanceMode.NONE);
+            ConfigOption.Type.GLOBAL_OFFLINE, ConflictAvoidanceMode.class, ConflictAvoidanceMode.NONE);
 
     /**
      * When Titan allocates IDs with {@link #IDAUTHORITY_RANDOMIZE_UNIQUEID}

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TransactionalTitanGraphTestSuite.java
Patch:
@@ -30,5 +30,4 @@ public void testCompetingThreads() {
         graph.shutdown();
         super.testCompetingThreads();
     }
-
 }

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthorityTest.java
Patch:
@@ -112,7 +112,9 @@ public IDAuthorityTest(WriteConfiguration baseConfig) {
 
     @Before
     public void setUp() throws Exception {
-        openStorageManager().clearStorage();
+        StoreManager m = openStorageManager();
+        m.clearStorage();
+        m.close();
         open();
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -43,7 +43,9 @@ public abstract class KeyColumnValueStoreTest extends AbstractKCVSTest {
 
     @Before
     public void setUp() throws Exception {
-        openStorageManager().clearStorage();
+        StoreManager m = openStorageManager();
+        m.clearStorage();
+        m.close();
         open();
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/MultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -48,7 +48,9 @@ public abstract class MultiWriteKeyColumnValueStoreTest extends AbstractKCVSTest
 
     @Before
     public void setUp() throws Exception {
-        openStorageManager().clearStorage();
+        StoreManager m = openStorageManager();
+        m.clearStorage();
+        m.close();
         open();
     }
 

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreTest.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -24,6 +25,7 @@ public KeyColumnValueStoreManager openStorageManager() throws BackendException {
                     ".hbase.zookeeper.quorum","localhost");
         config.set(GraphDatabaseConfiguration.STORAGE_NS.getName()+"."+HBaseStoreManager.HBASE_CONFIGURATION_NAMESPACE+
                 "hbase.zookeeper.property.clientPort",2181);
+        config.set(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER.getName(), HBaseStoreManager.PREFERRED_TIMESTAMPS);
         return new HBaseStoreManager(new BasicConfiguration(GraphDatabaseConfiguration.ROOT_NS,config, BasicConfiguration.Restriction.NONE));
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -355,7 +355,7 @@ private static LogManager getLogManager(Configuration config, String logName, Ke
             return new KCVSLogManager(sm,logConfig);
         } else {
             Preconditions.checkArgument(config!=null);
-            LogManager lm = getImplementationClass(config,config.get(LOG_BACKEND),REGISTERED_LOG_MANAGERS);
+            LogManager lm = getImplementationClass(logConfig,logConfig.get(LOG_BACKEND),REGISTERED_LOG_MANAGERS);
             Preconditions.checkNotNull(lm);
             return lm;
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/ConfigElement.java
Patch:
@@ -136,7 +136,7 @@ public static String getPath(ConfigElement element, String... umbrellaElements)
         while (!element.isRoot() && !element.getNamespace().isRoot()) {
             ConfigNamespace parent = element.getNamespace();
             if (parent.isUmbrella()) {
-                Preconditions.checkArgument(umbrellaPos>=0,"Missing umbrella element path");
+                Preconditions.checkArgument(umbrellaPos>=0,"Missing umbrella element path for element: {}",element);
                 String umbrellaName = umbrellaElements[umbrellaPos];
                 Preconditions.checkArgument(!StringUtils.containsAny(umbrellaName,ILLEGAL_CHARS),"Invalid umbrella name provided: %s. Contains illegal chars",umbrellaName);
                 path = umbrellaName + SEPARATOR + path;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/StaticArrayEntry.java
Patch:
@@ -298,7 +298,7 @@ public int compareTo(StaticBuffer other) {
     public String toString() {
         String s = super.toString();
         int pos = getValuePosition()*4;
-        return s.substring(0,pos-1) + "->" + s.substring(pos);
+        return s.substring(0,pos-1) + "->" + (getValuePosition()<length()?s.substring(pos):"");
     }
 
     //########## CACHE ############

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -209,7 +209,7 @@ public GraphDatabaseConfiguration getConfiguration() {
 
     @Override
     public TitanManagement getManagementSystem() {
-        return new ManagementSystem(this,backend.getGlobalSystemConfig(),backend.getSystemMgmtLog(), mgmtLogger);
+        return new ManagementSystem(this,backend.getGlobalSystemConfig(),backend.getSystemMgmtLog(), mgmtLogger, schemaCache);
     }
 
     public Set<? extends TitanTransaction> getOpenTransactions() {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.*;
 import com.thinkaurelius.titan.core.schema.*;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardTimestamp;
 import com.thinkaurelius.titan.graphdb.database.log.LogTxStatus;
 import com.thinkaurelius.titan.graphdb.database.management.MgmtLogType;
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.*;
@@ -36,7 +37,7 @@ public class StandardAttributeHandling implements AttributeHandling {
                     Parameter.class, Parameter[].class, ParameterType.class,
                     Order.class, Multiplicity.class, Cardinality.class, Direction.class, ElementCategory.class,
                     ConsistencyModifier.class, SchemaStatus.class, LogTxStatus.class, MgmtLogType.class,
-                    StandardDuration.class, StandardTimepoint.class, StandardTransactionId.class
+                    StandardDuration.class, StandardTimepoint.class, StandardTransactionId.class, StandardTimestamp.class
             );
 
     private final Map<Class,AttributeHandler> handlers;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/StandardLogProcessorFramework.java
Patch:
@@ -97,7 +97,6 @@ public synchronized void shutdown() throws TitanException {
         } catch (BackendException e) {
             throw new TitanException(e);
         }
-        graph.shutdown();
     }
 
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -84,8 +84,8 @@ public void tearDown() throws Exception {
     }
 
     public void finishSchema() {
-        assert mgmt!=null;
-        mgmt.commit();
+        if (mgmt!=null && mgmt.isOpen())
+            mgmt.commit();
         mgmt=graph.getManagementSystem();
         newTx();
         graph.commit();

File: titan-solr/src/test/java/com/thinkaurelius/titan/diskstorage/solr/transform/GeoToWktConverterTest.java
Patch:
@@ -1,11 +1,10 @@
 package com.thinkaurelius.titan.diskstorage.solr.transform;
 
 import com.thinkaurelius.titan.core.attribute.Geoshape;
-import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 
 /**
  * @author Jared Holmberg (jholmberg@bericotechnologies.com)
@@ -18,7 +17,7 @@ public class GeoToWktConverterTest {
      * format understood by Solr.
      */
     @Test
-    public void testConvertGeoshapePointToWktString() throws PermanentStorageException {
+    public void testConvertGeoshapePointToWktString() throws BackendException {
         Geoshape p1 = Geoshape.point(35.4, 48.9); //no spaces, no negative values
         Geoshape p2 = Geoshape.point(-35.4,48.9); //negative longitude value
         Geoshape p3 = Geoshape.point(35.4, -48.9); //negative latitude value

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/StandardRelation.java
Patch:
@@ -1,10 +1,12 @@
 package com.thinkaurelius.titan.graphdb.relations;
 
+import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
+
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public interface StandardRelation {
+public interface StandardRelation extends InternalRelation {
 
     public long getPreviousID();
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanGraphOutputMapReduce.java
Patch:
@@ -155,7 +155,7 @@ public void cleanup(final Mapper<NullWritable, FaunusVertex, LongWritable, Holde
 
         public TitanVertex getCreateOrDeleteVertex(final FaunusVertex faunusVertex, final Mapper<NullWritable, FaunusVertex, LongWritable, Holder<FaunusVertex>>.Context context) throws InterruptedException {
             if (this.trackState && faunusVertex.isRemoved()) {
-                final Vertex titanVertex = graph.getVertex(faunusVertex.getId());
+                final Vertex titanVertex = graph.getVertex(faunusVertex.getLongId());
                 if (null == titanVertex)
                     HadoopCompatLoader.getDefaultCompat().incrementContextCounter(context, Counters.NULL_VERTICES_IGNORED, 1L);
                 else {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VerticesEdgesMapReduce.java
Patch:
@@ -151,9 +151,10 @@ public void reduce(final LongWritable key, final Iterable<Holder> values, final
             }
 
             for (final Edge e : vertex.getEdges(this.direction, this.labels)) {
+                StandardFaunusEdge fe = (StandardFaunusEdge)e;
                 for (final StandardFaunusEdge edge : edges) {
-                    if (e.getId().equals(edge.getId())) {
-                        ((StandardFaunusEdge) e).getPaths(edge, false);
+                    if (fe.getLongId()==edge.getLongId()) {
+                        fe.getPaths(edge, false);
                         break;
                     }
                 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/util/ElementPicker.java
Patch:
@@ -24,7 +24,7 @@ public static String getPropertyAsString(final FaunusElement element, final Stri
             for (final TitanProperty property : element.query().properties()) {
                 properties.put(property.getType().getName(), property.getValue());
             }
-            properties.put(Tokens._ID, element.getId());
+            properties.put(Tokens._ID, element.getLongId());
             if (element instanceof StandardFaunusEdge)
                 properties.put(Tokens._LABEL, ((StandardFaunusEdge) element).getLabel());
 
@@ -56,7 +56,7 @@ public static Object getProperty(final FaunusElement element, final String key)
             for (final TitanProperty property : element.query().properties()) {
                 properties.put(property.getType().getName(), property.getValue());
             }
-            properties.put(Tokens._ID, element.getId());
+            properties.put(Tokens._ID, element.getLongId());
             return properties;
         } else {
             if (element instanceof FaunusVertex) {

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/EdgesMapTest.java
Patch:
@@ -64,7 +64,7 @@ public void testEdgesWithPaths() throws Exception {
             for (Edge edge : vertex.getEdges(Direction.BOTH)) {
                 assertEquals(((StandardFaunusEdge) edge).pathCount(), 1);
                 assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).size(), 1);
-                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(0).getId(), edge.getId());
+                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(0).getId(), ((StandardFaunusEdge) edge).getLongId());
             }
         }
 

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VerticesEdgesMapReduceTest.java
Patch:
@@ -53,15 +53,15 @@ public void testOutCreatedTraversalWithPaths() throws Exception {
                 assertEquals(((StandardFaunusEdge) edge).pathCount(), 1);
                 assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).size(), 2);
                 assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(0).getId(), edge.getVertex(Direction.OUT).getId());
-                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(1).getId(), edge.getId());
+                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(1).getId(), ((StandardFaunusEdge) edge).getLongId());
             }
 
             for (Edge edge : vertex.getEdges(Direction.IN, "created")) {
                 //System.out.println(vertex + " " + edge);
                 assertEquals(((StandardFaunusEdge) edge).pathCount(), 1);
                 assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).size(), 2);
                 assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(0).getId(), edge.getVertex(Direction.OUT).getId());
-                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(1).getId(), edge.getId());
+                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(1).getId(), ((StandardFaunusEdge) edge).getLongId());
             }
         }
 
@@ -92,7 +92,7 @@ public void testOutAllTraversalWithPaths() throws Exception {
                 assertEquals(((StandardFaunusEdge) edge).pathCount(), 1);
                 assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).size(), 2);
                 assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(0).getId(), edge.getVertex(Direction.OUT).getId());
-                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(1).getId(), edge.getId());
+                assertEquals(((StandardFaunusEdge) edge).getPaths().get(0).get(1).getId(), ((StandardFaunusEdge) edge).getLongId());
             }
         }
 

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VerticesMapTest.java
Patch:
@@ -69,7 +69,7 @@ public void testVerticesWithPaths() throws Exception {
         for (FaunusVertex vertex : graph.values()) {
             assertEquals(vertex.pathCount(), 1);
             assertEquals(vertex.getPaths().get(0).size(), 1);
-            assertEquals(vertex.getPaths().get(0).get(0).getId(), vertex.getId());
+            assertEquals(vertex.getPaths().get(0).get(0).getId(), vertex.getLongId());
             for (Edge edge : vertex.getEdges(Direction.BOTH)) {
                 assertEquals(((StandardFaunusEdge) edge).pathCount(), 0);
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/DirectionCondition.java
Patch:
@@ -32,8 +32,8 @@ public boolean evaluate(E element) {
             return direction==((CacheEdge)element).getVertexCentricDirection();
         } else if (element instanceof TitanEdge) {
             return ((TitanEdge)element).getVertex(direction).equals(baseVertex);
-        } else if (element instanceof TitanProperty && direction==Direction.OUT) {
-            return ((TitanProperty)element).getVertex().equals(baseVertex);
+        } else if (element instanceof TitanProperty) {
+            return direction==Direction.OUT;
         }
         return false;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/BaseVertexCentricQueryBuilder.java
Patch:
@@ -184,7 +184,7 @@ public Q type(RelationType type) {
     }
 
     public Q types(String... types) {
-        Preconditions.checkArgument(types!=null);
+        if (types==null) types = NO_TYPES;
         for (String type : types) Preconditions.checkArgument(StringUtils.isNotBlank(type),"Invalid type: %s",type);
         this.types=types;
         return getThis();

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/FaunusSerializer.java
Patch:
@@ -132,7 +132,7 @@ private void writePathElement(final FaunusPathElement element, final Schema sche
     private void readElement(final FaunusElement element, Schema schema, final DataInput in) throws IOException {
         element.id = WritableUtils.readVLong(in);
         if (trackState) element.setLifeCycle(in.readByte());
-        element.outAdjacency = readEdges(element,in,Direction.IN,schema);
+        element.outAdjacency = readEdges(element,in,Direction.OUT,schema);
     }
 
     private void writeElement(final FaunusElement element, final Schema schema, final DataOutput out) throws IOException {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/sideeffect/CommitVerticesMapReduce.java
Patch:
@@ -166,12 +166,12 @@ public void reduce(final LongWritable key, final Iterable<Holder> values, final
                     vertex = (FaunusVertex) holder.get();
                 } else {
                     vertex = (FaunusVertex) holder.get();
-                    vertex.updateLifeCycle(ElementLifeCycle.Event.REMOVED);
                     Iterator<Edge> itty = vertex.getEdges(Direction.BOTH).iterator();
                     while (itty.hasNext()) {
                         itty.next();
                         itty.remove();
                     }
+                    vertex.updateLifeCycle(ElementLifeCycle.Event.REMOVED);
                 }
             }
             if (null != vertex) {

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/FaunusEdgeTest.java
Patch:
@@ -26,7 +26,7 @@ public void testSimpleSerialization() throws IOException {
         ByteArrayOutputStream bytes = new ByteArrayOutputStream();
         DataOutputStream out = new DataOutputStream(bytes);
         edge1.write(out);
-        assertEquals(bytes.size(), 12);
+        assertEquals(13, bytes.size());
         // long id (vlong), path counters (vlong), long vid (vlong), long vid (vlong), String label
         // 1 + 1 + 1 + 1 + 10 byte label = 13
 

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/FaunusElementTest.java
Patch:
@@ -28,13 +28,13 @@ public void testBasicSerialization() throws IOException {
 
         ByteArrayOutputStream bytes1 = new ByteArrayOutputStream();
         vertex1.write(new DataOutputStream(bytes1));
-        assertEquals(bytes1.size(), 7);
+        assertEquals(bytes1.size(), 8);
         // 1 long id + 1 variable int paths + 1 short properties +  2 vinteger edge types (2)
         // ? + 1 + 1 + 2 + 2 + 2 = 11 bytes + 1 byte long id
 
         ByteArrayOutputStream bytes2 = new ByteArrayOutputStream();
         vertex2.write(new DataOutputStream(bytes2));
-        assertEquals(bytes2.size(), 23);
+        assertEquals(bytes2.size(), 24);
         // 1 long id + 1 int paths + 1 short properties + 2 vinteger edge types (2)
         // ? + 1 + 1 + 2 + 2 + 2 = 11 bytes + 9 byte long id
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -154,7 +154,7 @@ public boolean apply(@Nullable String s) {
 
     public static final ConfigOption<Timestamps> TIMESTAMP_PROVIDER = new ConfigOption<Timestamps>(ROOT_NS, "timestamps",
             "The timestamp resolution to use when writing to storage and indices",
-            ConfigOption.Type.FIXED, Timestamps.MICRO);
+            ConfigOption.Type.FIXED, Timestamps.class, Timestamps.MICRO);
 
 
     public static final ConfigOption<Boolean> SYSTEM_LOG_TRANSACTIONS = new ConfigOption<Boolean>(ROOT_NS,"log-tx",

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -509,7 +509,7 @@ public ModificationSummary prepareCommit(final Collection<InternalRelation> adde
                 IndexTransaction itx = mutator.getIndexTransaction(update.getIndex().getBackingIndexName());
                 String indexStore = ((MixedIndexType)update.getIndex()).getStoreName();
                 if (update.isAddition())
-                    itx.add(indexStore,update.getKey(),update.getEntry().field,update.getEntry().value,update.getElement().isNew());
+                    itx.add(indexStore, update.getKey(), update.getEntry(), update.getElement().isNew());
                 else
                     itx.delete(indexStore,update.getKey(),update.getEntry().field,update.getEntry().value,update.getElement().isRemoved());
             }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -830,8 +830,8 @@ public void testVertexTTLWithMixedIndices() throws Exception {
         assertNotNull(v1);
         assertNotNull(v2);
 
+        Thread.sleep(6000); // default ttl recycle interval is 5s
 
-        Thread.sleep(2001);
         clopen();
         time = tx.getPropertyKey("time");
 
@@ -905,7 +905,7 @@ public void testEdgeTTLWithMixedIndices() throws Exception {
         assertTrue(v2.getEdges(Direction.OUT).iterator().hasNext());
 
 
-        Thread.sleep(2001);
+        Thread.sleep(6000);
         clopen();
 
         time = tx.getPropertyKey("time");

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/TitanIndexRepair.java
Patch:
@@ -19,6 +19,7 @@
 import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 import com.thinkaurelius.titan.hadoop.config.ConfigurationUtil;
 import com.thinkaurelius.titan.hadoop.config.TitanHadoopConfiguration;
+import com.thinkaurelius.titan.hadoop.formats.titan.TitanGraphOutputMapReduce;
 import com.thinkaurelius.titan.hadoop.formats.titan.cassandra.TitanCassandraInputFormat;
 
 public class TitanIndexRepair {
@@ -34,7 +35,7 @@ public static void cassandraRepair(String titanPropertiesPath, String indexName,
     }
 
     public static void cassandraRepair(String titanPropertiesPath, String indexName, String indexType, String partitioner) throws Exception {
-        Configuration hadoopConfig = new Configuration();
+        Configuration hadoopConfig = TitanGraphOutputMapReduce.createConfiguration();
 
         hadoopConfig.set(ConfigElement.getPath(TitanHadoopConfiguration.INPUT_FORMAT), TitanCassandraInputFormat.class.getCanonicalName());
         ConfigHelper.setInputPartitioner(hadoopConfig, partitioner);

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/tinkerpop/gremlin/FaunusGremlinScriptEngine.java
Patch:
@@ -22,7 +22,7 @@ public FaunusGremlinScriptEngine() {
         HadoopGremlin.load();
         final CompilerConfiguration conf = new CompilerConfiguration();
         conf.addCompilationCustomizers(FaunusGremlinScriptEngine.getImportCustomizer());
-        this.loader = new GroovyClassLoader(getParentLoader(), conf);
+        this.loader = new GroovyClassLoader(this.getParentLoader(), conf);
         try {
             this.setBindings(Imports.getEvaluateBindings(), ScriptContext.GLOBAL_SCOPE);
         } catch (IOException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -139,12 +139,13 @@ public TitanGraph open() {
     }
 
     /**
-     * Returns a {@link com.thinkaurelius.titan.core.log.LogProcessorFramework} for processing triggers against the provided graph instance.
+     * Returns a {@link com.thinkaurelius.titan.core.log.LogProcessorFramework} for processing transaction log entries
+     * against the provided graph instance.
      *
      * @param graph
      * @return
      */
-    public static LogProcessorFramework openTriggers(TitanGraph graph) {
+    public static LogProcessorFramework openTransactionLog(TitanGraph graph) {
         return new StandardLogProcessorFramework((StandardTitanGraph)graph);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/ExpirationKCVSCache.java
Patch:
@@ -80,15 +80,15 @@ public EntryList getSlice(final KeySliceQuery query, final StoreTransaction txh)
         incActionBy(1, CacheMetricsAction.RETRIEVAL,txh);
         if (isExpired(query)) {
             incActionBy(1, CacheMetricsAction.MISS,txh);
-            return store.getSlice(query, getTx(txh));
+            return store.getSlice(query, unwrapTx(txh));
         }
 
         try {
             return cache.get(query,new Callable<EntryList>() {
                 @Override
                 public EntryList call() throws Exception {
                     incActionBy(1, CacheMetricsAction.MISS,txh);
-                    return store.getSlice(query, getTx(txh));
+                    return store.getSlice(query, unwrapTx(txh));
                 }
             });
         } catch (Exception e) {
@@ -117,7 +117,7 @@ public Map<StaticBuffer,EntryList> getSlice(final List<StaticBuffer> keys, final
         //Request remaining ones from backend
         if (!remainingKeys.isEmpty()) {
             incActionBy(remainingKeys.size(), CacheMetricsAction.MISS,txh);
-            Map<StaticBuffer,EntryList> subresults = store.getSlice(remainingKeys, query, getTx(txh));
+            Map<StaticBuffer,EntryList> subresults = store.getSlice(remainingKeys, query, unwrapTx(txh));
             for (int i=0;i<keys.size();i++) {
                 StaticBuffer key = keys.get(i);
                 EntryList subresult = subresults.get(key);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -52,7 +52,6 @@
 import com.thinkaurelius.titan.graphdb.types.system.BaseRelationType;
 import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
 import com.thinkaurelius.titan.graphdb.util.ExceptionFactory;
-import com.thinkaurelius.titan.graphdb.vertices.StandardVertex;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Features;
 
@@ -642,7 +641,7 @@ public void commit(final Collection<InternalRelation> addedRelations,
                         //3. Log transaction if configured - [FAILURE] is recorded but does not cause exception
                         if (logTxIdentifier!=null) {
                             try {
-                                final Log triggerLog = backend.getTriggerLog(logTxIdentifier);
+                                final Log triggerLog = backend.getUserLog(logTxIdentifier);
                                 Future<Message> env = triggerLog.add(txLogHeader.serializeModifications(serializer, LogTxStatus.USER_LOG, tx, addedRelations, deletedRelations));
                                 if (env.isDone()) {
                                     try {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/StandardLogProcessorFramework.java
Patch:
@@ -177,7 +177,7 @@ public void build() {
                 Preconditions.checkArgument(!processorLogs.containsKey(userLogName),
                         "Processors have already been registered for user log: %s",userLogName);
                 try {
-                    Log log = graph.getBackend().getTriggerLog(userLogName);
+                    Log log = graph.getBackend().getUserLog(userLogName);
                     log.registerReaders(readMarker,Iterables.transform(processors, new Function<ChangeProcessor, MessageReader>() {
                         @Nullable
                         @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/log/StandardTransactionLogProcessor.java
Patch:
@@ -103,7 +103,7 @@ public long[] getStatistics() {
     }
 
     public synchronized void shutdown() throws TitanException {
-        cleaner.close(CLEAN_SLEEP_TIME.getLength(CLEAN_SLEEP_TIME.getNativeUnit()),CLEAN_SLEEP_TIME.getNativeUnit());
+        cleaner.close(CLEAN_SLEEP_TIME.getLength(CLEAN_SLEEP_TIME.getNativeUnit()), CLEAN_SLEEP_TIME.getNativeUnit());
         graph.shutdown();
     }
 
@@ -140,7 +140,7 @@ public boolean apply(@Nullable String s) {
             BackendOperation.execute(new Callable<Boolean>(){
                 @Override
                 public Boolean call() throws Exception {
-                    final Log triggerLog = graph.getBackend().getTriggerLog(logTxIdentifier);
+                    final Log triggerLog = graph.getBackend().getUserLog(logTxIdentifier);
                     Future<Message> env = triggerLog.add(userLogContent);
                     if (env.isDone()) {
                         env.get();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -16,7 +16,6 @@
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingStore;
 import com.thinkaurelius.titan.diskstorage.log.Log;
 import com.thinkaurelius.titan.diskstorage.log.LogManager;
-import com.thinkaurelius.titan.diskstorage.log.ReadMarker;
 import com.thinkaurelius.titan.diskstorage.log.kcvs.KCVSLogManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
@@ -187,7 +186,7 @@ public void closeLogManager(String logManagerName) {
     }
 
     public Log openTriggerLog(String identifier) {
-        return openLog(TRIGGER_LOG, Backend.TRIGGER_LOG_PREFIX +identifier);
+        return openLog(TRIGGER_LOG, Backend.USER_LOG_PREFIX +identifier);
     }
 
     public Log openTxLog() {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -269,10 +269,10 @@ private static PropertyKey[] getKeysOfRecords(RecordEntry[] record) {
     }
 
     private static int getIndexTTL(InternalVertex vertex, PropertyKey... keys) {
-        Integer ttl = ((InternalVertexLabel)vertex.getVertexLabel()).getTTL();
+        int ttl = StandardTitanGraph.getTTL(vertex);
         for (int i=0;i<keys.length;i++) {
             PropertyKey key = keys[i];
-            Integer kttl = ((InternalRelationType)key).getTTL();
+            int kttl = ((InternalRelationType)key).getTTL();
             if (kttl>0 && (kttl<ttl || ttl<=0)) ttl=kttl;
         }
         return ttl;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -832,6 +832,7 @@ public Duration getTTL(final TitanSchemaType type) {
     @Override
     public void setTTL(final TitanSchemaType type,
                        final int ttl, TimeUnit unit) {
+        if (!graph.getBackend().getStoreFeatures().hasCellTTL()) throw new UnsupportedOperationException("The storage engine does not support TTL");
         if (type instanceof VertexLabelVertex) {
             Preconditions.checkArgument(((VertexLabelVertex) type).isStatic(), "must define vertex label as static to allow setting TTL");
         } else {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -545,8 +545,7 @@ public void updateIndex(TitanIndex index, SchemaAction updateAction) {
                 setUpdateTrigger(new UpdateStatusTrigger(graph, schemaVertex, SchemaStatus.REGISTERED, keySubset));
                 break;
             case REINDEX:
-                //TODO: implement using Titan-Hadoop
-                break;
+                throw new UnsupportedOperationException(updateAction + " requires a manual step: run a MapReduce reindex on index name \"" + index.getName() + "\"");
             case ENABLE_INDEX:
                 setStatus(schemaVertex,SchemaStatus.ENABLED,keySubset);
                 updatedTypes.add(schemaVertex);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalVertexLabel.java
Patch:
@@ -9,7 +9,7 @@ public interface InternalVertexLabel extends VertexLabel {
 
     public boolean hasDefaultConfiguration();
 
-    public Integer getTTL();
+    public int getTTL();
 
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeUtil.java
Patch:
@@ -89,7 +89,7 @@ public static ConsistencyModifier getConsistencyModifier(SchemaSource schema) {
         return getTypeModifier(schema, ModifierType.CONSISTENCY, ConsistencyModifier.DEFAULT);
     }
 
-    public static Integer getTTL(final SchemaSource schema) {
-        return getTypeModifier(schema, ModifierType.TTL, 0);
+    public static int getTTL(final SchemaSource schema) {
+        return getTypeModifier(schema, ModifierType.TTL, 0).intValue();
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/VertexLabelVertex.java
Patch:
@@ -34,7 +34,7 @@ public boolean hasDefaultConfiguration() {
     private Integer ttl = null;
 
     @Override
-    public Integer getTTL() {
+    public int getTTL() {
         if (null == ttl) {
             ttl = TypeUtil.getTTL(this);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseVertexLabel.java
Patch:
@@ -36,7 +36,7 @@ public boolean hasDefaultConfiguration() {
     }
 
     @Override
-    public Integer getTTL() {
+    public int getTTL() {
         return 0;
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -2871,7 +2871,6 @@ public void process(TitanTransaction tx, TransactionId txId, ChangeState changes
         recovery.shutdown();
         assertEquals(2, triggerCount.get());
         long[] recoveryStats = ((StandardTransactionLogProcessor)recovery).getStatistics();
-        System.out.println(Arrays.toString(recoveryStats));
         assertEquals(3,recoveryStats[0]);
         assertEquals(0,recoveryStats[1]);
     }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -298,7 +298,7 @@ public synchronized AstyanaxKeyColumnValueStore openDatabase(String name) throws
 
     @Override
     public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> batch, StoreTransaction txh) throws BackendException {
-        MutationBatch m = keyspaceContext.getClient().prepareMutationBatch().withAtomicBatch(true)
+        MutationBatch m = keyspaceContext.getClient().prepareMutationBatch().withAtomicBatch(atomicBatch)
                 .setConsistencyLevel(getTx(txh).getWriteConsistencyLevel().getAstyanax())
                 .withRetryPolicy(retryPolicy.duplicate());
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyBlueprintsTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.berkeleyje.BerkeleyJEStoreManager;
 import com.tinkerpop.blueprints.Graph;
 
@@ -45,7 +45,7 @@ public Graph generateGraph(String uid) {
                     s.close();
                     File dirFile = new File(dir);
                     Assert.assertFalse(dirFile.exists() && dirFile.listFiles().length > 0);
-                } catch (StorageException e) {
+                } catch (BackendException e) {
                     throw new RuntimeException(e);
                 }
             } else if (openGraphs.get(dir).isOpen()) {
@@ -67,7 +67,7 @@ public boolean supportsMultipleGraphs() {
     }
 
     @Override
-    public void cleanUp() throws StorageException {
+    public void cleanUp() throws BackendException {
         synchronized (openGraphs) {
             for (Map.Entry<String, TitanGraph> entry : openGraphs.entrySet()) {
                 String dir = entry.getKey();

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyFixedLengthKCVSTest.java
Patch:
@@ -2,16 +2,16 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.thinkaurelius.titan.BerkeleyStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManagerAdapter;
 import org.junit.Test;
 
 
 public class BerkeleyFixedLengthKCVSTest extends KeyColumnValueStoreTest {
 
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyStorageSetup.getBerkeleyJEConfiguration());
         return new OrderedKeyValueStoreManagerAdapter(sm, ImmutableMap.of(storeName, 8));
     }

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyKeyValueTest.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.berkeleyje;
 
 import com.thinkaurelius.titan.BerkeleyStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.KeyValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManager;
 
 
 public class BerkeleyKeyValueTest extends KeyValueStoreTest {
 
     @Override
-    public OrderedKeyValueStoreManager openStorageManager() throws StorageException {
+    public OrderedKeyValueStoreManager openStorageManager() throws BackendException {
         return new BerkeleyJEStoreManager(BerkeleyStorageSetup.getBerkeleyJEConfiguration());
     }
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyVariableLengthKCVSTest.java
Patch:
@@ -1,17 +1,16 @@
 package com.thinkaurelius.titan.diskstorage.berkeleyje;
 
 import com.thinkaurelius.titan.BerkeleyStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManagerAdapter;
-import org.apache.commons.configuration.Configuration;
 import org.junit.Test;
 
 
 public class BerkeleyVariableLengthKCVSTest extends KeyColumnValueStoreTest {
 
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyStorageSetup.getBerkeleyJEConfiguration());
         return new OrderedKeyValueStoreManagerAdapter(sm);
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxIDAuthorityTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
@@ -19,7 +19,7 @@ public static void startCassandra() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new AstyanaxStoreManager(CassandraStorageSetup.getAstyanaxConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxLogTest.java
Patch:
@@ -1,10 +1,10 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
 import com.thinkaurelius.titan.testcategory.SerialTests;
@@ -18,7 +18,7 @@ public static void startCassandra() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new AstyanaxStoreManager(CassandraStorageSetup.getAstyanaxConfiguration(getClass().getSimpleName()));
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreTest.java
Patch:
@@ -1,11 +1,11 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreTest;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 
@@ -22,7 +22,7 @@ public ModifiableConfiguration getBaseStorageConfiguration() {
     }
 
     @Override
-    public AbstractCassandraStoreManager openStorageManager(Configuration c) throws StorageException {
+    public AbstractCassandraStoreManager openStorageManager(Configuration c) throws BackendException {
         return new AstyanaxStoreManager(c);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedIDAuthorityTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
@@ -13,7 +13,7 @@ public EmbeddedIDAuthorityTest(WriteConfiguration baseConfig) {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new CassandraEmbeddedStoreManager(CassandraStorageSetup.getEmbeddedConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedLockStoreTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
 public class EmbeddedLockStoreTest extends LockKeyColumnValueStoreTest {
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager(int idx) throws BackendException {
         return new CassandraEmbeddedStoreManager(CassandraStorageSetup.getEmbeddedConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedLogTest.java
Patch:
@@ -1,10 +1,10 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
 import com.thinkaurelius.titan.testcategory.SerialTests;
@@ -18,7 +18,7 @@ public static void startCassandra() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new CassandraEmbeddedStoreManager(CassandraStorageSetup.getEmbeddedConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedMultiWriteStoreTest.java
Patch:
@@ -1,16 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
-import org.apache.commons.configuration.Configuration;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
 public class EmbeddedMultiWriteStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new CassandraEmbeddedStoreManager(CassandraStorageSetup.getEmbeddedConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedStoreTest.java
Patch:
@@ -2,14 +2,14 @@
 
 import static org.junit.Assert.assertTrue;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreTest;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
@@ -28,7 +28,7 @@ public ModifiableConfiguration getBaseStorageConfiguration() {
     }
 
     @Override
-    public AbstractCassandraStoreManager openStorageManager(Configuration c) throws StorageException {
+    public AbstractCassandraStoreManager openStorageManager(Configuration c) throws BackendException {
         return new CassandraEmbeddedStoreManager(c);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftDistributedStoreManagerTest.java
Patch:
@@ -1,12 +1,12 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.DistributedStoreManagerTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 
 public class ThriftDistributedStoreManagerTest extends DistributedStoreManagerTest<CassandraThriftStoreManager> {
 
@@ -16,14 +16,14 @@ public static void startCassandra() {
     }
 
     @Before
-    public void setUp() throws StorageException {
+    public void setUp() throws BackendException {
         manager = new CassandraThriftStoreManager(
                 CassandraStorageSetup.getCassandraThriftConfiguration(this.getClass().getSimpleName()));
         store = manager.openDatabase("distributedcf");
     }
 
     @After
-    public void tearDown() throws StorageException {
+    public void tearDown() throws BackendException {
         if (null != manager)
             manager.close();
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftIDAuthorityTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
@@ -19,7 +19,7 @@ public static void startCassandra() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new CassandraThriftStoreManager(CassandraStorageSetup.getCassandraThriftConfiguration(this.getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftLogTest.java
Patch:
@@ -1,10 +1,10 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
 import com.thinkaurelius.titan.testcategory.SerialTests;
@@ -18,7 +18,7 @@ public static void startCassandra() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new CassandraThriftStoreManager(CassandraStorageSetup.getCassandraThriftConfiguration(this.getClass().getSimpleName()));
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftStoreTest.java
Patch:
@@ -1,11 +1,11 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreTest;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 
@@ -22,7 +22,7 @@ public ModifiableConfiguration getBaseStorageConfiguration() {
     }
 
     @Override
-    public AbstractCassandraStoreManager openStorageManager(Configuration c) throws StorageException {
+    public AbstractCassandraStoreManager openStorageManager(Configuration c) throws BackendException {
         return new CassandraThriftStoreManager(c);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphIterativeTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.thrift;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.cassandra.thrift.CassandraThriftStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
@@ -18,7 +18,7 @@ public WriteConfiguration getConfiguration() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new CassandraThriftStoreManager(new BasicConfiguration(GraphDatabaseConfiguration.ROOT_NS,getConfiguration(), BasicConfiguration.Restriction.NONE));
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphSerialSpeedTest.java
Patch:
@@ -1,13 +1,13 @@
 package com.thinkaurelius.titan.graphdb.thrift;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.core.TitanFactory;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.graphdb.TitanGraphSerialSpeedTest;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
@@ -23,7 +23,7 @@ public class ThriftGraphSerialSpeedTest extends TitanGraphSerialSpeedTest {
     private static final Logger log =
             LoggerFactory.getLogger(ThriftGraphSerialSpeedTest.class);
 
-    public ThriftGraphSerialSpeedTest() throws StorageException {
+    public ThriftGraphSerialSpeedTest() throws BackendException {
         super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(ThriftGraphSerialSpeedTest.class.getSimpleName()));
     }
 
@@ -33,7 +33,7 @@ public static void beforeClass() {
     }
 
     @Override
-    protected StandardTitanGraph getGraph() throws StorageException {
+    protected StandardTitanGraph getGraph() throws BackendException {
 
 
         if (null == graph) {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanTransaction.java
Patch:
@@ -318,7 +318,7 @@ public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph
      * The call releases data structures if possible. All element references (e.g. vertex objects) retrieved
      * through this transaction are stale after the transaction closes and should no longer be used.
      *
-     * @throws com.thinkaurelius.titan.diskstorage.StorageException
+     * @throws com.thinkaurelius.titan.diskstorage.BackendException
      *          if an error arises during persistence
      */
     public void commit();
@@ -329,7 +329,7 @@ public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph
      * The call releases data structures if possible. All element references (e.g. vertex objects) retrieved
      * through this transaction are stale after the transaction closes and should no longer be used.
      *
-     * @throws com.thinkaurelius.titan.diskstorage.StorageException
+     * @throws com.thinkaurelius.titan.diskstorage.BackendException
      *          if an error arises when releasing the transaction handle
      */
     public void rollback();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/AbstractStoreTransaction.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.common;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 
@@ -21,11 +21,11 @@ public AbstractStoreTransaction(BaseTransactionConfig config) {
     }
 
     @Override
-    public void commit() throws StorageException {
+    public void commit() throws BackendException {
     }
 
     @Override
-    public void rollback() throws StorageException {
+    public void rollback() throws BackendException {
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/LocalStoreManager.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.common;
 
-import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.util.DirectoryUtil;
 
@@ -20,7 +19,7 @@ public abstract class LocalStoreManager extends AbstractStoreManager {
 
     protected final File directory;
 
-    public LocalStoreManager(Configuration storageConfig) throws StorageException {
+    public LocalStoreManager(Configuration storageConfig) throws BackendException {
         super(storageConfig);
         String storageDir = storageConfig.get(STORAGE_DIRECTORY);
         if (null == storageDir) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/ExpirationKCVSCache.java
Patch:
@@ -76,7 +76,7 @@ public int weigh(KeySliceQuery keySliceQuery, EntryList entries) {
     }
 
     @Override
-    public EntryList getSlice(final KeySliceQuery query, final StoreTransaction txh) throws StorageException {
+    public EntryList getSlice(final KeySliceQuery query, final StoreTransaction txh) throws BackendException {
         incActionBy(1, CacheMetricsAction.RETRIEVAL,txh);
         if (isExpired(query)) {
             incActionBy(1, CacheMetricsAction.MISS,txh);
@@ -99,7 +99,7 @@ public EntryList call() throws Exception {
     }
 
     @Override
-    public Map<StaticBuffer,EntryList> getSlice(final List<StaticBuffer> keys, final SliceQuery query, final StoreTransaction txh) throws StorageException {
+    public Map<StaticBuffer,EntryList> getSlice(final List<StaticBuffer> keys, final SliceQuery query, final StoreTransaction txh) throws BackendException {
         Map<StaticBuffer,EntryList> results = new HashMap<StaticBuffer, EntryList>(keys.size());
         List<StaticBuffer> remainingKeys = new ArrayList<StaticBuffer>(keys.size());
         KeySliceQuery[] ksqs = new KeySliceQuery[keys.size()];
@@ -145,7 +145,7 @@ public void invalidate(StaticBuffer key, List<CachableStaticBuffer> entries) {
     }
 
     @Override
-    public void close() throws StorageException {
+    public void close() throws BackendException {
         cleanupThread.stopThread();
         super.close();
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/NoKCVSCache.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue.cache;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.EntryList;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeySliceQuery;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
@@ -30,12 +30,12 @@ protected void invalidate(StaticBuffer key, List<CachableStaticBuffer> entries)
     }
 
     @Override
-    public EntryList getSlice(KeySliceQuery query, StoreTransaction txh) throws StorageException {
+    public EntryList getSlice(KeySliceQuery query, StoreTransaction txh) throws BackendException {
         return store.getSlice(query,getTx(txh));
     }
 
     @Override
-    public Map<StaticBuffer, EntryList> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
+    public Map<StaticBuffer, EntryList> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws BackendException {
         return store.getSlice(keys,query,getTx(txh));
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/AbstractLocker.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
+import com.thinkaurelius.titan.diskstorage.TemporaryBackendException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -13,7 +14,6 @@
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
-import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ConsistentKeyLockStatus;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ConsistentKeyLocker;
@@ -301,7 +301,7 @@ public void writeLock(KeyColumn lockID, StoreTransaction tx) throws TemporaryLoc
                 lockLocally(lockID, stat.getExpirationTimestamp(), tx); // update local lock expiration time
                 lockState.take(tx, lockID, stat);
                 ok = true;
-            } catch (TemporaryStorageException tse) {
+            } catch (TemporaryBackendException tse) {
                 throw new TemporaryLockingException(tse);
             } catch (AssertionError ae) {
                 // Concession to ease testing with mocks & behavior verification
@@ -349,7 +349,7 @@ public void checkLocks(StoreTransaction tx) throws TemporaryLockingException, Pe
             ok = true;
         } catch (InterruptedException e) {
             throw new TemporaryLockingException(e);
-        } catch (TemporaryStorageException tse) {
+        } catch (TemporaryBackendException tse) {
             throw new TemporaryLockingException(tse);
         } catch (AssertionError ae) {
             throw ae; // Concession to ease testing with mocks & behavior verification

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/PermanentLockingException.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
+import com.thinkaurelius.titan.diskstorage.PermanentBackendException;
 
 /**
  * This exception signifies a failure to lock based on durable state. For
@@ -12,7 +12,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class PermanentLockingException extends PermanentStorageException {
+public class PermanentLockingException extends PermanentBackendException {
 
     private static final long serialVersionUID = 482890657293484420L;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/TemporaryLockingException.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;
+import com.thinkaurelius.titan.diskstorage.TemporaryBackendException;
 
 /**
  * This exception signifies a (potentially) temporary exception while attempting
@@ -13,7 +13,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class TemporaryLockingException extends TemporaryStorageException {
+public class TemporaryLockingException extends TemporaryBackendException {
 
     private static final long serialVersionUID = 482890657293484420L;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/StandardLockCleanerRunnable.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.util.List;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.google.common.collect.ImmutableList;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeySliceQuery;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
@@ -47,12 +47,12 @@ public StandardLockCleanerRunnable(KeyColumnValueStore store, KeyColumn target,
     public void run() {
         try {
             runWithExceptions();
-        } catch (StorageException e) {
+        } catch (BackendException e) {
             log.warn("Expired lock cleaner failed", e);
         }
     }
 
-    private void runWithExceptions() throws StorageException {
+    private void runWithExceptions() throws BackendException {
         StaticBuffer lockKey = serializer.toLockKey(target.getKey(), target.getColumn());
         List<Entry> locks = store.getSlice(new KeySliceQuery(lockKey, LOCK_COL_START, LOCK_COL_END), tx); // TODO reduce LOCK_COL_END based on cutoff
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/DefaultTransaction.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.util;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.BaseTransactionConfigurable;
 
@@ -23,11 +23,11 @@ public BaseTransactionConfig getConfiguration() {
     }
 
     @Override
-    public void commit() throws StorageException {
+    public void commit() throws BackendException {
     }
 
     @Override
-    public void rollback() throws StorageException {
+    public void rollback() throws BackendException {
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/StorageCallable.java
Patch:
@@ -2,17 +2,17 @@
 
 import java.util.concurrent.Callable;
 
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 
 /**
  * Like {@link Callable}, except the exception type is narrowed from
- * {@link Exception} to {@link StorageException}.
+ * {@link Exception} to {@link com.thinkaurelius.titan.diskstorage.BackendException}.
  * 
  * @param <T>
  *            call return type
  */
 public interface StorageCallable<T> extends Callable<T> {
 
     @Override
-    public T call() throws StorageException;
+    public T call() throws BackendException;
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -72,7 +72,7 @@ public boolean containsIndex(final String indexName) {
         return mixedIndexes.containsKey(indexName);
     }
 
-    public static void register(final MixedIndexType index, final PropertyKey key, final BackendTransaction tx) throws StorageException {
+    public static void register(final MixedIndexType index, final PropertyKey key, final BackendTransaction tx) throws BackendException {
         tx.getIndexTransaction(index.getBackingIndexName()).register(index.getStoreName(), key2Field(index,key), getKeyInformation(index.getField(key)));
 
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StandardIDPool.java
Patch:
@@ -12,10 +12,10 @@
 import com.google.common.base.Stopwatch;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.thinkaurelius.titan.core.TitanException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.IDBlock;
 import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -173,7 +173,7 @@ private void renewBuffer() {
             log.debug("Retrieved ID block from authority on partition({})-namespace({}) in {}", partition, idNamespace, sw.stop());
             Preconditions.checkArgument(idBlock!=null && idBlock.numIds()>0);
             nextBlock = idBlock;
-        } catch (StorageException e) {
+        } catch (BackendException e) {
             throw new TitanException("Could not acquire new ID block from storage", e);
         } catch (IDPoolExhaustedException e) {
             nextBlock = ID_POOL_EXHAUSTION;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -3,13 +3,12 @@
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.schema.*;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.KCVSConfiguration;
 import com.thinkaurelius.titan.diskstorage.log.Log;
@@ -382,7 +381,7 @@ public void addIndexKey(final TitanGraphIndex index, final PropertyKey key, Para
         indexType.resetCache();
         try {
             IndexSerializer.register((MixedIndexType) indexType,key,transaction.getTxHandle());
-        } catch (StorageException e) {
+        } catch (BackendException e) {
             throw new TitanException("Could not register new index field with index backend",e);
         }
         if (!indexVertex.isNew()) updatedTypes.add(indexVertex);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -10,6 +10,7 @@
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.*;
 import com.thinkaurelius.titan.graphdb.internal.ElementCategory;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
+import com.thinkaurelius.titan.graphdb.log.StandardTransactionId;
 import com.thinkaurelius.titan.graphdb.types.ParameterType;
 import com.thinkaurelius.titan.core.schema.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
@@ -35,7 +36,7 @@ public class StandardAttributeHandling implements AttributeHandling {
                     Parameter.class, Parameter[].class, ParameterType.class,
                     Order.class, Multiplicity.class, Cardinality.class, Direction.class, ElementCategory.class,
                     ConsistencyModifier.class, SchemaStatus.class, LogTxStatus.class, MgmtLogType.class,
-                    StandardDuration.class, StandardTimepoint.class
+                    StandardDuration.class, StandardTimepoint.class, StandardTransactionId.class
             );
 
     private final Map<Class,AttributeHandler> handlers;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -12,11 +12,11 @@
 import com.thinkaurelius.titan.core.attribute.Cmp;
 import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.core.schema.*;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.BackendTransaction;
 import com.thinkaurelius.titan.diskstorage.EntryList;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.blueprints.TitanBlueprintsTransaction;
@@ -1224,7 +1224,7 @@ public synchronized void commit() {
         } catch (Exception e) {
             try {
                 txHandle.rollback();
-            } catch (StorageException e1) {
+            } catch (BackendException e1) {
                 throw new TitanException("Could not rollback after a failed commit", e);
             }
             throw new TitanException("Could not commit transaction due to exception during persistence", e);

File: titan-es/src/test/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndexTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.core.schema.Parameter;
 import com.thinkaurelius.titan.core.attribute.*;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexProvider;
@@ -25,7 +25,7 @@
 public class ElasticSearchIndexTest extends IndexProviderTest {
 
     @Override
-    public IndexProvider openIndex() throws StorageException {
+    public IndexProvider openIndex() throws BackendException {
         return new ElasticSearchIndex(getLocalESTestConfig());
     }
 
@@ -86,7 +86,7 @@ public void testSupport() {
     }
 
     @Test
-    public void testConfiguration() throws StorageException {
+    public void testConfiguration() throws BackendException {
         // Test that local-mode has precedence over hostname
         final String index = "es";
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/blueprints/HBaseBlueprintsTest.java
Patch:
@@ -2,9 +2,8 @@
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
 import com.thinkaurelius.titan.core.TitanFactory;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.hbase.HBaseStoreManager;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.tinkerpop.blueprints.Graph;
 
 import java.io.IOException;
@@ -34,7 +33,7 @@ public Graph generateGraph() {
     }
 
     @Override
-    public void cleanUp() throws StorageException {
+    public void cleanUp() throws BackendException {
         HBaseStoreManager s = new HBaseStoreManager(HBaseStorageSetup.getHBaseConfiguration());
         s.clearStorage();
     }

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseDistributedStoreManagerTest.java
Patch:
@@ -2,13 +2,13 @@
 
 import java.io.IOException;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
 import com.thinkaurelius.titan.diskstorage.DistributedStoreManagerTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 
 public class HBaseDistributedStoreManagerTest extends DistributedStoreManagerTest<HBaseStoreManager> {
     
@@ -18,7 +18,7 @@ public static void startHBase() throws IOException {
     }
     
     @Before
-    public void setUp() throws StorageException {
+    public void setUp() throws BackendException {
         manager = new HBaseStoreManager(HBaseStorageSetup.getHBaseConfiguration());
         store = manager.openDatabase("distributedStoreTest");
     }

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseIDAuthorityTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.hbase;
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
@@ -21,7 +21,7 @@ public static void startHBase() throws IOException {
         HBaseStorageSetup.startHBase();
     }
 
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new HBaseStoreManager(HBaseStorageSetup.getHBaseConfiguration());
     }
 }

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseLockStoreTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.hbase;
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
@@ -15,7 +15,7 @@ public static void startHBase() throws IOException {
         HBaseStorageSetup.startHBase();
     }
 
-    public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager(int idx) throws BackendException {
         return new HBaseStoreManager(HBaseStorageSetup.getHBaseConfiguration());
     }
 }

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseLogTest.java
Patch:
@@ -2,10 +2,10 @@
 
 import java.io.IOException;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
 
@@ -17,7 +17,7 @@ public static void startHBase() throws IOException {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new HBaseStoreManager(HBaseStorageSetup.getHBaseConfiguration());
     }
 

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseMultiWriteStoreTest.java
Patch:
@@ -1,10 +1,9 @@
 package com.thinkaurelius.titan.diskstorage.hbase;
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
 
 import java.io.IOException;
@@ -15,7 +14,7 @@ public static void startHBase() throws IOException {
         HBaseStorageSetup.startHBase();
     }
 
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new HBaseStoreManager(HBaseStorageSetup.getHBaseConfiguration());
     }
 }

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.hbase;
 
 import com.thinkaurelius.titan.HBaseStorageSetup;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
@@ -18,7 +18,7 @@ public static void startHBase() throws IOException {
         HBaseStorageSetup.startHBase();
     }
 
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         WriteConfiguration config = HBaseStorageSetup.getHBaseGraphConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_NS.getName()+"."+HBaseStoreManager.HBASE_CONFIGURATION_NAMESPACE+
                     ".hbase.zookeeper.quorum","localhost");

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneIndexTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.core.schema.Parameter;
 import com.thinkaurelius.titan.core.attribute.*;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexProvider;
@@ -33,7 +33,7 @@ public class LuceneIndexTest extends IndexProviderTest {
     public TestName methodName = new TestName();
 
     @Override
-    public IndexProvider openIndex() throws StorageException {
+    public IndexProvider openIndex() throws BackendException {
         return new LuceneIndex(getLocalLuceneTestConfig());
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TitanBlueprintsTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.blueprints;
 
 import com.google.common.collect.ImmutableSet;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.tinkerpop.blueprints.*;
 import com.tinkerpop.blueprints.impls.GraphTest;
 import com.tinkerpop.blueprints.util.io.gml.GMLReaderTestSuite;
@@ -102,7 +102,7 @@ public void testGMLReaderTestSuite() throws Exception {
      */
     public abstract boolean supportsMultipleGraphs();
 
-    public abstract void cleanUp() throws StorageException;
+    public abstract void cleanUp() throws BackendException;
 
     public abstract void beforeSuite();
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/DistributedStoreManagerTest.java
Patch:
@@ -27,7 +27,7 @@ public void testGetDeployment() {
     
     @Test
     @Category({ OrderedKeyStoreTests.class })
-    public void testGetLocalKeyPartition() throws StorageException {
+    public void testGetLocalKeyPartition() throws BackendException {
         List<KeyRange> local = manager.getLocalKeyPartition();
         assertNotNull(local);
         assertEquals(1, local.size());

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreUtil.java
Patch:
@@ -12,13 +12,13 @@
 
 public class KeyColumnValueStoreUtil {
 
-    public static void delete(KeyColumnValueStore store, StoreTransaction txn, long key, String col) throws StorageException {
+    public static void delete(KeyColumnValueStore store, StoreTransaction txn, long key, String col) throws BackendException {
         StaticBuffer k = longToByteBuffer(key);
         StaticBuffer c = stringToByteBuffer(col);
         store.mutate(k, KeyColumnValueStore.NO_ADDITIONS, Arrays.asList(c), txn);
     }
 
-    public static String get(KeyColumnValueStore store, StoreTransaction txn, long key, String col) throws StorageException {
+    public static String get(KeyColumnValueStore store, StoreTransaction txn, long key, String col) throws BackendException {
         StaticBuffer k = longToByteBuffer(key);
         StaticBuffer c = stringToByteBuffer(col);
         StaticBuffer valBytes = KCVSUtil.get(store, k, c, txn);
@@ -27,7 +27,7 @@ public static String get(KeyColumnValueStore store, StoreTransaction txn, long k
         return byteBufferToString(valBytes);
     }
 
-    public static void insert(KeyColumnValueStore store, StoreTransaction txn, long key, String col, String val) throws StorageException {
+    public static void insert(KeyColumnValueStore store, StoreTransaction txn, long key, String col, String val) throws BackendException {
         StaticBuffer k = longToByteBuffer(key);
         StaticBuffer c = stringToByteBuffer(col);
         StaticBuffer v = stringToByteBuffer(val);

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyValueStoreUtil.java
Patch:
@@ -71,7 +71,7 @@ public static String getString(StaticBuffer b) {
         return serial.readObjectNotNull(b.asReadBuffer(), String.class);
     }
 
-    public static int count(RecordIterator<?> iterator) throws StorageException {
+    public static int count(RecordIterator<?> iterator) throws BackendException {
         int count = 0;
         while (iterator.hasNext()) {
             iterator.next();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeBenchmark.java
Patch:
@@ -7,9 +7,9 @@
 import com.thinkaurelius.titan.core.TitanTransaction;
 import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.diskstorage.Backend;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
@@ -38,7 +38,7 @@ public abstract class TitanGraphIterativeBenchmark extends TitanGraphBaseTest {
     private static final Random random = new Random();
 
 
-    public abstract KeyColumnValueStoreManager openStorageManager() throws StorageException;
+    public abstract KeyColumnValueStoreManager openStorageManager() throws BackendException;
 
     //@Test
     public void testDataSequential() throws Exception {

File: titan-test/src/test/java/com/thinkaurelius/titan/blueprints/InMemoryBlueprintsTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.tinkerpop.blueprints.BaseTest;
 import com.tinkerpop.blueprints.Graph;
 import com.tinkerpop.blueprints.GraphTestSuite;
@@ -25,7 +25,7 @@ public void testGraphTestSuite() throws Exception {
     ///=========================== DEFAULT ===========
 
     @Override
-    public void cleanUp() throws StorageException {
+    public void cleanUp() throws BackendException {
 
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/inmemory/InMemoryIDAuthorityTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.inmemory;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
@@ -31,7 +31,7 @@ public InMemoryIDAuthorityTest(WriteConfiguration baseConfig) {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return sharedManager;
     }
 }

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/inmemory/InMemoryKeyColumnValueStoreTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.inmemory;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
 
@@ -12,7 +12,7 @@
 public class InMemoryKeyColumnValueStoreTest extends KeyColumnValueStoreTest {
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws BackendException {
         return new InMemoryStoreManager();
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/inmemory/InMemoryLockKeyColumnValueStoreTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.inmemory;
 
+import com.thinkaurelius.titan.diskstorage.BackendException;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
 
@@ -12,7 +12,7 @@
 public class InMemoryLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager(int id) throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager(int id) throws BackendException {
         return new InMemoryStoreManager();
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -796,7 +796,7 @@ private void testNestedWrites(String initialValue, String updatedValue) throws S
         // This method touches a single vertex with multiple transactions,
         // leading to deadlock under BDB and cascading test failures. Check for
         // the hasTxIsolation() store feature, which is currently true for BDB
-        // but false for HBase/Cassadra. This is kind of a hack; a more robust
+        // but false for HBase/Cassandra. This is kind of a hack; a more robust
         // approach might implement different methods/assertions depending on
         // whether the store is capable of deadlocking or detecting conflicting
         // writes and aborting a transaction.

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/EdgeCopyMapReduce.java
Patch:
@@ -25,7 +25,7 @@
  */
 public class EdgeCopyMapReduce {
 
-    public static final String TITAN_HADOOP_GRAPH_INPUT_EDGE_COPY_DIRECTION = "titan.hadoop.graph.input.edge-copy.direction";
+    public static final String TITAN_HADOOP_GRAPH_INPUT_EDGE_COPY_DIRECTION = "titan.hadoop.input.edge-copy.direction";
 
     public enum Counters {
         EDGES_COPIED,

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/VertexQueryFilter.java
Patch:
@@ -25,7 +25,7 @@
 
 public class VertexQueryFilter extends DefaultVertexQuery {
 
-    public static final String TITAN_HADOOP_GRAPH_INPUT_VERTEX_QUERY_FILTER = "titan.hadoop.graph.input.vertex-query-filter";
+    public static final String TITAN_HADOOP_GRAPH_INPUT_VERTEX_QUERY_FILTER = "titan.hadoop.input.vertex-query-filter";
 
     private static final GremlinGroovyScriptEngine engine = new GremlinGroovyScriptEngine();
     private static final String V = "v";

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/script/ScriptInputFormat.java
Patch:
@@ -31,7 +31,8 @@
  */
 public class ScriptInputFormat extends FileInputFormat<NullWritable, HadoopVertex> implements Configurable {
 
-    public static final String TITAN_HADOOP_GRAPH_INPUT_SCRIPT_FILE = "titan.hadoop.graph.input.script.file";
+    public static final String TITAN_HADOOP_GRAPH_INPUT_SCRIPT_FILE = "titan.hadoop.input.script.file";
+
     private VertexQueryFilter vertexQuery;
     private Configuration config;
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/script/ScriptOutputFormat.java
Patch:
@@ -14,7 +14,7 @@
  */
 public class ScriptOutputFormat extends HadoopFileOutputFormat {
 
-    public static final String TITAN_HADOOP_GRAPH_OUTPUT_SCRIPT_FILE = "titan.hadoop.graph.output.script.file";
+    public static final String TITAN_HADOOP_GRAPH_OUTPUT_SCRIPT_FILE = "titan.hadoop.output.script.file";
 
     @Override
     public RecordWriter<NullWritable, HadoopVertex> getRecordWriter(final TaskAttemptContext job) throws IOException, InterruptedException {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanGraphOutputMapReduce.java
Patch:
@@ -11,8 +11,8 @@
 import com.thinkaurelius.titan.hadoop.Holder;
 import com.thinkaurelius.titan.hadoop.Tokens;
 import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
+import com.thinkaurelius.titan.hadoop.config.ConfigurationUtil;
 import com.thinkaurelius.titan.hadoop.formats.titan.cassandra.TitanCassandraOutputFormat;
-import com.thinkaurelius.titan.hadoop.formats.titan.util.ConfigurationUtil;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Graph;
@@ -77,7 +77,7 @@ public enum Counters {
     public static Graph generateGraph(final Configuration configuration) {
         final Class<? extends OutputFormat> format = configuration.getClass(HadoopGraph.TITAN_HADOOP_GRAPH_OUTPUT_FORMAT, OutputFormat.class, OutputFormat.class);
         if (TitanOutputFormat.class.isAssignableFrom(format)) {
-            return TitanFactory.open(ConfigurationUtil.extractConfiguration(configuration, TitanOutputFormat.TITAN_HADOOP_GRAPH_OUTPUT_TITAN));
+            return TitanFactory.open(ConfigurationUtil.extractOutputConfiguration(configuration));
         } else {
             throw new RuntimeException("The provide graph output format is not a supported TitanOutputFormat: " + format.getName());
         }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanHadoopGraph.java
Patch:
@@ -97,7 +97,7 @@ else if (relation.direction.equals(Direction.OUT))
     }
 
     public void close() {
-
+        setup.close();
     }
 
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/compat/HadoopCompat.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.hadoop.compat;
 
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.mapreduce.JobContext;
 import org.apache.hadoop.mapreduce.TaskAttemptContext;
 import org.apache.hadoop.mapreduce.TaskAttemptID;
 import org.apache.hadoop.mapreduce.TaskInputOutputContext;
@@ -41,5 +42,7 @@ public interface HadoopCompat {
 
     public Configuration getContextConfiguration(TaskAttemptContext context);
 
+    public Configuration getJobContextConfiguration(JobContext context);
+
     public long getCounter(MapReduceDriver counters, Enum<?> e);
 }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/graphson/GraphSONInputFormat.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.hadoop.formats.graphson;
 
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 
 import org.apache.hadoop.conf.Configurable;
@@ -31,7 +32,7 @@ public RecordReader<NullWritable, HadoopVertex> createRecordReader(final InputSp
 
     @Override
     protected boolean isSplitable(final JobContext context, final Path file) {
-        return null == new CompressionCodecFactory(context.getConfiguration()).getCodec(file);
+        return null == new CompressionCodecFactory(HadoopCompatLoader.getDefaultCompat().getJobContextConfiguration(context)).getCodec(file);
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanCassandraRecordReader.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.hadoop.formats.titan.cassandra;
 
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 
 import org.apache.cassandra.hadoop.ColumnFamilyRecordReader;
@@ -32,7 +33,7 @@ public TitanCassandraRecordReader(final TitanCassandraHadoopGraph graph, final V
     @Override
     public void initialize(final InputSplit inputSplit, final TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException {
         this.reader.initialize(inputSplit, taskAttemptContext);
-        this.configuration = taskAttemptContext.getConfiguration();
+        this.configuration = HadoopCompatLoader.getDefaultCompat().getContextConfiguration(taskAttemptContext);
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanCassandraOutputFormatTest.java
Patch:
@@ -23,7 +23,7 @@ public class TitanCassandraOutputFormatTest extends TitanOutputFormatTest {
 
     private static TitanGraph startUpCassandra() throws Exception {
         ModifiableConfiguration configuration = GraphDatabaseConfiguration.buildConfiguration();
-        configuration.set(STORAGE_BACKEND,"embededcassandra");
+        configuration.set(STORAGE_BACKEND,"embeddedcassandra");
         configuration.set(STORAGE_HOSTS,new String[]{"localhost"});
         configuration.set(STORAGE_CONF_FILE, TitanCassandraOutputFormat.class.getResource("cassandra.yaml").toString());
         configuration.set(DB_CACHE, false);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -318,7 +318,7 @@ public boolean apply(@Nullable String s) {
     public static final ConfigOption<String> STORAGE_BACKEND = new ConfigOption<String>(STORAGE_NS,"backend",
             "Either the package and classname of a StoreManager implementation or one of " +
             "Titan's built-in shorthand names for its standard storage backends.",
-            ConfigOption.Type.LOCAL, "local");
+            ConfigOption.Type.LOCAL, String.class);
 //    public static final String STORAGE_BACKEND_KEY = "backend";
 //    public static final String STORAGE_BACKEND_DEFAULT = "local";
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexEntry.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
+import com.thinkaurelius.titan.diskstorage.MetaAnnotatable;
 import com.thinkaurelius.titan.diskstorage.MetaAnnotated;
 import org.apache.commons.lang.StringUtils;
 
@@ -13,7 +14,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class IndexEntry implements MetaAnnotated {
+public class IndexEntry implements MetaAnnotated, MetaAnnotatable {
 
     public final String field;
     public final Object value;
@@ -31,6 +32,7 @@ public IndexEntry(final String field, final Object value) {
 
     private Map<EntryMetaData,Object> metadata = EntryMetaData.EMPTY_METADATA;
 
+    @Override
     public synchronized Object setMetaData(EntryMetaData key, Object value) {
         if (metadata==EntryMetaData.EMPTY_METADATA) metadata = new EntryMetaData.Map();
         return metadata.put(key,value);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/StaticArrayEntry.java
Patch:
@@ -3,6 +3,7 @@
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
+import com.thinkaurelius.titan.diskstorage.MetaAnnotatable;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.graphdb.relations.RelationCache;
 
@@ -12,7 +13,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public class StaticArrayEntry extends BaseStaticArrayEntry implements Entry {
+public class StaticArrayEntry extends BaseStaticArrayEntry implements Entry, MetaAnnotatable {
 
     public StaticArrayEntry(byte[] array, int offset, int limit, int valuePosition) {
         super(array, offset, limit, valuePosition);
@@ -38,6 +39,7 @@ public StaticArrayEntry(StaticBuffer buffer, int valuePosition) {
 
     private Map<EntryMetaData,Object> metadata = EntryMetaData.EMPTY_METADATA;
 
+    @Override
     public synchronized Object setMetaData(EntryMetaData key, Object value) {
         if (metadata==EntryMetaData.EMPTY_METADATA) metadata = new EntryMetaData.Map();
         return metadata.put(key,value);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalRelationType.java
Patch:
@@ -28,7 +28,7 @@ public interface InternalRelationType extends RelationType, InternalVertex {
 
     public ConsistencyModifier getConsistencyModifier();
 
-    public Integer getTtl();
+    public Integer getTTL();
 
     public boolean isUnidirected(Direction dir);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalVertexLabel.java
Patch:
@@ -9,5 +9,7 @@ public interface InternalVertexLabel extends VertexLabel {
 
     public boolean hasDefaultConfiguration();
 
+    public Integer getTTL();
+
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeUtil.java
Patch:
@@ -82,15 +82,14 @@ private static <T> T getTypeModifier(final SchemaSource schema,
                 return value;
             }
         }
-
         return defaultValue;
     }
 
     public static ConsistencyModifier getConsistencyModifier(SchemaSource schema) {
         return getTypeModifier(schema, ModifierType.CONSISTENCY, ConsistencyModifier.DEFAULT);
     }
 
-    public static Integer getTtl(final SchemaSource schema) {
+    public static Integer getTTL(final SchemaSource schema) {
         return getTypeModifier(schema, ModifierType.TTL, 0);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyRelationType.java
Patch:
@@ -54,7 +54,7 @@ public Iterable<IndexType> getKeyIndexes() {
         return Collections.EMPTY_LIST;
     }
 
-    public Integer getTtl() {
+    public Integer getTTL() {
         return 0;
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -17,9 +17,7 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
 import com.thinkaurelius.titan.graphdb.types.TypeUtil;
-import com.thinkaurelius.titan.graphdb.types.VertexLabelVertex;
 import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
-import com.thinkaurelius.titan.graphdb.vertices.CacheVertex;
 import com.tinkerpop.blueprints.Direction;
 import org.apache.commons.lang.StringUtils;
 import static com.thinkaurelius.titan.graphdb.internal.Token.*;
@@ -113,7 +111,7 @@ public<O> O computeProperty(InternalElement e) {
                 return null;
             }
 
-            int ttl = TypeUtil.getTtl((TitanSchemaVertex) type);
+            int ttl = TypeUtil.getTTL((TitanSchemaVertex) type);
             return (O) new StandardDuration(ttl, TimeUnit.SECONDS);
         } else throw new AssertionError("Implicit key property is undefined: " + this.getName());
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -14,6 +14,8 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalElement;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
+import com.thinkaurelius.titan.graphdb.types.TypeUtil;
+import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
 import com.tinkerpop.blueprints.Direction;
 import org.apache.commons.lang.StringUtils;
 import static com.thinkaurelius.titan.graphdb.internal.Token.*;
@@ -89,7 +91,7 @@ public<O> O computeProperty(InternalElement e) {
                     return (O) new StandardTimestamp(time, unit);
                 } else {
                     assert this==TTL;
-                    Integer ttl = r.getPropertyDirect(this);
+                    Integer ttl = TypeUtil.getTtl((TitanSchemaVertex) r.getType());
                     if (null == ttl) {
                         ttl = 0;
                     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -406,6 +406,7 @@ public boolean prepareCommit(final Collection<InternalRelation> addedRelations,
 
         //3) Collect all index update for vertices
         for (InternalVertex v : mutatedProperties.keySet()) {
+            // TODO: check for vertex label TTL
             indexUpdates.addAll(indexSerializer.getIndexUpdates(v,mutatedProperties.get(v)));
         }
         //4) Acquire index locks (deletions first)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -14,8 +14,6 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalElement;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
-import com.thinkaurelius.titan.graphdb.types.TypeUtil;
-import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
 import com.tinkerpop.blueprints.Direction;
 import org.apache.commons.lang.StringUtils;
 import static com.thinkaurelius.titan.graphdb.internal.Token.*;
@@ -91,7 +89,7 @@ public<O> O computeProperty(InternalElement e) {
                     return (O) new StandardTimestamp(time, unit);
                 } else {
                     assert this==TTL;
-                    Integer ttl = TypeUtil.getTtl((TitanSchemaVertex) r.getType());
+                    Integer ttl = r.getPropertyDirect(this);
                     if (null == ttl) {
                         ttl = 0;
                     }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/ModifierType.java
Patch:
@@ -6,6 +6,7 @@
  * @author Joshua Shinavier (http://fortytwo.net)
  */
 public enum ModifierType {
+    CONSISTENCY(TypeDefinitionCategory.CONSISTENCY_LEVEL),
     TTL(TypeDefinitionCategory.TTL);
 
     private final TypeDefinitionCategory category;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -389,7 +389,7 @@ public boolean prepareCommit(final Collection<InternalRelation> addedRelations,
                 }
             }
             Collection<IndexSerializer.IndexUpdate> updates = indexSerializer.getIndexUpdates(add);
-            Integer ttl = ((InternalRelationType)add.getType()).getTypeModifier(ModifierType.TTL);
+            Integer ttl = ((InternalRelationType)add.getType()).getTtl();
             if (null != ttl && ttl > 0) {
                 for (IndexSerializer.IndexUpdate update : updates) {
                     if (update.isAddition() && update.isCompositeIndex()) {
@@ -430,7 +430,7 @@ public boolean prepareCommit(final Collection<InternalRelation> addedRelations,
                 InternalRelationType baseType = (InternalRelationType) edge.getType();
                 assert baseType.getBaseType()==null;
 
-                Integer ttl = (Integer) baseType.getTypeModifier(ModifierType.TTL);
+                Integer ttl = baseType.getTtl();
 
                 for (InternalRelationType type : baseType.getRelationIndexes()) {
                     if (type.getStatus()== SchemaStatus.DISABLED) continue;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalRelationType.java
Patch:
@@ -28,7 +28,7 @@ public interface InternalRelationType extends RelationType, InternalVertex {
 
     public ConsistencyModifier getConsistencyModifier();
 
-    public<T> T getTypeModifier(ModifierType modifierType);
+    public Integer getTtl();
 
     public boolean isUnidirected(Direction dir);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractProperty.java
Patch:
@@ -19,8 +19,8 @@ public abstract class AbstractProperty extends AbstractTypedRelation implements
 
     public AbstractProperty(long id, PropertyKey type, InternalVertex vertex, Object value) {
         super(id, type);
-        Preconditions.checkNotNull(vertex);
-        Preconditions.checkNotNull(value);
+        Preconditions.checkNotNull(vertex, "null vertex");
+        Preconditions.checkNotNull(value, "null value for property key " + type);
         this.vertex=vertex;
         this.value=value;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/CompositeIndexType.java
Patch:
@@ -20,5 +20,4 @@ public interface CompositeIndexType extends IndexType {
     public Cardinality getCardinality();
 
     public ConsistencyModifier getConsistencyModifier();
-
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyRelationType.java
Patch:
@@ -54,7 +54,7 @@ public Iterable<IndexType> getKeyIndexes() {
         return Collections.EMPTY_LIST;
     }
 
-    public<T> T getTypeModifier(ModifierType modifierType) {
-        return null;
+    public Integer getTtl() {
+        return 0;
     }
 }

File: titan-hadoop-parent/common/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -53,8 +53,8 @@ public TypeInspector getTypeInspector() {
                 Preconditions.checkNotNull(name);
                 TypeDefinitionMap dm = s.getDefinition();
                 Preconditions.checkNotNull(dm);
-                s.getRelated(TypeDefinitionCategory.CONSISTENCY_MODIFIER, Direction.OUT);
-                s.getRelated(TypeDefinitionCategory.CONSISTENCY_MODIFIER, Direction.IN);
+                //s.getRelated(TypeDefinitionCategory.CONSISTENCY_MODIFIER, Direction.OUT);
+                //s.getRelated(TypeDefinitionCategory.CONSISTENCY_MODIFIER, Direction.IN);
             }
         }
         return tx;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -420,6 +420,9 @@ public boolean prepareCommit(final Collection<InternalRelation> addedRelations,
             for (InternalRelation edge : edges) {
                 InternalRelationType baseType = (InternalRelationType) edge.getType();
                 assert baseType.getBaseType()==null;
+
+                Integer ttl = (Integer) baseType.getTypeModifier(ModifierType.TTL);
+
                 for (InternalRelationType type : baseType.getRelationIndexes()) {
                     if (type.getStatus()== SchemaStatus.DISABLED) continue;
                     for (int pos = 0; pos < edge.getArity(); pos++) {
@@ -428,7 +431,6 @@ public boolean prepareCommit(final Collection<InternalRelation> addedRelations,
                         if (edge.getVertex(pos).getID()==vertexid) {
                             StaticArrayEntry entry = edgeSerializer.writeRelation(edge, type, pos, tx);
 
-                            Integer ttl = (Integer) type.getTypeModifier(ModifierType.TTL);
                             if (null != ttl && ttl > 0) {
                                 entry.setMetaData(EntryMetaData.TTL, ttl);
                             }

File: titan-hadoop-parent/titan-hadoop-1/src/main/java/com/thinkaurelius/titan/hadoop/compat/Hadoop1Compiler.java
Patch:
@@ -1,8 +1,9 @@
-package com.thinkaurelius.titan.hadoop.mapreduce;
+package com.thinkaurelius.titan.hadoop.compat;
 
 import com.thinkaurelius.titan.hadoop.HadoopGraph;
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
 import com.thinkaurelius.titan.hadoop.Tokens;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 import com.thinkaurelius.titan.hadoop.formats.FormatTools;
 import com.thinkaurelius.titan.hadoop.formats.JobConfigurationFormat;
 import com.thinkaurelius.titan.hadoop.hdfs.NoSideEffectFilter;
@@ -28,7 +29,6 @@
 import org.apache.hadoop.mapreduce.lib.output.LazyOutputFormat;
 import org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;
 import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
-import org.apache.hadoop.util.Tool;
 import org.apache.log4j.Logger;
 
 import java.io.File;

File: titan-hadoop-parent/titan-hadoop-1/src/main/java/com/thinkaurelius/titan/hadoop/compat/MapSequence.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.hadoop.mapreduce;
+package com.thinkaurelius.titan.hadoop.compat;
 
 import com.thinkaurelius.titan.hadoop.Tokens;
 

File: titan-hadoop-parent/titan-hadoop-1/src/main/java/com/thinkaurelius/titan/hadoop/compat/MemoryMapper.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.hadoop.mapreduce;
+package com.thinkaurelius.titan.hadoop.compat;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.io.Writable;

File: titan-hadoop-parent/titan-hadoop-2/src/main/java/com/thinkaurelius/titan/hadoop/compat/Hadoop2Compiler.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.hadoop.mapreduce;
+package com.thinkaurelius.titan.hadoop.compat;
 
 import com.thinkaurelius.titan.hadoop.HadoopGraph;
 import com.thinkaurelius.titan.hadoop.HadoopVertex;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/HadoopPipeline.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.hadoop;
 
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 import com.thinkaurelius.titan.hadoop.formats.EdgeCopyMapReduce;
 import com.thinkaurelius.titan.hadoop.formats.MapReduceFormat;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompiler;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.IdentityMap;
 import com.thinkaurelius.titan.hadoop.mapreduce.filter.BackFilterMapReduce;
 import com.thinkaurelius.titan.hadoop.mapreduce.filter.CyclicPathFilterMap;
@@ -198,7 +198,7 @@ public int getStep(final String name) {
      */
     public HadoopPipeline(final HadoopGraph graph) {
         this.graph = graph;
-        this.compiler = HadoopCompatLoader.getCompilerFor(graph);
+        this.compiler = HadoopCompatLoader.getCompat().newCompiler(graph);
         this.state = new State();
 
         if (MapReduceFormat.class.isAssignableFrom(this.graph.getGraphInputFormat())) {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/compat/HadoopCompiler.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.hadoop.mapreduce;
+package com.thinkaurelius.titan.hadoop.compat;
 
 import java.io.IOException;
 
@@ -12,6 +12,7 @@
 
 import com.thinkaurelius.titan.hadoop.Tokens;
 
+
 // This interface must stay API compatible with both Hadoop1 and Hadoop2
 public interface HadoopCompiler extends Configurable, Tool {
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/MapReduceFormat.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.hadoop.formats;
 
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompiler;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 
 /**
  * If an Input- or OutputFormat requires some pre-post processing, then a MapReduceFormat can be implemented.

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/edgelist/rdf/RDFInputFormat.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.thinkaurelius.titan.hadoop.HadoopElement;
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 import com.thinkaurelius.titan.hadoop.formats.MapReduceFormat;
 import com.thinkaurelius.titan.hadoop.formats.edgelist.EdgeListInputMapReduce;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompiler;
 
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.io.LongWritable;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/graphson/GraphSONRecordReader.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
 
 import org.apache.hadoop.conf.Configuration;
@@ -31,7 +32,8 @@ public GraphSONRecordReader(VertexQueryFilter vertexQuery) {
     @Override
     public void initialize(final InputSplit genericSplit, final TaskAttemptContext context) throws IOException {
         this.lineRecordReader.initialize(genericSplit, context);
-        this.configuration = context.getConfiguration();
+        this.configuration = HadoopCompatLoader.getDefaultCompat().getContextConfiguration(context);
+        //this.configuration = context.getConfiguration();
     }
 
     @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/SchemaInferencerMapReduce.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.graphdb.blueprints.BlueprintsDefaultSchemaMaker;
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
-import com.thinkaurelius.titan.hadoop.formats.BlueprintsGraphOutputMapReduce;
+import com.thinkaurelius.titan.hadoop.formats.titan.TitanGraphOutputMapReduce;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
@@ -80,7 +80,7 @@ public static class Reduce extends org.apache.hadoop.mapreduce.Reducer<LongWrita
 
         @Override
         public void setup(final Reduce.Context context) throws IOException, InterruptedException {
-            this.graph = (TitanGraph) BlueprintsGraphOutputMapReduce.generateGraph(context.getConfiguration());
+            this.graph = (TitanGraph) TitanGraphOutputMapReduce.generateGraph(context.getConfiguration());
         }
 
         @Override

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanInputFormat.java
Patch:
@@ -17,7 +17,7 @@
  */
 public abstract class TitanInputFormat extends InputFormat<NullWritable, HadoopVertex> implements Configurable {
 
-    public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN = "titan.hadoop.graph.input.titan";
+    public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN = "titan.hadoop.input";
     public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN_STORAGE_HOSTNAME = TITAN_HADOOP_GRAPH_INPUT_TITAN + ".storage.hostname";
     public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN_STORAGE_PORT = TITAN_HADOOP_GRAPH_INPUT_TITAN + ".storage.port";
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanOutputFormat.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
 import com.thinkaurelius.titan.hadoop.Holder;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 import com.thinkaurelius.titan.hadoop.formats.MapReduceFormat;
 import com.thinkaurelius.titan.hadoop.formats.noop.NoOpOutputFormat;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompiler;
 
 import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.NullWritable;
@@ -14,8 +14,8 @@
  */
 public abstract class TitanOutputFormat extends NoOpOutputFormat implements MapReduceFormat {
 
-    public static final String TITAN_HADOOP_GRAPH_OUTPUT_TITAN = "titan.hadoop.graph.output.titan";
-    public static final String TITAN_HADOOP_GRAPH_OUTPUT_TITAN_INFER_SCHEMA = "titan.hadoop.graph.output.titan.infer-schema";
+    public static final String TITAN_HADOOP_GRAPH_OUTPUT_TITAN = "titan.hadoop.output";
+    public static final String TITAN_HADOOP_GRAPH_OUTPUT_TITAN_INFER_SCHEMA = "titan.hadoop.output.infer-schema";
 
     @Override
     public void addMapReduceJobs(final HadoopCompiler compiler) {

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanCassandraInputFormat.java
Patch:
@@ -26,7 +26,7 @@
  */
 public class TitanCassandraInputFormat extends TitanInputFormat {
 
-    public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN_STORAGE_KEYSPACE = "titan.hadoop.graph.input.titan.storage.keyspace";
+    public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN_STORAGE_KEYSPACE = "titan.hadoop.input.storage.keyspace";
 
     private final ColumnFamilyInputFormat columnFamilyInputFormat = new ColumnFamilyInputFormat();
     private TitanCassandraHadoopGraph graph;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/hbase/TitanHBaseInputFormat.java
Patch:
@@ -28,7 +28,7 @@
  */
 public class TitanHBaseInputFormat extends TitanInputFormat {
 
-    public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN_STORAGE_TABLENAME = "titan.hadoop.graph.input.titan.storage.tablename";
+    public static final String TITAN_HADOOP_GRAPH_INPUT_TITAN_STORAGE_TABLENAME = "titan.hadoop.input.storage.tablename";
     static final byte[] EDGE_STORE_FAMILY = Bytes.toBytes(Backend.EDGESTORE_NAME);
 
     private final TableInputFormat tableInputFormat = new TableInputFormat();

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VertexMap.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
 import com.thinkaurelius.titan.hadoop.Tokens;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 
 import org.apache.hadoop.conf.Configuration;
@@ -47,7 +48,8 @@ public void setup(final Mapper.Context context) throws IOException, InterruptedE
         public void map(final NullWritable key, final HadoopVertex value, final Mapper<NullWritable, HadoopVertex, NullWritable, HadoopVertex>.Context context) throws IOException, InterruptedException {
             if (this.ids.contains(value.getIdAsLong())) {
                 value.startPath();
-                context.getCounter(Counters.VERTICES_PROCESSED).increment(1l);
+                HadoopCompatLoader.getDefaultCompat().incrementContextCounter(context, Counters.VERTICES_PROCESSED, 1L);
+//                context.getCounter(Counters.VERTICES_PROCESSED).increment(1l);
             } else {
                 value.clearPaths();
             }

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VerticesEdgesMapReduce.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
 import com.thinkaurelius.titan.hadoop.Holder;
 import com.thinkaurelius.titan.hadoop.Tokens;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
@@ -102,7 +103,8 @@ public void map(final NullWritable key, final HadoopVertex value, final Mapper<N
                 }
 
                 value.clearPaths();
-                context.getCounter(Counters.EDGES_TRAVERSED).increment(edgesTraversed);
+                HadoopCompatLoader.getDefaultCompat().incrementContextCounter(context, Counters.EDGES_TRAVERSED, edgesTraversed);
+//                context.getCounter(Counters.EDGES_TRAVERSED).increment(edgesTraversed);
             }
 
 

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/transform/VerticesVerticesMapReduce.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
 import com.thinkaurelius.titan.hadoop.Holder;
 import com.thinkaurelius.titan.hadoop.Tokens;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
@@ -77,7 +78,8 @@ public void map(final NullWritable key, final HadoopVertex value, final Mapper<N
                     }
                 }
                 value.clearPaths();
-                context.getCounter(Counters.EDGES_TRAVERSED).increment(edgesTraversed);
+                HadoopCompatLoader.getDefaultCompat().incrementContextCounter(context, Counters.EDGES_TRAVERSED, edgesTraversed);
+//                context.getCounter(Counters.EDGES_TRAVERSED).increment(edgesTraversed);
             }
 
             this.longWritable.set(value.getIdAsLong());

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/util/SafeMapperOutputs.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.hadoop.mapreduce.util;
 
 import com.thinkaurelius.titan.hadoop.Tokens;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompiler;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 
 import org.apache.hadoop.io.Writable;
 import org.apache.hadoop.mapreduce.Mapper;

File: titan-hadoop-parent/titan-hadoop-core/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/util/SafeReducerOutputs.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.hadoop.mapreduce.util;
 
 import com.thinkaurelius.titan.hadoop.Tokens;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompiler;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompiler;
 
 import org.apache.hadoop.io.Writable;
 import org.apache.hadoop.mapreduce.Reducer;

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/edgelist/rdf/RDFRecordReaderTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.hadoop.formats.edgelist.rdf;
 
 import com.thinkaurelius.titan.hadoop.BaseTest;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompatLoader;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
@@ -19,7 +19,7 @@ public void testRecordReader() throws Exception {
         conf.set(RDFInputFormat.TITAN_HADOOP_GRAPH_INPUT_RDF_FORMAT, "n-triples");
         RDFRecordReader reader = new RDFRecordReader(conf);
         reader.initialize(new FileSplit(new Path(RDFRecordReaderTest.class.getResource("graph-example-1.ntriple").toURI()), 0, Long.MAX_VALUE, new String[]{}),
-                HadoopCompatLoader.getTasks().newTask(conf, new TaskAttemptID()));
+                HadoopCompatLoader.getCompat().newTask(conf, new TaskAttemptID()));
         int counter = 0;
         while (reader.nextKeyValue()) {
             assertEquals(reader.getCurrentKey(), NullWritable.get());

File: titan-hadoop-parent/titan-hadoop-core/src/test/java/com/thinkaurelius/titan/hadoop/formats/script/ScriptRecordReaderTest.java
Patch:
@@ -2,8 +2,8 @@
 
 import com.thinkaurelius.titan.hadoop.BaseTest;
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
+import com.thinkaurelius.titan.hadoop.compat.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
-import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 
@@ -21,9 +21,9 @@ public class ScriptRecordReaderTest extends BaseTest {
     public void testRecordReader() throws Exception {
         final Configuration conf = new Configuration();
         conf.setStrings(ScriptInputFormat.TITAN_HADOOP_GRAPH_INPUT_SCRIPT_FILE, ScriptRecordReaderTest.class.getResource("ScriptInput.groovy").getFile());
-        ScriptRecordReader reader = new ScriptRecordReader(VertexQueryFilter.create(new EmptyConfiguration()), HadoopCompatLoader.getTasks().newTask(conf, new TaskAttemptID()));
+        ScriptRecordReader reader = new ScriptRecordReader(VertexQueryFilter.create(new EmptyConfiguration()), HadoopCompatLoader.getCompat().newTask(conf, new TaskAttemptID()));
         reader.initialize(new FileSplit(new Path(ScriptRecordReaderTest.class.getResource("graph-of-the-gods.id").toURI()), 0, Long.MAX_VALUE, new String[]{}),
-                HadoopCompatLoader.getTasks().newTask(conf, new TaskAttemptID()));
+                HadoopCompatLoader.getCompat().newTask(conf, new TaskAttemptID()));
         int counter = 0;
         while (reader.nextKeyValue()) {
             assertEquals(reader.getCurrentKey(), NullWritable.get());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalRelationType.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.core.Order;
 import com.thinkaurelius.titan.core.RelationType;
+import com.thinkaurelius.titan.core.schema.ModifierType;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.graphdb.types.SchemaStatus;
 import com.tinkerpop.blueprints.Direction;
@@ -23,12 +24,12 @@ public interface InternalRelationType extends RelationType, InternalVertex {
 
     public Order getSortOrder();
 
-    public Integer getTtl();
-
     public Multiplicity getMultiplicity();
 
     public ConsistencyModifier getConsistencyModifier();
 
+    public Object getTypeModifier(ModifierType modifierType);
+
     public boolean isUnidirected(Direction dir);
 
     public InternalRelationType getBaseType();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardRelationTypeMaker.java
Patch:
@@ -113,7 +113,6 @@ protected final TypeDefinitionMap makeDefinition() {
         def.setValue(HIDDEN, isHidden);
         def.setValue(SORT_KEY, checkSortKey(sortKey));
         def.setValue(SORT_ORDER, sortOrder);
-        def.setValue(TTL, ttl);
         def.setValue(SIGNATURE, checkSignature(signature));
         def.setValue(MULTIPLICITY,multiplicity);
         return def;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseRelationType.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
+import com.thinkaurelius.titan.core.schema.ModifierType;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
 import org.apache.commons.lang.StringUtils;

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -345,6 +345,7 @@ public void mutate(Map<String, Map<String, IndexMutation>> mutations, KeyInforma
                                 log.trace("Deleting individual field [{}] for document {}", key, docid);
                             }
                             brb.add(client.prepareUpdate(indexName, storename, docid).setScript(script.toString()));
+                            bulkrequests++;
                         }
                     }
                     if (mutation.hasAdditions()) {
@@ -359,6 +360,7 @@ public void mutate(Map<String, Map<String, IndexMutation>> mutations, KeyInforma
                             if (needUpsert) update.setUpsert(builder);
                             log.trace("Updating document {} with upsert {}", docid, needUpsert);
                             brb.add(update);
+                            bulkrequests++;
                         }
                     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/AbstractStoreManager.java
Patch:
@@ -46,7 +46,7 @@ public EntryMetaData[] getMetaDataSchema(String storeName) {
         StoreFeatures features = getFeatures();
         if (features.hasTimestamps() && storageConfig.get(STORE_META_TIMESTAMPS,storeName))
             schemaBuilder.add(EntryMetaData.TIMESTAMP);
-        if (features.hasTTL() && storageConfig.get(STORE_META_TTL,storeName))
+        if (features.hasCellTTL() && storageConfig.get(STORE_META_TTL,storeName))
             schemaBuilder.add(EntryMetaData.TTL);
         if (features.hasVisibility() && storageConfig.get(STORE_META_VISIBILITY,storeName))
             schemaBuilder.add(EntryMetaData.VISIBILITY);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StandardStoreFeatures.java
Patch:
@@ -79,7 +79,7 @@ public boolean hasTimestamps() {
     }
 
     @Override
-    public boolean hasTTL() {
+    public boolean hasCellTTL() {
         return ttl;
     }
 
@@ -144,7 +144,7 @@ public Builder(StoreFeatures template) {
             distributed(template.isDistributed());
             transactional(template.hasTxIsolation());
             timestamps(template.hasTimestamps());
-            ttl(template.hasTTL());
+            ttl(template.hasCellTTL());
             visibility(template.hasVisibility());
             if (template.isKeyConsistent()) {
                 keyConsistent(template.getKeyConsistentTxConfig(), template.getLocalKeyConsistentTxConfig());

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreFeatures.java
Patch:
@@ -99,7 +99,7 @@ public interface StoreFeatures {
      *
      * @return true if the storage backend supports TTL, else false
      */
-    public boolean hasTTL();
+    public boolean hasCellTTL();
 
 
     /**

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -917,7 +917,7 @@ public void testGetKeysWithKeyRange() throws Exception {
     @Test
     public void testTtl() throws Exception {
 
-        if (!manager.getFeatures().hasTTL()) {
+        if (!manager.getFeatures().hasCellTTL()) {
             return;
         }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -2752,7 +2752,7 @@ public void read(Message message) {
             }
         });
         Thread.sleep(20000);
-        assertEquals(8, txMsgCounter.get());
+        assertEquals(3*2 + (features.hasTxIsolation()?0:2), txMsgCounter.get());
         assertEquals(2,triggerMsgCounter.get());
         assertEquals(2,triggerMeta.get());
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -85,6 +85,7 @@ public<O> O computeProperty(InternalElement e) {
                 } else {
                     assert this==TIMESTAMP || this==TTL;
                     Long time = r.getPropertyDirect(this);
+                    if (time==null) return null; //there is no timestamp or ttl
                     TimeUnit unit = r.tx().getConfiguration().getTimestampProvider().getUnit();
                     if (this==TIMESTAMP) return (O)new StandardTimestamp(time,unit);
                     else return (O)new StandardDuration(time,unit);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -566,6 +566,7 @@ private void setupChainGraph(int numV, String[] strs) {
         TitanGraphIndex eindex = getExternalIndex(Edge.class,INDEX);
         TitanGraphIndex pindex = getExternalIndex(TitanProperty.class,INDEX);
         PropertyKey name = makeKey("name",String.class);
+
         mgmt.addIndexKey(vindex, name, Mapping.STRING.getParameter(), Parameter.of("mapped-name","vstr"));
         mgmt.addIndexKey(eindex,name, Mapping.STRING.getParameter(), Parameter.of("mapped-name", "estr"));
         mgmt.addIndexKey(pindex,name, Mapping.STRING.getParameter(), Parameter.of("mapped-name", "pstr"));

File: titan-hadoop-parent/common/main/java/com/thinkaurelius/titan/hadoop/mapreduce/util/EmptyConfiguration.java
Patch:
@@ -15,7 +15,8 @@ public void set(final String key, final String value) {
     };
 
     public EmptyConfiguration() {
-        super(false);
+        super(true);
+        this.clear();
     }
 
     public static Configuration immutable() {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -151,7 +151,7 @@ public boolean apply(@Nullable String s) {
 
     public static final ConfigOption<Boolean> SYSTEM_LOG_TRANSACTIONS = new ConfigOption<Boolean>(ROOT_NS,"log-tx",
             "Whether transaction mutations should be logged to Titan's system log",
-            ConfigOption.Type.GLOBAL, true);
+            ConfigOption.Type.GLOBAL, false);
 
     public static final ConfigOption<String> UNIQUE_INSTANCE_ID = new ConfigOption<String>(ROOT_NS,"unique-instance-id",
             "Unique identifier for this Titan instance.  This must be unique among all instances " +

File: titan-hadoop-parent/common/test/java/com/thinkaurelius/titan/hadoop/formats/edgelist/rdf/RDFRecordReaderTest.java
Patch:
@@ -1,11 +1,11 @@
 package com.thinkaurelius.titan.hadoop.formats.edgelist.rdf;
 
 import com.thinkaurelius.titan.hadoop.BaseTest;
+import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompatLoader;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.io.NullWritable;
-import org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl;
 import org.apache.hadoop.mapreduce.TaskAttemptID;
 import org.apache.hadoop.mapreduce.lib.input.FileSplit;
 
@@ -19,7 +19,7 @@ public void testRecordReader() throws Exception {
         conf.set(RDFInputFormat.TITAN_HADOOP_GRAPH_INPUT_RDF_FORMAT, "n-triples");
         RDFRecordReader reader = new RDFRecordReader(conf);
         reader.initialize(new FileSplit(new Path(RDFRecordReaderTest.class.getResource("graph-example-1.ntriple").toURI()), 0, Long.MAX_VALUE, new String[]{}),
-                new TaskAttemptContextImpl(conf, new TaskAttemptID()));
+                HadoopCompatLoader.getTasks().newTask(conf, new TaskAttemptID()));
         int counter = 0;
         while (reader.nextKeyValue()) {
             assertEquals(reader.getCurrentKey(), NullWritable.get());

File: titan-hadoop-parent/common/test/java/com/thinkaurelius/titan/hadoop/formats/script/ScriptRecordReaderTest.java
Patch:
@@ -3,13 +3,13 @@
 import com.thinkaurelius.titan.hadoop.BaseTest;
 import com.thinkaurelius.titan.hadoop.HadoopVertex;
 import com.thinkaurelius.titan.hadoop.formats.VertexQueryFilter;
+import com.thinkaurelius.titan.hadoop.mapreduce.HadoopCompatLoader;
 import com.thinkaurelius.titan.hadoop.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.io.NullWritable;
-import org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl;
 import org.apache.hadoop.mapreduce.TaskAttemptID;
 import org.apache.hadoop.mapreduce.lib.input.FileSplit;
 
@@ -21,9 +21,9 @@ public class ScriptRecordReaderTest extends BaseTest {
     public void testRecordReader() throws Exception {
         final Configuration conf = new Configuration();
         conf.setStrings(ScriptInputFormat.TITAN_HADOOP_GRAPH_INPUT_SCRIPT_FILE, ScriptRecordReaderTest.class.getResource("ScriptInput.groovy").getFile());
-        ScriptRecordReader reader = new ScriptRecordReader(VertexQueryFilter.create(new EmptyConfiguration()), new TaskAttemptContextImpl(conf, new TaskAttemptID()));
+        ScriptRecordReader reader = new ScriptRecordReader(VertexQueryFilter.create(new EmptyConfiguration()), HadoopCompatLoader.getTasks().newTask(conf, new TaskAttemptID()));
         reader.initialize(new FileSplit(new Path(ScriptRecordReaderTest.class.getResource("graph-of-the-gods.id").toURI()), 0, Long.MAX_VALUE, new String[]{}),
-                new TaskAttemptContextImpl(conf, new TaskAttemptID()));
+                HadoopCompatLoader.getTasks().newTask(conf, new TaskAttemptID()));
         int counter = 0;
         while (reader.nextKeyValue()) {
             assertEquals(reader.getCurrentKey(), NullWritable.get());

File: titan-hadoop-parent/titan-hadoop-1/src/main/java/com/thinkaurelius/titan/hadoop/mapreduce/Hadoop1Compiler.java
Patch:
@@ -40,14 +40,13 @@
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public class Hadoop1Compiler extends Configured implements Tool {
+public class Hadoop1Compiler extends Configured implements HadoopCompiler {
 
     private static final String MAPRED_COMPRESS_MAP_OUTPUT = "mapred.compress.map.output";
     private static final String MAPRED_MAP_OUTPUT_COMPRESSION_CODEC = "mapred.map.output.compression.codec";
     private static final String MAPRED_JAR = "mapred.jar";
 
-    public static final String TESTING = Tokens.makeNamespace(HadoopCompiler.class) + ".testing";
-    public static final Logger logger = Logger.getLogger(HadoopCompiler.class);
+    public static final Logger logger = Logger.getLogger(Hadoop1Compiler.class);
 
     private HadoopGraph graph;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/KCVSConfiguration.java
Patch:
@@ -130,7 +130,7 @@ public <O> void set(String key, O value, O expectedValue, final boolean checkExp
         }
         final StaticBuffer expectedValueBuffer;
         if (checkExpectedValue && expectedValue!=null) {
-            expectedValueBuffer = object2StaticBuffer(value);
+            expectedValueBuffer = object2StaticBuffer(expectedValue);
         } else {
             expectedValueBuffer = null;
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -208,7 +208,7 @@ public void initialize(Configuration config) {
             //EdgeStore & VertexIndexStore
             KeyColumnValueStore idStore = storeManager.openDatabase(ID_STORE_NAME);
             if (reportMetrics) {
-                idStore = new MetricInstrumentedStore(idStore, getMetricsStoreName("idStore"));
+                idStore = new MetricInstrumentedStore(idStore, getMetricsStoreName(ID_STORE_NAME));
             }
             idAuthority = null;
             if (storeFeatures.isKeyConsistent()) {
@@ -221,8 +221,8 @@ public void initialize(Configuration config) {
             KeyColumnValueStore indexStoreRaw = storeManagerLocking.openDatabase(INDEXSTORE_NAME);
 
             if (reportMetrics) {
-                edgeStoreRaw = new MetricInstrumentedStore(edgeStoreRaw, getMetricsStoreName("edgeStore"));
-                indexStoreRaw = new MetricInstrumentedStore(indexStoreRaw, getMetricsStoreName("vertexIndexStore"));
+                edgeStoreRaw = new MetricInstrumentedStore(edgeStoreRaw, getMetricsStoreName(EDGESTORE_NAME));
+                indexStoreRaw = new MetricInstrumentedStore(indexStoreRaw, getMetricsStoreName(INDEXSTORE_NAME));
             }
 
             //Configure caches

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/cache/StandardSchemaCache.java
Patch:
@@ -154,9 +154,7 @@ public EntryList getSchemaRelations(final long schemaId, final BaseRelationType
                 } else {
                     //Expand map
                     entries = retriever.retrieveSchemaRelations(schemaId, type, dir, tx);
-                    if (!entries.isEmpty()) { //only cache if type exists
-                        types.put(typePlusRelation,entries);
-                    }
+                    types.put(typePlusRelation,entries);
                 }
             }
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraExecutor.java
Patch:
@@ -149,13 +149,12 @@ public void run() {
                 if (conditionQuery==null) break; //Termination condition - primary query has no more data
 
                 //First, check if this is a valid (non-deleted) vertex
-                assert conditionQuery.entries.size()==1;
                 RelationCache relCache = tx.getEdgeSerializer().parseRelation(
                                         conditionQuery.entries.get(0),true,tx);
                 final long vertexid = conditionQuery.vertexId;
                 if (relCache.typeId != BaseKey.VertexExists.getID() &&
                         (!idManager.isPartitionedVertex(vertexid) || idManager.isCanonicalVertexId(vertexid)) ) {
-                    log.warn("Found deleted vertex with id: %s. Skipping",conditionQuery.vertexId);
+                    log.warn("Found deleted vertex with id: {}|{}|{}. Skipping",conditionQuery.vertexId,idManager.isPartitionedVertex(vertexid),relCache);
                     if (idManager.isPartitionedVertex(vertexid)) getMessageAccumulator(vertexid).markDeleted();
                     for (int i=1;i<currentResults.length;i++) {
                         if (currentResults[i]!=null && currentResults[i].vertexId==conditionQuery.vertexId) {
@@ -190,7 +189,7 @@ public void run() {
                 for (final Map.Entry<Long,MessageAccumulator> partitionVertexMsg : partitionedVertexMsgs.entrySet()) {
                     final MessageAccumulator mergedMsg = partitionVertexMsg.getValue();
                     if (mergedMsg.isDeleted()) {
-                        log.warn("Found deleted partitioned vertex with id: %s. Skipping",partitionVertexMsg.getKey());
+                        log.warn("Found deleted partitioned vertex with id: {}. Skipping",partitionVertexMsg.getKey());
                         continue;
                     }
                     final FulgoraVertex vertex = new FulgoraVertex(tx,partitionVertexMsg.getKey(),FulgoraExecutor.this);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -313,10 +313,10 @@ public InternalVertex getOtherPartitionVertex(TitanVertex partitionedVertex, lon
         return getExistingVertex(idManager.getPartitionedVertexId(partitionedVertex.getID(), otherPartition));
     }
 
-    public InternalVertex[] getAllRepresentatives(TitanVertex partitionedVertex, boolean ignoreLocalRestriction) {
+    public InternalVertex[] getAllRepresentatives(TitanVertex partitionedVertex, boolean restrict2Partitions) {
         Preconditions.checkArgument(isPartitionedVertex(partitionedVertex));
         long[] ids;
-        if (ignoreLocalRestriction || !config.hasRestrictedPartitions()) {
+        if (!restrict2Partitions || !config.hasRestrictedPartitions()) {
             ids = idManager.getPartitionedVertexRepresentatives(partitionedVertex.getID());
         } else {
             int[] restrictedParititions = config.getRestrictedPartitions();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseKey.java
Patch:
@@ -114,7 +114,7 @@ public boolean indexesKey(PropertyKey key) {
         public Cardinality getCardinality() {
             switch(index) {
                 case UNIQUE: return Cardinality.SINGLE;
-                case STANDARD: return Cardinality.SET;
+                case STANDARD: return Cardinality.LIST;
                 default: throw new AssertionError();
             }
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -92,7 +92,7 @@ public Degree initialState() {
                 return new Degree();
             }
         });
-        builder.setNumProcessingThreads(1);
+        builder.setNumProcessingThreads(2);
         builder.setStateKey("degree");
         builder.setJob(new OLAPJob() {
             @Override

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEKeyValueStore.java
Patch:
@@ -131,6 +131,7 @@ public RecordIterator<KeyValueEntry> getSlice(StaticBuffer keyStart, StaticBuffe
                 status = cursor.getNext(foundKey, foundData, getLockMode(txh));
             }
             log.trace("db={}, op=getSlice, tx={}, resultcount={}", name, txh, result.size());
+//            log.trace("db={}, op=getSlice, tx={}, resultcount={}", name, txh, result.size(), new Throwable("getSlice trace"));
 
             return new RecordIterator<KeyValueEntry>() {
                 private final Iterator<KeyValueEntry> entries = result.iterator();

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TransactionalTitanGraphTestSuite.java
Patch:
@@ -1,5 +1,7 @@
 package com.thinkaurelius.titan.blueprints;
 
+import org.junit.Ignore;
+
 import com.thinkaurelius.titan.graphdb.blueprints.TitanBlueprintsGraph;
 import com.tinkerpop.blueprints.TransactionalGraphTestSuite;
 import com.tinkerpop.blueprints.impls.GraphTest;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/thriftpool/CTConnectionFactory.java
Patch:
@@ -78,7 +78,7 @@ public CTConnection makeRawConnection() throws TTransportException {
 
 
         TSocket socket;
-        if (!cfg.sslTruststoreLocation.isEmpty()) {
+        if (null != cfg.sslTruststoreLocation && !cfg.sslTruststoreLocation.isEmpty()) {
             TSSLTransportFactory.TSSLTransportParameters params = new TSSLTransportFactory.TSSLTransportParameters() {{
                setKeyStore(cfg.sslTruststoreLocation, cfg.sslTruststorePassword);
             }};

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/idmanagement/IDManager.java
Patch:
@@ -468,6 +468,7 @@ public StaticBuffer getKey(long vertexid) {
         } else {
             assert isUserVertex(vertexid);
             VertexIDType type = getUserVertexIDType(vertexid);
+            assert type.offset()==USERVERTEX_PADDING_BITWIDTH;
             long partition = getPartitionId(vertexid);
             long count = vertexid>>>(partitionBits+USERVERTEX_PADDING_BITWIDTH);
             assert count>0;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/AbstractVertexCentricQueryBuilder.java
Patch:
@@ -410,14 +410,14 @@ public VertexList emptyResult() {
 
     protected List<InternalVertex> allRepresentatives(InternalVertex partitionedVertex) {
         if (hasAllSingleKeys()) {
-            ImmutableList.of(tx.getCanonicalVertex(partitionedVertex));
+            return ImmutableList.of(tx.getCanonicalVertex(partitionedVertex));
         }
         return Arrays.asList(tx.getAllRepresentatives(partitionedVertex,restrict2Partitions));
     }
 
 
     protected final boolean isPartitionedVertex(InternalVertex vertex) {
-        return tx.isPartitionedVertex(vertex) && !vertex.isNew();
+        return tx.isPartitionedVertex(vertex);
     }
 
     protected boolean useSimpleQueryProcessor(BaseVertexCentricQuery query, InternalVertex... vertices) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractEdge.java
Patch:
@@ -40,8 +40,10 @@ public void setVertexAt(int pos, InternalVertex vertex) {
         switch (pos) {
             case 0:
                 start = vertex;
+                break;
             case 1:
                 end = vertex;
+                break;
             default:
                 throw new IllegalArgumentException("Invalid position: " + pos);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Decimal.java
Patch:
@@ -19,6 +19,8 @@ public class Decimal extends AbstractDecimal {
     public static final Decimal MIN_VALUE = new Decimal(minDoubleValue(DECIMALS));
     public static final Decimal MAX_VALUE = new Decimal(maxDoubleValue(DECIMALS));
 
+    private Decimal() {}
+
     public Decimal(double value) {
         super(value, DECIMALS);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Precision.java
Patch:
@@ -19,6 +19,7 @@ public class Precision extends AbstractDecimal {
     public static final Precision MIN_VALUE = new Precision(minDoubleValue(DECIMALS));
     public static final Precision MAX_VALUE = new Precision(maxDoubleValue(DECIMALS));
 
+    private Precision() {}
 
     public Precision(double value) {
         super(value, DECIMALS);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/OrderList.java
Patch:
@@ -44,7 +44,7 @@ public int size() {
         return list.size();
     }
 
-    public boolean containsKey(String key) {
+    public boolean containsKey(PropertyKey key) {
         for (int i = 0; i < list.size(); i++) if (getKey(i).equals(key)) return true;
         return false;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/Token.java
Patch:
@@ -10,6 +10,8 @@ public class Token {
 
     public static final char SEPARATOR_CHAR = '%';
 
+    public static final char SPECIAL_TYPE_CHAR = '$';
+
     public static final String getSeparatedName(String... components) {
         for (String component : components) verifyName(component);
         return StringUtils.join(components,SEPARATOR_CHAR);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/SimpleVertexQueryProcessor.java
Patch:
@@ -103,12 +103,13 @@ public Long apply(@Nullable Entry entry) {
      * @return
      */
     private Iterator<Entry> getBasicIterator() {
-        return vertex.loadRelations(sliceQuery, new Retriever<SliceQuery, EntryList>() {
+        EntryList result = vertex.loadRelations(sliceQuery, new Retriever<SliceQuery, EntryList>() {
             @Override
             public EntryList get(SliceQuery query) {
                 return tx.getGraph().edgeQuery(vertex.getID(), query, tx.getTxHandle());
             }
-        }).iterator();
+        });
+        return result.iterator();
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexCentricQueryBuilder.java
Patch:
@@ -48,7 +48,6 @@ public class VertexCentricQueryBuilder extends AbstractVertexCentricQueryBuilder
     public VertexCentricQueryBuilder(InternalVertex v) {
         super(v.tx());
         Preconditions.checkNotNull(v);
-        Preconditions.checkArgument(!v.isRemoved(),"Cannot access a removed vertex: %s",v);
         this.vertex = v;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardRelationTypeMaker.java
Patch:
@@ -18,7 +18,7 @@
 
 public abstract class StandardRelationTypeMaker implements RelationTypeMaker {
 
-    static final char[] RESERVED_CHARS = {'{', '}', '"', Token.SEPARATOR_CHAR};
+    static final char[] RESERVED_CHARS = {'{', '}', '"', '$', Token.SEPARATOR_CHAR};
 
     protected final StandardTitanTx tx;
     protected final IndexSerializer indexSerializer;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardVertexLabelMaker.java
Patch:
@@ -28,7 +28,7 @@ public StandardVertexLabelMaker name(String name) {
         //Verify name
         Preconditions.checkArgument(StringUtils.isNotBlank(name), "Need to specify name");
         for (char c : StandardRelationTypeMaker.RESERVED_CHARS)
-            Preconditions.checkArgument(name.indexOf(c) < 0, "Name can not contains reserved character %s: %s", c, name);
+            Preconditions.checkArgument(name.indexOf(c) < 0, "Name contains reserved character %s: %s", c, name);
         this.name=name;
         return this;
     }

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VariableLongTest.java
Patch:
@@ -274,7 +274,7 @@ public long read(ReadBuffer in) {
 
 
     @Test
-    public void byteOrderPreserving() {
+    public void byteOrderPreservingPositiveBackward() {
         long[] scalingFactors = { Long.MAX_VALUE, 1000, 1000000000l};
         for (int t=0;t<10000000;t++) {
             StaticBuffer[] b = new StaticBuffer[2];

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -92,7 +92,7 @@ public void testIDAssignment() {
                     }
                     InternalRelation property = (InternalRelation) next.addProperty("age", 25);
                     if (flush) {
-                        idAssigner.assignID((InternalVertex) next);
+                        idAssigner.assignID((InternalVertex) next,next.getVertexLabel());
                         idAssigner.assignID(property);
                         if (edge != null) idAssigner.assignID(edge);
                     } else {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/ExpirationKCVSCache.java
Patch:
@@ -157,7 +157,7 @@ private boolean isExpired(final KeySliceQuery query) {
             expiredKeys.remove(query.getKey(),until);
             return false;
         }
-        //We suffer
+        //We suffer a cache miss, hence decrease the count down
         penaltyCountdown.countDown();
         return true;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/ZeroDuration.java
Patch:
@@ -51,4 +51,5 @@ public boolean isZeroLength() {
     public Duration multiply(double multiplier) {
         return this;
     }
+
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/OrderList.java
Patch:
@@ -105,7 +105,8 @@ public int compare(TitanElement o1, TitanElement o2) {
             int cmp = list.get(i).compare(o1, o2);
             if (cmp != 0) return cmp;
         }
-        return o1.compareTo(o2);
+//        return o1.compareTo(o2);
+        return 0;
     }
 
     /**

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -84,7 +84,8 @@ public void degreeCount() throws Exception {
         assertEquals(numV*(numV+1),totalCount);
     }
 
-    public static OLAPResult<Degree> computeDegree(final OLAPJobBuilder<Degree> builder, final String aggregatePropKey, final String checkPropKey) throws Exception {
+    public static OLAPResult<Degree> computeDegree(final OLAPJobBuilder<Degree> builder, final String aggregatePropKey,
+                                                   final String checkPropKey) throws Exception {
         builder.setInitializer(new StateInitializer<Degree>() {
             @Override
             public Degree initialState() {
@@ -147,6 +148,7 @@ public Degree(int in, int out,int prop) {
             this.in=in;
             this.out=out;
             both=in+out;
+            this.prop = prop;
         }
 
         public Degree() {

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJETx.java
Patch:
@@ -7,7 +7,7 @@
 import com.sleepycat.je.Transaction;
 import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 
 import org.slf4j.Logger;
@@ -26,7 +26,7 @@ public class BerkeleyJETx extends AbstractStoreTransaction {
     private List<Cursor> openCursors = new ArrayList<Cursor>();
     private final LockMode lm;
 
-    public BerkeleyJETx(Transaction t, LockMode lockMode, TransactionHandleConfig config) {
+    public BerkeleyJETx(Transaction t, LockMode lockMode, BaseTransactionConfig config) {
         super(config);
         tx = t;
         lm = lockMode;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraTransaction.java
Patch:
@@ -7,15 +7,15 @@
 import org.slf4j.LoggerFactory;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 
 public class CassandraTransaction extends AbstractStoreTransaction {
 
     private static final Logger log = LoggerFactory.getLogger(CassandraTransaction.class);
 
-    public CassandraTransaction(TransactionHandleConfig c) {
+    public CassandraTransaction(BaseTransactionConfig c) {
         super(c);
     }
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -26,6 +26,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
@@ -45,6 +46,7 @@
 import static com.thinkaurelius.titan.diskstorage.cassandra.CassandraTransaction.getTx;
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.STORAGE_NS;
 
+@PreInitializeConfigOptions
 public class AstyanaxStoreManager extends AbstractCassandraStoreManager {
 
     private static final Logger log = LoggerFactory.getLogger(AstyanaxStoreManager.class);

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxIDAuthorityTest.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
-public class AstyanaxIDAllocationTest extends IDAllocationTest {
+public class AstyanaxIDAuthorityTest extends IDAuthorityTest {
 
-    public AstyanaxIDAllocationTest(WriteConfiguration baseConfig) {
+    public AstyanaxIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxLogTest.java
Patch:
@@ -1,12 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
 import org.junit.BeforeClass;
+import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
+import com.thinkaurelius.titan.testcategory.SerialTests;
 
+@Category(SerialTests.class)
 public class AstyanaxLogTest extends KCVSLogTest {
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedIDAuthorityTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class EmbeddedIDAllocationTest extends IDAllocationTest {
+public class EmbeddedIDAuthorityTest extends IDAuthorityTest {
 
-    public EmbeddedIDAllocationTest(WriteConfiguration baseConfig) {
+    public EmbeddedIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedLogTest.java
Patch:
@@ -1,12 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import org.junit.BeforeClass;
+import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
+import com.thinkaurelius.titan.testcategory.SerialTests;
 
+@Category(SerialTests.class)
 public class EmbeddedLogTest extends KCVSLogTest {
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftIDAuthorityTest.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
-public class ThriftIDAllocationTest extends IDAllocationTest {
+public class ThriftIDAuthorityTest extends IDAuthorityTest {
 
-    public ThriftIDAllocationTest(WriteConfiguration baseConfig) {
+    public ThriftIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftLogTest.java
Patch:
@@ -1,12 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
 import org.junit.BeforeClass;
+import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
+import com.thinkaurelius.titan.testcategory.SerialTests;
 
+@Category(SerialTests.class)
 public class ThriftLogTest extends KCVSLogTest {
 
     @BeforeClass

File: titan-core/src/main/java/com/thinkaurelius/titan/core/Multiplicity.java
Patch:
@@ -4,7 +4,8 @@
 import com.tinkerpop.blueprints.Direction;
 
 /**
- * The multiplicity of edges between vertices for a given label.
+ * The multiplicity of edges between vertices for a given label. Multiplicity here is understood in the same sense as
+ * for UML class diagrams {@url http://en.wikipedia.org/wiki/Class_diagram#Multiplicity}
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */

File: titan-core/src/main/java/com/thinkaurelius/titan/core/olap/OLAPResult.java
Patch:
@@ -4,11 +4,11 @@
 
 /**
  * The result of an {@link OLAPJob} execution against a graph. The result contains the final vertex states for the
- * vertices in the graph which can be retrieved by vertex id.
+ * vertices in the graph which can be retrieved by vertex id for iterated over like a map.
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface OLAPResult<S extends State<S>> {
+public interface OLAPResult<S> {
 
     /**
      * Returns an {@link Iterable} over all final vertex states.

File: titan-core/src/main/java/com/thinkaurelius/titan/core/olap/StateInitializer.java
Patch:
@@ -4,10 +4,12 @@
  * Returns the initial state for a vertex.
  * </p>
  * It is important to return independent objects unless they are immutable. Otherwise data inconsistencies will arise.
+ * Furthermore, it is expected that {@link #initialState()} will return the same state on subsequent invocations because
+ * the state is not cached and hence this method may be called multiple times for the same vertex.
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface StateInitializer<S extends State<S>> {
+public interface StateInitializer<S> {
 
     public S initialState();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/Parameter.java
Patch:
@@ -5,7 +5,8 @@
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**
- * Simple class to represent an arbitrary parameters
+ * Simple class to represent arbitrary parameters as key-value pairs.
+ * Parameters are used in configuration and definitions.
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/TitanConfiguration.java
Patch:
@@ -1,7 +1,8 @@
 package com.thinkaurelius.titan.core.schema;
 
 /**
- *
+ * Used to read and change the global Titan configuration.
+ * The configuration options are read from the graph and affect the entire database.
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BaseTransaction.java
Patch:
@@ -6,7 +6,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public interface TransactionHandle {
+public interface BaseTransaction {
 
     /**
      * Commits the transaction and persists all modifications to the backend.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BaseTransactionConfig.java
Patch:
@@ -8,7 +8,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  * @author Dan LaRocque <dalaro@hopcount.org>
  */
-public interface TransactionHandleConfig {
+public interface BaseTransactionConfig {
 
     /**
      * Returns the commit time of this transaction which is either a custom timestamp provided

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/LoggableTransaction.java
Patch:
@@ -5,7 +5,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface LoggableTransaction extends TransactionHandle {
+public interface LoggableTransaction extends BaseTransaction {
 
     public void logMutations(DataOutput out);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/NoOpStoreTransaction.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.common;
 
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 
 /**
  * Dummy transaction object that does nothing
@@ -10,7 +10,7 @@
 
 public class NoOpStoreTransaction extends AbstractStoreTransaction {
 
-    public NoOpStoreTransaction(TransactionHandleConfig config) {
+    public NoOpStoreTransaction(BaseTransactionConfig config) {
         super(config);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDAuthority.java
Patch:
@@ -19,7 +19,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public abstract class AbstractIDManager implements IDAuthority {
+public abstract class AbstractIDAuthority implements IDAuthority {
 
     /* This value can't be changed without either
       * corrupting existing ID allocations or taking
@@ -38,7 +38,7 @@ public abstract class AbstractIDManager implements IDAuthority {
     private IDBlockSizer blockSizer;
     private volatile boolean isActive;
 
-    public AbstractIDManager(Configuration config) {
+    public AbstractIDAuthority(Configuration config) {
         this.uid = config.get(UNIQUE_INSTANCE_ID);
 
         this.uidBytes = uid.getBytes();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -22,21 +22,21 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class IndexTransaction implements TransactionHandle, LoggableTransaction {
+public class IndexTransaction implements BaseTransaction, LoggableTransaction {
 
     private static final int DEFAULT_OUTER_MAP_SIZE = 3;
     private static final int DEFAULT_INNER_MAP_SIZE = 5;
 
     private final IndexProvider index;
-    private final TransactionHandle indexTx;
+    private final BaseTransaction indexTx;
     private final KeyInformation.IndexRetriever keyInformations;
 
     private final Duration maxWriteTime;
 
     private Map<String,Map<String,IndexMutation>> mutations;
 
     public IndexTransaction(final IndexProvider index, final KeyInformation.IndexRetriever keyInformations,
-                            TransactionHandleConfig config,
+                            BaseTransactionConfig config,
                             Duration maxWriteTime) throws StorageException {
         Preconditions.checkNotNull(index);
         Preconditions.checkNotNull(keyInformations);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/KeyInformation.java
Patch:
@@ -15,7 +15,7 @@
  * <p/>
  *
  * {@link IndexRetriever} returns {@link KeyInformation} for a given store and given key. This will be provided to an
- * index when the key is not fixed in the context, e.g. in {@link IndexProvider#mutate(java.util.Map, com.thinkaurelius.titan.diskstorage.indexing.KeyInformation.IndexRetriever, com.thinkaurelius.titan.diskstorage.TransactionHandle)}
+ * index when the key is not fixed in the context, e.g. in {@link IndexProvider#mutate(java.util.Map, IndexRetriever, com.thinkaurelius.titan.diskstorage.BaseTransaction)}
  *
  * <p/>
  *

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreManager.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 
 import java.util.List;
 
@@ -18,7 +18,7 @@ public interface StoreManager {
      *
      * @return New Transaction Handle
      */
-    public StoreTransaction beginTransaction(TransactionHandleConfig config) throws StorageException;
+    public StoreTransaction beginTransaction(BaseTransactionConfig config) throws StorageException;
 
     /**
      * Closes the Storage Manager and all databases that have been opened.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreTransaction.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfigurable;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfigurable;
 
 /**
  * A transaction handle uniquely identifies a transaction on the storage backend.
@@ -15,7 +15,7 @@
  *
  * @author Matthias Br&ouml;cheler (me@matthiasb.com);
  */
-public interface StoreTransaction extends TransactionHandleConfigurable {
+public interface StoreTransaction extends BaseTransactionConfigurable {
 
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -57,7 +57,7 @@ public CacheTransaction(StoreTransaction tx, KeyColumnValueStoreManager manager,
         this.mutations = new HashMap<KCVSCache, Map<StaticBuffer, KCVEntryMutation>>(expectedNumStores);
     }
 
-    public StoreTransaction getWrappedTransactionHandle() {
+    public StoreTransaction getWrappedTransaction() {
         return tx;
     }
 
@@ -208,7 +208,7 @@ public void rollback() throws StorageException {
     }
 
     @Override
-    public TransactionHandleConfig getConfiguration() {
+    public BaseTransactionConfig getConfiguration() {
         return tx.getConfiguration();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/KCVSCache.java
Patch:
@@ -58,7 +58,7 @@ public void mutateEntries(StaticBuffer key, List<Entry> additions, List<Entry> d
 
     protected final StoreTransaction getTx(StoreTransaction txh) {
         assert txh instanceof CacheTransaction;
-        return ((CacheTransaction) txh).getWrappedTransactionHandle();
+        return ((CacheTransaction) txh).getWrappedTransaction();
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreManagerAdapter.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 
 import java.util.HashMap;
@@ -48,7 +48,7 @@ public StoreFeatures getFeatures() {
     }
 
     @Override
-    public StoreTransaction beginTransaction(final TransactionHandleConfig config) throws StorageException {
+    public StoreTransaction beginTransaction(final BaseTransactionConfig config) throws StorageException {
         return manager.beginTransaction(config);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -498,7 +498,7 @@ protected void deleteSingleLock(KeyColumn kc, ConsistentKeyLockStatus ls, StoreT
     }
 
     private StoreTransaction overrideTimestamp(final StoreTransaction tx, final Timepoint commitTime) throws StorageException {
-        StandardTransactionHandleConfig newCfg = new StandardTransactionHandleConfig.Builder(tx.getConfiguration())
+        StandardBaseTransactionConfig newCfg = new StandardBaseTransactionConfig.Builder(tx.getConfiguration())
                .commitTime(commitTime).build();
         return manager.beginTransaction(newCfg);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -296,11 +296,11 @@ public synchronized void close() throws StorageException {
 
     @Override
     public StoreTransaction openTx() throws StorageException {
-        StandardTransactionHandleConfig config;
+        StandardBaseTransactionConfig config;
         if (keyConsistentOperations) {
-            config = StandardTransactionHandleConfig.of(times,manager.storeManager.getFeatures().getKeyConsistentTxConfig());
+            config = StandardBaseTransactionConfig.of(times,manager.storeManager.getFeatures().getKeyConsistentTxConfig());
         } else {
-            config = StandardTransactionHandleConfig.of(times);
+            config = StandardBaseTransactionConfig.of(times);
         }
         return manager.storeManager.beginTransaction(config);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -5,7 +5,7 @@
 import com.google.common.collect.*;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.Cardinality;
-import com.thinkaurelius.titan.core.schema.ParameterType;
+import com.thinkaurelius.titan.graphdb.types.ParameterType;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.indexing.*;
 import com.thinkaurelius.titan.diskstorage.Entry;
@@ -71,7 +71,7 @@ public boolean containsIndex(final String indexName) {
     }
 
     public static void register(final ExternalIndexType index, final PropertyKey key, final BackendTransaction tx) throws StorageException {
-        tx.getIndexTransactionHandle(index.getBackingIndexName()).register(index.getStoreName(), key2Field(index,key), getKeyInformation(index.getField(key)));
+        tx.getIndexTransaction(index.getBackingIndexName()).register(index.getStoreName(), key2Field(index,key), getKeyInformation(index.getField(key)));
 
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -440,7 +440,7 @@ public boolean prepareCommit(final Collection<InternalRelation> addedRelations,
                     mutator.mutateIndex(update.getKey(), KeyColumnValueStore.NO_ADDITIONS, Lists.newArrayList(update.getEntry()));
             } else {
                 IndexSerializer.IndexUpdate<String,IndexEntry> update = indexUpdate;
-                IndexTransaction itx = mutator.getIndexTransactionHandle(update.getIndex().getBackingIndexName());
+                IndexTransaction itx = mutator.getIndexTransaction(update.getIndex().getBackingIndexName());
                 String indexStore = ((ExternalIndexType)update.getIndex()).getStoreName();
                 if (update.isAddition())
                     itx.add(indexStore,update.getKey(),update.getEntry().field,update.getEntry().value,update.getElement().isNew());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -547,6 +547,7 @@ else if (element instanceof TitanGraphIndex) {
             assert base instanceof TitanSchemaVertex;
             vertex = (TitanSchemaVertex)base;
         } else throw new IllegalArgumentException("Cannot change consistency of schema element: "+element);
+
         for (TitanEdge edge : vertex.getEdges(TypeDefinitionCategory.CONSISTENCY_MODIFIER,Direction.OUT)) {
             edge.remove();
             edge.getVertex(Direction.IN).remove();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -10,6 +10,7 @@
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.*;
 import com.thinkaurelius.titan.graphdb.internal.ElementCategory;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
+import com.thinkaurelius.titan.graphdb.types.ParameterType;
 import com.thinkaurelius.titan.graphdb.types.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionDescription;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraNeighborVertex.java
Patch:
@@ -133,7 +133,7 @@ public InternalVertex it() {
 
     @Override
     public StandardTitanTx tx() {
-        throw new UnsupportedOperationException("This vertex is not associated with a transaction");
+        return executor.tx();
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/IndexQueryBuilder.java
Patch:
@@ -88,7 +88,7 @@ public IndexQueryBuilder(StandardTitanTx tx, IndexSerializer serializer) {
         this.serializer = serializer;
 
         parameters = Lists.newArrayList();
-        unkownKeyName = tx.getGraph().getConfiguration().getUnknownIndexKeydName();
+        unkownKeyName = tx.getGraph().getConfiguration().getUnknownIndexKeyName();
         this.offset=0;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/TransactionConfiguration.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.graphdb.transaction;
 
 import com.thinkaurelius.titan.core.schema.DefaultSchemaMaker;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 
 /**
  * Provides configuration options for {@link com.thinkaurelius.titan.core.TitanTransaction}.
  *
  * @author Matthias Br&ouml;cheler (me@matthiasb.com);
  * @see com.thinkaurelius.titan.core.TitanTransaction
  */
-public interface TransactionConfiguration extends TransactionHandleConfig {
+public interface TransactionConfiguration extends BaseTransactionConfig {
 
     /**
      * Checks whether the graph transaction is configured as read-only.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/ParameterIndexField.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.schema.Parameter;
-import com.thinkaurelius.titan.core.schema.ParameterType;
 import com.thinkaurelius.titan.core.PropertyKey;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/ParameterType.java
Patch:
@@ -1,6 +1,7 @@
-package com.thinkaurelius.titan.core.schema;
+package com.thinkaurelius.titan.graphdb.types;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.schema.Parameter;
 import org.apache.commons.lang.StringUtils;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/indextype/InternalIndexTypeWrapper.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.core.Cardinality;
 import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
 import com.thinkaurelius.titan.core.schema.Parameter;
-import com.thinkaurelius.titan.core.schema.ParameterType;
+import com.thinkaurelius.titan.graphdb.types.ParameterType;
 import com.thinkaurelius.titan.graphdb.types.*;
 import com.tinkerpop.blueprints.Direction;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/BaseLabel.java
Patch:
@@ -11,7 +11,7 @@ public class BaseLabel extends BaseRelationType implements EdgeLabel {
             new BaseLabel("SchemaRelated", 36, Direction.BOTH);
 
     public static final BaseLabel VertexLabelEdge =
-            new BaseLabel("vertexlabel", 2, Direction.BOTH);
+            new BaseLabel("vertexlabel", 2, Direction.OUT);
 
 
     private final Direction directionality;

File: titan-hadoop/src/main/java/com/thinkaurelius/titan/hadoop/formats/graphson/HadoopGraphSONUtility.java
Patch:
@@ -48,7 +48,7 @@ public class HadoopGraphSONUtility {
     private static final HadoopElementFactory elementFactory = new HadoopElementFactory();
 
     private static final GraphSONUtility graphson = new GraphSONUtility(GraphSONMode.COMPACT, elementFactory,
-            ElementPropertyConfig.ExcludeProperties(VERTEX_IGNORE, EDGE_IGNORE));
+            ElementPropertyConfig.excludeProperties(VERTEX_IGNORE, EDGE_IGNORE));
 
     public static List<HadoopVertex> fromJSON(final Configuration configuration, final InputStream in) throws IOException {
         final List<HadoopVertex> vertices = new LinkedList<HadoopVertex>();
@@ -189,4 +189,4 @@ private long convertIdentifier(final Object id) {
             return identifier;
         }
     }
-}
\ No newline at end of file
+}

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseTransaction.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.hbase;
 
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 
 /**
@@ -13,7 +13,7 @@
  */
 public class HBaseTransaction extends AbstractStoreTransaction {
 
-    public HBaseTransaction(final TransactionHandleConfig config) {
+    public HBaseTransaction(final BaseTransactionConfig config) {
         super(config);
     }
 }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -232,7 +232,7 @@ public void testCacheConcurrency() throws InterruptedException {
                 option(GraphDatabaseConfiguration.DB_CACHE_CLEAN_WAIT),0,
                 option(GraphDatabaseConfiguration.DB_CACHE_SIZE),0.25,
                 option(GraphDatabaseConfiguration.BASIC_METRICS),true,
-                option(GraphDatabaseConfiguration.MERGE_BASIC_METRICS),false,
+                option(GraphDatabaseConfiguration.METRICS_MERGE_STORES),false,
                 option(GraphDatabaseConfiguration.METRICS_PREFIX),metricsPrefix};
         clopen(newConfig);
         final String prop = "property";
@@ -413,7 +413,7 @@ public void testCacheExpiration(final int timeOutTime, final int waitTime) throw
                               option(GraphDatabaseConfiguration.DB_CACHE_TIME),timeOutTime,
                               option(GraphDatabaseConfiguration.DB_CACHE_CLEAN_WAIT),cleanTime,
                               option(GraphDatabaseConfiguration.BASIC_METRICS),true,
-                              option(GraphDatabaseConfiguration.MERGE_BASIC_METRICS),false,
+                              option(GraphDatabaseConfiguration.METRICS_MERGE_STORES),false,
                               option(GraphDatabaseConfiguration.METRICS_PREFIX),metricsPrefix};
         clopen(newConfig);
         long[] vs = new long[numV];

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeTest.java
Patch:
@@ -13,7 +13,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.graphdb.types.StandardEdgeLabelMaker;
 
@@ -42,7 +42,7 @@ public void testDataSequential() throws Exception {
         query.setLimit(2);
         Stopwatch watch = new Stopwatch();
         watch.start();
-        StoreTransaction txh = manager.beginTransaction(StandardTransactionHandleConfig.of(Timestamps.MILLI));
+        StoreTransaction txh = manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MILLI));
         KeyIterator iter = store.getKeys(query,txh);
         int numV = 0;
         while(iter.hasNext()) {

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanNonTransactionalGraphMetricsTest.java
Patch:
@@ -50,7 +50,7 @@ public WriteConfiguration getConfiguration() {
         WriteConfiguration config = getBaseConfiguration();
         ModifiableConfiguration mconf = new ModifiableConfiguration(GraphDatabaseConfiguration.ROOT_NS,config, BasicConfiguration.Restriction.NONE);
         mconf.set(GraphDatabaseConfiguration.BASIC_METRICS,true);
-        mconf.set(GraphDatabaseConfiguration.MERGE_BASIC_METRICS,false);
+        mconf.set(GraphDatabaseConfiguration.METRICS_MERGE_STORES,false);
         mconf.set(GraphDatabaseConfiguration.PROPERTY_PREFETCHING,false);
         mconf.set(GraphDatabaseConfiguration.DB_CACHE,false);
         return config;

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/FulgoraOLAPTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.olap;
 
 import com.thinkaurelius.titan.core.olap.OLAPJobBuilder;
-import com.thinkaurelius.titan.core.olap.State;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.fulgora.FulgoraBuilder;
 
@@ -10,7 +9,7 @@
  */
 public abstract class FulgoraOLAPTest extends OLAPTest {
 
-    protected <S extends State<S>> OLAPJobBuilder<S> getOLAPBuilder(StandardTitanGraph graph, Class<S> clazz) {
+    protected <S> OLAPJobBuilder<S> getOLAPBuilder(StandardTitanGraph graph, Class<S> clazz) {
         return new FulgoraBuilder<S>(graph);
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/KCVSConfigTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -21,7 +21,7 @@ public WriteConfiguration getConfig() {
             return new KCVSConfiguration(new BackendOperation.TransactionalProvider() {
                 @Override
                 public StoreTransaction openTx() throws StorageException {
-                    return manager.beginTransaction(StandardTransactionHandleConfig.of(Timestamps.MICRO, manager.getFeatures().getKeyConsistentTxConfig()));
+                    return manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MICRO, manager.getFeatures().getKeyConsistentTxConfig()));
                 }
 
                 @Override

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/inmemory/InMemoryIDAuthorityTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.inmemory;
 
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
@@ -10,7 +10,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class InMemoryIDAllocationTest extends IDAllocationTest {
+public class InMemoryIDAuthorityTest extends IDAuthorityTest {
 
     /**
      * The IDAllocationTest assumes that every StoreManager returned by
@@ -25,7 +25,7 @@ public class InMemoryIDAllocationTest extends IDAllocationTest {
      */
     private final InMemoryStoreManager sharedManager;
 
-    public InMemoryIDAllocationTest(WriteConfiguration baseConfig) {
+    public InMemoryIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
         sharedManager = new InMemoryStoreManager();
     }

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -19,6 +19,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.KeyValueEntry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.util.system.IOUtils;
 
 import org.slf4j.Logger;
@@ -30,6 +31,7 @@
 
 import static com.thinkaurelius.titan.diskstorage.configuration.ConfigOption.disallowEmpty;
 
+@PreInitializeConfigOptions
 public class BerkeleyJEStoreManager extends LocalStoreManager implements OrderedKeyValueStoreManager {
 
     private static final Logger log = LoggerFactory.getLogger(BerkeleyJEStoreManager.class);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -14,6 +14,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.*;
 
@@ -23,7 +24,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
+@PreInitializeConfigOptions
 public abstract class AbstractCassandraStoreManager extends DistributedStoreManager implements KeyColumnValueStoreManager {
 
     public enum Partitioner {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -27,6 +27,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
@@ -46,6 +47,7 @@
 import static com.thinkaurelius.titan.diskstorage.cassandra.CassandraTransaction.getTx;
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.STORAGE_NS;
 
+@PreInitializeConfigOptions
 public class AstyanaxStoreManager extends AbstractCassandraStoreManager {
 
     private static final Logger log = LoggerFactory.getLogger(AstyanaxStoreManager.class);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -321,12 +321,12 @@ public KCVSConfiguration getGlobalSystemConfig() {
     }
 
     private String getMetricsStoreName(String storeName) {
-        return configuration.get(MERGE_BASIC_METRICS) ? METRICS_MERGED_STORE : storeName;
+        return configuration.get(METRICS_MERGE_STORES) ? METRICS_MERGED_STORE : storeName;
     }
 
     private String getMetricsCacheName(String storeName, boolean reportMetrics) {
         if (!reportMetrics) return null;
-        return configuration.get(MERGE_BASIC_METRICS) ? METRICS_MERGED_CACHE : storeName + METRICS_CACHE_SUFFIX;
+        return configuration.get(METRICS_MERGE_STORES) ? METRICS_MERGED_CACHE : storeName + METRICS_CACHE_SUFFIX;
     }
 
     public static LogManager getLogManager(Configuration config, String logName, KeyColumnValueStoreManager sm) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/IndexQueryBuilder.java
Patch:
@@ -88,7 +88,7 @@ public IndexQueryBuilder(StandardTitanTx tx, IndexSerializer serializer) {
         this.serializer = serializer;
 
         parameters = Lists.newArrayList();
-        unkownKeyName = tx.getGraph().getConfiguration().getUnknownIndexKeydName();
+        unkownKeyName = tx.getGraph().getConfiguration().getUnknownIndexKeyName();
         this.offset=0;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/util/system/ConfigurationPrinter.java
Patch:
@@ -12,6 +12,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.core.util.ReflectiveConfigOptionLoader;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigElement;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigNamespace;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
@@ -35,6 +36,8 @@ public class ConfigurationPrinter {
 
     public static void main(String args[]) throws FileNotFoundException {
 
+        ReflectiveConfigOptionLoader.loadOnce();
+
         final PrintStream stream;
         if (args.length == 1) {
             File f = new File(args[0]);

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -18,6 +18,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.*;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.util.system.IOUtils;
 import com.thinkaurelius.titan.util.system.NetworkUtil;
 
@@ -43,6 +44,7 @@
  *
  * @author Dan LaRocque <dalaro@hopcount.org>
  */
+@PreInitializeConfigOptions
 public class HBaseStoreManager extends DistributedStoreManager implements KeyColumnValueStoreManager {
 
     private static final Logger logger = LoggerFactory.getLogger(HBaseStoreManager.class);

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthorityTest.java
Patch:
@@ -122,7 +122,7 @@ public void open() throws StorageException {
         for (int i = 0; i < CONCURRENCY; i++) {
 
             ModifiableConfiguration sc = StorageSetup.getConfig(baseStoreConfiguration.copy());
-            sc.set(GraphDatabaseConfiguration.INSTANCE_RID_SHORT,(short)i);
+            sc.set(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID_SUFFIX,(short)i);
             if (!sc.has(UNIQUE_INSTANCE_ID)) {
                 String uniqueGraphId = getOrGenerateUniqueInstanceId(sc);
                 log.debug("Setting unique instance id: {}", uniqueGraphId);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -232,7 +232,7 @@ public void testCacheConcurrency() throws InterruptedException {
                 option(GraphDatabaseConfiguration.DB_CACHE_CLEAN_WAIT),0,
                 option(GraphDatabaseConfiguration.DB_CACHE_SIZE),0.25,
                 option(GraphDatabaseConfiguration.BASIC_METRICS),true,
-                option(GraphDatabaseConfiguration.MERGE_BASIC_METRICS),false,
+                option(GraphDatabaseConfiguration.METRICS_MERGE_STORES),false,
                 option(GraphDatabaseConfiguration.METRICS_PREFIX),metricsPrefix};
         clopen(newConfig);
         final String prop = "property";
@@ -413,7 +413,7 @@ public void testCacheExpiration(final int timeOutTime, final int waitTime) throw
                               option(GraphDatabaseConfiguration.DB_CACHE_TIME),timeOutTime,
                               option(GraphDatabaseConfiguration.DB_CACHE_CLEAN_WAIT),cleanTime,
                               option(GraphDatabaseConfiguration.BASIC_METRICS),true,
-                              option(GraphDatabaseConfiguration.MERGE_BASIC_METRICS),false,
+                              option(GraphDatabaseConfiguration.METRICS_MERGE_STORES),false,
                               option(GraphDatabaseConfiguration.METRICS_PREFIX),metricsPrefix};
         clopen(newConfig);
         long[] vs = new long[numV];

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanNonTransactionalGraphMetricsTest.java
Patch:
@@ -50,7 +50,7 @@ public WriteConfiguration getConfiguration() {
         WriteConfiguration config = getBaseConfiguration();
         ModifiableConfiguration mconf = new ModifiableConfiguration(GraphDatabaseConfiguration.ROOT_NS,config, BasicConfiguration.Restriction.NONE);
         mconf.set(GraphDatabaseConfiguration.BASIC_METRICS,true);
-        mconf.set(GraphDatabaseConfiguration.MERGE_BASIC_METRICS,false);
+        mconf.set(GraphDatabaseConfiguration.METRICS_MERGE_STORES,false);
         mconf.set(GraphDatabaseConfiguration.PROPERTY_PREFETCHING,false);
         mconf.set(GraphDatabaseConfiguration.DB_CACHE,false);
         return config;

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -19,6 +19,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.KeyValueEntry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.util.system.IOUtils;
 
 import org.slf4j.Logger;
@@ -30,6 +31,7 @@
 
 import static com.thinkaurelius.titan.diskstorage.configuration.ConfigOption.disallowEmpty;
 
+@PreInitializeConfigOptions
 public class BerkeleyJEStoreManager extends LocalStoreManager implements OrderedKeyValueStoreManager {
 
     private static final Logger log = LoggerFactory.getLogger(BerkeleyJEStoreManager.class);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -14,6 +14,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.*;
 
@@ -23,7 +24,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
+@PreInitializeConfigOptions
 public abstract class AbstractCassandraStoreManager extends DistributedStoreManager implements KeyColumnValueStoreManager {
 
     public enum Partitioner {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -27,6 +27,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
@@ -46,6 +47,7 @@
 import static com.thinkaurelius.titan.diskstorage.cassandra.CassandraTransaction.getTx;
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.STORAGE_NS;
 
+@PreInitializeConfigOptions
 public class AstyanaxStoreManager extends AbstractCassandraStoreManager {
 
     private static final Logger log = LoggerFactory.getLogger(AstyanaxStoreManager.class);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -321,12 +321,12 @@ public KCVSConfiguration getGlobalSystemConfig() {
     }
 
     private String getMetricsStoreName(String storeName) {
-        return configuration.get(MERGE_BASIC_METRICS) ? METRICS_MERGED_STORE : storeName;
+        return configuration.get(METRICS_MERGE_STORES) ? METRICS_MERGED_STORE : storeName;
     }
 
     private String getMetricsCacheName(String storeName, boolean reportMetrics) {
         if (!reportMetrics) return null;
-        return configuration.get(MERGE_BASIC_METRICS) ? METRICS_MERGED_CACHE : storeName + METRICS_CACHE_SUFFIX;
+        return configuration.get(METRICS_MERGE_STORES) ? METRICS_MERGED_CACHE : storeName + METRICS_CACHE_SUFFIX;
     }
 
     public static LogManager getLogManager(Configuration config, String logName, KeyColumnValueStoreManager sm) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/IndexQueryBuilder.java
Patch:
@@ -88,7 +88,7 @@ public IndexQueryBuilder(StandardTitanTx tx, IndexSerializer serializer) {
         this.serializer = serializer;
 
         parameters = Lists.newArrayList();
-        unkownKeyName = tx.getGraph().getConfiguration().getUnknownIndexKeydName();
+        unkownKeyName = tx.getGraph().getConfiguration().getUnknownIndexKeyName();
         this.offset=0;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/util/system/ConfigurationPrinter.java
Patch:
@@ -12,6 +12,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.core.util.ReflectiveConfigOptionLoader;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigElement;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigNamespace;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
@@ -35,6 +36,8 @@ public class ConfigurationPrinter {
 
     public static void main(String args[]) throws FileNotFoundException {
 
+        ReflectiveConfigOptionLoader.loadOnce();
+
         final PrintStream stream;
         if (args.length == 1) {
             File f = new File(args[0]);

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -18,6 +18,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.*;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+import com.thinkaurelius.titan.graphdb.configuration.PreInitializeConfigOptions;
 import com.thinkaurelius.titan.util.system.IOUtils;
 import com.thinkaurelius.titan.util.system.NetworkUtil;
 
@@ -43,6 +44,7 @@
  *
  * @author Dan LaRocque <dalaro@hopcount.org>
  */
+@PreInitializeConfigOptions
 public class HBaseStoreManager extends DistributedStoreManager implements KeyColumnValueStoreManager {
 
     private static final Logger logger = LoggerFactory.getLogger(HBaseStoreManager.class);

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthorityTest.java
Patch:
@@ -122,7 +122,7 @@ public void open() throws StorageException {
         for (int i = 0; i < CONCURRENCY; i++) {
 
             ModifiableConfiguration sc = StorageSetup.getConfig(baseStoreConfiguration.copy());
-            sc.set(GraphDatabaseConfiguration.INSTANCE_RID_SHORT,(short)i);
+            sc.set(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID_SUFFIX,(short)i);
             if (!sc.has(UNIQUE_INSTANCE_ID)) {
                 String uniqueGraphId = getOrGenerateUniqueInstanceId(sc);
                 log.debug("Setting unique instance id: {}", uniqueGraphId);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -232,7 +232,7 @@ public void testCacheConcurrency() throws InterruptedException {
                 option(GraphDatabaseConfiguration.DB_CACHE_CLEAN_WAIT),0,
                 option(GraphDatabaseConfiguration.DB_CACHE_SIZE),0.25,
                 option(GraphDatabaseConfiguration.BASIC_METRICS),true,
-                option(GraphDatabaseConfiguration.MERGE_BASIC_METRICS),false,
+                option(GraphDatabaseConfiguration.METRICS_MERGE_STORES),false,
                 option(GraphDatabaseConfiguration.METRICS_PREFIX),metricsPrefix};
         clopen(newConfig);
         final String prop = "property";
@@ -413,7 +413,7 @@ public void testCacheExpiration(final int timeOutTime, final int waitTime) throw
                               option(GraphDatabaseConfiguration.DB_CACHE_TIME),timeOutTime,
                               option(GraphDatabaseConfiguration.DB_CACHE_CLEAN_WAIT),cleanTime,
                               option(GraphDatabaseConfiguration.BASIC_METRICS),true,
-                              option(GraphDatabaseConfiguration.MERGE_BASIC_METRICS),false,
+                              option(GraphDatabaseConfiguration.METRICS_MERGE_STORES),false,
                               option(GraphDatabaseConfiguration.METRICS_PREFIX),metricsPrefix};
         clopen(newConfig);
         long[] vs = new long[numV];

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanNonTransactionalGraphMetricsTest.java
Patch:
@@ -50,7 +50,7 @@ public WriteConfiguration getConfiguration() {
         WriteConfiguration config = getBaseConfiguration();
         ModifiableConfiguration mconf = new ModifiableConfiguration(GraphDatabaseConfiguration.ROOT_NS,config, BasicConfiguration.Restriction.NONE);
         mconf.set(GraphDatabaseConfiguration.BASIC_METRICS,true);
-        mconf.set(GraphDatabaseConfiguration.MERGE_BASIC_METRICS,false);
+        mconf.set(GraphDatabaseConfiguration.METRICS_MERGE_STORES,false);
         mconf.set(GraphDatabaseConfiguration.PROPERTY_PREFETCHING,false);
         mconf.set(GraphDatabaseConfiguration.DB_CACHE,false);
         return config;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/Multiplicity.java
Patch:
@@ -4,7 +4,8 @@
 import com.tinkerpop.blueprints.Direction;
 
 /**
- * The multiplicity of edges between vertices for a given label.
+ * The multiplicity of edges between vertices for a given label. Multiplicity here is understood in the same sense as
+ * for UML class diagrams {@url http://en.wikipedia.org/wiki/Class_diagram#Multiplicity}
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraNeighborVertex.java
Patch:
@@ -133,7 +133,7 @@ public InternalVertex it() {
 
     @Override
     public StandardTitanTx tx() {
-        throw new UnsupportedOperationException("This vertex is not associated with a transaction");
+        return executor.tx();
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -201,7 +201,8 @@ public Long combine(Long m1, Long m2) {
         builder.setJob(new OLAPJob() {
             @Override
             public PageRank process(TitanVertex vertex) {
-                return new PageRank(vertex.<Long>getProperty("degree"),1.0d/numVertices);
+                Long degree = vertex.<Long>getProperty("degree");
+                return new PageRank(degree==null?0:degree,1.0d/numVertices);
             }
         });
         OLAPResult<PageRank> ranks;
@@ -218,7 +219,7 @@ public PageRank process(TitanVertex vertex) {
             builder.setNumProcessingThreads(numThreads);
             builder.setStateKey("pageRank");
             builder.setInitialState(ranks);
-            query = builder.addQuery().setName("energy").direction(Direction.OUT);
+            query = builder.addQuery().setName("energy").direction(Direction.IN);
             if (labels!=null && labels.length>0) {
                 query.labels(labels);
             }

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.LocalStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
@@ -114,7 +114,7 @@ public List<KeyRange> getLocalKeyPartition() throws StorageException {
     }
 
     @Override
-    public BerkeleyJETx beginTransaction(final TransactionHandleConfig txCfg) throws StorageException {
+    public BerkeleyJETx beginTransaction(final BaseTransactionConfig txCfg) throws StorageException {
         try {
             Transaction tx = null;
 

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJETx.java
Patch:
@@ -7,7 +7,7 @@
 import com.sleepycat.je.Transaction;
 import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 
 import org.slf4j.Logger;
@@ -26,7 +26,7 @@ public class BerkeleyJETx extends AbstractStoreTransaction {
     private List<Cursor> openCursors = new ArrayList<Cursor>();
     private final LockMode lm;
 
-    public BerkeleyJETx(Transaction t, LockMode lockMode, TransactionHandleConfig config) {
+    public BerkeleyJETx(Transaction t, LockMode lockMode, BaseTransactionConfig config) {
         super(config);
         tx = t;
         lm = lockMode;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.diskstorage.EntryMetaData;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.DistributedStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
@@ -179,7 +179,7 @@ public final Partitioner getPartitioner() {
     public abstract IPartitioner<? extends Token<?>> getCassandraPartitioner() throws StorageException;
 
     @Override
-    public StoreTransaction beginTransaction(final TransactionHandleConfig config) {
+    public StoreTransaction beginTransaction(final BaseTransactionConfig config) {
         return new CassandraTransaction(config);
     }
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraTransaction.java
Patch:
@@ -7,15 +7,15 @@
 import org.slf4j.LoggerFactory;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 
 public class CassandraTransaction extends AbstractStoreTransaction {
 
     private static final Logger log = LoggerFactory.getLogger(CassandraTransaction.class);
 
-    public CassandraTransaction(TransactionHandleConfig c) {
+    public CassandraTransaction(BaseTransactionConfig c) {
         super(c);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -28,7 +28,7 @@
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
 import com.thinkaurelius.titan.diskstorage.util.MetricInstrumentedStore;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.KCVSConfiguration;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 import com.thinkaurelius.titan.graphdb.configuration.TitanConstants;
 import com.thinkaurelius.titan.graphdb.transaction.TransactionConfiguration;
 import com.thinkaurelius.titan.util.system.ConfigurationUtil;
@@ -266,7 +266,7 @@ public void initialize(Configuration config) {
             systemConfig = getGlobalConfiguration(new BackendOperation.TransactionalProvider() {
                 @Override
                 public StoreTransaction openTx() throws StorageException {
-                    return storeManagerLocking.beginTransaction(StandardTransactionHandleConfig.of(
+                    return storeManagerLocking.beginTransaction(StandardBaseTransactionConfig.of(
                             configuration.get(TIMESTAMP_PROVIDER),
                             storeFeatures.getKeyConsistentTxConfig()));
                 }
@@ -376,7 +376,7 @@ public static KCVSConfiguration getStandaloneGlobalConfiguration(final KeyColumn
             return getGlobalConfiguration(new BackendOperation.TransactionalProvider() {
                 @Override
                 public StoreTransaction openTx() throws StorageException {
-                    return manager.beginTransaction(StandardTransactionHandleConfig.of(config.get(TIMESTAMP_PROVIDER),features.getKeyConsistentTxConfig()));
+                    return manager.beginTransaction(StandardBaseTransactionConfig.of(config.get(TIMESTAMP_PROVIDER),features.getKeyConsistentTxConfig()));
                 }
 
                 @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BaseTransaction.java
Patch:
@@ -6,7 +6,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public interface TransactionHandle {
+public interface BaseTransaction {
 
     /**
      * Commits the transaction and persists all modifications to the backend.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BaseTransactionConfig.java
Patch:
@@ -8,7 +8,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  * @author Dan LaRocque <dalaro@hopcount.org>
  */
-public interface TransactionHandleConfig {
+public interface BaseTransactionConfig {
 
     /**
      * Returns the commit time of this transaction which is either a custom timestamp provided

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/LoggableTransaction.java
Patch:
@@ -5,7 +5,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface LoggableTransaction extends TransactionHandle {
+public interface LoggableTransaction extends BaseTransaction {
 
     public void logMutations(DataOutput out);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/NoOpStoreTransaction.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.common;
 
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 
 /**
  * Dummy transaction object that does nothing
@@ -10,7 +10,7 @@
 
 public class NoOpStoreTransaction extends AbstractStoreTransaction {
 
-    public NoOpStoreTransaction(TransactionHandleConfig config) {
+    public NoOpStoreTransaction(BaseTransactionConfig config) {
         super(config);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDAuthority.java
Patch:
@@ -26,7 +26,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.locking.TemporaryLockingException;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDPoolExhaustedException;
 import com.thinkaurelius.titan.graphdb.database.idhandling.VariableLong;
@@ -56,7 +56,7 @@ public class ConsistentKeyIDAuthority extends AbstractIDAuthority implements Bac
 
     private final StoreManager manager;
     private final KeyColumnValueStore idStore;
-    private final StandardTransactionHandleConfig.Builder storeTxConfigBuilder;
+    private final StandardBaseTransactionConfig.Builder storeTxConfigBuilder;
     /**
      * This belongs in TitanConfig.
      */
@@ -92,7 +92,7 @@ public ConsistentKeyIDAuthority(KeyColumnValueStore idStore, StoreManager manage
         Preconditions.checkArgument(uniqueIdBitWidth<=16 && uniqueIdBitWidth>=0);
         uniqueIDUpperBound = 1<<uniqueIdBitWidth;
 
-        storeTxConfigBuilder = new StandardTransactionHandleConfig.Builder().groupName(metricsPrefix).timestampProvider(times);
+        storeTxConfigBuilder = new StandardBaseTransactionConfig.Builder().groupName(metricsPrefix).timestampProvider(times);
 
         if (config.get(IDAUTHORITY_RANDOMIZE_UNIQUEID)) {
             Preconditions.checkArgument(!config.has(IDAUTHORITY_UNIQUEID),"Conflicting configuration: a unique id and randomization have been set");

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -22,21 +22,21 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class IndexTransaction implements TransactionHandle, LoggableTransaction {
+public class IndexTransaction implements BaseTransaction, LoggableTransaction {
 
     private static final int DEFAULT_OUTER_MAP_SIZE = 3;
     private static final int DEFAULT_INNER_MAP_SIZE = 5;
 
     private final IndexProvider index;
-    private final TransactionHandle indexTx;
+    private final BaseTransaction indexTx;
     private final KeyInformation.IndexRetriever keyInformations;
 
     private final Duration maxWriteTime;
 
     private Map<String,Map<String,IndexMutation>> mutations;
 
     public IndexTransaction(final IndexProvider index, final KeyInformation.IndexRetriever keyInformations,
-                            TransactionHandleConfig config,
+                            BaseTransactionConfig config,
                             Duration maxWriteTime) throws StorageException {
         Preconditions.checkNotNull(index);
         Preconditions.checkNotNull(keyInformations);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/KeyInformation.java
Patch:
@@ -15,7 +15,7 @@
  * <p/>
  *
  * {@link IndexRetriever} returns {@link KeyInformation} for a given store and given key. This will be provided to an
- * index when the key is not fixed in the context, e.g. in {@link IndexProvider#mutate(java.util.Map, com.thinkaurelius.titan.diskstorage.indexing.KeyInformation.IndexRetriever, com.thinkaurelius.titan.diskstorage.TransactionHandle)}
+ * index when the key is not fixed in the context, e.g. in {@link IndexProvider#mutate(java.util.Map, IndexRetriever, com.thinkaurelius.titan.diskstorage.BaseTransaction)}
  *
  * <p/>
  *

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreManager.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 
 import java.util.List;
 
@@ -18,7 +18,7 @@ public interface StoreManager {
      *
      * @return New Transaction Handle
      */
-    public StoreTransaction beginTransaction(TransactionHandleConfig config) throws StorageException;
+    public StoreTransaction beginTransaction(BaseTransactionConfig config) throws StorageException;
 
     /**
      * Closes the Storage Manager and all databases that have been opened.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreTransaction.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfigurable;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfigurable;
 
 /**
  * A transaction handle uniquely identifies a transaction on the storage backend.
@@ -15,7 +15,7 @@
  *
  * @author Matthias Br&ouml;cheler (me@matthiasb.com);
  */
-public interface StoreTransaction extends TransactionHandleConfigurable {
+public interface StoreTransaction extends BaseTransactionConfigurable {
 
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -57,7 +57,7 @@ public CacheTransaction(StoreTransaction tx, KeyColumnValueStoreManager manager,
         this.mutations = new HashMap<KCVSCache, Map<StaticBuffer, KCVEntryMutation>>(expectedNumStores);
     }
 
-    public StoreTransaction getWrappedTransactionHandle() {
+    public StoreTransaction getWrappedTransaction() {
         return tx;
     }
 
@@ -208,7 +208,7 @@ public void rollback() throws StorageException {
     }
 
     @Override
-    public TransactionHandleConfig getConfiguration() {
+    public BaseTransactionConfig getConfiguration() {
         return tx.getConfiguration();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/KCVSCache.java
Patch:
@@ -58,7 +58,7 @@ public void mutateEntries(StaticBuffer key, List<Entry> additions, List<Entry> d
 
     protected final StoreTransaction getTx(StoreTransaction txh) {
         assert txh instanceof CacheTransaction;
-        return ((CacheTransaction) txh).getWrappedTransactionHandle();
+        return ((CacheTransaction) txh).getWrappedTransaction();
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreManagerAdapter.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 
 import java.util.HashMap;
@@ -48,7 +48,7 @@ public StoreFeatures getFeatures() {
     }
 
     @Override
-    public StoreTransaction beginTransaction(final TransactionHandleConfig config) throws StorageException {
+    public StoreTransaction beginTransaction(final BaseTransactionConfig config) throws StorageException {
         return manager.beginTransaction(config);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -498,7 +498,7 @@ protected void deleteSingleLock(KeyColumn kc, ConsistentKeyLockStatus ls, StoreT
     }
 
     private StoreTransaction overrideTimestamp(final StoreTransaction tx, final Timepoint commitTime) throws StorageException {
-        StandardTransactionHandleConfig newCfg = new StandardTransactionHandleConfig.Builder(tx.getConfiguration())
+        StandardBaseTransactionConfig newCfg = new StandardBaseTransactionConfig.Builder(tx.getConfiguration())
                .commitTime(commitTime).build();
         return manager.beginTransaction(newCfg);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -296,11 +296,11 @@ public synchronized void close() throws StorageException {
 
     @Override
     public StoreTransaction openTx() throws StorageException {
-        StandardTransactionHandleConfig config;
+        StandardBaseTransactionConfig config;
         if (keyConsistentOperations) {
-            config = StandardTransactionHandleConfig.of(times,manager.storeManager.getFeatures().getKeyConsistentTxConfig());
+            config = StandardBaseTransactionConfig.of(times,manager.storeManager.getFeatures().getKeyConsistentTxConfig());
         } else {
-            config = StandardTransactionHandleConfig.of(times);
+            config = StandardBaseTransactionConfig.of(times);
         }
         return manager.storeManager.beginTransaction(config);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -71,7 +71,7 @@ public boolean containsIndex(final String indexName) {
     }
 
     public static void register(final ExternalIndexType index, final PropertyKey key, final BackendTransaction tx) throws StorageException {
-        tx.getIndexTransactionHandle(index.getBackingIndexName()).register(index.getStoreName(), key2Field(index,key), getKeyInformation(index.getField(key)));
+        tx.getIndexTransaction(index.getBackingIndexName()).register(index.getStoreName(), key2Field(index,key), getKeyInformation(index.getField(key)));
 
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -440,7 +440,7 @@ public boolean prepareCommit(final Collection<InternalRelation> addedRelations,
                     mutator.mutateIndex(update.getKey(), KeyColumnValueStore.NO_ADDITIONS, Lists.newArrayList(update.getEntry()));
             } else {
                 IndexSerializer.IndexUpdate<String,IndexEntry> update = indexUpdate;
-                IndexTransaction itx = mutator.getIndexTransactionHandle(update.getIndex().getBackingIndexName());
+                IndexTransaction itx = mutator.getIndexTransaction(update.getIndex().getBackingIndexName());
                 String indexStore = ((ExternalIndexType)update.getIndex()).getStoreName();
                 if (update.isAddition())
                     itx.add(indexStore,update.getKey(),update.getEntry().field,update.getEntry().value,update.getElement().isNew());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/TransactionConfiguration.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.graphdb.transaction;
 
 import com.thinkaurelius.titan.core.schema.DefaultSchemaMaker;
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 
 /**
  * Provides configuration options for {@link com.thinkaurelius.titan.core.TitanTransaction}.
  *
  * @author Matthias Br&ouml;cheler (me@matthiasb.com);
  * @see com.thinkaurelius.titan.core.TitanTransaction
  */
-public interface TransactionConfiguration extends TransactionHandleConfig {
+public interface TransactionConfiguration extends BaseTransactionConfig {
 
     /**
      * Checks whether the graph transaction is configured as read-only.

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -368,7 +368,7 @@ public KeyColumnValueStore openDatabase(final String longName) throws StorageExc
     }
 
     @Override
-    public StoreTransaction beginTransaction(final TransactionHandleConfig config) throws StorageException {
+    public StoreTransaction beginTransaction(final BaseTransactionConfig config) throws StorageException {
         return new HBaseTransaction(config);
     }
 

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseTransaction.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.hbase;
 
-import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.BaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
 
 /**
@@ -13,7 +13,7 @@
  */
 public class HBaseTransaction extends AbstractStoreTransaction {
 
-    public HBaseTransaction(final TransactionHandleConfig config) {
+    public HBaseTransaction(final BaseTransactionConfig config) {
         super(config);
     }
 }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeTest.java
Patch:
@@ -13,7 +13,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.graphdb.types.StandardEdgeLabelMaker;
 
@@ -42,7 +42,7 @@ public void testDataSequential() throws Exception {
         query.setLimit(2);
         Stopwatch watch = new Stopwatch();
         watch.start();
-        StoreTransaction txh = manager.beginTransaction(StandardTransactionHandleConfig.of(Timestamps.MILLI));
+        StoreTransaction txh = manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MILLI));
         KeyIterator iter = store.getKeys(query,txh);
         int numV = 0;
         while(iter.hasNext()) {

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/KCVSConfigTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.util.StandardBaseTransactionConfig;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -21,7 +21,7 @@ public WriteConfiguration getConfig() {
             return new KCVSConfiguration(new BackendOperation.TransactionalProvider() {
                 @Override
                 public StoreTransaction openTx() throws StorageException {
-                    return manager.beginTransaction(StandardTransactionHandleConfig.of(Timestamps.MICRO, manager.getFeatures().getKeyConsistentTxConfig()));
+                    return manager.beginTransaction(StandardBaseTransactionConfig.of(Timestamps.MICRO, manager.getFeatures().getKeyConsistentTxConfig()));
                 }
 
                 @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxIDAuthorityTest.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
-public class AstyanaxIDAllocationTest extends IDAllocationTest {
+public class AstyanaxIDAuthorityTest extends IDAuthorityTest {
 
-    public AstyanaxIDAllocationTest(WriteConfiguration baseConfig) {
+    public AstyanaxIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedIDAuthorityTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class EmbeddedIDAllocationTest extends IDAllocationTest {
+public class EmbeddedIDAuthorityTest extends IDAuthorityTest {
 
-    public EmbeddedIDAllocationTest(WriteConfiguration baseConfig) {
+    public EmbeddedIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftIDAuthorityTest.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
-public class ThriftIDAllocationTest extends IDAllocationTest {
+public class ThriftIDAuthorityTest extends IDAuthorityTest {
 
-    public ThriftIDAllocationTest(WriteConfiguration baseConfig) {
+    public ThriftIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
-import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDManager;
+import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDAuthority;
 import com.thinkaurelius.titan.diskstorage.indexing.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.cache.CacheTransaction;
@@ -213,7 +213,7 @@ public void initialize(Configuration config) {
             }
             idAuthority = null;
             if (storeFeatures.isKeyConsistent()) {
-                idAuthority = new ConsistentKeyIDManager(idStore, storeManager, config);
+                idAuthority = new ConsistentKeyIDAuthority(idStore, storeManager, config);
             } else {
                 throw new IllegalStateException("Store needs to support consistent key or transactional operations for ID manager to guarantee proper id allocations");
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDAuthority.java
Patch:
@@ -19,7 +19,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public abstract class AbstractIDManager implements IDAuthority {
+public abstract class AbstractIDAuthority implements IDAuthority {
 
     /* This value can't be changed without either
       * corrupting existing ID allocations or taking
@@ -38,7 +38,7 @@ public abstract class AbstractIDManager implements IDAuthority {
     private IDBlockSizer blockSizer;
     private volatile boolean isActive;
 
-    public AbstractIDManager(Configuration config) {
+    public AbstractIDAuthority(Configuration config) {
         this.uid = config.get(UNIQUE_INSTANCE_ID);
 
         this.uidBytes = uid.getBytes();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDAuthority.java
Patch:
@@ -47,9 +47,9 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class ConsistentKeyIDManager extends AbstractIDManager implements BackendOperation.TransactionalProvider {
+public class ConsistentKeyIDAuthority extends AbstractIDAuthority implements BackendOperation.TransactionalProvider {
 
-    private static final Logger log = LoggerFactory.getLogger(ConsistentKeyIDManager.class);
+    private static final Logger log = LoggerFactory.getLogger(ConsistentKeyIDAuthority.class);
 
     private static final StaticBuffer LOWER_SLICE = BufferUtil.zeroBuffer(16);
     private static final StaticBuffer UPPER_SLICE = BufferUtil.oneBuffer(16);
@@ -76,7 +76,7 @@ public class ConsistentKeyIDManager extends AbstractIDManager implements Backend
 
     private final Random random = new Random();
 
-    public ConsistentKeyIDManager(KeyColumnValueStore idStore, StoreManager manager, Configuration config) throws StorageException {
+    public ConsistentKeyIDAuthority(KeyColumnValueStore idStore, StoreManager manager, Configuration config) throws StorageException {
         super(config);
         Preconditions.checkArgument(manager.getFeatures().isKeyConsistent());
         this.manager = manager;

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/inmemory/InMemoryIDAuthorityTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.inmemory;
 
-import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
+import com.thinkaurelius.titan.diskstorage.IDAuthorityTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
@@ -10,7 +10,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class InMemoryIDAllocationTest extends IDAllocationTest {
+public class InMemoryIDAuthorityTest extends IDAuthorityTest {
 
     /**
      * The IDAllocationTest assumes that every StoreManager returned by
@@ -25,7 +25,7 @@ public class InMemoryIDAllocationTest extends IDAllocationTest {
      */
     private final InMemoryStoreManager sharedManager;
 
-    public InMemoryIDAllocationTest(WriteConfiguration baseConfig) {
+    public InMemoryIDAuthorityTest(WriteConfiguration baseConfig) {
         super(baseConfig);
         sharedManager = new InMemoryStoreManager();
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxLogTest.java
Patch:
@@ -1,12 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
 import org.junit.BeforeClass;
+import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
+import com.thinkaurelius.titan.testcategory.SerialTests;
 
+@Category(SerialTests.class)
 public class AstyanaxLogTest extends KCVSLogTest {
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedLogTest.java
Patch:
@@ -1,12 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import org.junit.BeforeClass;
+import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
+import com.thinkaurelius.titan.testcategory.SerialTests;
 
+@Category(SerialTests.class)
 public class EmbeddedLogTest extends KCVSLogTest {
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftLogTest.java
Patch:
@@ -1,12 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
 import org.junit.BeforeClass;
+import org.junit.experimental.categories.Category;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
+import com.thinkaurelius.titan.testcategory.SerialTests;
 
+@Category(SerialTests.class)
 public class ThriftLogTest extends KCVSLogTest {
 
     @BeforeClass

File: titan-hbase-parent/titan-hbase-core/src/test/java/com/thinkaurelius/titan/HBaseStatus.java
Patch:
@@ -1,10 +1,9 @@
-package test.java.com.thinkaurelius.titan;
+package com.thinkaurelius.titan;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.FileReader;
-import java.io.FileWriter;
 import java.io.IOException;
 
 import org.elasticsearch.common.Preconditions;

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/BerkeleyStorageSetup.java
Patch:
@@ -8,7 +8,7 @@
 import org.apache.commons.configuration.BaseConfiguration;
 import org.apache.commons.configuration.Configuration;
 
-public class BerkeleyJeStorageSetup extends StorageSetup {
+public class BerkeleyStorageSetup extends StorageSetup {
 
     public static ModifiableConfiguration getBerkeleyJEConfiguration(String dir) {
         return buildConfiguration()

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyFixedLengthKCVSTest.java
Patch:
@@ -1,18 +1,18 @@
 package com.thinkaurelius.titan.diskstorage.berkeleyje;
 
 import com.google.common.collect.ImmutableMap;
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManagerAdapter;
 import org.junit.Test;
 
 
-public class BerkeleyDBjeKeyColumnValueTest extends KeyColumnValueStoreTest {
+public class BerkeleyFixedLengthKCVSTest extends KeyColumnValueStoreTest {
 
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyJeStorageSetup.getBerkeleyJEConfiguration());
+        BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyStorageSetup.getBerkeleyJEConfiguration());
         return new OrderedKeyValueStoreManagerAdapter(sm, ImmutableMap.of(storeName, 8));
     }
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyKeyValueTest.java
Patch:
@@ -1,16 +1,16 @@
 package com.thinkaurelius.titan.diskstorage.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManager;
 
 
-public class BerkeleyJEKeyValueTest extends KeyValueStoreTest {
+public class BerkeleyKeyValueTest extends KeyValueStoreTest {
 
     @Override
     public OrderedKeyValueStoreManager openStorageManager() throws StorageException {
-        return new BerkeleyJEStoreManager(BerkeleyJeStorageSetup.getBerkeleyJEConfiguration());
+        return new BerkeleyJEStoreManager(BerkeleyStorageSetup.getBerkeleyJEConfiguration());
     }
 
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyLogTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
@@ -9,10 +9,10 @@
 import org.junit.Test;
 
 
-public class BerkeleyJeLogTest extends KCVSLogTest {
+public class BerkeleyLogTest extends KCVSLogTest {
 
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyJeStorageSetup.getBerkeleyJEConfiguration());
+        BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyStorageSetup.getBerkeleyJEConfiguration());
         return new OrderedKeyValueStoreManagerAdapter(sm);
     }
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyVariableLengthKCVSTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
@@ -9,10 +9,10 @@
 import org.junit.Test;
 
 
-public class BerkeleyDBjeKeyColumnValueVariableTest extends KeyColumnValueStoreTest {
+public class BerkeleyVariableLengthKCVSTest extends KeyColumnValueStoreTest {
 
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyJeStorageSetup.getBerkeleyJEConfiguration());
+        BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyStorageSetup.getBerkeleyJEConfiguration());
         return new OrderedKeyValueStoreManagerAdapter(sm);
     }
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyGraphConcurrentTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanGraphConcurrentTest;
 
-public class BerkeleyJEGraphConcurrentTest extends TitanGraphConcurrentTest {
+public class BerkeleyGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     @Override
     public WriteConfiguration getConfiguration() {
-        return BerkeleyJeStorageSetup.getBerkeleyJEGraphConfiguration();
+        return BerkeleyStorageSetup.getBerkeleyJEGraphConfiguration();
     }
 
 }

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyGraphPerformanceMemoryTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanGraphPerformanceMemoryTest;
 
-public class BerkeleyJEGraphPerformanceMemoryTest extends TitanGraphPerformanceMemoryTest {
+public class BerkeleyGraphPerformanceMemoryTest extends TitanGraphPerformanceMemoryTest {
 
     @Override
     public WriteConfiguration getConfiguration() {
-        return BerkeleyJeStorageSetup.getBerkeleyJEGraphConfiguration();
+        return BerkeleyStorageSetup.getBerkeleyJEGraphConfiguration();
     }
 
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyGraphTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 
-public class BerkeleyJEGraphTest extends TitanGraphTest {
+public class BerkeleyGraphTest extends TitanGraphTest {
 
     @Override
     public WriteConfiguration getConfiguration() {
-        return BerkeleyJeStorageSetup.getBerkeleyJEGraphConfiguration();
+        return BerkeleyStorageSetup.getBerkeleyJEGraphConfiguration();
     }
 
 }

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyOLAPTest.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.olap.FulgoraOLAPTest;
 
-public class BerkeleyJEOLAPTest extends FulgoraOLAPTest {
+public class BerkeleyOLAPTest extends FulgoraOLAPTest {
 
     @Override
     public WriteConfiguration getConfiguration() {
-        return BerkeleyJeStorageSetup.getBerkeleyJEGraphConfiguration();
+        return BerkeleyStorageSetup.getBerkeleyJEGraphConfiguration();
     }
 
 }

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleySpeedComparisonPerformanceTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.berkeleyje;
 
-import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
+import com.thinkaurelius.titan.BerkeleyStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.SpeedComparisonPerformanceTest;
@@ -11,11 +11,11 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class BerkeleyJESpeedComparisonPerformanceTest extends SpeedComparisonPerformanceTest {
+public class BerkeleySpeedComparisonPerformanceTest extends SpeedComparisonPerformanceTest {
 
     @Override
     public WriteConfiguration getConfiguration() {
-        ModifiableConfiguration config = BerkeleyJeStorageSetup.getBerkeleyJEConfiguration();
+        ModifiableConfiguration config = BerkeleyStorageSetup.getBerkeleyJEConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_TRANSACTIONAL,false);
         return config.getConfiguration();
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/AbstractCassandraBlueprintsTest.java
Patch:
@@ -12,7 +12,7 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public abstract class BasicBlueprintsTest  extends TitanBlueprintsTest {
+public abstract class AbstractCassandraBlueprintsTest extends TitanBlueprintsTest {
 
     @Override
     public void afterSuite() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/EmbeddedBlueprintsTest.java
Patch:
@@ -7,7 +7,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class EmbeddedCassandraBlueprintsTest extends BasicBlueprintsTest {
+public class EmbeddedBlueprintsTest extends AbstractCassandraBlueprintsTest {
 
     @Override
     protected WriteConfiguration getGraphConfig() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/ThriftBlueprintsTest.java
Patch:
@@ -16,7 +16,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class InternalCassandraBlueprintsTest extends BasicBlueprintsTest {
+public class ThriftBlueprintsTest extends AbstractCassandraBlueprintsTest {
 
     @Override
     public void beforeSuite() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreTest.java
Patch:
@@ -23,10 +23,10 @@
 import com.thinkaurelius.titan.testcategory.OrderedKeyStoreTests;
 import com.thinkaurelius.titan.testcategory.UnorderedKeyStoreTests;
 
-public abstract class AbstractCassandraKeyColumnValueStoreTest extends KeyColumnValueStoreTest {
+public abstract class AbstractCassandraStoreTest extends KeyColumnValueStoreTest {
 
     private static final Logger log =
-            LoggerFactory.getLogger(AbstractCassandraKeyColumnValueStoreTest.class);
+            LoggerFactory.getLogger(AbstractCassandraStoreTest.class);
     private static final String TEST_CF_NAME = "testcf";
     private static final String DEFAULT_COMPRESSOR_PACKAGE = "org.apache.cassandra.io.compress";
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxIDAllocationTest.java
Patch:
@@ -7,9 +7,9 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
-public class InternalAstyanaxIDAllocationTest extends IDAllocationTest {
+public class AstyanaxIDAllocationTest extends IDAllocationTest {
 
-    public InternalAstyanaxIDAllocationTest(WriteConfiguration baseConfig) {
+    public AstyanaxIDAllocationTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxLockStoreTest.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class InternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
+public class AstyanaxLockStoreTest extends LockKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxLogTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
 
-public class InternalAstyanaxLogTest extends KCVSLogTest {
+public class AstyanaxLogTest extends KCVSLogTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxMultiWriteStoreTest.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class InternalAstyanaxMultiWriteKeyColumnValueTest extends MultiWriteKeyColumnValueStoreTest {
+public class AstyanaxMultiWriteStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreTest.java
Patch:
@@ -6,10 +6,10 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraKeyColumnValueStoreTest;
+import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreTest;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 
-public class InternalAstyanaxKeyColumnValueTest extends AbstractCassandraKeyColumnValueStoreTest {
+public class AstyanaxStoreTest extends AbstractCassandraStoreTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedIDAllocationTest.java
Patch:
@@ -6,9 +6,9 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class InternalCassandraEmbeddedIDAllocationTest extends IDAllocationTest {
+public class EmbeddedIDAllocationTest extends IDAllocationTest {
 
-    public InternalCassandraEmbeddedIDAllocationTest(WriteConfiguration baseConfig) {
+    public EmbeddedIDAllocationTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedLockStoreTest.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class InternalCassandraEmbeddedLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
+public class EmbeddedLockStoreTest extends LockKeyColumnValueStoreTest {
 
     @Override
     public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedLogTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
 
-public class InternalCassandraEmbeddedLogTest extends KCVSLogTest {
+public class EmbeddedLogTest extends KCVSLogTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedMultiWriteStoreTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class InternalCassandraEmbeddedMultiWriteKeyColumnValueStoreTest extends MultiWriteKeyColumnValueStoreTest {
+public class EmbeddedMultiWriteStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/EmbeddedStoreTest.java
Patch:
@@ -10,12 +10,12 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraKeyColumnValueStoreTest;
+import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreTest;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.testcategory.OrderedKeyStoreTests;
 
-public class InternalCassandraEmbeddedKeyColumnValueTest extends AbstractCassandraKeyColumnValueStoreTest {
+public class EmbeddedStoreTest extends AbstractCassandraStoreTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftDistributedStoreManagerTest.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.diskstorage.DistributedStoreManagerTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 
-public class InternalCassandraDistributedStoreManagerTest extends DistributedStoreManagerTest<CassandraThriftStoreManager> {
+public class ThriftDistributedStoreManagerTest extends DistributedStoreManagerTest<CassandraThriftStoreManager> {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftIDAllocationTest.java
Patch:
@@ -7,9 +7,9 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
-public class InternalCassandraIDAllocationTest extends IDAllocationTest {
+public class ThriftIDAllocationTest extends IDAllocationTest {
 
-    public InternalCassandraIDAllocationTest(WriteConfiguration baseConfig) {
+    public ThriftIDAllocationTest(WriteConfiguration baseConfig) {
         super(baseConfig);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftLockStoreTest.java
Patch:
@@ -9,7 +9,7 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
-public class InternalCassandraLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
+public class ThriftLockStoreTest extends LockKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftLogTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.KCVSLogTest;
 
-public class InternalCassandraLogTest extends KCVSLogTest {
+public class ThriftLogTest extends KCVSLogTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftMultiWriteStoreTest.java
Patch:
@@ -9,7 +9,7 @@
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
-public class InternalCassandraThriftMultiWriteKeyColumnValueStoreTest extends MultiWriteKeyColumnValueStoreTest {
+public class ThriftMultiWriteStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ThriftStoreTest.java
Patch:
@@ -6,10 +6,10 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraKeyColumnValueStoreTest;
+import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreTest;
 import com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager;
 
-public class InternalCassandraThriftKeyColumnValueTest extends AbstractCassandraKeyColumnValueStoreTest {
+public class ThriftStoreTest extends AbstractCassandraStoreTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/AstyanaxGraphConcurrentTest.java
Patch:
@@ -9,7 +9,7 @@
 import org.junit.experimental.categories.Category;
 
 @Category({PerformanceTests.class})
-public class InternalAstyanaxGraphConcurrentTest extends TitanGraphConcurrentTest {
+public class AstyanaxGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/AstyanaxGraphPerformanceMemoryTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.graphdb.TitanGraphPerformanceMemoryTest;
 
-public class InternalAstyanaxGraphPerformanceMemoryTest extends TitanGraphPerformanceMemoryTest {
+public class AstyanaxGraphPerformanceMemoryTest extends TitanGraphPerformanceMemoryTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/AstyanaxGraphTest.java
Patch:
@@ -7,7 +7,7 @@
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
-public class InternalAstyanaxGraphTest extends TitanGraphTest {
+public class AstyanaxGraphTest extends TitanGraphTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedEventualGraphTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanEventualGraphTest;
 
-public class InternalCassandraEmbeddedEventualGraphTest extends TitanEventualGraphTest {
+public class EmbeddedEventualGraphTest extends TitanEventualGraphTest {
 
     @BeforeClass
     public static void startEmbeddedCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedGraphConcurrentTest.java
Patch:
@@ -13,7 +13,7 @@
  */
 
 @Category({PerformanceTests.class})
-public class InternalCassandraEmbeddedGraphConcurrentTest extends TitanGraphConcurrentTest {
+public class EmbeddedGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedGraphMemoryPerformanceTest.java
Patch:
@@ -10,7 +10,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class InternalCassandraEmbeddedGraphMemoryPerformanceTest extends TitanGraphPerformanceMemoryTest {
+public class EmbeddedGraphMemoryPerformanceTest extends TitanGraphPerformanceMemoryTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/EmbeddedGraphTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 
-public class InternalCassandraEmbeddedGraphTest extends TitanGraphTest {
+public class EmbeddedGraphTest extends TitanGraphTest {
 
     @BeforeClass
     public static void startCassandra() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftElasticsearchTest.java
Patch:
@@ -13,9 +13,9 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanIndexTest;
 
-public class InternalCassandraElasticsearchTest extends TitanIndexTest {
+public class ThriftElasticsearchTest extends TitanIndexTest {
 
-    public InternalCassandraElasticsearchTest() {
+    public ThriftElasticsearchTest() {
         super(true, true, true);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftEventualGraphTest.java
Patch:
@@ -7,7 +7,7 @@
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
-public class InternalCassandraEventualGraphTest extends TitanEventualGraphTest {
+public class ThriftEventualGraphTest extends TitanEventualGraphTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphCacheTest.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 import org.junit.BeforeClass;
 
-public class InternalCassandraGraphCacheTest extends TitanGraphTest {
+public class ThriftGraphCacheTest extends TitanGraphTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphConcurrentTest.java
Patch:
@@ -9,7 +9,7 @@
 import org.junit.experimental.categories.Category;
 
 @Category({PerformanceTests.class})
-public class InternalCassandraGraphConcurrentTest extends TitanGraphConcurrentTest {
+public class ThriftGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphIterativeTest.java
Patch:
@@ -10,7 +10,7 @@
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import org.junit.BeforeClass;
 
-public class InternalCassandraGraphIterativeTest extends TitanGraphIterativeTest {
+public class ThriftGraphIterativeTest extends TitanGraphIterativeTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphMetricsTest.java
Patch:
@@ -6,7 +6,7 @@
 import org.junit.BeforeClass;
 import org.junit.Ignore;
 
-public class InternalCassandraGraphMetricsTest extends TitanNonTransactionalGraphMetricsTest {
+public class ThriftGraphMetricsTest extends TitanNonTransactionalGraphMetricsTest {
 
     @BeforeClass
     public static void beforeClass() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphPerformanceMemoryTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.graphdb.TitanGraphPerformanceMemoryTest;
 
-public class InternalCassandraGraphPerformanceMemoryTest extends TitanGraphPerformanceMemoryTest {
+public class ThriftGraphPerformanceMemoryTest extends TitanGraphPerformanceMemoryTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphSerialSpeedTest.java
Patch:
@@ -12,13 +12,13 @@
 import com.thinkaurelius.titan.testutil.gen.Schema;
 
 @Category({PerformanceTests.class})
-public class InternalCassandraGraphSerialSpeedTest extends TitanGraphSerialSpeedTest {
+public class ThriftGraphSerialSpeedTest extends TitanGraphSerialSpeedTest {
 
     private static StandardTitanGraph graph;
     private static Schema schema;
 
-    public InternalCassandraGraphSerialSpeedTest() throws StorageException {
-        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(InternalCassandraGraphSerialSpeedTest.class.getSimpleName()));
+    public ThriftGraphSerialSpeedTest() throws StorageException {
+        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(ThriftGraphSerialSpeedTest.class.getSimpleName()));
     }
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftGraphTest.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 import org.junit.BeforeClass;
 
-public class InternalCassandraGraphTest extends TitanGraphTest {
+public class ThriftGraphTest extends TitanGraphTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ThriftOLAPTest.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.olap.FulgoraOLAPTest;
 import org.junit.BeforeClass;
 
-public class InternalCassandraOLAPTest extends FulgoraOLAPTest {
+public class ThriftOLAPTest extends FulgoraOLAPTest {
 
     @Override
     public WriteConfiguration getConfiguration() {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -446,7 +446,7 @@ public BackendTransaction beginTransaction(TransactionConfiguration configuratio
         // Index transactions
         Map<String, IndexTransaction> indexTx = new HashMap<String, IndexTransaction>(indexes.size());
         for (Map.Entry<String, IndexProvider> entry : indexes.entrySet()) {
-            indexTx.put(entry.getKey(), new IndexTransaction(entry.getValue(), indexKeyRetriever.get(entry.getKey()), maxWriteTime));
+            indexTx.put(entry.getKey(), new IndexTransaction(entry.getValue(), indexKeyRetriever.get(entry.getKey()), configuration, maxWriteTime));
         }
 
         return new BackendTransaction(cacheTx, configuration, storeFeatures,

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexProvider.java
Patch:
@@ -2,6 +2,8 @@
 
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;
+import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
+import com.thinkaurelius.titan.diskstorage.TransactionHandleConfigurable;
 
 import java.util.List;
 import java.util.Map;
@@ -72,7 +74,7 @@ public interface IndexProvider extends IndexInformation {
      *
      * @return New Transaction Handle
      */
-    public TransactionHandle beginTransaction() throws StorageException;
+    public TransactionHandleConfigurable beginTransaction(TransactionHandleConfig config) throws StorageException;
 
     /**
      * Closes the index

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheEdge.java
Patch:
@@ -128,7 +128,7 @@ public byte getLifeCycle() {
     public void remove() {
         if (!tx().isRemovedRelation(super.getID())) {
             tx().removeRelation(this);
-        } else throw InvalidElementException.removedException(this);
+        }// else throw InvalidElementException.removedException(this);
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheProperty.java
Patch:
@@ -119,7 +119,7 @@ public byte getLifeCycle() {
     public void remove() {
         if (!tx().isRemovedRelation(super.getID())) {
             tx().removeRelation(this);
-        } else throw InvalidElementException.removedException(this);
+        }// else throw InvalidElementException.removedException(this);
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/StandardEdge.java
Patch:
@@ -88,6 +88,6 @@ public synchronized void remove() {
         if (!ElementLifeCycle.isRemoved(lifecycle)) {
             tx().removeRelation(this);
             lifecycle = ElementLifeCycle.update(lifecycle, ElementLifeCycle.Event.REMOVED);
-        } else throw InvalidElementException.removedException(this);
+        } //else throw InvalidElementException.removedException(this);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/StandardProperty.java
Patch:
@@ -88,6 +88,6 @@ public synchronized void remove() {
         if (!ElementLifeCycle.isRemoved(lifecycle)) {
             tx().removeRelation(this);
             lifecycle = ElementLifeCycle.update(lifecycle, ElementLifeCycle.Event.REMOVED);
-        } else throw InvalidElementException.removedException(this);
+        } //else throw InvalidElementException.removedException(this);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/StandardVertex.java
Patch:
@@ -89,7 +89,7 @@ public boolean hasAddedRelations() {
     @Override
     public synchronized void remove() {
         super.remove();
-        updateLifeCycle(ElementLifeCycle.Event.REMOVED);
+        ((StandardVertex)it()).updateLifeCycle(ElementLifeCycle.Event.REMOVED);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/util/system/ConfigurationPrinter.java
Patch:
@@ -24,7 +24,7 @@
  * the AsciiDoc documentation.
  */
 public class ConfigurationPrinter {
-    private static final String TABLE_HEADER_LINES = "[role=\"tss-config-table\",cols=\"2,3,1,1,1\",options=\"header\",]\n|=====\n| Name | Description | Datatype | Default Value | Mutability";
+    private static final String TABLE_HEADER_LINES = "[role=\"tss-config-table\",cols=\"2,3,1,1,1\",options=\"header\",width=\"100%\"]\n|=====\n| Name | Description | Datatype | Default Value | Mutability";
     private static final String DELIM = "|";
     private static final String DELIM_PADDING = " ";
     private static final String TABLE_FOOTER_LINES = "|=====\n";
@@ -78,7 +78,7 @@ private void printNamespace(ConfigNamespace n, String prefix) {
 
     private String getNamespaceSectionHeader(ConfigNamespace n) {
         String fullName = ConfigElement.getPath(n);
-        return "=== " + fullName + " ===\n" + n.getDescription() + "\n";
+        return "==== " + fullName + " ====\n" + n.getDescription() + "\n";
     }
 
     private List<ConfigOption<?>> getSortedChildOptions(ConfigNamespace n) {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -1,13 +1,13 @@
 package com.thinkaurelius.titan;
 
 import static com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager.CASSANDRA_KEYSPACE;
-import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.IDS_PARTITION;
+import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.CLUSTER_PARTITION;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
@@ -53,7 +53,7 @@ public static ModifiableConfiguration getEmbeddedConfiguration(String ks) {
 
     public static ModifiableConfiguration getEmbeddedCassandraPartitionConfiguration(String ks) {
         ModifiableConfiguration config = getEmbeddedConfiguration(ks);
-        config.set(IDS_PARTITION, true);
+        config.set(CLUSTER_PARTITION, true);
         config.set(IDS_FLUSH,false);
 //        config.subset(GraphDatabaseConfiguration.METRICS_NAMESPACE).addProperty(GraphDatabaseConfiguration.METRICS_CONSOLE_INTERVAL, 3000L);
         return config;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/QueryException.java
Patch:
@@ -1,7 +1,8 @@
 package com.thinkaurelius.titan.core;
 
 /**
- * Exception thrown when a user defined query is invalid or could not be processed.
+ * Exception thrown when a user defined query (e.g. a {@link TitanVertex} or {@link TitanGraphQuery})
+ * is invalid or could not be processed.
  *
  * @author Matthias Br&ouml;cheler (http://www.matthiasb.com)
  */

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/AttributeHandler.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.core;
+package com.thinkaurelius.titan.core.attribute;
 
 /**
  * Allows custom handling of attributes inside Titan when it comes to a) data validation and b) conversion
@@ -19,7 +19,7 @@ public interface AttributeHandler<V> {
     public void verifyAttribute(V value);
 
     /**
-     * Converts the given (not-null) value to the this datatype V.
+     * Converts the given (not-null) value to the expected datatype V.
      * The given object will NOT be of type V.
      * Throws an {@link IllegalArgumentException} if it cannot be converted.
      *

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Duration.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.core.attribute;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Geoshape.java
Patch:
@@ -5,7 +5,6 @@
 import com.spatial4j.core.distance.DistanceUtils;
 import com.spatial4j.core.shape.Shape;
 import com.spatial4j.core.shape.SpatialRelation;
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.idhandling.VariableLong;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/olap/StateInitializer.java
Patch:
@@ -7,7 +7,7 @@
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface StateInitializer<S> {
+public interface StateInitializer<S extends State<S>> {
 
     public S initialState();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/ConsistencyModifier.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.core;
+package com.thinkaurelius.titan.core.schema;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/Mapping.java
Patch:
@@ -1,11 +1,11 @@
-package com.thinkaurelius.titan.core;
+package com.thinkaurelius.titan.core.schema;
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.indexing.KeyInformation;
 
 /**
  * Used to change the default mapping of an indexed key by providing the mapping explicitly as a parameter to
- * {@link com.thinkaurelius.titan.core.KeyMaker#indexed(String, Class, com.thinkaurelius.titan.core.Parameter[])}.
+ * {@link PropertyKeyMaker#indexed(String, Class, Parameter[])}.
  *
  * <p/>
  *

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/Parameter.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.core;
+package com.thinkaurelius.titan.core.schema;
 
 import com.google.common.base.Preconditions;
 import org.apache.commons.lang.StringUtils;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/ParameterType.java
Patch:
@@ -1,7 +1,6 @@
-package com.thinkaurelius.titan.core;
+package com.thinkaurelius.titan.core.schema;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.diskstorage.indexing.KeyInformation;
 import org.apache.commons.lang.StringUtils;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/core/schema/TitanConfiguration.java
Patch:
@@ -1,6 +1,8 @@
-package com.thinkaurelius.titan.core;
+package com.thinkaurelius.titan.core.schema;
 
 /**
+ *
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public interface TitanConfiguration {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/util/TitanCleanup.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.core.TitanConfigurationException;
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.core.TitanFactory;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDManager;
 import com.thinkaurelius.titan.diskstorage.indexing.*;
@@ -91,7 +91,7 @@ public class Backend implements LockerProvider {
     public static final Map<String, Integer> STATIC_KEY_LENGTHS = new HashMap<String, Integer>() {{
         put(EDGESTORE_NAME, 8);
         put(EDGESTORE_NAME + LOCK_STORE_SUFFIX, 8);
-        put(ID_STORE_NAME, 4);
+        put(ID_STORE_NAME, 8);
     }};
 
     private final KeyColumnValueStoreManager storeManager;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/UserModifiableConfiguration.java
Patch:
@@ -1,8 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.configuration;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.TitanConfiguration;
-import com.thinkaurelius.titan.diskstorage.configuration.*;
+import com.thinkaurelius.titan.core.schema.TitanConfiguration;
 
 import java.lang.reflect.Array;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/CommonsConfiguration.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.Durations;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.Durations;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ReadConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/KeyInformation.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.thinkaurelius.titan.core.Cardinality;
-import com.thinkaurelius.titan.core.Parameter;
+import com.thinkaurelius.titan.core.schema.Parameter;
 
 /**
  * Helper class that provides information on the data type and additional parameters that

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/RawQuery.java
Patch:
@@ -1,9 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.Parameter;
+import com.thinkaurelius.titan.core.schema.Parameter;
 import com.thinkaurelius.titan.graphdb.query.BaseQuery;
-import com.thinkaurelius.titan.graphdb.query.Query;
 import org.apache.commons.lang.StringUtils;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/StandardKeyInformation.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.Cardinality;
-import com.thinkaurelius.titan.core.Parameter;
+import com.thinkaurelius.titan.core.schema.Parameter;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KeyColumnValueStoreManager.java
Patch:
@@ -41,4 +41,6 @@ public interface KeyColumnValueStoreManager extends StoreManager {
     public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, StoreTransaction txh) throws StorageException;
 
 
+
+
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KeyRange.java
Patch:
@@ -3,6 +3,8 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 
 /**
+ * A range of bytes between start and end where start is inclusive and end is exclusive.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public class KeyRange {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediator.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Timepoint;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediatorProvider.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediators.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LockStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 
 /**
  * A single held lock's expiration time. This is used by {@link AbstractLocker}.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.locking.LockStatus;
 
 import java.util.concurrent.TimeUnit;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSMessage.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.log.kcvs;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.util.AbstractMessage;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/util/AbstractMessage.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.log.util;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.Message;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/util/ProcessMessageJob.java
Patch:
@@ -28,6 +28,7 @@ public ProcessMessageJob(final Message message, final MessageReader reader) {
     @Override
     public void run() {
         try {
+            log.debug("Passing {} to {}", message, reader);
             reader.read(message);
         } catch (Throwable e) {
             log.error("Encountered exception when processing message ["+message+"] by reader ["+reader+"]:",e);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/BackendOperation.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.StandardDuration;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/StandardTimepoint.java
Patch:
@@ -1,6 +1,7 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/Timer.java
Patch:
@@ -1,8 +1,9 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
 
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 /**
  * A utility to measure time durations.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/TimestampProvider.java
Patch:
@@ -1,4 +1,6 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
+
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/Timestamps.java
Patch:
@@ -1,7 +1,8 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
 
 import java.util.concurrent.TimeUnit;
 
+import com.thinkaurelius.titan.core.attribute.Duration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/RegisteredAttributeClass.java
Patch:
@@ -1,8 +1,7 @@
 package com.thinkaurelius.titan.graphdb.configuration;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.AttributeHandler;
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeHandler;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/RelationFactory.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database;
 
-import com.thinkaurelius.titan.core.TitanType;
+import com.thinkaurelius.titan.core.RelationType;
 import com.tinkerpop.blueprints.Direction;
 
 /**
@@ -13,14 +13,14 @@ public interface RelationFactory {
 
     public void setDirection(Direction dir);
 
-    public void setType(TitanType type);
+    public void setType(RelationType type);
 
     public void setRelationID(long relationID);
 
     public void setOtherVertexID(long vertexId);
 
     public void setValue(Object value);
 
-    public void addProperty(TitanType type, Object value);
+    public void addProperty(RelationType type, Object value);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/RelationReader.java
Patch:
@@ -9,6 +9,6 @@
  */
 public interface RelationReader {
 
-    public RelationCache parseRelation(long vertexid, Entry data, boolean parseHeaderOnly, TypeInspector tx);
+    public RelationCache parseRelation(Entry data, boolean parseHeaderOnly, TypeInspector tx);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StaticIDBlockSizer.java
Patch:
@@ -20,12 +20,12 @@ public StaticIDBlockSizer(long blockSize, long blockSizeLimit) {
     }
 
     @Override
-    public long getBlockSize(int partitionID) {
+    public long getBlockSize(int idNamespace) {
         return blockSize;
     }
 
     @Override
-    public long getIdUpperBound(int partitionID) {
+    public long getIdUpperBound(int idNamespace) {
         return blockSizeLimit;
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/placement/DefaultPlacementStrategy.java
Patch:
@@ -27,7 +27,7 @@ public DefaultPlacementStrategy() {
     }
 
     @Override
-    public int getPartition(InternalElement vertex) {
+    public int getPartition(InternalElement element) {
         return partitionID;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/placement/IDPlacementStrategy.java
Patch:
@@ -20,10 +20,10 @@ public interface IDPlacementStrategy {
     /**
      * Individually assigns an id to the given vertex or relation.
      *
-     * @param vertex Vertex or relation to assign id to.
+     * @param element Vertex or relation to assign id to.
      * @return
      */
-    public int getPartition(InternalElement vertex);
+    public int getPartition(InternalElement element);
 
     /**
      * Bulk assignment of idAuthorities to vertices.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/placement/SimpleBulkPlacementStrategy.java
Patch:
@@ -66,7 +66,7 @@ private final void updateElement(int index) {
     }
 
     @Override
-    public int getPartition(InternalElement vertex) {
+    public int getPartition(InternalElement element) {
         return nextPartitionID();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/log/TransactionLogHeader.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.graphdb.database.log;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.StandardTimepoint;
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardTimepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
 import com.thinkaurelius.titan.graphdb.transaction.TransactionConfiguration;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 import java.util.EnumMap;
 import java.util.concurrent.TimeUnit;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/AttributeHandling.java
Patch:
@@ -1,8 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
-import com.thinkaurelius.titan.core.AttributeHandler;
-import com.thinkaurelius.titan.core.AttributeSerializer;
-import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.core.attribute.AttributeHandler;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/AttributeUtil.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
-import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.core.attribute.Decimal;
 import com.thinkaurelius.titan.core.attribute.Precision;
 import org.slf4j.Logger;
@@ -78,7 +78,7 @@ public static final Integer compare(Object a, Object b) {
         }
     }
 
-    public static boolean hasGenericDataType(TitanKey key) {
+    public static boolean hasGenericDataType(PropertyKey key) {
         return key.getDataType().equals(Object.class);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/Serializer.java
Patch:
@@ -1,7 +1,5 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
-import com.thinkaurelius.titan.core.AttributeHandler;
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 
 public interface Serializer extends AttributeHandling {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -4,6 +4,7 @@
 import com.google.common.collect.ImmutableList;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.*;
+import com.thinkaurelius.titan.core.schema.*;
 import com.thinkaurelius.titan.graphdb.database.log.LogTxStatus;
 import com.thinkaurelius.titan.graphdb.database.management.MgmtLogType;
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.*;
@@ -12,8 +13,8 @@
 import com.thinkaurelius.titan.graphdb.types.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionDescription;
-import com.thinkaurelius.titan.util.time.StandardDuration;
-import com.thinkaurelius.titan.util.time.StandardTimepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardTimepoint;
 import com.tinkerpop.blueprints.Direction;
 
 import java.util.*;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardSerializer.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/AbstractDecimal.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.AttributeUtil;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/BooleanArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/BooleanSerializer.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ByteSerializer.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/CharArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/CharacterSerializer.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/DateSerializer.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/DoubleArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/DoubleSerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/FloatArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/FloatSerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/IntArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/IntegerSerializer.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.idhandling.VariableLong;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/LongArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/LongSerializer.java
Patch:
@@ -1,10 +1,8 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.core.Idfiable;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
-import com.thinkaurelius.titan.graphdb.database.idhandling.VariableLong;
 import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
 public class LongSerializer implements OrderPreservingSerializer<Long> {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ShortArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ShortSerializer.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StringArraySerializer.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
 
-import com.thinkaurelius.titan.core.AttributeSerializer;
+import com.thinkaurelius.titan.core.attribute.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/And.java
Patch:
@@ -3,9 +3,10 @@
 import com.thinkaurelius.titan.core.TitanElement;
 
 /**
+ * Combines multiple conditions under semantic AND, i.e. all conditions must be true for this combination to be true
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public class And<E extends TitanElement> extends MultiCondition<E> {
 
     public And(Condition<E>... elements) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/ConditionUtil.java
Patch:
@@ -7,9 +7,10 @@
 import javax.annotation.Nullable;
 
 /**
+ * Utility methods for transforming and inspecting {@link Condition}s.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public class ConditionUtil {
 
     public static final<E extends TitanElement> Condition<E> literalTransformation(Condition<E> condition, final Function<Condition<E>,Condition<E>> transformation) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/FixedCondition.java
Patch:
@@ -4,9 +4,10 @@
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**
+ * A fixed valued literal, which always returns either true or false irrespective of the element which is evaluated.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public class FixedCondition<E extends TitanElement> extends Literal<E> {
 
     private final boolean value;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/Literal.java
Patch:
@@ -5,9 +5,10 @@
 import com.thinkaurelius.titan.core.TitanElement;
 
 /**
+ * Abstract literal condition.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 abstract class Literal<E extends TitanElement> implements Condition<E> {
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/Not.java
Patch:
@@ -7,9 +7,10 @@
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**
+ * Negates the wrapped condition, i.e. semantic NOT
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public class Not<E extends TitanElement> implements Condition<E> {
 
     private final Condition<E> condition;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/Or.java
Patch:
@@ -3,6 +3,8 @@
 import com.thinkaurelius.titan.core.TitanElement;
 
 /**
+ * Combines multiple conditions under semantic OR, i.e. at least one condition must be true for this combination to be true
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/VertexFactory.java
Patch:
@@ -7,6 +7,6 @@
  */
 public interface VertexFactory {
 
-    public InternalVertex getExistingVertex(long id);
+    public InternalVertex getInternalVertex(long id);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/VertexIterable.java
Patch:
@@ -36,7 +36,7 @@ private InternalVertex nextVertex() {
                     //Filter out hidden vertices
                     if (IDManager.VertexIDType.Hidden.is(nextId)) continue;
 
-                    v = tx.getExistingVertex(nextId);
+                    v = tx.getInternalVertex(nextId);
                     //Filter out deleted vertices and types
                     if (v.isRemoved()) v = null;
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/indexcache/ConcurrentIndexCache.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.transaction.indexcache;
 
 import com.google.common.collect.HashMultimap;
-import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.core.TitanProperty;
 
 import java.util.ArrayList;
@@ -30,7 +30,7 @@ public synchronized void remove(TitanProperty property) {
     }
 
     @Override
-    public synchronized Iterable<TitanProperty> get(final Object value, final TitanKey key) {
+    public synchronized Iterable<TitanProperty> get(final Object value, final PropertyKey key) {
         List<TitanProperty> result = new ArrayList<TitanProperty>(4);
         for (TitanProperty p : map.get(value)) {
             if (p.getPropertyKey().equals(key)) result.add(p);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/indexcache/IndexCache.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.indexcache;
 
-import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.core.TitanProperty;
 
 /**
@@ -12,6 +12,6 @@ public interface IndexCache {
 
     public void remove(TitanProperty property);
 
-    public Iterable<TitanProperty> get(Object value, TitanKey key);
+    public Iterable<TitanProperty> get(Object value, PropertyKey key);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/indexcache/SimpleIndexCache.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Iterables;
-import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.core.TitanProperty;
 
 import javax.annotation.Nullable;
@@ -31,7 +31,7 @@ public void remove(TitanProperty property) {
     }
 
     @Override
-    public Iterable<TitanProperty> get(final Object value, final TitanKey key) {
+    public Iterable<TitanProperty> get(final Object value, final PropertyKey key) {
         return Iterables.filter(map.get(value),new Predicate<TitanProperty>() {
             @Override
             public boolean apply(@Nullable TitanProperty titanProperty) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/CombinerLock.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.Timer;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.Timer;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/FakeLock.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/ReentrantTransactionLock.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/TransactionLock.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/ExternalIndexType.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.types;
 
-import com.thinkaurelius.titan.core.Parameter;
-import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.core.PropertyKey;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -10,7 +9,7 @@ public interface ExternalIndexType extends IndexType {
 
     public ParameterIndexField[] getFieldKeys();
 
-    public ParameterIndexField getField(TitanKey key);
+    public ParameterIndexField getField(PropertyKey key);
 
     public String getStoreName();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/InternalIndexType.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.types;
 
 import com.thinkaurelius.titan.core.Cardinality;
-import com.thinkaurelius.titan.core.ConsistencyModifier;
+import com.thinkaurelius.titan.core.schema.ConsistencyModifier;
 
 /**
 * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/EdgeLabelVertex.java
Patch:
@@ -1,13 +1,13 @@
 package com.thinkaurelius.titan.graphdb.types.vertices;
 
-import com.thinkaurelius.titan.core.TitanLabel;
+import com.thinkaurelius.titan.core.EdgeLabel;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.tinkerpop.blueprints.Direction;
 
-public class TitanLabelVertex extends TitanTypeVertex implements TitanLabel {
+public class EdgeLabelVertex extends RelationTypeVertex implements EdgeLabel {
 
-    public TitanLabelVertex(StandardTitanTx tx, long id, byte lifecycle) {
+    public EdgeLabelVertex(StandardTitanTx tx, long id, byte lifecycle) {
         super(tx, id, lifecycle);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/PropertyKeyVertex.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.types.vertices;
 
 import com.thinkaurelius.titan.core.Cardinality;
-import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.core.PropertyKey;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.tinkerpop.blueprints.Direction;
 
-public class TitanKeyVertex extends TitanTypeVertex implements TitanKey {
+public class PropertyKeyVertex extends RelationTypeVertex implements PropertyKey {
 
-    public TitanKeyVertex(StandardTitanTx tx, long id, byte lifecycle) {
+    public PropertyKeyVertex(StandardTitanTx tx, long id, byte lifecycle) {
         super(tx, id, lifecycle);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/AllEdgesIterable.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.util.traversal;
+package com.thinkaurelius.titan.graphdb.util;
 
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Vertex;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/AllEdgesIterator.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.util.traversal;
+package com.thinkaurelius.titan.graphdb.util;
 
 import com.google.common.collect.Iterators;
 import com.tinkerpop.blueprints.Direction;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/ElementHelper.java
Patch:
@@ -4,7 +4,9 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.*;
+import com.thinkaurelius.titan.graphdb.idmanagement.IDInspector;
 import com.thinkaurelius.titan.graphdb.query.vertex.VertexCentricQueryBuilder;
+import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 
 import javax.annotation.Nullable;
 import java.util.Collections;
@@ -14,7 +16,7 @@
  */
 public class ElementHelper {
 
-    public static final Iterable<Object> getValues(TitanElement element, TitanKey key) {
+    public static final Iterable<Object> getValues(TitanElement element, PropertyKey key) {
         if (element instanceof TitanRelation) {
             Object value = element.getProperty(key);
             if (value==null) return Collections.EMPTY_LIST;
@@ -31,5 +33,4 @@ public Object apply(@Nullable TitanProperty titanProperty) {
         }
     }
 
-
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -155,7 +155,6 @@ private static StaticBuffer getPrefixed(int prefix) {
         return new StaticArrayBuffer(arr);
     }
 
-    //Assumes not hidden!
     public static StaticBuffer[] getBounds(RelationCategory type, boolean systemTypes) {
         int start, end;
         switch (type) {

File: titan-hadoop/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -102,7 +102,7 @@ public RelationReader getRelationReader(long vertexid) {
     @Override
     public SliceQuery inputSlice(final VertexQueryFilter inputFilter) {
         if (inputFilter.limit == 0) {
-            final StaticBuffer[] endPoints = IDHandler.getBounds(RelationCategory.PROPERTY);
+            final StaticBuffer[] endPoints = IDHandler.getBounds(RelationCategory.PROPERTY,false);
             return new SliceQuery(endPoints[0], endPoints[1]).setLimit(Integer.MAX_VALUE);
         } else {
             return super.inputSlice(inputFilter);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/ReadMarker.java
Patch:
@@ -3,6 +3,7 @@
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -82,7 +82,7 @@ public<O> O computeProperty(InternalElement e) {
                 } else {
                     assert this==TIMESTAMP || this==TTL;
                     Long time = r.getPropertyDirect(this);
-                    TimeUnit unit = r.tx().getConfiguration().getStartTime().getNativeUnit();
+                    TimeUnit unit = r.tx().getConfiguration().getTimestampProvider().getUnit();
                     if (this==TIMESTAMP) return (O)new StandardTimestamp(time,unit);
                     else return (O)new StandardDuration(time,unit);
                 }

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/log/KCVSLogTest.java
Patch:
@@ -7,8 +7,8 @@
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.log.kcvs.KCVSLogManager;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.util.time.StandardDuration;
 
 /**
  * Implemention of the {@link LogTest} for {@link KCVSLogManager} based log implementations.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/util/ProcessMessageJob.java
Patch:
@@ -28,6 +28,7 @@ public ProcessMessageJob(final Message message, final MessageReader reader) {
     @Override
     public void run() {
         try {
+            log.debug("Passing {} to {}", message, reader);
             reader.read(message);
         } catch (Throwable e) {
             log.error("Encountered exception when processing message ["+message+"] by reader ["+reader+"]:",e);

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/BasicBlueprintsTest.java
Patch:
@@ -15,12 +15,12 @@
 public abstract class BasicBlueprintsTest  extends TitanBlueprintsTest {
 
     @Override
-    public void shutDown() {
+    public void afterSuite() {
         //Do nothing
     }
 
     @Override
-    public void startUp() {
+    public void beforeSuite() {
         //Do nothing
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/InternalCassandraBlueprintsTest.java
Patch:
@@ -19,7 +19,7 @@
 public class InternalCassandraBlueprintsTest extends BasicBlueprintsTest {
 
     @Override
-    public void startUp() {
+    public void beforeSuite() {
         CassandraStorageSetup.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 

File: titan-hbase-parent/common/test/java/com/thinkaurelius/titan/blueprints/HBaseBlueprintsTest.java
Patch:
@@ -15,7 +15,7 @@
 public class HBaseBlueprintsTest extends TitanBlueprintsTest {
 
     @Override
-    public void startUp() {
+    public void beforeSuite() {
         try {
             HBaseStorageSetup.startHBase();
         } catch (IOException e) {
@@ -24,7 +24,7 @@ public void startUp() {
     }
 
     @Override
-    public void shutDown() {
+    public void afterSuite() {
         // we don't need to restart on each test because cleanup is in please
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/blueprints/InMemoryBlueprintsTest.java
Patch:
@@ -35,12 +35,12 @@ public boolean supportsMultipleGraphs() {
     }
 
     @Override
-    public void startUp() {
+    public void beforeSuite() {
 
     }
 
     @Override
-    public void shutDown() {
+    public void afterSuite() {
 
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraExecutor.java
Patch:
@@ -100,13 +100,13 @@ S getVertexState(long vertexId) {
         S state = vertexStates.get(vertexId);
         if (state==null) {
             state = initializer.initialState();
-            vertexStates.set(vertexId,state);
+            vertexStates.set(vertexId, state);
         }
         return state;
     }
 
     void setVertexState(long vertexId, S state) {
-        vertexStates.set(vertexId,state);
+        vertexStates.set(vertexId, state);
     }
 
     @Override
@@ -218,7 +218,7 @@ public TitanRelation apply(@Nullable Entry data) {
 
     private final VertexFactory neighborVertices = new VertexFactory() {
         @Override
-        public InternalVertex getExistingVertex(long id) {
+        public InternalVertex getInternalVertex(long id) {
             return new FulgoraNeighborVertex(id,FulgoraExecutor.this);
         }
     };

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/VisibilityFilterCondition.java
Patch:
@@ -28,7 +28,8 @@ public VisibilityFilterCondition(Visibility visibility) {
     public boolean evaluate(E element) {
         switch(visibility) {
             case NORMAL: return !((InternalElement)element).isHidden();
-            case SYSTEM: return (element instanceof TitanRelation && element instanceof SystemRelationType)
+            case SYSTEM: return (element instanceof TitanRelation &&
+                                    ((TitanRelation)element).getType() instanceof SystemRelationType)
                     || (element instanceof TitanVertex && element instanceof TitanSchemaElement);
             default: throw new AssertionError("Unrecognized visibility: " + visibility);
         }
@@ -47,6 +48,6 @@ public boolean equals(Object other) {
 
     @Override
     public String toString() {
-        return "!hidden";
+        return "visibility:"+visibility.toString().toLowerCase();
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/MultiVertexCentricQueryBuilder.java
Patch:
@@ -85,7 +85,7 @@ protected<Q> Map<TitanVertex,Q> execute(RelationCategory returnType, ResultConst
             for (BackendQueryHolder<SliceQuery> sq : bq.getQueries()) {
                 Set<InternalVertex> adjVertices = Sets.newHashSet(vertices);
                 for (InternalVertex v : vertices) {
-                    if (tx.isPartitionedVertex(v)) {
+                    if (isPartitionedVertex(v)) {
                         adjVertices.remove(v);
                         adjVertices.addAll(allRepresentatives(v));
                     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexCentricQueryBuilder.java
Patch:
@@ -65,7 +65,7 @@ protected VertexCentricQueryBuilder getThis() {
     protected<Q> Q execute(RelationCategory returnType, ResultConstructor<Q> resultConstructor) {
         BaseVertexCentricQuery bq = super.constructQuery(returnType);
         if (bq.isEmpty()) return resultConstructor.emptyResult();
-        if (tx.isPartitionedVertex(vertex)) {
+        if (isPartitionedVertex(vertex)) {
             List<InternalVertex> vertices = allRepresentatives(vertex);
             if (vertices.size()>1) {
                 for (BackendQueryHolder<SliceQuery> sq : bq.getQueries()) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/VertexLongList.java
Patch:
@@ -2,7 +2,6 @@
 
 import cern.colt.list.AbstractLongList;
 import cern.colt.list.LongArrayList;
-import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.core.VertexList;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
@@ -51,7 +50,7 @@ public AbstractLongList getIDs() {
 
     @Override
     public TitanVertex get(int pos) {
-        return tx.getExistingVertex(getID(pos));
+        return tx.getInternalVertex(getID(pos));
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -144,7 +144,7 @@ public <O> O getProperty(String key) {
     public TitanVertex getProperty(EdgeLabel label) {
         Object val = it().getPropertyDirect(label);
         if (val==null) return null;
-        else if (val instanceof Number) return tx().getExistingVertex(((Number)val).longValue());
+        else if (val instanceof Number) return tx().getInternalVertex(((Number) val).longValue());
         else if (val instanceof TitanVertex) return (TitanVertex) val;
         else throw new IllegalStateException("Invalid object found instead of vertex: " + val);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/RelationConstructor.java
Patch:
@@ -80,7 +80,7 @@ private static InternalRelation readRelation(final InternalVertex vertex, final
         }
 
         if (type.isEdgeLabel()) {
-            InternalVertex otherVertex = vertexFac.getExistingVertex(relation.getOtherVertexId());
+            InternalVertex otherVertex = vertexFac.getInternalVertex(relation.getOtherVertexId());
             switch (relation.direction) {
                 case IN:
                     return new CacheEdge(relation.relationId, (EdgeLabel) type, otherVertex, vertex, data);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/VertexFactory.java
Patch:
@@ -7,6 +7,6 @@
  */
 public interface VertexFactory {
 
-    public InternalVertex getExistingVertex(long id);
+    public InternalVertex getInternalVertex(long id);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/VertexIterable.java
Patch:
@@ -36,7 +36,7 @@ private InternalVertex nextVertex() {
                     //Filter out hidden vertices
                     if (IDManager.VertexIDType.Hidden.is(nextId)) continue;
 
-                    v = tx.getExistingVertex(nextId);
+                    v = tx.getInternalVertex(nextId);
                     //Filter out deleted vertices and types
                     if (v.isRemoved()) v = null;
                 }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -698,6 +698,7 @@ public void testTransaction() {
         assertFalse(v3.isRemoved());
         newTx();
 
+
         TitanTransaction tx3 = graph.buildTransaction().checkInternalVertexExistence().start();
         v21 = tx3.getVertex(v21.getID());
         v3 = (TitanVertex) Iterables.getOnlyElement(v21.getVertices(OUT, "link"));

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/IDManagementTest.java
Patch:
@@ -83,10 +83,12 @@ public void testEntityID(int partitionBits, int partition, long minCount, long m
         for (long count=minCount;count<maxCount;count++) {
 
             for (IDManager.VertexIDType vtype : USER_VERTEX_TYPES) {
+                if (partitionBits==0 && vtype== IDManager.VertexIDType.PartitionedVertex) continue;
+                if (vtype== IDManager.VertexIDType.PartitionedVertex) partition=IDManager.PARTITIONED_VERTEX_PARTITION;
                 long id = eid.getVertexID(count, partition,vtype);
                 assertTrue(isp.isUserVertexId(id));
                 assertTrue(vtype.is(id));
-                assertEquals(eid.getPartitionId(id), partition);
+                if (vtype != IDManager.VertexIDType.PartitionedVertex) assertEquals(eid.getPartitionId(id), partition);
                 assertEquals(id, eid.getKeyID(eid.getKey(id)));
             }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanSchemaElement.java
Patch:
@@ -3,6 +3,6 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface TitanSchemaElement {
+public interface TitanSchemaElement extends Namifiable {
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanSchemaType.java
Patch:
@@ -3,5 +3,5 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public interface TitanSchemaType extends TitanSchemaElement, Namifiable {
+public interface TitanSchemaType extends TitanSchemaElement {
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraVertex.java
Patch:
@@ -23,6 +23,7 @@
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.VertexLabelVertex;
 import com.thinkaurelius.titan.graphdb.types.system.BaseLabel;
+import com.thinkaurelius.titan.graphdb.types.system.BaseVertexLabel;
 import com.thinkaurelius.titan.graphdb.types.system.SystemTypeManager;
 import com.thinkaurelius.titan.graphdb.vertices.AbstractVertex;
 import com.thinkaurelius.titan.graphdb.vertices.CacheVertex;
@@ -81,7 +82,7 @@ public VertexCentricQueryBuilder query() {
     @Override
     public VertexLabel getVertexLabel() {
         FulgoraNeighborVertex label = (FulgoraNeighborVertex)getVertexLabelInternal();
-        if (label==null) return SystemTypeManager.DEFAULT_VERTEXLABEL;
+        if (label==null) return BaseVertexLabel.DEFAULT_VERTEXLABEL;
         else return (VertexLabelVertex)tx().getExistingVertex(label.getID());
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyVertex.java
Patch:
@@ -68,7 +68,7 @@ public String getLabel() {
 
     @Override
     public VertexLabel getVertexLabel() {
-        return SystemTypeManager.DEFAULT_VERTEXLABEL;
+        return BaseVertexLabel.DEFAULT_VERTEXLABEL;
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -11,6 +11,7 @@
 import com.thinkaurelius.titan.graphdb.types.VertexLabelVertex;
 import com.thinkaurelius.titan.graphdb.types.system.BaseKey;
 import com.thinkaurelius.titan.graphdb.types.system.BaseLabel;
+import com.thinkaurelius.titan.graphdb.types.system.BaseVertexLabel;
 import com.thinkaurelius.titan.graphdb.types.system.SystemTypeManager;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
@@ -109,7 +110,7 @@ protected Vertex getVertexLabelInternal() {
     @Override
     public VertexLabel getVertexLabel() {
         Vertex label = getVertexLabelInternal();
-        if (label==null) return SystemTypeManager.DEFAULT_VERTEXLABEL;
+        if (label==null) return BaseVertexLabel.DEFAULT_VERTEXLABEL;
         else return (VertexLabelVertex)label;
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -192,7 +192,7 @@ public void testLockException() {
 
     public void testBatchLoadingLocking(boolean batchloading) {
         PropertyKey uid = makeKey("uid",Long.class);
-        TitanGraphIndex uidIndex = mgmt.createInternalIndex("uid",Vertex.class,true,uid);
+        TitanGraphIndex uidIndex = mgmt.buildIndex("uid",Vertex.class).unique().indexKey(uid).buildInternalIndex();
         mgmt.setConsistency(uid,ConsistencyModifier.LOCK);
         mgmt.setConsistency(uidIndex,ConsistencyModifier.LOCK);
         EdgeLabel knows = mgmt.makeEdgeLabel("knows").multiplicity(Multiplicity.ONE2ONE).make();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -221,13 +221,13 @@ private Log openLog(String logManagerName, String logName, ReadMarker readMarker
 
     public PropertyKey makeVertexIndexedKey(String name, Class datatype) {
         PropertyKey key = mgmt.makePropertyKey(name).dataType(datatype).cardinality(Cardinality.SINGLE).make();
-        mgmt.createInternalIndex(name,Vertex.class,key);
+        mgmt.buildIndex(name,Vertex.class).indexKey(key).buildInternalIndex();
         return key;
     }
 
     public PropertyKey makeVertexIndexedUniqueKey(String name, Class datatype) {
         PropertyKey key = mgmt.makePropertyKey(name).dataType(datatype).cardinality(Cardinality.SINGLE).make();
-        mgmt.createInternalIndex(name,Vertex.class,true,key);
+        mgmt.buildIndex(name,Vertex.class).indexKey(key).unique().buildInternalIndex();
         return key;
     }
 
@@ -243,7 +243,7 @@ public TitanGraphIndex getExternalIndex(Class<? extends Element> clazz, String b
         String indexName = (Vertex.class.isAssignableFrom(clazz)?"v":"e")+backingIndex;
         TitanGraphIndex index = mgmt.getGraphIndex(indexName);
         if (index==null) {
-            index = mgmt.createExternalIndex(indexName,clazz,backingIndex);
+            index = mgmt.buildIndex(indexName,clazz).buildExternalIndex(backingIndex);
         }
         return index;
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanNonTransactionalGraphMetricsTest.java
Patch:
@@ -191,7 +191,7 @@ public void checkFastPropertyFalse() {
 
     public void checkFastPropertyAndLocking(boolean fastProperty) {
         PropertyKey uid = makeKey("uid",String.class);
-        TitanGraphIndex index = mgmt.createInternalIndex("uid",Vertex.class,true,uid);
+        TitanGraphIndex index = mgmt.buildIndex("uid",Vertex.class).unique().indexKey(uid).buildInternalIndex();
         mgmt.setConsistency(index,ConsistencyModifier.LOCK);
         finishSchema();
 

File: titan-test/src/main/java/com/thinkaurelius/titan/testutil/gen/Schema.java
Patch:
@@ -229,11 +229,11 @@ public void makeTypes(TitanGraph g) {
         TitanManagement mgmt = g.getManagementSystem();
         for (int i = 0; i < vertexPropKeys; i++) {
             PropertyKey key = mgmt.makePropertyKey(getVertexPropertyName(i)).dataType(Integer.class).cardinality(Cardinality.SINGLE).make();
-            mgmt.createInternalIndex("v-"+getVertexPropertyName(i),Vertex.class,key);
+            mgmt.buildIndex("v-"+getVertexPropertyName(i),Vertex.class).indexKey(key).buildInternalIndex();
         }
         for (int i = 0; i < edgePropKeys; i++) {
             PropertyKey key = mgmt.makePropertyKey(getEdgePropertyName(i)).dataType(Integer.class).cardinality(Cardinality.SINGLE).make();
-            mgmt.createInternalIndex("e-"+getEdgePropertyName(i),Edge.class,key);
+            mgmt.buildIndex("e-"+getEdgePropertyName(i),Edge.class).indexKey(key).buildInternalIndex();
         }
         for (int i = 0; i < edgeLabels; i++) {
             String labelName = getEdgeLabelName(i);
@@ -243,7 +243,7 @@ public void makeTypes(TitanGraph g) {
         }
 
         PropertyKey uid = mgmt.makePropertyKey(UID_PROP).dataType(Long.class).cardinality(Cardinality.SINGLE).make();
-        mgmt.createInternalIndex("v-uid",Vertex.class,true,uid);
+        mgmt.buildIndex("v-uid",Vertex.class).unique().indexKey(uid).buildInternalIndex();
         mgmt.commit();
     }
 

File: titan-hbase-parent/common/test/java/com/thinkaurelius/titan/HBaseStorageSetup.java
Patch:
@@ -66,7 +66,7 @@ public void run() {
     public static ModifiableConfiguration getHBaseConfiguration() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, "hbase");
-        config.set(GraphDatabaseConfiguration.IDS_PARTITION, true);
+        config.set(GraphDatabaseConfiguration.CLUSTER_PARTITION, true);
         config.set(SimpleBulkPlacementStrategy.CONCURRENT_PARTITIONS, 1);
         return config;
     }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraHelper;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
@@ -28,7 +28,6 @@
 import org.apache.cassandra.thrift.SlicePredicate;
 import org.apache.cassandra.thrift.SliceRange;
 import org.apache.cassandra.thrift.ThriftValidation;
-import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.commons.lang.ArrayUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -7,7 +7,7 @@
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Duration.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.core.attribute;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/util/TitanCleanup.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.core.TitanConfigurationException;
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.core.TitanFactory;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDManager;
 import com.thinkaurelius.titan.diskstorage.indexing.*;
@@ -91,7 +91,7 @@ public class Backend implements LockerProvider {
     public static final Map<String, Integer> STATIC_KEY_LENGTHS = new HashMap<String, Integer>() {{
         put(EDGESTORE_NAME, 8);
         put(EDGESTORE_NAME + LOCK_STORE_SUFFIX, 8);
-        put(ID_STORE_NAME, 4);
+        put(ID_STORE_NAME, 8);
     }};
 
     private final KeyColumnValueStoreManager storeManager;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BackendTransaction.java
Patch:
@@ -15,7 +15,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexQuery;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexTransaction;
 import com.thinkaurelius.titan.diskstorage.indexing.RawQuery;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthority.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage;
 
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/TransactionHandleConfig.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/CommonsConfiguration.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.Durations;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.Durations;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ReadConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.idmanagement;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.LoggableTransaction;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediator.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Timepoint;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediatorProvider.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediators.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LockStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 
 /**
  * A single held lock's expiration time. This is used by {@link AbstractLocker}.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.locking.LockStatus;
 
 import java.util.concurrent.TimeUnit;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStoreManager.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingTransaction.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.locking.LocalLockMediator;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/ReadMarker.java
Patch:
@@ -1,9 +1,8 @@
 package com.thinkaurelius.titan.diskstorage.log;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Timepoint;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -3,8 +3,9 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.*;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.util.time.*;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.*;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLogManager.java
Patch:
@@ -121,9 +121,7 @@ public KCVSLogManager(final KeyColumnValueStoreManager storeManager, final Confi
                     List<PartitionIDRange> partitionRanges = PartitionIDRange.getIDRanges(partitionBitWidth,
                             storeManager.getLocalKeyPartition());
                     for (PartitionIDRange idrange : partitionRanges) {
-                        for (int p = idrange.getLowerID();p<idrange.getUpperID(); p=(p+1)%idrange.getIdUpperBound()) {
-                            localPartitions.add(p);
-                        }
+                        for (int p : idrange.getAllContainedIDs()) localPartitions.add(p);
                     }
                 } catch (Throwable e) {
                     log.error("Could not process local id partitions",e);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSMessage.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.log.kcvs;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.util.AbstractMessage;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/util/AbstractMessage.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.log.util;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.Message;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/BackendOperation.java
Patch:
@@ -2,9 +2,9 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.StandardDuration;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/StandardTransactionHandleConfig.java
Patch:
@@ -1,12 +1,12 @@
 package com.thinkaurelius.titan.diskstorage.util;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/StandardTimepoint.java
Patch:
@@ -1,6 +1,7 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/Timer.java
Patch:
@@ -1,8 +1,9 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
 
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 /**
  * A utility to measure time durations.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/TimestampProvider.java
Patch:
@@ -1,4 +1,6 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
+
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 import java.util.concurrent.TimeUnit;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/time/Timestamps.java
Patch:
@@ -1,7 +1,8 @@
-package com.thinkaurelius.titan.util.time;
+package com.thinkaurelius.titan.diskstorage.util.time;
 
 import java.util.concurrent.TimeUnit;
 
+import com.thinkaurelius.titan.core.attribute.Duration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -2,9 +2,10 @@
 
 import com.google.common.collect.Maps;
 import com.thinkaurelius.titan.core.*;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.util.stats.NumberUtil;
-import com.thinkaurelius.titan.util.time.*;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.*;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.CommonsConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.KCVSConfiguration;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/EdgeSerializer.java
Patch:
@@ -149,7 +149,7 @@ public RelationCache parseRelation(Entry data, boolean excludeProperties, TypeIn
                 for (Map.Entry<EntryMetaData,Object> metas : data.getMetaData().entrySet()) {
                     ImplicitKey key = ImplicitKey.MetaData2ImplicitKey.get(metas.getKey());
                     if (key!=null) {
-                        assert metas.getValue()!=null && metas.getValue().getClass().equals(key.getDataType());
+                        assert metas.getValue()!=null;
                         properties.put(key.getID(),metas.getValue());
                     }
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -5,8 +5,8 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.*;
 import com.thinkaurelius.titan.core.*;
-import com.thinkaurelius.titan.util.time.Timepoint;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexEntry;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/IDBlockSizer.java
Patch:
@@ -7,7 +7,7 @@
 public interface IDBlockSizer {
 
     /**
-     * The size of the id block to be returned by calls {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, com.thinkaurelius.titan.util.time.Duration)}
+     * The size of the id block to be returned by calls {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, com.thinkaurelius.titan.core.attribute.Duration)}
      * for the given id namespace.
      * In other words, for the returned array of the above mentioned call, it must hold that the difference between the second
      * and first value is equal to the block size returned by this method (for the same partition id).
@@ -18,7 +18,7 @@ public interface IDBlockSizer {
     public long getBlockSize(int idNamespace);
 
     /**
-     * Returns the upper bound for any id block returned by {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, com.thinkaurelius.titan.util.time.Duration)}
+     * Returns the upper bound for any id block returned by {@link com.thinkaurelius.titan.diskstorage.IDAuthority#getIDBlock(int,int, com.thinkaurelius.titan.core.attribute.Duration)}
      * for the given id namespace.
      * In other words, it must hold that the second value of the returned array is smaller than this value for the same partition id.
      *

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StandardIDPool.java
Patch:
@@ -13,7 +13,7 @@
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.diskstorage.IDBlock;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -6,7 +6,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.util.stats.NumberUtil;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.Backend;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/log/TransactionLogHeader.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.graphdb.database.log;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.StandardTimepoint;
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardTimepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
 import com.thinkaurelius.titan.graphdb.transaction.TransactionConfiguration;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 import java.util.EnumMap;
 import java.util.concurrent.TimeUnit;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -12,8 +12,8 @@
 import com.thinkaurelius.titan.graphdb.types.SchemaStatus;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 import com.thinkaurelius.titan.graphdb.types.TypeDefinitionDescription;
-import com.thinkaurelius.titan.util.time.StandardDuration;
-import com.thinkaurelius.titan.util.time.StandardTimepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardTimepoint;
 import com.tinkerpop.blueprints.Direction;
 
 import java.util.*;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -10,9 +10,9 @@
 import com.google.common.collect.*;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.Cmp;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.StandardDuration;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.BackendTransaction;
 import com.thinkaurelius.titan.diskstorage.EntryList;
 import com.thinkaurelius.titan.diskstorage.StorageException;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTransactionBuilder.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
 import com.thinkaurelius.titan.core.TitanTransaction;
 import com.thinkaurelius.titan.core.TransactionBuilder;
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.configuration.UserModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
 import com.thinkaurelius.titan.diskstorage.configuration.BasicConfiguration;
@@ -18,7 +18,7 @@
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 /**
  * Used to configure a {@link com.thinkaurelius.titan.core.TitanTransaction}.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/CombinerLock.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.Timer;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.Timer;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/FakeLock.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/ReentrantTransactionLock.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/TransactionLock.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/util/stats/MetricManager.java
Patch:
@@ -29,7 +29,7 @@
 import com.codahale.metrics.graphite.Graphite;
 import com.codahale.metrics.graphite.GraphiteReporter;
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 
 /**
  * Singleton that contains and configures Titan's {@code MetricRegistry}.

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -8,8 +8,8 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Sets;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.common.DistributedStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigNamespace;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/AbstractKCVSTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage;
 
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreManager;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
 
 /**

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAllocationTest.java
Patch:
@@ -3,10 +3,9 @@
 import com.carrotsearch.hppc.LongOpenHashSet;
 import com.carrotsearch.hppc.LongSet;
 import com.google.common.base.Preconditions;
-import com.google.common.collect.Lists;
 import com.thinkaurelius.titan.StorageSetup;
-import com.thinkaurelius.titan.util.time.Duration;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.core.attribute.Duration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -9,10 +9,9 @@
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
 
 import org.junit.After;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/MultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.cache.CacheTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.cache.KCVEntryMutation;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexProviderTest.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.core.Order;
 import com.thinkaurelius.titan.core.Parameter;
 import com.thinkaurelius.titan.core.attribute.*;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
 import com.thinkaurelius.titan.graphdb.query.condition.*;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/util/TestTimeUtility.java
Patch:
@@ -1,12 +1,11 @@
 package com.thinkaurelius.titan.diskstorage.util;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
+import com.thinkaurelius.titan.diskstorage.util.time.Timepoint;
 import org.junit.Test;
 
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 
 import java.util.Random;
-import java.util.concurrent.TimeUnit;
 
 import static org.junit.Assert.assertTrue;
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.thinkaurelius.titan.core.*;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.Backend;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.*;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeTest.java
Patch:
@@ -14,7 +14,7 @@
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 
 import java.util.Random;
 import java.util.concurrent.*;

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -10,9 +10,7 @@
 import com.thinkaurelius.titan.core.attribute.Decimal;
 import com.thinkaurelius.titan.core.attribute.Precision;
 import com.thinkaurelius.titan.core.attribute.Cmp;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/CommonConfigTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.CommonsConfiguration;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import org.apache.commons.configuration.BaseConfiguration;
 import org.junit.Test;
 

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/KCVSConfigTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.configuration;
 
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.KCVSConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediatorTest.java
Patch:
@@ -1,8 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.util.time.Timepoint;
-import com.thinkaurelius.titan.util.time.TimestampProvider;
-import com.thinkaurelius.titan.util.time.Timestamps;
+import com.thinkaurelius.titan.diskstorage.util.time.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/IDPoolTest.java
Patch:
@@ -8,7 +8,7 @@
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
 
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import org.junit.Test;
 
 import com.thinkaurelius.titan.core.TitanException;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/MockIDAuthority.java
Patch:
@@ -3,7 +3,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import com.thinkaurelius.titan.diskstorage.*;
-import com.thinkaurelius.titan.util.time.Duration;
+import com.thinkaurelius.titan.core.attribute.Duration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.core.TitanVertex;
-import com.thinkaurelius.titan.util.time.StandardDuration;
+import com.thinkaurelius.titan.diskstorage.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StandardStoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -188,8 +188,8 @@ private StaticBuffer getPartitionKey(int partition, int idNamespace, int uniqueI
 
     @Override
     public synchronized IDBlock getIDBlock(final int partition, final int idNamespace, Duration timeout) throws StorageException {
-        Preconditions.checkArgument(partition>0 && partition<(1<<partitionBitWdith),"Invalid partition id: %d",partition);
-        Preconditions.checkArgument(idNamespace>0); //can be any non-negative value
+        Preconditions.checkArgument(partition>=0 && partition<(1<<partitionBitWdith),"Invalid partition id [%s] for bit width [%s]",partition, partitionBitWdith);
+        Preconditions.checkArgument(idNamespace>=0); //can be any non-negative value
 
         final Timer methodTime = times.getTimer().start();
 

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/MockIDAuthority.java
Patch:
@@ -49,7 +49,7 @@ public MockIDAuthority(int blockSize, int blockSizeLimit, int delayAcquisitionMS
     }
 
     @Override
-    public IDBlock getIDBlock(int partition, final int idNamespace, Duration timeout) throws StorageException {
+    public IDBlock getIDBlock(final int partition, final int idNamespace, Duration timeout) throws StorageException {
         //Delay artificially
         if (delayAcquisitionMS>0) {
             try {
@@ -60,7 +60,7 @@ public IDBlock getIDBlock(int partition, final int idNamespace, Duration timeout
         }
         Preconditions.checkArgument(partition>=0 && partition<=Integer.MAX_VALUE);
         Preconditions.checkArgument(idNamespace>=0 && idNamespace<=Integer.MAX_VALUE);
-        Long p = ((long)partition)<<Integer.SIZE + ((long)idNamespace);
+        Long p = (((long)partition)<<Integer.SIZE) + ((long)idNamespace);
         long size = blockSizer.getBlockSize(idNamespace);
         AtomicLong id = ids.get(p);
         if (id == null) {

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -60,6 +60,7 @@ public VertexIDAssignerTest(Boolean partition, int partitionMax, int[] localPart
 
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
         config.set(GraphDatabaseConfiguration.CLUSTER_PARTITION,partition);
+        config.set(GraphDatabaseConfiguration.CLUSTER_MAX_PARTITIONS,1024);
         idAssigner = new VertexIDAssigner(config, idAuthority, features);
         System.out.println("Partition: " + partition);
         System.out.println("partitionMax: " + partitionMax);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -307,7 +307,7 @@ private void assignID(final InternalElement vertex, final long partitionIDl) {
                 } else if (vertex instanceof TitanSchemaVertex) {
                     id = idManager.getSchemaId(IDManager.VertexIDType.GenericSchemaType,pool.genericType.nextID()<<1);
                 } else {
-                    id = idManager.getVertexID(pool.vertex.nextID(), partitionID);
+                    id = idManager.getVertexID(pool.vertex.nextID(), partitionID, IDManager.VertexIDType.Vertex);
                 }
                 pool.accessed();
             } catch (IDPoolExhaustedException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraBuilder.java
Patch:
@@ -124,7 +124,8 @@ public Future<Map<Long,S>> execute() {
         for (Map.Entry<String,Object> txOption : txOptions.entrySet())
             txBuilder.setCustomOption(txOption.getKey(),txOption.getValue());
         final StandardTitanTx tx = (StandardTitanTx)txBuilder.start();
-        FulgoraExecutor executor = new FulgoraExecutor(queries,tx,(int)numVertices,numProcessingThreads,
+        FulgoraExecutor executor = new FulgoraExecutor(queries,tx,graph.getIDManager(),
+                (int)numVertices,numProcessingThreads,
                 stateKey, olapJob, initializer,initialState);
         new Thread(executor).start();
         return executor;

File: titan-hadoop/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -89,7 +89,7 @@ public VertexReader getVertexReader() {
         return new VertexReader() {
             @Override
             public long getVertexId(StaticBuffer key) {
-                return IDHandler.getKeyID(key);
+                return graph.getIDManager().getKeyID(key);
             }
         };
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanGraph.java
Patch:
@@ -78,7 +78,7 @@ public interface TitanGraph extends Graph, KeyIndexableGraph, ThreadedTransactio
      *
      * @return
      */
-    public TitanGraphQuery query();
+    public TitanGraphQuery<? extends TitanGraphQuery> query();
 
     /**
      * Returns a {@link TitanIndexQuery} to query for vertices or edges against the specified indexing backend using

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanTransaction.java
Patch:
@@ -128,7 +128,7 @@ public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph
      * @return
      * @see com.thinkaurelius.titan.core.TitanGraph#query()
      */
-    public TitanGraphQuery query();
+    public TitanGraphQuery<? extends TitanGraphQuery> query();
 
     /**
      * Returns a {@link TitanIndexQuery} to query for vertices or edges against the specified indexing backend using
@@ -146,13 +146,13 @@ public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph
      * @return
      * @see com.thinkaurelius.titan.core.TitanGraph#multiQuery(TitanVertex...)
      */
-    public TitanMultiVertexQuery multiQuery(TitanVertex... vertices);
+    public TitanMultiVertexQuery<? extends TitanMultiVertexQuery> multiQuery(TitanVertex... vertices);
 
     /**
      * @return
      * @see com.thinkaurelius.titan.core.TitanGraph#multiQuery(Collection)
      */
-    public TitanMultiVertexQuery multiQuery(Collection<TitanVertex> vertices);
+    public TitanMultiVertexQuery<? extends TitanMultiVertexQuery> multiQuery(Collection<TitanVertex> vertices);
 
     /**
      * Executes a {@link TitanGraphQuery} to retrieve the vertex that has a property matching the key and attribute.

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanVertex.java
Patch:
@@ -88,7 +88,7 @@ public interface TitanVertex extends TitanElement, Vertex {
      * @return New TitanQuery for this vertex
      * @see TitanVertexQuery
      */
-    public TitanVertexQuery query();
+    public TitanVertexQuery<? extends TitanVertexQuery> query();
 
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/core/olap/OLAPJobBuilder.java
Patch:
@@ -76,7 +76,7 @@ public interface OLAPJobBuilder<S> {
      *
      * @return
      */
-    public OLAPQueryBuilder<S> addQuery();
+    public OLAPQueryBuilder<S,?> addQuery();
 
     /**
      * Starts the execution of this job and returns the computed vertex states as a map.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsGraph.java
Patch:
@@ -178,7 +178,7 @@ public LabelMaker makeLabel(String name) {
     }
 
     @Override
-    public TitanGraphQuery query() {
+    public TitanGraphQuery<? extends TitanGraphQuery> query() {
         return getAutoStartTx().query();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -107,7 +107,7 @@ public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
         StoreFeatures storeFeatures = backend.getStoreFeatures();
         this.indexSerializer = new IndexSerializer(this.serializer, this.backend.getIndexInformation(),storeFeatures.isDistributed() && storeFeatures.isKeyOrdered());
         this.edgeSerializer = new EdgeSerializer(this.serializer);
-        this.vertexExistenceQuery = edgeSerializer.getQuery(BaseKey.VertexExists, Direction.OUT, new EdgeSerializer.TypedInterval[0], null).setLimit(1);
+        this.vertexExistenceQuery = edgeSerializer.getQuery(BaseKey.VertexExists, Direction.OUT, new EdgeSerializer.TypedInterval[0]).setLimit(1);
         this.queryCache = new RelationQueryCache(this.edgeSerializer);
         this.schemaCache = configuration.getTypeCache(typeCacheRetrieval);
         this.times = configuration.getTimestampProvider();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/fulgora/FulgoraExecutor.java
Patch:
@@ -141,7 +141,7 @@ public void run() {
                 //First, check if this is a valid (non-deleted) vertex
                 assert conditionQuery.entries.size()==1;
                 RelationCache relCache = tx.getEdgeSerializer().parseRelation(
-                                        conditionQuery.vertexId,conditionQuery.entries.get(0),true,tx);
+                                        conditionQuery.entries.get(0),true,tx);
                 if (relCache.typeId != BaseKey.VertexExists.getID()) {
                     log.warn("Found deleted vertex with id: %s. Skipping",conditionQuery.vertexId);
                     for (int i=1;i<currentResults.length;i++) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/MultiVertexCentricQueryBuilder.java
Patch:
@@ -108,7 +108,7 @@ protected Map<TitanVertex, Iterable<? extends TitanRelation>> relations(Relation
                     newcond.add(new DirectionCondition<TitanRelation>(v, getDirection()));
                     if (getAdjacentVertex() != null)
                         newcond.add(new IncidenceCondition<TitanRelation>(v,getAdjacentVertex()));
-                    VertexCentricQuery vqsingle = new VertexCentricQuery(v, newcond, vq.getDirection(), vq.getQueries(), vq.getLimit());
+                    VertexCentricQuery vqsingle = new VertexCentricQuery(v, newcond, vq.getDirection(), vq.getQueries(), vq.getOrders(), vq.getLimit());
                     result.put(v, new QueryProcessor<VertexCentricQuery, TitanRelation, SliceQuery>(vqsingle, tx.edgeProcessor));
 
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheProperty.java
Patch:
@@ -76,7 +76,7 @@ public long getID() {
     private RelationCache getPropertyMap() {
         RelationCache map = data.getCache();
         if (map == null || !map.hasProperties()) {
-            map = RelationConstructor.readRelationCache(getVertex(0), data, tx());
+            map = RelationConstructor.readRelationCache(data, tx());
         }
         return map;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationIdentifier.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
+import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 import com.thinkaurelius.titan.util.encoding.LongEncoding;
 import com.tinkerpop.blueprints.Direction;
 import org.apache.commons.lang.builder.HashCodeBuilder;
@@ -109,7 +110,7 @@ TitanRelation findRelation(TitanTransaction tx) {
         if (((TitanType) typeVertex).isEdgeLabel()) {
             TitanVertex in = tx.getVertex(inVertexId);
             if (in==null) return null;
-            rels = v.query().types((TitanLabel)type).direction(Direction.OUT).adjacentVertex(in).titanEdges();
+            rels = v.query().types((TitanLabel)type).direction(Direction.OUT).adjacent(in).titanEdges();
         } else {
             rels = v.query().types((TitanKey)type).properties();
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -515,7 +515,7 @@ public TitanEdge addEdge(TitanVertex outVertex, TitanVertex inVertex, TitanLabel
             //Check uniqueness
             if (config.hasVerifyUniqueness()) {
                 if (multiplicity==Multiplicity.SIMPLE) {
-                    Preconditions.checkArgument(Iterables.isEmpty(query(outVertex).type(label).direction(Direction.OUT).adjacentVertex(inVertex).titanEdges()),
+                    Preconditions.checkArgument(Iterables.isEmpty(query(outVertex).type(label).direction(Direction.OUT).adjacent(inVertex).titanEdges()),
                             "An edge with the given label already exists between the pair of vertices and the label [%s] is simple", label.getName());
                 }
                 if (multiplicity.isUnique(Direction.OUT)) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/ImplicitKey.java
Patch:
@@ -20,7 +20,7 @@ public class ImplicitKey extends EmptyType implements SystemType, TitanKey {
 
     public static final ImplicitKey ID = new ImplicitKey(0,"id",Long.class);
 
-    public static final ImplicitKey LABEL = new ImplicitKey(0,"label",String.class);
+    public static final ImplicitKey LABEL = new ImplicitKey(11,"label",String.class);
 
 //    public static final ImplicitKey KEY = new ImplicitKey("key",Long.class);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanSchemaVertex.java
Patch:
@@ -128,7 +128,7 @@ public Iterable<TitanEdge> getEdges(final TypeDefinitionCategory def, final Dire
 
     public Iterable<TitanEdge> getEdges(final TypeDefinitionCategory def, final Direction dir, TitanSchemaVertex other) {
         VertexCentricQueryBuilder query = query().type(BaseLabel.TypeDefinitionEdge).direction(dir);
-        if (other!=null) query.adjacentVertex(other);
+        if (other!=null) query.adjacent(other);
         return Iterables.filter(query.titanEdges(),new Predicate<TitanEdge>() {
             @Override
             public boolean apply(@Nullable TitanEdge edge) {

File: titan-hadoop/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/TitanGraphOutputMapReduce.java
Patch:
@@ -282,7 +282,7 @@ public Edge getCreateOrDeleteEdge(final HadoopVertex hadoopVertex, final HadoopE
         private TitanEdge getIncident(final TitanVertex titanVertex, HadoopEdge hadoopEdge, final Object otherVertexId) {
             final VertexQuery query = (null == otherVertexId) ?   // the shell wasn't propagated because the vertex was deleted -- should we propagate shell?
                     titanVertex.query().direction(IN).labels(hadoopEdge.getLabel()) :
-                    titanVertex.query().direction(IN).labels(hadoopEdge.getLabel()).adjacentVertex((TitanVertex) this.graph.getVertex(otherVertexId));
+                    titanVertex.query().direction(IN).labels(hadoopEdge.getLabel()).adjacent((TitanVertex) this.graph.getVertex(otherVertexId));
             for (final HadoopProperty property : hadoopEdge.getPropertiesWithState()) {
                 if (property.isLoaded()) {
                     query.has(property.getName(), property.getValue());

File: titan-hadoop/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/TitanHadoopSetup.java
Patch:
@@ -14,7 +14,7 @@ public interface TitanHadoopSetup {
 
     public SystemTypeInspector getSystemTypeInspector();
 
-    public RelationReader getRelationReader();
+    public RelationReader getRelationReader(long vertexid);
 
     public VertexReader getVertexReader();
 

File: titan-hadoop/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/current/TitanHadoopSetupImpl.java
Patch:
@@ -95,7 +95,7 @@ public long getVertexId(StaticBuffer key) {
     }
 
     @Override
-    public RelationReader getRelationReader() {
+    public RelationReader getRelationReader(long vertexid) {
         return graph.getEdgeSerializer();
     }
 

File: titan-hadoop/src/main/java/com/thinkaurelius/titan/hadoop/formats/titan/input/titan03/TitanHadoopSetupImpl.java
Patch:
@@ -318,11 +318,11 @@ public boolean isUnidirected(Direction dir) {
 //    }
 
     @Override
-    public RelationReader getRelationReader() {
+    public RelationReader getRelationReader(final long vertexid) {
         return new RelationReader() {
 
             @Override
-            public RelationCache parseRelation(long vertexid, Entry entry, boolean headerOnly, TypeInspector typeInspector) {
+            public RelationCache parseRelation(Entry entry, boolean headerOnly, TypeInspector typeInspector) {
                 titan03.com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer column = new titan03.com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer(entry.getColumn().as(StaticBuffer.ARRAY_FACTORY));
                 titan03.com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer value = new titan03.com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer(entry.getValue().as(StaticBuffer.ARRAY_FACTORY));
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -299,9 +299,9 @@ public Object getMetaData(Column element, EntryMetaData meta) {
                 case TIMESTAMP:
                     return element.timestamp();
                 case TTL:
-                    return (element instanceof ExpiringColumn)
+                    return Long.valueOf((element instanceof ExpiringColumn)
                             ? ((ExpiringColumn) element).getTimeToLive()
-                            : null;
+                            : 0);
                 default:
                     return null;
             }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftKeyColumnValueStore.java
Patch:
@@ -183,7 +183,7 @@ public EntryMetaData[] getMetaSchema(ColumnOrSuperColumn element) {
         public Object getMetaData(ColumnOrSuperColumn element, EntryMetaData meta) {
             switch(meta) {
                 case TIMESTAMP: return element.getColumn().getTimestamp();
-                case TTL: return element.getColumn().getTtl();
+                case TTL: return Long.valueOf(element.getColumn().getTtl());
                 default: return null;
             }
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -500,7 +500,7 @@ protected void deleteSingleLock(KeyColumn kc, ConsistentKeyLockStatus ls, StoreT
     private StoreTransaction overrideTimestamp(final StoreTransaction tx, final Timepoint commitTime) throws StorageException {
         //TODO: check that start time is set correctly!
         StandardTransactionHandleConfig newCfg = new StandardTransactionHandleConfig.Builder(tx.getConfiguration())
-                .startTime(commitTime.getProvider().getTime()).commitTime(commitTime).build();
+                .startTime(tx.getConfiguration().getStartTime()).commitTime(commitTime).build();
         return manager.beginTransaction(newCfg);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/util/time/Timer.java
Patch:
@@ -21,7 +21,7 @@ public class Timer {
     private Timepoint start;
     private Timepoint stop;
 
-    Timer(final TimestampProvider times) {
+    public Timer(final TimestampProvider times) {
         this.times = times;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/util/time/TimestampProvider.java
Patch:
@@ -26,8 +26,7 @@ public interface TimestampProvider {
     /**
      * Return the units of {@link #getTime()}. This method's return value must
      * be constant over at least the life of the object implementing this
-     * interface. Clients of this interface may call this method once and assume
-     * that the return value never changes thereafter.
+     * interface.
      *
      * @return this instance's time unit
      */

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/locking/ConsistentKeyLockerTest.java
Patch:
@@ -51,7 +51,6 @@
 import static org.easymock.EasyMock.*;
 
 
-@Ignore
 public class ConsistentKeyLockerTest {
 
     // Arbitrary literals -- the exact values assigned here are not intrinsically important

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -7,7 +7,7 @@
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 
-import com.thinkaurelius.titan.core.time.SimpleDuration;
+import com.thinkaurelius.titan.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
@@ -39,7 +39,7 @@ private static ModifiableConfiguration getGenericConfiguration(String ks, String
         ModifiableConfiguration config = buildConfiguration();
         config.set(CASSANDRA_KEYSPACE, cleanKeyspaceName(ks));
         config.set(PAGE_SIZE,500);
-        config.set(CONNECTION_TIMEOUT, new SimpleDuration(60L, TimeUnit.SECONDS));
+        config.set(CONNECTION_TIMEOUT, new StandardDuration(60L, TimeUnit.SECONDS));
         config.set(STORAGE_BACKEND, backend);
         return config;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -164,7 +164,7 @@ private static ReadConfiguration getLocalConfiguration(String shortcutOrFile) {
             String secondArg = null;
             if (pos+1<shortcutOrFile.length()) secondArg = shortcutOrFile.substring(pos + 1).trim();
             BaseConfiguration config = new BaseConfiguration();
-            ModifiableConfiguration writeConfig = new ModifiableConfiguration(TITAN_NS,new CommonsConfiguration(config), BasicConfiguration.Restriction.NONE);
+            ModifiableConfiguration writeConfig = new ModifiableConfiguration(ROOT_NS,new CommonsConfiguration(config), BasicConfiguration.Restriction.NONE);
             writeConfig.set(STORAGE_BACKEND,backend);
             ConfigOption option = Backend.REGISTERED_STORAGE_MANAGERS_SHORTHAND.get(backend.toLowerCase());
             if (option==null) {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TransactionBuilder.java
Patch:
@@ -59,7 +59,7 @@ public interface TransactionBuilder {
      *            units of the {@code timestamp argument}
      * @return
      */
-    public TransactionBuilder setTimestamp(long timestampSinceEpoch, TimeUnit unit);
+    public TransactionBuilder setCommitTime(long timestampSinceEpoch, TimeUnit unit);
 
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/core/util/TitanCleanup.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanGraph;
-import com.thinkaurelius.titan.core.time.SimpleDuration;
+import com.thinkaurelius.titan.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
@@ -39,7 +39,7 @@ public Boolean call() throws Exception {
             }
             @Override
             public String toString() { return "ClearBackend"; }
-        },new SimpleDuration(20, TimeUnit.SECONDS));
+        },new StandardDuration(20, TimeUnit.SECONDS));
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -7,8 +7,7 @@
 import com.thinkaurelius.titan.core.TitanConfigurationException;
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.core.TitanFactory;
-import com.thinkaurelius.titan.core.time.Duration;
-import com.thinkaurelius.titan.core.time.TimestampProvider;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDManager;
 import com.thinkaurelius.titan.diskstorage.indexing.*;
@@ -268,6 +267,7 @@ public void initialize(Configuration config) {
                 @Override
                 public StoreTransaction openTx() throws StorageException {
                     return storeManagerLocking.beginTransaction(StandardTransactionHandleConfig.of(
+                            configuration.get(TIMESTAMP_PROVIDER),
                             storeFeatures.getKeyConsistentTxConfig()));
                 }
 
@@ -376,7 +376,7 @@ public static KCVSConfiguration getStandaloneGlobalConfiguration(final KeyColumn
             return getGlobalConfiguration(new BackendOperation.TransactionalProvider() {
                 @Override
                 public StoreTransaction openTx() throws StorageException {
-                    return manager.beginTransaction(StandardTransactionHandleConfig.of(features.getKeyConsistentTxConfig()));
+                    return manager.beginTransaction(StandardTransactionHandleConfig.of(config.get(TIMESTAMP_PROVIDER),features.getKeyConsistentTxConfig()));
                 }
 
                 @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BackendTransaction.java
Patch:
@@ -15,11 +15,10 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexQuery;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexTransaction;
 import com.thinkaurelius.titan.diskstorage.indexing.RawQuery;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyIterator;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRangeQuery;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeySliceQuery;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthority.java
Patch:
@@ -1,12 +1,11 @@
 package com.thinkaurelius.titan.diskstorage;
 
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 
 /**
  * Handles the unique allocation of ids. Returns blocks of ids that are uniquely allocated to the caller so that

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.idmanagement;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.LoggableTransaction;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediatorProvider.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.core.time.TimestampProvider;
+import com.thinkaurelius.titan.util.time.TimestampProvider;
 
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediators.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.time.TimestampProvider;
+import com.thinkaurelius.titan.util.time.TimestampProvider;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LockStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking;
 
-import com.thinkaurelius.titan.core.time.Timepoint;
+import com.thinkaurelius.titan.util.time.Timepoint;
 
 /**
  * A single held lock's expiration time. This is used by {@link AbstractLocker}.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
-import com.thinkaurelius.titan.core.time.Timepoint;
+import com.thinkaurelius.titan.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.locking.LockStatus;
 
 import java.util.concurrent.TimeUnit;
@@ -28,7 +28,7 @@ public Timepoint getExpirationTimestamp() {
     }
 
     public long getWriteTimestamp(TimeUnit tu) {
-        return write.getTime(tu);
+        return write.getTimestamp(tu);
     }
 
     public Timepoint getWriteTimestamp() {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStoreManager.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
@@ -62,6 +62,7 @@ public StoreTransaction beginTransaction(TransactionHandleConfig configuration)
         TransactionHandleConfig consistentTxCfg = new StandardTransactionHandleConfig.Builder()
                 .groupName(configuration.getGroupName())
                 .customOptions(customOptions)
+                .startTime(configuration.getStartTime())
                 .build();
         StoreTransaction consistentTx = storeManager.beginTransaction(consistentTxCfg);
         StoreTransaction wrappedTx = new ExpectedValueCheckingTransaction(tx, consistentTx, maxReadTime);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingTransaction.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.locking.LocalLockMediator;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSMessage.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.log.kcvs;
 
-import com.thinkaurelius.titan.core.time.Timepoint;
+import com.thinkaurelius.titan.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.util.AbstractMessage;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/util/AbstractMessage.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.log.util;
 
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.time.Timepoint;
+import com.thinkaurelius.titan.util.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.Message;
 
@@ -42,7 +42,7 @@ public Timepoint getTimestampMicro() {
 
     @Override
     public long getTimestamp(TimeUnit unit) {
-        return timestamp.getTime(unit);
+        return timestamp.getTimestamp(unit);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StandardIDPool.java
Patch:
@@ -12,7 +12,7 @@
 import com.google.common.base.Stopwatch;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -12,7 +12,7 @@
 import com.thinkaurelius.titan.core.TitanKey;
 import com.thinkaurelius.titan.core.TitanLabel;
 import com.thinkaurelius.titan.core.TitanType;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.Backend;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
@@ -24,7 +24,6 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalElement;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
-import com.thinkaurelius.titan.graphdb.types.system.SystemTypeManager;
 import com.thinkaurelius.titan.graphdb.types.vertices.TitanSchemaVertex;
 
 import org.slf4j.Logger;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -69,7 +69,7 @@ public ManagementSystem(StandardTitanGraph graph, KCVSConfiguration config, Log
         this.sysLog = sysLog;
         this.mgmtLogger = mgmtLogger;
         this.transactionalConfig = new TransactionalConfiguration(baseConfig);
-        this.modifyConfig = new ModifiableConfiguration(TITAN_NS,
+        this.modifyConfig = new ModifiableConfiguration(ROOT_NS,
                 transactionalConfig, BasicConfiguration.Restriction.GLOBAL);
         this.userConfig = new UserModifiableConfiguration(modifyConfig,configVerifier);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/FakeLock.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/ReentrantTransactionLock.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/TransactionLock.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/util/stats/MetricManager.java
Patch:
@@ -29,7 +29,7 @@
 import com.codahale.metrics.graphite.Graphite;
 import com.codahale.metrics.graphite.GraphiteReporter;
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 
 /**
  * Singleton that contains and configures Titan's {@code MetricRegistry}.

File: titan-hadoop/src/test/java/com/thinkaurelius/titan/hadoop/formats/titan/cassandra/TitanCassandraOutputFormatTest.java
Patch:
@@ -39,7 +39,7 @@ private static TitanGraph startUpCassandra() throws Exception {
     private static BaseConfiguration getConfiguration() throws Exception {
         BaseConfiguration configuration = new BaseConfiguration();
 
-        ModifiableConfiguration config = new ModifiableConfiguration(TITAN_NS,
+        ModifiableConfiguration config = new ModifiableConfiguration(ROOT_NS,
                 new CommonsConfiguration(configuration),
                 BasicConfiguration.Restriction.NONE);
 

File: titan-hadoop/src/test/java/com/thinkaurelius/titan/hadoop/formats/titan/hbase/TitanHBaseOutputFormatTest.java
Patch:
@@ -39,7 +39,7 @@ private static TitanGraph startUpHBase() throws Exception {
     private static BaseConfiguration getConfiguration() throws Exception {
         BaseConfiguration configuration = new BaseConfiguration();
 
-        ModifiableConfiguration config = new ModifiableConfiguration(TITAN_NS,
+        ModifiableConfiguration config = new ModifiableConfiguration(ROOT_NS,
                 new CommonsConfiguration(configuration),
                 BasicConfiguration.Restriction.NONE);
 

File: titan-hbase-parent/common/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseKeyColumnValueTest.java
Patch:
@@ -7,7 +7,6 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -25,7 +24,7 @@ public KeyColumnValueStoreManager openStorageManager() throws StorageException {
                     ".hbase.zookeeper.quorum","localhost");
         config.set(GraphDatabaseConfiguration.STORAGE_NS.getName()+"."+HBaseStoreManager.HBASE_CONFIGURATION_NAMESPACE+
                 "hbase.zookeeper.property.clientPort",2181);
-        return new HBaseStoreManager(new BasicConfiguration(GraphDatabaseConfiguration.TITAN_NS,config, BasicConfiguration.Restriction.NONE));
+        return new HBaseStoreManager(new BasicConfiguration(GraphDatabaseConfiguration.ROOT_NS,config, BasicConfiguration.Restriction.NONE));
     }
 
     @Test

File: titan-hbase-parent/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -8,8 +8,8 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Sets;
 import com.thinkaurelius.titan.core.TitanException;
-import com.thinkaurelius.titan.core.time.TimestampProvider;
-import com.thinkaurelius.titan.core.time.Timestamps;
+import com.thinkaurelius.titan.util.time.TimestampProvider;
+import com.thinkaurelius.titan.util.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.common.DistributedStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigNamespace;
@@ -747,7 +747,7 @@ else if (18 <= exponent && exponent < 21)
 
         logger.debug("Guessed timestamp provider " + prov);
 
-        return prov.getTime(prov.getUnit());
+        return prov.getTime().getNativeTimestamp();
     }
 
     private HBaseAdmin getAdminInterface() {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStorePerformance.java
Patch:
@@ -1,9 +1,7 @@
 package com.thinkaurelius.titan.diskstorage;
 
 import com.carrotsearch.junitbenchmarks.BenchmarkRule;
-import com.thinkaurelius.titan.core.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
 import com.thinkaurelius.titan.testcategory.PerformanceTests;
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -8,7 +8,6 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 
-import com.thinkaurelius.titan.core.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.util.*;
 
 import org.junit.*;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyValueStoreTest.java
Patch:
@@ -4,8 +4,6 @@
 import java.util.HashSet;
 import java.util.Set;
 
-import com.thinkaurelius.titan.core.time.Timestamps;
-import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexProviderTest.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.core.Order;
 import com.thinkaurelius.titan.core.Parameter;
 import com.thinkaurelius.titan.core.attribute.*;
-import com.thinkaurelius.titan.core.time.SimpleDuration;
+import com.thinkaurelius.titan.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
 import com.thinkaurelius.titan.graphdb.query.condition.*;
@@ -89,7 +89,7 @@ public void setUp() throws Exception {
 
     public void open() throws StorageException {
         index = openIndex();
-        tx = new IndexTransaction(index, indexRetriever, new SimpleDuration(2000L, TimeUnit.MILLISECONDS));
+        tx = new IndexTransaction(index, indexRetriever, new StandardDuration(2000L, TimeUnit.MILLISECONDS));
     }
 
     @After

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphIterativeTest.java
Patch:
@@ -14,6 +14,7 @@
 import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
+import com.thinkaurelius.titan.util.time.Timestamps;
 
 import java.util.Random;
 import java.util.concurrent.*;
@@ -40,7 +41,7 @@ public void testDataSequential() throws Exception {
         query.setLimit(2);
         Stopwatch watch = new Stopwatch();
         watch.start();
-        StoreTransaction txh = manager.beginTransaction(StandardTransactionHandleConfig.of());
+        StoreTransaction txh = manager.beginTransaction(StandardTransactionHandleConfig.of(Timestamps.MILLI));
         KeyIterator iter = store.getKeys(query,txh);
         int numV = 0;
         while(iter.hasNext()) {

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanNonTransactionalGraphMetricsTest.java
Patch:
@@ -46,7 +46,7 @@ public abstract class TitanNonTransactionalGraphMetricsTest extends TitanGraphBa
     @Override
     public WriteConfiguration getConfiguration() {
         WriteConfiguration config = getBaseConfiguration();
-        ModifiableConfiguration mconf = new ModifiableConfiguration(GraphDatabaseConfiguration.TITAN_NS,config, BasicConfiguration.Restriction.NONE);
+        ModifiableConfiguration mconf = new ModifiableConfiguration(GraphDatabaseConfiguration.ROOT_NS,config, BasicConfiguration.Restriction.NONE);
         mconf.set(GraphDatabaseConfiguration.BASIC_METRICS,true);
         mconf.set(GraphDatabaseConfiguration.MERGE_BASIC_METRICS,false);
         mconf.set(GraphDatabaseConfiguration.PROPERTY_PREFETCHING,false);

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/ConfigurationTest.java
Patch:
@@ -126,7 +126,7 @@ public void testConfigHierarchy() {
 
     @Test
     public void printTitanNS() {
-        System.out.println(ConfigElement.toString(GraphDatabaseConfiguration.TITAN_NS));
+        System.out.println(ConfigElement.toString(GraphDatabaseConfiguration.ROOT_NS));
     }
 
 

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/KCVSConfigTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.configuration;
 
-import com.thinkaurelius.titan.core.time.Timestamps;
+import com.thinkaurelius.titan.util.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.backend.KCVSConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
@@ -21,7 +21,7 @@ public WriteConfiguration getConfig() {
             return new KCVSConfiguration(new BackendOperation.TransactionalProvider() {
                 @Override
                 public StoreTransaction openTx() throws StorageException {
-                    return manager.beginTransaction(StandardTransactionHandleConfig.of(manager.getFeatures().getKeyConsistentTxConfig()));
+                    return manager.beginTransaction(StandardTransactionHandleConfig.of(Timestamps.MICRO, manager.getFeatures().getKeyConsistentTxConfig()));
                 }
 
                 @Override

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/MockIDAuthority.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
-import com.thinkaurelius.titan.core.time.Duration;
+import com.thinkaurelius.titan.util.time.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.core.TitanVertex;
-import com.thinkaurelius.titan.core.time.SimpleDuration;
+import com.thinkaurelius.titan.util.time.StandardDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StandardStoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
@@ -70,7 +70,7 @@ private static TitanGraph getInMemoryGraph() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, InMemoryStoreManager.class.getCanonicalName());
         config.set(GraphDatabaseConfiguration.IDS_FLUSH, false);
-        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT, new SimpleDuration(1L, TimeUnit.MILLISECONDS));
+        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT, new StandardDuration(1L, TimeUnit.MILLISECONDS));
         return TitanFactory.open(config);
     }
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -287,7 +287,7 @@ public ByteBuffer getValue(Column element) {
     }
 
     private long getTime(StoreTransaction txh) {
-        return txh.getConfiguration().getTimestamp().getTime(times.getUnit());
+        return times.getTime(times.getUnit());
     }
 
     private class RowIterator implements KeyIterator {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStorePerformance.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.diskstorage;
 
 import com.carrotsearch.junitbenchmarks.BenchmarkRule;
+import com.thinkaurelius.titan.core.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
@@ -23,7 +24,7 @@
  */
 
 @Category({ PerformanceTests.class })
-public abstract class KeyColumnValueStorePerformance {
+public abstract class KeyColumnValueStorePerformance extends AbstractKCVSTest {
 
     private Logger log = LoggerFactory.getLogger(KeyColumnValueStoreTest.class);
 
@@ -51,7 +52,7 @@ public void open() throws StorageException {
     }
 
     public StoreTransaction startTx() throws StorageException {
-        return manager.beginTransaction(StandardTransactionHandleConfig.of());
+        return manager.beginTransaction(getTxConfig());
     }
 
     public void clopen() throws StorageException {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -8,6 +8,7 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import com.thinkaurelius.titan.core.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.util.*;
 
 import org.junit.*;
@@ -24,7 +25,7 @@
 import com.thinkaurelius.titan.testcategory.UnorderedKeyStoreTests;
 import com.thinkaurelius.titan.testutil.RandomGenerator;
 
-public abstract class KeyColumnValueStoreTest {
+public abstract class KeyColumnValueStoreTest extends AbstractKCVSTest {
 
     @Rule
     public TestName name = new TestName();
@@ -55,7 +56,7 @@ public void open() throws StorageException {
     }
 
     public StoreTransaction startTx() throws StorageException {
-        return manager.beginTransaction(StandardTransactionHandleConfig.of());
+        return manager.beginTransaction(getTxConfig());
     }
 
     public StoreFeatures storeFeatures() {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyValueStoreTest.java
Patch:
@@ -4,6 +4,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import com.thinkaurelius.titan.core.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionHandleConfig;
 import org.junit.After;
 import org.junit.Assert;
@@ -20,7 +21,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.OrderedKeyValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
-public abstract class KeyValueStoreTest {
+public abstract class KeyValueStoreTest extends AbstractKCVSTest {
 
     private Logger log = LoggerFactory.getLogger(KeyValueStoreTest.class);
 
@@ -41,7 +42,7 @@ public void setUp() throws Exception {
     public void open() throws StorageException {
         manager = openStorageManager();
         store = manager.openDatabase(storeName);
-        tx = manager.beginTransaction(StandardTransactionHandleConfig.of());
+        tx = manager.beginTransaction(getTxConfig());
     }
 
     public abstract OrderedKeyValueStoreManager openStorageManager() throws StorageException;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -31,7 +31,7 @@
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
-public abstract class LockKeyColumnValueStoreTest {
+public abstract class LockKeyColumnValueStoreTest extends AbstractKCVSTest {
 
     private static final Logger log =
             LoggerFactory.getLogger(LockKeyColumnValueStoreTest.class);
@@ -90,7 +90,7 @@ public void open() throws StorageException {
             StoreFeatures storeFeatures = manager[i].getFeatures();
             store[i] = manager[i].openDatabase(DB_NAME);
             for (int j = 0; j < NUM_TX; j++) {
-                tx[i][j] = manager[i].beginTransaction(StandardTransactionHandleConfig.of());
+                tx[i][j] = manager[i].beginTransaction(getTxConfig());
                 log.debug("Began transaction of class {}", tx[i][j].getClass().getCanonicalName());
             }
 
@@ -112,7 +112,7 @@ public void open() throws StorageException {
     }
 
     public StoreTransaction newTransaction(KeyColumnValueStoreManager manager) throws StorageException {
-        StoreTransaction transaction = manager.beginTransaction(StandardTransactionHandleConfig.of());
+        StoreTransaction transaction = manager.beginTransaction(getTxConfig());
         if (!manager.getFeatures().hasLocking() && manager.getFeatures().isKeyConsistent()) {
             transaction = new ExpectedValueCheckingTransaction(transaction, manager.beginTransaction(StandardTransactionHandleConfig.of(manager.getFeatures().getKeyConsistentTxConfig())), GraphDatabaseConfiguration.STORAGE_READ_WAITTIME.getDefaultValue());
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/time/Timer.java
Patch:
@@ -56,6 +56,8 @@ public Duration elapsed() {
 
     public String toString() {
         TimeUnit u = times.getUnit();
+        if (start==null) return "Initialized";
+        if (stop==null) return String.format("Started at %d %s",start.getTime(u),u);
         return String.format("%d %s", stop.getTime(u) - start.getTime(u), u);
     }
 }

File: titan-hadoop/src/main/java/com/thinkaurelius/faunus/Tokens.java
Patch:
@@ -54,7 +54,7 @@ public static String makeNamespace(final Class klass) {
     public static final String NEWLINE = "\n";
     public static final String EMPTY_STRING = "";
 
-    public static final String FAUNUS_JOB_JAR = "faunus-" + VERSION + "-job.jar";
+    public static final String FAUNUS_JOB_JAR = "titan-hadoop-" + VERSION + "-job.jar";
     public static final String FAUNUS_HOME = "FAUNUS_HOME";
 
     public static final String PART = "part";

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -1235,9 +1235,6 @@ private static String computeUniqueInstanceId(Configuration config) {
             throw new TitanConfigurationException("Cannot determine local host", e);
         }
 
-        System.out.println("#### computeUniqueInstanceId(" + config + ") --> " + new String(Hex.encodeHex(addrBytes)) + suffix);
-        System.out.println("\t java.lang.management.ManagementFactory.getRuntimeMXBean().getName(): " +  java.lang.management.ManagementFactory.getRuntimeMXBean().getName());
-
         return new String(Hex.encodeHex(addrBytes)) + suffix;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/AttributeSerializer.java
Patch:
@@ -44,6 +44,6 @@ public interface AttributeSerializer<V> extends AttributeHandler<V> {
      * @param buffer    WriteBuffer to write attribute to
      * @param attribute Attribute to write to WriteBuffer
      */
-    public void writeObjectData(WriteBuffer buffer, V attribute);
+    public void write(WriteBuffer buffer, V attribute);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Geoshape.java
Patch:
@@ -398,7 +398,7 @@ public Geoshape read(ScanBuffer buffer) {
         }
 
         @Override
-        public void writeObjectData(WriteBuffer buffer, Geoshape attribute) {
+        public void write(WriteBuffer buffer, Geoshape attribute) {
             float[][] coordinates = attribute.coordinates;
             assert (coordinates.length==2);
             assert (coordinates[0].length==coordinates[1].length && coordinates[0].length>0);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/VariableLong.java
Patch:
@@ -127,7 +127,7 @@ public static void write(WriteBuffer out, final long value) {
         writeUnsigned(out, convert2Unsigned(value));
     }
 
-    public static long read(ReadBuffer in) {
+    public static long read(ScanBuffer in) {
         return convertFromUnsigned(readUnsigned(in));
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/DataOutput.java
Patch:
@@ -34,6 +34,8 @@ public interface DataOutput extends WriteBuffer {
 
     public DataOutput writeObject(Object object, Class<?> type);
 
+    public DataOutput writeObjectByteOrder(Object object, Class<?> type);
+
     public DataOutput writeObjectNotNull(Object object);
 
     public DataOutput writeClassAndObject(Object object);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/Serializer.java
Patch:
@@ -10,6 +10,8 @@ public interface Serializer extends AttributeHandling {
 
     public <T> T readObject(ReadBuffer buffer, Class<T> type);
 
+    public <T> T readObjectByteOrder(ReadBuffer buffer, Class<T> type);
+
     public <T> T readObjectNotNull(ReadBuffer buffer, Class<T> type);
 
     public DataOutput getDataOutput(int initialCapacity);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -51,7 +51,6 @@ public StandardAttributeHandling() {
         registerClass(Precision.class, new Precision.PrecisionSerializer());
         registerClass(Character.class, new CharacterSerializer());
         registerClass(Boolean.class, new BooleanSerializer());
-        registerClass(CString.class, new CStringSerializer());
         registerClass(Date.class, new DateSerializer());
 
         registerClass(Geoshape.class, new Geoshape.GeoshapeSerializer());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/BooleanArraySerializer.java
Patch:
@@ -47,7 +47,7 @@ public boolean[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, boolean[] attribute) {
+    public void write(WriteBuffer buffer, boolean[] attribute) {
         writeLength(buffer,attribute);
         if (attribute==null) return;
         byte b = 0;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ByteArraySerializer.java
Patch:
@@ -42,7 +42,7 @@ public byte[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, byte[] attribute) {
+    public void write(WriteBuffer buffer, byte[] attribute) {
         writeLength(buffer,attribute);
         if (attribute!=null) for (int i = 0; i < attribute.length; i++) buffer.putByte(attribute[i]);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/CharArraySerializer.java
Patch:
@@ -38,7 +38,7 @@ public char[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, char[] attribute) {
+    public void write(WriteBuffer buffer, char[] attribute) {
         writeLength(buffer,attribute);
         if (attribute!=null) for (int i = 0; i < attribute.length; i++) buffer.putChar(attribute[i]);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/DoubleArraySerializer.java
Patch:
@@ -38,7 +38,7 @@ public double[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, double[] attribute) {
+    public void write(WriteBuffer buffer, double[] attribute) {
         writeLength(buffer,attribute);
         if (attribute!=null) for (int i = 0; i < attribute.length; i++) buffer.putDouble(attribute[i]);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/DoubleSerializer.java
Patch:
@@ -30,7 +30,7 @@ public Double read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, Double attribute) {
+    public void write(WriteBuffer buffer, Double attribute) {
         buffer.putDouble(attribute.doubleValue());
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/FloatArraySerializer.java
Patch:
@@ -38,7 +38,7 @@ public float[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, float[] attribute) {
+    public void write(WriteBuffer buffer, float[] attribute) {
         writeLength(buffer,attribute);
         if (attribute!=null) for (int i = 0; i < attribute.length; i++) buffer.putFloat(attribute[i]);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/FloatSerializer.java
Patch:
@@ -32,7 +32,7 @@ public Float read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, Float attribute) {
+    public void write(WriteBuffer buffer, Float attribute) {
         buffer.putFloat(attribute.floatValue());
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/IntArraySerializer.java
Patch:
@@ -38,7 +38,7 @@ public int[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, int[] attribute) {
+    public void write(WriteBuffer buffer, int[] attribute) {
         writeLength(buffer,attribute);
         if (attribute!=null) for (int i = 0; i < attribute.length; i++) buffer.putInt(attribute[i]);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/LongArraySerializer.java
Patch:
@@ -38,7 +38,7 @@ public long[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, long[] attribute) {
+    public void write(WriteBuffer buffer, long[] attribute) {
         writeLength(buffer,attribute);
         if (attribute!=null) for (int i = 0; i < attribute.length; i++) buffer.putLong(attribute[i]);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ShortArraySerializer.java
Patch:
@@ -38,7 +38,7 @@ public short[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, short[] attribute) {
+    public void write(WriteBuffer buffer, short[] attribute) {
         writeLength(buffer,attribute);
         if (attribute!=null) for (int i = 0; i < attribute.length; i++) buffer.putShort(attribute[i]);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StringArraySerializer.java
Patch:
@@ -44,8 +44,8 @@ public String[] read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer buffer, String[] attribute) {
+    public void write(WriteBuffer buffer, String[] attribute) {
         writeLength(buffer,attribute);
-        if (attribute!=null) for (int i = 0; i < attribute.length; i++) stringSerializer.writeObjectData(buffer,attribute[i]);
+        if (attribute!=null) for (int i = 0; i < attribute.length; i++) stringSerializer.write(buffer, attribute[i]);
     }
 }
\ No newline at end of file

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -3,7 +3,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.*;
-import com.thinkaurelius.titan.core.attribute.CString;
 import com.thinkaurelius.titan.core.attribute.Cmp;
 import com.thinkaurelius.titan.core.attribute.Geo;
 import com.thinkaurelius.titan.core.attribute.Geoshape;
@@ -271,7 +270,7 @@ public void testIndexing() {
     private void setupChainGraph(int numV, String[] strs) {
         TitanGraphIndex vindex = getExternalIndex(Vertex.class,INDEX);
         TitanGraphIndex eindex = getExternalIndex(Edge.class,INDEX);
-        TitanKey name = makeKey("name",CString.class);
+        TitanKey name = makeKey("name",String.class);
         mgmt.addIndexKey(vindex,name,ParameterType.MAPPING.getParameter(Mapping.STRING));
         mgmt.addIndexKey(eindex,name,ParameterType.MAPPING.getParameter(Mapping.STRING));
         TitanKey text = makeKey("text",String.class);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/serializer/SpecialIntSerializer.java
Patch:
@@ -16,7 +16,7 @@ public SpecialInt read(ScanBuffer buffer) {
     }
 
     @Override
-    public void writeObjectData(WriteBuffer out, SpecialInt attribute) {
+    public void write(WriteBuffer out, SpecialInt attribute) {
         out.putInt(attribute.getValue());
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/StandardEdge.java
Patch:
@@ -6,6 +6,7 @@
 import com.thinkaurelius.titan.core.TitanType;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
+import com.thinkaurelius.titan.graphdb.types.system.ImplicitKey;
 
 import java.util.Collections;
 import java.util.HashMap;
@@ -49,6 +50,7 @@ public <O> O getPropertyDirect(TitanType type) {
 
     @Override
     public void setPropertyDirect(TitanType type, Object value) {
+        Preconditions.checkArgument(!(type instanceof ImplicitKey) && type.hasId(),"Cannot use implicit type [%s] when setting property",type.getName());
         if (properties == EMPTY_PROPERTIES) {
             if (tx().getConfiguration().isSingleThreaded()) {
                 properties = new HashMap<TitanType, Object>(5);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsTransaction.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
 import com.thinkaurelius.titan.graphdb.internal.TitanSchemaCategory;
 import com.thinkaurelius.titan.graphdb.relations.RelationIdentifier;
-import com.thinkaurelius.titan.graphdb.types.system.SystemKey;
+import com.thinkaurelius.titan.graphdb.types.system.BaseKey;
 import com.thinkaurelius.titan.util.datastructures.IterablesUtil;
 import com.tinkerpop.blueprints.*;
 import com.tinkerpop.blueprints.Parameter;
@@ -228,7 +228,7 @@ public <T extends Element> Set<String> getIndexedKeys(Class<T> elementClass) {
         Preconditions.checkArgument(elementClass == Vertex.class || elementClass == Edge.class, "Must provide either Vertex.class or Edge.class as an argument");
 
         Set<String> indexedkeys = new HashSet<String>();
-        for (TitanVertex k : getVertices(SystemKey.TypeCategory, TitanSchemaCategory.KEY)) {
+        for (TitanVertex k : getVertices(BaseKey.TypeCategory, TitanSchemaCategory.KEY)) {
             assert k instanceof InternalType;
             if (!Iterables.isEmpty(((InternalType) k).getKeyIndexes())) indexedkeys.add(((TitanKey)k).getName());
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
 import com.thinkaurelius.titan.graphdb.query.vertex.VertexCentricQueryBuilder;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.thinkaurelius.titan.graphdb.types.system.SystemKey;
+import com.thinkaurelius.titan.graphdb.types.system.BaseKey;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Vertex;
@@ -74,7 +74,7 @@ public synchronized void remove() {
             iter.remove();
         }
         //Finally remove internal/hidden relations
-        for (TitanProperty r : it().query().type(SystemKey.VertexExists).properties()) {
+        for (TitanProperty r : it().query().type(BaseKey.VertexExists).properties()) {
             r.remove();
         }
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -299,9 +299,9 @@ private void assignID(final InternalElement vertex, final long partitionIDl) {
                 if (vertex instanceof InternalRelation) {
                     id = idManager.getRelationID(pool.relation.nextID(), partitionID);
                 } else if (vertex instanceof TitanKey) {
-                    id = idManager.getSchemaId(IDManager.VertexIDType.PropertyKey,pool.relationType.nextID()+SystemTypeManager.SYSTEM_RELATIONTYPE_OFFSET);
+                    id = idManager.getSchemaId(IDManager.VertexIDType.UserPropertyKey,pool.relationType.nextID());
                 } else if (vertex instanceof TitanLabel) {
-                    id = idManager.getSchemaId(IDManager.VertexIDType.EdgeLabel, pool.relationType.nextID() + SystemTypeManager.SYSTEM_RELATIONTYPE_OFFSET);
+                    id = idManager.getSchemaId(IDManager.VertexIDType.UserEdgeLabel, pool.relationType.nextID());
                 } else if (vertex instanceof TitanSchemaVertex) {
                     id = idManager.getSchemaId(IDManager.VertexIDType.GenericSchemaType,pool.genericType.nextID()<<1);
                 } else {
@@ -385,7 +385,7 @@ private static class PartitionPool {
             relation = new StandardIDPool(idAuthority, PoolType.RELATION.getFullPartitionID(partitionID), idManager.getRelationCountBound(), renewTimeoutMS, renewBufferPercentage);
             if (includeType) {
                 relationType = new StandardIDPool(idAuthority, PoolType.RELATIONTYPE.getFullPartitionID(partitionID), idManager.getRelationTypeCountBound(), renewTimeoutMS, renewBufferPercentage);
-                genericType = new StandardIDPool(idAuthority, PoolType.GENERICTYPE.getFullPartitionID(partitionID), idManager.getRelationTypeCountBound(), renewTimeoutMS, renewBufferPercentage);
+                genericType = new StandardIDPool(idAuthority, PoolType.GENERICTYPE.getFullPartitionID(partitionID), idManager.getGenericTypeCountBound(), renewTimeoutMS, renewBufferPercentage);
             } else {
                 relationType = null;
                 genericType = null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/idmanagement/IDInspector.java
Patch:
@@ -15,6 +15,8 @@ public interface IDInspector {
 
     public boolean isPropertyKeyId(long id);
 
+    public boolean isSystemRelationTypeId(long id);
+
     public boolean isGenericSchemaVertexId(long id);
 
     public boolean isVertexId(long id);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemLabel.java
Patch:
@@ -8,7 +8,7 @@
 public class SystemLabel extends SystemType implements TitanLabel {
 
     public static final SystemLabel TypeDefinitionEdge =
-            new SystemLabel("TypeRelated", 6);
+            new SystemLabel("TypeRelated", 36);
 
     private SystemLabel(String name, int id) {
         super(name, id, RelationCategory.EDGE);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemType.java
Patch:
@@ -21,13 +21,12 @@ public abstract class SystemType extends EmptyType implements InternalType {
 
     static long getSystemTypeId(long id, RelationCategory type) {
         Preconditions.checkArgument(id > 0);
-        Preconditions.checkArgument(id < SystemTypeManager.SYSTEM_RELATIONTYPE_OFFSET, "System id [%s] is too large", id);
         Preconditions.checkArgument(type.isProper());
         switch (type) {
             case EDGE:
-                return IDManager.getSchemaId(IDManager.VertexIDType.EdgeLabel,id);
+                return IDManager.getSchemaId(IDManager.VertexIDType.SystemEdgeLabel,id);
             case PROPERTY:
-                return IDManager.getSchemaId(IDManager.VertexIDType.PropertyKey,id);
+                return IDManager.getSchemaId(IDManager.VertexIDType.SystemPropertyKey,id);
             default:
                 throw new AssertionError("Illegal condition: " + type);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -8,9 +8,7 @@
 
 public abstract class SystemTypeManager {
 
-    public static final String systemETprefix = "#System#";
-
-    public static final int SYSTEM_RELATIONTYPE_OFFSET = 8;
+    public static final String systemETprefix = "System%&%";
 
     private volatile static Map<Long, SystemType> SYSTEM_TYPES_BY_ID;
     private volatile static Map<String, SystemType> SYSTEM_TYPES_BY_NAME;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -191,13 +191,14 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
 
                 if (mut.hasAdditions()) {
                     for (Entry e : mut.getAdditions()) {
-                        rm.add(columnFamily, e.getColumnAs(StaticBuffer.BB_FACTORY), e.getValueAs(StaticBuffer.BB_FACTORY), timestamp.additionTime);
+                        rm.add(columnFamily, e.getColumnAs(StaticBuffer.BB_FACTORY), e.getValueAs(StaticBuffer.BB_FACTORY), timestamp.getAdditionTime(times.getUnit()));
+
                     }
                 }
 
                 if (mut.hasDeletions()) {
                     for (StaticBuffer col : mut.getDeletions()) {
-                        rm.delete(columnFamily, col.as(StaticBuffer.BB_FACTORY), timestamp.deletionTime);
+                        rm.delete(columnFamily, col.as(StaticBuffer.BB_FACTORY), timestamp.getDeletionTime(times.getUnit()));
                     }
                 }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -5,7 +5,9 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 
+import com.thinkaurelius.titan.core.time.SimpleDuration;
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
@@ -37,7 +39,7 @@ private static ModifiableConfiguration getGenericConfiguration(String ks, String
         ModifiableConfiguration config = buildConfiguration();
         config.set(CASSANDRA_KEYSPACE, cleanKeyspaceName(ks));
         config.set(PAGE_SIZE,500);
-        config.set(CONNECTION_TIMEOUT, 60000);
+        config.set(CONNECTION_TIMEOUT, new SimpleDuration(60L, TimeUnit.SECONDS));
         config.set(STORAGE_BACKEND, backend);
         return config;
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphTest.java
Patch:
@@ -3,9 +3,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
-
 import org.junit.BeforeClass;
-import org.junit.experimental.categories.Category;
 
 public class InternalCassandraGraphTest extends TitanGraphTest {
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TypeMaker.java
Patch:
@@ -16,5 +16,7 @@
  */
 public interface TypeMaker {
 
+    public String getName();
+
     public TitanType make();
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/olap/OLAPQueryBuilder.java
Patch:
@@ -6,6 +6,9 @@
 import com.tinkerpop.blueprints.Predicate;
 
 /**
+ * Builds a vertex-centric query to define the edges and/or properties that will be accessible during the execution
+ * of an {@link OLAPJob} as defined through the associated {@link OLAPQueryBuilder}.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public interface OLAPQueryBuilder<S> extends BaseVertexQuery {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthority.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage;
 
+import com.thinkaurelius.titan.core.time.Duration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
@@ -33,11 +34,9 @@ public interface IDAuthority {
      *            When a call to this method is unable to return a id block
      *            before this timeout elapses, the implementation must give up
      *            and throw a {@code StorageException} ASAP
-     * @param TimeUnit
-     *            Units associated with the {@code timeout} parameter
      * @return a range of ids for the {@code partition} parameter
      */
-    public long[] getIDBlock(int partition, long timeout, TimeUnit unit)
+    public long[] getIDBlock(int partition, Duration timout)
             throws StorageException;
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.idmanagement;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.time.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
@@ -27,7 +28,7 @@ public abstract class AbstractIDManager implements IDAuthority {
       */
     protected static final long BASE_ID = 1;
 
-    protected final long idApplicationWaitMS;
+    protected final Duration idApplicationWaitMS;
     protected final int randomUniqueIDLimit;
 
     protected final String uid;
@@ -46,7 +47,7 @@ public AbstractIDManager(Configuration config) {
         this.isActive = false;
 
         this.idApplicationWaitMS =
-                config.get(GraphDatabaseConfiguration.IDAUTHORITY_WAIT_MS);
+                config.get(GraphDatabaseConfiguration.IDAUTHORITY_WAIT);
 
         this.randomUniqueIDLimit =
                 config.get(GraphDatabaseConfiguration.IDAUTHORITY_UNIQUEID_RETRY_COUNT);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSUtil.java
Patch:
@@ -64,7 +64,7 @@ public static StaticBuffer get(KeyColumnValueStore store, StaticBuffer key, Stat
      * @return keys returned by the store.getKeys call
      * @throws StorageException unexpected failure
      */
-    public static RecordIterator<StaticBuffer> getKeys(KeyColumnValueStore store, StoreFeatures features, int keyLength, int sliceLength, StoreTransaction txh) throws StorageException {
+    public static KeyIterator getKeys(KeyColumnValueStore store, StoreFeatures features, int keyLength, int sliceLength, StoreTransaction txh) throws StorageException {
         SliceQuery slice = new SliceQuery(BufferUtil.zeroBuffer(sliceLength), BufferUtil.oneBuffer(sliceLength)).setLimit(1);
         if (features.hasUnorderedScan()) {
             return store.getKeys(slice, txh);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStoreManager.java
Patch:
@@ -61,7 +61,6 @@ public StoreTransaction beginTransaction(TransactionHandleConfig configuration)
         TransactionHandleConfig consistentTxCfg = new StandardTransactionConfig.Builder()
                 .metricsPrefix(configuration.getMetricsPrefix())
                 .customOptions(customOptions)
-                .timestampProvider(configuration.getTimestampProvider())
                 .build();
         StoreTransaction consistentTx = storeManager.beginTransaction(consistentTxCfg);
         StoreTransaction wrappedTx = new ExpectedValueCheckingTransaction(tx, consistentTx, readAttempts);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSMessage.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.log.kcvs;
 
+import com.thinkaurelius.titan.core.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.util.AbstractMessage;
 
@@ -10,7 +11,7 @@
  */
 public class KCVSMessage extends AbstractMessage {
 
-    public KCVSMessage(StaticBuffer payload, long timestampMirco, String senderId) {
-        super(payload, timestampMirco, senderId);
+    public KCVSMessage(StaticBuffer payload, Timepoint timestamp, String senderId) {
+        super(payload, timestamp, senderId);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -78,7 +78,7 @@ public Direction getDirection() {
         }
 
         public int getPrefix(boolean hidden) {
-            return ((hidden?1:0)<<2) + getRelationType();
+            return ((hidden?0:1)<<2) + getRelationType();
         }
 
         private static DirectionID getDirectionID(int relationType, int direction) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StringArraySerializer.java
Patch:
@@ -8,7 +8,6 @@
 
 public class StringArraySerializer extends ArraySerializer implements AttributeSerializer<String[]> {
 
-    //TODO: use StringX here
     private static final StringSerializer stringSerializer = new StringSerializer();
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/IndexLockTuple.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
 import com.thinkaurelius.titan.graphdb.types.InternalIndexType;
-import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardTypeMaker.java
Patch:
@@ -51,7 +51,7 @@ public StandardTypeMaker(final StandardTitanTx tx, final IndexSerializer indexSe
     }
 
 
-    protected String getName() {
+    public String getName() {
         return this.name;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/typemaker/DisableDefaultTypeMaker.java
Patch:
@@ -15,12 +15,12 @@ private DisableDefaultTypeMaker() {
 
     @Override
     public TitanLabel makeLabel(LabelMaker factory) {
-        throw new IllegalArgumentException("Label with given name does not exist");
+        throw new IllegalArgumentException("Label with given name does not exist: " + factory.getName());
     }
 
     @Override
     public TitanKey makeKey(KeyMaker factory) {
-        throw new IllegalArgumentException("Key with given name does not exist");
+        throw new IllegalArgumentException("Key with given name does not exist: " + factory.getName());
     }
 
     @Override

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -189,14 +189,14 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
                 if (mut.hasAdditions()) {
                     for (Entry e : mut.getAdditions()) {
                         QueryPath path = new QueryPath(columnFamily, null, e.getColumnAs(StaticBuffer.BB_FACTORY));
-                        rm.add(path, e.getValueAs(StaticBuffer.BB_FACTORY), timestamp.additionTime);
+                        rm.add(path, e.getValueAs(StaticBuffer.BB_FACTORY), timestamp.getAdditionTime(times.getUnit()));
                     }
                 }
 
                 if (mut.hasDeletions()) {
                     for (StaticBuffer col : mut.getDeletions()) {
                         QueryPath path = new QueryPath(columnFamily, null, col.as(StaticBuffer.BB_FACTORY));
-                        rm.delete(path, timestamp.deletionTime);
+                        rm.delete(path, timestamp.getDeletionTime(times.getUnit()));
                     }
                 }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -5,7 +5,9 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 
+import com.thinkaurelius.titan.core.time.SimpleDuration;
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
@@ -37,7 +39,7 @@ private static ModifiableConfiguration getGenericConfiguration(String ks, String
         ModifiableConfiguration config = buildConfiguration();
         config.set(CASSANDRA_KEYSPACE, cleanKeyspaceName(ks));
         config.set(PAGE_SIZE,500);
-        config.set(CONNECTION_TIMEOUT, 60000);
+        config.set(CONNECTION_TIMEOUT, new SimpleDuration(60L, TimeUnit.SECONDS));
         config.set(STORAGE_BACKEND, backend);
         return config;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.core.TitanConfigurationException;
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.core.TitanFactory;
+import com.thinkaurelius.titan.core.time.Duration;
 import com.thinkaurelius.titan.diskstorage.configuration.*;
 import com.thinkaurelius.titan.diskstorage.idmanagement.ConsistentKeyIDManager;
 import com.thinkaurelius.titan.diskstorage.indexing.*;
@@ -111,7 +112,7 @@ public class Backend implements LockerProvider {
     private final int bufferSize;
     private final int writeAttempts;
     private final int readAttempts;
-    private final int persistAttemptWaittime;
+    private final Duration persistAttemptWaittime;
     private final boolean cacheEnabled;
     private final ExecutorService threadPool;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthority.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage;
 
+import com.thinkaurelius.titan.core.time.Duration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
@@ -33,11 +34,9 @@ public interface IDAuthority {
      *            When a call to this method is unable to return a id block
      *            before this timeout elapses, the implementation must give up
      *            and throw a {@code StorageException} ASAP
-     * @param TimeUnit
-     *            Units associated with the {@code timeout} parameter
      * @return a range of ids for the {@code partition} parameter
      */
-    public long[] getIDBlock(int partition, long timeout, TimeUnit unit)
+    public long[] getIDBlock(int partition, Duration timout)
             throws StorageException;
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.idmanagement;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.time.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
@@ -27,7 +28,7 @@ public abstract class AbstractIDManager implements IDAuthority {
       */
     protected static final long BASE_ID = 1;
 
-    protected final long idApplicationWaitMS;
+    protected final Duration idApplicationWaitMS;
     protected final int randomUniqueIDLimit;
 
     protected final String uid;
@@ -46,7 +47,7 @@ public AbstractIDManager(Configuration config) {
         this.isActive = false;
 
         this.idApplicationWaitMS =
-                config.get(GraphDatabaseConfiguration.IDAUTHORITY_WAIT_MS);
+                config.get(GraphDatabaseConfiguration.IDAUTHORITY_WAIT);
 
         this.randomUniqueIDLimit =
                 config.get(GraphDatabaseConfiguration.IDAUTHORITY_UNIQUEID_RETRY_COUNT);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.time.Duration;
 import com.thinkaurelius.titan.diskstorage.LoggableTransaction;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;
@@ -30,12 +31,12 @@ public class IndexTransaction implements TransactionHandle, LoggableTransaction
     private final KeyInformation.IndexRetriever keyInformations;
 
     private final int mutationAttempts;
-    private final int attemptWaitTime;
+    private final Duration attemptWaitTime;
 
     private Map<String,Map<String,IndexMutation>> mutations;
 
     public IndexTransaction(final IndexProvider index, final KeyInformation.IndexRetriever keyInformations,
-                            int mutationAttempts, int attemptWaitTime) throws StorageException {
+                            int mutationAttempts, Duration attemptWaitTime) throws StorageException {
         Preconditions.checkNotNull(index);
         Preconditions.checkNotNull(keyInformations);
         this.index=index;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStoreManager.java
Patch:
@@ -61,7 +61,6 @@ public StoreTransaction beginTransaction(TransactionHandleConfig configuration)
         TransactionHandleConfig consistentTxCfg = new StandardTransactionConfig.Builder()
                 .metricsPrefix(configuration.getMetricsPrefix())
                 .customOptions(customOptions)
-                .timestampProvider(configuration.getTimestampProvider())
                 .build();
         StoreTransaction consistentTx = storeManager.beginTransaction(consistentTxCfg);
         StoreTransaction wrappedTx = new ExpectedValueCheckingTransaction(tx, consistentTx, readAttempts);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSMessage.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.log.kcvs;
 
+import com.thinkaurelius.titan.core.time.Timepoint;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.log.util.AbstractMessage;
 
@@ -10,7 +11,7 @@
  */
 public class KCVSMessage extends AbstractMessage {
 
-    public KCVSMessage(StaticBuffer payload, long timestampMirco, String senderId) {
-        super(payload, timestampMirco, senderId);
+    public KCVSMessage(StaticBuffer payload, Timepoint timestamp, String senderId) {
+        super(payload, timestamp, senderId);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -5,6 +5,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.*;
+import com.thinkaurelius.titan.core.time.SimpleDuration;
+import com.thinkaurelius.titan.core.time.Timepoint;
 import com.thinkaurelius.titan.graphdb.database.management.LogTxStatus;
 import com.thinkaurelius.titan.graphdb.database.management.MgmtLogType;
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.*;
@@ -68,7 +70,6 @@ public StandardAttributeHandling() {
         registerClass(char[].class, new CharArraySerializer());
         registerClass(boolean[].class, new BooleanArraySerializer());
         registerClass(String[].class, new StringArraySerializer());
-
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/IndexLockTuple.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction.lock;
 
 import com.thinkaurelius.titan.graphdb.types.InternalIndexType;
-import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/MultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -3,6 +3,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
+import com.thinkaurelius.titan.core.time.ZeroDuration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.cache.CacheTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.cache.NoKCVSCache;
@@ -58,7 +59,7 @@ public void tearDown() throws Exception {
 
     public void open() throws StorageException {
         manager = openStorageManager();
-        tx = new CacheTransaction(manager.beginTransaction(StandardTransactionConfig.of()), manager, bufferSize, 1, 0, true);
+        tx = new CacheTransaction(manager.beginTransaction(StandardTransactionConfig.of()), manager, bufferSize, 1, ZeroDuration.INSTANCE, true);
         store1 = new NoKCVSCache(manager.openDatabase(storeName1));
         store2 = new NoKCVSCache(manager.openDatabase(storeName2));
 
@@ -78,7 +79,7 @@ public void clopen() throws StorageException {
 
     public void newTx() throws StorageException {
         if (tx!=null) tx.commit();
-        tx = new CacheTransaction(manager.beginTransaction(StandardTransactionConfig.of()), manager, bufferSize, 1, 0, true);
+        tx = new CacheTransaction(manager.beginTransaction(StandardTransactionConfig.of()), manager, bufferSize, 1, ZeroDuration.INSTANCE, true);
     }
 
     @Test

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/MockIDAuthority.java
Patch:
@@ -2,12 +2,12 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import com.thinkaurelius.titan.core.time.Duration;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
-import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDPoolExhaustedException;
@@ -16,7 +16,6 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
@@ -53,7 +52,7 @@ public MockIDAuthority(int blockSize, int blockSizeLimit, int delayAcquisitionMS
     }
 
     @Override
-    public long[] getIDBlock(int partition, long timeout, TimeUnit unit) throws StorageException {
+    public long[] getIDBlock(int partition, Duration timeout) throws StorageException {
         //Delay artificially
         if (delayAcquisitionMS>0) {
             try {

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -3,6 +3,7 @@
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.core.TitanVertex;
+import com.thinkaurelius.titan.core.time.SimpleDuration;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StandardStoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
@@ -20,6 +21,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -68,7 +70,7 @@ private static TitanGraph getInMemoryGraph() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, InMemoryStoreManager.class.getCanonicalName());
         config.set(GraphDatabaseConfiguration.IDS_FLUSH, false);
-        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT_MS,1);
+        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT, new SimpleDuration(1L, TimeUnit.MILLISECONDS));
         return TitanFactory.open(config);
     }
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -71,7 +71,7 @@ public CassandraThriftStoreManager(Configuration config) throws StorageException
          * This is eventually passed to Thrift's TSocket constructor. The
          * constructor parameter is of type int.
          */
-        int thriftTimeoutMS = (int)config.get(GraphDatabaseConfiguration.CONNECTION_TIMEOUT_MS).getLength(TimeUnit.MILLISECONDS);
+        int thriftTimeoutMS = (int)config.get(GraphDatabaseConfiguration.CONNECTION_TIMEOUT).getLength(TimeUnit.MILLISECONDS);
 
         int maxTotalConnections = config.get(GraphDatabaseConfiguration.CONNECTION_POOL_SIZE);
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -39,7 +39,7 @@ private static ModifiableConfiguration getGenericConfiguration(String ks, String
         ModifiableConfiguration config = buildConfiguration();
         config.set(CASSANDRA_KEYSPACE, cleanKeyspaceName(ks));
         config.set(PAGE_SIZE,500);
-        config.set(CONNECTION_TIMEOUT_MS, new SimpleDuration(60L, TimeUnit.SECONDS));
+        config.set(CONNECTION_TIMEOUT, new SimpleDuration(60L, TimeUnit.SECONDS));
         config.set(STORAGE_BACKEND, backend);
         return config;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/DistributedStoreManager.java
Patch:
@@ -65,7 +65,7 @@ public DistributedStoreManager(Configuration storageConfig, int portDefault) {
         Preconditions.checkArgument(hostnames.length > 0, "No hostname configured");
         if (storageConfig.has(PORT)) this.port = storageConfig.get(PORT);
         else this.port = portDefault;
-        this.connectionTimeoutMS = storageConfig.get(CONNECTION_TIMEOUT_MS);
+        this.connectionTimeoutMS = storageConfig.get(CONNECTION_TIMEOUT);
         this.connectionPoolSize = storageConfig.get(CONNECTION_POOL_SIZE);
         this.pageSize = storageConfig.get(PAGE_SIZE);
         this.times = storageConfig.get(TIMESTAMP_PROVIDER);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -47,7 +47,7 @@ public AbstractIDManager(Configuration config) {
         this.isActive = false;
 
         this.idApplicationWaitMS =
-                config.get(GraphDatabaseConfiguration.IDAUTHORITY_WAIT_MS);
+                config.get(GraphDatabaseConfiguration.IDAUTHORITY_WAIT);
 
         this.randomUniqueIDLimit =
                 config.get(GraphDatabaseConfiguration.IDAUTHORITY_UNIQUEID_RETRY_COUNT);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -414,7 +414,7 @@ public boolean apply(@Nullable String s) {
      * The number of milliseconds the system waits for an id block application to be acknowledged by the storage backend.
      * Also, the time waited after the application before verifying that the application was successful.
      */
-    public static final ConfigOption<Duration> IDAUTHORITY_WAIT_MS = new ConfigOption<Duration>(STORAGE_NS,"idauthority-wait-time",
+    public static final ConfigOption<Duration> IDAUTHORITY_WAIT = new ConfigOption<Duration>(STORAGE_NS,"idauthority-wait-time",
             "The number of milliseconds the system waits for an id block application to be acknowledged by the storage backend",
             ConfigOption.Type.GLOBAL_OFFLINE, Duration.class, new SimpleDuration(300L, TimeUnit.MILLISECONDS));
 //    public static final String IDAUTHORITY_WAIT_MS_KEY = "idauthority-wait-time";
@@ -573,7 +573,7 @@ public boolean apply(@Nullable Integer uniqueIdBitWidth) {
      * Default timeout when connecting to a remote database instance
      * <p/>
      */
-    public static final ConfigOption<Duration> CONNECTION_TIMEOUT_MS = new ConfigOption<Duration>(STORAGE_NS,"connection-timeout",
+    public static final ConfigOption<Duration> CONNECTION_TIMEOUT = new ConfigOption<Duration>(STORAGE_NS,"connection-timeout",
             "Default timeout, in milliseconds, when connecting to a remote database instance",
             ConfigOption.Type.MASKABLE, Duration.class, new SimpleDuration(10000L, TimeUnit.MILLISECONDS));
 //    public static final int CONNECTION_TIMEOUT_DEFAULT = 10000;
@@ -660,7 +660,7 @@ public boolean apply(@Nullable Integer uniqueIdBitWidth) {
      * of ids. Note, that failure to allocate a new id block will cause the entire database to fail, hence this value
      * should be set conservatively. Choose a high value if there is a lot of contention around id allocation.
      */
-    public static final ConfigOption<Duration> IDS_RENEW_TIMEOUT_MS = new ConfigOption<Duration>(IDS_NS,"renew-timeout",
+    public static final ConfigOption<Duration> IDS_RENEW_TIMEOUT = new ConfigOption<Duration>(IDS_NS,"renew-timeout",
             "The number of milliseconds that the Titan id pool manager will wait before giving up on allocating a new block of ids",
             ConfigOption.Type.MASKABLE, Duration.class, new SimpleDuration(60000L, TimeUnit.MILLISECONDS));
 //    public static final String IDS_RENEW_TIMEOUT_KEY = "renew-timeout";

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -102,7 +102,7 @@ public VertexIDAssigner(Configuration config, IDAuthority idAuthority, StoreFeat
         long baseBlockSize = config.get(IDS_BLOCK_SIZE);
         idAuthority.setIDBlockSizer(new SimpleVertexIDBlockSizer(baseBlockSize));
 
-        renewTimeoutMS = config.get(IDS_RENEW_TIMEOUT_MS);
+        renewTimeoutMS = config.get(IDS_RENEW_TIMEOUT);
         renewBufferPercentage = config.get(IDS_RENEW_BUFFER_PERCENTAGE);
 
         idPools = new OpenIntObjectHashMap();

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAllocationTest.java
Patch:
@@ -64,7 +64,7 @@ public static Collection<Object[]> configs() {
 
         c = getBasicConfig();
         c.set(IDAUTHORITY_UNIQUEID_RETRY_COUNT,10);
-        c.set(IDAUTHORITY_WAIT_MS, new SimpleDuration(10L, TimeUnit.MILLISECONDS));
+        c.set(IDAUTHORITY_WAIT, new SimpleDuration(10L, TimeUnit.MILLISECONDS));
         c.set(IDAUTHORITY_UNIQUE_ID_BITS,7);
         c.set(IDAUTHORITY_RANDOMIZE_UNIQUE_ID,true);
         configurations.add(new Object[]{c.getConfiguration()});
@@ -75,7 +75,7 @@ public static Collection<Object[]> configs() {
     public static ModifiableConfiguration getBasicConfig() {
         ModifiableConfiguration c = GraphDatabaseConfiguration.buildConfiguration();
         c.set(IDAUTHORITY_UNIQUEID_RETRY_COUNT,50);
-        c.set(IDAUTHORITY_WAIT_MS, new SimpleDuration(100L, TimeUnit.MILLISECONDS));
+        c.set(IDAUTHORITY_WAIT, new SimpleDuration(100L, TimeUnit.MILLISECONDS));
         c.set(IDS_BLOCK_SIZE,400);
         return c;
     }

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -70,7 +70,7 @@ private static TitanGraph getInMemoryGraph() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, InMemoryStoreManager.class.getCanonicalName());
         config.set(GraphDatabaseConfiguration.IDS_FLUSH, false);
-        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT_MS, new SimpleDuration(1L, TimeUnit.MILLISECONDS));
+        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT, new SimpleDuration(1L, TimeUnit.MILLISECONDS));
         return TitanFactory.open(config);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphTest.java
Patch:
@@ -3,9 +3,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
-
 import org.junit.BeforeClass;
-import org.junit.experimental.categories.Category;
 
 public class InternalCassandraGraphTest extends TitanGraphTest {
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/olap/OLAPQueryBuilder.java
Patch:
@@ -6,6 +6,9 @@
 import com.tinkerpop.blueprints.Predicate;
 
 /**
+ * Builds a vertex-centric query to define the edges and/or properties that will be accessible during the execution
+ * of an {@link OLAPJob} as defined through the associated {@link OLAPQueryBuilder}.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public interface OLAPQueryBuilder<S> extends BaseVertexQuery {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVSUtil.java
Patch:
@@ -64,7 +64,7 @@ public static StaticBuffer get(KeyColumnValueStore store, StaticBuffer key, Stat
      * @return keys returned by the store.getKeys call
      * @throws StorageException unexpected failure
      */
-    public static RecordIterator<StaticBuffer> getKeys(KeyColumnValueStore store, StoreFeatures features, int keyLength, int sliceLength, StoreTransaction txh) throws StorageException {
+    public static KeyIterator getKeys(KeyColumnValueStore store, StoreFeatures features, int keyLength, int sliceLength, StoreTransaction txh) throws StorageException {
         SliceQuery slice = new SliceQuery(BufferUtil.zeroBuffer(sliceLength), BufferUtil.oneBuffer(sliceLength)).setLimit(1);
         if (features.hasUnorderedScan()) {
             return store.getKeys(slice, txh);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -78,7 +78,7 @@ public Direction getDirection() {
         }
 
         public int getPrefix(boolean hidden) {
-            return ((hidden?1:0)<<2) + getRelationType();
+            return ((hidden?0:1)<<2) + getRelationType();
         }
 
         private static DirectionID getDirectionID(int relationType, int direction) {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAllocationTest.java
Patch:
@@ -27,7 +27,7 @@
 
 import java.util.*;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -315,7 +315,7 @@ public void testManyThreadsOneIDAuthority() throws StorageException, Interrupted
         final IDAuthority targetAuthority = idAuthorities[0];
         targetAuthority.setIDBlockSizer(new InnerIDBlockSizer());
         final int targetPartition = 0;
-        final ConcurrentLinkedDeque<Long> blocks = new ConcurrentLinkedDeque<Long>();
+        final ConcurrentLinkedQueue<Long> blocks = new ConcurrentLinkedQueue<Long>();
         final int blocksPerThread = 40;
         Assert.assertTrue(0 < blocksPerThread);
         List <Future<Void>> futures = new ArrayList<Future<Void>>(CONCURRENCY);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -277,7 +277,7 @@ private void setupChainGraph(int numV, String[] strs) {
         TitanKey text = makeKey("text",String.class);
         mgmt.addIndexKey(vindex,text,ParameterType.MAPPING.getParameter(Mapping.TEXT));
         mgmt.addIndexKey(eindex,text,ParameterType.MAPPING.getParameter(Mapping.TEXT));
-        mgmt.makeLabel("knows").sortKey(name).sortOrder(Order.DESC).make();
+        mgmt.makeLabel("knows").signature(name).make();
         finishSchema();
         TitanVertex previous = null;
         for (int i=0;i<numV;i++) {

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -37,7 +37,7 @@ public static Collection<Object[]> configs() {
         configurations.add(new Object[]{false, Integer.MAX_VALUE, null});
 
         for (int max : new int[]{Integer.MAX_VALUE, 100}) {
-            for (int[] local : new int[][]{null, {0, 2000}, {-100000, -1}, {-10000, 10000}}) {
+            for (int[] local : new int[][]{null, {0, 2000}, {-100000, -1}, {10000, -10000}}) {
                 configurations.add(new Object[]{true, max, local});
             }
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TypeMaker.java
Patch:
@@ -16,5 +16,7 @@
  */
 public interface TypeMaker {
 
+    public String getName();
+
     public TitanType make();
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardTypeMaker.java
Patch:
@@ -51,7 +51,7 @@ public StandardTypeMaker(final StandardTitanTx tx, final IndexSerializer indexSe
     }
 
 
-    protected String getName() {
+    public String getName() {
         return this.name;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/typemaker/DisableDefaultTypeMaker.java
Patch:
@@ -15,12 +15,12 @@ private DisableDefaultTypeMaker() {
 
     @Override
     public TitanLabel makeLabel(LabelMaker factory) {
-        throw new IllegalArgumentException("Label with given name does not exist");
+        throw new IllegalArgumentException("Label with given name does not exist: " + factory.getName());
     }
 
     @Override
     public TitanKey makeKey(KeyMaker factory) {
-        throw new IllegalArgumentException("Key with given name does not exist");
+        throw new IllegalArgumentException("Key with given name does not exist: " + factory.getName());
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -274,7 +274,7 @@ private void setupChainGraph(int numV, String[] strs) {
         TitanKey text = makeKey("text",String.class);
         mgmt.addIndexKey(vindex,text,ParameterType.MAPPING.getParameter(Mapping.TEXT));
         mgmt.addIndexKey(eindex,text,ParameterType.MAPPING.getParameter(Mapping.TEXT));
-        mgmt.makeLabel("knows").sortKey(name).sortOrder(Order.DESC).make();
+        mgmt.makeLabel("knows").signature(name).make();
         finishSchema();
         TitanVertex previous = null;
         for (int i=0;i<numV;i++) {

File: titan-test/src/main/java/com/thinkaurelius/titan/olap/OLAPTest.java
Patch:
@@ -226,7 +226,7 @@ public void process(TitanVertex vertex) {
             for (PageRank pr : ranks.values()) {
                 totalDelta+=pr.completeIteration();
             }
-            System.out.println(String.format("Completed iteration [%s] in time %s ms with delta PR=%s",iteration,w.elapsed(TimeUnit.MILLISECONDS),totalDelta));
+//            System.out.println(String.format("Completed iteration [%s] in time %s ms with delta PR=%s",iteration,w.elapsed(TimeUnit.MILLISECONDS),totalDelta));
         } while (totalDelta>PR_TERMINATION_THRESHOLD);
         return ranks;
     }

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyJEOLAPTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.titan.BerkeleyJeStorageSetup;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
-import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 import com.thinkaurelius.titan.olap.FulgoraOLAPTest;
 
 public class BerkeleyJEOLAPTest extends FulgoraOLAPTest {

File: titan-hbase/common/test/java/com/thinkaurelius/titan/graphdb/hbase/HBaseOLAPTest.java
Patch:
@@ -7,7 +7,7 @@
 
 import java.io.IOException;
 
-public class HBaseGraphTest extends FulgoraOLAPTest {
+public class HBaseOLAPTest extends FulgoraOLAPTest {
     @BeforeClass
     public static void startHBase() throws IOException {
         HBaseStorageSetup.startHBase();

File: titan-core/src/main/java/com/thinkaurelius/titan/core/olap/OLAPQueryBuilder.java
Patch:
@@ -6,6 +6,9 @@
 import com.tinkerpop.blueprints.Predicate;
 
 /**
+ * Builds a vertex-centric query to define the edges and/or properties that will be accessible during the execution
+ * of an {@link OLAPJob} as defined through the associated {@link OLAPQueryBuilder}.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 public interface OLAPQueryBuilder<S> extends BaseVertexQuery {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -42,7 +42,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
 
 import static com.thinkaurelius.titan.diskstorage.cassandra.CassandraTransaction.getTx;
 import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.STORAGE_NS;
@@ -461,8 +460,8 @@ private AstyanaxContext.Builder getContextBuilder(Configuration config, int maxC
                         .setRetryDelaySlice(retryDelaySlice)
                         .setRetryMaxDelaySlice(retryMaxDelaySlice)
                         .setRetrySuspendWindow(retrySuspendWindow)
-                        .setSocketTimeout((int)getConnectionTimeout(TimeUnit.MILLISECONDS))
-                        .setConnectTimeout((int)getConnectionTimeout(TimeUnit.MILLISECONDS))
+                        .setSocketTimeout((int)connectionTimeoutMS)
+                        .setConnectTimeout((int)connectionTimeoutMS)
                         .setSeeds(StringUtils.join(hostnames, ","));
 
         if (null != retryBackoffStrategy) {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -37,7 +37,7 @@ private static ModifiableConfiguration getGenericConfiguration(String ks, String
         ModifiableConfiguration config = buildConfiguration();
         config.set(CASSANDRA_KEYSPACE, cleanKeyspaceName(ks));
         config.set(PAGE_SIZE,500);
-        config.set(CONNECTION_TIMEOUT, 60000);
+        config.set(CONNECTION_TIMEOUT_MS, 60000L);
         config.set(STORAGE_BACKEND, backend);
         return config;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BackendTransaction.java
Patch:
@@ -51,15 +51,15 @@ public class BackendTransaction implements TransactionHandle, LoggableTransactio
     private final KeyColumnValueStore indexStore;
 
     private final int maxReadRetryAttempts;
-    private final long retryStorageWaitTime;
+    private final int retryStorageWaitTime;
 
     private final Executor threadPool;
 
     private final Map<String, IndexTransaction> indexTx;
 
     public BackendTransaction(CacheTransaction storeTx, TransactionHandleConfig txConfig,
                               StoreFeatures features, KeyColumnValueStore edgeStore, KeyColumnValueStore indexStore,
-                              int maxReadRetryAttempts, long retryStorageWaitTime,
+                              int maxReadRetryAttempts, int retryStorageWaitTime,
                               Map<String, IndexTransaction> indexTx, Executor threadPool) {
         this.storeTx = storeTx;
         this.txConfig = txConfig;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -30,12 +30,12 @@ public class IndexTransaction implements TransactionHandle, LoggableTransaction
     private final KeyInformation.IndexRetriever keyInformations;
 
     private final int mutationAttempts;
-    private final long attemptWaitTime;
+    private final int attemptWaitTime;
 
     private Map<String,Map<String,IndexMutation>> mutations;
 
     public IndexTransaction(final IndexProvider index, final KeyInformation.IndexRetriever keyInformations,
-                            int mutationAttempts, long attemptWaitTime) throws StorageException {
+                            int mutationAttempts, int attemptWaitTime) throws StorageException {
         Preconditions.checkNotNull(index);
         Preconditions.checkNotNull(keyInformations);
         this.index=index;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -31,18 +31,18 @@ public class CacheTransaction implements StoreTransaction, LoggableTransaction {
     private final boolean continuousPersistence;
     private final int persistChunkSize;
     private final int mutationAttempts;
-    private final long attemptWaitTime;
+    private final int attemptWaitTime;
 
     private int numMutations;
     private final Map<KCVSCache, Map<StaticBuffer, KCVMutation>> mutations;
 
     public CacheTransaction(StoreTransaction tx, KeyColumnValueStoreManager manager,
-                             int persistChunkSize, int attempts, long waitTime, boolean continuousPersistence) {
+                             int persistChunkSize, int attempts, int waitTime, boolean continuousPersistence) {
         this(tx, manager, persistChunkSize, attempts, waitTime, continuousPersistence, 2);
     }
 
     public CacheTransaction(StoreTransaction tx, KeyColumnValueStoreManager manager, int persistChunkSize,
-                            int attempts, long waitTime, boolean continuousPersistence, int expectedNumStores) {
+                            int attempts, int waitTime, boolean continuousPersistence, int expectedNumStores) {
         Preconditions.checkArgument(tx != null && manager != null && persistChunkSize > 0);
         this.tx = tx;
         this.manager = manager;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediators.java
Patch:
@@ -68,7 +68,7 @@ public void clear() {
      * This deletes all entries in the global map of namespaces to mediators
      * whose namespace key equals the argument.
      * 
-     * @param namespace
+     * @param prefix 
      */
     public void clear(String namespace) {
         Iterator<Entry<String, LocalLockMediator<?>>> iter = mediators.entrySet().iterator();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/StandardLockCleanerService.java
Patch:
@@ -64,7 +64,6 @@ public StandardLockCleanerService(KeyColumnValueStore store, ConsistentKeyLocker
         this (store, serializer, getDefaultExecutor(), COOLDOWN_TIME, COOLDOWN_UNIT);
     }
 
-    @Override
     public void clean(KeyColumn target, long cutoff, StoreTransaction tx) {
         Long b = blocked.putIfAbsent(target, cutoff);
         if (null == b) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSMessage.java
Patch:
@@ -10,7 +10,7 @@
  */
 public class KCVSMessage extends AbstractMessage {
 
-    public KCVSMessage(StaticBuffer payload, long timestamp, String senderId) {
-        super(payload, timestamp, senderId);
+    public KCVSMessage(StaticBuffer payload, long timestampMirco, String senderId) {
+        super(payload, timestampMirco, senderId);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/FakeLock.java
Patch:
@@ -17,7 +17,7 @@ public class FakeLock implements TransactionLock {
     private FakeLock() {}
 
     @Override
-    public void lock(long maxTime) {
+    public void lock(long timeMillisecond) {
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/lock/ReentrantTransactionLock.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.diskstorage.locking.TemporaryLockingException;
-import com.thinkaurelius.titan.diskstorage.time.Timestamps;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -17,10 +16,10 @@ public class ReentrantTransactionLock extends ReentrantLock implements Transacti
     private static final Logger log = LoggerFactory.getLogger(ReentrantTransactionLock.class);
 
     @Override
-    public void lock(long maxTime) {
+    public void lock(long timeMillisecond) {
         boolean success = false;
         try {
-            success = super.tryLock(maxTime, Timestamps.SYSTEM().getUnit());
+            success = super.tryLock(timeMillisecond, TimeUnit.MILLISECONDS);
         } catch (InterruptedException e) {
             log.warn("Interrupted waiting for lock: {}",e);
         }

File: titan-hbase/titan-hbase-core/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -13,8 +13,6 @@
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
-import com.thinkaurelius.titan.diskstorage.time.TimestampProvider;
-import com.thinkaurelius.titan.diskstorage.time.Timestamps;
 import com.thinkaurelius.titan.diskstorage.util.*;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.util.system.IOUtils;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAllocationTest.java
Patch:
@@ -62,7 +62,7 @@ public static Collection<Object[]> configs() {
 
         c = getBasicConfig();
         c.set(IDAUTHORITY_UNIQUEID_RETRY_COUNT,10);
-        c.set(IDAUTHORITY_WAIT,10);
+        c.set(IDAUTHORITY_WAIT_MS,10);
         c.set(IDAUTHORITY_UNIQUE_ID_BITS,7);
         c.set(IDAUTHORITY_RANDOMIZE_UNIQUE_ID,true);
         configurations.add(new Object[]{c.getConfiguration()});
@@ -73,7 +73,7 @@ public static Collection<Object[]> configs() {
     public static ModifiableConfiguration getBasicConfig() {
         ModifiableConfiguration c = GraphDatabaseConfiguration.buildConfiguration();
         c.set(IDAUTHORITY_UNIQUEID_RETRY_COUNT,50);
-        c.set(IDAUTHORITY_WAIT,100);
+        c.set(IDAUTHORITY_WAIT_MS,100);
         c.set(IDS_BLOCK_SIZE,400);
         return c;
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/log/LogTest.java
Patch:
@@ -139,8 +139,8 @@ public void testSeparateReadersAndLogsInSharedManager() throws Exception {
 
     @Test
     public void testFuzzMessages() throws Exception {
-        final int maxLen = 1024 * 1024 * 4;
-        final int rounds = 32;
+        final int maxLen = 269; // TODO increase value over 271
+        final int rounds = 4;
 
         StoringReader reader = new StoringReader();
         List<StaticBuffer> expected = new ArrayList<StaticBuffer>(rounds);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -68,7 +68,7 @@ private static TitanGraph getInMemoryGraph() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
         config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, InMemoryStoreManager.class.getCanonicalName());
         config.set(GraphDatabaseConfiguration.IDS_FLUSH, false);
-        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT,1);
+        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT_MS,1);
         return TitanFactory.open(config);
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -37,7 +37,7 @@ public static Collection<Object[]> configs() {
         configurations.add(new Object[]{false, Integer.MAX_VALUE, null});
 
         for (int max : new int[]{Integer.MAX_VALUE, 100}) {
-            for (int[] local : new int[][]{null, {0, 2000}, {-100000, -1}, {-10000, 10000}}) {
+            for (int[] local : new int[][]{null, {0, 2000}, {-100000, -1}, {10000, -10000}}) {
                 configurations.add(new Object[]{true, max, local});
             }
         }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -133,7 +133,7 @@ public static Partitioner getPartitioner(String className) {
      */
     public static final int PORT_DEFAULT = 9160;
 
-
+    public static final String SYSTEM_KS = "system";
 
 //    public static final String REPLICATION_FACTOR_KEY = "replication-factor";
 //    public static final int REPLICATION_FACTOR_DEFAULT = 1;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.thrift;
 
 import static com.thinkaurelius.titan.diskstorage.cassandra.CassandraTransaction.getTx;
-import static org.apache.cassandra.db.Table.SYSTEM_KS;
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
-import com.thinkaurelius.titan.core.attribute.StringX;
 import com.thinkaurelius.titan.diskstorage.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
@@ -184,7 +183,7 @@ public void logMutations(DataOutput out) {
         Preconditions.checkArgument(!continuousPersistence,"Cannot log entire mutation set when continuous persistence is enabled");
         VariableLong.writePositive(out,mutations.size());
         for (Map.Entry<KCVSCache,Map<StaticBuffer, KCVMutation>> storeMuts : mutations.entrySet()) {
-            out.writeObjectNotNull(new StringX(storeMuts.getKey().getName()));
+            out.writeObjectNotNull(storeMuts.getKey().getName());
             VariableLong.writePositive(out,storeMuts.getValue().size());
             for (Map.Entry<StaticBuffer,KCVMutation> muts : storeMuts.getValue().entrySet()) {
                 BufferUtil.writeBuffer(out,muts.getKey());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardAttributeHandling.java
Patch:
@@ -49,11 +49,11 @@ public StandardAttributeHandling() {
         registerClass(Precision.class, new Precision.PrecisionSerializer());
         registerClass(Character.class, new CharacterSerializer());
         registerClass(Boolean.class, new BooleanSerializer());
-        registerClass(String.class, new StringSerializer());
+        registerClass(CString.class, new CStringSerializer());
         registerClass(Date.class, new DateSerializer());
 
         registerClass(Geoshape.class, new Geoshape.GeoshapeSerializer());
-        registerClass(StringX.class, new StringXSerializer()); //supports null serialization
+        registerClass(String.class, new StringSerializer()); //supports null serialization
         registerClass(Float.class, new FloatSerializer());
         registerClass(Double.class, new DoubleSerializer());
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StringArraySerializer.java
Patch:
@@ -8,7 +8,6 @@
 
 public class StringArraySerializer extends ArraySerializer implements AttributeSerializer<String[]> {
 
-    //TODO: use StringX here
     private static final StringSerializer stringSerializer = new StringSerializer();
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -434,6 +434,7 @@ public void persist(final Collection<InternalRelation> addedRelations,
         if (logTransaction) {
             DataOutput out = txLogHeader.serializeHeader(serializer,256);
             mutator.logMutations(out);
+//            txLog.add(out.getStaticBuffer(),txLogHeader.getLogKey());
             txLog.add(out.getStaticBuffer());
         }
 
@@ -450,6 +451,7 @@ public void persist(final Collection<InternalRelation> addedRelations,
             if (logTransaction) {
                 txLogHeader.setStatus(success?LogTxStatus.SUCCESS:LogTxStatus.FAILURE);
                 DataOutput out = txLogHeader.serializeHeader(serializer,20);
+//                txLog.add(out.getStaticBuffer(),txLogHeader.getLogKey());
                 txLog.add(out.getStaticBuffer());
             }
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -194,6 +194,9 @@ private Log openLog(String logManagerName, String logName, ReadMarker readMarker
             if (logStoreManager==null) {
                 logStoreManager = Backend.getStorageManager(configuration);
             }
+            StoreFeatures f = logStoreManager.getFeatures();
+            boolean part = f.isDistributed() && f.isKeyOrdered();
+            configuration.set(GraphDatabaseConfiguration.IDS_PARTITION, part);
             assert logStoreManager!=null;
             if (!logManagers.containsKey(logManagerName)) {
                 //Open log manager - only supports KCVSLog

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/inmemory/InMemoryGraphTest.java
Patch:
@@ -34,4 +34,7 @@ public void clopen(Object... settings) {
     @Override
     public void testTypes() {}
 
+    @Override
+    public void simpleLogTest() {}
+
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxIDAllocationTest.java
Patch:
@@ -2,11 +2,9 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
-import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
 
 public class InternalAstyanaxIDAllocationTest extends IDAllocationTest {
@@ -21,7 +19,7 @@ public static void startCassandra() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
         return new AstyanaxStoreManager(CassandraStorageSetup.getAstyanaxConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/InternalCassandraEmbeddedIDAllocationTest.java
Patch:
@@ -5,7 +5,6 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import org.apache.commons.configuration.Configuration;
 
 public class InternalCassandraEmbeddedIDAllocationTest extends IDAllocationTest {
 
@@ -14,7 +13,7 @@ public InternalCassandraEmbeddedIDAllocationTest(WriteConfiguration baseConfig)
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
         return new CassandraEmbeddedStoreManager(CassandraStorageSetup.getEmbeddedConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/InternalCassandraIDAllocationTest.java
Patch:
@@ -2,11 +2,9 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.IDAllocationTest;
-import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
 
 public class InternalCassandraIDAllocationTest extends IDAllocationTest {
@@ -21,7 +19,7 @@ public static void startCassandra() {
     }
 
     @Override
-    public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
         return new CassandraThriftStoreManager(CassandraStorageSetup.getCassandraThriftConfiguration(this.getClass().getSimpleName()));
     }
 }

File: titan-hbase/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseIDAllocationTest.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 
 import java.io.IOException;
 
@@ -21,7 +22,7 @@ public static void startHBase() throws IOException {
         HBaseStorageSetup.startHBase();
     }
 
-    public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
+    public KeyColumnValueStoreManager openStorageManager() throws StorageException {
         return new HBaseStoreManager(HBaseStorageSetup.getHBaseConfiguration());
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -120,7 +120,7 @@ private static String loadAbsoluteDirectoryPath(String name, String prop, boolea
         String s = System.getProperty(prop);
 
         if (null == s) {
-            s = Joiner.on(File.separator).join(System.getProperty("user.dir"), "target", "cassandra", name, "localhost-rp");
+            s = Joiner.on(File.separator).join(System.getProperty("user.dir"), "target", "cassandra", name, "localhost-bop");
             log.info("Set default Cassandra {} directory path {}", name, s);
         } else {
             log.info("Loaded Cassandra {} directory path {} from system property {}", new Object[] { name, s, prop });

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/HashKeyColumnValueStoreTest.java
Patch:
@@ -11,7 +11,7 @@ public abstract class HashKeyColumnValueStoreTest extends KeyColumnValueStoreTes
 
     @Override
     public void open() throws StorageException {
-        manager = new HashPrefixStoreManager(openStorageManager(), HashPrefixKeyColumnValueStore.HashLength.LONG);
+        manager = new HashPrefixStoreManager(openStorageManager(), HashPrefixKeyColumnValueStore.HashLength.SHORT);
         store = manager.openDatabase(storeName);
         tx = startTx();
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -43,6 +43,7 @@ public void testBasic() {
         TitanKey weight = tx.makeKey("weight").dataType(Decimal.class).cardinality(Cardinality.SINGLE).make();
         TitanVertex n1 = tx.addVertex();
         n1.addProperty(weight, 10.5);
+        assertTrue(tx.containsType("weight"));
         clopen();
         long nid = n1.getID();
         assertTrue(tx.containsVertex(nid));

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphMetricsTest.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.TitanNonTransactionalGraphMetricsTest;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 
 public class InternalCassandraGraphMetricsTest extends TitanNonTransactionalGraphMetricsTest {
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanManagement.java
Patch:
@@ -71,4 +71,6 @@ public interface TitanManagement extends TitanConfiguration {
 
     public void rollback();
 
+    public boolean isOpen();
+
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementLogger.java
Patch:
@@ -90,7 +90,7 @@ public void sendCacheEviction(Set<TitanSchemaVertex> updatedTypes,
         VariableLong.writePositive(out,evictionId);
         VariableLong.writePositive(out,updatedTypes.size());
         for (TitanSchemaVertex type : updatedTypes) {
-            assert !type.isNew();
+            assert type.hasId();
             VariableLong.writePositive(out,type.getID());
         }
         sysLog.add(out.getStaticBuffer());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -643,7 +643,7 @@ public final TitanSchemaVertex makeSchemaVertex(TitanSchemaCategory typeCategory
 
         graph.assignID(type);
         Preconditions.checkArgument(type.getID() > 0);
-        addProperty(type, SystemKey.TypeName, name);
+        if (typeCategory.hasName()) addProperty(type, SystemKey.TypeName, name);
         addProperty(type, SystemKey.VertexExists, Boolean.TRUE);
         addProperty(type, SystemKey.TypeCategory, typeCategory);
         for (Map.Entry<TypeDefinitionCategory,Object> def : definition.entrySet()) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanSchemaVertex.java
Patch:
@@ -98,8 +98,8 @@ public Iterable<Entry> getRelated(TypeDefinitionCategory def, Direction dir) {
                 assert oth instanceof TitanSchemaVertex;
                 TypeDefinitionDescription desc = edge.getProperty(SystemKey.TypeDefinitionDesc);
                 Object modifier = null;
-                if (def.hasDataType()) {
-                    assert desc.getModifier()!=null && desc.getModifier().getClass().equals(def.getDataType());
+                if (desc.getCategory().hasDataType()) {
+                    assert desc.getModifier()!=null && desc.getModifier().getClass().equals(desc.getCategory().getDataType());
                     modifier = desc.getModifier();
                 }
                 b.put(desc.getCategory(), new Entry((TitanSchemaVertex) oth, modifier));

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/util/TestLockerManager.java
Patch:
@@ -33,7 +33,7 @@ private TestLocker(String name, boolean errorOnLock) {
         @Override
         public void writeLock(KeyColumn lockID, StoreTransaction tx) throws TemporaryLockingException, PermanentLockingException {
             if (errorOnLock)
-                throw new UnsupportedOperationException();
+                throw new UnsupportedOperationException("Locking is not supported!");
         }
 
         @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -69,7 +69,7 @@ public void finishSchema() {
     }
 
     public void close() {
-        if (mgmt!=null) mgmt.rollback();
+        if (mgmt!=null && mgmt.isOpen()) mgmt.rollback();
         if (null != tx && tx.isOpen())
             tx.commit();
 
@@ -86,7 +86,7 @@ public void newTx() {
 
     public void clopen(Object... settings) {
         config = getConfiguration();
-        if (mgmt!=null) mgmt.rollback();
+        if (mgmt!=null && mgmt.isOpen()) mgmt.rollback();
         if (null != tx && tx.isOpen()) tx.commit();
         if (settings!=null && settings.length>0) {
             //Parse settings

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEKeyValueStore.java
Patch:
@@ -95,7 +95,7 @@ public boolean containsKey(StaticBuffer key, StoreTransaction txh) throws Storag
     @Override
     public void acquireLock(StaticBuffer key, StaticBuffer expectedValue, StoreTransaction txh) throws StorageException {
         if (getTransaction(txh) == null) {
-            log.info("Attempt to acquire lock with transactions disabled");
+            log.warn("Attempt to acquire lock with transactions disabled");
         } //else we need no locking
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexTransaction.java
Patch:
@@ -44,7 +44,7 @@ public IndexTransaction(final IndexProvider index, final KeyInformation.IndexRet
         Preconditions.checkNotNull(indexTx);
         this.mutationAttempts = mutationAttempts;
         this.attemptWaitTime = attemptWaitTime;
-        this.mutations = null;
+        this.mutations = new HashMap<String,Map<String,IndexMutation>>(DEFAULT_OUTER_MAP_SIZE);
     }
 
     public void add(String store, String docid, String key, Object value, boolean isNew) {
@@ -56,7 +56,6 @@ public void delete(String store, String docid, String key, Object value, boolean
     }
 
     private IndexMutation getIndexMutation(String store, String docid, boolean isNew, boolean isDeleted) {
-        if (mutations==null) mutations = new HashMap<String,Map<String,IndexMutation>>(DEFAULT_OUTER_MAP_SIZE);
         Map<String,IndexMutation> storeMutations = mutations.get(store);
         if (storeMutations==null) {
             storeMutations = new HashMap<String,IndexMutation>(DEFAULT_INNER_MAP_SIZE);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -35,7 +35,6 @@ public InMemoryStoreManager(final Configuration configuration) {
         features = new StandardStoreFeatures.Builder()
             .orderedScan(true)
             .unorderedScan(true)
-            //.transactional(true)
             .keyOrdered(true)
             .keyConsistent(GraphDatabaseConfiguration.buildConfiguration())
             .build();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -434,9 +434,11 @@ protected void waitCondition() throws InterruptedException {
         @Override
         protected void action() {
             MessageEnvelope msg;
+            //Opportunistically drain the queue for up to the batch-send-size number of messages before evaluating condition
             while (toSend.size()<sendBatchSize && (msg=outgoingMsg.poll())!=null) {
                 toSend.add(msg);
             }
+            //Evaluate send condition: 1) Is the oldest message waiting longer than the delay? or 2) Do we have enough messages to send?
             if (!toSend.isEmpty() && (timeSinceFirstMsg()>=maxSendDelay || toSend.size()>=sendBatchSize)) {
                 sendMessages(toSend);
                 toSend.clear();
@@ -445,6 +447,7 @@ protected void action() {
 
         @Override
         protected void cleanup() {
+            //Send all remaining messages
             if (!toSend.isEmpty() || !outgoingMsg.isEmpty()) {
                 //There are still messages waiting to be sent
                 toSend.addAll(outgoingMsg);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanFeatures.java
Patch:
@@ -34,8 +34,8 @@ private static Features getBaselineTitanFeatures() {
         features.supportsVertexIndex = false;
         features.supportsEdgeIndex = false;
         features.supportsKeyIndices = true;
-        features.supportsVertexKeyIndex = true;
-        features.supportsEdgeKeyIndex = true;
+        features.supportsVertexKeyIndex = false;
+        features.supportsEdgeKeyIndex = false;
         features.supportsEdgeIteration = false;
         features.supportsVertexIteration = false;
         features.supportsVertexProperties = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -512,7 +512,7 @@ public Iterable<RawQuery.Result> executeQuery(IndexQueryBuilder query, final Ele
         log.info("Converted query string with {} replacements: [{}] => [{}]",replacements,query.getQuery(),queryStr);
         RawQuery rawQuery=new RawQuery(index.getStoreName(),queryStr,query.getParameters());
         if (query.hasLimit()) rawQuery.setLimit(query.getLimit());
-        return Iterables.transform(backendTx.rawQuery(query.getIndex(), rawQuery), new Function<RawQuery.Result<String>, RawQuery.Result>() {
+        return Iterables.transform(backendTx.rawQuery(index.getBackingIndexName(), rawQuery), new Function<RawQuery.Result<String>, RawQuery.Result>() {
             @Nullable
             @Override
             public RawQuery.Result apply(@Nullable RawQuery.Result<String> result) {
@@ -528,6 +528,7 @@ public RawQuery.Result apply(@Nullable RawQuery.Result<String> result) {
 
     private static final ExternalIndexType getExternalIndex(String indexName,StandardTitanTx transaction) {
         IndexType index = ManagementSystem.getGraphIndexDirect(indexName, transaction);
+        Preconditions.checkArgument(index!=null,"Index with name [%s] is unknown or not configured properly",indexName);
         Preconditions.checkArgument(index.isExternalIndex());
         return (ExternalIndexType)index;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -259,7 +259,7 @@ public void assignIDs(Iterable<InternalRelation> addedRelations) {
 
     private final long getPartitionID(final InternalVertex v) {
         long vid = v.getID();
-        if (IDManager.VertexIDType.RelationType.is(vid)) return 0;
+        if (IDManager.VertexIDType.Schema.is(vid)) return 0;
         else return idManager.getPartitionId(vid);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -22,6 +22,7 @@
 import com.thinkaurelius.titan.graphdb.internal.Token;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.types.*;
+import com.thinkaurelius.titan.graphdb.types.indextype.ExternalIndexTypeWrapper;
 import com.thinkaurelius.titan.graphdb.types.indextype.IndexTypeWrapper;
 import com.thinkaurelius.titan.graphdb.types.system.SystemKey;
 import com.thinkaurelius.titan.graphdb.types.system.SystemLabel;
@@ -329,6 +330,7 @@ public TitanGraphIndex createExternalIndex(String indexName, Class<? extends Ele
         def.setValue(TypeDefinitionCategory.BACKING_INDEX,backingIndex);
         def.setValue(TypeDefinitionCategory.INDEXSTORE_NAME,indexName);
         def.setValue(TypeDefinitionCategory.INDEX_CARDINALITY,Cardinality.LIST);
+        def.setValue(TypeDefinitionCategory.STATUS,SchemaStatus.ENABLED);
         TitanSchemaVertex v = transaction.makeSchemaVertex(TitanSchemaCategory.INDEX,composeIndexName(indexName),def);
         return new TitanGraphIndexWrapper(v.asIndexType());
     }
@@ -352,6 +354,7 @@ public void addIndexKey(final TitanGraphIndex index, final TitanKey key, Paramet
         System.arraycopy(parameters,0,extendedParas,0,parameters.length);
         extendedParas[parameters.length]=ParameterType.STATUS.getParameter(SchemaStatus.ENABLED);
         addSchemaEdge(indexVertex, key, TypeDefinitionCategory.INDEX_FIELD, extendedParas);
+        indexType.resetCache();
         try {
             IndexSerializer.register((ExternalIndexType) indexType,key,transaction.getTxHandle());
         } catch (StorageException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/idmanagement/IDManager.java
Patch:
@@ -361,7 +361,8 @@ public long getPartitionBound() {
 
 
     public long getPartitionId(long id) {
-        Preconditions.checkArgument(!VertexIDType.Schema.is(id), "Schema vertices don't have a partition: %s", id);
+        //Cannot do this check because it does not apply to edges which are in a different id space
+        //Preconditions.checkArgument(!VertexIDType.Schema.is(id), "Schema vertices don't have a partition: %s", id);
         return (id >>> partitionOffset);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/vertex/AbstractVertexCentricQueryBuilder.java
Patch:
@@ -242,6 +242,7 @@ protected BaseVertexCentricQuery constructQuery(RelationCategory returnType) {
             query.getBackendQuery().setLimit(computeLimit(conditions.size(),sliceLimit));
             queries = ImmutableList.of(query);
             conditions.add(returnType);
+            conditions.add(new HiddenFilterCondition<TitanRelation>());
         } else {
             Set<TitanType> ts = new HashSet<TitanType>(types.length);
             queries = new ArrayList<BackendQueryHolder<SliceQuery>>(types.length + 2);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -545,7 +545,7 @@ public TitanProperty addPropertyInternal(TitanVertex vertex, final TitanKey key,
         //Determine unique indexes
         List<IndexLockTuple> uniqueIndexTuples = new ArrayList<IndexLockTuple>();
         for (InternalIndexType index : TypeUtil.getUniqueIndexes(key)) {
-            IndexSerializer.IndexRecords matches = IndexSerializer.indexMatches(vertex, index, key, value);
+            IndexSerializer.IndexRecords matches = IndexSerializer.indexMatches(vertex, index, key, normalizedValue);
             for (Object[] match : matches.getRecordValues()) uniqueIndexTuples.add(new IndexLockTuple(index,match));
         }
 
@@ -864,7 +864,8 @@ private PredicateCondition<TitanKey, TitanElement> getEqualityCondition(Conditio
         public Iterator<TitanElement> getNew(final GraphCentricQuery query) {
             Preconditions.checkArgument(query.getResultType() == ElementCategory.VERTEX || query.getResultType() == ElementCategory.EDGE);
             //If the query is unconstrained then we don't need to add new elements, so will be picked up by getVertices()/getEdges() below
-            if (!query.getCondition().hasChildren()) return Iterators.emptyIterator();
+            if (query.numSubQueries()==1 && query.getSubQuery(0).getBackendQuery().isEmpty()) return Iterators.emptyIterator();
+            Preconditions.checkArgument(query.getCondition().hasChildren(),"If the query is non-empty it needs to have a condition");
 
             if (query.getResultType() == ElementCategory.VERTEX && hasModifications()) {
                 Preconditions.checkArgument(QueryUtil.isQueryNormalForm(query.getCondition()));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardTypeMaker.java
Patch:
@@ -79,7 +79,7 @@ private void checkGeneralArguments() {
         checkSignature(signature);
         Preconditions.checkArgument(Sets.intersection(Sets.newHashSet(sortKey), Sets.newHashSet(signature)).isEmpty(),
                 "Signature and sort key must be disjoined");
-        Preconditions.checkArgument(!hasSortKey() || !multiplicity.isConstrained(),"Cannot define a sort-key on constrained (simple) edge labels");
+        Preconditions.checkArgument(!hasSortKey() || !multiplicity.isConstrained(),"Cannot define a sort-key on constrained edge labels");
     }
 
     private long[] checkSortKey(List<TitanType> sig) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemKey.java
Patch:
@@ -149,6 +149,9 @@ public SchemaStatus getStatus() {
             return SchemaStatus.ENABLED;
         }
 
+        @Override
+        public void resetCache() {}
+
         //Use default hashcode and equals
     };
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/IndexHelper.java
Patch:
@@ -36,7 +36,7 @@ public static GraphCentricQueryBuilder getQuery(InternalIndexType index, Object[
             Object value = values[i];
             Preconditions.checkNotNull(value);
             TitanKey key = f.getFieldKey();
-            Preconditions.checkArgument(key.getDataType().equals(value.getClass()),"Incompatible data types");
+            Preconditions.checkArgument(key.getDataType().equals(value.getClass()),"Incompatible data types for: " + value);
             gb.has(key, Cmp.EQUAL,value);
         }
         return gb;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -68,7 +68,6 @@ public boolean isModified() {
     @Override
     public synchronized void remove() {
         if (it().isRemoved()) return;
-        //TODO: It's Blueprints semantics to remove all edges - is this correct?
         Iterator<TitanRelation> iter = it().getRelations().iterator();
         while (iter.hasNext()) {
             iter.next();

File: titan-persistit/src/main/java/com/thinkaurelius/titan/diskstorage/persistit/PersistitKeyValueStore.java
Patch:
@@ -285,7 +285,7 @@ public void delete(final StaticBuffer key, StoreTransaction txh) throws StorageE
 
     @Override
     public void acquireLock(StaticBuffer key, StaticBuffer expectedValue, StoreTransaction txh) throws StorageException {
-        //@todo: what is this supposed to do? BerkelyDB doesn't really implement this
+        //We need no locking since transactions are always enabled
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/SpeedComparisonPerformanceTest.java
Patch:
@@ -25,7 +25,9 @@ public abstract class SpeedComparisonPerformanceTest extends TitanGraphTestCommo
 
     @Test
     public void compare() {
-        graph.createKeyIndex("uid", Vertex.class);
+        makeVertexIndexedUniqueKey("uid", Long.class);
+        finishSchema();
+
         Vertex vertices[] = new TitanVertex[numVertices];
         for (int i = 0; i < numVertices; i++) {
             vertices[i] = graph.addVertex(null);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphPerformanceMemoryTest.java
Patch:
@@ -234,9 +234,7 @@ public void run() {
 
     @Test
     public void elementCreationPerformance() {
-        TitanLabel connect = makeLabel("connect");
-        finishSchema();
-
+        TitanLabel connect = tx.makeLabel("connect").make();
         int noNodes = 20000;
         TitanVertex[] nodes = new TitanVertex[noNodes];
         PerformanceTest p = new PerformanceTest(true);
@@ -247,6 +245,7 @@ public void elementCreationPerformance() {
         System.out.println("Time per node in (ns): " + (p.getNanoTime() / noNodes));
 
         p = new PerformanceTest(true);
+
         for (int i = 0; i < noNodes; i++) {
             new StandardEdge(i + 1, connect, (InternalVertex) nodes[i], (InternalVertex) nodes[(i + 1) % noNodes], ElementLifeCycle.New);
         }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/thriftpool/CTConnection.java
Patch:
@@ -39,6 +39,9 @@ public CTConnectionFactory.Config getConfig() {
      return cfg;
     }
 
+    public boolean isOpen() {
+        return transport.isOpen();
+    }
     @Override
     public void close() {
         if (transport != null && transport.isOpen())

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/thriftpool/CTConnectionPool.java
Patch:
@@ -40,7 +40,7 @@ public CTConnectionPool(KeyedPoolableObjectFactory<String, CTConnection> factory
     }
 
     /**
-     * If {@code conn} is non-null, then call
+     * If {@code conn} is non-null and is still open, then call
      * {@link GenericKeyedObjectPool#returnObject(String, CTConnection),
      * catching and logging and Exception that method might generate. 
      * This method does not emit any exceptions.
@@ -49,7 +49,7 @@ public CTConnectionPool(KeyedPoolableObjectFactory<String, CTConnection> factory
      * @param conn The pooled object being returned, or null to do nothing
      */
     public void returnObjectUnsafe(String keyspace, CTConnection conn) {
-        if (conn != null) {
+        if (conn != null && conn.isOpen()) {
             try {
                 returnObject(keyspace, conn);
             } catch (Exception e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -9,6 +9,8 @@
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 
+import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID;
+
 
 /**
  * Base Class for {@link IDAuthority} implementations.
@@ -37,7 +39,7 @@ public abstract class AbstractIDManager implements IDAuthority {
     private volatile boolean isActive;
 
     public AbstractIDManager(Configuration config) {
-        this.rid = DistributedStoreManager.getRid(config);
+        this.rid = config.get(UNIQUE_INSTANCE_ID).getBytes();
 
         this.isActive = false;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/AbstractLocker.java
Patch:
@@ -124,7 +124,7 @@ public static abstract class Builder<S, B extends Builder<S, B>> {
         protected Logger log;
 
         public Builder() {
-            this.rid = new StaticArrayBuffer(DistributedStoreManager.getRid(Configuration.EMPTY));
+            this.rid = null; //TODO: can we ensure that this is always set correctly? Check the AstyanaxRecipe
             this.times = Timestamps.NANO;
             this.serializer = new ConsistentKeyLockerSerializer();
             this.llm = null; // redundant, but it preserves this constructor's overall pattern

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -181,7 +181,7 @@ public Builder customCleaner(LockCleanerService s) {
         }
 
         public Builder fromConfig(Configuration config) {
-            rid(new StaticArrayBuffer(DistributedStoreManager.getRid(config)));
+            rid(new StaticArrayBuffer(config.get(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID).getBytes()));
 
             final String llmPrefix = config.get(
                     ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/LogManager.java
Patch:
@@ -26,7 +26,7 @@ public interface LogManager {
     public Log openLog(String name, ReadMarker readMarker) throws StorageException;
 
     /**
-     * Closes the log manager and all open logs
+     * Closes the log manager and all open logs (if they haven't already been explicitly closed)
      *
      * @throws StorageException
      */

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/EdgeSerializer.java
Patch:
@@ -220,7 +220,7 @@ public Entry writeRelation(InternalRelation relation, InternalType type, int pos
         Multiplicity multiplicity = type.getMultiplicity();
 
         long[] sortKey = type.getSortKey();
-        assert sortKey.length>0 ^ multiplicity.isConstrained();
+        assert !multiplicity.isConstrained() || sortKey.length==0: type.getName();
         int keyStartPos = out.getPosition();
         if (!multiplicity.isConstrained()) {
             writeInlineTypes(sortKey, relation, out, tx);
@@ -326,6 +326,7 @@ private void writePropertyValue(DataOutput out, TitanKey key, Object value) {
         if (AttributeUtil.hasGenericDataType(key)) {
             out.writeClassAndObject(value);
         } else {
+            assert value==null || value.getClass().equals(key.getDataType());
             out.writeObject(value, key.getDataType());
         }
     }
@@ -364,7 +365,7 @@ public SliceQuery getQuery(InternalType type, Direction dir, TypedInterval[] sor
             int startPosition = colStart.getPosition();
             int i;
             boolean wroteInterval = false;
-            Preconditions.checkArgument(sortKey.length>0 ^ type.getMultiplicity().isConstrained(),"Cannot use sort key with constrained types");
+            Preconditions.checkArgument(!type.getMultiplicity().isConstrained() || sortKey.length==0,"Cannot use sort key with constrained types");
             for (i = 0; i < sortKeyIDs.length && sortKey[i] != null; i++) {
                 TitanType t = sortKey[i].type;
                 Interval interval = sortKey[i].interval;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/cache/StandardSchemaCache.java
Patch:
@@ -30,9 +30,9 @@ public class StandardSchemaCache implements SchemaCache {
 
     private static final int SCHEMAID_FORW_SHIFT = 4; //Number of bits at the end to append the id of the system type
     private static final int SCHEMAID_TOTALFORW_SHIFT = SCHEMAID_FORW_SHIFT +1; //Total number of bits appended - the 1 is for the 1 bit direction
-    private static final int SCHEMAID_BACK_SHIFT = 3; //Number of bits to remove from end of schema id since its just the padding
+    private static final int SCHEMAID_BACK_SHIFT = 2; //Number of bits to remove from end of schema id since its just the padding
     {
-        assert IDManager.VertexIDType.SchemaType.removePadding(1l<<SCHEMAID_BACK_SHIFT)==1;
+        assert IDManager.VertexIDType.Schema.removePadding(1l<<SCHEMAID_BACK_SHIFT)==1;
         assert SystemTypeManager.SYSTEM_RELATIONTYPE_OFFSET <= (1<< SCHEMAID_FORW_SHIFT);
         assert SCHEMAID_TOTALFORW_SHIFT-SCHEMAID_BACK_SHIFT>=0;
     }
@@ -107,7 +107,7 @@ public Long getTypeId(final String typeName, final StandardTitanTx tx) {
     @Override
     public EntryList getTypeRelations(final long schemaId, final SystemType type, final Direction dir, final StandardTitanTx tx) {
         assert IDManager.getRelationTypeIdCount(type.getID())<SystemTypeManager.SYSTEM_RELATIONTYPE_OFFSET;
-        Preconditions.checkArgument(IDManager.VertexIDType.SchemaType.is(schemaId));
+        Preconditions.checkArgument(IDManager.VertexIDType.Schema.is(schemaId));
         Preconditions.checkArgument((Long.MAX_VALUE>>>(SCHEMAID_TOTALFORW_SHIFT-SCHEMAID_BACK_SHIFT))>= schemaId);
 
         int edgeDir = EdgeDirection.position(dir);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/management/ManagementSystem.java
Patch:
@@ -230,7 +230,7 @@ private TitanEdge addSchemaEdge(TitanVertex out, TitanVertex in, TypeDefinitionC
         assert def.isEdge();
         TitanEdge edge = transaction.addEdge(out,in, SystemLabel.TypeDefinitionEdge);
         TypeDefinitionDescription desc = new TypeDefinitionDescription(def,modifier);
-        edge.setProperty(SystemKey.TypeDefinitionDesc,def);
+        edge.setProperty(SystemKey.TypeDefinitionDesc,desc);
         return edge;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardSerializer.java
Patch:
@@ -18,7 +18,7 @@ public class StandardSerializer extends StandardAttributeHandling implements Ser
     private final KryoSerializer backupSerializer;
 
     public StandardSerializer(boolean allowCustomSerialization) {
-        if (allowCustomSerialization) backupSerializer = new KryoSerializer();
+        if (allowCustomSerialization) backupSerializer = new KryoSerializer(DEFAULT_REGISTRATIONS);
         else backupSerializer = null;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/idmanagement/IDInspector.java
Patch:
@@ -7,6 +7,8 @@
  */
 public interface IDInspector {
 
+    public boolean isSchemaVertexId(long id);
+
     public boolean isRelationTypeId(long id);
 
     public boolean isEdgeLabelId(long id);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/AbstractElement.java
Patch:
@@ -79,7 +79,6 @@ public boolean hasId() {
 
     @Override
     public void setID(long id) {
-        assert isTemporaryId(this.id);
         assert id > 0;
         this.id=id;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -136,10 +136,10 @@ public static <E extends TitanElement> And<E> constraints2QNF(StandardTitanTx tx
             Object value = atom.getValue();
             TitanPredicate predicate = atom.getPredicate();
 
-            assert predicate.isValidCondition(value);
 
             if (type.isPropertyKey()) {
                 TitanKey key = (TitanKey) type;
+                assert predicate.isValidCondition(value);
                 Preconditions.checkArgument(key.getDataType()==Object.class || predicate.isValidValueType(key.getDataType()), "Data type of key is not compatible with condition");
             } else { //its a label
                 Preconditions.checkArgument(((TitanLabel) type).isUnidirected());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/graph/JointIndexQuery.java
Patch:
@@ -23,7 +23,7 @@ public class JointIndexQuery extends BaseQuery implements BackendQuery<JointInde
     private final List<Subquery> queries;
 
     private JointIndexQuery(List<Subquery> queries) {
-        Preconditions.checkArgument(queries!=null && !queries.isEmpty());
+        Preconditions.checkArgument(queries!=null);
         this.queries = queries;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationIdentifier.java
Patch:
@@ -105,13 +105,13 @@ TitanRelation findRelation(TitanTransaction tx) {
             throw new IllegalArgumentException("Invalid RelationIdentifier: typeID does not reference a type");
 
         TitanType type = (TitanType)typeVertex;
-        Iterable<TitanRelation> rels;
+        Iterable<? extends TitanRelation> rels;
         if (((TitanType) typeVertex).isEdgeLabel()) {
             TitanVertex in = tx.getVertex(inVertexId);
             if (in==null) return null;
-            rels = v.query().types((TitanLabel)type).direction(Direction.OUT).adjacentVertex(in).relations();
+            rels = v.query().types((TitanLabel)type).direction(Direction.OUT).adjacentVertex(in).titanEdges();
         } else {
-            rels = v.query().types((TitanKey)type).relations();
+            rels = v.query().types((TitanKey)type).properties();
         }
 
         for (TitanRelation r : rels) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -318,7 +318,7 @@ private VertexConstructor(boolean verifyExistence) {
         public InternalVertex get(Long vertexid) {
             Preconditions.checkNotNull(vertexid);
             Preconditions.checkArgument(vertexid > 0);
-            Preconditions.checkArgument(idInspector.isRelationTypeId(vertexid) || idInspector.isVertexId(vertexid), "Not a valid vertex id: %s", vertexid);
+            Preconditions.checkArgument(idInspector.isSchemaVertexId(vertexid) || idInspector.isVertexId(vertexid), "Not a valid vertex id: %s", vertexid);
 
             byte lifecycle = ElementLifeCycle.Loaded;
             if (verifyExistence) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeDefinitionCategory.java
Patch:
@@ -45,7 +45,7 @@ public enum TypeDefinitionCategory {
     public static final Set<TypeDefinitionCategory> PROPERTY_KEY_DEFINITION_CATEGORIES = ImmutableSet.of(HIDDEN, SORT_KEY, SORT_ORDER, SIGNATURE, MULTIPLICITY, DATATYPE);
     public static final Set<TypeDefinitionCategory> EDGE_LABEL_DEFINITION_CATEGORIES = ImmutableSet.of(HIDDEN, SORT_KEY, SORT_ORDER, SIGNATURE, MULTIPLICITY, UNIDIRECTIONAL);
     public static final Set<TypeDefinitionCategory> CONSISTENCY_MODIFIER_DEFINITION_CATEGORIES = ImmutableSet.of(CONSISTENCY_LEVEL);
-    public static final Set<TypeDefinitionCategory> INDEX_DEFINITION_CATEGORIES = ImmutableSet.of(ELEMENT_CATEGORY,INDEX_CARDINALITY,INTERNAL_INDEX, BACKING_INDEX,INDEXSTORE_NAME);
+    public static final Set<TypeDefinitionCategory> INDEX_DEFINITION_CATEGORIES = ImmutableSet.of(STATUS, ELEMENT_CATEGORY,INDEX_CARDINALITY,INTERNAL_INDEX, BACKING_INDEX,INDEXSTORE_NAME);
 
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyType.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.graphdb.types.system;
 
+import com.google.common.collect.ImmutableSet;
 import com.thinkaurelius.titan.core.Order;
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
 import com.thinkaurelius.titan.graphdb.types.IndexType;
@@ -39,7 +40,7 @@ public InternalType getBaseType() {
 
     @Override
     public Iterable<InternalType> getRelationIndexes() {
-        return Collections.EMPTY_LIST;
+        return ImmutableSet.of((InternalType)this);
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -95,7 +95,7 @@ public void open() throws StorageException {
 
             ModifiableConfiguration sc = GraphDatabaseConfiguration.buildConfiguration();
             sc.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX,concreteClassName + i);
-            sc.set(GraphDatabaseConfiguration.INSTANCE_RID_SHORT,(short)i);
+            sc.set(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID,"inst"+i);
             sc.set(GraphDatabaseConfiguration.LOCK_RETRY,10);
             sc.set(GraphDatabaseConfiguration.LOCK_EXPIRE, EXPIRE_MS);
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -32,8 +32,6 @@ public abstract class TitanGraphBaseTest {
     public TitanGraphBaseTest() {
     }
 
-
-
     public abstract WriteConfiguration getConfiguration();
 
     @Before
@@ -42,6 +40,7 @@ public void setUp() throws Exception {
         Preconditions.checkNotNull(config);
         ModifiableConfiguration configuration = new ModifiableConfiguration(GraphDatabaseConfiguration.TITAN_NS,config.copy(), BasicConfiguration.Restriction.NONE);
         configuration.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX, "tmp");
+        configuration.set(GraphDatabaseConfiguration.UNIQUE_INSTANCE_ID, "inst");
         Backend backend = new Backend(configuration);
         backend.initialize(configuration);
         backend.clearStorage();

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/RidGenerationTest.java
Patch:
@@ -36,8 +36,8 @@ public void testThreadBasedRidGeneration() throws InterruptedException {
         for (int i = 0; i < n; i++) {
             threads[i].join();
         }
-        
-        assertEquals(n, rids.size());
+        //TODO: rewrite test case in terms of GraphDatabaseConfiguration
+        //assertEquals(n, rids.size());
     }
     
     private static class RidThread extends Thread {
@@ -52,7 +52,7 @@ private RidThread(Collection<byte[]> rids, Configuration c) {
         
         @Override
         public void run() {
-            rids.add(DistributedStoreManager.getRid(c));
+            //rids.add(DistributedStoreManager.getRid(c));
         }
     };
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -143,7 +143,7 @@ public Backend(Configuration storageConfig, Configuration metricsConfig) {
         Preconditions.checkArgument(persistAttemptWaittime > 0, "Persistence attempt retry wait time must be non-negative");
 
         if (storageConfig.getBoolean(PARALLEL_BACKEND_OPS_KEY, PARALLEL_BACKEND_OPS_DEFAULT)) {
-            int poolsize = Math.min(1, Runtime.getRuntime().availableProcessors()) * THREAD_POOL_SIZE_SCALE_FACTOR;
+            int poolsize = Runtime.getRuntime().availableProcessors() * THREAD_POOL_SIZE_SCALE_FACTOR;
             threadPool = Executors.newFixedThreadPool(poolsize);
             log.info("Initiated backend operations thread pool of size {}", poolsize);
         } else {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexProviderTest.java
Patch:
@@ -86,7 +86,7 @@ public void setUp() throws Exception {
 
     public void open() throws StorageException {
         index = openIndex();
-        tx = new IndexTransaction(index, indexRetriever, mutationAttempts, attemptWaitTime);
+        tx = new IndexTransaction(index, indexRetriever, 2, 1000);
     }
 
     @After
@@ -340,7 +340,7 @@ private void add(String store, String docid, Map<String, Object> doc, boolean is
     private void remove(String store, String docid, Map<String, Object> doc, boolean deleteAll) {
         for (Map.Entry<String, Object> kv : doc.entrySet()) {
             if (index.supports(allKeys.get(kv.getKey()))) {
-                tx.delete(store, docid, kv.getKey(), deleteAll);
+                tx.delete(store, docid, kv.getKey(), kv.getValue(), deleteAll);
             }
         }
     }

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/configuration/ConfigurationTest.java
Patch:
@@ -89,12 +89,12 @@ public void testConfigHierarchy() {
         try {
             userconfig.set("storage.bits",6);
         } catch (IllegalArgumentException e) {}
-        userconfig.set("storage.bits",6,"force");
+        userconfig.set("storage.bits",6);
         try {
             userconfig.set("storage.locktime",1221);
         } catch (IllegalArgumentException e) {}
         try {
-            userconfig.set("storage.locktime",1221,"force");
+            userconfig.set("storage.locktime",1221);
         } catch (IllegalArgumentException e) {}
         userconfig.set("indexes.find.name","lulu");
 

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/EdgeSerializerTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.serializer;
 
 import com.thinkaurelius.titan.StorageSetup;
+import com.thinkaurelius.titan.core.Multiplicity;
 import com.thinkaurelius.titan.core.TitanEdge;
 import com.thinkaurelius.titan.core.TitanLabel;
 import com.thinkaurelius.titan.core.TitanVertex;
@@ -21,8 +22,8 @@ public class EdgeSerializerTest {
     @Test
     public void testValueOrdering() {
         StandardTitanGraph graph = (StandardTitanGraph) StorageSetup.getInMemoryGraph();
-        TitanLabel father = graph.makeLabel("father").manyToOne().make();
-        for (int i=1;i<=5;i++) graph.makeKey("key"+i).single().dataType(Integer.class).make();
+        TitanLabel father = graph.makeLabel("father").multiplicity(Multiplicity.MANY2ONE).make();
+        for (int i=1;i<=5;i++) graph.makeKey("key"+i).dataType(Integer.class).make();
 
         TitanVertex v1 = graph.addVertex(null), v2 = graph.addVertex(null);
         TitanEdge e1 = v1.addEdge("father",v2);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -143,7 +143,7 @@ public Backend(Configuration storageConfig, Configuration metricsConfig) {
         Preconditions.checkArgument(persistAttemptWaittime > 0, "Persistence attempt retry wait time must be non-negative");
 
         if (storageConfig.getBoolean(PARALLEL_BACKEND_OPS_KEY, PARALLEL_BACKEND_OPS_DEFAULT)) {
-            int poolsize = Math.min(1, Runtime.getRuntime().availableProcessors()) * THREAD_POOL_SIZE_SCALE_FACTOR;
+            int poolsize = Runtime.getRuntime().availableProcessors() * THREAD_POOL_SIZE_SCALE_FACTOR;
             threadPool = Executors.newFixedThreadPool(poolsize);
             log.info("Initiated backend operations thread pool of size {}", poolsize);
         } else {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAllocationTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDPoolExhaustedException;
+import com.thinkaurelius.titan.testutil.TestGraphConfigs;
 
 import org.junit.After;
 import org.junit.Assert;
@@ -88,6 +89,7 @@ public static Collection<Object[]> configs() {
 
     public IDAllocationTest(WriteConfiguration baseConfig) {
         Preconditions.checkNotNull(baseConfig);
+        TestGraphConfigs.applyOverrides(baseConfig);
         this.baseStoreConfiguration = baseConfig;
         Configuration config = StorageSetup.getConfig(baseConfig);
         hasFixedUid = !config.get(IDAUTHORITY_RANDOMIZE_UNIQUE_ID);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -11,6 +11,8 @@
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingStore;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
+import com.thinkaurelius.titan.testutil.TestGraphConfigs;
+
 import org.junit.After;
 import org.junit.Before;
 
@@ -34,6 +36,7 @@ public TitanGraphBaseTest() {
     @Before
     public void setUp() throws Exception {
         this.config = getConfiguration();
+        TestGraphConfigs.applyOverrides(config);
         Preconditions.checkNotNull(config);
         ModifiableConfiguration configuration = new ModifiableConfiguration(GraphDatabaseConfiguration.TITAN_NS,config.clone(), BasicConfiguration.Restriction.NONE);
         configuration.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX, "tmp");

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAllocationTest.java
Patch:
@@ -15,6 +15,7 @@
 
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDPoolExhaustedException;
+import com.thinkaurelius.titan.testutil.TestGraphConfigs;
 
 import org.junit.After;
 import org.junit.Assert;
@@ -88,6 +89,7 @@ public static Collection<Object[]> configs() {
 
     public IDAllocationTest(WriteConfiguration baseConfig) {
         Preconditions.checkNotNull(baseConfig);
+        TestGraphConfigs.applyOverrides(baseConfig);
         this.baseStoreConfiguration = baseConfig;
         Configuration config = StorageSetup.getConfig(baseConfig);
         hasFixedUid = !config.get(IDAUTHORITY_RANDOMIZE_UNIQUE_ID);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphBaseTest.java
Patch:
@@ -11,6 +11,8 @@
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingStore;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
+import com.thinkaurelius.titan.testutil.TestGraphConfigs;
+
 import org.junit.After;
 import org.junit.Before;
 
@@ -34,6 +36,7 @@ public TitanGraphBaseTest() {
     @Before
     public void setUp() throws Exception {
         this.config = getConfiguration();
+        TestGraphConfigs.applyOverrides(config);
         Preconditions.checkNotNull(config);
         ModifiableConfiguration configuration = new ModifiableConfiguration(GraphDatabaseConfiguration.TITAN_NS,config.clone(), BasicConfiguration.Restriction.NONE);
         configuration.set(ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX, "tmp");

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/IDAllocationTest.java
Patch:
@@ -66,7 +66,7 @@ public static Collection<Object[]> configs() {
 
         c = GraphDatabaseConfiguration.buildConfiguration();
         c.set(IDAUTHORITY_UNIQUEID_RETRY_COUNT,10);
-        c.set(IDAUTHORITY_WAIT_MS,10);
+        c.set(IDAUTHORITY_WAIT_MS,100);
         c.set(IDAUTHORITY_UNIQUE_ID_BITS,7);
         c.set(IDAUTHORITY_RANDOMIZE_UNIQUE_ID,true);
         c.set(IDS_BLOCK_SIZE,400);

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseKeyColumnValueStore.java
Patch:
@@ -167,7 +167,7 @@ public void mutate(StaticBuffer key, List<Entry> additions, List<StaticBuffer> d
     }
 
     public void mutateMany(Map<StaticBuffer, KCVMutation> mutations, StoreTransaction txh) throws StorageException {
-        storeManager.mutateMany(ImmutableMap.of(columnFamily, mutations), txh);
+        storeManager.mutateMany(ImmutableMap.of(storeName, mutations), txh);
     }
 
     @Override

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -216,7 +216,7 @@ public HBaseStoreManager(com.thinkaurelius.titan.diskstorage.configuration.Confi
             this.cnx = HConnectionManager.createConnection(hconf);
         } catch (ZooKeeperConnectionException e) {
             throw new PermanentStorageException(e);
-        } catch (IOException e) { // thrown in 0.96 but not 0.94
+        } catch (@SuppressWarnings("hiding") IOException e) { // not thrown in 0.94, but thrown in 0.96+
             throw new PermanentStorageException(e);
         }
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseTransaction.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.titan.diskstorage.TransactionHandleConfig;
 import com.thinkaurelius.titan.diskstorage.common.AbstractStoreTransaction;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.ConsistencyLevel;
 
 /**
  * This class overrides and adds nothing compared with

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -351,6 +351,7 @@ private WriteResult tryWriteLockOnce(StaticBuffer key, StaticBuffer del, StoreTr
             StoreTransaction newTx = overrideTimestamp(txh, before);
             store.mutate(key, Arrays.asList(newLockEntry), null == del ? KeyColumnValueStore.NO_DELETIONS : Arrays.asList(del), newTx);
         } catch (StorageException e) {
+            log.debug("Lock write attempt failed with exception", e);
             t = e;
         }
         final long after = times.getTime();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/placement/PartitionIDRange.java
Patch:
@@ -27,7 +27,7 @@ public PartitionIDRange(int lowerID, int upperID, int idUpperBound) {
         Preconditions.checkArgument(idUpperBound>0, "Partition limit " + idUpperBound + " must be positive");
         Preconditions.checkArgument(idUpperBound<=Integer.MAX_VALUE, "Partition limit cannot exceed representable range of an integer");
         Preconditions.checkArgument(lowerID>=0, "Negative partition lower bound " + lowerID);
-        Preconditions.checkArgument(lowerID< idUpperBound, "Partition lower bound" + lowerID + " equal to or greater than limit " + idUpperBound);
+        Preconditions.checkArgument(lowerID< idUpperBound, "Partition lower bound " + lowerID + " exceeds limit " + idUpperBound);
         Preconditions.checkArgument(upperID>=0, "Negative partition upper bound " + upperID);
         Preconditions.checkArgument(upperID<=idUpperBound, "Partition upper bound " + upperID + " exceeds limit " + idUpperBound);
         this.lowerID = lowerID;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/AbstractVertexCentricQueryBuilder.java
Patch:
@@ -454,12 +454,12 @@ public static boolean hasSortKeyConstraints(EdgeSerializer.TypedInterval[] cons)
     private static Condition<TitanRelation> getTypeCondition(Set<TitanType> types) {
         assert !types.isEmpty();
         if (types.size() == 1)
-            return new LabelCondition<TitanRelation>(types.iterator().next());
+            return new RelationTypeCondition<TitanRelation>(types.iterator().next());
 
         Or<TitanRelation> typeCond = new Or<TitanRelation>(types.size());
 
         for (TitanType type : types)
-            typeCond.add(new LabelCondition<TitanRelation>(type));
+            typeCond.add(new RelationTypeCondition<TitanRelation>(type));
 
         return typeCond;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanTypeVertex.java
Patch:
@@ -62,6 +62,7 @@ public TypeDefinitionMap getDefinition() {
                 Preconditions.checkArgument(desc!=null && desc.getCategory().isProperty());
                 def.setValue(desc.getCategory(), property.getValue());
             }
+            assert def.size()>0;
             definition = def;
         }
         return definition;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/kryo/KryoSerializer.java
Patch:
@@ -29,7 +29,7 @@ public class KryoSerializer {
             //General
                     ArrayList.class, HashMap.class, Object.class,
             //Titan specific
-                    TypeAttributeType.class, TypeAttribute.class, TitanTypeCategory.class,
+                    TypeDefinitionCategory.class, TypeDefinitionDescription.class, TitanTypeCategory.class,
                     IndexType.class, IndexType[].class, Parameter.class, Parameter[].class,
                     IndexParameters.class, IndexParameters[].class, Order.class
             );

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalType.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.titan.core.Order;
 import com.thinkaurelius.titan.core.TitanType;
-import com.thinkaurelius.titan.graphdb.types.TypeAttribute;
 import com.tinkerpop.blueprints.Direction;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardLabelMaker.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.tinkerpop.blueprints.Direction;
 
-import static com.thinkaurelius.titan.graphdb.types.TypeAttributeType.UNIDIRECTIONAL;
+import static com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory.UNIDIRECTIONAL;
 import static com.tinkerpop.blueprints.Direction.IN;
 
 /**
@@ -112,7 +112,7 @@ public TitanLabel make() {
                 (!isUnique(IN)),
                 "Unidirectional labels cannot be unique");
 
-        TypeAttribute.Map definition = makeDefinition();
+        TypeDefinitionMap definition = makeDefinition();
         definition.setValue(UNIDIRECTIONAL, isUnidirectional);
         return tx.makeEdgeLabel(getName(), definition);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardTypeMaker.java
Patch:
@@ -14,7 +14,7 @@
 
 import java.util.*;
 
-import static com.thinkaurelius.titan.graphdb.types.TypeAttributeType.*;
+import static com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory.*;
 import static com.tinkerpop.blueprints.Direction.OUT;
 
 abstract class StandardTypeMaker implements TypeMaker {
@@ -102,10 +102,10 @@ private static long[] checkSignature(List<TitanType> sig) {
         return signature;
     }
 
-    protected final TypeAttribute.Map makeDefinition() {
+    protected final TypeDefinitionMap makeDefinition() {
         checkGeneralArguments();
 
-        TypeAttribute.Map def = new TypeAttribute.Map();
+        TypeDefinitionMap def = new TypeDefinitionMap();
         def.setValue(UNIQUENESS, new boolean[]{isUnique[0], isUnique[1]});
         def.setValue(UNIQUENESS_LOCK, hasUniqueLock);
         def.setValue(HIDDEN, isHidden);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -41,7 +41,7 @@ public static SystemType getSystemRelationType(long id) {
 
     public static final Set<? extends SystemType> prepersistedSystemTypes = ImmutableSet.of(
             SystemKey.TypeName,
-            SystemKey.TypeDefinition,
+            SystemKey.TypeDefinitionProperty,
             SystemKey.TypeCategory);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanLabelVertex.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.thinkaurelius.titan.core.TitanLabel;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
-import com.thinkaurelius.titan.graphdb.types.TypeAttributeType;
+import com.thinkaurelius.titan.graphdb.types.TypeDefinitionCategory;
 
 public class TitanLabelVertex extends TitanTypeVertex implements TitanLabel {
 
@@ -17,7 +17,7 @@ public boolean isDirected() {
     }
 
     public boolean isUnidirected() {
-        return getDefinition().getValue(TypeAttributeType.UNIDIRECTIONAL,boolean.class);
+        return getDefinition().getValue(TypeDefinitionCategory.UNIDIRECTIONAL,boolean.class);
     }
 
     @Override

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/types/TypeReferenceContainerTest.java
Patch:
@@ -79,7 +79,7 @@ private void verifyTypes(TypeInspector types) {
         assertEquals(String.class,uid.getDataType());
 
         assertTrue(types.containsType(SystemKey.VertexExists.getName()));
-        assertEquals(SystemKey.TypeDefinition,types.getExistingType(SystemKey.TypeDefinition.getID()));
+        assertEquals(SystemKey.TypeDefinitionProperty,types.getExistingType(SystemKey.TypeDefinitionProperty.getID()));
         assertEquals(SystemKey.TypeCategory,types.getType(SystemKey.TypeCategory.getName()));
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanElement.java
Patch:
@@ -156,5 +156,4 @@ public interface TitanElement extends Element, Comparable<TitanElement>, Removab
      */
     public boolean isRemoved();
 
-
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -85,7 +85,7 @@ public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
         this.serializer = config.getSerializer();
         this.indexSerializer = new IndexSerializer(this.serializer, this.backend.getIndexInformation());
         this.edgeSerializer = new EdgeSerializer(this.serializer);
-        this.vertexExistenceQuery = edgeSerializer.getQuery(SystemKey.VertexState, Direction.OUT, new EdgeSerializer.TypedInterval[0], null).setLimit(1);
+        this.vertexExistenceQuery = edgeSerializer.getQuery(SystemKey.VertexExists, Direction.OUT, new EdgeSerializer.TypedInterval[0], null).setLimit(1);
         this.queryCache = new RelationQueryCache(this.edgeSerializer);
         this.schemaCache = configuration.getTypeCache(typeCacheRetrieval);
         isOpen = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
-import com.thinkaurelius.titan.graphdb.internal.RelationType;
+import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -130,7 +130,7 @@ private static StaticBuffer getPrefixed(int prefix) {
         return new StaticArrayBuffer(arr);
     }
 
-    public static StaticBuffer[] getBounds(RelationType type) {
+    public static StaticBuffer[] getBounds(RelationCategory type) {
         int start, end;
         switch (type) {
             case PROPERTY:

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalType.java
Patch:
@@ -12,8 +12,6 @@
  */
 public interface InternalType extends TitanType, InternalVertex {
 
-    public boolean isHidden();
-
     public boolean uniqueLock(Direction direction);
 
     public long[] getSignature();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/RelationCategory.java
Patch:
@@ -8,7 +8,7 @@
 /**
 * @author Matthias Broecheler (me@matthiasb.com)
 */
-public enum RelationType implements Condition<TitanRelation> {
+public enum RelationCategory implements Condition<TitanRelation> {
 
     EDGE, PROPERTY, RELATION;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.core.attribute.Cmp;
 import com.thinkaurelius.titan.core.attribute.Contain;
 import com.thinkaurelius.titan.graphdb.database.IndexSerializer;
-import com.thinkaurelius.titan.graphdb.internal.ElementType;
+import com.thinkaurelius.titan.graphdb.internal.ElementCategory;
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
 import com.thinkaurelius.titan.graphdb.query.condition.*;
@@ -209,7 +209,7 @@ private static <E extends TitanElement> void addConstraint(TitanType type, Titan
      * @param condition
      * @return
      */
-    public static final Set<String> andClauseIndexCover(final ElementType result, Condition<TitanElement> condition, IndexSerializer indexInfo) {
+    public static final Set<String> andClauseIndexCover(final ElementCategory result, Condition<TitanElement> condition, IndexSerializer indexInfo) {
         Set<String> indexes = NO_INDEXES;
         if (condition instanceof PredicateCondition) {
             PredicateCondition<TitanType, TitanElement> atom = (PredicateCondition) condition;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/SimpleVertexQueryProcessor.java
Patch:
@@ -14,7 +14,7 @@
 import com.thinkaurelius.titan.graphdb.database.RelationQueryCache;
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
-import com.thinkaurelius.titan.graphdb.internal.RelationType;
+import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
 import com.thinkaurelius.titan.graphdb.transaction.RelationConstructor;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.util.datastructures.Retriever;
@@ -66,7 +66,7 @@ public SimpleVertexQueryProcessor(InternalVertex vertex, TitanKey key) {
         filterHiddenProperties = key==null;
         if (key==null || tx.getConfiguration().hasPropertyPrefetching()) {
             this.key = key;
-            sliceQuery = cache.getQuery(RelationType.PROPERTY);
+            sliceQuery = cache.getQuery(RelationCategory.PROPERTY);
         } else {
             sliceQuery = cache.getQuery((InternalType)key,Direction.OUT);
         }
@@ -79,7 +79,7 @@ public SimpleVertexQueryProcessor(InternalVertex vertex, Direction dir, TitanLab
         RelationQueryCache cache = tx.getGraph().getQueryCache();
         if (label==null) {
             assert sortKeyConstraints==null;
-            sliceQuery = cache.getQuery(RelationType.EDGE);
+            sliceQuery = cache.getQuery(RelationCategory.EDGE);
             filterDirection = dir==Direction.BOTH?null:dir;
         } else {
             if (AbstractVertexCentricQueryBuilder.hasSortKeyConstraints(sortKeyConstraints)) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemType.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
-import com.thinkaurelius.titan.graphdb.internal.RelationType;
+import com.thinkaurelius.titan.graphdb.internal.RelationCategory;
 import com.thinkaurelius.titan.graphdb.relations.EdgeDirection;
 import com.tinkerpop.blueprints.Direction;
 import org.apache.commons.lang.StringUtils;
@@ -18,7 +18,7 @@ public abstract class SystemType extends EmptyVertex implements InternalVertex,
     private final boolean isModifiable;
 
 
-    SystemType(String name, long id, RelationType type, boolean[] isUnique, boolean isModifiable) {
+    SystemType(String name, long id, RelationCategory type, boolean[] isUnique, boolean isModifiable) {
         Preconditions.checkArgument(StringUtils.isNotBlank(name));
         Preconditions.checkArgument(isUnique != null && isUnique.length == 2);
         this.name = SystemTypeManager.systemETprefix + name;
@@ -27,7 +27,7 @@ public abstract class SystemType extends EmptyVertex implements InternalVertex,
         this.isModifiable = isModifiable;
     }
 
-    static long getSystemTypeId(long id, RelationType type) {
+    static long getSystemTypeId(long id, RelationCategory type) {
         Preconditions.checkArgument(id > 0);
         Preconditions.checkArgument(id <= SystemTypeManager.SYSTEM_TYPE_OFFSET, "System id [%s] is too large", id);
         Preconditions.checkArgument(type.isProper());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -42,6 +42,6 @@ public static SystemType getSystemRelationType(long id) {
     public static final Set<? extends SystemType> prepersistedSystemTypes = ImmutableSet.of(
             SystemKey.TypeName,
             SystemKey.TypeDefinition,
-            SystemKey.TypeClass);
+            SystemKey.TypeCategory);
 
 }

File: titan-lucene/src/main/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneIndex.java
Patch:
@@ -414,6 +414,7 @@ public TransactionHandle beginTransaction() throws StorageException {
 
     @Override
     public boolean supports(KeyInformation information, TitanPredicate titanPredicate) {
+        if (information.getCardinality()!= KeyInformation.Cardinality.SINGLE) return false;
         Class<?> dataType = information.getDataType();
         Mapping mapping = Mapping.getMapping(information);
         if (mapping!=Mapping.DEFAULT && !AttributeUtil.isString(dataType)) return false;
@@ -436,6 +437,7 @@ public boolean supports(KeyInformation information, TitanPredicate titanPredicat
 
     @Override
     public boolean supports(KeyInformation information) {
+        if (information.getCardinality()!= KeyInformation.Cardinality.SINGLE) return false;
         Class<?> dataType = information.getDataType();
         Mapping mapping = Mapping.getMapping(information);
         if (Number.class.isAssignableFrom(dataType) || dataType == Geoshape.class) {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/util/TitanId.java
Patch:
@@ -19,8 +19,8 @@ public class TitanId {
      */
     public static final long toVertexId(long id) {
         Preconditions.checkArgument(id > 0, "Vertex id must be positive: %s", id);
-        Preconditions.checkArgument(IDManager.IDType.Vertex.removePadding(Long.MAX_VALUE) >= id, "Vertex id is too large: %s", id);
-        return IDManager.IDType.Vertex.addPadding(id);
+        Preconditions.checkArgument(IDManager.VertexIDType.Vertex.removePadding(Long.MAX_VALUE) >= id, "Vertex id is too large: %s", id);
+        return IDManager.VertexIDType.Vertex.addPadding(id);
     }
 
     /**
@@ -31,7 +31,7 @@ public static final long toVertexId(long id) {
      */
     public static final long fromVertexId(long id) {
         Preconditions.checkArgument(id > 0, "Invalid vertex id provided: %s", id);
-        return IDManager.IDType.Vertex.removePadding(id);
+        return IDManager.VertexIDType.Vertex.removePadding(id);
     }
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemType.java
Patch:
@@ -33,9 +33,9 @@ static long getSystemTypeId(long id, RelationType type) {
         Preconditions.checkArgument(type.isProper());
         switch (type) {
             case EDGE:
-                return IDManager.getEdgeLabelID(id);
+                return IDManager.getSchemaId(IDManager.VertexIDType.EdgeLabel,id);
             case PROPERTY:
-                return IDManager.getPropertyKeyID(id);
+                return IDManager.getSchemaId(IDManager.VertexIDType.PropertyKey,id);
             default:
                 throw new AssertionError("Illegal condition: " + type);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanTypeVertex.java
Patch:
@@ -30,7 +30,7 @@ public String getName() {
             if (isLoaded()) {
                 StandardTitanTx tx = tx();
                 p = (TitanProperty) Iterables.getOnlyElement(RelationConstructor.readRelation(this,
-                                            tx.getGraph().getTypeCache().getTypeRelations(getID(), SystemKey.TypeName, Direction.OUT, tx()),
+                                            tx.getGraph().getSchemaCache().getTypeRelations(getID(), SystemKey.TypeName, Direction.OUT, tx()),
                                             tx), null);
             } else {
                 p = Iterables.getOnlyElement(query().
@@ -50,7 +50,7 @@ public TypeAttribute.Map getDefinition() {
             if (isLoaded()) {
                 StandardTitanTx tx = tx();
                 ps = (Iterable)RelationConstructor.readRelation(this,
-                        tx.getGraph().getTypeCache().getTypeRelations(getID(), SystemKey.TypeDefinition, Direction.OUT, tx()),
+                        tx.getGraph().getSchemaCache().getTypeRelations(getID(), SystemKey.TypeDefinition, Direction.OUT, tx()),
                         tx);
             } else {
                 ps = query().includeHidden().type(SystemKey.TypeDefinition).properties();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanNonTransactionalGraphMetricsTest.java
Patch:
@@ -14,7 +14,7 @@
 import static junit.framework.Assert.assertNotNull;
 
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import static com.thinkaurelius.titan.graphdb.database.cache.MetricInstrumentedTypeCache.*;
+import static com.thinkaurelius.titan.graphdb.database.cache.MetricInstrumentedSchemaCache.*;
 import com.thinkaurelius.titan.testcategory.SerialTests;
 import com.thinkaurelius.titan.util.stats.MetricManager;
 import com.tinkerpop.blueprints.Direction;

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -103,7 +103,7 @@ public void testIDAssignment() {
                 if (!flush) idAssigner.assignIDs(relations);
                 if (trial == -1) {
                     for (TitanVertex v : vertices) {
-                        System.out.println(idAssigner.getIDManager().getPartitionID(v.getID()));
+                        System.out.println(idAssigner.getIDManager().getPartitionId(v.getID()));
                     }
                     System.out.println("_____________________________________________");
                 }

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -468,8 +468,7 @@ private void ensureColumnFamilyExists(String tableName, String columnFamily) thr
                 HColumnDescriptor cdesc = new HColumnDescriptor(columnFamily);
                 if (null != compression && !compression.equals(COMPRESSION_DEFAULT))
                     HBaseSupport.setCompression(cdesc, compression);
-                desc.addFamily(cdesc);
-                adm.modifyTable(tableName.getBytes(), desc);
+                adm.addColumn(tableName, cdesc);
 
                 try {
                     logger.debug("Added HBase ColumnFamily {}, waiting for 1 sec. to propogate.", columnFamily);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -123,6 +123,7 @@ private void setLocalPartitions(long partitionBits) {
             try {
                 List<KeyRange> locals = idAuthority.getLocalIDPartition();
                 if (locals==null || locals.isEmpty()) throw new IllegalStateException("Returned partitions were empty");
+                log.debug("Processing {} local ID partition range(s)", locals.size());
                 for (KeyRange local : locals) {
                     Preconditions.checkArgument(local.getStart().length() >= 4);
                     Preconditions.checkArgument(local.getEnd().length() >= 4);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/VertexIDAssigner.java
Patch:
@@ -124,7 +124,8 @@ private void setLocalPartitions(long partitionBits) {
                 List<KeyRange> locals = idAuthority.getLocalIDPartition();
                 if (locals==null || locals.isEmpty()) throw new IllegalStateException("Returned partitions were empty");
                 for (KeyRange local : locals) {
-                    Preconditions.checkArgument(local.getStart().length() >= 4 && local.getEnd().length() >= 4);
+                    Preconditions.checkArgument(local.getStart().length() >= 4);
+                    Preconditions.checkArgument(local.getEnd().length() >= 4);
                     int[] partition = new int[2];
                     for (int i = 0; i < 2; i++) {
                         partition[i] = local.getAt(i).getInt(0);

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -1,13 +1,15 @@
 package com.thinkaurelius.titan;
 
 import static com.thinkaurelius.titan.diskstorage.cassandra.AbstractCassandraStoreManager.CASSANDRA_KEYSPACE;
+import static com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration.IDS_PARTITION;
 
 import java.io.File;
 import java.io.IOException;
 
 import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
+import com.thinkaurelius.titan.graphdb.database.idassigner.IDPartitionMode;
 
 import org.apache.commons.io.FileUtils;
 import org.slf4j.Logger;
@@ -49,7 +51,7 @@ public static ModifiableConfiguration getEmbeddedConfiguration(String ks) {
 
     public static ModifiableConfiguration getEmbeddedCassandraPartitionConfiguration(String ks) {
         ModifiableConfiguration config = getEmbeddedConfiguration(ks);
-        config.set(IDS_PARTITION,true);
+        config.set(IDS_PARTITION, IDPartitionMode.ENABLED);
         config.set(IDS_FLUSH,false);
 //        config.subset(GraphDatabaseConfiguration.METRICS_NAMESPACE).addProperty(GraphDatabaseConfiguration.METRICS_CONSOLE_INTERVAL, 3000L);
         return config;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -37,6 +37,7 @@
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
 import com.thinkaurelius.titan.diskstorage.Backend;
 import com.thinkaurelius.titan.graphdb.blueprints.BlueprintsDefaultTypeMaker;
+import com.thinkaurelius.titan.graphdb.database.idassigner.IDPartitionMode;
 import com.thinkaurelius.titan.graphdb.database.idassigner.VertexIDAssigner;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTransactionBuilder;
@@ -611,9 +612,9 @@ public boolean apply(@Nullable Integer uniqueIdBitWidth) {
      * enabled to ensure an even distribution of data. If the keyspace is random/hashed, then enabling this only has the benefit
      * of de-congesting a single id pool in the database.
      */
-    public static final ConfigOption<Boolean> IDS_PARTITION = new ConfigOption<Boolean>(IDS_NS,"partition",
+    public static final ConfigOption<IDPartitionMode> IDS_PARTITION = new ConfigOption<IDPartitionMode>(IDS_NS,"partition",
             "Whether the id space should be partitioned for equal distribution of keys",
-            ConfigOption.Type.FIXED, false);
+            ConfigOption.Type.FIXED, IDPartitionMode.DEFAULT);
 //    public static final String IDS_PARTITION_KEY = "partition";
 //    public static final boolean IDS_PARTITION_DEFAULT = false;
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -96,7 +96,7 @@ public static Partitioner getPartitioner(String className) {
      */
     public static final ConfigOption<String> CASSANDRA_COMPRESSION_TYPE = new ConfigOption<String>(STORAGE_NS,"compression-type",
             "The particular compression type to use for Cassandra sstable compression",
-            ConfigOption.Type.FIXED, "SnappyCompressor");
+            ConfigOption.Type.FIXED, "LZ4Compressor");
 
 //    public static final String COMPRESSION_KEY = "compression.sstable_compression";
 //    public static final String DEFAULT_COMPRESSION = "SnappyCompressor";

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraKeyColumnValueStoreTest.java
Patch:
@@ -78,7 +78,7 @@ public void testDefaultCFCompressor() throws StorageException {
 
         Map<String, String> defaultCfCompressionOps =
                 new ImmutableMap.Builder<String, String>()
-                .put("sstable_compression", DEFAULT_COMPRESSOR_PACKAGE + ".SnappyCompressor")
+                .put("sstable_compression", DEFAULT_COMPRESSOR_PACKAGE + "." + AbstractCassandraStoreManager.CASSANDRA_COMPRESSION_TYPE.getDefaultValue())
                 .put("chunk_length_kb", "64")
                 .build();
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftKeyColumnValueStore.java
Patch:
@@ -100,9 +100,9 @@ public Map<StaticBuffer, EntryList> getNamesSlice(List<StaticBuffer> keys,
 		 * Cassandra's Thrift getSlice() throws InvalidRequestException
 		 * if columnStart = columnEnd.
 		 */
-        if (ByteBufferUtil.compare(query.getSliceStart(), query.getSliceEnd()) >= 0) {
+        if (query.getSliceStart().compareTo(query.getSliceEnd()) >= 0) {
             // Check for invalid arguments where columnEnd < columnStart
-            if (ByteBufferUtil.isSmallerThan(query.getSliceEnd(), query.getSliceStart())) {
+            if (query.getSliceEnd().compareTo(query.getSliceStart())<0) {
                 throw new PermanentStorageException("columnStart=" + query.getSliceStart() +
                         " is greater than columnEnd=" + query.getSliceEnd() + ". " +
                         "columnStart must be less than or equal to columnEnd");
@@ -113,7 +113,7 @@ public Map<StaticBuffer, EntryList> getNamesSlice(List<StaticBuffer> keys,
             }
         }
 
-        assert ByteBufferUtil.compare(query.getSliceStart(), query.getSliceEnd()) < 0;
+        assert query.getSliceStart().compareTo(query.getSliceEnd()) < 0;
         ConsistencyLevel consistency = getTx(txh).getReadConsistencyLevel().getThrift();
         SlicePredicate predicate = new SlicePredicate();
         SliceRange range = new SliceRange();

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -12,11 +12,11 @@
 import java.util.Map;
 import java.util.SortedMap;
 import java.util.TreeMap;
-import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
+import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
 import com.thinkaurelius.titan.util.system.NetworkUtil;
 
 import org.apache.cassandra.dht.ByteOrderedPartitioner;
@@ -55,9 +55,7 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KCVMutation;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.Hex;
-import com.thinkaurelius.titan.diskstorage.util.TimestampProvider;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
 /**

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/utils/CassandraHelper.java
Patch:
@@ -6,13 +6,12 @@
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.thinkaurelius.titan.diskstorage.EntryList;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntryList;
@@ -72,7 +71,7 @@ private FilterResultColumns(StaticBuffer lastColumn, int limit, StaticArrayEntry
         @Override
         public boolean apply(@Nullable E e) {
             assert e!=null;
-            if (count>=limit || ByteBufferUtil.equals(lastColumn, getter.getColumn(e))) return false;
+            if (count>=limit || BufferUtil.equals(lastColumn, getter.getColumn(e))) return false;
             count++;
             return true;
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/BackendTransaction.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.indexing.RawQuery;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -34,8 +34,8 @@ public class BackendTransaction implements TransactionHandle {
     public static final int MIN_TASKS_TO_PARALLELIZE = 2;
 
     //Assumes 64 bit key length as specified in IDManager
-    public static final StaticBuffer EDGESTORE_MIN_KEY = ByteBufferUtil.zeroBuffer(8);
-    public static final StaticBuffer EDGESTORE_MAX_KEY = ByteBufferUtil.oneBuffer(8);
+    public static final StaticBuffer EDGESTORE_MIN_KEY = BufferUtil.zeroBuffer(8);
+    public static final StaticBuffer EDGESTORE_MAX_KEY = BufferUtil.oneBuffer(8);
 
     private final StoreTransaction storeTx;
     private final TransactionHandleConfig txConfig;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/KCVSConfiguration.java
Patch:
@@ -14,7 +14,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionConfig;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
@@ -75,7 +75,7 @@ public void setMaxOperationWaitTime(long waitTimeMS) {
     @Override
     public <O> O get(final String key, final Class<O> datatype) {
         StaticBuffer column = string2StaticBuffer(key);
-        final KeySliceQuery query = new KeySliceQuery(rowKey,column, ByteBufferUtil.nextBiggerBuffer(column));
+        final KeySliceQuery query = new KeySliceQuery(rowKey,column, BufferUtil.nextBiggerBuffer(column));
         StaticBuffer result = BackendOperation.execute(new Callable<StaticBuffer>() {
             @Override
             public StaticBuffer call() throws Exception {
@@ -173,7 +173,7 @@ public List<Entry> call() throws Exception {
                 StoreTransaction txh=null;
                 try {
                     txh= manager.beginTransaction(txCfg);
-                    return store.getSlice(new KeySliceQuery(rowKey,ByteBufferUtil.zeroBuffer(128),ByteBufferUtil.oneBuffer(128)),txh);
+                    return store.getSlice(new KeySliceQuery(rowKey, BufferUtil.zeroBuffer(128), BufferUtil.oneBuffer(128)),txh);
                 } finally {
                     if (txh!=null) txh.commit();
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.common.DistributedStoreManager;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 
@@ -63,7 +63,7 @@ public synchronized void setIDBlockSizer(IDBlockSizer sizer) {
      * @return
      */
     protected StaticBuffer getPartitionKey(int partition) {
-        return ByteBufferUtil.getIntBuffer(partition);
+        return BufferUtil.getIntBuffer(partition);
     }
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreAdapter.java
Patch:
@@ -50,7 +50,7 @@ public OrderedKeyValueStoreAdapter(OrderedKeyValueStore store, int keyLength) {
     @Override
     public boolean containsKey(StaticBuffer key, StoreTransaction txh) throws StorageException {
         ContainsSelector select = new ContainsSelector(key);
-        store.getSlice(key, ByteBufferUtil.nextBiggerBuffer(key), select, txh);
+        store.getSlice(key, BufferUtil.nextBiggerBuffer(key), select, txh);
         return select.contains();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -122,10 +122,10 @@ public class ConsistentKeyLocker extends AbstractLocker<ConsistentKeyLockStatus>
      */
     private final LockCleanerService cleanerService;
 
-    private static final StaticBuffer zeroBuf = ByteBufferUtil.getIntBuffer(0); // TODO this does not belong here
+    private static final StaticBuffer zeroBuf = BufferUtil.getIntBuffer(0); // TODO this does not belong here
 
-    public static final StaticBuffer LOCK_COL_START = ByteBufferUtil.zeroBuffer(9);
-    public static final StaticBuffer LOCK_COL_END   = ByteBufferUtil.oneBuffer(9);
+    public static final StaticBuffer LOCK_COL_START = BufferUtil.zeroBuffer(9);
+    public static final StaticBuffer LOCK_COL_END   = BufferUtil.oneBuffer(9);
 
     private static final Logger log = LoggerFactory.getLogger(ConsistentKeyLocker.class);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingTransaction.java
Patch:
@@ -8,7 +8,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.locking.LocalLockMediator;
 import com.thinkaurelius.titan.diskstorage.locking.PermanentLockingException;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -116,7 +116,7 @@ private void checkSingleExpectedValue(final KeyColumn kc,
 
     private void checkSingleExpectedValueUnsafe(final KeyColumn kc,
                                                 final StaticBuffer ev, final ExpectedValueCheckingStore store) throws StorageException {
-        KeySliceQuery ksq = new KeySliceQuery(kc.getKey(), kc.getColumn(), ByteBufferUtil.nextBiggerBuffer(kc.getColumn()));
+        KeySliceQuery ksq = new KeySliceQuery(kc.getKey(), kc.getColumn(), BufferUtil.nextBiggerBuffer(kc.getColumn()));
         List<Entry> actualEntries = store.getSlice(ksq, this); // TODO make this consistent/QUORUM?
 
         if (null == actualEntries)

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/Hex.java
Patch:
@@ -10,7 +10,7 @@ public class Hex {
     private static final Constructor<String> stringConstructor = getProtectedConstructor(String.class, int.class, int.class, char[].class);
     private final static byte[] charToByte = new byte[256];
 
-    // package protected for use by ByteBufferUtil. Do not modify this array !!
+    // package protected for use by BufferUtil. Do not modify this array !!
     static final char[] byteToChar = new char[16];
 
     static {

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/log/LogTest.java
Patch:
@@ -2,8 +2,7 @@
 
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import org.junit.*;
 import static org.junit.Assert.*;
 import org.slf4j.Logger;
@@ -56,7 +55,7 @@ public void simpleSendReceive(int numMessages, int delayMS) throws Exception {
         CountingReader count = new CountingReader();
         log1.registerReader(count);
         for (long i=1;i<=numMessages;i++) {
-            log1.add(ByteBufferUtil.getLongBuffer(i));
+            log1.add(BufferUtil.getLongBuffer(i));
             System.out.println("Wrote message: " + i);
             Thread.sleep(delayMS);
         }

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/MockIDAuthority.java
Patch:
@@ -7,13 +7,12 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyRange;
-import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.util.BufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDPoolExhaustedException;
 import com.thinkaurelius.titan.graphdb.database.idassigner.StaticIDBlockSizer;
 
-import java.nio.ByteBuffer;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ConcurrentHashMap;
@@ -86,7 +85,7 @@ public void setLocalPartition(int[] local) {
     public List<KeyRange> getLocalIDPartition() throws StorageException {
         StaticBuffer lower = new WriteByteBuffer(4).putInt(localPartition[0]).getStaticBuffer();
         StaticBuffer upper = new WriteByteBuffer(4).putInt(localPartition[1]).getStaticBuffer();
-        Preconditions.checkArgument(ByteBufferUtil.isSmallerThan(lower, upper), Arrays.toString(localPartition));
+        Preconditions.checkArgument(lower.compareTo(upper)<0, Arrays.toString(localPartition));
         return Lists.newArrayList(new KeyRange(lower, upper));
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -244,8 +244,8 @@ public void initialize(Configuration config) {
             boolean hashPrefixIndex = storeFeatures.isDistributed() && storeFeatures.isKeyOrdered();
             if (hashPrefixIndex) {
                 log.info("Wrapping index store with HashPrefix");
-                vertexIndexStore = new HashPrefixKeyColumnValueStore(vertexIndexStore, 4);
-                edgeIndexStore = new HashPrefixKeyColumnValueStore(edgeIndexStore, 4);
+                vertexIndexStore = new HashPrefixKeyColumnValueStore(vertexIndexStore, HashPrefixKeyColumnValueStore.HashLength.SHORT);
+                edgeIndexStore = new HashPrefixKeyColumnValueStore(edgeIndexStore, HashPrefixKeyColumnValueStore.HashLength.SHORT);
             }
 
             if (reportMetrics) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/WriteBuffer.java
Patch:
@@ -13,6 +13,8 @@ public interface WriteBuffer {
 
     public WriteBuffer putBytes(byte[] val);
 
+    public WriteBuffer putBytes(StaticBuffer val);
+
     public WriteBuffer putShort(short val);
 
     public WriteBuffer putInt(int val);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/log/kcvs/KCVSLog.java
Patch:
@@ -290,9 +290,7 @@ private Entry writeMessage(KCVSMessage msg) {
         out.writeObjectNotNull(manager.senderId);
         out.putLong(numMsgCounter.incrementAndGet());
         final int valuePos = out.getPosition();
-        for (int i = 0; i < content.length(); i++) {
-            out.putByte(content.getByte(i));
-        }
+        out.putBytes(content);
         return new StaticArrayEntry(out.getStaticBuffer(),valuePos);
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/HashKeyColumnValueStoreTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage;
 
+import com.thinkaurelius.titan.diskstorage.indexing.HashPrefixKeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.indexing.HashPrefixStoreManager;
 
 /**
@@ -10,7 +11,7 @@ public abstract class HashKeyColumnValueStoreTest extends KeyColumnValueStoreTes
 
     @Override
     public void open() throws StorageException {
-        manager = new HashPrefixStoreManager(openStorageManager(),4);
+        manager = new HashPrefixStoreManager(openStorageManager(), HashPrefixKeyColumnValueStore.HashLength.LONG);
         store = manager.openDatabase(storeName);
         tx = startTx();
     }

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/IDPoolTest.java
Patch:
@@ -87,7 +87,7 @@ public void run() {
                     }
                 }
             });
-            threads[i].run();
+            threads[i].start();
         }
         for (int i = 0; i < numThreads; i++) threads[i].join();
         for (int i = 0; i < idPools.length; i++) idPools[i].close();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -503,7 +503,7 @@ protected void deleteSingleLock(KeyColumn kc, ConsistentKeyLockStatus ls, StoreT
     }
 
     private StoreTransaction overrideTimestamp(final StoreTransaction tx, final long ts) throws StorageException {
-        StandardTransactionConfig newCfg = new StandardTransactionConfig.Builder(tx.getConfiguration(), ts).build();
+        StandardTransactionConfig newCfg = new StandardTransactionConfig.Builder(tx.getConfiguration(), ts).timestampProvider(times).build();
         return manager.beginTransaction(newCfg);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/Timestamps.java
Patch:
@@ -82,7 +82,7 @@ public TimeUnit getUnit() {
 
         @Override
         public long sleepUntil(long time, final TimeUnit unit, final Logger log) throws InterruptedException {
-            return super.sleepUntil(TimeUnit.MILLISECONDS.convert(time, unit) + 1, TimeUnit.MILLISECONDS, log);
+            return TimeUnit.MICROSECONDS.convert(super.sleepUntil(TimeUnit.MILLISECONDS.convert(time, unit) + 1, TimeUnit.MILLISECONDS, log), TimeUnit.MILLISECONDS);
         }
     },
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -213,6 +213,8 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
         } catch (InterruptedException e) {
             throw new TemporaryStorageException(e);
         }
+
+        Uninterruptibles.sleepUninterruptibly(1L, TimeUnit.MILLISECONDS);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -187,6 +187,8 @@ public Builder fromConfig(Configuration config) {
                     ExpectedValueCheckingStore.LOCAL_LOCK_MEDIATOR_PREFIX);
             mediator(LocalLockMediators.INSTANCE.<StoreTransaction>get(llmPrefix));
 
+            times(config.get(GraphDatabaseConfiguration.TIMESTAMP_PROVIDER));
+
             lockRetryCount(config.get(GraphDatabaseConfiguration.LOCK_RETRY));
 
             lockWait(config.get(GraphDatabaseConfiguration.LOCK_WAIT), TimeUnit.MILLISECONDS);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/AbstractLocker.java
Patch:
@@ -11,10 +11,11 @@
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ConsistentKeyLockerSerializer;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
-import com.thinkaurelius.titan.diskstorage.util.NanoTime;
 import com.thinkaurelius.titan.diskstorage.util.TimestampProvider;
+import com.thinkaurelius.titan.diskstorage.util.Timestamps;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.util.stats.MetricManager;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -124,7 +125,7 @@ public static abstract class Builder<S, B extends Builder<S, B>> {
 
         public Builder() {
             this.rid = new StaticArrayBuffer(DistributedStoreManager.getRid(Configuration.EMPTY));
-            this.times = NanoTime.INSTANCE;
+            this.times = Timestamps.NANO;
             this.serializer = new ConsistentKeyLockerSerializer();
             this.llm = null; // redundant, but it preserves this constructor's overall pattern
             this.lockState = new LockerState<S>();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediator.java
Patch:
@@ -2,7 +2,8 @@
 
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
-import com.thinkaurelius.titan.diskstorage.util.NanoTime;
+import com.thinkaurelius.titan.diskstorage.util.Timestamps;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -115,7 +116,7 @@ public boolean lock(KeyColumn kc, T requestor,
                                     audit.expires});
                 }
             }
-        } else if (inmap.expires <= NanoTime.INSTANCE.getTime()) {
+        } else if (inmap.expires <= Timestamps.NANO.getTime()) {
             // the recorded lock has expired; replace it
             success = locks.replace(kc, inmap, audit);
             if (log.isTraceEnabled()) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTransactionBuilder.java
Patch:
@@ -14,7 +14,6 @@
 import com.thinkaurelius.titan.diskstorage.configuration.ConfigOption;
 import com.thinkaurelius.titan.diskstorage.configuration.Configuration;
 import com.thinkaurelius.titan.diskstorage.util.StandardTransactionConfig;
-import com.thinkaurelius.titan.diskstorage.util.NanoTime;
 import com.thinkaurelius.titan.diskstorage.util.TimestampProvider;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
@@ -56,7 +55,7 @@ public class StandardTransactionBuilder implements TransactionConfiguration, Tra
 
     private String metricsPrefix;
 
-    private TimestampProvider timestampProvider = NanoTime.INSTANCE;
+    private TimestampProvider timestampProvider;
 
     private final UserModifiableConfiguration storageConfiguration;
 
@@ -73,6 +72,7 @@ public StandardTransactionBuilder(GraphDatabaseConfiguration graphConfig, Standa
         this.assignIDsImmediately = graphConfig.hasFlushIDs();
         this.metricsPrefix = graphConfig.getMetricsPrefix();
         this.propertyPrefetching = graphConfig.hasPropertyPrefetching();
+        this.timestampProvider = graphConfig.getTimestampProvider();
         this.storageConfiguration = TitanFactory.buildConfiguration();
         if (graphConfig.isReadOnly()) readOnly();
         setCacheSize(graphConfig.getTxCacheSize());

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/util/TestTimeUtility.java
Patch:
@@ -18,7 +18,7 @@ public void testTimeSequence() throws Exception {
         Random r = new Random();
         long[] times = new long[10];
         for (int i = 0; i < times.length; i++) {
-            times[i] = NanoTime.INSTANCE.getTime();
+            times[i] = Timestamps.NANO.getTime();
             if (i > 0) assertTrue(times[i] + " > " + times[i - 1], times[i] > times[i - 1]);
             Thread.sleep(r.nextInt(50) + 2);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/cache/CacheTransaction.java
Patch:
@@ -16,17 +16,17 @@
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public class ExpirationTransaction implements StoreTransaction {
+public class CacheTransaction implements StoreTransaction {
 
     private static final Logger log =
-            LoggerFactory.getLogger(ExpirationTransaction.class);
+            LoggerFactory.getLogger(CacheTransaction.class);
 
     private final StoreTransaction tx;
     private final boolean validateKeysOnly;
     private final List<InvalidationEntry> invalidations;
 
 
-    public ExpirationTransaction(StoreTransaction tx) {
+    public CacheTransaction(StoreTransaction tx) {
         Preconditions.checkNotNull(tx);
         this.tx = tx;
         this.validateKeysOnly = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/MetricInstrumentedIterator.java
Patch:
@@ -6,6 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyIterator;
+import org.apache.commons.lang.StringUtils;
 
 /**
  * This class is used by {@code MetricInstrumentedStore} to measure wallclock
@@ -39,13 +40,13 @@ public class MetricInstrumentedIterator implements KeyIterator {
      * @return a wrapper around {@code keyIterator} or null if
      *         {@code keyIterator} is null
      */
-    public static MetricInstrumentedIterator of(KeyIterator keyIterator, String prefix) {
+    public static MetricInstrumentedIterator of(KeyIterator keyIterator, String... prefix) {
         if (keyIterator == null) {
             return null;
         }
 
         Preconditions.checkNotNull(prefix);
-        return new MetricInstrumentedIterator(keyIterator, prefix);
+        return new MetricInstrumentedIterator(keyIterator, StringUtils.join(prefix,"."));
     }
     
     private MetricInstrumentedIterator(KeyIterator i, String p) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -88,7 +88,7 @@ public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
         this.edgeSerializer = new EdgeSerializer(this.serializer);
         this.vertexExistenceQuery = edgeSerializer.getQuery(SystemKey.VertexState, Direction.OUT, new EdgeSerializer.TypedInterval[0], null).setLimit(1);
         this.queryCache = new RelationQueryCache(this.edgeSerializer);
-        this.typeCache = new StandardTypeCache(typeCacheRetrieval);
+        this.typeCache = configuration.getTypeCache(typeCacheRetrieval);
         isOpen = true;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/cache/StandardTypeCache.java
Patch:
@@ -107,12 +107,12 @@ public EntryList getTypeRelations(final long typeid, final SystemType type, fina
         assert IDManager.isEdgeLabelID(typeid) || IDManager.isPropertyKeyID(typeid);
         assert IDManager.IDType.EdgeLabel.offset()==TYPE_ID_BACKSHIFT && IDManager.IDType.PropertyKey.offset()==TYPE_ID_BACKSHIFT;
         assert SystemTypeManager.SYSTEM_TYPE_OFFSET <= (1<<TYPE_ID_BITSHIFT);
-        assert type.getID()<SystemTypeManager.SYSTEM_TYPE_OFFSET;
+        assert IDManager.getTypeCount(type.getID())<SystemTypeManager.SYSTEM_TYPE_OFFSET;
         Preconditions.checkArgument((Long.MAX_VALUE>>>(TYPE_ID_BITSHIFT-TYPE_ID_BACKSHIFT))>=typeid);
         int edgeDir = EdgeDirection.position(dir);
         assert edgeDir==0 || edgeDir==1;
 
-        final long typePlusRelation = ((((typeid >>> TYPE_ID_BACKSHIFT) << 1) + edgeDir) << TYPE_ID_BITSHIFT) + type.getID();
+        final long typePlusRelation = ((((typeid >>> TYPE_ID_BACKSHIFT) << 1) + edgeDir) << TYPE_ID_BITSHIFT) + IDManager.getTypeCount(type.getID());
         ConcurrentMap<Long,EntryList> types = typeRelations;
         EntryList entries;
         if (types==null) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/SimpleVertexQueryProcessor.java
Patch:
@@ -53,7 +53,7 @@ public class SimpleVertexQueryProcessor implements Iterable<Entry> {
     private boolean filterHiddenProperties;
 
     private SimpleVertexQueryProcessor(InternalVertex vertex) {
-        Preconditions.checkArgument(vertex.isLoaded(),"SimpleVertexQuery only applies to unmodified vertices");
+        //Preconditions.checkArgument(vertex.isLoaded()); -> don't check since concurrent parallel modification may have taken place and should be ignored. This is verified in VertexCentricQueryBuilder
         this.vertex = vertex;
         this.tx = vertex.tx();
         this.edgeSerializer = this.tx.getEdgeSerializer();

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -271,7 +271,7 @@ public void storeAndRetrieve() throws StorageException {
         checkValues(values);
     }
 
-    @Test
+    //@Test
     public void compareStores() throws StorageException {
         int keys = 1000, columns = 2000; boolean normalMode=true;
         String[][] values = new String[keys*2][];
@@ -319,7 +319,7 @@ public void compareStores() throws StorageException {
     @Test
     public void storeAndRetrievePerformance() throws StorageException {
         int multiplier = 4;
-        int keys = 500*4 * multiplier, columns = 200;
+        int keys = 50 * multiplier, columns = 200;
         String[][] values = KeyValueStoreUtil.generateData(keys, columns);
         log.debug("Loading values: " + keys + "x" + columns);
         long time = System.currentTimeMillis();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphConcurrentTest.java
Patch:
@@ -177,7 +177,7 @@ public void concurrentReadWriteOnSingleTransaction() throws Exception {
                 new FixedRelationshipMaker(tx, id,
                         makeSimpleEdgeLabel("dummyRelationship"));
 
-        newTx();
+        //newTx();
 
         Future<?> propFuture = executor.submit(propMaker);
         Future<?> relFuture = executor.submit(relMaker);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/configuration/backend/KCVSConfiguration.java
Patch:
@@ -72,7 +72,7 @@ public void setMaxOperationWaitTime(long waitTimeMS) {
     @Override
     public <O> O get(final String key, final Class<O> datatype) {
         StaticBuffer column = string2StaticBuffer(key);
-        final KeySliceQuery query = new KeySliceQuery(rowKey,column, ByteBufferUtil.nextBiggerBuffer(column),false);
+        final KeySliceQuery query = new KeySliceQuery(rowKey,column, ByteBufferUtil.nextBiggerBuffer(column));
         StaticBuffer result = BackendOperation.execute(new Callable<StaticBuffer>() {
             @Override
             public StaticBuffer call() throws Exception {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -95,7 +95,7 @@ public void close() throws StorageException {
 
     @Override
     public StoreTransaction openTx() throws StorageException {
-        return manager.beginTransaction(new StoreTxConfig(consistencLevel, metricsPrefix));
+        return manager.beginTransaction(new StoreTxConfig(consistencLevel, new StandardTransactionConfig(metricsPrefix)));
     }
 
     private long getCurrentID(final StaticBuffer partitionKey) throws StorageException {
@@ -248,7 +248,7 @@ public Boolean call(StoreTransaction txh) throws StorageException {
                                 }, new BackendOperation.TransactionalProvider() { //Use normal consistency level for these non-critical delete operations
                                     @Override
                                     public StoreTransaction openTx() throws StorageException {
-                                        return manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.DEFAULT,metricsPrefix));
+                                        return manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.DEFAULT,new StandardTransactionConfig(metricsPrefix)));
                                     }
                                 });
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreTransaction.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
-import com.thinkaurelius.titan.diskstorage.TransactionHandle;
+import com.thinkaurelius.titan.diskstorage.TransactionHandleConfigurable;
 
 /**
  * A transaction handle uniquely identifies a transaction on the storage backend.
@@ -14,13 +14,14 @@
  *
  * @author Matthias Br&ouml;cheler (me@matthiasb.com);
  */
-public interface StoreTransaction extends TransactionHandle {
+public interface StoreTransaction extends TransactionHandleConfigurable {
 
     /**
      * Get the configuration for this transaction
      *
      * @return
      */
+    @Override
     public StoreTxConfig getConfiguration();
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -430,6 +430,7 @@ protected void deleteSingleLock(KeyColumn kc, ConsistentKeyLockStatus ls, StoreT
     }
     
     private static StoreTransaction overrideTimestamp(final StoreTransaction tx, final long nanoTimestamp) {
+        //TODO: need to figure out how to do this with separate transactions!
         tx.getConfiguration().setTimestamp(nanoTimestamp);
         return tx;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/EdgeSerializer.java
Patch:
@@ -365,13 +365,11 @@ public SliceQuery getQuery(InternalType type, Direction dir, TypedInterval[] sor
         boolean isStatic;
         RelationType rt = type.isPropertyKey() ? RelationType.PROPERTY : RelationType.EDGE;
         if (dir == Direction.BOTH) {
-            isStatic = type.isStatic(Direction.OUT) && type.isStatic(Direction.IN);
             sliceStart = IDHandler.getEdgeType(type.getID(), getDirID(Direction.OUT, rt));
             sliceEnd = IDHandler.getEdgeType(type.getID(), getDirID(Direction.IN, rt));
             assert ByteBufferUtil.isSmallerThan(sliceStart, sliceEnd);
             sliceEnd = ByteBufferUtil.nextBiggerBuffer(sliceEnd);
         } else {
-            isStatic = type.isStatic(dir);
             int dirID = getDirID(dir, rt);
 
             DataOutput colStart = serializer.getDataOutput(DEFAULT_COLUMN_CAPACITY);
@@ -457,7 +455,7 @@ public SliceQuery getQuery(InternalType type, Direction dir, TypedInterval[] sor
                 sliceEnd = ByteBufferUtil.nextBiggerBuffer(sliceStart);
             }
         }
-        return new SliceQuery(sliceStart, sliceEnd, isStatic);
+        return new SliceQuery(sliceStart, sliceEnd);
     }
 
     public static class VertexConstraint {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -282,7 +282,7 @@ private List<Object> processSingleCondition(ElementType resultType, PredicateCon
                 "Cannot retrieve for given property key - it does not have an index [%s]", key.getName());
         Object value = pc.getValue();
         StaticBuffer column = getUniqueIndexColumn(key);
-        KeySliceQuery sq = new KeySliceQuery(getIndexKey(value), column, SliceQuery.pointRange(column), ((InternalType) key).isStatic(Direction.IN)).setLimit(limit);
+        KeySliceQuery sq = new KeySliceQuery(getIndexKey(value), column, SliceQuery.pointRange(column)).setLimit(limit);
         EntryList r;
         if (resultType == ElementType.VERTEX) {
             r = tx.vertexIndexQuery(sq);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalType.java
Patch:
@@ -14,8 +14,6 @@ public interface InternalType extends TitanType, InternalVertex {
 
     public boolean isHidden();
 
-    public boolean isStatic(Direction dir);
-
     public boolean uniqueLock(Direction direction);
 
     public long[] getSignature();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheEdge.java
Patch:
@@ -91,7 +91,7 @@ public long getID() {
     private RelationCache getPropertyMap() {
         RelationCache map = data.getCache();
         if (map == null || !map.hasProperties()) {
-            map = RelationConstructor.readRelation(getVertex(position), data, tx());
+            map = RelationConstructor.readRelationCache(getVertex(position), data, tx());
         }
         return map;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheProperty.java
Patch:
@@ -74,7 +74,7 @@ public long getID() {
     private RelationCache getPropertyMap() {
         RelationCache map = data.getCache();
         if (map == null || !map.hasProperties()) {
-            map = RelationConstructor.readRelation(getVertex(0), data, tx());
+            map = RelationConstructor.readRelationCache(getVertex(0), data, tx());
         }
         return map;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeAttributeType.java
Patch:
@@ -13,7 +13,6 @@ public enum TypeAttributeType {
 
     UNIQUENESS(boolean[].class),
     UNIQUENESS_LOCK(boolean[].class),
-    STATIC(boolean[].class),
     HIDDEN(Boolean.class),
     MODIFIABLE(Boolean.class),
     SORT_KEY(long[].class),
@@ -24,10 +23,10 @@ public enum TypeAttributeType {
     SORT_ORDER(Order.class),
     INDEX_PARAMETERS(IndexParameters[].class);
 
-    static final Set<TypeAttributeType> PROPERTY_KEY_TYPES = ImmutableSet.of(UNIQUENESS, UNIQUENESS_LOCK, STATIC,
+    static final Set<TypeAttributeType> PROPERTY_KEY_TYPES = ImmutableSet.of(UNIQUENESS, UNIQUENESS_LOCK,
             HIDDEN, MODIFIABLE, SORT_KEY, SORT_ORDER, SIGNATURE, INDEXES, INDEX_PARAMETERS, DATATYPE);
 
-    static final Set<TypeAttributeType> EDGE_LABEL_TYPES = ImmutableSet.of(UNIQUENESS, UNIQUENESS_LOCK, STATIC,
+    static final Set<TypeAttributeType> EDGE_LABEL_TYPES = ImmutableSet.of(UNIQUENESS, UNIQUENESS_LOCK,
             HIDDEN, MODIFIABLE, SORT_KEY, SORT_ORDER, SIGNATURE, UNIDIRECTIONAL);
 
     private final Class attributeClass;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/reference/TypeReferenceContainer.java
Patch:
@@ -164,7 +164,6 @@ private TitanTypeReference getFromJson(JsonObject input) {
                     break;
                 case UNIQUENESS:
                 case UNIQUENESS_LOCK:
-                case STATIC:
                     JsonArray arr = input.getJsonArray(key);
                     boolean[] bools = new boolean[arr.size()];
                     for (int i=0;i<bools.length;i++) bools[i]=arr.getBoolean(i);
@@ -259,7 +258,6 @@ private JsonObject exportToJson(TitanTypeReference type) {
                     break;
                 case UNIQUENESS:
                 case UNIQUENESS_LOCK:
-                case STATIC:
                     boolean[] bools = (boolean[])value;
                     assert bools.length==2;
                     JsonArrayBuilder arr = Json.createArrayBuilder();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemKey.java
Patch:
@@ -54,7 +54,7 @@ private SystemKey(String name, Class<?> dataType, int id) {
     }
 
     private SystemKey(String name, Class<?> dataType, int id, boolean index, boolean[] uniqueness, boolean modifiable) {
-        super(name, id, RelationType.PROPERTY, uniqueness, new boolean[]{!modifiable, uniqueness[1] && index}, modifiable);
+        super(name, id, RelationType.PROPERTY, uniqueness, modifiable);
         this.dataType = dataType;
         this.index = index;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/WriteByteBuffer.java
Patch:
@@ -31,7 +31,7 @@ public WriteByteBuffer(int capacity) {
     private void require(int size) {
         if (buffer.capacity()-buffer.position()<size) {
             //Need to resize
-            int newcapacity = buffer.capacity()*2;
+            int newcapacity = buffer.position() + size + buffer.capacity(); //extra capacity as buffer
             Preconditions.checkArgument(newcapacity<=MAX_BUFFER_CAPACITY,"Capacity exceeds max buffer capacity: %s",MAX_BUFFER_CAPACITY);
             ByteBuffer newBuffer = ByteBuffer.allocate(newcapacity);
             buffer.flip();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/AttributeHandling.java
Patch:
@@ -24,6 +24,6 @@ public interface AttributeHandling {
      */
     public<V> V convert(Class<V> datatype, Object value);
 
-    public boolean isSupportedSortKeyDatatype(Class<?> datatype);
+    public boolean isOrderPreservingDatatype(Class<?> datatype);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/AttributeUtil.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
-import com.thinkaurelius.titan.core.attribute.FullDouble;
-import com.thinkaurelius.titan.core.attribute.FullFloat;
+import com.thinkaurelius.titan.core.attribute.Decimal;
+import com.thinkaurelius.titan.core.attribute.Precision;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -29,7 +29,7 @@ public static final boolean isWholeNumber(Class<?> clazz) {
 
     public static final boolean isDecimal(Class<?> clazz) {
         return clazz.equals(Double.class) || clazz.equals(Float.class) ||
-                clazz.equals(FullDouble.class) || clazz.equals(FullFloat.class);
+                clazz.equals(Decimal.class) || clazz.equals(Precision.class);
     }
 
     public static final boolean isString(Object o) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/StandardSerializer.java
Patch:
@@ -5,7 +5,6 @@
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoSerializer;
-import com.thinkaurelius.titan.graphdb.query.condition.PredicateCondition;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
@@ -29,7 +28,7 @@ private KryoSerializer getBackupSerializer() {
     }
 
     private boolean supportsNullSerialization(Class type) {
-        return getSerializer(type) instanceof SupportsNullSerialization;
+        return getSerializer(type) instanceof SupportsNullSerializer;
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ArraySerializer.java
Patch:
@@ -4,14 +4,14 @@
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.graphdb.database.idhandling.VariableLong;
-import com.thinkaurelius.titan.graphdb.database.serialize.SupportsNullSerialization;
+import com.thinkaurelius.titan.graphdb.database.serialize.SupportsNullSerializer;
 
 import java.lang.reflect.Array;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-public abstract class ArraySerializer implements SupportsNullSerialization {
+public abstract class ArraySerializer implements SupportsNullSerializer {
 
     protected abstract Object getArray(int length);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/BooleanSerializer.java
Patch:
@@ -3,8 +3,9 @@
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
+import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
-public class BooleanSerializer implements AttributeSerializer<Boolean> {
+public class BooleanSerializer implements AttributeSerializer<Boolean>, OrderPreservingSerializer {
 
     @Override
     public Boolean read(ScanBuffer buffer) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ByteSerializer.java
Patch:
@@ -3,8 +3,9 @@
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
+import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
-public class ByteSerializer implements AttributeSerializer<Byte> {
+public class ByteSerializer implements AttributeSerializer<Byte>, OrderPreservingSerializer {
 
     private static final long serialVersionUID = 117423419883604186L;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/CharacterSerializer.java
Patch:
@@ -3,8 +3,9 @@
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
+import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
-public class CharacterSerializer implements AttributeSerializer<Character> {
+public class CharacterSerializer implements AttributeSerializer<Character>, OrderPreservingSerializer {
 
     private final ShortSerializer ss = new ShortSerializer();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/IntegerSerializer.java
Patch:
@@ -3,8 +3,9 @@
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
+import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
-public class IntegerSerializer implements AttributeSerializer<Integer> {
+public class IntegerSerializer implements AttributeSerializer<Integer>, OrderPreservingSerializer {
 
     private static final long serialVersionUID = 1174998819862504186L;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/LongSerializer.java
Patch:
@@ -3,8 +3,9 @@
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
+import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
-public class LongSerializer implements AttributeSerializer<Long> {
+public class LongSerializer implements AttributeSerializer<Long>, OrderPreservingSerializer {
 
     private static final long serialVersionUID = -8438674418838450877L;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/ShortSerializer.java
Patch:
@@ -3,8 +3,9 @@
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
+import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
-public class ShortSerializer implements AttributeSerializer<Short> {
+public class ShortSerializer implements AttributeSerializer<Short>, OrderPreservingSerializer {
 
     private static final long serialVersionUID = 117423419862504186L;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/StringSerializer.java
Patch:
@@ -4,12 +4,13 @@
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
+import com.thinkaurelius.titan.graphdb.database.serialize.OrderPreservingSerializer;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class StringSerializer implements AttributeSerializer<String> {
+public class StringSerializer implements AttributeSerializer<String>, OrderPreservingSerializer {
 
     private final CharacterSerializer cs = new CharacterSerializer();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/compression/Smaz.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.graphdb.database.serialize.attribute;
+package com.thinkaurelius.titan.graphdb.database.serialize.compression;
 
 /*
    Copyright 2011 icedrake

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/kryo/KryoSerializer.java
Patch:
@@ -41,7 +41,7 @@ public class KryoSerializer {
                     IndexParameters.class, IndexParameters[].class, Order.class
             );
 
-    public static final int KRYO_ID_OFFSET = 10;
+    public static final int KRYO_ID_OFFSET = 50;
 
     private final boolean registerRequired;
     private final ThreadLocal<Kryo> kryos;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -661,14 +661,14 @@ public TitanLabel getEdgeLabel(String name) {
 
     @Override
     public KeyMaker makeKey(String name) {
-        StandardKeyMaker maker = new StandardKeyMaker(this, indexSerializer);
+        StandardKeyMaker maker = new StandardKeyMaker(this, indexSerializer, attributeHandler);
         maker.name(name);
         return maker;
     }
 
     @Override
     public LabelMaker makeLabel(String name) {
-        StandardLabelMaker maker = new StandardLabelMaker(this, indexSerializer);
+        StandardLabelMaker maker = new StandardLabelMaker(this, indexSerializer, attributeHandler);
         maker.name(name);
         return maker;
     }

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -223,10 +223,10 @@ public void register(String store, String key, KeyInformation information, Trans
                 mapping.field("type", "string");
                 if (map==Mapping.STRING)
                     mapping.field("index","not_analyzed");
-            } else if (dataType == Float.class || dataType == FullFloat.class) {
+            } else if (dataType == Float.class) {
                 log.debug("Registering float type for {}", key);
                 mapping.field("type", "float");
-            } else if (dataType == Double.class || dataType == FullDouble.class) {
+            } else if (dataType == Double.class || dataType == Decimal.class || dataType == Precision.class) {
                 log.debug("Registering double type for {}", key);
                 mapping.field("type", "double");
             } else if (dataType == Byte.class) {

File: titan-test/src/main/java/com/thinkaurelius/titan/TestBed.java
Patch:
@@ -8,6 +8,7 @@
 import com.google.common.cache.CacheBuilder;
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.core.TitanGraph;
+import com.thinkaurelius.titan.graphdb.database.serialize.attribute.FloatSerializer;
 import com.tinkerpop.blueprints.TransactionalGraph;
 import com.tinkerpop.blueprints.Vertex;
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTestCommon.java
Patch:
@@ -2,6 +2,7 @@
 
 
 import com.thinkaurelius.titan.core.*;
+import com.thinkaurelius.titan.core.attribute.Decimal;
 import com.thinkaurelius.titan.diskstorage.configuration.WriteConfiguration;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
@@ -70,7 +71,7 @@ public TitanKey makeIntegerUIDPropertyKey(String name) {
 
     public TitanKey makeWeightPropertyKey(String name) {
         return tx.makeKey(name).single().
-                dataType(Double.class).
+                dataType(Decimal.class).
                 make();
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/EdgeSerializer.java
Patch:
@@ -247,7 +247,7 @@ public Entry writeRelation(InternalRelation relation, int position, boolean writ
         Direction dir = EdgeDirection.fromPosition(position);
         int dirID = getDirID(dir, relation.isProperty() ? RelationType.PROPERTY : RelationType.EDGE);
 
-        DataOutput out = serializer.getDataOutput(DEFAULT_CAPACITY, true);
+        DataOutput out = serializer.getDataOutput(DEFAULT_CAPACITY);
         int valuePosition;
         IDHandler.writeEdgeType(out, typeid, dirID);
 
@@ -374,8 +374,8 @@ public SliceQuery getQuery(InternalType type, Direction dir, TypedInterval[] sor
             isStatic = type.isStatic(dir);
             int dirID = getDirID(dir, rt);
 
-            DataOutput colStart = serializer.getDataOutput(DEFAULT_COLUMN_CAPACITY, true);
-            DataOutput colEnd = serializer.getDataOutput(DEFAULT_COLUMN_CAPACITY, true);
+            DataOutput colStart = serializer.getDataOutput(DEFAULT_COLUMN_CAPACITY);
+            DataOutput colEnd = serializer.getDataOutput(DEFAULT_COLUMN_CAPACITY);
             IDHandler.writeEdgeType(colStart, type.getID(), dirID);
             IDHandler.writeEdgeType(colEnd, type.getID(), dirID);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -461,7 +461,7 @@ private static final ElementType getElementType(String store) {
     }
 
     private final StaticBuffer getIndexKey(Object att) {
-        DataOutput out = serializer.getDataOutput(DEFAULT_VALUE_CAPACITY, true);
+        DataOutput out = serializer.getDataOutput(DEFAULT_VALUE_CAPACITY);
         out.writeObjectNotNull(att);
         return out.getStaticBuffer();
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/VariableLong.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database.idhandling;
 
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
+import com.thinkaurelius.titan.diskstorage.ScanBuffer;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
@@ -20,7 +21,7 @@ public static int unsignedByte(byte b) {
     private static final byte BIT_MASK = 127;
     private static final byte STOP_MASK = -128;
 
-    private static long readUnsigned(ReadBuffer in) {
+    private static long readUnsigned(ScanBuffer in) {
         long value = 0;
         byte b;
         do {
@@ -69,7 +70,7 @@ public static int unsignedBitLength(final long value) {
        ################################## */
 
 
-    public static long readPositive(ReadBuffer in) {
+    public static long readPositive(ScanBuffer in) {
         long value = readUnsigned(in);
         assert value >= 0;
         return value;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/AttributeHandling.java
Patch:
@@ -24,4 +24,6 @@ public interface AttributeHandling {
      */
     public<V> V convert(Class<V> datatype, Object value);
 
+    public boolean isSupportedSortKeyDatatype(Class<?> datatype);
+
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/DataOutput.java
Patch:
@@ -16,6 +16,9 @@ public interface DataOutput extends WriteBuffer {
     @Override
     public DataOutput putByte(byte val);
 
+    @Override
+    public DataOutput putBytes(byte[] val);
+
     @Override
     public DataOutput putChar(char val);
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyValueStoreUtil.java
Patch:
@@ -4,6 +4,7 @@
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
+import com.thinkaurelius.titan.graphdb.database.serialize.StandardSerializer;
 import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoSerializer;
 import com.thinkaurelius.titan.testutil.RandomGenerator;
 import org.junit.Assert;
@@ -15,7 +16,7 @@
 public class KeyValueStoreUtil {
 
     private static final Logger log = LoggerFactory.getLogger(KeyValueStoreUtil.class);
-    public static final Serializer serial = new KryoSerializer(true);
+    public static final Serializer serial = new StandardSerializer();
     public static final long idOffset = 1000;
 
     public static final StaticBuffer MIN_KEY = ByteBufferUtil.getLongBuffer(0);
@@ -58,7 +59,7 @@ public static int getID(StaticBuffer b) {
     }
 
     public static StaticBuffer getBuffer(String s) {
-        DataOutput out = serial.getDataOutput(50, true);
+        DataOutput out = serial.getDataOutput(50);
         out.writeObjectNotNull(s);
         return out.getStaticBuffer();
     }

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/SerializerTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.util.Calendar;
 
-import static com.thinkaurelius.titan.graphdb.database.serialize.SerializerInitialization.RESERVED_ID_OFFSET;
+import static com.thinkaurelius.titan.graphdb.database.serialize.kryo.SerializerInitialization.RESERVED_ID_OFFSET;
 import static org.junit.Assert.*;
 
 public class SerializerTest {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/StaticArrayBuffer.java
Patch:
@@ -217,7 +217,7 @@ public String toString() {
     public final String toString(String separator) {
         StringBuilder s = new StringBuilder();
         for (int i=offset;i<limit;i++) {
-            if (i>0) s.append(separator);
+            if (i>offset) s.append(separator);
             s.append(ByteBufferUtil.toFixedWidthString(array[i]));
         }
         return s.toString();
@@ -240,7 +240,7 @@ protected int compareTo(int length, StaticBuffer buffer, int bufferLen) {
 
     protected int compareTo(int length, StaticArrayBuffer buffer, int bufferLen) {
         assert buffer!=null;
-        Preconditions.checkArgument(length<length() && bufferLen<=buffer.length());
+        Preconditions.checkArgument(length<=length() && bufferLen<=buffer.length());
         return compareTo(array, offset, offset+length, buffer.array, buffer.offset, buffer.offset+bufferLen);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/kryo/KryoSerializer.java
Patch:
@@ -34,6 +34,7 @@ public class KryoSerializer extends DefaultAttributeHandling implements Serializ
         @Override
         public Input get(byte[] array, int offset, int limit) {
             //Needs to copy array - otherwise we see BufferUnderflow exceptions from concurrent access
+            //See https://github.com/EsotericSoftware/kryo#threading
             return new Input(Arrays.copyOfRange(array,offset,limit));
         }
     };

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/SimpleVertexQueryProcessor.java
Patch:
@@ -150,6 +150,7 @@ public Iterable<Edge> edges() {
         return (Iterable) relations();
     }
 
+    //TODO: use reuseIterator() when querying for vertices and only read ids
     public Iterable<Vertex> vertices() {
         return Iterables.transform(this,new Function<Entry, Vertex>() {
             @Nullable
@@ -180,7 +181,7 @@ private Iterator<Entry> getBasicIterator() {
             public EntryList get(SliceQuery query) {
                 return tx.getGraph().edgeQuery(vertex.getID(), query, tx.getTxHandle());
             }
-        }).reuseIterator();
+        }).iterator();
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -290,10 +290,8 @@ public final static KeyColumnValueStoreManager getStorageManager(Configuration s
                 REGISTERED_STORAGE_MANAGERS);
         if (manager instanceof OrderedKeyValueStoreManager) {
             manager = new OrderedKeyValueStoreManagerAdapter((OrderedKeyValueStoreManager) manager, STATIC_KEY_LENGTHS);
-        } else if (manager instanceof CacheStoreManager) {
-            manager = new CacheStoreManagerAdapter((CacheStoreManager) manager);
         }
-        Preconditions.checkArgument(manager instanceof KeyColumnValueStoreManager);
+        Preconditions.checkArgument(manager instanceof KeyColumnValueStoreManager,"Invalid storage manager: %s",manager.getClass());
         return (KeyColumnValueStoreManager) manager;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/ReadBuffer.java
Patch:
@@ -16,6 +16,6 @@ public interface ReadBuffer extends ScanBuffer, StaticBuffer {
 
     public<T> T asRelative(Factory<T> factory);
 
-    public ReadBuffer invert();
+    public void invert();
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/NoOpStoreTransaction.java
Patch:
@@ -3,6 +3,8 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTxConfig;
 
 /**
+ * Dummy transaction object that does nothing
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/BufferTransaction.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.util.BackendOperation;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KCVMutation.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.Mutation;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KeyIterator.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/KVMutation.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue;
 
 import com.thinkaurelius.titan.diskstorage.Mutation;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 
 import java.util.List;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStore.java
Patch:
@@ -2,11 +2,10 @@
 
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
-import java.util.List;
-
 /**
  * A {@link KeyValueStore} where the keys are ordered such that keys can be retrieved in order.
  *
@@ -38,7 +37,6 @@ public interface OrderedKeyValueStore extends KeyValueStore {
      * @return
      * @throws StorageException
      */
-    //public List<KeyValueEntry> getSlice(StaticBuffer keyStart, StaticBuffer keyEnd, KeySelector selector, StoreTransaction txh) throws StorageException;
     public RecordIterator<KeyValueEntry> getSlice(StaticBuffer keyStart, StaticBuffer keyEnd, KeySelector selector, StoreTransaction txh) throws StorageException;
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/AbstractLocker.java
Patch:
@@ -10,11 +10,10 @@
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ConsistentKeyLocker;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ConsistentKeyLockerSerializer;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
-import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
+import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import com.thinkaurelius.titan.diskstorage.util.TimeUtility;
 import com.thinkaurelius.titan.diskstorage.util.TimestampProvider;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import org.apache.commons.configuration.BaseConfiguration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -101,7 +100,7 @@ public static abstract class Builder<S, B extends Builder<S, B>> {
         protected Logger log;
 
         public Builder() {
-            this.rid = new StaticByteBuffer(DistributedStoreManager.getRid(Configuration.EMPTY));
+            this.rid = new StaticArrayBuffer(DistributedStoreManager.getRid(Configuration.EMPTY));
             this.times = TimeUtility.INSTANCE;
             this.serializer = new ConsistentKeyLockerSerializer();
             this.llm = null; // redundant, but it preserves this constructor's overall pattern

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockerSerializer.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.diskstorage.ReadBuffer;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.WriteBuffer;
-import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
+import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import com.thinkaurelius.titan.diskstorage.util.WriteBufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.WriteByteBuffer;
 
@@ -38,7 +38,7 @@ public TimestampRid fromLockColumn(StaticBuffer lockKey) {
         for (int i = 0; r.hasRemaining(); i++) {
             curRid[i] = r.getByte();
         }
-        StaticBuffer rid = new StaticByteBuffer(curRid);
+        StaticBuffer rid = new StaticArrayBuffer(curRid);
         return new TimestampRid(tsNS, rid);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/MetricInstrumentedIterator.java
Patch:
@@ -4,7 +4,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyIterator;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/WriteByteBuffer.java
Patch:
@@ -77,6 +77,6 @@ public StaticBuffer getStaticBufferFlipBytes(int from, int to) {
         Preconditions.checkArgument(from>=0 && from<=to);
         Preconditions.checkArgument(to<=b.limit());
         for (int i=from;i<to;i++) b.put(i,(byte)~b.get(i));
-        return new StaticByteBuffer(b);
+        return StaticArrayBuffer.of(b);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/RelationReader.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.database;
 
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.graphdb.relations.RelationCache;
 import com.thinkaurelius.titan.graphdb.types.TypeInspector;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/kryo/KryoDataOutput.java
Patch:
@@ -5,11 +5,8 @@
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
-import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
 
-import java.nio.ByteBuffer;
-
 public class KryoDataOutput implements DataOutput {
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalVertex.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Predicate;
 import com.thinkaurelius.titan.core.TitanVertex;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.query.VertexCentricQueryBuilder;
 import com.thinkaurelius.titan.util.datastructures.Retriever;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/SimpleVertexQueryProcessor.java
Patch:
@@ -7,7 +7,7 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.*;
 import com.thinkaurelius.titan.core.*;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.database.EdgeSerializer;
 import com.thinkaurelius.titan.graphdb.database.RelationQueryCache;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheEdge.java
Patch:
@@ -5,7 +5,7 @@
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.TitanLabel;
 import com.thinkaurelius.titan.core.TitanType;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheProperty.java
Patch:
@@ -5,7 +5,7 @@
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.TitanKey;
 import com.thinkaurelius.titan.core.TitanType;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/RelationConstructor.java
Patch:
@@ -3,14 +3,13 @@
 import com.thinkaurelius.titan.core.TitanKey;
 import com.thinkaurelius.titan.core.TitanLabel;
 import com.thinkaurelius.titan.core.TitanType;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.graphdb.database.EdgeSerializer;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
 import com.thinkaurelius.titan.graphdb.internal.InternalVertex;
 import com.thinkaurelius.titan.graphdb.relations.CacheEdge;
 import com.thinkaurelius.titan.graphdb.relations.CacheProperty;
 import com.thinkaurelius.titan.graphdb.relations.RelationCache;
-import com.thinkaurelius.titan.graphdb.types.TypeInspector;
 import com.tinkerpop.blueprints.Direction;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -11,9 +11,10 @@
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.core.attribute.Cmp;
 import com.thinkaurelius.titan.diskstorage.BackendTransaction;
+import com.thinkaurelius.titan.diskstorage.EntryList;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexQuery;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.blueprints.TitanBlueprintsTransaction;
 import com.thinkaurelius.titan.graphdb.database.EdgeSerializer;
@@ -692,7 +693,7 @@ public void executeMultiQuery(final Collection<InternalVertex> vertices, final S
         }
 
         if (!vids.isEmpty()) {
-            List<List<Entry>> results = graph.edgeMultiQuery(vids, sq, txHandle);
+            List<EntryList> results = graph.edgeMultiQuery(vids, sq, txHandle);
             int pos = 0;
             for (TitanVertex v : vertices) {
                 if (vids.get(pos) == v.getID()) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyVertex.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.primitives.Longs;
 import com.thinkaurelius.titan.core.*;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/CacheVertex.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.vertices;
 
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.util.datastructures.Retriever;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/StandardVertex.java
Patch:
@@ -2,8 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
-import com.google.common.collect.ImmutableList;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStorePerformance.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.titan.diskstorage;
 
 import com.carrotsearch.junitbenchmarks.BenchmarkRule;
-import com.carrotsearch.randomizedtesting.RandomizedTest;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
+import com.thinkaurelius.titan.diskstorage.util.StaticArrayEntry;
 import com.thinkaurelius.titan.testcategory.PerformanceTests;
 
 import org.junit.After;
@@ -77,7 +77,7 @@ public void addRecords() throws StorageException {
             int numCols = 10;
             List<Entry> entries = new ArrayList<Entry>();
             for (int c = 0; c < numCols; c++) {
-                entries.add(new StaticBufferEntry(KeyValueStoreUtil.getBuffer(c + 1), KeyValueStoreUtil.getBuffer(c + r + 2)));
+                entries.add(StaticArrayEntry.of(KeyValueStoreUtil.getBuffer(c + 1), KeyValueStoreUtil.getBuffer(c + r + 2)));
             }
             store.mutate(KeyValueStoreUtil.getBuffer(r + 1), entries, KeyColumnValueStore.NO_DELETIONS, tx);
         }

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediatorTest.java
Patch:
@@ -3,8 +3,8 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
-import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
 
+import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import org.junit.Test;
 
 import java.nio.ByteBuffer;
@@ -17,8 +17,8 @@
 public class LocalLockMediatorTest {
 
     private static final String LOCK_NAMESPACE = "test";
-    private static final StaticBuffer LOCK_ROW = new StaticByteBuffer(ByteBuffer.wrap(new byte[]{1}));
-    private static final StaticBuffer LOCK_COL = new StaticByteBuffer(ByteBuffer.wrap(new byte[]{1}));
+    private static final StaticBuffer LOCK_ROW = StaticArrayBuffer.of(new byte[]{1});
+    private static final StaticBuffer LOCK_COL = StaticArrayBuffer.of(new byte[]{1});
     private static final KeyColumn kc = new KeyColumn(LOCK_ROW, LOCK_COL);
     //	private static final long LOCK_EXPIRATION_TIME_MS = 1;
 //	private static final long SLEEP_MS = LOCK_EXPIRATION_TIME_MS * 1000;

File: titan-test/src/test/java/com/thinkaurelius/titan/testutil/ObjectSizer.java
Patch:
@@ -4,10 +4,7 @@
 import cern.colt.map.OpenIntIntHashMap;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.Weigher;
 import com.google.common.collect.HashMultimap;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeySliceQuery;
 
 import java.util.*;
 import java.util.concurrent.*;

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseKeyColumnValueStore.java
Patch:
@@ -192,7 +192,7 @@ public void mutate(StaticBuffer key, List<Entry> additions, List<StaticBuffer> d
     }
 
     public void mutateMany(Map<StaticBuffer, KCVMutation> mutations, StoreTransaction txh) throws StorageException {
-        storeManager.mutateMany(ImmutableMap.of(columnFamily, mutations), txh);
+        storeManager.mutateMany(ImmutableMap.of(storeName, mutations), txh);
     }
 
     @Override

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -64,7 +64,7 @@ public class HBaseStoreManager extends DistributedStoreManager implements KeyCol
 
     public static final ConfigOption<Boolean> SHORT_CF_NAMES = new ConfigOption<Boolean>(STORAGE_NS,"short-cf-names",
             "Whether to automatically shorten the names of frequently used column families to preserve space",
-            ConfigOption.Type.FIXED, false);
+            ConfigOption.Type.FIXED, true);
 
 //    public static final String SHORT_CF_NAMES_KEY = "short-cf-names";
 //    public static final boolean SHORT_CF_NAMES_DEFAULT = false;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/attribute/FloatSerializer.java
Patch:
@@ -16,7 +16,7 @@ public class FloatSerializer implements AttributeSerializer<Float> {
 
 
     public static final int DECIMALS = 3;
-    private static int MULTIPLIER = 0;
+    private static long MULTIPLIER = 0;
 
     static {
         MULTIPLIER = 1;
@@ -43,7 +43,7 @@ public void writeObjectData(WriteBuffer out, Float object) {
     }
 
     public static final long convert(Float object) {
-        return (long) (object.floatValue() * MULTIPLIER);
+        return Math.round(object.doubleValue() * MULTIPLIER);
     }
 
     public static final float convert(long value) {
@@ -62,7 +62,7 @@ public static final boolean withinRange(Float object) {
     public void verifyAttribute(Float value) {
         Preconditions.checkArgument(!Float.isNaN(value),"Value may not be NaN");
         Preconditions.checkArgument(withinRange(value),"Value out of range [%s,%s]: %s. Use FullFloat instead.",MIN_VALUE,MAX_VALUE,value);
-        if (convert(convert(value))!=value) log.warn("Truncated decimals of float value: {}. Use FullFloat for full precision.",value);
+        if (Math.abs(convert(convert(value))-value)>DoubleSerializer.EPSILON) log.warn("Truncated decimals of float value: {}. Use FullFloat for full precision.",value);
     }
 
     @Override

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -5,7 +5,6 @@
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.core.TitanVertex;
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
-import com.thinkaurelius.titan.diskstorage.inmemory.InMemoryStorageAdapter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -197,7 +197,7 @@ public StoreFeatures getFeatures() {
         if (features == null) {
             features = new StoreFeatures();
             features.supportsBatchMutation = true;
-            features.supportsTransactions = false;
+            features.supportsTxIsolation = false;
             features.supportsConsistentKeyOperations = true;
             features.supportsLocking = false;
             features.isDistributed = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -37,7 +37,7 @@ public InMemoryStoreManager(final Configuration configuration) {
         features.supportsOrderedScan = true;
         features.supportsUnorderedScan = true;
         features.supportsBatchMutation = false;
-        features.supportsTransactions = false;
+        features.supportsTxIsolation = false;
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;
         features.isDistributed = false;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/VertexCentricQueryBuilder.java
Patch:
@@ -34,6 +34,7 @@ public class VertexCentricQueryBuilder extends AbstractVertexCentricQueryBuilder
     public VertexCentricQueryBuilder(InternalVertex v, EdgeSerializer serializer) {
         super(v.tx(), serializer);
         Preconditions.checkNotNull(v);
+        Preconditions.checkArgument(!v.isRemoved(),"Cannot access a removed vertex: %s",v);
         this.vertex = v;
     }
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -160,7 +160,7 @@ public StoreFeatures getFeatures() {
         features.supportsOrderedScan = true;
         features.supportsUnorderedScan = true;
         features.supportsBatchMutation = true;
-        features.supportsTransactions = false;
+        features.supportsTxIsolation = false;
         features.supportsMultiQuery = true;
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;

File: titan-persistit/src/main/java/com/thinkaurelius/titan/diskstorage/persistit/PersistitStoreManager.java
Patch:
@@ -170,14 +170,14 @@ public String getName() {
     private StoreFeatures getDefaultFeatures() {
         StoreFeatures features = new StoreFeatures();
 
-        features.supportsTransactions = true;
+        features.supportsTxIsolation = true;
         features.isDistributed = false;
 
         //@todo: figure out what these do, Copied from Berkeley for now
         features.supportsOrderedScan = true;
         features.supportsUnorderedScan = false;
         features.supportsBatchMutation = false;
-        features.supportsConsistentKeyOperations = false;
+        features.supportsConsistentKeyOperations = true;
         features.supportsLocking = true;
         features.isKeyOrdered = true;
         features.hasLocalKeyPartition = false;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -98,7 +98,7 @@ public void open() throws StorageException {
             sc.set(GraphDatabaseConfiguration.LOCK_EXPIRE, EXPIRE_MS);
 
             if (!storeFeatures.supportsLocking()) {
-                if (storeFeatures.supportsTransactions()) {
+                if (storeFeatures.supportsTxIsolation()) {
                     store[i] = new TransactionalLockStore(store[i]);
                 } else if (storeFeatures.supportsConsistentKeyOperations()) {
 

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/util/StorageFeaturesTest.java
Patch:
@@ -32,7 +32,7 @@ public void testFeaturesImplementation() {
         features.supportsOrderedScan = false;
         features.supportsUnorderedScan = false;
         features.supportsBatchMutation = true;
-        features.supportsTransactions = false;
+        features.supportsTxIsolation = false;
         features.supportsMultiQuery = false;
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;
@@ -41,7 +41,7 @@ public void testFeaturesImplementation() {
         features.hasLocalKeyPartition = false;
         assertNotNull(features);
         assertFalse(features.supportsScan());
-        assertFalse(features.supportsTransactions());
+        assertFalse(features.supportsTxIsolation());
         assertTrue(features.isDistributed());
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.configuration.ModifiableConfiguration;
 import com.thinkaurelius.titan.diskstorage.inmemory.InMemoryStorageAdapter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.inmemory.InMemoryStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.VertexIDAssigner;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
@@ -63,8 +64,9 @@ public VertexIDAssignerTest(boolean partition, int partitionMax, int[] localPart
 
     private static TitanGraph getInMemoryGraph() {
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
-        config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, InMemoryStorageAdapter.class.getCanonicalName());
+        config.set(GraphDatabaseConfiguration.STORAGE_BACKEND, InMemoryStoreManager.class.getCanonicalName());
         config.set(GraphDatabaseConfiguration.IDS_FLUSH, false);
+        config.set(GraphDatabaseConfiguration.IDAUTHORITY_WAIT_MS,1);
         return TitanFactory.open(config);
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/types/TypeReferenceContainerTest.java
Patch:
@@ -3,7 +3,6 @@
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.core.*;
-import com.thinkaurelius.titan.diskstorage.inmemory.InMemoryStorageAdapter;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -930,10 +930,10 @@ public static boolean isMetricsMergingEnabled(Configuration storageConf, Configu
     private void configureMetricsConsoleReporter(Configuration conf) {
         Long ms = conf.getLong(METRICS_CONSOLE_INTERVAL_KEY, METRICS_CONSOLE_INTERVAL_DEFAULT);
         if (null != ms) {
-            System.err.println("Console metrics on");
+            log.debug("Console metrics on");
             MetricManager.INSTANCE.addConsoleReporter(ms);
         } else {
-            System.err.println("Console metrics off");
+            log.debug("Console metrics off");
         }
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/cache/ExpirationStoreCache.java
Patch:
@@ -11,6 +11,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeySliceQuery;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
+import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.util.stats.MetricManager;
 
 import static com.thinkaurelius.titan.util.datastructures.ByteSize.*;
@@ -39,7 +40,8 @@ public class ExpirationStoreCache implements StoreCache {
     private static final int INVALIDATE_KEY_FRACTION_PENALTY = 1000;
     private static final int PENALTY_THRESHOLD = 5;
 
-    private static final String METRICS_PREFIX = ExpirationStoreCache.class.getSimpleName();
+    private static final String METRICS_PREFIX = GraphDatabaseConfiguration.METRICS_SYSTEM_PREFIX_DEFAULT
+            + "." + ExpirationStoreCache.class.getSimpleName();
     private static final Counter GLOBAL_CACHE_MISSES = MetricManager.INSTANCE.getCounter(METRICS_PREFIX, "misses");
     private static final Counter GLOBAL_CACHE_RETRIEVALS = MetricManager.INSTANCE.getCounter(METRICS_PREFIX, "retrievals");
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StandardIDPool.java
Patch:
@@ -91,7 +91,7 @@ private synchronized void nextBlock() throws InterruptedException {
         nextID = bufferNextID;
         currentMaxID = bufferMaxID;
 
-        log.debug("[{}] Next/Max ID: {}", partitionID, new long[]{nextID, currentMaxID});
+        log.debug("[ID Partition {}] Acquired range: [{},{}]", new Object[]{ partitionID, nextID, currentMaxID });
 
         assert nextID > 0 && currentMaxID > nextID;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -283,7 +283,7 @@ public List<StaticBuffer> call() throws Exception {
                             Direction dir = EdgeDirection.fromPosition(pos);
                             if (acquireLocks && relation.getType().isUnique(dir) && !vertex.isNew()
                                     && ((InternalType) relation.getType()).uniqueLock(dir)) {
-                                Entry entry = edgeSerializer.writeRelation(relation, pos, false, tx);
+                                Entry entry = edgeSerializer.writeRelation(relation, pos, tx);
                                 mutator.acquireEdgeLock(IDHandler.getKey(vertex.getID()), entry.getColumn(), null);
                             }
                         }
@@ -339,7 +339,7 @@ private <V extends InternalVertex> List<StaticBuffer> persist(ListMultimap<V, In
                 for (int pos = 0; pos < edge.getLen(); pos++) {
                     if (edge.getVertex(pos).equals(vertex)) {
                         if (edge.isRemoved()) {
-                            deletions.add(edgeSerializer.writeRelation(edge, pos, false, tx).getColumn());
+                            deletions.add(edgeSerializer.writeRelation(edge, pos, tx).getColumn());
                         } else {
                             Preconditions.checkArgument(edge.isNew());
                             additions.add(edgeSerializer.writeRelation(edge, pos, tx));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -696,16 +696,16 @@ public void executeMultiQuery(final Collection<InternalVertex> vertices, final S
             List<List<Entry>> results = graph.edgeMultiQuery(vids, sq, txHandle);
             int pos = 0;
             for (TitanVertex v : vertices) {
-                if (vids.get(pos) == v.getID()) {
+                if (pos<vids.size() && vids.get(pos) == v.getID()) {
                     final List<Entry> vresults = results.get(pos);
                     ((CacheVertex) v).loadRelations(sq, new Retriever<SliceQuery, List<Entry>>() {
                         @Override
                         public List<Entry> get(SliceQuery query) {
                             return vresults;
                         }
                     });
+                    pos++;
                 }
-                pos++;
             }
         }
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -99,6 +99,8 @@ public void testTypes() {
         assertTrue(spouse.isUnique(IN));
         assertTrue(spouse.isUnique(OUT));
 
+        assertEquals("weight",weight.toString());
+
 
         try {
             tx.makeKey("pint").dataType(int.class).make();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -157,7 +157,8 @@ public static <E extends TitanElement> And<E> constraints2QNF(StandardTitanTx tx
             assert predicate.isValidCondition(value);
 
             if (type.isPropertyKey()) {
-                Preconditions.checkArgument(predicate.isValidValueType(((TitanKey) type).getDataType()), "Data type of key is not compatible with condition");
+                TitanKey key = (TitanKey) type;
+                Preconditions.checkArgument(key.getDataType()==Object.class || predicate.isValidValueType(key.getDataType()), "Data type of key is not compatible with condition");
             } else { //its a label
                 Preconditions.checkArgument(((TitanLabel) type).isUnidirected());
                 Preconditions.checkArgument(predicate.isValidValueType(TitanVertex.class), "Data type of key is not compatible with condition");

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -570,13 +570,13 @@ private final TitanType makeTitanType(TitanTypeClass typeClass, String name, Typ
             type = new TitanLabelVertex(this, temporaryID.decrementAndGet(), ElementLifeCycle.New);
         }
         graph.assignID(type);
-        addProperty(type, SystemKey.VertexState, SystemKey.VertexStates.DEFAULT.getValue());
+        Preconditions.checkArgument(type.getID() > 0);
         addProperty(type, SystemKey.TypeName, name);
+        addProperty(type, SystemKey.VertexState, SystemKey.VertexStates.DEFAULT.getValue());
         addProperty(type, SystemKey.TypeClass, typeClass);
         for (TypeAttribute attribute : definition.getAttributes()) {
             addProperty(type, SystemKey.TypeDefinition, attribute);
         }
-        Preconditions.checkArgument(type.getID() > 0);
         vertexCache.add(type, type.getID());
         typeCache.put(name, type.getID());
         return type;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/util/TestLockerManager.java
Patch:
@@ -32,7 +32,8 @@ private TestLocker(String name, boolean errorOnLock) {
 
         @Override
         public void writeLock(KeyColumn lockID, StoreTransaction tx) throws TemporaryLockingException, PermanentLockingException {
-            if (errorOnLock) throw new UnsupportedOperationException();
+            if (errorOnLock)
+                throw new UnsupportedOperationException();
         }
 
         @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -1306,10 +1306,10 @@ public VertexIDAssigner getIDAssigner(Backend backend) {
 
     public String getBackendDescription() {
         String clazzname = configuration.get(STORAGE_BACKEND);
-        if (configuration.has(STORAGE_HOSTS)) {
-            return clazzname + ":" + Arrays.toString(configuration.get(STORAGE_HOSTS));
-        } else {
+        if (clazzname.equalsIgnoreCase("berkeleyje") || clazzname.equalsIgnoreCase("persistit")) {
             return clazzname + ":" + configuration.get(STORAGE_DIRECTORY);
+        } else {
+            return clazzname + ":" + Arrays.toString(configuration.get(STORAGE_HOSTS));
         }
     }
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -118,9 +118,8 @@ public HBaseStoreManager(com.thinkaurelius.titan.diskstorage.configuration.Confi
         }
 
         // Copy a subset of our commons config into a Hadoop config
-        Preconditions.checkArgument(config instanceof MixedConfiguration);
         int keysLoaded=0;
-        Map<String,Object> configSub = ((MixedConfiguration)config).getSubset(HBASE_CONFIGURATION_NAMESPACE);
+        Map<String,Object> configSub = config.getSubset(HBASE_CONFIGURATION_NAMESPACE);
         for (Map.Entry<String,Object> entry : configSub.entrySet()) {
             logger.debug("HBase configuration: setting {}={}", entry.getKey(), entry.getValue());
             if (entry.getValue()==null) continue;

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneIndexTest.java
Patch:
@@ -32,9 +32,10 @@ public boolean supportsLuceneStyleQueries() {
     }
 
     public static final Configuration getLocalLuceneTestConfig() {
+        final String index = "lucene";
         ModifiableConfiguration config = GraphDatabaseConfiguration.buildConfiguration();
-        config.set(GraphDatabaseConfiguration.INDEX_DIRECTORY, StorageSetup.getHomeDir("lucene"));
-        return config;
+        config.set(GraphDatabaseConfiguration.INDEX_DIRECTORY, StorageSetup.getHomeDir("lucene"),index);
+        return config.restrictTo(index);
     }
 
     @Test

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanNonTransactionalGraphMetricsTest.java
Patch:
@@ -49,7 +49,7 @@ public abstract class TitanNonTransactionalGraphMetricsTest extends TitanGraphBa
 
     @Override
     public WriteConfiguration getConfiguration() {
-        WriteConfiguration config = getConfiguration();
+        WriteConfiguration config = getBaseConfiguration();
         ModifiableConfiguration mconf = new ModifiableConfiguration(GraphDatabaseConfiguration.TITAN_NS,config, BasicConfiguration.Restriction.NONE);
         mconf.set(GraphDatabaseConfiguration.BASIC_METRICS,true);
         mconf.set(GraphDatabaseConfiguration.MERGE_BASIC_METRICS,false);

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/ElasticSearchBerkeleyDBTest.java
Patch:
@@ -26,7 +26,7 @@ public ElasticSearchBerkeleyDBTest() {
     public WriteConfiguration getConfiguration() {
         ModifiableConfiguration config = BerkeleyJeStorageSetup.getBerkeleyJEConfiguration();
         //Add index
-        config.set(INDEX_BACKEND,"com.thinkaurelius.titan.diskstorage.es.ElasticSearchIndex",INDEX);
+        config.set(INDEX_BACKEND,"elasticsearch",INDEX);
         config.set(LOCAL_MODE,true,INDEX);
         config.set(CLIENT_ONLY,false,INDEX);
         config.set(INDEX_DIRECTORY,StorageSetup.getHomeDir("es"),INDEX);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/UserModifiableConfiguration.java
Patch:
@@ -7,6 +7,7 @@
 
 /**
  * Helper class for inspecting and modifying a configuration for Titan.
+ * It is important to {@link #close()} the configuration when all changes have been made.
  *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
@@ -53,7 +54,7 @@ public String get(String path) {
             return s.toString();
         } else {
             Object value;
-            if (config.has((ConfigOption)pp.element,pp.umbrellaElements)) {
+            if (config.has((ConfigOption)pp.element,pp.umbrellaElements) || ((ConfigOption) pp.element).getDefaultValue()!=null) {
                 value = config.get((ConfigOption)pp.element,pp.umbrellaElements);
             } else {
                 return "null";

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreManagerAdapter.java
Patch:
@@ -62,7 +62,7 @@ public void clearStorage() throws StorageException {
     @Override
     public synchronized OrderedKeyValueStoreAdapter openDatabase(String name)
             throws StorageException {
-        if (!stores.containsKey(name)) {
+        if (!stores.containsKey(name) || stores.get(name).isClosed()) {
             OrderedKeyValueStoreAdapter store = wrapKeyValueStore(manager.openDatabase(name), keyLengths);
             stores.put(name, store);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -434,7 +434,9 @@ public void close() throws StorageException {
         edgeIndexStore.close();
         idAuthority.close();
         storeManager.close();
-        threadPool.shutdown();
+        if(threadPool != null) {
+        	threadPool.shutdown();
+        }
         //Indexes
         for (IndexProvider index : indexes.values()) index.close();
     }

File: src/test/java/com/thinkaurelius/faunus/mapreduce/util/CountMapReducePipelineTest.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public class CounterMapPipelineTest extends BaseTest {
+public class CountMapReducePipelineTest extends BaseTest {
 
     public void testWithPipeline() throws Exception {
         FaunusGraph g = createFaunusGraph(BaseTest.class.getResourceAsStream("graphson-noop.properties"));

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -31,6 +31,7 @@ public class CassandraStorageSetup {
     public static Configuration getGenericCassandraStorageConfiguration(String ks) {
         BaseConfiguration config = new BaseConfiguration();
         config.addProperty(KEYSPACE_KEY, cleanKeyspaceName(ks));
+        config.addProperty(GraphDatabaseConfiguration.CONNECTION_TIMEOUT_KEY, 60000L);
         return config;
         
     }
@@ -93,6 +94,7 @@ private static Configuration getGraphBaseConfiguration(String ks, String backend
         Configuration config = new BaseConfiguration();
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(KEYSPACE_KEY, cleanKeyspaceName(ks));
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.STORAGE_BACKEND_KEY, backend);
+        config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.CONNECTION_TIMEOUT_KEY, 60000L);
         return config;
     }
     

File: titan-hbase/src/test/java/com/thinkaurelius/titan/HBaseStorageSetup.java
Patch:
@@ -64,12 +64,14 @@ public void run() {
     public static Configuration getHBaseStorageConfiguration() {
         BaseConfiguration config = new BaseConfiguration();
         config.addProperty(GraphDatabaseConfiguration.STORAGE_BACKEND_KEY, "hbase");
+        config.addProperty(GraphDatabaseConfiguration.CONNECTION_TIMEOUT_KEY, 60000L);
         return config;
     }
 
     public static Configuration getHBaseGraphConfiguration() {
         BaseConfiguration config = new BaseConfiguration();
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.STORAGE_BACKEND_KEY, "hbase");
+        config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.CONNECTION_TIMEOUT_KEY, 60000L);
         return config;
     }
 

File: src/main/java/com/thinkaurelius/faunus/FaunusVertex.java
Patch:
@@ -24,6 +24,7 @@
 import java.io.IOException;
 import java.util.AbstractList;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
@@ -89,7 +90,7 @@ public FaunusProperty addProperty(final String key, final Object value) {
 
     public <T> Iterable<T> getProperties(final String key) {
         FaunusType type = FaunusType.DEFAULT_MANAGER.get(key);
-        if (type.isImplicit()) return getImplicitProperty(type);
+        if (type.isImplicit()) return Arrays.<T>asList((T)this.getImplicitProperty(type)); // TODO: is this okay?
         return Iterables.transform(Iterables.filter(properties.get(type), FILTER_DELETED_PROPERTIES), new Function<FaunusProperty, T>() {
             @Nullable
             @Override

File: src/main/java/com/thinkaurelius/faunus/FaunusEdge.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.faunus;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Vertex;
@@ -25,7 +26,7 @@ public class FaunusEdge extends FaunusPathElement implements Edge {
     private FaunusType label;
 
     public FaunusEdge() {
-        this(EMPTY_CONFIGURATION);
+        this(EmptyConfiguration.immutable());
     }
 
     public FaunusEdge(final Configuration configuration) {

File: src/main/java/com/thinkaurelius/faunus/FaunusElement.java
Patch:
@@ -24,8 +24,6 @@
  */
 public abstract class FaunusElement implements Element, Comparable<FaunusElement> {
 
-    public static final Configuration EMPTY_CONFIGURATION = new EmptyConfiguration();
-
     static final Multimap<FaunusType, FaunusProperty> NO_PROPERTIES = ImmutableListMultimap.of();
 
     protected static final Predicate<FaunusProperty> FILTER_DELETED_PROPERTIES = new Predicate<FaunusProperty>() {

File: src/main/java/com/thinkaurelius/faunus/FaunusPathElement.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.faunus;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import org.apache.hadoop.conf.Configurable;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.io.WritableComparable;
@@ -18,7 +19,7 @@ public abstract class FaunusPathElement extends FaunusElement implements Writabl
     protected MicroElement microVersion = null;
     protected boolean trackPaths = false;
     protected long pathCounter = 0;
-    protected Configuration configuration = FaunusElement.EMPTY_CONFIGURATION;
+    protected Configuration configuration = EmptyConfiguration.immutable();
 
     public FaunusPathElement(final long id) {
         super(id);

File: src/test/java/com/thinkaurelius/faunus/FaunusEdgeTest.java
Patch:
@@ -17,7 +17,7 @@ public class FaunusEdgeTest extends TestCase {
 
     public void testSimpleSerialization() throws IOException {
 
-        FaunusEdge edge1 = new FaunusEdge(FaunusElement.EMPTY_CONFIGURATION, 1, 2, "knows");
+        FaunusEdge edge1 = new FaunusEdge(EmptyConfiguration.immutable(), 1, 2, "knows");
         assertEquals(edge1.getLabel(), "knows");
         assertEquals(edge1.getVertex(Direction.OUT).getId(), 1l);
         assertEquals(edge1.getVertex(Direction.IN).getId(), 2l);
@@ -30,7 +30,7 @@ public void testSimpleSerialization() throws IOException {
         // 1 + 1 + 1 + 1 + 10 byte label = 13
 
 
-        FaunusEdge edge2 = new FaunusEdge(new EmptyConfiguration(), new DataInputStream(new ByteArrayInputStream(bytes.toByteArray())));
+        FaunusEdge edge2 = new FaunusEdge(EmptyConfiguration.immutable(), new DataInputStream(new ByteArrayInputStream(bytes.toByteArray())));
         assertEquals(edge1, edge2);
         assertEquals(edge2.getId(), -1l);
         assertEquals(edge2.getLabel(), "knows");
@@ -41,7 +41,7 @@ public void testSimpleSerialization() throws IOException {
 
     public void testSerializationWithProperties() throws IOException {
 
-        FaunusEdge edge1 = new FaunusEdge(FaunusElement.EMPTY_CONFIGURATION, 1, 2, "knows");
+        FaunusEdge edge1 = new FaunusEdge(EmptyConfiguration.immutable(), 1, 2, "knows");
         edge1.setProperty("weight", 0.5f);
         edge1.setProperty("type", "coworker");
         edge1.setProperty("alive", true);

File: src/test/java/com/thinkaurelius/faunus/formats/VertexQueryFilterTest.java
Patch:
@@ -3,6 +3,7 @@
 import com.thinkaurelius.faunus.BaseTest;
 import com.thinkaurelius.faunus.FaunusElement;
 import com.thinkaurelius.faunus.FaunusVertex;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
 import org.apache.hadoop.conf.Configuration;
@@ -23,7 +24,7 @@ public void testDegenerateVertexQuery() {
         assertEquals(query.hasContainers.size(), 0);
         assertEquals(query.direction, Direction.BOTH);
         assertEquals(query.labels.length, 0);
-        FaunusVertex vertex = new FaunusVertex(FaunusElement.EMPTY_CONFIGURATION, 1);
+        FaunusVertex vertex = new FaunusVertex(EmptyConfiguration.immutable(), 1);
         vertex.setProperty("name", "marko");
         vertex.addEdge("knows", vertex).setProperty("time", 1);
         query.defaultFilter(vertex);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/sideeffect/ValueGroupCountMapReduceTest.java
Patch:
@@ -1,8 +1,8 @@
 package com.thinkaurelius.faunus.mapreduce.sideeffect;
 
 import com.thinkaurelius.faunus.BaseTest;
-import com.thinkaurelius.faunus.FaunusElement;
 import com.thinkaurelius.faunus.FaunusVertex;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Vertex;
 import org.apache.hadoop.conf.Configuration;
@@ -165,7 +165,7 @@ public void testPropertySortingOnInteger() throws Exception {
 
         Map<Long, FaunusVertex> vertices = new HashMap<Long, FaunusVertex>();
         for (long i = 0; i < 15; i++) {
-            FaunusVertex v = new FaunusVertex(FaunusElement.EMPTY_CONFIGURATION, i);
+            FaunusVertex v = new FaunusVertex(EmptyConfiguration.immutable(), i);
             v.setProperty("age", i);
             vertices.put(i, v);
             v.startPath();
@@ -183,7 +183,7 @@ public void testPropertySortingOnText() throws Exception {
 
         Map<Long, FaunusVertex> vertices = new HashMap<Long, FaunusVertex>();
         for (long i = 0; i < 15; i++) {
-            FaunusVertex v = new FaunusVertex(FaunusElement.EMPTY_CONFIGURATION, i);
+            FaunusVertex v = new FaunusVertex(EmptyConfiguration.immutable(), i);
             v.setProperty("age", i);
             vertices.put(i, v);
             v.startPath();

File: src/main/java/com/thinkaurelius/faunus/FaunusSerializer.java
Patch:
@@ -219,15 +219,15 @@ private void writeEdges(final ListMultimap<FaunusType, FaunusEdge> edges, final
         Map<FaunusType, Integer> counts = Maps.newHashMap();
         int typeCount = 0;
         for (FaunusType type : edges.keySet()) {
-            int count = IterablesUtil.size(filterDeleted(edges.get(type)));
+            int count = this.trackState ? IterablesUtil.size(edges.get(type)) : IterablesUtil.size(filterDeleted(edges.get(type)));
             counts.put(type, count);
             if (count > 0) typeCount++;
         }
 
         WritableUtils.writeVInt(out, typeCount);
         for (FaunusType type : edges.keySet()) {
             if (counts.get(type) == 0) continue;
-            Iterable<FaunusEdge> subset = filterDeleted(edges.get(type));
+            Iterable<FaunusEdge> subset = this.trackState ? edges.get(type) : filterDeleted(edges.get(type));
             WritableUtils.writeVLong(out, schema.getTypeId(type));
             WritableUtils.writeVInt(out, counts.get(type));
             for (final FaunusEdge edge : subset) {

File: src/main/java/com/thinkaurelius/faunus/formats/titan/cassandra/TitanCassandraInputFormat.java
Patch:
@@ -53,7 +53,7 @@ public void setConf(final Configuration config) {
         ConfigHelper.setInputSlicePredicate(config, predicate);
         ConfigHelper.setInputInitialAddress(config, config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_HOSTNAME));
         ConfigHelper.setInputRpcPort(config, config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_PORT));
-        config.set("storage.read-only", "true");
+        // TODO config.set("storage.read-only", "true");
         config.set("autotype", "none");
 
         this.config = config;

File: src/main/java/com/thinkaurelius/faunus/formats/titan/hbase/TitanHBaseInputFormat.java
Patch:
@@ -56,7 +56,7 @@ public void setConf(final Configuration config) {
         config.set(HConstants.ZOOKEEPER_QUORUM, config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_HOSTNAME));
         if (config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_PORT, null) != null)
             config.set(HConstants.ZOOKEEPER_CLIENT_PORT, config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_PORT));
-        config.set("storage.read-only", "true");
+        // TODO: config.set("storage.read-only", "true");
         config.set("autotype", "none");
         Scan scanner = new Scan();
         scanner.addFamily(Backend.EDGESTORE_NAME.getBytes());

File: src/main/java/com/thinkaurelius/faunus/formats/titan/util/ConfigurationUtil.java
Patch:
@@ -7,7 +7,7 @@
 import java.util.Map;
 
 /**
- * @author Matthias Broecheler (me@matthiasb.com)
+ * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
 public class ConfigurationUtil {
 

File: src/main/java/com/thinkaurelius/faunus/mapreduce/sideeffect/CommitVerticesMapReduce.java
Patch:
@@ -173,7 +173,9 @@ public void reduce(final LongWritable key, final Iterable<Holder> values, final
                 if (ids.size() > 0)
                     vertex.removeEdgesToFrom(ids);
 
-                if (!vertex.isDeleted() && this.trackState)
+                if (this.trackState)
+                    context.write(NullWritable.get(), vertex);
+                else if (!vertex.isDeleted())
                     context.write(NullWritable.get(), vertex);
 
                 context.getCounter(Counters.OUT_EDGES_KEPT).increment(((List) vertex.getEdges(OUT)).size());

File: src/test/java/com/thinkaurelius/faunus/mapreduce/sideeffect/CommitVerticesMapReduceTest.java
Patch:
@@ -50,7 +50,7 @@ public void testKeepAllVertices() throws Exception {
 
     public void testDropAllVertices() throws Exception {
         Configuration config = CommitVerticesMapReduce.createConfiguration(Tokens.Action.DROP);
-        config.setBoolean(Tokens.FAUNUS_PIPELINE_TRACK_STATE, true);
+        //config.setBoolean(Tokens.FAUNUS_PIPELINE_TRACK_STATE, true);
         mapReduceDriver.withConfiguration(config);
 
         Map<Long, FaunusVertex> results = runWithGraph(startPath(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, config), Vertex.class), mapReduceDriver);
@@ -63,7 +63,7 @@ public void testDropAllVertices() throws Exception {
 
     public void testKeepProjectVertices() throws Exception {
         Configuration config = CommitVerticesMapReduce.createConfiguration(Tokens.Action.KEEP);
-        config.setBoolean(Tokens.FAUNUS_PIPELINE_TRACK_STATE, true);
+        //config.setBoolean(Tokens.FAUNUS_PIPELINE_TRACK_STATE, true);
         mapReduceDriver.withConfiguration(config);
 
         Map<Long, FaunusVertex> graph = generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, config);
@@ -85,7 +85,7 @@ public void testKeepProjectVertices() throws Exception {
 
     public void testDropProjectVertices() throws Exception {
         Configuration config = CommitVerticesMapReduce.createConfiguration(Tokens.Action.KEEP);
-        config.setBoolean(Tokens.FAUNUS_PIPELINE_TRACK_STATE, true);
+        //config.setBoolean(Tokens.FAUNUS_PIPELINE_TRACK_STATE, true);
         mapReduceDriver.withConfiguration(config);
 
         Map<Long, FaunusVertex> graph = generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, config);

File: src/main/java/com/thinkaurelius/faunus/Tokens.java
Patch:
@@ -48,6 +48,7 @@ public static String makeNamespace(final Class klass) {
     public static final String _COUNT = "_count";
     public static final String _LINK = "_link";
     public static final String LABEL = "label";
+    public static final String _LABEL = "_label";
     public static final String NULL = "null";
     public static final String TAB = "\t";
     public static final String NEWLINE = "\n";

File: src/main/java/com/thinkaurelius/faunus/mapreduce/util/ElementPicker.java
Patch:
@@ -24,6 +24,9 @@ else if (key.equals(Tokens._PROPERTIES)) {
                 properties.put(property.getType().getName(), property.getValue());
             }
             properties.put(Tokens._ID, element.getId());
+            if (element instanceof FaunusEdge)
+                properties.put(Tokens._LABEL, ((FaunusEdge) element).getLabel());
+
             return properties.toString();
         } else if (key.equals(Tokens.LABEL) && element instanceof FaunusEdge) {
             return ((FaunusEdge) element).getLabel();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -437,7 +437,9 @@ public void close() throws StorageException {
         edgeIndexStore.close();
         idAuthority.close();
         storeManager.close();
-        threadPool.shutdown();
+        if(threadPool != null) {
+        	threadPool.shutdown();
+        }
         //Indexes
         for (IndexProvider index : indexes.values()) index.close();
     }

File: src/main/java/com/thinkaurelius/faunus/formats/titan/cassandra/TitanCassandraInputFormat.java
Patch:
@@ -45,7 +45,7 @@ public RecordReader<NullWritable, FaunusVertex> createRecordReader(final InputSp
     @Override
     public void setConf(final Configuration config) {
         super.setConf(config);
-        this.graph = new FaunusTitanCassandraGraph(titanSetup.getRelationReader(),titanSetup.getTypeInspector());
+        this.graph = new FaunusTitanCassandraGraph(titanSetup);
 
         config.set("cassandra.input.keyspace", config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_KEYSPACE));
         ConfigHelper.setInputColumnFamily(config, ConfigHelper.getInputKeyspace(config), Backend.EDGESTORE_NAME);

File: src/main/java/com/thinkaurelius/faunus/formats/titan/hbase/TitanHBaseInputFormat.java
Patch:
@@ -48,7 +48,7 @@ public RecordReader<NullWritable, FaunusVertex> createRecordReader(final InputSp
     @Override
     public void setConf(final Configuration config) {
         super.setConf(config);
-        this.graph = new FaunusTitanHBaseGraph(titanSetup.getRelationReader(),titanSetup.getTypeInspector());
+        this.graph = new FaunusTitanHBaseGraph(titanSetup);
 
 
         //config.set(TableInputFormat.SCAN_COLUMN_FAMILY, Backend.EDGESTORE_NAME);

File: src/main/java/com/thinkaurelius/faunus/FaunusType.java
Patch:
@@ -35,7 +35,7 @@ private FaunusType(String name, boolean isHidden) {
     }
 
     private static final String checkName(String name) {
-        Preconditions.checkArgument(!name.startsWith("_"),"Cannot use reserved name as type: " + name);
+        //Preconditions.checkArgument(!name.startsWith("_"),"Cannot use reserved name as type: " + name);
         return name;
     }
 

File: src/test/java/com/thinkaurelius/faunus/FaunusElementTest.java
Patch:
@@ -24,13 +24,13 @@ public void testBasicSerialization() throws IOException {
 
         ByteArrayOutputStream bytes1 = new ByteArrayOutputStream();
         vertex1.write(new DataOutputStream(bytes1));
-        assertEquals(bytes1.size(), 6);
+        assertEquals(bytes1.size(), 7);
         // 1 long id + 1 boolean path + 1 variable int paths + 1 short properties +  2 vinteger edge types (2)
         // ? + 1 + 1 + 2 + 2 + 2 = 11 bytes + 1 byte long id
 
         ByteArrayOutputStream bytes2 = new ByteArrayOutputStream();
         vertex2.write(new DataOutputStream(bytes2));
-        assertEquals(bytes2.size(), 14);
+        assertEquals(bytes2.size(), 15);
         // 1 long id + 1 boolean path + 1 int paths + 1 short properties + 2 vinteger edge types (2)
         // ? + 1 + 1 + 2 + 2 + 2 = 11 bytes + 9 byte long id
 

File: src/test/java/com/thinkaurelius/faunus/FaunusVertexTest.java
Patch:
@@ -51,13 +51,14 @@ public void testSimpleSerialization() throws IOException {
         DataOutputStream out = new DataOutputStream(bytes);
         vertex1.write(out);
 
+        // schema length is 1 byte
         // id length is 1 byte (variable long)
         // pathsEnabled boolean 1 byte (boolean)
         // paths size 1 byte (variable int)
         // properties size 1 byte (variable int)
         // out edge types size 1 byte (variable int)
         // in edge types size 1 byte (variable int)
-        assertEquals(bytes.toByteArray().length, 6);
+        assertEquals(7, bytes.toByteArray().length);
         FaunusVertex vertex2 = new FaunusVertex(new DataInputStream(new ByteArrayInputStream(bytes.toByteArray())));
         System.out.println("Vertex with 0 properties has a byte size of: " + bytes.toByteArray().length);
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -58,7 +58,7 @@ public class HBaseStoreManager extends DistributedStoreManager implements KeyCol
     public static final String TABLE_NAME_DEFAULT = "titan";
 
     public static final String SHORT_CF_NAMES_KEY = "short-cf-names";
-    public static final boolean SHORT_CF_NAMES_DEFAULT = true;
+    public static final boolean SHORT_CF_NAMES_DEFAULT = false;
 
     public static final int PORT_DEFAULT = 9160;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeInspector.java
Patch:
@@ -9,5 +9,8 @@ public interface TypeInspector {
 
     public TitanType getExistingType(long id);
 
+    public boolean containsType(String name);
+
+    public TitanType getType(String name);
 
 }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -163,8 +163,7 @@ public AstyanaxStoreManager(Configuration config) throws StorageException {
 
     @Override
     public Deployment getDeployment() {
-        //return Deployment.REMOTE;
-        //return LOCAL if over localhost else REMOTE
+        return Deployment.REMOTE; // TODO
     }
 
     @Override

File: src/main/java/com/thinkaurelius/faunus/FaunusElement.java
Patch:
@@ -71,7 +71,7 @@ void updateSchema(FaunusSerializer.Schema schema) {
     @Override
     public void setProperty(final String key, final Object value) {
         ElementHelper.validateProperty(this, key, value);
-        FaunusType type = FaunusGraph.getCurrent().getTypes().get(key);
+        FaunusType type = FaunusType.DEFAULT_MANAGER.get(key);
         if (properties == NO_PROPERTIES)
             this.properties = ArrayListMultimap.create();
         this.properties.removeAll(type);
@@ -81,15 +81,15 @@ public void setProperty(final String key, final Object value) {
     @Override
     public <T> T removeProperty(final String key) {
         if (properties.isEmpty()) return null;
-        Collection<Object>  removed = this.properties.removeAll(FaunusGraph.getCurrent().getTypes().get(key));
+        Collection<Object>  removed = this.properties.removeAll(FaunusType.DEFAULT_MANAGER.get(key));
         if (removed.isEmpty()) return null;
         else if (removed.size()==1) return (T)removed.iterator().next();
         else return (T)removed;
     }
 
     @Override
     public <T> T getProperty(final String key) {
-        FaunusType type = FaunusGraph.getCurrent().getTypes().get(key);
+        FaunusType type = FaunusType.DEFAULT_MANAGER.get(key);
         //First, handle special cases
         if (type.equals(FaunusType.COUNT))
             return (T) Long.valueOf(this.pathCount());

File: src/main/java/com/thinkaurelius/faunus/FaunusType.java
Patch:
@@ -69,6 +69,9 @@ public boolean equals(Object other) {
         return name.equals(((FaunusType)other).name);
     }
 
+    public static final FaunusType.Manager DEFAULT_MANAGER = new FaunusType.Manager();
+
+
     public static class Manager extends HashMap<String,FaunusType> {
 
         Manager() {

File: src/main/java/com/thinkaurelius/faunus/formats/BlueprintsGraphOutputMapReduce.java
Patch:
@@ -4,9 +4,10 @@
 import com.thinkaurelius.faunus.FaunusVertex;
 import com.thinkaurelius.faunus.Holder;
 import com.thinkaurelius.faunus.Tokens;
-import com.thinkaurelius.faunus.formats.titan.GraphFactory;
 import com.thinkaurelius.faunus.formats.titan.TitanOutputFormat;
+import com.thinkaurelius.faunus.formats.titan.util.ConfigurationUtil;
 import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
+import com.thinkaurelius.titan.core.TitanFactory;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Graph;
 import com.tinkerpop.blueprints.TransactionalGraph;
@@ -71,7 +72,7 @@ public enum Counters {
     public static Graph generateGraph(final Configuration config) {
         final Class<? extends OutputFormat> format = config.getClass(FaunusGraph.FAUNUS_GRAPH_OUTPUT_FORMAT, OutputFormat.class, OutputFormat.class);
         if (TitanOutputFormat.class.isAssignableFrom(format)) {
-            return GraphFactory.generateGraph(config, TitanOutputFormat.FAUNUS_GRAPH_OUTPUT_TITAN);
+            return TitanFactory.open(ConfigurationUtil.extractConfiguration(config, TitanOutputFormat.FAUNUS_GRAPH_OUTPUT_TITAN));
         } else {
             // TODO: this is where Rexster can come into play here
             throw new RuntimeException("The provide graph output format is not supported: " + format.getName());

File: src/main/java/com/thinkaurelius/faunus/formats/titan/FaunusTitanGraph.java
Patch:
@@ -39,9 +39,9 @@ public class FaunusTitanGraph {
     private final EdgeSerializer edgeSerializer;
     private final TypeReferenceContainer typeManager;
 
-    public FaunusTitanGraph(final Serializer serializer, final Configuration configuration) {
+    public FaunusTitanGraph(final Serializer serializer, final TypeReferenceContainer types) {
         this.edgeSerializer = new EdgeSerializer(serializer);
-        typeManager = new TypeReferenceContainer(configuration);
+        typeManager = types;
     }
 
     protected FaunusVertex readFaunusVertex(final StaticBuffer key, Iterable<Entry> entries) {

File: src/main/java/com/thinkaurelius/faunus/formats/titan/cassandra/FaunusTitanCassandraGraph.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StaticBufferEntry;
 import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
+import com.thinkaurelius.titan.graphdb.types.reference.TypeReferenceContainer;
 import org.apache.cassandra.db.IColumn;
 import org.apache.commons.configuration.Configuration;
 
@@ -22,8 +23,8 @@
 public class FaunusTitanCassandraGraph extends FaunusTitanGraph {
 
 
-    public FaunusTitanCassandraGraph(Serializer serializer, Configuration configuration) {
-        super(serializer, configuration);
+    public FaunusTitanCassandraGraph(Serializer serializer, final TypeReferenceContainer types) {
+        super(serializer, types);
     }
 
     public FaunusVertex readFaunusVertex(final ByteBuffer key, final SortedMap<ByteBuffer, IColumn> value) {

File: src/main/java/com/thinkaurelius/faunus/formats/titan/hbase/FaunusTitanHBaseGraph.java
Patch:
@@ -8,6 +8,7 @@
 import com.thinkaurelius.titan.diskstorage.util.StaticArrayBuffer;
 import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
+import com.thinkaurelius.titan.graphdb.types.reference.TypeReferenceContainer;
 import org.apache.commons.configuration.Configuration;
 import org.apache.commons.configuration.ConfigurationException;
 import org.apache.commons.configuration.PropertiesConfiguration;
@@ -23,8 +24,8 @@
 
 public class FaunusTitanHBaseGraph extends FaunusTitanGraph {
 
-    public FaunusTitanHBaseGraph(Serializer serializer, Configuration configuration) {
-        super(serializer, configuration);
+    public FaunusTitanHBaseGraph(Serializer serializer, final TypeReferenceContainer types) {
+        super(serializer, types);
     }
 
     public FaunusVertex readFaunusVertex(byte[] key, final NavigableMap<byte[], NavigableMap<Long, byte[]>> rowMap) {

File: src/test/java/com/thinkaurelius/faunus/FaunusElementTest.java
Patch:
@@ -78,7 +78,7 @@ public void testElementComparator() throws IOException {
 
         //////// test raw byte comparator
 
-        FaunusElement.Comparator comparator = new FaunusElement.Comparator();
+        FaunusSerializer.Comparator comparator = new FaunusSerializer.Comparator();
 
         assertEquals(0, comparator.compare(aBytes.toByteArray(), 0, aBytes.size(), aBytes.toByteArray(), 0, aBytes.size()));
         assertEquals(-1, comparator.compare(aBytes.toByteArray(), 0, aBytes.size(), bBytes.toByteArray(), 0, bBytes.size()));

File: src/test/java/com/thinkaurelius/faunus/FaunusVertexTest.java
Patch:
@@ -36,9 +36,9 @@ public void testRawComparator() throws IOException {
         ByteArrayOutputStream bytes2 = new ByteArrayOutputStream();
         vertex2.write(new DataOutputStream(bytes2));
 
-        assertEquals(-1, new FaunusVertex.Comparator().compare(bytes1.toByteArray(), 0, bytes1.size(), bytes2.toByteArray(), 0, bytes2.size()));
-        assertEquals(1, new FaunusVertex.Comparator().compare(bytes2.toByteArray(), 0, bytes2.size(), bytes1.toByteArray(), 0, bytes1.size()));
-        assertEquals(0, new FaunusVertex.Comparator().compare(bytes1.toByteArray(), 0, bytes1.size(), bytes1.toByteArray(), 0, bytes1.size()));
+        assertEquals(-1, new FaunusSerializer.Comparator().compare(bytes1.toByteArray(), 0, bytes1.size(), bytes2.toByteArray(), 0, bytes2.size()));
+        assertEquals(1, new FaunusSerializer.Comparator().compare(bytes2.toByteArray(), 0, bytes2.size(), bytes1.toByteArray(), 0, bytes1.size()));
+        assertEquals(0, new FaunusSerializer.Comparator().compare(bytes1.toByteArray(), 0, bytes1.size(), bytes1.toByteArray(), 0, bytes1.size()));
 
         System.out.println("Vertex with 0 properties has a byte size of: " + bytes1.toByteArray().length);
     }

File: src/test/java/com/thinkaurelius/faunus/formats/titan/GraphFactoryTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.faunus.formats.titan;
 
 import com.thinkaurelius.faunus.BaseTest;
+import com.thinkaurelius.faunus.formats.titan.util.ConfigurationUtil;
 import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import org.apache.commons.configuration.BaseConfiguration;
 import org.apache.hadoop.conf.Configuration;
@@ -15,7 +16,7 @@ public void testPropertyPrefixes() {
         configuration.set("faunus.graph.output.titan.storage.backend", "cassandrathrift");
         configuration.set("faunus.graph.output.titan.ids.block-size", "100000");
         configuration.set("faunus.graph.output.titan.storage.batch-loading", "true");
-        BaseConfiguration base = GraphFactory.generateTitanConfiguration(configuration, TitanOutputFormat.FAUNUS_GRAPH_OUTPUT_TITAN);
+        BaseConfiguration base = ConfigurationUtil.extractConfiguration(configuration, TitanOutputFormat.FAUNUS_GRAPH_OUTPUT_TITAN);
         assertEquals(base.getString("storage.backend"), "cassandrathrift");
         assertEquals(base.getLong("ids.block-size"), 100000);
         assertTrue(base.getBoolean("storage.batch-loading"));

File: src/main/java/com/thinkaurelius/faunus/Tokens.java
Patch:
@@ -46,6 +46,7 @@ public static String makeNamespace(final Class klass) {
     public static final String ID = "id";
     public static final String _PROPERTIES = "_properties";
     public static final String _COUNT = "_count";
+    public static final String _LINK = "_link";
     public static final String LABEL = "label";
     public static final String NULL = "null";
     public static final String TAB = "\t";

File: src/main/java/com/thinkaurelius/faunus/formats/edgelist/EdgeListInputMapReduce.java
Patch:
@@ -70,7 +70,7 @@ public void map(final NullWritable key, final FaunusElement value, final Mapper<
                     vertex = new FaunusVertex(id);
                     this.map.put(id, vertex);
                 }
-                vertex.getProperties().putAll(value.getProperties());
+                vertex.addAllProperties(value.getProperties());
                 vertex.addEdges(BOTH, WritableUtils.clone((FaunusVertex) value, context.getConfiguration()));
                 this.counter++;
             }
@@ -103,7 +103,7 @@ public void reduce(final LongWritable key, final Iterable<FaunusVertex> values,
             this.vertex.reuse(key.get());
             for (final FaunusVertex value : values) {
                 this.vertex.addEdges(BOTH, value);
-                this.vertex.getProperties().putAll(value.getProperties());
+                this.vertex.addAllProperties(value.getProperties());
             }
             context.write(key, this.vertex);
         }
@@ -118,7 +118,7 @@ public void reduce(final LongWritable key, final Iterable<FaunusVertex> values,
             this.vertex.reuse(key.get());
             for (final FaunusVertex value : values) {
                 this.vertex.addEdges(BOTH, value);
-                this.vertex.getProperties().putAll(value.getProperties());
+                this.vertex.addAllProperties(value.getProperties());
             }
             context.getCounter(Counters.VERTICES_CREATED).increment(1l);
             context.getCounter(Counters.VERTEX_PROPERTIES_CREATED).increment(this.vertex.getProperties().size());

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -515,7 +515,7 @@ public void testGetKeysColumnSlicesOnLowerTriangular() throws StorageException,
                         Collection<StaticBuffer> actual = Sets.newHashSet(i);
 
                         // Check
-                        log.error("Checking bounds [{}, {}) (expect {} keys)",
+                        log.debug("Checking bounds [{}, {}) (expect {} keys)",
                                 new Object[]{startCol, endCol, expected.size()});
                         Assert.assertEquals(expected, actual);
                         i.close();
@@ -551,7 +551,7 @@ public void testGetKeysColumnSlicesOnLowerTriangular() throws StorageException,
                         KeyIterator i = store.getKeys(krq, tx);
                         Collection<StaticBuffer> actual = Lists.newArrayList(i);
 
-                        log.error("Checking bounds key:[{}, {}) & col:[{}, {}) (expect {} keys)",
+                        log.debug("Checking bounds key:[{}, {}) & col:[{}, {}) (expect {} keys)",
                                 new Object[]{keyStart, keyEnd, startCol, endCol, expected.size()});
                         Assert.assertEquals(expected, actual);
                         i.close();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/SimpleVertexQueryProcessor.java
Patch:
@@ -59,6 +59,8 @@ private SimpleVertexQueryProcessor(InternalVertex vertex) {
 
     public SimpleVertexQueryProcessor(InternalVertex vertex, TitanKey key) {
         this(vertex);
+        assert key==null || !((InternalType)key).isHidden();
+        assert key==null || !((InternalType)key).isStatic(Direction.OUT);
         RelationQueryCache cache = tx.getGraph().getRelationCache();
         filterHiddenProperties = key==null;
         if (key==null || tx.getConfiguration().hasPropertyPrefetching()) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/ConcurrentLRUCache.java
Patch:
@@ -658,7 +658,7 @@ void stopThread() {
     protected void finalize() throws Throwable {
         try {
             if (!isDestroyed) {
-                log.error("ConcurrentLRUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEALong!!!");
+                log.error("ConcurrentLRUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEAK!!!");
                 destroy();
             }
         } finally {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/SimpleVertexQueryProcessor.java
Patch:
@@ -88,9 +88,7 @@ public SimpleVertexQueryProcessor(InternalVertex vertex, Direction dir, TitanLab
         }
 
         this.limit = limit;
-        int baseLimit = tx.getGraph().getConfiguration().getResultSetLoadSize();
-        if (baseLimit>0 || limit!=Query.NO_LIMIT) {
-            if (baseLimit>0) limit = Math.min(limit,baseLimit);
+        if (limit!=Query.NO_LIMIT) {
             sliceQuery = sliceQuery.updateLimit(limit);
         }
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/vertexcache/GuavaVertexCache.java
Patch:
@@ -62,7 +62,7 @@ public InternalVertex get(final long id, final Retriever<Long, InternalVertex> r
             assert newVertex!=null;
             try {
                 vertex = cache.get(vertexId, new NewVertexCallable(newVertex));
-            } catch (Exception e) { throw new AssertionError("Should not happen: ",e); }
+            } catch (Exception e) { throw new AssertionError("Should not happen: "+e.getMessage()); }
             assert vertex!=null;
         }
 

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneIndexTest.java
Patch:
@@ -57,8 +57,9 @@ public void testSupport() {
         assertFalse(index.supports(of(Exception.class)));
 
         assertTrue(index.supports(of(String.class), Text.CONTAINS));
-        assertTrue(index.supports(of(String.class, new Parameter("mapping", Mapping.TEXT)), Text.PREFIX));
-        assertFalse(index.supports(of(String.class), Text.REGEX));
+        assertTrue(index.supports(of(String.class, new Parameter("mapping", Mapping.TEXT)), Text.CONTAINS_PREFIX));
+        assertFalse(index.supports(of(String.class), Text.CONTAINS_REGEX));
+        assertTrue(index.supports(of(String.class, new Parameter("mapping", Mapping.STRING)), Text.PREFIX));
         assertFalse(index.supports(of(String.class, new Parameter("mapping",Mapping.STRING)), Text.CONTAINS));
         assertTrue(index.supports(of(String.class, new Parameter("mapping",Mapping.STRING)), Cmp.EQUAL));
         assertTrue(index.supports(of(String.class, new Parameter("mapping",Mapping.STRING)), Cmp.NOT_EQUAL));

File: titan-test/src/main/java/com/thinkaurelius/titan/testcategory/SerialTests.java
Patch:
@@ -0,0 +1,3 @@
+package com.thinkaurelius.titan.testcategory;
+
+public interface SerialTests { }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -15,6 +15,7 @@
 import static org.junit.Assert.*;
 import static org.junit.Assert.assertEquals;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -264,8 +265,9 @@ private double testAllVertices(long vid, int numV) {
     }
 
     @Test
+    @Ignore //Only works if run individually due to concurrency issues in how we access the stats
     public void testCacheExpiration() throws InterruptedException {
-        final int cleanTime = 50;
+        final int cleanTime = 400;
         final int numV = 10;
         final int edgePerV = 10;
         Map<String,? extends Object> newConfig = ImmutableMap.of("cache.db-cache",true,"cache.db-cache-time",0,"cache.db-cache-clean-wait",cleanTime);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/DirectoryUtil.java
Patch:
@@ -21,7 +21,7 @@ public static File getOrCreateDataDirectory(String location) throws StorageExcep
             throw new PermanentStorageException(String.format("%s exists but is a file.", location));
 
         if (!storageDir.exists() && !storageDir.mkdirs())
-            throw new PermanentStorageException(String.format("Failed to create directory %s for BerkleyDB storage.", location));
+            throw new PermanentStorageException(String.format("Failed to create directory %s for local storage.", location));
 
         return storageDir;
     }

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/inmemory/InMemoryMetricsTest.java
Patch:
@@ -50,6 +50,7 @@ public static final Configuration getConfiguration() {
     public void before() {
         graph = (StandardTitanGraph)TitanFactory.open(getConfiguration());
         metric = MetricManager.INSTANCE;
+        CachedKeyColumnValueStore.resetGlobalMetrics();
     }
 
     @After

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -73,7 +73,7 @@ public boolean isModifiable() {
 
     @Override
     public boolean isLoop() {
-        return getArity()==2 && it().getVertex(0).equals(it().getVertex(1));
+        return getArity()==2 && getVertex(0).equals(getVertex(1));
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheEdge.java
Patch:
@@ -54,9 +54,7 @@ public boolean apply(@Nullable InternalRelation internalRelation) {
                     return (internalRelation instanceof StandardEdge) && ((StandardEdge) internalRelation).getPreviousID() == id;
                 }
             });
-
-            int psize = Iterables.size(previous);
-            assert psize == 0 || psize == 1 || (isLoop() && psize == 2);
+            assert Iterables.size(previous) <= 1 || (isLoop() && Iterables.size(previous) == 2);
             it = Iterables.getFirst(previous, null);
         }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/SliceQuery.java
Patch:
@@ -31,8 +31,6 @@ public class SliceQuery extends BaseQuery implements BackendQuery<SliceQuery> {
 
     private final boolean isStatic;
 
-    protected int hashcode;
-
     public SliceQuery(final StaticBuffer sliceStart, final StaticBuffer sliceEnd, boolean isStatic) {
         assert sliceStart != null && sliceEnd != null;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/CacheStore.java
Patch:
@@ -18,7 +18,7 @@ public interface CacheStore extends KeyValueStore {
      * @param txh      The transaction context for the operation.
      * @throws CacheUpdateException If "oldValue" doesn't match currently find in the cache.
      */
-    public void replace(StaticBuffer key, StaticBuffer newValue, StaticBuffer oldValue, StoreTransaction txh) throws CacheUpdateException;
+    public void replace(StaticBuffer key, StaticBuffer newValue, StaticBuffer oldValue, StoreTransaction txh) throws StorageException;
 
     /**
      * Returns an iterator over all keys in this store that match the given KeySelector. The keys may be

File: titan-infinispan/src/test/java/com/thinkaurelius/titan/InfinispanStorageSetup.java
Patch:
@@ -25,7 +25,7 @@ public static Configuration getInfinispanCacheGraphConfig(boolean transactional)
 
 
     public static Configuration getInfinispanBaseConfig() {
-        return getInfinispanBaseConfig(false);
+        return getInfinispanBaseConfig(true);
     }
 
     public static Configuration getInfinispanBaseConfig(boolean transactional) {

File: titan-infinispan/src/test/java/com/thinkaurelius/titan/blueprints/InfinispanBlueprintsTest.java
Patch:
@@ -47,7 +47,7 @@ public Graph generateGraph(String s) {
     }
 
     private Configuration getGraphConfig() {
-        return InfinispanStorageSetup.getInfinispanCacheGraphConfig(false);
+        return InfinispanStorageSetup.getInfinispanCacheGraphConfig(true);
     }
     
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -302,8 +302,8 @@ public class GraphDatabaseConfiguration {
      * Username and password keys to be used to specify an access credential that may be needed to connect
      * with a secured storage backend.
      */
-    public static final String AUTH_USERNAME_KEY = "user";
-    public static final String AUHT_PASSWORD_KEY = "password";
+    public static final String AUTH_USERNAME_KEY = "username";
+    public static final String AUTH_PASSWORD_KEY = "password";
 
     /**
      * Default timeout when connecting to a remote database instance

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/SerializerInitialization.java
Patch:
@@ -30,7 +30,7 @@ public static final void initialize(Serializer serializer) {
         serializer.registerClass(long[].class, KRYO_OFFSET + 11);
         serializer.registerClass(byte[].class, new ByteArrayHandler(), KRYO_OFFSET + 12);
         serializer.registerClass(boolean[].class, KRYO_OFFSET + 13);
-//        serializer.registerClass(IndexType.class, KRYO_OFFSET + 14); //duplicate of 20
+        serializer.registerClass(IndexType.class, KRYO_OFFSET + 14); //duplicate of 20 TODO: remove one!
         serializer.registerClass(TitanTypeClass.class, KRYO_OFFSET + 15);
         serializer.registerClass(Integer.class, new IntegerSerializer(), KRYO_OFFSET + 16);
         serializer.registerClass(Double.class, new DoubleSerializer(), KRYO_OFFSET + 17);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/SerializerInitialization.java
Patch:
@@ -28,7 +28,7 @@ public static final void initialize(Serializer serializer) {
         serializer.registerClass(int[].class, KRYO_OFFSET + 9);
         serializer.registerClass(double[].class, KRYO_OFFSET + 10);
         serializer.registerClass(long[].class, KRYO_OFFSET + 11);
-        serializer.registerClass(byte[].class, KRYO_OFFSET + 12);
+        serializer.registerClass(byte[].class, new ByteArrayHandler(), KRYO_OFFSET + 12);
         serializer.registerClass(boolean[].class, KRYO_OFFSET + 13);
 //        serializer.registerClass(IndexType.class, KRYO_OFFSET + 14); //duplicate of 20
         serializer.registerClass(TitanTypeClass.class, KRYO_OFFSET + 15);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -124,9 +124,6 @@ public static Partitioner getPartitioner(String className) {
     private StoreFeatures features = null;
     private Partitioner partitioner = null;
 
-    protected static final String SYSTEM_PROPERTIES_CF = "system_properties";
-    protected static final String SYSTEM_PROPERTIES_KEY = "general";
-
     protected final boolean compressionEnabled;
     protected final int compressionChunkSizeKB;
     protected final String compressionClass;

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/ElasticSearchBerkeleyDBTest.java
Patch:
@@ -36,6 +36,6 @@ public static final Configuration getElasticSearchBDBConfig() {
 
     @Override
     public boolean supportsLuceneStyleQueries() {
-        return false;
+        return true;
     }
 }
\ No newline at end of file

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -343,6 +343,7 @@ public Iterable<RawQuery.Result> executeQuery(IndexQueryBuilder query, final Ele
                 keyBuilder.append(qB.charAt(pos));
                 pos++;
             }
+            if (quoteTerminated) pos++;
             int endPos = pos;
             String keyname = keyBuilder.toString();
             Preconditions.checkArgument(StringUtils.isNotBlank(keyname),"Found reference to empty key at position [%s]",startPos);
@@ -355,7 +356,7 @@ public Iterable<RawQuery.Result> executeQuery(IndexQueryBuilder query, final Ele
         }
 
         String queryStr = qB.toString();
-        Preconditions.checkArgument(replacements>0,"Could not convert given raw index query: %s",query.getQuery());
+        Preconditions.checkArgument(replacements>0,"Could not convert given %s index query: %s",resultType, query.getQuery());
         log.info("Converted query string with {} replacements: [{}] => [{}]",replacements,query.getQuery(),queryStr);
         RawQuery rawQuery=new RawQuery(getStoreName(resultType),queryStr,query.getParameters());
         if (query.hasLimit()) rawQuery.setLimit(query.getLimit());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -787,6 +787,9 @@ private PredicateCondition<TitanKey, TitanElement> getEqualityCondition(Conditio
         @Override
         public Iterator<TitanElement> getNew(final GraphCentricQuery query) {
             Preconditions.checkArgument(query.getResultType() == ElementType.VERTEX || query.getResultType() == ElementType.EDGE);
+            //If the query is unconstrained then we don't need to add new elements, so will be picked up by getVertices()/getEdges() below
+            if (!query.getCondition().hasChildren()) return Iterators.emptyIterator();
+
             if (query.getResultType() == ElementType.VERTEX && hasModifications()) {
                 Preconditions.checkArgument(QueryUtil.isQueryNormalForm(query.getCondition()));
                 PredicateCondition<TitanKey, TitanElement> standardIndexKey = getEqualityCondition(query.getCondition());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/ConcurrentLRUCache.java
Patch:
@@ -619,6 +619,8 @@ private static class CleanupThread extends Thread {
 
         public CleanupThread(ConcurrentLRUCache c) {
             cache = new WeakReference<ConcurrentLRUCache>(c);
+            this.setDaemon(true);
+            this.setName("ConcurrentLRUCleaner-" + getId());
         }
 
         @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/core/KeyMaker.java
Patch:
@@ -92,7 +92,7 @@ public interface KeyMaker extends TypeMaker {
      * @see com.thinkaurelius.titan.core.TitanKey#hasIndex(String, Class)
      * @since 0.3.0
      */
-    public KeyMaker indexed(String indexName, Class<? extends Element> clazz);
+    public KeyMaker indexed(String indexName, Class<? extends Element> clazz, Parameter... indexParameters);
 
     /**
      * Configures the data type for this type.  This only applies to property keys.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsGraph.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.util.ExceptionFactory;
 import com.tinkerpop.blueprints.*;
+import com.tinkerpop.blueprints.Parameter;
 import com.tinkerpop.blueprints.util.StringFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsTransaction.java
Patch:
@@ -9,6 +9,7 @@
 import com.thinkaurelius.titan.graphdb.types.system.SystemKey;
 import com.thinkaurelius.titan.util.datastructures.IterablesUtil;
 import com.tinkerpop.blueprints.*;
+import com.tinkerpop.blueprints.Parameter;
 import com.tinkerpop.blueprints.util.ExceptionFactory;
 import com.tinkerpop.blueprints.util.StringFactory;
 import org.slf4j.Logger;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/indexing/StandardIndexInformation.java
Patch:
@@ -3,6 +3,7 @@
 import com.thinkaurelius.titan.core.attribute.Cmp;
 import com.thinkaurelius.titan.core.attribute.Contain;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexInformation;
+import com.thinkaurelius.titan.diskstorage.indexing.KeyInformation;
 import com.thinkaurelius.titan.graphdb.query.TitanPredicate;
 
 /**
@@ -17,13 +18,12 @@ private StandardIndexInformation() {
     }
 
     @Override
-    public boolean supports(Class<?> dataType, TitanPredicate titanPredicate) {
+    public boolean supports(KeyInformation information, TitanPredicate titanPredicate) {
         return titanPredicate == Cmp.EQUAL || titanPredicate == Contain.IN;
     }
 
     @Override
-    public boolean supports(Class<?> dataType) {
+    public boolean supports(KeyInformation information) {
         return true;
     }
-
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -218,7 +218,7 @@ public static final Set<String> andClauseIndexCover(final ElementType result, Co
                 indexes = Sets.newHashSet(key.getIndexes(result.getElementType()));
                 Iterator<String> indexiter = indexes.iterator();
                 while (indexiter.hasNext()) {
-                    if (!indexInfo.getIndexInformation(indexiter.next()).supports(key.getDataType(), atom.getPredicate())) {
+                    if (!indexInfo.supports(indexiter.next(),result,key,atom.getPredicate())) {
                         indexiter.remove();
                     }
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeAttributeType.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.types;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import com.thinkaurelius.titan.core.Order;
 
@@ -22,10 +21,11 @@ public enum TypeAttributeType {
     INDEXES(IndexType[].class),
     DATATYPE(Class.class),
     UNIDIRECTIONAL(Boolean.class),
-    SORT_ORDER(Order.class);
+    SORT_ORDER(Order.class),
+    INDEX_PARAMETERS(IndexParameters[].class);
 
     static final Set<TypeAttributeType> PROPERTY_KEY_TYPES = ImmutableSet.of(UNIQUENESS, UNIQUENESS_LOCK, STATIC,
-            HIDDEN, MODIFIABLE, SORT_KEY, SORT_ORDER, SIGNATURE, INDEXES, DATATYPE);
+            HIDDEN, MODIFIABLE, SORT_KEY, SORT_ORDER, SIGNATURE, INDEXES, INDEX_PARAMETERS, DATATYPE);
 
     static final Set<TypeAttributeType> EDGE_LABEL_TYPES = ImmutableSet.of(UNIQUENESS, UNIQUENESS_LOCK, STATIC,
             HIDDEN, MODIFIABLE, SORT_KEY, SORT_ORDER, SIGNATURE, UNIDIRECTIONAL);

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -1489,7 +1489,7 @@ public void testWithoutIndex() {
             }
             previous=v;
         }
-        graph.commit();
+        clopen();
 
         TestUtil.verifyElementOrder(graph.query().orderBy("kid",Order.ASC).limit(500).vertices(),"kid",Order.ASC,500);
         TestUtil.verifyElementOrder(graph.query().orderBy("kid",Order.ASC).limit(300).edges(),"kid",Order.ASC,300);

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/SerializerTest.java
Patch:
@@ -8,10 +8,8 @@
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.DoubleSerializer;
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.FloatSerializer;
 import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoSerializer;
-import com.thinkaurelius.titan.graphdb.types.IndexType;
 import com.thinkaurelius.titan.testutil.PerformanceTest;
 import com.thinkaurelius.titan.testutil.RandomGenerator;
-import com.tinkerpop.blueprints.Vertex;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;

File: titan-infinispan/src/test/java/com/thinkaurelius/titan/diskstorage/infinispan/InfinispanCacheAdapterLockStoreTest.java
Patch:
@@ -19,7 +19,4 @@ public void testRemoteLockContention() {
         //Does not apply to non-persisting in-memory store
     }
     
-    //TODO: should this test work in-memory?
-    @Override
-    public void testMultiIDAcquisition() {}
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexQuery.java
Patch:
@@ -12,6 +12,7 @@
 import com.thinkaurelius.titan.graphdb.query.Query;
 import com.thinkaurelius.titan.graphdb.query.QueryUtil;
 import com.thinkaurelius.titan.graphdb.query.condition.Condition;
+import org.apache.commons.lang.builder.HashCodeBuilder;
 
 import java.util.Comparator;
 import java.util.List;
@@ -45,8 +46,7 @@ public IndexQuery(String store, Condition condition, ImmutableList<OrderEntry> o
         this.orders = orders;
         this.store = store;
 
-        this.hashcode = condition.hashCode() * 9876469 + store.hashCode() * 4711
-                + orders.hashCode() * 107 + limit;
+        this.hashcode = new HashCodeBuilder().append(condition).append(store).append(orders).append(limit).toHashCode();
     }
 
     public IndexQuery(String store, Condition condition, ImmutableList<OrderEntry> orders) {

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanIndexTest.java
Patch:
@@ -161,7 +161,10 @@ public void testIndexing() {
 
         clopen();
 
+        //##########################
         //Copied from above
+        //##########################
+
         for (int i = 0; i < words.length; i++) {
             int expectedSize = numV / words.length;
             assertEquals(expectedSize, Iterables.size(tx.query().has("text", Text.CONTAINS, words[i]).vertices()));

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraTransaction.java
Patch:
@@ -82,6 +82,9 @@ public CassandraTransaction(StoreTxConfig config, Consistency readConsistency, C
         } else if (config.getConsistency() == ConsistencyLevel.KEY_CONSISTENT) {
             this.readConsistency = Consistency.QUORUM;
             this.writeConsistency = Consistency.QUORUM;
+        } else if (config.getConsistency() == ConsistencyLevel.LOCAL_KEY_CONSISTENT) {
+            this.readConsistency = Consistency.LOCAL_QUORUM;
+            this.writeConsistency = Consistency.LOCAL_QUORUM;
         } else {
             throw new IllegalArgumentException("Unsupported consistency level: " + config.getConsistency());
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/ColumnValueStore.java
Patch:
@@ -147,7 +147,7 @@ synchronized void mutate(List<Entry> additions, List<StaticBuffer> deletions, St
     private ReentrantLock lock = null;
 
     private Lock getLock(StoreTransaction txh) {
-        if (txh.getConfiguration().getConsistency() == ConsistencyLevel.KEY_CONSISTENT) {
+        if (txh.getConfiguration().getConsistency().isKeyConsistent()) {
             if (lock == null) {
                 synchronized (this) {
                     if (lock == null) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StandardIDPool.java
Patch:
@@ -44,6 +44,7 @@ public class StandardIDPool implements IDPool {
     public StandardIDPool(IDAuthority idAuthority, long partitionID, long maximumID, long renewTimeoutMS, double renewBufferPercentage) {
         Preconditions.checkArgument(maximumID > 0);
         this.idAuthority = idAuthority;
+        Preconditions.checkArgument(partitionID<(1l<<32));
         this.partitionID = (int) partitionID;
         this.maxID = maximumID;
         Preconditions.checkArgument(renewTimeoutMS>0,"Renew-timeout must be positive");

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/VariableLong.java
Patch:
@@ -60,7 +60,7 @@ private static int numVariableBlocks(final int numBits) {
         return (numBits - 1) / 7 + 1;
     }
 
-    private static int unsignedBitLength(final long value) {
+    public static int unsignedBitLength(final long value) {
         return (value == 0) ? 1 : Long.SIZE - Long.numberOfLeadingZeros(value);
     }
 

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/inmemory/inMemoryLockKeyColumnValueStoreTest.java
Patch:
@@ -21,7 +21,4 @@ public void testRemoteLockContention() {
         //Does not apply to non-persisting in-memory store
     }
 
-    //TODO: should this test work in-memory?
-    @Override
-    public void testMultiIDAcquisition() {}
 }

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/VertexIDAssignerTest.java
Patch:
@@ -42,7 +42,6 @@ public static Collection<Object[]> configs() {
         }
 
         return configurations;
-
     }
 
     public VertexIDAssignerTest(boolean partition, int partitionMax, int[] localPartition) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/util/ConcurrentLRUCache.java
Patch:
@@ -656,7 +656,7 @@ void stopThread() {
     protected void finalize() throws Throwable {
         try {
             if (!isDestroyed) {
-                log.error("ConcurrentLRUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEALong!!!");
+                log.error("ConcurrentLRUCache was not destroyed prior to finalize(), indicates a bug -- POSSIBLE RESOURCE LEAK!!!");
                 destroy();
             }
         } finally {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -247,7 +247,7 @@ public class GraphDatabaseConfiguration {
      */
     public static final String PORT_KEY = "port";
     /**
-     * Default timeout whne connecting to a remote database instance
+     * Default timeout when connecting to a remote database instance
      * <p/>
      * Value = {@value}
      */

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -465,7 +465,7 @@ public void clearStorage() throws StorageException {
         put("local", "com.thinkaurelius.titan.diskstorage.berkeleyje.BerkeleyJEStoreManager");
         put("berkeleyje", "com.thinkaurelius.titan.diskstorage.berkeleyje.BerkeleyJEStoreManager");
         put("persistit", "com.thinkaurelius.titan.diskstorage.persistit.PersistitStoreManager");
-        put("hazelcastkcvs", "com.thinkaurelius.titan.diskstorage.hazelcast.HazelcastKeyColumnValueStoreManager");
+        put("hazelcast", "com.thinkaurelius.titan.diskstorage.hazelcast.HazelcastCacheStoreManager");
         put("hazelcastcache", "com.thinkaurelius.titan.diskstorage.hazelcast.HazelcastCacheStoreManager");
         put("cassandra", "com.thinkaurelius.titan.diskstorage.cassandra.astyanax.AstyanaxStoreManager");
         put("cassandrathrift", "com.thinkaurelius.titan.diskstorage.cassandra.thrift.CassandraThriftStoreManager");

File: titan-hazelcast/src/test/java/com/thinkaurelius/titan/diskstorage/hazelcast/HazelcastCacheHashKeyColumnValueStoreTest.java
Patch:
@@ -3,9 +3,9 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.indexing.HashPrefixKeyColumnValueStore;
 
-public class HazelcastHashPrefixedKeyColumnValueStoreTest extends HazelcastKeyColumnValueStoreTest {
+public class HazelcastCacheHashKeyColumnValueStoreTest extends HazelcastCacheAdapterKCVSTest {
 
-    public HazelcastHashPrefixedKeyColumnValueStoreTest() throws StorageException {
+    public HazelcastCacheHashKeyColumnValueStoreTest() throws StorageException {
         super();
         store = new HashPrefixKeyColumnValueStore(store, 4);
     }

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -54,6 +54,7 @@ public BerkeleyJEStoreManager(Configuration configuration) throws StorageExcepti
         features.isKeyOrdered = true;
         features.isDistributed = false;
         features.hasLocalKeyPartition = false;
+        features.supportsMultiQuery = false;
 
         storageConfig = new FileStorageConfiguration(directory);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TransactionBuilder.java
Patch:
@@ -33,7 +33,7 @@ public interface TransactionBuilder {
      * @param size
      * @return
      */
-    public TransactionBuilder setCacheSize(long size);
+    public TransactionBuilder setCacheSize(int size);
 
     /**
      * Enables checks that verify that each vertex actually exists in the underlying data store when it is retrieved.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -41,7 +41,7 @@ public InMemoryStoreManager(final Configuration configuration) {
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;
         features.isDistributed = false;
-
+        features.supportsMultiQuery = false;
         features.isKeyOrdered = true;
         features.hasLocalKeyPartition = false;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -225,7 +225,7 @@ private List<Object> processSingleCondition(ElementType resultType, PredicateCon
         for (Entry entry : r) {
             ReadBuffer entryValue = entry.getReadValue();
             if (resultType == ElementType.VERTEX) {
-                results.add(Long.valueOf(VariableLong.readPositive(entryValue)));
+                results.add(VariableLong.readPositive(entryValue));
             } else {
                 results.add(bytebuffer2RelationId(entryValue));
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -77,7 +77,7 @@ public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
 
         this.serializer = config.getSerializer();
         this.indexSerializer = new IndexSerializer(this.serializer, this.backend.getIndexInformation());
-        this.edgeSerializer = new EdgeSerializer(this.serializer, this.idManager);
+        this.edgeSerializer = new EdgeSerializer(this.serializer);
         this.vertexExistenceQuery = edgeSerializer.getQuery(SystemKey.VertexState, Direction.OUT, new EdgeSerializer.TypedInterval[0], null).setLimit(1);
 
         isOpen = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/InternalVertex.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.titan.graphdb.query.VertexCentricQueryBuilder;
 import com.thinkaurelius.titan.util.datastructures.Retriever;
 
+import java.util.Collection;
 import java.util.List;
 
 /**
@@ -57,7 +58,7 @@ public interface InternalVertex extends TitanVertex, InternalElement {
      * @param lookup
      * @return
      */
-    public Iterable<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery,List<Entry>> lookup);
+    public Collection<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery,List<Entry>> lookup);
 
     /**
      * Returns true if the results for the given query have already been loaded for this vertex and are locally cached.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/ElementQuery.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.titan.core.TitanElement;
 
+import java.util.Collection;
 import java.util.Comparator;
 
 /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/GraphCentricQuery.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.TitanElement;
-import com.thinkaurelius.titan.diskstorage.indexing.IndexQuery;
 import com.thinkaurelius.titan.graphdb.internal.ElementType;
 import com.thinkaurelius.titan.graphdb.internal.OrderList;
 import com.thinkaurelius.titan.graphdb.query.condition.Condition;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/VertexCentricQuery.java
Patch:
@@ -8,6 +8,7 @@
 import com.thinkaurelius.titan.graphdb.relations.RelationComparator;
 import com.tinkerpop.blueprints.Direction;
 
+import java.util.Collection;
 import java.util.Comparator;
 import java.util.List;
 
@@ -40,7 +41,7 @@ protected VertexCentricQuery(InternalVertex vertex) {
         this.vertex = vertex;
     }
 
-    public static final VertexCentricQuery emptyQuery(InternalVertex vertex) {
+    public static VertexCentricQuery emptyQuery(InternalVertex vertex) {
         return new VertexCentricQuery(vertex);
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/condition/Literal.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.query.condition;
 
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableList;
+import java.util.Collections;
+
 import com.thinkaurelius.titan.core.TitanElement;
 
 /**
@@ -27,7 +27,7 @@ public int numChildren() {
 
     @Override
     public Iterable<Condition<E>> getChildren() {
-        return ImmutableList.of();
+        return Collections.EMPTY_LIST;
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationComparator.java
Patch:
@@ -38,7 +38,7 @@ public int compare(final InternalRelation r1, final InternalRelation r2) {
                 dir2 = EdgeDirection.fromPosition(i);
                 break;
             }
-        Preconditions.checkArgument(dir1 != null && dir2 != null, "Either relation is not incident on vertex [%s]", vertex);
+        assert dir1 != null && dir2 != null; // ("Either relation is not incident on vertex [%s]", vertex);
         int dirCompare = EdgeDirection.position(dir1) - EdgeDirection.position(dir2);
         if (dirCompare != 0) return dirCompare;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTransactionBuilder.java
Patch:
@@ -35,7 +35,7 @@ public class StandardTransactionBuilder implements TransactionConfiguration, Tra
 
     private boolean threadBound = false;
 
-    private long vertexCacheSize;
+    private int vertexCacheSize;
 
     private long indexCacheWeight;
 
@@ -95,7 +95,7 @@ public StandardTransactionBuilder enableBatchLoading() {
     }
 
     @Override
-    public StandardTransactionBuilder setCacheSize(long size) {
+    public StandardTransactionBuilder setCacheSize(int size) {
         verifyOpen();
         Preconditions.checkArgument(size >= 0);
         this.vertexCacheSize = size;
@@ -187,7 +187,7 @@ public final boolean isThreadBound() {
     }
 
     @Override
-    public final long getVertexCacheSize() {
+    public final int getVertexCacheSize() {
         return vertexCacheSize;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/TransactionConfiguration.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction;
 
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
 /**
  * Provides configuration options for {@link com.thinkaurelius.titan.core.TitanTransaction}.
@@ -98,7 +97,7 @@ public interface TransactionConfiguration {
      *
      * @return
      */
-    public long getVertexCacheSize();
+    public int getVertexCacheSize();
 
     /**
      * The maximum weight for the index cache store used in this particular transaction

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/vertexcache/VertexCache.java
Patch:
@@ -21,7 +21,7 @@ public interface VertexCache {
      * @param id
      * @return
      */
-    public InternalVertex get(long id, Retriever<Long, InternalVertex> vertexConstructor);
+    public InternalVertex get(long id, Retriever<Long, InternalVertex> retriever);
 
     /**
      * Adds the given vertex with the given id to the cache. The given vertex may already be in the cache.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeAttributeType.java
Patch:
@@ -31,7 +31,7 @@ public enum TypeAttributeType {
     private final Class attributeClass;
 
     private TypeAttributeType(Class<?> attributeClass) {
-        Preconditions.checkNotNull(attributeClass);
+        assert attributeClass != null;
         this.attributeClass = attributeClass;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyVertex.java
Patch:
@@ -17,6 +17,7 @@
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Vertex;
 
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
@@ -40,7 +41,7 @@ public List<InternalRelation> getAddedRelations(Predicate<InternalRelation> quer
     }
 
     @Override
-    public Iterable<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery, List<Entry>> lookup) {
+    public Collection<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery, List<Entry>> lookup) {
         throw new UnsupportedOperationException(errorName + " do not support incident edges");
     }
 
@@ -214,8 +215,7 @@ public long getID() {
 
     @Override
     public Object getId() {
-        if (hasId()) return Long.valueOf(getID());
-        else return null;
+        return hasId() ? getID() : null;
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemType.java
Patch:
@@ -29,7 +29,7 @@ public abstract class SystemType extends EmptyVertex implements InternalVertex,
         this.isModifiable = isModifiable;
     }
 
-    static final long getSystemTypeId(long id, RelationType type) {
+    static long getSystemTypeId(long id, RelationType type) {
         Preconditions.checkArgument(id > 0);
         Preconditions.checkArgument(id <= SystemTypeManager.SYSTEM_TYPE_OFFSET, "System id [%s] is too large", id);
         Preconditions.checkArgument(type.isProper());

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanKeyVertex.java
Patch:
@@ -36,7 +36,7 @@ public final boolean isEdgeLabel() {
         return false;
     }
 
-    private final IndexType[] getIndexes() {
+    private IndexType[] getIndexes() {
         if (indexes==null) {
             indexes = getDefinition().getValue(TypeAttributeType.INDEXES,IndexType[].class);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanTypeVertex.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.types.vertices;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.TitanProperty;
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
@@ -29,7 +28,7 @@ public String getName() {
                     type(SystemKey.TypeName).
                     properties(), null).getValue(String.class);
         }
-        Preconditions.checkNotNull(name);
+        assert name != null;
         return name;
     }
 
@@ -42,7 +41,6 @@ protected TypeAttribute.Map getDefinition() {
             }
             definition = def;
         }
-        Preconditions.checkNotNull(definition);
         return definition;
     }
 

File: titan-hazelcast/src/test/java/com/thinkaurelius/titan/diskstorage/hazelcast/HazelcastCacheHashKeyColumnValueStoreTest.java
Patch:
@@ -3,9 +3,9 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.indexing.HashPrefixKeyColumnValueStore;
 
-public class HazelcastHashPrefixedKeyColumnValueStoreTest extends HazelcastKeyColumnValueStoreTest {
+public class HazelcastCacheHashKeyColumnValueStoreTest extends HazelcastCacheAdapterKCVSTest {
 
-    public HazelcastHashPrefixedKeyColumnValueStoreTest() throws StorageException {
+    public HazelcastCacheHashKeyColumnValueStoreTest() throws StorageException {
         super();
         store = new HashPrefixKeyColumnValueStore(store, 4);
     }

File: titan-persistit/src/main/java/com/thinkaurelius/titan/diskstorage/persistit/PersistitStoreManager.java
Patch:
@@ -190,6 +190,7 @@ private StoreFeatures getDefaultFeatures() {
         features.supportsLocking = true;
         features.isKeyOrdered = true;
         features.hasLocalKeyPartition = false;
+        features.supportsMultiQuery = false;
 
         return features;
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/inmemory/InMemoryStorageAdapter.java
Patch:
@@ -123,6 +123,7 @@ public StoreFeatures getFeatures() {
         f.supportsUnorderedScan = true;
         f.supportsOrderedScan = true;
         f.supportsBatchMutation = true;
+        f.supportsMultiQuery = true;
 
         f.supportsTransactions = true;
         f.supportsConsistentKeyOperations = false;
@@ -166,7 +167,7 @@ public StaticBuffer next() {
         public void close() {
             // Do nothing
         }
-        
+
         @Override
         public void remove() {
             throw new UnsupportedOperationException("Can't remove element from empty iterator");

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/util/StorageFeaturesTest.java
Patch:
@@ -18,21 +18,22 @@ public void testFeaturesImplementation() {
             features = new StoreFeatures();
             features.supportsBatchMutation();
             fail();
-        } catch (IllegalArgumentException e) {
+        } catch (AssertionError e) {
         }
 
         try {
             features = new StoreFeatures();
             features.hasLocalKeyPartition = true;
             features.hasLocalKeyPartition();
             fail();
-        } catch (IllegalArgumentException e) {
+        } catch (AssertionError e) {
         }
         features = new StoreFeatures();
         features.supportsOrderedScan = false;
         features.supportsUnorderedScan = false;
         features.supportsBatchMutation = true;
         features.supportsTransactions = false;
+        features.supportsMultiQuery = false;
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;
         features.isKeyOrdered = false;

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -42,8 +42,8 @@ public abstract class KeyColumnValueStoreTest {
 
     private Logger log = LoggerFactory.getLogger(KeyColumnValueStoreTest.class);
 
-    int numKeys = 2;
-    int numColumns = 1;
+    int numKeys = 500;
+    int numColumns = 50;
 
     protected String storeName = "testStore1";
 
@@ -331,7 +331,7 @@ public void deleteKeys() throws StorageException {
         String[][] values = generateValues();
         log.debug("Loading values...");
         loadValues(values);
-        Set<Integer> deleted = deleteKeys(2);
+        Set<Integer> deleted = deleteKeys(11);
         clopen();
         checkKeys(deleted);
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -42,8 +42,8 @@ public abstract class KeyColumnValueStoreTest {
 
     private Logger log = LoggerFactory.getLogger(KeyColumnValueStoreTest.class);
 
-    int numKeys = 500;
-    int numColumns = 50;
+    int numKeys = 2;
+    int numColumns = 1;
 
     protected String storeName = "testStore1";
 
@@ -331,7 +331,7 @@ public void deleteKeys() throws StorageException {
         String[][] values = generateValues();
         log.debug("Loading values...");
         loadValues(values);
-        Set<Integer> deleted = deleteKeys(11);
+        Set<Integer> deleted = deleteKeys(2);
         clopen();
         checkKeys(deleted);
     }

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -54,6 +54,7 @@ public BerkeleyJEStoreManager(Configuration configuration) throws StorageExcepti
         features.isKeyOrdered = true;
         features.isDistributed = false;
         features.hasLocalKeyPartition = false;
+        features.supportsMultiQuery = false;
 
         storageConfig = new FileStorageConfiguration(directory);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TransactionBuilder.java
Patch:
@@ -33,7 +33,7 @@ public interface TransactionBuilder {
      * @param size
      * @return
      */
-    public TransactionBuilder setCacheSize(long size);
+    public TransactionBuilder setCacheSize(int size);
 
     /**
      * Enables checks that verify that each vertex actually exists in the underlying data store when it is retrieved.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -41,7 +41,7 @@ public InMemoryStoreManager(final Configuration configuration) {
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;
         features.isDistributed = false;
-
+        features.supportsMultiQuery = false;
         features.isKeyOrdered = true;
         features.hasLocalKeyPartition = false;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/IndexSerializer.java
Patch:
@@ -225,7 +225,7 @@ private List<Object> processSingleCondition(ElementType resultType, PredicateCon
         for (Entry entry : r) {
             ReadBuffer entryValue = entry.getReadValue();
             if (resultType == ElementType.VERTEX) {
-                results.add(Long.valueOf(VariableLong.readPositive(entryValue)));
+                results.add(VariableLong.readPositive(entryValue));
             } else {
                 results.add(bytebuffer2RelationId(entryValue));
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTransactionBuilder.java
Patch:
@@ -35,7 +35,7 @@ public class StandardTransactionBuilder implements TransactionConfiguration, Tra
 
     private boolean threadBound = false;
 
-    private long vertexCacheSize;
+    private int vertexCacheSize;
 
     private long indexCacheWeight;
 
@@ -95,7 +95,7 @@ public StandardTransactionBuilder enableBatchLoading() {
     }
 
     @Override
-    public StandardTransactionBuilder setCacheSize(long size) {
+    public StandardTransactionBuilder setCacheSize(int size) {
         verifyOpen();
         Preconditions.checkArgument(size >= 0);
         this.vertexCacheSize = size;
@@ -187,7 +187,7 @@ public final boolean isThreadBound() {
     }
 
     @Override
-    public final long getVertexCacheSize() {
+    public final int getVertexCacheSize() {
         return vertexCacheSize;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/TransactionConfiguration.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction;
 
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
 /**
  * Provides configuration options for {@link com.thinkaurelius.titan.core.TitanTransaction}.
@@ -98,7 +97,7 @@ public interface TransactionConfiguration {
      *
      * @return
      */
-    public long getVertexCacheSize();
+    public int getVertexCacheSize();
 
     /**
      * The maximum weight for the index cache store used in this particular transaction

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyVertex.java
Patch:
@@ -215,8 +215,7 @@ public long getID() {
 
     @Override
     public Object getId() {
-        if (hasId()) return Long.valueOf(getID());
-        else return null;
+        return hasId() ? getID() : null;
     }
 
     @Override

File: titan-hazelcast/src/main/java/com/thinkaurelius/titan/diskstorage/hazelcast/AbstractHazelcastStoreManager.java
Patch:
@@ -32,7 +32,7 @@ public AbstractHazelcastStoreManager(Configuration config) throws StorageExcepti
         manager = Hazelcast.newHazelcastInstance();
         storageConfig = new FileStorageConfiguration(directory);
         lockExpireMS = config.getLong(GraphDatabaseConfiguration.LOCK_EXPIRE_MS,
-                                      GraphDatabaseConfiguration.LOCK_EXPIRE_MS_DEFAULT);
+                GraphDatabaseConfiguration.LOCK_EXPIRE_MS_DEFAULT);
 
         if (transactional)
             logger.warn("Hazelcast does not support multiple transactions per thread");
@@ -75,6 +75,7 @@ private StoreFeatures getDefaultFeatures() {
         features.supportsOrderedScan = false;
         features.supportsUnorderedScan = true;
         features.supportsBatchMutation = false;
+        features.supportsMultiQuery = false;
 
         features.supportsTransactions = true;
         features.supportsConsistentKeyOperations = false;

File: titan-persistit/src/main/java/com/thinkaurelius/titan/diskstorage/persistit/PersistitStoreManager.java
Patch:
@@ -190,6 +190,7 @@ private StoreFeatures getDefaultFeatures() {
         features.supportsLocking = true;
         features.isKeyOrdered = true;
         features.hasLocalKeyPartition = false;
+        features.supportsMultiQuery = false;
 
         return features;
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/inmemory/InMemoryStorageAdapter.java
Patch:
@@ -123,6 +123,7 @@ public StoreFeatures getFeatures() {
         f.supportsUnorderedScan = true;
         f.supportsOrderedScan = true;
         f.supportsBatchMutation = true;
+        f.supportsMultiQuery = true;
 
         f.supportsTransactions = true;
         f.supportsConsistentKeyOperations = false;
@@ -166,7 +167,7 @@ public StaticBuffer next() {
         public void close() {
             // Do nothing
         }
-        
+
         @Override
         public void remove() {
             throw new UnsupportedOperationException("Can't remove element from empty iterator");

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/util/StorageFeaturesTest.java
Patch:
@@ -18,21 +18,22 @@ public void testFeaturesImplementation() {
             features = new StoreFeatures();
             features.supportsBatchMutation();
             fail();
-        } catch (IllegalArgumentException e) {
+        } catch (AssertionError e) {
         }
 
         try {
             features = new StoreFeatures();
             features.hasLocalKeyPartition = true;
             features.hasLocalKeyPartition();
             fail();
-        } catch (IllegalArgumentException e) {
+        } catch (AssertionError e) {
         }
         features = new StoreFeatures();
         features.supportsOrderedScan = false;
         features.supportsUnorderedScan = false;
         features.supportsBatchMutation = true;
         features.supportsTransactions = false;
+        features.supportsMultiQuery = false;
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;
         features.isKeyOrdered = false;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -212,12 +212,12 @@ public StoreFeatures getFeatures() {
 
                 case LOCAL:
                     features.supportsMultiQuery = true;
-                    features.hasLocalKeyPartition = true;
+                    features.hasLocalKeyPartition = features.isKeyOrdered;
                     break;
 
                 case EMBEDDED:
                     features.supportsMultiQuery = false;
-                    features.hasLocalKeyPartition = true;
+                    features.hasLocalKeyPartition = features.isKeyOrdered;
                     break;
 
                 default:

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/vertexcache/LRUVertexCache.java
Patch:
@@ -53,7 +53,8 @@ public InternalVertex get(long id, final Retriever<Long, InternalVertex> retriev
                 vertex = retriever.get(vertexId);
             }
 
-            cache.put(vertexId, vertex);
+            InternalVertex existingVertex = cache.putIfAbsent(vertexId, vertex);
+            if (existingVertex != null) vertex = existingVertex;
         }
 
         return vertex;
@@ -66,7 +67,7 @@ public void add(InternalVertex vertex, long id) {
 
         Long vertexId = id;
 
-        cache.put(vertexId, vertex);
+        cache.putIfAbsent(vertexId, vertex);
 
         if (vertex.isNew() || vertex.hasAddedRelations())
             volatileVertices.put(vertexId, vertex);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TransactionBuilder.java
Patch:
@@ -33,7 +33,7 @@ public interface TransactionBuilder {
      * @param size
      * @return
      */
-    public TransactionBuilder setCacheSize(long size);
+    public TransactionBuilder setCacheSize(int size);
 
     /**
      * Enables checks that verify that each vertex actually exists in the underlying data store when it is retrieved.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTransactionBuilder.java
Patch:
@@ -35,7 +35,7 @@ public class StandardTransactionBuilder implements TransactionConfiguration, Tra
 
     private boolean threadBound = false;
 
-    private long vertexCacheSize;
+    private int vertexCacheSize;
 
     private long indexCacheWeight;
 
@@ -95,7 +95,7 @@ public StandardTransactionBuilder enableBatchLoading() {
     }
 
     @Override
-    public StandardTransactionBuilder setCacheSize(long size) {
+    public StandardTransactionBuilder setCacheSize(int size) {
         verifyOpen();
         Preconditions.checkArgument(size >= 0);
         this.vertexCacheSize = size;
@@ -187,7 +187,7 @@ public final boolean isThreadBound() {
     }
 
     @Override
-    public final long getVertexCacheSize() {
+    public final int getVertexCacheSize() {
         return vertexCacheSize;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/TransactionConfiguration.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.transaction;
 
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
-import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
 /**
  * Provides configuration options for {@link com.thinkaurelius.titan.core.TitanTransaction}.
@@ -98,7 +97,7 @@ public interface TransactionConfiguration {
      *
      * @return
      */
-    public long getVertexCacheSize();
+    public int getVertexCacheSize();
 
     /**
      * The maximum weight for the index cache store used in this particular transaction

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanMultiVertexQuery.java
Patch:
@@ -47,6 +47,9 @@ public interface TitanMultiVertexQuery extends BaseVertexQuery {
     @Override
     public TitanMultiVertexQuery types(TitanType... type);
 
+    @Override
+    public TitanMultiVertexQuery keys(String... keys);
+
     @Override
     public TitanMultiVertexQuery direction(Direction d);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanVertexQuery.java
Patch:
@@ -30,6 +30,9 @@ public interface TitanVertexQuery extends BaseVertexQuery, VertexQuery {
     @Override
     public TitanVertexQuery labels(String... labels);
 
+    @Override
+    public TitanVertexQuery keys(String... keys);
+
     @Override
     public TitanVertexQuery types(TitanType... type);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -83,7 +83,7 @@ public long[] getIDBlock(int partition) throws StorageException {
         for (int retry = 0; retry < idApplicationRetryCount; retry++) {
             StoreTransaction txh = null;
             try {
-                txh = manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.KEY_CONSISTENT));
+                txh = manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.KEY_CONSISTENT, metricsPrefix));
                 // Read the latest counter values from the idStore
                 StaticBuffer partitionKey = getPartitionKey(partition);
                 // calculate the start (inclusive) and end (exclusive) of the allocation we're about to attempt

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/TransactionalIDManager.java
Patch:
@@ -46,7 +46,7 @@ public long[] getIDBlock(int partition) throws StorageException {
         for (int retry = 0; retry < idApplicationRetryCount; retry++) {
             StoreTransaction txh = null;
             try {
-                txh = manager.beginTransaction(new StoreTxConfig());
+                txh = manager.beginTransaction(new StoreTxConfig(metricsPrefix));
                 long current = getCurrentID(partitionKey, txh);
                 Preconditions.checkArgument(Long.MAX_VALUE - blockSize > current, "ID overflow detected");
                 long next = current + blockSize;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/CachedKeyColumnValueStore.java
Patch:
@@ -30,7 +30,7 @@ public class CachedKeyColumnValueStore implements KeyColumnValueStore {
 
     private static final Logger log = LoggerFactory.getLogger(CachedKeyColumnValueStore.class);
 
-    private static final long DEFAULT_CACHE_SIZE = 100000;
+    private static final long DEFAULT_CACHE_SIZE = 1000;
 
     private final KeyColumnValueStore store;
     private final Cache<KeySliceQuery, List<Entry>> cache;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -66,14 +66,12 @@ public class StandardTitanGraph extends TitanBlueprintsGraph {
 
     public final SliceQuery vertexExistenceQuery;
 
-
     public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
         this.config = configuration;
         this.backend = configuration.getBackend();
         this.maxWriteRetryAttempts = config.getWriteAttempts();
         this.retryStorageWaitTime = config.getStorageWaittime();
 
-
         this.idAssigner = config.getIDAssigner(backend);
         this.idManager = idAssigner.getIDManager();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/CachedKeyColumnValueStore.java
Patch:
@@ -30,7 +30,7 @@ public class CachedKeyColumnValueStore implements KeyColumnValueStore {
 
     private static final Logger log = LoggerFactory.getLogger(CachedKeyColumnValueStore.class);
 
-    private static final long DEFAULT_CACHE_SIZE = 100000;
+    private static final long DEFAULT_CACHE_SIZE = 1000;
 
     private final KeyColumnValueStore store;
     private final Cache<KeySliceQuery, List<Entry>> cache;

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -49,7 +49,7 @@ public class HBaseStoreManager extends DistributedStoreManager implements KeyCol
     public static final String TABLE_NAME_DEFAULT = "titan";
     
     public static final String SHORT_CF_NAMES_KEY = "short-cf-names";
-    public static final boolean SHORT_CF_NAMES_DEFAULT = false;
+    public static final boolean SHORT_CF_NAMES_DEFAULT = true;
 
     public static final int PORT_DEFAULT = 9160;
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -136,7 +136,7 @@ public HBaseStoreManager(org.apache.commons.configuration.Configuration config)
         features.supportsTransactions = false;
         features.supportsConsistentKeyOperations = true;
         features.supportsLocking = false;
-        features.isKeyOrdered = false;
+        features.isKeyOrdered = true;
         features.isDistributed = true;
         features.hasLocalKeyPartition = false;
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -5,6 +5,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
+import com.google.common.collect.Sets;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.internal.InternalType;
@@ -1126,7 +1127,7 @@ public void testQuery() {
         Map<TitanVertex, Iterable<TitanProperty>> results2;
         results = tx.multiQuery(qvs).direction(IN).labels("connect").titanEdges();
         for (Iterable<TitanEdge> result : results.values()) assertEquals(1, Iterables.size(result));
-        results = tx.multiQuery(qvs).labels("connect").titanEdges();
+        results = tx.multiQuery(Sets.newHashSet(qvs)).labels("connect").titanEdges();
         for (Iterable<TitanEdge> result : results.values()) assertEquals(1, Iterables.size(result));
         results = tx.multiQuery(qvs).labels("knows").titanEdges();
         for (Iterable<TitanEdge> result : results.values()) assertEquals(0, Iterables.size(result));
@@ -1196,7 +1197,7 @@ public void testQuery() {
         qvs = qvs2;
         results = tx.multiQuery(qvs).direction(IN).labels("connect").titanEdges();
         for (Iterable<TitanEdge> result : results.values()) assertEquals(1, Iterables.size(result));
-        results = tx.multiQuery(qvs).labels("connect").titanEdges();
+        results = tx.multiQuery(Sets.newHashSet(qvs)).labels("connect").titanEdges();
         for (Iterable<TitanEdge> result : results.values()) assertEquals(1, Iterables.size(result));
         results = tx.multiQuery(qvs).labels("knows").titanEdges();
         for (Iterable<TitanEdge> result : results.values()) assertEquals(0, Iterables.size(result));

File: titan-hbase/src/test/java/com/thinkaurelius/titan/HBaseStorageSetup.java
Patch:
@@ -15,7 +15,7 @@ public class HBaseStorageSetup {
     private static final int SHUTDOWN_TIMEOUT_SEC = 20;
 
     // hbase config for testing
-    private static final String HBASE_CONFIG_DIR = "./src/test/config";
+    private static final String HBASE_CONFIG_DIR = "./conf";
 
     // default pid file location
     private static final String HBASE_PID_FILE = "/tmp/hbase-" + System.getProperty("user.name") + "-master.pid";
@@ -25,8 +25,8 @@ public class HBaseStorageSetup {
             System.out.println("Deleteing old test directories (if any).");
 
             // please keep in sync with HBASE_CONFIG_DIR/hbase-site.xml, reading HBase XML config is huge pain.
-            File hbaseRoot = new File("./src/test/titan-hbase-test-data");
-            File zookeeperDataDir = new File("./src/test/titan-zookeeper-test");
+            File hbaseRoot = new File("./target/hbase-root");
+            File zookeeperDataDir = new File("./target/zk-data");
 
             if (hbaseRoot.exists())
                 FileUtils.deleteDirectory(hbaseRoot);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanMultiVertexQuery.java
Patch:
@@ -47,6 +47,9 @@ public interface TitanMultiVertexQuery extends BaseVertexQuery {
     @Override
     public TitanMultiVertexQuery types(TitanType... type);
 
+    @Override
+    public TitanMultiVertexQuery keys(String... keys);
+
     @Override
     public TitanMultiVertexQuery direction(Direction d);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanVertexQuery.java
Patch:
@@ -30,6 +30,9 @@ public interface TitanVertexQuery extends BaseVertexQuery, VertexQuery {
     @Override
     public TitanVertexQuery labels(String... labels);
 
+    @Override
+    public TitanVertexQuery keys(String... keys);
+
     @Override
     public TitanVertexQuery types(TitanType... type);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -333,7 +333,7 @@ public class GraphDatabaseConfiguration {
      * methods using the {@code com.codahale.metrics} package.
      */
     public static final String BASIC_METRICS = "enable-basic-metrics";
-    public static final boolean BASIC_METRICS_DEFAULT = true;
+    public static final boolean BASIC_METRICS_DEFAULT = false;
     
     
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -83,7 +83,7 @@ public long[] getIDBlock(int partition) throws StorageException {
         for (int retry = 0; retry < idApplicationRetryCount; retry++) {
             StoreTransaction txh = null;
             try {
-                txh = manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.KEY_CONSISTENT)); // TODO honor configured metrics prefix
+                txh = manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.KEY_CONSISTENT, metricsPrefix));
                 // Read the latest counter values from the idStore
                 StaticBuffer partitionKey = getPartitionKey(partition);
                 // calculate the start (inclusive) and end (exclusive) of the allocation we're about to attempt

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/TransactionalIDManager.java
Patch:
@@ -46,7 +46,7 @@ public long[] getIDBlock(int partition) throws StorageException {
         for (int retry = 0; retry < idApplicationRetryCount; retry++) {
             StoreTransaction txh = null;
             try {
-                txh = manager.beginTransaction(new StoreTxConfig()); // TODO honor configured metrics prefix
+                txh = manager.beginTransaction(new StoreTxConfig(metricsPrefix));
                 long current = getCurrentID(partitionKey, txh);
                 Preconditions.checkArgument(Long.MAX_VALUE - blockSize > current, "ID overflow detected");
                 long next = current + blockSize;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/MetricInstrumentedStore.java
Patch:
@@ -120,7 +120,6 @@ public List<List<Entry>> call() throws StorageException {
                     for (List<Entry> result : results) {
                         recordSliceMetrics(p, result);
                     }
-    
                     return results;
                 }
             }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/MetricInstrumentedStore.java
Patch:
@@ -165,7 +165,7 @@ public KeyIterator getKeys(final KeyRangeQuery query, final StoreTransaction txh
                 public KeyIterator call() throws StorageException {
                     KeyIterator ki = backend.getKeys(query, txh);
                     if (null != p) {
-                        return MetricInstrumentedIterator.of(ki, p + "." + M_ITERATOR);
+                        return MetricInstrumentedIterator.of(ki, p + "." + M_GET_KEYS + "." + M_ITERATOR);
                     } else {
                         return ki;
                     }
@@ -182,7 +182,7 @@ public KeyIterator getKeys(final SliceQuery query, final StoreTransaction txh) t
                 public KeyIterator call() throws StorageException {
                     KeyIterator ki = backend.getKeys(query, txh);
                     if (null != p) {
-                        return MetricInstrumentedIterator.of(ki, p + "." + M_ITERATOR);
+                        return MetricInstrumentedIterator.of(ki, p + "." + M_GET_KEYS + "." + M_ITERATOR);
                     } else {
                         return ki;
                     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -790,8 +790,8 @@ private void configureMetricsGraphiteReporter(Configuration conf) {
         if (null == graphite)
             return;
         
-        final String host = graphite.getString(GRAPHITE_HOST);
-        final Long ms = graphite.getLong(GRAPHITE_INTERVAL);
+        final String host = graphite.getString(GRAPHITE_HOST, null);
+        final Long ms = graphite.getLong(GRAPHITE_INTERVAL, null);
         
         if (null == host || null == ms) {
             return;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -83,7 +83,7 @@ public long[] getIDBlock(int partition) throws StorageException {
         for (int retry = 0; retry < idApplicationRetryCount; retry++) {
             StoreTransaction txh = null;
             try {
-                txh = manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.KEY_CONSISTENT));
+                txh = manager.beginTransaction(new StoreTxConfig(ConsistencyLevel.KEY_CONSISTENT)); // TODO honor configured metrics prefix
                 // Read the latest counter values from the idStore
                 StaticBuffer partitionKey = getPartitionKey(partition);
                 // calculate the start (inclusive) and end (exclusive) of the allocation we're about to attempt

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/TransactionalIDManager.java
Patch:
@@ -46,7 +46,7 @@ public long[] getIDBlock(int partition) throws StorageException {
         for (int retry = 0; retry < idApplicationRetryCount; retry++) {
             StoreTransaction txh = null;
             try {
-                txh = manager.beginTransaction(new StoreTxConfig());
+                txh = manager.beginTransaction(new StoreTxConfig()); // TODO honor configured metrics prefix
                 long current = getCurrentID(partitionKey, txh);
                 Preconditions.checkArgument(Long.MAX_VALUE - blockSize > current, "ID overflow detected");
                 long next = current + blockSize;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -66,14 +66,12 @@ public class StandardTitanGraph extends TitanBlueprintsGraph {
 
     public final SliceQuery vertexExistenceQuery;
 
-
     public StandardTitanGraph(GraphDatabaseConfiguration configuration) {
         this.config = configuration;
         this.backend = configuration.getBackend();
         this.maxWriteRetryAttempts = config.getWriteAttempts();
         this.retryStorageWaitTime = config.getStorageWaittime();
 
-
         this.idAssigner = config.getIDAssigner(backend);
         this.idManager = idAssigner.getIDManager();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/util/stats/MetricManager.java
Patch:
@@ -327,7 +327,6 @@ public synchronized void addGraphiteReporter(String host, int port,
         
         Preconditions.checkNotNull(host);
         
-
         Graphite graphite = new Graphite(new InetSocketAddress(host, port));
 
         GraphiteReporter.Builder b = GraphiteReporter
@@ -340,6 +339,8 @@ public synchronized void addGraphiteReporter(String host, int port,
 
         graphiteReporter = b.build(graphite);
         graphiteReporter.start(reportIntervalInMS, TimeUnit.MILLISECONDS);
+        log.info("Configured Graphite reporter host={} interval={}ms port={} prefix={}",
+                new Object[] { host, reportIntervalInMS, port, prefix });
     }
     
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -857,12 +857,12 @@ public Iterator<TitanElement> execute(final GraphCentricQuery query, final Joint
                     retrievals.add(new QueryUtil.IndexCall<Object>() {
                         @Override
                         public Collection<Object> call(int limit) {
-                            IndexQuery adjustedQuery = subquery.updateLimit(limit);
+                            final IndexQuery adjustedQuery = subquery.updateLimit(limit);
                             try {
-                                return indexCache.get(subquery, new Callable<List<Object>>() {
+                                return indexCache.get(adjustedQuery, new Callable<List<Object>>() {
                                     @Override
                                     public List<Object> call() throws Exception {
-                                        return indexSerializer.query(index, subquery, txHandle);
+                                        return indexSerializer.query(index, adjustedQuery, txHandle);
                                     }
                                 });
                             } catch (Exception e) {

File: titan-dist/titan-dist-hazelcast/src/test/java/com/thinkaurelius/titan/pkgtest/HazelcastAssemblyIT.java
Patch:
@@ -6,6 +6,6 @@ public class HazelcastAssemblyIT extends AssemblyITSupport {
     
     @Test
     public void testHazelcastSimpleSession() throws Exception {
-        testSimpleGremlinSession("conf/titan-hazelcast.properties", "hazelcastcache");
+        testSimpleGremlinSession("conf/titan-hazelcastcache.properties", "hazelcastcache");
     }
 }
\ No newline at end of file

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -141,9 +141,10 @@ public ElasticSearchIndex(Configuration config) {
                 Preconditions.checkArgument(StringUtils.isNotBlank(clustername), "Invalid cluster name: %s", clustername);
                 settings.put("cluster.name", clustername);
             } else {
-                settings.put("client.transport.ignore_cluster_name", config.getBoolean(CLIENT_SNIFF_KEY, CLIENT_SNIFF_DEFAULT));
+                settings.put("client.transport.ignore_cluster_name", true);
             }
-            settings.put("client.transport.sniff", true);
+            log.debug("Transport sniffing enabled: {}", config.getBoolean(CLIENT_SNIFF_KEY, CLIENT_SNIFF_DEFAULT));
+            settings.put("client.transport.sniff", config.getBoolean(CLIENT_SNIFF_KEY, CLIENT_SNIFF_DEFAULT));
             TransportClient tc = new TransportClient(settings.build());
             for (String host : config.getStringArray(GraphDatabaseConfiguration.HOSTNAME_KEY)) {
                 String[] hostparts = host.split(":");

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -81,6 +81,8 @@ public class ElasticSearchIndex implements IndexProvider {
     public static final String INDEX_NAME_DEFAULT = "titan";
     public static final String LOCAL_MODE_KEY = "local-mode";
     public static final boolean LOCAL_MODE_DEFAULT = false;
+    public static final String CLIENT_SNIFF_KEY = "sniff";
+    public static final boolean CLIENT_SNIFF_DEFAULT = true;
 
     //    public static final String HOST_NAMES_KEY = "hosts";
     public static final int HOST_PORT_DEFAULT = 9300;
@@ -139,7 +141,7 @@ public ElasticSearchIndex(Configuration config) {
                 Preconditions.checkArgument(StringUtils.isNotBlank(clustername), "Invalid cluster name: %s", clustername);
                 settings.put("cluster.name", clustername);
             } else {
-                settings.put("client.transport.ignore_cluster_name", true);
+                settings.put("client.transport.ignore_cluster_name", config.getBoolean(CLIENT_SNIFF_KEY, CLIENT_SNIFF_DEFAULT));
             }
             settings.put("client.transport.sniff", true);
             TransportClient tc = new TransportClient(settings.build());

File: src/main/java/com/thinkaurelius/faunus/formats/titan/SchemaInferencerMapReduce.java
Patch:
@@ -88,12 +88,13 @@ public void reduce(final LongWritable key, final Iterable<FaunusVertex> value, f
                             if (null == graph.getType(property2)) {
                                 // TODO: Automated type inference
                                 // typeMaker.makeKey(property2, graph.makeType().dataType(Class.forName(vertex.getProperty(property).toString())));
-                                typeMaker.makeKey(property2, graph.makeType());
+                                typeMaker.makeKey(graph.makeKey(property2));
                                 context.getCounter(Counters.PROPERTY_KEYS_CREATED).increment(1l);
                             }
                         } else {
                             if (null == graph.getType(property2)) {
-                                typeMaker.makeLabel(property2, graph.makeType());
+                                //typeMaker.makeLabel(property2, graph.makeType());
+                                typeMaker.makeLabel(graph.makeLabel(property2));
                                 context.getCounter(Counters.EDGE_LABELS_CREATED).increment(1l);
                             }
                         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsTransaction.java
Patch:
@@ -187,12 +187,12 @@ public <T extends Element> void createKeyIndex(String key, Class<T> elementClass
             if (!indexesCovered)
                 throw new UnsupportedOperationException("Cannot add an index to an already existing property key: " + type.getName());
         } else {
-            TypeMaker tm = makeType().name(key).dataType(Object.class);
+            KeyMaker tm = makeKey(key).dataType(Object.class);
             for (Parameter p : indexParameters) {
                 Preconditions.checkArgument(p.getKey() instanceof String, "Invalid index argument: " + p);
                 tm.indexed((String) p.getKey(), elementClass);
             }
-            tm.makePropertyKey();
+            tm.make();
         }
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TitanGraphQueryTestSuite.java
Patch:
@@ -21,7 +21,7 @@ public TitanGraphQueryTestSuite(final GraphTest graphTest) {
     public void testGraphQueryForVertices() {
         TitanGraph g = (TitanGraph) graphTest.generateGraph();
         if (g.getType("age") == null) {
-            TitanKey age = g.makeType().name("age").dataType(Integer.class).vertexUnique(Direction.OUT).makePropertyKey();
+            TitanKey age = g.makeKey("age").dataType(Integer.class).single().make();
         }
         g.shutdown();
         super.testGraphQueryForVertices();
@@ -31,7 +31,7 @@ public void testGraphQueryForVertices() {
     public void testGraphQueryForEdges() {
         TitanGraph g = (TitanGraph) graphTest.generateGraph();
         if (g.getType("weight") == null) {
-            TitanKey weight = g.makeType().name("weight").dataType(Double.class).vertexUnique(Direction.OUT).makePropertyKey();
+            TitanKey weight = g.makeKey("weight").dataType(Double.class).single().make();
         }
         g.shutdown();
         super.testGraphQueryForEdges();

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanEventualGraphTest.java
Patch:
@@ -30,8 +30,8 @@ public TitanEventualGraphTest(Configuration config) {
 
     @Test
     public void concurrentIndexTest() {
-        TitanKey id = tx.makeType().name("uid").vertexUnique(Direction.OUT).graphUnique().indexed(Vertex.class).dataType(String.class).makePropertyKey();
-        TitanKey value = tx.makeType().name("value").vertexUnique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Object.class).indexed(Vertex.class).makePropertyKey();
+        TitanKey id = tx.makeKey("uid").single().unique().indexed(Vertex.class).dataType(String.class).make();
+        TitanKey value = tx.makeKey("value").single(TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Object.class).indexed(Vertex.class).make();
 
         TitanVertex v = tx.addVertex();
         v.setProperty(id, "v");

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyDBjeKeyColumnValueTest.java
Patch:
@@ -13,8 +13,7 @@ public class BerkeleyDBjeKeyColumnValueTest extends KeyColumnValueStoreTest {
 
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
         BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(BerkeleyJeStorageSetup.getBerkeleyJEStorageConfiguration());
-        OrderedKeyValueStoreManagerAdapter smadapter = new OrderedKeyValueStoreManagerAdapter(sm, ImmutableMap.of(storeName, 8));
-        return smadapter;
+        return new OrderedKeyValueStoreManagerAdapter(sm, ImmutableMap.of(storeName, 8));
     }
 
     @Test

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/common/LocalStoreManager.java
Patch:
@@ -25,7 +25,5 @@ public LocalStoreManager(Configuration storageConfig) throws StorageException {
         String storageDir = storageConfig.getString(STORAGE_DIRECTORY_KEY);
         Preconditions.checkArgument(storageDir != null, "Need to specify storage directory");
         directory = DirectoryUtil.getOrCreateDataDirectory(storageDir);
-
-
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/HashPrefixKeyColumnValueStore.java
Patch:
@@ -91,7 +91,7 @@ public void acquireLock(StaticBuffer key, StaticBuffer column, StaticBuffer expe
 
     @Override
     public KeyIterator getKeys(KeyRangeQuery keyQuery, StoreTransaction txh) throws StorageException {
-        throw new UnsupportedOperationException("getKeys(KeyRangeQuery) is not supported in hash prefixed mode.");
+        throw new UnsupportedOperationException("getKeys(KeyRangeQuery, StoreTransaction) is not supported in hash prefixed mode.");
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/ReadOnlyKeyColumnValueStore.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
 import java.util.List;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreManagerAdapter.java
Patch:
@@ -31,13 +31,15 @@ public OrderedKeyValueStoreManagerAdapter(OrderedKeyValueStoreManager manager) {
     }
 
     public OrderedKeyValueStoreManagerAdapter(OrderedKeyValueStoreManager manager, Map<String, Integer> keyLengths) {
+        Preconditions.checkArgument(manager.getFeatures().isKeyOrdered(), "Expected backing store to be ordered: %s", manager);
         this.manager = manager;
         ImmutableMap.Builder<String, Integer> mb = ImmutableMap.builder();
         if (keyLengths != null && !keyLengths.isEmpty()) mb.putAll(keyLengths);
         this.keyLengths = mb.build();
         this.stores = new HashMap<String, OrderedKeyValueStoreAdapter>();
     }
 
+    @Override
     public StoreFeatures getFeatures() {
         return manager.getFeatures();
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStore.java
Patch:
@@ -7,7 +7,6 @@
 import com.thinkaurelius.titan.diskstorage.locking.Locker;
 import com.thinkaurelius.titan.diskstorage.locking.PermanentLockingException;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
-import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/transactional/TransactionalLockStore.java
Patch:
@@ -3,7 +3,6 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
-import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
 import java.util.List;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/ByteBufferUtil.java
Patch:
@@ -205,7 +205,7 @@ public static final int compare(byte c1, byte c2) {
         } else return 0;
     }
 
-    public static final int compare(StaticBuffer b1, StaticBuffer b2) {
+    public static int compare(StaticBuffer b1, StaticBuffer b2) {
         if (b1 == b2) {
             return 0;
         }

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseKeyColumnValueStore.java
Patch:
@@ -336,7 +336,6 @@ public boolean hasNext() {
                 @Override
                 public Entry next() {
                     ensureOpen();
-
                     Map.Entry<byte[], byte[]> column = kv.next();
                     return StaticBufferEntry.of(new StaticArrayBuffer(column.getKey()), new StaticArrayBuffer(column.getValue()));
                 }

File: titan-es/src/test/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndexTest.java
Patch:
@@ -47,13 +47,14 @@ public void testSupport() {
         assertFalse(index.supports(Object.class));
         assertFalse(index.supports(Exception.class));
 
+        assertTrue(index.supports(String.class, Text.PREFIX));
         assertTrue(index.supports(String.class, Text.CONTAINS));
+        assertTrue(index.supports(String.class, Text.REGEX));
         assertTrue(index.supports(Double.class, Cmp.EQUAL));
         assertTrue(index.supports(Double.class, Cmp.GREATER_THAN_EQUAL));
         assertTrue(index.supports(Double.class, Cmp.LESS_THAN));
         assertTrue(index.supports(Geoshape.class, Geo.WITHIN));
 
-        assertFalse(index.supports(String.class, Text.PREFIX));
         assertFalse(index.supports(Double.class, Geo.INTERSECT));
         assertFalse(index.supports(Long.class, Text.CONTAINS));
         assertFalse(index.supports(Geoshape.class, Geo.DISJOINT));

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneIndexTest.java
Patch:
@@ -41,12 +41,13 @@ public void testSupport() {
         assertFalse(index.supports(Exception.class));
 
         assertTrue(index.supports(String.class, Text.CONTAINS));
+        assertTrue(index.supports(String.class, Text.PREFIX));
+        assertFalse(index.supports(String.class, Text.REGEX));
         assertTrue(index.supports(Double.class, Cmp.EQUAL));
         assertTrue(index.supports(Double.class, Cmp.GREATER_THAN_EQUAL));
         assertTrue(index.supports(Double.class, Cmp.LESS_THAN));
         assertTrue(index.supports(Geoshape.class, Geo.WITHIN));
 
-        assertFalse(index.supports(String.class, Text.PREFIX));
         assertFalse(index.supports(Double.class, Geo.INTERSECT));
         assertFalse(index.supports(Long.class, Text.CONTAINS));
         assertFalse(index.supports(Geoshape.class, Geo.DISJOINT));

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexQuery.java
Patch:
@@ -43,7 +43,7 @@ public ElementType getResultType() {
     }
 
     public String getStore() {
-        return resultType.toString();
+        return resultType.toString().toLowerCase();
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -256,7 +256,9 @@ public static <R> List<R> processIntersectingRetrievals(List<IndexCall<R>> retri
                 } else {
                     Set<R> subresultset = ImmutableSet.copyOf(subresult);
                     Iterator riter = results.iterator();
-                    while (riter.hasNext()) if (subresultset.contains(riter.next())) riter.remove();
+                    while (riter.hasNext()) {
+                        if (!subresultset.contains(riter.next())) riter.remove();
+                    }
                 }
             }
             sublimit = (int) Math.min(Integer.MAX_VALUE - 1, Math.pow(sublimit, 1.5));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -877,7 +877,7 @@ public Iterator<TitanElement> execute(final GraphCentricQuery query, final Index
                         public Collection<Object> call(int limit) {
                             final IndexQuery subquery = new IndexQuery(indexQuery.getResultType(), matchingCond).setLimit(limit);
                             try {
-                                return indexCache.get(indexQuery, new Callable<List<Object>>() {
+                                return indexCache.get(subquery, new Callable<List<Object>>() {
                                     @Override
                                     public List<Object> call() throws Exception {
                                         return indexSerializer.query(bestIndex, subquery, txHandle);
@@ -890,7 +890,7 @@ public List<Object> call() throws Exception {
                     });
                 }
 
-                List<Object> resultSet = QueryUtil.processIntersectingRetrievals(retrievals, query.getLimit());
+                List<Object> resultSet = QueryUtil.processIntersectingRetrievals(retrievals, indexQuery.getLimit());
                 iter = Iterators.transform(resultSet.iterator(), new Function<Object, TitanElement>() {
                     @Nullable
                     @Override

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraTransaction.java
Patch:
@@ -96,7 +96,8 @@ public Consistency getWriteConsistencyLevel() {
     }
 
     public static CassandraTransaction getTx(StoreTransaction txh) {
-        Preconditions.checkArgument(txh != null && (txh instanceof CassandraTransaction));
+        Preconditions.checkArgument(txh != null);
+        Preconditions.checkArgument(txh instanceof CassandraTransaction, "Unexpected transaction type %s", txh.getClass().getName());
         return (CassandraTransaction) txh;
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/EmbeddedCassandraBlueprintsTest.java
Patch:
@@ -8,14 +8,12 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraEmbeddedStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 import com.tinkerpop.blueprints.Graph;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-@Category({RandomPartitionerTests.class})
 public class EmbeddedCassandraBlueprintsTest extends TitanBlueprintsTest {
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/InternalCassandraBlueprintsTest.java
Patch:
@@ -9,22 +9,20 @@
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.cassandra.thrift.CassandraThriftStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 import com.tinkerpop.blueprints.Graph;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-@Category({RandomPartitionerTests.class})
 public class InternalCassandraBlueprintsTest extends TitanBlueprintsTest {
 
     private static boolean isStartedUp = false;
 
     @Override
     public synchronized void startUp() {
         if (!isStartedUp) {
-            CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+            CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
             isStartedUp = true;
         }
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraProcessStarter.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.cassandra;
 
+import com.google.common.base.Joiner;
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.core.TitanException;
 import com.thinkaurelius.titan.diskstorage.StorageException;
@@ -8,6 +9,7 @@
 import com.thinkaurelius.titan.diskstorage.cassandra.thrift.thriftpool.CTConnection;
 import com.thinkaurelius.titan.diskstorage.cassandra.thrift.thriftpool.CTConnectionFactory;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
+
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.lang.StringUtils;
 import org.apache.thrift.transport.TTransportException;
@@ -220,7 +222,7 @@ public static synchronized void startCleanEmbedded(String cassandraYamlPath) {
         }
         
         try {
-            FileUtils.deleteDirectory(new File(CassandraStorageSetup.CASSANDRA_TEMP_PATH + File.separator + "workdir"));
+            FileUtils.deleteDirectory(new File(CassandraStorageSetup.DATA_PATH));
         } catch (IOException e) {
             throw new RuntimeException(e);
         }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -9,14 +9,12 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 
-@Category({RandomPartitionerTests.class})
 public class InternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxMultiWriteKeyColumnValueTest.java
Patch:
@@ -9,14 +9,12 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 
-@Category({RandomPartitionerTests.class})
 public class InternalAstyanaxMultiWriteKeyColumnValueTest extends MultiWriteKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/InternalCassandraEmbeddedLockKeyColumnValueStoreTest.java
Patch:
@@ -7,14 +7,12 @@
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.testcategory.ByteOrderedPartitionerTests;
 
-@Category({ByteOrderedPartitionerTests.class})
 public class InternalCassandraEmbeddedLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 
     @Override
     public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
-        Configuration sc = CassandraStorageSetup.getEmbeddedCassandraStorageConfiguration(getClass().getSimpleName(), true);
+        Configuration sc = CassandraStorageSetup.getEmbeddedCassandraStorageConfiguration(getClass().getSimpleName());
         return new CassandraEmbeddedStoreManager(sc);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/InternalCassandraEmbeddedMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -7,14 +7,12 @@
 import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.testcategory.ByteOrderedPartitionerTests;
 
-@Category({ByteOrderedPartitionerTests.class})
 public class InternalCassandraEmbeddedMultiWriteKeyColumnValueStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        Configuration config = CassandraStorageSetup.getEmbeddedCassandraStorageConfiguration(getClass().getSimpleName(), true);
+        Configuration config = CassandraStorageSetup.getEmbeddedCassandraStorageConfiguration(getClass().getSimpleName());
         return new CassandraEmbeddedStoreManager(config);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/InternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -9,14 +9,12 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 
-@Category({RandomPartitionerTests.class})
 public class InternalCassandraLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/InternalCassandraThriftMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -5,18 +5,16 @@
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 
 import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
-@Category({RandomPartitionerTests.class})
 public class InternalCassandraThriftMultiWriteKeyColumnValueStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphConcurrentTest.java
Patch:
@@ -13,7 +13,7 @@ public class InternalAstyanaxGraphConcurrentTest extends TitanGraphConcurrentTes
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 
     public InternalAstyanaxGraphConcurrentTest() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphTest.java
Patch:
@@ -3,17 +3,15 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
-@Category({RandomPartitionerTests.class})
 public class InternalAstyanaxGraphTest extends TitanGraphTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 
     public InternalAstyanaxGraphTest() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/InternalCassandraEmbeddedGraphTest.java
Patch:
@@ -4,9 +4,7 @@
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
-import com.thinkaurelius.titan.testcategory.ByteOrderedPartitionerTests;
 
-@Category({ByteOrderedPartitionerTests.class})
 public class InternalCassandraEmbeddedGraphTest extends TitanGraphTest {
 
     public InternalCassandraEmbeddedGraphTest() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraEventualGraphTest.java
Patch:
@@ -4,11 +4,9 @@
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.graphdb.TitanEventualGraphTest;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
-@Category({RandomPartitionerTests.class})
 public class InternalCassandraEventualGraphTest extends TitanEventualGraphTest {
 
     public InternalCassandraEventualGraphTest() {
@@ -17,6 +15,6 @@ public InternalCassandraEventualGraphTest() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphConcurrentTest.java
Patch:
@@ -17,6 +17,6 @@ public InternalCassandraGraphConcurrentTest() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphSerialSpeedTest.java
Patch:
@@ -24,7 +24,7 @@ public InternalCassandraGraphSerialSpeedTest() throws StorageException {
     
     @BeforeClass
     public static void beforeClass() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
     
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphTest.java
Patch:
@@ -3,12 +3,10 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
-import com.thinkaurelius.titan.testcategory.RandomPartitionerTests;
 
 import org.junit.BeforeClass;
 import org.junit.experimental.categories.Category;
 
-@Category({RandomPartitionerTests.class})
 public class InternalCassandraGraphTest extends TitanGraphTest {
 
     public InternalCassandraGraphTest() {
@@ -17,6 +15,6 @@ public InternalCassandraGraphTest() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.YAML_PATH);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/BufferedKeyColumnValueStore.java
Patch:
@@ -62,12 +62,12 @@ public void acquireLock(StaticBuffer key, StaticBuffer column, StaticBuffer expe
 
     @Override
     public KeyIterator getKeys(KeyRangeQuery keyQuery, StoreTransaction txh) throws StorageException {
-        return store.getKeys(keyQuery, txh);
+        return store.getKeys(keyQuery, getTx(txh));
     }
 
     @Override
     public KeyIterator getKeys(SliceQuery columnQuery, StoreTransaction txh) throws StorageException {
-        return store.getKeys(columnQuery, txh);
+        return store.getKeys(columnQuery, getTx(txh));
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStore.java
Patch:
@@ -134,12 +134,12 @@ public void acquireLock(StaticBuffer key, StaticBuffer column, StaticBuffer expe
 
     @Override
     public KeyIterator getKeys(KeyRangeQuery query, StoreTransaction txh) throws StorageException {
-        return dataStore.getKeys(query, txh);
+        return dataStore.getKeys(query, getBaseTx(txh));
     }
 
     @Override
     public KeyIterator getKeys(SliceQuery query, StoreTransaction txh) throws StorageException {
-        return dataStore.getKeys(query, txh);
+        return dataStore.getKeys(query, getBaseTx(txh));
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/testcategory/KeyOrderAgnosticTests.java
Patch:
@@ -0,0 +1,3 @@
+package com.thinkaurelius.titan.testcategory;
+
+public interface KeyOrderAgnosticTests { }

File: titan-test/src/main/java/com/thinkaurelius/titan/testcategory/MemoryTests.java
Patch:
@@ -8,4 +8,4 @@
  * If you rename or move this class, then you must also update mentions of it in
  * the Titan root pom.xml.
  */
-public class MemoryTests { }
+public interface MemoryTests { }

File: titan-test/src/main/java/com/thinkaurelius/titan/testcategory/OrderedKeyStoreTests.java
Patch:
@@ -0,0 +1,3 @@
+package com.thinkaurelius.titan.testcategory;
+
+public interface OrderedKeyStoreTests { }

File: titan-test/src/main/java/com/thinkaurelius/titan/testcategory/PerformanceTests.java
Patch:
@@ -8,4 +8,4 @@
  * If you rename or move this class, then you must also update mentions of it in
  * the Titan root pom.xml.
  */
-public class PerformanceTests { }
+public interface PerformanceTests { }

File: titan-test/src/main/java/com/thinkaurelius/titan/testcategory/UnorderedKeyStoreTests.java
Patch:
@@ -0,0 +1,3 @@
+package com.thinkaurelius.titan.testcategory;
+
+public interface UnorderedKeyStoreTests { }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -55,14 +55,14 @@ public static Partitioner getPartitioner(String className) {
      * for operation are created. If this flag is set to "true" Snappy
      * compression mechanism would be used.  Default is "true" (see DEFAULT_COMPRESSION_FLAG).
      */
-    public static final String ENABLE_COMPRESSION_KEY = "cassandra.db.compression.enabled";
+    public static final String ENABLE_COMPRESSION_KEY = "compression.enabled";
     public static final boolean DEFAULT_COMPRESSION_FLAG = true;
 
     /**
      * This property allows to set appropriate initial compression chunk_size (in kilobytes) when compression is enabled,
      * Default: 64 (see DEFAULT_COMPRESSION_CHUNK_SIZE), should be positive 2^n.
      */
-    public static final String COMPRESSION_CHUNKS_SIZE_KEY = "cassandra.db.compression.chunk_size_kb";
+    public static final String COMPRESSION_CHUNKS_SIZE_KEY = "compression.chunk_length_kb";
     public static final int DEFAULT_COMPRESSION_CHUNK_SIZE = 64;
     
     /**
@@ -74,7 +74,7 @@ public static Partitioner getPartitioner(String className) {
      * <p>
      * Default: {@literal #DEFAULT_COMPRESSOR}
      */
-    public static final String COMPRESSION_KEY = "cassandra.db.compression.sstable_compression";
+    public static final String COMPRESSION_KEY = "compression.sstable_compression";
     public static final String DEFAULT_COMPRESSION = "SnappyCompressor";
 
 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -309,7 +309,7 @@ private void ensureColumnFamilyExists(String name, String comparator) throws Sto
                 ImmutableMap.Builder<String, String> compressionOptions = new ImmutableMap.Builder<String, String>();
 
                 if (compressionEnabled) {
-                    compressionOptions.put("sstable_compression", sstableCompressionClass)
+                    compressionOptions.put("sstable_compression", compressionClass)
                                       .put("chunk_length_kb", Integer.toString(compressionChunkSizeKB));
                 }
                 

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -327,7 +327,7 @@ private void ensureColumnFamilyExists(String keyspaceName, String columnfamilyNa
         Class<?> compressorClass;
         CompressionParameters cp;
         try {
-            compressorClass = Class.forName(sstableCompressionClass);
+            compressorClass = Class.forName(compressionClass);
             Method method = compressorClass.getMethod("create", Map.class);
         	ICompressor compressor = (ICompressor) method.invoke(null, new HashMap<String, String>());
             cp = new CompressionParameters(compressor, compressionChunkSizeKB * 1024, ImmutableMap.<String, String>of());

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -393,7 +393,7 @@ private void createColumnFamily(Cassandra.Client client,
         ImmutableMap.Builder<String, String> compressionOptions = new ImmutableMap.Builder<String, String>();
 
         if (compressionEnabled) {
-            compressionOptions.put("sstable_compression", sstableCompressionClass)
+            compressionOptions.put("sstable_compression", compressionClass)
                               .put("chunk_length_kb", Integer.toString(compressionChunkSizeKB));
         }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -394,7 +394,7 @@ public BackendTransaction beginTransaction(TransactionConfiguration configuratio
         if (configuration.hasTimestamp()) txConfig.setTimestamp(configuration.getTimestamp());
         StoreTransaction tx = storeManager.beginTransaction(txConfig);
         if (bufferSize > 1) {
-            assert storeManager.getFeatures().supportsBatchMutation();
+            Preconditions.checkArgument(storeManager.getFeatures().supportsBatchMutation());
             tx = new BufferTransaction(tx, storeManager, bufferSize, writeAttempts, persistAttemptWaittime);
         }
         if (!storeFeatures.supportsLocking()) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/TimeUtility.java
Patch:
@@ -76,7 +76,7 @@ public enum TimeUtility implements TimestampProvider {
 //    }
     @Override
     public long getApproxNSSinceEpoch() {
-        return ((System.nanoTime() - t0NanoTime + t0NanosSinceEpoch) & 0xFFFFFFFFFFFFFFFEL);
+        return (System.nanoTime() - t0NanoTime + t0NanosSinceEpoch);
     }
 
     /**

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -46,6 +46,9 @@ public void testBasic() {
         clopen();
         long nid = n1.getID();
         assertTrue(tx.containsVertex(nid));
+        assertTrue(tx.containsVertex(weight.getID()));
+        assertFalse(tx.containsVertex(nid + 64));
+        assertFalse(tx.containsVertex(weight.getID() + 64));
         assertTrue(tx.containsType("weight"));
         weight = tx.getPropertyKey("weight");
         assertEquals(weight.getDataType(), Double.class);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -351,7 +351,6 @@ public void removeRelation(InternalRelation relation) {
         relation = relation.it();
         //Delete from Vertex
         for (int i = 0; i < relation.getLen(); i++) {
-            if (i > 0 && relation.isLoop()) continue; //No need to remove loop twice
             relation.getVertex(i).removeRelation(relation);
         }
         //Update transaction data structures
@@ -428,7 +427,6 @@ public TitanEdge addEdge(TitanVertex outVertex, TitanVertex inVertex, TitanLabel
 
     private void connectRelation(InternalRelation r) {
         for (int i = 0; i < r.getLen(); i++) {
-            if (i > 0 && r.isLoop()) continue; //Do not need to connect a loop twice
             boolean success = r.getVertex(i).addRelation(r);
             if (!success) throw new AssertionError("Could not connect relation: " + r);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -222,7 +222,7 @@ public Boolean call() throws Exception {
                         Preconditions.checkArgument(del.isRemoved());
                         for (int pos = 0; pos < del.getLen(); pos++) {
                             InternalVertex vertex = del.getVertex(pos);
-                            mutations.put(vertex, del);
+                            if (pos == 0 || !del.isLoop()) mutations.put(vertex, del);
                             Direction dir = EdgeDirection.fromPosition(pos);
                             if (acquireLocks && del.getType().isUnique(dir) &&
                                     ((InternalType) del.getType()).uniqueLock(dir)) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -351,6 +351,7 @@ public void removeRelation(InternalRelation relation) {
         relation = relation.it();
         //Delete from Vertex
         for (int i = 0; i < relation.getLen(); i++) {
+            if (i > 0 && relation.isLoop()) continue; //No need to remove loop twice
             relation.getVertex(i).removeRelation(relation);
         }
         //Update transaction data structures
@@ -427,6 +428,7 @@ public TitanEdge addEdge(TitanVertex outVertex, TitanVertex inVertex, TitanLabel
 
     private void connectRelation(InternalRelation r) {
         for (int i = 0; i < r.getLen(); i++) {
+            if (i > 0 && r.isLoop()) continue; //Do not need to connect a loop twice
             boolean success = r.getVertex(i).addRelation(r);
             if (!success) throw new AssertionError("Could not connect relation: " + r);
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/testutil/MemoryAssess.java
Patch:
@@ -20,11 +20,9 @@ public long end() {
 
     public static long getMemoryUse() {
         putOutTheGarbage();
-        long totalMemory = Runtime.getRuntime().totalMemory();
-
         putOutTheGarbage();
+        long totalMemory = Runtime.getRuntime().totalMemory();
         long freeMemory = Runtime.getRuntime().freeMemory();
-
         return (totalMemory - freeMemory);
     }
 

File: titan-hazelcast/src/test/java/com/thinkaurelius/titan/graphdb/HazelcastTitanGraphPerformanceTest.java
Patch:
@@ -2,9 +2,7 @@
 
 import com.thinkaurelius.titan.HazelcastStorageSetup;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import org.junit.Ignore;
 
-@Ignore
 public class HazelcastTitanGraphPerformanceTest extends TitanGraphPerformanceTest {
     public HazelcastTitanGraphPerformanceTest() {
         super(HazelcastStorageSetup.getHazelcastGraphConfig(false));

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardTypeMaker.java
Patch:
@@ -85,8 +85,8 @@ private void checkGeneralArguments() {
         checkSignature(signature);
         Preconditions.checkArgument(Sets.intersection(Sets.newHashSet(primaryKey), Sets.newHashSet(signature)).isEmpty(),
                 "Signature and primary key must be disjoined");
-        if ((isUnique[0] || isUnique[1]) && !primaryKey.isEmpty())
-            throw new IllegalArgumentException("Cannot define a primary key on a unique type");
+        if ((isUnique[0] && isUnique[1]) && !primaryKey.isEmpty())
+            throw new IllegalArgumentException("Cannot define a primary key on a both-unique type");
     }
 
     private static long[] checkPrimaryKey(List<TitanType> sig) {

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/ScriptExecutor.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.faunus.tinkerpop.gremlin;
 
 import javax.script.Bindings;
+import javax.script.ScriptContext;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.Reader;
@@ -23,7 +24,7 @@ public static void main(final String[] arguments) throws IOException {
     protected static void evaluate(final Reader reader, final List<String> arguments) throws IOException {
         final FaunusGremlinScriptEngine engine = new FaunusGremlinScriptEngine();
 
-        final Bindings bindings = engine.createBindings();
+        final Bindings bindings = engine.getBindings(ScriptContext.GLOBAL_SCOPE);
         if (arguments.size() > 0) {
             for (int i = 0; i < arguments.size(); i++) {
                 bindings.put("a" + (i + 1), arguments.get(i));

File: src/test/java/com/thinkaurelius/faunus/FaunusVertexTest.java
Patch:
@@ -386,11 +386,11 @@ public void testSequenceFileRepresentation() throws Exception {
 
     public void testLargeProperty() throws Exception {
         String value = "a24$%~bU*!";
-        for (int i = 0; i < 19; i++) {
+        for (int i = 0; i < 18; i++) {
             value = value + value;
         }
-        // a 5 million length string == ~10 books worth of data
-        assertTrue(value.length() > 5000000);
+        // a 2.6 million length string == ~5 books worth of data
+        assertEquals(value.length(), 2621440);
 
         FaunusVertex vertex1 = new FaunusVertex(1l);
         vertex1.setProperty("name", value);

File: src/test/java/com/thinkaurelius/faunus/formats/VertexQueryFilterTest.java
Patch:
@@ -70,7 +70,7 @@ public void testDefaultFilterLimitOneTinkerGraph() throws Exception {
 
     public void testDefaultFilterHasTinkerGraph() throws Exception {
         Configuration config = new Configuration();
-        config.set(VertexQueryFilter.FAUNUS_GRAPH_INPUT_VERTEX_QUERY_FILTER, "v.query().has('weight',0.5d,Query.Compare.LESS_THAN).limit(5)");
+        config.set(VertexQueryFilter.FAUNUS_GRAPH_INPUT_VERTEX_QUERY_FILTER, "v.query().has('weight',Compare.LESS_THAN,0.5d).limit(5)");
         VertexQueryFilter query = VertexQueryFilter.create(config);
         Map<Long, FaunusVertex> graph = generateGraph(ExampleGraph.TINKERGRAPH);
 

File: src/test/java/com/thinkaurelius/faunus/tinkerpop/gremlin/FaunusGremlinScriptEngineTest.java
Patch:
@@ -12,5 +12,7 @@ public class FaunusGremlinScriptEngineTest extends TestCase {
     public void testEvaluates() throws Exception {
         ScriptEngine engine = new FaunusGremlinScriptEngineFactory().getScriptEngine();
         engine.eval("local.ls()");
+        engine.eval("hdfs.ls()");
     }
+
 }

File: titan-hazelcast/src/test/java/com/thinkaurelius/titan/graphdb/HazelcastTitanGraphPerformanceTest.java
Patch:
@@ -7,7 +7,7 @@
 @Ignore
 public class HazelcastTitanGraphPerformanceTest extends TitanGraphPerformanceTest {
     public HazelcastTitanGraphPerformanceTest() {
-        super(HazelcastStorageSetup.getHazelcastGraphConfig());
+        super(HazelcastStorageSetup.getHazelcastGraphConfig(false));
     }
 
     @Override

File: titan-hazelcast/src/test/java/com/thinkaurelius/titan/graphdb/HazelcastTitanGraphTest.java
Patch:
@@ -5,7 +5,7 @@
 
 public class HazelcastTitanGraphTest extends TitanGraphTest {
     public HazelcastTitanGraphTest() {
-        super(HazelcastStorageSetup.getHazelcastGraphConfig());
+        super(HazelcastStorageSetup.getHazelcastGraphConfig(false));
     }
 
     @Override

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxOrderedKeyColumnValueStore.java
Patch:
@@ -16,6 +16,7 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;
+import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraHelper;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
@@ -90,7 +91,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        return Lists.newArrayList(getNamesSlice(keys, query, txh).values());
+        return CassandraHelper.order(getNamesSlice(keys, query, txh), keys);
     }
 
     public Map<ByteBuffer, List<Entry>> getNamesSlice(List<StaticBuffer> keys,

File: titan-core/src/main/java/com/thinkaurelius/titan/core/AttributeSerializer.java
Patch:
@@ -24,7 +24,7 @@
  * @see TypeMaker
  * @see <a href="https://github.com/thinkaurelius/titan/wiki/Graph-Configuration">Graph Configuration Wiki</a>
  */
-public interface AttributeSerializer<V> {
+public interface AttributeSerializer<V> extends AttributeHandler<V> {
 
     /**
      * Reads an attribute from the given ReadBuffer.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/BufferedKeyColumnValueStore.java
Patch:
@@ -42,7 +42,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        return store.getSlice(keys, query, txh);
+        return store.getSlice(keys, query, getTx(txh));
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreAdapter.java
Patch:
@@ -63,7 +63,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        List<List<Entry>> results = new ArrayList<List<Entry>>();
+        List<List<Entry>> results = new ArrayList<List<Entry>>(keys.size());
 
         for (StaticBuffer key : keys) {
             results.add(getSlice(new KeySliceQuery(key, query), txh));

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/AbstractLocker.java
Patch:
@@ -294,7 +294,7 @@ public void writeLock(KeyColumn lockID, StoreTransaction tx) throws TemporaryLoc
             }
         } else {
             // Fail immediately with no retries on local contention
-            throw new TemporaryLockingException("Local lock contention");
+            throw new PermanentLockingException("Local lock contention");
         }
     }
     

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStore.java
Patch:
@@ -81,7 +81,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        return dataStore.getSlice(keys, query, txh);
+        return dataStore.getSlice(keys, query, getBaseTx(txh));
     }
 
     /**
@@ -145,7 +145,7 @@ public KeyIterator getKeys(KeyRangeQuery query, StoreTransaction txh) throws Sto
 
     @Override
     public KeyIterator getKeys(SliceQuery query, StoreTransaction txh) throws StorageException {
-        return getKeys(query, txh);
+        return dataStore.getKeys(query, txh);
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/BlueprintsDefaultTypeMaker.java
Patch:
@@ -25,8 +25,7 @@ public TitanLabel makeLabel(String name, TypeMaker factory) {
 
     @Override
     public TitanKey makeKey(String name, TypeMaker factory) {
-        return factory.name(name).unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).
-                dataType(Object.class).makePropertyKey();
+        return factory.name(name).dataType(Object.class).makePropertyKey();
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -119,7 +119,7 @@ public void setProperty(TitanLabel label, TitanVertex vertex) {
     public void setProperty(TitanKey key, Object value) {
         Preconditions.checkArgument(!it().isRemoved(),"Cannot modified removed relation");
         Preconditions.checkArgument(key.isUnique(Direction.OUT),"Key must have unique assignment");
-        it().setPropertyDirect(key,AttributeUtil.verifyAttribute(key,value));
+        it().setPropertyDirect(key,tx().verifyAttribute(key,value));
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TransactionalTitanGraphTestSuite.java
Patch:
@@ -23,9 +23,9 @@ public void testCompetingThreads() {
         //Need to define types before hand to avoid deadlock in transactions
 
         graph.makeType().name("friend").makeEdgeLabel();
-        graph.makeType().name("test").unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Long.class).makePropertyKey();
-        graph.makeType().name("blah").unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Float.class).makePropertyKey();
-        graph.makeType().name("bloop").unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Integer.class).makePropertyKey();
+        graph.makeType().name("test").dataType(Long.class).makePropertyKey();
+        graph.makeType().name("blah").dataType(Float.class).makePropertyKey();
+        graph.makeType().name("bloop").dataType(Integer.class).makePropertyKey();
 
 
         graph.commit();

File: titan-test/src/main/java/com/thinkaurelius/titan/testutil/gen/GraphGenerator.java
Patch:
@@ -30,8 +30,7 @@
  * <ul>
  * <li>Creating types</li>
  * <li>Inserting vertices and labeled, directed edges (power-law distribution)</li>
- * <li>Setting integer-valued, standard-indexed, out-unique vertex properties</li>
- * <li>Setting integer-valued, standard-indexed, out-unique edge properties</li>
+ * <li>Setting integer-valued, standard-indexed, vertex-unique properties on edges and vertices</li>
  * </ul>
  * 
  * This uses a {@link java.util.Random} with a hard-coded seed. However, it also

File: titan-test/src/main/java/com/thinkaurelius/titan/testutil/gen/Schema.java
Patch:
@@ -239,10 +239,10 @@ public void makeTypes(TitanGraph g) {
         
         TitanTransaction tx = g.newTransaction();
         for (int i = 0; i < vertexPropKeys; i++) {
-            tx.makeType().name(getVertexPropertyName(i)).dataType(Integer.class).indexed(Vertex.class).unique(Direction.OUT).makePropertyKey();
+            tx.makeType().name(getVertexPropertyName(i)).dataType(Integer.class).indexed(Vertex.class).vertexUnique(Direction.OUT).makePropertyKey();
         }
         for (int i = 0; i < edgePropKeys; i++) {
-            tx.makeType().name(getEdgePropertyName(i)).dataType(Integer.class).indexed(Edge.class).unique(Direction.OUT).makePropertyKey();
+            tx.makeType().name(getEdgePropertyName(i)).dataType(Integer.class).indexed(Edge.class).vertexUnique(Direction.OUT).makePropertyKey();
         }
         for (int i = 0; i < edgeLabels; i++) {
             String labelName = getEdgeLabelName(i);
@@ -251,7 +251,7 @@ public void makeTypes(TitanGraph g) {
             tx.makeType().name(getEdgeLabelName(i)).primaryKey(pk).makeEdgeLabel();
         }
 
-        tx.makeType().name(UID_PROP).dataType(Long.class).indexed(Vertex.class).unique(Direction.BOTH).makePropertyKey();
+        tx.makeType().name(UID_PROP).dataType(Long.class).indexed(Vertex.class).vertexUnique(Direction.BOTH).makePropertyKey();
         tx.commit();
     }
 

File: titan-hazelcast/src/test/java/com/thinkaurelius/titan/diskstorage/hazelcast/HazelcastKeyColumnValueStoreTest.java
Patch:
@@ -8,7 +8,6 @@
 
 
 public class HazelcastKeyColumnValueStoreTest extends KeyColumnValueStoreTest {
-
     public HazelcastKeyColumnValueStoreTest() throws StorageException {
         manager = openStorageManager();
         store = manager.openDatabase(STORE_NAME);
@@ -29,7 +28,7 @@ public void tearDown() throws Exception {
         if (tx != null)
             tx.commit();
 
-        ((HazelcastKeyColumnValueStore) store).clear();
+        ((HazelcastKeyColumnValueStoreManager) manager).clear(store.getName());
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/AbstractLocker.java
Patch:
@@ -294,7 +294,7 @@ public void writeLock(KeyColumn lockID, StoreTransaction tx) throws TemporaryLoc
             }
         } else {
             // Fail immediately with no retries on local contention
-            throw new TemporaryLockingException("Local lock contention");
+            throw new PermanentLockingException("Local lock contention");
         }
     }
     

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStore.java
Patch:
@@ -145,7 +145,7 @@ public KeyIterator getKeys(KeyRangeQuery query, StoreTransaction txh) throws Sto
 
     @Override
     public KeyIterator getKeys(SliceQuery query, StoreTransaction txh) throws StorageException {
-        return getKeys(query, txh);
+        return dataStore.getKeys(query, txh);
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTestCommon.java
Patch:
@@ -120,7 +120,7 @@ public TitanKey makeWeightPropertyKey(String name) {
     }
 
     public TitanKey makeNonUniqueStringPropertyKey(String name) {
-        return tx.makeType().name(name).
+        return tx.makeType().name(name).multiValued().
                 indexed(Vertex.class).
                 dataType(String.class).
                 makePropertyKey();

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TransactionalTitanGraphTestSuite.java
Patch:
@@ -23,9 +23,9 @@ public void testCompetingThreads() {
         //Need to define types before hand to avoid deadlock in transactions
 
         graph.makeType().name("friend").makeEdgeLabel();
-        graph.makeType().name("test").unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Long.class).makePropertyKey();
-        graph.makeType().name("blah").unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Float.class).makePropertyKey();
-        graph.makeType().name("bloop").unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).dataType(Integer.class).makePropertyKey();
+        graph.makeType().name("test").dataType(Long.class).makePropertyKey();
+        graph.makeType().name("blah").dataType(Float.class).makePropertyKey();
+        graph.makeType().name("bloop").dataType(Integer.class).makePropertyKey();
 
 
         graph.commit();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/BlueprintsDefaultTypeMaker.java
Patch:
@@ -25,8 +25,7 @@ public TitanLabel makeLabel(String name, TypeMaker factory) {
 
     @Override
     public TitanKey makeKey(String name, TypeMaker factory) {
-        return factory.name(name).unique(Direction.OUT, TypeMaker.UniquenessConsistency.NO_LOCK).
-                dataType(Object.class).makePropertyKey();
+        return factory.name(name).dataType(Object.class).makePropertyKey();
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -417,11 +417,11 @@ public TitanProperty addPropertyInternal(TitanVertex vertex, TitanKey key, Objec
             if (config.hasVerifyUniqueness()) {
                 if (key.isUnique(Direction.OUT)) {
                     Preconditions.checkArgument(Iterables.isEmpty(query(vertex).includeHidden().type(key).direction(Direction.OUT).properties()),
-                            "An property with the given key already exists on the vertex and the property key is defined as out-unique");
+                            "A property with the given key [%s] already exists on the vertex [%s] and the property key is defined as out-unique", key.getName(), vertex);
                 }
                 if (key.isUnique(Direction.IN)) {
                     Preconditions.checkArgument(Iterables.isEmpty(getVertices(key, value)),
-                            "The given value is already used as a property and the property key is defined as in-unique");
+                            "The given value [%s] is already used as a property and the property key [%s] is defined as in-unique", value, key.getName());
                 }
             }
             StandardProperty prop = new StandardProperty(temporaryID.decrementAndGet(), key, (InternalVertex) vertex, value, ElementLifeCycle.New);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/AttributeSerializer.java
Patch:
@@ -24,7 +24,7 @@
  * @see TypeMaker
  * @see <a href="https://github.com/thinkaurelius/titan/wiki/Graph-Configuration">Graph Configuration Wiki</a>
  */
-public interface AttributeSerializer<V> {
+public interface AttributeSerializer<V> extends AttributeHandler<V> {
 
     /**
      * Reads an attribute from the given ReadBuffer.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.configuration;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.AttributeHandler;
 import com.thinkaurelius.titan.core.AttributeSerializer;
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
 import com.thinkaurelius.titan.diskstorage.Backend;
@@ -526,7 +527,7 @@ public static List<RegisteredAttributeClass<?>> getRegisteredAttributeClasses(Co
             try {
                 int position = Integer.parseInt(key.substring(ATTRIBUTE_PREFIX.length()));
                 Class<?> clazz = null;
-                AttributeSerializer<?> serializer = null;
+                AttributeHandler<?> serializer = null;
                 String classname = config.getString(key);
                 try {
                     clazz = Class.forName(classname);
@@ -539,7 +540,7 @@ public static List<RegisteredAttributeClass<?>> getRegisteredAttributeClasses(Co
                     String serializername = config.getString(SERIALIZER_PREFIX + position);
                     try {
                         Class sclass = Class.forName(serializername);
-                        serializer = (AttributeSerializer) sclass.newInstance();
+                        serializer = (AttributeHandler) sclass.newInstance();
                     } catch (ClassNotFoundException e) {
                         throw new IllegalArgumentException("Could not find serializer class" + serializername);
                     } catch (InstantiationException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/SerializerInitialization.java
Patch:
@@ -39,14 +39,14 @@ public static final void initialize(Serializer serializer) {
         serializer.registerClass(Long.class, new LongSerializer(),KRYO_OFFSET+19);
         serializer.registerClass(IndexType.class,KRYO_OFFSET+20);
         serializer.registerClass(IndexType[].class,KRYO_OFFSET+21);
-        serializer.registerClass(Geoshape.class,KRYO_OFFSET+22);
+        serializer.registerClass(Geoshape.class,new GeoshapeHandler(), KRYO_OFFSET+22);
         serializer.registerClass(Byte.class, new ByteSerializer(),KRYO_OFFSET+23);
         serializer.registerClass(Short.class, new ShortSerializer(),KRYO_OFFSET+24);
         serializer.registerClass(Character.class, new CharacterSerializer(),KRYO_OFFSET+25);
         serializer.registerClass(Boolean.class, new BooleanSerializer(),KRYO_OFFSET+26);
         serializer.registerClass(Object.class, KRYO_OFFSET+27);
-        serializer.registerClass(FullFloat.class, KRYO_OFFSET+28);
-        serializer.registerClass(FullDouble.class, KRYO_OFFSET+29);
+        serializer.registerClass(FullFloat.class, new FullFloatHandler(), KRYO_OFFSET+28);
+        serializer.registerClass(FullDouble.class, new FullDoubleHandler(), KRYO_OFFSET+29);
         serializer.registerClass(char[].class, KRYO_OFFSET+30);
         serializer.registerClass(short[].class, KRYO_OFFSET+31);
         serializer.registerClass(float[].class, KRYO_OFFSET+32);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -119,7 +119,7 @@ public void setProperty(TitanLabel label, TitanVertex vertex) {
     public void setProperty(TitanKey key, Object value) {
         Preconditions.checkArgument(!it().isRemoved(),"Cannot modified removed relation");
         Preconditions.checkArgument(key.isUnique(Direction.OUT),"Key must have unique assignment");
-        it().setPropertyDirect(key,AttributeUtil.verifyAttribute(key,value));
+        it().setPropertyDirect(key,tx().verifyAttribute(key,value));
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -181,7 +181,7 @@ public void testTypes() {
         v.addProperty(weight, 0.5);
         v.addProperty(boolval,true);
         try {
-            v.addProperty(weight, "0.5");
+            v.addProperty(weight, "x");
             fail();
         } catch (IllegalArgumentException e) {
         }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxOrderedKeyColumnValueStore.java
Patch:
@@ -16,6 +16,7 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;
+import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraHelper;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import com.thinkaurelius.titan.diskstorage.util.StaticByteBuffer;
@@ -90,7 +91,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        return Lists.newArrayList(getNamesSlice(keys, query, txh).values());
+        return CassandraHelper.order(getNamesSlice(keys, query, txh), keys);
     }
 
     public Map<ByteBuffer, List<Entry>> getNamesSlice(List<StaticBuffer> keys,

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftKeyColumnValueStore.java
Patch:
@@ -7,6 +7,7 @@
 
 import javax.annotation.Nullable;
 
+import com.thinkaurelius.titan.diskstorage.cassandra.utils.CassandraHelper;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import org.apache.cassandra.dht.*;
 import org.apache.cassandra.thrift.Cassandra;
@@ -33,7 +34,6 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterators;
-import com.google.common.collect.Lists;
 import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
@@ -116,7 +116,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        return Lists.newArrayList(getNamesSlice(keys, query, txh).values());
+        return CassandraHelper.order(getNamesSlice(keys, query, txh), keys);
     }
 
     public Map<ByteBuffer, List<Entry>> getNamesSlice(List<StaticBuffer> keys,

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -918,7 +918,7 @@ public void testQuery() {
             e.setProperty(author, vs[i % 5]);
         }
 
-        VertexList vl = null;
+        VertexList vl;
         clopen();
         for (int i = 0; i < noVertices; i++) vs[i] = tx.getVertex(vs[i].getID());
         v = vs[0];
@@ -927,7 +927,7 @@ public void testQuery() {
         //Queries
         int lastTime = 0;
         for (Edge e : v.query().labels("connect").direction(OUT).limit(20).edges()) {
-            int nowTime = (Integer) e.getProperty("time");
+            int nowTime = e.getProperty("time");
             //System.out.println(nowTime);
             assertTrue(lastTime + " vs. " + nowTime, lastTime <= nowTime);
             lastTime = nowTime;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/BufferedKeyColumnValueStore.java
Patch:
@@ -42,7 +42,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        return store.getSlice(keys, query, txh);
+        return store.getSlice(keys, query, getTx(txh));
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/OrderedKeyValueStoreAdapter.java
Patch:
@@ -63,7 +63,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        List<List<Entry>> results = new ArrayList<List<Entry>>();
+        List<List<Entry>> results = new ArrayList<List<Entry>>(keys.size());
 
         for (StaticBuffer key : keys) {
             results.add(getSlice(new KeySliceQuery(key, query), txh));

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStore.java
Patch:
@@ -81,7 +81,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public List<List<Entry>> getSlice(List<StaticBuffer> keys, SliceQuery query, StoreTransaction txh) throws StorageException {
-        return dataStore.getSlice(keys, query, txh);
+        return dataStore.getSlice(keys, query, getBaseTx(txh));
     }
 
     /**

File: titan-berkeleyje/src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -30,9 +30,9 @@ public class BerkeleyJEStoreManager extends LocalStoreManager implements Ordered
 
     private final Map<String, BerkeleyJEKeyValueStore> stores;
 
-    private Environment environment;
-    private final StoreFeatures features;
-    private final FileStorageConfiguration storageConfig;
+    protected Environment environment;
+    protected final StoreFeatures features;
+    protected final FileStorageConfiguration storageConfig;
 
     public BerkeleyJEStoreManager(Configuration configuration) throws StorageException {
         super(configuration);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/HashPrefixKeyColumnValueStore.java
Patch:
@@ -90,7 +90,7 @@ public void acquireLock(StaticBuffer key, StaticBuffer column, StaticBuffer expe
 
     @Override
     public KeyIterator getKeys(KeyRangeQuery keyQuery, StoreTransaction txh) throws StorageException {
-        throw new UnsupportedOperationException("getKeys(KeyRangeQuery) is not supported in hash prefixed mode.");
+        throw new UnsupportedOperationException("getKeys(KeyRangeQuery, StoreTransaction) is not supported in hash prefixed mode.");
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KeyColumnValueStore.java
Patch:
@@ -3,7 +3,6 @@
 import com.google.common.collect.ImmutableList;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
 import java.util.List;
 
@@ -144,7 +143,6 @@ public interface KeyColumnValueStore {
      */
     public void acquireLock(StaticBuffer key, StaticBuffer column, StaticBuffer expectedValue, StoreTransaction txh) throws StorageException;
 
-
     /**
      * Returns a {@link KeyIterator} over all keys that fall within the key-range specified by the given query and have one or more columns matching the column-range.
      * Calling {@link KeyIterator#getEntries()} returns the list of all entries that match the column-range specified by the given query.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/ReadOnlyKeyColumnValueStore.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
 import java.util.List;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryKeyColumnValueStore.java
Patch:
@@ -143,19 +143,16 @@ public RecordIterator<Entry> getEntries() {
 
                 @Override
                 public boolean hasNext() throws StorageException {
-                    ensureOpen();
                     return items.hasNext();
                 }
 
                 @Override
                 public Entry next() throws StorageException {
-                    ensureOpen();
                     return items.next();
                 }
 
                 @Override
                 public void close() throws StorageException {
-                    isClosed = true;
                 }
             };
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ExpectedValueCheckingStore.java
Patch:
@@ -7,7 +7,6 @@
 import com.thinkaurelius.titan.diskstorage.locking.Locker;
 import com.thinkaurelius.titan.diskstorage.locking.PermanentLockingException;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
-import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/transactional/TransactionalLockStore.java
Patch:
@@ -3,7 +3,6 @@
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
-import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
 import java.util.List;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/ByteBufferUtil.java
Patch:
@@ -205,7 +205,7 @@ public static final int compare(byte c1, byte c2) {
         } else return 0;
     }
 
-    public static final int compare(StaticBuffer b1, StaticBuffer b2) {
+    public static int compare(StaticBuffer b1, StaticBuffer b2) {
         if (b1 == b2) {
             return 0;
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/tinkerpop/rexster/RexsterServerClientTest.java
Patch:
@@ -33,6 +33,9 @@ public abstract class RexsterServerClientTest extends TitanGraphTestCommon {
     public RexsterServerClientTest(Configuration config) {
         super(config);
         rexsterConfig = new XMLConfiguration();
+
+        // script engine is not defaulted by rexster.
+        rexsterConfig.addProperty("script-engines.script-engine.name", "gremlin-groovy");
     }
 
     @Before
@@ -60,7 +63,6 @@ public void tearDown() throws Exception {
     }
 
     @Test
-    @Ignore
     public void simpleQuerying() throws Exception {
         List<Map<String, Object>> result;
 //      result = client.query("g.V");

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KeyColumnValueStore.java
Patch:
@@ -179,7 +179,7 @@ public interface KeyColumnValueStore {
      * @throws StorageException
      */
     public KeyIterator getKeys(SliceQuery query, StoreTransaction txh) throws StorageException;
-    // like current getKeys if column-slice is such that is queries for vertex state property
+    // like current getKeys if column-slice is such that it queries for vertex state property
 
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/ElementType.java
Patch:
@@ -21,7 +21,7 @@ public Class<? extends Element> getElementType() {
     public String getName() {
         switch(this) {
             case VERTEX: return "vertex";
-            case EDGE: return "relation";
+            case EDGE: return "edge";
             default: throw new IllegalArgumentException();
         }
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/GraphCentricQuery.java
Patch:
@@ -100,7 +100,7 @@ public boolean hasDuplicateResults() {
 
     @Override
     public boolean matches(TitanElement element) {
-        return condition.equals(element);
+        return condition.evaluate(element);
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryProcessor.java
Patch:
@@ -125,7 +125,7 @@ private Iterator<R> getUnwrappedIterator() {
             for (int i=0;i<query.numSubQueries();i++) {
                 BackendQueryHolder<B> subq = query.getSubQuery(i);
                 Iterator subiter = new LimitAdjustingIterator(subq);
-                subiter = getFilterIterator(subiter,hasDeletions,subq.isFitted());
+                subiter = getFilterIterator(subiter,hasDeletions,!subq.isFitted());
                 if (!allNew.isEmpty()) {
                     subiter = Iterators.filter(subiter,new Predicate<R>() {
                         @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/util/datastructures/ProperInterval.java
Patch:
@@ -60,14 +60,14 @@ public boolean endInclusive() {
 
     @Override
     public boolean isPoint() {
-        return start.equals(end) && startInclusive && endInclusive;
+        return start!=null && end!=null && start.equals(end) && startInclusive && endInclusive;
     }
 
     @Override
     public boolean isEmpty() {
         if (start==null || end==null) return false;
         int cmp = start.compareTo(end);
-        return cmp<0 || (cmp==0 && startInclusive && endInclusive);
+        return cmp>0 || (cmp==0 && (!startInclusive || !endInclusive));
     }
 
     @Override

File: titan-test/src/main/java/com/thinkaurelius/titan/tinkerpop/rexster/RexsterServerClientTest.java
Patch:
@@ -11,6 +11,7 @@
 import org.apache.commons.configuration.XMLConfiguration;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.util.HashMap;
@@ -59,6 +60,7 @@ public void tearDown() throws Exception {
     }
 
     @Test
+    @Ignore
     public void simpleQuerying() throws Exception {
         List<Map<String, Object>> result;
 //      result = client.query("g.V");

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -43,7 +43,6 @@ public class FaunusCompiler extends Configured implements Tool {
 
     public static final String PATH_ENABLED = Tokens.makeNamespace(FaunusCompiler.class) + ".pathEnabled";
     public static final String TESTING = Tokens.makeNamespace(FaunusCompiler.class) + ".testing";
-
     public static final Logger logger = Logger.getLogger(FaunusCompiler.class);
 
     private FaunusGraph graph;

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/FaunusGremlinScriptEngine.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.faunus.tinkerpop.gremlin;
 
+import com.tinkerpop.gremlin.groovy.jsr223.DefaultImportCustomizerProvider;
 import com.tinkerpop.gremlin.groovy.jsr223.GremlinGroovyScriptEngine;
 import groovy.lang.GroovyClassLoader;
 import org.codehaus.groovy.control.CompilerConfiguration;
@@ -30,7 +31,7 @@ public FaunusGremlinScriptEngine() {
     }
 
     public static ImportCustomizer getImportCustomizer() {
-        final ImportCustomizer ic = GremlinGroovyScriptEngine.getImportCustomizer();
+        final ImportCustomizer ic = new DefaultImportCustomizerProvider().getImportCustomizer();
         for (final String imp : Imports.getImports()) {
             ic.addStarImports(imp.replace(DOT_STAR, EMPTY_STRING));
         }

File: src/test/java/com/thinkaurelius/faunus/formats/VertexQueryFilterTest.java
Patch:
@@ -18,7 +18,7 @@ public void testDegenerateVertexQuery() {
         Configuration config = new Configuration();
         VertexQueryFilter query = VertexQueryFilter.create(config);
         assertFalse(query.doesFilter());
-        assertEquals(query.limit, Long.MAX_VALUE);
+        assertEquals(query.limit, Integer.MAX_VALUE);
         assertEquals(query.hasContainers.size(), 0);
         assertEquals(query.direction, Direction.BOTH);
         assertEquals(query.labels.length, 0);

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/ScriptExecutor.java
Patch:
@@ -20,7 +20,7 @@ public static void main(final String[] arguments) throws IOException {
         }
     }
 
-    protected static void evaluate(final Reader reader, final List<String> arguments) {
+    protected static void evaluate(final Reader reader, final List<String> arguments) throws IOException {
         final FaunusGremlinScriptEngine engine = new FaunusGremlinScriptEngine();
 
         final Bindings bindings = engine.createBindings();
@@ -29,6 +29,7 @@ protected static void evaluate(final Reader reader, final List<String> arguments
                 bindings.put("a" + (i + 1), arguments.get(i));
             }
         }
+
         try {
             engine.eval(reader, bindings);
         } catch (Exception e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -460,8 +460,8 @@ private final TitanType makeTitanType(TitanTypeClass typeClass, String name, Typ
             TypeAttribute.isValidLabelDefinition(definition);
             type = new TitanLabelVertex(this, temporaryID.decrementAndGet(), ElementLifeCycle.New);
         }
-        addProperty(type, SystemKey.TypeClass, typeClass);
         addProperty(type, SystemKey.TypeName, name);
+        addProperty(type, SystemKey.TypeClass, typeClass);
         for (TypeAttribute attribute : definition.getAttributes()) {
             addProperty(type,SystemKey.TypeDefinition,attribute);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/SerializerInitialization.java
Patch:
@@ -18,8 +18,8 @@ public class SerializerInitialization {
 
     public static final void initialize(Serializer serializer) {
         serializer.registerClass(String[].class,KRYO_OFFSET+1);
-        serializer.registerClass(StandardKeyDefinition.class,KRYO_OFFSET+2);
-        serializer.registerClass(StandardLabelDefinition.class,KRYO_OFFSET+3);
+        serializer.registerClass(TypeAttributeType.class,KRYO_OFFSET+2);
+        serializer.registerClass(TypeAttribute.class,KRYO_OFFSET+3);
         serializer.registerClass(Date.class, new DateSerializer(),KRYO_OFFSET+6);
         serializer.registerClass(ArrayList.class,KRYO_OFFSET+7);
         serializer.registerClass(HashMap.class,KRYO_OFFSET+8);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationComparator.java
Patch:
@@ -42,7 +42,7 @@ public int compare(final InternalRelation r1, final InternalRelation r2) {
         if (t1.isUnique(dir1)) return 0;
 
         // 3) Compare primary key values
-        for (long typeid : t1.getDefinition().getPrimaryKey()) {
+        for (long typeid : t1.getPrimaryKey()) {
             int keycompare = compareOnKey(r1, r2, typeid);
             if (keycompare != 0) return keycompare;
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -43,9 +43,9 @@ public static SystemType getSystemRelationType(long id) {
     }
 
 
-    public static final Set<? extends SystemType> prepersistedSystemTypes = ImmutableSet.of(SystemKey.TypeName,
-            SystemKey.PropertyKeyDefinition,
-            SystemKey.RelationTypeDefinition,
+    public static final Set<? extends SystemType> prepersistedSystemTypes = ImmutableSet.of(
+            SystemKey.TypeName,
+            SystemKey.TypeDefinition,
             SystemKey.TypeClass);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/ReadByteBuffer.java
Patch:
@@ -53,7 +53,7 @@ public boolean hasRemaining() {
 
     @Override
     public void movePosition(int delta) {
-        Preconditions.checkArgument(position+delta>=0 && position+delta<=length(),"Invalid move, position out of bounce: %s",position+delta);
+        Preconditions.checkArgument(position+delta>=-1 && position+delta<=length(),"Invalid move, position out of bounce: %s",position+delta);
         this.position=position+delta;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/ReadBuffer.java
Patch:
@@ -10,6 +10,8 @@
  */
 public interface ReadBuffer extends ScanBuffer, StaticBuffer {
 
+    public int getPosition();
+
     public void movePosition(int delta);
 
     public ByteBuffer asRelativeByteBuffer();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -129,7 +129,7 @@ public IndexInformation getIndexInformation(String indexName) {
     }
 
     public IDInspector getIDInspector() {
-        return idManager;
+        return idManager.getIDInspector();
     }
 
     public EdgeSerializer getEdgeSerializer() {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/SerializerInitialization.java
Patch:
@@ -20,7 +20,6 @@ public static final void initialize(Serializer serializer) {
         serializer.registerClass(String[].class,KRYO_OFFSET+1);
         serializer.registerClass(StandardKeyDefinition.class,KRYO_OFFSET+2);
         serializer.registerClass(StandardLabelDefinition.class,KRYO_OFFSET+3);
-        serializer.registerClass(StandardTypeGroup.class,KRYO_OFFSET+4);
         serializer.registerClass(Date.class, new DateSerializer(),KRYO_OFFSET+6);
         serializer.registerClass(ArrayList.class,KRYO_OFFSET+7);
         serializer.registerClass(HashMap.class,KRYO_OFFSET+8);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -490,9 +490,9 @@ public TitanType getType(String name) {
     }
 
     public TitanType getExistingType(long typeid) {
-        if (idInspector.getGroupID(typeid) == SystemTypeManager.SYSTEM_TYPE_GROUP.getID()) {
-            //its a systemtype
-            return SystemTypeManager.getSystemEdgeType(typeid);
+        Preconditions.checkArgument(idInspector.isTypeID(typeid),"Provided id [%s] is not a type id",typeid);
+        if (SystemTypeManager.isSystemRelationType(typeid)) {
+            return SystemTypeManager.getSystemRelationType(typeid);
         } else {
             InternalVertex v = getExistingVertex(typeid);
             Preconditions.checkArgument(v instanceof TitanType,"Given id is not a type: " + typeid);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardKeyDefinition.java
Patch:
@@ -4,7 +4,6 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.thinkaurelius.titan.core.TypeGroup;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Element;
 import com.tinkerpop.blueprints.Vertex;
@@ -23,12 +22,12 @@ public class StandardKeyDefinition extends AbstractTypeDefinition implements Pro
     StandardKeyDefinition() {
     }
 
-    public StandardKeyDefinition(String name, TypeGroup group,
+    public StandardKeyDefinition(String name,
                                  boolean[] unique, boolean[] hasUniqueLock, boolean[] isStatic,
                                  boolean hidden, boolean modifiable,
                                  long[] primaryKey, long[] signature,
                                  IndexType[] indexes, Class<?> objectType) {
-        super(name, group, unique, hasUniqueLock, isStatic, hidden, modifiable, primaryKey, signature);
+        super(name, unique, hasUniqueLock, isStatic, hidden, modifiable, primaryKey, signature);
         this.indexes = indexes;
         this.objectType = objectType;
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/TypeDefinition.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.types;
 
-import com.thinkaurelius.titan.core.TypeGroup;
 import com.tinkerpop.blueprints.Direction;
 
 
@@ -13,8 +12,6 @@ public interface TypeDefinition {
      */
     public String getName();
 
-    public TypeGroup getGroup();
-
     public long[] getPrimaryKey();
 
     public long[] getSignature();

File: titan-test/src/test/java/com/thinkaurelius/titan/graphdb/serializer/SerializerTest.java
Patch:
@@ -239,11 +239,11 @@ public void enumSerializeTest() {
 
     @Test
     public void serializeRelationshipType() {
-        StandardLabelDefinition relType = new StandardLabelDefinition("testName", SystemTypeManager.SYSTEM_TYPE_GROUP,
+        StandardLabelDefinition relType = new StandardLabelDefinition("testName",
         new boolean[2], new boolean[2], new boolean[2], false, true, new long[0], new long[0], false);
 
 
-        StandardKeyDefinition propType = new StandardKeyDefinition("testName", SystemTypeManager.SYSTEM_TYPE_GROUP,
+        StandardKeyDefinition propType = new StandardKeyDefinition("testName",
         new boolean[]{false,true}, new boolean[]{false,true}, new boolean[2], false ,true , new long[0], new long[0],
                 new IndexType[]{IndexType.of(Vertex.class)}, String.class);
         DataOutput out = serialize.getDataOutput(128, true);

File: src/main/java/com/thinkaurelius/faunus/Tokens.java
Patch:
@@ -54,7 +54,8 @@ public static String makeNamespace(final Class klass) {
     public static final String NEWLINE = "\n";
     public static final String EMPTY_STRING = "";
 
-    public static final String FAUNUS_JOB_JAR = "faunus-" + VERSION + "-job.jar";
+    // TODO: FIX BEFORE RELEASE
+    public static final String FAUNUS_JOB_JAR = "faunus-" + "0.3.2-SNAPSHOT" + "-job.jar";
     public static final String FAUNUS_HOME = "FAUNUS_HOME";
 
     public static final String PART = "part";

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -433,7 +433,7 @@ private void checkSeniority(KeyColumn target, ConsistentKeyLockStatus ls, Iterab
          * these two seem most likely.
          */
         if (0 == trCount) {
-            throw new PermanentLockingException("No lock columns found for " + target);
+            throw new TemporaryLockingException("No lock columns found for " + target);
         } else {
             final String msg = "Read "
                     + trCount

File: titan-test/src/test/java/com/thinkaurelius/titan/diskstorage/locking/ConsistentKeyLockerTest.java
Patch:
@@ -362,10 +362,10 @@ public void testCheckLocksIgnoresSingleExpiredLock() throws StorageException, In
                         defaultLockVal));
 
         ctrl.replay();
-        PermanentLockingException ple = null;
+        TemporaryLockingException ple = null;
         try {
             locker.checkLocks(defaultTx);
-        } catch (PermanentLockingException e) {
+        } catch (TemporaryLockingException e) {
             ple = e;
         }
         assertNotNull(ple);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraTransaction.java
Patch:
@@ -7,7 +7,7 @@
 
 /**
  * This class overrides and adds nothing compared with
- * {@link com.thinkaurelius.titan.diskstorage.locking.consistentkey.ConsistentKeyLockTransaction}; however, it creates a transaction type specific
+ * {@link com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction}; however, it creates a transaction type specific
  * to Cassandra, which lets us check for user errors like passing a HBase
  * transaction into a Cassandra method.
  *

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -193,8 +193,8 @@ StaticBuffer[] getLocalKeyPartition() throws StorageException {
     public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, StoreTransaction txh) throws StorageException {
         Preconditions.checkNotNull(mutations);
 
-        long deletionTimestamp = TimeUtility.getApproxNSSinceEpoch(false);
-        long additionTimestamp = TimeUtility.getApproxNSSinceEpoch(true);
+        long deletionTimestamp = TimeUtility.INSTANCE.getApproxNSSinceEpoch(false);
+        long additionTimestamp = TimeUtility.INSTANCE.getApproxNSSinceEpoch(true);
 
         int size = 0;
         for (Map<StaticBuffer, KCVMutation> mutation : mutations.values()) size += mutation.size();

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -153,8 +153,8 @@ public void close() throws StorageException {
     public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, StoreTransaction txh) throws StorageException {
         Preconditions.checkNotNull(mutations);
 
-        long deletionTimestamp = TimeUtility.getApproxNSSinceEpoch(false);
-        long additionTimestamp = TimeUtility.getApproxNSSinceEpoch(true);
+        long deletionTimestamp = TimeUtility.INSTANCE.getApproxNSSinceEpoch(false);
+        long additionTimestamp = TimeUtility.INSTANCE.getApproxNSSinceEpoch(true);
 
         ConsistencyLevel consistency = getTx(txh).getWriteConsistencyLevel().getThriftConsistency();
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/TransactionalIDManager.java
Patch:
@@ -58,7 +58,7 @@ public long[] getIDBlock(int partition) throws StorageException {
                 log.warn("Storage exception while allocating id block - retrying in {} ms: {}", idApplicationWaitMS, e);
                 if (txh != null) txh.rollback();
                 if (idApplicationWaitMS > 0)
-                    TimeUtility.sleepUntil(System.currentTimeMillis() + idApplicationWaitMS, log);
+                    TimeUtility.INSTANCE.sleepUntil(System.currentTimeMillis() + idApplicationWaitMS, log);
             }
         }
         throw new TemporaryLockingException("Exceeded timeout count [" + idApplicationRetryCount + "] when attempting to allocate next id block");
@@ -96,7 +96,7 @@ public long peekNextID(int partition) throws StorageException {
                 log.warn("Storage exception while reading id block - retrying in {} ms: {}", idApplicationWaitMS, e);
                 if (txh != null) txh.rollback();
                 if (idApplicationWaitMS > 0)
-                    TimeUtility.sleepUntil(System.currentTimeMillis() + idApplicationWaitMS, log);
+                    TimeUtility.INSTANCE.sleepUntil(System.currentTimeMillis() + idApplicationWaitMS, log);
             }
         }
         throw new TemporaryLockingException("Exceeded timeout count [" + idApplicationRetryCount + "] when attempting to read id block");

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KeyColumnValueStore.java
Patch:
@@ -3,7 +3,6 @@
 import com.google.common.collect.ImmutableList;
 import com.thinkaurelius.titan.diskstorage.StaticBuffer;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.locking.LockingException;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
 
 import java.util.List;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/LocalLockMediatorProvider.java
Patch:
@@ -1,4 +1,5 @@
-package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
+package com.thinkaurelius.titan.diskstorage.locking;
+
 
 /**
  * Service provider interface for {@link LocalLockMediators}.
@@ -23,6 +24,6 @@ public interface LocalLockMediatorProvider {
      * @author Dan LaRocque <dalaro@hopcount.org>
      * @see LocalLockMediator
      */
-    public LocalLockMediator get(String namespace);
+    public <T> LocalLockMediator<T> get(String namespace);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/PermanentLockingException.java
Patch:
@@ -9,7 +9,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class PermanentLockingException extends PermanentStorageException implements LockingException {
+public class PermanentLockingException extends PermanentStorageException {
 
     private static final long serialVersionUID = 482890657293484420L;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/TemporaryLockingException.java
Patch:
@@ -10,7 +10,7 @@
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class TemporaryLockingException extends TemporaryStorageException implements LockingException {
+public class TemporaryLockingException extends TemporaryStorageException {
 
     private static final long serialVersionUID = 482890657293484420L;
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseTransaction.java
Patch:
@@ -5,7 +5,7 @@
 
 /**
  * This class overrides and adds nothing compared with
- * {@link com.thinkaurelius.titan.diskstorage.locking.consistentkey.ConsistentKeyLockTransaction}; however, it creates a transaction type specific
+ * {@link com.thinkaurelius.titan.diskstorage.locking.consistentkey.ExpectedValueCheckingTransaction}; however, it creates a transaction type specific
  * to HBase, which lets us check for user errors like passing a Cassandra
  * transaction into a HBase method.
  *

File: src/main/java/com/thinkaurelius/faunus/formats/EdgeCopyMapReduce.java
Patch:
@@ -28,7 +28,6 @@ public enum Counters {
         EDGES_ADDED
     }
 
-
     public static Configuration createConfiguration(final Direction direction) {
         final Configuration configuration = new EmptyConfiguration();
         configuration.setEnum(FAUNUS_GRAPH_INPUT_EDGE_COPY_DIRECTION, direction);
@@ -51,7 +50,6 @@ public void setup(final Mapper.Context context) throws IOException, InterruptedE
 
         @Override
         public void map(final NullWritable key, final FaunusVertex value, final Mapper<NullWritable, FaunusVertex, LongWritable, Holder<FaunusVertex>>.Context context) throws IOException, InterruptedException {
-            System.err.println("map phase (edge copy): " + value.getProperty("amp3_long_id"));
             long edgesInverted = 0;
             for (final Edge edge : value.getEdges(this.direction)) {
                 final long id = (Long) edge.getVertex(this.direction.opposite()).getId();
@@ -92,7 +90,6 @@ public void reduce(final LongWritable key, final Iterable<Holder<FaunusVertex>>
                     this.vertex.addAll(holder.get());
                 }
             }
-            System.err.println("reduce phase (edge copy): " + this.vertex.getProperty("amp3_long_id"));
             context.write(NullWritable.get(), this.vertex);
             context.getCounter(Counters.EDGES_ADDED).increment(edgesAggregated);
         }

File: src/main/java/com/thinkaurelius/faunus/formats/BlueprintsGraphOutputMapReduce.java
Patch:
@@ -124,7 +124,6 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
             try {
                 // Read (and/or Write) FaunusVertex (and respective properties) to Blueprints Graph
                 // Attempt to use the ID provided by Faunus
-                System.err.println(value.getProperty("amp3_long_id") + " amp3_long_id");
                 final Vertex blueprintsVertex = this.getOrCreateVertex(value, context);
 
                 // Propagate shell vertices with Blueprints ids

File: src/main/java/com/thinkaurelius/faunus/formats/EdgeCopyMapReduce.java
Patch:
@@ -51,6 +51,7 @@ public void setup(final Mapper.Context context) throws IOException, InterruptedE
 
         @Override
         public void map(final NullWritable key, final FaunusVertex value, final Mapper<NullWritable, FaunusVertex, LongWritable, Holder<FaunusVertex>>.Context context) throws IOException, InterruptedException {
+            System.err.println("map phase (edge copy): " + value.getProperty("amp3_long_id"));
             long edgesInverted = 0;
             for (final Edge edge : value.getEdges(this.direction)) {
                 final long id = (Long) edge.getVertex(this.direction.opposite()).getId();
@@ -91,6 +92,7 @@ public void reduce(final LongWritable key, final Iterable<Holder<FaunusVertex>>
                     this.vertex.addAll(holder.get());
                 }
             }
+            System.err.println("reduce phase (edge copy): " + this.vertex.getProperty("amp3_long_id"));
             context.write(NullWritable.get(), this.vertex);
             context.getCounter(Counters.EDGES_ADDED).increment(edgesAggregated);
         }

File: src/main/java/com/thinkaurelius/faunus/formats/BlueprintsGraphOutputMapReduce.java
Patch:
@@ -124,6 +124,7 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
             try {
                 // Read (and/or Write) FaunusVertex (and respective properties) to Blueprints Graph
                 // Attempt to use the ID provided by Faunus
+                System.err.println(value.getProperty("amp3_long_id") + " amp3_long_id");
                 final Vertex blueprintsVertex = this.getOrCreateVertex(value, context);
 
                 // Propagate shell vertices with Blueprints ids

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -298,6 +298,7 @@ private void ensureKeyspaceExists(String keyspaceName) throws StorageException {
         }
         try {
             MigrationManager.announceNewKeyspace(ksm);
+            log.debug("Created keyspace {}", keyspaceName);
         } catch (ConfigurationException e) {
             throw new PermanentStorageException("Failed to create keyspace " + keyspaceName, e);
         }
@@ -325,7 +326,7 @@ private void ensureColumnFamilyExists(String keyspaceName, String columnfamilyNa
         try {
             CompressionParameters cp = new CompressionParameters(new SnappyCompressor(), 64 * 1024, ImmutableMap.<String, String>of());
             cfm.compressionParameters(cp);
-            log.warn("Set CompressionParameters {}", cp);
+            log.debug("Set CompressionParameters {}", cp);
         } catch (ConfigurationException e) {
             throw new PermanentStorageException("Failed to create compression parameters for " + keyspaceName + ":" + columnfamilyName, e);
         }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/ExternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -14,7 +14,7 @@ public class ExternalAstyanaxKeyColumnValueTest extends KeyColumnValueStoreTest
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
+        return new AstyanaxStoreManager(CassandraStorageSetup.getGenericCassandraStorageConfiguration(getClass().getSimpleName()));
     }
 
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/ExternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -13,7 +13,7 @@ public class ExternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnVa
 
     @Override
     public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
-        Configuration sc = CassandraStorageSetup.getCassandraStorageConfiguration();
+        Configuration sc = CassandraStorageSetup.getGenericCassandraStorageConfiguration(getClass().getSimpleName());
         return new AstyanaxStoreManager(sc);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/ExternalAstyanaxMultiWriteKeyColumnValueTest.java
Patch:
@@ -12,7 +12,7 @@ public class ExternalAstyanaxMultiWriteKeyColumnValueTest extends MultiWriteKeyC
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
+        return new AstyanaxStoreManager(CassandraStorageSetup.getGenericCassandraStorageConfiguration(getClass().getSimpleName()));
     }
 
     public static CassandraProcessStarter ch = new CassandraProcessStarter();

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -17,6 +17,6 @@ public static void startCassandra() {
 
     @Override
     public AbstractCassandraStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
+        return new AstyanaxStoreManager(CassandraStorageSetup.getGenericCassandraStorageConfiguration(getClass().getSimpleName()));
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/InternalCassandraEmbeddedLockKeyColumnValueStoreTest.java
Patch:
@@ -1,16 +1,17 @@
 package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
+import org.apache.commons.configuration.Configuration;
+
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import org.apache.commons.configuration.Configuration;
 
 public class InternalCassandraEmbeddedLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 
     @Override
     public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
-        Configuration sc = CassandraStorageSetup.getEmbeddedCassandraStorageConfiguration(true);
+        Configuration sc = CassandraStorageSetup.getEmbeddedCassandraStorageConfiguration(getClass().getSimpleName(), true);
         return new CassandraEmbeddedStoreManager(sc);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ExternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -15,7 +15,7 @@ public class ExternalCassandraLockKeyColumnValueStoreTest extends LockKeyColumnV
 
     @Override
     public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
-        Configuration sc = CassandraStorageSetup.getCassandraStorageConfiguration();
+        Configuration sc = CassandraStorageSetup.getGenericCassandraStorageConfiguration(getClass().getSimpleName());
         return new CassandraThriftStoreManager(sc);
     }
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ExternalCassandraThriftKeyColumnValueTest.java
Patch:
@@ -15,7 +15,7 @@ public class ExternalCassandraThriftKeyColumnValueTest extends KeyColumnValueSto
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new CassandraThriftStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
+        return new CassandraThriftStoreManager(CassandraStorageSetup.getGenericCassandraStorageConfiguration(getClass().getSimpleName()));
     }
 
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/ExternalCassandraThriftMultiWriteKeyColumnValueTest.java
Patch:
@@ -15,7 +15,7 @@ public class ExternalCassandraThriftMultiWriteKeyColumnValueTest extends MultiWr
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new CassandraThriftStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
+        return new CassandraThriftStoreManager(CassandraStorageSetup.getGenericCassandraStorageConfiguration(getClass().getSimpleName()));
     }
 
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/ExternalAstyanaxGraphPerformanceTest.java
Patch:
@@ -9,7 +9,7 @@
 public class ExternalAstyanaxGraphPerformanceTest extends TitanGraphPerformanceTest {
 
     public ExternalAstyanaxGraphPerformanceTest() {
-        super(CassandraStorageSetup.getAstyanaxGraphConfiguration(), 0, 1, false);
+        super(CassandraStorageSetup.getAstyanaxGraphConfiguration(ExternalAstyanaxGraphPerformanceTest.class.getSimpleName()), 0, 1, false);
     }
 
     public static CassandraProcessStarter ch = new CassandraProcessStarter();

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/ExternalAstyanaxGraphTest.java
Patch:
@@ -9,7 +9,7 @@
 public class ExternalAstyanaxGraphTest extends TitanGraphTest {
 
     public ExternalAstyanaxGraphTest() {
-        super(CassandraStorageSetup.getAstyanaxGraphConfiguration());
+        super(CassandraStorageSetup.getAstyanaxGraphConfiguration(ExternalAstyanaxGraphTest.class.getSimpleName()));
     }
 
     public static CassandraProcessStarter ch = new CassandraProcessStarter();

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphConcurrentTest.java
Patch:
@@ -13,7 +13,7 @@ public static void startCassandra() {
     }
 
     public InternalAstyanaxGraphConcurrentTest() {
-        super(CassandraStorageSetup.getAstyanaxGraphConfiguration());
+        super(CassandraStorageSetup.getAstyanaxGraphConfiguration(InternalAstyanaxGraphConcurrentTest.class.getSimpleName()));
     }
 
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphTest.java
Patch:
@@ -13,7 +13,7 @@ public static void startCassandra() {
     }
 
     public InternalAstyanaxGraphTest() {
-        super(CassandraStorageSetup.getAstyanaxGraphConfiguration());
+        super(CassandraStorageSetup.getAstyanaxGraphConfiguration(InternalAstyanaxGraphTest.class.getSimpleName()));
     }
 
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/InternalCassandraEmbeddedGraphConcurrentTest.java
Patch:
@@ -10,7 +10,7 @@
 public class InternalCassandraEmbeddedGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     public InternalCassandraEmbeddedGraphConcurrentTest() {
-        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration());
+        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration(InternalCassandraEmbeddedGraphConcurrentTest.class.getSimpleName()));
     }
 
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/InternalCassandraEmbeddedGraphPerformanceTest.java
Patch:
@@ -10,7 +10,7 @@
 public class InternalCassandraEmbeddedGraphPerformanceTest extends TitanGraphPerformanceTest {
 
     public InternalCassandraEmbeddedGraphPerformanceTest() {
-        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration(),0,1,false);
+        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration(InternalCassandraEmbeddedGraphPerformanceTest.class.getSimpleName()),0,1,false);
     }
 
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/embedded/InternalCassandraEmbeddedGraphTest.java
Patch:
@@ -6,7 +6,7 @@
 public class InternalCassandraEmbeddedGraphTest extends TitanGraphTest {
 
     public InternalCassandraEmbeddedGraphTest() {
-        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration());
+        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration(InternalCassandraEmbeddedGraphTest.class.getSimpleName()));
     }
 
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ExternalCassandraGraphConcurrentTest.java
Patch:
@@ -11,7 +11,7 @@ public class ExternalCassandraGraphConcurrentTest extends TitanGraphConcurrentTe
     public static CassandraProcessStarter ch = new CassandraProcessStarter();
 
     public ExternalCassandraGraphConcurrentTest() {
-        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration());
+        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(ExternalCassandraGraphConcurrentTest.class.getSimpleName()));
     }
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ExternalCassandraGraphPerformanceTest.java
Patch:
@@ -12,7 +12,7 @@ public class ExternalCassandraGraphPerformanceTest extends TitanGraphPerformance
     public static CassandraProcessStarter ch = new CassandraProcessStarter();
 
     public ExternalCassandraGraphPerformanceTest() {
-        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(), 0, 1, false);
+        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(ExternalCassandraGraphPerformanceTest.class.getSimpleName()), 0, 1, false);
     }
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/ExternalCassandraGraphTest.java
Patch:
@@ -11,7 +11,7 @@ public class ExternalCassandraGraphTest extends TitanGraphTest {
     public static CassandraProcessStarter ch = new CassandraProcessStarter();
 
     public ExternalCassandraGraphTest() {
-        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration());
+        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(ExternalCassandraGraphTest.class.getSimpleName()));
     }
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphConcurrentTest.java
Patch:
@@ -8,7 +8,7 @@
 public class InternalCassandraGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     public InternalCassandraGraphConcurrentTest() {
-        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration());
+        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(InternalCassandraGraphConcurrentTest.class.getSimpleName()));
     }
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphTest.java
Patch:
@@ -8,7 +8,7 @@
 public class InternalCassandraGraphTest extends TitanGraphTest {
 
     public InternalCassandraGraphTest() {
-        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration());
+        super(CassandraStorageSetup.getCassandraThriftGraphConfiguration(InternalCassandraGraphTest.class.getSimpleName()));
     }
 
     @BeforeClass

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/tinkerpop/rexster/RexsterServerClientCassandraEmbeddedTest.java
Patch:
@@ -8,7 +8,7 @@
 
 public class RexsterServerClientCassandraEmbeddedTest extends RexsterServerClientTest {
     public RexsterServerClientCassandraEmbeddedTest() {
-        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration());
+        super(CassandraStorageSetup.getEmbeddedCassandraPartitionGraphConfiguration(RexsterServerClientCassandraEmbeddedTest.class.getSimpleName()));
     }
 
 }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedStoreManager.java
Patch:
@@ -326,7 +326,7 @@ private void ensureColumnFamilyExists(String keyspaceName, String columnfamilyNa
         try {
             CompressionParameters cp = new CompressionParameters(new SnappyCompressor(), 64 * 1024, ImmutableMap.<String, String>of());
             cfm.compressionParameters(cp);
-            log.warn("Set CompressionParameters {}", cp);
+            log.debug("Set CompressionParameters {}", cp);
         } catch (ConfigurationException e) {
             throw new PermanentStorageException("Failed to create compression parameters for " + keyspaceName + ":" + columnfamilyName, e);
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/tinkerpop/rexster/RexsterTitanServer.java
Patch:
@@ -22,8 +22,8 @@
  * Standalone Titan database with fronting Rexster server.
  *
  * @author Matthias Broecheler (me@matthiasb.com)
+ * @author Stephen Mallette (http://stephen.genoprime.com)
  */
-
 public class RexsterTitanServer {
 
     private static final Logger log =
@@ -77,7 +77,7 @@ public void start() {
         final List<String> allowableNamespaces = new ArrayList<String>() {{
             add("*:*");
         }};
-        final RexsterApplication ra = new DefaultRexsterApplication(DEFAULT_GRAPH_NAME, graph, allowableNamespaces, extensionConfigurations);
+        final RexsterApplication ra = new DefaultRexsterApplication(DEFAULT_GRAPH_NAME, graph, allowableNamespaces, extensionConfigurations, null);
 
         startRexProServer(ra);
         startHttpServer(ra);
@@ -110,7 +110,7 @@ public void stop() {
         graph.shutdown();
     }
 
-    public static void main(String[] args) throws Exception {
+    public static void main(final String[] args) throws Exception {
         RexsterTitanServer server;
         if (args.length == 2) {
             final Configuration titanConfig = new PropertiesConfiguration(args[1]);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -270,8 +270,6 @@ public void clearStorage() throws StorageException {
             }
         } catch (ConnectionException e) {
             throw new PermanentStorageException(e);
-        } finally {
-            close();
         }
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -60,7 +60,9 @@ public void close() throws StorageException {
 
     @Override
     public void clearStorage() throws StorageException {
-        close();
+        for (InMemoryKeyColumnValueStore store : stores.values()) {
+            store.clear();
+        }
     }
 
     @Override

File: titan-hbase/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseLockKeyColumnValueStoreTest.java
Patch:
@@ -16,7 +16,6 @@ public static void startHBase() throws IOException {
     }
 
     public KeyColumnValueStoreManager openStorageManager(int idx) throws StorageException {
-        Configuration sc = HBaseStorageSetup.getHBaseStorageConfiguration();
-        return new HBaseStoreManager(sc);
+        return new HBaseStoreManager(HBaseStorageSetup.getHBaseStorageConfiguration());
     }
 }

File: titan-hbase/src/test/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -20,7 +20,6 @@ public KeyColumnValueStoreManager openStorageManager() throws StorageException {
     }
 
     private Configuration getConfig() {
-        Configuration c = HBaseStorageSetup.getHBaseStorageConfiguration();
-        return c;
+        return HBaseStorageSetup.getHBaseStorageConfiguration();
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -17,6 +17,6 @@ public static void startCassandra() {
 
     @Override
     public AbstractCassandraStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStoreManager(CassandraStorageSetup.getAstyanaxGraphConfiguration());
+        return new AstyanaxStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -17,6 +17,6 @@ public static void startCassandra() {
 
     @Override
     public AbstractCassandraStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStoreManager(CassandraStorageSetup.getAstyanaxGraphConfiguration());
+        return new AstyanaxStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -26,6 +26,7 @@ public class CassandraStorageSetup {
 
     public static Configuration getCassandraStorageConfiguration() {
         BaseConfiguration config = new BaseConfiguration();
+        config.setProperty(GraphDatabaseConfiguration.LOCK_BACKEND, "astyanaxrecipe"); // TODO remove testing hack
         return config;
 
     }
@@ -47,6 +48,7 @@ public static Configuration getEmbeddedCassandraStorageConfiguration(boolean ord
     public static Configuration getAstyanaxGraphConfiguration() {
         BaseConfiguration config = new BaseConfiguration();
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.STORAGE_BACKEND_KEY, "astyanax");
+        config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.LOCK_BACKEND, "astyanaxrecipe"); // TODO remove testing hack
         return config;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockStore.java
Patch:
@@ -12,6 +12,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeySliceQuery;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
+import com.thinkaurelius.titan.diskstorage.locking.Locker;
 import com.thinkaurelius.titan.diskstorage.locking.PermanentLockingException;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
 import com.thinkaurelius.titan.diskstorage.util.RecordIterator;
@@ -38,9 +39,9 @@ public class ConsistentKeyLockStore implements KeyColumnValueStore {
      */
     final KeyColumnValueStore dataStore;
     
-    final ConsistentKeyLocker locker;
+    final Locker locker;
     
-    public ConsistentKeyLockStore(KeyColumnValueStore dataStore, ConsistentKeyLocker locker) {
+    public ConsistentKeyLockStore(KeyColumnValueStore dataStore, Locker locker) {
         Preconditions.checkNotNull(dataStore);
         this.dataStore = dataStore;
         this.locker = locker;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -151,6 +151,9 @@ public class GraphDatabaseConfiguration {
      */
     public static final String LOCK_EXPIRE_MS = "lock-expiry-time";
     public static final long LOCK_EXPIRE_MS_DEFAULT = 300 * 1000;
+    
+    public static final String LOCK_BACKEND = "lock-backend";
+    public static final String LOCK_BACKEND_DEFAULT = "consistentkey";
 
     /**
      * The number of milliseconds the system waits for an id block application to be acknowledged by the storage backend.

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLocker.java
Patch:
@@ -170,7 +170,7 @@ private long tryLockRemotely(KeyColumn lockID, StoreTransaction txh) throws Thro
         for (int i = 0; i < conf.getLockRetryCount(); i++) {
             WriteResult wr = tryWriteLockOnce(lockKey, oldLockCol, txh);
             if (wr.isSuccessful() && wr.getDurationNS() <= conf.getLockWaitNS()) {
-                log.debug("Lock write succeeded {} {}", lockID, txh);
+                log.debug("Wrote lock {} to store {} using {}", new Object[] { lockID, conf.getStore().getName(), txh });
                 return wr.getBeforeNS();
             }
             oldLockCol = wr.getLockCol();
@@ -343,7 +343,7 @@ private void checkSeniority(KeyColumn target, LockStatus ls, Iterable<TimestampR
             }
            
             if (tr.getTimestamp() == ls.getWrittenTimestamp(TimeUnit.NANOSECONDS)) {
-                log.debug("Lock check succeeded for {}", target);
+                log.debug("Checked lock {} in store {}", target, conf.getStore().getName());
                 return;
             }
 

File: src/test/java/com/thinkaurelius/faunus/BaseTest.java
Patch:
@@ -171,6 +171,7 @@ public static Map<Long, FaunusVertex> startPath(final Map<Long, FaunusVertex> gr
 
     public static Map<Long, FaunusVertex> runWithGraph(final Map<Long, FaunusVertex> graph, final MapReduceDriver driver) throws IOException {
         driver.resetOutput();
+        driver.resetExpectedCounters();
         driver.getConfiguration().setBoolean(FaunusCompiler.TESTING, true);
         for (final FaunusVertex vertex : graph.values()) {
             driver.withInput(NullWritable.get(), vertex);
@@ -185,6 +186,7 @@ public static Map<Long, FaunusVertex> runWithGraph(final Map<Long, FaunusVertex>
 
     public static List runWithGraphNoIndex(final Map<Long, FaunusVertex> graph, final MapReduceDriver driver) throws IOException {
         driver.resetOutput();
+        driver.resetExpectedCounters();
         driver.getConfiguration().setBoolean(FaunusCompiler.TESTING, true);
         for (final Vertex vertex : graph.values()) {
             driver.withInput(NullWritable.get(), vertex);

File: src/main/java/com/thinkaurelius/faunus/formats/titan/TitanOutputFormat.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.faunus.formats.MapReduceFormat;
 import com.thinkaurelius.faunus.formats.noop.NoOpOutputFormat;
 import com.thinkaurelius.faunus.mapreduce.FaunusCompiler;
-import org.apache.hadoop.conf.Configuration;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.NullWritable;
 
@@ -28,7 +28,7 @@ public void addMapReduceJobs(final FaunusCompiler compiler) {
                     FaunusVertex.class,
                     NullWritable.class,
                     FaunusVertex.class,
-                    new Configuration());
+                    new EmptyConfiguration());
         }
         compiler.addMapReduce(BlueprintsGraphOutputMapReduce.Map.class,
                 null,

File: src/main/java/com/thinkaurelius/faunus/mapreduce/IdentityMap.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.faunus.FaunusEdge;
 import com.thinkaurelius.faunus.FaunusVertex;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
 import org.apache.hadoop.conf.Configuration;
@@ -26,9 +27,7 @@ public enum Counters {
     }
 
     public static Configuration createConfiguration() {
-        Configuration configuration = new Configuration();
-        configuration.clear();
-        return configuration;
+        return new EmptyConfiguration();
     }
 
     public static class Map extends Mapper<NullWritable, FaunusVertex, NullWritable, FaunusVertex> {

File: src/main/java/com/thinkaurelius/faunus/formats/titan/TitanOutputFormat.java
Patch:
@@ -6,7 +6,7 @@
 import com.thinkaurelius.faunus.formats.MapReduceFormat;
 import com.thinkaurelius.faunus.formats.noop.NoOpOutputFormat;
 import com.thinkaurelius.faunus.mapreduce.FaunusCompiler;
-import org.apache.hadoop.conf.Configuration;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.NullWritable;
 
@@ -28,7 +28,7 @@ public void addMapReduceJobs(final FaunusCompiler compiler) {
                     FaunusVertex.class,
                     NullWritable.class,
                     FaunusVertex.class,
-                    new Configuration());
+                    new EmptyConfiguration());
         }
         compiler.addMapReduce(BlueprintsGraphOutputMapReduce.Map.class,
                 null,

File: src/main/java/com/thinkaurelius/faunus/mapreduce/IdentityMap.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.faunus.FaunusEdge;
 import com.thinkaurelius.faunus.FaunusVertex;
+import com.thinkaurelius.faunus.mapreduce.util.EmptyConfiguration;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
 import org.apache.hadoop.conf.Configuration;
@@ -26,9 +27,7 @@ public enum Counters {
     }
 
     public static Configuration createConfiguration() {
-        Configuration configuration = new Configuration();
-        configuration.clear();
-        return configuration;
+        return new EmptyConfiguration();
     }
 
     public static class Map extends Mapper<NullWritable, FaunusVertex, NullWritable, FaunusVertex> {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/StandardVertex.java
Patch:
@@ -22,7 +22,7 @@
 public class StandardVertex extends AbstractVertex {
 
     private byte lifecycle;
-    private AddedRelationsContainer addedRelations=AddedRelationsContainer.EMPTY;
+    private volatile AddedRelationsContainer addedRelations=AddedRelationsContainer.EMPTY;
 
     public StandardVertex(final StandardTitanTx tx, final long id, byte lifecycle) {
         super(tx, id);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/StandardVertex.java
Patch:
@@ -22,7 +22,7 @@
 public class StandardVertex extends AbstractVertex {
 
     private byte lifecycle;
-    private AddedRelationsContainer addedRelations=AddedRelationsContainer.EMPTY;
+    private volatile AddedRelationsContainer addedRelations=AddedRelationsContainer.EMPTY;
 
     public StandardVertex(final StandardTitanTx tx, final long id, byte lifecycle) {
         super(tx, id);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxOrderedKeyColumnValueStore.java
Patch:
@@ -189,7 +189,7 @@ public void acquireLock(StaticBuffer key, StaticBuffer column, StaticBuffer expe
 
     @Override
     public RecordIterator<StaticBuffer> getKeys(StoreTransaction txh) throws StorageException {
-        return getKeys(null, txh);
+        return getKeys((SliceQuery) null, txh);
     }
 
     @Override

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftKeyColumnValueStore.java
Patch:
@@ -243,7 +243,7 @@ public void acquireLock(StaticBuffer key, StaticBuffer column, StaticBuffer expe
 
     @Override
     public RecordIterator<StaticBuffer> getKeys(final StoreTransaction txh) throws StorageException {
-        return getKeys(null, txh);
+        return getKeys((SliceQuery) null, txh);
     }
 
     @Override

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -117,7 +117,7 @@ public class AstyanaxStoreManager extends AbstractCassandraStoreManager {
      * <p/>
      * Value = {@value}
      */
-    public static final String RETRY_POLICY_DEFAULT = "com.netflix.astyanax.retry.BoundedExponentialBackoff,25,1000,30";
+    public static final String RETRY_POLICY_DEFAULT = "com.netflix.astyanax.retry.BoundedExponentialBackoff,100,25000,8";
     public static final String RETRY_POLICY_KEY = "retry-policy";
 
     private static final ColumnFamily<String, String> PROPERTIES_CF;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -233,8 +233,6 @@ public Edge addEdge(String label, Vertex vertex) {
     @Override
     public <O> O removeProperty(TitanType key) {
         Preconditions.checkArgument(key.isPropertyKey());
-        Preconditions.checkArgument(key.isUnique(Direction.OUT));
-
 
         Object result = null;
         Iterator<TitanProperty> iter = query().type(key).properties().iterator();

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -10,6 +10,7 @@
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.thrift.CfDef;
 import org.apache.commons.configuration.Configuration;
 
 /**

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -117,7 +117,7 @@ public class AstyanaxStoreManager extends AbstractCassandraStoreManager {
      * <p/>
      * Value = {@value}
      */
-    public static final String RETRY_POLICY_DEFAULT = "com.netflix.astyanax.retry.BoundedExponentialBackoff,100,25000,8";
+    public static final String RETRY_POLICY_DEFAULT = "com.netflix.astyanax.retry.BoundedExponentialBackoff,25,1000,30";
     public static final String RETRY_POLICY_KEY = "retry-policy";
 
     private static final ColumnFamily<String, String> PROPERTIES_CF;

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -79,7 +79,6 @@ public static Configuration getEmbeddedCassandraPartitionGraphConfiguration() {
                 cassandraOrderedYamlPath);
         config.subset(GraphDatabaseConfiguration.IDS_NAMESPACE).addProperty(GraphDatabaseConfiguration.IDS_PARTITION_KEY, true);
         config.subset(GraphDatabaseConfiguration.IDS_NAMESPACE).addProperty(GraphDatabaseConfiguration.IDS_FLUSH_KEY, false);
-//        config.subset(GraphDatabaseConfiguration.METRICS_NAMESPACE).addProperty(GraphDatabaseConfiguration.METRICS_CONSOLE_INTERVAL, 3000L);
         return config;
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanFeatures.java
Patch:
@@ -29,6 +29,7 @@ private static Features getBaselineTitanFeatures() {
         features.supportsStringProperty = true;
         features.ignoresSuppliedIds = true;
         features.isPersistent = true;
+        features.isRDFModel = false;
         features.isWrapper = false;
         features.supportsIndices = false;
         features.supportsVertexIndex = false;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -233,6 +233,8 @@ public Edge addEdge(String label, Vertex vertex) {
     @Override
     public <O> O removeProperty(TitanType key) {
         Preconditions.checkArgument(key.isPropertyKey());
+        Preconditions.checkArgument(key.isUnique(Direction.OUT));
+
 
         Object result = null;
         Iterator<TitanProperty> iter = query().type(key).properties().iterator();

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/QueryTitanTestSuite.java
Patch:
@@ -3,17 +3,17 @@
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.core.TitanKey;
 import com.tinkerpop.blueprints.Direction;
-import com.tinkerpop.blueprints.GraphQueryTestSuite;
+import com.tinkerpop.blueprints.QueryTestSuite;
 import com.tinkerpop.blueprints.impls.GraphTest;
 
 /**
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 
-public class TitanGraphQueryTestSuite extends GraphQueryTestSuite {
+public class QueryTitanTestSuite extends QueryTestSuite {
 
 
-    public TitanGraphQueryTestSuite(final GraphTest graphTest) {
+    public QueryTitanTestSuite(final GraphTest graphTest) {
         super(graphTest);
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TitanSpecificBlueprintsTestSuite.java
Patch:
@@ -18,7 +18,7 @@ public void testVertexReattachment() {
         TransactionalGraph graph = (TransactionalGraph) graphTest.generateGraph();
         Vertex a = graph.addVertex(null);
         Vertex b = graph.addVertex(null);
-        Edge e = graph.addEdge(null, a, b, "friend");
+        Edge e = graph.addEdge(null, a, b, convertId(graph, "friend"));
         graph.commit();
 
         a = graph.getVertex(a);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsTransaction.java
Patch:
@@ -98,6 +98,9 @@ public Edge addEdge(Object id, Vertex outVertex, Vertex inVertex, String label)
 
     @Override
     public TitanEdge addEdge(TitanVertex outVertex, TitanVertex inVertex, String label) {
+        if (null == label) {
+            throw new IllegalArgumentException("Edge label must be non-null");
+        }
         return addEdge(outVertex, inVertex, getEdgeLabel(label));
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/tinkerpop/rexster/RexsterTitanServer.java
Patch:
@@ -97,7 +97,7 @@ private void configureScriptEngine(final RexsterProperties properties) {
 
         // allow scriptengines to be configured so that folks can drop in different gremlin flavors.
         final List configuredScriptEngineNames = properties.getConfiguredScriptEngines();
-        if (configuredScriptEngineNames == null) {
+        if (configuredScriptEngineNames == null || configuredScriptEngineNames.isEmpty()) {
             // configure to default with gremlin-groovy
             log.info("No configuration for <script-engines>.  Using gremlin-groovy by default.");
             EngineController.configure(scriptEngineThreshold, scriptEngineInitFile);

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -79,7 +79,7 @@ public static Configuration getEmbeddedCassandraPartitionGraphConfiguration() {
                 cassandraOrderedYamlPath);
         config.subset(GraphDatabaseConfiguration.IDS_NAMESPACE).addProperty(GraphDatabaseConfiguration.IDS_PARTITION_KEY, true);
         config.subset(GraphDatabaseConfiguration.IDS_NAMESPACE).addProperty(GraphDatabaseConfiguration.IDS_FLUSH_KEY, false);
-        config.subset(GraphDatabaseConfiguration.METRICS_NAMESPACE).addProperty(GraphDatabaseConfiguration.METRICS_CONSOLE_INTERVAL, 3000L);
+//        config.subset(GraphDatabaseConfiguration.METRICS_NAMESPACE).addProperty(GraphDatabaseConfiguration.METRICS_CONSOLE_INTERVAL, 3000L);
         return config;
     }
 }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -386,13 +386,11 @@ public void testMultivaluedVertexPropertyRemoval() {
         // Check that the properties were actually deleted from v
         assertFalse(v.getProperties(key).iterator().hasNext());
         
-        long id = v.getID(); // So we can find v again after clopen()
-        
         // Reopen database
         clopen();
         
         // Retrieve and check our test vertex
-        v = tx.getVertex(id);
+        v = tx.getVertex(v.getID());
         key = tx.getPropertyKey(pname);
         Iterable<TitanProperty> iter = v.getProperties(key);
         assertFalse("Failed to durably remove multivalued property",

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/AbstractElement.java
Patch:
@@ -38,9 +38,9 @@ public boolean equals(Object other) {
         } else if (other==null) {
             return false;
         } else if (this instanceof TitanVertex && other instanceof TitanVertex) {
-            return getId().equals(((TitanVertex)other).getId());
+            return getID() == ((TitanVertex)other).getID();
         } else if (this instanceof TitanEdge && other instanceof TitanEdge) {
-            return getId().equals(((TitanEdge)other).getId());
+            return getID() == ((TitanEdge)other).getID();
         } else {
             return false;
         }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxStoreManager.java
Patch:
@@ -117,7 +117,7 @@ public class AstyanaxStoreManager extends AbstractCassandraStoreManager {
      * <p/>
      * Value = {@value}
      */
-    public static final String RETRY_POLICY_DEFAULT = "com.netflix.astyanax.retry.BoundedExponentialBackoff,25,1000,30";
+    public static final String RETRY_POLICY_DEFAULT = "com.netflix.astyanax.retry.BoundedExponentialBackoff,100,25000,8";
     public static final String RETRY_POLICY_KEY = "retry-policy";
 
     private static final ColumnFamily<String, String> PROPERTIES_CF;

File: titan-core/src/main/java/com/thinkaurelius/titan/tinkerpop/gremlin/Imports.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.tinkerpop.gremlin;
 
+import com.thinkaurelius.titan.core.TypeMaker;
 import com.thinkaurelius.titan.core.attribute.Geo;
 import com.thinkaurelius.titan.core.attribute.Text;
 import com.tinkerpop.blueprints.Query;
@@ -25,6 +26,7 @@ public class Imports {
         imports.add("org.apache.commons.configuration.*");
         imports.add("static " + Geo.class.getName() + ".*");
         imports.add("static " + Text.class.getName() + ".*");
+        imports.add("static " + TypeMaker.UniquenessConsistency.class.getName() + ".*");
         // todo: remove with Gremlin 2.3.1+
         imports.add("static " + Query.Compare.class.getName() + ".*");
     }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -109,15 +109,15 @@ public void mutateMany(Map<String, Map<StaticBuffer, KCVMutation>> mutations, St
             String columnFamily = keyMutation.getKey();
             for (Map.Entry<StaticBuffer, KCVMutation> mutEntry : keyMutation.getValue().entrySet()) {
                 StaticBuffer key = mutEntry.getKey();
+                ByteBuffer keyBB = key.asByteBuffer();
 
                 // Get or create the single Cassandra Mutation object responsible for this key 
-                Map<String, List<org.apache.cassandra.thrift.Mutation>> cfmutation = batch.get(key);
+                Map<String, List<org.apache.cassandra.thrift.Mutation>> cfmutation = batch.get(keyBB);
                 if (cfmutation == null) {
                     cfmutation = new HashMap<String, List<org.apache.cassandra.thrift.Mutation>>(3); // TODO where did the magic number 3 come from?
-                    batch.put(key.asByteBuffer(), cfmutation);
+                    batch.put(keyBB, cfmutation);
                 }
 
-                // 
                 KCVMutation mutation = mutEntry.getValue();
                 List<org.apache.cassandra.thrift.Mutation> thriftMutation =
                         new ArrayList<org.apache.cassandra.thrift.Mutation>(mutations.size());

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -17,7 +17,7 @@
 
 public abstract class KeyColumnValueStoreTest {
 
-    private Logger log = LoggerFactory.getLogger(KeyValueStoreTest.class);
+    private Logger log = LoggerFactory.getLogger(KeyColumnValueStoreTest.class);
 
     int numKeys = 500;
     int numColumns = 50;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/ByteBufferUtil.java
Patch:
@@ -111,7 +111,7 @@ public static final int compare(ByteBuffer b1, ByteBuffer b2) {
             if (p1>=b1.limit()) return -1;
             else if (p2>=b2.limit()) return 1;
             else {
-                byte c1 = b1.get(), c2 = b2.get();
+                byte c1 = b1.get(p1), c2 = b2.get(p2);
                 if (c1 != c2) {
                     if (c1 >= 0 && c2 >= 0) {
                         if (c1 < c2) return -1;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/ByteBufferUtil.java
Patch:
@@ -108,14 +108,14 @@ public static final int compare(ByteBuffer a, ByteBuffer b) {
         int ib = 0;
         int result;
         while (true) {
-            boolean aHasRemaining = ia < a.limit();
-            boolean bHasRemaining = ib < b.limit();
+            boolean aHasRemaining = ia + a.position() < a.limit();
+            boolean bHasRemaining = ib + b.position() < b.limit();
             
             if (!aHasRemaining && bHasRemaining) {
                 result = -1;
                 break;
             } else if (aHasRemaining && bHasRemaining) {
-                byte ca = a.get(ia), cb = b.get(ib);
+                byte ca = a.get(a.position() + ia), cb = b.get(b.position() + ib);
                 if (ca != cb) {
                     if (ca >= 0 && cb >= 0) {
                         if (ca < cb) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -857,7 +857,7 @@ public synchronized void rollback() {
         try {
             txHandle.rollback();
         } catch (Exception e) {
-            throw new TitanException("Could not rollback transaction due to exception during persistence", e);
+            throw new TitanException("Could not rollback transaction due to exception", e);
         } finally {
             close();
         }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -145,7 +145,7 @@ public StoreFeatures getFeatures() {
             try {
                 partitioner = getPartitioner();
             } catch (StorageException e) {
-                throw new TitanException("Could not read partitioner information", e);
+                throw new TitanException("Could not connect to Cassandra to read partitioner information. Please check the connection", e);
             }
             features.supportsScan = true;
             if (partitioner == Partitioner.RANDOM) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -839,7 +839,7 @@ public synchronized void commit() {
                 graph.save(addedRelations.getAll(), deletedRelations.values(), this);
             }
             txHandle.commit();
-        } catch (StorageException e) {
+        } catch (Exception e) {
             try {
                 txHandle.rollback();
             } catch (StorageException e1) {
@@ -856,7 +856,7 @@ public synchronized void rollback() {
         Preconditions.checkArgument(isOpen(), "The transaction has already been closed");
         try {
             txHandle.rollback();
-        } catch (StorageException e) {
+        } catch (Exception e) {
             throw new TitanException("Could not rollback transaction due to exception during persistence", e);
         } finally {
             close();

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/LockKeyColumnValueStoreTest.java
Patch:
@@ -358,8 +358,8 @@ public long getBlockSize(int partitionID) {
 
     @Test
     public void testMultiIDAcquisition() throws StorageException, InterruptedException {
-        final int numPartitions = 2;
-        final int numAcquisitionsPerThreadPartition = 10;
+        final int numPartitions = 4;
+        final int numAcquisitionsPerThreadPartition = 50;
         final int blockSize = 250;
         final IDBlockSizer blockSizer = new IDBlockSizer() {
             @Override
@@ -387,6 +387,7 @@ public void run() {
                                 long[] block = idAuthority.getIDBlock(p);
                                 Assert.assertTrue(nextId <= block[0]);
                                 Assert.assertEquals(block[0] + blockSize, block[1]);
+                                Assert.assertFalse(ids.get(p).contains(block[0]));
                                 ids.get(p).add(block[0]);
                             }
                         }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -147,18 +147,16 @@ public StoreFeatures getFeatures() {
             } catch (StorageException e) {
                 throw new TitanException("Could not read partitioner information", e);
             }
+            features.supportsScan = true;
             if (partitioner == Partitioner.RANDOM) {
                 features.isKeyOrdered = false;
                 features.hasLocalKeyPartition = false;
-                features.supportsScan = true;
             } else if (partitioner == Partitioner.BYTEORDER) {
                 features.isKeyOrdered = true;
                 features.hasLocalKeyPartition = false;
-                features.supportsScan = false;
             } else if (partitioner == Partitioner.LOCALBYTEORDER) {
                 features.isKeyOrdered = true;
                 features.hasLocalKeyPartition = true;
-                features.supportsScan = false;
             } else throw new IllegalArgumentException("Unrecognized partitioner: " + partitioner);
         }
         return features;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -199,7 +199,7 @@ private Iterator<Row> getKeySlice(Token start, Token end, int pageSize) throws S
         return Iterators.filter(rows.iterator(), new Predicate<Row>() {
             @Override
             public boolean apply(@Nullable Row row) {
-                return (row == null) ? false : !(row.cf == null || row.cf.isMarkedForDelete() || row.cf.getColumnCount() == 0);
+                return !(row == null || row.cf == null || row.cf.isMarkedForDelete() || row.cf.hasOnlyTombstones());
             }
         });
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/BlueprintsDefaultTypeMaker.java
Patch:
@@ -7,7 +7,9 @@
 import com.tinkerpop.blueprints.Direction;
 
 /**
+ * {@link DefaultTypeMaker} implementation for Blueprints graphs
  *
+ * @author Matthias Broecheler (me@matthiasb.com)
  */
 public class BlueprintsDefaultTypeMaker implements DefaultTypeMaker {
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsGraph.java
Patch:
@@ -14,9 +14,11 @@
 import java.util.WeakHashMap;
 
 /**
+ * Blueprints specific implementation for {@link TitanGraph}.
+ * Handles thread-bound transactions.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public abstract class TitanBlueprintsGraph implements TitanGraph {
 
     // ########## TRANSACTION HANDLING ###########################

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsTransaction.java
Patch:
@@ -19,9 +19,11 @@
 import java.util.Set;
 
 /**
+ * Blueprints specific implementation of {@link TitanTransaction}.
+ * Provides utility methods that wrap Titan calls with Blueprints terminology.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public abstract class TitanBlueprintsTransaction implements TitanTransaction {
 
     private static final Logger log =

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanFeatures.java
Patch:
@@ -5,6 +5,8 @@
 import com.tinkerpop.blueprints.Features;
 
 /**
+ * Blueprint's features of a TitanGraph.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/AbstractElement.java
Patch:
@@ -7,9 +7,11 @@
 import com.thinkaurelius.titan.core.TitanVertex;
 
 /**
+ * AbstractElement is the base class for all elements in Titan.
+ * It is defined and uniquely identified by its id.
+ *
  * @author Matthias Broecheler (me@matthiasb.com)
  */
-
 public abstract class AbstractElement implements InternalElement {
 
     private long id;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/VertexArrayList.java
Patch:
@@ -54,9 +54,9 @@ public int size() {
     }
 
     @Override
-    public void addAll(VertexList nodelist) {
-        Preconditions.checkArgument(nodelist instanceof VertexArrayList, "Only supporting union of identical lists.");
-        VertexArrayList other = (VertexArrayList) nodelist;
+    public void addAll(VertexList vertexlist) {
+        Preconditions.checkArgument(vertexlist instanceof VertexArrayList, "Only supporting union of identical lists.");
+        VertexArrayList other = (VertexArrayList) vertexlist;
         sorted = false;
         vertices.addAll(other.vertices);
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractVertex.java
Patch:
@@ -78,7 +78,7 @@ public synchronized void remove() {
         //Finally remove internal/hidden relations
         for (TitanRelation r : QueryUtil.queryAll(it())) {
             if (r.getType().equals(SystemKey.VertexState)) r.remove();
-            else throw new IllegalStateException("Cannot remove node since it is still connected");
+            else throw new IllegalStateException("Cannot remove vertex since it is still connected");
         }
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -27,7 +27,8 @@ public InternalRelation it() {
         InternalVertex v = getVertex(0);
         if (v==v.it()) return this;
         else {
-            InternalRelation next = (InternalRelation)getId().findRelation(tx());
+            InternalRelation next = (InternalRelation) RelationIdentifier.get(getVertex(0)
+                                                , type, super.getID()).findRelation(tx());
             if (next==null) throw new InvalidElementException("Relation has been removed",this);
             else return next;
         }

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -677,7 +677,7 @@ public void testThreadBoundTx() {
         assertEquals(55,v3.getProperty("age"));
         v3.setProperty("age", 65);
         assertEquals(65, v3.getProperty("age"));
-
+        e1 = graph.getEdge(e1);
 
         for (Vertex v : new Vertex[]{v1,v2,v3}) {
             assertEquals(2,v.query().direction(Direction.BOTH).labels("knows").count());
@@ -688,6 +688,7 @@ public void testThreadBoundTx() {
         graph.commit();
 
         assertEquals(45,e3.getProperty("time"));
+        assertEquals(5,e1.getProperty("time"));
 
         try {
             //TODO: how to address this? Only allow transactional passing for vertices?

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsGraph.java
Patch:
@@ -3,6 +3,7 @@
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
+import com.thinkaurelius.titan.graphdb.util.ExceptionFactory;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Element;
 import com.tinkerpop.blueprints.Parameter;
@@ -73,6 +74,7 @@ public void stopTransaction(Conclusion conclusion) {
     public abstract TitanTransaction newThreadBoundTransaction();
 
     private TitanTransaction getAutoStartTx() {
+        if (txs==null)  ExceptionFactory.graphShutdown();
         TitanTransaction tx = txs.get();
         if (tx == null) {
             tx = newThreadBoundTransaction();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -27,6 +27,7 @@
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.transaction.TransactionConfig;
 import com.thinkaurelius.titan.graphdb.types.system.SystemTypeManager;
+import com.thinkaurelius.titan.graphdb.util.ExceptionFactory;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Features;
 import org.slf4j.Logger;
@@ -109,6 +110,7 @@ public TitanTransaction newThreadBoundTransaction() {
     }
 
     public StandardTitanTx newTransaction(TransactionConfig configuration) {
+        if (!isOpen) ExceptionFactory.graphShutdown();
         try {
             return new StandardTitanTx(this, configuration, backend.beginTransaction());
         } catch (StorageException e) {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -19,7 +19,7 @@ public class CassandraStorageSetup {
                     "cassandra-tmp", "conf", "127.0.0.1", "cassandra.yaml"},
             File.separator);
     public static final String cassandraOrderedYamlPath = StringUtils.join(
-            new String[]{"file://", System.getProperty("user.dir"), "titan-cassandra", "target",
+            new String[]{"file://", System.getProperty("user.dir"), "target",
                     "cassandra-tmp", "conf", "127.0.0.1", "cassandra-ordered.yaml"},
             File.separator);
 

File: titan-es/src/main/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndex.java
Patch:
@@ -329,7 +329,7 @@ public FilterBuilder getFilter(KeyCondition<String> condition) {
                 }
             } else if (value instanceof String) {
                 if (relation == Text.CONTAINS) {
-                    return FilterBuilders.termFilter(key,(String)value);
+                    return FilterBuilders.termFilter(key,((String)value).toLowerCase());
 //                } else if (relation == Txt.PREFIX) {
 //                    return new PrefixFilter(new Term(key+STR_SUFFIX,(String)value));
 //                } else if (relation == Cmp.EQUAL) {

File: titan-lucene/src/main/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneIndex.java
Patch:
@@ -303,7 +303,7 @@ private final Filter convertQuery(KeyCondition<String> condition) {
                 }
             } else if (value instanceof String) {
                 if (relation == Text.CONTAINS) {
-                    return new TermsFilter(new Term(key,(String)value));
+                    return new TermsFilter(new Term(key,((String)value).toLowerCase()));
 //                } else if (relation == Txt.PREFIX) {
 //                    return new PrefixFilter(new Term(key+STR_SUFFIX,(String)value));
 //                } else if (relation == Cmp.EQUAL) {

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneBerkeleyDBTest.java
Patch:
@@ -11,7 +11,7 @@
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 
-public class LuceneBerkeleyDBTest extends TitanIndexTest {
+public abstract class LuceneBerkeleyDBTest extends TitanIndexTest {
 
     public LuceneBerkeleyDBTest() {
         super(getLuceneBDBConfig(), true, true, true);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/InMemoryStoreManager.java
Patch:
@@ -80,7 +80,7 @@ public void setConfigurationProperty(String key, String value) throws StorageExc
 
     @Override
     public KeyColumnValueStore openDatabase(final String name) throws StorageException {
-        if (!stores.contains(name)) {
+        if (!stores.containsKey(name)) {
             stores.putIfAbsent(name,new InMemoryKeyColumnValueStore(name));
         }
         KeyColumnValueStore store = stores.get(name);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -118,7 +118,7 @@ public long[] getIDBlock(int partition) throws StorageException {
                 boolean success = false;
                 try {
                     long before = System.currentTimeMillis();
-                    idStore.mutate(partitionKey, Arrays.asList(SimpleEntry.of(target, ByteBuffer.allocate(0))), null, txh);
+                    idStore.mutate(partitionKey, Arrays.asList(SimpleEntry.of(target, ByteBuffer.allocate(0))), KeyColumnValueStore.NO_DELETIONS, txh);
                     long after = System.currentTimeMillis();
 
                     if (idApplicationWaitMS < after - before) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -235,7 +235,7 @@ public void save(final Collection<InternalRelation> addedRelations,
                     } else { //STANDARD TitanRelation
                         for (int pos = 0; pos < relation.getLen(); pos++) {
                             InternalVertex node = relation.getVertex(pos);
-                            mutations.put(node, relation);
+                            if (pos==0 || !relation.isLoop()) mutations.put(node, relation);
                             Direction dir = EdgeDirection.fromPosition(pos);
                             if (acquireLocks && relation.getType().isUnique(dir) && !node.isNew()
                                     && ((InternalType) relation.getType()).uniqueLock(dir)) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -154,7 +154,7 @@ public long[] getIDBlock(int partition) throws StorageException {
                         //Delete claim to not pollute id space
                         try {
                             for (int attempt = 0; attempt < rollbackAttempts; attempt++) {
-                                idStore.mutate(partitionKey, null, Arrays.asList(target), txh);
+                                idStore.mutate(partitionKey, KeyColumnValueStore.NO_ADDITIONS, Arrays.asList(target), txh);
                                 break;
                             }
                         } catch (StorageException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/TransactionalIDManager.java
Patch:
@@ -44,7 +44,7 @@ public long[] getIDBlock(int partition) throws StorageException {
                 long current = getCurrentID(partitionKey, txh);
                 Preconditions.checkArgument(Long.MAX_VALUE - blockSize > current, "ID overflow detected");
                 long next = current + blockSize;
-                idStore.mutate(partitionKey, ImmutableList.of(SimpleEntry.of(DEFAULT_COLUMN, ByteBufferUtil.getLongByteBuffer(next))), null, txh);
+                idStore.mutate(partitionKey, ImmutableList.of(SimpleEntry.of(DEFAULT_COLUMN, ByteBufferUtil.getLongByteBuffer(next))), KeyColumnValueStore.NO_DELETIONS, txh);
                 txh.commit();
                 return new long[]{current, next};
             } catch (StorageException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/BufferTransaction.java
Patch:
@@ -57,7 +57,7 @@ public StoreTransaction getWrappedTransactionHandle() {
 
     public void mutate(String store, ByteBuffer key, List<Entry> additions, List<ByteBuffer> deletions) throws StorageException {
         Preconditions.checkNotNull(store);
-        if ((additions == null || additions.isEmpty()) && (deletions == null || deletions.isEmpty())) return;
+        if (additions.isEmpty() && deletions.isEmpty()) return;
 
         KCVMutation m = new KCVMutation(additions, deletions);
         Map<ByteBuffer, KCVMutation> storeMutation = mutations.get(store);
@@ -72,8 +72,8 @@ public void mutate(String store, ByteBuffer key, List<Entry> additions, List<Byt
             storeMutation.put(key, m);
         }
 
-        if (additions != null) numMutations += additions.size();
-        if (deletions != null) numMutations += deletions.size();
+        numMutations += additions.size();
+        numMutations += deletions.size();
 
         if (numMutations >= bufferSize) {
             flushInternal();

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/inmemory/ColumnValueStore.java
Patch:
@@ -75,7 +75,7 @@ List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) {
     synchronized void mutate(List<Entry> additions, List<ByteBuffer> deletions, StoreTransaction txh) {
         //Prepare data
         CacheEntry[] add;
-        if (additions!=null && !additions.isEmpty()) {
+        if (!additions.isEmpty()) {
             add = new CacheEntry[additions.size()];
             int pos = 0;
             for (Entry e : additions) {
@@ -87,7 +87,7 @@ synchronized void mutate(List<Entry> additions, List<ByteBuffer> deletions, Stor
 
         //Filter out deletions that are also added
         ByteBuffer[] del;
-        if (deletions!=null && !deletions.isEmpty()) {
+        if (!deletions.isEmpty()) {
             Iterator<ByteBuffer> iter = deletions.iterator();
             while (iter.hasNext()) {
                 if (Arrays.binarySearch(add,new SimpleEntry(iter.next(),null))>=0) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/KeyValueStoreAdapter.java
Patch:
@@ -49,14 +49,14 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
 
     @Override
     public void mutate(ByteBuffer key, List<Entry> additions, List<ByteBuffer> deletions, StoreTransaction txh) throws StorageException {
-        if (deletions != null && !deletions.isEmpty()) {
+        if (!deletions.isEmpty()) {
             for (ByteBuffer column : deletions) {
                 ByteBuffer del = concatenate(key, column);
                 store.delete(del, txh);
             }
 
         }
-        if (additions != null && !additions.isEmpty()) {
+        if (!additions.isEmpty()) {
             for (Entry entry : additions) {
                 ByteBuffer newkey = concatenate(key, entry.getColumn());
                 store.insert(newkey, entry.getValue(), txh);

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockTransaction.java
Patch:
@@ -173,13 +173,13 @@ public void writeBlindLockClaim(
                 Entry addition = SimpleEntry.of(lc.getLockCol(tsNS, backer.getRid()), valBuf);
 
                 long before = System.currentTimeMillis();
-                backer.getLockStore().mutate(lockKey, Arrays.asList(addition), null, consistentTx);
+                backer.getLockStore().mutate(lockKey, Arrays.asList(addition), KeyColumnValueStore.NO_DELETIONS, consistentTx);
                 long after = System.currentTimeMillis();
 
                 if (backer.getLockWaitMS() < after - before) {
                     // Too slow
                     // Delete lock claim and loop again
-                    backer.getLockStore().mutate(lockKey, null, Arrays.asList(lc.getLockCol(tsNS, backer.getRid())), consistentTx);
+                    backer.getLockStore().mutate(lockKey, KeyColumnValueStore.NO_ADDITIONS, Arrays.asList(lc.getLockCol(tsNS, backer.getRid())), consistentTx);
                 } else {
                     ok = true;
                     lastLockApplicationTimesMS.put(backer, before);
@@ -346,7 +346,7 @@ private void unlockAll() {
 
             try {
                 // Release lock remotely
-                lc.getBacker().getLockStore().mutate(lockKeyBuf, null, Arrays.asList(lockColBuf), consistentTx);
+                lc.getBacker().getLockStore().mutate(lockKeyBuf, KeyColumnValueStore.NO_ADDITIONS, Arrays.asList(lockColBuf), consistentTx);
 
                 if (log.isTraceEnabled()) {
                     log.trace("Wrote unlock {}", lc);

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreUtil.java
Patch:
@@ -14,7 +14,7 @@ public class KeyColumnValueStoreUtil {
     public static void delete(KeyColumnValueStore store, StoreTransaction txn, long key, String col) throws StorageException {
         ByteBuffer k = longToByteBuffer(key);
         ByteBuffer c = stringToByteBuffer(col);
-        store.mutate(k, null, Arrays.asList(c), txn);
+        store.mutate(k, KeyColumnValueStore.NO_ADDITIONS, Arrays.asList(c), txn);
     }
 
     public static String get(KeyColumnValueStore store, StoreTransaction txn, long key, String col) throws StorageException {
@@ -30,7 +30,7 @@ public static void insert(KeyColumnValueStore store, StoreTransaction txn, long
         ByteBuffer k = longToByteBuffer(key);
         ByteBuffer c = stringToByteBuffer(col);
         ByteBuffer v = stringToByteBuffer(val);
-        store.mutate(k, Arrays.asList(SimpleEntry.of(c, v)), null, txn);
+        store.mutate(k, Arrays.asList(SimpleEntry.of(c, v)), KeyColumnValueStore.NO_DELETIONS, txn);
     }
 
     public static String byteBufferToString(ByteBuffer b) {

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/AstyanaxOrderedKeyColumnValueStore.java
Patch:
@@ -165,7 +165,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
                 break;
             }
 
-            result.add(new Entry(colName, c.getByteBufferValue()));
+            result.add(CacheEntry.of(colName, c.getByteBufferValue()));
 
             if (++i == limit) {
                 break;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -375,7 +375,7 @@ private List<Entry> cfToEntries(ColumnFamily cf, ByteBuffer columnStart,
             if (columnEnd.equals(name))
                 continue;
 
-            result.add(new Entry(name, value));
+            result.add(CacheEntry.of(name, value));
         }
 
         return result;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftKeyColumnValueStore.java
Patch:
@@ -124,7 +124,7 @@ public List<Entry> getSlice(KeySliceQuery query, StoreTransaction txh) throws St
                 // Skip column if it is equal to columnEnd because columnEnd is exclusive
                 if (query.getSliceEnd().equals(c.bufferForName())) continue;
 
-                result.add(new Entry(c.bufferForName(), c.bufferForValue()));
+                result.add(CacheEntry.of(c.bufferForName(), c.bufferForValue()));
             }
             return result;
         } catch (Exception e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/ConsistentKeyIDManager.java
Patch:
@@ -104,7 +104,7 @@ public long[] getIDBlock(int partition) throws StorageException {
                 boolean success = false;
                 try {
                     long before = System.currentTimeMillis();
-                    idStore.mutate(partitionKey, Arrays.asList(new Entry(target, ByteBuffer.allocate(0))), null, txh);
+                    idStore.mutate(partitionKey, Arrays.asList(SimpleEntry.of(target, ByteBuffer.allocate(0))), null, txh);
                     long after = System.currentTimeMillis();
 
                     if (idApplicationWaitMS < after - before) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/TransactionalIDManager.java
Patch:
@@ -44,7 +44,7 @@ public long[] getIDBlock(int partition) throws StorageException {
                 long current = getCurrentID(partitionKey, txh);
                 Preconditions.checkArgument(Long.MAX_VALUE - blockSize > current, "ID overflow detected");
                 long next = current + blockSize;
-                idStore.mutate(partitionKey, ImmutableList.of(new Entry(DEFAULT_COLUMN, ByteBufferUtil.getLongByteBuffer(next))), null, txh);
+                idStore.mutate(partitionKey, ImmutableList.of(SimpleEntry.of(DEFAULT_COLUMN, ByteBufferUtil.getLongByteBuffer(next))), null, txh);
                 txh.commit();
                 return new long[]{current, next};
             } catch (StorageException e) {

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/KeyValueStoreAdapter.java
Patch:
@@ -108,7 +108,7 @@ private List<Entry> convert(List<KeyValueEntry> entries) {
         if (entries == null) return null;
         List<Entry> newentries = new ArrayList<Entry>(entries.size());
         for (KeyValueEntry entry : entries) {
-            newentries.add(new Entry(getColumn(entry.getKey()), entry.getValue()));
+            newentries.add(new CacheEntry(getColumn(entry.getKey()), entry.getValue()));
         }
         return newentries;
     }
@@ -128,7 +128,7 @@ private Map<ByteBuffer, List<Entry>> convertKey(List<KeyValueEntry> entries) {
                 key = currentKey;
                 newentries = new ArrayList<Entry>((int) Math.sqrt(entries.size()));
             }
-            newentries.add(new Entry(getColumn(entry.getKey()), entry.getValue()));
+            newentries.add(new CacheEntry(getColumn(entry.getKey()), entry.getValue()));
         }
         if (key != null) {
             assert newentries != null;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheEdge.java
Patch:
@@ -5,6 +5,7 @@
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.TitanLabel;
 import com.thinkaurelius.titan.core.TitanType;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.CacheEntry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
@@ -80,7 +81,8 @@ public long getID() {
     }
 
     private ImmutableLongObjectMap getMap() {
-        ImmutableLongObjectMap map = data.getCache();
+        ImmutableLongObjectMap map = null;
+        if (data instanceof CacheEntry) map = ((CacheEntry)data).getCache();
         if (map==null) {
             map = tx().getGraph().getEdgeSerializer().readProperties(getVertex(position),data,tx());
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/CacheProperty.java
Patch:
@@ -4,6 +4,7 @@
 import com.google.common.collect.Iterables;
 import com.thinkaurelius.titan.core.TitanKey;
 import com.thinkaurelius.titan.core.TitanType;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.CacheEntry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
 import com.thinkaurelius.titan.graphdb.internal.ElementLifeCycle;
 import com.thinkaurelius.titan.graphdb.internal.InternalRelation;
@@ -74,7 +75,8 @@ public long getID() {
     }
 
     private ImmutableLongObjectMap getMap() {
-        ImmutableLongObjectMap map = data.getCache();
+        ImmutableLongObjectMap map = null;
+        if (data instanceof CacheEntry) map = ((CacheEntry)data).getCache();
         if (map==null) {
             map = tx().getGraph().getEdgeSerializer().readProperties(getVertex(0),data,tx());
         }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/CacheVertex.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SimpleEntry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SliceQuery;
 import com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;
 import com.thinkaurelius.titan.graphdb.vertices.querycache.ConcurrentQueryCache;
@@ -45,7 +46,7 @@ public Iterable<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery, Lis
                 }
             }
             if (queryCache.isCovered(query)) {
-                SortedSet<Entry> results = relationCache.subSet(new Entry(query.getSliceStart(),null),new Entry(query.getSliceEnd(),null));
+                SortedSet<Entry> results = relationCache.subSet(new SimpleEntry(query.getSliceStart(),null),new SimpleEntry(query.getSliceEnd(),null));
                 return results;
             } else {
                 List<Entry> results = lookup.get(query);

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseKeyColumnValueStore.java
Patch:
@@ -181,7 +181,7 @@ private List<Entry> getHelper(ByteBuffer key, Filter getFilter) throws StorageEx
 
             if (null != fmap) {
                 for (Map.Entry<byte[], byte[]> ent : fmap.entrySet()) {
-                    ret.add(new Entry(ByteBuffer.wrap(ent.getKey()), ByteBuffer.wrap(ent.getValue())));
+                    ret.add(CacheEntry.of(ByteBuffer.wrap(ent.getKey()), ByteBuffer.wrap(ent.getValue())));
                 }
             }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreUtil.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Entry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStore;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.SimpleEntry;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 
 import java.io.UnsupportedEncodingException;
@@ -29,7 +30,7 @@ public static void insert(KeyColumnValueStore store, StoreTransaction txn, long
         ByteBuffer k = longToByteBuffer(key);
         ByteBuffer c = stringToByteBuffer(col);
         ByteBuffer v = stringToByteBuffer(val);
-        store.mutate(k, Arrays.asList(new Entry(c, v)), null, txn);
+        store.mutate(k, Arrays.asList(SimpleEntry.of(c, v)), null, txn);
     }
 
     public static String byteBufferToString(ByteBuffer b) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardTypeMaker.java
Patch:
@@ -13,6 +13,7 @@
 import com.tinkerpop.blueprints.Vertex;
 import org.apache.commons.lang.StringUtils;
 
+import java.lang.reflect.Modifier;
 import java.util.*;
 
 import static com.tinkerpop.blueprints.Direction.IN;
@@ -125,6 +126,8 @@ public TitanKey makePropertyKey() {
         isUnidirectional=false;
         Preconditions.checkArgument(dataType!=null,"Need to specify a datatype");
         Preconditions.checkArgument(!dataType.isPrimitive(),"Primitive types are not supported. Use the corresponding object type, e.g. Integer.class instead of int.class [%s]",dataType);
+        Preconditions.checkArgument(!dataType.isInterface(),"Datatype must be a class and not an interface: %s",dataType);
+        Preconditions.checkArgument(dataType.isArray() || !Modifier.isAbstract(dataType.getModifiers()),"Datatype cannot be an abstract class: %s",dataType);
         Preconditions.checkArgument(!isUnique[EdgeDirection.position(IN)] ||
                 indexes.contains(IndexType.of(Vertex.class)), "A unique key requires the existence of a standard vertex index");
         return tx.makePropertyKey(new StandardKeyDefinition(name, group, isUnique, hasUniqueLock, isStatic, isHidden, isModifiable,

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/StandardTypeMaker.java
Patch:
@@ -124,6 +124,7 @@ public TitanKey makePropertyKey() {
         checkGeneralArguments();
         isUnidirectional=false;
         Preconditions.checkArgument(dataType!=null,"Need to specify a datatype");
+        Preconditions.checkArgument(!dataType.isPrimitive(),"Primitive types are not supported. Use the corresponding object type, e.g. Integer.class instead of int.class [%s]",dataType);
         Preconditions.checkArgument(!isUnique[EdgeDirection.position(IN)] ||
                 indexes.contains(IndexType.of(Vertex.class)), "A unique key requires the existence of a standard vertex index");
         return tx.makePropertyKey(new StandardKeyDefinition(name, group, isUnique, hasUniqueLock, isStatic, isHidden, isModifiable,

File: src/main/java/com/thinkaurelius/faunus/formats/titan/SchemaInferencerMapReduce.java
Patch:
@@ -7,7 +7,6 @@
 import com.thinkaurelius.titan.graphdb.blueprints.BlueprintsDefaultTypeMaker;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
-import com.tinkerpop.blueprints.TransactionalGraph;
 import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.NullWritable;
 import org.apache.hadoop.mapreduce.Mapper;
@@ -103,7 +102,7 @@ public void reduce(final LongWritable key, final Iterable<FaunusVertex> value, f
 
         @Override
         public void cleanup(final Reducer<LongWritable, FaunusVertex, NullWritable, FaunusVertex>.Context context) throws IOException, InterruptedException {
-            this.graph.stopTransaction(TransactionalGraph.Conclusion.SUCCESS);
+            this.graph.commit();
             this.graph.shutdown();
         }
     }

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/Imports.java
Patch:
@@ -1,5 +1,7 @@
 package com.thinkaurelius.faunus.tinkerpop.gremlin;
 
+import com.tinkerpop.pipes.transform.TransformPipe;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -40,7 +42,7 @@ public class Imports {
         imports.add("com.thinkaurelius.faunus.tinkerpop.gremlin.*");
         imports.add("com.tinkerpop.gremlin.Tokens.T");
         imports.add("com.tinkerpop.gremlin.groovy.*");
-        imports.add("com.thinkaurelius.faunus.Tokens.F");
+        imports.add("static " + TransformPipe.Order.class.getName() + ".*");
 
         // titan
         imports.addAll(com.thinkaurelius.titan.tinkerpop.gremlin.Imports.getImports());

File: src/test/java/com/thinkaurelius/faunus/FaunusPipelineTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.faunus;
 
 import com.thinkaurelius.faunus.formats.titan.cassandra.TitanCassandraOutputFormat;
+import com.tinkerpop.pipes.transform.TransformPipe;
 
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
@@ -54,7 +55,7 @@ public void testPipelineLocking() {
         }
 
         try {
-            pipe.order(Tokens.Order.INCREASING, "name").V();
+            pipe.order(TransformPipe.Order.INCR, "name").V();
             assertTrue(false);
         } catch (IllegalStateException e) {
             assertTrue(true);

File: src/test/java/com/thinkaurelius/faunus/formats/EdgeCopyMapReduceTest.java
Patch:
@@ -22,7 +22,6 @@ public class EdgeCopyMapReduceTest extends BaseTest {
     public void setUp() {
         mapReduceDriver = new MapReduceDriver<NullWritable, FaunusVertex, LongWritable, Holder<FaunusVertex>, NullWritable, FaunusVertex>();
         mapReduceDriver.setMapper(new EdgeCopyMapReduce.Map());
-        mapReduceDriver.setCombiner(new EdgeCopyMapReduce.Combiner());
         mapReduceDriver.setReducer(new EdgeCopyMapReduce.Reduce());
     }
 

File: src/test/java/com/thinkaurelius/faunus/mapreduce/FaunusCompilerTest.java
Patch:
@@ -72,7 +72,7 @@ public void testJobOrder2() throws Exception {
         assertEquals(mapClasses[1], VerticesVerticesMapReduce.Map.class.getName());
         assertEquals(compiler.jobs.get(0).getConfiguration().getStrings(VerticesVerticesMapReduce.LABELS + "-1").length, 1);
         assertEquals(compiler.jobs.get(0).getConfiguration().getStrings(VerticesVerticesMapReduce.LABELS + "-1")[0], "knows");
-        assertEquals(compiler.jobs.get(0).getCombinerClass(), VerticesVerticesMapReduce.Combiner.class);
+        assertEquals(compiler.jobs.get(0).getCombinerClass(), null);
         assertEquals(compiler.jobs.get(0).getReducerClass(), VerticesVerticesMapReduce.Reduce.class);
 
         assertEquals(compiler.jobs.get(1).getMapperClass(), MapSequence.Map.class);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/transform/VerticesVerticesMapReduceTest.java
Patch:
@@ -23,7 +23,6 @@ public class VerticesVerticesMapReduceTest extends BaseTest {
     public void setUp() {
         mapReduceDriver = new MapReduceDriver<NullWritable, FaunusVertex, LongWritable, Holder, NullWritable, FaunusVertex>();
         mapReduceDriver.setMapper(new VerticesVerticesMapReduce.Map());
-        mapReduceDriver.setCombiner(new VerticesVerticesMapReduce.Combiner());
         mapReduceDriver.setReducer(new VerticesVerticesMapReduce.Reduce());
     }
 

File: src/main/java/com/thinkaurelius/faunus/formats/titan/TitanInputFormat.java
Patch:
@@ -26,8 +26,8 @@ public abstract class TitanInputFormat extends InputFormat<NullWritable, FaunusV
 
     public static SliceQuery inputSlice(final VertexQueryFilter inputFilter, final TitanGraph graph) {
         if (inputFilter.limit == 0) {
-            IDManager idManager = (IDManager) ((StandardTitanGraph) graph).getIDInspector();
-            ByteBuffer startColumn, endColumn;
+            final IDManager idManager = (IDManager) ((StandardTitanGraph) graph).getIDInspector();
+            final ByteBuffer startColumn, endColumn;
             startColumn = IDHandler.getEdgeTypeGroup(0, 0, idManager);
             endColumn = IDHandler.getEdgeTypeGroup(idManager.getMaxGroupID() + 1, 0, idManager);
             return new SliceQuery(startColumn, endColumn, Integer.MAX_VALUE);

File: src/main/java/com/thinkaurelius/faunus/formats/titan/hbase/TitanHBaseInputFormat.java
Patch:
@@ -53,6 +53,9 @@ public RecordReader<NullWritable, FaunusVertex> createRecordReader(final InputSp
 
     @Override
     public void setConf(final Configuration config) {
+        this.graph = new FaunusTitanHBaseGraph(GraphFactory.generateTitanConfiguration(config, FAUNUS_GRAPH_INPUT_TITAN));
+        this.pathEnabled = config.getBoolean(FaunusCompiler.PATH_ENABLED, false);
+
         //config.set(TableInputFormat.SCAN_COLUMN_FAMILY, Backend.EDGESTORE_NAME);
         config.set(TableInputFormat.INPUT_TABLE, config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_TABLENAME));
         config.set(HConstants.ZOOKEEPER_QUORUM, config.get(FAUNUS_GRAPH_INPUT_TITAN_STORAGE_HOSTNAME));
@@ -74,8 +77,6 @@ public void setConf(final Configuration config) {
         }
 
         this.tableInputFormat.setConf(config);
-        this.graph = new FaunusTitanHBaseGraph(GraphFactory.generateTitanConfiguration(config, FAUNUS_GRAPH_INPUT_TITAN));
-        this.pathEnabled = config.getBoolean(FaunusCompiler.PATH_ENABLED, false);
     }
 
     private Filter getColumnFilter(InputGraphFilter inputFilter) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/SerializerInitialization.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database.serialize;
 
 import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.attribute.Geoshape;
 import com.thinkaurelius.titan.graphdb.database.serialize.attribute.*;
 import com.thinkaurelius.titan.graphdb.types.*;
 
@@ -34,7 +35,8 @@ public static final void initialize(Serializer serializer) {
         serializer.registerClass(Long.class, new LongSerializer(),KRYO_OFFSET+19);
         serializer.registerClass(IndexType.class,KRYO_OFFSET+20);
         serializer.registerClass(IndexType[].class,KRYO_OFFSET+21);
-        Preconditions.checkArgument(KRYO_OFFSET+21<RESERVED_ID_OFFSET,"ID allocation overflow!");
+        serializer.registerClass(Geoshape.class,KRYO_OFFSET+22);
+        Preconditions.checkArgument(KRYO_OFFSET+22<RESERVED_ID_OFFSET,"ID allocation overflow!");
     }
 
 }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/sideeffect/LinkMapReduce.java
Patch:
@@ -39,7 +39,7 @@ public enum Counters {
         OUT_EDGES_CREATED
     }
 
-    public static Configuration createConfiguration(final Direction direction, final int step, final String label, final String mergeWeightKey) {
+    public static Configuration createConfiguration(final Direction direction, final String label, final int step, final String mergeWeightKey) {
         final Configuration configuration = new EmptyConfiguration();
         configuration.setInt(STEP, step);
         configuration.set(DIRECTION, direction.name());

File: src/test/java/com/thinkaurelius/faunus/mapreduce/sideeffect/LinkMapReduceTest.java
Patch:
@@ -32,7 +32,7 @@ public void setUp() {
 
     public void testKnowsCreatedTraversal() throws Exception {
 
-        Configuration config = LinkMapReduce.createConfiguration(Direction.IN, 0, "knowsCreated", null);
+        Configuration config = LinkMapReduce.createConfiguration(Direction.IN, "knowsCreated", 0, null);
         mapReduceDriver.withConfiguration(config);
 
         Map<Long, FaunusVertex> graph = generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, config);
@@ -61,7 +61,7 @@ public void testKnowsCreatedTraversal() throws Exception {
 
     public void testCreated2Traversal() throws Exception {
 
-        Configuration config = LinkMapReduce.createConfiguration(Direction.OUT, 0, "created2", null);
+        Configuration config = LinkMapReduce.createConfiguration(Direction.OUT, "created2", 0, null);
         mapReduceDriver.withConfiguration(config);
 
         Map<Long, FaunusVertex> graph = generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, config);

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -204,7 +204,7 @@ private Iterator<Row> getKeySlice(Token start, Token end, int pageSize) throws S
         return Iterators.filter(rows.iterator(), new Predicate<Row>() {
             @Override
             public boolean apply(@Nullable Row row) {
-                return (row == null) ? false : !(row.cf == null || row.cf.isMarkedForDelete() || row.cf.getColumnCount() == 0);
+                return !(row == null || row.cf == null || row.cf.isMarkedForDelete() || row.cf.hasOnlyTombstones());
             }
         });
     }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -65,7 +65,7 @@ public class FaunusCompiler extends Configured implements Tool {
 
     public FaunusCompiler(final FaunusGraph graph) {
         this.graph = graph;
-        this.setConf(new Configuration());
+        this.setConf(this.graph.getConfiguration());
     }
 
     private String toStringOfJob(final Class sequenceClass) {
@@ -188,7 +188,7 @@ public void completeSequence() {
 
             this.jobs.add(job);
 
-            this.setConf(new Configuration());
+            this.setConf(this.graph.getConfiguration());
             this.mapSequenceClasses.clear();
             this.combinerClass = null;
             this.reduceClass = null;

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraEmbeddedKeyColumnValueStore.java
Patch:
@@ -204,7 +204,7 @@ private Iterator<Row> getKeySlice(Token start, Token end, int pageSize) throws S
         return Iterators.filter(rows.iterator(), new Predicate<Row>() {
             @Override
             public boolean apply(@Nullable Row row) {
-                return (row == null) ? false : !(row.cf == null || row.cf.isMarkedForDelete() || row.cf.getColumnCount() == 0);
+                return !(row == null || row.cf == null || row.cf.isMarkedForDelete() || row.cf.hasOnlyTombstones());
             }
         });
     }

File: src/main/java/com/thinkaurelius/faunus/formats/FaunusFileOutputFormat.java
Patch:
@@ -32,7 +32,7 @@ public DataOutputStream getDataOuputStream(final TaskAttemptContext job) throws
         final Path file = super.getDefaultWorkFile(job, extension);
         final FileSystem fs = file.getFileSystem(conf);
         if (!isCompressed) {
-            return fs.create(file, false);
+            return new DataOutputStream(fs.create(file, false));
         } else {
             return new DataOutputStream(codec.createOutputStream(fs.create(file, false)));
         }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/util/SafeMapperOutputs.java
Patch:
@@ -23,7 +23,7 @@ public SafeMapperOutputs(final Mapper.Context context) {
         this.testing = this.context.getConfiguration().getBoolean(FaunusCompiler.TESTING, false);
     }
 
-    public void write(final String type, Writable key, Writable value) throws IOException, InterruptedException {
+    public void write(final String type, final Writable key, final Writable value) throws IOException, InterruptedException {
         if (this.testing) {
             if (type.equals(Tokens.SIDEEFFECT))
                 this.context.write(key, value);

File: src/main/java/com/thinkaurelius/faunus/mapreduce/util/SafeReducerOutputs.java
Patch:
@@ -23,7 +23,7 @@ public SafeReducerOutputs(final Reducer.Context context) {
         this.testing = this.context.getConfiguration().getBoolean(FaunusCompiler.TESTING, false);
     }
 
-    public void write(final String type, Writable key, Writable value) throws IOException, InterruptedException {
+    public void write(final String type, final Writable key, final Writable value) throws IOException, InterruptedException {
         if (this.testing) {
             if (type.equals(Tokens.SIDEEFFECT))
                 this.context.write(key, value);

File: src/main/java/com/thinkaurelius/faunus/FaunusElement.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.faunus;
 
+import com.thinkaurelius.titan.core.attribute.Geoshape;
 import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoSerializer;
 import com.tinkerpop.blueprints.Element;
 import com.tinkerpop.blueprints.util.ElementHelper;
@@ -30,7 +31,7 @@ public abstract class FaunusElement implements Element, WritableComparable<Faunu
     protected static final KryoSerializer serialize = new KryoSerializer(true);
 
     /*static {
-        serialize.registerClass(Geoshape.class, 1);
+        serialize.registerClass(Geoshape.class,9090);
     }*/
 
     protected static final Map<String, String> TYPE_MAP = new HashMap<String, String>() {

File: src/test/java/com/thinkaurelius/faunus/formats/BlueprintsGraphOutputMapReduceTest.java
Patch:
@@ -32,7 +32,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new TinkerGraphOutputMapReduce.Reduce());
     }
 
-    public void testTinkerGraphMapping() throws IOException {
+    public void testTinkerGraphMapping() throws Exception {
         mapReduceDriver.withConfiguration(new Configuration());
         final Map<Long, FaunusVertex> graph = runWithGraph(startPath(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, new Configuration()), Vertex.class), mapReduceDriver);
         for (FaunusVertex vertex : graph.values()) {

File: src/test/java/com/thinkaurelius/faunus/formats/sequence/faunus01/FaunusSequenceFileRecordReaderTest.java
Patch:
@@ -32,5 +32,7 @@ public void testConversionWithReader() throws Exception {
             graph.put(value.getIdAsLong(), VertexConverter.buildFaunusVertex(value));
         }
         identicalStructure(graph, BaseTest.ExampleGraph.GRAPH_OF_THE_GODS);
+
+        reader.close();
     }
 }

File: src/test/java/com/thinkaurelius/faunus/mapreduce/IdentityMapTest.java
Patch:
@@ -11,7 +11,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -27,7 +27,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testIdentityNoPaths() throws IOException {
+    public void testIdentityNoPaths() throws Exception {
         mapReduceDriver.withConfiguration(new Configuration());
 
         Map<Long, FaunusVertex> graph = runWithGraph(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, new Configuration()), mapReduceDriver);
@@ -52,7 +52,7 @@ public void testIdentityNoPaths() throws IOException {
         identicalStructure(graph, BaseTest.ExampleGraph.TINKERGRAPH);
     }
 
-    public void testIdentityPaths() throws IOException {
+    public void testIdentityPaths() throws Exception {
         mapReduceDriver.withConfiguration(new Configuration());
 
         Map<Long, FaunusVertex> graph = runWithGraph(startPath(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, new Configuration()), Vertex.class), mapReduceDriver);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/MapSequenceTest.java
Patch:
@@ -7,7 +7,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -23,7 +23,7 @@ public void setUp() throws Exception {
         mapReduceDriver.setReducer(new Reducer<Writable, Writable, Writable, Writable>());
     }
 
-    public void testVertexFiltering() throws IOException {
+    public void testVertexFiltering() throws Exception {
         Configuration config = new Configuration();
         config.setStrings(MapSequence.MAP_CLASSES, IdentityMap.Map.class.getName(), IdentityMap.Map.class.getName(), IdentityMap.Map.class.getName());
         this.mapReduceDriver.withConfiguration(config);
@@ -32,7 +32,7 @@ public void testVertexFiltering() throws IOException {
         identicalStructure(results, ExampleGraph.TINKERGRAPH);
     }
 
-    /*public void testMapReduceOneJob() throws IOException {
+    /*public void testMapReduceOneJob() throws Exception {
         Configuration config = new Configuration();
         config.setStrings(MapSequence.MAP_CLASSES, VerticesVerticesMapReduce.Map.class.getName());
         this.mapReduceDriver.withConfiguration(config);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/filter/CyclicPathFilterMapTest.java
Patch:
@@ -11,7 +11,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
@@ -29,7 +29,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testVertices() throws IOException {
+    public void testVertices() throws Exception {
         Configuration config = CyclicPathFilterMap.createConfiguration(Vertex.class);
         mapReduceDriver.withConfiguration(config);
         Map<Long, FaunusVertex> graph = generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, config);
@@ -68,7 +68,7 @@ public void testVertices() throws IOException {
         identicalStructure(graph, BaseTest.ExampleGraph.TINKERGRAPH);
     }
 
-    public void testEdges() throws IOException {
+    public void testEdges() throws Exception {
         Configuration config = CyclicPathFilterMap.createConfiguration(Edge.class);
 
         mapReduceDriver.withConfiguration(config);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/filter/FilterMapTest.java
Patch:
@@ -11,7 +11,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -27,7 +27,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testVerticesOnName() throws IOException {
+    public void testVerticesOnName() throws Exception {
         Configuration config = FilterMap.createConfiguration(Vertex.class, "{it -> it.name.startsWith('v')}");
         mapReduceDriver.withConfiguration(config);
 
@@ -47,7 +47,7 @@ public void testVerticesOnName() throws IOException {
         identicalStructure(graph, ExampleGraph.TINKERGRAPH);
     }
 
-    public void testEdgesOnWeight() throws IOException {
+    public void testEdgesOnWeight() throws Exception {
         Configuration config = FilterMap.createConfiguration(Edge.class, "{it -> it.weight > 0.19 && it.weight < 0.21}");
         mapReduceDriver.withConfiguration(config);
 

File: src/test/java/com/thinkaurelius/faunus/mapreduce/filter/IntervalFilterMapTest.java
Patch:
@@ -11,7 +11,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -27,7 +27,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testVerticesOnAge() throws IOException {
+    public void testVerticesOnAge() throws Exception {
         Configuration config = IntervalFilterMap.createConfiguration(Vertex.class, "age", 10, 30);
         mapReduceDriver.withConfiguration(config);
 
@@ -46,7 +46,7 @@ public void testVerticesOnAge() throws IOException {
         identicalStructure(graph, ExampleGraph.TINKERGRAPH);
     }
 
-    public void testEdgesOnWeight() throws IOException {
+    public void testEdgesOnWeight() throws Exception {
         Configuration config = IntervalFilterMap.createConfiguration(Edge.class, "weight", 0.3f, 0.45f);
         mapReduceDriver.withConfiguration(config);
         Map<Long, FaunusVertex> graph = runWithGraph(startPath(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, config), Edge.class), mapReduceDriver);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/filter/PropertyFilterMapTest.java
Patch:
@@ -12,7 +12,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -28,7 +28,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testVerticesOnName() throws IOException {
+    public void testVerticesOnName() throws Exception {
         Configuration config = PropertyFilterMap.createConfiguration(Vertex.class, "name", Query.Compare.EQUAL, "marko", "vadas");
         mapReduceDriver.withConfiguration(config);
 
@@ -48,7 +48,7 @@ public void testVerticesOnName() throws IOException {
         identicalStructure(graph, ExampleGraph.TINKERGRAPH);
     }
 
-    public void testEdgesOnWeight() throws IOException {
+    public void testEdgesOnWeight() throws Exception {
         Configuration config = PropertyFilterMap.createConfiguration(Edge.class, "weight", Query.Compare.EQUAL, 0.2f);
         mapReduceDriver.withConfiguration(config);
 

File: src/test/java/com/thinkaurelius/faunus/mapreduce/sideeffect/LinkMapReduceTest.java
Patch:
@@ -10,7 +10,7 @@
 import org.apache.hadoop.io.NullWritable;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
@@ -31,7 +31,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new LinkMapReduce.Reduce());
     }
 
-    public void testKnowsCreatedTraversal() throws IOException {
+    public void testKnowsCreatedTraversal() throws Exception {
 
         Configuration config = LinkMapReduce.createConfiguration(Direction.IN, 0, "knowsCreated", null);
         mapReduceDriver.withConfiguration(config);
@@ -60,7 +60,7 @@ public void testKnowsCreatedTraversal() throws IOException {
         assertEquals(mapReduceDriver.getCounters().findCounter(LinkMapReduce.Counters.IN_EDGES_CREATED).getValue(), 2);
     }
 
-    public void testCreated2Traversal() throws IOException {
+    public void testCreated2Traversal() throws Exception {
 
         Configuration config = LinkMapReduce.createConfiguration(Direction.OUT, 0, "created2", null);
         mapReduceDriver.withConfiguration(config);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/transform/EdgesMapTest.java
Patch:
@@ -11,7 +11,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -27,7 +27,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testEdges() throws IOException {
+    public void testEdges() throws Exception {
         mapReduceDriver.withConfiguration(new Configuration());
 
         Map<Long, FaunusVertex> graph = runWithGraph(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH, new Configuration()), mapReduceDriver);
@@ -47,7 +47,7 @@ public void testEdges() throws IOException {
         identicalStructure(graph, ExampleGraph.TINKERGRAPH);
     }
 
-    public void testEdgesWithPaths() throws IOException {
+    public void testEdgesWithPaths() throws Exception {
         Configuration config = EdgesMap.createConfiguration(false);
         config.setBoolean(FaunusCompiler.PATH_ENABLED, true);
         mapReduceDriver.withConfiguration(config);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/transform/PathMapTest.java
Patch:
@@ -11,7 +11,7 @@
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 import org.apache.hadoop.mrunit.types.Pair;
 
-import java.io.IOException;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
@@ -29,7 +29,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, Text, NullWritable, Text>());
     }
 
-    public void testPathsFromVertices() throws IOException {
+    public void testPathsFromVertices() throws Exception {
         Configuration config = PathMap.createConfiguration(Vertex.class);
         mapReduceDriver.withConfiguration(config);
 
@@ -62,7 +62,7 @@ public void testPathsFromVertices() throws IOException {
         identicalStructure(graph, BaseTest.ExampleGraph.TINKERGRAPH);
     }
 
-    public void testPathsAndGetException() throws IOException {
+    public void testPathsAndGetException() throws Exception {
         Configuration config = PathMap.createConfiguration(Vertex.class);
         config.setBoolean(FaunusCompiler.PATH_ENABLED, false);
 

File: src/test/java/com/thinkaurelius/faunus/mapreduce/transform/VertexMapTest.java
Patch:
@@ -8,7 +8,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -24,7 +24,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testVerticesWith() throws IOException {
+    public void testVerticesWith() throws Exception {
         Configuration config = VertexMap.createConfiguration(1, 2, 2346);
         mapReduceDriver.withConfiguration(config);
 
@@ -48,7 +48,7 @@ public void testVerticesWith() throws IOException {
         identicalStructure(graph, ExampleGraph.TINKERGRAPH);
     }
 
-    public void testVerticesWithPaths() throws IOException {
+    public void testVerticesWithPaths() throws Exception {
         Configuration config = VertexMap.createConfiguration(1, 2, 2346, 2345, 3333, 1, 1, 2);
         config.setBoolean(FaunusCompiler.PATH_ENABLED, true);
         mapReduceDriver.withConfiguration(config);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/transform/VerticesMapTest.java
Patch:
@@ -11,7 +11,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
 
-import java.io.IOException;
+
 import java.util.Map;
 
 /**
@@ -27,7 +27,7 @@ public void setUp() {
         mapReduceDriver.setReducer(new Reducer<NullWritable, FaunusVertex, NullWritable, FaunusVertex>());
     }
 
-    public void testVerticesWithNoPaths() throws IOException {
+    public void testVerticesWithNoPaths() throws Exception {
         Configuration config = new Configuration();
         mapReduceDriver.withConfiguration(config);
 
@@ -54,7 +54,7 @@ public void testVerticesWithNoPaths() throws IOException {
         identicalStructure(graph, ExampleGraph.TINKERGRAPH);
     }
 
-    public void testVerticesWithPaths() throws IOException {
+    public void testVerticesWithPaths() throws Exception {
         Configuration config = new Configuration();
         config.setBoolean(FaunusCompiler.PATH_ENABLED, true);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/tinkerpop/gremlin/Imports.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.tinkerpop.gremlin;
 
+import com.thinkaurelius.titan.core.TypeMaker;
 import com.thinkaurelius.titan.core.attribute.Geo;
 import com.thinkaurelius.titan.core.attribute.Text;
 import com.tinkerpop.blueprints.Query;
@@ -24,6 +25,7 @@ public class Imports {
         imports.add("org.apache.commons.configuration.*");
         imports.add("static " + Geo.class.getName() + ".*");
         imports.add("static " + Text.class.getName() + ".*");
+        imports.add("static " + TypeMaker.UniquenessConsistency.class.getName() + ".*");
         // todo: remove with Gremlin 2.3.1+
         imports.add("static " + Query.Compare.class.getName() + ".*");
     }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/Entry.java
Patch:
@@ -49,7 +49,7 @@ public ByteBuffer getValue() {
 
     @Override
     public int hashCode() {
-        return new HashCodeBuilder().append(column).toHashCode();
+        return new HashCodeBuilder().append(column.duplicate()).toHashCode();
     }
 
     @Override
@@ -58,12 +58,12 @@ public boolean equals(Object obj) {
         if (obj == null) return false;
         if (!getClass().isInstance(obj)) return false;
         Entry other = (Entry) obj;
-        return column.equals(other.column);
+        return column.duplicate().equals(other.column.duplicate());
     }
 
     @Override
     public int compareTo(Entry entry) {
-        return ByteBufferUtil.compare(column,entry.column);
+        return ByteBufferUtil.compare(column.duplicate(),entry.column.duplicate());
     }
 
     public ImmutableLongObjectMap getCache() {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/CacheVertex.java
Patch:
@@ -44,16 +44,15 @@ public Iterable<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery, Lis
                     }
                 }
             }
-            synchronized (this) {
             if (queryCache.isCovered(query)) {
-                return relationCache.subSet(new Entry(query.getSliceStart(),null),new Entry(query.getSliceEnd(),null));
+                SortedSet<Entry> results = relationCache.subSet(new Entry(query.getSliceStart(),null),new Entry(query.getSliceEnd(),null));
+                return results;
             } else {
                 List<Entry> results = lookup.get(query);
                 relationCache.addAll(results);
                 queryCache.add(query);
                 return results;
             }
-            }
         }
     }
 

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphConcurrentTest.java
Patch:
@@ -23,8 +23,8 @@ public abstract class TitanGraphConcurrentTest extends TitanGraphTestCommon {
     // Parallelism settings
     private static final int CORE_COUNT = ManagementFactory.
             getOperatingSystemMXBean().getAvailableProcessors();
-    private static final int THREAD_COUNT = CORE_COUNT * 4;
-    private static final int TASK_COUNT = 16;//THREAD_COUNT * 512;
+    private static final int THREAD_COUNT = CORE_COUNT * 8;
+    private static final int TASK_COUNT = THREAD_COUNT * 256;
 
     // Graph structure settings
     private static final int NODE_COUNT = 1000;

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TitanBlueprintsTest.java
Patch:
@@ -49,7 +49,7 @@ public void testEdgeTestSuite() throws Exception {
 
     public void testGraphTestSuite() throws Exception {
         this.stopWatch();                       //Excluded test case because toString representation is non-standard
-        doTestSuite(new GraphTestSuite(this), ImmutableSet.of("testStringRepresentation"));
+        doTestSuite(new GraphTestSuite(this), ImmutableSet.of("testStringRepresentation","testDataTypeValidationOnProperties"));
         printTestPerformance("GraphTestSuite", this.stopWatch());
     }
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyJEGraphTest.java
Patch:
@@ -7,6 +7,7 @@ public class BerkeleyJEGraphTest extends TitanGraphTest {
 
     public BerkeleyJEGraphTest() {
         super(BerkeleyJeStorageSetup.getBerkeleyJEGraphConfiguration());
+        //System.out.println(BerkeleyJeStorageSetup.getHomeDir());
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/kryo/KryoDataOutput.java
Patch:
@@ -73,21 +73,21 @@ private void append(byte[] bytes) {
 
     public DataOutput writeObject(Object object) {
         Preconditions.checkArgument(objects != null, "This DataOutput has not been initialized for object writing!");
-        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize objects of type: %s",object.getClass().getName());
+        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize object: %s",object);
         append(objects.writeObject(object));
         return this;
     }
 
     public DataOutput writeObjectNotNull(Object object) {
         Preconditions.checkArgument(objects != null, "This DataOutput has not been initialized for object writing!");
-        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize objects of type: %s",object.getClass().getName());
+        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize object: %s",object);
         append(objects.writeObjectData(object));
         return this;
     }
 
     public DataOutput writeClassAndObject(Object object) {
         Preconditions.checkArgument(objects != null, "This DataOutput has not been initialized for object writing!");
-        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize objects of type: %s",object.getClass().getName());
+        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize object: %s",object);
         append(objects.writeClassAndObject(object));
         return this;
     }

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TitanBlueprintsTest.java
Patch:
@@ -49,7 +49,7 @@ public void testEdgeTestSuite() throws Exception {
 
     public void testGraphTestSuite() throws Exception {
         this.stopWatch();                       //Excluded test case because toString representation is non-standard
-        doTestSuite(new GraphTestSuite(this), ImmutableSet.of("testStringRepresentation"));
+        doTestSuite(new GraphTestSuite(this), ImmutableSet.of("testStringRepresentation","testDataTypeValidationOnProperties"));
         printTestPerformance("GraphTestSuite", this.stopWatch());
     }
 

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/graphdb/berkeleyje/BerkeleyJEGraphTest.java
Patch:
@@ -7,6 +7,7 @@ public class BerkeleyJEGraphTest extends TitanGraphTest {
 
     public BerkeleyJEGraphTest() {
         super(BerkeleyJeStorageSetup.getBerkeleyJEGraphConfiguration());
+        //System.out.println(BerkeleyJeStorageSetup.getHomeDir());
     }
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/serialize/kryo/KryoDataOutput.java
Patch:
@@ -73,21 +73,21 @@ private void append(byte[] bytes) {
 
     public DataOutput writeObject(Object object) {
         Preconditions.checkArgument(objects != null, "This DataOutput has not been initialized for object writing!");
-        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize objects of type: %s",object.getClass().getName());
+        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize object: %s",object);
         append(objects.writeObject(object));
         return this;
     }
 
     public DataOutput writeObjectNotNull(Object object) {
         Preconditions.checkArgument(objects != null, "This DataOutput has not been initialized for object writing!");
-        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize objects of type: %s",object.getClass().getName());
+        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize object: %s",object);
         append(objects.writeObjectData(object));
         return this;
     }
 
     public DataOutput writeClassAndObject(Object object) {
         Preconditions.checkArgument(objects != null, "This DataOutput has not been initialized for object writing!");
-        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize objects of type: %s",object.getClass().getName());
+        Preconditions.checkArgument(kryo.isValidObject(object),"Cannot de-/serialize object: %s",object);
         append(objects.writeClassAndObject(object));
         return this;
     }

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -231,7 +231,7 @@ private void ensureColumnFamilyExists(String tableName, String columnFamily) thr
                 throw new TemporaryStorageException(ee);
             }
         } else { // check if compression was enabled, if not - enable it
-            if (cf.getCompressionType() == null) {
+            if (cf.getCompressionType() == null || cf.getCompressionType() == Compression.Algorithm.NONE) {
                 try {
                     adm.disableTable(tableName);
 

File: titan-hbase/src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -230,7 +230,7 @@ private void ensureColumnFamilyExists(String tableName, String columnFamily) thr
                 throw new TemporaryStorageException(ee);
             }
         } else { // check if compression was enabled, if not - enable it
-            if (cf.getCompressionType() == null) {
+            if (cf.getCompressionType() == null || cf.getCompressionType() == Compression.Algorithm.NONE) {
                 try {
                     adm.disableTable(tableName);
 

File: titan-persistit/src/test/java/com/thinkaurelius/titan/diskstorage/persistit/PersistitHashKeyColumnValueTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.diskstorage.persistit;
 
-import com.google.common.collect.ImmutableMap;
 import com.thinkaurelius.titan.diskstorage.HashKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/InMemoryTitanGraph.java
Patch:
@@ -101,7 +101,7 @@ public StoreTransaction getTxHandle() {
 
     @Override
     public synchronized void commit() {
-        super.commit();
+        //Do nothing
     }
 
     @Override
@@ -117,7 +117,7 @@ public synchronized void rollback() {
 
     @Override
     public void shutdown() throws TitanException {
-        commit();
+        super.commit();
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/InMemoryTitanGraph.java
Patch:
@@ -101,7 +101,7 @@ public StoreTransaction getTxHandle() {
 
     @Override
     public synchronized void commit() {
-        //Simply ignore
+        super.commit();
     }
 
     @Override
@@ -117,7 +117,7 @@ public synchronized void rollback() {
 
     @Override
     public void shutdown() throws TitanException {
-        rollback();
+        commit();
     }
 
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/InMemoryTitanGraph.java
Patch:
@@ -117,7 +117,7 @@ public synchronized void rollback() {
 
     @Override
     public void shutdown() throws TitanException {
-        //Nothing to do;
+        rollback();
     }
 
 

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -211,7 +211,7 @@ public void composeJobs() throws IOException {
             logger.warn("Using developer reference to target/" + Tokens.FAUNUS_JOB_JAR);
             hadoopFileJar = "../target/" + Tokens.FAUNUS_JOB_JAR;
         } else {
-            final String faunusHome = System.getProperty(Tokens.FAUNUS_HOME);
+            final String faunusHome = System.getenv(Tokens.FAUNUS_HOME);
             if (null == faunusHome || faunusHome.isEmpty())
                 throw new IllegalStateException("FAUNUS_HOME must be set in order to locate the Faunus Hadoop job jar: " + Tokens.FAUNUS_JOB_JAR);
             if (new File(faunusHome + "/lib/" + Tokens.FAUNUS_JOB_JAR).exists()) {

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -46,7 +46,7 @@ public class FaunusCompiler extends Configured implements Tool {
 
     private FaunusGraph graph;
 
-    private final List<Job> jobs = new ArrayList<Job>();
+    protected final List<Job> jobs = new ArrayList<Job>();
 
     private final List<Class<? extends Mapper>> mapSequenceClasses = new ArrayList<Class<? extends Mapper>>();
     private Class<? extends WritableComparable> mapOutputKey = NullWritable.class;
@@ -66,7 +66,6 @@ public class FaunusCompiler extends Configured implements Tool {
     public FaunusCompiler(final FaunusGraph graph) {
         this.graph = graph;
         this.setConf(new Configuration());
-        this.addConfiguration(this.graph.getConfiguration());
     }
 
     private String toStringOfJob(final Class sequenceClass) {
@@ -157,6 +156,7 @@ public void addMap(final Class<? extends Mapper> mapper,
 
     public void completeSequence() {
         if (this.mapSequenceClasses.size() > 0) {
+            this.addConfiguration(this.graph.getConfiguration());
             this.getConf().setStrings(MapSequence.MAP_CLASSES, toStringMapSequenceClasses());
             final Job job;
             try {
@@ -191,7 +191,6 @@ public void completeSequence() {
             this.jobs.add(job);
 
             this.setConf(new Configuration());
-            this.addConfiguration(this.graph.getConfiguration());
             this.mapSequenceClasses.clear();
             this.combinerClass = null;
             this.reduceClass = null;

File: src/main/java/com/thinkaurelius/faunus/formats/titan/FaunusVertexLoader.java
Patch:
@@ -120,7 +120,7 @@ public void build() {
                 //Add properties
                 for (Map.Entry<String,Object> entry : properties.entrySet()) {
                     if (entry.getValue()!=null) {
-                        edge.setProperty(entry.getKey(),entry.getValue());
+                        edge.setProperty(entry.getKey(),prepareAttribute(entry.getValue()));
                     }
                 }
                 vertex.addEdge(dir, edge);

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/VertexCentricQueryBuilder.java
Patch:
@@ -104,7 +104,7 @@ private VertexCentricQuery constructQuery(RelationType returnType) {
             //Check condition
             Preconditions.checkArgument(relation.isValidCondition(condition),"Invalid condition onf key [%s]: %s",t.getName(),condition);
             if (t.isPropertyKey()) {
-                if (condition!=null) condition = AttributeUtil.verifyAttribute((TitanKey)t,condition);
+                condition = AttributeUtil.verifyAttributeQuery((TitanKey)t,condition);
                 Preconditions.checkArgument(relation.isValidCondition(condition),"Invalid condition: %s",condition);
 //                Preconditions.checkArgument(relation.isValidDataType(((TitanKey)t).getDataType()),"Invalid data type for condition");
             } else { //t.isEdgeLabel()

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractProperty.java
Patch:
@@ -27,7 +27,9 @@ public AbstractProperty(long id, TitanKey type, InternalVertex vertex, Object va
 
     @Override
     public String toString() {
-        return E + L_BRACKET + getId() + R_BRACKET + L_BRACKET + getVertex().getId() + DASH + getPropertyKey() + ARROW + String.valueOf(value).substring(0,100) + R_BRACKET;
+        String valueStr = String.valueOf(value);
+        valueStr = valueStr.substring(0,Math.min(valueStr.length(),20));
+        return E + L_BRACKET + getId() + R_BRACKET + L_BRACKET + getVertex().getId() + DASH + getPropertyKey() + ARROW + valueStr + R_BRACKET;
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardTitanTx.java
Patch:
@@ -647,7 +647,7 @@ public boolean apply(@Nullable TitanVertex vertex) {
                 return (Iterator)addedRelations.getView(new Predicate<InternalRelation>() {
                     @Override
                     public boolean apply(@Nullable InternalRelation relation) {
-                        return query.matches(relation);
+                        return (relation instanceof TitanEdge) && !relation.isHidden() && query.matches(relation);
                     }
                 }).iterator();
             } else throw new IllegalArgumentException("Unexpected type: " + query.getType());
@@ -698,7 +698,7 @@ public boolean apply(@Nullable TitanElement element) {
                 for (KeyCondition<TitanKey> c : condition.getChildren()) {
                     KeyAtom<TitanKey> atom = (KeyAtom<TitanKey>)c;
                     if (getGraph().getIndexInformation(index).supports(atom.getKey().getDataType(),atom.getRelation()) &&
-                            atom.getKey().hasIndex(index,query.getType().getElementType())) {
+                            atom.getKey().hasIndex(index,query.getType().getElementType()) && atom.getCondition()!=null) {
                         newConds.add(atom);
                     } else {
                         log.debug("Filtered out atom [{}] from query [{}] because it is not indexed or not covered by the index");
@@ -708,6 +708,7 @@ public boolean apply(@Nullable TitanElement element) {
                 Preconditions.checkArgument(!newConds.isEmpty(),"Invalid index assignment [%s] to query [%s]",index, query);
                 final StandardElementQuery indexQuery;
                 if (needsFilter) {
+                    Preconditions.checkArgument(!newConds.isEmpty(),"Query has been assigned an index [%s] in error: %s",query.getIndex(),query);
                     indexQuery = new StandardElementQuery(query.getType(),KeyAnd.of(newConds.toArray(new KeyAtom[newConds.size()])),query.getLimit(),index);
                 } else {
                     indexQuery = query;

File: titan-test/src/main/java/com/thinkaurelius/titan/blueprints/TitanBlueprintsTest.java
Patch:
@@ -55,7 +55,7 @@ public void testGraphTestSuite() throws Exception {
 
     public void testQueryTestSuite() throws Exception {
         this.stopWatch();
-        doTestSuite(new QueryTestSuite(this));
+        doTestSuite(new QueryTitanTestSuite(this));
         printTestPerformance("QueryTestSuite", this.stopWatch());
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractTitanTx.java
Patch:
@@ -470,8 +470,8 @@ public Iterable<Vertex> getVertices(String key, Object attribute) {
     public Iterable<TitanVertex> getVertices(final TitanKey key, Object attribute) {
         verifyAccess(key);
         Preconditions.checkNotNull(key);
-        attribute = AttributeUtil.prepareAttribute(attribute, key.getDataType());
-        if (key.hasIndex()) {
+        if (attribute!=null) attribute = AttributeUtil.prepareAttribute(attribute, key.getDataType());
+        if (key.hasIndex() && attribute!=null) {
             // First, get stuff from disk
             long[] nodeids = getVertexIDsFromDisk(key, attribute);
             Set<TitanVertex> vertices = new HashSet<TitanVertex>(nodeids.length);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanQuery.java
Patch:
@@ -4,6 +4,7 @@
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Query;
+import com.tinkerpop.blueprints.VertexQuery;
 
 /**
  * TitanQuery constructs and executes a query over incident edges from the perspective of a vertex.
@@ -16,7 +17,7 @@
  *
  * @author Matthias Br&ouml;cheler (http://www.matthiasb.com)
  */
-public interface TitanQuery extends Query {
+public interface TitanQuery extends VertexQuery {
 
     /* ---------------------------------------------------------------
     * Query Specification

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -138,7 +138,7 @@ public String toString() {
     public StoreFeatures getFeatures() {
         if (features == null) {
             features = new StoreFeatures();
-            features.supportsScan = false;
+            features.supportsScan = true;
             features.supportsBatchMutation = true;
             features.supportsTransactions = false;
             features.supportsConsistentKeyOperations = true;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/KeyColumnValueStore.java
Patch:
@@ -7,6 +7,8 @@
 
 public interface KeyColumnValueStore {
 
+    public static final int PAGE_SIZE = 10; /* default page size for "slice" or "paged" operations */
+
     /**
      * Returns true if the specified key exists in the store, i.e. there is at least one column-value
      * pair for the key.

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/KeyColumnValueStoreTest.java
Patch:
@@ -247,6 +247,9 @@ public void scanTest() throws StorageException {
             clopen();
             RecordIterator<ByteBuffer> iterator1 = store.getKeys(tx);
             RecordIterator<ByteBuffer> iterator2 = store.getKeys(tx);
+            // The idea is to open an iterator without using it
+            // to make sure that closing a transaction will clean it up.
+            // (important for BerkeleyJE where leaving cursors open causes exceptions)
             RecordIterator<ByteBuffer> iterator3 = store.getKeys(tx);
             Assert.assertEquals(numKeys, KeyValueStoreUtil.count(iterator1));
             Assert.assertEquals(numKeys, KeyValueStoreUtil.count(iterator2));

File: src/main/java/com/thinkaurelius/faunus/mapreduce/util/ScriptMap.java
Patch:
@@ -29,7 +29,7 @@ public class ScriptMap {
     private static final String MAP_V_ARGS = "map(v,args)";
     private static final String CLEANUP_ARGS = "cleanup(args)";
 
-    public static Configuration createConfiguration(final String scriptUri, String... args) {
+    public static Configuration createConfiguration(final String scriptUri, final String... args) {
         Configuration configuration = new Configuration();
         configuration.set(SCRIPT_PATH, scriptUri);
         configuration.setStrings(SCRIPT_ARGS, args);

File: src/main/java/com/thinkaurelius/faunus/Tokens.java
Patch:
@@ -43,6 +43,7 @@ public static String makeNamespace(final Class klass) {
 
     public static final String VERSION = "0.2.0-SNAPSHOT";
     public static final String FAUNUS_JOB_JAR = "faunus-" + VERSION + "-job.jar";
+    public static final String FAUNUS_HOME = "FAUNUS_HOME";
 
     public static final String PART = "part";
     public static final String GRAPH = "graph";

File: src/main/java/com/thinkaurelius/faunus/formats/titan/TitanOutputFormat.java
Patch:
@@ -37,7 +37,7 @@ public void addMapReduceJobs(final FaunusCompiler compiler) {
                 Holder.class,
                 NullWritable.class,
                 FaunusVertex.class,
-                new Configuration());
+                BlueprintsGraphOutputMapReduce.createConfiguration());
     }
 
 }

File: titan-berkeleyje/src/test/java/com/thinkaurelius/titan/blueprints/BerkeleyJEBlueprintsTest.java
Patch:
@@ -32,6 +32,7 @@ public Graph generateGraph() {
     @Override
     public Graph generateGraph(String uid) {
         String dir = BerkeleyJeStorageSetup.getHomeDir(uid);
+        System.out.println("Opening graph in: " + dir);
         BaseConfiguration config = new BaseConfiguration();
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.STORAGE_DIRECTORY_KEY, dir);
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.STORAGE_BACKEND_KEY, "berkeleyje");

File: titan-core/src/main/java/com/thinkaurelius/titan/core/InvalidElementException.java
Patch:
@@ -8,13 +8,13 @@
  */
 public class InvalidElementException extends TitanException {
 
-    private final TitanVertex element;
+    private final TitanElement element;
 
     /**
      * @param msg     Exception message
      * @param element The invalid element causing the exception
      */
-    public InvalidElementException(String msg, TitanVertex element) {
+    public InvalidElementException(String msg, TitanElement element) {
         super(msg);
         this.element = element;
     }
@@ -24,7 +24,7 @@ public InvalidElementException(String msg, TitanVertex element) {
      *
      * @return The element causing the exception
      */
-    public TitanVertex getElement() {
+    public TitanElement getElement() {
         return element;
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/Titan.java
Patch:
@@ -4,6 +4,8 @@
 
 
 /**
+ * Contains constants for this Titan Graph Database.
+ *
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 public class Titan {

File: titan-core/src/main/java/com/thinkaurelius/titan/core/TitanTransaction.java
Patch:
@@ -3,6 +3,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
+import com.thinkaurelius.titan.graphdb.query.ElementQueryBuilder;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.KeyIndexableGraph;
 import com.tinkerpop.blueprints.TransactionalGraph;
@@ -113,6 +114,8 @@ public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph
      */
     public boolean containsVertex(long vertexid);
 
+    public ElementQueryBuilder queryElements();
+
     public TitanVertex getVertex(TitanKey key, Object attribute);
 
     public TitanVertex getVertex(String key, Object attribute);

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Cmp.java
Patch:
@@ -7,6 +7,8 @@
 import org.slf4j.LoggerFactory;
 
 /**
+ * Basic comparison relations for comparable (i.e. linearly ordered) objects.
+ *
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 

File: titan-core/src/main/java/com/thinkaurelius/titan/core/attribute/Geo.java
Patch:
@@ -4,6 +4,8 @@
 import com.thinkaurelius.titan.graphdb.query.keycondition.Relation;
 
 /**
+ * Comparison relations for geographic shapes.
+ *
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexEntry.java
Patch:
@@ -1,9 +1,11 @@
-package com.thinkaurelius.titan.diskstorage.lucene;
+package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
 import org.apache.commons.lang.StringUtils;
 
 /**
+ * An index entry is a key-value pair (or field-value pair).
+ *
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexInformation.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.diskstorage.lucene;
+package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.thinkaurelius.titan.graphdb.query.keycondition.Relation;
 

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexMutation.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.diskstorage.lucene;
+package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.Mutation;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexProvider.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.diskstorage.lucene;
+package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/indexing/IndexQuery.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.diskstorage.lucene;
+package com.thinkaurelius.titan.diskstorage.indexing;
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.graphdb.query.keycondition.KeyCondition;

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsGraph.java
Patch:
@@ -73,7 +73,7 @@ public void stopTransaction(Conclusion conclusion) {
         }
     }
 
-    protected abstract TitanTransaction newThreadBoundTransaction();
+    public abstract TitanTransaction newThreadBoundTransaction();
 
     private TitanTransaction getAutoStartTx() {
         TitanTransaction tx = txs.get();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/database/indexing/StandardIndexInformation.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.database.indexing;
 
 import com.thinkaurelius.titan.core.attribute.Cmp;
-import com.thinkaurelius.titan.diskstorage.lucene.IndexInformation;
+import com.thinkaurelius.titan.diskstorage.indexing.IndexInformation;
 import com.thinkaurelius.titan.graphdb.query.keycondition.Relation;
 
 /**
@@ -16,7 +16,7 @@ private StandardIndexInformation() {}
 
     @Override
     public boolean supports(Class<?> dataType, Relation relation) {
-        return relation== Cmp.EQUAL;
+        return relation==Cmp.EQUAL;
     }
 
     @Override

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/internal/ElementLifeCycle.java
Patch:
@@ -25,17 +25,17 @@ public enum Event {REMOVED, REMOVED_RELATION, ADDED_RELATION }
     /**
      * The entity has changed after being loaded from the database by adding relations.
      */
-    final static byte AddedRelations = 3;
+    private final static byte AddedRelations = 3;
 
     /**
      * The entity has changed after being loaded from the database by deleting relations.
      */
-    final static byte RemovedRelations = 4;
+    private final static byte RemovedRelations = 4;
 
     /**
      * The entity has changed after being loaded from the database by adding and/or deleting relations.
      */
-    final static byte Modified = 5;
+    private final static byte Modified = 5;
 
     /**
      * The entity has been deleted but not yet erased from the database.

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/QueryExecutor.java
Patch:
@@ -12,8 +12,6 @@ public interface QueryExecutor<Q extends Query<Q>,R> {
 
     public Iterator<R> getNew(Q query);
 
-    public boolean isDeleted(Q query, R result);
-
     public Iterator<R> execute(Q query);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/keycondition/KeyAnd.java
Patch:
@@ -77,7 +77,7 @@ public String toString() {
         b.append("(");
         for (int i=0;i<elements.length;i++) {
             if (i>0) b.append(" AND ");
-            b.append(elements);
+            b.append(elements[i]);
         }
         b.append(")");
         return b.toString();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/keycondition/KeyAtom.java
Patch:
@@ -17,7 +17,6 @@ public class KeyAtom<K> implements KeyCondition<K> {
     public KeyAtom(K key, Relation relation, Object condition) {
         Preconditions.checkNotNull(key);
         Preconditions.checkNotNull(relation);
-        Preconditions.checkNotNull(condition);
         this.key = key;
         this.relation = relation;
         this.condition = condition;
@@ -66,7 +65,7 @@ public boolean equals(Object other) {
 
     @Override
     public String toString() {
-        return key.toString()+relation.toString()+condition.toString();
+        return key.toString()+relation.toString()+String.valueOf(condition);
     }
 
     public static final<K> KeyAtom<K> of(K key, Relation relation, Object condition) {

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/query/keycondition/KeyOr.java
Patch:
@@ -76,7 +76,7 @@ public String toString() {
         b.append("(");
         for (int i=0;i<elements.length;i++) {
             if (i>0) b.append(" OR ");
-            b.append(elements);
+            b.append(elements[i]);
         }
         b.append(")");
         return b.toString();

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/EmptyVertex.java
Patch:
@@ -21,7 +21,7 @@
 
 public class EmptyVertex implements InternalVertex {
 
-    private static final String errorName = "Empty Nodes";
+    private static final String errorName = "Empty vertex";
 
 	/* ---------------------------------------------------------------
      * TitanRelation Iteration/Access

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -40,8 +40,8 @@ public static SystemType getSystemEdgeType(long id) {
 
 
     public static final Set<? extends SystemType> prepersistedSystemTypes = ImmutableSet.of(SystemKey.TypeName,
-            SystemKey.PropertyTypeDefinition,
-            SystemKey.EdgeTypeDefinition,
+            SystemKey.PropertyKeyDefinition,
+            SystemKey.RelationTypeDefinition,
             SystemKey.TypeClass);
 
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanKeyVertex.java
Patch:
@@ -21,7 +21,7 @@ public PropertyKeyDefinition getDefinition() {
         if (definition == null) {
             synchronized (this) {
                 if (definition==null) {
-                    definition = QueryUtil.queryHiddenUniqueProperty(this, SystemKey.PropertyTypeDefinition)
+                    definition = QueryUtil.queryHiddenUniqueProperty(this, SystemKey.PropertyKeyDefinition)
                             .getValue(PropertyKeyDefinition.class);
                     Preconditions.checkNotNull(definition);
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanLabelVertex.java
Patch:
@@ -20,7 +20,7 @@ public EdgeLabelDefinition getDefinition() {
         if (definition == null) {
             synchronized (this) {
                 if (definition==null) {
-                    definition = QueryUtil.queryHiddenUniqueProperty(this, SystemKey.EdgeTypeDefinition)
+                    definition = QueryUtil.queryHiddenUniqueProperty(this, SystemKey.RelationTypeDefinition)
                             .getValue(EdgeLabelDefinition.class);
                     Preconditions.checkNotNull(definition);
                 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/TitanTypeVertex.java
Patch:
@@ -52,5 +52,4 @@ public boolean isModifiable() {
         return getDefinition().isModifiable();
     }
 
-
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/vertices/CacheVertex.java
Patch:
@@ -34,7 +34,7 @@ public Iterable<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery, Lis
             if (relationCache==null) {
                 //Initialize datastructures
                 if (tx().getConfiguration().isSingleThreaded()) {
-                    relationCache = new TreeSet<Entry>();
+                    relationCache = new ConcurrentSkipListSet<Entry>();
                     queryCache = new SimpleQueryCache();
                 } else {
                     synchronized (this) {
@@ -45,6 +45,7 @@ public Iterable<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery, Lis
                     }
                 }
             }
+            synchronized (this) {
             if (queryCache.isCovered(query)) {
                 return relationCache.subSet(new Entry(query.getSliceStart(),null),new Entry(query.getSliceEnd(),null));
             } else {
@@ -53,6 +54,7 @@ public Iterable<Entry> loadRelations(SliceQuery query, Retriever<SliceQuery, Lis
                 queryCache.add(query);
                 return results;
             }
+            }
         }
     }
 

File: titan-core/src/main/java/com/thinkaurelius/titan/tinkerpop/gremlin/Console.java
Patch:
@@ -14,6 +14,8 @@
 import java.io.IOException;
 
 /**
+ * The Gremlin console adapted for the Titan Graph Database
+ *
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
 public class Console {

File: titan-core/src/main/java/com/thinkaurelius/titan/tinkerpop/gremlin/Imports.java
Patch:
@@ -4,6 +4,8 @@
 import java.util.List;
 
 /**
+ * Titan specific Gremlin imports
+ *
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
 public class Imports {

File: titan-core/src/main/java/com/thinkaurelius/titan/tinkerpop/rexster/RexsterTitanServer.java
Patch:
@@ -14,6 +14,8 @@
 import java.util.Iterator;
 
 /**
+ * Standalone Titan database with fronting Rexster server.
+ *
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 

File: titan-es/src/test/java/com/thinkaurelius/titan/diskstorage/es/ElasticSearchIndexTest.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.core.attribute.Txt;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexProviderTest;
-import com.thinkaurelius.titan.diskstorage.lucene.IndexProvider;
+import com.thinkaurelius.titan.diskstorage.indexing.IndexProvider;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import org.apache.commons.configuration.BaseConfiguration;
 import org.apache.commons.configuration.Configuration;
@@ -32,7 +32,7 @@ public static final Configuration getLocalESTestConfig() {
         Configuration config = new BaseConfiguration();
         config.setProperty(LOCAL_MODE_KEY,true);
         config.setProperty(CLIENT_ONLY_KEY,false);
-        config.setProperty(DATA_DIRECTORY_KEY,StorageSetup.getHomeDir("es"));
+        config.setProperty(GraphDatabaseConfiguration.STORAGE_DIRECTORY_KEY,StorageSetup.getHomeDir("es"));
         return config;
     }
 
@@ -51,7 +51,7 @@ public void testSupport() {
         assertTrue(index.supports(Double.class, Cmp.GREATER_THAN_EQUAL));
         assertTrue(index.supports(Double.class, Cmp.LESS_THAN));
         assertTrue(index.supports(Long.class, Cmp.INTERVAL));
-        assertTrue(index.supports(Geoshape.class, Geo.INTERSECT));
+        assertTrue(index.supports(Geoshape.class, Geo.WITHIN));
 
         assertFalse(index.supports(String.class, Txt.PREFIX));
         assertFalse(index.supports(Double.class, Geo.INTERSECT));

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneExample.java
Patch:
@@ -11,7 +11,6 @@
 import org.apache.lucene.document.*;
 import org.apache.lucene.index.*;
 import org.apache.lucene.queries.BooleanFilter;
-import org.apache.lucene.queries.TermsFilter;
 import org.apache.lucene.search.*;
 import org.apache.lucene.spatial.SpatialStrategy;
 import org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy;

File: titan-lucene/src/test/java/com/thinkaurelius/titan/diskstorage/lucene/LuceneIndexTest.java
Patch:
@@ -6,7 +6,9 @@
 import com.thinkaurelius.titan.core.attribute.Geoshape;
 import com.thinkaurelius.titan.core.attribute.Txt;
 import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.indexing.IndexProvider;
 import com.thinkaurelius.titan.diskstorage.indexing.IndexProviderTest;
+import com.thinkaurelius.titan.diskstorage.lucene.LuceneIndex;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import org.apache.commons.configuration.BaseConfiguration;
 import org.apache.commons.configuration.Configuration;
@@ -45,7 +47,7 @@ public void testSupport() {
         assertTrue(index.supports(Double.class, Cmp.GREATER_THAN_EQUAL));
         assertTrue(index.supports(Double.class, Cmp.LESS_THAN));
         assertTrue(index.supports(Long.class, Cmp.INTERVAL));
-        assertTrue(index.supports(Geoshape.class, Geo.INTERSECT));
+        assertTrue(index.supports(Geoshape.class, Geo.WITHIN));
 
         assertFalse(index.supports(String.class, Txt.PREFIX));
         assertFalse(index.supports(Double.class, Geo.INTERSECT));

File: titan-test/src/main/java/com/thinkaurelius/titan/StorageSetup.java
Patch:
@@ -10,6 +10,7 @@
 import org.apache.commons.lang.StringUtils;
 
 import java.io.File;
+import java.util.Iterator;
 
 public class StorageSetup {
 

File: titan-test/src/main/java/com/thinkaurelius/titan/diskstorage/HashKeyColumnValueStoreTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage;
 
-import com.thinkaurelius.titan.diskstorage.lucene.HashPrefixKeyColumnValueStore;
+import com.thinkaurelius.titan.diskstorage.indexing.HashPrefixKeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.ConsistencyLevel;
 
 /**

File: titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphConcurrentTest.java
Patch:
@@ -32,7 +32,7 @@ public abstract class TitanGraphConcurrentTest extends TitanGraphTestCommon {
     private static final int CORE_COUNT = ManagementFactory.
             getOperatingSystemMXBean().getAvailableProcessors();
     private static final int THREAD_COUNT = CORE_COUNT * 4;
-    private static final int TASK_COUNT = THREAD_COUNT * 512;
+    private static final int TASK_COUNT = 16;//THREAD_COUNT * 512;
 
     // Graph structure settings
     private static final int NODE_COUNT = 1000;
@@ -246,7 +246,7 @@ protected void doRun() throws Exception {
             TitanVertex n = Iterables.getOnlyElement(tx.getVertices(id, nodeid));
 
             for (int i = 0; i < nodeTraversalCount; i++) {
-                assertEquals(expectedEdges, Iterables.size(n.getTitanEdges(Direction.BOTH, relTypeToTraverse)));
+                assertEquals("On vertex: " + n.getID(),expectedEdges, Iterables.size(n.getTitanEdges(Direction.BOTH, relTypeToTraverse)));
                 for (TitanEdge r : n.getTitanEdges(Direction.OUT, relTypeToTraverse)) {
                     n = r.getVertex(Direction.IN);
                 }

File: titan-cassandra/src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -74,6 +74,9 @@ public static Partitioner getPartitioner(String className) {
 
     private StoreFeatures features = null;
 
+    protected static final String SYSTEM_PROPERTIES_CF  = "system_properties";
+    protected static final String SYSTEM_PROPERTIES_KEY = "general";
+
     public AbstractCassandraStoreManager(Configuration storageConfig) {
         super(storageConfig, PORT_DEFAULT);
 

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/InternalTitanTransaction.java
Patch:
@@ -97,6 +97,8 @@ public interface InternalTitanTransaction extends TitanTransaction {
 
     public boolean isDeletedRelation(long relationId);
 
+    public boolean isDeletedVertex(long vertexId);
+
     // ######## TitanVertex / TitanRelation Loading  ############
 
     /**

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/transaction/VertexIterable.java
Patch:
@@ -35,7 +35,9 @@ private InternalTitanVertex nextVertex() {
                 InternalTitanVertex v = null;
                 try {
                     while (v == null && iterator.hasNext()) {
-                        v = tx.getExistingVertex(iterator.next().longValue());
+                        long nextId = iterator.next().longValue();
+                        if (tx.isDeletedVertex(nextId)) continue;
+                        v = tx.getExistingVertex(nextId);
                         //Filter out types
                         if (v instanceof TitanType) v = null;
                     }

File: titan-core/src/main/java/com/thinkaurelius/titan/graphdb/relations/factory/RelationFactoryUtil.java
Patch:
@@ -16,7 +16,7 @@ public static final void connectRelation(InternalRelation relation, boolean isNe
 
         TitanType et = relation.getType();
         //If functional relation, check that it is indeed unique for that type
-        if (isNew && et.isFunctional() && !relation.getVertex(0).isNew()) {
+        if (isNew && et.isFunctional()) {
 
             InternalTitanVertex start = (InternalTitanVertex) relation.getVertex(0);
 

File: src/main/java/com/thinkaurelius/faunus/FaunusPipeline.java
Patch:
@@ -1065,16 +1065,14 @@ private FaunusPipeline done() {
         if (!this.state.isLocked()) {
             final Pair<String, Class<? extends WritableComparable>> pair = this.state.popProperty();
             if (null != pair) {
-
                 this.compiler.addMap(PropertyMap.Map.class,
                         LongWritable.class,
                         pair.getB(),
                         PropertyMap.createConfiguration(this.state.getElementType(), pair.getA(), pair.getB()));
                 makeMapReduceString(PropertyMap.class, pair.getA());
+                this.state.lock();
             }
-            this.state.lock();
         }
-        this.compiler.completeSequence();
         return this;
     }
 
@@ -1100,6 +1098,7 @@ public void submit(final String script, final Boolean showHeader) throws Excepti
             this.state.checkLocked();
             ((Class<? extends MapReduceFormat>) this.graph.getGraphOutputFormat()).getConstructor().newInstance().addMapReduceJobs(this.compiler);
         }
+        this.compiler.completeSequence();
         ToolRunner.run(this.compiler, new String[]{script, showHeader.toString()});
     }
 

File: src/main/java/com/thinkaurelius/faunus/FaunusEdge.java
Patch:
@@ -19,20 +19,20 @@
  */
 public class FaunusEdge extends FaunusElement implements Edge {
 
-    private static final String DEFAULT = "_default";
+    private static final String LINK = "_link";
 
     protected long outVertex;
     protected long inVertex;
     private String label;
 
     public FaunusEdge() {
         super(-1l);
-        this.label = DEFAULT;
+        this.label = LINK;
     }
 
     public FaunusEdge(final boolean enablePaths) {
         super(-1l);
-        this.label = DEFAULT;
+        this.label = LINK;
         this.enablePath(enablePaths);
     }
 

File: src/main/java/com/thinkaurelius/faunus/formats/edgelist/rdf/RDFBlueprintsHandler.java
Patch:
@@ -82,16 +82,16 @@ public RDFBlueprintsHandler(final Configuration configuration) throws IOExceptio
         this.useFragments = configuration.getBoolean(RDFInputFormat.USE_LOCALNAME, false);
         this.literalAsProperty = configuration.getBoolean(RDFInputFormat.LITERAL_AS_PROPERTY, false);
         for (final String property : configuration.getStringCollection(RDFInputFormat.AS_PROPERTIES)) {
-            this.asProperties.add(property);
+            this.asProperties.add(property.trim());
         }
         try {
             this.md = MessageDigest.getInstance("MD5");
         } catch (NoSuchAlgorithmException e) {
             throw new IOException(e.getMessage(), e);
         }
-
         this.parser = Rio.createParser(formats.get(configuration.get(RDFInputFormat.RDF_FORMAT)));
         this.parser.setRDFHandler(this);
+        this.parser.setDatatypeHandling(RDFParser.DatatypeHandling.IGNORE);
     }
 
     public void startRDF() throws RDFHandlerException {

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -521,7 +521,7 @@ else if (new File("lib/" + Tokens.FAUNUS_JOB_JAR).exists())
         else if (new File("../lib/" + Tokens.FAUNUS_JOB_JAR).exists())
             hadoopFileJar = "../lib/" + Tokens.FAUNUS_JOB_JAR;
         else
-            throw new IllegalStateException("The Faunus Hadoop job jar could not be found: faunus-" + Tokens.FAUNUS_JOB_JAR);
+            throw new IllegalStateException("The Faunus Hadoop job jar could not be found: " + Tokens.FAUNUS_JOB_JAR);
 
         if (this.pathEnabled)
             logger.warn("Path calculations are enabled for this Faunus job (space and time expensive)");

File: src/main/java/com/thinkaurelius/faunus/formats/edgelist/ntriple/NTripleInputFormat.java
Patch:
@@ -17,6 +17,7 @@ public class NTripleInputFormat extends FileInputFormat<NullWritable, FaunusElem
 
     public static final String USE_LOCALNAME = "faunus.input.format.ntriple.use-localname";
     public static final String AS_PROPERTIES = "faunus.input.format.ntriple.as-properties";
+    public static final String LITERAL_AS_PROPERTY = "faunus.input.format.ntriple.literal-as-property";
 
     public static final String URI = "uri";
     public static final String CONTEXT = "context";

File: src/main/java/com/thinkaurelius/faunus/formats/edgelist/ntriple/NTripleRecordReader.java
Patch:
@@ -85,7 +85,7 @@ public boolean nextKeyValue() throws IOException {
                 break;
             }
             this.pos += newSize;
-            if (newSize < this.maxLineLength && text.toString().trim().length() > 0) {
+            if (newSize < this.maxLineLength && text.getLength() > 0) {
                 try {
                     this.parser.parse(new StringReader(text.toString()), "http://thinkaurelius.com/baseUri#");
                     this.queue.add(this.handler.getSubject());

File: src/test/java/com/thinkaurelius/faunus/formats/edgelist/ntriple/RDFBlueprintsHandlerTest.java
Patch:
@@ -45,6 +45,7 @@ public void testUseFragments() throws Exception {
         assertEquals(handler.getSubject().getProperty("name"), "Abraham_Lincoln");
         assertEquals(handler.getPredicate().getLabel(), "type");
         assertEquals(handler.getObject().getProperty("name"), "Person");
+        assertFalse(handler.isOnlySubject());
     }
 
     public void testAsProperties() throws Exception {
@@ -60,7 +61,6 @@ public void testAsProperties() throws Exception {
         parser.parse(new StringReader("<http://dbpedia.org/resource/Abraham_Lincoln> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://dbpedia.org/ontology/Person> ."), "http://baseURI#");
         assertEquals(handler.getSubject().getProperty("name"), "Abraham_Lincoln");
         assertEquals(handler.getSubject().getProperty("type"), "Person");
-        assertNull(handler.getPredicate());
-        assertNull(handler.getObject());
+        assertTrue(handler.isOnlySubject());
     }
 }

File: src/main/java/com/thinkaurelius/faunus/formats/edgelist/EdgeListInputMapReduce.java
Patch:
@@ -10,6 +10,7 @@
 import org.apache.hadoop.mapreduce.Reducer;
 
 import java.io.IOException;
+import java.util.List;
 
 import static com.tinkerpop.blueprints.Direction.*;
 
@@ -89,6 +90,8 @@ public void reduce(final LongWritable key, final Iterable<Holder> values, final
                         vertex.setProperty(property, temp.getProperty(property));
                     }
                     vertex.addEdges(BOTH, temp);
+                    context.getCounter(Counters.OUT_EDGES_CREATED).increment(((List) temp.getEdges(OUT)).size());
+                    context.getCounter(Counters.IN_EDGES_CREATED).increment(((List) temp.getEdges(IN)).size());
                 }
             }
             context.write(NullWritable.get(), vertex);

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/blueprints/InternalCassandraBlueprintsTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.cassandra.thrift.CassandraThriftStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.tinkerpop.blueprints.Graph;
@@ -19,7 +19,7 @@ public class InternalCassandraBlueprintsTest extends TitanBlueprintsTest {
     @Override
     public synchronized void startUp() {
         if (!isStartedUp) {
-            CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+            CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
             isStartedUp = true;
         }
     }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import org.junit.BeforeClass;
@@ -15,12 +15,12 @@ public class InternalAstyanaxKeyColumnValueTest extends KeyColumnValueStoreTest
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStoreManager(CassandraStorageSetup.getCassandraStorageConfiguration());
+        return new AstyanaxStoreManager(CassandraStorageSetup.getAstyanaxGraphConfiguration());
     }
 
 

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
@@ -12,7 +12,7 @@ public class InternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnVa
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/InternalAstyanaxMultiWriteKeyColumnValueTest.java
Patch:
@@ -3,15 +3,15 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
 public class InternalAstyanaxMultiWriteKeyColumnValueTest extends MultiWriteKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/InternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
@@ -12,7 +12,7 @@ public class InternalCassandraLockKeyColumnValueStoreTest extends LockKeyColumnV
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/InternalCassandraThriftKeyColumnValueTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import org.apache.commons.configuration.Configuration;
@@ -17,7 +17,7 @@ public class InternalCassandraThriftKeyColumnValueTest extends KeyColumnValueSto
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/InternalCassandraThriftMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -3,15 +3,15 @@
 import com.thinkaurelius.titan.CassandraStorageSetup;
 import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.junit.BeforeClass;
 
 public class InternalCassandraThriftMultiWriteKeyColumnValueStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     @Override

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphConcurrentTest.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.graphdb.astyanax;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.graphdb.TitanGraphConcurrentTest;
 import org.junit.BeforeClass;
 
 public class InternalAstyanaxGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     public InternalAstyanaxGraphConcurrentTest() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphTest.java
Patch:
@@ -1,15 +1,15 @@
 package com.thinkaurelius.titan.graphdb.astyanax;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 import org.junit.BeforeClass;
 
 public class InternalAstyanaxGraphTest extends TitanGraphTest {
 
     @BeforeClass
     public static void startCassandra() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 
     public InternalAstyanaxGraphTest() {

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphConcurrentTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.thrift;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.graphdb.TitanGraphConcurrentTest;
 import org.junit.BeforeClass;
 
@@ -13,6 +13,6 @@ public InternalCassandraGraphConcurrentTest() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 }

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/graphdb/thrift/InternalCassandraGraphTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.thrift;
 
 import com.thinkaurelius.titan.CassandraStorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 import org.junit.BeforeClass;
 
@@ -13,6 +13,6 @@ public InternalCassandraGraphTest() {
 
     @BeforeClass
     public static void beforeClass() {
-        CassandraDaemonWrapper.start(CassandraStorageSetup.cassandraYamlPath);
+        CassandraProcessStarter.startCleanEmbedded(CassandraStorageSetup.cassandraYamlPath);
     }
 }

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/Backend.java
Patch:
@@ -282,8 +282,7 @@ public void clearStorage() throws StorageException {
     
     //############ Registered Storage Managers ##############
 
-    private static final Map<String, String> REGISTERED_STORAGE_MANAGERS =
-            new HashMap<String, String>();
+    private static final Map<String, String> REGISTERED_STORAGE_MANAGERS = new HashMap<String, String>();
 
     static {
         Properties props;

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/LockClaim.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
+import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
 import com.thinkaurelius.titan.diskstorage.util.KeyColumn;
-import org.apache.cassandra.utils.ByteBufferUtil;
 
 import java.nio.ByteBuffer;
 
@@ -120,6 +120,4 @@ public String toString() {
                 + ", col=0x" + ByteBufferUtil.bytesToHex(kc.getColumn())
                 + ", expectedValue=" + (null == expectedValue ? "null" : "0x" + ByteBufferUtil.bytesToHex(expectedValue)) + "]";
     }
-
-
 }
\ No newline at end of file

File: titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/KeyColumn.java
Patch:
@@ -1,7 +1,5 @@
 package com.thinkaurelius.titan.diskstorage.util;
 
-import org.apache.cassandra.utils.ByteBufferUtil;
-
 import java.nio.ByteBuffer;
 
 /**

File: src/main/java/com/thinkaurelius/faunus/formats/titan/TitanOutputFormat.java
Patch:
@@ -7,8 +7,6 @@
  */
 public abstract class TitanOutputFormat extends NoOpOutputFormat {
 
-    public static final String TITAN_GRAPH_OUTPUT_STORAGE_BACKEND = "titan.graph.output.storage.backend";
-    public static final String TITAN_GRAPH_OUTPUT_STORAGE_HOSTNAME = "titan.graph.output.storage.hostname";
-    public static final String TITAN_GRAPH_OUTPUT_STORAGE_PORT = "titan.graph.output.storage.port";
+    public static final String TITAN_GRAPH_OUTPUT = "titan.graph.output";
     public static final String TITAN_GRAPH_OUTPUT_INFER_SCHEMA = "titan.graph.output.infer-schema";
 }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -155,6 +155,7 @@ public void setPathEnabled(final boolean pathEnabled) {
 
     public void blueprintsGraphOutputMapReduce() throws IOException {
         this.mapSequenceClasses.add(BlueprintsGraphOutputMapReduce.Map.class);
+        this.combinerClass = BlueprintsGraphOutputMapReduce.Combiner.class;
         this.reduceClass = BlueprintsGraphOutputMapReduce.Reduce.class;
         this.setKeyValueClasses(LongWritable.class, Holder.class, NullWritable.class, FaunusVertex.class);
         this.completeSequence();

File: titan-cassandra/src/test/java/com/thinkaurelius/titan/CassandraStorageSetup.java
Patch:
@@ -16,11 +16,11 @@
 public class CassandraStorageSetup {
 
     public static final String cassandraYamlPath = StringUtils.join(
-            new String[]{"file://", System.getProperty("user.dir"), "titan-cassandra", "target",
+            new String[]{"file://", System.getProperty("user.dir"), "target",
                     "cassandra-tmp", "conf", "127.0.0.1", "cassandra.yaml"},
             File.separator);
     public static final String cassandraOrderedYamlPath = StringUtils.join(
-            new String[]{"file://", System.getProperty("user.dir"), "titan-cassandra", "target",
+            new String[]{"file://", System.getProperty("user.dir"), "target",
                     "cassandra-tmp", "conf", "127.0.0.1", "cassandra-ordered.yaml"},
             File.separator);
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thrift/CassandraThriftStoreManager.java
Patch:
@@ -355,6 +355,7 @@ public void setConfigurationProperty(final String key, final String value) throw
             client.system_update_keyspace(new KsDef().setName(ksDef.name)
                                                      .setDurable_writes(ksDef.durable_writes)
                                                      .setStrategy_class(ksDef.strategy_class)
+                                                     .setCf_defs(Collections.EMPTY_LIST)
                                                      .setStrategy_options(new HashMap<String, String>(ksDef.strategy_options) {{
                                                          put(key, value);
                                                      }}));

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/AbstractCassandraStoreManager.java
Patch:
@@ -48,6 +48,7 @@ public static Partitioner getPartitioner(String className) {
      */
     public static final String KEYSPACE_DEFAULT = "titan";
     public static final String KEYSPACE_KEY = "keyspace";
+    public static final String VERSION_PROPERTY_KEY = "last-titan-version";
 
     /**
      * Default port at which to attempt Cassandra Thrift connection.
@@ -72,8 +73,6 @@ public static Partitioner getPartitioner(String className) {
     public AbstractCassandraStoreManager(Configuration storageConfig) {
         super(storageConfig, PORT_DEFAULT);
 
-
-        
         this.keySpaceName = storageConfig.getString(KEYSPACE_KEY, KEYSPACE_DEFAULT);
 
         this.replicationFactor = storageConfig.getInt(REPLICATION_FACTOR_KEY, REPLICATION_FACTOR_DEFAULT);

File: src/test/java/com/thinkaurelius/titan/StorageSetup.java
Patch:
@@ -46,6 +46,7 @@ public static final void deleteHomeDir() {
     public static Configuration getLocalStorageConfiguration() {
         BaseConfiguration config = new BaseConfiguration();
         config.addProperty(GraphDatabaseConfiguration.STORAGE_DIRECTORY_KEY,getHomeDir());
+        config.addProperty(GraphDatabaseConfiguration.EXISTING_DIRECTORY_KEY, "true");
         return config;
     }
     
@@ -75,6 +76,7 @@ public static Configuration getEmbeddedCassandraStorageConfiguration() {
 
     public static Configuration getLocalGraphConfiguration() {
         BaseConfiguration config = new BaseConfiguration();
+        config.setProperty(GraphDatabaseConfiguration.keyInNamespace(GraphDatabaseConfiguration.STORAGE_NAMESPACE, GraphDatabaseConfiguration.EXISTING_DIRECTORY_KEY), "true");
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.STORAGE_DIRECTORY_KEY,getHomeDir());
         return config;
     }

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/BasicLoadingStatus.java
Patch:
@@ -53,7 +53,9 @@ public boolean hasLoadedEdges(AtomicQuery query) {
 	
 	@Override
 	public LoadingStatus loadedEdges(AtomicQuery query) {
-		if (query.hasEdgeTypeCondition()) {
+		if (query.hasLimit()) {
+          //Nothing
+        } else if (query.hasEdgeTypeCondition()) {
             if (!QueryUtil.hasFirstKeyConstraint(query)) {
                 TitanType type = query.getTypeCondition();
                 if (loadedTypes==null) loadedTypes = new HashMap<TitanType,Byte>();

File: src/test/java/com/thinkaurelius/titan/tinkerpop/rexster/RexsterServerClientTest.java
Patch:
@@ -55,7 +55,7 @@ public void tearDown() throws Exception {
     }
 
     @Test
-    public void simpleQuery() throws Exception {
+    public void simpleQuerying() throws Exception {
         List<Map<String,Object>> result;
 //      result = client.query("g.V");
 //      assertEquals(3,result.size());

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraEmbeddedGraphConcurrentTest.java
Patch:
@@ -10,7 +10,7 @@
 public class InternalCassandraEmbeddedGraphConcurrentTest extends TitanGraphConcurrentTest {
 
     public InternalCassandraEmbeddedGraphConcurrentTest() {
-        super(StorageSetup.getEmbeddedCassandraGraphConfiguration());
+        super(StorageSetup.getEmbeddedCassandraPartitionGraphConfiguration());
     }
 
 }

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraEmbeddedGraphPerformanceTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.graphdb.cassandra;
 
 import com.thinkaurelius.titan.StorageSetup;
-import com.thinkaurelius.titan.graphdb.TitanGraphConcurrentTest;
 import com.thinkaurelius.titan.graphdb.TitanGraphPerformanceTest;
 
 /**
@@ -11,7 +10,7 @@
 public class InternalCassandraEmbeddedGraphPerformanceTest extends TitanGraphPerformanceTest {
 
     public InternalCassandraEmbeddedGraphPerformanceTest() {
-        super(StorageSetup.getEmbeddedCassandraGraphConfiguration(),0,1,false);
+        super(StorageSetup.getEmbeddedCassandraPartitionGraphConfiguration(),0,1,false);
     }
 
 }

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraEmbeddedGraphTest.java
Patch:
@@ -6,6 +6,6 @@
 public class InternalCassandraEmbeddedGraphTest extends TitanGraphTest {
 
 	public InternalCassandraEmbeddedGraphTest() {
-		super(StorageSetup.getEmbeddedCassandraGraphConfiguration());
+		super(StorageSetup.getEmbeddedCassandraPartitionGraphConfiguration());
 	}
 }

File: src/test/java/com/thinkaurelius/titan/blueprints/LocalBlueprintsTest.java
Patch:
@@ -54,7 +54,7 @@ public void testQueryTestSuite() throws Exception {
 
     public void testKeyIndexableGraphTestSuite() throws Exception {
         this.stopWatch();                                   //Excluded test cases because Titan does not yet support dropping or modifying key indexes
-        doTestSuite(new KeyIndexableGraphTestSuite(this), ImmutableSet.of("testAutoIndexKeyDroppingWithPersistence","testReIndexingOfElements","testGettingVerticesAndEdgesWithKeyValue"));
+        doTestSuite(new KeyIndexableGraphTestSuite(this), ImmutableSet.of("testAutoIndexKeyDroppingWithPersistence","testReIndexingOfElements"));
         printTestPerformance("KeyIndexableGraphTestSuite", this.stopWatch());
     }
 

File: src/main/java/com/thinkaurelius/titan/graphdb/adjacencylist/AdjacencyList.java
Patch:
@@ -11,8 +11,6 @@ public interface AdjacencyList extends Iterable<InternalRelation> {
 	
 	public AdjacencyList addEdge(InternalRelation e, ModificationStatus status);
 	
-	public AdjacencyList addEdge(InternalRelation e, boolean checkTypeUniqueness, ModificationStatus status);
-	
 	public void removeEdge(InternalRelation e, ModificationStatus status);
 
 	public boolean isEmpty();

File: src/main/java/com/thinkaurelius/titan/graphdb/database/VertexRelationLoader.java
Patch:
@@ -21,4 +21,6 @@ public interface VertexRelationLoader {
 
     public long getVertexId();
 
+    public void finalizeRelation();
+
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/factory/RelationFactory.java
Patch:
@@ -12,7 +12,7 @@
  * @author matthias
  *
  */
-public interface RelationFactory extends RelationLoader {
+public interface RelationFactory {
 
 	InternalRelation createNewProperty(TitanKey type, InternalTitanVertex node, Object attribute);
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/factory/RelationFactoryUtil.java
Patch:
@@ -38,7 +38,8 @@ public static final void connectRelation(InternalRelation relation, boolean isNe
 
 		
 		if (loaded>0) {
-			if (notloaded>0) throw new InvalidElementException("Relation already existed on some vertices but not on others",relation);
+			if (notloaded>0)
+                throw new InvalidElementException("Relation already existed on some vertices but not on others",relation);
 			else {
 				graph.loadedRelation(relation);
 			}

File: src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/PersistVertexTitanType.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.graphdb.types.vertices;
 
+import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
 import com.thinkaurelius.titan.graphdb.types.Directionality;
 import com.thinkaurelius.titan.graphdb.types.TypeCategory;
 import com.thinkaurelius.titan.core.TypeGroup;
-import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
 import com.thinkaurelius.titan.graphdb.query.QueryUtil;
 import com.thinkaurelius.titan.graphdb.types.InternalTitanType;
 import com.thinkaurelius.titan.graphdb.types.system.SystemKey;

File: src/test/java/com/thinkaurelius/titan/blueprints/TransactionalTitanGraphTestSuite.java
Patch:
@@ -24,9 +24,9 @@ public void testCompetingThreads() {
         //Need to define types before hand to avoid deadlock in transactions
         
         graph.makeType().name("friend").makeEdgeLabel();
-        graph.makeType().name("test").dataType(Long.class).makePropertyKey();
-        graph.makeType().name("blah").dataType(Float.class).makePropertyKey();
-        graph.makeType().name("bloop").dataType(Integer.class).makePropertyKey();
+        graph.makeType().name("test").functional(false).dataType(Long.class).makePropertyKey();
+        graph.makeType().name("blah").functional(false).dataType(Float.class).makePropertyKey();
+        graph.makeType().name("bloop").functional(false).dataType(Integer.class).makePropertyKey();
 
         
         graph.stopTransaction(TransactionalGraph.Conclusion.SUCCESS);

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTestCommon.java
Patch:
@@ -81,7 +81,7 @@ public TitanLabel makeKeyedEdgeLabel(String name, TitanKey primary, TitanKey sig
 	}
 	
 	public TitanKey makeUniqueStringPropertyKey(String name) {
-		return tx.makeType().name(name).simple().
+		return tx.makeType().name(name).simple().functional().
                 unique().indexed().dataType(String.class).makePropertyKey();
 	}
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/adjacencylist/AdjacencyList.java
Patch:
@@ -11,8 +11,6 @@ public interface AdjacencyList extends Iterable<InternalRelation> {
 	
 	public AdjacencyList addEdge(InternalRelation e, ModificationStatus status);
 	
-	public AdjacencyList addEdge(InternalRelation e, boolean checkTypeUniqueness, ModificationStatus status);
-	
 	public void removeEdge(InternalRelation e, ModificationStatus status);
 
 	public boolean isEmpty();
@@ -26,6 +24,6 @@ public interface AdjacencyList extends Iterable<InternalRelation> {
 	public Iterable<InternalRelation> getEdges(TypeGroup group);
 	
 	
-	public AdjacencyListStrategy getStrategy();
+	public AdjacencyListFactory getFactory();
 	
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/database/VertexRelationLoader.java
Patch:
@@ -21,4 +21,6 @@ public interface VertexRelationLoader {
 
     public long getVertexId();
 
+    public void finalizeRelation();
+
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/factory/RelationFactory.java
Patch:
@@ -12,7 +12,7 @@
  * @author matthias
  *
  */
-public interface RelationFactory extends RelationLoader {
+public interface RelationFactory {
 
 	InternalRelation createNewProperty(TitanKey type, InternalTitanVertex node, Object attribute);
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/factory/RelationFactoryUtil.java
Patch:
@@ -38,7 +38,8 @@ public static final void connectRelation(InternalRelation relation, boolean isNe
 
 		
 		if (loaded>0) {
-			if (notloaded>0) throw new InvalidElementException("Relation already existed on some vertices but not on others",relation);
+			if (notloaded>0)
+                throw new InvalidElementException("Relation already existed on some vertices but not on others",relation);
 			else {
 				graph.loadedRelation(relation);
 			}

File: src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/PersistVertexTitanKey.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.types.vertices;
 
 import com.thinkaurelius.titan.core.TitanKey;
+import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
 import com.thinkaurelius.titan.graphdb.query.QueryUtil;
 import com.thinkaurelius.titan.graphdb.types.PropertyKeyDefinition;
 import com.thinkaurelius.titan.graphdb.types.system.SystemKey;

File: src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/PersistVertexTitanLabel.java
Patch:
@@ -1,6 +1,7 @@
 package com.thinkaurelius.titan.graphdb.types.vertices;
 
 import com.thinkaurelius.titan.core.TitanLabel;
+import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
 import com.thinkaurelius.titan.graphdb.query.QueryUtil;
 import com.thinkaurelius.titan.graphdb.types.EdgeLabelDefinition;
 import com.thinkaurelius.titan.graphdb.types.system.SystemKey;

File: src/main/java/com/thinkaurelius/titan/graphdb/types/vertices/PersistVertexTitanType.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.graphdb.types.vertices;
 
+import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
 import com.thinkaurelius.titan.graphdb.types.Directionality;
 import com.thinkaurelius.titan.graphdb.types.TypeCategory;
 import com.thinkaurelius.titan.core.TypeGroup;

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/PersistStandardTitanVertex.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.graphdb.vertices;
 
+import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
 import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 import com.thinkaurelius.titan.graphdb.relations.InternalRelation;
 import com.thinkaurelius.titan.graphdb.entitystatus.BasicElement;

File: src/test/java/com/thinkaurelius/titan/TestBed.java
Patch:
@@ -17,6 +17,9 @@ public class TestBed {
 	 * @throws java.io.IOException
 	 */
 	public static void main(String[] args) throws Exception {
+        System.out.println(1-Integer.MIN_VALUE);
+        System.out.println(-2147483647+Integer.MIN_VALUE);
+        System.exit(0);
         byte b = (byte)(15 | (1<<7));
         System.out.println(b);
         System.out.println(Runtime.getRuntime().maxMemory()/1024);

File: src/test/java/com/thinkaurelius/titan/blueprints/TransactionalTitanGraphTestSuite.java
Patch:
@@ -24,9 +24,9 @@ public void testCompetingThreads() {
         //Need to define types before hand to avoid deadlock in transactions
         
         graph.makeType().name("friend").makeEdgeLabel();
-        graph.makeType().name("test").dataType(Long.class).makePropertyKey();
-        graph.makeType().name("blah").dataType(Float.class).makePropertyKey();
-        graph.makeType().name("bloop").dataType(Integer.class).makePropertyKey();
+        graph.makeType().name("test").functional(false).dataType(Long.class).makePropertyKey();
+        graph.makeType().name("blah").functional(false).dataType(Float.class).makePropertyKey();
+        graph.makeType().name("bloop").functional(false).dataType(Integer.class).makePropertyKey();
 
         
         graph.stopTransaction(TransactionalGraph.Conclusion.SUCCESS);

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTestCommon.java
Patch:
@@ -81,7 +81,7 @@ public TitanLabel makeKeyedEdgeLabel(String name, TitanKey primary, TitanKey sig
 	}
 	
 	public TitanKey makeUniqueStringPropertyKey(String name) {
-		return tx.makeType().name(name).simple().
+		return tx.makeType().name(name).simple().functional().
                 unique().indexed().dataType(String.class).makePropertyKey();
 	}
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardPersistTitanTx.java
Patch:
@@ -67,6 +67,7 @@ public boolean isDeletedRelation(long relationId) {
 	@Override
 	public boolean isDeletedRelation(InternalRelation relation) {
 		if (relation.isRemoved()) return true;
+        else if (relation.isNew() || !relation.hasID()) return false;
 		else return isDeletedRelation(Long.valueOf(relation.getID()));
 	}
 

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/InternalTitanTransaction.java
Patch:
@@ -100,6 +100,7 @@ public interface InternalTitanTransaction extends TitanTransaction {
 	 * @return true, if the edge has been deleted, else false
 	 */
 	public boolean isDeletedRelation(InternalRelation relation);
+    public boolean isDeletedRelation(long relationId);
 	
 	// ######## TitanVertex / TitanRelation Loading  ############
 	

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEStoreManager.java
Patch:
@@ -21,7 +21,7 @@
 
 public class BerkeleyJEStoreManager implements KeyValueStoreManager {
 
-    private final Logger log = LoggerFactory.getLogger(BerkeleyJEStoreManager.class);
+    private static final Logger log = LoggerFactory.getLogger(BerkeleyJEStoreManager.class);
 
 
     public static final String CACHE_KEY = "cache-percentage";

File: src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStoreManager.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.PermanentStorageException;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.TemporaryStorageException;
-import com.thinkaurelius.titan.diskstorage.common.RemoteStoreManager;
+import com.thinkaurelius.titan.diskstorage.common.DistributedStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.*;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Mutation;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
@@ -26,7 +26,7 @@
  * 
  * @author Dan LaRocque <dalaro@hopcount.org>
  */
-public class HBaseStoreManager extends RemoteStoreManager implements KeyColumnValueStoreManager  {
+public class HBaseStoreManager extends DistributedStoreManager implements KeyColumnValueStoreManager  {
 
 	private static final Logger log = LoggerFactory.getLogger(HBaseStoreManager.class);
 	
@@ -83,7 +83,7 @@ public HBaseStoreManager(org.apache.commons.configuration.Configuration config)
 
         features = new StoreFeatures();
         features.supportsScan=false; features.supportsBatchMutation=true; features.isTransactional=false;
-        features.supportsConsistentKeyOperations=true; features.supportsLocking=false; features.isKeyOrdered=false;
+        features.supportsConsistentKeyOperations=true; features.supportsLocking=false; features.isKeyOrdered=super.isKeyOrdered;
         features.isDistributed=true; features.hasLocalKeyPartition=false;
     }
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/idmanagement/AbstractIDManager.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.IDAuthority;
-import com.thinkaurelius.titan.diskstorage.common.RemoteStoreManager;
+import com.thinkaurelius.titan.diskstorage.common.DistributedStoreManager;
 import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.idassigner.IDBlockSizer;
@@ -32,7 +32,7 @@ public abstract class AbstractIDManager implements IDAuthority {
     private volatile boolean isActive;
 
     public AbstractIDManager(Configuration config) {
-        this.rid = RemoteStoreManager.getRid(config);
+        this.rid = DistributedStoreManager.getRid(config);
 
         this.isActive = false;
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockConfiguration.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.locking.consistentkey;
 
-import com.thinkaurelius.titan.diskstorage.common.RemoteStoreManager;
+import com.thinkaurelius.titan.diskstorage.common.DistributedStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import org.apache.commons.configuration.Configuration;
 
@@ -17,7 +17,7 @@ public class ConsistentKeyLockConfiguration {
     final String localLockMediatorPrefix;
     
     public ConsistentKeyLockConfiguration(Configuration config, String storeManagerName) {
-        this.rid = RemoteStoreManager.getRid(config);
+        this.rid = DistributedStoreManager.getRid(config);
 
         this.localLockMediatorPrefix = config.getString(
                 ConsistentKeyLockStore.LOCAL_LOCK_MEDIATOR_PREFIX_KEY,

File: src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -662,7 +662,7 @@ public void save(final Collection<InternalRelation> addedRelations,
         
         //1. Assign TitanVertex IDs
         if (!tx.getTxConfiguration().hasAssignIDsImmediately())
-            idAssigner.assignIDs(addedRelations);
+            idAssigner.assignIDs(addedRelationsIter);
 
         for (int saveAttempt=0;saveAttempt<maxWriteRetryAttempts;saveAttempt++) {
 //        while (true) { //Indefinite loop, broken if no exception occurs, otherwise retried or failed immediately

File: src/main/java/com/thinkaurelius/titan/graphdb/entitystatus/BasicElement.java
Patch:
@@ -40,7 +40,7 @@ public boolean hasID() {
 	
 	@Override
 	public void setID(long id) {
-		Preconditions.checkArgument(isNew(), "Illegal lifecycle status for setting id");
+		Preconditions.checkArgument(isNew(), "Illegal lifecycle status for setting id: " + isLoaded() + " | " + isRemoved());
 		Preconditions.checkArgument(id!=NoID,"Illegal id: " + id);
 		if (hasID()) throw new IllegalStateException("The entity has already been assigned an id");
 		this.id = id;

File: src/test/java/com/thinkaurelius/titan/StorageSetup.java
Patch:
@@ -111,6 +111,9 @@ public static Configuration getEmbeddedCassandraGraphConfiguration() {
         config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(
         		CassandraEmbeddedStoreManager.CASSANDRA_CONFIG_DIR_KEY,
         		cassandraYamlPath);
+        config.subset(GraphDatabaseConfiguration.IDS_NAMESPACE).addProperty(GraphDatabaseConfiguration.IDS_PARTITION_KEY,true);
+        config.subset(GraphDatabaseConfiguration.IDS_NAMESPACE).addProperty(GraphDatabaseConfiguration.IDS_FLUSH_KEY,false);
+        config.subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE).addProperty(GraphDatabaseConfiguration.STORAGE_IS_ORDERED_KEY,true);
         return config;
     }
 }

File: src/test/java/com/thinkaurelius/titan/diskstorage/MultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -51,7 +51,7 @@ public void setUp() throws Exception {
 	public void open() throws StorageException {
         manager = openStorageManager();
         assertTrue(manager.getFeatures().supportsBatchMutation());
-        tx = new BufferTransaction(manager.beginTransaction(ConsistencyLevel.DEFAULT),manager,bufferSize);
+        tx = new BufferTransaction(manager.beginTransaction(ConsistencyLevel.DEFAULT),manager,bufferSize,1,0);
         store1 = new BufferedKeyColumnValueStore(manager.openDatabase(storeName1),true);
         store2 = new BufferedKeyColumnValueStore(manager.openDatabase(storeName2),true);
         

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -250,10 +250,10 @@ public void testCreateDelete() {
 		TitanVertex n1 = tx.addVertex(), n3 = tx.addVertex();
 		TitanEdge e=n3.addEdge(knows, n1);
 		e.addProperty(id, 111);
-        Object eid = e.getId();
 		n3.addProperty(id, 445);
 		assertEquals(111, e.getProperty(id));
 		clopen();
+        Object eid = e.getId();
 		long nid = n3.getID();
 		
 		n3 = tx.getVertex(nid);

File: src/main/java/com/thinkaurelius/titan/diskstorage/indexing/HashPrefixKeyColumnValueStore.java
Patch:
@@ -34,7 +34,9 @@ public HashPrefixKeyColumnValueStore(KeyColumnValueStore store, int numPrefixByt
     private final ByteBuffer prefixKey(ByteBuffer key) {
         try {
             MessageDigest m = MessageDigest.getInstance(algorithm);
+            key.mark();
             m.update(key);
+            key.reset();
             byte[] hash = m.digest();
             ByteBuffer newKey = ByteBuffer.allocate(key.remaining()+numPrefixBytes);
             for (int i=0;i<numPrefixBytes;i++) {

File: src/main/java/com/thinkaurelius/titan/diskstorage/locking/consistentkey/ConsistentKeyLockTransaction.java
Patch:
@@ -326,7 +326,7 @@ public void verifyAllLockClaims() throws StorageException {
 			
 			
 			// Check expectedValue
-			ByteBuffer bb = backer.getDataStore().get(lc.getKey(), lc.getColumn(), consistentTx);
+			ByteBuffer bb = backer.getDataStore().get(lc.getKey(), lc.getColumn(), baseTx);
 			if ((null == bb && null != lc.getExpectedValue()) ||
 			    (null != bb && null == lc.getExpectedValue()) ||
 			    (null != bb && null != lc.getExpectedValue() && !lc.getExpectedValue().equals(bb))) {

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -363,7 +363,7 @@ public static List<RegisteredAttributeClass<?>> getRegisteredAttributeClasses(Co
     }
 
 	public VertexIDAssigner getIDAssigner(Backend backend) {
-		return new VertexIDAssigner(configuration.subset(IDS_NAMESPACE),backend);
+		return new VertexIDAssigner(configuration.subset(IDS_NAMESPACE),backend.getIDAuthority(),backend.getStoreFeatures());
 	}
 
     public String getBackendDescription() {

File: src/test/java/com/thinkaurelius/titan/diskstorage/MultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -135,7 +135,7 @@ public void mutateManyStressTest() throws StorageException {
     	int dels = 1024;
     	int adds = 4096;
     	
-    	for (int round = 0; round < 10; round++) {
+    	for (int round = 0; round < 5; round++) {
     		Map<ByteBuffer, Mutation> changes = mutateState(state, dels, adds);
 
             applyChanges(changes,store1,tx);

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/InternalCassandraEmbeddedMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -10,6 +10,6 @@ public class InternalCassandraEmbeddedMultiWriteKeyColumnValueStoreTest extends
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new CassandraThriftStoreManager(StorageSetup.getEmbeddedCassandraStorageConfiguration());
+        return new CassandraEmbeddedStoreManager(StorageSetup.getEmbeddedCassandraStorageConfiguration());
     }
 }

File: src/main/java/com/thinkaurelius/titan/core/TitanElement.java
Patch:
@@ -31,7 +31,7 @@ public interface TitanElement {
      * 
      * The unique identifier may only be set when the transaction in which entity is created commits.
      * The <a href="https://github.com/thinkaurelius/titan/wiki/Graph-Configuration">Graph Configuration Wiki</a> explains
-     * how to configure when entity ids are assigned.
+     * how to configure when entity idAuthorities are assigned.
      * Some entities are never assigned a unique identifier if they depend on a parent entity.
      * 
      * Note: Edges cannot be retrieved by the unique identifier returned by {@link #getID()}. Use the identifier returned

File: src/main/java/com/thinkaurelius/titan/core/TitanQuery.java
Patch:
@@ -137,7 +137,7 @@ public interface TitanQuery extends Query {
      *
      * By default, an implementation of TitanQuery chooses the most efficient way to retrieve a vertex's incident relations.
      * In some cases, it may be most efficient to NOT create the object graph in memory but only retrieve what is asked
-     * for (e.g. vertex ids) directly from the storage backend. However, when the same or similar queries are repeatedly
+     * for (e.g. vertex idAuthorities) directly from the storage backend. However, when the same or similar queries are repeatedly
      * executed, creating the object graph in memory first is more efficient.
      * Calling this method signals such cases to the TitanQuery implementation.
      *
@@ -209,7 +209,7 @@ public interface TitanQuery extends Query {
      * matching the conditions defined in this query.
      *
      * No guarantee is made as to the order in which the vertices are listed. Use {@link com.thinkaurelius.titan.core.VertexList#sort()}
-     * to sort by vertex ids most efficiently.
+     * to sort by vertex idAuthorities most efficiently.
      *
      * The query engine will determine the most efficient way to retrieve the vertices that match this query.
      *

File: src/main/java/com/thinkaurelius/titan/core/TypeGroup.java
Patch:
@@ -15,7 +15,7 @@
  * TitanTypes are assigned to TypeGroups when they are first created using {@link TypeMaker#group(TypeGroup)}.
  * <br />
  * A TitanGroup is defined with a name and an id, however, two groups with the same id are considered equivalent.
- * The name is only used for recognition has is not persisted in the database. Group ids must be positive (>0)
+ * The name is only used for recognition has is not persisted in the database. Group idAuthorities must be positive (>0)
  * and the maximum group id allowed is configurable.
  *
  * @author	Matthias Br&ouml;cheler (http://www.matthiasb.com)

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/CassandraDaemonWrapper.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.diskstorage.cassandra;
+package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;

File: src/main/java/com/thinkaurelius/titan/diskstorage/common/AbstractStoreTransaction.java
Patch:
@@ -3,17 +3,17 @@
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.ConsistencyLevel;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransactionHandle;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 
 /**
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 
-public abstract class AbstractStoreTransactionHandle implements StoreTransactionHandle {
+public abstract class AbstractStoreTransaction implements StoreTransaction {
 
     private final ConsistencyLevel consistencyLevel;
 
-    public AbstractStoreTransactionHandle(ConsistencyLevel level) {
+    public AbstractStoreTransaction(ConsistencyLevel level) {
         Preconditions.checkNotNull(level);
         consistencyLevel=level;
     }

File: src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/BufferMutationKeyColumnValueStore.java
Patch:
@@ -1,8 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue;
 
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.Mutation;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransactionHandle;
 
 import java.nio.ByteBuffer;
 import java.util.Map;
@@ -13,6 +11,6 @@
 
 public interface BufferMutationKeyColumnValueStore {
     
-    public void mutateMany(Map<String,Map<ByteBuffer,Mutation>> mutations, StoreTransactionHandle txh) throws StorageException;
+    public void mutateMany(Map<String,Map<ByteBuffer,Mutation>> mutations, StoreTransaction txh) throws StorageException;
     
 }

File: src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreManager.java
Patch:
@@ -13,7 +13,7 @@ public interface StoreManager {
      *
      * @return New Transaction Hanlde
      */
-    public StoreTransactionHandle beginTransaction(ConsistencyLevel consistencyLevel) throws StorageException;
+    public StoreTransaction beginTransaction(ConsistencyLevel consistencyLevel) throws StorageException;
 
     /**
      * Closes the Storage Manager and all databases that have been opened.

File: src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/StoreTransaction.java
Patch:
@@ -6,16 +6,16 @@
  * A transaction handle uniquely identifies a transaction on the storage backend.
  * 
  * All modifications to the storage backend must occur within the context of a single 
- * transaction. Such a transaction is identified to the Titan middleware by a StoreTransactionHandle.
+ * transaction. Such a transaction is identified to the Titan middleware by a StoreTransaction.
  * Graph transactions rely on the existence of a storage backend transaction.
  * 
- * Note, that a StoreTransactionHandle by itself does not provide any isolation or consistency guarantees (e.g. ACID).
+ * Note, that a StoreTransaction by itself does not provide any isolation or consistency guarantees (e.g. ACID).
  * Graph Transactions can only extend such guarantees if they are supported by the respective storage backend.
  * 
  * @author	Matthias Br&ouml;cheler (me@matthiasb.com);
  *
  */
-public interface StoreTransactionHandle extends TransactionHandle {
+public interface StoreTransaction extends TransactionHandle {
 
     public ConsistencyLevel getConsistencyLevel();
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/keycolumnvalue/keyvalue/KeyValueStoreManager.java
Patch:
@@ -1,9 +1,7 @@
 package com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue;
 
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreManager;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransactionHandle;
 
 public interface KeyValueStoreManager extends StoreManager {
 

File: src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanFeatures.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.blueprints;
 
-import com.thinkaurelius.titan.diskstorage.StorageFeatures;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreFeatures;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.tinkerpop.blueprints.Features;
 
@@ -46,7 +46,7 @@ private static Features getBaselineTitanFeatures() {
         return features;
     }
     
-    public static Features getFeatures(GraphDatabaseConfiguration config, StorageFeatures storageFeatures) {
+    public static Features getFeatures(GraphDatabaseConfiguration config, StoreFeatures storageFeatures) {
         Features features = TitanFeatures.getBaselineTitanFeatures();
         features.supportsSerializableObjectProperty = config.hasSerializeAll();
         if (storageFeatures!=null) {

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/RelationIdentifier.java
Patch:
@@ -91,7 +91,7 @@ public static final RelationIdentifier parse(String id) {
     public static final RelationIdentifier get(long[] ids) {
         if (ids.length!=3) return null;
         for (int i=0;i<3;i++) {
-            //Preconditions.checkArgument(ids[i]>=0,"Non-negative numbers expected");
+            //Preconditions.checkArgument(idAuthorities[i]>=0,"Non-negative numbers expected");
             if (ids[i]<0) return null;
         }
         return new RelationIdentifier(ids[0],ids[1],ids[2]);
@@ -100,7 +100,7 @@ public static final RelationIdentifier get(long[] ids) {
     public static final RelationIdentifier get(int[] ids) {
         if (ids.length!=3) return null;
         for (int i=0;i<3;i++) {
-            //Preconditions.checkArgument(ids[i]>=0,"Non-negative numbers expected");
+            //Preconditions.checkArgument(idAuthorities[i]>=0,"Non-negative numbers expected");
             if (ids[i]<0) return null;
         }
         return new RelationIdentifier(ids[0],ids[1],ids[2]);

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/InMemoryTitanGraph.java
Patch:
@@ -4,7 +4,7 @@
 import com.google.common.base.Preconditions;
 import com.thinkaurelius.titan.core.*;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransactionHandle;
+import com.thinkaurelius.titan.diskstorage.keycolumnvalue.StoreTransaction;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.RecordIterator;
 import com.thinkaurelius.titan.graphdb.blueprints.TitanFeatures;
 import com.thinkaurelius.titan.graphdb.database.InternalTitanGraph;
@@ -87,7 +87,7 @@ public AbstractLongList getRawNeighborhood(AtomicQuery query) {
 	}
 	
 	@Override
-	public StoreTransactionHandle getTxHandle() {
+	public StoreTransaction getTxHandle() {
 		throw new UnsupportedOperationException("InMemory Transactions do not have transaction handles");
 	}
 
@@ -134,7 +134,7 @@ public void assignID(InternalTitanVertex vertex) {
         int id = idCounter.incrementAndGet();
         long newid = -1;
         if (vertex instanceof InternalRelation) {
-            newid = idManager.getEdgeID(id);
+            newid = idManager.getEdgeID(id,0);
         } else if (vertex instanceof TitanKey) {
             newid = idManager.getPropertyTypeID(id,0,0);
         } else if (vertex instanceof TitanLabel) {

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/TransactionConfig.java
Patch:
@@ -64,7 +64,7 @@ public boolean isReadOnly() {
 
     /**
      *
-     * @return Whether this transaction is configured to assign ids immediately.
+     * @return Whether this transaction is configured to assign idAuthorities immediately.
      */
     public boolean hasAssignIDsImmediately() {
         return assignIDsImmediately;

File: src/main/java/com/thinkaurelius/titan/graphdb/types/manager/SimpleTypeManager.java
Patch:
@@ -79,7 +79,7 @@ public void committed(InternalTitanType type) {
                 throw new InvalidElementException("TitanRelation Type with name does already exist: " + type.getName()
                         + " | " + type.isEdgeLabel(), type);
             nameIndex.put(type.getName(), id);
-            // Determine system edge ids
+            // Determine system edge idAuthorities
             long nameEdgeID = QueryUtil.queryHiddenFunctionalProperty(type, SystemKey.TypeName).getID();
             long defEdgeID = -1;
             if (type.isPropertyKey()) {

File: src/test/java/com/thinkaurelius/titan/blueprints/ExternalCassandraBlueprintsTest.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
-import com.thinkaurelius.titan.diskstorage.cassandra.CassandraThriftStorageManager;
+import com.thinkaurelius.titan.diskstorage.cassandra.thrift.CassandraThriftStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.tinkerpop.blueprints.Graph;
 
@@ -34,7 +34,7 @@ public Graph generateGraph() {
 
     @Override
     public void cleanUp() throws StorageException {
-        CassandraThriftStorageManager s = new CassandraThriftStorageManager(
+        CassandraThriftStoreManager s = new CassandraThriftStoreManager(
                 StorageSetup.getCassandraGraphConfiguration().subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE));
         s.clearStorage();
     }

File: src/test/java/com/thinkaurelius/titan/blueprints/ExternalHBaseBlueprintsTest.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.hbase.HBaseStorageManager;
+import com.thinkaurelius.titan.diskstorage.hbase.HBaseStoreManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.tinkerpop.blueprints.Graph;
 
@@ -32,7 +32,7 @@ public Graph generateGraph() {
 
     @Override
     public void cleanUp() throws StorageException {
-        HBaseStorageManager s = new HBaseStorageManager(
+        HBaseStoreManager s = new HBaseStoreManager(
                 StorageSetup.getHBaseGraphConfiguration().subset(GraphDatabaseConfiguration.STORAGE_NAMESPACE));
         s.clearStorage();
     }

File: src/test/java/com/thinkaurelius/titan/blueprints/LocalBlueprintsTest.java
Patch:
@@ -4,7 +4,7 @@
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.core.TitanFactory;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEStoreManager;
+import com.thinkaurelius.titan.diskstorage.berkeleyje.BerkeleyJEStoreManager;
 import com.tinkerpop.blueprints.*;
 import com.tinkerpop.blueprints.impls.GraphTest;
 import com.tinkerpop.blueprints.util.io.gml.GMLReaderTestSuite;

File: src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyDBjeKeyColumnValueVariableTest.java
Patch:
@@ -4,7 +4,6 @@
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
-import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.KeyValueStoreManagerAdapter;
 import org.apache.commons.configuration.Configuration;
 
@@ -14,7 +13,7 @@ public class BerkeleyDBjeKeyColumnValueVariableTest extends KeyColumnValueStoreT
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
         Configuration config = StorageSetup.getBerkeleyJEStorageConfiguration();
 		BerkeleyJEStoreManager sm = new BerkeleyJEStoreManager(config);
-		return new KeyValueStoreManagerAdapter(sm,config);
+		return new KeyValueStoreManagerAdapter(sm);
 	}
 
 }

File: src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyJEKeyValueTest.java
Patch:
@@ -3,7 +3,6 @@
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.keyvalue.KeyValueStoreManager;
 
 

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraProcessStarter.java
Patch:
@@ -175,7 +175,7 @@ public void startCassandra() {
 			 */
 			log.debug("Clearing pooled Thrift connections for {}:{}",
 					address, port);
-			CTConnectionPool.getPool(address, port, GraphDatabaseConfiguration.COMMUNICATION_TIMEOUT_DEFAULT).clear();
+			CTConnectionPool.getPool(address, port, GraphDatabaseConfiguration.CONNECTION_TIMEOUT_DEFAULT).clear();
 		} catch (Exception e) {
 			e.printStackTrace();
 			throw new TitanException(e);
@@ -207,7 +207,7 @@ public void stopCassandra() {
 	}
 
 	public void waitForClusterSize(int minSize) throws InterruptedException, StorageException {
-		CTConnectionFactory f = CTConnectionPool.getFactory(address, port, GraphDatabaseConfiguration.COMMUNICATION_TIMEOUT_DEFAULT);
+		CTConnectionFactory f = CTConnectionPool.getFactory(address, port, GraphDatabaseConfiguration.CONNECTION_TIMEOUT_DEFAULT);
 		CTConnection conn = null;
 		try {
 			conn = f.makeRawConnection();

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/ExternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -1,9 +1,9 @@
-package com.thinkaurelius.titan.diskstorage.astyanax;
+package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.astyanax.AstyanaxStorageManager;
+import com.thinkaurelius.titan.diskstorage.cassandra.astyanax.AstyanaxStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import org.junit.AfterClass;
@@ -15,7 +15,7 @@ public class ExternalAstyanaxKeyColumnValueTest extends KeyColumnValueStoreTest
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStorageManager(StorageSetup.getCassandraStorageConfiguration());
+        return new AstyanaxStoreManager(StorageSetup.getCassandraStorageConfiguration());
     }
 
 

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/astyanax/ExternalAstyanaxMultiWriteKeyColumnValueTest.java
Patch:
@@ -1,9 +1,9 @@
-package com.thinkaurelius.titan.diskstorage.astyanax;
+package com.thinkaurelius.titan.diskstorage.cassandra.astyanax;
 
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
-import com.thinkaurelius.titan.diskstorage.cassandra.astyanax.AstyanaxStorageManager;
+import com.thinkaurelius.titan.diskstorage.cassandra.astyanax.AstyanaxStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import org.junit.AfterClass;
@@ -13,7 +13,7 @@ public class ExternalAstyanaxMultiWriteKeyColumnValueTest extends MultiWriteKeyC
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new AstyanaxStorageManager(StorageSetup.getCassandraStorageConfiguration());
+        return new AstyanaxStoreManager(StorageSetup.getCassandraStorageConfiguration());
     }
 
     public static CassandraProcessStarter ch = new CassandraProcessStarter();

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/InternalCassandraEmbeddedKeyColumnValueTest.java
Patch:
@@ -1,6 +1,7 @@
-package com.thinkaurelius.titan.diskstorage.cassandra;
+package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraEmbeddedStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 import org.apache.commons.configuration.Configuration;
 
@@ -11,7 +12,7 @@ public class InternalCassandraEmbeddedKeyColumnValueTest extends KeyColumnValueS
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new CassandraEmbeddedStorageManager(getConfiguration());
+        return new CassandraEmbeddedStoreManager(getConfiguration());
     }
 
     private Configuration getConfiguration() {

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/embedded/InternalCassandraEmbeddedMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -1,14 +1,15 @@
-package com.thinkaurelius.titan.diskstorage.cassandra;
+package com.thinkaurelius.titan.diskstorage.cassandra.embedded;
 
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageException;
+import com.thinkaurelius.titan.diskstorage.cassandra.thrift.CassandraThriftStoreManager;
 import com.thinkaurelius.titan.diskstorage.keycolumnvalue.KeyColumnValueStoreManager;
 
 public class InternalCassandraEmbeddedMultiWriteKeyColumnValueStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     @Override
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new CassandraThriftStorageManager(StorageSetup.getEmbeddedCassandraStorageConfiguration());
+        return new CassandraThriftStoreManager(StorageSetup.getEmbeddedCassandraStorageConfiguration());
     }
 }

File: src/test/java/com/thinkaurelius/titan/diskstorage/hbase/ExternalHBaseKeyColumnValueTest.java
Patch:
@@ -10,7 +10,7 @@
 public class ExternalHBaseKeyColumnValueTest extends KeyColumnValueStoreTest {
 
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new HBaseStorageManager(getConfig());
+        return new HBaseStoreManager(getConfig());
     }
 	
 	private Configuration getConfig() {

File: src/test/java/com/thinkaurelius/titan/diskstorage/hbase/ExternalHBaseMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -10,7 +10,7 @@
 public class ExternalHBaseMultiWriteKeyColumnValueStoreTest extends MultiWriteKeyColumnValueStoreTest {
 
     public KeyColumnValueStoreManager openStorageManager() throws StorageException {
-        return new HBaseStorageManager(getConfig());
+        return new HBaseStoreManager(getConfig());
     }
 
 	private Configuration getConfig() {

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTestCommon.java
Patch:
@@ -21,7 +21,7 @@ public TitanGraphTestCommon(Configuration config) {
 	@Before
 	public void setUp() throws Exception {
         GraphDatabaseConfiguration graphconfig = new GraphDatabaseConfiguration(config);
-        graphconfig.getStorageManager().clearStorage();
+        graphconfig.getBackend().clearStorage();
 		open();
 	}
 	

File: src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphConcurrentTest.java
Patch:
@@ -1,9 +1,8 @@
 package com.thinkaurelius.titan.graphdb.astyanax;
 
 import com.thinkaurelius.titan.StorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.graphdb.TitanGraphConcurrentTest;
-import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 import org.junit.BeforeClass;
 
 public class InternalAstyanaxGraphConcurrentTest extends TitanGraphConcurrentTest {

File: src/test/java/com/thinkaurelius/titan/graphdb/astyanax/InternalAstyanaxGraphTest.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.graphdb.astyanax;
 
+import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.StorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 
 public class InternalAstyanaxGraphTest extends TitanGraphTest {

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraGraphConcurrentTest.java
Patch:
@@ -1,9 +1,8 @@
 package com.thinkaurelius.titan.graphdb.cassandra;
 
 import com.thinkaurelius.titan.StorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.CassandraDaemonWrapper;
+import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.graphdb.TitanGraphConcurrentTest;
-import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 import org.junit.BeforeClass;
 
 public class InternalCassandraGraphConcurrentTest extends TitanGraphConcurrentTest {

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraGraphTest.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.graphdb.cassandra;
 
+import com.thinkaurelius.titan.diskstorage.cassandra.embedded.CassandraDaemonWrapper;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.StorageSetup;
-import com.thinkaurelius.titan.diskstorage.cassandra.CassandraDaemonWrapper;
 import com.thinkaurelius.titan.graphdb.TitanGraphTest;
 
 public class InternalCassandraGraphTest extends TitanGraphTest {

File: src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/IDManagementTest.java
Patch:
@@ -57,8 +57,9 @@ public void testEntityID(int partitionBits, int groupBits, long count, int parti
 		assertTrue(eid.isNodeID(id));
 		assertEquals(eid.getPartitionID(id),partition);
 		
-		id = eid.getEdgeID(count);
+		id = eid.getEdgeID(count,partition);
 		assertTrue(eid.isEdgeID(id));
+        assertEquals(eid.getPartitionID(id),partition);
 
 		id = eid.getPropertyTypeID(count, group, partition);
 		assertTrue(eid.isPropertyTypeID(id));

File: src/test/java/com/thinkaurelius/titan/testutil/CassandraUtil.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.testutil;
 
-import com.thinkaurelius.titan.diskstorage.cassandra.astyanax.AstyanaxStorageManager;
+import com.thinkaurelius.titan.diskstorage.cassandra.astyanax.AstyanaxStoreManager;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -19,7 +19,7 @@ public class CassandraUtil {
 
 	public static void dropKeyspace(String name, String hostname, int port) {
 		AstyanaxContext<Cluster> ctx = new AstyanaxContext.Builder()
-				.forCluster(AstyanaxStorageManager.CLUSTER_DEFAULT)
+				.forCluster(AstyanaxStoreManager.CLUSTER_DEFAULT)
 				.withAstyanaxConfiguration(
 						new AstyanaxConfigurationImpl()
 								.setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE))

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -50,7 +50,7 @@
 import org.apache.hadoop.io.WritableComparable;
 import org.apache.hadoop.io.WritableComparator;
 import org.apache.hadoop.io.compress.CompressionCodec;
-import org.apache.hadoop.io.compress.SnappyCodec;
+import org.apache.hadoop.io.compress.DefaultCodec;
 import org.apache.hadoop.mapreduce.InputFormat;
 import org.apache.hadoop.mapreduce.Job;
 import org.apache.hadoop.mapreduce.Mapper;
@@ -448,7 +448,7 @@ public void completeSequence() throws IOException {
                     job.setCombinerClass(this.combinerClass);
                 // if there is a reduce task, compress the map output to limit network traffic
                 job.getConfiguration().setBoolean("mapred.compress.map.output", true);
-                job.getConfiguration().setClass("mapred.map.output.compression.codec", SnappyCodec.class, CompressionCodec.class);
+                job.getConfiguration().setClass("mapred.map.output.compression.codec", DefaultCodec.class, CompressionCodec.class);
             } else {
                 job.setNumReduceTasks(0);
             }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -33,10 +33,8 @@
 import com.thinkaurelius.faunus.mapreduce.util.CountMapReduce;
 import com.thinkaurelius.faunus.mapreduce.util.WritableComparators;
 import com.tinkerpop.blueprints.Direction;
-import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Element;
 import com.tinkerpop.blueprints.Query;
-import com.tinkerpop.blueprints.Vertex;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.conf.Configured;
 import org.apache.hadoop.fs.FileStatus;
@@ -426,7 +424,7 @@ public void countMapReduce(final Class<? extends Element> klass) throws IOExcept
         this.mapSequenceClasses.add(CountMapReduce.Map.class);
         this.combinerClass = CountMapReduce.Combiner.class;
         this.reduceClass = CountMapReduce.Reduce.class;
-        this.setKeyValueClasses(IntWritable.class, LongWritable.class, IntWritable.class, Text.class);
+        this.setKeyValueClasses(NullWritable.class, LongWritable.class, NullWritable.class, LongWritable.class);
         this.completeSequence();
     }
 

File: src/main/java/com/thinkaurelius/faunus/formats/titan/cassandra/FaunusTitanCassandraGraph.java
Patch:
@@ -37,9 +37,9 @@ public FaunusTitanCassandraGraph(final Configuration configuration) {
         this.tx = startTransaction(new TransactionConfig(this.getConfiguration()));
     }
 
-    public FaunusVertex readFaunusVertex(final Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> row) {
-        FaunusVertexRelationLoader loader = new FaunusVertexRelationLoader(row.left.duplicate());
-        loadRelations(new CassandraMapIterable(row.right), loader, tx);
+    public FaunusVertex readFaunusVertex(final ByteBuffer key, final SortedMap<ByteBuffer, IColumn> value) {
+        FaunusVertexRelationLoader loader = new FaunusVertexRelationLoader(key);
+        loadRelations(new CassandraMapIterable(value), loader, tx);
         return loader.getVertex();
     }
 

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/Imports.java
Patch:
@@ -30,6 +30,8 @@ public class Imports {
         imports.add("com.thinkaurelius.faunus.formats.noop.*");
         imports.add("com.thinkaurelius.faunus.formats.rexster.*");
         imports.add("com.thinkaurelius.faunus.formats.titan.*");
+        imports.add("com.thinkaurelius.faunus.formats.titan.hbase.*");
+        imports.add("com.thinkaurelius.faunus.formats.titan.cassandra.*");
         imports.add("com.thinkaurelius.faunus.hdfs.*");
         imports.add("com.thinkaurelius.faunus.tinkerpop.gremlin.*");
         imports.add("com.tinkerpop.gremlin.Tokens.T");

File: src/main/java/com/thinkaurelius/faunus/mapreduce/filter/CyclicPathFilterMap.java
Patch:
@@ -21,7 +21,7 @@
  */
 public class CyclicPathFilterMap {
 
-    public static final String CLASS = Tokens.makeNamespace(FilterMap.class) + ".class";
+    public static final String CLASS = Tokens.makeNamespace(CyclicPathFilterMap.class) + ".class";
 
     public enum Counters {
         PATHS_FILTERED

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/PropertyMapMap.java
Patch:
@@ -21,7 +21,7 @@
  */
 public class PropertyMapMap {
 
-    public static final String CLASS = Tokens.makeNamespace(PropertyMap.class) + ".class";
+    public static final String CLASS = Tokens.makeNamespace(PropertyMapMap.class) + ".class";
 
     public enum Counters {
         VERTICES_PROCESSED,

File: src/test/java/com/thinkaurelius/faunus/mapreduce/filter/CyclicPathFilterMapTest.java
Patch:
@@ -34,7 +34,7 @@ public void setUp() {
 
     public void testVertices() throws IOException {
         Configuration config = new Configuration();
-        config.setClass(FilterMap.CLASS, Vertex.class, Element.class);
+        config.setClass(CyclicPathFilterMap.CLASS, Vertex.class, Element.class);
         config.setBoolean(FaunusCompiler.PATH_ENABLED, true);
 
         mapReduceDriver.withConfiguration(config);
@@ -77,7 +77,7 @@ public void testVertices() throws IOException {
 
     public void testEdges() throws IOException {
         Configuration config = new Configuration();
-        config.setClass(FilterMap.CLASS, Edge.class, Element.class);
+        config.setClass(CyclicPathFilterMap.CLASS, Edge.class, Element.class);
         config.setBoolean(FaunusCompiler.PATH_ENABLED, true);
 
         mapReduceDriver.withConfiguration(config);
@@ -120,5 +120,4 @@ public void testEdges() throws IOException {
 
         identicalStructure(graph, BaseTest.ExampleGraph.TINKERGRAPH);
     }
-
 }

File: src/main/java/com/thinkaurelius/faunus/formats/Inverter.java
Patch:
@@ -30,6 +30,6 @@ public static Class<? extends InputFormat> invertOutputFormat(Class<? extends Ou
         else if (outputFormat.equals(SequenceFileOutputFormat.class))
             return SequenceFileInputFormat.class;
 
-        throw new UnsupportedOperationException("There currently is no inverse for " + outputFormat.getClass());
+        throw new UnsupportedOperationException("There currently is no inverse for " + outputFormat.getName());
     }
 }

File: src/main/java/com/thinkaurelius/faunus/formats/noop/NoOpOutputFormat.java
Patch:
@@ -9,7 +9,7 @@
 import java.io.IOException;
 
 /**
- * USe NoOpOutputFormat to ensure that sideeffect data is outputted, but not graph data
+ * Use NoOpOutputFormat to ensure that sideeffect data is outputted, but not graph data.
  *
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/OrderMapReduce.java
Patch:
@@ -87,7 +87,6 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
 
         @Override
         public void cleanup(final Mapper<NullWritable, FaunusVertex, WritableComparable, Text>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }
@@ -110,7 +109,6 @@ public void reduce(final WritableComparable key, final Iterable<Text> values, fi
 
         @Override
         public void cleanup(final Reducer<WritableComparable, Text, Text, WritableComparable>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/PathMap.java
Patch:
@@ -72,7 +72,6 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
 
         @Override
         public void cleanup(final Mapper<NullWritable, FaunusVertex, NullWritable, Text>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/PropertyMap.java
Patch:
@@ -77,7 +77,6 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
 
         @Override
         public void cleanup(final Mapper<NullWritable, FaunusVertex, NullWritable, WritableComparable>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/PropertyMapMap.java
Patch:
@@ -73,7 +73,6 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
 
         @Override
         public void cleanup(final Mapper<NullWritable, FaunusVertex, LongWritable, Text>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/TransformMap.java
Patch:
@@ -85,7 +85,6 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
 
         @Override
         public void cleanup(final Mapper<NullWritable, FaunusVertex, NullWritable, Text>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/util/CountMapReduce.java
Patch:
@@ -68,7 +68,6 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
 
         @Override
         public void cleanup(final Mapper<NullWritable, FaunusVertex, IntWritable, LongWritable>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }
@@ -108,7 +107,6 @@ public void reduce(final IntWritable key, final Iterable<LongWritable> values, f
 
         @Override
         public void cleanup(final Reducer<IntWritable, LongWritable, NullWritable, Text>.Context context) throws IOException, InterruptedException {
-            super.cleanup(context);
             this.outputs.close();
         }
     }

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/Imports.java
Patch:
@@ -27,6 +27,7 @@ public class Imports {
         imports.add("com.thinkaurelius.faunus.formats.*");
         imports.add("com.thinkaurelius.faunus.formats.edgelist.*");
         imports.add("com.thinkaurelius.faunus.formats.graphson.*");
+        imports.add("com.thinkaurelius.faunus.formats.noop.*");
         imports.add("com.thinkaurelius.faunus.formats.rexster.*");
         imports.add("com.thinkaurelius.faunus.formats.titan.*");
         imports.add("com.thinkaurelius.faunus.hdfs.*");

File: src/test/java/com/thinkaurelius/faunus/FaunusPipelineTest.java
Patch:
@@ -47,13 +47,13 @@ public void testElementTypeUpdating() throws IOException {
     public void testPipelineLocking() throws IOException {
         FaunusPipeline pipeline = new FaunusPipeline(new FaunusGraph());
         pipeline.V().out().property("name");
-        /* // TODO: proper locking required
+
         try {
             pipeline.V();
             assertTrue(false);
         } catch (IllegalStateException e) {
             assertTrue(true);
-        }*/
+        }
 
         try {
             pipeline.order(Tokens.Order.INCREASING, "name").V();

File: src/main/java/com/thinkaurelius/faunus/mapreduce/FaunusCompiler.java
Patch:
@@ -7,6 +7,7 @@
 import com.thinkaurelius.faunus.formats.rexster.RexsterInputFormat;
 import com.thinkaurelius.faunus.formats.titan.TitanCassandraInputFormat;
 import com.thinkaurelius.faunus.hdfs.GraphFilter;
+import com.thinkaurelius.faunus.hdfs.NoSideEffectFilter;
 import com.thinkaurelius.faunus.mapreduce.filter.BackFilterMapReduce;
 import com.thinkaurelius.faunus.mapreduce.filter.CyclicPathFilterMap;
 import com.thinkaurelius.faunus.mapreduce.filter.DuplicateFilterMap;
@@ -532,7 +533,7 @@ else if (new File("../lib/" + Tokens.FAUNUS_JOB_JAR).exists())
 
         if (FileInputFormat.class.isAssignableFrom(this.graph.getGraphInputFormat())) {
             FileInputFormat.setInputPaths(this.jobs.get(0), this.graph.getInputLocation());
-            FileInputFormat.setInputPathFilter(this.jobs.get(0), GraphFilter.class);
+            FileInputFormat.setInputPathFilter(this.jobs.get(0), NoSideEffectFilter.class);
         } else if (this.graph.getGraphInputFormat().equals(RexsterInputFormat.class)) {
             /* do nothing */
         } else if (this.graph.getGraphInputFormat().equals(TitanCassandraInputFormat.class)) {

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/Imports.java
Patch:
@@ -17,6 +17,7 @@ public class Imports {
         imports.add("org.apache.hadoop.conf.*");
         imports.add("org.apache.hadoop.fs.*");
         imports.add("org.apache.hadoop.util.*");
+        imports.add("org.apache.hadoop.io.*");
         imports.add("org.apache.hadoop.io.compress.*");
         imports.add("org.apache.hadoop.mapreduce.lib.input.*");
         imports.add("org.apache.hadoop.mapreduce.lib.output.*");

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -154,7 +154,7 @@ public class GraphDatabaseConfiguration {
      * Number of times the system attempts to acquire a unique id block before giving up and throwing an exception.
      */
     public static final String IDAUTHORITY_RETRY_COUNT_KEY = "idauthority-retries";
-    public static final int IDAUTHORITY_RETRY_COUNT_DEFAULT = 3;
+    public static final int IDAUTHORITY_RETRY_COUNT_DEFAULT = 20;
     /**
      * Size of the block to be acquired. Larger block sizes require fewer block applications but also leave a larger
      * fraction of the id pool occupied and potentially lost. For write heavy applications, larger block sizes should

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/VerticesEdgesMapReduce.java
Patch:
@@ -107,6 +107,7 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
             context.write(this.longWritable, this.holder.set('v', value));
         }
 
+        // TODO: this is horribly inefficient
         private List<List<MicroElement>> clonePaths(final FaunusVertex vertex, final MicroEdge edge) {
             final List<List<MicroElement>> paths = new ArrayList<List<MicroElement>>();
             for (List<MicroElement> path : vertex.getPaths()) {

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/VerticesVerticesMapReduce.java
Patch:
@@ -27,7 +27,7 @@ public class VerticesVerticesMapReduce {
     public static final String LABELS = Tokens.makeNamespace(VerticesVerticesMapReduce.class) + ".labels";
 
     public enum Counters {
-        EDGES_TRAVERSED;
+        EDGES_TRAVERSED
     }
 
     public static class Map extends Mapper<NullWritable, FaunusVertex, LongWritable, Holder> {

File: src/test/java/com/thinkaurelius/faunus/mapreduce/sideeffect/SideEffectMapTest.java
Patch:
@@ -45,7 +45,7 @@ public void testVertexSideEffect() throws IOException {
         assertNull(graph.get(6l).getProperty("count"));
 
 
-        assertEquals(mapReduceDriver.getCounters().findCounter(SideEffectMap.Counters.VERTICES_PROCESSED).getValue(), 6);
+        assertEquals(mapReduceDriver.getCounters().findCounter(SideEffectMap.Counters.VERTICES_PROCESSED).getValue(), 3);
         assertEquals(mapReduceDriver.getCounters().findCounter(SideEffectMap.Counters.OUT_EDGES_PROCESSED).getValue(), 0);
     }
 

File: src/main/java/com/thinkaurelius/faunus/FaunusEdge.java
Patch:
@@ -52,12 +52,10 @@ public FaunusEdge(final long id, final long outVertex, final long inVertex, fina
     }
 
     public FaunusEdge reuse(final long id, final long outVertex, final long inVertex, final String label) {
-        this.id = id;
+        super.reuse(id);
         this.outVertex = outVertex;
         this.inVertex = inVertex;
         this.setLabel(label);
-        this.properties = null;
-        this.clearPaths();
         return this;
     }
 

File: src/main/java/com/thinkaurelius/faunus/formats/graphson/GraphSONRecordReader.java
Patch:
@@ -84,7 +84,8 @@ public boolean nextKeyValue() throws IOException {
             this.pos += newSize;
             if (newSize < this.maxLineLength) {
                 this.value = GraphSONUtility.fromJSON(text.toString());
-                this.value.enablePath(this.pathEnabled);
+                if(this.pathEnabled)
+                    this.value.enablePath(true);
                 break;
             }
 

File: src/main/java/com/thinkaurelius/faunus/formats/titan/TitanCassandraRecordReader.java
Patch:
@@ -186,8 +186,8 @@ public boolean nextKeyValue() throws IOException {
         currentRow = null;
         while (currentRow == null && iter.hasNext()) {
             currentRow = graph.readFaunusVertex(iter.next());
-            if (null != currentRow)
-                currentRow.enablePath(this.pathEnabled);
+            if (null != currentRow && this.pathEnabled)
+                currentRow.enablePath(true);
         }
         return currentRow != null;
     }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/filter/PropertyFilterMap.java
Patch:
@@ -74,15 +74,15 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
                     context.getCounter(Counters.VERTICES_FILTERED).increment(1l);
                 }
             } else {
-                long counter = 0;
+                long edgesFiltered = 0;
                 for (Edge e : value.getEdges(Direction.BOTH)) {
                     final FaunusEdge edge = (FaunusEdge) e;
                     if (edge.hasPaths() && !this.elementChecker.isLegal(edge)) {
                         edge.clearPaths();
-                        counter++;
+                        edgesFiltered++;
                     }
                 }
-                context.getCounter(Counters.EDGES_FILTERED).increment(counter);
+                context.getCounter(Counters.EDGES_FILTERED).increment(edgesFiltered);
             }
 
             context.write(NullWritable.get(), value);

File: src/main/java/com/thinkaurelius/faunus/mapreduce/sideeffect/ValueGroupCountMapReduce.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.faunus.FaunusEdge;
 import com.thinkaurelius.faunus.FaunusVertex;
 import com.thinkaurelius.faunus.Tokens;
-import com.thinkaurelius.faunus.WritableHandler;
+import com.thinkaurelius.faunus.mapreduce.util.WritableHandler;
 import com.thinkaurelius.faunus.mapreduce.util.CounterMap;
 import com.thinkaurelius.faunus.mapreduce.util.ElementPicker;
 import com.tinkerpop.blueprints.Direction;

File: src/main/java/com/thinkaurelius/faunus/mapreduce/transform/OrderMapReduce.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.faunus.FaunusEdge;
 import com.thinkaurelius.faunus.FaunusVertex;
 import com.thinkaurelius.faunus.Tokens;
-import com.thinkaurelius.faunus.WritableHandler;
+import com.thinkaurelius.faunus.mapreduce.util.WritableHandler;
 import com.thinkaurelius.faunus.mapreduce.util.ElementPicker;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;

File: src/main/java/com/thinkaurelius/faunus/mapreduce/util/WritableHandler.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.faunus;
+package com.thinkaurelius.faunus.mapreduce.util;
 
 import org.apache.hadoop.io.DoubleWritable;
 import org.apache.hadoop.io.FloatWritable;

File: src/main/java/com/thinkaurelius/faunus/tinkerpop/gremlin/Console.java
Patch:
@@ -32,8 +32,6 @@ public Console(final IO io, final String inputPrompt, final String resultPrompt)
         for (String imps : Imports.getImports()) {
             groovy.execute("import " + imps);
         }
-        groovy.execute("import com.tinkerpop.gremlin.Tokens.T");
-        groovy.execute("import com.tinkerpop.gremlin.groovy.*");
 
         groovy.execute("hdfs = FileSystem.get(new Configuration())");
         groovy.execute("local = FileSystem.getLocal(new Configuration())");

File: src/test/java/com/thinkaurelius/faunus/WritableHandlerTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.faunus;
 
+import com.thinkaurelius.faunus.mapreduce.util.WritableHandler;
 import junit.framework.TestCase;
 import org.apache.hadoop.io.BooleanWritable;
 import org.apache.hadoop.io.DoubleWritable;

File: src/main/java/com/thinkaurelius/faunus/mapreduce/filter/BackFilterMapReduce.java
Patch:
@@ -70,6 +70,7 @@ public static class Reduce extends Reducer<LongWritable, Holder, NullWritable, F
         @Override
         public void reduce(final LongWritable key, final Iterable<Holder> values, final Reducer<LongWritable, Holder, NullWritable, FaunusVertex>.Context context) throws IOException, InterruptedException {
             final FaunusVertex vertex = new FaunusVertex(key.get());
+            vertex.enablePath(true);
             for (final Holder holder : values) {
                 if (holder.getTag() == 'v') {
                     vertex.addAll((FaunusVertex) holder.get());

File: src/test/java/com/thinkaurelius/faunus/mapreduce/transform/VerticesVerticesMapReduceTest.java
Patch:
@@ -3,6 +3,7 @@
 import com.thinkaurelius.faunus.BaseTest;
 import com.thinkaurelius.faunus.FaunusVertex;
 import com.thinkaurelius.faunus.Holder;
+import com.thinkaurelius.faunus.mapreduce.FaunusCompiler;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Vertex;
 import org.apache.hadoop.conf.Configuration;
@@ -47,10 +48,11 @@ public void testKnowsCreatedTraversal2() throws IOException {
         Configuration config = new Configuration();
         config.set(VerticesVerticesMapReduce.DIRECTION, Direction.OUT.name());
         config.setStrings(VerticesVerticesMapReduce.LABELS, "created");
+        config.setBoolean(FaunusCompiler.PATH_ENABLED, false);
 
         mapReduceDriver.withConfiguration(config);
 
-        Map<Long, FaunusVertex> results = runWithGraph(startPath(generateGraph(ExampleGraph.TINKERGRAPH), Vertex.class, true), mapReduceDriver);
+        Map<Long, FaunusVertex> results = runWithGraph(startPath(generateGraph(ExampleGraph.TINKERGRAPH), Vertex.class), mapReduceDriver);
         assertEquals(results.size(), 6);
         assertEquals(results.get(1l).pathCount(), 0);
         assertEquals(results.get(2l).pathCount(), 0);

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -56,9 +56,10 @@ public class GraphDatabaseConfiguration {
     private static final Map<String,Class<? extends StorageManager>> preregisteredStorageManagers = new HashMap<String,Class<? extends StorageManager>>() {{
         put("local", BerkeleyJEStorageAdapter.class);
         put("berkeleyje", BerkeleyJEStorageAdapter.class);
-        put("cassandra", CassandraThriftStorageManager.class);
-        put("hbase", HBaseStorageManager.class);
+        put("cassandra", AstyanaxStorageManager.class);
+        put("cassandrathrift", CassandraThriftStorageManager.class);
         put("astyanax", AstyanaxStorageManager.class);
+        put("hbase", HBaseStorageManager.class);
         put("embeddedcassandra", CassandraEmbeddedStorageManager.class);
     }};
 

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/ExternalCassandraGraphConcurrentTest.java
Patch:
@@ -12,7 +12,7 @@ public class ExternalCassandraGraphConcurrentTest extends TitanGraphConcurrentTe
     public static CassandraProcessStarter ch = new CassandraProcessStarter();
 
     public ExternalCassandraGraphConcurrentTest() {
-        super(StorageSetup.getCassandraGraphConfiguration());
+        super(StorageSetup.getCassandraThriftGraphConfiguration());
     }
 
     @BeforeClass

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/ExternalCassandraGraphPerformanceTest.java
Patch:
@@ -13,7 +13,7 @@ public class ExternalCassandraGraphPerformanceTest extends TitanGraphPerformance
     public static CassandraProcessStarter ch = new CassandraProcessStarter();
 
     public ExternalCassandraGraphPerformanceTest() {
-        super(StorageSetup.getCassandraGraphConfiguration(),0,1,false);
+        super(StorageSetup.getCassandraThriftGraphConfiguration(),0,1,false);
     }
 
     @BeforeClass

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/ExternalCassandraGraphTest.java
Patch:
@@ -12,7 +12,7 @@ public class ExternalCassandraGraphTest extends TitanGraphTest {
 	public static CassandraProcessStarter ch = new CassandraProcessStarter();
 	
 	public ExternalCassandraGraphTest() {
-		super(StorageSetup.getCassandraGraphConfiguration());
+		super(StorageSetup.getCassandraThriftGraphConfiguration());
 	}
 
 	@BeforeClass

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraGraphTest.java
Patch:
@@ -9,7 +9,7 @@
 public class InternalCassandraGraphTest extends TitanGraphTest {
 
 	public InternalCassandraGraphTest() {
-		super(StorageSetup.getCassandraGraphConfiguration());
+		super(StorageSetup.getCassandraThriftGraphConfiguration());
 	}
 
 	@BeforeClass

File: src/main/java/com/thinkaurelius/titan/diskstorage/locking/LockingTransactionHandle.java
Patch:
@@ -161,7 +161,6 @@ public void writeBlindLockClaim(
 				if (backer.getLockWaitMS() < after - before) {
 					// Too slow
 					// Delete lock claim and loop again
-					tsNS = TimestampProvider.getApproxNSSinceEpoch(false);
 					backer.getLockStore().mutate(lockKey, null, Arrays.asList(lc.getLockCol(tsNS, backer.getRid())), null);
 				} else {
 					ok = true;

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/ExternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -1,14 +1,13 @@
 package com.thinkaurelius.titan.diskstorage.astyanax;
 
-import com.thinkaurelius.titan.StorageSetup;
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import org.apache.commons.configuration.Configuration;
 
+import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
+import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraThriftStorageManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.testutil.CassandraUtil;
 
 public class ExternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 	
@@ -17,6 +16,7 @@ public StorageManager openStorageManager(short idx) throws StorageException {
     	Configuration sc = StorageSetup.getCassandraStorageConfiguration();
     	sc.addProperty(CassandraThriftStorageManager.LOCAL_LOCK_MEDIATOR_PREFIX_KEY, "astyanax-" + idx);
     	sc.addProperty(GraphDatabaseConfiguration.INSTANCE_RID_SHORT_KEY, idx);
+    	sc.addProperty(GraphDatabaseConfiguration.LOCK_EXPIRE_MS, EXPIRE_MS);
     	
         return new AstyanaxStorageManager(sc);
     }

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/InternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -1,17 +1,15 @@
 package com.thinkaurelius.titan.diskstorage.astyanax;
 
-import com.thinkaurelius.titan.diskstorage.StorageException;
 import org.apache.commons.configuration.Configuration;
 import org.junit.BeforeClass;
 
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
+import com.thinkaurelius.titan.diskstorage.StorageException;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraDaemonWrapper;
-import com.thinkaurelius.titan.diskstorage.cassandra.CassandraProcessStarter;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraThriftStorageManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.testutil.CassandraUtil;
 
 public class InternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 	
@@ -25,6 +23,7 @@ public StorageManager openStorageManager(short idx) throws StorageException {
     	Configuration sc = StorageSetup.getCassandraStorageConfiguration();
     	sc.addProperty(CassandraThriftStorageManager.LOCAL_LOCK_MEDIATOR_PREFIX_KEY, "astyanax-" + idx);
     	sc.addProperty(GraphDatabaseConfiguration.INSTANCE_RID_SHORT_KEY, idx);
+    	sc.addProperty(GraphDatabaseConfiguration.LOCK_EXPIRE_MS, EXPIRE_MS);
     	
         return new AstyanaxStorageManager(sc);
     }

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/ExternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -19,6 +19,7 @@ public StorageManager openStorageManager(short idx) throws StorageException {
     	Configuration sc = StorageSetup.getCassandraStorageConfiguration();
     	sc.addProperty(CassandraThriftStorageManager.LOCAL_LOCK_MEDIATOR_PREFIX_KEY, "cassandra-" + idx);
     	sc.addProperty(GraphDatabaseConfiguration.INSTANCE_RID_SHORT_KEY, idx);
+    	sc.addProperty(GraphDatabaseConfiguration.LOCK_EXPIRE_MS, EXPIRE_MS);
     	
         return new CassandraThriftStorageManager(sc);
     }

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/InternalCassandraEmbeddedLockKeyColumnValueStoreTest.java
Patch:
@@ -15,6 +15,7 @@ public StorageManager openStorageManager(short idx) throws StorageException {
     	Configuration sc = StorageSetup.getEmbeddedCassandraStorageConfiguration();
     	sc.addProperty(CassandraThriftStorageManager.LOCAL_LOCK_MEDIATOR_PREFIX_KEY, "cassandra-" + idx);
     	sc.addProperty(GraphDatabaseConfiguration.INSTANCE_RID_SHORT_KEY, idx);
+    	sc.addProperty(GraphDatabaseConfiguration.LOCK_EXPIRE_MS, EXPIRE_MS);
     	
         return new CassandraEmbeddedStorageManager(sc);
     }

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/InternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -21,6 +21,7 @@ public StorageManager openStorageManager(short idx) throws StorageException {
     	Configuration sc = StorageSetup.getCassandraStorageConfiguration();
     	sc.addProperty(StorageManager.LOCAL_LOCK_MEDIATOR_PREFIX_KEY, "cassandra-" + idx);
     	sc.addProperty(GraphDatabaseConfiguration.INSTANCE_RID_SHORT_KEY, idx);
+    	sc.addProperty(GraphDatabaseConfiguration.LOCK_EXPIRE_MS, EXPIRE_MS);
     	
         return new CassandraThriftStorageManager(sc);
     }

File: src/test/java/com/thinkaurelius/titan/diskstorage/hbase/ExternalHBaseLockKeyColumnValueStoreTest.java
Patch:
@@ -15,6 +15,7 @@ public StorageManager openStorageManager(short idx) throws StorageException {
     	Configuration sc = StorageSetup.getHBaseStorageConfiguration();
     	sc.addProperty(HBaseStorageManager.LOCAL_LOCK_MEDIATOR_PREFIX_KEY, "hbase-" + idx);
     	sc.addProperty(GraphDatabaseConfiguration.INSTANCE_RID_SHORT_KEY, idx);
+    	sc.addProperty(GraphDatabaseConfiguration.LOCK_EXPIRE_MS, EXPIRE_MS);
         return new HBaseStorageManager(sc);
     }
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StandardIDPool.java
Patch:
@@ -55,11 +55,12 @@ private synchronized void nextBlock() throws InterruptedException {
         assert nextID == maxID;
         
         long time = System.currentTimeMillis();
-        while (bufferMaxID<0 || bufferMaxID<0) {
+        if (idBlockRenewer!=null && idBlockRenewer.isAlive()) {
             //Updating thread has not yet completed, so wait for it
             log.debug("Waiting for id renewal thread");
             idBlockRenewer.join(MAX_WAIT_TIME);
         }
+        Preconditions.checkArgument(bufferMaxID>0 && bufferNextID>0);
         
         nextID = bufferNextID;
         maxID = bufferMaxID;

File: src/test/java/com/thinkaurelius/titan/graphdb/idmanagement/IDPoolTest.java
Patch:
@@ -24,7 +24,7 @@ public class IDPoolTest {
 
     @Test
     public void testStandardIDPool() {
-        int noIds = 1000000;
+        int noIds = 2000000;
         MockIDAuthority idauth = new MockIDAuthority(200,0);
         StandardIDPool pool = new StandardIDPool(idauth,0);
         IntSet ids = new IntHashSet(noIds);

File: src/main/java/com/thinkaurelius/faunus/util/VertexToFaunusBinary.java
Patch:
@@ -73,6 +73,9 @@ private static void writeProperties(final Element element, final DataOutput out)
             } else if (valueClass.equals(String.class)) {
                 out.writeByte(FaunusElement.ElementProperties.PropertyType.STRING.val);
                 out.writeUTF((String) valueObject);
+            } else if (valueClass.equals(Boolean.class)) {
+                out.writeByte(FaunusElement.ElementProperties.PropertyType.BOOLEAN.val);
+                out.writeBoolean((Boolean) valueObject);
             } else {
                 throw new IOException("Property value type of " + valueClass + " is not supported");
             }

File: src/test/java/com/thinkaurelius/faunus/util/VertexToFaunusBinaryTest.java
Patch:
@@ -31,6 +31,7 @@ public void testConversion() throws IOException {
         Vertex stephen = graph.addVertex(3);
         stephen.setProperty("name", "stephen");
         stephen.setProperty("weight", 160.42);
+        stephen.setProperty("male",true);
         Edge e = graph.addEdge(null, marko, stephen, "knows");
         e.setProperty("weight", 0.2);
         e.setProperty("type", "coworker");
@@ -61,7 +62,8 @@ public void testConversion() throws IOException {
         FaunusVertex stephenFaunus = new FaunusVertex(in);
         assertEquals(stephenFaunus.getProperty("name"), "stephen");
         assertEquals(stephenFaunus.getProperty("weight"), 160.42);
-        assertEquals(stephenFaunus.getPropertyKeys().size(), 2);
+        assertTrue((Boolean)stephenFaunus.getProperty("male"));
+        assertEquals(stephenFaunus.getPropertyKeys().size(), 3);
         assertEquals(asList(stephenFaunus.getEdges(Direction.IN)).size(), 1);
         assertFalse(stephenFaunus.getEdges(Direction.OUT).iterator().hasNext());
         assertTrue(stephenFaunus.getEdges(Direction.IN, "knows").iterator().hasNext());

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractTitanTx.java
Patch:
@@ -152,7 +152,6 @@ public InternalTitanVertex getExistingVertex(long id) {
     private InternalTitanVertex getExisting(long id) {
         synchronized (vertexCache) {
             InternalTitanVertex node = vertexCache.get(id);
-            if (node.isRemoved()) throw new IllegalArgumentException("Vertex has been removed for id: " + id);
             if (node==null) {
                 IDInspector idspec = graphdb.getIDInspector();
 
@@ -165,7 +164,7 @@ private InternalTitanVertex getExisting(long id) {
                 } else
                     throw new IllegalArgumentException("ID could not be recognized");
                 vertexCache.add(node, id);
-            }
+            } else if (node.isRemoved()) throw new IllegalArgumentException("Vertex has been removed for id: " + id);
             return node;
         }
     }

File: src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/StandardIDPool.java
Patch:
@@ -101,7 +101,7 @@ public synchronized long nextID() {
         }
         long id = nextID;
         nextID++;
-        log.debug("[{}] Returned id: {}",partitionID,id);
+        log.trace("[{}] Returned id: {}",partitionID,id);
         return id;
     }
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyJEKeyValueStore.java
Patch:
@@ -11,15 +11,15 @@
 import java.util.ArrayList;
 import java.util.List;
 
-public class BerkeleyKeyValueStore implements OrderedKeyValueStore {
+public class BerkeleyJEKeyValueStore implements OrderedKeyValueStore {
 	
-	private Logger log = LoggerFactory.getLogger(BerkeleyKeyValueStore.class);
+	private Logger log = LoggerFactory.getLogger(BerkeleyJEKeyValueStore.class);
 	
 	private final Database db;
 	private final String name;
 	private final BerkeleyJEStorageManager manager;
 	
-	public BerkeleyKeyValueStore(String n, Database data, BerkeleyJEStorageManager m) {
+	public BerkeleyJEKeyValueStore(String n, Database data, BerkeleyJEStorageManager m) {
 		db = data;
 		name = n;
 		manager = m;

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyKeyValueStore.java
Patch:
@@ -152,6 +152,7 @@ public List<KeyValueEntry> getSlice(ByteBuffer keyStart, ByteBuffer keyEnd,
 		        status = cursor.getNext(foundKey, foundData, LockMode.DEFAULT);
 			}
 			log.trace("Retrieved: {}",result.size());
+            return result;
 		} catch (DatabaseException e) {
 			throw new GraphStorageException(e);
 		} finally {
@@ -161,7 +162,6 @@ public List<KeyValueEntry> getSlice(ByteBuffer keyStart, ByteBuffer keyEnd,
 				throw new GraphStorageException(e);
 			}
 		}
-		return result;
 	}
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/graphdb/adjacencylist/ArrayAdjacencyList.java
Patch:
@@ -193,7 +193,7 @@ private class InternalIterator implements Iterator<InternalRelation> {
 		
 
 		
-		protected void findNext() {
+		protected final void findNext() {
 			last = next;
 			next = null;
 			for (position = position+1; position<contents.length;position++) {

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -442,7 +442,7 @@ static PropertiesConfiguration getPropertiesConfig(String file) {
 			try {
 				config.load(file);
 			} catch (ConfigurationException e) {
-				throw new IllegalArgumentException("Cannot load existing configuration file: " + e.getMessage());
+				throw new IllegalArgumentException("Cannot load existing configuration file",e);
 			}
 		}
 		config.setFileName(file);

File: src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -491,8 +491,7 @@ private List<Entry> appendResults(ByteBuffer key, ByteBuffer columnStart, ByteBu
         results = edgeStore.getSlice(key, columnStart, columnEnd, limit.getLimit(), txh);
         limit.retrieved(results.size());
 
-		if (results==null) return null;
-		else if (entries==null) return results;
+		if (entries==null) return results;
 		else {
 			entries.addAll(results);
 			return entries;
@@ -576,7 +575,7 @@ public boolean save(Collection<InternalRelation> addedRelations,
                 stats.removedEdge(del);
             }
         }
-        deletedRelations =null;
+        deletedRelations=null;
 
 
 		ListMultimap<InternalTitanType,InternalRelation> simpleEdgeTypes = null;

File: src/main/java/com/thinkaurelius/titan/graphdb/entitystatus/VirtualElement.java
Patch:
@@ -113,8 +113,8 @@ public final void resetNew() {
 		switch(lifecycle) {
 		case Deleted: 
 			throw new IllegalStateException();
-		case New: lifecycle = New;
-		case Modified: lifecycle = New;
+		case New:
+		case Modified:
 		case Loaded: lifecycle = New; break;
 		default: throw new IllegalStateException("Current lifecycle code: " + lifecycle);
 		}

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/LabeledTitanEdge.java
Patch:
@@ -45,7 +45,7 @@ public boolean addRelation(InternalRelation e, boolean isNew) {
 		Preconditions.checkArgument(e.getVertex(0).equals(this),"This node only supports out edges!");
 
 		ModificationStatus status = new ModificationStatus();
-		synchronized(outEdges) {
+		synchronized(this) {
 			outEdges = outEdges.addEdge(e, e.getType().isFunctional(),status);
 		}
 		return status.hasChanged();

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractTitanTx.java
Patch:
@@ -183,7 +183,7 @@ public void deleteVertex(InternalTitanVertex n) {
     public TitanProperty addProperty(TitanVertex vertex, TitanKey key, Object attribute) {
         verifyWriteAccess(vertex);
         // Check that attribute of keyed propertyType is unique and lock if so
-        boolean isUniqueKey = key.isUnique();
+        final boolean isUniqueKey = key.isUnique();
         if (isUniqueKey) keyedPropertyCreateLock.lock();
         InternalRelation e = null;
         try {

File: src/main/java/com/thinkaurelius/titan/graphdb/types/TypeComparator.java
Patch:
@@ -31,8 +31,8 @@ public int compare(TitanType et1, TitanType et2) {
 	
 	private static final ConcurrentMap<Short,TitanType> groupTypes = new ConcurrentHashMap<Short,TitanType>();
 
-	private static Method getID=null;
-	private static Method getName=null;
+	private volatile static Method getID=null;
+	private volatile static Method getName=null;
 	
 	public static final TitanType getGroupComparisonType(final short id) {
 		if (getID==null || getName==null) {

File: src/main/java/com/thinkaurelius/titan/graphdb/types/system/SystemTypeManager.java
Patch:
@@ -15,7 +15,7 @@ public abstract class SystemTypeManager {
 	public static final TypeGroup SYSTEM_TYPE_GROUP = new StandardTypeGroup((short)0,systemETprefix);
 	
 	
-	private static Map<Long,SystemType> systemEdgeTypes = null;
+	private volatile static Map<Long,SystemType> systemEdgeTypes = null;
 	
 	public static SystemType getSystemEdgeType(long id) {
 		if (systemEdgeTypes==null) {

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/StandardTitanVertex.java
Patch:
@@ -34,13 +34,13 @@ public boolean addRelation(InternalRelation e, boolean isNew) {
         ModificationStatus status = new ModificationStatus();
         if (EdgeDirection.IN.impliedBy(e.getDirection(this))) {
             loadIn = true;
-            synchronized(inEdges) {
+            synchronized(this) {
                 inEdges = inEdges.addEdge(e,status);
             }
             success = status.hasChanged();
         }
         if (EdgeDirection.OUT.impliedBy(e.getDirection(this))) {
-            synchronized(outEdges) {
+            synchronized(this) {
                 outEdges = outEdges.addEdge(e, e.getType().isFunctional(), status);
             }
             if (status.hasChanged()) {

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyJEStorageManager.java
Patch:
@@ -22,7 +22,7 @@
 
 public class BerkeleyJEStorageManager implements KeyValueStorageManager {
 
-    private Logger log = LoggerFactory.getLogger(BerkeleyJEStorageManager.class);
+    private final Logger log = LoggerFactory.getLogger(BerkeleyJEStorageManager.class);
 
 
     public static final String CACHE_KEY = "cache_percentage";

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyKeyValueStore.java
Patch:
@@ -156,7 +156,7 @@ public List<KeyValueEntry> getSlice(ByteBuffer keyStart, ByteBuffer keyEnd,
 			throw new GraphStorageException(e);
 		} finally {
 			try {
-			cursor.close();
+			if (cursor!=null) cursor.close();
 			} catch (DatabaseException e) {
 				throw new GraphStorageException(e);
 			}

File: src/test/java/com/thinkaurelius/faunus/formats/rexster/RexsterIteratorTest.java
Patch:
@@ -49,10 +49,10 @@ public void shouldBufferToEndFromStart() {
     }
 
     @Test
-    public void shouldBufferBiggerThanResult() {
+    public void shouldBufferBiggerSplit() {
 
-        final RexsterVertexLoader loader = new MockRexsterVertexLoader(generateJsonArray(20));
-        final RexsterIterator iterator = new RexsterIterator(loader, 0, 10, 512);
+        final RexsterVertexLoader loader = new MockRexsterVertexLoader(generateJsonArray(40));
+        final RexsterIterator iterator = new RexsterIterator(loader, 0, 20, 1000);
 
         assertValidIteration(iterator, 0);
     }

File: src/main/java/com/thinkaurelius/faunus/formats/titan/FaunusTitanGraph.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.Entry;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
+import com.thinkaurelius.titan.graphdb.database.idhandling.IDHandler;
 import com.thinkaurelius.titan.graphdb.transaction.InternalTitanTransaction;
 import com.thinkaurelius.titan.graphdb.transaction.TransactionConfig;
 import org.apache.cassandra.db.IColumn;
@@ -37,7 +38,7 @@ public FaunusTitanGraph(Configuration configuration) {
     }
 
     public FaunusVertex readFaunusVertex(final Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> row) {
-        FaunusVertexRelationLoader loader = new FaunusVertexRelationLoader(row.left.duplicate());
+        FaunusVertexRelationLoader loader = new FaunusVertexRelationLoader(IDHandler.getKeyID(row.left.duplicate()));
         loadRelations(new CassandraMapIterable(row.right),loader,tx);
         return loader.getVertex();
     }

File: src/main/java/com/thinkaurelius/titan/graphdb/database/InternalTitanGraph.java
Patch:
@@ -32,7 +32,7 @@ public interface InternalTitanGraph extends TitanGraph {
 	
 	public long[] indexRetrieval(Object value, TitanKey key, InternalTitanTransaction tx);
 
-	public InternalTitanTransaction startThreadTransaction(TransactionConfig configuration);
+	public InternalTitanTransaction startTransaction(TransactionConfig configuration);
 	
 	// ######## TitanVertex Operations  ############
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/InMemoryTitanGraph.java
Patch:
@@ -106,7 +106,7 @@ public void shutdown() throws GraphStorageException {
 	
 	
 	@Override
-	public InternalTitanTransaction startThreadTransaction(TransactionConfig config) {
+	public InternalTitanTransaction startTransaction(TransactionConfig config) {
 		Preconditions.checkArgument(!getTxConfiguration().equals(config),"Cannot open in-memory transactions with non-default configuration.");
 		return this;
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/database/InternalTitanGraph.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.core.TitanGraph;
 import com.thinkaurelius.titan.core.TitanKey;
 import com.thinkaurelius.titan.graphdb.transaction.TransactionConfig;
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 import com.thinkaurelius.titan.graphdb.relations.InternalRelation;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDInspector;
 import com.thinkaurelius.titan.graphdb.transaction.InternalTitanTransaction;
@@ -26,9 +26,9 @@ public interface InternalTitanGraph extends TitanGraph {
 
     public boolean isReferenceVertexID(long vertexid);
 
-	void loadRelations(InternalTitanQuery query, InternalTitanTransaction tx);
+	void loadRelations(AtomicQuery query, InternalTitanTransaction tx);
 	
-	public AbstractLongList getRawNeighborhood(InternalTitanQuery query, InternalTitanTransaction tx);
+	public AbstractLongList getRawNeighborhood(AtomicQuery query, InternalTitanTransaction tx);
 	
 	public long[] indexRetrieval(Object value, TitanKey key, InternalTitanTransaction tx);
 

File: src/main/java/com/thinkaurelius/titan/graphdb/database/util/LimitTracker.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.database.util;
 
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 
 public class LimitTracker {
 
 	private static final int retrievalLimit = 2000000000; //2 billion
 	
 	private int remainingLimit;
 
-	public LimitTracker(InternalTitanQuery query) {
+	public LimitTracker(AtomicQuery query) {
 		remainingLimit = (int)Math.min(retrievalLimit, query.getLimit());
 	}
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/BasicLoadingStatus.java
Patch:
@@ -3,8 +3,8 @@
 import cern.colt.map.AbstractIntIntMap;
 import cern.colt.map.OpenIntIntHashMap;
 import com.thinkaurelius.titan.core.TitanType;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 import com.thinkaurelius.titan.graphdb.query.QueryUtil;
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -29,7 +29,7 @@ public class BasicLoadingStatus implements LoadingStatus {
 	 */
 
 	@Override
-	public boolean hasLoadedEdges(InternalTitanQuery query) {
+	public boolean hasLoadedEdges(AtomicQuery query) {
 		if (DirectionTypeEncoder.hasAllCovered(allLoadedDirsIndex, query)) return true;
 		
 		if (groups!=null && (query.hasGroupCondition() || query.hasEdgeTypeCondition())) {
@@ -52,7 +52,7 @@ public boolean hasLoadedEdges(InternalTitanQuery query) {
 
 	
 	@Override
-	public LoadingStatus loadedEdges(InternalTitanQuery query) {
+	public LoadingStatus loadedEdges(AtomicQuery query) {
 		if (query.hasEdgeTypeCondition()) {
             if (!QueryUtil.hasFirstKeyConstraint(query)) {
                 TitanType type = query.getTypeCondition();

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/DefaultLoadingStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.loadingstatus;
 
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 
 public class DefaultLoadingStatus implements LoadingStatus {
 	
@@ -11,12 +11,12 @@ public class DefaultLoadingStatus implements LoadingStatus {
 	}
 
 	@Override
-	public boolean hasLoadedEdges(InternalTitanQuery query) {
+	public boolean hasLoadedEdges(AtomicQuery query) {
 		return defaultStatus;
 	}
 
 	@Override
-	public LoadingStatus loadedEdges(InternalTitanQuery query) {
+	public LoadingStatus loadedEdges(AtomicQuery query) {
 		if (!defaultStatus) {
 			BasicLoadingStatus update = new BasicLoadingStatus();
 			update.loadedEdges(query);

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/DirectionTypeEncoder.java
Patch:
@@ -1,13 +1,13 @@
 package com.thinkaurelius.titan.graphdb.loadingstatus;
 
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 import com.thinkaurelius.titan.graphdb.relations.EdgeDirection;
 import com.thinkaurelius.titan.util.datastructures.BitMap;
 
 public class DirectionTypeEncoder {
 
 	
-	public static final boolean hasAllCovered(byte code, InternalTitanQuery query) {
+	public static final boolean hasAllCovered(byte code, AtomicQuery query) {
 		for (EdgeDirection dir : EdgeDirection.values()) {
 			if (!query.hasDirectionCondition() || query.isAllowedDirection(dir)) {
 				if (dir==EdgeDirection.OUT && query.queryProperties()) {
@@ -21,7 +21,7 @@ public static final boolean hasAllCovered(byte code, InternalTitanQuery query) {
 		return true;
 	}
 	
-	public static final byte loaded(byte code, InternalTitanQuery query) {
+	public static final byte loaded(byte code, AtomicQuery query) {
 		for (EdgeDirection dir : EdgeDirection.values()) {
 			if (!query.hasDirectionCondition() || query.isAllowedDirection(dir)) {
 				if (dir==EdgeDirection.OUT && query.queryProperties()) {

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/LoadingStatus.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.loadingstatus;
 
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 
 public interface LoadingStatus {
 
 	public static final LoadingStatus AllLoaded = new DefaultLoadingStatus(true);
 	public static final LoadingStatus NothingLoaded = new DefaultLoadingStatus(false);
 	
-	LoadingStatus loadedEdges(InternalTitanQuery query);
+	LoadingStatus loadedEdges(AtomicQuery query);
 	
-	boolean hasLoadedEdges(InternalTitanQuery query);
+	boolean hasLoadedEdges(AtomicQuery query);
 	
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/factory/RelationFactoryUtil.java
Patch:
@@ -2,7 +2,7 @@
 
 import com.thinkaurelius.titan.core.InvalidElementException;
 import com.thinkaurelius.titan.core.TitanType;
-import com.thinkaurelius.titan.graphdb.query.AtomicTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.SimpleTitanQuery;
 import com.thinkaurelius.titan.graphdb.relations.InternalRelation;
 import com.thinkaurelius.titan.graphdb.transaction.InternalTitanTransaction;
 import com.thinkaurelius.titan.graphdb.vertices.InternalTitanVertex;
@@ -49,7 +49,7 @@ public static final void connectRelation(InternalRelation relation, boolean isNe
 
 	
 	public static final boolean hasRelationOfType(InternalTitanVertex vertex, TitanType type, Direction dir) {
-		AtomicTitanQuery q = new AtomicTitanQuery(vertex);
+        SimpleTitanQuery q = new SimpleTitanQuery(vertex);
 		q.includeHidden().type(type).direction(dir);
 		if (vertex.getRelations(q, true).iterator().hasNext()) {
 			return true;

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/TransactionConfig.java
Patch:
@@ -47,7 +47,9 @@ public TransactionConfig(DefaultTypeMaker defaultTypeMaker, boolean assignIDsImm
         this.assignIDsImmediately=assignIDsImmediately;
     }
 
-
+    public TransactionConfig() {
+        this(BlueprintsDefaultTypeMaker.INSTANCE,true);
+    }
 
 	/**
 	 * Checks whether the graph transaction is configured as read-only.

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/PersistStandardTitanVertex.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.vertices;
 
 import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 import com.thinkaurelius.titan.graphdb.relations.InternalRelation;
 import com.thinkaurelius.titan.graphdb.entitystatus.BasicElement;
 import com.thinkaurelius.titan.graphdb.loadingstatus.LoadingStatus;
@@ -54,12 +54,12 @@ public boolean addRelation(InternalRelation e, boolean isNew) {
 	}
 	
 	@Override
-	public void loadedEdges(InternalTitanQuery query) {
+	public void loadedEdges(AtomicQuery query) {
 		loading = loading.loadedEdges(query);
 	}
 
 	@Override
-	public boolean hasLoadedEdges(InternalTitanQuery query) {
+	public boolean hasLoadedEdges(AtomicQuery query) {
 		return loading.hasLoadedEdges(query);
 	}
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/StandardTitanVertex.java
Patch:
@@ -7,7 +7,7 @@
 import com.thinkaurelius.titan.graphdb.adjacencylist.AdjacencyListFactory;
 import com.thinkaurelius.titan.graphdb.adjacencylist.InitialAdjListFactory;
 import com.thinkaurelius.titan.graphdb.adjacencylist.ModificationStatus;
-import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.query.AtomicQuery;
 import com.thinkaurelius.titan.graphdb.relations.EdgeDirection;
 import com.thinkaurelius.titan.graphdb.relations.InternalRelation;
 import com.thinkaurelius.titan.graphdb.transaction.InternalTitanTransaction;
@@ -56,7 +56,7 @@ public boolean addRelation(InternalRelation e, boolean isNew) {
 	}
 	
 	@Override
-	public Iterable<InternalRelation> getRelations(InternalTitanQuery query, boolean loadRemaining) {
+	public Iterable<InternalRelation> getRelations(AtomicQuery query, boolean loadRemaining) {
 		assert isAvailable();
 		if (loadRemaining) ensureLoadedEdges(query);
 		

File: src/main/java/com/thinkaurelius/titan/util/interval/PointInterval.java
Patch:
@@ -9,6 +9,7 @@
  * A PointInterval is a {@link AtomicInterval} with identical start and end points.
  * 
  * In other words, the attribute values defining the end points of the interval are identical and both are inclusive.
+ *
  * 
  * @author	Matthias Br&ouml;cheler (me@matthiasb.com);
  * 

File: src/main/java/com/thinkaurelius/titan/util/interval/Range.java
Patch:
@@ -10,6 +10,7 @@
  * 
  * Note that a range could also be defined with identical bounds. However, in that case it is preferable to use
  * {@link PointInterval} for efficiency.
+ * The start and/or end point of a range can be null which denotes the open interval in the start and/or end direction.
  * 
  * @author	Matthias Br&ouml;cheler (me@matthiasb.com);
  * 
@@ -114,7 +115,7 @@ public Set<V> getHoles() {
 	@SuppressWarnings("unchecked")
 	@Override
 	public boolean inInterval(Object obj) {
-        Preconditions.checkNotNull(obj);
+        if (obj==null) return false;
         if (start==null && end==null) return true;
 		V p = (V)obj;
 		int startcomp = start==null?1:p.compareTo(start);
@@ -127,7 +128,7 @@ public boolean inInterval(Object obj) {
 
     @Override
     public AtomicInterval<V> intersect(AtomicInterval<V> other) {
-        if (other.isPoint()) {
+        if (other.isPoint() || other.hasHoles()) {
             return other.intersect(this);
         } else {
             assert other.isRange();

File: src/main/java/com/thinkaurelius/titan/util/interval/RangeWithHoles.java
Patch:
@@ -78,7 +78,7 @@ public AtomicInterval<V> intersect(AtomicInterval<V> other) {
             assert newholes.contains(res.getStartPoint()); //The only point is also a hole => empty interval
             return null;
         } else {
-            return new RangeWithHoles(res.getStartPoint(),res.getEndPoint(),res.startInclusive(),res.endInclusive(),ImmutableSet.of(newholes));
+            return new RangeWithHoles(res.getStartPoint(),res.getEndPoint(),res.startInclusive(),res.endInclusive(),ImmutableSet.copyOf(newholes));
         }
     }
     

File: src/main/java/com/thinkaurelius/faunus/mapreduce/statistics/Transform.java
Patch:
@@ -2,7 +2,6 @@
 
 import com.thinkaurelius.faunus.FaunusVertex;
 import com.thinkaurelius.faunus.Tokens;
-import com.tinkerpop.blueprints.Element;
 import com.tinkerpop.gremlin.groovy.jsr223.GremlinGroovyScriptEngine;
 import groovy.lang.Closure;
 import org.apache.hadoop.io.NullWritable;
@@ -28,7 +27,6 @@ public enum Counters {
     public static class Map extends Mapper<NullWritable, FaunusVertex, FaunusVertex, Text> {
 
         private Closure closure;
-        private Class<? extends Element> klass;
 
         @Override
         public void setup(final Mapper.Context context) throws IOException, InterruptedException {

File: src/main/java/com/thinkaurelius/faunus/FaunusGraph.java
Patch:
@@ -297,10 +297,11 @@ private void configureMapReduceJob(final Job job) {
     ///////////////////////// STATISTICS /////////////////////////
     //////////////////////////////////////////////////////////////
 
-    public FaunusGraph adjacentProperties(final String property) throws IOException {
+    public FaunusGraph adjacentProperties(final String property, final String... labels) throws IOException {
         this.completeSequence();
         Configuration conf = new Configuration();
         conf.set(AdjacentProperties.PROPERTY, property);
+        conf.setStrings(AdjacentProperties.LABELS, labels);
         final Job job1 = new Job(conf, AdjacentProperties.class.getCanonicalName() + ":part-1");
         job1.setMapperClass(AdjacentProperties.Map.class);
         job1.setReducerClass(AdjacentProperties.Reduce.class);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/derivations/EdgePropertyFilterTest.java
Patch:
@@ -28,7 +28,7 @@ public void setUp() throws Exception {
 
     public void testLowWeightedEdgesFiltered() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(EdgePropertyFilter.KEY, "weight");
+        config.set(EdgePropertyFilter.KEY, "weight");
         config.setClass(EdgePropertyFilter.VALUE_CLASS, Double.class, Double.class);
         config.setFloat(EdgePropertyFilter.VALUE, 0.5f);
         config.set(EdgePropertyFilter.COMPARE, Query.Compare.LESS_THAN_EQUAL.name());
@@ -51,7 +51,7 @@ public void testLowWeightedEdgesFiltered() throws IOException {
 
     public void testEdgesFilteredWithNullWildcard() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(EdgePropertyFilter.KEY, "nothing");
+        config.set(EdgePropertyFilter.KEY, "nothing");
         config.setClass(EdgePropertyFilter.VALUE_CLASS, Double.class, Double.class);
         config.setFloat(EdgePropertyFilter.VALUE, 0.5f);
         config.set(EdgePropertyFilter.COMPARE, Query.Compare.LESS_THAN_EQUAL.name());

File: src/test/java/com/thinkaurelius/faunus/mapreduce/derivations/VertexPropertyFilterTest.java
Patch:
@@ -29,7 +29,7 @@ public void setUp() throws Exception {
 
     public void testOldVerticesFiltered() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(VertexPropertyFilter.KEY, "age");
+        config.set(VertexPropertyFilter.KEY, "age");
         config.setClass(VertexPropertyFilter.VALUE_CLASS, Integer.class, Integer.class);
         config.set(VertexPropertyFilter.VALUE, "35");
         config.set(VertexPropertyFilter.COMPARE, Query.Compare.LESS_THAN.name());
@@ -62,7 +62,7 @@ public void testOldVerticesFiltered() throws IOException {
 
     public void testOldVerticesFilteredWildCardNull() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(VertexPropertyFilter.KEY, "age");
+        config.set(VertexPropertyFilter.KEY, "age");
         config.setClass(VertexPropertyFilter.VALUE_CLASS, Integer.class, Integer.class);
         config.set(VertexPropertyFilter.VALUE, "35");
         config.set(VertexPropertyFilter.COMPARE, Query.Compare.LESS_THAN.name());

File: src/test/java/com/thinkaurelius/faunus/mapreduce/statistics/DegreeDistributionTest.java
Patch:
@@ -29,7 +29,7 @@ public void setUp() throws Exception {
 
     public void testOutDegree() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(DegreeDistribution.DIRECTION, "OUT");
+        config.set(DegreeDistribution.DIRECTION, "OUT");
         this.mapReduceDriver.withConfiguration(config);
         final List<Pair<IntWritable, LongWritable>> results = runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS, this.mapReduceDriver);
         //System.out.println(results);
@@ -57,7 +57,7 @@ public void testOutDegree() throws IOException {
 
     public void testInDegree() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(DegreeDistribution.DIRECTION, "IN");
+        config.set(DegreeDistribution.DIRECTION, "IN");
         this.mapReduceDriver.withConfiguration(config);
         final List<Pair<IntWritable, LongWritable>> results = runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS, this.mapReduceDriver);
         //System.out.println(results);
@@ -82,7 +82,7 @@ public void testInDegree() throws IOException {
 
     public void testBothDegree() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(DegreeDistribution.DIRECTION, "BOTH");
+        config.set(DegreeDistribution.DIRECTION, "BOTH");
         this.mapReduceDriver.withConfiguration(config);
         final List<Pair<IntWritable, IntWritable>> results = runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS, this.mapReduceDriver);
         //System.out.println(results);

File: src/test/java/com/thinkaurelius/faunus/mapreduce/statistics/LabelDistributionTest.java
Patch:
@@ -28,7 +28,7 @@ public void setUp() throws Exception {
 
     public void testOutLabelDistribution() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(LabelDistribution.DIRECTION, "OUT");
+        config.set(LabelDistribution.DIRECTION, "OUT");
         this.mapReduceDriver.withConfiguration(config);
         final List<Pair<Text, LongWritable>> results = runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS, this.mapReduceDriver);
         assertEquals(results.size(), 6);
@@ -56,7 +56,7 @@ public void testOutLabelDistribution() throws IOException {
 
     public void testInLabelDistribution() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(LabelDistribution.DIRECTION, "IN");
+        config.set(LabelDistribution.DIRECTION, "IN");
         this.mapReduceDriver.withConfiguration(config);
         final List<Pair<Text, LongWritable>> results = runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS, this.mapReduceDriver);
         assertEquals(results.size(), 6);
@@ -84,7 +84,7 @@ public void testInLabelDistribution() throws IOException {
 
     public void testBothLabelDistribution() throws IOException {
         Configuration config = new Configuration();
-        config.setStrings(LabelDistribution.DIRECTION, "BOTH");
+        config.set(LabelDistribution.DIRECTION, "BOTH");
         this.mapReduceDriver.withConfiguration(config);
         final List<Pair<Text, LongWritable>> results = runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS, this.mapReduceDriver);
         assertEquals(results.size(), 6);

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -16,6 +16,7 @@
 import com.thinkaurelius.titan.graphdb.database.serialize.Serializer;
 import com.thinkaurelius.titan.graphdb.database.serialize.kryo.KryoSerializer;
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
+import com.thinkaurelius.titan.graphdb.types.DisableDefaultTypeMaker;
 import org.apache.commons.configuration.BaseConfiguration;
 import org.apache.commons.configuration.Configuration;
 import org.apache.commons.configuration.ConfigurationException;
@@ -60,6 +61,7 @@ public class GraphDatabaseConfiguration {
     }};
 
     private static final Map<String,DefaultTypeMaker> preregisteredAutoType = new HashMap<String,DefaultTypeMaker>() {{
+        put("none", DisableDefaultTypeMaker.INSTANCE);
         put("blueprints", BlueprintsDefaultTypeMaker.INSTANCE);
     }};
 
@@ -232,6 +234,7 @@ private void preLoadConfiguration() {
         flushIDs = configuration.getBoolean(FLUSH_IDS_KEY,FLUSH_IDS_DEFAULT);
         batchLoading = storageConfig.getBoolean(STORAGE_BATCH_KEY,STORAGE_BATCH_DEFAULT);
         defaultTypeMaker = preregisteredAutoType.get(configuration.getString(AUTO_TYPE_KEY, AUTO_TYPE_DEFAULT));
+        Preconditions.checkNotNull(defaultTypeMaker,"Invalid "+AUTO_TYPE_KEY+" option: " + configuration.getString(AUTO_TYPE_KEY, AUTO_TYPE_DEFAULT));
     }
 
     public boolean isReadOnly() {

File: src/main/java/com/thinkaurelius/faunus/mapreduce/derivations/DirectionFilter.java
Patch:
@@ -14,9 +14,9 @@
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public class EdgeDirectionFilter {
-    public static final String DIRECTION = Tokens.makeNamespace(EdgeDirectionFilter.class) + ".direction";
-    public static final String ACTION = Tokens.makeNamespace(EdgeDirectionFilter.class) + ".action";
+public class DirectionFilter {
+    public static final String DIRECTION = Tokens.makeNamespace(DirectionFilter.class) + ".direction";
+    public static final String ACTION = Tokens.makeNamespace(DirectionFilter.class) + ".action";
 
     public enum Counters {
         EDGES_KEPT,

File: src/main/java/com/thinkaurelius/faunus/mapreduce/derivations/LabelFilter.java
Patch:
@@ -13,10 +13,10 @@
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public class EdgeLabelFilter {
+public class LabelFilter {
 
-    public static final String LABELS = Tokens.makeNamespace(EdgeLabelFilter.class) + ".labels";
-    public static final String ACTION = Tokens.makeNamespace(EdgeLabelFilter.class) + ".action";
+    public static final String LABELS = Tokens.makeNamespace(LabelFilter.class) + ".labels";
+    public static final String ACTION = Tokens.makeNamespace(LabelFilter.class) + ".action";
 
     public enum Counters {
         EDGES_KEPT,

File: src/main/java/com/thinkaurelius/faunus/mapreduce/derivations/LoopFilter.java
Patch:
@@ -16,10 +16,10 @@
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public class Self {
+public class LoopFilter {
 
-    public static final String ACTION = Tokens.makeNamespace(Self.class) + ".action";
-    public static final String LABELS = Tokens.makeNamespace(Self.class) + ".labels";
+    public static final String ACTION = Tokens.makeNamespace(LoopFilter.class) + ".action";
+    public static final String LABELS = Tokens.makeNamespace(LoopFilter.class) + ".labels";
 
     public enum Counters {
         EDGES_DROPPED,

File: src/test/java/com/thinkaurelius/faunus/BaseTest.java
Patch:
@@ -89,11 +89,11 @@ public static List<Vertex> getVertices(final Iterable<Edge> edges, final Directi
     }
 
     public static String getFullString(final Vertex vertex) {
-        String string = vertex.toString() + "[";
+        String string = vertex.toString() + "IN[";
         for (Edge edge : vertex.getEdges(Direction.IN)) {
             string = string + edge.toString();
         }
-        string = string + "][";
+        string = string + "]OUT[";
         for (Edge edge : vertex.getEdges(Direction.OUT)) {
             string = string + edge.toString();
         }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/MapReduceSequence.java
Patch:
@@ -18,9 +18,9 @@
  */
 public class MapReduceSequence {
 
-    public static final String MAP_CLASSES = Tokens.makeNamespace(MapSequence.class) + ".mapClasses";
-    public static final String MAPR_CLASS = Tokens.makeNamespace(MapSequence.class) + ".mapRClass";
-    public static final String REDUCE_CLASS = Tokens.makeNamespace(MapSequence.class) + ".reduceClass";
+    public static final String MAP_CLASSES = Tokens.makeNamespace(MapReduceSequence.class) + ".mapClasses";
+    public static final String MAPR_CLASS = Tokens.makeNamespace(MapReduceSequence.class) + ".mapRClass";
+    public static final String REDUCE_CLASS = Tokens.makeNamespace(MapReduceSequence.class) + ".reduceClass";
 
     public static class Map extends MemoryMapper<NullWritable, FaunusVertex, LongWritable, Holder> {
 

File: src/main/java/com/thinkaurelius/faunus/mapreduce/derivations/EdgeFilter.java
Patch:
@@ -35,7 +35,7 @@ public static class Map extends Mapper<NullWritable, FaunusVertex, NullWritable,
         public void setup(final Mapper.Context context) throws IOException, InterruptedException {
             try {
                 this.closure = (Closure) engine.eval(context.getConfiguration().get(FUNCTION));
-            } catch (ScriptException e) {
+            } catch (final ScriptException e) {
                 throw new IOException(e.getMessage(), e);
             }
         }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/derivations/VertexFilter.java
Patch:
@@ -43,7 +43,7 @@ public static class Map extends Mapper<NullWritable, FaunusVertex, LongWritable,
         public void setup(final Mapper.Context context) throws IOException, InterruptedException {
             try {
                 this.closure = (Closure) engine.eval(context.getConfiguration().get(FUNCTION));
-            } catch (ScriptException e) {
+            } catch (final ScriptException e) {
                 throw new IOException(e.getMessage(), e);
             }
         }

File: src/test/java/com/thinkaurelius/faunus/mapreduce/MapSequenceTest.java
Patch:
@@ -32,7 +32,7 @@ public void testLongSequence() throws Exception {
         config.setStrings(PropertyFilter.KEYS + "-2", "name");
         config.set(PropertyFilter.ACTION + "-2", Tokens.Action.DROP.name());
         config.set(PropertyFilter.CLASS + "-2", Vertex.class.getName());
-        config.setStrings(MapReduceSequence.MAP_CLASSES, Identity.Map.class.getName(), Identity.Map.class.getName(), PropertyFilter.Map.class.getName());
+        config.setStrings(MapSequence.MAP_CLASSES, Identity.Map.class.getName(), Identity.Map.class.getName(), PropertyFilter.Map.class.getName());
         this.mapReduceDriver.withConfiguration(config);
         final Map<Long, FaunusVertex> results = runWithToyGraph(BaseTest.ExampleGraph.TINKERGRAPH, this.mapReduceDriver);
         assertEquals(results.size(), 6);
@@ -45,10 +45,10 @@ public void testLongSequence() throws Exception {
 
     public void testBadSequenceId() throws Exception {
         Configuration config = new Configuration();
-        config.setStrings(PropertyFilter.KEYS + "-3", "name");
+        config.setStrings(PropertyFilter.KEYS + "-3", "name"); // should be 2
         config.set(PropertyFilter.ACTION + "-3", Tokens.Action.DROP.name());
         config.set(PropertyFilter.CLASS + "-3", Vertex.class.getName());
-        config.setStrings(MapReduceSequence.MAP_CLASSES, Identity.Map.class.getName(), Identity.Map.class.getName(), PropertyFilter.Map.class.getName());
+        config.setStrings(MapSequence.MAP_CLASSES, Identity.Map.class.getName(), Identity.Map.class.getName(), PropertyFilter.Map.class.getName());
         this.mapReduceDriver.withConfiguration(config);
         try {
             final Map<Long, FaunusVertex> results = runWithToyGraph(BaseTest.ExampleGraph.TINKERGRAPH, this.mapReduceDriver);

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -219,6 +219,7 @@ public void testCreateDelete() {
 		TitanVertex n1 = tx.addVertex(), n3 = tx.addVertex();
 		TitanEdge e=n3.addEdge(knows, n1);
 		e.addProperty(id, 111);
+        Object eid = e.getId();
 		n3.addProperty(id, 445);
 		assertEquals(111,e.getProperty(id));
 		clopen();
@@ -228,6 +229,8 @@ public void testCreateDelete() {
 		assertEquals(445,n3.getProperty("uid"));
 		e=Iterables.getOnlyElement(n3.getTitanEdges(Direction.OUT, tx.getEdgeLabel("knows")));
 		assertEquals(111,e.getProperty(id));
+        assertEquals(e,tx.getEdge(eid));
+        assertEquals(e,tx.getEdge(eid.toString()));
 		TitanProperty p = Iterables.getOnlyElement(n3.getProperties("uid"));
 		p.remove();
 		n3.addProperty("uid", 353);

File: src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanFeatures.java
Patch:
@@ -38,7 +38,7 @@ public static Features getBaselineTitanFeatures() {
         features.supportsVertexIteration = false;
         features.supportsVertexProperties = true;
         features.supportsEdgeProperties = true;
-        features.supportsEdgeRetrieval = false;
+        features.supportsEdgeRetrieval = true;
         features.supportsTransactions = true;
         features.supportsThreadedTransactions = true;
         features.checkCompliance();

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/persist/PersistSimpleTitanEdge.java
Patch:
@@ -58,8 +58,6 @@ public long getID() {
 		return entity.getID();
 	}
 
-
-
 	@Override
 	public boolean hasID() {
 		return entity.hasID();

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraEmbeddedGraphTest.java
Patch:
@@ -9,7 +9,7 @@
 public class InternalCassandraEmbeddedGraphTest extends TitanGraphTest {
 
 	public InternalCassandraEmbeddedGraphTest() {
-		super(StorageSetup.getCassandraGraphConfiguration());
+		super(StorageSetup.getEmbeddedCassandraGraphConfiguration());
 	}
 
 	@BeforeClass

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -219,6 +219,7 @@ public void testCreateDelete() {
 		TitanVertex n1 = tx.addVertex(), n3 = tx.addVertex();
 		TitanEdge e=n3.addEdge(knows, n1);
 		e.addProperty(id, 111);
+        Object eid = e.getId();
 		n3.addProperty(id, 445);
 		assertEquals(111,e.getProperty(id));
 		clopen();
@@ -228,6 +229,8 @@ public void testCreateDelete() {
 		assertEquals(445,n3.getProperty("uid"));
 		e=Iterables.getOnlyElement(n3.getTitanEdges(Direction.OUT, tx.getEdgeLabel("knows")));
 		assertEquals(111,e.getProperty(id));
+        assertEquals(e,tx.getEdge(eid));
+        assertEquals(e,tx.getEdge(eid.toString()));
 		TitanProperty p = Iterables.getOnlyElement(n3.getProperties("uid"));
 		p.remove();
 		n3.addProperty("uid", 353);

File: src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanFeatures.java
Patch:
@@ -38,7 +38,7 @@ public static Features getBaselineTitanFeatures() {
         features.supportsVertexIteration = false;
         features.supportsVertexProperties = true;
         features.supportsEdgeProperties = true;
-        features.supportsEdgeRetrieval = false;
+        features.supportsEdgeRetrieval = true;
         features.supportsTransactions = true;
         features.supportsThreadedTransactions = true;
         features.checkCompliance();

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/persist/PersistSimpleTitanEdge.java
Patch:
@@ -58,8 +58,6 @@ public long getID() {
 		return entity.getID();
 	}
 
-
-
 	@Override
 	public boolean hasID() {
 		return entity.hasID();

File: src/main/java/com/thinkaurelius/faunus/mapreduce/MapReduceSequence.java
Patch:
@@ -48,6 +48,7 @@ public void setup(final Mapper.Context context) throws IOException, InterruptedE
                         this.mapperMethods.add(mapClass.getMethod(Tokens.MAP, NullWritable.class, FaunusVertex.class, Mapper.Context.class));
                     }
                 }
+                memoryContext.stageConfiguration();
                 final String mapRClassName = context.getConfiguration().get(MAPR_CLASS);
                 final Class<Mapper<NullWritable, FaunusVertex, LongWritable, Holder>> mapRClass = (Class) Class.forName(mapRClassName);
                 this.mapperR = mapRClass.getConstructor().newInstance();

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraEmbeddedGraphTest.java
Patch:
@@ -9,7 +9,7 @@
 public class InternalCassandraEmbeddedGraphTest extends TitanGraphTest {
 
 	public InternalCassandraEmbeddedGraphTest() {
-		super(StorageSetup.getCassandraGraphConfiguration());
+		super(StorageSetup.getEmbeddedCassandraGraphConfiguration());
 	}
 
 	@BeforeClass

File: src/main/java/com/thinkaurelius/faunus/mapreduce/Function.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.faunus.mapreduce.steps;
+package com.thinkaurelius.faunus.mapreduce;
 
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)

File: src/main/java/com/thinkaurelius/faunus/FaunusVertex.java
Patch:
@@ -80,7 +80,7 @@ public Iterable<Vertex> getVertices(final Direction direction, final String... l
     public Iterable<Edge> getEdges(final Direction direction, final String... labels) {
         final List<List<Edge>> edges = new ArrayList<List<Edge>>();
         if (direction.equals(OUT) || direction.equals(BOTH)) {
-            if (labels.length == 0) {
+            if (null == labels || labels.length == 0) {
                 for (final List<Edge> temp : this.outEdges.values()) {
                     edges.add(temp);
                 }
@@ -94,7 +94,7 @@ public Iterable<Edge> getEdges(final Direction direction, final String... labels
         }
 
         if (direction.equals(IN) || direction.equals(BOTH)) {
-            if (labels.length == 0) {
+            if (null == labels || labels.length == 0) {
                 for (final List<Edge> temp : this.inEdges.values()) {
                     edges.add(temp);
                 }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/operators/DegreeDistribution.java
Patch:
@@ -33,7 +33,7 @@ public static class Map extends Mapper<NullWritable, FaunusVertex, IntWritable,
         @Override
         public void setup(final Mapper.Context context) throws IOException, InterruptedException {
             this.direction = Direction.valueOf(context.getConfiguration().get(DIRECTION));
-            this.labels = context.getConfiguration().getStrings(LABELS);
+            this.labels = context.getConfiguration().getStrings(LABELS, new String[0]);
         }
 
         @Override

File: src/main/java/com/thinkaurelius/faunus/mapreduce/operators/EdgeLabelDistribution.java
Patch:
@@ -45,11 +45,11 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
             for (final Edge edge : value.getEdges(this.direction)) {
                 counter++;
                 final String label = edge.getLabel();
-                final Long count = map.get(label);
+                final Long count = this.map.get(label);
                 if (null == count)
-                    map.put(label, 1l);
+                    this.map.put(label, 1l);
                 else
-                    map.put(label, count + 1l);
+                    this.map.put(label, count + 1l);
             }
             context.getCounter(Counters.VERTICES_COUNTED).increment(1);
             context.getCounter(Counters.EDGES_COUNTED).increment(counter);

File: src/main/java/com/thinkaurelius/faunus/FaunusGraph.java
Patch:
@@ -1,13 +1,13 @@
 package com.thinkaurelius.faunus;
 
+import com.thinkaurelius.faunus.mapreduce.MapReduceSequence;
+import com.thinkaurelius.faunus.mapreduce.MapSequence;
 import com.thinkaurelius.faunus.mapreduce.operators.DegreeDistribution;
 import com.thinkaurelius.faunus.mapreduce.operators.EdgeLabelDistribution;
 import com.thinkaurelius.faunus.mapreduce.operators.VertexDegree;
 import com.thinkaurelius.faunus.mapreduce.steps.EdgeLabelFilter;
 import com.thinkaurelius.faunus.mapreduce.steps.Function;
 import com.thinkaurelius.faunus.mapreduce.steps.Identity;
-import com.thinkaurelius.faunus.mapreduce.steps.MapReduceSequence;
-import com.thinkaurelius.faunus.mapreduce.steps.MapSequence;
 import com.thinkaurelius.faunus.mapreduce.steps.PropertyFilter;
 import com.thinkaurelius.faunus.mapreduce.steps.Self;
 import com.thinkaurelius.faunus.mapreduce.steps.Transpose;

File: src/main/java/com/thinkaurelius/faunus/mapreduce/operators/DegreeDistribution.java
Patch:
@@ -55,7 +55,7 @@ public static class Reduce extends Reducer<IntWritable, IntWritable, IntWritable
         public void reduce(final IntWritable key, final Iterable<IntWritable> values, final Reducer<IntWritable, IntWritable, IntWritable, IntWritable>.Context context) throws IOException, InterruptedException {
             int totalDegree = 0;
             for (final IntWritable token : values) {
-                totalDegree++;
+                totalDegree = totalDegree + token.get();
             }
             context.write(key, new IntWritable(totalDegree));
         }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/operators/EdgeLabelDistribution.java
Patch:
@@ -51,7 +51,7 @@ public static class Reduce extends Reducer<Text, IntWritable, Text, IntWritable>
         public void reduce(final Text key, final Iterable<IntWritable> values, final Reducer<Text, IntWritable, Text, IntWritable>.Context context) throws IOException, InterruptedException {
             int totalNumberOfEdges = 0;
             for (final IntWritable token : values) {
-                totalNumberOfEdges++;
+                totalNumberOfEdges = totalNumberOfEdges + token.get();
             }
             context.write(key, new IntWritable(totalNumberOfEdges));
         }

File: src/main/java/com/thinkaurelius/faunus/mapreduce/steps/Transpose.java
Patch:
@@ -51,7 +51,7 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
                     final FaunusEdge inverseEdge = new FaunusEdge((FaunusVertex) edge.getVertex(IN), (FaunusVertex) edge.getVertex(OUT), this.newLabel);
                     inverseEdge.setProperties(((FaunusEdge) edge).getProperties());
                     counter++;
-                    context.write(new LongWritable((Long) inverseEdge.getVertex(OUT).getId()), new TaggedHolder<FaunusEdge>('i', inverseEdge));
+                    context.write(vertex.getIdAsLongWritable(), new TaggedHolder<FaunusEdge>('i', inverseEdge));
                 }
             }
 
@@ -61,7 +61,7 @@ public void map(final NullWritable key, final FaunusVertex value, final Mapper<N
                     final FaunusEdge inverseEdge = new FaunusEdge((FaunusVertex) edge.getVertex(IN), (FaunusVertex) edge.getVertex(OUT), this.newLabel);
                     inverseEdge.setProperties(((FaunusEdge) edge).getProperties());
                     counter++;
-                    context.write(new LongWritable((Long) inverseEdge.getVertex(IN).getId()), new TaggedHolder<FaunusEdge>('o', inverseEdge));
+                    context.write(vertex.getIdAsLongWritable(), new TaggedHolder<FaunusEdge>('o', inverseEdge));
                 }
             }
 

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
 import com.thinkaurelius.titan.diskstorage.OrderedKeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
+import com.thinkaurelius.titan.diskstorage.astyanax.AstyanaxStorageManager;
 import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEStorageAdapter;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraThriftStorageManager;
 import com.thinkaurelius.titan.diskstorage.hbase.HBaseStorageManager;
@@ -53,6 +54,7 @@ public class GraphDatabaseConfiguration {
         put("berkeleyje", BerkeleyJEStorageAdapter.class);
         put("cassandra", CassandraThriftStorageManager.class);
         put("hbase", HBaseStorageManager.class);
+        put("astyanax", AstyanaxStorageManager.class);
     }};
 
     private static final Map<String,DefaultTypeMaker> preregisteredAutoType = new HashMap<String,DefaultTypeMaker>() {{

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/ExternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -21,7 +21,7 @@ public class ExternalAstyanaxKeyColumnValueTest extends KeyColumnValueStoreTest
 	@BeforeClass
 	public static void connectToClusterForCleanup() {
 		AstyanaxContext<Cluster> ctx = new AstyanaxContext.Builder()
-				.forCluster(AstyanaxStorageManager.CLUSTER_NAME)
+				.forCluster(AstyanaxStorageManager.CLUSTER_DEFAULT)
 				.withAstyanaxConfiguration(
 						new AstyanaxConfigurationImpl()
 								.setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE))
@@ -44,7 +44,7 @@ public StorageManager openStorageManager() {
 	@Override
 	public void cleanUp() {
 		try {
-			cluster.dropKeyspace(AstyanaxStorageManager.KS_NAME);
+			cluster.dropKeyspace(AstyanaxStorageManager.KEYSPACE_DEFAULT);
 			AstyanaxStorageManager.clearKeyspaces();
 		} catch (ConnectionException e) {
 //			throw new RuntimeException(e);

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/ExternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -11,7 +11,6 @@
 import com.netflix.astyanax.connectionpool.impl.CountingConnectionPoolMonitor;
 import com.netflix.astyanax.impl.AstyanaxConfigurationImpl;
 import com.netflix.astyanax.thrift.ThriftFamilyFactory;
-import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraLocalhostHelper;
@@ -25,7 +24,7 @@ public class ExternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnVa
 	@BeforeClass
 	public static void connectToClusterForCleanup() {
 		AstyanaxContext<Cluster> ctx = new AstyanaxContext.Builder()
-				.forCluster(AstyanaxStorageManager.CLUSTER_NAME)
+				.forCluster(AstyanaxStorageManager.CLUSTER_DEFAULT)
 				.withAstyanaxConfiguration(
 						new AstyanaxConfigurationImpl()
 								.setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE))
@@ -52,7 +51,7 @@ public StorageManager openStorageManager(short idx) {
 	@Override
 	public void cleanUp() {
 		try {
-			cluster.dropKeyspace(AstyanaxStorageManager.KS_NAME);
+			cluster.dropKeyspace(AstyanaxStorageManager.KEYSPACE_DEFAULT);
 			AstyanaxStorageManager.clearKeyspaces();
 		} catch (ConnectionException e) {
 //			throw new RuntimeException(e);

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -505,7 +505,7 @@ public void testQuery() {
         for (int i=0;i<noVertices;i++) vs[i]=tx.getVertex(vs[i].getID());
         v = vs[0];
 
-        //Same queries as above but without memory loading
+        //Same queries as above but without memory loading        
         assertEquals(0,v.query().labels("follows").has("time",10, Query.Compare.LESS_THAN).count());
         assertEquals(10,v.query().labels("connect").direction(Direction.OUT).interval("time",3,31).count());
         assertEquals(10,v.query().labels("connect").direction(Direction.OUT).interval("time",3,31).vertexIds().size());
@@ -527,6 +527,7 @@ public void testQuery() {
         assertEquals(20,Iterables.size(v.query().labels("connect","friend").direction(Direction.OUT).interval("time",3,33).vertexIds()));
         assertEquals(50,Iterables.size(v.query().labels("connect","friend","knows").has("weight",1.5).vertexIds()));
         assertEquals(33,v.query().labels("connect").direction(Direction.OUT).count());
+        assertEquals(99,Iterables.size(v.query().direction(Direction.OUT).vertices()));
 
     }
 

File: src/main/java/com/thinkaurelius/titan/graphdb/query/AtomicTitanQuery.java
Patch:
@@ -504,6 +504,7 @@ public Iterable<Vertex> vertices() {
     }
 
     private VertexListInternal retrieveFromMemory(VertexListInternal vertices) {
+        edgesOnly();
         if (node==null) node = tx.getExistingVertex(nodeid);
         AtomicTitanQuery q = new AtomicTitanQuery(node,this);
         Iterator<TitanEdge> iter = q.edgeIterator();
@@ -515,6 +516,7 @@ private VertexListInternal retrieveFromMemory(VertexListInternal vertices) {
     }
 
     public VertexListInternal getVertexIDs() {
+        edgesOnly();
         Preconditions.checkNotNull(tx);
         Preconditions.checkArgument(node==null || (!node.isNew() && !node.isModified()),
                 "Cannot query for raw neighborhood on new or modified node.");

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
 import com.thinkaurelius.titan.diskstorage.OrderedKeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
+import com.thinkaurelius.titan.diskstorage.astyanax.AstyanaxStorageManager;
 import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEStorageAdapter;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraThriftStorageManager;
 import com.thinkaurelius.titan.diskstorage.hbase.HBaseStorageManager;
@@ -53,6 +54,7 @@ public class GraphDatabaseConfiguration {
         put("berkeleyje", BerkeleyJEStorageAdapter.class);
         put("cassandra", CassandraThriftStorageManager.class);
         put("hbase", HBaseStorageManager.class);
+        put("astyanax", AstyanaxStorageManager.class);
     }};
 
     private static final Map<String,DefaultTypeMaker> preregisteredAutoType = new HashMap<String,DefaultTypeMaker>() {{

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/ExternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -21,7 +21,7 @@ public class ExternalAstyanaxKeyColumnValueTest extends KeyColumnValueStoreTest
 	@BeforeClass
 	public static void connectToClusterForCleanup() {
 		AstyanaxContext<Cluster> ctx = new AstyanaxContext.Builder()
-				.forCluster(AstyanaxStorageManager.CLUSTER_NAME)
+				.forCluster(AstyanaxStorageManager.CLUSTER_DEFAULT)
 				.withAstyanaxConfiguration(
 						new AstyanaxConfigurationImpl()
 								.setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE))
@@ -44,7 +44,7 @@ public StorageManager openStorageManager() {
 	@Override
 	public void cleanUp() {
 		try {
-			cluster.dropKeyspace(AstyanaxStorageManager.KS_NAME);
+			cluster.dropKeyspace(AstyanaxStorageManager.KEYSPACE_DEFAULT);
 			AstyanaxStorageManager.clearKeyspaces();
 		} catch (ConnectionException e) {
 //			throw new RuntimeException(e);

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/ExternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -11,7 +11,6 @@
 import com.netflix.astyanax.connectionpool.impl.CountingConnectionPoolMonitor;
 import com.netflix.astyanax.impl.AstyanaxConfigurationImpl;
 import com.netflix.astyanax.thrift.ThriftFamilyFactory;
-import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraLocalhostHelper;
@@ -25,7 +24,7 @@ public class ExternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnVa
 	@BeforeClass
 	public static void connectToClusterForCleanup() {
 		AstyanaxContext<Cluster> ctx = new AstyanaxContext.Builder()
-				.forCluster(AstyanaxStorageManager.CLUSTER_NAME)
+				.forCluster(AstyanaxStorageManager.CLUSTER_DEFAULT)
 				.withAstyanaxConfiguration(
 						new AstyanaxConfigurationImpl()
 								.setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE))
@@ -52,7 +51,7 @@ public StorageManager openStorageManager(short idx) {
 	@Override
 	public void cleanUp() {
 		try {
-			cluster.dropKeyspace(AstyanaxStorageManager.KS_NAME);
+			cluster.dropKeyspace(AstyanaxStorageManager.KEYSPACE_DEFAULT);
 			AstyanaxStorageManager.clearKeyspaces();
 		} catch (ConnectionException e) {
 //			throw new RuntimeException(e);

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraThriftStorageManager.java
Patch:
@@ -212,7 +212,7 @@ public TransactionHandle beginTransaction() {
 
 	@Override
 	public void close() {
-        //Do nothing
+		stores.clear();
 	}
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -5,6 +5,7 @@
 import com.thinkaurelius.titan.core.DefaultTypeMaker;
 import com.thinkaurelius.titan.diskstorage.OrderedKeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
+import com.thinkaurelius.titan.diskstorage.astyanax.AstyanaxStorageManager;
 import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEStorageAdapter;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraThriftStorageManager;
 import com.thinkaurelius.titan.diskstorage.hbase.HBaseStorageManager;
@@ -53,6 +54,7 @@ public class GraphDatabaseConfiguration {
         put("berkeleyje", BerkeleyJEStorageAdapter.class);
         put("cassandra", CassandraThriftStorageManager.class);
         put("hbase", HBaseStorageManager.class);
+        put("astyanax", AstyanaxStorageManager.class);
     }};
 
     private static final Map<String,DefaultTypeMaker> preregisteredAutoType = new HashMap<String,DefaultTypeMaker>() {{

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/ExternalAstyanaxKeyColumnValueTest.java
Patch:
@@ -21,7 +21,7 @@ public class ExternalAstyanaxKeyColumnValueTest extends KeyColumnValueStoreTest
 	@BeforeClass
 	public static void connectToClusterForCleanup() {
 		AstyanaxContext<Cluster> ctx = new AstyanaxContext.Builder()
-				.forCluster(AstyanaxStorageManager.CLUSTER_NAME)
+				.forCluster(AstyanaxStorageManager.CLUSTER_DEFAULT)
 				.withAstyanaxConfiguration(
 						new AstyanaxConfigurationImpl()
 								.setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE))
@@ -44,7 +44,7 @@ public StorageManager openStorageManager() {
 	@Override
 	public void cleanUp() {
 		try {
-			cluster.dropKeyspace(AstyanaxStorageManager.KS_NAME);
+			cluster.dropKeyspace(AstyanaxStorageManager.KEYSPACE_DEFAULT);
 			AstyanaxStorageManager.clearKeyspaces();
 		} catch (ConnectionException e) {
 //			throw new RuntimeException(e);

File: src/test/java/com/thinkaurelius/titan/diskstorage/astyanax/ExternalAstyanaxLockKeyColumnValueStoreTest.java
Patch:
@@ -11,7 +11,6 @@
 import com.netflix.astyanax.connectionpool.impl.CountingConnectionPoolMonitor;
 import com.netflix.astyanax.impl.AstyanaxConfigurationImpl;
 import com.netflix.astyanax.thrift.ThriftFamilyFactory;
-import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraLocalhostHelper;
@@ -25,7 +24,7 @@ public class ExternalAstyanaxLockKeyColumnValueStoreTest extends LockKeyColumnVa
 	@BeforeClass
 	public static void connectToClusterForCleanup() {
 		AstyanaxContext<Cluster> ctx = new AstyanaxContext.Builder()
-				.forCluster(AstyanaxStorageManager.CLUSTER_NAME)
+				.forCluster(AstyanaxStorageManager.CLUSTER_DEFAULT)
 				.withAstyanaxConfiguration(
 						new AstyanaxConfigurationImpl()
 								.setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE))
@@ -52,7 +51,7 @@ public StorageManager openStorageManager(short idx) {
 	@Override
 	public void cleanUp() {
 		try {
-			cluster.dropKeyspace(AstyanaxStorageManager.KS_NAME);
+			cluster.dropKeyspace(AstyanaxStorageManager.KEYSPACE_DEFAULT);
 			AstyanaxStorageManager.clearKeyspaces();
 		} catch (ConnectionException e) {
 //			throw new RuntimeException(e);

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -231,10 +231,13 @@ public void testCreateDelete() {
 		TitanProperty p = Iterables.getOnlyElement(n3.getProperties("uid"));
 		p.remove();
 		n3.addProperty("uid", 353);
+
+
 		clopen();
 		
 		n3 = tx.getVertex(nid);
 		assertEquals(353,n3.getProperty("uid"));
+        TitanEdge e2 = n3.addEdge("knows",tx.addVertex());
 	}
 	
 	@Test

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -231,10 +231,13 @@ public void testCreateDelete() {
 		TitanProperty p = Iterables.getOnlyElement(n3.getProperties("uid"));
 		p.remove();
 		n3.addProperty("uid", 353);
+
+
 		clopen();
 		
 		n3 = tx.getVertex(nid);
 		assertEquals(353,n3.getProperty("uid"));
+        TitanEdge e2 = n3.addEdge("knows",tx.addVertex());
 	}
 	
 	@Test

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardPersistTitanTx.java
Patch:
@@ -8,6 +8,7 @@
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;
 import com.thinkaurelius.titan.graphdb.database.InternalTitanGraph;
 import com.thinkaurelius.titan.graphdb.query.InternalTitanQuery;
+import com.thinkaurelius.titan.graphdb.relations.AttributeUtil;
 import com.thinkaurelius.titan.graphdb.relations.InternalRelation;
 import com.thinkaurelius.titan.graphdb.relations.factory.StandardPersistedRelationFactory;
 import com.thinkaurelius.titan.graphdb.types.manager.TypeManager;
@@ -114,6 +115,7 @@ public TitanVertex getVertex(TitanKey key, Object value) {
 		TitanVertex node = super.getVertex(key, value);
 		if (node==null && !key.isNew()) {
 			//Look up
+            value = AttributeUtil.prepareAttribute(value, key.getDataType());
 			long[] ids = graphdb.indexRetrieval(value, key, this);
 			if (ids.length==0) {
                 //TODO Set NO-ENTRY

File: src/main/java/com/thinkaurelius/titan/graphdb/blueprints/TitanBlueprintsTransaction.java
Patch:
@@ -122,7 +122,7 @@ public <T extends Element> void createKeyIndex(String key, Class<T> elementClass
 
     @Override
     public <T extends Element> Set<String> getIndexedKeys(Class<T> elementClass) {
-        Preconditions.checkArgument(elementClass.equals(Vertex.class),"Only vertex indexing is supported");
+        Preconditions.checkArgument(elementClass==null || elementClass.equals(Vertex.class),"Only vertex indexing is supported");
 
         Set<String> indexedkeys = new HashSet<String>();
         for (TitanVertex v : getVertices(SystemKey.TypeClass, TitanTypeClass.KEY)) {

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractTitanTx.java
Patch:
@@ -285,7 +285,7 @@ public void addedRelation(InternalRelation relation) {
 	@Override
 	public void deletedRelation(InternalRelation relation) {
 		verifyWriteAccess();
-		if (relation.isProperty() && !relation.isInline()) {
+		if (relation.isProperty() && !relation.isRemoved() && !relation.isInline()) {
 			TitanProperty prop = (TitanProperty) relation;
 			if (prop.getPropertyKey().hasIndex()) {
 				removeKeyFromIndex(prop);
@@ -389,7 +389,7 @@ private void removeKeyFromIndex(TitanProperty property) {
             Map<Object,TitanVertex> subindex = keyIndex.get(type);
             Preconditions.checkNotNull(subindex);
             TitanVertex n = subindex.remove(property.getAttribute());
-            Preconditions.checkArgument(n!=null && n.equals(property.getVertex()));
+            assert n!=null && n.equals(property.getVertex());
             //TODO Set to NO-ENTRY node object
         } else {
             boolean hasIdenticalProperty = false;

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardPersistTitanTx.java
Patch:
@@ -79,8 +79,7 @@ public Iterable<Vertex> getVertices() {
 	@Override
 	public void deletedRelation(InternalRelation relation) {
 		super.deletedRelation(relation);
-		if (relation.isNew()) return;
-		if (!relation.isInline()) {
+		if (relation.isLoaded() && !relation.isInline()) {
 			//Only store those deleted edges that matter, i.e. those that we need to erase from memory on their own		
 			boolean success = deletedEdges.add(relation);
 			assert success;

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/SimpleProperty.java
Patch:
@@ -79,7 +79,7 @@ public boolean isIncidentOn(TitanVertex vertex) {
 	}
 
 	@Override
-	public void forceDelete() {
+	public synchronized void forceDelete() {
 		super.forceDelete();
 		node.removeRelation(this);
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/SimpleTitanEdge.java
Patch:
@@ -97,7 +97,7 @@ public boolean isIncidentOn(TitanVertex vertex) {
 	}
 
 	@Override
-	public void forceDelete() {
+	public synchronized void forceDelete() {
 		start.removeRelation(this);
 		if (!isUnidirected())
 			end.removeRelation(this);

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/persist/PersistLabeledTitanEdge.java
Patch:
@@ -45,7 +45,7 @@ public PersistLabeledTitanEdge clone() {
 	 */
 	
 	@Override
-	public void forceDelete() {
+	public synchronized void forceDelete() {
 		super.forceDelete();
 		entity.remove();
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/persist/PersistSimpleProperty.java
Patch:
@@ -40,7 +40,7 @@ public boolean equals(Object oth) {
 	}
 	
 	@Override
-	public void forceDelete() {
+	public synchronized void forceDelete() {
 		super.forceDelete();
 		entity.remove();
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/persist/PersistSimpleTitanEdge.java
Patch:
@@ -42,7 +42,7 @@ public boolean equals(Object oth) {
 	}
 	
 	@Override
-	public void forceDelete() {
+	public synchronized void forceDelete() {
 		super.forceDelete();
 		entity.remove();
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/relations/AbstractTypedRelation.java
Patch:
@@ -47,7 +47,7 @@ public void remove() {
 	}
 	
 	@Override
-	public void forceDelete() {
+	public synchronized void forceDelete() {
 		getTransaction().deletedRelation(this);
 	}
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/AbstractTitanVertex.java
Patch:
@@ -89,7 +89,7 @@ protected synchronized void ensureLoadedEdges(InternalTitanQuery query) {
 	}
 
 	@Override
-	public void remove() {
+	public synchronized void remove() {
 		VertexUtil.checkAvailability(this);
         VertexUtil.prepareForRemoval(this);
         tx.deleteVertex(this);

File: src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -51,7 +51,7 @@ public static boolean hasFirstKeyConstraint(InternalTitanQuery query) {
         if (!query.hasConstraints()) return false;
         if (!query.hasEdgeTypeCondition()) return false;
         String[] keysig = ((InternalTitanType)query.getTypeCondition()).getDefinition().getKeySignature();
-        return query.getConstraints().containsKey(keysig[0]);
+        return keysig.length>0 && query.getConstraints().containsKey(keysig[0]);
     }
     
 }

File: src/main/java/com/thinkaurelius/titan/core/TypeMaker.java
Patch:
@@ -140,7 +140,7 @@ public interface TypeMaker {
      * For instance, if all edges with label <i>friend</i> have a property with key <i>createdOn</i>, then specifying
      * (<i>createdOn</i>) as the signature for type <i>friend</i> allows friend edges to be stored more efficiently.
      * <br />
-     * {@link TitanType}s used in the primary key must be either property keys or unidirected edge lables.
+     * {@link TitanType}s used in the signature must be either property keys or unidirected edge lables.
      * Also, they must be simple ({@link com.thinkaurelius.titan.core.TitanType#isSimple()}) and
      * functional ({@link com.thinkaurelius.titan.core.TitanType#isFunctional()}).
      * <br />

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyJEStorageManager.java
Patch:
@@ -24,8 +24,8 @@ public class BerkeleyJEStorageManager implements KeyValueStorageManager {
     private Logger log = LoggerFactory.getLogger(BerkeleyJEStorageManager.class);
 
 
-    private static final String CACHE_KEY = "cache_percentage";
-    private static final int CACHE_DEFAULT = 65;
+    public static final String CACHE_KEY = "cache_percentage";
+    public static final int CACHE_DEFAULT = 65;
     
     private static final String IDMANAGER_KEY = "idmanager_table";
     private static final String IDMANAGER_DEFAULT = "titan_idmanager";

File: src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStorageManager.java
Patch:
@@ -27,7 +27,7 @@ public class HBaseStorageManager implements StorageManager {
 	private static final Logger log = LoggerFactory.getLogger(HBaseStorageManager.class);
 	
     static final String TABLE_NAME_KEY = "tablename";
-    static final String TABLE_NAME_DEFAULT = "titantest";
+    static final String TABLE_NAME_DEFAULT = "titan";
     
     public static final String LOCAL_LOCK_MEDIATOR_PREFIX_KEY = "local_lock_mediator_prefix";
     public static final String LOCAL_LOCK_MEDIATOR_PREFIX_DEFAULT = "hbase";

File: src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -141,9 +141,9 @@ public boolean containsVertexID(long id, InternalTitanTransaction tx) {
     @Override
 	public long[] indexRetrieval(Object key, TitanKey pt, InternalTitanTransaction tx) {
 		Preconditions.checkArgument(pt.isSimple(),
-					"Currently, only simple properties are supported for hasIndex retrieval!");
+					"Currently, only simple properties are supported for index retrieval!");
 		Preconditions.checkArgument(pt.hasIndex(),
-					"Cannot retrieve for given property type - it does not have an hasIndex.");
+					"Cannot retrieve for given property key - it does not have an index.");
 
 		long[] vertices = null;
 			

File: src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -12,7 +12,7 @@
 public class QueryUtil {
 
 	public static final TitanProperty queryHiddenFunctionalProperty(InternalTitanVertex node, TitanKey propType) {
-		assert ((InternalTitanType)propType).isHidden() : "Expected hidden property type";
+		assert ((InternalTitanType)propType).isHidden() : "Expected hidden property key";
 		assert propType.isFunctional() : "Expected functional property  type";
 		return Iterators.getOnlyElement(
 				new AtomicTitanQuery(node).

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractTitanTx.java
Patch:
@@ -187,7 +187,7 @@ public TitanProperty addProperty(TitanVertex vertex, TitanKey key, Object attrib
 		if (key.isUnique()) {
 			keyedPropertyCreateLock.lock();
 			if (config.doVerifyKeyUniqueness() && getVertex(key, attribute)!=null)
-				throw new InvalidElementException("The specified attribute is already used as a key for the given property type: " + attribute,vertex);
+				throw new InvalidElementException("The specified attribute is already used for the given property key: " + attribute,vertex);
 		}
 			
 		InternalRelation e = edgeFactory.createNewProperty(key, (InternalTitanVertex)vertex, attribute);

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/InternalTitanTransaction.java
Patch:
@@ -119,9 +119,9 @@ public interface InternalTitanTransaction extends TitanTransaction {
     /**
      * Retrieves all ids for vertices which have an incident property of the given type with the specified attribute value
      *
-     * The given property type must have an hasIndex defined for this retrieval to succeed.
+     * The given property key must have an hasIndex defined for this retrieval to succeed.
      *
-     * @param type TitanProperty type for which to retrieve vertices
+     * @param type Property key for which to retrieve vertices
      * @param attribute Attribute value for which to retrieve vertices
      * @return	All ids for vertices which have an incident property of the given type with the specified attribute value
      * @throws	IllegalArgumentException if the property type is not indexed.

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/ExternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -17,7 +17,7 @@ public void cleanUp() {
         StorageSetup.deleteHomeDir();
         ch.startCassandra();
         CassandraThriftStorageManager cmanager = new CassandraThriftStorageManager(CassandraLocalhostHelper.getLocalStorageConfiguration());
-        cmanager.dropKeyspace(CassandraThriftStorageManager.DEFAULT_KEYSPACE);
+        cmanager.dropKeyspace(CassandraThriftStorageManager.KEYSPACE_DEFAULT);
     }
 
     @Override

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/ExternalCassandraThriftKeyColumnValueTest.java
Patch:
@@ -14,7 +14,7 @@ public class ExternalCassandraThriftKeyColumnValueTest extends KeyColumnValueSto
     public void cleanUp() {
         ch.startCassandra();
         CassandraThriftStorageManager cmanager = new CassandraThriftStorageManager(CassandraLocalhostHelper.getLocalStorageConfiguration());
-        cmanager.dropKeyspace(CassandraThriftStorageManager.DEFAULT_KEYSPACE);
+        cmanager.dropKeyspace(CassandraThriftStorageManager.KEYSPACE_DEFAULT);
     }
 
     @Override

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/InternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -20,7 +20,7 @@ public static void startCassandra() {
     public void cleanUp() {
         CassandraThriftStorageManager cmanager =
         		new CassandraThriftStorageManager(CassandraLocalhostHelper.getLocalStorageConfiguration());
-        cmanager.dropKeyspace(CassandraThriftStorageManager.DEFAULT_KEYSPACE);
+        cmanager.dropKeyspace(CassandraThriftStorageManager.KEYSPACE_DEFAULT);
     }
     
     @Override

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/InternalCassandraThriftKeyColumnValueTest.java
Patch:
@@ -18,7 +18,7 @@ public static void startCassandra() {
     public void cleanUp() {
         CassandraThriftStorageManager cmanager =
         		new CassandraThriftStorageManager(CassandraLocalhostHelper.getLocalStorageConfiguration());
-        cmanager.dropKeyspace(CassandraThriftStorageManager.DEFAULT_KEYSPACE);
+        cmanager.dropKeyspace(CassandraThriftStorageManager.KEYSPACE_DEFAULT);
     }
 
     @Override

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/InternalCassandraThriftMultiWriteKeyColumnValueStoreTest.java
Patch:
@@ -17,7 +17,7 @@ public static void startCassandra() {
     public void cleanUp() {
         CassandraThriftStorageManager cmanager =
         		new CassandraThriftStorageManager(CassandraLocalhostHelper.getLocalStorageConfiguration());
-        cmanager.dropKeyspace(CassandraThriftStorageManager.DEFAULT_KEYSPACE);
+        cmanager.dropKeyspace(CassandraThriftStorageManager.KEYSPACE_DEFAULT);
     }
 
     @Override

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/ExternalCassandraGraphConcurrentTest.java
Patch:
@@ -27,9 +27,9 @@ public static void afterClass() throws InterruptedException {
 
     public void cleanUp() {
         CassandraThriftStorageManager.dropKeyspace(
-                CassandraThriftStorageManager.DEFAULT_KEYSPACE,
+                CassandraThriftStorageManager.KEYSPACE_DEFAULT,
                 "127.0.0.1",
-                CassandraThriftStorageManager.DEFAULT_PORT);
+                CassandraThriftStorageManager.PORT_DEFAULT);
     }
 
 }
\ No newline at end of file

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/ExternalCassandraGraphPerformanceTest.java
Patch:
@@ -28,9 +28,9 @@ public static void afterClass() throws InterruptedException {
 
     public void cleanUp() {
         CassandraThriftStorageManager.dropKeyspace(
-                CassandraThriftStorageManager.DEFAULT_KEYSPACE,
+                CassandraThriftStorageManager.KEYSPACE_DEFAULT,
                 "127.0.0.1",
-                CassandraThriftStorageManager.DEFAULT_PORT);
+                CassandraThriftStorageManager.PORT_DEFAULT);
     }
 
 }

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/ExternalCassandraGraphTest.java
Patch:
@@ -27,8 +27,8 @@ public static void afterClass() throws InterruptedException {
 
 	public void cleanUp() {
 		CassandraThriftStorageManager.dropKeyspace(
-                CassandraThriftStorageManager.DEFAULT_KEYSPACE,
+                CassandraThriftStorageManager.KEYSPACE_DEFAULT,
 				"127.0.0.1",
-                CassandraThriftStorageManager.DEFAULT_PORT);
+                CassandraThriftStorageManager.PORT_DEFAULT);
 	}
 }

File: src/test/java/com/thinkaurelius/titan/graphdb/cassandra/InternalCassandraGraphTest.java
Patch:
@@ -21,8 +21,8 @@ public static void beforeClass() {
 
 	public void cleanUp() {
 		CassandraThriftStorageManager.dropKeyspace(
-                CassandraThriftStorageManager.DEFAULT_KEYSPACE,
+                CassandraThriftStorageManager.KEYSPACE_DEFAULT,
 				"127.0.0.1",
-                CassandraThriftStorageManager.DEFAULT_PORT);
+                CassandraThriftStorageManager.PORT_DEFAULT);
 	}
 }

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -44,7 +44,7 @@ public void testMultipleDatabases() {
         close();
         long memoryAfter = MemoryAssess.getMemoryUse();
         log.debug("Memory after: {}",memoryAfter/1024);
-        assertTrue(memoryAfter<10*memoryBaseline);
+        assertTrue(memoryAfter<100*1024*1024);
     }
     
     @Test

File: src/main/java/com/thinkaurelius/titan/graphdb/query/AtomicTitanQuery.java
Patch:
@@ -45,7 +45,7 @@ public class AtomicTitanQuery implements InternalTitanQuery {
 
     public AtomicTitanQuery(InternalTitanTransaction tx) {
         this.tx=tx;
-        if (tx.isClosed()) throw GraphDatabaseException.transactionNotOpenException();
+        if (tx!=null && tx.isClosed()) throw GraphDatabaseException.transactionNotOpenException();
 
         dir = null;
         types = null;

File: src/main/java/com/thinkaurelius/titan/diskstorage/IDAuthority.java
Patch:
@@ -18,6 +18,6 @@ public interface IDAuthority {
      * @param blockSize The size of the partition block. The range of ids (i.e. return[1]-return[0]) is expected to be equal to blockSize - however, it may be smaller. Returned ids must be positive.
      * @return a range of ids for the particular partition
      */
-    public long[] getIDBlock(int partition, int blockSize);
+    public long[] getIDBlock(int partition);
 
 }

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraThriftStorageManager.java
Patch:
@@ -192,8 +192,8 @@ public CassandraThriftStorageManager(Configuration config) {
 	}
 
     @Override
-    public long[] getIDBlock(int partition, int blockSize) {
-        return idmanager.getIDBlock(partition, blockSize);
+    public long[] getIDBlock(int partition) {
+        return idmanager.getIDBlock(partition);
     }
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStorageManager.java
Patch:
@@ -74,8 +74,8 @@ public HBaseStorageManager(org.apache.commons.configuration.Configuration config
 
 
     @Override
-    public long[] getIDBlock(int partition, int blockSize) {
-        return idmanager.getIDBlock(partition,blockSize);
+    public long[] getIDBlock(int partition) {
+        return idmanager.getIDBlock(partition);
     }
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/KeyValueStorageManager.java
Patch:
@@ -23,7 +23,7 @@ public interface KeyValueStorageManager {
      * @param blockSize The size of the partition block.
      * @return a range of ids for the particular partition
      */
-    public long[] getIDBlock(int partition, int blockSize);
+    public long[] getIDBlock(int partition);
 
 
 	/**

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/KeyValueStorageManagerAdapter.java
Patch:
@@ -52,8 +52,8 @@ public OrderedKeyColumnValueStore openDatabase(String name)
 	}
 
     @Override
-    public long[] getIDBlock(int partition, int blockSize) {
-        return manager.getIDBlock(partition,blockSize);
+    public long[] getIDBlock(int partition) {
+        return manager.getIDBlock(partition);
     }
 
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/OrderedKeyColumnValueIDManager.java
Patch:
@@ -58,7 +58,7 @@ public OrderedKeyColumnValueIDManager(OrderedKeyColumnValueStore store, byte[] r
 						GraphDatabaseConfiguration.IDAUTHORITY_RETRY_COUNT_DEFAULT);
 	}
 
-	public long[] getIDBlock(int partition, int unused) {
+	public long[] getIDBlock(int partition) {
 		
 		for (int retry = 0; retry < lockRetryCount; retry++) {
 			

File: src/main/java/com/thinkaurelius/titan/util/system/IOUtils.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.testutil;
+package com.thinkaurelius.titan.util.system;
 
 import java.io.File;
 
@@ -21,7 +21,7 @@ static public boolean deleteDirectory(File path, boolean includeDir) {
 				}
 			}
 		}
-		if (includeDir)	success = path.delete()  && success;;
+		if (includeDir)	success = path.delete()  && success;
         return success;
 	}
 

File: src/main/java/com/thinkaurelius/titan/util/system/Threads.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.util.concurrent;
+package com.thinkaurelius.titan.util.system;
 
 public class Threads {
 

File: src/test/java/com/thinkaurelius/titan/StorageSetup.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan;
 
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
-import com.thinkaurelius.titan.testutil.IOUtils;
+import com.thinkaurelius.titan.util.system.IOUtils;
 import org.apache.commons.configuration.BaseConfiguration;
 import org.apache.commons.configuration.Configuration;
 

File: src/test/java/com/thinkaurelius/titan/blueprints/ExternalCassandraBlueprintsTest.java
Patch:
@@ -28,7 +28,7 @@ public void shutDown() {
 
     @Override
     public Graph generateGraph() {
-        graph = TitanFactory.open(ch.getConfiguration());
+        Graph graph = TitanFactory.open(ch.getConfiguration());
         return graph;
     }
 

File: src/test/java/com/thinkaurelius/titan/blueprints/ExternalHBaseBlueprintsTest.java
Patch:
@@ -27,7 +27,7 @@ public void shutDown() {
 
     @Override
     public Graph generateGraph() {
-        graph = TitanFactory.open(StorageSetup.getHBaseGraphConfiguration());
+        Graph graph = TitanFactory.open(StorageSetup.getHBaseGraphConfiguration());
         return graph;
     }
 

File: src/test/java/com/thinkaurelius/titan/diskstorage/berkeleyje/BerkeleyDBjeKeyColumnValueTest.java
Patch:
@@ -3,6 +3,7 @@
 import com.thinkaurelius.titan.StorageSetup;
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
+import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEHelper;
 import com.thinkaurelius.titan.diskstorage.berkeleydb.je.BerkeleyJEStorageManager;
 import com.thinkaurelius.titan.diskstorage.util.KeyValueStorageManagerAdapter;
 import com.thinkaurelius.titan.diskstorage.util.KeyValueStoreAdapter;
@@ -14,7 +15,7 @@
 public class BerkeleyDBjeKeyColumnValueTest extends KeyColumnValueStoreTest {
 
     public void cleanUp() {
-        StorageSetup.deleteHomeDir();
+        BerkeleyJEHelper.clearEnvironment(StorageSetup.getHomeDirFile());
     }
 
     public StorageManager openStorageManager() {

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java
Patch:
@@ -468,6 +468,7 @@ public void testQuery() {
         
         //Queries
         assertEquals(10,v.query().labels("connect").direction(Direction.OUT).interval("time",3,31).count());
+        assertEquals(33,v.query().labels("connect").direction(Direction.OUT).count());
         assertEquals(10,v.query().inMemory().labels("connect").direction(Direction.OUT).interval("time",3,31).vertexIds().size());
         assertEquals(10,Iterables.size(v.query().inMemory().labels("connect").direction(Direction.OUT).interval("time",3,31).vertices()));
         assertEquals(1,v.query().has("time",1).count());
@@ -493,6 +494,7 @@ public void testQuery() {
 
         //Same queries as above but without memory loading
         assertEquals(10,v.query().labels("connect").direction(Direction.OUT).interval("time",3,31).count());
+        assertEquals(33,v.query().labels("connect").direction(Direction.OUT).count());
         assertEquals(10,v.query().labels("connect").direction(Direction.OUT).interval("time",3,31).vertexIds().size());
         assertEquals(10,Iterables.size(v.query().labels("connect").direction(Direction.OUT).interval("time",3,31).vertices()));
         assertEquals(1,v.query().has("time",1).count());

File: src/main/java/com/thinkaurelius/titan/graphdb/database/StandardTitanGraph.java
Patch:
@@ -457,8 +457,8 @@ private List<Entry> queryForEntries(InternalTitanQuery query, TransactionHandle
                     }
                 }
 			}
-		} else if (query.hasEdgeTypeGroupCondition()) {
-			int groupid = query.getEdgeTypeGroupCondition().getID();
+		} else if (query.hasGroupCondition()) {
+			int groupid = query.getGroupCondition().getID();
             for (int dirID=0;dirID<4;dirID++) {
                 if (dirs[dirID]) {
                     ByteBuffer columnStart = IDHandler.getEdgeTypeGroup(groupid,dirID,idManager);

File: src/main/java/com/thinkaurelius/titan/graphdb/query/AtomicTitanQuery.java
Patch:
@@ -323,13 +323,13 @@ public TitanType getTypeCondition() {
 
 
     @Override
-    public TypeGroup getEdgeTypeGroupCondition() {
-        if (!hasEdgeTypeGroupCondition()) throw new IllegalStateException("This query does not have a edge type group condition!");
+    public TypeGroup getGroupCondition() {
+        if (!hasGroupCondition()) throw new IllegalStateException("This query does not have a edge type group condition!");
         return group;
     }
 
     @Override
-    public boolean hasEdgeTypeGroupCondition() {
+    public boolean hasGroupCondition() {
         return group!=null;
     }
 

File: src/main/java/com/thinkaurelius/titan/graphdb/query/InternalTitanQuery.java
Patch:
@@ -25,9 +25,9 @@ public interface InternalTitanQuery extends TitanQuery {
 
     TitanType getTypeCondition();
 
-    boolean hasEdgeTypeGroupCondition();
+    boolean hasGroupCondition();
 
-    TypeGroup getEdgeTypeGroupCondition();
+    TypeGroup getGroupCondition();
 
     boolean hasDirectionCondition();
 

File: src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -49,7 +49,7 @@ public static boolean queryCoveredByDiskIndexes(InternalTitanQuery query) {
     
     public static boolean hasFirstKeyConstraint(InternalTitanQuery query) {
         if (!query.hasConstraints()) return false;
-        if (!query.hasEdgeTypeGroupCondition()) return false;
+        if (!query.hasEdgeTypeCondition()) return false;
         String[] keysig = ((InternalTitanType)query.getTypeCondition()).getDefinition().getKeySignature();
         return query.getConstraints().containsKey(keysig[0]);
     }

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/VertexUtil.java
Patch:
@@ -105,8 +105,8 @@ public static final Iterable<InternalRelation> getQuerySpecificIterable(Adjacenc
         if (query.hasEdgeTypeCondition()) {
             assert query.getTypeCondition()!=null;
             return edges.getEdges(query.getTypeCondition());
-        } else if (query.hasEdgeTypeGroupCondition()) {
-            return edges.getEdges(query.getEdgeTypeGroupCondition());
+        } else if (query.hasGroupCondition()) {
+            return edges.getEdges(query.getGroupCondition());
         } else {
             return edges.getEdges();
         }

File: src/test/java/com/thinkaurelius/titan/TitanBenchmark.java
Patch:
@@ -22,8 +22,8 @@ public class TitanBenchmark {
     
     
     public static void main(String[] args) throws IOException {
-        Preconditions.checkArgument(args.length==2);
-        final int batchSize = 10000;
+        Preconditions.checkArgument(args.length==3);
+        final int batchSize = Integer.parseInt(args[2]);
         final int maxTime = 1000000;
 
         String configFile = args[0];

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/ExternalCassandraLockKeyColumnValueStoreTest.java
Patch:
@@ -8,8 +8,7 @@
 import com.thinkaurelius.titan.diskstorage.StorageManager;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 
-public class CassandraLockKeyColumnValueStoreTest 
-	extends LockKeyColumnValueStoreTest {
+public class ExternalCassandraLockKeyColumnValueStoreTest extends LockKeyColumnValueStoreTest {
 
     public static CassandraLocalhostHelper ch = new CassandraLocalhostHelper("127.0.0.1");
 

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/ExternalCassandraThriftKeyColumnValueTest.java
Patch:
@@ -5,8 +5,7 @@
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
 
-
-public class CassandraThriftKeyColumnValueTest extends KeyColumnValueStoreTest {
+public class ExternalCassandraThriftKeyColumnValueTest extends KeyColumnValueStoreTest {
 
 
 	public static CassandraLocalhostHelper ch = new CassandraLocalhostHelper("127.0.0.1");
@@ -28,5 +27,4 @@ public void cassandraTearDown() {
 		ch.stopCassandra();
 	}
 	
-
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/query/QueryUtil.java
Patch:
@@ -30,7 +30,7 @@ public static final TitanProperty queryHiddenFunctionalProperty(InternalTitanVer
      */
     public static boolean queryCoveredByDiskIndexes(InternalTitanQuery query) {
         if (!query.hasConstraints()) return true;
-        if (!query.hasEdgeTypeGroupCondition()) return false;
+        if (!query.hasEdgeTypeCondition()) return false;
         String[] keysig = ((InternalTitanType)query.getTypeCondition()).getDefinition().getKeySignature();
         Map<String,Object> constraints = query.getConstraints();
         int num = 0;

File: src/main/java/com/thinkaurelius/titan/graphdb/query/VertexLongList.java
Patch:
@@ -69,7 +69,7 @@ public void addAll(VertexList nodelist) {
         Preconditions.checkArgument(nodelist instanceof VertexLongList,"Only supporting union of identical lists.");
         VertexLongList other = (VertexLongList)nodelist;
         sorted=false;
-        vertices.addAllOfFromTo(other.vertices,0,other.vertices.size());
+        vertices.addAllOfFromTo(other.vertices,0,other.vertices.size()-1);
     }
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraTransaction.java
Patch:
@@ -4,9 +4,8 @@
 
 public class CassandraTransaction extends LockingTransaction {
 
-	CassandraTransaction(CassandraThriftStorageManager sm, byte[] rid,
-			int lockRetryCount, long lockWaitMS, long lockExpireMS) {
-		super(sm, rid, lockRetryCount, lockWaitMS, lockExpireMS);
+	CassandraTransaction() {
+		super();
 	}
 
 }

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/ConfigHelper.java
Patch:
@@ -64,7 +64,7 @@ public static byte[] getRid(Configuration config) {
 				throw new RuntimeException(e);
 			}
 			
-			log.debug("Set rid from hex string: 0x{}" + ridText);
+			log.debug("Set rid from hex string: 0x{}", ridText);
 		} else {
 			final byte[] endBytes;
 			
@@ -95,7 +95,7 @@ public static byte[] getRid(Configuration config) {
 			System.arraycopy(endBytes, 0, tentativeRid, addrBytes.length, endBytes.length);
 			
 			if (log.isDebugEnabled()) {
-				log.debug("Set rid: 0x{}" + new String(Hex.encodeHex(tentativeRid)));
+				log.debug("Set rid: 0x{}", new String(Hex.encodeHex(tentativeRid)));
 			}
 		}
 		

File: src/test/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraThriftKeyColumnValueTest.java
Patch:
@@ -1,9 +1,9 @@
 package com.thinkaurelius.titan.diskstorage.cassandra;
 
+import org.junit.After;
+
 import com.thinkaurelius.titan.diskstorage.KeyColumnValueStoreTest;
 import com.thinkaurelius.titan.diskstorage.StorageManager;
-import org.junit.After;
-import org.junit.Before;
 
 
 public class CassandraThriftKeyColumnValueTest extends KeyColumnValueStoreTest {

File: src/main/java/com/thinkaurelius/titan/core/TitanFactory.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.core;
 
+import com.thinkaurelius.titan.graphdb.blueprints.TitanInMemoryBlueprintsGraph;
 import com.thinkaurelius.titan.graphdb.configuration.GraphDatabaseConfiguration;
 import com.thinkaurelius.titan.graphdb.database.StandardTitanGraph;
 import com.thinkaurelius.titan.graphdb.transaction.InMemoryTitanGraph;
@@ -24,7 +25,7 @@ public class TitanFactory {
      * @see TitanGraph
      */
     public static TitanGraph openInMemoryGraph() {
-        return new InMemoryTitanGraph(new TransactionConfig(null,true));
+        return new TitanInMemoryBlueprintsGraph();
     }
 
 

File: src/main/java/com/thinkaurelius/titan/core/TitanGraph.java
Patch:
@@ -42,7 +42,9 @@ public interface TitanGraph extends Graph, KeyIndexableGraph, ThreadedTransactio
 	  * 
 	  * @throws GraphStorageException if closing the graph database caused errors in the storage backend
 	  */
-	 public void shutdown() throws GraphStorageException;
+	public void shutdown() throws GraphStorageException;
+
+    public boolean isOpen();
 
 	
 }

File: src/main/java/com/thinkaurelius/titan/core/TitanTransaction.java
Patch:
@@ -3,6 +3,7 @@
 
 import com.thinkaurelius.titan.graphdb.transaction.TransactionConfig;
 import com.tinkerpop.blueprints.Edge;
+import com.tinkerpop.blueprints.KeyIndexableGraph;
 import com.tinkerpop.blueprints.TransactionalGraph;
 import com.tinkerpop.blueprints.Vertex;
 
@@ -30,7 +31,7 @@
  * 
  *
  */
-public interface TitanTransaction extends TransactionalGraph {
+public interface TitanTransaction extends TransactionalGraph, KeyIndexableGraph {
 
 	/***
 	 * Creates a new node in the graph.

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -121,9 +121,9 @@ public class GraphDatabaseConfiguration {
     private static final String READ_ONLY_KEY = "readonly";
     private static final boolean READ_ONLY_DEFAULT = false;
     private static final String FLUSH_IDS_KEY = "flushids";
-    private static final boolean FLUSH_IDS_DEFAULT = false;
+    private static final boolean FLUSH_IDS_DEFAULT = true;
     private static final String AUTO_TYPE_KEY = "autotype";
-    private static final String AUTO_TYPE_DEFAULT = "";
+    private static final String AUTO_TYPE_DEFAULT = "blueprints";
     private static final String BATCH_LOADING_KEY = "batch";
     private static final boolean BATCH_LOADING_DEFAULT = false;
     

File: src/main/java/com/thinkaurelius/titan/graphdb/edges/persist/PersistLabeledBinaryTitanEdge.java
Patch:
@@ -89,8 +89,6 @@ public long getID() {
 		return entity.getID();
 	}
 
-
-
 	@Override
 	public boolean hasID() {
 		return entity.hasID();

File: src/main/java/com/thinkaurelius/titan/graphdb/edges/persist/PersistSimpleBinaryTitanEdge.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.graphdb.edges.SimpleBinaryTitanEdge;
 import com.thinkaurelius.titan.graphdb.entitystatus.BasicElement;
 import com.thinkaurelius.titan.graphdb.vertices.InternalTitanVertex;
-import com.thinkaurelius.titan.graphdb.vertices.NodeUtil;
+import com.thinkaurelius.titan.graphdb.vertices.VertexUtil;
 
 public class PersistSimpleBinaryTitanEdge extends SimpleBinaryTitanEdge {
 
@@ -25,7 +25,7 @@ public PersistSimpleBinaryTitanEdge(TitanLabel type,
 
 	@Override
 	public int hashCode() {
-		if (hasID()) return NodeUtil.getIDHashCode(this);
+		if (hasID()) return VertexUtil.getIDHashCode(this);
 		else return super.hashCode();
 	}
 
@@ -35,7 +35,7 @@ public boolean equals(Object oth) {
 		else if (!(oth instanceof InternalRelation)) return false;
 		InternalRelation other = (InternalRelation)oth;
 		if (hasID() || other.hasID()) {
-			if (hasID() && other.hasID()) return NodeUtil.equalIDs(this, other);
+			if (hasID() && other.hasID()) return VertexUtil.equalIDs(this, other);
 			else return false;
 		}
 		return super.equals(other);

File: src/main/java/com/thinkaurelius/titan/graphdb/edges/persist/PersistSimpleProperty.java
Patch:
@@ -5,7 +5,7 @@
 import com.thinkaurelius.titan.graphdb.edges.SimpleProperty;
 import com.thinkaurelius.titan.graphdb.entitystatus.BasicElement;
 import com.thinkaurelius.titan.graphdb.vertices.InternalTitanVertex;
-import com.thinkaurelius.titan.graphdb.vertices.NodeUtil;
+import com.thinkaurelius.titan.graphdb.vertices.VertexUtil;
 
 public class PersistSimpleProperty extends SimpleProperty {
 
@@ -23,7 +23,7 @@ public PersistSimpleProperty(TitanKey type, InternalTitanVertex node, Object att
 	
 	@Override
 	public int hashCode() {
-		if (hasID()) return NodeUtil.getIDHashCode(this);
+		if (hasID()) return VertexUtil.getIDHashCode(this);
 		else return super.hashCode();
 	}
 
@@ -33,7 +33,7 @@ public boolean equals(Object oth) {
 		else if (!(oth instanceof InternalRelation)) return false;
 		InternalRelation other = (InternalRelation)oth;
 		if (hasID() || other.hasID()) {
-			if (hasID() && other.hasID()) return NodeUtil.equalIDs(this, other);
+			if (hasID() && other.hasID()) return VertexUtil.equalIDs(this, other);
 			else return false;
 		}
 		return super.equals(other);

File: src/main/java/com/thinkaurelius/titan/graphdb/edgetypes/manager/InMemoryEdgeTypeManager.java
Patch:
@@ -48,7 +48,7 @@ public InternalTitanType getEdgeType(long id, InternalTitanTransaction tx) {
 
 	@Override
 	public InternalTitanType getEdgeType(String name, InternalTitanTransaction tx) {
-		throw new UnsupportedOperationException("Not supported for InMemory Transactions");
+		return null;
 	}
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/graphdb/edgetypes/system/SystemType.java
Patch:
@@ -37,7 +37,6 @@ public boolean isHidden() {
 		return true;
 	}
 
-
 	@Override
 	public boolean isModifiable() {
 		return false;

File: src/main/java/com/thinkaurelius/titan/graphdb/entitystatus/LocatedElement.java
Patch:
@@ -43,7 +43,7 @@ public boolean hasID() {
 	public void setID(long id) {
 		Preconditions.checkArgument(isNew());
 		Preconditions.checkArgument(id!=NoID,"Illegal id: " + id);
-		if (hasID()) throw new IllegalStateException("The entity has already been assigned an ID!");
+		if (hasID()) throw new IllegalStateException("The entity has already been assigned an ID: " + getID());
 		this.id = id;
 	}
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractTitanTx.java
Patch:
@@ -97,7 +97,7 @@ public void registerNewEntity(InternalTitanVertex n) {
         assert (!(n instanceof InternalRelation) || !((InternalRelation)n).isInline());
         assert n.isNew();
         assert !n.hasID();
-        
+
         boolean isNode = !(n instanceof InternalRelation);
         if (config.assignIDsImmediately()) {
             graphdb.assignID(n);           
@@ -447,7 +447,7 @@ public Iterable<TitanVertex> getVertices(TitanKey key, Object attribute) {
 	 */	
 	
 	private void close() {
-         vertexCache.close(); vertexCache =null;
+        vertexCache.close(); vertexCache =null;
 		keyIndex.clear(); keyIndex=null;
 		isOpen=false;
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/LoadedEmptyTitanVertex.java
Patch:
@@ -196,7 +196,7 @@ public long getID() {
 
     @Override
     public Object getId() {
-        throw new UnsupportedOperationException(errorName + " don't have an ID!");
+        return Long.valueOf(getID());
     }
 
 	@Override

File: src/test/java/com/thinkaurelius/titan/StorageSetup.java
Patch:
@@ -30,7 +30,7 @@ public static final void deleteHomeDir() {
 		if (!homeDirFile.exists())
 			homeDirFile.mkdirs();
 		boolean success = IOUtils.deleteFromDirectory(homeDirFile);
-        if (!success) System.err.println("Could not remove " + homeDirFile);
+        if (!success) throw new IllegalStateException("Could not remove " + homeDirFile) ;
 	}
 
     public static Configuration getLocalStorageConfiguration() {

File: src/test/java/com/thinkaurelius/titan/blueprints/TitanBenchmarkSuite.java
Patch:
@@ -50,9 +50,9 @@ public void testTitanGraph() throws Exception {
             double currentTime = this.stopWatch();
             totalTime = totalTime + currentTime;
             BaseTest.printPerformance(graph.toString(), counter, "TinkerGraph elements touched", currentTime);
-            graph.shutdown();
         }
         BaseTest.printPerformance("TinkerGraph", 1, "TinkerGraph experiment average", totalTime / (double) TOTAL_RUNS);
+        graph.shutdown();
     }
 
 }

File: src/test/java/com/thinkaurelius/titan/blueprints/TransactionalTitanGraphTestSuite.java
Patch:
@@ -13,10 +13,10 @@
  * (c) Matthias Broecheler (me@matthiasb.com)
  */
 
-public class TransactionalGraphTestSuite  extends TestSuite {
+public class TransactionalTitanGraphTestSuite extends TestSuite {
 
 
-    public TransactionalGraphTestSuite(final GraphTest graphTest) {
+    public TransactionalTitanGraphTestSuite(final GraphTest graphTest) {
         super(graphTest);
     }
 

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphConcurrentTest.java
Patch:
@@ -52,7 +52,7 @@ public void setUp() throws Exception {
 		for (int i = 0; i < rels.length; i++) {
 			rels[i] = makeRelationshipType("rel" + i);
 		}
-		TitanKey id = makeIDPropertyType("id");
+		TitanKey id = makeIDPropertyType("uid");
 		TitanVertex nodes[] = new TitanVertex[NODE_COUNT];
 		for (int i=0;i<NODE_COUNT;i++) {
 			nodes[i]=tx.addVertex();
@@ -92,7 +92,7 @@ public void tearDown() throws Exception {
 	 */
 	@Test
 	public void concurrentReadsOnSingleTransaction() throws Exception {
-		TitanKey id = tx.getPropertyKey("id");
+		TitanKey id = tx.getPropertyKey("uid");
 		
 		// Tail many concurrent readers on a single transaction
 		CountDownLatch startLatch = new CountDownLatch(TASK_COUNT);
@@ -119,7 +119,7 @@ public void concurrentReadsOnSingleTransaction() throws Exception {
 	 */
 	@Test
 	public void concurrentReadWriteOnSingleTransaction() throws Exception {
-		TitanKey id = tx.getPropertyKey("id");
+		TitanKey id = tx.getPropertyKey("uid");
 		
 		Runnable propMaker =
 			new RandomPropertyMaker(tx, NODE_COUNT, id,

File: src/test/java/com/thinkaurelius/titan/graphdb/TitanGraphPerformanceTest.java
Patch:
@@ -203,7 +203,7 @@ public String toString() {
 		@Override
 		protected void doLoad() {
 			TitanKey weight = makeWeightPropertyType("weight");
-			TitanKey id = makeIDPropertyType("id");
+			TitanKey id = makeIDPropertyType("uid");
 			TitanLabel knows = makeLabeledRelationshipType("knows",id,weight);
 			TitanKey name = makeStringPropertyType("name");
 			

File: src/test/java/com/thinkaurelius/titan/testutil/MemoryAssess.java
Patch:
@@ -17,7 +17,7 @@ public long end() {
 	
 	  private static long fSLEEP_INTERVAL = 100;
 
-	  private static long getMemoryUse(){
+	  public static long getMemoryUse(){
 	    putOutTheGarbage();
 	    long totalMemory = Runtime.getRuntime().totalMemory();
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraThriftStorageManager.java
Patch:
@@ -126,7 +126,7 @@ public class CassandraThriftStorageManager implements StorageManager {
 	
 	public CassandraThriftStorageManager(Configuration config) {
 		
-		this.rid = ConfigHelper.getRid(config, this);
+		this.rid = ConfigHelper.getRid(config);
 		
 		this.keyspace = config.getString(PROP_KEYSPACE,DEFAULT_KEYSPACE);
 		

File: src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStorageManager.java
Patch:
@@ -37,7 +37,7 @@ public class HBaseStorageManager implements StorageManager {
     private final byte[] rid;
 	
     public HBaseStorageManager(org.apache.commons.configuration.Configuration config) {
-    	this.rid = ConfigHelper.getRid(config, this);
+    	this.rid = ConfigHelper.getRid(config);
     	
         this.tableName = config.getString(TABLE_NAME_KEY,TABLE_NAME_DEFAULT);
         

File: src/main/java/com/thinkaurelius/titan/core/TitanRelation.java
Patch:
@@ -110,7 +110,7 @@ public interface TitanRelation extends TitanVertex {
 	 * @param vertex TitanVertex to check the loop condition for
 	 * @return true, if this edge is a loop with respect to the given node, else false.
 	 */
-	boolean isSelfLoop(TitanVertex vertex);
+	boolean isSelfLoop();
 
 	/**
 	 * Checks whether this edge is a property.

File: src/main/java/com/thinkaurelius/titan/graphdb/edges/SimpleBinaryTitanEdge.java
Patch:
@@ -68,9 +68,9 @@ public InternalTitanVertex getVertex(int pos) {
 	}
 
 	@Override
-	public boolean isSelfLoop(TitanVertex vertex) {
-		if (!start.equals(end)) return false;
-		else return vertex ==null || vertex.equals(start);
+	public boolean isSelfLoop() {
+		if (start.equals(end)) return true;
+		else return false;
 	}
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/graphdb/edges/SimpleProperty.java
Patch:
@@ -51,7 +51,7 @@ public InternalTitanVertex getVertex(int pos) {
 	}
 
 	@Override
-	public boolean isSelfLoop(TitanVertex vertex) {
+	public boolean isSelfLoop() {
 		return false;
 	}
 

File: src/main/java/com/thinkaurelius/titan/graphdb/edges/factory/EdgeFactoryUtil.java
Patch:
@@ -29,7 +29,7 @@ public static final void connectEdge(InternalRelation edge, boolean isNew, Inter
 		
 		int notloaded=0,loaded=0;
         int arity = edge.getArity();
-        if (edge.isUnidirected() || edge.isProperty() || edge.isSelfLoop(null)) {
+        if (edge.isUnidirected() || edge.isProperty() || edge.isSelfLoop()) {
             arity=1;
         }
         for (int i=0;i<arity;i++) {

File: src/main/java/com/thinkaurelius/titan/graphdb/edgetypes/StandardTypeMaker.java
Patch:
@@ -71,8 +71,8 @@ private TitanType[] checkSignature(List<TitanType> sig) {
 	
 	@Override
 	public TitanKey makePropertyKey() {
-		checkGeneralArguments();
         if (category==null) category = EdgeCategory.Simple;
+        checkGeneralArguments();
 		if (directionality!=Directionality.Directed)
 			throw new IllegalArgumentException("TitanProperty types must be directed!");
 		if (category!=EdgeCategory.Simple)
@@ -88,8 +88,8 @@ visibility, isFunctional, checkSignature(keysig), checkSignature(compactsig),
 
 	@Override
 	public TitanLabel makeEdgeLabel() {
-		checkGeneralArguments();
         if (category==null) category = EdgeCategory.HasProperties;
+        checkGeneralArguments();
 		if (hasIndex)
 			throw new IllegalArgumentException("Cannot specify hasIndex for relationship type.");
 		return etManager.createRelationshipType(tx, name, category, directionality, 

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractTitanTx.java
Patch:
@@ -195,7 +195,7 @@ public TitanProperty addProperty(TitanVertex vertex, String key, Object attribut
 
 	@Override
 	public TitanEdge addEdge(TitanVertex outVertex, TitanVertex inVertex, TitanLabel label) {
-		InternalRelation e = edgeFactory.createNewRelationship(label, (InternalTitanVertex)outVertex, (InternalTitanVertex)label);
+		InternalRelation e = edgeFactory.createNewRelationship(label, (InternalTitanVertex)outVertex, (InternalTitanVertex)inVertex);
 		addedRelation(e);
 		return (TitanEdge)e;
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/NodeUtil.java
Patch:
@@ -85,7 +85,7 @@ public static final Iterable<InternalRelation> filterLoopEdges(Iterable<Internal
 
 			@Override
 			public boolean apply(InternalRelation edge) {
-				if (edge.isSelfLoop(v)) return false;
+				if (edge.isSelfLoop()) return false;
 				else return true;
 			}}
 		);

File: src/test/java/com/thinkaurelius/titan/graphdb/test/AbstractGraphDBTest.java
Patch:
@@ -201,7 +201,7 @@ public void createAndRetrieveSimple() {
 		e=n3.addEdge(knows, n1);
 		n3.addEdge(connect, n3);
 		e.addProperty(id, 111);
-		assertEquals(3,Iterables.size(n3.getEdges()));
+		assertEquals(4,Iterables.size(n3.getEdges()));
 		
 		clopen();
 		
@@ -249,7 +249,7 @@ public void createAndRetrieveSimple() {
 		e=Iterables.getOnlyElement(n3.getTitanEdges(Direction.OUT,tx.getEdgeLabel("knows")));
 		assertEquals(111,e.getProperty(id));
 		
-		assertEquals(3,Iterables.size(n3.getEdges()));
+		assertEquals(4,Iterables.size(n3.getEdges()));
 				
 		//Delete Edges, create new ones		
 		e=Iterables.getOnlyElement(n2.getTitanEdges(Direction.OUT,tx.getEdgeLabel("knows")));

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyJEStorageManager.java
Patch:
@@ -142,7 +142,7 @@ public void close() throws GraphStorageException {
 		if (environment!=null) {
             BerkeleyKeyValueStore idmanager = stores.get(idManagerTableName);
             if (idmanager!=null) idmanager.close();
-			if (!stores.isEmpty()) throw new GraphStorageException("Cannot close manager since some databases are still open");
+			if (!stores.isEmpty()) throw new GraphStorageException("Cannot shutdown manager since some databases are still open");
 			try {
 				environment.close();
 			} catch (DatabaseException e) {

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyKeyValueStore.java
Patch:
@@ -119,7 +119,7 @@ public List<KeyValueEntry> getSlice(ByteBuffer keyStart, ByteBuffer keyEnd,
 		List<KeyValueEntry> result;
 		try {
 			//log.debug("Sta: {}",ByteBufferUtil.toBitString(keyStart, " "));
-			//log.debug("End: {}",ByteBufferUtil.toBitString(keyEnd, " "));
+			//log.debug("Head: {}",ByteBufferUtil.toBitString(keyEnd, " "));
 			
 			DatabaseEntry foundKey = getDataEntry(keyStart);
 			DatabaseEntry foundData = new DatabaseEntry();
@@ -208,7 +208,7 @@ public void delete(List<ByteBuffer> keys, TransactionHandle txh) {
 			for (ByteBuffer entry : keys) {
 				OperationStatus status = db.delete(tx, getDataEntry(entry));
 				if (status!=OperationStatus.SUCCESS) {
-					throw new GraphStorageException("Could not delete: " + status);
+					throw new GraphStorageException("Could not remove: " + status);
 				}
 			}
 			

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/thriftpool/CTConnectionPool.java
Patch:
@@ -26,7 +26,7 @@ public class CTConnectionPool {
 	
 	/*
 	 * We don't want to risk creating a pool multiple times, since
-	 * each one must be explicitly close()d.  Synchronize the method
+	 * each one must be explicitly shutdown()d.  Synchronize the method
 	 * for now to guarantee that only one pool is ever created for a
 	 * particular PoolKey.
 	 */

File: src/main/java/com/thinkaurelius/titan/diskstorage/hbase/HBaseStorageManager.java
Patch:
@@ -129,7 +129,7 @@ public void deleteAll() {
                      * Swallow exception.  Disabling a table typically throws
                      * an exception because the table doesn't exist or is
                      * already disabled.  If there's a serious problem
-                     * interacting with HBase, then the following delete
+                     * interacting with HBase, then the following remove
                      * statement will generate an appropriate exception
                      * (which would propagate up as a RuntimeException).
                      */

File: src/main/java/com/thinkaurelius/titan/graphdb/adjacencylist/AdjacencyListFactory.java
Patch:
@@ -1,11 +1,11 @@
 package com.thinkaurelius.titan.graphdb.adjacencylist;
 
-import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
+import com.thinkaurelius.titan.graphdb.edges.InternalRelation;
 
 public interface AdjacencyListFactory {
 	
 	public AdjacencyList emptyList();
 	
-	public AdjacencyList extend(AdjacencyList list, InternalEdge newEdge, ModificationStatus status);
+	public AdjacencyList extend(AdjacencyList list, InternalRelation newEdge, ModificationStatus status);
 	
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/adjacencylist/ArrayAdjListFactory.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.adjacencylist;
 
-import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
+import com.thinkaurelius.titan.graphdb.edges.InternalRelation;
 
 public class ArrayAdjListFactory implements AdjacencyListFactory {
 
@@ -31,7 +31,7 @@ public AdjacencyList emptyList() {
 	}
 
 	@Override
-	public AdjacencyList extend(AdjacencyList list, InternalEdge newEdge, ModificationStatus status) {
+	public AdjacencyList extend(AdjacencyList list, InternalRelation newEdge, ModificationStatus status) {
 		AdjacencyList newadj = null;
 		switch(extension) {
 		case Typed: 

File: src/main/java/com/thinkaurelius/titan/graphdb/adjacencylist/SetAdjListFactory.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.adjacencylist;
 
-import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
+import com.thinkaurelius.titan.graphdb.edges.InternalRelation;
 
 public class SetAdjListFactory implements AdjacencyListFactory {
 
@@ -21,7 +21,7 @@ public AdjacencyList emptyList() {
 	}
 
 	@Override
-	public AdjacencyList extend(AdjacencyList list, InternalEdge newEdge,
+	public AdjacencyList extend(AdjacencyList list, InternalRelation newEdge,
 			ModificationStatus status) {
 		throw new UnsupportedOperationException("There is no extension for set adjacency lists!");
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/adjacencylist/TypedAdjListFactory.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.adjacencylist;
 
-import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
+import com.thinkaurelius.titan.graphdb.edges.InternalRelation;
 
 public class TypedAdjListFactory implements AdjacencyListFactory {
 
@@ -18,7 +18,7 @@ public AdjacencyList emptyList() {
 	}
 
 	@Override
-	public AdjacencyList extend(AdjacencyList list, InternalEdge newEdge,
+	public AdjacencyList extend(AdjacencyList list, InternalRelation newEdge,
 			ModificationStatus status) {
 		throw new UnsupportedOperationException("There is no extension for typed adjacency lists!");
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/configuration/GraphDatabaseConfiguration.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.*;
 
 /**
- * Provides functionality to configure a {@link com.thinkaurelius.titan.core.GraphDatabase} instance.
+ * Provides functionality to configure a {@link com.thinkaurelius.titan.core.TitanGraph} INSTANCE.
  *
  * 
  * A graph database configuration is uniquely associated with a graph database and must not be used for multiple

File: src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/NodeIDAssigner.java
Patch:
@@ -1,11 +1,11 @@
 package com.thinkaurelius.titan.graphdb.database.idassigner;
 
 import com.thinkaurelius.titan.graphdb.idmanagement.IDManager;
-import com.thinkaurelius.titan.graphdb.vertices.InternalNode;
+import com.thinkaurelius.titan.graphdb.vertices.InternalTitanVertex;
 
 public interface NodeIDAssigner {
 
-	public long getNewID(InternalNode node);
+	public long getNewID(InternalTitanVertex node);
 
     public long getNewID(IDManager.IDType type, long groupid);
     

File: src/main/java/com/thinkaurelius/titan/graphdb/database/util/LimitTracker.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.database.util;
 
-import com.thinkaurelius.titan.graphdb.edgequery.InternalEdgeQuery;
+import com.thinkaurelius.titan.graphdb.edgequery.InternalTitanQuery;
 
 public class LimitTracker {
 
 	private static final int retrievalLimit = 2000000000; //2 billion
 	
 	private int remainingLimit;
 
-	public LimitTracker(InternalEdgeQuery query) {
+	public LimitTracker(InternalTitanQuery query) {
 		remainingLimit = (int)Math.min(retrievalLimit, query.getLimit());
 	}
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/edgetypes/PropertyTypeDefinition.java
Patch:
@@ -6,6 +6,6 @@ public interface PropertyTypeDefinition extends EdgeTypeDefinition {
 	
 	public boolean hasIndex();
 	
-	public boolean isKeyed();
+	public boolean isUnique();
 	
 }

File: src/main/java/com/thinkaurelius/titan/graphdb/edgetypes/manager/EdgeTypeManagerUtil.java
Patch:
@@ -1,10 +1,10 @@
 package com.thinkaurelius.titan.graphdb.edgetypes.manager;
 
-import com.thinkaurelius.titan.core.EdgeType;
+import com.thinkaurelius.titan.core.TitanType;
 
 public class EdgeTypeManagerUtil {
 
-	public static final String[] convertSignature(EdgeType[] sig) {
+	public static final String[] convertSignature(TitanType[] sig) {
 		String[] res = new String[sig.length];
 		for (int i=0;i<sig.length;i++) {
 			res[i]=sig[i].getName();

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/DefaultLoadingStatus.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.loadingstatus;
 
-import com.thinkaurelius.titan.graphdb.edgequery.InternalEdgeQuery;
+import com.thinkaurelius.titan.graphdb.edgequery.InternalTitanQuery;
 
 public class DefaultLoadingStatus implements LoadingStatus {
 	
@@ -11,12 +11,12 @@ public class DefaultLoadingStatus implements LoadingStatus {
 	}
 
 	@Override
-	public boolean hasLoadedEdges(InternalEdgeQuery query) {
+	public boolean hasLoadedEdges(InternalTitanQuery query) {
 		return defaultStatus;
 	}
 
 	@Override
-	public LoadingStatus loadedEdges(InternalEdgeQuery query) {
+	public LoadingStatus loadedEdges(InternalTitanQuery query) {
 		if (!defaultStatus) {
 			BasicLoadingStatus update = new BasicLoadingStatus();
 			update.loadedEdges(query);

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/LoadingStatus.java
Patch:
@@ -1,14 +1,14 @@
 package com.thinkaurelius.titan.graphdb.loadingstatus;
 
-import com.thinkaurelius.titan.graphdb.edgequery.InternalEdgeQuery;
+import com.thinkaurelius.titan.graphdb.edgequery.InternalTitanQuery;
 
 public interface LoadingStatus {
 
 	public static final LoadingStatus AllLoaded = new DefaultLoadingStatus(true);
 	public static final LoadingStatus NothingLoaded = new DefaultLoadingStatus(false);
 	
-	LoadingStatus loadedEdges(InternalEdgeQuery query);
+	LoadingStatus loadedEdges(InternalTitanQuery query);
 	
-	boolean hasLoadedEdges(InternalEdgeQuery query);
+	boolean hasLoadedEdges(InternalTitanQuery query);
 	
 }

File: src/main/java/com/thinkaurelius/titan/util/datastructures/BitMap.java
Patch:
@@ -1,4 +1,4 @@
-package com.thinkaurelius.titan.graphdb.util;
+package com.thinkaurelius.titan.util.datastructures;
 
 public class BitMap {
 

File: src/main/java/com/thinkaurelius/titan/util/interval/AtomicInterval.java
Patch:
@@ -20,14 +20,14 @@ public interface AtomicInterval<V> {
 	/**
 	 * Returns the start point of the interval
 	 * 
-	 * @return Start point of the interval
+	 * @return Tail point of the interval
 	 */
 	public V getStartPoint();
 	
 	/**
 	 * Returns the end point of the interval
 	 * 
-	 * @return End point of the interval
+	 * @return Head point of the interval
 	 */
 	public V getEndPoint();
 	

File: src/main/java/com/thinkaurelius/titan/util/interval/IntervalUtil.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.util.interval;
 
-import com.tinkerpop.blueprints.pgm.Query;
+import com.tinkerpop.blueprints.Query;
 
 /**
  * (c) Matthias Broecheler (me@matthiasb.com)

File: src/test/java/com/thinkaurelius/titan/DiskgraphTest.java
Patch:
@@ -28,7 +28,7 @@ public static final void deleteHomeDir() {
 		if (!homeDirFile.exists())
 			homeDirFile.mkdirs();
 		boolean success = IOUtils.deleteFromDirectory(homeDirFile);
-        if (!success) System.err.println("Could not delete " + homeDir);
+        if (!success) System.err.println("Could not remove " + homeDir);
 	}
 
     public static Configuration getDirectoryStorageConfiguration() {

File: src/test/java/com/thinkaurelius/titan/TestBed.java
Patch:
@@ -20,6 +20,7 @@ public static String toBinary(int b) {
 		while (res.length()<32) res = "0" + res;
 		return res;
 		
+
 	}
 	
 

File: src/test/java/com/thinkaurelius/titan/diskstorage/test/CassandraNativeLocalhostHelper.java
Patch:
@@ -87,7 +87,7 @@ public void restoreSystemProperties() {
 //	}
 	
 	public void stop() {
-//		manager.close();
+//		manager.shutdown();
 		restoreSystemProperties();
 	}
 }

File: src/test/java/com/thinkaurelius/titan/diskstorage/test/KeyColumnValueStoreTest.java
Patch:
@@ -303,8 +303,8 @@ public void insertingGettingAndDeletingSimpleDataWorks() throws Exception {
 //		
 //		txn.commit();
 //		
-//		store.close();
-//		manager.close();
+//		store.shutdown();
+//		manager.shutdown();
 //	}
 
 	@Test

File: src/test/java/com/thinkaurelius/titan/graphdb/test/CassandraConcurrentGraphDBTest.java
Patch:
@@ -1,5 +1,6 @@
 package com.thinkaurelius.titan.graphdb.test;
 
+import com.thinkaurelius.titan.core.TransactionConfig;
 import com.thinkaurelius.titan.diskstorage.cassandra.CassandraThriftStorageManager;
 import com.thinkaurelius.titan.diskstorage.test.CassandraLocalhostHelper;
 import org.junit.AfterClass;
@@ -37,6 +38,6 @@ public void setUp() throws Exception {
 	@Override
 	public void open() {
 		graphdb = ch.openDatabase();
-		tx=graphdb.startTransaction();
+		tx=graphdb.startThreadTransaction(TransactionConfig.STANDARD);
 	}
 }

File: src/test/java/com/thinkaurelius/titan/graphdb/test/InMemoryGraphDBPerformance.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.test;
 
-import com.thinkaurelius.titan.graphdb.transaction.InMemoryGraphDB;
+import com.thinkaurelius.titan.graphdb.transaction.InMemoryTitanGraph;
 import org.junit.Test;
 
 
@@ -12,7 +12,7 @@ public InMemoryGraphDBPerformance() {
 	
 	@Override
 	public void open() {
-		tx=new InMemoryGraphDB();
+		tx=new InMemoryTitanGraph();
 	}
 
 	@Override

File: src/test/java/com/thinkaurelius/titan/graphdb/test/InMemoryGraphDBTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.thinkaurelius.titan.graphdb.test;
 
-import com.thinkaurelius.titan.graphdb.transaction.InMemoryGraphDB;
+import com.thinkaurelius.titan.graphdb.transaction.InMemoryTitanGraph;
 import org.junit.Test;
 
 
@@ -12,7 +12,7 @@ public InMemoryGraphDBTest() {
 	
 	@Override
 	public void open() {
-		tx=new InMemoryGraphDB();
+		tx=new InMemoryTitanGraph();
 	}
 
 	@Override

File: src/test/java/com/thinkaurelius/titan/util/test/BitMapTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.util.test;
 
 
-import com.thinkaurelius.titan.graphdb.util.BitMap;
+import com.thinkaurelius.titan.util.datastructures.BitMap;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -10,7 +10,7 @@
 import static org.junit.Assert.assertTrue;
 
 
-public class BitMapText {
+public class BitMapTest {
 
 	@Before
 	public void setUp() throws Exception {

File: src/test/java/com/thinkaurelius/titan/util/test/RandomRemovalList.java
Patch:
@@ -132,7 +132,7 @@ public T next() {
 
 	@Override
 	public void remove() {
-		throw new UnsupportedOperationException("Element has already been removed!");
+		throw new UnsupportedOperationException("TitanElement has already been removed!");
 	}
 
 	@Override

File: src/main/java/com/thinkaurelius/titan/diskstorage/locking/LockClaim.java
Patch:
@@ -60,15 +60,15 @@ public ByteBuffer getLockKey() {
 		}
 		
 		lockKey = ByteBuffer.allocate(key.remaining() + column.remaining() + 4);
-		lockKey.putInt(key.remaining()).put(key.duplicate()).put(column.duplicate()).reset();
+		lockKey.putInt(key.remaining()).put(key.duplicate()).put(column.duplicate()).rewind();
 		
 		return lockKey;
 	}
 	
 	public ByteBuffer getLockCol(long ts, byte[] rid) {
 		
 		lockCol = ByteBuffer.allocate(rid.length + 8);
-		lockCol.putLong(ts).put(rid).reset();
+		lockCol.putLong(ts).put(rid).rewind();
 		
 		return lockCol;
 	}

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyJEStorageManager.java
Patch:
@@ -116,7 +116,7 @@ public synchronized long[] getIDBlock(int partition, int blockSize) {
         ByteBuffer key = ByteBufferUtil.getIntByteBuffer(partition);
         BDBTxHandle tx = beginTransaction();
         ByteBuffer value = idDB.get(key,tx);
-        int counter = 0;
+        int counter = 1;
         if (value!=null) {
             assert value.remaining()==4;
             counter = value.getInt();

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/LocalIDManager.java
Patch:
@@ -41,6 +41,7 @@ public LocalIDManager(String file) {
 
     public synchronized long[] getIDBlock(int partition, int blockSize) {
         int current = idmap.get(partition);
+        if (current==0) current=1; //starting point
         Preconditions.checkArgument(Integer.MAX_VALUE-blockSize>current,"ID overflow for partition: " + partition);
         int next = current + blockSize;
         idmap.put(partition,next);

File: src/main/java/com/thinkaurelius/titan/graphdb/idmanagement/IDManager.java
Patch:
@@ -42,11 +42,9 @@ public enum IDType {
 		public abstract long offset();
 		public abstract long id();
 		public final long addPadding(long id) {
-			assert id>0;
 			return (id<<offset()) | id();
 		}
 		public final boolean is(long id) {
-			assert id>0;
 			return (id&((1l<<offset())-1)) == id();
 		}
 	}
@@ -146,10 +144,13 @@ private static long prefixWithOffset(long id, long prefixid, long prefixOffset,
 
 
 	private long addPartition(long id, long partitionID) {
+        assert id>0;
+        assert partitionID>=0;
         return prefixWithOffset(id,partitionID,partitionOffset,maxPartitionID);
 	}
 	
 	private long addGroup(long id, long groupID) {
+        assert id>0;
         return prefixWithOffset(id,groupID,groupOffset,maxGroupID);
 	}
 

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/StandardPersistGraphTx.java
Patch:
@@ -176,6 +176,7 @@ public synchronized void rollingCommit() {
 	
 	@Override
 	public synchronized void commit() {
+        Preconditions.checkArgument(isOpen());
         if (!getTxConfiguration().isReadOnly()) {
             List<InternalEdge> added=addedEdges;
             Set<InternalEdge> deleted=deletedEdges;
@@ -196,6 +197,7 @@ public synchronized void commit() {
 
 	@Override
 	public synchronized void abort() {
+        Preconditions.checkArgument(isOpen());
 		clear();
 		txHandle.abort();
 		super.abort();

File: src/main/java/com/thinkaurelius/titan/core/EdgeQuery.java
Patch:
@@ -32,7 +32,7 @@ public interface EdgeQuery {
 	 * @param type Edge type to query for
 	 * @return This edge query
 	 */
-	public EdgeQuery withEdgeType(EdgeType type);
+	public EdgeQuery withEdgeType(EdgeType... type);
 
     /**
      * Defines this edge query to query only for edges of the specified type.
@@ -41,7 +41,7 @@ public interface EdgeQuery {
      * @param type Edge type to query for
      * @return This edge query
      */
-    public EdgeQuery withEdgeType(String type);
+    public EdgeQuery withEdgeType(String... type);
 
 	/**
 	 * Defines this edge query to query only for edges which type belongs to the specified group.
@@ -201,7 +201,7 @@ public interface EdgeQuery {
      * matching the conditions defined in this query.
      *
      * No guarantee is made as to the order in which the nodes are listed. However, in some cases the retrieved list of node ids will be
-     * ordered (use {@link NodeList#isSorted()} to check whether the list is sorted).
+     * ordered (use {@link NodeList#sort()} to check whether the list is sorted).
      *
      * The query engine will determine the most efficient way to retrieve the nodes that match this query. For instance,
      * it might only retrieve the node ids and instantiate the node objects only as needed.

File: src/main/java/com/thinkaurelius/titan/graphdb/database/StandardGraphDB.java
Patch:
@@ -27,7 +27,7 @@
 import com.thinkaurelius.titan.graphdb.edgequery.EdgeQueryUtil;
 import com.thinkaurelius.titan.graphdb.edgequery.InternalEdgeQuery;
 import com.thinkaurelius.titan.graphdb.edgequery.Interval;
-import com.thinkaurelius.titan.graphdb.edgequery.StandardEdgeQuery;
+import com.thinkaurelius.titan.graphdb.edgequery.AtomicEdgeQuery;
 import com.thinkaurelius.titan.graphdb.edges.EdgeDirection;
 import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
 import com.thinkaurelius.titan.graphdb.edges.factory.EdgeLoader;
@@ -732,7 +732,7 @@ private Entry getEntry(GraphTx tx,InternalEdge edge, InternalNode perspective, M
 			InternalEdge[] keys = new InternalEdge[ets.keyLength()], 
 						   values = new InternalEdge[ets.valueLength()];
 			List<InternalEdge> rest = new ArrayList<InternalEdge>();
-			ets.sort(edge.getEdges(StandardEdgeQuery.queryAll(edge), false),keys,values,rest);
+			ets.sort(edge.getEdges(AtomicEdgeQuery.queryAll(edge), false),keys,values,rest);
 			
 			DataOutput out = serializer.getDataOutput(defaultOutputCapacity, true);
             IDHandler.writeEdgeType(out,etid,dirID,idManager);

File: src/main/java/com/thinkaurelius/titan/graphdb/edgequery/EdgeQueryUtil.java
Patch:
@@ -1,6 +1,5 @@
 package com.thinkaurelius.titan.graphdb.edgequery;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterators;
 import com.thinkaurelius.titan.core.Property;
 import com.thinkaurelius.titan.core.PropertyType;
@@ -15,7 +14,7 @@ public static final Property queryHiddenFunctionalProperty(InternalNode node, Pr
 		assert propType.isHidden() : "Expected hidden property type";
 		assert propType.isFunctional() : "Expected functional property  type";
 		return Iterators.getOnlyElement(
-				new StandardEdgeQuery(node).
+				new AtomicEdgeQuery(node).
 					includeHidden().
 					withEdgeType(propType).
 					getPropertyIterator(),null);

File: src/main/java/com/thinkaurelius/titan/graphdb/edges/factory/EdgeFactoryUtil.java
Patch:
@@ -3,7 +3,7 @@
 import com.thinkaurelius.titan.core.Direction;
 import com.thinkaurelius.titan.core.EdgeType;
 import com.thinkaurelius.titan.exceptions.InvalidEdgeException;
-import com.thinkaurelius.titan.graphdb.edgequery.StandardEdgeQuery;
+import com.thinkaurelius.titan.graphdb.edgequery.AtomicEdgeQuery;
 import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
 import com.thinkaurelius.titan.graphdb.transaction.GraphTx;
 import com.thinkaurelius.titan.graphdb.vertices.InternalNode;
@@ -49,7 +49,7 @@ public static final void connectEdge(InternalEdge edge, boolean isNew, GraphTx g
 
 	
 	public static final boolean hasEdgeOfType(InternalNode start, EdgeType type, Direction dir) {
-		StandardEdgeQuery q = new StandardEdgeQuery(start);
+		AtomicEdgeQuery q = new AtomicEdgeQuery(start);
 		q.includeHidden().withEdgeType(type).inDirection(dir);
 		if (start.getEdges(q, true).iterator().hasNext()) {
 			return true;

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractGraphTx.java
Patch:
@@ -11,7 +11,7 @@
 import com.thinkaurelius.titan.exceptions.InvalidNodeException;
 import com.thinkaurelius.titan.graphdb.database.GraphDB;
 import com.thinkaurelius.titan.graphdb.edgequery.InternalEdgeQuery;
-import com.thinkaurelius.titan.graphdb.edgequery.StandardEdgeQuery;
+import com.thinkaurelius.titan.graphdb.edgequery.AtomicEdgeQuery;
 import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
 import com.thinkaurelius.titan.graphdb.edges.factory.EdgeFactory;
 import com.thinkaurelius.titan.graphdb.edgetypes.InternalEdgeType;
@@ -291,12 +291,12 @@ public void loadedEdge(InternalEdge edge) {
 	
 	@Override
 	public InternalEdgeQuery makeEdgeQuery(InternalNode n) {
-		return new StandardEdgeQuery(n);
+		return new AtomicEdgeQuery(n);
 	}
 
 	@Override
 	public EdgeQuery makeEdgeQuery(long nodeid) {
-		return new StandardEdgeQuery((InternalNode)getNode(nodeid));
+		return new AtomicEdgeQuery((InternalNode)getNode(nodeid));
 	}
 
 	@Override

File: src/test/java/com/thinkaurelius/titan/graphdb/loading/test/EdgeLoadingTest.java
Patch:
@@ -1,7 +1,7 @@
 package com.thinkaurelius.titan.graphdb.loading.test;
 
 import com.thinkaurelius.titan.core.Direction;
-import com.thinkaurelius.titan.graphdb.edgequery.StandardEdgeQuery;
+import com.thinkaurelius.titan.graphdb.edgequery.AtomicEdgeQuery;
 import com.thinkaurelius.titan.graphdb.edgetypes.system.SystemRelationshipType;
 import com.thinkaurelius.titan.graphdb.loadingstatus.DefaultLoadingStatus;
 import com.thinkaurelius.titan.graphdb.loadingstatus.LoadingStatus;
@@ -16,7 +16,7 @@ public class EdgeLoadingTest {
 	public void edgeLoadingTest() {
 		LoadingStatus status1 = DefaultLoadingStatus.AllLoaded;
 		LoadingStatus status2 = DefaultLoadingStatus.NothingLoaded;
-		StandardEdgeQuery q = new StandardEdgeQuery(null,1);
+		AtomicEdgeQuery q = new AtomicEdgeQuery(null,1);
 		assertTrue(status1.hasLoadedEdges(q));
 		assertFalse(status2.hasLoadedEdges(q));
 		assertTrue(status1==status1.loadedEdges(q));

File: src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -107,6 +107,7 @@ public final static ByteBuffer getEdgeTypeGroup(long groupid, int dirID, IDManag
         else if (groupbits<=14) len =2;
         ByteBuffer result = ByteBuffer.allocate(len);
         writeEdgeTypeGroup(result, groupid,dirID,idManager);
+        result.flip();
         return result;
     }
     

File: src/main/java/com/thinkaurelius/titan/graphdb/edgetypes/nodes/PersistNodePropertyType.java
Patch:
@@ -24,6 +24,7 @@ public PropertyTypeDefinition getDefinition() {
 		if (definition==null) {
 			definition = EdgeQueryUtil.queryHiddenFunctionalProperty(this, SystemPropertyType.PropertyTypeDefinition)
 					.getAttribute(PropertyTypeDefinition.class);
+            assert definition!=null;
 		}
 		return definition;
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/vertices/DualNode.java
Patch:
@@ -13,6 +13,8 @@
 import com.thinkaurelius.titan.graphdb.edges.InternalEdge;
 import com.thinkaurelius.titan.graphdb.transaction.GraphTx;
 
+import java.util.HashMap;
+
 public class DualNode extends UndirectedNode {
 
 	private AdjacencyList inEdges;
@@ -24,8 +26,6 @@ public DualNode(GraphTx g, AdjacencyListFactory adjList) {
 		outEdges = adjList.emptyList();
 	}
 	
-	
-	
 	@Override
 	public boolean addEdge(InternalEdge e, boolean isNew) {
         assert isAvailable();

File: src/test/java/com/thinkaurelius/titan/blueprints/TitanGraphTest.java
Patch:
@@ -34,10 +34,11 @@ public TitanGraphTest() {
         this.allowFloatProperty = true;
         this.allowIntegerProperty = true;
         this.allowPrimitiveArrayProperty = true;
-        this.allowListProperty = true;
         this.allowLongProperty = true;
         this.allowMapProperty = true;
         this.allowStringProperty = true;
+        this.allowUniformListProperty = true;
+        this.allowMixedListProperty = true;
         
 
     }
@@ -56,7 +57,7 @@ public void testEdgeTestSuite() throws Exception {
 
     public void testGraphTestSuite() throws Exception {
         this.stopWatch();
-        doTestSuite(new GraphTestSuite(this));
+        doTestSuite(new GraphTestSuite(this),ImmutableSet.of("testVertexQuery"));
         printTestPerformance("GraphTestSuite", this.stopWatch());
     }
 

File: src/main/java/com/thinkaurelius/titan/core/EdgeTypeGroup.java
Patch:
@@ -20,7 +20,7 @@
  */
 public abstract class EdgeTypeGroup {
 	
-    private static final int MAX_GROUP_ID = (2<<6)-1;
+    private static final int MAX_GROUP_ID = (2<<6)-2;
     
 	/**
 	 * The default edge type group when no group is specified during edge type construction.

File: src/main/java/com/thinkaurelius/titan/graphdb/database/idassigner/local/SimpleNodeIDAssigner.java
Patch:
@@ -81,7 +81,8 @@ public synchronized void close() {
 	}
 
     private final long getPartitionID() {
-        return randomSource.nextInt((int)maxPartitionID)+1;
+        if (maxPartitionID==0) return 0;
+        else return randomSource.nextInt((int)maxPartitionID)+1;
     }
 
 	private long nextEdgeID() {

File: src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -44,7 +44,7 @@ public final static int edgeTypeLength(long etid, IDManager idManager) {
         } else {
             result = 4;
         }
-        return result + VariableLong.length(idManager.removeGroupID(etid));
+        return result + VariableLong.positiveLength(idManager.removeGroupID(etid));
     }
 
     private final static void writeEdgeTypeGroup(ByteBuffer out, long group, int dirID, IDManager idManager) {

File: src/main/java/com/thinkaurelius/titan/graphdb/idmanagement/IDManager.java
Patch:
@@ -137,6 +137,7 @@ private static long prefixWithOffset(long id, long prefixid, long prefixOffset,
         assert maxPrefixID>=0 && prefixOffset<64;
         if (id<0) throw new IllegalArgumentException("ID cannot be negative: " + id);
         if (prefixid<0) throw new IllegalArgumentException("Prefix ID cannot be negative: " + prefixid);
+        if (prefixid==0) return id;
         if (prefixid>maxPrefixID)
             throw new IllegalArgumentException("Prefix ID exceeds limit of: " + maxPrefixID);
         assert id<(1l<<prefixOffset) : "ID is too large for prefix offset: " + id + " ( " + prefixOffset + " )";

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyKeyValueStore.java
Patch:
@@ -95,7 +95,7 @@ public boolean isLocalKey(ByteBuffer key) {
 	@Override
 	public void acquireLock(ByteBuffer key, ByteBuffer expectedValue, TransactionHandle txh) {
 		if (getTransaction(txh)==null) {
-            log.warn("Enable transaction for locking in BerkeleyDB!");
+            throw new GraphStorageException("Enable transaction for locking in BerkeleyDB!");
 		} //else we need no locking
 	}
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/ReadOnlyKeyValueStore.java
Patch:
@@ -22,7 +22,7 @@ public void close() throws GraphStorageException {
 	}
 
 	@Override
-	public void acquireLock(ByteBuffer key, ByteBuffer column,
+	public void acquireLock(ByteBuffer key, ByteBuffer column, ByteBuffer expectedValue,
 			TransactionHandle txh) {
 		throw new UnsupportedOperationException("Cannot lock on a read-only store!");
 	}

File: src/main/java/com/thinkaurelius/titan/graphdb/edgequery/InternalEdgeQuery.java
Patch:
@@ -40,9 +40,9 @@ public interface InternalEdgeQuery extends EdgeQuery {
 
     boolean queryUnmodifiable();
     
-    boolean hasPropertyConstraints();
+    boolean hasConstraints();
     
-    Map<PropertyType,Interval<?>> getPropertyConstraints();
+    Map<String,Object> getConstraints();
 
     long getLimit();
 	

File: src/main/java/com/thinkaurelius/titan/graphdb/idmanagement/IDManager.java
Patch:
@@ -295,8 +295,9 @@ public long addGroupID(long edgetypeid, long groupid) {
 //		return new long[]{sw,sw+1};
 //	}
 
-	
-	
+	public long getGroupBits() {
+        return groupBits;
+    }
 	
 	public long getMaxGroupID() {
 		return maxGroupID;

File: src/main/java/com/thinkaurelius/titan/graphdb/loadingstatus/BasicLoadingStatus.java
Patch:
@@ -3,6 +3,7 @@
 import cern.colt.map.AbstractIntIntMap;
 import cern.colt.map.OpenIntIntHashMap;
 import com.thinkaurelius.titan.core.EdgeType;
+import com.thinkaurelius.titan.graphdb.edgequery.EdgeQueryUtil;
 import com.thinkaurelius.titan.graphdb.edgequery.InternalEdgeQuery;
 
 import java.util.HashMap;
@@ -52,7 +53,7 @@ public boolean hasLoadedEdges(InternalEdgeQuery query) {
 	
 	@Override
 	public LoadingStatus loadedEdges(InternalEdgeQuery query) {
-		if (query.hasEdgeTypeCondition()) {
+		if (query.hasEdgeTypeCondition() && !EdgeQueryUtil.hasFirstKeyConstraint(query)) {
 			EdgeType type = query.getEdgeTypeCondition();
 			if (loadedTypes==null) loadedTypes = new HashMap<EdgeType,Byte>();
 			byte code = 0;

File: src/test/java/com/thinkaurelius/titan/TestBed.java
Patch:
@@ -11,7 +11,8 @@ public class TestBed {
 	 * @throws java.io.IOException
 	 */
 	public static void main(String[] args) throws IOException {
-		DbCacheSize.main(args);
+		byte b = (byte)(15 | (1<<7));
+        System.out.println(b);
 	}
 
 	public static String toBinary(int b) {

File: src/main/java/com/thinkaurelius/titan/diskstorage/berkeleydb/je/BerkeleyKeyValueStore.java
Patch:
@@ -93,9 +93,9 @@ public boolean isLocalKey(ByteBuffer key) {
 	}
 	
 	@Override
-	public void acquireLock(ByteBuffer key, TransactionHandle txh) {
+	public void acquireLock(ByteBuffer key, ByteBuffer expectedValue, TransactionHandle txh) {
 		if (getTransaction(txh)==null) {
-			throw new GraphStorageException("Enable transaction for locking in BerkeleyDB!");
+            log.warn("Enable transaction for locking in BerkeleyDB!");
 		} //else we need no locking
 	}
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraThriftOrderedKeyColumnValueStore.java
Patch:
@@ -327,7 +327,7 @@ public boolean containsKeyColumn(ByteBuffer key, ByteBuffer column,
 	}
 
 	@Override
-	public void acquireLock(ByteBuffer key, ByteBuffer column,
+	public void acquireLock(ByteBuffer key, ByteBuffer column, ByteBuffer expectedValue,
 			TransactionHandle txh) {
 		// TODO Auto-generated method stub
 		

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/KeyValueStore.java
Patch:
@@ -23,7 +23,7 @@ public interface KeyValueStore {
 	public boolean isLocalKey(ByteBuffer key);
 	
 
-	public void acquireLock(ByteBuffer key, TransactionHandle txh);
+	public void acquireLock(ByteBuffer key, ByteBuffer expectedValue, TransactionHandle txh);
 
 	/**
 	 * Closes the store.

File: src/main/java/com/thinkaurelius/titan/diskstorage/util/KeyValueStoreAdapter.java
Patch:
@@ -152,9 +152,9 @@ public boolean isLocalKey(ByteBuffer key) {
 	}
 	
 	@Override
-	public void acquireLock(ByteBuffer key, ByteBuffer column,
+	public void acquireLock(ByteBuffer key, ByteBuffer column, ByteBuffer expectedValue,
 			TransactionHandle txh) {
-		store.acquireLock(concatenate(key,column), txh);
+		store.acquireLock(concatenate(key,column), expectedValue, txh);
 	}
 
 

File: src/main/java/com/thinkaurelius/titan/diskstorage/writeaggregation/MultiWriteKeyColumnValueStore.java
Patch:
@@ -1,13 +1,14 @@
 package com.thinkaurelius.titan.diskstorage.writeaggregation;
 
 import com.thinkaurelius.titan.diskstorage.Entry;
+import com.thinkaurelius.titan.diskstorage.LockKeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;
 
 import java.nio.ByteBuffer;
 import java.util.List;
 import java.util.Map;
 
-public interface MultiWriteKeyColumnValueStore {
+public interface MultiWriteKeyColumnValueStore extends LockKeyColumnValueStore {
 
 	/**
 	 * Apply a batch of mutations

File: src/main/java/com/thinkaurelius/titan/graphdb/database/idhandling/IDHandler.java
Patch:
@@ -10,12 +10,12 @@
 
 public class IDHandler {
     
-    public ByteBuffer getKey(long id) {
+    public final static ByteBuffer getKey(long id) {
         assert id>=0;
         return ByteBufferUtil.getLongByteBuffer(id<<1);
     }
     
-    public long getKeyID(ByteBuffer b) {
+    public final static long getKeyID(ByteBuffer b) {
         long value = b.getLong();
         return value>>>1;
     }

File: src/main/java/com/thinkaurelius/titan/graphdb/database/GraphDB.java
Patch:
@@ -24,6 +24,8 @@ public interface GraphDB extends GraphDatabase {
 
     public void assignID(InternalNode node);
 
+    public boolean isReferenceNodeID(long nodeID);
+
 	void loadEdges(InternalEdgeQuery query, GraphTx tx);
 	
 	public AbstractLongList getRawNeighborhood(InternalEdgeQuery query, GraphTx tx);

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/AbstractGraphTx.java
Patch:
@@ -144,7 +144,7 @@ private InternalNode getExisting(long id) {
 
                 if (idspec.isEdgeTypeID(id)) {
                     node = etManager.getEdgeType(id, this);
-                } else if (idspec.isReferenceNodeID(id)) {
+                } else if (graphdb.isReferenceNodeID(id)) {
                     return new StandardReferenceNode(this, id);
                 } else if (idspec.isNodeID(id)) {
                     node = nodeFactory.createExisting(this,id);

File: src/main/java/com/thinkaurelius/titan/graphdb/transaction/InMemoryGraphDB.java
Patch:
@@ -38,7 +38,7 @@ public boolean isDeletedEdge(InternalEdge e) {
 	}
 	
 
-	public boolean isReferenceNode(long nodeID) {
+	public boolean isReferenceNodeID(long nodeID) {
 		return false;
 	}
 		

File: src/main/java/com/thinkaurelius/titan/diskstorage/cassandra/CassandraThriftOrderedKeyColumnValueStore.java
Patch:
@@ -6,6 +6,7 @@
 import com.thinkaurelius.titan.diskstorage.cassandra.thriftpool.CTConnection;
 import com.thinkaurelius.titan.diskstorage.cassandra.thriftpool.UncheckedGenericKeyedObjectPool;
 import com.thinkaurelius.titan.diskstorage.util.ByteBufferUtil;
+import com.thinkaurelius.titan.diskstorage.writeaggregation.MultiWriteKeyColumnValueStore;
 import com.thinkaurelius.titan.exceptions.GraphStorageException;
 import org.apache.cassandra.thrift.*;
 import org.apache.thrift.TException;

File: src/main/java/com/thinkaurelius/titan/diskstorage/writeaggregation/BatchKeyColumnValueStoreMutator.java
Patch:
@@ -1,7 +1,6 @@
 package com.thinkaurelius.titan.diskstorage.writeaggregation;
 
 import com.thinkaurelius.titan.diskstorage.Entry;
-import com.thinkaurelius.titan.diskstorage.MultiWriteKeyColumnValueStore;
 import com.thinkaurelius.titan.diskstorage.TransactionHandle;
 
 import java.nio.ByteBuffer;

File: src/main/java/com/thinkaurelius/titan/graphdb/database/StandardGraphDB.java
Patch:
@@ -13,6 +13,7 @@
 import com.thinkaurelius.titan.diskstorage.writeaggregation.BatchKeyColumnValueStoreMutator;
 import com.thinkaurelius.titan.diskstorage.writeaggregation.DirectKeyColumnValueStoreMutator;
 import com.thinkaurelius.titan.diskstorage.writeaggregation.KeyColumnValueStoreMutator;
+import com.thinkaurelius.titan.diskstorage.writeaggregation.MultiWriteKeyColumnValueStore;
 import com.thinkaurelius.titan.exceptions.GraphStorageException;
 import com.thinkaurelius.titan.graphdb.database.idassigner.NodeIDAssigner;
 import com.thinkaurelius.titan.graphdb.database.serialize.DataOutput;
@@ -426,7 +427,7 @@ public boolean save(Collection<InternalEdge> addedEdges,
 		TransactionStatistics stats = new TransactionStatistics();
 		
 		KeyColumnValueStoreMutator edgeMutator = getEdgeStoreMutator(edgeStore,txh);
-		KeyColumnValueStoreMutator propMutator = getEdgeStoreMutator(propertyIndex,txh);
+		KeyColumnValueStoreMutator propMutator = getEdgeStoreMutator(propertyIndex, txh);
 		
 		//1. Delete edges
 		if (deletedEdges!=null && !deletedEdges.isEmpty()) {

